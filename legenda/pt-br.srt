1
00:00:00,160 --> 00:00:03,040
este curso completo c plus plus irá

2
00:00:03,040 --> 00:00:05,279
tomar você de ser um iniciante absoluto

3
00:00:05,279 --> 00:00:08,160
usar os recursos avançados de c plus plus

4
00:00:08,160 --> 00:00:10,480
danielle gaguaya ensina este curso que ele

5
00:00:10,480 --> 00:00:12,719
é um desenvolvedor de software experiente e

6
00:00:12,719 --> 00:00:15,440
criou muitos cursos populares

7
00:00:15,440 --> 00:00:18,400
Olá pessoal e bem-vindo a este moderno c

8
00:00:18,400 --> 00:00:20,880
mais mais 20 cursos, este é um curso

9
00:00:20,880 --> 00:00:22,560
que vai te tirar do

10
00:00:22,560 --> 00:00:24,400
Início absoluto onde você sabe

11
00:00:24,400 --> 00:00:26,080
Nada sobre c plus plus e você está

12
00:00:26,080 --> 00:00:28,800
indo para ir todo o caminho para um ponto onde

13
00:00:28,800 --> 00:00:30,880
você pode usar alguns recursos avançados em

14
00:00:30,880 --> 00:00:33,200
c plus linguagem de programação

15
00:00:33,200 --> 00:00:34,600
Isso inclui coisas como

16
00:00:34,600 --> 00:00:36,559
programação orientada a objetos com

17
00:00:36,559 --> 00:00:38,960
herança e polimorfismo com c

18
00:00:38,960 --> 00:00:41,200
além de linguagem de programação agora eu sou

19
00:00:41,200 --> 00:00:42,960
Não vou passar muito tempo

20
00:00:42,960 --> 00:00:45,360
convencê-lo sobre por que você deve usar c

21
00:00:45,360 --> 00:00:47,840
mais plus mas c plus plus é muito

22
00:00:47,840 --> 00:00:49,920
Linguagem de programação poderosa que você pode

23
00:00:49,920 --> 00:00:52,960
Use para fazer todos os tipos de coisas loucas que você

24
00:00:52,960 --> 00:00:55,039
pode usá-lo para fazer sistemas de programação você

25
00:00:55,039 --> 00:00:57,360
pode construir jogos com ele e é usado

26
00:00:57,360 --> 00:01:00,079
em uma ampla gama de áreas para que você possa fazer

27
00:01:00,079 --> 00:01:03,039
muito com c plus plus agora quem é este

28
00:01:03,039 --> 00:01:05,439
O curso para este curso é construído para

29
00:01:05,439 --> 00:01:07,680
completar iniciantes se você já tiver

30
00:01:07,680 --> 00:01:09,600
alguma experiência com c plus mais você

31
00:01:09,600 --> 00:01:11,840
Ainda vai encontrar algumas coisas boas que você pode

32
00:01:11,840 --> 00:01:14,479
Aprenda com o curso, mas eu vou

33
00:01:14,479 --> 00:01:16,720
ir desde o começo absoluto mostrando

34
00:01:16,720 --> 00:01:19,119
Você cada pequena coisa mostrando o

35
00:01:19,119 --> 00:01:21,439
ferramentas que mostram os compiladores e os

36
00:01:21,439 --> 00:01:23,439
Editor que vamos usar aqui, então

37
00:01:23,439 --> 00:01:25,280
Vamos passar muito tempo

38
00:01:25,280 --> 00:01:26,560
certificando-se de que você entende o

39
00:01:26,560 --> 00:01:28,720
Fundamentos no momento em que você é feito

40
00:01:28,720 --> 00:01:30,640
Com este curso você vai entender o

41
00:01:30,640 --> 00:01:33,840
básicos sobre c plus vamos

42
00:01:33,840 --> 00:01:36,159
Passe muito tempo explorando o

43
00:01:36,159 --> 00:01:38,479
processo de programação do lado c plus

44
00:01:38,479 --> 00:01:40,079
Mais para que você esteja escrevendo

45
00:01:40,079 --> 00:01:42,720
programas que são executados de cima para baixo e

46
00:01:42,720 --> 00:01:44,240
Vamos passar muito tempo em

47
00:01:44,240 --> 00:01:46,320
o editor que escreve o código, certificando-se de que você

48
00:01:46,320 --> 00:01:48,399
realmente entender o que está acontecendo aqui

49
00:01:48,399 --> 00:01:49,840
No final, vamos aprender

50
00:01:49,840 --> 00:01:51,920
sobre a programação orientada a objetos e

51
00:01:51,920 --> 00:01:53,520
Vamos tocar nas aulas

52
00:01:53,520 --> 00:01:55,920
herança e polimorfismo e estes

53
00:01:55,920 --> 00:01:57,680
são as ferramentas que você vai usar

54
00:01:57,680 --> 00:02:00,000
muito em sua carreira como c plus plus

55
00:02:00,000 --> 00:02:02,240
Desenvolver outra grande característica disso

56
00:02:02,240 --> 00:02:04,320
O curso é que passamos muito tempo

57
00:02:04,320 --> 00:02:06,640
Certifique-se de entender as ferramentas assim

58
00:02:06,640 --> 00:02:08,560
se você não sabe o que é um compilador se

59
00:02:08,560 --> 00:02:10,879
Você não sabe o que um ide é que nós somos

60
00:02:10,879 --> 00:02:12,560
Vou ter certeza de que você entende estes

61
00:02:12,560 --> 00:02:14,319
coisas e nós vamos gastar um monte de

62
00:02:14,319 --> 00:02:16,560
tempo usando essas coisas e no momento

63
00:02:16,560 --> 00:02:17,760
Você está feito com o curso que você está indo

64
00:02:17,760 --> 00:02:20,480
para ser muito confortável usando as ferramentas

65
00:02:20,480 --> 00:02:22,319
o editor de escolha para o curso é

66
00:02:22,319 --> 00:02:25,040
vai ser código de estúdio visual, então isso é

67
00:02:25,040 --> 00:02:26,720
um editor que nos permitirá

68
00:02:26,720 --> 00:02:29,200
digite o código e nos dê algumas coisas

69
00:02:29,200 --> 00:02:31,599
como um destaque de sintaxe, mas nós somos

70
00:02:31,599 --> 00:02:34,239
Vou conectar nosso editor a um

71
00:02:34,239 --> 00:02:36,480
compilador de fundo que vai

72
00:02:36,480 --> 00:02:39,200
Certifique-se de que nosso código é transformado

73
00:02:39,200 --> 00:02:41,760
para executar em nosso computador, mas não se preocupe

74
00:02:41,760 --> 00:02:43,680
sobre toda essa loucura agora que estamos

75
00:02:43,680 --> 00:02:46,400
indo em detalhes sobre essas coisas

76
00:02:46,400 --> 00:02:48,800
por enquanto eu só quero que você tenha um pássaro

77
00:02:48,800 --> 00:02:51,440
visão do olho sobre o que você pode esperar do

78
00:02:51,440 --> 00:02:54,000
Curso aqui agora espero que você saiba o que fazer

79
00:02:54,000 --> 00:02:57,120
esperar do curso, mas eu também espero

80
00:02:57,120 --> 00:03:00,159
Você está pronto para fazer o curso e

81
00:03:00,159 --> 00:03:02,800
Os requisitos não são tão ruins

82
00:03:02,800 --> 00:03:04,560
O único requisito é que você tenha

83
00:03:04,560 --> 00:03:06,560
tempo reservado para realmente praticar o que

84
00:03:06,560 --> 00:03:08,400
Você aprende com o curso aqui e você

85
00:03:08,400 --> 00:03:10,319
precisa ter um forte impulso e

86
00:03:10,319 --> 00:03:12,239
vontade de aprender agora se você quiser

87
00:03:12,239 --> 00:03:14,560
Acompanhe eu vou compartilhar um link

88
00:03:14,560 --> 00:03:17,360
para o repositório github para o código i

89
00:03:17,360 --> 00:03:19,280
usar no curso para que você possa verificar isso

90
00:03:19,280 --> 00:03:21,920
fora e realmente seguir junto se você quiser

91
00:03:21,920 --> 00:03:24,000
Se você quiser algum apoio, temos um

92
00:03:24,000 --> 00:03:26,319
Servidor de discórdia dedicado para o nosso

93
00:03:26,319 --> 00:03:28,640
estudantes para que você possa participar e fazer parte de

94
00:03:28,640 --> 00:03:30,799
A comunidade se você tem uma pergunta

95
00:03:30,799 --> 00:03:32,640
Posso perguntar, mas outra coisa que eu gostaria

96
00:03:32,640 --> 00:03:35,040
Incentive você a fazer é também ajudar

97
00:03:35,040 --> 00:03:37,360
Outros, então se você ver alguém perguntando a

98
00:03:37,360 --> 00:03:39,360
Pergunta para tentar ajudá-los você está indo

99
00:03:39,360 --> 00:03:41,680
para aprender muito assim, tudo bem agora que

100
00:03:41,680 --> 00:03:43,360
Você sabe um pouco sobre o curso vamos

101
00:03:43,360 --> 00:03:45,760
Fale sobre mim aqui meu nome é daniel

102
00:03:45,760 --> 00:03:48,000
cacoya i am um engenheiro de software que eu tenho

103
00:03:48,000 --> 00:03:50,720
Escreve código desde 2011 ou

104
00:03:50,720 --> 00:03:51,760
alguma coisa

105
00:03:51,760 --> 00:03:53,920
e eu sou um profissional c plus plus

106
00:03:53,920 --> 00:03:56,560
Desenvolvedor i fazer um monte de trabalho freelance i

107
00:03:56,560 --> 00:03:58,640
trabalho para algumas empresas que faço todos os tipos

108
00:03:58,640 --> 00:04:00,959
de coisas loucas que eu também gosto de ensinar

109
00:04:00,959 --> 00:04:03,599
outros então eu tenho alguns cursos sobre udemy

110
00:04:03,599 --> 00:04:05,280
Se você está interessado em bonito você pode

111
00:04:05,280 --> 00:04:07,439
verificar essas coisas, eu também tenho um

112
00:04:07,439 --> 00:04:09,680
tendência c plus mais curso que você pode

113
00:04:09,680 --> 00:04:12,560
Confira, mas não sinta a necessidade de ir

114
00:04:12,560 --> 00:04:14,480
e verifique este curso ziplesque para fora

115
00:04:14,480 --> 00:04:17,280
porque muita coisa é coberta neste youtube

116
00:04:17,280 --> 00:04:19,759
curso aqui, então isso é realmente tudo sobre

117
00:04:19,759 --> 00:04:22,400
Eu estou bem agora que você tem uma ideia sobre

118
00:04:22,400 --> 00:04:24,160
O curso que vamos seguir em frente

119
00:04:24,160 --> 00:04:26,160
A próxima palestra e aprenda sobre a

120
00:04:26,160 --> 00:04:28,240
ferramentas que vamos usar durante todo o tempo

121
00:04:28,240 --> 00:04:30,240
O curso aqui vá em frente e termine

122
00:04:30,240 --> 00:04:32,479
aqui e me encontrar lá

123
00:04:32,479 --> 00:04:34,400
boas-vindas a este novo capítulo onde estamos

124
00:04:34,400 --> 00:04:37,199
Vou explorar o c plus plus

125
00:04:37,199 --> 00:04:39,840
ferramentas de desenvolvimento que você precisa começar

126
00:04:39,840 --> 00:04:41,919
escrevendo seu próprio c plus plus

127
00:04:41,919 --> 00:04:44,320
Aplicações e você realmente precisa de dois

128
00:04:44,320 --> 00:04:46,960
tipos de ferramentas que o primeiro vai

129
00:04:46,960 --> 00:04:49,600
ser um editor ou um ide através do qual

130
00:04:49,600 --> 00:04:51,759
Você vai escrever seu c plus

131
00:04:51,759 --> 00:04:53,919
além do código que vamos usar

132
00:04:53,919 --> 00:04:56,320
código de estúdio visual como editor neste

133
00:04:56,320 --> 00:04:58,560
claro porque é muito fácil

134
00:04:58,560 --> 00:05:01,199
instale é multiplataforma que está indo

135
00:05:01,199 --> 00:05:04,080
para correr bem em janelas mac e linux e

136
00:05:04,080 --> 00:05:07,039
suporta uma série de ferramentas que são

137
00:05:07,039 --> 00:05:08,960
tornar seu trabalho mais fácil como um

138
00:05:08,960 --> 00:05:11,600
excedente mais desenvolvedor, mas isso não é para

139
00:05:11,600 --> 00:05:14,000
Diga que você não pode usar seu ide favorito se

140
00:05:14,000 --> 00:05:16,160
Você pode, mas o código visual do estúdio está indo

141
00:05:16,160 --> 00:05:18,560
para ser nosso editor principal neste curso

142
00:05:18,560 --> 00:05:20,479
Eu recomendaria instalá-lo para ser

143
00:05:20,479 --> 00:05:22,400
capaz de acompanhar o que fazemos

144
00:05:22,400 --> 00:05:25,120
Aqui agora, depois de termos um ide ou um

145
00:05:25,120 --> 00:05:28,000
Editor no lugar vamos precisar de um compilador

146
00:05:28,000 --> 00:05:31,120
e o compilador é um pedaço de software

147
00:05:31,120 --> 00:05:33,120
que leva o código que escrevemos no

148
00:05:33,120 --> 00:05:37,039
Editor e compila isso em código que

149
00:05:37,039 --> 00:05:40,639
pode ser executado diretamente no hardware ou

150
00:05:40,639 --> 00:05:43,280
formato executável binário, então é isso que

151
00:05:43,280 --> 00:05:45,039
nós vamos estar fazendo aqui nós vamos

152
00:05:45,039 --> 00:05:48,000
digitar nosso código em um editor como

153
00:05:48,000 --> 00:05:50,000
Código de estúdio visual que vamos ser

154
00:05:50,000 --> 00:05:52,000
dar início a um processo para compilar o nosso

155
00:05:52,000 --> 00:05:54,000
programa e isso vai virar o nosso

156
00:05:54,000 --> 00:05:56,720
programa em um formato que pode executá-lo

157
00:05:56,720 --> 00:05:59,120
diretamente no hardware, por exemplo

158
00:05:59,120 --> 00:06:00,880
Se você está em uma máquina de janelas você está

159
00:06:00,880 --> 00:06:03,440
vai gerar um executável binário

160
00:06:03,440 --> 00:06:05,919
que pode correr diretamente nas janelas se você

161
00:06:05,919 --> 00:06:08,080
estamos em linux vamos gerar um binário

162
00:06:08,080 --> 00:06:10,720
que pode correr em linux e o mesmo

163
00:06:10,720 --> 00:06:13,680
Os conceitos podem realmente estender em mac ou qualquer

164
00:06:13,680 --> 00:06:15,600
outro tipo de sistema operacional que você pode

165
00:06:15,600 --> 00:06:18,160
estar trabalhando com o curso aqui, então nós

166
00:06:18,160 --> 00:06:20,319
Precisamos de duas ferramentas, precisamos de um ide ou um

167
00:06:20,319 --> 00:06:23,120
Editor e um compilador e as ferramentas que você

168
00:06:23,120 --> 00:06:26,080
A instalação dependerá do

169
00:06:26,080 --> 00:06:28,160
sistema operacional que você está usando para assistir

170
00:06:28,160 --> 00:06:30,479
O curso se você está nas janelas você está

171
00:06:30,479 --> 00:06:33,440
vamos instalar um conjunto de ferramentas que são

172
00:06:33,440 --> 00:06:36,319
específico para janelas se você estiver no linux

173
00:06:36,319 --> 00:06:38,080
você vai instalar um conjunto de ferramentas

174
00:06:38,080 --> 00:06:40,319
para linux se você está em um mac você está

175
00:06:40,319 --> 00:06:44,000
instalar um conjunto de ferramentas específicas

176
00:06:44,000 --> 00:06:46,319
ao sistema operacional da maçã para

177
00:06:46,319 --> 00:06:49,919
desktop agora em janelas em termos de ides

178
00:06:49,919 --> 00:06:52,479
ou ambiente de desenvolvimento integrado

179
00:06:52,479 --> 00:06:55,759
é possível usar uma série de ides para

180
00:06:55,759 --> 00:06:58,319
O exemplo você pode usar o código lite é um
Você 
181
00:06:58,319 --> 00:07:00,639
pode usar você pode usar o microsoft

182
00:07:00,639 --> 00:07:03,039
estúdio visual, mas neste curso estamos

183
00:07:03,039 --> 00:07:05,039
usará o código do estúdio visual

184
00:07:05,039 --> 00:07:08,080
porque é fácil de instalar, tem um

185
00:07:08,080 --> 00:07:10,400
conjunto de características que são realmente boas

186
00:07:10,400 --> 00:07:12,720
É popular, tem uma grande comunidade

187
00:07:12,720 --> 00:07:14,800
em torno dele eu acho que você vai ter um

188
00:07:14,800 --> 00:07:17,280
Grande momento como um iniciante para começar

189
00:07:17,280 --> 00:07:19,919
escrevendo seus c plus mais programas usando

190
00:07:19,919 --> 00:07:22,160
código de estúdio visual que não quer dizer

191
00:07:22,160 --> 00:07:24,400
que você não pode usar outro ide que você pode

192
00:07:24,400 --> 00:07:27,120
Se você quiser, mas eu vou estar usando

193
00:07:27,120 --> 00:07:29,440
código de estúdio visual neste curso aqui

194
00:07:29,440 --> 00:07:31,440
Agora, no linux, também vamos ser

195
00:07:31,440 --> 00:07:34,479
usando código de estúdio visual como nosso editor

196
00:07:34,479 --> 00:07:37,120
no curso, mas existem outros ides

197
00:07:37,120 --> 00:07:39,039
você pode usar, por exemplo, você pode usar bonito

198
00:07:39,039 --> 00:07:40,479
Criador, se quiser, você pode usar

199
00:07:40,479 --> 00:07:43,120
Codelight você pode usar uma hoste de outros

200
00:07:43,120 --> 00:07:45,919
ides em linux mas novamente estúdio visual

201
00:07:45,919 --> 00:07:47,520
O código vai ser a nossa coisa no

202
00:07:47,520 --> 00:07:49,440
curso aqui e eu recomendo

203
00:07:49,440 --> 00:07:52,319
instalando-o em sua caixa de linux se você

204
00:07:52,319 --> 00:07:54,479
estão assistindo este curso no linux

205
00:07:54,479 --> 00:07:57,280
máquina assim para osx, também vamos

206
00:07:57,280 --> 00:07:59,440
usar código de estúdio visual como nosso

207
00:07:59,440 --> 00:08:02,319
Editor como eu disse que são plataformas cruzadas

208
00:08:02,319 --> 00:08:04,319
ele corre onde, independentemente da

209
00:08:04,319 --> 00:08:06,240
sistema operacional que você pode estar usando para

210
00:08:06,240 --> 00:08:08,319
assistir o curso, mas se você quiser você pode

211
00:08:08,319 --> 00:08:09,840
Use a maçã

212
00:08:09,840 --> 00:08:12,639
olho que é xcode ou mesmo código lite todos

213
00:08:12,639 --> 00:08:14,639
Estes vão funcionar se você quiser, mas

214
00:08:14,639 --> 00:08:16,960
Mais uma vez eu recomendo ir com

215
00:08:16,960 --> 00:08:19,919
visual studio code.plus para começar assim

216
00:08:19,919 --> 00:08:22,240
que temos um terreno comum e você

217
00:08:22,240 --> 00:08:24,240
Não se confunda muito facilmente

218
00:08:24,240 --> 00:08:26,400
Especialmente se você é um iniciante agora

219
00:08:26,400 --> 00:08:28,639
depois que nós temos um ide rolling vamos

220
00:08:28,639 --> 00:08:30,400
Preciso de um compilador

221
00:08:30,400 --> 00:08:32,959
e como dizemos o compilador é uma ferramenta

222
00:08:32,959 --> 00:08:35,279
que vai transformar seu c plus

223
00:08:35,279 --> 00:08:38,240
além de código em um formato que pode ser executado

224
00:08:38,240 --> 00:08:40,800
diretamente no hardware para que o compilador

225
00:08:40,800 --> 00:08:42,479
Você usa novamente vai depender do

226
00:08:42,479 --> 00:08:44,240
sistema operacional onde você está assistindo

227
00:08:44,240 --> 00:08:46,480
O curso eu vou te mostrar a

228
00:08:46,480 --> 00:08:49,600
um monte de compiladores que você pode usar, mas gcc

229
00:08:49,600 --> 00:08:52,160
Será a nossa base comum assim

230
00:08:52,160 --> 00:08:54,399
Janelas que vou usar o que chamamos

231
00:08:54,399 --> 00:08:56,800
mingw não se preocupe se você não fizer o que for

232
00:08:56,800 --> 00:08:58,320
Eu vou te mostrar em um minuto

233
00:08:58,320 --> 00:09:01,040
quando o instalamos, mas este é um projeto

234
00:09:01,040 --> 00:09:03,920
que traz o compilador gcc na janela

235
00:09:03,920 --> 00:09:06,320
para que possamos usá-lo facilmente e eu sou

236
00:09:06,320 --> 00:09:08,399
vou mostrar-lhe como instalá-lo, mas

237
00:09:08,399 --> 00:09:09,839
Eu também vou mostrar-lhe como

238
00:09:09,839 --> 00:09:12,160
Instale o compilador do microsoft e

239
00:09:12,160 --> 00:09:15,360
O compilador clang llvm estes são todos

240
00:09:15,360 --> 00:09:17,600
disponível para você nas janelas e é

241
00:09:17,600 --> 00:09:20,160
É muito fácil instalá-los hoje em dia

242
00:09:20,160 --> 00:09:22,880
e eu vou usá-los todos se você estiver

243
00:09:22,880 --> 00:09:24,959
nas janelas eu recomendaria instalar

244
00:09:24,959 --> 00:09:27,279
todos eles para que você realmente tenha um

245
00:09:27,279 --> 00:09:30,240
chance de tentar o seu c plus mais código em

246
00:09:30,240 --> 00:09:31,839
os diferentes compiladores e isso é um

247
00:09:31,839 --> 00:09:34,320
muito bom a fazer se você testar o seu

248
00:09:34,320 --> 00:09:36,399
c plus código contra múltiplos

249
00:09:36,399 --> 00:09:38,959
compiladores que você estará aumentando o seu

250
00:09:38,959 --> 00:09:41,360
chances de seu código realmente ser

251
00:09:41,360 --> 00:09:43,680
portátil e trabalhar em vários compiladores

252
00:09:43,680 --> 00:09:46,399
e sistemas operacionais e que não podem ser

253
00:09:46,399 --> 00:09:48,160
Uma coisa ruim, então eu recomendaria

254
00:09:48,160 --> 00:09:50,240
instalando todos esses compiladores se você

255
00:09:50,240 --> 00:09:52,320
Estão nas janelas que também vou mostrar

256
00:09:52,320 --> 00:09:54,320
você como instalar dois compiladores em

257
00:09:54,320 --> 00:09:56,320
linux eu vou te mostrar gcc nós somos

258
00:09:56,320 --> 00:09:58,880
vai instalar o novo recurso brilhante

259
00:09:58,880 --> 00:10:01,760
em gcc nós vamos instalar o clang lvm

260
00:10:01,760 --> 00:10:03,600
em linux e nós seremos capazes de usar todos

261
00:10:03,600 --> 00:10:05,760
esses compiladores novamente se você estiver em

262
00:10:05,760 --> 00:10:07,920
linux i recomendo instalar todos

263
00:10:07,920 --> 00:10:10,000
esses compiladores para que você tenha um

264
00:10:10,000 --> 00:10:12,720
chance de tentar seu código contra vários

265
00:10:12,720 --> 00:10:14,480
compiladores e isso vai fazer seu

266
00:10:14,480 --> 00:10:18,000
código muito portátil e mais fácil de usar

267
00:10:18,000 --> 00:10:21,120
vários compiladores e plataformas no

268
00:10:21,120 --> 00:10:22,959
Mac vou te mostrar como

269
00:10:22,959 --> 00:10:25,200
instalar gcc

270
00:10:25,200 --> 00:10:27,120
E eu vou te mostrar como

271
00:10:27,120 --> 00:10:29,760
instalar clangle lvm mas se você quiser você

272
00:10:29,760 --> 00:10:32,240
também pode instalar o xcode e o compilador

273
00:10:32,240 --> 00:10:34,160
que vem com isso para c plus mas

274
00:10:34,160 --> 00:10:37,040
desenvolvimento de tudo isso são opções para você

275
00:10:37,040 --> 00:10:38,880
mas, novamente, neste curso, somos principalmente

276
00:10:38,880 --> 00:10:41,120
Vou usar o compilador gcc para que eu

277
00:10:41,120 --> 00:10:43,360
recomendaria obter isso

278
00:10:43,360 --> 00:10:45,120
se você não quiser instalar outro

279
00:10:45,120 --> 00:10:47,519
compiladores se você só tem que instalar

280
00:10:47,519 --> 00:10:50,399
um compilador por favor instale o gcc que é

281
00:10:50,399 --> 00:10:52,399
Será o nosso principal compilador no

282
00:10:52,399 --> 00:10:54,480
curso aqui está bem, então essas são as ferramentas

283
00:10:54,480 --> 00:10:56,240
Precisamos que vamos nos dirigir no

284
00:10:56,240 --> 00:10:58,880
próxima palestra e mostrar como instalar

285
00:10:58,880 --> 00:11:01,600
o editor de código visual do estúdio no Windows

286
00:11:01,600 --> 00:11:03,600
E realmente começar com isso

287
00:11:03,600 --> 00:11:05,680
Vá em frente e termine aqui e me encontre

288
00:11:05,680 --> 00:11:07,440
Na próxima palestra este vídeo eu sou

289
00:11:07,440 --> 00:11:09,680
Vou mostrar-lhe como instalar um c

290
00:11:09,680 --> 00:11:12,079
Plus mais compilador em suas janelas

291
00:11:12,079 --> 00:11:14,959
Sistema operacional, então nós vamos ser

292
00:11:14,959 --> 00:11:16,959
olhando para três tipos de compiladores

293
00:11:16,959 --> 00:11:18,800
nós vamos olhar para o mingw

294
00:11:18,800 --> 00:11:21,519
compilador que nos dá acesso a um gcc

295
00:11:21,519 --> 00:11:23,760
como o compilador nas janelas, vamos

296
00:11:23,760 --> 00:11:26,000
olhar para o clã llvm que é outro

297
00:11:26,000 --> 00:11:27,680
compilador, vamos olhar para o

298
00:11:27,680 --> 00:11:30,160
Compilador da microsoft

299
00:11:30,160 --> 00:11:32,560
agora antes de falarmos sobre qualquer compilador i

300
00:11:32,560 --> 00:11:34,800
Gostaria que você viesse ao Google ou ao seu

301
00:11:34,800 --> 00:11:37,200
Motor de busca favorito e dizer

302
00:11:37,200 --> 00:11:39,760
c plus suporte do compilador OK assim

303
00:11:39,760 --> 00:11:41,279
nós vamos escolher esse garotinho

304
00:11:41,279 --> 00:11:43,839
Aqui e isso vai realmente nos dar

305
00:11:43,839 --> 00:11:46,079
uma visão do iceberg

306
00:11:46,079 --> 00:11:48,959
em que o recurso é suportado pelo qual c

307
00:11:48,959 --> 00:11:51,839
plus compilador, por exemplo, se nós somos

308
00:11:51,839 --> 00:11:54,320
interessado em c mais mais 20 que é

309
00:11:54,320 --> 00:11:56,079
o padrão de treliça que temos em

310
00:11:56,079 --> 00:11:58,639
mais simples no momento da gravação

311
00:11:58,639 --> 00:12:00,959
Este vídeo eu estou gravando isso em

312
00:12:00,959 --> 00:12:01,959
August

313
00:12:01,959 --> 00:12:04,880
2021 mas se formos aqui, vamos

314
00:12:04,880 --> 00:12:07,600
ver c plus mais 20 características principais e

315
00:12:07,600 --> 00:12:09,600
Vamos ver que temos uma lista

316
00:12:09,600 --> 00:12:12,000
do que cada compilador suporta que temos

317
00:12:12,000 --> 00:12:15,040
gcc temos clã que temos msvc que temos

318
00:12:15,040 --> 00:12:18,079
a versão do clã da empresa de maçã

319
00:12:18,079 --> 00:12:20,079
E se rolarmos para baixo podemos realmente ver

320
00:12:20,079 --> 00:12:22,480
os recursos que são suportados por cada um

321
00:12:22,480 --> 00:12:26,000
compilador novamente gcc vai ser o nosso

322
00:12:26,000 --> 00:12:27,600
escolha neste curso isso vai

323
00:12:27,600 --> 00:12:30,079
ser o nosso compilador principal, mas nada realmente

324
00:12:30,079 --> 00:12:32,320
impede você de usar o compilador do clã

325
00:12:32,320 --> 00:12:34,800
ou o compilador msvc e se você acontecer

326
00:12:34,800 --> 00:12:36,720
para ver que seu compilador de escolha

327
00:12:36,720 --> 00:12:38,320
Não suporta o que você precisa

328
00:12:38,320 --> 00:12:40,800
O exemplo você pode ver isso no atual

329
00:12:40,800 --> 00:12:44,320
tempo lambdas em um contexto avaliado são

330
00:12:44,320 --> 00:12:46,959
Não apoiado no clã

331
00:12:46,959 --> 00:12:49,279
Você pode ver que está pronto aqui, mas

332
00:12:49,279 --> 00:12:51,279
Este é um recurso que você pode usar ambos em

333
00:12:51,279 --> 00:12:55,920
gcc e o compilador msvc da microsoft

334
00:12:55,920 --> 00:12:59,279
então fique de olho nesta página aqui para

335
00:12:59,279 --> 00:13:01,279
Saiba em que tipo de coisas você pode usar

336
00:13:01,279 --> 00:13:03,519
seu compilador se você tentar algo

337
00:13:03,519 --> 00:13:05,839
E você vê que não funciona isso é

338
00:13:05,839 --> 00:13:07,920
Um bom lugar para vir e descobrir se

339
00:13:07,920 --> 00:13:10,240
seu compilador suporta o recurso que

340
00:13:10,240 --> 00:13:12,399
você está usando neste vídeo eu estou indo

341
00:13:12,399 --> 00:13:14,079
para mostrar como instalar os três

342
00:13:14,079 --> 00:13:16,639
Os compiladores mais comuns e estes são gcc

343
00:13:16,639 --> 00:13:19,839
clang msvc se você quiser você pode entrar

344
00:13:19,839 --> 00:13:22,560
seu motor de busca e digite gcc para ver

345
00:13:22,560 --> 00:13:24,800
O que isso é bom fazer para

346
00:13:24,800 --> 00:13:27,040
Saiba mais sobre suas ferramentas aqui você pode ver

347
00:13:27,040 --> 00:13:28,720
que é um compilador que é principalmente

348
00:13:28,720 --> 00:13:31,040
usado na plataforma lenox mas nós podemos

349
00:13:31,040 --> 00:13:33,760
também usá-lo nas janelas mais recentes

350
00:13:33,760 --> 00:13:34,959
Liberte que nós vamos ser

351
00:13:34,959 --> 00:13:37,600
A instalação é 11 dois zero eu acho que

352
00:13:37,600 --> 00:13:39,120
Foi liberado

353
00:13:39,120 --> 00:13:41,440
Há seis dias, por isso é realmente fresco e

354
00:13:41,440 --> 00:13:43,040
nós vamos estar aproveitando

355
00:13:43,040 --> 00:13:45,040
Esta outra coisa que eu devo dizer aqui é

356
00:13:45,040 --> 00:13:47,519
Você deve instalar as ferramentas mais recentes

357
00:13:47,519 --> 00:13:50,079
Você pode colocar suas mãos sobre isso é o

358
00:13:50,079 --> 00:13:52,320
Versão que vamos usar principalmente

359
00:13:52,320 --> 00:13:54,320
neste curso, mas se você está assistindo

360
00:13:54,320 --> 00:13:55,760
Isso no futuro você vai ter

361
00:13:55,760 --> 00:13:57,760
uma versão mais recente que recomendo

362
00:13:57,760 --> 00:14:00,079
Instalando a versão mais recente ou a

363
00:14:00,079 --> 00:14:02,320
A mais nova versão você pode obter suas mãos

364
00:14:02,320 --> 00:14:04,880
Assim, o primeiro que vamos fazer é

365
00:14:04,880 --> 00:14:07,760
instalar um compilador gcc no Windows i am

366
00:14:07,760 --> 00:14:10,000
Vou mostrar-lhe uma maneira que podemos obter ambos

367
00:14:10,000 --> 00:14:13,360
gcc e clang em uma só vez e para obter

368
00:14:13,360 --> 00:14:15,279
acesso a isso, por favor, vá em sua busca

369
00:14:15,279 --> 00:14:17,760
motor e tipo de lajes e este é

370
00:14:17,760 --> 00:14:19,839
Vou nos levar a este projeto aqui

371
00:14:19,839 --> 00:14:22,320
Se você quiser você pode clicar sobre isso

372
00:14:22,320 --> 00:14:25,440
e este é um projeto legal de um cara que

373
00:14:25,440 --> 00:14:28,320
está fornecendo mundos para esses compiladores

374
00:14:28,320 --> 00:14:30,399
que podemos usar em janelas

375
00:14:30,399 --> 00:14:32,959
Então, se você quiser, você pode simplesmente ir aqui

376
00:14:32,959 --> 00:14:35,760
e olhar para a alface libera novamente i

377
00:14:35,760 --> 00:14:37,760
Recomendar o uso do

378
00:14:37,760 --> 00:14:39,839
A alface você pode colocar as mãos em

379
00:14:39,839 --> 00:14:43,360
Este caso, a alface passa a ser 1120

380
00:14:43,360 --> 00:14:45,199
Mas no futuro isto vai

381
00:14:45,199 --> 00:14:46,800
Mudança que você vai encontrar uma versão

382
00:14:46,800 --> 00:14:50,160
por 12 ou 13, então por favor pegue o mais novo

383
00:14:50,160 --> 00:14:52,480
Versão em que você pode colocar as mãos para cima

384
00:14:52,480 --> 00:14:54,399
Quero que você instale a versão que

385
00:14:54,399 --> 00:14:58,000
diz que tem llvm e clang assim se

386
00:14:58,000 --> 00:15:01,040
você está em uma versão de 32 bits no Windows i

387
00:15:01,040 --> 00:15:03,440
recomendaria obter este 7-zip

388
00:15:03,440 --> 00:15:06,320
arquivo neste arquivo zip aqui se você

389
00:15:06,320 --> 00:15:08,800
estão em 64 eu recomendo obter um

390
00:15:08,800 --> 00:15:11,199
Segure esta ou esta coisinha aqui

391
00:15:11,199 --> 00:15:13,120
Isso realmente não importa, mas certifique-se

392
00:15:13,120 --> 00:15:15,040
você obtém a versão mais recente que pode obter

393
00:15:15,040 --> 00:15:16,959
suas mãos e você pode ver que

394
00:15:16,959 --> 00:15:19,760
isso convenientemente diz mais recente aqui, então eu

395
00:15:19,760 --> 00:15:22,480
Vou baixar a versão de 64 bits

396
00:15:22,480 --> 00:15:24,480
nas janelas eu vou pegar o zip

397
00:15:24,480 --> 00:15:27,440
arquivo aqui e vamos clicar sobre isso

398
00:15:27,440 --> 00:15:30,160
Isso deve começar meu download e

399
00:15:30,160 --> 00:15:32,240
isso vai baixar no meu sistema eu

400
00:15:32,240 --> 00:15:34,399
Posso fazer o download se eu quiser e você estiver

401
00:15:34,399 --> 00:15:36,079
Vou ver que vai começar

402
00:15:36,079 --> 00:15:38,480
baixar aqui e eu vou esperar

403
00:15:38,480 --> 00:15:41,440
para que isso termine novamente isso está acontecendo

404
00:15:41,440 --> 00:15:44,320
para nos dar o compilador gcc e a

405
00:15:44,320 --> 00:15:46,639
Compilador de clã e isso é realmente como

406
00:15:46,639 --> 00:15:49,360
disparando dois pássaros com uma pedra assim

407
00:15:49,360 --> 00:15:51,519
Isso vai ser muito bom eu

408
00:15:51,519 --> 00:15:53,440
Já tenho isso baixado, então eu sou

409
00:15:53,440 --> 00:15:56,160
apenas indo para a cabeça para a localização

410
00:15:56,160 --> 00:15:58,560
onde eu tenho isso baixado eu acho que eu

411
00:15:58,560 --> 00:16:01,759
pode simplesmente entrar na minha unidade aqui

412
00:16:01,759 --> 00:16:04,160
Então vamos abrir isso e entrar no meu

413
00:16:04,160 --> 00:16:06,079
Baixar a pasta

414
00:16:06,079 --> 00:16:08,880
e se eu for na minha pasta compactada eu sou

415
00:16:08,880 --> 00:16:12,959
indo para encontrar winlabs llvm e mingw

416
00:16:12,959 --> 00:16:15,360
Isto é o que você realmente quer, mas se você

417
00:16:15,360 --> 00:16:17,040
Não quero o compilador do clã que você pode

418
00:16:17,040 --> 00:16:20,639
Pegue aquele que não diz llvm aqui

419
00:16:20,639 --> 00:16:22,160
Porque nós realmente queremos os dois

420
00:16:22,160 --> 00:16:24,320
compiladores que vamos pegar um

421
00:16:24,320 --> 00:16:26,560
que tem o compilador gcc e o

422
00:16:26,560 --> 00:16:28,959
Compilador de clã se quebrarmos esta abertura

423
00:16:28,959 --> 00:16:30,720
Vamos abrir isso juntos para que você possa

424
00:16:30,720 --> 00:16:32,880
Veja o que está acontecendo, vamos

425
00:16:32,880 --> 00:16:35,120
ter esta pequena pasta aqui se entrarmos

426
00:16:35,120 --> 00:16:37,360
vamos encontrar uma pasta se nós

427
00:16:37,360 --> 00:16:39,680
entrar e abrir, nós vamos

428
00:16:39,680 --> 00:16:40,959
Tem uma pasta

429
00:16:40,959 --> 00:16:44,160
que diz clang você vê que temos um clang

430
00:16:44,160 --> 00:16:46,639
compilador, temos nosso clã mais mais

431
00:16:46,639 --> 00:16:48,880
compilador para c plus plus e se formos

432
00:16:48,880 --> 00:16:50,959
para baixo nós vamos encontrar o nosso g plus mais

433
00:16:50,959 --> 00:16:53,680
compilador e o compilador gcc este é

434
00:16:53,680 --> 00:16:55,839
O que queremos, então o que vamos fazer

435
00:16:55,839 --> 00:16:58,480
é extrair isso em algum lugar do nosso sistema

436
00:16:58,480 --> 00:17:01,040
Eu coloco isso no meu c drive, então se você for

437
00:17:01,040 --> 00:17:03,759
Aqui você vai encontrar o mingw64

438
00:17:03,759 --> 00:17:06,160
Então tudo que você realmente tem que fazer é ir para onde

439
00:17:06,160 --> 00:17:08,720
você baixou o seu compilador

440
00:17:08,720 --> 00:17:10,559
e dizer extrato, vamos para a direita

441
00:17:10,559 --> 00:17:12,079
Clique sobre isso

442
00:17:12,079 --> 00:17:14,959
e dizer extrato para um local e você está

443
00:17:14,959 --> 00:17:16,720
especificar onde você quer isso

444
00:17:16,720 --> 00:17:19,760
ir e isso vai ser extraído ou

445
00:17:19,760 --> 00:17:21,760
mesmo se você quiser você pode extrair aqui

446
00:17:21,760 --> 00:17:23,439
Isso é algo que eu gosto de fazer é

447
00:17:23,439 --> 00:17:25,520
aparecer na pasta atual

448
00:17:25,520 --> 00:17:28,079
e você pode pegar isso e colar isso em

449
00:17:28,079 --> 00:17:30,320
um local onde você quer isso no meu

450
00:17:30,320 --> 00:17:33,120
Caso eu coloquei isso no meu c drive como eu disse

451
00:17:33,120 --> 00:17:35,679
Então este vai ser o meu compilador

452
00:17:35,679 --> 00:17:37,760
Agora, uma vez que você tem esses compiladores

453
00:17:37,760 --> 00:17:39,520
Instalado novamente temos o clã

454
00:17:39,520 --> 00:17:42,480
Compilador temos o compilador gcc se nós

455
00:17:42,480 --> 00:17:44,080
descer, vamos encontrar o g plus

456
00:17:44,080 --> 00:17:46,240
Além disso, temos até gdb, que é um

457
00:17:46,240 --> 00:17:48,400
depurador que podemos usar para depurar c plus plus

458
00:17:48,400 --> 00:17:50,720
Aplicações, mas vamos falar sobre isso

459
00:17:50,720 --> 00:17:52,799
Mais tarde, uma vez que você tem isso, eu faria

460
00:17:52,799 --> 00:17:54,559
Recomendamos colocar isso em seu

461
00:17:54,559 --> 00:17:57,120
variáveis ambientais nas janelas do caminho

462
00:17:57,120 --> 00:17:59,360
Você faz isso você agarra bem esse caminho

463
00:17:59,360 --> 00:18:00,960
ter nossos compiladores aqui e nós estamos indo

464
00:18:00,960 --> 00:18:02,559
Copiar isso é algo que eu

465
00:18:02,559 --> 00:18:03,760
Recomendar

466
00:18:03,760 --> 00:18:06,640
e nas janelas 10 você pode ir no

467
00:18:06,640 --> 00:18:10,559
iniciar menu e digitar env

468
00:18:10,559 --> 00:18:12,799
E isso vai nos dar uma janela para dentro

469
00:18:12,799 --> 00:18:15,039
que podemos editar o nosso ambiente

470
00:18:15,039 --> 00:18:16,799
variáveis vamos clicar sobre isso

471
00:18:16,799 --> 00:18:19,120
pequena coisa isso vai se abrir

472
00:18:19,120 --> 00:18:20,559
nosso sistema, vamos esperar por isso

473
00:18:20,559 --> 00:18:22,640
para se abrir e nós vamos ter um

474
00:18:22,640 --> 00:18:25,039
Janela que diz propriedades do sistema que somos

475
00:18:25,039 --> 00:18:26,960
Vou clicar em variáveis de ambiente

476
00:18:26,960 --> 00:18:30,080
Aqui e podemos colocar isso em nosso usuário

477
00:18:30,080 --> 00:18:32,880
variáveis de ambiente ou em nosso sistema

478
00:18:32,880 --> 00:18:34,960
variáveis ambientais, uma vez que eu sou o

479
00:18:34,960 --> 00:18:37,280
Apenas um usando este sistema eu gosto de colocar

480
00:18:37,280 --> 00:18:40,160
Isso no meu caminho para as variáveis do meu sistema

481
00:18:40,160 --> 00:18:42,480
então eu vou clicar no caminho e clicar

482
00:18:42,480 --> 00:18:45,360
editar aqui e vou adicionar um caminho

483
00:18:45,360 --> 00:18:48,240
para o meu gcc e instalação na nuvem aqui

484
00:18:48,240 --> 00:18:50,559
você pode ver isso aqui se você não fizer isso

485
00:18:50,559 --> 00:18:52,880
ter este fim você pode clicar em

486
00:18:52,880 --> 00:18:54,400
Você vai ter uma janela aqui e

487
00:18:54,400 --> 00:18:56,880
você pode colar isso diretamente e você pode

488
00:18:56,880 --> 00:18:58,720
clique ok, mas eu não vou fazer isso

489
00:18:58,720 --> 00:19:01,679
Porque eu já tenho isso aqui, então

490
00:19:01,679 --> 00:19:04,000
O que eu vou fazer é simplesmente excluir

491
00:19:04,000 --> 00:19:06,880
vamos ver se eu posso excluir eu posso

492
00:19:06,880 --> 00:19:08,880
Apague este pequeno rapaz e eu tenho o meu

493
00:19:08,880 --> 00:19:11,039
caminho aqui, então se você não tem isso

494
00:19:11,039 --> 00:19:12,960
por favor, certifique-se de que você tem isso em

495
00:19:12,960 --> 00:19:15,440
suas variáveis de ambiente, então nós somos

496
00:19:15,440 --> 00:19:17,520
vai cancelar isso, mas se isso

497
00:19:17,520 --> 00:19:19,520
É a primeira vez que você faz isso, você deve

498
00:19:19,520 --> 00:19:22,480
clique ok e uma maneira de testar que

499
00:19:22,480 --> 00:19:24,960
As variáveis de ambiente estão funcionando ou

500
00:19:24,960 --> 00:19:27,840
mesmo que seus compiladores estejam funcionando

501
00:19:27,840 --> 00:19:30,880
é para rachar um terminal de linha de comando

502
00:19:30,880 --> 00:19:32,880
Vamos dizer cmd no começo

503
00:19:32,880 --> 00:19:34,559
menu aqui

504
00:19:34,559 --> 00:19:37,039
E tudo que você precisa fazer é dizer g plus

505
00:19:37,039 --> 00:19:40,640
plus apenas como esta versão dash dash

506
00:19:40,640 --> 00:19:41,919
Se você fizer isso, você vai ver

507
00:19:41,919 --> 00:19:43,840
informações sobre o seu c plus plus

508
00:19:43,840 --> 00:19:45,039
Compilador

509
00:19:45,039 --> 00:19:46,960
e isso vem da instalação

510
00:19:46,960 --> 00:19:49,679
nós apenas fizemos e para o clã você pode dizer

511
00:19:49,679 --> 00:19:53,120
clan plus versão plus e isso está indo

512
00:19:53,120 --> 00:19:55,120
para informar as informações sobre o seu

513
00:19:55,120 --> 00:19:57,280
instalação do compilador do clã vamos esperar

514
00:19:57,280 --> 00:19:58,799
para que isso venha, eu não sei por quê

515
00:19:58,799 --> 00:20:01,039
É lento, mas você pode ver que nós temos um

516
00:20:01,039 --> 00:20:03,039
clank compilador que a versão treliça é

517
00:20:03,039 --> 00:20:06,240
1201 para o compilador gcc o mais recente

518
00:20:06,240 --> 00:20:08,559
A versão é 1120

519
00:20:08,559 --> 00:20:10,799
e estes são os compiladores que podemos usar

520
00:20:10,799 --> 00:20:13,760
para escrever c mais mais 20 aplicações

521
00:20:13,760 --> 00:20:16,480
Ok, então agora temos um compilador gcc

522
00:20:16,480 --> 00:20:19,280
através do projeto gw principal temos um

523
00:20:19,280 --> 00:20:22,320
cliente do llcm compilador em nosso sistema nós

524
00:20:22,320 --> 00:20:24,400
Também vai ver como conseguir uma espera

525
00:20:24,400 --> 00:20:27,440
do compilador da microsoft e para

526
00:20:27,440 --> 00:20:29,600
Segure isso que você precisa instalar

527
00:20:29,600 --> 00:20:32,000
microsoft visual studio

528
00:20:32,000 --> 00:20:34,080
para instalar o microsoft visual studio todos

529
00:20:34,080 --> 00:20:36,080
Você tem que fazer é vir para o seu favorito

530
00:20:36,080 --> 00:20:38,320
motor de busca e dizer microsoft visual

531
00:20:38,320 --> 00:20:41,280
Estúdio podemos ver a versão 2019

532
00:20:41,280 --> 00:20:43,440
que é o mais recente eu penso e nós somos

533
00:20:43,440 --> 00:20:45,840
Vou clicar no link de download aqui

534
00:20:45,840 --> 00:20:48,480
Temos como primeiro elo e nós somos

535
00:20:48,480 --> 00:20:50,400
Vamos ver maneiras de baixar isso

536
00:20:50,400 --> 00:20:52,720
Um garotinho agora microsoft visual studio

537
00:20:52,720 --> 00:20:55,039
tem uma versão comunitária que você pode baixar

538
00:20:55,039 --> 00:20:57,440
de graça, mas também temos um profissional

539
00:20:57,440 --> 00:20:59,679
e versões empresariais que não somos

540
00:20:59,679 --> 00:21:02,080
Vou me preocupar neste curso aqui

541
00:21:02,080 --> 00:21:04,400
Vamos apenas baixar

542
00:21:04,400 --> 00:21:06,880
a versão da comunidade e isso está indo

543
00:21:06,880 --> 00:21:09,039
para ser suficiente para nossos propósitos aqui, então se

544
00:21:09,039 --> 00:21:11,600
Você clica em download gratuito aqui este é

545
00:21:11,600 --> 00:21:14,400
Vai baixar e instalar o visual

546
00:21:14,400 --> 00:21:16,640
compilador de estúdio você pode clicar sobre isso

547
00:21:16,640 --> 00:21:18,320
Um garotinho e vai baixar

548
00:21:18,320 --> 00:21:20,000
um instalador que você vai quebrar isso

549
00:21:20,000 --> 00:21:22,240
abra em seu sistema e ele vai

550
00:21:22,240 --> 00:21:25,440
Instale o instalador visual do estúdio assim

551
00:21:25,440 --> 00:21:27,360
uma vez que você tem instalado você pode vir

552
00:21:27,360 --> 00:21:29,360
para o menu Iniciar aqui

553
00:21:29,360 --> 00:21:32,320
e dizer visual studio installer i think

554
00:21:32,320 --> 00:21:33,919
Se você disser estúdio visual que você vai

555
00:21:33,919 --> 00:21:35,520
ter este pop-up em algum lugar em seu

556
00:21:35,520 --> 00:21:38,000
sistema vamos clicar sobre isso e

557
00:21:38,000 --> 00:21:39,840
se você quebrar o instalador aberto você está

558
00:21:39,840 --> 00:21:41,600
Vou ver uma janela como esta, que é

559
00:21:41,600 --> 00:21:43,360
realmente vai te dar uma chance de

560
00:21:43,360 --> 00:21:46,000
Instale as ferramentas que você deseja usar

561
00:21:46,000 --> 00:21:48,720
o microsoft visual studio

562
00:21:48,720 --> 00:21:51,679
Ir e neste caso estamos interessados

563
00:21:51,679 --> 00:21:53,840
em desenvolvimento desktop com c plus mais

564
00:21:53,840 --> 00:21:55,600
Então nós vamos clicar neste pequeno cara

565
00:21:55,600 --> 00:21:57,679
Aqui nós vamos levá-lo aberto

566
00:21:57,679 --> 00:22:00,559
E uma vez que você faz isso você vai clicar

567
00:22:00,559 --> 00:22:02,400
Baixe e instale e isso está acontecendo

568
00:22:02,400 --> 00:22:05,039
para instalar o compilador de estúdio visual

569
00:22:05,039 --> 00:22:07,039
com o compilador subjacente que você vê

570
00:22:07,039 --> 00:22:08,880
que isso nos dará acesso a

571
00:22:08,880 --> 00:22:11,600
O compilador msvc e todos os tipos de loucos

572
00:22:11,600 --> 00:22:13,360
Coisas que realmente precisávamos escrever c plus

573
00:22:13,360 --> 00:22:16,480
além de aplicativos em janelas usando o

574
00:22:16,480 --> 00:22:18,799
Compilador da Microsoft agora eu tenho que

575
00:22:18,799 --> 00:22:20,320
Digamos que isso vai levar algum tempo para

576
00:22:20,320 --> 00:22:22,480
instale isso se você ver que isso acontece

577
00:22:22,480 --> 00:22:24,880
20 minutos do seu tempo não se preocupem com isso

578
00:22:24,880 --> 00:22:27,919
é realmente normal porque este id e a

579
00:22:27,919 --> 00:22:30,640
Compilador por trás dele e realmente grande

580
00:22:30,640 --> 00:22:33,440
Eles não são como o gcc ou o clã

581
00:22:33,440 --> 00:22:35,840
llvm compiladores que acabamos de instalar

582
00:22:35,840 --> 00:22:38,320
Tudo bem, então depois de ter isso marcado ou

583
00:22:38,320 --> 00:22:39,679
Verifique se você vai clicar

584
00:22:39,679 --> 00:22:41,840
baixar ou instalar qualquer que seja este botão

585
00:22:41,840 --> 00:22:44,159
Está dizendo aqui que isso vai instalar

586
00:22:44,159 --> 00:22:47,280
ambos o microsoft visual studio ide

587
00:22:47,280 --> 00:22:49,520
e o compilador da Microsoft que você

588
00:22:49,520 --> 00:22:51,840
pode usar diretamente para escrever c plus mais

589
00:22:51,840 --> 00:22:54,400
aplicações assim, uma vez que temos este aberto i

590
00:22:54,400 --> 00:22:56,320
Vou supor que você tem isso

591
00:22:56,320 --> 00:22:58,080
instalado já vou fechar

592
00:22:58,080 --> 00:22:59,919
Isso porque eu não quero fazer

593
00:22:59,919 --> 00:23:00,720
Isto é

594
00:23:00,720 --> 00:23:02,240
e você vai ter estúdio visual

595
00:23:02,240 --> 00:23:04,480
instalado em seu sistema uma vez que você tem

596
00:23:04,480 --> 00:23:06,080
Este instalado você vai vir para

597
00:23:06,080 --> 00:23:09,120
O menu Iniciar e Diga Desenvolvedor

598
00:23:09,120 --> 00:23:10,880
E isso vai trazer duas coisas

599
00:23:10,880 --> 00:23:12,320
Um vai ser o desenvolvedor

600
00:23:12,320 --> 00:23:15,520
powershell para estúdio visual 2019 e

601
00:23:15,520 --> 00:23:16,799
O outro vai ser um comando

602
00:23:16,799 --> 00:23:18,559
Isso não importa realmente o que você

603
00:23:18,559 --> 00:23:19,919
Escolher eu vou clicar sobre o

604
00:23:19,919 --> 00:23:21,600
prompt de comando aqui

605
00:23:21,600 --> 00:23:23,679
E uma vez que você faça isso, isso vai

606
00:23:23,679 --> 00:23:26,559
dar-lhe um terminal ou uma janela através

607
00:23:26,559 --> 00:23:27,440
que

608
00:23:27,440 --> 00:23:29,919
As variáveis de ambiente já estão em

609
00:23:29,919 --> 00:23:31,679
para começar a usar o compilador a partir de

610
00:23:31,679 --> 00:23:34,159
microsoft e se viermos aqui e digitar

611
00:23:34,159 --> 00:23:36,640
cl.exe (em Inglês)

612
00:23:36,640 --> 00:23:37,840
nós vamos ver que nós vamos

613
00:23:37,840 --> 00:23:39,919
Veja a informação aqui se isso der

614
00:23:39,919 --> 00:23:41,679
Você é um erro ou algo que você está indo

615
00:23:41,679 --> 00:23:43,840
Saber que você realmente não instalou

616
00:23:43,840 --> 00:23:46,080
isso corretamente, então por favor, volte e faça

617
00:23:46,080 --> 00:23:48,240
Você tem isso instalado se você tem

618
00:23:48,240 --> 00:23:50,080
um problema que você pode me perguntar que eu posso fazer o

619
00:23:50,080 --> 00:23:52,720
O melhor que posso para te ajudar, mas com isso

620
00:23:52,720 --> 00:23:54,880
momento em que temos três compiladores em

621
00:23:54,880 --> 00:23:57,440
janelas que podemos usar para c plus mais

622
00:23:57,440 --> 00:24:00,880
desenvolvimento que temos o mingw ou o gcc

623
00:24:00,880 --> 00:24:03,200
Compilador em nossas mãos temos o klanga

624
00:24:03,200 --> 00:24:06,080
lvm compilador e nós temos o compilador

625
00:24:06,080 --> 00:24:09,679
da Microsoft e agora podemos instalar um

626
00:24:09,679 --> 00:24:11,919
um editor ou um editor e isso vai ser

627
00:24:11,919 --> 00:24:14,400
código de estúdio visual e podemos conectar

628
00:24:14,400 --> 00:24:16,480
para esses compiladores para que possamos

629
00:24:16,480 --> 00:24:19,039
começar a escrever o nosso próprio z mais ônibus 20

630
00:24:19,039 --> 00:24:21,200
aplicações que vamos nos dirigir

631
00:24:21,200 --> 00:24:23,120
na próxima palestra e instalar o

632
00:24:23,120 --> 00:24:25,279
Editor de código de estúdio visual

633
00:24:25,279 --> 00:24:27,520
Vá em frente e termine aqui e me encontre

634
00:24:27,520 --> 00:24:29,840
lá nesta palestra vou mostrar

635
00:24:29,840 --> 00:24:31,679
Como instalar o estúdio visual

636
00:24:31,679 --> 00:24:34,400
Editor de código no Windows, portanto, se você estiver

637
00:24:34,400 --> 00:24:36,480
assistindo este curso nas janelas este

638
00:24:36,480 --> 00:24:39,200
O vídeo aqui vai ser um relógio obrigatório

639
00:24:39,200 --> 00:24:42,000
Vamos para a nossa busca

640
00:24:42,000 --> 00:24:44,080
código de estúdio visual do motor e tipo este

641
00:24:44,080 --> 00:24:46,080
vai te dar um link onde pudermos

642
00:24:46,080 --> 00:24:48,720
Baixe este editor legal se você quiser

643
00:24:48,720 --> 00:24:50,559
Você pode aprender tudo o que puder sobre isso é

644
00:24:50,559 --> 00:24:52,960
um editor de código fonte feito pela microsoft

645
00:24:52,960 --> 00:24:55,200
suporta vários idiomas, mas nós somos

646
00:24:55,200 --> 00:24:57,840
Vou usar isso especificamente para

647
00:24:57,840 --> 00:25:00,640
c plus plus no curso aqui estou

648
00:25:00,640 --> 00:25:03,679
na página para o editor e você pode

649
00:25:03,679 --> 00:25:06,000
Leia tudo o que quiser, mas nós somos

650
00:25:06,000 --> 00:25:08,559
interessado em baixar isso para

651
00:25:08,559 --> 00:25:10,720
Janelas, se você quiser, você pode clicar

652
00:25:10,720 --> 00:25:12,880
Este botão de download aqui, mas eu sou apenas

653
00:25:12,880 --> 00:25:14,480
indo para rolar para baixo

654
00:25:14,480 --> 00:25:17,840
e ter links para Windows se i

655
00:25:17,840 --> 00:25:19,679
Quero eu posso clicar no instalador do usuário

656
00:25:19,679 --> 00:25:21,440
instalador do sistema você pode clicar sobre o que

657
00:25:21,440 --> 00:25:24,159
Você quer se estiver em um sistema de 32 bits

658
00:25:24,159 --> 00:25:25,919
você vai baixar um 32-bit

659
00:25:25,919 --> 00:25:28,080
versão eu vou apenas clicar em

660
00:25:28,080 --> 00:25:31,840
64 bits aqui porque eu estou em um 64 bits

661
00:25:31,840 --> 00:25:33,919
sistema operacional novamente

662
00:25:33,919 --> 00:25:36,000
Neste vídeo estamos fazendo isso para

663
00:25:36,000 --> 00:25:38,480
Janelas para que esta seja a nossa área

664
00:25:38,480 --> 00:25:40,960
de interesse aqui vou clicar em

665
00:25:40,960 --> 00:25:43,200
este link de download e eu estou indo para

666
00:25:43,200 --> 00:25:45,520
Aguarde as coisas para começar

667
00:25:45,520 --> 00:25:47,360
E terei uma janela para começar

668
00:25:47,360 --> 00:25:49,520
baixar a configuração de código visual do estúdio

669
00:25:49,520 --> 00:25:51,600
Aqui eu posso salvar este arquivo e é

670
00:25:51,600 --> 00:25:54,000
Vou começar a baixar uma vez que é

671
00:25:54,000 --> 00:25:55,919
baixados I'i indo para duplo clique

672
00:25:55,919 --> 00:25:58,240
e realmente clique no meu caminho através disso

673
00:25:58,240 --> 00:26:00,000
até que eu tenha um código de estúdio visual

674
00:26:00,000 --> 00:26:02,960
instalado no meu computador aqui

675
00:26:02,960 --> 00:26:05,200
OK o download é bom eu posso quebrar

676
00:26:05,200 --> 00:26:07,600
Este aberto vamos clicar sobre isso

677
00:26:07,600 --> 00:26:08,960
e você vai ver que é

678
00:26:08,960 --> 00:26:11,200
dizendo que detectou que

679
00:26:11,200 --> 00:26:13,520
O código do estúdio já está sendo executado no meu

680
00:26:13,520 --> 00:26:15,840
sistema porque eu tenho instalado, mas

681
00:26:15,840 --> 00:26:17,200
Se você não o tiver instalado, você está

682
00:26:17,200 --> 00:26:19,440
Vou clicar em seu caminho e

683
00:26:19,440 --> 00:26:21,679
Instale isso em janelas e depois de você

684
00:26:21,679 --> 00:26:23,440
Você pode começar

685
00:26:23,440 --> 00:26:25,279
Tudo bem depois de iniciar o código do estúdio visual

686
00:26:25,279 --> 00:26:26,880
Você vai ter uma janela como esta

687
00:26:26,880 --> 00:26:28,799
Se você executá-lo pela primeira vez você é

688
00:26:28,799 --> 00:26:30,880
Provavelmente vai ver uma janela com

689
00:26:30,880 --> 00:26:33,600
Documentação e qualquer coisa

690
00:26:33,600 --> 00:26:35,360
Vamos olhar para a tela de boas-vindas que você é

691
00:26:35,360 --> 00:26:36,880
Vou ver que você vai

692
00:26:36,880 --> 00:26:38,640
provavelmente ver algo assim, mas eu

693
00:26:38,640 --> 00:26:40,960
Não tenho certeza, mas o mais importante

694
00:26:40,960 --> 00:26:42,640
É que você vai ter uma janela

695
00:26:42,640 --> 00:26:44,880
assim com código visual do estúdio o

696
00:26:44,880 --> 00:26:46,480
primeira coisa que queremos fazer para c plus

697
00:26:46,480 --> 00:26:49,440
além do desenvolvimento vai rolar para baixo

698
00:26:49,440 --> 00:26:51,679
e clique nessa pequena coisa que diz

699
00:26:51,679 --> 00:26:54,880
extensões eu vou clicar sobre isso

700
00:26:54,880 --> 00:26:57,279
E eu vou na minha caixa de pesquisa

701
00:26:57,279 --> 00:27:00,720
aqui e digite c e c plus eu posso até

702
00:27:00,720 --> 00:27:02,400
tipo c plus plus não

703
00:27:02,400 --> 00:27:05,360
matéria e esta é uma área onde podemos

704
00:27:05,360 --> 00:27:08,799
instalar extensões para fazer o estúdio visual

705
00:27:08,799 --> 00:27:11,200
O código faz todo tipo de coisas loucas em

706
00:27:11,200 --> 00:27:13,760
Este caso estamos interessados em fazê-lo

707
00:27:13,760 --> 00:27:16,480
suporte c e c plus plus assim que nós somos

708
00:27:16,480 --> 00:27:18,320
Vou clicar nesta extensão que

709
00:27:18,320 --> 00:27:21,120
diz microsoft aqui cnc plus plus eu sou

710
00:27:21,120 --> 00:27:23,440
Vou clicar sobre isso e se você não clicar

711
00:27:23,440 --> 00:27:25,200
tê-lo instalado você pode clicar sobre o

712
00:27:25,200 --> 00:27:27,120
Botão de instalação e vai

713
00:27:27,120 --> 00:27:29,120
Instale esta coisinha e faça seu

714
00:27:29,120 --> 00:27:32,080
computador pronto para usar código de estúdio visual

715
00:27:32,080 --> 00:27:34,399
para c plus plus assim certifique-se de instalar

716
00:27:34,399 --> 00:27:37,039
Isso e no final vai dizer

717
00:27:37,039 --> 00:27:39,520
desabilitar ou desinstalar porque será

718
00:27:39,520 --> 00:27:43,039
já instalado e habilitado em seu

719
00:27:43,039 --> 00:27:45,600
computador e este é realmente o fim de

720
00:27:45,600 --> 00:27:47,840
nosso vídeo de instalação para estúdio visual

721
00:27:47,840 --> 00:27:49,679
Código que vamos nos dirigir no

722
00:27:49,679 --> 00:27:51,919
próximo vídeo e mostrar como você pode fazer

723
00:27:51,919 --> 00:27:54,880
Um código de estúdio visual usa os compiladores

724
00:27:54,880 --> 00:27:57,360
que nós instalamos no vídeo anterior

725
00:27:57,360 --> 00:27:59,440
então vá em frente e termine aqui e conheça

726
00:27:59,440 --> 00:28:01,440
Eu na próxima palestra

727
00:28:01,440 --> 00:28:03,120
Neste vídeo vamos ver como

728
00:28:03,120 --> 00:28:06,320
conectar o nosso editor de código de estúdio visual a

729
00:28:06,320 --> 00:28:09,440
um compilador para que possamos compilar o nosso

730
00:28:09,440 --> 00:28:11,840
Projetos facilmente através do visual

731
00:28:11,840 --> 00:28:14,240
Editor de código de estúdio que já temos

732
00:28:14,240 --> 00:28:17,039
A partir dos dois últimos anteriores

733
00:28:17,039 --> 00:28:18,960
palestras quando temos um compilador

734
00:28:18,960 --> 00:28:20,480
instalado na última palestra

735
00:28:20,480 --> 00:28:22,399
instalado o compilador gcc através do

736
00:28:22,399 --> 00:28:25,840
Projeto de mingw nós instalamos a clangela

737
00:28:25,840 --> 00:28:27,679
vm compilador nós mesmo instalamos o

738
00:28:27,679 --> 00:28:30,080
Compilador da Microsoft agora estamos indo

739
00:28:30,080 --> 00:28:32,640
para conectar o ide ao compilador para

740
00:28:32,640 --> 00:28:35,200
torná-lo realmente fácil de compilar c plus

741
00:28:35,200 --> 00:28:38,399
além de aplicativos usando essas ferramentas aqui

742
00:28:38,399 --> 00:28:40,320
O que eu vou fazer é realmente configurar um

743
00:28:40,320 --> 00:28:42,240
Projeto de modelo que vamos ser

744
00:28:42,240 --> 00:28:45,360
reutilizando ao longo deste curso aqui, então eu

745
00:28:45,360 --> 00:28:48,080
Vou fazer uma pasta no meu sistema

746
00:28:48,080 --> 00:28:50,240
e eu vou clicar com a direita no

747
00:28:50,240 --> 00:28:52,240
pasta e dizer

748
00:28:52,240 --> 00:28:55,279
aberto com código de estúdio visual

749
00:28:55,279 --> 00:28:57,360
Vamos fazer isso, isso vai abrir isso

750
00:28:57,360 --> 00:28:59,520
pasta em código de estúdio visual e i am

751
00:28:59,520 --> 00:29:02,080
Vou confiar nesta pasta aqui ser

752
00:29:02,080 --> 00:29:04,240
Cuidado com o que você confia, porque alguns

753
00:29:04,240 --> 00:29:06,000
As coisas vão fazer algum mal-intencionado

754
00:29:06,000 --> 00:29:08,159
Coisas no seu computador certifique-se de

755
00:29:08,159 --> 00:29:11,039
Confie nas pastas que você abre para eu

756
00:29:11,039 --> 00:29:12,960
Vou confiar em mim mesmo porque eu sou

757
00:29:12,960 --> 00:29:15,760
o criador desta pasta aqui e este

758
00:29:15,760 --> 00:29:18,159
vai abrir o código do estúdio visual

759
00:29:18,159 --> 00:29:20,559
agora em nosso vídeo de instalação que instalamos

760
00:29:20,559 --> 00:29:22,640
A extensão c plus para visual

761
00:29:22,640 --> 00:29:24,840
código do estúdio novamente se você não tem isso

762
00:29:24,840 --> 00:29:27,120
instalado por favor certifique-se de voltar

763
00:29:27,120 --> 00:29:29,200
e instalar e certifique-se de que isso está dizendo

764
00:29:29,200 --> 00:29:32,720
que isso está habilitado e agora queremos

765
00:29:32,720 --> 00:29:34,559
Use isso para escrever c plus plus

766
00:29:34,559 --> 00:29:36,799
Aplicações aqui nós vamos escrever um

767
00:29:36,799 --> 00:29:39,200
simples brinquedo c plus mais aplicação para

768
00:29:39,200 --> 00:29:42,240
apenas teste que nossos compiladores suportam c

769
00:29:42,240 --> 00:29:44,799
mais mais 20 e então vamos usar

770
00:29:44,799 --> 00:29:46,799
Isso como ponto de partida ou como

771
00:29:46,799 --> 00:29:49,600
modelo de projeto, então eu quero que você clique

772
00:29:49,600 --> 00:29:52,080
neste pequeno e mais ícone aqui

773
00:29:52,080 --> 00:29:53,840
e vamos criar um arquivo chamado

774
00:29:53,840 --> 00:29:56,159
em main.cpp

775
00:29:56,159 --> 00:29:58,880
E uma vez que você fizer isso, você será capaz de

776
00:29:58,880 --> 00:30:01,520
tipo c plus código neste ano, então nós

777
00:30:01,520 --> 00:30:03,120
Estou apenas começando aqui eu iria

778
00:30:03,120 --> 00:30:05,520
recomendo para digitar isso exatamente como eu faço

779
00:30:05,520 --> 00:30:08,640
Aqui, então vamos dizer incluir e

780
00:30:08,640 --> 00:30:11,520
Diga suporte de ângulo de abertura e diga io

781
00:30:11,520 --> 00:30:12,720
fluxo

782
00:30:12,720 --> 00:30:14,480
e nós vamos descer aqui e dizer

783
00:30:14,480 --> 00:30:15,840
E o principal

784
00:30:15,840 --> 00:30:18,960
e nós vamos entrar nestes encaracolados

785
00:30:18,960 --> 00:30:23,520
chaves e dizer auto resultado e você é

786
00:30:23,520 --> 00:30:26,240
Vou digitar exatamente o que eu toque aqui

787
00:30:26,240 --> 00:30:27,760
Não se preocupe, vamos ter uma chance

788
00:30:27,760 --> 00:30:30,159
para aprender sobre todas essas coisas aqui, então

789
00:30:30,159 --> 00:30:33,440
Eu vou colocar um par de parênteses

790
00:30:33,440 --> 00:30:36,960
E eu vou dizer 10. e eu vou

791
00:30:36,960 --> 00:30:39,600
para colocar um operador estranho aqui é

792
00:30:39,600 --> 00:30:42,159
chamado de operador da nave espacial, é apenas

793
00:30:42,159 --> 00:30:44,080
algo que podemos usar para testar que

794
00:30:44,080 --> 00:30:46,559
Compilador suporta mais mais 20 e

795
00:30:46,559 --> 00:30:48,240
nós vamos colocar um 20 aqui e depois

796
00:30:48,240 --> 00:30:50,880
nós vamos tentar ver se isso é

797
00:30:50,880 --> 00:30:53,200
Maior do que zero e nós vamos

798
00:30:53,200 --> 00:30:55,200
impeça isso, vamos dizer stdc

799
00:30:55,200 --> 00:30:57,360
fora novamente não se preocupe se você não sabe

800
00:30:57,360 --> 00:30:59,919
O que é isso é apenas um caminho para nós

801
00:30:59,919 --> 00:31:02,240
para testar e ver se o nosso compilador está indo

802
00:31:02,240 --> 00:31:05,200
para poder usar c mais mais 20.

803
00:31:05,200 --> 00:31:07,279
Vou dizer resultado aqui

804
00:31:07,279 --> 00:31:10,320
e este vai ser o nosso programa agora

805
00:31:10,320 --> 00:31:12,559
Queremos ter certeza de que compilamos isso

806
00:31:12,559 --> 00:31:14,720
programa para trazer seus compiladores em

807
00:31:14,720 --> 00:31:17,120
código de estúdio visual tudo que você precisa fazer é

808
00:31:17,120 --> 00:31:19,519
Venha para o menu do terminal aqui, então por favor

809
00:31:19,519 --> 00:31:20,720
Venha aqui

810
00:31:20,720 --> 00:31:22,559
e nós vamos ter

811
00:31:22,559 --> 00:31:25,519
uma opção para configurar tarefas que eu quero

812
00:31:25,519 --> 00:31:27,200
para clicar sobre isso

813
00:31:27,200 --> 00:31:28,799
E uma vez que você faça isso, você vai ver

814
00:31:28,799 --> 00:31:30,720
O código visual do estúdio vai encontrar

815
00:31:30,720 --> 00:31:33,919
os compiladores que acabamos de instalar você

816
00:31:33,919 --> 00:31:35,919
Veja que ele encontrou

817
00:31:35,919 --> 00:31:36,799
O que é

818
00:31:36,799 --> 00:31:40,000
gcc compilador nós instalamos em mingw você

819
00:31:40,000 --> 00:31:42,960
Veja que encontrou o compilador do clã

820
00:31:42,960 --> 00:31:45,200
Eu sei sobre o compilador g plus plus

821
00:31:45,200 --> 00:31:46,720
porque você pode ver o caminho aqui você

822
00:31:46,720 --> 00:31:50,080
pode ver c major w ben g plus dot

823
00:31:50,080 --> 00:31:52,799
exe é aqui que instalamos nosso g

824
00:31:52,799 --> 00:31:55,279
plus compilador e eu sei sobre o

825
00:31:55,279 --> 00:31:56,960
clank compilador porque é isso que é

826
00:31:56,960 --> 00:31:59,120
sendo encontrado aqui, por exemplo, sobre isso

827
00:31:59,120 --> 00:32:02,480
entrada aqui você vê isso diz cmajw bin

828
00:32:02,480 --> 00:32:05,279
clan plus plus para que quiséssemos configurar

829
00:32:05,279 --> 00:32:07,679
Estes dois compiladores aqui e mais tarde

830
00:32:07,679 --> 00:32:10,080
Estúdio visual poderia usá-los para construir

831
00:32:10,080 --> 00:32:12,480
nossos c plus mais 20 projetos

832
00:32:12,480 --> 00:32:14,240
Agora, o que vamos fazer é clicar

833
00:32:14,240 --> 00:32:17,039
O compilador g plus plus primeiro

834
00:32:17,039 --> 00:32:18,880
E quando fazemos que isso vai

835
00:32:18,880 --> 00:32:22,159
criar uma tarefa que json file em nosso

836
00:32:22,159 --> 00:32:24,640
projeto e você vê que ele criou

837
00:32:24,640 --> 00:32:27,679
uma pasta chamada dot vs código se eu clicar

838
00:32:27,679 --> 00:32:30,960
no meu arquivo cpp principal aqui e revelar

839
00:32:30,960 --> 00:32:33,440
em explorador

840
00:32:33,440 --> 00:32:35,360
Isso vai se abrir no meu sistema

841
00:32:35,360 --> 00:32:37,600
e você vê que isso criou um pontos

842
00:32:37,600 --> 00:32:40,240
vs pasta de código e se formos e estamos

843
00:32:40,240 --> 00:32:43,360
vai encontrar este arquivo tasks.json esta

844
00:32:43,360 --> 00:32:45,120
Vai ser a nossa configuração para

845
00:32:45,120 --> 00:32:47,840
configurar quais compiladores que

846
00:32:47,840 --> 00:32:50,080
Código de estúdio visual está usando para compilar

847
00:32:50,080 --> 00:32:53,679
nosso arquivo main.cpp aqui, portanto, se entrarmos

848
00:32:53,679 --> 00:32:55,519
Vai realmente ter tudo

849
00:32:55,519 --> 00:32:57,600
pronto para nós para que você veja isso

850
00:32:57,600 --> 00:32:59,840
vai usar o nosso g plus plus

851
00:32:59,840 --> 00:33:03,039
Compilador este é o caminho para ele e em

852
00:33:03,039 --> 00:33:05,919
nossas opções de args aqui temos o

853
00:33:05,919 --> 00:33:08,640
opções que passamos para o compilador para

854
00:33:08,640 --> 00:33:11,760
compilar o nosso programa aqui agora eu quero

855
00:33:11,760 --> 00:33:13,519
mudar isso para dizer que tipo de

856
00:33:13,519 --> 00:33:15,600
Compilador que estamos usando

857
00:33:15,600 --> 00:33:17,760
Vamos mudar o nível aqui

858
00:33:17,760 --> 00:33:19,840
para dizer a largura do mundo

859
00:33:19,840 --> 00:33:22,080
g plus plus e dizer a versão que eu acho

860
00:33:22,080 --> 00:33:24,399
Isso vai ser mais descritivo aqui

861
00:33:24,399 --> 00:33:26,960
Vamos salvar o mundo com g plus

862
00:33:26,960 --> 00:33:28,960
plus ou gcc

863
00:33:28,960 --> 00:33:31,159
e nós vamos dizer

864
00:33:31,159 --> 00:33:34,480
11.2.0 porque essa é a nossa versão aqui

865
00:33:34,480 --> 00:33:36,240
E o resto vai realmente ser

866
00:33:36,240 --> 00:33:38,399
o suficiente para que vamos tentar ver se nós podemos

867
00:33:38,399 --> 00:33:40,720
compile nosso programa aqui e veja o

868
00:33:40,720 --> 00:33:42,640
A coisa aqui imprimindo para fora

869
00:33:42,640 --> 00:33:43,519


870
00:33:43,519 --> 00:33:45,519
A outra coisa que precisamos fazer porque

871
00:33:45,519 --> 00:33:48,799
este programa está usando c plus mais 20 nós

872
00:33:48,799 --> 00:33:51,679
precisamos configurar nosso compilador para usar c

873
00:33:51,679 --> 00:33:54,480
mais 20. e uma maneira de fazer isso em

874
00:33:54,480 --> 00:33:56,559
gcc e você pode realmente procurar estes

875
00:33:56,559 --> 00:33:58,000
Coisas, por exemplo

876
00:33:58,000 --> 00:34:00,480
Se viermos ao nosso motor de busca aqui e

877
00:34:00,480 --> 00:34:04,000
Diga configure gcc para usar c plus mais 20

878
00:34:04,000 --> 00:34:06,240
ou mesmo gcc

879
00:34:06,240 --> 00:34:08,720
e dizer c mais mais 20. você pode procurar

880
00:34:08,720 --> 00:34:11,040
essas coisas e encontrar informações e

881
00:34:11,040 --> 00:34:13,359
É uma boa maneira de testar suas coisas

882
00:34:13,359 --> 00:34:14,159
aqui

883
00:34:14,159 --> 00:34:16,639
então vamos ver se podemos encontrar um link para

884
00:34:16,639 --> 00:34:18,879
ajudamos a ter um link de estouro de pilha

885
00:34:18,879 --> 00:34:22,000
Aqui para que possamos abrir isso e se nós

886
00:34:22,000 --> 00:34:23,520
Vamos e vamos encontrar um lote de

887
00:34:23,520 --> 00:34:25,919
Coisas, por exemplo, podemos dizer std c plus

888
00:34:25,919 --> 00:34:28,079
mais 20 aqui como uma opção para o nosso

889
00:34:28,079 --> 00:34:31,200
Compilador e isso vai trazer

890
00:34:31,200 --> 00:34:33,919
c plus mais 20 suporte em nosso gcc

891
00:34:33,919 --> 00:34:36,240
compilador para que eu vou copiar isso

892
00:34:36,240 --> 00:34:38,560
E eu vou voltar no meu visual

893
00:34:38,560 --> 00:34:40,480
Editor de código de estúdio

894
00:34:40,480 --> 00:34:43,280
e eu vou passar uma bandeira para ferver

895
00:34:43,280 --> 00:34:45,760
em c mais 20 modo e é algo que eu

896
00:34:45,760 --> 00:34:48,480
Acabei de sair da pilha transbordar aqui e nós

897
00:34:48,480 --> 00:34:50,399
vamos passar isso para o nosso compilador

898
00:34:50,399 --> 00:34:52,720
e colocar uma vírgula para tornar isso válido

899
00:34:52,720 --> 00:34:54,560
arquivo de configuração e eu estou indo para

900
00:34:54,560 --> 00:34:55,760
Feche este mesmo

901
00:34:55,760 --> 00:34:58,400
Agora, uma vez que temos isso aberto e queremos

902
00:34:58,400 --> 00:35:00,000
para construir isso, precisamos trazer uma

903
00:35:00,000 --> 00:35:01,680
Janela terminal para que nós vamos

904
00:35:01,680 --> 00:35:03,359
Trazei a janela do terminal para que possamos

905
00:35:03,359 --> 00:35:05,680
ver as coisas acontecendo e nós fazemos isso por

906
00:35:05,680 --> 00:35:07,440
vindo ao terminal e dizendo o novo

907
00:35:07,440 --> 00:35:09,040
O terminal

908
00:35:09,040 --> 00:35:11,760
e voltaremos ao terminal novamente

909
00:35:11,760 --> 00:35:14,640
e dizer que queremos executar uma tarefa em

910
00:35:14,640 --> 00:35:16,560
Este caso nós vamos estar executando o nosso

911
00:35:16,560 --> 00:35:20,400
mundo com gcc 1120 novamente se você é

912
00:35:20,400 --> 00:35:22,079
Usando uma versão mais recente, é isso que você

913
00:35:22,079 --> 00:35:25,280
usar e se clicarmos sobre esta coisa

914
00:35:25,280 --> 00:35:27,359
por favor, certifique-se de que você tem o cpp principal

915
00:35:27,359 --> 00:35:29,599
arquivo selecionado antes de fazer isso, então eu

916
00:35:29,599 --> 00:35:31,599
Tenho este selecionado e eu vou embora

917
00:35:31,599 --> 00:35:34,079
para executar a tarefa e eu vou clicar em

918
00:35:34,079 --> 00:35:36,079
Esta coisinha que você vai ver

919
00:35:36,079 --> 00:35:37,760
que isso vai dar início ao

920
00:35:37,760 --> 00:35:40,640
Processo para construir o nosso programa

921
00:35:40,640 --> 00:35:41,920
e nós vamos esperar por isso para

922
00:35:41,920 --> 00:35:43,359
Termine e você vai ver que

923
00:35:43,359 --> 00:35:46,160
está usando c plus mais 20 aqui estamos indo

924
00:35:46,160 --> 00:35:47,440
para ver que o mundo acabou

925
00:35:47,440 --> 00:35:51,200
Temos um arquivo main.exe

926
00:35:51,200 --> 00:35:55,359
Criado aqui, então se formos em nosso terminal

927
00:35:55,359 --> 00:35:58,480
em código de estúdio visual e clique em digitar

928
00:35:58,480 --> 00:35:59,359
E a

929
00:35:59,359 --> 00:36:01,599
digite claro e acertar enter isso está indo

930
00:36:01,599 --> 00:36:03,359
para limpar a tela, isso é algo

931
00:36:03,359 --> 00:36:05,920
Você pode fazer para esclarecer as coisas que podemos

932
00:36:05,920 --> 00:36:09,760
executar este binário main.exe diretamente aqui

933
00:36:09,760 --> 00:36:12,320
então nós vamos correr exe aqui e se

934
00:36:12,320 --> 00:36:14,880
você executá, vai dizer zero e

935
00:36:14,880 --> 00:36:17,200
Esta é uma indicação de que temos o nosso

936
00:36:17,200 --> 00:36:19,839
Editor de código de estúdio visual conectado

937
00:36:19,839 --> 00:36:22,320
para o nosso compilador gcc e podemos usar isso

938
00:36:22,320 --> 00:36:24,960
para compilar c plus aplicações e

939
00:36:24,960 --> 00:36:27,040
Esta é realmente a configuração com ele

940
00:36:27,040 --> 00:36:30,079
Agora você pode perguntar como eu sei assim como

941
00:36:30,079 --> 00:36:32,079
Eu sabia os passos a seguir para

942
00:36:32,079 --> 00:36:33,760
Faz com que isto funcione

943
00:36:33,760 --> 00:36:36,079
Bem se você chegar à guia de extensão aqui

944
00:36:36,079 --> 00:36:37,920
E antes mesmo de fazermos isso eu quero

945
00:36:37,920 --> 00:36:39,599
Trazei à vossa atenção que temos a

946
00:36:39,599 --> 00:36:42,160
Um monte de guias aqui no código do estúdio visual

947
00:36:42,160 --> 00:36:44,960
temos uma aba que diz arquivo eu acho que

948
00:36:44,960 --> 00:36:47,680
Um aqui dizendo explorador, temos um

949
00:36:47,680 --> 00:36:50,400
nós podemos usar para controle de versão se você

950
00:36:50,400 --> 00:36:52,480
Use algo como git ou o que quer que você

951
00:36:52,480 --> 00:36:54,400
Podemos usar isso, mas neste curso estamos

952
00:36:54,400 --> 00:36:56,400
principalmente vai usar o explorador

953
00:36:56,400 --> 00:36:58,800
tabulação aqui e o

954
00:36:58,800 --> 00:37:01,359
extensions tab para instalar as coisas e em

955
00:37:01,359 --> 00:37:03,280
Mais tarde, vou mostrar-lhe como usar

956
00:37:03,280 --> 00:37:06,000
a aba de depuração aqui ou executar uma aba de depuração

957
00:37:06,000 --> 00:37:07,520
Mas na maioria dos casos vamos ser

958
00:37:07,520 --> 00:37:10,320
usando a guia do explorador ou as extensões

959
00:37:10,320 --> 00:37:12,240
guia aqui, se você quiser, você pode clicar em

960
00:37:12,240 --> 00:37:14,320
Isso para fechar isso para que você tenha alguns

961
00:37:14,320 --> 00:37:16,480
mais espaço que você pode clicar novamente para trazer

962
00:37:16,480 --> 00:37:18,000
Estas são algumas coisas que você pode

963
00:37:18,000 --> 00:37:20,240
fazer em código de estúdio visual, mas eu estou indo

964
00:37:20,240 --> 00:37:22,880
para mostrar como configurar o seu

965
00:37:22,880 --> 00:37:24,880
compiladores onde eu tenho a informação, então

966
00:37:24,880 --> 00:37:27,200
Clique em extensões aqui

967
00:37:27,200 --> 00:37:29,200
e nós vamos encontrar o nosso cnc plus

968
00:37:29,200 --> 00:37:30,640
mais extensão

969
00:37:30,640 --> 00:37:32,960
Se rolarmos para baixo, vamos encontrar

970
00:37:32,960 --> 00:37:35,760
Tutoriais sobre como configurar isso em

971
00:37:35,760 --> 00:37:37,839
Compiladores diferentes, por exemplo, você pode

972
00:37:37,839 --> 00:37:39,440
Quebre esta abertura

973
00:37:39,440 --> 00:37:41,359
ver como montar um estúdio visual

974
00:37:41,359 --> 00:37:44,240
código para usar seu compilador do microsoft

975
00:37:44,240 --> 00:37:46,640
Se voltarmos, podemos ver um link para ver

976
00:37:46,640 --> 00:37:49,440
Como usar isso com mingw nas janelas

977
00:37:49,440 --> 00:37:51,680
Vamos clicar sobre isso

978
00:37:51,680 --> 00:37:53,920
E vamos ver o que mais temos nós podemos

979
00:37:53,920 --> 00:37:56,240
Volte aqui e podemos ver como

980
00:37:56,240 --> 00:37:58,640
Use isso com gcc em linux ou clango em

981
00:37:58,640 --> 00:38:00,560
um mac você pode realmente escolher o que quer que seja

982
00:38:00,560 --> 00:38:02,960
relevante para o seu sistema operacional, mas

983
00:38:02,960 --> 00:38:05,839
Neste caso, aqui estamos apenas usando o

984
00:38:05,839 --> 00:38:07,520
Windows sistema operacional para que estejamos indo

985
00:38:07,520 --> 00:38:10,720
para ver como usar isso com o mingw

986
00:38:10,720 --> 00:38:13,440
compilador que acabamos de instalar agora

987
00:38:13,440 --> 00:38:16,480
pode usar o compilador mingw e eu iria

988
00:38:16,480 --> 00:38:18,640
Recomendar ler sobre este todo

989
00:38:18,640 --> 00:38:21,040
Uma coisa para ter uma ideia sobre o que é

990
00:38:21,040 --> 00:38:24,160
Já temos nosso g plus

991
00:38:24,160 --> 00:38:26,240
plus compilador, então este é esse comando

992
00:38:26,240 --> 00:38:28,160
Vou trabalhar novamente se voltarmos para

993
00:38:28,160 --> 00:38:30,720
terminal aqui e executar g plus plus

994
00:38:30,720 --> 00:38:32,480
A versão eu acho que podemos ver que nós corremos

995
00:38:32,480 --> 00:38:34,160
Estes comandos aqui para ver essas coisas

996
00:38:34,160 --> 00:38:37,280
trabalhando para que tenhamos esse passo aqui e se

997
00:38:37,280 --> 00:38:39,359
Você se pergunta o que gdb é apenas um

998
00:38:39,359 --> 00:38:41,040
depurador que você pode usar para depurar seu

999
00:38:41,040 --> 00:38:43,520
programas e novamente se chegarmos ao nosso

1000
00:38:43,520 --> 00:38:47,200
terminal aqui e dizer gdb

1001
00:38:47,200 --> 00:38:48,720
Versão que vamos ter isso

1002
00:38:48,720 --> 00:38:51,119
disponível a partir da nossa instalação mingw

1003
00:38:51,119 --> 00:38:53,359
você pode ver que temos isso aqui, então

1004
00:38:53,359 --> 00:38:55,680
Isso está funcionando muito bem, você pode realmente

1005
00:38:55,680 --> 00:38:58,160
Siga isso e configure seu visual

1006
00:38:58,160 --> 00:39:00,640
instalação de código de estúdio, mas eu sou apenas

1007
00:39:00,640 --> 00:39:02,480
mostrando-lhe como fazer isso muito rápido

1008
00:39:02,480 --> 00:39:04,800
você pode ver que é isso que nós estabelecemos

1009
00:39:04,800 --> 00:39:07,359
em nosso arquivo de configuração, que é nosso

1010
00:39:07,359 --> 00:39:10,720
tarefas dot json arquivo agora uma coisa que você

1011
00:39:10,720 --> 00:39:14,079
pode fazer é modificar o arquivo task.json para

1012
00:39:14,079 --> 00:39:17,040
construir cada arquivo em seu projeto

1013
00:39:17,040 --> 00:39:18,480
E isso é algo que vai

1014
00:39:18,480 --> 00:39:20,960
tornar as coisas mais fáceis do que eu vou fazer

1015
00:39:20,960 --> 00:39:23,440
é voltar para o nosso código de estúdio visual

1016
00:39:23,440 --> 00:39:25,760
e encontrar o nosso projeto que somos

1017
00:39:25,760 --> 00:39:28,560
Vou abrir as nossas tarefas que json

1018
00:39:28,560 --> 00:39:31,200
arquivo que está vivendo em nosso dot vs código

1019
00:39:31,200 --> 00:39:32,320
pasta de trabalho

1020
00:39:32,320 --> 00:39:34,640
E eu vou tirar a loucura

1021
00:39:34,640 --> 00:39:37,200
Eu tenho em meus argumentos aqui eu estou indo

1022
00:39:37,200 --> 00:39:39,839
para selecionar tudo o que eu vou

1023
00:39:39,839 --> 00:39:41,200
excluir isso

1024
00:39:41,200 --> 00:39:43,760
e vou colocar em uma configuração

1025
00:39:43,760 --> 00:39:46,000
que estou usando meus projetos aqui para

1026
00:39:46,000 --> 00:39:48,560
tornar isso super fácil o que isso está fazendo

1027
00:39:48,560 --> 00:39:50,640
está dizendo ao compilador para construir em c

1028
00:39:50,640 --> 00:39:53,520
mais mais 20 modo que vai dizer

1029
00:39:53,520 --> 00:39:55,040
visual estúdio que vai dizer o

1030
00:39:55,040 --> 00:39:57,839
compilador para construir cada arquivo cpp

1031
00:39:57,839 --> 00:40:00,240
em nosso projeto, portanto, se tivermos vários

1032
00:40:00,240 --> 00:40:01,680
Arquivos que serão construídos

1033
00:40:01,680 --> 00:40:04,079
juntos e vamos especificar o

1034
00:40:04,079 --> 00:40:06,880
nome para o nosso arquivo de saída, por exemplo, se

1035
00:40:06,880 --> 00:40:09,040
Não queremos que o nosso executável binário

1036
00:40:09,040 --> 00:40:11,920
ser nomeado principalmente.exe nós podemos dar-lhe um

1037
00:40:11,920 --> 00:40:15,200
Nome e eu vou nomear o meu

1038
00:40:15,200 --> 00:40:17,599
galoster.exe no curso aqui i

1039
00:40:17,599 --> 00:40:19,359
Recomendar fazer o mesmo para que possamos

1040
00:40:19,359 --> 00:40:20,720
Realmente tem

1041
00:40:20,720 --> 00:40:23,040
Os mesmos hábitos que passamos pelo

1042
00:40:23,040 --> 00:40:24,880
curso aqui, mas é claro que você é livre

1043
00:40:24,880 --> 00:40:26,880
para usar o que quiser em seu c plus

1044
00:40:26,880 --> 00:40:29,119
além de programas aqui, então uma vez que você tem isso

1045
00:40:29,119 --> 00:40:31,760
você pode clicar em salvar aqui e isso é

1046
00:40:31,760 --> 00:40:33,839
indo para salvar o nosso arquivo json aqui eu posso

1047
00:40:33,839 --> 00:40:35,359
Feche este mesmo

1048
00:40:35,359 --> 00:40:37,760
E eu vou trazer o meu terminal por

1049
00:40:37,760 --> 00:40:39,280
Indo para a visão

1050
00:40:39,280 --> 00:40:41,280
E o terminal aqui vai

1051
00:40:41,280 --> 00:40:44,160
Trate meu terminal que eu tinha antes

1052
00:40:44,160 --> 00:40:46,800
e eu vou executar o comando claro

1053
00:40:46,800 --> 00:40:48,480
e bater em entrar

1054
00:40:48,480 --> 00:40:51,359
e eu vou fazer dir para mostrar o

1055
00:40:51,359 --> 00:40:52,400
Conteúdos de conteúdo

1056
00:40:52,400 --> 00:40:55,440
da minha pasta nas janelas aqui eu queria

1057
00:40:55,440 --> 00:40:58,160
remover o arquivo main.exe do arquivo

1058
00:40:58,160 --> 00:41:00,640
terminal aqui, então o que eu vou fazer

1059
00:41:00,640 --> 00:41:03,040
é dizer rm

1060
00:41:03,040 --> 00:41:05,520
E eu vou dizer o nome do

1061
00:41:05,520 --> 00:41:07,359
arquivo que eu quero remover eu vou dizer

1062
00:41:07,359 --> 00:41:08,240
Principal

1063
00:41:08,240 --> 00:41:11,359
exe e se eu acertar, digite o que

1064
00:41:11,359 --> 00:41:12,960
Vai acontecer o arquivo para

1065
00:41:12,960 --> 00:41:15,440
ir embora eu não vejo mais aqui eu

1066
00:41:15,440 --> 00:41:17,440
Quero construir novamente usando o meu novo

1067
00:41:17,440 --> 00:41:21,040
configurações em minhas tarefas, o arquivo json

1068
00:41:21,040 --> 00:41:23,920
Eu vou executar a tarefa para construir com

1069
00:41:23,920 --> 00:41:26,400
nosso compilador gcc

1070
00:41:26,400 --> 00:41:28,319
Isso vai construir de novo e você vê

1071
00:41:28,319 --> 00:41:30,480
que está usando as configurações que

1072
00:41:30,480 --> 00:41:32,880
Eu passei você vê que ele está construindo

1073
00:41:32,880 --> 00:41:35,760
Cada arquivo cpp no diretório

1074
00:41:35,760 --> 00:41:38,000
Aqui e vai gerar um

1075
00:41:38,000 --> 00:41:40,800
programa chamado galoster.exe e nós se nós

1076
00:41:40,800 --> 00:41:42,880
Olha aqui nós vamos encontrá-lo nós podemos

1077
00:41:42,880 --> 00:41:45,280
hit enter no terminal

1078
00:41:45,280 --> 00:41:47,599
e nós podemos digitar claro para limpar as coisas

1079
00:41:47,599 --> 00:41:50,640
fora e se fizermos o ir novamente, estamos

1080
00:41:50,640 --> 00:41:53,200
Vou ver que temos galo.exe

1081
00:41:53,200 --> 00:41:55,720
e nós podemos executá-lo fazendo

1082
00:41:55,720 --> 00:41:58,079
galoster.exe aqui e isso vai fazer

1083
00:41:58,079 --> 00:42:00,079
O que queremos isso é realmente tudo que você precisa

1084
00:42:00,079 --> 00:42:02,160
para fazer para conectar o código do estúdio visual a

1085
00:42:02,160 --> 00:42:05,119
seu compilador gcc agora vamos

1086
00:42:05,119 --> 00:42:07,200
Conecte o código do estúdio visual ao nosso clã

1087
00:42:07,200 --> 00:42:09,200
compilador que temos instalado

1088
00:42:09,200 --> 00:42:10,800
realmente quero ser capaz de usá-lo com

1089
00:42:10,800 --> 00:42:12,319
nosso projeto aqui e vamos embora

1090
00:42:12,319 --> 00:42:14,240
através dos sete passos novamente, então nós somos

1091
00:42:14,240 --> 00:42:15,760
Vou ao terminal e dizer

1092
00:42:15,760 --> 00:42:18,160
Configuração de tarefas

1093
00:42:18,160 --> 00:42:19,839
e nós vamos escolher algo que

1094
00:42:19,839 --> 00:42:22,960
Diz o compilador clanger e nós estamos

1095
00:42:22,960 --> 00:42:26,640
indo para encontrar clang plus plus, então vamos

1096
00:42:26,640 --> 00:42:29,680
Caça para isso eu tenho algo que diz

1097
00:42:29,680 --> 00:42:32,359
que aqui temos

1098
00:42:32,359 --> 00:42:34,480
cloneplusplus.exe vou clicar em

1099
00:42:34,480 --> 00:42:36,720
Isso e se eu fizer isso, isso vai

1100
00:42:36,720 --> 00:42:39,079
Adicione uma entrada no meu

1101
00:42:39,079 --> 00:42:41,599
tasks.json arquivo, então cuidado com isso i

1102
00:42:41,599 --> 00:42:43,280
Vou clicar sobre isso

1103
00:42:43,280 --> 00:42:46,960
e vamos quebrar este teste que json arquivo

1104
00:42:46,960 --> 00:42:48,880
Abra e você vai ver que isso

1105
00:42:48,880 --> 00:42:50,480
também vai criar outro

1106
00:42:50,480 --> 00:42:54,000
configuração para o mundo usando meu clang

1107
00:42:54,000 --> 00:42:56,160
Plus plus compilador

1108
00:42:56,160 --> 00:42:58,160
e novamente eu posso editar isso um pouco

1109
00:42:58,160 --> 00:43:00,800
Um pouco para dizer o que queremos, vamos olhar

1110
00:43:00,800 --> 00:43:02,640
A versão da nuvem que instalamos

1111
00:43:02,640 --> 00:43:06,720
para dizer que isso vai ser 12

1112
00:43:06,720 --> 00:43:07,839
0 - 0

1113
00:43:07,839 --> 00:43:10,400
1 então nós vamos dizer o mundo com o clank

1114
00:43:10,400 --> 00:43:11,760
plus plus

1115
00:43:11,760 --> 00:43:16,119
12 0 1 vamos dizer que aqui no nosso nível

1116
00:43:16,119 --> 00:43:19,119
12.0.1 podemos dizer isso aqui e

1117
00:43:19,119 --> 00:43:20,960
Você vê que está realmente fazendo o mesmo

1118
00:43:20,960 --> 00:43:23,599
o que fizemos com o nosso compilador gcc assim

1119
00:43:23,599 --> 00:43:26,240
O que eu posso realmente fazer é tudo

1120
00:43:26,240 --> 00:43:29,680
Eu fiz no meu compilador gcc eu posso

1121
00:43:29,680 --> 00:43:30,960
Copie isso

1122
00:43:30,960 --> 00:43:33,359
E eu vou tirar os argumentos

1123
00:43:33,359 --> 00:43:36,800
Eu tenho em meus args aqui e eu uso o que eu

1124
00:43:36,800 --> 00:43:39,359
ter no meu compilador gcc você pode ver que

1125
00:43:39,359 --> 00:43:41,359
você pode usar o compilador do cliente e

1126
00:43:41,359 --> 00:43:44,000
gcc compilador da mesma forma e isso é

1127
00:43:44,000 --> 00:43:46,560
Algo muito legal, então agora temos o

1128
00:43:46,560 --> 00:43:48,560
opção para usar dois compiladores e este é

1129
00:43:48,560 --> 00:43:50,720
muito legal, então vamos fechar o

1130
00:43:50,720 --> 00:43:52,480
Arquivo json e vai ser salvo

1131
00:43:52,480 --> 00:43:54,480
automaticamente

1132
00:43:54,480 --> 00:43:56,480
e nós vamos trazer o nosso terminal

1133
00:43:56,480 --> 00:43:58,000
Janela novamente

1134
00:43:58,000 --> 00:44:00,160
e vamos trazer isso um pouco e

1135
00:44:00,160 --> 00:44:03,359
nós vamos fazer dir nas janelas e

1136
00:44:03,359 --> 00:44:05,599
Vamos remover o binário novamente

1137
00:44:05,599 --> 00:44:08,480
nós vamos remover a lista.exe

1138
00:44:08,480 --> 00:44:10,400
e novamente o que você pode fazer você pode começar

1139
00:44:10,400 --> 00:44:12,240
digitando o nome do arquivo que você deseja

1140
00:44:12,240 --> 00:44:15,119
remover e bater a guia se você fizer isso

1141
00:44:15,119 --> 00:44:16,800
O terminal vai completar isso

1142
00:44:16,800 --> 00:44:18,960
para você e isso é muito legal, então se eu

1143
00:44:18,960 --> 00:44:20,880
fazer isso o arquivo vai desaparecer você

1144
00:44:20,880 --> 00:44:23,440
Veja que está indo aqui

1145
00:44:23,440 --> 00:44:25,200
E eu posso limpar

1146
00:44:25,200 --> 00:44:27,040
O que eu vou fazer é o mundo com

1147
00:44:27,040 --> 00:44:29,359
o compilador do clã pode fazer isso vindo

1148
00:44:29,359 --> 00:44:31,839
para o terminal eu vou dizer que eu

1149
00:44:31,839 --> 00:44:34,720
Quero executar uma tarefa e eu vou ser

1150
00:44:34,720 --> 00:44:37,119
dada uma opção que eu posso construir com

1151
00:44:37,119 --> 00:44:39,359
gcc então se eu escolher gcc aqui está indo

1152
00:44:39,359 --> 00:44:42,640
para ser usado, mas eu também posso usar o clã vamos

1153
00:44:42,640 --> 00:44:44,640
use clang aqui, então eu vou clicar em

1154
00:44:44,640 --> 00:44:46,160
Isto é

1155
00:44:46,160 --> 00:44:47,599
E você vai ver esse visual

1156
00:44:47,599 --> 00:44:49,280
O código do estúdio vai começar o

1157
00:44:49,280 --> 00:44:50,400
O processo do mundo

1158
00:44:50,400 --> 00:44:52,160
Isto vai construir o meu binário

1159
00:44:52,160 --> 00:44:54,720
executável e note que ele está usando c

1160
00:44:54,720 --> 00:44:56,960
mais mais 20 novamente a construção vai

1161
00:44:56,960 --> 00:44:58,800
Acabar com sucesso e eu terei um

1162
00:44:58,800 --> 00:45:00,640
binário aqui e isso vai ser tudo

1163
00:45:00,640 --> 00:45:04,000
Eu preciso fazer isso se eu acertar enter e correr

1164
00:45:04,000 --> 00:45:07,920
Meu binário tocando o nome

1165
00:45:07,920 --> 00:45:10,000
e apertando a conta isso vai

1166
00:45:10,000 --> 00:45:12,079
auto-completar se eu executá-lo, ele vai

1167
00:45:12,079 --> 00:45:14,640
Diga zero e isso é o que esperamos aqui

1168
00:45:14,640 --> 00:45:16,400
se você tiver algum tipo de erro, por favor

1169
00:45:16,400 --> 00:45:18,480
Tente corrigi-lo se você tiver um problema

1170
00:45:18,480 --> 00:45:20,640
Posso me perguntar e eu vou fazer o melhor que posso

1171
00:45:20,640 --> 00:45:22,240
para te ajudar

1172
00:45:22,240 --> 00:45:24,000
Ok, agora temos nossos dois compiladores

1173
00:45:24,000 --> 00:45:26,240
trabalhando, precisamos configurar o

1174
00:45:26,240 --> 00:45:29,359
Compilador do microsoft agora o compilador

1175
00:45:29,359 --> 00:45:31,359
de microsoft é um pouco estranho

1176
00:45:31,359 --> 00:45:33,359
Mais uma vez você pode ler sobre isso vindo

1177
00:45:33,359 --> 00:45:35,599
para a sua documentação de extensão

1178
00:45:35,599 --> 00:45:37,760
e usar o compilador a partir de

1179
00:45:37,760 --> 00:45:39,920
microsoft com código de estúdio visual em

1180
00:45:39,920 --> 00:45:41,680
janelas que você pode ler em tudo isso se

1181
00:45:41,680 --> 00:45:43,839
Você quer, mas eu só vou te mostrar

1182
00:45:43,839 --> 00:45:46,160
uma maneira rápida de fazer isso correr para que o

1183
00:45:46,160 --> 00:45:48,560
compilador da microsoft é especial em

1184
00:45:48,560 --> 00:45:51,359
que você tem que especificar o caminho para ele

1185
00:45:51,359 --> 00:45:53,440
Se abrirmos um regular

1186
00:45:53,440 --> 00:45:55,160
Janela terminal e dizer

1187
00:45:55,160 --> 00:45:58,319
cl.exe para chamar o compilador

1188
00:45:58,319 --> 00:45:59,839
Vamos ver que o terminal é

1189
00:45:59,839 --> 00:46:01,480
Vou dizer que

1190
00:46:01,480 --> 00:46:04,880
O compilador cl.exe não é reconhecido e

1191
00:46:04,880 --> 00:46:07,119
A razão é que não temos o próprio

1192
00:46:07,119 --> 00:46:09,520
configurações variáveis de ambiente para

1193
00:46:09,520 --> 00:46:11,839
sistema operacional para encontrar este compilador

1194
00:46:11,839 --> 00:46:14,160
Quando chamamos isso aqui, somos capazes

1195
00:46:14,160 --> 00:46:16,560
para usar g plus plus e clã porque nós

1196
00:46:16,560 --> 00:46:19,040
colocar as variáveis de ambiente no lugar

1197
00:46:19,040 --> 00:46:20,720
Se você se lembrar quando os instalamos

1198
00:46:20,720 --> 00:46:22,400
Fizemos algo assim que chegamos

1199
00:46:22,400 --> 00:46:25,440
O menu inicial e fizemos env que viemos

1200
00:46:25,440 --> 00:46:28,000
variáveis de ambiente aqui e colocamos

1201
00:46:28,000 --> 00:46:29,200
o caminho

1202
00:46:29,200 --> 00:46:32,160
para nossos compiladores em nosso ambiente

1203
00:46:32,160 --> 00:46:33,920
variáveis aqui você pode vê-las corretamente

1204
00:46:33,920 --> 00:46:36,160
Aqui para que não tenhamos a mesma coisa para

1205
00:46:36,160 --> 00:46:37,920
O compilador do microsoft e isso é

1206
00:46:37,920 --> 00:46:40,079
por uma razão, porque podemos ter

1207
00:46:40,079 --> 00:46:42,000
vários compiladores instalados a partir de

1208
00:46:42,000 --> 00:46:43,359
Microsoft

1209
00:46:43,359 --> 00:46:45,440
então se você tem vários compiladores

1210
00:46:45,440 --> 00:46:47,200
seria realmente complicado escolher

1211
00:46:47,200 --> 00:46:49,839
Em qual compilador você quer os caras

1212
00:46:49,839 --> 00:46:52,480
A Microsoft optou pela opção por você

1213
00:46:52,480 --> 00:46:54,800
O desenvolvedor para especificar qual compilador

1214
00:46:54,800 --> 00:46:57,680
Você quer correr vindo para o início

1215
00:46:57,680 --> 00:47:00,480
menu aqui e desenvolvedor de digitação

1216
00:47:00,480 --> 00:47:02,560
e escolher qual powershell para o

1217
00:47:02,560 --> 00:47:04,960
compilador que você deseja usar, por exemplo, se

1218
00:47:04,960 --> 00:47:07,359
Queremos usar o estúdio visual 2019

1219
00:47:07,359 --> 00:47:09,599
compilador podemos clicar sobre isso e, em seguida,

1220
00:47:09,599 --> 00:47:11,520
Vamos ter um terminal

1221
00:47:11,520 --> 00:47:13,119
que pode correr

1222
00:47:13,119 --> 00:47:15,359
o c plus compilador da microsoft

1223
00:47:15,359 --> 00:47:17,440
Por exemplo, se esperarmos que isso seja

1224
00:47:17,440 --> 00:47:20,880
Pronto e dizer cl.exe

1225
00:47:20,880 --> 00:47:22,160
nós vamos ver que nós vamos

1226
00:47:22,160 --> 00:47:23,920
Tenho uma mensagem dizendo que este é nosso

1227
00:47:23,920 --> 00:47:26,240
compilador podemos usá-lo como quisermos

1228
00:47:26,240 --> 00:47:28,079
Então, o que vamos fazer é configurar um

1229
00:47:28,079 --> 00:47:30,880
terminal como este e usar este terminal

1230
00:47:30,880 --> 00:47:33,040
para iniciar o código do estúdio visual e a

1231
00:47:33,040 --> 00:47:34,880
O código do estúdio visual vai começar em

1232
00:47:34,880 --> 00:47:36,079
o modo

1233
00:47:36,079 --> 00:47:38,000
onde ele pode encontrar o compilador a partir de

1234
00:47:38,000 --> 00:47:40,000
microsoft eu sei que isso é confuso, mas

1235
00:47:40,000 --> 00:47:41,839
Por favor, tenha paciência comigo, isso é o que precisamos

1236
00:47:41,839 --> 00:47:44,559
para fazer isso funcionar se começarmos

1237
00:47:44,559 --> 00:47:46,559
código de estúdio visual em um modo em que

1238
00:47:46,559 --> 00:47:48,720
Conheça as variáveis de ambiente

1239
00:47:48,720 --> 00:47:51,920
para o compilador da microsoft, vamos

1240
00:47:51,920 --> 00:47:54,800
tem a capacidade de dizer.cl.exe

1241
00:47:54,800 --> 00:47:56,880
e nós seremos capazes de usar esse direito

1242
00:47:56,880 --> 00:47:58,880
Aqui, mas você vê que não é

1243
00:47:58,880 --> 00:48:01,359
reconhecido agora, mas podemos usar o g plus

1244
00:48:01,359 --> 00:48:03,359
além do compilador se fizermos isso

1245
00:48:03,359 --> 00:48:04,480
versão

1246
00:48:04,480 --> 00:48:05,839
nós vamos ver que ele está disponível

1247
00:48:05,839 --> 00:48:08,480
nós podemos usá-lo nós podemos usar o clã plus mais

1248
00:48:08,480 --> 00:48:10,960
E se fizermos a versão também, vamos

1249
00:48:10,960 --> 00:48:12,720
para ver que podemos usar este pequeno rapaz

1250
00:48:12,720 --> 00:48:15,119
Aqui também queremos a capacidade de usar o

1251
00:48:15,119 --> 00:48:17,760
compilador do microsoft, mas para ter

1252
00:48:17,760 --> 00:48:20,079
O acesso a isso teremos que fechar o

1253
00:48:20,079 --> 00:48:22,640
instância de código de estúdio visual que temos aqui

1254
00:48:22,640 --> 00:48:24,160
E nós vamos voltar para o nosso

1255
00:48:24,160 --> 00:48:27,040
Projeto vamos ver se consigo encontrá-lo aqui

1256
00:48:27,040 --> 00:48:28,559
Vamos para a localização

1257
00:48:28,559 --> 00:48:30,720
onde temos nosso projeto e nós somos

1258
00:48:30,720 --> 00:48:32,319
Vai mudar para a localização do

1259
00:48:32,319 --> 00:48:34,720
projeto aqui para que eu possa pegar a localização

1260
00:48:34,720 --> 00:48:37,440
do meu projeto de código de estúdio visual que

1261
00:48:37,440 --> 00:48:39,839
Eu apenas atuo eu vou voltar para

1262
00:48:39,839 --> 00:48:41,920
Minha janela powershell que conhece

1263
00:48:41,920 --> 00:48:44,079
o caminho para o compilador c plus

1264
00:48:44,079 --> 00:48:46,800
da Microsoft e eu vou mudar

1265
00:48:46,800 --> 00:48:49,200
para a localização do meu projeto aqui, então

1266
00:48:49,200 --> 00:48:51,280
Eu vou dizer cd e colar no

1267
00:48:51,280 --> 00:48:53,920
caminho eu apenas copiei e se eu acertar Enter

1268
00:48:53,920 --> 00:48:56,000
Isso vai mudar para a minha localização

1269
00:48:56,000 --> 00:48:58,240
e eu realmente recomendo usar powershell

1270
00:48:58,240 --> 00:49:00,240
se você tem acesso a isso porque é

1271
00:49:00,240 --> 00:49:02,400
um pouco mais conveniente para usá-lo

1272
00:49:02,400 --> 00:49:05,200
Suporta mais comandos que você pode usar

1273
00:49:05,200 --> 00:49:07,599
no prompt de comando, mas novamente isso é

1274
00:49:07,599 --> 00:49:10,240
Vou ser sua escolha agora eu estou no

1275
00:49:10,240 --> 00:49:13,280
localização para o meu projeto se eu faço ls ou

1276
00:49:13,280 --> 00:49:14,960
dir

1277
00:49:14,960 --> 00:49:17,040
você pode ver que eu posso ver o meu cpp principal

1278
00:49:17,040 --> 00:49:19,040
arquivo pode ver o binário que geramos

1279
00:49:19,040 --> 00:49:22,079
Mais cedo, mas isso não é problema, então o que

1280
00:49:22,079 --> 00:49:24,800
Eu posso fazer aqui é dizer código

1281
00:49:24,800 --> 00:49:27,040
E eu digo um dot e isso vai

1282
00:49:27,040 --> 00:49:29,680
iniciar código de estúdio visual na corrente

1283
00:49:29,680 --> 00:49:32,480
pasta do nosso projeto ano assim que se você bater

1284
00:49:32,480 --> 00:49:34,160
Entrar, vamos esperar pelo visual

1285
00:49:34,160 --> 00:49:36,079
Código do estúdio para aparecer, ele vai

1286
00:49:36,079 --> 00:49:38,240
Venha com o projeto que tivemos em que

1287
00:49:38,240 --> 00:49:39,280
pasta de trabalho

1288
00:49:39,280 --> 00:49:41,359
E a coisa especial sobre

1289
00:49:41,359 --> 00:49:43,680
começar o código visual do estúdio desta forma é

1290
00:49:43,680 --> 00:49:45,040
que vai saber sobre o

1291
00:49:45,040 --> 00:49:47,520
Compilador da Microsoft se voltarmos

1292
00:49:47,520 --> 00:49:49,359
para o nosso terminal aqui

1293
00:49:49,359 --> 00:49:52,160
e claro e dizer cl.exe

1294
00:49:52,160 --> 00:49:53,839
Você vai ver que agora ele sabe

1295
00:49:53,839 --> 00:49:56,079
sobre compilador da Microsoft e nós

1296
00:49:56,079 --> 00:49:58,559
pode usá-lo para fazer as coisas, então vamos definir

1297
00:49:58,559 --> 00:50:00,400
Isso novamente se você quiser, você pode ler

1298
00:50:00,400 --> 00:50:02,720
sobre como fazer isso

1299
00:50:02,720 --> 00:50:05,200
na documentação do estúdio visual

1300
00:50:05,200 --> 00:50:07,280
código em si, mas novamente eu vou mostrar

1301
00:50:07,280 --> 00:50:08,880
Como fazer isso você pode ver que

1302
00:50:08,880 --> 00:50:11,200
É realmente a mesma coisa que eles estão fazendo

1303
00:50:11,200 --> 00:50:13,359
Aqui vamos voltar ao estúdio visual

1304
00:50:13,359 --> 00:50:15,520
código e nós vamos para o terminal

1305
00:50:15,520 --> 00:50:18,400
e queremos configurar uma tarefa

1306
00:50:18,400 --> 00:50:20,720
Agora você vê que temos o compilador

1307
00:50:20,720 --> 00:50:22,559
da Microsoft disponível você pode ver

1308
00:50:22,559 --> 00:50:25,520
que podemos usar isso aqui, então o que

1309
00:50:25,520 --> 00:50:28,599
Eu vou fazer é clicar em

1310
00:50:28,599 --> 00:50:31,359
Arquivo ativo do mundo do cl.exe

1311
00:50:31,359 --> 00:50:33,359
e isso vai adicionar uma nova entrada em

1312
00:50:33,359 --> 00:50:35,760
nosso arquivo de configuração e ele está indo

1313
00:50:35,760 --> 00:50:37,920
para abrir se formos aqui, vamos

1314
00:50:37,920 --> 00:50:40,800
descobrir que temos um comando para construir

1315
00:50:40,800 --> 00:50:43,200
usando o compilador da microsoft assim

1316
00:50:43,200 --> 00:50:45,359
Vamos mudar o nível aqui e eu digo

1317
00:50:45,359 --> 00:50:48,319
mundo com msvc eu acho que isso vai

1318
00:50:48,319 --> 00:50:50,720
ser mais descritivo e isso é realmente

1319
00:50:50,720 --> 00:50:52,880
Vou construir sua coisa agora eu estou indo

1320
00:50:52,880 --> 00:50:55,200
para mudar isso para que ele funcione

1321
00:50:55,200 --> 00:50:57,599
Tudo na pasta atual

1322
00:50:57,599 --> 00:50:59,920
E de novo eu vou remover

1323
00:50:59,920 --> 00:51:01,359
tudo aqui e colocar em um

1324
00:51:01,359 --> 00:51:03,599
configuração que eu tenho pronto em minha

1325
00:51:03,599 --> 00:51:05,760
sistema aqui é o que eu uso para todos

1326
00:51:05,760 --> 00:51:08,079
Meus projetos novamente, isso é apenas chamar

1327
00:51:08,079 --> 00:51:10,319
O compilador e dando opções para fazer

1328
00:51:10,319 --> 00:51:12,720
Coisas que só precisamos especificar que

1329
00:51:12,720 --> 00:51:14,720
quer usar o padrão de treliça do

1330
00:51:14,720 --> 00:51:17,280
c plus mais padrão e vai

1331
00:51:17,280 --> 00:51:18,640
Especificar a

1332
00:51:18,640 --> 00:51:20,240
os arquivos de entrada que vamos ser

1333
00:51:20,240 --> 00:51:22,000
construindo tudo na corrente

1334
00:51:22,000 --> 00:51:24,400
Pasta é o que estamos dizendo aqui

1335
00:51:24,400 --> 00:51:26,160
e o arquivo de saída será

1336
00:51:26,160 --> 00:51:28,480
chamado de galo.exe

1337
00:51:28,480 --> 00:51:31,520
se salvarmos isso dizendo ctrl s ou

1338
00:51:31,520 --> 00:51:33,119
command s

1339
00:51:33,119 --> 00:51:36,559
e fechar nossas tarefas do arquivo json que podemos

1340
00:51:36,559 --> 00:51:38,720
trazer para cima a nossa janela terminal indo para

1341
00:51:38,720 --> 00:51:41,200
ver e dizer o terminal aqui

1342
00:51:41,200 --> 00:51:44,319
e nós podemos descer e limpar podemos dizer

1343
00:51:44,319 --> 00:51:46,319
claro e bater enter

1344
00:51:46,319 --> 00:51:50,960
e se fizermos rm e dizer galo e bater

1345
00:51:50,960 --> 00:51:52,800
tab que isso vai remover o binário

1346
00:51:52,800 --> 00:51:55,760
nós geramos com o clang llvm

1347
00:51:55,760 --> 00:51:58,559
Compilador mais cedo agora queremos construir

1348
00:51:58,559 --> 00:52:01,040
com o compilador do microsoft assim

1349
00:52:01,040 --> 00:52:02,559
Vamos fazer isso, vamos dizer

1350
00:52:02,559 --> 00:52:04,640
terminal e vamos dizer que nós

1351
00:52:04,640 --> 00:52:07,680
Queremos executar uma tarefa, mas desta vez queremos

1352
00:52:07,680 --> 00:52:10,400
para construir com msvc isso é o que queremos

1353
00:52:10,400 --> 00:52:12,640
para fazer aqui se clicarmos sobre este pequeno

1354
00:52:12,640 --> 00:52:14,160
O que nós vamos começar a

1355
00:52:14,160 --> 00:52:16,680
processo para construir com o compilador a partir de

1356
00:52:16,680 --> 00:52:18,880
Microsoft e nós vamos esperar

1357
00:52:18,880 --> 00:52:21,760
O compilador para fazer sua coisa

1358
00:52:21,760 --> 00:52:23,440
E se esperarmos, vamos ver isso

1359
00:52:23,440 --> 00:52:25,680
O mundo terminou com sucesso e se

1360
00:52:25,680 --> 00:52:27,119
olhamos em nossa pasta que vamos ver

1361
00:52:27,119 --> 00:52:30,000
que temos nosso arquivo de saída e podemos

1362
00:52:30,000 --> 00:52:32,319
Venha em nosso terminal e bater para entrar

1363
00:52:32,319 --> 00:52:34,960
e fazer claro para esclarecer as coisas e se

1364
00:52:34,960 --> 00:52:38,319
dizemos galo assim

1365
00:52:38,319 --> 00:52:39,920
e bater em entrar você vai ver que

1366
00:52:39,920 --> 00:52:43,119
vai dizer zero e isso é

1367
00:52:43,119 --> 00:52:46,400
confirmação de que somos capazes de usar o nosso

1368
00:52:46,400 --> 00:52:49,119
Editor de código de estúdio visual e ser capaz de

1369
00:52:49,119 --> 00:52:51,520
usá-lo com todos os tipos de compiladores loucos

1370
00:52:51,520 --> 00:52:53,839
E isso é muito legal se você estiver

1371
00:52:53,839 --> 00:52:56,240
janelas que recomendo configurar isso

1372
00:52:56,240 --> 00:52:57,760
Porque é que vai fazer isso

1373
00:52:57,760 --> 00:53:00,400
mais fácil executar um c plus mais aplicações

1374
00:53:00,400 --> 00:53:02,079
Código do estúdio visual usando

1375
00:53:02,079 --> 00:53:04,880
Compiladores de última geração como o msvc

1376
00:53:04,880 --> 00:53:07,280
clone e gcc aqui e isso é realmente

1377
00:53:07,280 --> 00:53:09,839
legal agora temos tudo o que precisamos

1378
00:53:09,839 --> 00:53:12,240
começar a executar c plus aplicações

1379
00:53:12,240 --> 00:53:14,319
Mas antes eu deixar você ir, vamos te mostrar

1380
00:53:14,319 --> 00:53:16,160
Como você pode configurar isso para que você tenha

1381
00:53:16,160 --> 00:53:18,960
um tempo mais fácil no que diz respeito a

1382
00:53:18,960 --> 00:53:21,119
intellisense e qualquer coisa assim o que somos

1383
00:53:21,119 --> 00:53:22,720
Vou fazer, vamos para o nosso

1384
00:53:22,720 --> 00:53:24,400
ver menu e vamos escolher

1385
00:53:24,400 --> 00:53:25,920
paleta de comandos

1386
00:53:25,920 --> 00:53:28,880
E nisso vamos dizer c ou c

1387
00:53:28,880 --> 00:53:30,319
plus plus

1388
00:53:30,319 --> 00:53:32,480
Podemos dizer algo assim e nós somos

1389
00:53:32,480 --> 00:53:35,040
vai escolher editar configuração ui

1390
00:53:35,040 --> 00:53:36,720
Isso vai nos dar uma opção para

1391
00:53:36,720 --> 00:53:38,079
configurar as coisas

1392
00:53:38,079 --> 00:53:40,000
e eu quero que você configure as coisas

1393
00:53:40,000 --> 00:53:41,359
Novo sistema

1394
00:53:41,359 --> 00:53:43,920
Estou em um sistema de janelas

1395
00:53:43,920 --> 00:53:46,480
Vamos ver as opções que temos aqui eu sou

1396
00:53:46,480 --> 00:53:49,280
só vai ter a opção de ganhar32

1397
00:53:49,280 --> 00:53:52,880
Mas se cairmos, podemos especificar

1398
00:53:52,880 --> 00:53:54,640
As coisas que precisamos

1399
00:53:54,640 --> 00:53:56,559
código de estúdio visual configurado para

1400
00:53:56,559 --> 00:53:57,839
O exemplo vai nos dar

1401
00:53:57,839 --> 00:54:00,079
intellisense ou autocomplete e tudo

1402
00:54:00,079 --> 00:54:02,000
Tipos de coisas maiores usando o

1403
00:54:02,000 --> 00:54:04,240
configuração escolhemos aqui se quisermos que possamos

1404
00:54:04,240 --> 00:54:06,960
escolher o compilador gcc ou qualquer que eu sou

1405
00:54:06,960 --> 00:54:08,960
apenas indo para sair nas janelas msvc

1406
00:54:08,960 --> 00:54:11,359
compilador porque estou nas janelas aqui

1407
00:54:11,359 --> 00:54:13,359
mas saiba que você pode configurar estes

1408
00:54:13,359 --> 00:54:15,200
coisas agora, se descermos, vamos

1409
00:54:15,200 --> 00:54:17,359
Veja que temos a opção de configurar

1410
00:54:17,359 --> 00:54:20,000
O padrão c plus plus e o

1411
00:54:20,000 --> 00:54:22,079
Caminho do compilador que vai ser usado

1412
00:54:22,079 --> 00:54:23,599
Para descobrir as coisas, nós vamos ser

1413
00:54:23,599 --> 00:54:26,079
usando o compilador do microsoft aqui

1414
00:54:26,079 --> 00:54:27,760
Mas saiba que você tem a opção de

1415
00:54:27,760 --> 00:54:29,839
escolher qualquer outro compilador, por exemplo,

1416
00:54:29,839 --> 00:54:31,520
pode escolher o g plus plus compilador we

1417
00:54:31,520 --> 00:54:33,599
pode escolher o compilador de classe clank plus

1418
00:54:33,599 --> 00:54:35,599
você pode configurar essas coisas e se

1419
00:54:35,599 --> 00:54:37,359
Você precisa mudar isso, por favor volte

1420
00:54:37,359 --> 00:54:40,079
Aqui e fazer essas configurações aqui

1421
00:54:40,079 --> 00:54:41,440
nós vamos sair neste todo

1422
00:54:41,440 --> 00:54:43,839
em inteligência e o que vamos fazer

1423
00:54:43,839 --> 00:54:46,720
é configurar código de estúdio visual para usar

1424
00:54:46,720 --> 00:54:49,040
o padrão c plus mais 20 para que nós sejamos

1425
00:54:49,040 --> 00:54:50,839
Vou fazer esse direito

1426
00:54:50,839 --> 00:54:53,520
aqui e se você configurar isso você está indo

1427
00:54:53,520 --> 00:54:55,359
para ver que o código visual do estúdio está indo

1428
00:54:55,359 --> 00:54:58,160
para gerar uma propriedade cpp

1429
00:54:58,160 --> 00:55:00,559
arquivo que vai armazenar tudo isso

1430
00:55:00,559 --> 00:55:02,480
configurações aqui, então é realmente

1431
00:55:02,480 --> 00:55:03,760
Vou ser

1432
00:55:03,760 --> 00:55:06,319
uma configuração para o que escolhemos

1433
00:55:06,319 --> 00:55:08,559
nossa configuração aqui, então certifique-se de que

1434
00:55:08,559 --> 00:55:10,319
Escolher o que faz sentido de novo

1435
00:55:10,319 --> 00:55:12,720
recomendar usar c plus mais 20, mas se

1436
00:55:12,720 --> 00:55:14,400
você vai no topo você pode realmente usar qualquer

1437
00:55:14,400 --> 00:55:16,160
Compilador que você quer que eu vou usar o

1438
00:55:16,160 --> 00:55:18,559
compilador do microsoft isso é ok i

1439
00:55:18,559 --> 00:55:20,240
Vou usar o windows msvc

1440
00:55:20,240 --> 00:55:22,559
configuração para o intellisense aqui e

1441
00:55:22,559 --> 00:55:24,559
Eu vou fechar isso e nós estamos

1442
00:55:24,559 --> 00:55:26,400
realmente pronto para começar a usar visual

1443
00:55:26,400 --> 00:55:28,880
código de estúdio para montar c plus plus

1444
00:55:28,880 --> 00:55:31,040
aplicação, então vamos limpar isso um

1445
00:55:31,040 --> 00:55:32,799
Um pouco nós vamos ver o nosso

1446
00:55:32,799 --> 00:55:35,119
terminal e vamos remover o

1447
00:55:35,119 --> 00:55:37,920
lixo que foi gerado pelo compilador

1448
00:55:37,920 --> 00:55:40,720
de microsoft eu vou dizer rm e

1449
00:55:40,720 --> 00:55:42,559
Diga o galo

1450
00:55:42,559 --> 00:55:46,400
e eu posso remover o binário eu posso dizer rm

1451
00:55:46,400 --> 00:55:48,559
e dizer galo e dizer tab este é

1452
00:55:48,559 --> 00:55:51,040
indo para auto-completar e realmente remover

1453
00:55:51,040 --> 00:55:53,119
Coisas que eu não preciso vou remover

1454
00:55:53,119 --> 00:55:56,000
o arquivo pdb eu vou remover

1455
00:55:56,000 --> 00:55:57,680
Galo

1456
00:55:57,680 --> 00:56:00,319
Você sabe que eu vou remover o principal

1457
00:56:00,319 --> 00:56:04,640
arquivo de objeto, então vamos dizer ponto principal obj

1458
00:56:04,640 --> 00:56:07,599
e vou remover o ponto principal

1459
00:56:07,599 --> 00:56:10,640
ou vc não queremos remover o nosso cpd

1460
00:56:10,640 --> 00:56:13,599
arquivo para que agora temos um projeto que podemos usar

1461
00:56:13,599 --> 00:56:16,240
Como ponto de partida para escrever c e c

1462
00:56:16,240 --> 00:56:19,040
mais mais aplicações aqui para o que nós

1463
00:56:19,040 --> 00:56:21,520
Vai fazer nas próximas palestras

1464
00:56:21,520 --> 00:56:24,720
ou os próximos capítulos estão reutilizando

1465
00:56:24,720 --> 00:56:28,480
Esta coisa aqui como um projeto de modelo, então

1466
00:56:28,480 --> 00:56:31,440
O que eu posso fazer é chamar isso

1467
00:56:31,440 --> 00:56:34,720
c plus mais 20 projeto de modelo e

1468
00:56:34,720 --> 00:56:36,160
Vamos fazer isso aqui eu acho que eu preciso

1469
00:56:36,160 --> 00:56:37,839
close código de estúdio de vídeo caso contrário é

1470
00:56:37,839 --> 00:56:40,079
Vou reclamar, então eu vou ligar

1471
00:56:40,079 --> 00:56:43,040
este pequeno cara c mais 20 modelo

1472
00:56:43,040 --> 00:56:44,799
Projeto e

1473
00:56:44,799 --> 00:56:46,559
Mais tarde, quando começamos a aprender sobre c

1474
00:56:46,559 --> 00:56:48,559
mais plus proper que vamos usar

1475
00:56:48,559 --> 00:56:50,640
Isso como ponto de partida e queremos

1476
00:56:50,640 --> 00:56:52,960
Tenho que reconfigurar os compiladores nosso

1477
00:56:52,960 --> 00:56:55,599
O projeto estará pronto para uso

1478
00:56:55,599 --> 00:56:58,079
os compiladores que estabelecemos aqui, ou seja,

1479
00:56:58,079 --> 00:57:00,799
O compilador do microsoft o g plus

1480
00:57:00,799 --> 00:57:03,040
plus compilador e o clang plus plus

1481
00:57:03,040 --> 00:57:05,200
Compilador e isso vai ser realmente

1482
00:57:05,200 --> 00:57:07,440
legal isso é realmente tudo que eu tenho que compartilhar

1483
00:57:07,440 --> 00:57:09,200
Nesta palestra espero que você tenha

1484
00:57:09,200 --> 00:57:10,960
Código de estúdio configurado para usar tudo isso

1485
00:57:10,960 --> 00:57:13,200
Compiladores que vamos parar aqui em

1486
00:57:13,200 --> 00:57:15,119
Esta palestra é a próxima que vamos

1487
00:57:15,119 --> 00:57:16,880
Comece e veja como configurar o seu

1488
00:57:16,880 --> 00:57:19,280
ambiente de desenvolvimento em linux e

1489
00:57:19,280 --> 00:57:20,960
Vamos começar instalando

1490
00:57:20,960 --> 00:57:24,880
Compiladores em ubuntu 2004

1491
00:57:24,880 --> 00:57:27,040
Vá em frente e termine aqui e me encontre

1492
00:57:27,040 --> 00:57:29,119
lá nesta palestra vamos ver

1493
00:57:29,119 --> 00:57:31,920
Como instalar c plus compiladores em

1494
00:57:31,920 --> 00:57:34,640
O linux vamos trabalhar em um

1495
00:57:34,640 --> 00:57:38,799
sistema ubuntu 2004 e vamos instalar um

1496
00:57:38,799 --> 00:57:42,079
nova versão do gcc e o mais recente

1497
00:57:42,079 --> 00:57:44,559
versão eu posso colocar minhas mãos em para clang

1498
00:57:44,559 --> 00:57:47,839
llvm então vamos fazer isso ok, então aqui eu estou

1499
00:57:47,839 --> 00:57:52,240
na minha caixa de linux este é ubuntu 2004 se eu

1500
00:57:52,240 --> 00:57:55,440
Você nomeia e diz a

1501
00:57:55,440 --> 00:57:56,880
nós vamos ver as informações sobre

1502
00:57:56,880 --> 00:57:57,680
Isto é

1503
00:57:57,680 --> 00:57:59,839
e você terá que adaptar isso para

1504
00:57:59,839 --> 00:58:02,960
Seja qual for a distribuição do Linux em que você está

1505
00:58:02,960 --> 00:58:05,680
e para instalar gcc é muito simples

1506
00:58:05,680 --> 00:58:08,160
mas o problema é a última versão de

1507
00:58:08,160 --> 00:58:10,559
gcc no momento da gravação deste vídeo

1508
00:58:10,559 --> 00:58:13,760
é gcc 11 e não está disponível no

1509
00:58:13,760 --> 00:58:16,319
ubuntu agora, por exemplo, se você

1510
00:58:16,319 --> 00:58:17,920
Faça o que fazer

1511
00:58:17,920 --> 00:58:20,079
apt get install

1512
00:58:20,079 --> 00:58:22,480
gcc 11

1513
00:58:22,480 --> 00:58:24,799
É assim que você consegue

1514
00:58:24,799 --> 00:58:26,880
Se você fizer isso

1515
00:58:26,880 --> 00:58:28,319
você vai colocar sua senha

1516
00:58:28,319 --> 00:58:30,240
você vai ver que isso é realmente

1517
00:58:30,240 --> 00:58:33,119
Ainda não disponível corretamente, não podemos encontrar

1518
00:58:33,119 --> 00:58:36,160
Esta é a melhor versão que podemos instalar

1519
00:58:36,160 --> 00:58:38,319
é gcc 10 que eu tenho

1520
00:58:38,319 --> 00:58:40,480
instalado já neste sistema assim

1521
00:58:40,480 --> 00:58:43,040
nós vamos fazer gcc 10 é isso que

1522
00:58:43,040 --> 00:58:44,880
Vamos instalar aqui

1523
00:58:44,880 --> 00:58:46,400
E se fizermos isso, vamos ver

1524
00:58:46,400 --> 00:58:48,079
que isso já está disponível, você pode

1525
00:58:48,079 --> 00:58:50,559
também instalar g plus plus done i think

1526
00:58:50,559 --> 00:58:52,160
Você pode fazer isso

1527
00:58:52,160 --> 00:58:53,680
Tudo bem, então vamos executar o comando

1528
00:58:53,680 --> 00:58:56,480
Aqui e também vamos ver isso

1529
00:58:56,480 --> 00:58:58,480
já está disponível aqui, mas se você

1530
00:58:58,480 --> 00:59:00,240
Não tenho estes

1531
00:59:00,240 --> 00:59:02,079
Eles serão instalados e você

1532
00:59:02,079 --> 00:59:04,480
pode usá-los em seu sistema linux

1533
00:59:04,480 --> 00:59:07,040
Outra ferramenta que é necessária no linux

1534
00:59:07,040 --> 00:59:09,520
é o gdb depurador, então vamos fazer

1535
00:59:09,520 --> 00:59:12,079
Sudo aptTradução

1536
00:59:12,079 --> 00:59:13,839
obter a instalação

1537
00:59:13,839 --> 00:59:15,440
gtb (tradução)

1538
00:59:15,440 --> 00:59:17,359
Se você instalá-lo, será

1539
00:59:17,359 --> 00:59:19,200
instalado, mas eu já tenho

1540
00:59:19,200 --> 00:59:23,040
já instalado agora se eu faço gcc 10

1541
00:59:23,040 --> 00:59:25,839
no meu sistema aqui e dizer versão nós somos

1542
00:59:25,839 --> 00:59:27,520
Vou ver a versão impressa para fora

1543
00:59:27,520 --> 00:59:29,599
pode fazer g plus plus stand, podemos ver o

1544
00:59:29,599 --> 00:59:32,400
versão aqui vamos fazer isso para c plus

1545
00:59:32,400 --> 00:59:34,480
+ a vantagem

1546
00:59:34,480 --> 00:59:36,000
Vamos ver a versão aqui

1547
00:59:36,000 --> 00:59:40,000
Podemos até fazer versão gdb

1548
00:59:40,640 --> 00:59:42,400
E vai aparecer, vamos esperar

1549
00:59:42,400 --> 00:59:44,319
para isso nós vamos ver o meu gdp

1550
00:59:44,319 --> 00:59:46,880
versão aqui e agora eu posso usar estes

1551
00:59:46,880 --> 00:59:50,000
compiladores para compilar c plus mais código em

1552
00:59:50,000 --> 00:59:53,119
minha caixa de linux aqui, então isso completa o nosso

1553
00:59:53,119 --> 00:59:56,319
etapas para instalar um compilador gcc no linux

1554
00:59:56,319 --> 00:59:57,920
nós vamos ver como podemos obter um

1555
00:59:57,920 --> 01:00:00,559
Segure o compilador clang

1556
01:00:00,559 --> 01:00:03,040
em nossa caixa de linux aqui e é realmente

1557
01:00:03,040 --> 01:00:05,359
simples tudo que você precisa fazer é fazer

1558
01:00:05,359 --> 01:00:07,599
apt get install

1559
01:00:07,599 --> 01:00:10,160
e vamos instalar o clang 12

1560
01:00:10,160 --> 01:00:12,160
porque essa é a versão mais recente no

1561
01:00:12,160 --> 01:00:14,480
tempo de gravação deste vídeo se o fizermos

1562
01:00:14,480 --> 01:00:15,920
Isso nós vamos ver que está indo

1563
01:00:15,920 --> 01:00:17,920
para instalar já instalá-lo

1564
01:00:17,920 --> 01:00:20,079
Aqui, mas se você não tiver instalado

1565
01:00:20,079 --> 01:00:22,319
ele vai instalar no seu sistema e

1566
01:00:22,319 --> 01:00:24,160
Isso vai te dar todas as ferramentas

1567
01:00:24,160 --> 01:00:26,000
Você precisa compilar com o clã

1568
01:00:26,000 --> 01:00:28,559
Compilador sobre este ubuntu em particular

1569
01:00:28,559 --> 01:00:30,559
sistema que essas instalações serão

1570
01:00:30,559 --> 01:00:33,440
instalado no meu diretório de usuário bin, então se

1571
01:00:33,440 --> 01:00:37,440
Eu vejo lá e faço análises para mostrar

1572
01:00:37,440 --> 01:00:39,040
Tudo aqui dentro

1573
01:00:39,040 --> 01:00:41,119
e role para cima, vamos encontrar tudo

1574
01:00:41,119 --> 01:00:42,960
as versões para o clã que você vê que eu tenho

1575
01:00:42,960 --> 01:00:45,839
várias versões clang 10 11 12

1576
01:00:45,839 --> 01:00:48,799
e nós temos clã mais mais variância de

1577
01:00:48,799 --> 01:00:51,280
Eu acho que nós fazemos bem nós temos clank

1578
01:00:51,280 --> 01:00:53,920
mais e mais e clã aqui e isso é

1579
01:00:53,920 --> 01:00:55,760
Vou fazer o que queremos, nós temos o

1580
01:00:55,760 --> 01:00:58,640
Combinador de clã e compilador gcc

1581
01:00:58,640 --> 01:01:01,359
instalado em nosso sistema aqui agora, se você

1582
01:01:01,359 --> 01:01:03,599
Quer obter a última versão do gcc

1583
01:01:03,599 --> 01:01:05,280
instalado em seu sistema

1584
01:01:05,280 --> 01:01:08,880
Uma maneira fácil que eu encontrei é passar por um

1585
01:01:08,880 --> 01:01:11,280
gerenciador de pacotes chamado homebrew's

1586
01:01:11,280 --> 01:01:12,880
Procure por isso

1587
01:01:12,880 --> 01:01:14,319
Se você procura por isso, você está

1588
01:01:14,319 --> 01:01:16,000
Vou encontrá-lo e se você quiser você pode

1589
01:01:16,000 --> 01:01:18,240
instale-o em seu sistema linux

1590
01:01:18,240 --> 01:01:20,400
E quando você instalá-lo, ele vai

1591
01:01:20,400 --> 01:01:23,680
Estar basicamente pronto para usar

1592
01:01:23,680 --> 01:01:25,359
e para instalá-lo eu acho que há um

1593
01:01:25,359 --> 01:01:28,000
comando lá instalar cerveja em casa

1594
01:01:28,000 --> 01:01:30,720
Vamos fazer isso instalar aqui e se fizermos

1595
01:01:30,720 --> 01:01:32,160
A instalação

1596
01:01:32,160 --> 01:01:34,799
Devemos encontrar um link para instalar isso

1597
01:01:34,799 --> 01:01:37,359
Vamos encontrar um link eu acho que eles têm um

1598
01:01:37,359 --> 01:01:39,359
link você pode copiar aha é este pequeno

1599
01:01:39,359 --> 01:01:42,240
A coisa aqui você pode copiá-lo em

1600
01:01:42,240 --> 01:01:44,000
seu terminal e ele vai instalar

1601
01:01:44,000 --> 01:01:45,839
Home brew em seu sistema

1602
01:01:45,839 --> 01:01:48,480
e quando você tem cerveja em casa instalada

1603
01:01:48,480 --> 01:01:50,240
você pode passar por isso para instalar o

1604
01:01:50,240 --> 01:01:52,480
última versão do gcc, por exemplo, se nós

1605
01:01:52,480 --> 01:01:54,400
busca por homo azul

1606
01:01:54,400 --> 01:01:57,920
gcc em nosso motor de busca aqui

1607
01:01:57,920 --> 01:02:00,400
Vamos encontrar todas as informações

1608
01:02:00,400 --> 01:02:03,039
para instalar isso através da cerveja caseira e

1609
01:02:03,039 --> 01:02:05,599
você só tem que fazer bro instalar gcc e

1610
01:02:05,599 --> 01:02:07,359
Isso vai instalar isso em seu

1611
01:02:07,359 --> 01:02:09,039
sistema e você vai ver que

1612
01:02:09,039 --> 01:02:11,280
vai instalar a versão mais recente

1613
01:02:11,280 --> 01:02:13,520
no momento da gravação deste vídeo

1614
01:02:13,520 --> 01:02:15,520
Isto é o que você deve fazer, por exemplo

1615
01:02:15,520 --> 01:02:19,280
se voltarmos para a nossa caixa de linux nós podemos fazer

1616
01:02:19,280 --> 01:02:21,760
vamos cd em nosso diretório home e

1617
01:02:21,760 --> 01:02:23,599
nós vamos dizer cerveja

1618
01:02:23,599 --> 01:02:26,160
instalar gcc

1619
01:02:26,160 --> 01:02:28,000
E vai me dizer que é

1620
01:02:28,000 --> 01:02:30,319
já instalado porque eu instalei

1621
01:02:30,319 --> 01:02:31,280
Isto é

1622
01:02:31,280 --> 01:02:33,039
Mas se você não tiver instalado, é

1623
01:02:33,039 --> 01:02:34,960
indo para instalá-lo e você faz isso

1624
01:02:34,960 --> 01:02:37,839
Depois de ter passado pelos passos

1625
01:02:37,839 --> 01:02:39,760
para instalar

1626
01:02:39,760 --> 01:02:41,920
o gerente de pacote de cerveja em casa em seu

1627
01:02:41,920 --> 01:02:44,079
sistema e você faz isso apenas copiando

1628
01:02:44,079 --> 01:02:45,839
Este link e colagem que em seu

1629
01:02:45,839 --> 01:02:48,000
terminal e batendo em entrar e é

1630
01:02:48,000 --> 01:02:49,839
Vou dar instruções sobre o que você

1631
01:02:49,839 --> 01:02:52,559
pode fazer para que isso seja instalado corretamente em

1632
01:02:52,559 --> 01:02:54,799
Seu sistema aqui, então isso é muito legal

1633
01:02:54,799 --> 01:02:56,880
então, se você quiser o mais recente absoluto

1634
01:02:56,880 --> 01:02:59,839
versão em gcc esta é uma maneira que você tem

1635
01:02:59,839 --> 01:03:01,760
para segurá-lo sem realmente ir

1636
01:03:01,760 --> 01:03:04,160
através dos passos complexos para construir o

1637
01:03:04,160 --> 01:03:07,359
compilador você mesmo no linux ok é

1638
01:03:07,359 --> 01:03:09,599
levando mais algum tempo aqui eu sou apenas

1639
01:03:09,599 --> 01:03:11,359
Vou matar isso porque eu já

1640
01:03:11,359 --> 01:03:14,480
ter a última versão do gcc aqui se i

1641
01:03:14,480 --> 01:03:19,359
do jcc 11 no linux e na versão do

1642
01:03:19,359 --> 01:03:21,760
Eu vou ver que eu tenho 11 2 e

1643
01:03:21,760 --> 01:03:24,160
foi instalado através de homebrew e se

1644
01:03:24,160 --> 01:03:26,079
Você deixa esta corrida para a conclusão é

1645
01:03:26,079 --> 01:03:28,079
vamos instalar isso no seu computador

1646
01:03:28,079 --> 01:03:30,559
Não temos que esperar por isso agora

1647
01:03:30,559 --> 01:03:33,599
ter a versão mais recente do gcc em um

1648
01:03:33,599 --> 01:03:35,839
sistema ubuntu também temos o mais recente

1649
01:03:35,839 --> 01:03:38,000
versão do clã isso completa o nosso

1650
01:03:38,000 --> 01:03:40,480
tutorial sobre como configurar compiladores em

1651
01:03:40,480 --> 01:03:42,799
linux nós vamos parar aqui neste

1652
01:03:42,799 --> 01:03:45,119
dar palestra este que vamos instalar

1653
01:03:45,119 --> 01:03:47,599
código de estúdio visual no sistema linux

1654
01:03:47,599 --> 01:03:49,440
E então, no próximo, vamos

1655
01:03:49,440 --> 01:03:51,839
link código visual do estúdio para estes

1656
01:03:51,839 --> 01:03:54,079
Compiladores e ser capaz de usar visual

1657
01:03:54,079 --> 01:03:56,799
código de tipo de código de estúdio e compilar o nosso

1658
01:03:56,799 --> 01:03:59,760
programas usando esses dois compiladores aqui

1659
01:03:59,760 --> 01:04:01,520
então vá em frente e termine aqui e conheça

1660
01:04:01,520 --> 01:04:03,599
Eu na próxima palestra

1661
01:04:03,599 --> 01:04:05,359
Nesta palestra vamos ver como

1662
01:04:05,359 --> 01:04:08,319
para instalar o editor de código de estúdio visual

1663
01:04:08,319 --> 01:04:11,039
em um sistema linux e novamente nós seremos

1664
01:04:11,039 --> 01:04:15,280
trabalhando em nosso sistema ubuntu 2004 aqui

1665
01:04:15,280 --> 01:04:17,119
então vamos para o site para

1666
01:04:17,119 --> 01:04:18,960
código de estúdio visual e baixar o nosso

1667
01:04:18,960 --> 01:04:22,000
binário e instalá-lo em nosso linux

1668
01:04:22,000 --> 01:04:24,319
sistema aqui está bem, então aqui estamos no

1669
01:04:24,319 --> 01:04:26,960
site para código de estúdio visual que você pode

1670
01:04:26,960 --> 01:04:29,039
chegar lá procurando por estúdio visual

1671
01:04:29,039 --> 01:04:31,119
código em seu motor de busca e você está

1672
01:04:31,119 --> 01:04:33,359
indo para pousar aqui e tudo o que realmente

1673
01:04:33,359 --> 01:04:34,720
Tenho que fazer

1674
01:04:34,720 --> 01:04:36,880
é ir para baixo para encontrar nossos links de download

1675
01:04:36,880 --> 01:04:38,640
nós vamos ver isso para Debian e

1676
01:04:38,640 --> 01:04:41,440
ubuntu podemos baixar aqui mas você pode

1677
01:04:41,440 --> 01:04:43,440
Encontre também algo específico para outros

1678
01:04:43,440 --> 01:04:45,920
distribuição bem, então vamos

1679
01:04:45,920 --> 01:04:49,280
Pegue a versão de 64 bits do debian ubuntu

1680
01:04:49,280 --> 01:04:51,839
aqui porque esse é o meu sistema e você está

1681
01:04:51,839 --> 01:04:53,440
Vou encontrar o que faz sentido para

1682
01:04:53,440 --> 01:04:56,079
Sua distribuição, então vamos pegar isso

1683
01:04:56,079 --> 01:04:58,319
Aqui vamos pegar o link, então se

1684
01:04:58,319 --> 01:05:00,000
Você clica sobre isso

1685
01:05:00,000 --> 01:05:01,920
Isso vai dar início ao download

1686
01:05:01,920 --> 01:05:04,480
processo e você verá isso baixado

1687
01:05:04,480 --> 01:05:07,039
em seu sistema e uma vez que você tem isso

1688
01:05:07,039 --> 01:05:09,200
baixados, você vai instalá-lo

1689
01:05:09,200 --> 01:05:11,520
e em ubuntu você pode simplesmente clicar duas vezes

1690
01:05:11,520 --> 01:05:13,920
sobre isso para instalá-lo ou você pode instalar

1691
01:05:13,920 --> 01:05:16,400
como você instalar qualquer pacote debian

1692
01:05:16,400 --> 01:05:19,520
em um sistema linux, por exemplo, se você é

1693
01:05:19,520 --> 01:05:22,319
inseguro sobre como instalar pacotes debian

1694
01:05:22,319 --> 01:05:24,960
Tudo o que você precisa fazer é fazer uma pesquisa simples

1695
01:05:24,960 --> 01:05:28,079
então vamos fazer google.com e ir lá e

1696
01:05:28,079 --> 01:05:30,319
Vamos ver como instalar

1697
01:05:30,319 --> 01:05:32,880
para instalar o debian

1698
01:05:32,880 --> 01:05:34,160
Pacotes

1699
01:05:34,160 --> 01:05:35,680
em ubuntu

1700
01:05:35,680 --> 01:05:38,720
2004 então esta é a nossa versão aqui e

1701
01:05:38,720 --> 01:05:40,000
Você vai encontrar um monte de

1702
01:05:40,000 --> 01:05:42,240
Instruções sobre como fazer isso é

1703
01:05:42,240 --> 01:05:44,799
Vou ser muito simples para que possamos ir

1704
01:05:44,799 --> 01:05:47,920
para baixo e encontrar uma maneira de instalar assim todos

1705
01:05:47,920 --> 01:05:51,359
Você tem que fazer é dizer que você faz dpkga

1706
01:05:51,359 --> 01:05:53,119
Diga-me e você passa o nome do

1707
01:05:53,119 --> 01:05:54,640
pacote e isso vai instalar

1708
01:05:54,640 --> 01:05:56,799
código de estúdio visual no seu sistema uma vez

1709
01:05:56,799 --> 01:05:58,720
Você faz isso, você terá estúdio visual

1710
01:05:58,720 --> 01:06:01,119
código instalado e você estará pronto para

1711
01:06:01,119 --> 01:06:03,839
Inicá-lo e usá-lo em seu sistema aqui

1712
01:06:03,839 --> 01:06:05,520
uma vez instalado você terá o

1713
01:06:05,520 --> 01:06:08,160
capacidade de entrar no seu sistema aqui para

1714
01:06:08,160 --> 01:06:11,440
exemplo e diga código dot e isso é

1715
01:06:11,440 --> 01:06:13,359
abrir um código de estúdio visual

1716
01:06:13,359 --> 01:06:15,520
Na sua instância do seu sistema, vamos aguardar

1717
01:06:15,520 --> 01:06:17,440
Isso para subir para que você realmente veja

1718
01:06:17,440 --> 01:06:18,559
Isto é

1719
01:06:18,559 --> 01:06:20,160
Tudo bem, então isso vai abrir o visual

1720
01:06:20,160 --> 01:06:22,240
sistema de coordenadas de estúdio e você pode

1721
01:06:22,240 --> 01:06:24,880
começar a usá-lo como vamos fazer no

1722
01:06:24,880 --> 01:06:27,039
próxima palestra OK uma vez que você tem um visual

1723
01:06:27,039 --> 01:06:29,440
código de estúdio instalado e iniciado

1724
01:06:29,440 --> 01:06:31,440
seu sistema linux é a primeira coisa

1725
01:06:31,440 --> 01:06:32,799
Você precisa fazer

1726
01:06:32,799 --> 01:06:35,200
é instalar a extensão que é

1727
01:06:35,200 --> 01:06:37,520
permitindo que você faça algum c e c

1728
01:06:37,520 --> 01:06:40,000
mais e para fazer isso você virá

1729
01:06:40,000 --> 01:06:43,280
para esta guia aqui que diz extensão e

1730
01:06:43,280 --> 01:06:45,760
em nossa caixa de pesquisa você pode começar a digitar c

1731
01:06:45,760 --> 01:06:47,520
e c mais mais

1732
01:06:47,520 --> 01:06:50,000
e você vai ter uma entrada que

1733
01:06:50,000 --> 01:06:53,280
diz microsoft aqui, por favor selecione

1734
01:06:53,280 --> 01:06:55,119
Isto e isto vai ser

1735
01:06:55,119 --> 01:06:56,640
Extensão que você precisa instalar você é

1736
01:06:56,640 --> 01:06:58,160
Vou clicar em instalar e é

1737
01:06:58,160 --> 01:06:59,520
indo para a instalação

1738
01:06:59,520 --> 01:07:02,400
E isso é o que permite um estúdio visual

1739
01:07:02,400 --> 01:07:05,119
código para fazer algum c plus mais programação

1740
01:07:05,119 --> 01:07:07,200
E isso é muito legal se você quiser

1741
01:07:07,200 --> 01:07:09,839
pode verificar como usá-lo no linux e

1742
01:07:09,839 --> 01:07:11,760
Você vai ter instruções sobre como

1743
01:07:11,760 --> 01:07:13,520
para fazer isso, mas vamos fazer isso no

1744
01:07:13,520 --> 01:07:15,440
próxima palestra e mostrar como

1745
01:07:15,440 --> 01:07:18,240
configurar código de estúdio visual para usar o

1746
01:07:18,240 --> 01:07:20,799
compiladores que temos instalado em um

1747
01:07:20,799 --> 01:07:22,799
palestra anterior, então vamos contar

1748
01:07:22,799 --> 01:07:25,039
código de estúdio visual para usar nosso cliente

1749
01:07:25,039 --> 01:07:26,720
compilador, vamos dizer a ele para usar

1750
01:07:26,720 --> 01:07:29,039
nosso compilador gcc e teremos a

1751
01:07:29,039 --> 01:07:31,039
flexibilidade para chegar ao terminal e

1752
01:07:31,039 --> 01:07:33,760
escolher qual compilador queremos usar e

1753
01:07:33,760 --> 01:07:35,920
nós vamos fazer tudo isso no próximo

1754
01:07:35,920 --> 01:07:38,640
palestra, então vá em frente e termine aqui

1755
01:07:38,640 --> 01:07:40,799
e me encontrar lá

1756
01:07:40,799 --> 01:07:42,880
Nesta palestra vamos configurar

1757
01:07:42,880 --> 01:07:45,920
nosso editor de código de estúdio visual para usar o

1758
01:07:45,920 --> 01:07:49,039
compiladores que acabamos de instalar em um

1759
01:07:49,039 --> 01:07:51,039
Poucas palestras anteriores para que possamos

1760
01:07:51,039 --> 01:07:53,119
digitar nosso código em nosso estúdio visual

1761
01:07:53,119 --> 01:07:56,400
Editor de código como fazemos aqui e nós

1762
01:07:56,400 --> 01:07:58,640
passar o código através do compilador

1763
01:07:58,640 --> 01:08:01,839
para gerar um binário que, por sua vez,

1764
01:08:01,839 --> 01:08:04,400
correr em nosso sistema linux aqui este é

1765
01:08:04,400 --> 01:08:06,319
O que queremos fazer, queremos visual

1766
01:08:06,319 --> 01:08:08,400
código de estúdio para usar os compiladores que nós

1767
01:08:08,400 --> 01:08:10,640
instalado assim vamos cabeça para o nosso

1768
01:08:10,640 --> 01:08:13,680
linux box e fazer isso ok aqui estou

1769
01:08:13,680 --> 01:08:15,920
minha caixa linux esta é a corrente

1770
01:08:15,920 --> 01:08:18,560
diretório onde eu estou nisso é onde eu

1771
01:08:18,560 --> 01:08:21,040
Vou fazer minhas coisas aqui, então eu estou

1772
01:08:21,040 --> 01:08:24,319
vai criar uma pasta e chamá-la de

1773
01:08:24,319 --> 01:08:26,799
modelo de projeto vamos fazer isso, nós somos

1774
01:08:26,799 --> 01:08:27,960
Vou dizer que

1775
01:08:27,960 --> 01:08:31,040
mkdir e nós vamos dizer c plus plus

1776
01:08:31,040 --> 01:08:33,279
Projeto de 20 templates eu acho que isso é

1777
01:08:33,279 --> 01:08:34,640
Vou fazer isso

1778
01:08:34,640 --> 01:08:37,199
ou podemos até dizer cpp porque eu não sou

1779
01:08:37,199 --> 01:08:39,040
Certifique-se de que os sinais de mais aqui não estão indo

1780
01:08:39,040 --> 01:08:41,679
para nos dar um problema, vamos jogar

1781
01:08:41,679 --> 01:08:44,319
O lado seguro e vamos criar

1782
01:08:44,319 --> 01:08:46,960
esta pasta e nós vamos cd em

1783
01:08:46,960 --> 01:08:48,319
Esta pasta

1784
01:08:48,319 --> 01:08:50,560
Tudo bem quando estamos nesta pasta, estamos

1785
01:08:50,560 --> 01:08:52,880
abrir esta pasta no visual

1786
01:08:52,880 --> 01:08:55,440
código de estúdio e a maneira mais fácil de fazer

1787
01:08:55,440 --> 01:08:56,239
que

1788
01:08:56,239 --> 01:08:57,679
uma vez que você tem código de estúdio visual

1789
01:08:57,679 --> 01:09:00,400
instalado é apenas para digitar código e tipo

1790
01:09:00,400 --> 01:09:01,359
dot

1791
01:09:01,359 --> 01:09:03,199
e você basicamente estará dizendo o

1792
01:09:03,199 --> 01:09:05,440
sistema operacional para abrir o estúdio visual

1793
01:09:05,440 --> 01:09:08,239
código na pasta atual aqui, então eu estou

1794
01:09:08,239 --> 01:09:10,000
indo para bater enter

1795
01:09:10,000 --> 01:09:13,359
e isso vai chutá-lo aberto e eu

1796
01:09:13,359 --> 01:09:15,520
Confie nesta pasta porque acabei de criar

1797
01:09:15,520 --> 01:09:18,080
Isso e estamos no nosso projeto aqui o

1798
01:09:18,080 --> 01:09:20,080
A primeira coisa que vamos fazer é

1799
01:09:20,080 --> 01:09:23,359
criar um arquivo cpp principal, então vamos fazer isso

1800
01:09:23,359 --> 01:09:25,520
e eu fiz isso clicando no plus

1801
01:09:25,520 --> 01:09:26,799
O ícone aqui

1802
01:09:26,799 --> 01:09:29,920
e i digitou o nome do arquivo e

1803
01:09:29,920 --> 01:09:32,480
Eu vou colocar algum código fictício

1804
01:09:32,480 --> 01:09:34,640
Aqui que queremos usar nosso iniciador

1805
01:09:34,640 --> 01:09:36,640
Código que vamos dizer

1806
01:09:36,640 --> 01:09:39,520
iostream e nós vamos colocar em nosso

1807
01:09:39,520 --> 01:09:41,359
código aqui vamos dizer principal e

1808
01:09:41,359 --> 01:09:43,199
novamente você não tem que digitar tudo isso se

1809
01:09:43,199 --> 01:09:45,120
Você quer que você possa obter o código a partir do

1810
01:09:45,120 --> 01:09:47,279
seção de recursos sobre a palestra para que você

1811
01:09:47,279 --> 01:09:49,279
pode copiar esse código que aqui e

1812
01:09:49,279 --> 01:09:51,600
estar no seu caminho alegre porque nós não temos

1813
01:09:51,600 --> 01:09:53,359
realmente começou a aprender sobre c plus

1814
01:09:53,359 --> 01:09:55,440
Além disso, estamos a criar o ambiente

1815
01:09:55,440 --> 01:09:57,760
então não se estresse aqui

1816
01:09:57,760 --> 01:09:59,679
Este é apenas um código simples para testar

1817
01:09:59,679 --> 01:10:02,480
nossos compiladores para ver se eles suportam c

1818
01:10:02,480 --> 01:10:04,800
mais 20 porque queremos usar o

1819
01:10:04,800 --> 01:10:07,360
Carta padrão, podemos colocar as mãos

1820
01:10:07,360 --> 01:10:10,400
Aqui, então vamos fazer iguais

1821
01:10:10,400 --> 01:10:12,480
digite exatamente o que eu digitei aqui, então nós somos

1822
01:10:12,480 --> 01:10:14,239
Vou dizer 10

1823
01:10:14,239 --> 01:10:15,920
e nós vamos colocar isso estranho

1824
01:10:15,920 --> 01:10:18,640
Operador e dizer 20 e queremos ver

1825
01:10:18,640 --> 01:10:19,760
Se isto for

1826
01:10:19,760 --> 01:10:22,239
A loucura aqui é maior do que zero

1827
01:10:22,239 --> 01:10:24,239
É o que queremos fazer e nós vamos

1828
01:10:24,239 --> 01:10:27,920
Diga stdc para fora e o mesmo resultado ok, então

1829
01:10:27,920 --> 01:10:30,480
digitar exatamente o que eu digito aqui e como nós

1830
01:10:30,480 --> 01:10:31,920
Progresso no curso que vamos fazer

1831
01:10:31,920 --> 01:10:34,000
dar sentido a toda essa loucura que vemos

1832
01:10:34,000 --> 01:10:38,320
Então, agora que temos um arquivo cpp

1833
01:10:38,320 --> 01:10:40,880
contendo o código para o nosso c plus plus

1834
01:10:40,880 --> 01:10:44,320
programa que queremos compilar isso e nós

1835
01:10:44,320 --> 01:10:46,239
precisa dizer ao código do estúdio visual qual

1836
01:10:46,239 --> 01:10:48,159
compilador que vai usar para compilar

1837
01:10:48,159 --> 01:10:50,640
Este programa aqui para nos dar um binário

1838
01:10:50,640 --> 01:10:52,560
que podemos correr para o que vamos

1839
01:10:52,560 --> 01:10:55,520
Faze chegar ao terminal aqui

1840
01:10:55,520 --> 01:10:57,120
e nós vamos dizer que nós queremos

1841
01:10:57,120 --> 01:10:58,960
Configuração de tarefas

1842
01:10:58,960 --> 01:11:00,960
e a tarefa é realmente um conjunto de

1843
01:11:00,960 --> 01:11:02,880
Instruções que você dá ao estúdio visual

1844
01:11:02,880 --> 01:11:05,920
código sobre como levar o seu c plus plus

1845
01:11:05,920 --> 01:11:08,960
e transformar isso em um binário que

1846
01:11:08,960 --> 01:11:11,199
pode rodar nesse sistema aqui para que seja

1847
01:11:11,199 --> 01:11:12,800
O que queremos fazer queremos dizer

1848
01:11:12,800 --> 01:11:15,280
código de estúdio visual que compilador é

1849
01:11:15,280 --> 01:11:16,719
indo para usar, vamos configurar

1850
01:11:16,719 --> 01:11:18,800
tarefa aqui e você vai ver isso

1851
01:11:18,800 --> 01:11:21,280
ele vai descobrir muitos compiladores em

1852
01:11:21,280 --> 01:11:24,080
Meu sistema aqui você vê que temos clã 10

1853
01:11:24,080 --> 01:11:27,600
clang 11 clã 12 e nós também devemos ter

1854
01:11:27,600 --> 01:11:30,719
gcc 11 se continuarmos rolando para baixo, estamos

1855
01:11:30,719 --> 01:11:33,679
Vou encontrar esses garomezinhos aqui eu

1856
01:11:33,679 --> 01:11:36,400
tenho muitos compiladores neste sistema, então eu

1857
01:11:36,400 --> 01:11:38,080
Eu vou escolher

1858
01:11:38,080 --> 01:11:38,880
O que é

1859
01:11:38,880 --> 01:11:40,400
compilador de gcc

1860
01:11:40,400 --> 01:11:42,480
que é instalado através de cerveja caseira

1861
01:11:42,480 --> 01:11:44,320
Isto é o que eu vou escolher aqui

1862
01:11:44,320 --> 01:11:46,880
você diz que está dizendo g mais mais 11, mas

1863
01:11:46,880 --> 01:11:48,960
e você tem acesso a g plus mais 10 você

1864
01:11:48,960 --> 01:11:51,360
Também pode usar que vai funcionar

1865
01:11:51,360 --> 01:11:53,199
com o que queremos fazer neste curso

1866
01:11:53,199 --> 01:11:55,760
Aqui principalmente, então eu vou escolher o

1867
01:11:55,760 --> 01:11:58,560
O melhor eu tenho em termos de gcc

1868
01:11:58,560 --> 01:12:01,199
e isso vai criar uma entrada em

1869
01:12:01,199 --> 01:12:04,719
nossas tarefas dot json file para construir e executar

1870
01:12:04,719 --> 01:12:06,719
Este programa aqui e é isso que somos

1871
01:12:06,719 --> 01:12:09,120
indo fazer ok você vê que está usando

1872
01:12:09,120 --> 01:12:12,480
Este compilador em particular e uma coisa

1873
01:12:12,480 --> 01:12:14,560
Podemos fazer antes de tentar construir isso

1874
01:12:14,560 --> 01:12:16,560
Podemos mudar o nível aqui para fazê-lo

1875
01:12:16,560 --> 01:12:17,760
Um pouquinho

1876
01:12:17,760 --> 01:12:19,920
Mais descritivo, então vamos salvar

1877
01:12:19,920 --> 01:12:21,360
o mundo

1878
01:12:21,360 --> 01:12:24,640
com o Gcc

1879
01:12:25,000 --> 01:12:27,679
11.2.0 se eu estiver correto

1880
01:12:27,679 --> 01:12:30,080
E isso é tudo que podemos salvar isso

1881
01:12:30,080 --> 01:12:33,199
e nós podemos fechar este arquivo json e se

1882
01:12:33,199 --> 01:12:35,199
Trazemos uma janela terminal que podemos fazer

1883
01:12:35,199 --> 01:12:37,679
Isso batendo no terminal aqui e

1884
01:12:37,679 --> 01:12:40,640
Escolhendo um novo terminal

1885
01:12:40,640 --> 01:12:42,320
Isso vai abrir a corrente

1886
01:12:42,320 --> 01:12:46,000
localização, por exemplo, se fizermos pwd em

1887
01:12:46,000 --> 01:12:49,040
este terminal aqui vamos usar minúsculo i

1888
01:12:49,040 --> 01:12:50,400
Acho que é isso que queremos, estamos indo

1889
01:12:50,400 --> 01:12:52,480
para ver a localização aqui é meu

1890
01:12:52,480 --> 01:12:55,120
projeto para construir eu possa chegar

1891
01:12:55,120 --> 01:12:56,560
O terminal

1892
01:12:56,560 --> 01:12:59,360
e eu escolho executar a tarefa e eu estou indo para

1893
01:12:59,360 --> 01:13:02,400
escolha a tarefa de compilar com meu gcc

1894
01:13:02,400 --> 01:13:05,440
instalação aqui se eu escolher isso

1895
01:13:05,440 --> 01:13:08,400
Vai dar início ao processo de solda

1896
01:13:08,400 --> 01:13:09,600
E você vai ver que

1897
01:13:09,600 --> 01:13:11,920
gibberish que tenho aqui não é suportado

1898
01:13:11,920 --> 01:13:13,280
Porque o

1899
01:13:13,280 --> 01:13:15,760
O compilador não está configurado para usar o c

1900
01:13:15,760 --> 01:13:18,080
mais mais 20. então tudo o que realmente precisamos

1901
01:13:18,080 --> 01:13:22,400
fazer é voltar ao nosso comando e dizer-lhe

1902
01:13:22,400 --> 01:13:24,560
para usar c mais mais 20. e nós podemos fazer

1903
01:13:24,560 --> 01:13:26,960
ao passar uma instrução específica

1904
01:13:26,960 --> 01:13:29,840
para o compilador usar c plus mais 20

1905
01:13:29,840 --> 01:13:32,000
Como nós fazemos na linha 10 aqui, então nós somos

1906
01:13:32,000 --> 01:13:35,040
indo dizer std é igual a c mais mais 20.

1907
01:13:35,040 --> 01:13:36,640
Vamos salvar isso um pouco

1908
01:13:36,640 --> 01:13:38,159
E eu realmente queria que você visse isso

1909
01:13:38,159 --> 01:13:39,679
O problema aqui, porque muitas pessoas são

1910
01:13:39,679 --> 01:13:41,840
Vou esquecer isso e nós vamos

1911
01:13:41,840 --> 01:13:43,679
Tente construir novamente certificando-nos de que estamos

1912
01:13:43,679 --> 01:13:46,239
selecionando o arquivo principal cpp aqui, então

1913
01:13:46,239 --> 01:13:49,120
vamos para a tarefa de executar terminal e usar

1914
01:13:49,120 --> 01:13:51,360
O nosso compilador

1915
01:13:51,360 --> 01:13:53,199
e esperar que ele faça a sua coisa que você é

1916
01:13:53,199 --> 01:13:55,840
Vou ver que o mundo já terminou

1917
01:13:55,840 --> 01:13:58,000
com sucesso

1918
01:13:58,000 --> 01:14:00,640
e se voltarmos ao nosso terminal aqui

1919
01:14:00,640 --> 01:14:02,960
e fazer ls nós vamos ver que nós

1920
01:14:02,960 --> 01:14:05,280
ter um arquivo chamado main

1921
01:14:05,280 --> 01:14:07,920
e se nós corremos, devemos ver um zero assim

1922
01:14:07,920 --> 01:14:10,320
Vamos dizer o principal aqui

1923
01:14:10,320 --> 01:14:11,760
E se nós corrermos, vamos ver um

1924
01:14:11,760 --> 01:14:14,239
zero significando que o nosso programa está em execução

1925
01:14:14,239 --> 01:14:16,480
e trabalhando corretamente, somos capazes de

1926
01:14:16,480 --> 01:14:19,600
compilar um projeto c plus em um linux

1927
01:14:19,600 --> 01:14:22,960
sistema aqui agora, se você quiser ver como eu

1928
01:14:22,960 --> 01:14:24,960
surgiu a informação para usar o

1929
01:14:24,960 --> 01:14:27,920
tax json arquivo por favor volte para o

1930
01:14:27,920 --> 01:14:30,320
extensions tab aqui

1931
01:14:30,320 --> 01:14:33,199
e escolher o c e c plus plus

1932
01:14:33,199 --> 01:14:35,440
Extensão, vamos clicar sobre isso

1933
01:14:35,440 --> 01:14:36,560
E nós vamos ver tudo

1934
01:14:36,560 --> 01:14:38,960
Instruções sobre como usar esse cara em

1935
01:14:38,960 --> 01:14:41,760
o sistema linux aqui, então gcc em linux nós

1936
01:14:41,760 --> 01:14:43,120
Pode escolher este

1937
01:14:43,120 --> 01:14:44,159
E nós vamos ver tudo

1938
01:14:44,159 --> 01:14:46,320
informações aqui agora você pode ler sobre

1939
01:14:46,320 --> 01:14:48,400
Tudo isso se você quiser, mas o que eu estou indo

1940
01:14:48,400 --> 01:14:51,040
fazer é ir ao código do estúdio visual e

1941
01:14:51,040 --> 01:14:52,880
mostrar exatamente o que você precisa fazer para

1942
01:14:52,880 --> 01:14:55,360
conseguir isso para trabalhar o que eu quero fazer em

1943
01:14:55,360 --> 01:14:57,920
Há isso para compilar

1944
01:14:57,920 --> 01:15:00,719
Tudo no que eu quero fazer é fazer

1945
01:15:00,719 --> 01:15:03,440
definir o que eu realmente quero fazer é para o que

1946
01:15:03,440 --> 01:15:06,640
Eu realmente queria fazer isso

1947
01:15:06,640 --> 01:15:09,199
de modo que ele compila cada cpp

1948
01:15:09,199 --> 01:15:11,760
arquivo no meu diretório aqui e eu posso fazer

1949
01:15:11,760 --> 01:15:13,679
Isso ao colocar em

1950
01:15:13,679 --> 01:15:15,920
um conjunto de instruções que preparei

1951
01:15:15,920 --> 01:15:17,199
de antemão

1952
01:15:17,199 --> 01:15:18,960
Então nós vamos dizer isso para compilar em

1953
01:15:18,960 --> 01:15:21,120
c plus mais 20 modo que vamos dizer

1954
01:15:21,120 --> 01:15:24,159
ele para compilar cada arquivo cpp em

1955
01:15:24,159 --> 01:15:26,159
Este diretório e então vamos

1956
01:15:26,159 --> 01:15:28,719
especificar o nome do arquivo de saída para o nosso

1957
01:15:28,719 --> 01:15:31,120
binário agora este é o código que eu usei em

1958
01:15:31,120 --> 01:15:33,440
Janelas que eu preciso adaptá-lo para ser

1959
01:15:33,440 --> 01:15:35,280
específico para o linux

1960
01:15:35,280 --> 01:15:36,080
Então,

1961
01:15:36,080 --> 01:15:37,280
Vamos ver o que eles dizem no

1962
01:15:37,280 --> 01:15:40,480
documentação lá e nós podemos

1963
01:15:40,480 --> 01:15:42,400
Podemos rolar um pouco e

1964
01:15:42,400 --> 01:15:44,239
nós vamos ver que eles usam

1965
01:15:44,239 --> 01:15:46,000
barras aqui, então é isso que nós somos

1966
01:15:46,000 --> 01:15:47,679
usar em código de vídeo visual para

1967
01:15:47,679 --> 01:15:50,719
jogar pelo seguro para que possamos dizer isso

1968
01:15:50,719 --> 01:15:53,760
uma barra traseira e isso é uma barra traseira

1969
01:15:53,760 --> 01:15:56,159
E vamos tentar construir isso e nós somos

1970
01:15:56,159 --> 01:15:57,840
Vou ver o que acontece aqui, isto é

1971
01:15:57,840 --> 01:16:00,080
Vou construir nosso projeto em c plus

1972
01:16:00,080 --> 01:16:02,239
mais 20 modo que vamos construir

1973
01:16:02,239 --> 01:16:04,719
cada arquivo cpp no projeto e

1974
01:16:04,719 --> 01:16:07,280
a saída será chamada de galo este

1975
01:16:07,280 --> 01:16:09,440
É o que queremos fazer aqui vamos salvar

1976
01:16:09,440 --> 01:16:10,560
Isso para cima

1977
01:16:10,560 --> 01:16:13,600
e eu vou fechar este arquivo json

1978
01:16:13,600 --> 01:16:15,840
E eu vou trazer meu terminal por

1979
01:16:15,840 --> 01:16:19,679
vindo para ver e salvar um terminal aqui

1980
01:16:19,679 --> 01:16:23,120
e eu posso remover o arquivo main.exe ou

1981
01:16:23,120 --> 01:16:25,360
O executável principal que eu tinha lá se eu

1982
01:16:25,360 --> 01:16:28,880
do lsuc, ele se foi, mas agora, se tentarmos e

1983
01:16:28,880 --> 01:16:31,840
Compilar com o compilador gcc

1984
01:16:31,840 --> 01:16:33,199
nós vamos ver o que você vê

1985
01:16:33,199 --> 01:16:35,280
O mundo é bom e nós temos um binário

1986
01:16:35,280 --> 01:16:37,679
chamado galo e podemos executá-lo aqui se

1987
01:16:37,679 --> 01:16:39,920
Nós fazemos o galo, nós vamos vê-lo correr

1988
01:16:39,920 --> 01:16:41,760
e dar-nos um zero e isso é realmente

1989
01:16:41,760 --> 01:16:43,760
Tudo o que precisamos fazer agora temos isso

1990
01:16:43,760 --> 01:16:45,679
Trabalhando para

1991
01:16:45,679 --> 01:16:48,239
nosso compilador gcc, mas queríamos o mesmo

1992
01:16:48,239 --> 01:16:50,640
para um compilador clanger e nós queremos o

1993
01:16:50,640 --> 01:16:52,239
flexibilidade para poder mudar

1994
01:16:52,239 --> 01:16:54,880
compiladores vindo aqui e apenas

1995
01:16:54,880 --> 01:16:57,440
Selecionar a tarefa certa, então vamos fazer

1996
01:16:57,440 --> 01:16:59,120
Isso vamos configurar o clã, nós somos

1997
01:16:59,120 --> 01:17:01,040
indo para o terminal que queremos

1998
01:17:01,040 --> 01:17:03,199
configurar uma tarefa e nós vamos

1999
01:17:03,199 --> 01:17:04,800
escolher o melhor que temos em termos de

2000
01:17:04,800 --> 01:17:07,600
clang que acontece de ser clang

2001
01:17:07,600 --> 01:17:09,679
mais 12 aqui, então vamos

2002
01:17:09,679 --> 01:17:11,840
escolha isso e isso vai adicionar um

2003
01:17:11,840 --> 01:17:14,120
entrada em nosso

2004
01:17:14,120 --> 01:17:16,640
tasks.json arquivo que vamos mudar

2005
01:17:16,640 --> 01:17:18,960
para dizer que queremos construir com

2006
01:17:18,960 --> 01:17:21,199
Cl, vamos fazer isso, vamos dizer

2007
01:17:21,199 --> 01:17:23,840
Mundo com o clang

2008
01:17:23,840 --> 01:17:26,360
Eu acho que temos

2009
01:17:26,360 --> 01:17:29,360
12.0.1 se eu me lembro corretamente, mas nós

2010
01:17:29,360 --> 01:17:30,480
Pode perguntar

2011
01:17:30,480 --> 01:17:33,040
nosso terminal aqui vamos para o terminal

2012
01:17:33,040 --> 01:17:36,000
e nós vamos dizer clang mais mais

2013
01:17:36,000 --> 01:17:37,840
e 12 essa é a versão e nós somos

2014
01:17:37,840 --> 01:17:39,920
Vou perguntar qual é a sua versão

2015
01:17:39,920 --> 01:17:42,320
vamos nos dizer em detalhes e se nós

2016
01:17:42,320 --> 01:17:44,560
Espere, vamos ver essa velocidade

2017
01:17:44,560 --> 01:17:47,600
no terminal aqui e isso acontece com

2018
01:17:47,600 --> 01:17:50,480
ser clank versão 1200

2019
01:17:50,480 --> 01:17:52,000
Então é isso que vamos dizer em nosso

2020
01:17:52,000 --> 01:17:53,520
arquivo aqui

2021
01:17:53,520 --> 01:17:56,560
solda com clã 12 0 0

2022
01:17:56,560 --> 01:18:00,320
para ser super claro sobre isso

2023
01:18:00,320 --> 01:18:02,800
E uh isso é realmente tudo o que precisamos

2024
01:18:02,800 --> 01:18:05,600
O fazer é colocado nas instruções

2025
01:18:05,600 --> 01:18:07,920
para construir em c plus mais 20 mod exatamente

2026
01:18:07,920 --> 01:18:10,560
o que fizemos para Gcc aqui, então eu estou indo

2027
01:18:10,560 --> 01:18:14,080
para copiar isso e colocar isso na minha

2028
01:18:14,080 --> 01:18:16,239
argumentos aqui eu estou eu vou tomar

2029
01:18:16,239 --> 01:18:18,159
fora o que eu tinha lá eu estou indo

2030
01:18:18,159 --> 01:18:20,880
para colocar minhas coisas novas e vamos ver se

2031
01:18:20,880 --> 01:18:23,040
este compilador funciona agora que vamos

2032
01:18:23,040 --> 01:18:26,159
Salve nosso arquivo tasks.json e volte

2033
01:18:26,159 --> 01:18:28,640
para o arquivo cpp que vamos trazer

2034
01:18:28,640 --> 01:18:30,719
a nossa janela do terminal

2035
01:18:30,719 --> 01:18:33,199
E nós vamos limpar

2036
01:18:33,199 --> 01:18:35,600
e remover o galo porque nós queríamos

2037
01:18:35,600 --> 01:18:38,239
construir um novo com o nosso compilador clank

2038
01:18:38,239 --> 01:18:42,080
e chegaremos à tarefa de corrida terminal

2039
01:18:42,080 --> 01:18:43,760
Agora vamos escolher construir com

2040
01:18:43,760 --> 01:18:46,640
clang 12.0 nós vamos consertar isso em um

2041
01:18:46,640 --> 01:18:48,719
minuto, mas se fizermos isso, vamos

2042
01:18:48,719 --> 01:18:51,040
Veja que nosso processo de solda está indo para

2043
01:18:51,040 --> 01:18:53,360
Comece que vai construir com o nosso

2044
01:18:53,360 --> 01:18:55,520
Compilador de clã que vai usar c

2045
01:18:55,520 --> 01:18:57,840
mais mais 20. vai ser construído

2046
01:18:57,840 --> 01:19:00,480
cada arquivo cpp neste local

2047
01:19:00,480 --> 01:19:03,280
Aqui e a produção do mundo será

2048
01:19:03,280 --> 01:19:05,360
Um binário chamado galo que temos

2049
01:19:05,360 --> 01:19:07,920
Aqui, então a construção é boa se o fizermos

2050
01:19:07,920 --> 01:19:09,760
ls vamos encontrar galo e se nós

2051
01:19:09,760 --> 01:19:12,239
executá-lo vai dizer zero exatamente como

2052
01:19:12,239 --> 01:19:15,120
Esperamos aqui e temos estúdio visual

2053
01:19:15,120 --> 01:19:17,920
código corretamente configurado para usar nossos dois

2054
01:19:17,920 --> 01:19:20,159
compiladores do compilador do cliente e

2055
01:19:20,159 --> 01:19:22,719
gcc compiler vamos voltar para o nosso

2056
01:19:22,719 --> 01:19:24,719
configuração e mudar isso para dizer

2057
01:19:24,719 --> 01:19:26,880
12.0.0

2058
01:19:26,880 --> 01:19:29,600
para ser super claro na versão que temos

2059
01:19:29,600 --> 01:19:32,719
podemos fechar nosso arquivo json aqui

2060
01:19:32,719 --> 01:19:35,280
e vir e tentar construir novamente se fizermos

2061
01:19:35,280 --> 01:19:38,640
terminal e tarefa de execução que teremos

2062
01:19:38,640 --> 01:19:40,640
Compilador aqui ignora todas essas coisas i

2063
01:19:40,640 --> 01:19:42,159
Acho que o código visual do vídeo vai dar

2064
01:19:42,159 --> 01:19:44,880
Você duplica, mas você pode escolher

2065
01:19:44,880 --> 01:19:47,440
a versão que diz o que você quer e

2066
01:19:47,440 --> 01:19:48,880
vai funcionar, então vamos

2067
01:19:48,880 --> 01:19:52,080
escolher gcc oh estamos dizendo gcc mas nós

2068
01:19:52,080 --> 01:19:54,480
querer clang aqui, então vamos dizer que nós

2069
01:19:54,480 --> 01:19:56,560
Quero construir com o clã que vamos

2070
01:19:56,560 --> 01:19:58,080
ir para o terminal

2071
01:19:58,080 --> 01:19:59,600
e executar a tarefa

2072
01:19:59,600 --> 01:20:02,199
E nós queremos clang

2073
01:20:02,199 --> 01:20:05,199
12.0.0 isso está bem aqui, então estamos indo

2074
01:20:05,199 --> 01:20:06,639
para selecioná-lo

2075
01:20:06,639 --> 01:20:08,400
e vai construir com sucesso e

2076
01:20:08,400 --> 01:20:11,040
nós teremos o nosso binário aqui se corrermos

2077
01:20:11,040 --> 01:20:11,840


2078
01:20:11,840 --> 01:20:13,440
vai dizer zero e isso é

2079
01:20:13,440 --> 01:20:16,080
realmente o que precisamos fazer aqui, então isso

2080
01:20:16,080 --> 01:20:17,600
É realmente tudo que eu tive que compartilhar disso

2081
01:20:17,600 --> 01:20:19,040
palestra mostrando como você pode

2082
01:20:19,040 --> 01:20:20,320
A configuração

2083
01:20:20,320 --> 01:20:22,400
código visual do estúdio para compilar o

2084
01:20:22,400 --> 01:20:24,719
compiladores que temos instalado outro

2085
01:20:24,719 --> 01:20:26,800
O que você pode fazer para fazer sua experiência

2086
01:20:26,800 --> 01:20:30,480
Melhor é voltar para ver e selecionar

2087
01:20:30,480 --> 01:20:34,080
paleta de comando aqui e você pode fazer c

2088
01:20:34,080 --> 01:20:36,239
e o c plus e editar o

2089
01:20:36,239 --> 01:20:39,280
configurações através de uma interface de usuário

2090
01:20:39,280 --> 01:20:40,639
E se fizermos isso você vai ver

2091
01:20:40,639 --> 01:20:42,480
que isso vai criar um cpp

2092
01:20:42,480 --> 01:20:45,360
propriedades arquivo json, então este é o lugar onde nós

2093
01:20:45,360 --> 01:20:46,480
pode configurar

2094
01:20:46,480 --> 01:20:48,560
Que tipo de inteligência que tipo de

2095
01:20:48,560 --> 01:20:50,239
Que tipo de compilador vai ser

2096
01:20:50,239 --> 01:20:53,600
usados, podemos fazer todas essas coisas aqui, então

2097
01:20:53,600 --> 01:20:55,120
nós vamos deixar isso para o padrão

2098
01:20:55,120 --> 01:20:57,360
é no nosso sistema linux que vai

2099
01:20:57,360 --> 01:20:59,840
usar o gcc 11, que é o melhor

2100
01:20:59,840 --> 01:21:00,719


2101
01:21:00,719 --> 01:21:02,719
em termos de gcc

2102
01:21:02,719 --> 01:21:06,800
Mas uma coisa que você deve notar nisso

2103
01:21:06,800 --> 01:21:08,800
O curso aqui é o c plus mais padrão

2104
01:21:08,800 --> 01:21:10,800
queríamos usar, então queríamos usar z

2105
01:21:10,800 --> 01:21:13,600
mais mais 20 e queremos estúdio visual

2106
01:21:13,600 --> 01:21:16,000
código para nos dar em inteligência

2107
01:21:16,000 --> 01:21:16,719
ou

2108
01:21:16,719 --> 01:21:19,600
Formatar nosso arquivo principal cpp com base no c

2109
01:21:19,600 --> 01:21:21,920
mais mais 20 ano padrão que é o que

2110
01:21:21,920 --> 01:21:23,440
Nós podemos conseguir com isso assim que você

2111
01:21:23,440 --> 01:21:24,880
Tenho isso e

2112
01:21:24,880 --> 01:21:27,520
Você pode vir e fechar isso

2113
01:21:27,520 --> 01:21:29,520
e se voltarmos para o arquivo cpp principal

2114
01:21:29,520 --> 01:21:30,800
Você vê agora

2115
01:21:30,800 --> 01:21:33,520
que isso não é mais sinalizado como um

2116
01:21:33,520 --> 01:21:35,360
problema com linhas lojeiras visuais

2117
01:21:35,360 --> 01:21:37,280
O código do estúdio é bem entender

2118
01:21:37,280 --> 01:21:39,280
O que está acontecendo aqui e isso é

2119
01:21:39,280 --> 01:21:40,880
Algo que você pode fazer para fazer seu

2120
01:21:40,880 --> 01:21:42,880
Experiência um pouco melhor

2121
01:21:42,880 --> 01:21:45,120
Tudo bem agora que temos este conjunto de projetos

2122
01:21:45,120 --> 01:21:47,840
para cima e pronto em linux que vamos ser

2123
01:21:47,840 --> 01:21:50,639
reutilizando isso como um projeto de modelo a cada

2124
01:21:50,639 --> 01:21:53,600
Hora de começar algo novo no linux assim

2125
01:21:53,600 --> 01:21:54,960
Cada vez que queremos criar um novo

2126
01:21:54,960 --> 01:21:57,600
projeto vamos pegar toda esta pasta

2127
01:21:57,600 --> 01:21:59,840
por exemplo, chegaremos ao nosso

2128
01:21:59,840 --> 01:22:03,280
terminal aqui e subir um pouco

2129
01:22:03,280 --> 01:22:06,400
assim cd e subir um nível e se fizermos

2130
01:22:06,400 --> 01:22:08,320
ls nós vamos ter o nosso c plus plus

2131
01:22:08,320 --> 01:22:11,520
Projeto de 20 modelos vamos copiá-lo e

2132
01:22:11,520 --> 01:22:14,159
renomeá-lo para iniciar um novo projeto e

2133
01:22:14,159 --> 01:22:15,520
que vai nos dar tudo

2134
01:22:15,520 --> 01:22:17,520
configuração que fizemos, não precisamos

2135
01:22:17,520 --> 01:22:19,920
para reconfigurar os compiladores ou qualquer coisa

2136
01:22:19,920 --> 01:22:22,800
vai funcionar logo fora da caixa

2137
01:22:22,800 --> 01:22:25,040
E isso é realmente o que fizemos aqui nós

2138
01:22:25,040 --> 01:22:27,600
criar um projeto de modelo que vamos

2139
01:22:27,600 --> 01:22:30,159
estar reutilizando tudo de novo no curso

2140
01:22:30,159 --> 01:22:32,800
à medida que progredimos aprendendo sobre c plus

2141
01:22:32,800 --> 01:22:35,440
mais 20. eu vou parar aqui neste

2142
01:22:35,440 --> 01:22:37,520
dar uma palestra no próximo que vou mostrar

2143
01:22:37,520 --> 01:22:39,520
Como você pode configurar um desenvolvimento

2144
01:22:39,520 --> 01:22:42,800
ambiente no sistema mac os

2145
01:22:42,800 --> 01:22:45,040
Vá em frente e termine aqui e me encontre

2146
01:22:45,040 --> 01:22:46,320
lá

2147
01:22:46,320 --> 01:22:48,080
Neste vídeo vou mostrar-lhe como

2148
01:22:48,080 --> 01:22:50,800
para instalar o compilador c plus plus no seu

2149
01:22:50,800 --> 01:22:54,000
Mac os sistema e nós temos um monte de

2150
01:22:54,000 --> 01:22:56,639
opções no mac podemos instalar o

2151
01:22:56,639 --> 01:22:59,199
gcc compilador nós podemos instalar o clang

2152
01:22:59,199 --> 01:23:00,320
versão

2153
01:23:00,320 --> 01:23:03,120
da empresa da maçã ou podemos instalar

2154
01:23:03,120 --> 01:23:05,520
a versão do clangle vm tudo isso é

2155
01:23:05,520 --> 01:23:07,520
Opções e vou mostrar-lhe como

2156
01:23:07,520 --> 01:23:09,679
instale estes não tenho acesso a um

2157
01:23:09,679 --> 01:23:12,239
mac dispositivo para que eu não seja realmente capaz de

2158
01:23:12,239 --> 01:23:14,719
instale xcode e mostre-lhe, mas eu acho

2159
01:23:14,719 --> 01:23:17,040
você pode gerenciar se estiver usando um Mac

2160
01:23:17,040 --> 01:23:19,120
Sistema não é nada complicado você

2161
01:23:19,120 --> 01:23:21,360
só tem que ir para a loja de maçãs e

2162
01:23:21,360 --> 01:23:23,040
clique em xcode e ele vai

2163
01:23:23,040 --> 01:23:27,040
instalar para um gcc e clang

2164
01:23:27,040 --> 01:23:28,960
mostrar-lhe como fazer isso usando o

2165
01:23:28,960 --> 01:23:31,440
homebrew package manager que também é

2166
01:23:31,440 --> 01:23:34,400
Vou fazer isso super fácil, assim

2167
01:23:34,400 --> 01:23:36,719
vamos para o nosso navegador e nós

2168
01:23:36,719 --> 01:23:39,520
ter um bom link aqui do digitalocean

2169
01:23:39,520 --> 01:23:42,800
sobre como instalar e usar homobrew em um

2170
01:23:42,800 --> 01:23:45,360
mac os sistema este é realmente validado

2171
01:23:45,360 --> 01:23:47,679
link você pode ver isso aqui e você

2172
01:23:47,679 --> 01:23:50,159
pode ler sobre isso se você estiver usando um

2173
01:23:50,159 --> 01:23:52,159
sistema mac eu vou compartilhar o link

2174
01:23:52,159 --> 01:23:54,880
aqui na seção de recursos da

2175
01:23:54,880 --> 01:23:57,600
curso e para usar isso vamos embora

2176
01:23:57,600 --> 01:24:00,000
através do Mac os terminal e é

2177
01:24:00,000 --> 01:24:01,760
Nada complicado que você possa procurar

2178
01:24:01,760 --> 01:24:04,960
ele e abra e depois que você fizer isso

2179
01:24:04,960 --> 01:24:07,520
você terá que instalar as ferramentas

2180
01:24:07,520 --> 01:24:10,080
Eu precisava construir coisas no mac os

2181
01:24:10,080 --> 01:24:12,639
sistema e que vai instalar o xcode

2182
01:24:12,639 --> 01:24:15,679
aqui então pegue o comando aqui e execute-o

2183
01:24:15,679 --> 01:24:18,239
em seu terminal e isso vai

2184
01:24:18,239 --> 01:24:20,560
Instale tudo que você precisa e depois

2185
01:24:20,560 --> 01:24:22,159
você tem isso instalado que você está indo para

2186
01:24:22,159 --> 01:24:24,800
instalar home brew i recomendo vir

2187
01:24:24,800 --> 01:24:29,199
até o site aqui para homebrew e

2188
01:24:29,199 --> 01:24:32,320
clicando neste ícone de cópia aqui este é

2189
01:24:32,320 --> 01:24:34,960
Vou copiar a coisa toda e você

2190
01:24:34,960 --> 01:24:36,560
Você pode copiar isso

2191
01:24:36,560 --> 01:24:38,320
E uma vez que você copiá-lo, ele vai dar

2192
01:24:38,320 --> 01:24:40,239
Nós um carrapato verde aqui

2193
01:24:40,239 --> 01:24:42,159
e você pode entrar no terminal em seu

2194
01:24:42,159 --> 01:24:44,800
mac os sistema i estou usando um linux

2195
01:24:44,800 --> 01:24:46,400
terminal aqui e então você vai

2196
01:24:46,400 --> 01:24:49,199
colar este comando aqui e bater enter

2197
01:24:49,199 --> 01:24:51,040
Depois de fazer isso, você será solicitado a

2198
01:24:51,040 --> 01:24:52,719
colocar na senha que vai dizer

2199
01:24:52,719 --> 01:24:54,880
você que precisa instalar homebrew

2200
01:24:54,880 --> 01:24:56,560
E você basicamente vai esperar

2201
01:24:56,560 --> 01:24:58,880
Isso para terminar eu tenho que avisá-lo isso

2202
01:24:58,880 --> 01:25:00,719
vai levar algum tempo mesmo se você

2203
01:25:00,719 --> 01:25:02,880
Tenha uma boa conexão de internet que é

2204
01:25:02,880 --> 01:25:04,719
Vou levar algum tempo, então seja paciente

2205
01:25:04,719 --> 01:25:06,480
Aqui, quando estiver feito, vai dizer

2206
01:25:06,480 --> 01:25:08,639
você que está acabado e você será

2207
01:25:08,639 --> 01:25:11,120
pronto para instalar o compilador gcc e

2208
01:25:11,120 --> 01:25:13,920
O compilador llvm cliente através do seu

2209
01:25:13,920 --> 01:25:16,000
Homebrew instalação aqui não estou

2210
01:25:16,000 --> 01:25:18,159
Vou clicar sobre isso porque

2211
01:25:18,159 --> 01:25:20,159
Eu já tenho isso instalado no meu
Sistema 
2212
01:25:20,159 --> 01:25:22,400
linux aqui vamos voltar para o

2213
01:25:22,400 --> 01:25:24,719
link e ver o que eles dizem a seguir, então depois

2214
01:25:24,719 --> 01:25:27,280
Você cola isso em que vai instalar

2215
01:25:27,280 --> 01:25:30,880
E depois disso você verá que

2216
01:25:30,880 --> 01:25:32,480
Homebrew vai ser instalado em

2217
01:25:32,480 --> 01:25:33,679
o seu sistema

2218
01:25:33,679 --> 01:25:35,040
E uh

2219
01:25:35,040 --> 01:25:36,880
você pode usar cerveja caseira para começar

2220
01:25:36,880 --> 01:25:38,800
Instalar e atualizar pacotes que você

2221
01:25:38,800 --> 01:25:41,120
Eu posso realmente ler sobre isso, mas o que eu

2222
01:25:41,120 --> 01:25:42,639
Quero que você veja

2223
01:25:42,639 --> 01:25:44,880
é que você pode usar cerveja doméstica para instalar

2224
01:25:44,880 --> 01:25:47,600
o compilador gcc e o clang ll vm

2225
01:25:47,600 --> 01:25:49,840
compilador, então se chegarmos à pesquisa

2226
01:25:49,840 --> 01:25:52,840
aqui e dizer gcc homo

2227
01:25:52,840 --> 01:25:55,280
vassoura, vamos encontrar instruções

2228
01:25:55,280 --> 01:25:57,840
sobre como instalar isso para tudo o que você precisa

2229
01:25:57,840 --> 01:26:00,639
fazer realmente é dizer brew install gcc

2230
01:26:00,639 --> 01:26:02,159
Isto vai instalar o mais recente

2231
01:26:02,159 --> 01:26:04,480
versão do gcc no seu mac

2232
01:26:04,480 --> 01:26:07,600
se nós viermos aqui e dizemos llvm ou clank

2233
01:26:07,600 --> 01:26:09,920
Vamos dizer clã

2234
01:26:09,920 --> 01:26:11,600
E a

2235
01:26:11,600 --> 01:26:15,679
podemos achar que aqui llvm

2236
01:26:15,679 --> 01:26:17,360
E isso vai nos dar instruções

2237
01:26:17,360 --> 01:26:19,360
sobre como instalar isso e tudo o que você tem

2238
01:26:19,360 --> 01:26:20,239
para fazer

2239
01:26:20,239 --> 01:26:22,719
é brew install llvm e isso está indo

2240
01:26:22,719 --> 01:26:25,440
para instalar esses dois compiladores em seu

2241
01:26:25,440 --> 01:26:28,159
mac system assim que você fizer isso você vai

2242
01:26:28,159 --> 01:26:30,800
tê-los armazenados em algum lugar, vamos para

2243
01:26:30,800 --> 01:26:33,199
O link de instalação e vamos ver

2244
01:26:33,199 --> 01:26:35,920
que homebrew vai ser basicamente

2245
01:26:35,920 --> 01:26:38,880
instalado em coisas em seu usuário local

2246
01:26:38,880 --> 01:26:41,520
diretório em um dispositivo Mac por favor me diga

2247
01:26:41,520 --> 01:26:43,760
se isso for verdade para o seu caso e se você

2248
01:26:43,760 --> 01:26:46,320
ter um problema que vamos tentar passar

2249
01:26:46,320 --> 01:26:49,440
e corrigir isso, então se você estiver em um

2250
01:26:49,440 --> 01:26:51,120
mac i realmente recomendo ir

2251
01:26:51,120 --> 01:26:53,440
através disso para instalar homebrew uma vez

2252
01:26:53,440 --> 01:26:55,199
Você tem que instalar você vai

2253
01:26:55,199 --> 01:26:58,639
através disso para instalar ambos os llvm

2254
01:26:58,639 --> 01:27:01,520
compilador e compilador gcc e que é

2255
01:27:01,520 --> 01:27:03,360
vai dar as últimas versões

2256
01:27:03,360 --> 01:27:05,920
para esses compiladores descobrirem se eles

2257
01:27:05,920 --> 01:27:08,560
irá instalar você pode ir em seu usuário

2258
01:27:08,560 --> 01:27:11,040
diretório local e você pode caçar através

2259
01:27:11,040 --> 01:27:12,800
Estes compiladores e você vai encontrar

2260
01:27:12,800 --> 01:27:15,440
binários para eles e começar a usá-los

2261
01:27:15,440 --> 01:27:17,440
para construir seus aplicativos c plus plus

2262
01:27:17,440 --> 01:27:19,199
Você está bem, então agora eu vou

2263
01:27:19,199 --> 01:27:21,840
Considere que você tem gcc e um

2264
01:27:21,840 --> 01:27:24,400
clang instalado em seu sistema Mac

2265
01:27:24,400 --> 01:27:27,040
A próxima coisa lógica a fazer é querer o

2266
01:27:27,040 --> 01:27:29,280
versão de apple do clang e eu acho

2267
01:27:29,280 --> 01:27:31,679
Isso vai vir como parte do xcode

2268
01:27:31,679 --> 01:27:32,480
aqui

2269
01:27:32,480 --> 01:27:35,760
e isso virá como resultado de

2270
01:27:35,760 --> 01:27:38,400
executando o comando que fizemos antes de eu

2271
01:27:38,400 --> 01:27:40,239
Acho que foi esse pequeno comando aqui

2272
01:27:40,239 --> 01:27:41,920
que vai instalar tudo você

2273
01:27:41,920 --> 01:27:43,520
A necessidade a partir do

2274
01:27:43,520 --> 01:27:44,840
x Código

2275
01:27:44,840 --> 01:27:47,360
ide, então isso é tudo que eu tenho que compartilhar

2276
01:27:47,360 --> 01:27:49,920
Esta palestra novamente peço desculpas

2277
01:27:49,920 --> 01:27:52,080
ter acesso a um dispositivo Mac, mas se você

2278
01:27:52,080 --> 01:27:53,600
Tenho um problema que você pode me dizer e eu

2279
01:27:53,600 --> 01:27:56,239
tentará ajudá-lo e conseguir isso

2280
01:27:56,239 --> 01:27:57,440
resoliu para fora

2281
01:27:57,440 --> 01:27:59,040
Vamos parar aqui neste

2282
01:27:59,040 --> 01:28:00,800
dar uma palestra no próximo que vamos ver

2283
01:28:00,800 --> 01:28:03,280
Como podemos instalar o xcode no seu Mac

2284
01:28:03,280 --> 01:28:06,000
Dispositivo vá em frente e termine aqui

2285
01:28:06,000 --> 01:28:07,440
e me encontrar lá

2286
01:28:07,440 --> 01:28:09,280
Neste vídeo vou mostrar-lhe como

2287
01:28:09,280 --> 01:28:12,480
para instalar o editor de código de estúdio visual

2288
01:28:12,480 --> 01:28:15,120
no seu sistema mac, por favor, saiba que

2289
01:28:15,120 --> 01:28:17,840
você também pode usar outros ides como x código

2290
01:28:17,840 --> 01:28:20,480
ou código lite do c plus plus desenvolvimento

2291
01:28:20,480 --> 01:28:22,560
mas o código do estúdio visual vai ser

2292
01:28:22,560 --> 01:28:25,520
nosso principal editor neste curso aqui e

2293
01:28:25,520 --> 01:28:27,600
Eu recomendaria instalá-lo para que

2294
01:28:27,600 --> 01:28:29,840
Estamos fazendo coisas consistentes que são

2295
01:28:29,840 --> 01:28:31,920
vai reduzir as chances para você conseguir

2296
01:28:31,920 --> 01:28:34,560
confusos, então vamos nos dirigir para

2297
01:28:34,560 --> 01:28:37,120
O site para código de estúdio visual

2298
01:28:37,120 --> 01:28:40,159
e para chegar lá podemos apenas digitar visual

2299
01:28:40,159 --> 01:28:43,199
código de estúdio aqui em nossa busca

2300
01:28:43,199 --> 01:28:45,600
Motor e teremos um link aqui que

2301
01:28:45,600 --> 01:28:47,920
Podemos usar para baixar nossos fãs

2302
01:28:47,920 --> 01:28:50,960
então nós vamos descer e encontrar

2303
01:28:50,960 --> 01:28:54,800
Baixar links para windows linux e mac

2304
01:28:54,800 --> 01:28:57,280
Use o botão de download do mac aqui

2305
01:28:57,280 --> 01:28:58,880
e você vai baixar o binário

2306
01:28:58,880 --> 01:29:01,199
e instalá-lo eu acho que vai ser

2307
01:29:01,199 --> 01:29:03,840
na pasta de download por padrão, então tudo

2308
01:29:03,840 --> 01:29:05,040
Você tem que fazer

2309
01:29:05,040 --> 01:29:07,760
é arrastar isso para cima em sua instalação

2310
01:29:07,760 --> 01:29:10,480
diretório para que ele se torne um runnable

2311
01:29:10,480 --> 01:29:12,239
Aplicação depois que você faz isso você é

2312
01:29:12,239 --> 01:29:14,480
indo para executá-lo e ele vai correr

2313
01:29:14,480 --> 01:29:17,040
e você terá uma interface de usuário como

2314
01:29:17,040 --> 01:29:19,440
isto com código de estúdio visual aberto

2315
01:29:19,440 --> 01:29:21,600
uma vez que você tem isso você vai precisar

2316
01:29:21,600 --> 01:29:24,000
Instale o c plus mais extensão e

2317
01:29:24,000 --> 01:29:26,239
O que você precisa fazer é chegar ao

2318
01:29:26,239 --> 01:29:28,639
extensions tab aqui e tipo c e c

2319
01:29:28,639 --> 01:29:30,639
mais mais aqui e você vai

2320
01:29:30,639 --> 01:29:33,040
ter uma entrada para microsoft clique em

2321
01:29:33,040 --> 01:29:35,920
e instale esta extensão no seu

2322
01:29:35,920 --> 01:29:38,239
sistema e seu código de estúdio visual

2323
01:29:38,239 --> 01:29:40,800
A instância estará pronta para lidar

2324
01:29:40,800 --> 01:29:43,520
algum c plus desenvolvimento e isso é

2325
01:29:43,520 --> 01:29:44,960
Realmente tudo que eu tinha para compartilhar isso

2326
01:29:44,960 --> 01:29:46,800
Uma palestra mostrando como você pode obter isso

2327
01:29:46,800 --> 01:29:49,120
instalado novamente eu peço desculpas eu não tenho

2328
01:29:49,120 --> 01:29:51,600
acesso a um dispositivo Mac para que eu usasse o meu

2329
01:29:51,600 --> 01:29:54,560
linux caixa correndo dentro da janela

2330
01:29:54,560 --> 01:29:56,639
subsistema para linux para mostrar isso, mas

2331
01:29:56,639 --> 01:29:58,719
Isso é bom o suficiente eu acho que se você tem

2332
01:29:58,719 --> 01:30:00,800
um problema que você pode me dizer e eu vou fazer

2333
01:30:00,800 --> 01:30:03,120
o melhor que posso para te ajudar por agora

2334
01:30:03,120 --> 01:30:05,280
Vamos parar aqui nesta palestra

2335
01:30:05,280 --> 01:30:07,440
No próximo eu vou tentar mostrar a você

2336
01:30:07,440 --> 01:30:09,920
Como configurar um código de estúdio visual para

2337
01:30:09,920 --> 01:30:12,080
Use os compiladores que instalamos em

2338
01:30:12,080 --> 01:30:13,440
A última palestra

2339
01:30:13,440 --> 01:30:15,760
Vá em frente e termine aqui e me encontre

2340
01:30:15,760 --> 01:30:17,040
lá

2341
01:30:17,040 --> 01:30:19,040
Nesta palestra vou tentar

2342
01:30:19,040 --> 01:30:21,920
mostrar como configurar o estúdio visual

2343
01:30:21,920 --> 01:30:24,239
código para usar os compiladores que nós

2344
01:30:24,239 --> 01:30:26,639
instalado em nosso sistema mac em um

2345
01:30:26,639 --> 01:30:28,639
palestra anterior, então queremos visual

2346
01:30:28,639 --> 01:30:30,639
código de estúdio para poder pegar o nosso

2347
01:30:30,639 --> 01:30:33,040
gcc compilador e usá-lo, queremos que ele

2348
01:30:33,040 --> 01:30:35,679
pegue nosso compilador de clientes e use-o

2349
01:30:35,679 --> 01:30:37,760
Também queríamos pegar o nosso clanger

2350
01:30:37,760 --> 01:30:40,719
compilador da Apple e usá-lo para construir

2351
01:30:40,719 --> 01:30:43,600
binários que podemos então correr em nosso

2352
01:30:43,600 --> 01:30:46,560
sistema aqui, então vamos ver como fazer isso

2353
01:30:46,560 --> 01:30:48,880
Eu tenho que dizer que eu não tenho um dispositivo Mac

2354
01:30:48,880 --> 01:30:51,360
Então o melhor que posso fazer aqui é descrever

2355
01:30:51,360 --> 01:30:53,280
O processo para você e se você tem um

2356
01:30:53,280 --> 01:30:54,960
problema você pode me dizer que eu vou fazer o

2357
01:30:54,960 --> 01:30:57,199
Melhor eu posso para ajudá-lo bem, então uma vez

2358
01:30:57,199 --> 01:30:59,679
você tem código de estúdio visual instalado

2359
01:30:59,679 --> 01:31:01,040
você vai criar uma pasta

2360
01:31:01,040 --> 01:31:03,360
Em algum lugar e abrir código de estúdio visual

2361
01:31:03,360 --> 01:31:06,080
dessa pasta e do que você vai

2362
01:31:06,080 --> 01:31:08,639
basicamente é usar o terminal para

2363
01:31:08,639 --> 01:31:10,159
Navegue até um local para o qual você está indo

2364
01:31:10,159 --> 01:31:12,560
criar uma pasta que você pode até chamá-lo de cpp

2365
01:31:12,560 --> 01:31:14,560
Projeto de modelo que você vai pular

2366
01:31:14,560 --> 01:31:17,280
sobre essa pasta e depois abrir

2367
01:31:17,280 --> 01:31:19,920
código visual do estúdio dessa pasta aqui

2368
01:31:19,920 --> 01:31:23,840
por exemplo, podemos pular em cpp

2369
01:31:23,840 --> 01:31:26,800
e executar código e dizer dot que vai

2370
01:31:26,800 --> 01:31:29,600
Abrir código de estúdio visual nessa pasta

2371
01:31:29,600 --> 01:31:31,840
e a partir dessa pasta você vai criar um

2372
01:31:31,840 --> 01:31:34,159
arquivo cpp principal clicando no plus

2373
01:31:34,159 --> 01:31:36,639
botão aqui e você vai criar o cpp

2374
01:31:36,639 --> 01:31:39,280
arquivo chamá-lo cpp principal e você pode colocar em

2375
01:31:39,280 --> 01:31:42,639
o conteúdo aqui e uma vez que você tem isso

2376
01:31:42,639 --> 01:31:45,199
A próxima tarefa será criar uma

2377
01:31:45,199 --> 01:31:48,560
compilador para construir esta pequena coisa assim

2378
01:31:48,560 --> 01:31:50,719
Quando você tiver este projeto, você virá

2379
01:31:50,719 --> 01:31:52,480
Para o terminal eu acho que vai haver

2380
01:31:52,480 --> 01:31:55,199
um menu terminal em algum lugar e você vai

2381
01:31:55,199 --> 01:31:58,080
escolher configurar tarefas depois de fazer isso

2382
01:31:58,080 --> 01:32:00,159
Código de estúdio visual é inteligente o suficiente para

2383
01:32:00,159 --> 01:32:03,280
escanear o seu sistema e encontrar qualquer compilador

2384
01:32:03,280 --> 01:32:05,520
Você instalou a primeira coisa que

2385
01:32:05,520 --> 01:32:07,679
É provável que seja encontrado é a maçã

2386
01:32:07,679 --> 01:32:09,600
cliente compilador para que você vai encontrar

2387
01:32:09,600 --> 01:32:10,880
um clone

2388
01:32:10,880 --> 01:32:12,880
plus compilador plus para que você possa escolher

2389
01:32:12,880 --> 01:32:15,600
Isso e você pode usar isso para a maçã

2390
01:32:15,600 --> 01:32:18,000
Compilador de clientes, temos sorte mesmo

2391
01:32:18,000 --> 01:32:20,639
ter um tutorial sobre como fazer isso se

2392
01:32:20,639 --> 01:32:23,120
clicamos na guia de extensões aqui e

2393
01:32:23,120 --> 01:32:25,760
escolha nosso c e c plus plus

2394
01:32:25,760 --> 01:32:26,960
de extensão

2395
01:32:26,960 --> 01:32:28,880
Se rolarmos para baixo, vamos ver um

2396
01:32:28,880 --> 01:32:32,080
link sobre como usar o cliente no mac os aqui

2397
01:32:32,080 --> 01:32:33,600
Isso vai nos dar tudo

2398
01:32:33,600 --> 01:32:36,159
instruções que precisamos usar visual

2399
01:32:36,159 --> 01:32:38,719
código de estúdio com o compilador cliente

2400
01:32:38,719 --> 01:32:41,600
da empresa de maçã, então se você rolar

2401
01:32:41,600 --> 01:32:43,120
para baixo você vai ser capaz de ler

2402
01:32:43,120 --> 01:32:45,600
em tudo isso, mas o que eu realmente quero você

2403
01:32:45,600 --> 01:32:47,760
para ver é o arquivo de configuração que você é

2404
01:32:47,760 --> 01:32:49,280
Vou ver que vai usar

2405
01:32:49,280 --> 01:32:51,679
o compilador clang da caixa do usuário

2406
01:32:51,679 --> 01:32:54,639
diretório e isso vai ser principalmente

2407
01:32:54,639 --> 01:32:57,600
a versão clang da empresa da Apple

2408
01:32:57,600 --> 01:33:00,400
e às vezes você não quer isso, então se

2409
01:33:00,400 --> 01:33:02,560
você quer usar a versão clang que

2410
01:33:02,560 --> 01:33:04,960
nós instalamos através da cerveja caseira eu acho

2411
01:33:04,960 --> 01:33:07,199
Você precisará passar pelo usuário

2412
01:33:07,199 --> 01:33:08,800
Diretório local porque é onde

2413
01:33:08,800 --> 01:33:10,719
homebrew vai dizer que você está indo

2414
01:33:10,719 --> 01:33:12,000
para ver que isso vai ser o

2415
01:33:12,000 --> 01:33:14,159
Localização aqui do nosso tutorial e

2416
01:33:14,159 --> 01:33:16,480
Você vai caçar o clã

2417
01:33:16,480 --> 01:33:19,679
compilador e encontrar o seu binário e que é

2418
01:33:19,679 --> 01:33:21,760
o que vamos usar a seguir, mas

2419
01:33:21,760 --> 01:33:23,440
Pela primeira vez se você quiser usar

2420
01:33:23,440 --> 01:33:26,080
o compilador do clã da Apple este é o

2421
01:33:26,080 --> 01:33:28,080
configuração que você precisa e tudo que você precisa

2422
01:33:28,080 --> 01:33:30,639
fazer neste caso é mudar isso para c

2423
01:33:30,639 --> 01:33:32,159
mais mais 20.

2424
01:33:32,159 --> 01:33:34,239
Agora, uma vez que você tenha configurado você

2425
01:33:34,239 --> 01:33:35,840
terá a capacidade de chegar

2426
01:33:35,840 --> 01:33:38,960
terminal vamos mostrar nossos arquivos aqui

2427
01:33:38,960 --> 01:33:40,320
terá a capacidade de chegar

2428
01:33:40,320 --> 01:33:42,159
terminal e tarefa de execução e escolha o

2429
01:33:42,159 --> 01:33:44,480
Compilador que vai ser o clang

2430
01:33:44,480 --> 01:33:46,719
compilador da Apple, mas você também pode

2431
01:33:46,719 --> 01:33:48,639
configurar outros compiladores e todos vocês

2432
01:33:48,639 --> 01:33:50,639
Realmente ter que fazer é escolhê-los no

2433
01:33:50,639 --> 01:33:52,800
Liste aqui e você vai ter um

2434
01:33:52,800 --> 01:33:55,760
Arquivo de configuração de tarefas

2435
01:33:55,760 --> 01:33:58,560
Json arquivo para ser exato vamos mostrar isso

2436
01:33:58,560 --> 01:34:00,080
aqui

2437
01:34:00,080 --> 01:34:01,360
e isso vai te dar o

2438
01:34:01,360 --> 01:34:03,600
instruções que você precisa para construir isso

2439
01:34:03,600 --> 01:34:06,080
Na maioria dos casos, você só precisará

2440
01:34:06,080 --> 01:34:07,679
Tenha cuidado com o caminho para o

2441
01:34:07,679 --> 01:34:10,159
compilador, por exemplo, se você estiver usando

2442
01:34:10,159 --> 01:34:12,239
a versão gcc que você instalou através

2443
01:34:12,239 --> 01:34:14,719
homo brew você vai encontrar isso em

2444
01:34:14,719 --> 01:34:17,120
Sua localização, você vai ter certeza

2445
01:34:17,120 --> 01:34:19,520
que é o correto e você vai colocar

2446
01:34:19,520 --> 01:34:22,560
nestas instruções aqui para dizer o seu

2447
01:34:22,560 --> 01:34:25,520
compilador para construir cada arquivo cpp

2448
01:34:25,520 --> 01:34:28,080
no diretório aqui é o que fazemos

2449
01:34:28,080 --> 01:34:29,600
Se você usar o clã, você vai ter

2450
01:34:29,600 --> 01:34:32,080
Algo como isto e outra vez eu sou

2451
01:34:32,080 --> 01:34:34,080
descrevendo isso para você porque eu não

2452
01:34:34,080 --> 01:34:36,639
Tenho um mac disponível para mim agora

2453
01:34:36,639 --> 01:34:38,239
e se você tem um problema, você pode dizer

2454
01:34:38,239 --> 01:34:41,040
eu podemos tentar resolver isso bem e

2455
01:34:41,040 --> 01:34:44,080
A essa altura você terá a capacidade

2456
01:34:44,080 --> 01:34:46,400
para usar sua instância de código de estúdio visual

2457
01:34:46,400 --> 01:34:47,760
e compilar

2458
01:34:47,760 --> 01:34:50,560
c plus programas usando qualquer um dos

2459
01:34:50,560 --> 01:34:53,040
apple client compiler the llvm

2460
01:34:53,040 --> 01:34:55,520
compilador ou compilador gcc e todos

2461
01:34:55,520 --> 01:34:57,360
Estes vão estar compilando em c

2462
01:34:57,360 --> 01:34:59,920
mais mais 20 modo novamente para ambos que você precisa

2463
01:34:59,920 --> 01:35:02,000
para garantir que você tenha o arquivo selecionado

2464
01:35:02,000 --> 01:35:03,760
e escolha o compilador que você deseja

2465
01:35:03,760 --> 01:35:05,920
Use, por exemplo, se você quiser usar clone

2466
01:35:05,920 --> 01:35:08,400
12 de homebrew você está indo para você é

2467
01:35:08,400 --> 01:35:09,920
Vou escolher isso e vai

2468
01:35:09,920 --> 01:35:12,000
ser usado para construir seu projeto e você

2469
01:35:12,000 --> 01:35:13,600
terá a capacidade de executar o seu

2470
01:35:13,600 --> 01:35:16,000
projetos como fazemos aqui e é

2471
01:35:16,000 --> 01:35:18,080
indo para o trabalho, vamos ter certeza de que estamos

2472
01:35:18,080 --> 01:35:20,800
correndo galo aqui nosso binário

2473
01:35:20,800 --> 01:35:23,119
e vai rodar e impressora 0 e

2474
01:35:23,119 --> 01:35:25,520
Isso vai funcionar novamente eu estou realmente

2475
01:35:25,520 --> 01:35:27,199
Desculpe, eu não tenho um dispositivo Mac

2476
01:35:27,199 --> 01:35:28,400
disponível para mim

2477
01:35:28,400 --> 01:35:31,040
Mas isso é o que eu tenho que trabalhar agora

2478
01:35:31,040 --> 01:35:33,119
se você tem um problema em um dispositivo Mac

2479
01:35:33,119 --> 01:35:35,119
Por favor, diga-me que vou fazer o melhor que posso

2480
01:35:35,119 --> 01:35:37,920
para te ajudar

2481
01:35:38,320 --> 01:35:40,239
Nesta palestra vamos explorar

2482
01:35:40,239 --> 01:35:43,679
a opção de usar compiladores online se

2483
01:35:43,679 --> 01:35:46,159
por qualquer motivo, não podemos instalar um

2484
01:35:46,159 --> 01:35:49,520
Compilador de rádio em nosso sistema e novamente

2485
01:35:49,520 --> 01:35:51,600
O objetivo é poder virar o código

2486
01:35:51,600 --> 01:35:54,800
nós digitamos o que parece ser um ide

2487
01:35:54,800 --> 01:35:57,679
em um compilador e obter um binário que nós

2488
01:35:57,679 --> 01:36:00,880
pode correr e ver a saída de

2489
01:36:00,880 --> 01:36:03,040
alguns compiladores online que são muito

2490
01:36:03,040 --> 01:36:05,920
popular dentro da comunidade c plus mais

2491
01:36:05,920 --> 01:36:08,000
Uma caixa é uma delas, também há

2492
01:36:08,000 --> 01:36:11,520
Explorador do compilador e kodiro mas lá

2493
01:36:11,520 --> 01:36:14,159
pode ser outros lá fora, se você fizer

2494
01:36:14,159 --> 01:36:16,480
Pesquise por conta própria, vamos embora

2495
01:36:16,480 --> 01:36:19,199
para o navegador e realmente verificar cada

2496
01:36:19,199 --> 01:36:22,000
Destes, tudo bem aqui estamos em nosso

2497
01:36:22,000 --> 01:36:25,840
navegador aqui estou em onebox.org

2498
01:36:25,840 --> 01:36:27,920
E você vê que realmente parece um

2499
01:36:27,920 --> 01:36:30,159
Eu tenho o código que temos sido

2500
01:36:30,159 --> 01:36:32,960
correr o tempo todo para ter certeza de que

2501
01:36:32,960 --> 01:36:36,080
compila com c plus mais 20.

2502
01:36:36,080 --> 01:36:38,000
Deixados aqui temos algumas opções que podemos

2503
01:36:38,000 --> 01:36:40,400
Selecione qual compilador queremos usar você

2504
01:36:40,400 --> 01:36:42,719
Veja que há um par de gcc

2505
01:36:42,719 --> 01:36:43,840
Versões em versão

2506
01:36:43,840 --> 01:36:45,600
você pode ver que isso é realmente bom

2507
01:36:45,600 --> 01:36:48,159
maneira de testar as coisas através de

2508
01:36:48,159 --> 01:36:51,920
gcc versões que você vê temos clã 12

2509
01:36:51,920 --> 01:36:54,480
então, se você quiser testar clang out você pode

2510
01:36:54,480 --> 01:36:57,679
Selecione isso, vamos realmente tentar isso

2511
01:36:57,679 --> 01:37:00,080
Então nós vamos usar a cabeça do clã

2512
01:37:00,080 --> 01:37:02,880
e tentar compilar isso

2513
01:37:02,880 --> 01:37:06,560
então vamos entrar e ver se clank 12

2514
01:37:06,560 --> 01:37:09,199
suporta c plus mais 20

2515
01:37:09,199 --> 01:37:11,280
e você vê que realmente funciona clã

2516
01:37:11,280 --> 01:37:12,639
Versão 12

2517
01:37:12,639 --> 01:37:15,440
deve suportar c mais mais 20 como este

2518
01:37:15,440 --> 01:37:17,040
Vamos voltar para

2519
01:37:17,040 --> 01:37:20,400
gcc porque é isso que eu gosto e você

2520
01:37:20,400 --> 01:37:22,400
pode tentar colocar coisas diferentes em seu

2521
01:37:22,400 --> 01:37:25,280
c plus código para ver se o compilador

2522
01:37:25,280 --> 01:37:28,400
Na verdade, responde, por exemplo, podemos dizer

2523
01:37:28,400 --> 01:37:29,920
O stdcl

2524
01:37:29,920 --> 01:37:31,440
Olá lá

2525
01:37:31,440 --> 01:37:33,679


2526
01:37:33,679 --> 01:37:35,920
E se corrermos

2527
01:37:35,920 --> 01:37:37,280
nós vamos ver

2528
01:37:37,280 --> 01:37:40,000
A saída da mensagem aqui outro bem

2529
01:37:40,000 --> 01:37:42,639
A coisa com esses compiladores online é

2530
01:37:42,639 --> 01:37:45,920
que você pode compartilhar este código e qualquer um

2531
01:37:45,920 --> 01:37:48,000
será capaz de olhar para o código aqui

2532
01:37:48,000 --> 01:37:50,639
e correr para que este seja um bom caminho

2533
01:37:50,639 --> 01:37:51,920
A sua forma de

2534
01:37:51,920 --> 01:37:55,199
obter ajuda do seu instrutor para que eu faça

2535
01:37:55,199 --> 01:37:57,679
Incentive você se você encontrar um problema

2536
01:37:57,679 --> 01:37:59,679
vem e usa um desses compiladores e

2537
01:37:59,679 --> 01:38:01,679
envie-me o link do jeito que você pode enviar

2538
01:38:01,679 --> 01:38:04,480
o link que você pode clicar em compartilhar aqui este

2539
01:38:04,480 --> 01:38:07,040
Botão aqui você vai pegar a url

2540
01:38:07,040 --> 01:38:09,679
que você pode copiar e enviar para qualquer um

2541
01:38:09,679 --> 01:38:12,080
e eles serão capazes de ver o seu código

2542
01:38:12,080 --> 01:38:14,000
Assim como nós vamos ver aqui em um

2543
01:38:14,000 --> 01:38:16,080
Minuto bem você vê que não é o

2544
01:38:16,080 --> 01:38:18,400
Exatamente a mesma coisa e qualquer um no

2545
01:38:18,400 --> 01:38:20,320
Internet será capaz de ver o seu código

2546
01:38:20,320 --> 01:38:22,560
e tentar encontrar qualquer que seja o problema

2547
01:38:22,560 --> 01:38:24,159
E ajudar você a sair

2548
01:38:24,159 --> 01:38:27,040
Uma caixa muito rápida é um compilador

2549
01:38:27,040 --> 01:38:29,040
Podemos jogar com as opções que temos

2550
01:38:29,040 --> 01:38:31,360
Aqui você pode

2551
01:38:31,360 --> 01:38:33,520
Carregar diferentes bibliotecas que você vê

2552
01:38:33,520 --> 01:38:35,679
tem um monte de bibliotecas de impulso, mas isso

2553
01:38:35,679 --> 01:38:38,400
Não é de nenhum interesse para nós agora você

2554
01:38:38,400 --> 01:38:40,080
pode brincar com ele e ver o que você gosta

2555
01:38:40,080 --> 01:38:42,800
Quanto a isso, outro é kaliru, que é

2556
01:38:42,800 --> 01:38:44,560
outro compilador online que você vê

2557
01:38:44,560 --> 01:38:47,119
Não tem muitas opções como nós

2558
01:38:47,119 --> 01:38:49,280
tinha em uma caixa, por exemplo, você não pode

2559
01:38:49,280 --> 01:38:51,280
alterar o compilador que vai ser

2560
01:38:51,280 --> 01:38:54,719
usando g plus plus, mas se apertarmos compilar

2561
01:38:54,719 --> 01:38:56,639
link e executar ele vai executar o nosso código

2562
01:38:56,639 --> 01:38:58,800
e nós vamos obter a saída aqui

2563
01:38:58,800 --> 01:39:00,960
novamente podemos tentar mudar isso para que

2564
01:39:00,960 --> 01:39:02,960
Você sabe que eu não estou mentindo para você para que possamos

2565
01:39:02,960 --> 01:39:04,960
Diga stdcl

2566
01:39:04,960 --> 01:39:07,280
E dizer o céu

2567
01:39:07,280 --> 01:39:09,119
É azul

2568
01:39:09,119 --> 01:39:12,560
std endl se você quiser você pode bater o controle

2569
01:39:12,560 --> 01:39:15,360
além do seu navegador e ele vai

2570
01:39:15,360 --> 01:39:17,600
fazer isso um pouco maior

2571
01:39:17,600 --> 01:39:21,600
e se compilarmos link e executarmos

2572
01:39:21,600 --> 01:39:24,159
Devemos ver que o céu é azul no

2573
01:39:24,159 --> 01:39:26,159
janela de saída aqui este é realmente tudo

2574
01:39:26,159 --> 01:39:28,719
você pode fazer com kolero e se você gosta

2575
01:39:28,719 --> 01:39:30,719
Você pode doar para os desenvolvedores i

2576
01:39:30,719 --> 01:39:32,960
Acho que temos a mesma coisa

2577
01:39:32,960 --> 01:39:36,400
em uma caixa, mas é em japonês, então eu

2578
01:39:36,400 --> 01:39:39,520
Não posso realmente ler isso

2579
01:39:39,520 --> 01:39:42,239
OK outro é o explorador compilador

2580
01:39:42,239 --> 01:39:44,320
que é realmente bom o principal

2581
01:39:44,320 --> 01:39:46,560
O propósito disso não é realmente dar-lhe

2582
01:39:46,560 --> 01:39:49,280
a saída que está realmente vendo

2583
01:39:49,280 --> 01:39:52,239
código de montagem que é gerado para o seu

2584
01:39:52,239 --> 01:39:54,400
c plus código este é algo a

2585
01:39:54,400 --> 01:39:56,639
Um pouco avançado para nossos propósitos

2586
01:39:56,639 --> 01:39:58,719
Aqui, então vamos ignorar isso, estamos

2587
01:39:58,719 --> 01:40:01,679
só vou usá-lo para testar o nosso

2588
01:40:01,679 --> 01:40:04,159
código com alguns dos compiladores populares

2589
01:40:04,159 --> 01:40:07,040
Se você olhar aqui nesta caixa solta você

2590
01:40:07,040 --> 01:40:08,880
Veja que eles também têm um monte de

2591
01:40:08,880 --> 01:40:11,040
compiladores que você pode usar diferentes gcc

2592
01:40:11,040 --> 01:40:13,600
Compiladores eu acho que eles têm clã eles

2593
01:40:13,600 --> 01:40:16,800
até mesmo ter msvc como legal é isso para que você

2594
01:40:16,800 --> 01:40:20,080
pode usar um monte de compiladores gcc clang você

2595
01:40:20,080 --> 01:40:22,080
Veja que temos muitos compiladores de clãs

2596
01:40:22,080 --> 01:40:23,760
tem clang

2597
01:40:23,760 --> 01:40:26,480
11 aqui, então este é um bom caminho para

2598
01:40:26,480 --> 01:40:28,960
Experimente as coisas que vamos voltar

2599
01:40:28,960 --> 01:40:30,639
para o gcc

2600
01:40:30,639 --> 01:40:32,400
10 2

2601
01:40:32,400 --> 01:40:35,360
e eu notei que eu passei a bandeira de

2602
01:40:35,360 --> 01:40:38,719
c mais 20 para poder suportar c plus

2603
01:40:38,719 --> 01:40:41,520
mais 20. novamente se eu vier aqui no meu código

2604
01:40:41,520 --> 01:40:44,159
e dizer stdc para fora

2605
01:40:44,159 --> 01:40:45,360
O céu

2606
01:40:45,360 --> 01:40:46,639
É branco

2607
01:40:46,639 --> 01:40:48,239
Não se preocupe com esses erros que eles são

2608
01:40:48,239 --> 01:40:51,440
Vou embora em um minuto

2609
01:40:51,440 --> 01:40:53,440
Vamos aguardar a compilação do programa

2610
01:40:53,440 --> 01:40:55,840
Você vê que está compilando vamos esperar

2611
01:40:55,840 --> 01:40:58,800
Um minuto o céu é branco e tudo

2612
01:40:58,800 --> 01:40:59,920
Está tudo bem

2613
01:40:59,920 --> 01:41:01,920
se você não vê essa saída aqui é

2614
01:41:01,920 --> 01:41:04,000
Possível que você não tenha verificado isso

2615
01:41:04,000 --> 01:41:06,800
a caixa de seleção executar a saída compilada

2616
01:41:06,800 --> 01:41:08,320
então venha para isso

2617
01:41:08,320 --> 01:41:10,719
dropbox e certifique-se de que isso está marcado

2618
01:41:10,719 --> 01:41:13,040
e você deve ter uma janela como eu tenho

2619
01:41:13,040 --> 01:41:16,239
aqui compilador explorador também permite que você

2620
01:41:16,239 --> 01:41:18,880
para compartilhar seu código com pessoas no

2621
01:41:18,880 --> 01:41:20,000
Internet

2622
01:41:20,000 --> 01:41:22,960
Deixe-me ver se posso encontrar a opção para

2623
01:41:22,960 --> 01:41:24,000
Compartilhe

2624
01:41:24,000 --> 01:41:27,679
Você vem a esta caixa e você recebe um

2625
01:41:27,679 --> 01:41:30,400
link aqui que você pode copiar

2626
01:41:30,400 --> 01:41:33,119
Eu vou copiar isso

2627
01:41:33,119 --> 01:41:36,000
e abrir uma janela privada no meu navegador

2628
01:41:36,000 --> 01:41:38,480
Aqui, para que saibamos que é um pouco

2629
01:41:38,480 --> 01:41:39,440
O outro

2630
01:41:39,440 --> 01:41:42,400
navegador que vai abrir isso

2631
01:41:42,400 --> 01:41:44,719
link e acesso ao mesmo código

2632
01:41:44,719 --> 01:41:47,199
nós temos no compilador explorador e isso é

2633
01:41:47,199 --> 01:41:48,719
indo para ser muito legal

2634
01:41:48,719 --> 01:41:50,480
e você vê que nós olhemos compilador

2635
01:41:50,480 --> 01:41:52,320
Explorador de privacidade que vamos fechar

2636
01:41:52,320 --> 01:41:53,119
Isto é

2637
01:41:53,119 --> 01:41:55,040
E você vê que temos o mesmo código

2638
01:41:55,040 --> 01:41:57,199
podemos tentar modificar este código para

2639
01:41:57,199 --> 01:41:59,199
Por exemplo, podemos tirar esta terceira linha

2640
01:41:59,199 --> 01:42:01,440
Aqui vai começar a compilar você

2641
01:42:01,440 --> 01:42:03,760
Veja que está compilando e está indo

2642
01:42:03,760 --> 01:42:06,000
para nos dar a saída que esperamos

2643
01:42:06,000 --> 01:42:08,639
A partir disso, então esta é uma ferramenta muito boa

2644
01:42:08,639 --> 01:42:11,760
para experimentar se você quiser compartilhar seu

2645
01:42:11,760 --> 01:42:14,320
código com algumas pessoas que não estão perto

2646
01:42:14,320 --> 01:42:16,000
Para você, esta é uma boa maneira de fazer

2647
01:42:16,000 --> 01:42:18,719
Isso também é bom experimentar

2648
01:42:18,719 --> 01:42:21,199
Compiladores diferentes, por exemplo, se você

2649
01:42:21,199 --> 01:42:24,320
Não tem um compilador gcc você pode experimentá-lo

2650
01:42:24,320 --> 01:42:26,480
Aqui e ver se faz coisas para

2651
01:42:26,480 --> 01:42:29,440
exemplo, não instalamos o clang em nosso

2652
01:42:29,440 --> 01:42:32,000
sistema, mas podemos experimentá-lo e ver se

2653
01:42:32,000 --> 01:42:34,880
ele corre ou poderia, mas certifique-se de passar

2654
01:42:34,880 --> 01:42:37,360
os apartamentos corretos aqui porque você é

2655
01:42:37,360 --> 01:42:39,600
responsável por isso se você passar o

2656
01:42:39,600 --> 01:42:41,600
apartamentos que não funcionam

2657
01:42:41,600 --> 01:42:43,679
Você vai ter flechas, por exemplo

2658
01:42:43,679 --> 01:42:46,639
Se dissermos olá aqui

2659
01:42:46,639 --> 01:42:47,920
nós vamos conseguir

2660
01:42:47,920 --> 01:42:49,840
flechas estranhas

2661
01:42:49,840 --> 01:42:52,880
e oh e reconhecer a opção de linha de comando

2662
01:42:52,880 --> 01:42:57,280
std hello, mas se dissermos c mais 20

2663
01:42:57,280 --> 01:42:59,119
Vai funcionar, então certifique-se de que você

2664
01:42:59,119 --> 01:43:01,520
passar as opções corretas

2665
01:43:01,520 --> 01:43:03,199
Nesta palestra você vai escrever

2666
01:43:03,199 --> 01:43:06,320
seu primeiro programa c mais 20 e nós somos

2667
01:43:06,320 --> 01:43:08,639
Vou começar e tentar entender

2668
01:43:08,639 --> 01:43:10,880
nosso programa vamos pular para o visual

2669
01:43:10,880 --> 01:43:13,440
código de estúdio e realmente fazer isso

2670
01:43:13,440 --> 01:43:15,679
A primeira coisa que queremos fazer é estabelecer

2671
01:43:15,679 --> 01:43:18,480
nosso código para que possamos abrir isso em

2672
01:43:18,480 --> 01:43:20,880
código de estúdio visual que vamos começar

2673
01:43:20,880 --> 01:43:24,400
do nosso projeto de modelo c mais 20 que

2674
01:43:24,400 --> 01:43:26,400
Atuamos na última palestra

2675
01:43:26,400 --> 01:43:28,480
E eu vou fazer os projetos

2676
01:43:28,480 --> 01:43:31,280
para este capítulo nesta pasta aqui assim

2677
01:43:31,280 --> 01:43:33,440
nós vamos fazer o nosso primeiro c plus

2678
01:43:33,440 --> 01:43:35,679
além do programa para o que vamos fazer

2679
01:43:35,679 --> 01:43:39,280
é entrar no nosso modelo c plus mais 20

2680
01:43:39,280 --> 01:43:40,560
Projeto

2681
01:43:40,560 --> 01:43:42,719
e eu notei que nós realmente saímos

2682
01:43:42,719 --> 01:43:45,520
Os arquivos cozidos que não queremos assim

2683
01:43:45,520 --> 01:43:47,600
O que vamos fazer é remover isso

2684
01:43:47,600 --> 01:43:49,199
arquivo principal

2685
01:43:49,199 --> 01:43:52,080
e que este vc 140 fã nós não queremos

2686
01:43:52,080 --> 01:43:54,080
Estes aqui

2687
01:43:54,080 --> 01:43:55,920
E nós vamos copiar

2688
01:43:55,920 --> 01:43:59,760
O arquivo principal cpp e o dot vs código

2689
01:43:59,760 --> 01:44:02,080
pasta vamos copiar essas coisas

2690
01:44:02,080 --> 01:44:04,800
E nós vamos colocá-los em nosso primeiro

2691
01:44:04,800 --> 01:44:07,199
c plus folder do programa

2692
01:44:07,199 --> 01:44:08,960
e nós vamos abrir esta pasta em

2693
01:44:08,960 --> 01:44:11,760
Código visual do estúdio visual é código visual

2694
01:44:11,760 --> 01:44:14,400
não abriu você vê que eu tenho o meu

2695
01:44:14,400 --> 01:44:17,280
Desenvolvedor powershell aberto se você quiser

2696
01:44:17,280 --> 01:44:19,600
você pode abrir o código do estúdio visual diretamente

2697
01:44:19,600 --> 01:44:21,520
Sem passar por isso se você não estiver

2698
01:44:21,520 --> 01:44:23,119
Vou usar o estúdio visual

2699
01:44:23,119 --> 01:44:26,000
Compilador mas quero ter a opção

2700
01:44:26,000 --> 01:44:28,320
para usar esse compilador, então é assim que eu sou

2701
01:44:28,320 --> 01:44:30,320
abrir meu código de estúdio visual

2702
01:44:30,320 --> 01:44:32,840
A instância eu vou digitar

2703
01:44:32,840 --> 01:44:34,719
code.exe

2704
01:44:34,719 --> 01:44:37,280
para abrir isso eu vou bater Enter

2705
01:44:37,280 --> 01:44:39,679
e o código visual do estúdio vai abrir

2706
01:44:39,679 --> 01:44:41,679
E vai abrir tudo o que fizemos

2707
01:44:41,679 --> 01:44:44,080
Na última palestra não queremos isso

2708
01:44:44,080 --> 01:44:46,159
projeto porque este é um modelo

2709
01:44:46,159 --> 01:44:48,159
Projeto do último capítulo que somos

2710
01:44:48,159 --> 01:44:51,280
indo para fechar esta pasta ir para o arquivo

2711
01:44:51,280 --> 01:44:52,639
e bater

2712
01:44:52,639 --> 01:44:54,960
fechar a pasta e vamos abrir o

2713
01:44:54,960 --> 01:44:57,679
nova pasta que queremos trabalhar em nós somos

2714
01:44:57,679 --> 01:45:00,560
indo para o arquivo e aperte a pasta aberta

2715
01:45:00,560 --> 01:45:02,239
nós vamos para o local onde

2716
01:45:02,239 --> 01:45:04,239
Nosso projeto é para que você vá

2717
01:45:04,239 --> 01:45:06,080
onde você está eu vou navegar para

2718
01:45:06,080 --> 01:45:07,040
mina

2719
01:45:07,040 --> 01:45:08,960
E eu vou para a corrente

2720
01:45:08,960 --> 01:45:12,960
capítulo e escolha 3 2 primeiro c plus plus

2721
01:45:12,960 --> 01:45:14,000
O programa

2722
01:45:14,000 --> 01:45:16,639
Vou selecionar a pasta

2723
01:45:16,639 --> 01:45:18,480
Vai se abrir e você está indo

2724
01:45:18,480 --> 01:45:20,800
para ver que nossas configurações a partir de

2725
01:45:20,800 --> 01:45:24,400
O último projeto de modelo ainda está

2726
01:45:24,400 --> 01:45:27,040
válido aqui eles foram copiados se nós

2727
01:45:27,040 --> 01:45:29,040
abrir o arquivo cpp principal será

2728
01:45:29,040 --> 01:45:30,639
A principal coisa que tivemos no último

2729
01:45:30,639 --> 01:45:31,679
A palestra

2730
01:45:31,679 --> 01:45:32,400
Então,

2731
01:45:32,400 --> 01:45:34,960
nós temos a opção de executar a tarefa que você é

2732
01:45:34,960 --> 01:45:37,119
Vamos ver que temos dois compiladores

2733
01:45:37,119 --> 01:45:39,760
disponível e isso é muito bom

2734
01:45:39,760 --> 01:45:42,400
Pronto para começar a usar isso, vamos tentar

2735
01:45:42,400 --> 01:45:45,119
Construa isso com gcc

2736
01:45:45,119 --> 01:45:47,199
E nós vamos ter o nosso binário

2737
01:45:47,199 --> 01:45:48,480
Criado

2738
01:45:48,480 --> 01:45:51,440
Podemos clicar no terminal aqui

2739
01:45:51,440 --> 01:45:53,360
e se queremos abrir o terminal

2740
01:45:53,360 --> 01:45:54,880
Mais uma vez temos a opção de entrar

2741
01:45:54,880 --> 01:45:57,840
terminal e novo terminal que está indo

2742
01:45:57,840 --> 01:46:00,480
para abrir isso se fizermos dir no

2743
01:46:00,480 --> 01:46:01,679
O terminal

2744
01:46:01,679 --> 01:46:04,560
Vamos ver o nosso programa gerado

2745
01:46:04,560 --> 01:46:07,679
nós podemos remover esta coisa aqui e dizer rm

2746
01:46:07,679 --> 01:46:08,719
Galo

2747
01:46:08,719 --> 01:46:13,520
dot exe e remover isso nós podemos limpar

2748
01:46:13,520 --> 01:46:15,679
e nós temos um projeto limpo que podemos começar

2749
01:46:15,679 --> 01:46:17,840
aprendendo do OK agora que temos o

2750
01:46:17,840 --> 01:46:20,159
projeto e está construindo com sucesso

2751
01:46:20,159 --> 01:46:22,639
Vamos tentar entender o código que temos

2752
01:46:22,639 --> 01:46:25,280
Aqui, a primeira declaração, temos

2753
01:46:25,280 --> 01:46:28,000
isto inclui io stream thung

2754
01:46:28,000 --> 01:46:31,040
este é um recurso c plus plus ofertas para

2755
01:46:31,040 --> 01:46:34,000
carregar as bibliotecas pró construídas que podemos

2756
01:46:34,000 --> 01:46:37,040
usar iostream está indo especificamente para

2757
01:46:37,040 --> 01:46:39,600
Ajude-nos a imprimir graças ao console

2758
01:46:39,600 --> 01:46:42,000
Vimos que podemos, por exemplo, imprimir

2759
01:46:42,000 --> 01:46:43,280
Olá do mundo

2760
01:46:43,280 --> 01:46:44,480
Se nós queremos

2761
01:46:44,480 --> 01:46:47,600
Vamos tirar todas essas coisas aqui

2762
01:46:47,600 --> 01:46:51,679
e dizer std coluna coluna c para fora

2763
01:46:51,679 --> 01:46:54,639
Isto vem do i iostream e nós estamos

2764
01:46:54,639 --> 01:46:57,440
Vou colocar dois menos do que símbolos nós somos

2765
01:46:57,440 --> 01:46:59,920
abrir duas citações e dentro

2766
01:46:59,920 --> 01:47:02,080
nós vamos digitar o hello world

2767
01:47:02,080 --> 01:47:05,040
e nós vamos sair das citações

2768
01:47:05,040 --> 01:47:09,520
e fazer dois menos do que sinais e dizer std

2769
01:47:09,520 --> 01:47:12,320
endol do cólon do cólon

2770
01:47:12,320 --> 01:47:14,800
e colocar um ponto e vírgula isso vai

2771
01:47:14,800 --> 01:47:16,960
imprimir coisas no console se corrermos

2772
01:47:16,960 --> 01:47:18,400
este programa

2773
01:47:18,400 --> 01:47:21,520
Se executarmos este programa o primeiro

2774
01:47:21,520 --> 01:47:23,600
O que precisamos fazer é construir isso

2775
01:47:23,600 --> 01:47:26,719
programa para que possamos chegar à tarefa terminal

2776
01:47:26,719 --> 01:47:29,760
e nós vamos construí-lo com gcc e

2777
01:47:29,760 --> 01:47:32,480
depois de construí-lo, podemos entrar para

2778
01:47:32,480 --> 01:47:34,239
Feche o terminal

2779
01:47:34,239 --> 01:47:36,880
e nós podemos fazer sujeira para ver o conteúdo de

2780
01:47:36,880 --> 01:47:38,800
A pasta que você vê que um programa tem

2781
01:47:38,800 --> 01:47:41,600
Foi gerado, podemos executá-lo e se nós

2782
01:47:41,600 --> 01:47:43,440
Executá-lo, vai dizer olá mundo

2783
01:47:43,440 --> 01:47:46,320
Esta mensagem vem disso

2784
01:47:46,320 --> 01:47:48,560
Declaração aqui e nós temos isso

2785
01:47:48,560 --> 01:47:51,679
declaração porque incluímos io

2786
01:47:51,679 --> 01:47:54,400
fluxo para realmente deixar isso super claro

2787
01:47:54,400 --> 01:47:57,040
Podemos tentar remover essa linha que diz

2788
01:47:57,040 --> 01:47:59,040
incluir o io stream

2789
01:47:59,040 --> 01:48:00,960
E no momento em que fazemos isso você está indo

2790
01:48:00,960 --> 01:48:03,280
para ver que esta guia diz que temos

2791
01:48:03,280 --> 01:48:04,480
problemas

2792
01:48:04,480 --> 01:48:07,040
e se você abrir esta aba

2793
01:48:07,040 --> 01:48:08,639
Você vai ver a mensagem

2794
01:48:08,639 --> 01:48:11,600
namespace sdd não tem nenhum membro c out name

2795
01:48:11,600 --> 01:48:14,639
espaço std não tem membro a e dl

2796
01:48:14,639 --> 01:48:16,080
Isto é porque

2797
01:48:16,080 --> 01:48:18,480
O programa z plus plus não sabe

2798
01:48:18,480 --> 01:48:21,440
O que o esddc significa porque nós não

2799
01:48:21,440 --> 01:48:23,840
ter a biblioteca incluída e você também

2800
01:48:23,840 --> 01:48:25,920
Veja que temos essas linhas squiggly para

2801
01:48:25,920 --> 01:48:27,920
deixar bem claro que temos um

2802
01:48:27,920 --> 01:48:30,639
problema para realmente ser capaz de usar isso

2803
01:48:30,639 --> 01:48:34,159
Temos que incluir uma biblioteca de terceiros

2804
01:48:34,159 --> 01:48:36,400
que traz essas características para o nosso

2805
01:48:36,400 --> 01:48:38,800
programa e é isso que inclui

2806
01:48:38,800 --> 01:48:41,119
A declaração aqui está realmente fazendo isso, vamos

2807
01:48:41,119 --> 01:48:42,800
Trate isso para dentro

2808
01:48:42,800 --> 01:48:46,800
e nós vamos dizer eu o stream novamente

2809
01:48:46,800 --> 01:48:48,880
e vamos esperar e ver que o problema

2810
01:48:48,880 --> 01:48:50,159
Vai-se embora

2811
01:48:50,159 --> 01:48:51,920
E a única coisa que você realmente deve saber

2812
01:48:51,920 --> 01:48:54,320
é que nós não temos um ponto e vírgula no

2813
01:48:54,320 --> 01:48:57,440
Fim da declaração do io stream nós não fazemos

2814
01:48:57,440 --> 01:49:00,159
precisa colocá-lo lá, mas muitos c

2815
01:49:00,159 --> 01:49:03,040
plus plus declaração precisa de um ponto-e-vírgula em

2816
01:49:03,040 --> 01:49:04,080
o fim

2817
01:49:04,080 --> 01:49:06,320
Ok eu acho que isso realmente deixa claro

2818
01:49:06,320 --> 01:49:09,679
O que a declaração incluem aqui está fazendo

2819
01:49:09,679 --> 01:49:11,920
A outra coisa que temos em nosso programa

2820
01:49:11,920 --> 01:49:15,360
é este ant principal parêntese

2821
01:49:15,360 --> 01:49:17,520
curly braces coisa

2822
01:49:17,520 --> 01:49:19,760
Esta coisa aqui é chamada de principal

2823
01:49:19,760 --> 01:49:20,800
A função

2824
01:49:20,800 --> 01:49:23,520
uma função em c plus plus é um bloco de

2825
01:49:23,520 --> 01:49:26,080
Código que faz muitas coisas

2826
01:49:26,080 --> 01:49:28,880
Mas a função principal aqui é especial

2827
01:49:28,880 --> 01:49:31,360
Porque é o ponto de partida do seu

2828
01:49:31,360 --> 01:49:33,440
c plus plus programa

2829
01:49:33,440 --> 01:49:36,000
também chamamos a função principal de entrada

2830
01:49:36,000 --> 01:49:38,719
Ponto do programa c plus plus e

2831
01:49:38,719 --> 01:49:41,040
O que isso significa é que se você abrir o

2832
01:49:41,040 --> 01:49:43,760
programar a função principal será

2833
01:49:43,760 --> 01:49:46,239
A primeira coisa que vai

2834
01:49:46,239 --> 01:49:48,080
correr e as coisas vão ser

2835
01:49:48,080 --> 01:49:50,880
executados na função principal em ordem

2836
01:49:50,880 --> 01:49:52,880
Então a declaração no topo vai

2837
01:49:52,880 --> 01:49:55,280
correr primeiro e a declaração depois disso

2838
01:49:55,280 --> 01:49:57,360
até atingirmos o fim da função

2839
01:49:57,360 --> 01:49:59,360
Isto é o que queremos dizer aqui para realmente

2840
01:49:59,360 --> 01:50:02,159
conduzir esta casa que podemos vir aqui em nosso

2841
01:50:02,159 --> 01:50:05,520
função principal e dizer sdd

2842
01:50:05,520 --> 01:50:06,880
Número um

2843
01:50:06,880 --> 01:50:11,520
e dizer sdd e pelo caminho este e n

2844
01:50:11,520 --> 01:50:13,840
d l declaração vai imprimir um novo

2845
01:50:13,840 --> 01:50:14,960
linha de linha

2846
01:50:14,960 --> 01:50:16,080
nós vamos

2847
01:50:16,080 --> 01:50:19,520
Veja isso em prática em um momento, vamos

2848
01:50:19,520 --> 01:50:22,000
realmente tirar isso para que possamos ver

2849
01:50:22,000 --> 01:50:25,199
seu efeito nós vamos também fazer sddc

2850
01:50:25,199 --> 01:50:28,000
O número dois

2851
01:50:28,000 --> 01:50:30,159
E o que isso vai fazer

2852
01:50:30,159 --> 01:50:33,280
é imprimir o número um e o número dois em

2853
01:50:33,280 --> 01:50:36,719
O terminal vamos construir este programa

2854
01:50:36,719 --> 01:50:38,960
e se você quiser construir o padrão

2855
01:50:38,960 --> 01:50:42,080
tarefa que você pode bater ctrl shift b para ele

2856
01:50:42,080 --> 01:50:44,719
Acontece muito rápido, mas eu estou sempre indo

2857
01:50:44,719 --> 01:50:47,520
para vir aqui para que seja realmente claro

2858
01:50:47,520 --> 01:50:50,239
O que estou fazendo um programa deve ser

2859
01:50:50,239 --> 01:50:53,599
gerado agora se tentarmos executá-lo

2860
01:50:53,599 --> 01:50:55,000
digitando

2861
01:50:55,000 --> 01:50:58,080
galoster.exe e novamente podemos bater

2862
01:50:58,080 --> 01:51:01,119
o botão de seta do aplicativo em nosso teclado

2863
01:51:01,119 --> 01:51:03,760
É o último comando do qual corremos

2864
01:51:03,760 --> 01:51:05,760
Este terminal funciona e isso vai

2865
01:51:05,760 --> 01:51:07,840
acelerar as coisas um pouco, então se nós

2866
01:51:07,840 --> 01:51:10,080
executar este programa deve dizer número

2867
01:51:10,080 --> 01:51:13,199
Um e número dois como você vê aqui

2868
01:51:13,199 --> 01:51:16,239
Mas essas duas coisas estão apertadas em uma

2869
01:51:16,239 --> 01:51:19,040
A linha e a razão é que não somos

2870
01:51:19,040 --> 01:51:21,679
imprimir novos personagens da linha depois nós

2871
01:51:21,679 --> 01:51:24,320
imprimir número um e número dois e nós

2872
01:51:24,320 --> 01:51:28,000
pode resolver este problema colocando em dois

2873
01:51:28,000 --> 01:51:31,440
menos do que símbolos e dizer coluna std

2874
01:51:31,440 --> 01:51:33,679
coluna e n d l

2875
01:51:33,679 --> 01:51:35,440
Isso vai colocar uma nova linha

2876
01:51:35,440 --> 01:51:38,000
personagem após o número um que podemos construir

2877
01:51:38,000 --> 01:51:39,119
Mais uma vez

2878
01:51:39,119 --> 01:51:42,159
para nossas novas mudanças no efeito tecnológico

2879
01:51:42,159 --> 01:51:43,679
Depois de fazer isso, nós clicamos no

2880
01:51:43,679 --> 01:51:46,800
terminal hit enter nós atingimos a seta do aplicativo

2881
01:51:46,800 --> 01:51:48,880
botão se corrermos, vai dizer

2882
01:51:48,880 --> 01:51:51,599
número um e número dois em dois

2883
01:51:51,599 --> 01:51:54,159
linhas separadas porque estamos imprimindo um

2884
01:51:54,159 --> 01:51:56,639
Novo caractere de linha após o número um i

2885
01:51:56,639 --> 01:51:58,719
Realmente espero que isso faça sentido

2886
01:51:58,719 --> 01:52:00,960
Por favor, tome algum tempo para brincar conosco

2887
01:52:00,960 --> 01:52:02,960
Porque se esta é a primeira vez que você é

2888
01:52:02,960 --> 01:52:05,280
Fazendo isso algumas coisas podem não ser

2889
01:52:05,280 --> 01:52:08,000
claro e a melhor maneira de realmente fazer

2890
01:52:08,000 --> 01:52:10,880
senso disso é digitar código executá-lo e

2891
01:52:10,880 --> 01:52:13,119
Veja o efeito do que você digita

2892
01:52:13,119 --> 01:52:15,119
executando seu programa, então vamos fazer isso a

2893
01:52:15,119 --> 01:52:17,280
Algumas vezes vamos fazer o sdd

2894
01:52:17,280 --> 01:52:19,119
endl

2895
01:52:19,119 --> 01:52:20,400
Depois de

2896
01:52:20,400 --> 01:52:22,960
A declaração para o número dois vamos

2897
01:52:22,960 --> 01:52:25,360
para fazer stdc para fora

2898
01:52:25,360 --> 01:52:28,080
Número três

2899
01:52:28,159 --> 01:52:32,080
e nós vamos fazer stdeandl

2900
01:52:32,080 --> 01:52:34,719
para realmente mostrar o problema novamente

2901
01:52:34,719 --> 01:52:36,040
Vou levar para fora

2902
01:52:36,040 --> 01:52:39,280
stdendl na linha número dois

2903
01:52:39,280 --> 01:52:41,920
Nós vamos soldar a construção está indo

2904
01:52:41,920 --> 01:52:43,520
para ser bem sucedido

2905
01:52:43,520 --> 01:52:45,599
nós vamos clicar no terminal hit

2906
01:52:45,599 --> 01:52:48,480
Enter clique no botão de seta do aplicativo executar o

2907
01:52:48,480 --> 01:52:50,159
programa novamente e você vai ver

2908
01:52:50,159 --> 01:52:52,239
Está a dizer que o número um está a acontecer

2909
01:52:52,239 --> 01:52:55,199
nova linha de impressão número dois, mas nós não

2910
01:52:55,199 --> 01:52:57,199
para saltar para a nova linha do número

2911
01:52:57,199 --> 01:52:59,920
Dois assim o número dois e o número três são

2912
01:52:59,920 --> 01:53:02,320
Vou ser apertado em uma linha que é

2913
01:53:02,320 --> 01:53:04,800
O que vemos aqui podemos resolver isso novamente

2914
01:53:04,800 --> 01:53:07,440
colocando em uma nova linha após o número

2915
01:53:07,440 --> 01:53:08,639
Dois dos dois

2916
01:53:08,639 --> 01:53:10,480
Vamos fazer std

2917
01:53:10,480 --> 01:53:12,480
e e d l aqui

2918
01:53:12,480 --> 01:53:14,960
E uh isso deve resolver o problema

2919
01:53:14,960 --> 01:53:17,280
novamente vamos construir, vamos executar o nosso

2920
01:53:17,280 --> 01:53:19,760
construir a tarefa que a construção vai ser

2921
01:53:19,760 --> 01:53:21,440
Bem sucedido vamos chegar ao aplicativo

2922
01:53:21,440 --> 01:53:23,599
seta para executar o programa se nós executá-lo

2923
01:53:23,599 --> 01:53:25,840
Vai dizer o número um número dois

2924
01:53:25,840 --> 01:53:28,880
e número três e isso é realmente bom

2925
01:53:28,880 --> 01:53:31,599
Agora deve ficar claro que declarações

2926
01:53:31,599 --> 01:53:34,400
na função principal são executados em ordem

2927
01:53:34,400 --> 01:53:36,719
de cima para baixo e que o programa

2928
01:53:36,719 --> 01:53:40,320
vai acabar quando chegar ao fim do

2929
01:53:40,320 --> 01:53:43,520
Esta cinta encaracolada que inclui o nosso

2930
01:53:43,520 --> 01:53:45,599
Função, vamos ter uma chance de

2931
01:53:45,599 --> 01:53:47,679
Saiba mais sobre funções

2932
01:53:47,679 --> 01:53:50,400
em detalhes mais tarde no curso, mas nós somos

2933
01:53:50,400 --> 01:53:52,080
apenas começando e precisamos

2934
01:53:52,080 --> 01:53:54,080
Começar em algum lugar, então é por isso que estamos

2935
01:53:54,080 --> 01:53:56,400
fazendo essa coisa principal da função aqui

2936
01:53:56,400 --> 01:53:59,520
Outra coisa que você pode fazer é voltar de

2937
01:53:59,520 --> 01:54:02,560
A função principal e em muitos exemplos

2938
01:54:02,560 --> 01:54:05,199
Você vai ver as pessoas voltarem 0

2939
01:54:05,199 --> 01:54:06,800
Algo assim

2940
01:54:06,800 --> 01:54:09,360
Este é um caminho para a função principal

2941
01:54:09,360 --> 01:54:12,239
para enviar a mensagem para a operação

2942
01:54:12,239 --> 01:54:15,280
sistema se terminar com sucesso ou

2943
01:54:15,280 --> 01:54:17,599
Se houvesse algum tipo de problema

2944
01:54:17,599 --> 01:54:19,520
Não vamos entrar mais

2945
01:54:19,520 --> 01:54:21,360
detalhes sobre a função principal porque

2946
01:54:21,360 --> 01:54:22,560
Isso é realmente

2947
01:54:22,560 --> 01:54:25,119
Muito por agora estamos apenas recebendo

2948
01:54:25,119 --> 01:54:27,840
Comecemos a tentar ter uma sensação de

2949
01:54:27,840 --> 01:54:30,719
Como c plus funciona a mensagem principal aqui

2950
01:54:30,719 --> 01:54:33,280
É realmente que você deve ser capaz de

2951
01:54:33,280 --> 01:54:36,560
Imprimir coisas para o console usando sddc

2952
01:54:36,560 --> 01:54:38,880
Você deve ser capaz de imprimir um novo

2953
01:54:38,880 --> 01:54:40,960
linha após sua mensagem

2954
01:54:40,960 --> 01:54:45,880
usando sdd ndl este stdc para fora e

2955
01:54:45,880 --> 01:54:49,599
stdendl Agradecer vem do iostream

2956
01:54:49,599 --> 01:54:52,239
biblioteca que estamos incluindo aqui

2957
01:54:52,239 --> 01:54:53,920
Se não incluirmos esta biblioteca, somos

2958
01:54:53,920 --> 01:54:56,159
Vou ter problemas porque

2959
01:54:56,159 --> 01:54:58,480
O nosso excedente mais programa não vai

2960
01:54:58,480 --> 01:55:00,960
Saiba de onde eles estão vindo, então nós

2961
01:55:00,960 --> 01:55:03,280
deveria realmente colocar isso se quisermos

2962
01:55:03,280 --> 01:55:04,960
Use esses recursos

2963
01:55:04,960 --> 01:55:07,679
e nós podemos voltar de uma função para deixar

2964
01:55:07,679 --> 01:55:10,560
O sistema conhece o sistema operacional

2965
01:55:10,560 --> 01:55:13,599
se o programa terminou com sucesso

2966
01:55:13,599 --> 01:55:16,320
ou se houvesse algum tipo de problema e

2967
01:55:16,320 --> 01:55:18,400
Mais uma vez este projeto está usando o

2968
01:55:18,400 --> 01:55:20,320
modelos que já fizemos antes

2969
01:55:20,320 --> 01:55:22,480
E isso é realmente tudo o que nos prossistimos

2970
01:55:22,480 --> 01:55:25,199
Nesta palestra tentando dar sentido a

2971
01:55:25,199 --> 01:55:27,679
A principal função em c plus plus para

2972
01:55:27,679 --> 01:55:29,920
realmente pratique essas coisas que eu faria

2973
01:55:29,920 --> 01:55:32,000
desafiar você a escrever um c plus plus

2974
01:55:32,000 --> 01:55:34,159
Programa assim que vai

2975
01:55:34,159 --> 01:55:37,199
imprimir seu nome 10 vezes tente fazer isso

2976
01:55:37,199 --> 01:55:39,520
e se você tiver um problema, por favor, pergunte

2977
01:55:39,520 --> 01:55:42,080
Eu e eu vamos fazer o melhor que posso para ajudar

2978
01:55:42,080 --> 01:55:43,119
Você está fora

2979
01:55:43,119 --> 01:55:44,800
Isso é realmente tudo o que nos prossamos fazer em

2980
01:55:44,800 --> 01:55:46,320
Esta palestra espero que você a tenha encontrado

2981
01:55:46,320 --> 01:55:48,159
interessante, vamos parar por aqui

2982
01:55:48,159 --> 01:55:49,760
Esta palestra no próximo vamos

2983
01:55:49,760 --> 01:55:52,239
para começar e aprender sobre comentários em c

2984
01:55:52,239 --> 01:55:55,040
mais mais vá em frente e termine aqui

2985
01:55:55,040 --> 01:55:56,560
e me encontrar lá

2986
01:55:56,560 --> 01:55:57,920
Nesta palestra vamos aprender

2987
01:55:57,920 --> 01:56:00,560
sobre comentários e c plus mais

2988
01:56:00,560 --> 01:56:02,800
Os comentários são o caminho para colocar alguns

2989
01:56:02,800 --> 01:56:05,920
mensagens em seu c plus mais acorde que

2990
01:56:05,920 --> 01:56:08,159
São realmente feitos para serem lidos por humanos

2991
01:56:08,159 --> 01:56:10,320
e uma maneira que temos que fazer comentários em c

2992
01:56:10,320 --> 01:56:12,560
plus plus é através desta barragem

2993
01:56:12,560 --> 01:56:14,880
A coisa da reação que temos aqui é

2994
01:56:14,880 --> 01:56:17,040
Vou comentar a linha, então o

2995
01:56:17,040 --> 01:56:18,719
Compilador realmente não vai se importar

2996
01:56:18,719 --> 01:56:20,639
sobre isso vai pensar que é

2997
01:56:20,639 --> 01:56:22,080
Algo que é para o

2998
01:56:22,080 --> 01:56:24,880
Desenvolvedor para ver, então esta é uma linha

2999
01:56:24,880 --> 01:56:26,880
Comentário e é assim que você faz isso em c

3000
01:56:26,880 --> 01:56:29,520
plus plus você também pode comentar a

3001
01:56:29,520 --> 01:56:31,760
Bloco de código em seu código c mais ônibus

3002
01:56:31,760 --> 01:56:33,360
E isso é algo que entra

3003
01:56:33,360 --> 01:56:35,840
bastante útil muitas vezes você coloca seu

3004
01:56:35,840 --> 01:56:39,040
comentário em uma estrela de barras e uma estrela

3005
01:56:39,040 --> 01:56:41,440
backslash assim isso vai

3006
01:56:41,440 --> 01:56:43,679
Comentar as coisas no seu código e no

3007
01:56:43,679 --> 01:56:45,520
Compilador realmente não vai se importar

3008
01:56:45,520 --> 01:56:47,760
sobre isso vamos pular para o visual

3009
01:56:47,760 --> 01:56:50,239
código de estúdio e realmente jogar com a gente assim

3010
01:56:50,239 --> 01:56:52,159
Aqui estamos na pasta que está indo

3011
01:56:52,159 --> 01:56:54,239
para conter o nosso código a primeira coisa que eu sou

3012
01:56:54,239 --> 01:56:55,920
Ir fazer é passar pelo modelo

3013
01:56:55,920 --> 01:56:58,639
Projeto eu vou copiar meus arquivos

3014
01:56:58,639 --> 01:57:00,560
E eu vou subir de novo e nós estamos

3015
01:57:00,560 --> 01:57:02,480
Vou aprender sobre comentários assim

3016
01:57:02,480 --> 01:57:04,480
Eu vou colocar isso na pasta em

3017
01:57:04,480 --> 01:57:07,360
comentários eu vou fechar tudo

3018
01:57:07,360 --> 01:57:09,760
pasta que abrimos no estúdio visual

3019
01:57:09,760 --> 01:57:11,760
código e eu vou navegar para o

3020
01:57:11,760 --> 01:57:14,159
Localização onde meu projeto em comentário

3021
01:57:14,159 --> 01:57:15,360
Diz que

3022
01:57:15,360 --> 01:57:17,920
O meu projeto está nesta pasta que é

3023
01:57:17,920 --> 01:57:20,080
mete três comentários que vou fazer

3024
01:57:20,080 --> 01:57:22,480
abra a pasta e se eu abrir o principal

3025
01:57:22,480 --> 01:57:25,199
cpp arquivo eu vou encontrar o iniciador

3026
01:57:25,199 --> 01:57:27,360
projeto vamos remover este const

3027
01:57:27,360 --> 01:57:29,280
eval obrigado porque nós realmente não somos

3028
01:57:29,280 --> 01:57:31,520
Pronto para entender isso, ainda estava em

3029
01:57:31,520 --> 01:57:33,440
Aqui para nos ajudar

3030
01:57:33,440 --> 01:57:36,320
teste que nossos compiladores suportam c plus

3031
01:57:36,320 --> 01:57:38,719
mais 20. então vamos remover isso

3032
01:57:38,719 --> 01:57:40,480
e nós vamos colocar em uma mensagem que

3033
01:57:40,480 --> 01:57:42,960
Diga olá mundo que você já sabe como

3034
01:57:42,960 --> 01:57:45,119
fazer isso desde a última palestra, então estamos

3035
01:57:45,119 --> 01:57:47,280
indo para dizer sddc para fora

3036
01:57:47,280 --> 01:57:50,599
Olá mundo e nós vamos dizer

3037
01:57:50,599 --> 01:57:54,239
stdendl e não se esqueça deste ponto e-vírgula

3038
01:57:54,239 --> 01:57:55,920
No final, se você fizer você vai

3039
01:57:55,920 --> 01:57:58,320
ter problemas para garantir que seu código

3040
01:57:58,320 --> 01:58:00,880
Parece que isso tenta construí-lo para fazer

3041
01:58:00,880 --> 01:58:03,920
Certamente está funcionando bem, isso vai fazer

3042
01:58:03,920 --> 01:58:07,119
executar o mundo tarefa Gcc que podemos clicar

3043
01:58:07,119 --> 01:58:09,280
o terminal aqui e vai

3044
01:58:09,280 --> 01:58:10,800
Feche o terminal

3045
01:58:10,800 --> 01:58:13,599
e podemos abrir um novo terminal aqui se

3046
01:58:13,599 --> 01:58:16,639
Queremos que se fizermos o Dir, vamos encontrar

3047
01:58:16,639 --> 01:58:19,360
nosso programa de galo dentro, podemos executá-lo

3048
01:58:19,360 --> 01:58:21,679
E vai dizer olá mundo

3049
01:58:21,679 --> 01:58:23,360
Já sabe fazer isso desde o último

3050
01:58:23,360 --> 01:58:25,440
palestra e nesta que vamos

3051
01:58:25,440 --> 01:58:28,159
Aprendendo sobre os comentários, o primeiro

3052
01:58:28,159 --> 01:58:31,119
O que você pode fazer é usar barra de barra, então

3053
01:58:31,119 --> 01:58:32,639
Vamos fazer isso

3054
01:58:32,639 --> 01:58:36,159
E uh vamos colocar alguma mensagem aqui

3055
01:58:36,159 --> 01:58:40,080
branch e a biblioteca do iôstream este

3056
01:58:40,080 --> 01:58:41,679
uma mensagem agradável que vai dar

3057
01:58:41,679 --> 01:58:44,000
Mais informações sobre isso

3058
01:58:44,000 --> 01:58:46,159
Declaração para quem quer que esteja lendo

3059
01:58:46,159 --> 01:58:48,159
Este programa e isso é chamado de um

3060
01:58:48,159 --> 01:58:50,239
comentário de linha que você pode realmente colocar isso

3061
01:58:50,239 --> 01:58:52,320
Onde você quiser em seu c plus plus

3062
01:58:52,320 --> 01:58:54,639
arquivo que podemos ir na função principal para

3063
01:58:54,639 --> 01:58:56,800
exemplo e dizer que isso vai imprimir

3064
01:58:56,800 --> 01:58:59,119
Olá mundo para o console ou a

3065
01:58:59,119 --> 01:59:01,520
terminal, podemos realmente colocar isso em qualquer lugar

3066
01:59:01,520 --> 01:59:03,840
Podemos até colocá-lo após o retorno

3067
01:59:03,840 --> 01:59:06,320
declaração aqui e realmente colocar em

3068
01:59:06,320 --> 01:59:08,480
Seja qual for a informação que pensamos

3069
01:59:08,480 --> 01:59:10,800
Vai fazer sentido para onde quer que seja

3070
01:59:10,800 --> 01:59:13,599
Vou ler o nosso programa ok

3071
01:59:13,599 --> 01:59:16,239
É assim que você faz um comentário de linha

3072
01:59:16,239 --> 01:59:19,119
também pode fazer comentários em diferentes

3073
01:59:19,119 --> 01:59:21,360
linhas e a maneira que você faz que você coloca

3074
01:59:21,360 --> 01:59:23,040
Isso no

3075
01:59:23,040 --> 01:59:27,440
cortar estrela e ir para baixo e dizer estrela

3076
01:59:27,440 --> 01:59:29,679
cortar assim e tudo o que vai

3077
01:59:29,679 --> 01:59:31,760
estar no meio aqui vai ser um

3078
01:59:31,760 --> 01:59:33,920
O comentário é geralmente chamado de bloco

3079
01:59:33,920 --> 01:59:36,320
Comentário que você pode colocar no que quiser

3080
01:59:36,320 --> 01:59:38,880
Se você tem um pedaço de texto que você

3081
01:59:38,880 --> 01:59:40,560
Gostaria de usar como comentário em seu

3082
01:59:40,560 --> 01:59:43,520
programa Esta é uma maneira que você pode fazer isso

3083
01:59:43,520 --> 01:59:46,159
Uma coisa que você deve saber é que

3084
01:59:46,159 --> 01:59:48,880
Você não pode aninhar essas coisas, mas antes

3085
01:59:48,880 --> 01:59:50,480
Fazemos isso, vamos tentar construir o nosso

3086
01:59:50,480 --> 01:59:52,960
programa para realmente mostrar que não há

3087
01:59:52,960 --> 01:59:55,360
problema se tivermos esses comentários no

3088
01:59:55,360 --> 01:59:58,320
O mundo é bem sucedido e se clicarmos

3089
01:59:58,320 --> 02:00:00,719
este terminal e bater em entrar

3090
02:00:00,719 --> 02:00:03,599
e bater claro para limpar as coisas no

3091
02:00:03,599 --> 02:00:06,159
terminal que podemos tentar executar o nosso galo

3092
02:00:06,159 --> 02:00:08,080
programa e vai dizer olá

3093
02:00:08,080 --> 02:00:10,800
mundo você vê que todas essas linhas verdes

3094
02:00:10,800 --> 02:00:12,960
quais são comentários realmente não

3095
02:00:12,960 --> 02:00:15,360
afetando o programa todo o compilador

3096
02:00:15,360 --> 02:00:17,360
Vai se preocupar é que estes incluem

3097
02:00:17,360 --> 02:00:19,440
O que vai se preocupar com o principal

3098
02:00:19,440 --> 02:00:21,360
função aqui vai ignorar estes

3099
02:00:21,360 --> 02:00:23,599
coisas verdes, vai ser assim

3100
02:00:23,599 --> 02:00:26,000
linhas verdes que são nossos comentários são

3101
02:00:26,000 --> 02:00:28,400
Não lá, este é o efeito comentários

3102
02:00:28,400 --> 02:00:30,159
Temos em seu programa e nós vamos

3103
02:00:30,159 --> 02:00:32,880
usar isso muito neste curso

3104
02:00:32,880 --> 02:00:34,639
Uma coisa que você deve saber é que

3105
02:00:34,639 --> 02:00:38,080
você não pode aninhar esses comentários de bloco, então

3106
02:00:38,080 --> 02:00:40,480
Se você tentar fazer algo assim

3107
02:00:40,480 --> 02:00:44,000
E uh dizer que este é um comentário e uh

3108
02:00:44,000 --> 02:00:46,480
Venha novamente e diga que este é outro

3109
02:00:46,480 --> 02:00:48,320
O comentário você vê que temos problemas

3110
02:00:48,320 --> 02:00:50,400
O aninhamento já não é permitido que você esteja

3111
02:00:50,400 --> 02:00:52,239
Vou obter um erro de compilador e nós estamos

3112
02:00:52,239 --> 02:00:54,080
Vou aprender mais sobre esses erros

3113
02:00:54,080 --> 02:00:56,320
na próxima palestra, mas não faça isso

3114
02:00:56,320 --> 02:00:58,639
Não aninhe esses comentários em bloco se você

3115
02:00:58,639 --> 02:01:00,800
Faz isso que você vai conseguir algum

3116
02:01:00,800 --> 02:01:03,520
Erros confusos e isso vai ser

3117
02:01:03,520 --> 02:01:06,239
A causa para eles, então não ninho seu

3118
02:01:06,239 --> 02:01:08,560
Comentários do blog que vai te dar

3119
02:01:08,560 --> 02:01:10,880
dores de cabeça ok, isso é realmente tudo o que estabelecemos

3120
02:01:10,880 --> 02:01:12,560
para fazer nesta palestra aprendendo sobre

3121
02:01:12,560 --> 02:01:15,199
comentários em c plus mais você pode fazer um

3122
02:01:15,199 --> 02:01:17,840
Comentários em uma única linha como esta

3123
02:01:17,840 --> 02:01:20,480
você pode bloquear comentários para comentar

3124
02:01:20,480 --> 02:01:23,679
Um bloco de texto você não pode aninhar seu blog

3125
02:01:23,679 --> 02:01:25,440
comentários porque isso vai dar

3126
02:01:25,440 --> 02:01:27,520
Você tem muitos problemas que você não quer

3127
02:01:27,520 --> 02:01:31,760
Isso e realmente usar comentários sabiamente e

3128
02:01:31,760 --> 02:01:33,840
Não exageres porque vai

3129
02:01:33,840 --> 02:01:36,080
transformar seu programa em um romance e eu

3130
02:01:36,080 --> 02:01:38,320
Não pense que as pessoas querem isso, então use isso

3131
02:01:38,320 --> 02:01:40,080
recurso quando você precisa dele para dar alguns

3132
02:01:40,080 --> 02:01:42,000
mais informações sobre o seu código e

3133
02:01:42,000 --> 02:01:44,239
Não exagere nisso, vamos parar

3134
02:01:44,239 --> 02:01:46,000
Aqui nesta palestra o próximo somos

3135
02:01:46,000 --> 02:01:48,320
Vou aprender sobre diferentes tipos de

3136
02:01:48,320 --> 02:01:51,119
erros e avisos que você pode ver em seu

3137
02:01:51,119 --> 02:01:53,040
c plus plus programa

3138
02:01:53,040 --> 02:01:55,679
Vá em frente e termine aqui e me encontre

3139
02:01:55,679 --> 02:01:57,440
lá nesta palestra vamos

3140
02:01:57,440 --> 02:02:00,159
Saiba mais sobre erros e avisos em sua

3141
02:02:00,159 --> 02:02:02,719
c plus programas existem três

3142
02:02:02,719 --> 02:02:05,520
tipos de erros ou avisos que você pode obter

3143
02:02:05,520 --> 02:02:08,080
você pode obter erros de tempo de compilação que você pode

3144
02:02:08,080 --> 02:02:10,560
obter erros de tempo de execução e você pode obter

3145
02:02:10,560 --> 02:02:13,119
advertências, mas o que realmente significa

3146
02:02:13,119 --> 02:02:15,920
essas coisas lembram o objetivo final

3147
02:02:15,920 --> 02:02:19,520
de cada desenvolvedor ou cada c mais mais

3148
02:02:19,520 --> 02:02:22,159
Desenvolvedor no nosso caso aqui é para ser capaz

3149
02:02:22,159 --> 02:02:25,679
para gerar um arquivo executável binário

3150
02:02:25,679 --> 02:02:28,080
do c plus código e temos que

3151
02:02:28,080 --> 02:02:30,320
executar o código através do compilador para ser

3152
02:02:30,320 --> 02:02:32,400
capaz de fazer isso e uma coisa que você deveria

3153
02:02:32,400 --> 02:02:34,639
Sei que existe um conjunto de

3154
02:02:34,639 --> 02:02:36,159
requisitos

3155
02:02:36,159 --> 02:02:38,880
que o compilador impõe em nosso código

3156
02:02:38,880 --> 02:02:40,880
para que seja capaz de compilar

3157
02:02:40,880 --> 02:02:43,199
Com sucesso e esses requisitos são

3158
02:02:43,199 --> 02:02:45,520
As regras realmente que temos que seguir

3159
02:02:45,520 --> 02:02:47,599
em nosso programa c plus plus e se nós

3160
02:02:47,599 --> 02:02:49,280
quebrar essas regras que vamos ter

3161
02:02:49,280 --> 02:02:51,360
Os problemas e esses problemas vão

3162
02:02:51,360 --> 02:02:54,000
vem na forma de erros de tempo de compilação

3163
02:02:54,000 --> 02:02:56,639
Erros de tempo de execução ou avisos

3164
02:02:56,639 --> 02:02:59,599
Veja erros de tempo de compilação em

3165
02:02:59,599 --> 02:03:00,480
Detalhe de pormenor

3166
02:03:00,480 --> 02:03:02,400
Aqui temos um simples c plus plus

3167
02:03:02,400 --> 02:03:05,599
Programa que tem alguns problemas que temos

3168
02:03:05,599 --> 02:03:08,239
Esqueceu-se de colocar o ponto e vírgula no

3169
02:03:08,239 --> 02:03:12,239
fim do nosso stdc out statement aqui e

3170
02:03:12,239 --> 02:03:14,320
O compilador vai surtar

3171
02:03:14,320 --> 02:03:15,599
Por causa disso

3172
02:03:15,599 --> 02:03:17,440
Se compilarmos este programa, vamos

3173
02:03:17,440 --> 02:03:20,239
para obter um monte de erros e o ide é

3174
02:03:20,239 --> 02:03:22,719
vamos nos mostrar esse problema alguns ides

3175
02:03:22,719 --> 02:03:24,320
vai lhe dar erros diferentes

3176
02:03:24,320 --> 02:03:27,119
Por exemplo, aqui eu estava usando codelite

3177
02:03:27,119 --> 02:03:28,800
E estava dizendo

3178
02:03:28,800 --> 02:03:31,840
erro esperado de ponto e vírgula antes do retorno

3179
02:03:31,840 --> 02:03:33,760
ou algo assim, então isso é um

3180
02:03:33,760 --> 02:03:36,560
erro do compilador e se você tem esse tipo

3181
02:03:36,560 --> 02:03:38,560
de erros seu programa não vai

3182
02:03:38,560 --> 02:03:41,199
A compilação vai falhar

3183
02:03:41,199 --> 02:03:42,960
você vai receber esse erro e

3184
02:03:42,960 --> 02:03:44,560
Você não vai conseguir o seu binário

3185
02:03:44,560 --> 02:03:46,719
executável e quando você tem isso

3186
02:03:46,719 --> 02:03:48,719
basicamente tem que voltar e consertar isso

3187
02:03:48,719 --> 02:03:51,760
problema empilar novamente e quando você chegar

3188
02:03:51,760 --> 02:03:53,760
livrar-se desses problemas, a compilação é

3189
02:03:53,760 --> 02:03:56,079
vai conseguir isso é o que uma compilação

3190
02:03:56,079 --> 02:03:58,800
Erro de tempo é outra coisa que você pode ter

3191
02:03:58,800 --> 02:04:01,280
é o erro de tempo de execução que não está indo

3192
02:04:01,280 --> 02:04:03,679
para causar um erro de tempo de compilação

3193
02:04:03,679 --> 02:04:06,079
A compilação vai ter sucesso, mas quando

3194
02:04:06,079 --> 02:04:08,480
você executa o programa que não vai fazer

3195
02:04:08,480 --> 02:04:11,199
O que você pretendia fazer no primeiro

3196
02:04:11,199 --> 02:04:13,119
lugar, por exemplo, você pode querer

3197
02:04:13,119 --> 02:04:16,159
impressão verde em alguma interface de usuário é

3198
02:04:16,159 --> 02:04:18,480
indo para imprimir cinza ou o que quer que seja

3199
02:04:18,480 --> 02:04:20,560
Realmente não vai fazer o que você quer, então

3200
02:04:20,560 --> 02:04:22,400
É um erro lógico que você tem em

3201
02:04:22,400 --> 02:04:24,400
seu programa e você tem que corrigi-lo para

3202
02:04:24,400 --> 02:04:26,880
Livre-se disso e outra coisa você

3203
02:04:26,880 --> 02:04:29,199
deveria saber que às vezes essas corridas

3204
02:04:29,199 --> 02:04:32,480
erros de tempo podem fazer com que seu programa

3205
02:04:32,480 --> 02:04:35,119
falhar e terminar imediatamente e nós

3206
02:04:35,119 --> 02:04:37,199
Digamos que o programa caiu, estamos

3207
02:04:37,199 --> 02:04:38,880
Vou ver um exemplo disso em um

3208
02:04:38,880 --> 02:04:41,119
minuto o último tipo de problema que você pode

3209
02:04:41,119 --> 02:04:44,480
ter em seu programa é um aviso

3210
02:04:44,480 --> 02:04:46,880
Este é um problema que não é grave

3211
02:04:46,880 --> 02:04:49,599
o suficiente para o compilador parar o seu

3212
02:04:49,599 --> 02:04:51,840
A compilação de compilação vai

3213
02:04:51,840 --> 02:04:53,840
ter sucesso, mas este é basicamente o

3214
02:04:53,840 --> 02:04:55,840
Compilador dizendo que você está fazendo

3215
02:04:55,840 --> 02:04:58,480
Algo que tem alguns problemas e você

3216
02:04:58,480 --> 02:05:00,719
realmente deve consertá-lo antes que ele se torne um

3217
02:05:00,719 --> 02:05:02,719
sério problema para que isso seja um

3218
02:05:02,719 --> 02:05:05,040
Advertindo, por exemplo, aqui você vê alguns

3219
02:05:05,040 --> 02:05:07,840
Os compiladores podem avisá-lo quando você divide

3220
02:05:07,840 --> 02:05:10,079
Coisas por zero e vamos ver como

3221
02:05:10,079 --> 02:05:12,000
Isso funciona a mensagem principal nesta

3222
02:05:12,000 --> 02:05:14,320
A palestra é que você pode ter problemas em

3223
02:05:14,320 --> 02:05:16,960
Seu programa e eles virão

3224
02:05:16,960 --> 02:05:19,360
em três formas, alguns vão ser

3225
02:05:19,360 --> 02:05:22,000
erros de tempo de compilação, alguns serão

3226
02:05:22,000 --> 02:05:24,480
Erros de tempo de execução alguns vão ser

3227
02:05:24,480 --> 02:05:26,639
Avisos que vamos pular para

3228
02:05:26,639 --> 02:05:28,880
código de estúdio visual e realmente jogar

3229
02:05:28,880 --> 02:05:31,840
Com isso ok aqui estou no visual

3230
02:05:31,840 --> 02:05:34,159
código de estúdio a primeira coisa que eu vou

3231
02:05:34,159 --> 02:05:36,000
O fazer é a configuração

3232
02:05:36,000 --> 02:05:37,760
O projeto de modelo que vamos ser

3233
02:05:37,760 --> 02:05:40,320
usando em nosso projeto aqui o projeto é

3234
02:05:40,320 --> 02:05:42,480
indo para sair nestes erros de pasta e

3235
02:05:42,480 --> 02:05:44,880
avisos que vou copiar sobre o

3236
02:05:44,880 --> 02:05:47,440
Arquivos e eu vou para o

3237
02:05:47,440 --> 02:05:48,880
Projeto atual que vamos ser

3238
02:05:48,880 --> 02:05:51,440
trabalhando e eu vou abrir isso

3239
02:05:51,440 --> 02:05:53,840
pasta no código do estúdio visual i

3240
02:05:53,840 --> 02:05:56,400
para ir ao arquivo close folder eu vou

3241
02:05:56,400 --> 02:05:58,800
Feche este e eu vou abrir

3242
02:05:58,800 --> 02:06:01,119
nosso novo projeto eu vou navegar para

3243
02:06:01,119 --> 02:06:03,760
O projeto é este que eu vou

3244
02:06:03,760 --> 02:06:06,239
selecione-o e selecione a pasta e é

3245
02:06:06,239 --> 02:06:08,480
vou abrir no código do estúdio visual i

3246
02:06:08,480 --> 02:06:10,719
Vou fechar esta tela de boas-vindas

3247
02:06:10,719 --> 02:06:13,440
e abrir o nosso arquivo cpp principal que estamos indo

3248
02:06:13,440 --> 02:06:15,840
para se livrar deste fã de polícia este é

3249
02:06:15,840 --> 02:06:18,159
um c plus mais 20 teste

3250
02:06:18,159 --> 02:06:20,239
A coisa que tínhamos e nós realmente não precisamos disso

3251
02:06:20,239 --> 02:06:22,639
Agora vamos chegar lá no devido tempo

3252
02:06:22,639 --> 02:06:25,199
O que queremos ver é tempo de compilação

3253
02:06:25,199 --> 02:06:28,000
erros que vamos colocar em nosso stdc

3254
02:06:28,000 --> 02:06:31,040
declaração hello mundo

3255
02:06:31,040 --> 02:06:33,199
Como nós costumo fazer

3256
02:06:33,199 --> 02:06:36,480
nós vamos acabar com este stdndm e nós estamos

3257
02:06:36,480 --> 02:06:37,520
Indo para dentro de nós.

3258
02:06:37,520 --> 02:06:40,400
remover o ponto vírgula de propósito e se

3259
02:06:40,400 --> 02:06:42,560
Tentamos compilar nosso programa como este

3260
02:06:42,560 --> 02:06:44,639
vamos ter um erro de tempo de compilação

3261
02:06:44,639 --> 02:06:47,040
Isto é o que queremos ver, então vamos tentar

3262
02:06:47,040 --> 02:06:49,440
e construir o nosso programa vamos executar

3263
02:06:49,440 --> 02:06:52,880
a tarefa de construir com gcc e você vê

3264
02:06:52,880 --> 02:06:55,280
Que o mundo falha, nós vamos conseguir

3265
02:06:55,280 --> 02:06:57,760
um monte de erros em nosso terminal é

3266
02:06:57,760 --> 02:07:00,560
Vou dizer na função principal

3267
02:07:00,560 --> 02:07:03,840
Esperava um ponto-e-vírgula antes do retorno

3268
02:07:03,840 --> 02:07:05,920
Vou tentar o seu melhor para lhe dizer o que

3269
02:07:05,920 --> 02:07:08,000
O problema é, mas às vezes estes

3270
02:07:08,000 --> 02:07:10,639
Os erros podem ser confusos nisso

3271
02:07:10,639 --> 02:07:12,719
Caso é realmente fácil porque nós

3272
02:07:12,719 --> 02:07:15,440
Introduziu este erro de propósito, então

3273
02:07:15,440 --> 02:07:17,360
vamos consertá-lo em um minuto, mas

3274
02:07:17,360 --> 02:07:19,199
Antes de fazermos isso, quero que você veja

3275
02:07:19,199 --> 02:07:21,520
Estes problemas tab que é onde o

3276
02:07:21,520 --> 02:07:23,440
Os problemas vão aparecer no visual

3277
02:07:23,440 --> 02:07:25,440
código de estúdio para ver o seu

3278
02:07:25,440 --> 02:07:28,480
Problemas aqui ou através do terminal

3279
02:07:28,480 --> 02:07:30,639
Aqui está tudo bem uma coisa que você deve saber é

3280
02:07:30,639 --> 02:07:32,960
quando você tem uma seta do compilador

3281
02:07:32,960 --> 02:07:34,960
A compilação não vai ter sucesso e

3282
02:07:34,960 --> 02:07:36,719
Você não vai ter o seu binário

3283
02:07:36,719 --> 02:07:39,040
arquivo que é o que você realmente quer, então

3284
02:07:39,040 --> 02:07:41,599
resolver este problema que vamos colocar

3285
02:07:41,599 --> 02:07:43,840
nosso ponto e vírgula aqui vamos construir

3286
02:07:43,840 --> 02:07:46,079
novamente nós vamos para a corrida terminal

3287
02:07:46,079 --> 02:07:49,119
tarefa que vamos construir com gcc e

3288
02:07:49,119 --> 02:07:50,560
Desta vez você vai ver isso

3289
02:07:50,560 --> 02:07:53,040
A compilação vai ter sucesso e nós

3290
02:07:53,040 --> 02:07:55,360
ter o nosso programa aqui podemos executá-lo

3291
02:07:55,360 --> 02:07:57,119
através do terminal aqui para que vamos

3292
02:07:57,119 --> 02:07:58,800
para clicar no terminal vai embora

3293
02:07:58,800 --> 02:08:01,679
longe, mas nós podemos abrir o nosso próprio

3294
02:08:01,679 --> 02:08:04,400
e se fizermos dur, vamos ver o nosso

3295
02:08:04,400 --> 02:08:06,800
arquivos aqui e podemos executar o nosso programa

3296
02:08:06,800 --> 02:08:09,599
Podemos dizer galo e se corrermos, estamos

3297
02:08:09,599 --> 02:08:12,239
Vou ter olá mundo, então eu espero que isso

3298
02:08:12,239 --> 02:08:14,960
realmente deixa bem claro o que

3299
02:08:14,960 --> 02:08:18,480
Erro de tempo de compilação, pois este é um

3300
02:08:18,480 --> 02:08:20,800
tipo de erro que você pode obter o outro

3301
02:08:20,800 --> 02:08:23,760
é um erro de tempo e isso vem em

3302
02:08:23,760 --> 02:08:26,239
A forma de coisas que não funcionam como

3303
02:08:26,239 --> 02:08:28,880
Você realmente esperava, então digamos que estamos

3304
02:08:28,880 --> 02:08:31,199
Tentando fazer alguma computação em nosso

3305
02:08:31,199 --> 02:08:32,320
O programa

3306
02:08:32,320 --> 02:08:33,119
Somos

3307
02:08:33,119 --> 02:08:37,280
Tente tomar 7 e dividir isso por 0 para

3308
02:08:37,280 --> 02:08:39,840
exemplo e esta é uma afirmação que existe

3309
02:08:39,840 --> 02:08:42,320
uma carga em c plus plus então vamos tentar

3310
02:08:42,320 --> 02:08:44,719
Construa isso e veja o que temos porque

3311
02:08:44,719 --> 02:08:47,520
Este é um cenário comum onde temos

3312
02:08:47,520 --> 02:08:49,840
erros de tempo de execução, vamos executar o

3313
02:08:49,840 --> 02:08:53,280
tarefa para construir com gcc bem se fizermos

3314
02:08:53,280 --> 02:08:55,599
Você vê que o mundo terminou com

3315
02:08:55,599 --> 02:08:58,400
avisos de que não conseguimos um tempo de compilação

3316
02:08:58,400 --> 02:09:01,440
a flecha e nossa construção foi bem sucedida para

3317
02:09:01,440 --> 02:09:03,679
Realmente provar isso eu vou fazer

3318
02:09:03,679 --> 02:09:06,400
voltar em nosso diretório eu vou fazer

3319
02:09:06,400 --> 02:09:08,480
dur você vai ver que galo é

3320
02:09:08,480 --> 02:09:10,719
lá eu vou removê-lo Eu estou indo

3321
02:09:10,719 --> 02:09:12,119
para dizer

3322
02:09:12,119 --> 02:09:14,960
galo.exe é assim que removemos coisas

3323
02:09:14,960 --> 02:09:17,520
da linha de comando quando eu faço isso e

3324
02:09:17,520 --> 02:09:19,520
fazer sujeira novamente o

3325
02:09:19,520 --> 02:09:21,840
O arquivo executável deve desaparecer, então vamos

3326
02:09:21,840 --> 02:09:24,480
Tente construir com esta declaração e

3327
02:09:24,480 --> 02:09:25,840
e você vai ver que nós temos um

3328
02:09:25,840 --> 02:09:28,960
aviso e não um erro de tempo de compilação

3329
02:09:28,960 --> 02:09:30,719
Como nós tínhamos aqui, então nós vamos para

3330
02:09:30,719 --> 02:09:33,280
tarefa de corrida terminal que vamos construir

3331
02:09:33,280 --> 02:09:35,360
com gcc e você vai ver isso

3332
02:09:35,360 --> 02:09:37,679
nós vamos ter o nosso executável aqui

3333
02:09:37,679 --> 02:09:39,840
Mas tivemos um aviso e está dizendo

3334
02:09:39,840 --> 02:09:42,960
essa divisão por 0 foi detectada em nosso

3335
02:09:42,960 --> 02:09:45,920
Programa e é uma receita para o desastre

3336
02:09:45,920 --> 02:09:48,719
Então, por que é um desastre, vamos tentar

3337
02:09:48,719 --> 02:09:51,760
Dirita este programa para que vamos

3338
02:09:51,760 --> 02:09:54,480
sujeira para provar que está aqui e nós vamos

3339
02:09:54,480 --> 02:09:56,800
para executá-lo se executá-lo vai dizer

3340
02:09:56,800 --> 02:09:59,440
Olá mundo e vai acabar, vamos acabar

3341
02:09:59,440 --> 02:10:02,400
Tentar e realmente usar nosso próprio terminal para

3342
02:10:02,400 --> 02:10:04,719
Veja se temos uma melhor chance de ver

3343
02:10:04,719 --> 02:10:06,960
O problema aqui, então eu vou revelar

3344
02:10:06,960 --> 02:10:10,320
no explorador clicando em cpp principal e

3345
02:10:10,320 --> 02:10:12,800
Vou tentar abrir um terminal

3346
02:10:12,800 --> 02:10:15,199
janela aqui powershell que nós abrimos

3347
02:10:15,199 --> 02:10:17,360
Nós mesmos já fizemos isso antes

3348
02:10:17,360 --> 02:10:20,719
Isso não deveria ser novo para você agora

3349
02:10:20,719 --> 02:10:23,199
então nós vamos fazer sujeira aqui

3350
02:10:23,199 --> 02:10:24,560
e nós vamos tentar correr o

3351
02:10:24,560 --> 02:10:27,520
programa e vai funcionar, então é

3352
02:10:27,520 --> 02:10:30,480
realmente não nos dando um erro de tempo de execução

3353
02:10:30,480 --> 02:10:33,360
Porque não estamos capturando isso ou

3354
02:10:33,360 --> 02:10:35,119
Tentando usar o resultado disso

3355
02:10:35,119 --> 02:10:36,639
Divisão aqui estamos apenas fazendo o

3356
02:10:36,639 --> 02:10:38,960
divisão que é um problema, então vamos tentar

3357
02:10:38,960 --> 02:10:40,800
e capturar isso que não aprendemos

3358
02:10:40,800 --> 02:10:43,119
sobre variáveis ainda, mas o que estamos indo

3359
02:10:43,119 --> 02:10:46,239
fazer agora é fazer o valor final e nós somos

3360
02:10:46,239 --> 02:10:48,800
vai atribuir o resultado disso

3361
02:10:48,800 --> 02:10:51,360
divisão para este valor e vamos tentar

3362
02:10:51,360 --> 02:10:54,079
Imprimir o resultado de dividir um número

3363
02:10:54,079 --> 02:10:56,880
por zero, então nós vamos fazer stdc out

3364
02:10:56,880 --> 02:10:59,119
e nós vamos dizer valor e isso é

3365
02:10:59,119 --> 02:11:02,079
Como você pode imprimir um valor no

3366
02:11:02,079 --> 02:11:04,239
console OK agora que temos isso e

3367
02:11:04,239 --> 02:11:06,400
Vamos tentar e soldar, vamos correr

3368
02:11:06,400 --> 02:11:09,040
tarefas e gcc em todo o mundo que vamos

3369
02:11:09,040 --> 02:11:11,360
obter o mesmo aviso, mas se tentarmos

3370
02:11:11,360 --> 02:11:13,599
executar o programa que não vamos conseguir

3371
02:11:13,599 --> 02:11:17,040
O que esperamos vamos executar galo exe nós

3372
02:11:17,040 --> 02:11:19,440
Espera-lhe dizer olá mundo e impresso

3373
02:11:19,440 --> 02:11:21,440
O valor, mas você vê que é realmente

3374
02:11:21,440 --> 02:11:23,360
lutando para imprimir o valor e ele

3375
02:11:23,360 --> 02:11:26,239
desistiu e terminou imediatamente, então isso é

3376
02:11:26,239 --> 02:11:29,679
um exemplo de um erro de tempo de execução que você

3377
02:11:29,679 --> 02:11:31,599
Pode enfrentar em seu programa, há muitos

3378
02:11:31,599 --> 02:11:33,280
Outros tipos que vamos ver como

3379
02:11:33,280 --> 02:11:35,040
Estamos progredindo no curso

3380
02:11:35,040 --> 02:11:37,440
Aqui estamos apenas tentando levantar o seu

3381
02:11:37,440 --> 02:11:39,760
consciência sobre esses problemas para que você

3382
02:11:39,760 --> 02:11:41,760
pode saber como corrigi-los quando eles vêm

3383
02:11:41,760 --> 02:11:44,000
Ok, então isso é tudo o que posso compartilhar com

3384
02:11:44,000 --> 02:11:46,880
você agora sobre erros de tempo de execução que também tivemos

3385
02:11:46,880 --> 02:11:48,560
uma chance de ver que isso também está indo

3386
02:11:48,560 --> 02:11:50,800
para lhe dar um aviso e um visual

3387
02:11:50,800 --> 02:11:52,880
Código de estúdio aqui também está ajudando

3388
02:11:52,880 --> 02:11:55,520
dizendo-nos que podemos ter um problema

3389
02:11:55,520 --> 02:11:58,320
está girando o arquivo principal cpp amarelo

3390
02:11:58,320 --> 02:11:59,920
e está dizendo que há um

3391
02:11:59,920 --> 02:12:02,159
problema neste arquivo e se você for aqui

3392
02:12:02,159 --> 02:12:04,000
você vai ver que nós temos um

3393
02:12:04,000 --> 02:12:06,320
Aviso aqui está bem, então este é um caminho

3394
02:12:06,320 --> 02:12:08,159
Tenho que ver isso para que isso não seja

3395
02:12:08,159 --> 02:12:09,599
Recomendado para fazer isso nós vamos

3396
02:12:09,599 --> 02:12:12,000
Comente isso bem, isso é realmente tudo

3397
02:12:12,000 --> 02:12:14,719
Eu tive que compartilhar nesta palestra que tivemos um

3398
02:12:14,719 --> 02:12:17,199
chance de olhar para erros de tempo de compilação nós

3399
02:12:17,199 --> 02:12:19,040
Também teve a chance de olhar para os avisos

3400
02:12:19,040 --> 02:12:21,920
e erros de tempo em execução usando este exemplo

3401
02:12:21,920 --> 02:12:24,079
Se você receber um aviso, é uma mensagem

3402
02:12:24,079 --> 02:12:26,159
O compilador está lhe dando que você deve

3403
02:12:26,159 --> 02:12:29,119
realmente olhe para cima e conserte o problema

3404
02:12:29,119 --> 02:12:32,000
antes que se torne uma compilação mais séria

3405
02:12:32,000 --> 02:12:34,000
Erros de tempo vão causar a sua

3406
02:12:34,000 --> 02:12:36,239
compilação para falhar e isso é realmente

3407
02:12:36,239 --> 02:12:38,079
Boa coisa porque o compilador está indo

3408
02:12:38,079 --> 02:12:41,280
para impedi-lo de gerar um binário

3409
02:12:41,280 --> 02:12:43,599
que realmente não faz o que você espera

3410
02:12:43,599 --> 02:12:45,760
para isso é uma coisa boa, mas

3411
02:12:45,760 --> 02:12:47,840
às vezes o compilador quer lhe dar

3412
02:12:47,840 --> 02:12:50,239
uma seta de compilação e você tem a chance de

3413
02:12:50,239 --> 02:12:52,400
correr em um erro de tempo de execução e isso é

3414
02:12:52,400 --> 02:12:54,560
É realmente ruim, então tenha cuidado com isso

3415
02:12:54,560 --> 02:12:57,119
Coisas e quando você tem problemas visuais

3416
02:12:57,119 --> 02:12:58,800
O código do estúdio vai te mostrar o

3417
02:12:58,800 --> 02:13:01,520
problema no terminal ou nestes problemas

3418
02:13:01,520 --> 02:13:03,360
tabulação e você vai ser capaz de corrigir

3419
02:13:03,360 --> 02:13:05,199
Em cima, vamos parar aqui nisso

3420
02:13:05,199 --> 02:13:06,800
palestra no próximo, vamos

3421
02:13:06,800 --> 02:13:09,360
Aprenda um pouco mais sobre declarações e

3422
02:13:09,360 --> 02:13:11,520
As funções vão em frente e terminam aqui

3423
02:13:11,520 --> 02:13:13,520
e encontrar-me lá nesta palestra nós somos

3424
02:13:13,520 --> 02:13:15,679
Vou aprender um pouco mais sobre

3425
02:13:15,679 --> 02:13:18,560
declarações e funções em c plus plus

3426
02:13:18,560 --> 02:13:21,119
Uma declaração é uma unidade básica de

3427
02:13:21,119 --> 02:13:23,760
computação em c plus plus você pode dizer

3428
02:13:23,760 --> 02:13:26,880
que é a coisa mais pequena sua cpu

3429
02:13:26,880 --> 02:13:30,000
pode executar em seu programa cada c plus

3430
02:13:30,000 --> 02:13:32,000
O programa plus é uma coleção de

3431
02:13:32,000 --> 02:13:33,760
declarações para que você tenha um

3432
02:13:33,760 --> 02:13:37,040
Um monte de declarações organizadas

3433
02:13:37,040 --> 02:13:39,360
de uma certa maneira para conseguir o que quer que seja

3434
02:13:39,360 --> 02:13:42,159
é você quer e declarações em c plus

3435
02:13:42,159 --> 02:13:44,960
plus deve terminar com o ponto e vírgula que vimos

3436
02:13:44,960 --> 02:13:47,440
na última palestra que não coloca

3437
02:13:47,440 --> 02:13:49,840
que o ponto e-micolon vai resultar em um

3438
02:13:49,840 --> 02:13:53,040
Erro de tempo de compilação aqui é um básico

3439
02:13:53,040 --> 02:13:55,360
amostra c plus programa que nós somos

3440
02:13:55,360 --> 02:13:58,480
usar para aprender sobre declarações

3441
02:13:58,480 --> 02:14:00,639
Na função principal aqui temos dois

3442
02:14:00,639 --> 02:14:03,360
variáveis declaradas que não temos realmente

3443
02:14:03,360 --> 02:14:05,360
aprendeu sobre as variáveis, mas elas são a

3444
02:14:05,360 --> 02:14:08,239
maneira de armazenar dados em seu programa e

3445
02:14:08,239 --> 02:14:11,360
Aqui estamos armazenando dois números decimais

3446
02:14:11,360 --> 02:14:13,840
Um é chamado primeiro número, o segundo é

3447
02:14:13,840 --> 02:14:16,079
chamado segundo número, podemos fazer algo

3448
02:14:16,079 --> 02:14:18,159
com essas variáveis que temos em nosso

3449
02:14:18,159 --> 02:14:20,560
programa, por exemplo, podemos adicioná-los

3450
02:14:20,560 --> 02:14:23,280
ter outra variável em nosso programa e

3451
02:14:23,280 --> 02:14:25,599
Podemos imprimir isso para que você veja aqui estamos

3452
02:14:25,599 --> 02:14:28,880
dizendo stdc para fora a soma de dois números

3453
02:14:28,880 --> 02:14:31,920
é soma, então isso vai imprimir 21

3454
02:14:31,920 --> 02:14:34,960
porque vai adicionar 12 e 9 e

3455
02:14:34,960 --> 02:14:36,480
O resultado disso vai ser

3456
02:14:36,480 --> 02:14:39,119
exibido no terminal se executarmos isso

3457
02:14:39,119 --> 02:14:41,360
programar o que eu realmente quero que você perceba

3458
02:14:41,360 --> 02:14:44,320
é que este e primeiro o número é igual

3459
02:14:44,320 --> 02:14:47,840
12 coisa é uma declaração em c plus

3460
02:14:47,840 --> 02:14:50,480
assim, deve terminar com um ponto e vírgula da linha

3461
02:14:50,480 --> 02:14:52,719
Aqui com o segundo número também é um

3462
02:14:52,719 --> 02:14:55,280
Declaração para que ela termine com um

3463
02:14:55,280 --> 02:14:58,320
ponto emicolon cada linha que temos aqui

3464
02:14:58,320 --> 02:14:59,920
na função principal é realmente um

3465
02:14:59,920 --> 02:15:02,639
Declaração e deve terminar com um

3466
02:15:02,639 --> 02:15:05,040
ponto e-vírgula se não colocarmos o ponto e-vírgula

3467
02:15:05,040 --> 02:15:07,119
No lugar, vamos conseguir um compilador

3468
02:15:07,119 --> 02:15:09,040
Erro ok outra coisa que é

3469
02:15:09,040 --> 02:15:11,520
É importante ter em mente que

3470
02:15:11,520 --> 02:15:14,239
As declarações são executadas em ordem em seu

3471
02:15:14,239 --> 02:15:17,280
programa e a ordem é de cima para

3472
02:15:17,280 --> 02:15:19,520
fundo se você voltar para o nosso programa

3473
02:15:19,520 --> 02:15:21,840
Aqui, a primeira declaração é a única

3474
02:15:21,840 --> 02:15:24,079
com o primeiro número aqui 12 vai ser

3475
02:15:24,079 --> 02:15:26,400
instalado na memória quando esta declaração

3476
02:15:26,400 --> 02:15:29,280
é executado pelo seu computador e nós somos

3477
02:15:29,280 --> 02:15:31,360
Vou para a segunda declaração com

3478
02:15:31,360 --> 02:15:33,280
segundo número e nós vamos manter

3479
02:15:33,280 --> 02:15:35,760
Indo até chegarmos ao final do principal

3480
02:15:35,760 --> 02:15:38,079
A função e a declaração de retorno são

3481
02:15:38,079 --> 02:15:40,960
indo para a execução e quando o principal

3482
02:15:40,960 --> 02:15:43,440
A função retorna ou termina que estamos

3483
02:15:43,440 --> 02:15:45,920
obter o valor de retorno enviado para

3484
02:15:45,920 --> 02:15:47,920
seu sistema operacional e ele vai

3485
02:15:47,920 --> 02:15:50,800
Saiba se o seu programa terminou com sucesso

3486
02:15:50,800 --> 02:15:52,800
ou com um problema e a operação

3487
02:15:52,800 --> 02:15:54,880
O sistema vai saber o que fazer com

3488
02:15:54,880 --> 02:15:57,199
que a execução da informação continua

3489
02:15:57,199 --> 02:15:59,920
até chegarmos ao final do programa ou

3490
02:15:59,920 --> 02:16:02,079
se houver qualquer outra condição causando

3491
02:16:02,079 --> 02:16:04,000
para o programa terminar e nós somos

3492
02:16:04,000 --> 02:16:05,920
Vou ter mais detalhes sobre estes

3493
02:16:05,920 --> 02:16:08,079
Coisas depois eu só quero que você saiba

3494
02:16:08,079 --> 02:16:10,880
que as declarações são executadas em

3495
02:16:10,880 --> 02:16:12,960
ordem em sua função principal outra

3496
02:16:12,960 --> 02:16:14,960
Conceito eu realmente quero que você tenha um

3497
02:16:14,960 --> 02:16:18,239
A ideia é o conceito de funções a

3498
02:16:18,239 --> 02:16:20,239
A função é realmente como uma máquina que você

3499
02:16:20,239 --> 02:16:22,320
dar a ele entrada e ele vai te dar

3500
02:16:22,320 --> 02:16:25,280
saída se olharmos para a operação aqui

3501
02:16:25,280 --> 02:16:27,599
para adicionar primeiro um número ao segundo número

3502
02:16:27,599 --> 02:16:30,480
Podemos considerar o primeiro número e o segundo

3503
02:16:30,480 --> 02:16:33,439
número como entrada para a função e soma

3504
02:16:33,439 --> 02:16:35,359
é a saída da função que nós podemos

3505
02:16:35,359 --> 02:16:37,599
visualizem assim para que tenhamos um

3506
02:16:37,599 --> 02:16:39,679
primeiro número e o segundo número que

3507
02:16:39,679 --> 02:16:42,080
Passe isso para a nossa máquina, que é

3508
02:16:42,080 --> 02:16:44,000
Realmente uma função e nós vamos conseguir

3509
02:16:44,000 --> 02:16:46,880
O resultado desta função em um retorno

3510
02:16:46,880 --> 02:16:49,519
valor ou algo que nós saímos

3511
02:16:49,519 --> 02:16:52,399
A função como nosso resultado c plus plus

3512
02:16:52,399 --> 02:16:55,280
tem uma sintaxe especial que usamos para definir

3513
02:16:55,280 --> 02:16:57,840
funções esta é a nossa função para adicionar

3514
02:16:57,840 --> 02:17:00,559
Números à esquerda temos um inteiro

3515
02:17:00,559 --> 02:17:03,679
qual é o nome de código para um número inteiro em

3516
02:17:03,679 --> 02:17:05,519
c plus é um número sem

3517
02:17:05,519 --> 02:17:07,840
pontos decimais e é um número inteiro

3518
02:17:07,840 --> 02:17:09,200
Depois disso, temos o nome do

3519
02:17:09,200 --> 02:17:11,200
Funcionar e podemos nomeá-lo o que quer que seja

3520
02:17:11,200 --> 02:17:13,599
Quero e depois disso vamos ter

3521
02:17:13,599 --> 02:17:16,080
A lista de parâmetros que podemos passar

3522
02:17:16,080 --> 02:17:17,760
para a função e isso vai

3523
02:17:17,760 --> 02:17:20,399
trabalho como a entrada para a função

3524
02:17:20,399 --> 02:17:22,719
Depois que você faz isso, você vai ter um

3525
02:17:22,719 --> 02:17:26,240
par de aparelhos encaracolados o que está aqui

3526
02:17:26,240 --> 02:17:28,479
Outro está aqui até o fim e dentro

3527
02:17:28,479 --> 02:17:30,800
esses aparelhos encaracolados vai ser

3528
02:17:30,800 --> 02:17:33,040
corpo da função dentro da função

3529
02:17:33,040 --> 02:17:35,439
Você vê que estamos declarando uma variável

3530
02:17:35,439 --> 02:17:37,120
que é chamado de soma

3531
02:17:37,120 --> 02:17:39,679
e estamos armazenando a soma de primeiro

3532
02:17:39,679 --> 02:17:41,519
número e segundo número neste

3533
02:17:41,519 --> 02:17:42,479
a variável

3534
02:17:42,479 --> 02:17:45,519
e estamos fazendo esta função retornar

3535
02:17:45,519 --> 02:17:47,679
A soma como resultado e vamos

3536
02:17:47,679 --> 02:17:50,000
ser capaz de capturá-lo se chamarmos isso

3537
02:17:50,000 --> 02:17:52,000
Função em uma função como eu, você é

3538
02:17:52,000 --> 02:17:53,679
Vou ver como isso funciona em um minuto

3539
02:17:53,679 --> 02:17:56,080
uma função deve ser definida antes de

3540
02:17:56,080 --> 02:17:58,639
usado para que você não possa chamar uma função

3541
02:17:58,639 --> 02:18:01,359
Você não definiu primeiro em seu c plus

3542
02:18:01,359 --> 02:18:04,240
além do programa e aqui está um pouco

3543
02:18:04,240 --> 02:18:06,639
programa completo para realmente colocar tudo isso

3544
02:18:06,639 --> 02:18:09,439
ideias em conjunto, temos a nossa função para

3545
02:18:09,439 --> 02:18:11,920
adicionar números, é preciso dois números primeiro

3546
02:18:11,920 --> 02:18:14,080
Número e segundo número vai

3547
02:18:14,080 --> 02:18:16,479
Adicione-os e armazene os resultados e

3548
02:18:16,479 --> 02:18:19,280
Vamos devolver alguns para serem usados por

3549
02:18:19,280 --> 02:18:21,840
Quem chamou essa função e se você

3550
02:18:21,840 --> 02:18:24,719
Olhe em nosso programa principal, temos um

3551
02:18:24,719 --> 02:18:27,280
A declaração aqui nós vamos guardar o

3552
02:18:27,280 --> 02:18:30,479
resultado de adicionar números na soma

3553
02:18:30,479 --> 02:18:33,679
variável e passamos o primeiro número e

3554
02:18:33,679 --> 02:18:35,519
segundo número na função e nós somos

3555
02:18:35,519 --> 02:18:37,599
ter esse resultado armazenado aqui

3556
02:18:37,599 --> 02:18:39,920
Aqui também chamamos a função com

3557
02:18:39,920 --> 02:18:42,559
números diretos que você vê que passamos em

3558
02:18:42,559 --> 02:18:44,639
34 e os sete e nós vamos

3559
02:18:44,639 --> 02:18:46,719
imprimir o resultado aqui este é o

3560
02:18:46,719 --> 02:18:48,719
ideia básica que eu quero que você tenha sobre

3561
02:18:48,719 --> 02:18:51,519
funções que são peças reutilizáveis de

3562
02:18:51,519 --> 02:18:53,920
código que agrupa um monte de

3563
02:18:53,920 --> 02:18:55,840
declarações para fazer o que quer que seja que seja

3564
02:18:55,840 --> 02:18:58,160
Queria fazer nessa função uma

3565
02:18:58,160 --> 02:19:00,240
O benefício sobre funções é que podemos

3566
02:19:00,240 --> 02:19:02,960
reutilizar o código aqui se você olhar aqui

3567
02:19:02,960 --> 02:19:05,519
estão chamando essa função várias vezes

3568
02:19:05,519 --> 02:19:07,679
Sem realmente reescrevê-los

3569
02:19:07,679 --> 02:19:10,160
declarações que estão dentro da função

3570
02:19:10,160 --> 02:19:12,000
Eu sei que alguns desses conceitos podem ser

3571
02:19:12,000 --> 02:19:14,319
enigmática para você agora, nós vamos

3572
02:19:14,319 --> 02:19:17,200
Ir para o código de estúdio visual e tentar isso em

3573
02:19:17,200 --> 02:19:18,960
código e você vai ver exatamente como

3574
02:19:18,960 --> 02:19:21,599
Isso funciona bem aqui estamos em nosso

3575
02:19:21,599 --> 02:19:24,080
Pasta onde estamos armazenando nossos projetos

3576
02:19:24,080 --> 02:19:26,319
Eu vou pegar o código do

3577
02:19:26,319 --> 02:19:28,719
Projeto de modelo eu vou colocar isso

3578
02:19:28,719 --> 02:19:30,960
no projeto atual que é

3579
02:19:30,960 --> 02:19:33,439
declarações e funções que eu vou

3580
02:19:33,439 --> 02:19:35,840
colar isso aqui e eu vou

3581
02:19:35,840 --> 02:19:38,479
abrir isso em código de estúdio visual i am

3582
02:19:38,479 --> 02:19:40,399
Vamos fechar o projeto que temos direito

3583
02:19:40,399 --> 02:19:43,120
Agora e eu vou abrir o nosso novo

3584
02:19:43,120 --> 02:19:46,080
Projeto vamos navegar até a sua localização i

3585
02:19:46,080 --> 02:19:48,160
Vou abrir o projeto em

3586
02:19:48,160 --> 02:19:50,720
declarações e funções, vamos abrir isso

3587
02:19:50,720 --> 02:19:52,880
pasta no código do estúdio visual e nós somos

3588
02:19:52,880 --> 02:19:55,359
Vou ter o nosso projeto inicial aqui eu

3589
02:19:55,359 --> 02:19:57,040
Vou tirar o que tivermos

3590
02:19:57,040 --> 02:19:59,040
A principal função e tirar isso

3591
02:19:59,040 --> 02:20:01,120
coisa complicada não precisamos disso

3592
02:20:01,120 --> 02:20:03,359
e vamos tentar definir dois

3593
02:20:03,359 --> 02:20:05,920
variáveis usando duas afirmações que somos

3594
02:20:05,920 --> 02:20:08,240
vamos dizer e primeiro número e nós somos

3595
02:20:08,240 --> 02:20:10,960
Vou colocar um valor, digamos três

3596
02:20:10,960 --> 02:20:13,200
e temos que lembrar para terminar isso com

3597
02:20:13,200 --> 02:20:15,920
um ponto e-vírgula, então isso faz nossa declaração

3598
02:20:15,920 --> 02:20:18,240
Podemos codificar isso em um comentário para fazer

3599
02:20:18,240 --> 02:20:20,240
Isso bem claro, nós também vamos

3600
02:20:20,240 --> 02:20:22,800
Definir uma segunda variável, então estamos indo

3601
02:20:22,800 --> 02:20:24,560
para dizer ent para

3602
02:20:24,560 --> 02:20:26,960
significa que é um número inteiro

3603
02:20:26,960 --> 02:20:30,080
não tem pontos decimais como 2.5

3604
02:20:30,080 --> 02:20:32,319
é um número inteiro como um ou sete ou

3605
02:20:32,319 --> 02:20:34,319
10 então vamos dizer segundo número

3606
02:20:34,319 --> 02:20:37,280
nós podemos dar um nome e uh vamos colocar

3607
02:20:37,280 --> 02:20:39,439
em um sete nós vamos guardar estes

3608
02:20:39,439 --> 02:20:42,160
valores em nosso programa e podemos imprimir

3609
02:20:42,160 --> 02:20:44,240
Esses valores para fora, vamos imprimi-los

3610
02:20:44,240 --> 02:20:47,600
Primeiro, vamos dizer stdc para fora

3611
02:20:47,600 --> 02:20:49,840
Já sei como fazer isso e nós podemos

3612
02:20:49,840 --> 02:20:53,120
Diga primeiro número e podemos mudar isso

3613
02:20:53,120 --> 02:20:55,760
declarações de saída e dizer o primeiro

3614
02:20:55,760 --> 02:20:58,800
O número é o primeiro número que você pode fazer isso

3615
02:20:58,800 --> 02:21:02,240
std endl e você pode notar que visual

3616
02:21:02,240 --> 02:21:04,479
O código do estúdio está realmente ajudando a entrar

3617
02:21:04,479 --> 02:21:06,880
Auto completando as coisas que temos em nosso

3618
02:21:06,880 --> 02:21:09,040
programa, vamos imprimir o segundo número para

3619
02:21:09,040 --> 02:21:12,000
realmente pratique isso, então se fizermos std

3620
02:21:12,000 --> 02:21:13,520
você vai ver que vai

3621
02:21:13,520 --> 02:21:15,439
nos dar um monte de opções que podemos escolher

3622
02:21:15,439 --> 02:21:18,479
se você quiser, você pode percorrer

3623
02:21:18,479 --> 02:21:20,800
Isso com o mouse ou você pode simplesmente

3624
02:21:20,800 --> 02:21:23,200
digite o que você quiser digitar, então eu sou

3625
02:21:23,200 --> 02:21:25,840
indo para fazer c para fora e vai tentar

3626
02:21:25,840 --> 02:21:28,000
e ajudar se eu realmente quero que eu possa vir

3627
02:21:28,000 --> 02:21:30,399
em c para fora aqui e clique sobre ele e é

3628
02:21:30,399 --> 02:21:32,000
vai ser auto concluído que é

3629
02:21:32,000 --> 02:21:34,080
É muito legal, então vamos dizer em segundo

3630
02:21:34,080 --> 02:21:36,800
Número e vamos dizer segundo

3631
02:21:36,800 --> 02:21:38,880
número aqui e vai para auto

3632
02:21:38,880 --> 02:21:40,720
Completo para nós

3633
02:21:40,720 --> 02:21:43,760
endl e nós podemos tentar compilar isso

3634
02:21:43,760 --> 02:21:46,399
programa antes de nós, quero que você adivinhe

3635
02:21:46,399 --> 02:21:49,359
O que vamos conseguir quando fizermos isso

3636
02:21:49,359 --> 02:21:51,439
O programa dá um palpite que somos então

3637
02:21:51,439 --> 02:21:53,840
indo para ir para terminal executar tarefa e

3638
02:21:53,840 --> 02:21:56,319
nós vamos construir isso com gcc o

3639
02:21:56,319 --> 02:21:58,240
O mundo vai ser bem sucedido, nós somos

3640
02:21:58,240 --> 02:22:00,479
vamos abrir isso em nosso terminal o

3641
02:22:00,479 --> 02:22:02,479
O terminal vai embora sem nenhum problema que estamos

3642
02:22:02,479 --> 02:22:04,640
Vou abrir de novo e nós vamos

3643
02:22:04,640 --> 02:22:08,160
para ir em nossa pasta e fazer o ir e

3644
02:22:08,160 --> 02:22:09,960
Você vai ver que nós temos

3645
02:22:09,960 --> 02:22:12,960
galoster.exe nosso programa, podemos executá-lo

3646
02:22:12,960 --> 02:22:15,600
e vai dizer o primeiro número três

3647
02:22:15,600 --> 02:22:18,319
e o segundo número s7 é o que nós

3648
02:22:18,319 --> 02:22:20,399
têm armazenado nestas variáveis e

3649
02:22:20,399 --> 02:22:22,479
benefício de armazenar seus dados em

3650
02:22:22,479 --> 02:22:25,040
As variáveis é que você pode mudar o

3651
02:22:25,040 --> 02:22:27,200
variáveis e deixar o resto do seu

3652
02:22:27,200 --> 02:22:30,240
O programa realmente faz as mesmas coisas e

3653
02:22:30,240 --> 02:22:32,160
Pegue os dados que você tem neles

3654
02:22:32,160 --> 02:22:35,760
variáveis, por exemplo, podemos colocar 13 em

3655
02:22:35,760 --> 02:22:37,200
O primeiro número

3656
02:22:37,200 --> 02:22:39,200
e se construirmos novamente este número é

3657
02:22:39,200 --> 02:22:41,439
será pego por este código e

3658
02:22:41,439 --> 02:22:43,920
Não precisamos entrar e manualmente

3659
02:22:43,920 --> 02:22:46,960
Alterar dados nessas declarações de sddc out

3660
02:22:46,960 --> 02:22:49,600
Aqui vamos soldar para que possamos ver isso

3661
02:22:49,600 --> 02:22:53,040
e podemos fechar isso clicando e se

3662
02:22:53,040 --> 02:22:55,760
nós corremos o galo novamente, vai dizer

3663
02:22:55,760 --> 02:22:58,399
13 e 7. brinque com isso um par de

3664
02:22:58,399 --> 02:23:00,960
tempos até que você realmente se sinta confiante

3665
02:23:00,960 --> 02:23:02,800
E se você tiver algum problema, não

3666
02:23:02,800 --> 02:23:04,800
hesite em me perguntar que eu vou fazer o

3667
02:23:04,800 --> 02:23:06,800
O melhor que posso para te ajudar

3668
02:23:06,800 --> 02:23:09,120
Agora que temos esses números armazenados em

3669
02:23:09,120 --> 02:23:12,479
Nosso programa podemos solá-los, digamos

3670
02:23:12,479 --> 02:23:14,640
E alguns vamos declarar outro

3671
02:23:14,640 --> 02:23:16,960
variável e nós vamos dizer que é

3672
02:23:16,960 --> 02:23:20,000
igual ao primeiro número mais segundo número

3673
02:23:20,000 --> 02:23:21,439
e nós vamos acabar com isso com um

3674
02:23:21,439 --> 02:23:23,680
ponto e vírgula e vamos imprimir o

3675
02:23:23,680 --> 02:23:25,040
sum out

3676
02:23:25,040 --> 02:23:28,240
Vamos fazer sddc para fora e nós vamos dizer

3677
02:23:28,240 --> 02:23:30,800
A soma é a soma que vamos imprimir o nosso

3678
02:23:30,800 --> 02:23:33,520
variável aqui e vamos imprimir um

3679
02:23:33,520 --> 02:23:37,200
novo personagem de linha com std endl nós somos

3680
02:23:37,200 --> 02:23:39,200
vamos construir o nosso programa para que

3681
02:23:39,200 --> 02:23:42,160
As mudanças se refletem em nosso binário aqui

3682
02:23:42,160 --> 02:23:44,399
Então nós vamos para o terminal

3683
02:23:44,399 --> 02:23:47,359
executar tarefa weld com gcc e compilação é

3684
02:23:47,359 --> 02:23:49,439
Vou ser bem sucedido, vamos

3685
02:23:49,439 --> 02:23:51,840
Pressione qualquer tecla que vamos clicar aqui

3686
02:23:51,840 --> 02:23:54,080
no terminal e nós vamos bater

3687
02:23:54,080 --> 02:23:56,800
Entrar e correr galo novamente e nós

3688
02:23:56,800 --> 02:23:58,960
deve ver a soma e você vê que diz

3689
02:23:58,960 --> 02:24:02,399
A soma é 20, que é o que esperamos

3690
02:24:02,399 --> 02:24:05,200
Agora estamos fazendo a soma aqui, mas

3691
02:24:05,200 --> 02:24:07,520
Seria realmente melhor se não formos

3692
02:24:07,520 --> 02:24:10,479
fazendo a soma na função principal aqui

3693
02:24:10,479 --> 02:24:13,359
E se nós realmente tomamos esse código e

3694
02:24:13,359 --> 02:24:15,680
embrulhe-o em uma função que poderíamos

3695
02:24:15,680 --> 02:24:18,240
reutilizar o que quisermos, vimos como

3696
02:24:18,240 --> 02:24:20,399
podemos declarar uma função assim vamos fazer

3697
02:24:20,399 --> 02:24:22,080
que vamos seguir o mesmo

3698
02:24:22,080 --> 02:24:24,399
estrutura que vimos nos slides mais cedo

3699
02:24:24,399 --> 02:24:26,319
Então nós vamos dizer e isso está indo

3700
02:24:26,319 --> 02:24:29,280
para ser o valor de retorno ou o que temos

3701
02:24:29,280 --> 02:24:30,960
fora da função, então nós vamos

3702
02:24:30,960 --> 02:24:32,560
colocar em nome da função que somos

3703
02:24:32,560 --> 02:24:34,560
vamos dizer adicionar números e nós vamos

3704
02:24:34,560 --> 02:24:36,640
para passar nos parâmetros os parâmetros

3705
02:24:36,640 --> 02:24:38,800
Você pode realmente ter qualquer nome que você quer, mas

3706
02:24:38,800 --> 02:24:40,640
é necessário especificar

3707
02:24:40,640 --> 02:24:43,359
O tipo do parâmetro primeiro, de modo a

3708
02:24:43,359 --> 02:24:45,280
Os parâmetros também vão ser inteiros

3709
02:24:45,280 --> 02:24:48,960
números como 1 5 7 ou o que você quiser

3710
02:24:48,960 --> 02:24:51,439
e vamos dizer primeiro programa

3711
02:24:51,439 --> 02:24:53,520
E o segundo também será um

3712
02:24:53,520 --> 02:24:55,600
Um número inteiro e ele está indo

3713
02:24:55,600 --> 02:24:56,960
Para ser o segundo

3714
02:24:56,960 --> 02:24:59,439
Param ok depois que fazemos isso, estamos indo

3715
02:24:59,439 --> 02:25:02,160
Para especificar o corpo da função

3716
02:25:02,160 --> 02:25:04,960
que vai ser entre estes encaracolados

3717
02:25:04,960 --> 02:25:07,520
Eu vou pular para o próximo

3718
02:25:07,520 --> 02:25:09,920
linha para que isso seja realmente fácil de ver

3719
02:25:09,920 --> 02:25:12,880
então eu vou definir nossa variável de soma

3720
02:25:12,880 --> 02:25:14,880
dentro da função vai ser um

3721
02:25:14,880 --> 02:25:17,680
Número inteiro e eu posso chamá-lo de qualquer coisa

3722
02:25:17,680 --> 02:25:20,960
Eu quero, então vamos chamar isso de resultado porque

3723
02:25:20,960 --> 02:25:23,120
Vai ser o resultado disso

3724
02:25:23,120 --> 02:25:25,280
A função e o resultado serão

3725
02:25:25,280 --> 02:25:28,080
a soma do primeiro param e do segundo param

3726
02:25:28,080 --> 02:25:30,240
Espero que isso faça sentido e estamos

3727
02:25:30,240 --> 02:25:32,399
vou acabar com isso com um ponto e vírgula

3728
02:25:32,399 --> 02:25:35,200
porque cada declaração em c plus mais

3729
02:25:35,200 --> 02:25:37,280
tem que terminar com o ponto e-vírgula depois de

3730
02:25:37,280 --> 02:25:38,399
Tem o resultado

3731
02:25:38,399 --> 02:25:40,880
Precisamos devolvê-lo a quem quer que seja

3732
02:25:40,880 --> 02:25:43,040
Chamou essa função e nós vamos

3733
02:25:43,040 --> 02:25:45,359
fazer isso com uma declaração de retorno e

3734
02:25:45,359 --> 02:25:47,600
Vamos devolver o resultado para

3735
02:25:47,600 --> 02:25:48,720
Quem quer que

3736
02:25:48,720 --> 02:25:50,800
poderia ter chamado essa função aqui agora

3737
02:25:50,800 --> 02:25:52,319
que nós temos a função que nós podemos

3738
02:25:52,319 --> 02:25:54,479
realmente usá-lo nós vamos voltar

3739
02:25:54,479 --> 02:25:56,880
em nossa principal função e o que somos

3740
02:25:56,880 --> 02:25:58,240
Vou fazer isso

3741
02:25:58,240 --> 02:26:01,680
é reutilizar essa variável de soma e armazenar

3742
02:26:01,680 --> 02:26:04,240
em tudo o que é devolvido de nossa

3743
02:26:04,240 --> 02:26:06,479
função da sintaxe para isso vai

3744
02:26:06,479 --> 02:26:07,520
Seja somado

3745
02:26:07,520 --> 02:26:09,359
e nós vamos dizer iguais e nós somos

3746
02:26:09,359 --> 02:26:12,080
Vamos dizer adicionar números e podemos passar

3747
02:26:12,080 --> 02:26:14,319
em quaisquer dois números que queremos

3748
02:26:14,319 --> 02:26:18,640
somar vamos passar em 25

3749
02:26:18,640 --> 02:26:20,560
e 7 por exemplo

3750
02:26:20,560 --> 02:26:23,760
Nós esperamos que isso nos dê 32

3751
02:26:23,760 --> 02:26:27,200
Então, se imprimirmos a soma novamente, podemos apenas

3752
02:26:27,200 --> 02:26:29,280
completar esta declaração

3753
02:26:29,280 --> 02:26:32,240
que imprime a soma e reutilizá-la aqui

3754
02:26:32,240 --> 02:26:34,880
Vamos alinhar isso um pouco e eu quero

3755
02:26:34,880 --> 02:26:37,200
Você vai adivinhar o que estamos indo

3756
02:26:37,200 --> 02:26:39,439
para ir a partir deste programa agora, nós

3757
02:26:39,439 --> 02:26:41,359
Temos esses dois números que estamos adicionando

3758
02:26:41,359 --> 02:26:44,319
eles se chegarmos aqui, isso deve imprimir

3759
02:26:44,319 --> 02:26:46,240
O primeiro número que vai ser um

3760
02:26:46,240 --> 02:26:50,240
13 então aqui esperamos obter 13 e por

3761
02:26:50,240 --> 02:26:52,399
o tempo que atingimos este segundo número

3762
02:26:52,399 --> 02:26:54,560
Declaração vamos imprimir o

3763
02:26:54,560 --> 02:26:57,280
Segundo número vai ser 7. se nós

3764
02:26:57,280 --> 02:26:59,439
chegar aqui nós vamos imprimir o que quer que

3765
02:26:59,439 --> 02:27:02,479
é armazenado em soma e em soma que temos o

3766
02:27:02,479 --> 02:27:05,439
soma do primeiro e segundo número assim

3767
02:27:05,439 --> 02:27:08,960
isso deveria imprimir 20 e aqui estamos

3768
02:27:08,960 --> 02:27:11,359
estão fazendo mais uma soma de dois números, mas

3769
02:27:11,359 --> 02:27:14,479
Estamos usando uma função predefinida

3770
02:27:14,479 --> 02:27:16,560
que temos aqui antes do principal

3771
02:27:16,560 --> 02:27:19,120
Função porque você tem que definir o

3772
02:27:19,120 --> 02:27:21,200
função antes de usá-lo bem se nós

3773
02:27:21,200 --> 02:27:24,319
Adicione 25 e sete nós vamos cair

3774
02:27:24,319 --> 02:27:27,200
nesta função e vai adicionar

3775
02:27:27,200 --> 02:27:28,960
esses números aumentam e nós vamos conseguir

3776
02:27:28,960 --> 02:27:30,399
um 32 aqui dentro

3777
02:27:30,399 --> 02:27:32,560
E é isso que vamos voltar

3778
02:27:32,560 --> 02:27:34,319
E vai ser salvo neste

3779
02:27:34,319 --> 02:27:36,479
variável se imprimirmos, ele está indo

3780
02:27:36,479 --> 02:27:39,280
para nos dar 32. Espero que isso faça sentido

3781
02:27:39,280 --> 02:27:42,800
Vamos construir e executar nossa tarefa de execução de programas

3782
02:27:42,800 --> 02:27:45,439
mundo com gcc o mundo vai ir

3783
02:27:45,439 --> 02:27:47,200
Tudo bem, vamos voltar para o nosso

3784
02:27:47,200 --> 02:27:49,680
terminal aqui que é claro para que

3785
02:27:49,680 --> 02:27:52,800
As coisas não nos incomodam e uh tragam

3786
02:27:52,800 --> 02:27:54,880
alguma confusão que vamos executar o nosso

3787
02:27:54,880 --> 02:27:58,000
programa de galo e exatamente o que temos

3788
02:27:58,000 --> 02:28:00,080
Aqui temos um 13 do primeiro

3789
02:28:00,080 --> 02:28:03,120
Declaração aqui temos um 7 a partir deste

3790
02:28:03,120 --> 02:28:06,080
Declaração aqui temos um 20 a partir deste

3791
02:28:06,080 --> 02:28:09,600
soma aqui que está aqui e nós temos um 32

3792
02:28:09,600 --> 02:28:12,080
que nós temos desta função o bem

3793
02:28:12,080 --> 02:28:13,760
O que é sobre funções é que podemos

3794
02:28:13,760 --> 02:28:16,080
reutilizá-los agora que sabemos como usar

3795
02:28:16,080 --> 02:28:18,399
Podemos usá-lo novamente e podemos dizer

3796
02:28:18,399 --> 02:28:20,080
A soma é igual a

3797
02:28:20,080 --> 02:28:24,160
adicionar números e podemos dizer 30 e

3798
02:28:24,160 --> 02:28:26,479
54, por exemplo, você os soma e

3799
02:28:26,479 --> 02:28:28,080
Você vai obter os resultados, então nós somos

3800
02:28:28,080 --> 02:28:30,800
vamos imprimir o resultado alguns e nós estamos

3801
02:28:30,800 --> 02:28:33,520
Vou colocar na soma que eu realmente quero

3802
02:28:33,520 --> 02:28:35,520
você para levar algum tempo e jogar com isso

3803
02:28:35,520 --> 02:28:37,359
declaração para que essas coisas façam

3804
02:28:37,359 --> 02:28:39,760
Sentir que não é tão difícil, mas

3805
02:28:39,760 --> 02:28:41,760
Você só tem que balançar seus cérebros ao redor

3806
02:28:41,760 --> 02:28:44,880
Como c plus define essas coisas assim

3807
02:28:44,880 --> 02:28:47,200
Nós temos esta declaração e estamos adicionando

3808
02:28:47,200 --> 02:28:51,760
30 e 54 então deve obter um 84 depois

3809
02:28:51,760 --> 02:28:54,640
os 32 aqui vamos soldar, vamos

3810
02:28:54,640 --> 02:28:57,359
executar a tarefa para o mundo com gcc

3811
02:28:57,359 --> 02:28:59,600
Vou clicar no terminal aqui e

3812
02:28:59,600 --> 02:29:02,720
hit enter vamos claro para que não

3813
02:29:02,720 --> 02:29:04,399
Tenho coisas que nos perturbam e nós

3814
02:29:04,399 --> 02:29:07,359
vamos executar o nosso programa e nós temos o nosso

3815
02:29:07,359 --> 02:29:10,720
confiável 84 aqui eu realmente espero que isso faça

3816
02:29:10,720 --> 02:29:12,800
Sentir e como um bônus que vou mostrar

3817
02:29:12,800 --> 02:29:15,680
Você que você também pode chamar de coisas

3818
02:29:15,680 --> 02:29:19,200
no stdc out declaração aqui sem

3819
02:29:19,200 --> 02:29:21,840
Ter que armazená-los em alguns

3820
02:29:21,840 --> 02:29:24,080
variáveis e às vezes isso vem em

3821
02:29:24,080 --> 02:29:27,920
útil para que você possa dizer std ver e

3822
02:29:27,920 --> 02:29:31,200
nós vamos dizer soma e você pode dizer

3823
02:29:31,200 --> 02:29:33,600
adicionar números aqui e você está

3824
02:29:33,600 --> 02:29:37,600
vamos dizer 3, por exemplo, e uh 42 e

3825
02:29:37,600 --> 02:29:40,800
Isso vai nos dar um 45 que é

3826
02:29:40,800 --> 02:29:43,200
O que devemos esperar ver depois de 84

3827
02:29:43,200 --> 02:29:44,080
aqui

3828
02:29:44,080 --> 02:29:46,720
Então esse é o mundo e executar a tarefa para

3829
02:29:46,720 --> 02:29:49,040
construir com gcc o mundo vai ser

3830
02:29:49,040 --> 02:29:51,760
bem sucedido, clique no terminal aqui

3831
02:29:51,760 --> 02:29:54,080
nós atingimos entrar para que vejamos nosso terminal

3832
02:29:54,080 --> 02:29:56,319
com a saída, vamos limpar para que

3833
02:29:56,319 --> 02:29:59,120
vemos nossa saída sem ruído

3834
02:29:59,120 --> 02:30:01,600
vamos executar o nosso programa e nós vamos

3835
02:30:01,600 --> 02:30:04,240
para ver um 45 aqui eu realmente espero que isso

3836
02:30:04,240 --> 02:30:06,000
Faz sentido todo o ponto disso

3837
02:30:06,000 --> 02:30:08,080
A palestra foi para torná-lo consciente de

3838
02:30:08,080 --> 02:30:10,560
declarações e função de uma declaração é

3839
02:30:10,560 --> 02:30:13,120
a unidade mais básica em seu c plus plus

3840
02:30:13,120 --> 02:30:16,080
programar basicamente vive em uma linha

3841
02:30:16,080 --> 02:30:19,200
mas também pode se espalhar por diferentes

3842
02:30:19,200 --> 02:30:20,960
linhas, mas não vamos olhar para

3843
02:30:20,960 --> 02:30:22,640
que aqui talvez nós vamos ver isso

3844
02:30:22,640 --> 02:30:25,120
Mais tarde nas declarações do curso são

3845
02:30:25,120 --> 02:30:27,760
executado em ordem quando o nosso principal

3846
02:30:27,760 --> 02:30:30,240
A função começa a ser executada pelo computador

3847
02:30:30,240 --> 02:30:31,520
Vai sair do primeiro

3848
02:30:31,520 --> 02:30:33,439
Declaração de segunda declaração em terceiro

3849
02:30:33,439 --> 02:30:36,000
Declaração e vai até lá

3850
02:30:36,000 --> 02:30:39,040
atinge o fim e podemos ver que aqui em

3851
02:30:39,040 --> 02:30:40,960
A ordem em que nossos números são

3852
02:30:40,960 --> 02:30:43,680
impresso está indo de cima para baixo

3853
02:30:43,680 --> 02:30:46,000
Também vimos que podemos dividir nosso

3854
02:30:46,000 --> 02:30:48,399
código em diferentes funções e wrap

3855
02:30:48,399 --> 02:30:50,160
Seja qual for a funcionalidade que temos em um

3856
02:30:50,160 --> 02:30:52,800
Função que temos visto os conceitos básicos

3857
02:30:52,800 --> 02:30:54,960
em funções uma função tem um retorno

3858
02:30:54,960 --> 02:30:57,680
valor tem um nome e você tem que dar

3859
02:30:57,680 --> 02:31:00,080
Os parâmetros e você coloca o corpo

3860
02:31:00,080 --> 02:31:02,880
de sua função dentro destes dois encaracolados

3861
02:31:02,880 --> 02:31:05,760
chaves como um exercício eu iria desafiar

3862
02:31:05,760 --> 02:31:09,120
você para fazer uma função que multiplica dois

3863
02:31:09,120 --> 02:31:11,680
números e chamá-lo na função principal

3864
02:31:11,680 --> 02:31:14,000
aqui para ver o resultado se você tiver alguma

3865
02:31:14,000 --> 02:31:16,080
Problema, por favor, pergunte-me que eu vou

3866
02:31:16,080 --> 02:31:18,880
fazer o melhor que posso para ajudar isso

3867
02:31:18,880 --> 02:31:20,880
Cobres tudo o que nos prosseguimos para fazer neste

3868
02:31:20,880 --> 02:31:22,560
palestra e espero que você a tenha encontrado

3869
02:31:22,560 --> 02:31:24,640
interessante, vamos parar por aqui

3870
02:31:24,640 --> 02:31:26,319
Esta palestra no próximo vamos

3871
02:31:26,319 --> 02:31:29,280
para ver como podemos inserir e produzir

3872
02:31:29,280 --> 02:31:32,240
coisas do nosso programa c plus plus go

3873
02:31:32,240 --> 02:31:34,479
Na frente e terminar aqui e me encontrar

3874
02:31:34,479 --> 02:31:35,920
lá nesta palestra vamos

3875
02:31:35,920 --> 02:31:38,560
Saiba como podemos receber graças em nosso

3876
02:31:38,560 --> 02:31:41,120
programar e tirar as coisas do nosso

3877
02:31:41,120 --> 02:31:43,359
programa e que é basicamente entrada e

3878
02:31:43,359 --> 02:31:46,720
saída de e para o nosso programa que temos

3879
02:31:46,720 --> 02:31:49,040
Na verdade, tenho feito isso o tempo todo

3880
02:31:49,040 --> 02:31:51,040
têm impresso as coisas do nosso

3881
02:31:51,040 --> 02:31:52,880
Programa para o console

3882
02:31:52,880 --> 02:31:55,040
e com esta técnica você pode realmente

3883
02:31:55,040 --> 02:31:57,680
Pense em stdc para fora

3884
02:31:57,680 --> 02:32:01,040
como uma estrada que vai do seu programa

3885
02:32:01,040 --> 02:32:02,960
para o terminal você pode, basicamente, pensar

3886
02:32:02,960 --> 02:32:05,200
dele como se esses dados fossem de você

3887
02:32:05,200 --> 02:32:08,240
programa para sddc para fora e está indo de

3888
02:32:08,240 --> 02:32:10,560
aqui para o terminal e disso você

3889
02:32:10,560 --> 02:32:13,280
pode ter uma ideia do porquê

3890
02:32:13,280 --> 02:32:16,080
menos do que sinais de ponto para o

3891
02:32:16,080 --> 02:32:18,720
à esquerda porque os dados estão saindo do seu

3892
02:32:18,720 --> 02:32:22,319
programa para htdc para fora e estes dois

3893
02:32:22,319 --> 02:32:25,280
Os símbolos apontam para a esquerda que apontam para

3894
02:32:25,280 --> 02:32:29,840
hddc para sinalizar para o fato de que os dados

3895
02:32:29,840 --> 02:32:33,120
está indo daqui para aqui eu realmente espero

3896
02:32:33,120 --> 02:32:35,600
Isso faz sentido, porque às vezes estes

3897
02:32:35,600 --> 02:32:37,920
As coisas podem confundir as pessoas que este é o

3898
02:32:37,920 --> 02:32:41,040
por que ele está indo de seus dados para

3899
02:32:41,040 --> 02:32:43,520
Os dados do stdc out estão basicamente indo de

3900
02:32:43,520 --> 02:32:47,600
seu programa em httc para fora e o sddc

3901
02:32:47,600 --> 02:32:50,080
fora é uma maneira de obter dados de

3902
02:32:50,080 --> 02:32:52,000
Nosso programa para o console existem

3903
02:32:52,000 --> 02:32:57,200
muitos outros temos std c e r r ou std

3904
02:32:57,200 --> 02:32:59,520
servidor isto é o que eu gostaria de chamá-lo

3905
02:32:59,520 --> 02:33:02,160
e o que ele faz imprime erros para o

3906
02:33:02,160 --> 02:33:05,120
Console, temos stdc log que está indo

3907
02:33:05,120 --> 02:33:08,000
para imprimir mensagens de log por que temos

3908
02:33:08,000 --> 02:33:09,760
Essas diferentes coisas são diferentes

3909
02:33:09,760 --> 02:33:12,479
Os programas podem decidir formatar estes

3910
02:33:12,479 --> 02:33:14,720
Mensagens de forma diferente porque são

3911
02:33:14,720 --> 02:33:17,200
Mensagens diferentes é simples

3912
02:33:17,200 --> 02:33:19,520
Mensagem do programa outro é o

3913
02:33:19,520 --> 02:33:22,080
estreitas que você pode querer virar este vermelho

3914
02:33:22,080 --> 02:33:24,240
para realmente trazer a atenção

3915
02:33:24,240 --> 02:33:26,399
para esta mensagem porque o usuário tem que

3916
02:33:26,399 --> 02:33:28,560
resolver esse problema outro pode ser um

3917
02:33:28,560 --> 02:33:30,720
mensagem de log que você deseja armazenar em

3918
02:33:30,720 --> 02:33:33,040
algum arquivo ou algum banco de dados

3919
02:33:33,040 --> 02:33:35,439
Os usos para essas coisas diferem e c plus

3920
02:33:35,439 --> 02:33:37,280
Além disso, certifique-se de lhe dar diferente

3921
02:33:37,280 --> 02:33:40,080
maneiras de declarar sua intenção através do

3922
02:33:40,080 --> 02:33:42,720
ferramentas que você usa, nós olhamos

3923
02:33:42,720 --> 02:33:47,600
esddc out sddc erro e stdc log o que

3924
02:33:47,600 --> 02:33:51,520
faz

3925
02:33:51,520 --> 02:33:53,439
ele vai tirar dados do

3926
02:33:53,439 --> 02:33:56,479
programar e trazer isso para o programa

3927
02:33:56,479 --> 02:33:58,880
Vejamos alguns exemplos usando

3928
02:33:58,880 --> 02:34:01,280
Estes aqui temos um exemplo de

3929
02:34:01,280 --> 02:34:04,479
impressão de dados do programa para o

3930
02:34:04,479 --> 02:34:06,800
Terminal através de c out

3931
02:34:06,800 --> 02:34:08,720
cr e c log

3932
02:34:08,720 --> 02:34:10,800
Aqui temos uma mensagem de mundo olá indo

3933
02:34:10,800 --> 02:34:12,240
para c out

3934
02:34:12,240 --> 02:34:15,680
Aqui temos um número indo para c out

3935
02:34:15,680 --> 02:34:17,920
Isto é o que temos feito o tempo todo

3936
02:34:17,920 --> 02:34:20,399
nós também podemos fazer uma variável que armazena o

3937
02:34:20,399 --> 02:34:22,319
borda, por exemplo, é um número inteiro

3938
02:34:22,319 --> 02:34:23,680
É um inteiro

3939
02:34:23,680 --> 02:34:26,399
Então nós imprimimos isso e a mensagem é

3940
02:34:26,399 --> 02:34:30,000
indo para ir do programa para cl so

3941
02:34:30,000 --> 02:34:32,080
Você pode pensar que as coisas estão indo

3942
02:34:32,080 --> 02:34:35,680
O programa para sair eu realmente queria

3943
02:34:35,680 --> 02:34:37,760
Isso para fazer sentido se descermos

3944
02:34:37,760 --> 02:34:40,399
nós vamos ver que podemos usar cr para

3945
02:34:40,399 --> 02:34:42,960
Imprimir erros no terminal e nós

3946
02:34:42,960 --> 02:34:45,359
Pode dizer que algo deu errado ou

3947
02:34:45,359 --> 02:34:47,280
algo nesse sentido para trazer o

3948
02:34:47,280 --> 02:34:50,160
atenção ao problema e podemos usar

3949
02:34:50,160 --> 02:34:53,280
c log para imprimir mensagens de log e eles

3950
02:34:53,280 --> 02:34:55,760
trabalhar da mesma forma que todos usam o

3951
02:34:55,760 --> 02:34:58,560
operador de saída de fluxo e está indo

3952
02:34:58,560 --> 02:35:01,280
para tirar dados do programa para

3953
02:35:01,280 --> 02:35:03,520
O fluxo de saída realmente é o que nós

3954
02:35:03,520 --> 02:35:05,760
Significado aqui é um exemplo de como você

3955
02:35:05,760 --> 02:35:08,240
pode ler dados e trazer isso para o

3956
02:35:08,240 --> 02:35:10,560
programa aqui temos duas variáveis uma

3957
02:35:10,560 --> 02:35:12,880
é a idade que é um número inteiro ou um

3958
02:35:12,880 --> 02:35:15,600
inteiro e z plus plus e o outro é

3959
02:35:15,600 --> 02:35:18,000
uma string este é um tipo que lhe permite

3960
02:35:18,000 --> 02:35:20,720
para armazenar cordas em c plus plus

3961
02:35:20,720 --> 02:35:22,560
Vou aprender um pouco mais sobre isso

3962
02:35:22,560 --> 02:35:25,280
Mais tarde, mas aqui eu quero usá-lo para

3963
02:35:25,280 --> 02:35:27,439
realmente deixar claro que você pode obter

3964
02:35:27,439 --> 02:35:29,600
coisas de fora e trazer isso

3965
02:35:29,600 --> 02:35:31,439
dados em seu programa, então vamos

3966
02:35:31,439 --> 02:35:34,560
Deixe o usuário digitar o sobrenome e

3967
02:35:34,560 --> 02:35:37,920
Esta declaração aqui com cin

3968
02:35:37,920 --> 02:35:40,800
está obtendo dados do fluxo ou de

3969
02:35:40,800 --> 02:35:43,359
A estrada através da qual os dados vêm

3970
02:35:43,359 --> 02:35:45,920
em nosso programa e trazendo isso

3971
02:35:45,920 --> 02:35:48,399
nosso programa e aqui deve ser claro

3972
02:35:48,399 --> 02:35:51,120
que o fluxo de dados está neste

3973
02:35:51,120 --> 02:35:54,399
Os dados de direção estão indo de c i n e

3974
02:35:54,399 --> 02:35:56,560
estamos armazenando isso em uma variável que

3975
02:35:56,560 --> 02:35:59,120
temos em nosso programa que é chamado nome

3976
02:35:59,120 --> 02:36:01,520
Fazemos a mesma coisa e pedimos ao usuário que

3977
02:36:01,520 --> 02:36:03,760
Imprima a idade e eles vão

3978
02:36:03,760 --> 02:36:06,160
imprimir isso e os dados virão

3979
02:36:06,160 --> 02:36:09,040
A partir de cin e nós vamos armazenar isso

3980
02:36:09,040 --> 02:36:11,439
em nossa variável de borda aqui depois de

3981
02:36:11,439 --> 02:36:13,120
coletar os dados do usuário que somos

3982
02:36:13,120 --> 02:36:14,800
vou imprimir isso e nós vamos

3983
02:36:14,800 --> 02:36:16,960
Diga olá, vamos imprimir o nome

3984
02:36:16,960 --> 02:36:18,800
e nós vamos dizer que eles são o que for

3985
02:36:18,800 --> 02:36:21,600
anos de idade, é isso que este programa faz

3986
02:36:21,600 --> 02:36:24,000
E eu realmente espero que isso o torne claro

3987
02:36:24,000 --> 02:36:27,200
Como a entrada de dados funciona através de fluxos em

3988
02:36:27,200 --> 02:36:29,200
excedente mais outra coisa que podemos fazer

3989
02:36:29,200 --> 02:36:30,120
em

3990
02:36:30,120 --> 02:36:34,640
sddcin é entrada de encadeamento e nós podemos usar

3991
02:36:34,640 --> 02:36:37,280
Esta técnica para obter dados em um

3992
02:36:37,280 --> 02:36:39,439
A declaração veja o programa aqui em baixo

3993
02:36:39,439 --> 02:36:41,200
Para realmente entender isso, temos o

3994
02:36:41,200 --> 02:36:43,680
as mesmas variáveis idade e nome deixamos a

3995
02:36:43,680 --> 02:36:45,840
tipo de usuário no sobrenome e idade

3996
02:36:45,840 --> 02:36:47,840
separados por espaços

3997
02:36:47,840 --> 02:36:50,319
e pegamos os dados como este, primeiro

3998
02:36:50,319 --> 02:36:53,120
Pegue o nome depois que pegamos a idade

3999
02:36:53,120 --> 02:36:55,200
E nós vamos imprimir as mesmas coisas

4000
02:36:55,200 --> 02:36:57,040
e nós podemos acorrentar

4001
02:36:57,040 --> 02:37:00,479
operadores de fluxo de entrada como este para agarrar

4002
02:37:00,479 --> 02:37:02,880
os dados de uma só vez e isso pode vir

4003
02:37:02,880 --> 02:37:04,479
úteis às vezes

4004
02:37:04,479 --> 02:37:06,880
antes de tentar essas coisas no visual

4005
02:37:06,880 --> 02:37:08,720
código de estúdio que eu quero trazer seu

4006
02:37:08,720 --> 02:37:10,800
Atenção a um problema que você é

4007
02:37:10,800 --> 02:37:13,760
É provável que entre em contato e que

4008
02:37:13,760 --> 02:37:16,880
está lendo dados com espaços e se

4009
02:37:16,880 --> 02:37:19,200
O usuário digita o nome

4010
02:37:19,200 --> 02:37:21,359
com espaços, por exemplo, você me pediu para

4011
02:37:21,359 --> 02:37:23,439
digite meu nome eu não vou digitar

4012
02:37:23,439 --> 02:37:26,240
daniel eu vou digitar daniel cafwaya

4013
02:37:26,240 --> 02:37:28,000
e seu programa vai se deparar com

4014
02:37:28,000 --> 02:37:30,560
problemas c plus plus permite resolver

4015
02:37:30,560 --> 02:37:34,000
este problema usando std obter linha e você

4016
02:37:34,000 --> 02:37:35,120
Use-o

4017
02:37:35,120 --> 02:37:37,920
usando esta sintaxe que você vai passar

4018
02:37:37,920 --> 02:37:39,840
no fluxo onde os dados vão

4019
02:37:39,840 --> 02:37:41,760
ir e você vai passar no

4020
02:37:41,760 --> 02:37:43,920
variável que vai ler os dados

4021
02:37:43,920 --> 02:37:45,040
E você vai ter isso

4022
02:37:45,040 --> 02:37:47,200
informações armazenadas corretamente em seu

4023
02:37:47,200 --> 02:37:50,000
programa isso pode não fazer sentido

4024
02:37:50,000 --> 02:37:52,479
Ainda para você vamos para o visual

4025
02:37:52,479 --> 02:37:55,040
código de estúdio e jogar conosco e eu sou

4026
02:37:55,040 --> 02:37:57,280
Com certeza vai fazer sentido ok aqui

4027
02:37:57,280 --> 02:37:59,840
Estamos em código de estúdio visual e temos

4028
02:37:59,840 --> 02:38:01,840
nosso projeto onde vamos armazenar

4029
02:38:01,840 --> 02:38:04,479
nossos arquivos dados importados saída que somos

4030
02:38:04,479 --> 02:38:06,640
Vou copiar o código do nosso modelo

4031
02:38:06,640 --> 02:38:08,960
Projeto e vamos colocar os dados

4032
02:38:08,960 --> 02:38:11,120
e eu vou abrir esta pasta em

4033
02:38:11,120 --> 02:38:13,439
código de estúdio visual, então vamos fechar

4034
02:38:13,439 --> 02:38:15,920
O que quer que tenhamos agora e eu vou

4035
02:38:15,920 --> 02:38:18,960
abrir minha pasta vamos navegar lá eu sou

4036
02:38:18,960 --> 02:38:21,520
nesta pasta entrada de dados e saída i

4037
02:38:21,520 --> 02:38:24,000
Vou selecionar isso e ao projeto

4038
02:38:24,000 --> 02:38:26,560
Vai abrir no estúdio visual

4039
02:38:26,560 --> 02:38:28,800
Código eu vou pular para o meu principal

4040
02:38:28,800 --> 02:38:30,720
Função eu vou tirar as coisas

4041
02:38:30,720 --> 02:38:32,800
Não precisamos e a primeira coisa que somos

4042
02:38:32,800 --> 02:38:34,800
indo fazer é imprimir dados que temos

4043
02:38:34,800 --> 02:38:36,080
Realmente fez isso, então nós vamos

4044
02:38:36,080 --> 02:38:38,240
Pratique isso um pouco, podemos dizer

4045
02:38:38,240 --> 02:38:40,000
stdc para fora

4046
02:38:40,000 --> 02:38:44,080
e podemos dizer olá c mais 20 porquê

4047
02:38:44,080 --> 02:38:47,359
Não e nós vamos colocar um std

4048
02:38:47,359 --> 02:38:50,080
endl no final e lembrem-se do nosso

4049
02:38:50,080 --> 02:38:53,680
ponto e vírgula e aqui eu quero que você realmente

4050
02:38:53,680 --> 02:38:56,960
Coloque em sua cabeça que os dados estão indo

4051
02:38:56,960 --> 02:39:01,040
nosso programa aqui para hddc out e sddc

4052
02:39:01,040 --> 02:39:02,880
fora vai despejar isso no

4053
02:39:02,880 --> 02:39:05,120
terminal que é assim que funciona você pode

4054
02:39:05,120 --> 02:39:08,399
também fazer uma variável, digamos, formi

4055
02:39:08,399 --> 02:39:11,760
a idade, por exemplo, digamos 21 anos e terminar

4056
02:39:11,760 --> 02:39:14,000
Isso com o ponto e vírgula e também podemos

4057
02:39:14,000 --> 02:39:17,280
imprimir o h nós podemos dizer sddc para fora

4058
02:39:17,280 --> 02:39:19,359
E nós podemos dizer

4059
02:39:19,359 --> 02:39:21,920
idade que vai ser enviada para o

4060
02:39:21,920 --> 02:39:23,600
fluxo de saída

4061
02:39:23,600 --> 02:39:26,720
e nós vamos fazer sdd e dl para adicionar

4062
02:39:26,720 --> 02:39:27,600
a

4063
02:39:27,600 --> 02:39:30,240
Novo personagem de linha no final e podemos

4064
02:39:30,240 --> 02:39:32,240
Tente construir isso antes do programa

4065
02:39:32,240 --> 02:39:34,160
fica mais complicado, vamos para

4066
02:39:34,160 --> 02:39:36,240
terminal, vamos fazer o teste

4067
02:39:36,240 --> 02:39:38,800
Mundo com o Gcc

4068
02:39:38,800 --> 02:39:42,319
e se nós entrarmos no terminal aqui

4069
02:39:42,319 --> 02:39:44,319
O terminal vai desaparecer, estamos

4070
02:39:44,319 --> 02:39:47,040
Vai criar um novo, não é grande coisa

4071
02:39:47,040 --> 02:39:49,600
E se fizermos o Dir, vamos encontrar

4072
02:39:49,600 --> 02:39:52,319
nosso programa de galo se executá-lo é

4073
02:39:52,319 --> 02:39:56,000
vamos dizer olá c mais 20 e a idade

4074
02:39:56,000 --> 02:39:59,040
vai ser 21. nós estamos com sucesso

4075
02:39:59,040 --> 02:40:01,600
recebendo dados do nosso programa e

4076
02:40:01,600 --> 02:40:04,080
Imprimindo isso no terminal, isso é

4077
02:40:04,080 --> 02:40:06,640
muito legal e você pode pensar em esddc

4078
02:40:06,640 --> 02:40:09,359
fora como a estrada que realmente está indo

4079
02:40:09,359 --> 02:40:12,080
para retirar os seus dados do seu programa e

4080
02:40:12,080 --> 02:40:16,080
Trate isso para sddc fora assim

4081
02:40:16,080 --> 02:40:18,000
nós também vamos tomar a idade que é

4082
02:40:18,000 --> 02:40:20,399
indo passar pelo esddc para fora e é

4083
02:40:20,399 --> 02:40:22,160
indo para aparecer aqui você pode pensar

4084
02:40:22,160 --> 02:40:24,319
assim tudo bem agora que temos

4085
02:40:24,319 --> 02:40:29,279
usado para fora, podemos usar sddcr e sddc

4086
02:40:29,279 --> 02:40:31,439
faça o login da mesma maneira, então vamos

4087
02:40:31,439 --> 02:40:34,000
Diga a sddcr

4088
02:40:34,000 --> 02:40:36,479
Eu vou dizer mensagem de erro e

4089
02:40:36,479 --> 02:40:38,800
A mensagem vai ser algo

4090
02:40:38,800 --> 02:40:41,359
errado você pode fazer o que quiser

4091
02:40:41,359 --> 02:40:43,840
Aqui e temos que lembrar de colocar um

4092
02:40:43,840 --> 02:40:45,840
Novo caractere de linha, caso contrário, dados

4093
02:40:45,840 --> 02:40:48,240
vai ser apertado em uma linha que podemos

4094
02:40:48,240 --> 02:40:51,359
também usar sddc log que realmente funciona o

4095
02:40:51,359 --> 02:40:54,960
da mesma maneira c log e podemos dizer log

4096
02:40:54,960 --> 02:40:57,840
Mensagem e vamos dizer alguma coisa

4097
02:40:57,840 --> 02:40:58,800
Aconteceu

4098
02:40:58,800 --> 02:41:03,040
e nós lembramos de colocar std endl e nosso

4099
02:41:03,040 --> 02:41:05,920
ponto e-vírgula se construirmos este programa

4100
02:41:05,920 --> 02:41:07,520
pode adivinhar o que vai fazer é

4101
02:41:07,520 --> 02:41:09,359
Vou imprimir essas coisas no

4102
02:41:09,359 --> 02:41:10,479
O terminal

4103
02:41:10,479 --> 02:41:12,319
Mas isso pode ser

4104
02:41:12,319 --> 02:41:13,439
úteis

4105
02:41:13,439 --> 02:41:15,680
para programas de terminais que suportam

4106
02:41:15,680 --> 02:41:17,760
Recursos para formatar diferentes mensagens

4107
02:41:17,760 --> 02:41:20,080
diretamente o programa vai saber

4108
02:41:20,080 --> 02:41:22,080
que uma mensagem é uma mensagem simples:

4109
02:41:22,080 --> 02:41:24,160
Outro é uma seta o outro é um log

4110
02:41:24,160 --> 02:41:26,800
mensagem vamos executar o nosso programa

4111
02:41:26,800 --> 02:41:28,640
Mas antes de fazermos isso, vamos claro

4112
02:41:28,640 --> 02:41:30,560
que não temos barulho aqui, estamos

4113
02:41:30,560 --> 02:41:32,640
indo para executar o programa e ele está indo

4114
02:41:32,640 --> 02:41:34,960
para dizer a mensagem de erro e o log

4115
02:41:34,960 --> 02:41:37,279
Mensagem aqui está ok agora o que estamos indo

4116
02:41:37,279 --> 02:41:40,080
olhar para é como podemos obter dados em

4117
02:41:40,080 --> 02:41:42,479
nosso programa e dados serão

4118
02:41:42,479 --> 02:41:44,800
Indo em uma direção diferente

4119
02:41:44,800 --> 02:41:46,319
Vai vir do

4120
02:41:46,319 --> 02:41:49,359
terminal e fluindo para o nosso programa

4121
02:41:49,359 --> 02:41:51,520
O que vamos fazer, vamos fazer

4122
02:41:51,520 --> 02:41:54,880
idade de form, esta é uma nova variável, então

4123
02:41:54,880 --> 02:41:57,520
nós vamos colocar dados e nós somos

4124
02:41:57,520 --> 02:42:00,640
vai trazer uma biblioteca de strings para

4125
02:42:00,640 --> 02:42:04,080
permitir que nosso programa armazene pontos fortes

4126
02:42:04,080 --> 02:42:05,439
Como vamos fazer isso, estamos indo

4127
02:42:05,439 --> 02:42:06,880
para incluir

4128
02:42:06,880 --> 02:42:09,279
força é assim que você faz em c plus

4129
02:42:09,279 --> 02:42:11,279
Além disso, nós realmente não aprendemos sobre

4130
02:42:11,279 --> 02:42:13,439
este tipo é um tipo poderoso em c plus

4131
02:42:13,439 --> 02:42:15,600
além disso, mas vamos chegar lá quando nós

4132
02:42:15,600 --> 02:42:17,600
ter ferramentas mais poderosas para realmente

4133
02:42:17,600 --> 02:42:19,200
Entenda isso, estamos apenas recebendo

4134
02:42:19,200 --> 02:42:21,279
Comece aqui, então o que vamos fazer

4135
02:42:21,279 --> 02:42:24,160
nós vamos dizer força e

4136
02:42:24,160 --> 02:42:25,680
nós vamos dizer nome

4137
02:42:25,680 --> 02:42:28,000
e vamos pedir ao usuário para imprimir

4138
02:42:28,000 --> 02:42:30,960
Seu nome e idade você já sabe como

4139
02:42:30,960 --> 02:42:33,520
para fazer isso para que vamos dizer por favor

4140
02:42:33,520 --> 02:42:35,760
Digite seu nome e idade e nós vamos

4141
02:42:35,760 --> 02:42:38,800
para fazer stdndl sobre isso e como estamos indo

4142
02:42:38,800 --> 02:42:41,520
para obter dados no programa que estamos indo

4143
02:42:41,520 --> 02:42:43,319
para usar

4144
02:42:43,319 --> 02:42:46,960
stdcin e nós vamos fazer std

4145
02:42:46,960 --> 02:42:50,399
Cim e os dados vão partir

4146
02:42:50,399 --> 02:42:53,200
o fluxo para o programa para que o

4147
02:42:53,200 --> 02:42:55,760
operador de entrada de fluxo aqui aponta para o

4148
02:42:55,760 --> 02:42:56,560
à direita

4149
02:42:56,560 --> 02:42:59,279
e os dados vão entrar no

4150
02:42:59,279 --> 02:43:00,960
Nome variável porque é isso que

4151
02:43:00,960 --> 02:43:02,880
Eles vão estar digitando primeiro

4152
02:43:02,880 --> 02:43:04,960
Porque isso é o que nós lhes dissemos para fazer

4153
02:43:04,960 --> 02:43:07,040
Então vamos guardar o nome

4154
02:43:07,040 --> 02:43:09,399
e nós vamos dizer

4155
02:43:09,399 --> 02:43:12,680
Os dados stdcim vão fluir a partir de

4156
02:43:12,680 --> 02:43:17,439
sddcin em nossa variável h1 OK agora

4157
02:43:17,439 --> 02:43:19,120
que o usuário nos deu sua

4158
02:43:19,120 --> 02:43:20,960
informações que podemos cumprimentá-los com um

4159
02:43:20,960 --> 02:43:23,200
Mensagem personalizada que vamos dizer

4160
02:43:23,200 --> 02:43:26,800
stdc out hello e nós vamos colocar

4161
02:43:26,800 --> 02:43:29,279
fora seu nome e nós vamos dizer

4162
02:43:29,279 --> 02:43:31,760
Eles são e nós vamos colocar o

4163
02:43:31,760 --> 02:43:32,640
A idade

4164
02:43:32,640 --> 02:43:34,560
um porque é isso que eles estão indo

4165
02:43:34,560 --> 02:43:37,840
Dá-nos aqui e eu vou dizer

4166
02:43:37,840 --> 02:43:38,880
anos de idade

4167
02:43:38,880 --> 02:43:41,920
e nós vamos colocar um std endl aqui

4168
02:43:41,920 --> 02:43:44,640
Eu vou pegar isso e puxar isso para

4169
02:43:44,640 --> 02:43:47,600
a esquerda para que possamos ver a nossa totalidade

4170
02:43:47,600 --> 02:43:50,560
programa aqui que é útil, então o que nós

4171
02:43:50,560 --> 02:43:52,240
Estamos fazendo aqui que estamos recebendo dados de

4172
02:43:52,240 --> 02:43:54,399
o usuário e estamos armazenando isso em nosso

4173
02:43:54,399 --> 02:43:56,560
variáveis e estamos a imprimir o

4174
02:43:56,560 --> 02:43:58,640
mensagem para que o usuário possa vê-lo i

4175
02:43:58,640 --> 02:44:01,120
Não quero as primeiras coisas que fizemos aqui

4176
02:44:01,120 --> 02:44:04,080
para nos incomodar quando nós e tentamos isso

4177
02:44:04,080 --> 02:44:07,040
fora, então eu vou comentar isso

4178
02:44:07,040 --> 02:44:10,000
e comentar o primeiro bloco de código para fora

4179
02:44:10,000 --> 02:44:12,000
usando comentários do blog eu acho que este é o

4180
02:44:12,000 --> 02:44:14,399
Primeira vez que usamos isso e isso é

4181
02:44:14,399 --> 02:44:16,560
será ignorado pelo compilador agora

4182
02:44:16,560 --> 02:44:18,800
E só vai considerar isso

4183
02:44:18,800 --> 02:44:20,640
E isso vai ser muito legal

4184
02:44:20,640 --> 02:44:22,960
Vamos descer um pouco aqui e eu

4185
02:44:22,960 --> 02:44:25,200
Tente construir o programa que vamos

4186
02:44:25,200 --> 02:44:28,880
executar a tarefa que solda com gcc e uh

4187
02:44:28,880 --> 02:44:31,040
Parece que o mundo é bom que estamos indo

4188
02:44:31,040 --> 02:44:33,600
para bater em entrar e nós vamos limpar assim

4189
02:44:33,600 --> 02:44:36,560
que não somos perturbados por isso que somos

4190
02:44:36,560 --> 02:44:38,319
Vou executar o programa, digamos

4191
02:44:38,319 --> 02:44:40,000
laoster.exe

4192
02:44:40,000 --> 02:44:42,560
vai me pedir para digitar meu nome e

4193
02:44:42,560 --> 02:44:44,560
idade meu nome é daniel eu vou digitar

4194
02:44:44,560 --> 02:44:47,279
aquele hit enter que vai querer que eu

4195
02:44:47,279 --> 02:44:48,880
Digite minha idade

4196
02:44:48,880 --> 02:44:50,600
então eu vou dizer

4197
02:44:50,600 --> 02:44:53,600
33, por exemplo,

4198
02:44:53,600 --> 02:44:56,080
E vai me dizer olá daniel

4199
02:44:56,080 --> 02:44:59,840
você tem 33 anos eu coloquei um slash aqui

4200
02:44:59,840 --> 02:45:02,000
nós podemos tentar executá-lo novamente para que eu

4201
02:45:02,000 --> 02:45:04,160
Não precisa cometer esse erro novamente, então

4202
02:45:04,160 --> 02:45:07,680
daniel que é o meu nome eu hit enter I say

4203
02:45:07,680 --> 02:45:08,880
33

4204
02:45:08,880 --> 02:45:10,640
e se eu correr

4205
02:45:10,640 --> 02:45:13,040
vai dizer olá daniel que você é

4206
02:45:13,040 --> 02:45:16,319
33 anos eu realmente espero que isso traga

4207
02:45:16,319 --> 02:45:17,840
o ponto de casa

4208
02:45:17,840 --> 02:45:18,680
que

4209
02:45:18,680 --> 02:45:21,680
stdcin é uma estrada

4210
02:45:21,680 --> 02:45:24,720
que leva os dados do terminal para

4211
02:45:24,720 --> 02:45:26,720
Seu programa, então isso é realmente o que é

4212
02:45:26,720 --> 02:45:28,560
acontecendo aqui quando eu digito daniel é

4213
02:45:28,560 --> 02:45:30,640
vai fluir do terminal e é

4214
02:45:30,640 --> 02:45:33,120
indo para a minha variável que é

4215
02:45:33,120 --> 02:45:35,840
nome aqui e quando eu digito a idade é

4216
02:45:35,840 --> 02:45:38,720
indo para ir na minha margem variável aqui e

4217
02:45:38,720 --> 02:45:41,680
Tudo isso acontecendo através de

4218
02:45:41,680 --> 02:45:44,800
Aqui, ok, uma outra coisa que podemos fazer

4219
02:45:44,800 --> 02:45:46,000
É

4220
02:45:46,000 --> 02:45:48,319
Pegue os dados e coloque isso em nosso

4221
02:45:48,319 --> 02:45:51,040
variáveis de uma só opção, então o que podemos fazer

4222
02:45:51,040 --> 02:45:53,439
Aqui está o comentário e nós vamos

4223
02:45:53,439 --> 02:45:54,359
para fazer

4224
02:45:54,359 --> 02:45:57,120
stdcin e nós vamos colocar isso dentro

4225
02:45:57,120 --> 02:45:59,439
nome e nós vamos mudar esses dois

4226
02:45:59,439 --> 02:46:02,720
Coisas e colocar o outro pedaço de dados

4227
02:46:02,720 --> 02:46:05,200
em h1 se você executar o programa que está indo

4228
02:46:05,200 --> 02:46:07,680
para trabalhar exatamente da mesma maneira, mas nós

4229
02:46:07,680 --> 02:46:10,479
agarrando os dados em uma linha, então vamos

4230
02:46:10,479 --> 02:46:12,319
solde para ver isso em ação, estamos indo

4231
02:46:12,319 --> 02:46:15,120
para executar a tarefa que mundos com gcc

4232
02:46:15,120 --> 02:46:16,880
Vamos clicar aqui e nós somos

4233
02:46:16,880 --> 02:46:18,960
indo para limpar se nós corremos o galo é

4234
02:46:18,960 --> 02:46:21,040
Vou pedir o nome e a idade

4235
02:46:21,040 --> 02:46:23,040
Eu vou colocar em daniel e eu estou indo

4236
02:46:23,040 --> 02:46:26,160
para colocar meu h e dizer 33, por exemplo, e

4237
02:46:26,160 --> 02:46:28,319
Vai fazer exatamente a mesma coisa

4238
02:46:28,319 --> 02:46:30,399
Mas temos uma linha compacta a última

4239
02:46:30,399 --> 02:46:32,160
O que eu quero te mostrar nesta palestra

4240
02:46:32,160 --> 02:46:34,880
É como você pode pegar dados com espaços

4241
02:46:34,880 --> 02:46:37,200
porque se eu tentar colocar dados com

4242
02:46:37,200 --> 02:46:40,399
espaços aqui o programa vai falhar

4243
02:46:40,399 --> 02:46:42,640
miseravelmente deixe-me mostrar-lhe isso eu estou indo

4244
02:46:42,640 --> 02:46:44,640
para limpar e eu vou correr o galo

4245
02:46:44,640 --> 02:46:47,439
de novo e eu vou dizer daniel eu sou

4246
02:46:47,439 --> 02:46:50,319
vou colocar meu nome completo e uh é

4247
02:46:50,319 --> 02:46:52,880
Realmente não pega o segundo nome e

4248
02:46:52,880 --> 02:46:55,520
Não me deu uma chance de inserir o meu

4249
02:46:55,520 --> 02:46:57,439
idade e isso é realmente ruim

4250
02:46:57,439 --> 02:46:59,840
assim c plus fornece uma maneira de resolver

4251
02:46:59,840 --> 02:47:03,040
este usando std obter linha, então vamos ver

4252
02:47:03,040 --> 02:47:04,880
O que estamos fazendo aqui e antes de

4253
02:47:04,880 --> 02:47:06,240
Com isso, vamos comentar

4254
02:47:06,240 --> 02:47:08,720
fora o que tínhamos aqui para que

4255
02:47:08,720 --> 02:47:11,279
Não nos incomoda no que somos

4256
02:47:11,279 --> 02:47:14,160
Estou prestes a fazer, vamos vir aqui e

4257
02:47:14,160 --> 02:47:16,560
Digamos que estávamos fazendo informações de dados sobre isso

4258
02:47:16,560 --> 02:47:18,479
é útil aqui e nós vamos embora

4259
02:47:18,479 --> 02:47:21,439
para baixo e pegar dados com espaços para que eu seja

4260
02:47:21,439 --> 02:47:23,600
Vou criar outra força e

4261
02:47:23,600 --> 02:47:25,840
Isso vai armazenar meu nome completo

4262
02:47:25,840 --> 02:47:28,319
Isso é o que eu vou dizer aqui e para

4263
02:47:28,319 --> 02:47:30,319
Agarrá-lo eu vou dizer ao usuário para

4264
02:47:30,319 --> 02:47:33,200
digite em seu nome completo e idade para que eu seja

4265
02:47:33,200 --> 02:47:35,760
indo para esddc para fora, então o caminho eu estou indo

4266
02:47:35,760 --> 02:47:38,880
para pegar os dados que eu vou fazer std get

4267
02:47:38,880 --> 02:47:40,880
linha você vê que nós temos essa função

4268
02:47:40,880 --> 02:47:42,800
aqui e vai levar uma entrada

4269
02:47:42,800 --> 02:47:45,920
fluxo para que a dd dcin vá trabalhar e

4270
02:47:45,920 --> 02:47:47,520
O segundo parâmetro vai ser o

4271
02:47:47,520 --> 02:47:49,760
variável onde esses dados de string estão indo

4272
02:47:49,760 --> 02:47:51,680
para ser armazenado, vamos passar em nosso

4273
02:47:51,680 --> 02:47:54,560
Nome completo e isso vai funcionar apenas

4274
02:47:54,560 --> 02:47:57,920
bem e nós também vamos pegar o h

4275
02:47:57,920 --> 02:47:59,680
usando a mesma técnica que usamos

4276
02:47:59,680 --> 02:48:01,560
Antes assim vamos dizer

4277
02:48:01,560 --> 02:48:04,560
stdcin e nós vamos armazenar isso em

4278
02:48:04,560 --> 02:48:07,680
nossa variável h3 quando temos os dados

4279
02:48:07,680 --> 02:48:10,720
pode cumprimentar o nosso usuário usando o mesmo

4280
02:48:10,720 --> 02:48:12,720
Mensagem que tivemos antes, então eu vou

4281
02:48:12,720 --> 02:48:15,279
copiar se eu posso fazer isso e eu estou indo

4282
02:48:15,279 --> 02:48:17,600
para colar que aqui eu vou trazer

4283
02:48:17,600 --> 02:48:19,439
este para o mesmo local que vai

4284
02:48:19,439 --> 02:48:21,680
Esteja o nome completo aqui e vai dizer

4285
02:48:21,680 --> 02:48:25,040
h3 e vamos tentar soldar, vamos

4286
02:48:25,040 --> 02:48:28,479
terminal executar a tarefa para aparafusar com gcc

4287
02:48:28,479 --> 02:48:31,600
e nós temos um problema porque esquecemos

4288
02:48:31,600 --> 02:48:33,760
Nosso ponto e vírgula vê como esses problemas

4289
02:48:33,760 --> 02:48:35,680
pode vir até você uh-huh, então nós estamos indo

4290
02:48:35,680 --> 02:48:38,399
para colocar em nosso ponto de ponto e outro

4291
02:48:38,399 --> 02:48:41,120
A coisa que eu realmente quero que você veja

4292
02:48:41,120 --> 02:48:42,399
É que você pode

4293
02:48:42,399 --> 02:48:44,640
trazer essas coisas para a próxima linha se

4294
02:48:44,640 --> 02:48:47,200
Eles saem por muito tempo como vemos aqui

4295
02:48:47,200 --> 02:48:49,359
para que eu possa, por exemplo, colocar isso para o

4296
02:48:49,359 --> 02:48:51,200
próxima linha e vai funcionar apenas

4297
02:48:51,200 --> 02:48:53,120
Que bom, então o que eu vou fazer eu estou indo

4298
02:48:53,120 --> 02:48:56,160
para tentar e soldar novamente executar a tarefa para construir

4299
02:48:56,160 --> 02:48:59,279
com gcc você vê que o mundo é bom

4300
02:48:59,279 --> 02:49:00,399
nós vamos

4301
02:49:00,399 --> 02:49:02,880
trazer o nosso terminal eu vou limpar

4302
02:49:02,880 --> 02:49:05,520
para que não tenhamos barulho aqui e

4303
02:49:05,520 --> 02:49:07,439
Vamos executar o nosso programa é

4304
02:49:07,439 --> 02:49:09,600
Vou pedir-me para colocar meu nome completo

4305
02:49:09,600 --> 02:49:11,600
Eu vou dizer daniel

4306
02:49:11,600 --> 02:49:13,520
E vai querer a idade que eu vou

4307
02:49:13,520 --> 02:49:15,600
para dizer 33 e vai chegar até mim

4308
02:49:15,600 --> 02:49:18,640
hello daniel gaway você tem 33 anos

4309
02:49:18,640 --> 02:49:21,600
Somos capazes de trazer dados com espaços

4310
02:49:21,600 --> 02:49:24,479
em nosso programa e isso conclui o que

4311
02:49:24,479 --> 02:49:26,800
nós tivemos que dizer nesta palestra eu espero que

4312
02:49:26,800 --> 02:49:30,640
deixou muito claro o que estes htd n e

4313
02:49:30,640 --> 02:49:33,520
stdc fora as coisas são que são basicamente

4314
02:49:33,520 --> 02:49:36,000
Estradas que tiram dados do seu

4315
02:49:36,000 --> 02:49:38,640
programar ou trazer dados para o seu programa

4316
02:49:38,640 --> 02:49:40,640
E a maneira como você os usa é o que temos

4317
02:49:40,640 --> 02:49:42,399
feito aqui neste curso eu gostaria

4318
02:49:42,399 --> 02:49:44,160
Incentive você a brincar conosco um casal

4319
02:49:44,160 --> 02:49:45,840
momentos em que esta é a primeira vez

4320
02:49:45,840 --> 02:49:47,680
Você está fazendo isso, vamos parar

4321
02:49:47,680 --> 02:49:49,520
Aqui nesta palestra na próxima

4322
02:49:49,520 --> 02:49:51,920
nós vamos tentar e recapitular no c

4323
02:49:51,920 --> 02:49:54,560
além de além do fluxo de trabalho de desenvolvimento, vá em frente

4324
02:49:54,560 --> 02:49:57,120
e terminar aqui e encontrar-me lá

4325
02:49:57,120 --> 02:49:59,040
Nesta palestra vamos explorar

4326
02:49:59,040 --> 02:50:02,160
o c plus mais modelo de execução e show

4327
02:50:02,160 --> 02:50:04,800
uma versão simplificada da memória

4328
02:50:04,800 --> 02:50:08,080
modelo do seu c plus programa aqui

4329
02:50:08,080 --> 02:50:11,279
É como o nosso programa parece que é simples

4330
02:50:11,279 --> 02:50:13,680
programa em nossa principal função que está indo

4331
02:50:13,680 --> 02:50:15,840
para chamar uma função simples que está indo

4332
02:50:15,840 --> 02:50:17,600
para adicionar dois números que vimos a

4333
02:50:17,600 --> 02:50:19,680
programa como este antes e quando

4334
02:50:19,680 --> 02:50:22,240
Comprificá-lo que vai ser transformado em

4335
02:50:22,240 --> 02:50:25,200
um binário que este ícone negro aqui representa

4336
02:50:25,200 --> 02:50:28,160
O executável binário e não está em

4337
02:50:28,160 --> 02:50:29,439
o formato

4338
02:50:29,439 --> 02:50:31,680
que você pode ler com seus olhos se nós

4339
02:50:31,680 --> 02:50:34,160
Volte aqui para o que estávamos fazendo

4340
02:50:34,160 --> 02:50:36,800
A última palestra podemos ver o nosso galo

4341
02:50:36,800 --> 02:50:39,600
binário executável aqui se você tentar

4342
02:50:39,600 --> 02:50:41,279
abra aqui você vai ver que

4343
02:50:41,279 --> 02:50:43,040
O código do estúdio visual vai dizer o

4344
02:50:43,040 --> 02:50:45,040
O arquivo não é exibido no editor

4345
02:50:45,040 --> 02:50:48,240
porque é binário ou usa um

4346
02:50:48,240 --> 02:50:52,000
codificação de texto não suportada, então diz i

4347
02:50:52,000 --> 02:50:53,520
Não posso dizer isso porque é

4348
02:50:53,520 --> 02:50:55,359
binário e diz que você quer abrir

4349
02:50:55,359 --> 02:50:57,760
de qualquer maneira, se eu tentar abri-lo, ele está indo

4350
02:50:57,760 --> 02:50:59,600
ser apenas um pouco bobish porque isso

4351
02:50:59,600 --> 02:51:02,720
É binário, é para ser

4352
02:51:02,720 --> 02:51:05,520
lidos por programas, não é para ser

4353
02:51:05,520 --> 02:51:09,040
por editores de texto ou editores de texto como visual

4354
02:51:09,040 --> 02:51:11,760
código de estúdio, então este é o arquivo binário

4355
02:51:11,760 --> 02:51:14,560
Temos aqui que eu tentei colocar um simplificado

4356
02:51:14,560 --> 02:51:16,479
Versão deste programa para representar

4357
02:51:16,479 --> 02:51:18,560
binário para que possamos acompanhe-o, mas

4358
02:51:18,560 --> 02:51:21,279
Não está na forma que é legível

4359
02:51:21,279 --> 02:51:24,399
por qualquer humano lá fora, a menos que você é um

4360
02:51:24,399 --> 02:51:26,720
máquina então por que é em binário porque

4361
02:51:26,720 --> 02:51:29,600
O formato binário é facilmente compreensível

4362
02:51:29,600 --> 02:51:31,920
pelo seu cpu e nós vamos ver como

4363
02:51:31,920 --> 02:51:34,080
seu programa é carregado na memória e

4364
02:51:34,080 --> 02:51:36,720
declaração executada por declaração pela

4365
02:51:36,720 --> 02:51:39,200
cpu para que você possa realmente entender

4366
02:51:39,200 --> 02:51:41,680
Aqui está uma representação de sua

4367
02:51:41,680 --> 02:51:44,319
programa aqui temos o nosso como conduzir

4368
02:51:44,319 --> 02:51:45,840
e temos o programa sentado

4369
02:51:45,840 --> 02:51:48,640
em algum lugar em nosso disco rígido em binário

4370
02:51:48,640 --> 02:51:52,000
formato e está esperando para ser executado por você

4371
02:51:52,000 --> 02:51:54,640
clicando duas vezes sobre ele ou abrindo

4372
02:51:54,640 --> 02:51:56,880
no terminal e à esquerda aqui nós

4373
02:51:56,880 --> 02:51:59,680
Veja uma representação da memória de

4374
02:51:59,680 --> 02:52:02,479
nosso computador e quando eu digo memória i

4375
02:52:02,479 --> 02:52:05,200
memória de acesso aleatório não quero dizer

4376
02:52:05,200 --> 02:52:07,920
memória em seu disco rígido que deve ser

4377
02:52:07,920 --> 02:52:09,920
muito claro que este é o acesso aleatório

4378
02:52:09,920 --> 02:52:12,319
memória do seu computador que está em execução

4379
02:52:12,319 --> 02:52:15,200
seus programas muito rápido quando você

4380
02:52:15,200 --> 02:52:18,240
duplo clique em nosso programa ou se nós

4381
02:52:18,240 --> 02:52:20,720
Abri-lo no terminal o arquivo binário

4382
02:52:20,720 --> 02:52:23,279
vai ser carregado na memória e

4383
02:52:23,279 --> 02:52:25,120
você vê isso em vermelho aqui este é um

4384
02:52:25,120 --> 02:52:27,520
Representação disso e está pronto

4385
02:52:27,520 --> 02:52:30,240
para ser executado pela cpu no momento em que o cpu

4386
02:52:30,240 --> 02:52:32,319
Diz na localização da memória que está indo

4387
02:52:32,319 --> 02:52:34,479
para saber que eu tenho um programa para executar e

4388
02:52:34,479 --> 02:52:36,560
cpu vai começar a executá-lo

4389
02:52:36,560 --> 02:52:38,399
declaração por declaração que vai

4390
02:52:38,399 --> 02:52:40,640
começar pelo topo para que ele vai ver

4391
02:52:40,640 --> 02:52:43,760
que precisa alocar espaço para armazenar

4392
02:52:43,760 --> 02:52:46,479
nosso inteiro a que vai alocar para

4393
02:52:46,479 --> 02:52:48,800
que em algum lugar na memória em amarelo

4394
02:52:48,800 --> 02:52:50,880
Aqui você vê a e vai ver

4395
02:52:50,880 --> 02:52:53,920
que deve armazenar em um valor de 10

4396
02:52:53,920 --> 02:52:55,520
E vai fazer isso que você pode ver

4397
02:52:55,520 --> 02:52:57,760
que aqui vai para a próxima

4398
02:52:57,760 --> 02:53:00,240
declaração e a próxima declaração diz

4399
02:53:00,240 --> 02:53:02,399
para alocar espaço para

4400
02:53:02,399 --> 02:53:06,000
um valor b e vai armazenar em f5

4401
02:53:06,000 --> 02:53:08,080
Vai para a próxima declaração

4402
02:53:08,080 --> 02:53:10,560
é uma variável chamada c que vai

4403
02:53:10,560 --> 02:53:12,560
alocar espaço para isso, mas nós não

4404
02:53:12,560 --> 02:53:15,439
especificar um valor para c então o que está acontecendo

4405
02:53:15,439 --> 02:53:17,840
fazer é armazenar em algum valor de lixo o

4406
02:53:17,840 --> 02:53:20,640
O valor lá não é especificado em

4407
02:53:20,640 --> 02:53:22,880
No momento em que vai saltar para o

4408
02:53:22,880 --> 02:53:25,120
A próxima declaração e o que vai fazer

4409
02:53:25,120 --> 02:53:27,600
é imprimir algumas coisas no console e

4410
02:53:27,600 --> 02:53:29,279
Vai fazer isso que vai

4411
02:53:29,279 --> 02:53:31,439
saltar para a próxima declaração e é

4412
02:53:31,439 --> 02:53:34,720
indo para a instrução 2 e aqui está

4413
02:53:34,720 --> 02:53:36,560
vai notar que ele vai

4414
02:53:36,560 --> 02:53:38,399
chamar uma função Eu não sei se você tem

4415
02:53:38,399 --> 02:53:40,720
notado, mas a cpu alocou a

4416
02:53:40,720 --> 02:53:44,080
localização especial da memória para a nossa função

4417
02:53:44,080 --> 02:53:46,319
a função não sai com o nosso código

4418
02:53:46,319 --> 02:53:49,040
aqui ou em qualquer lugar próximo das variáveis que

4419
02:53:49,040 --> 02:53:52,720
Temos aqui pode haver um grande pedaço

4420
02:53:52,720 --> 02:53:55,040
Memória entre estes dois ou três

4421
02:53:55,040 --> 02:53:57,840
Coisas para que o cpu saiba que está indo

4422
02:53:57,840 --> 02:54:00,080
para saltar para outro local que está indo

4423
02:54:00,080 --> 02:54:02,720
para perguntar a si mesmo se eu pular para esse local

4424
02:54:02,720 --> 02:54:04,800
para executar esta função como eu vou

4425
02:54:04,800 --> 02:54:07,600
Volte e a cpu é inteligente o suficiente para

4426
02:54:07,600 --> 02:54:10,240
Armazene o endereço de retorno e é isso que

4427
02:54:10,240 --> 02:54:12,160
Vai fazer isso vai dizer se eu

4428
02:54:12,160 --> 02:54:13,920
Ir para essa função eu quero voltar

4429
02:54:13,920 --> 02:54:16,479
para o endereço 6 e executar o que é

4430
02:54:16,479 --> 02:54:18,080
Depois deste endereço, então vai

4431
02:54:18,080 --> 02:54:21,279
armazenar 6 e cpu memória e vai

4432
02:54:21,279 --> 02:54:23,040
saltar para a função que vai demorar

4433
02:54:23,040 --> 02:54:25,600
O primeiro parâmetro como a e segundo

4434
02:54:25,600 --> 02:54:28,640
parâmetro como b assim a é feito o

4435
02:54:28,640 --> 02:54:30,800
O parâmetro 1 vai ser 10 que está indo

4436
02:54:30,800 --> 02:54:33,200
Para tomar o parâmetro 2 vai ser 5

4437
02:54:33,200 --> 02:54:35,840
porque é b aqui e em b temos um

4438
02:54:35,840 --> 02:54:38,080
5 e vai saltar para o próximo

4439
02:54:38,080 --> 02:54:40,240
declaração na função e é

4440
02:54:40,240 --> 02:54:42,560
vai adicionar o parâmetro 1 e

4441
02:54:42,560 --> 02:54:45,680
parâmetro 2. depois de adicionar essas coisas

4442
02:54:45,680 --> 02:54:48,479
up vai retornar o resultado para c

4443
02:54:48,479 --> 02:54:50,720
Podemos ver que aqui está tudo bem que é isso

4444
02:54:50,720 --> 02:54:52,880
o cpu vai fazer isso vai colocar

4445
02:54:52,880 --> 02:54:55,439
os resultados em c e o resultado é um 15

4446
02:54:55,439 --> 02:54:57,359
Então nós vamos escrever isso lá dentro

4447
02:54:57,359 --> 02:55:00,080
E agora que a função é realmente feita

4448
02:55:00,080 --> 02:55:01,920
Vai voltar ao seu endereço

4449
02:55:01,920 --> 02:55:03,920
E vai saltar para o próximo

4450
02:55:03,920 --> 02:55:06,560
segmento depois disso, ele vai

4451
02:55:06,560 --> 02:55:09,120
imprimir três declaração três que está indo

4452
02:55:09,120 --> 02:55:11,439
para saltar através da próxima linha e imprimir

4453
02:55:11,439 --> 02:55:14,560
A declaração quatro vai fazer isso e

4454
02:55:14,560 --> 02:55:17,680
A essa altura chegamos ao fim de

4455
02:55:17,680 --> 02:55:20,240
nosso programa e ele vai ser estourado

4456
02:55:20,240 --> 02:55:22,640
fora da memória e seu programa é

4457
02:55:22,640 --> 02:55:24,960
basicamente vai acabar com isso como você

4458
02:55:24,960 --> 02:55:28,479
O programa é executado pelo seu cpu e por que

4459
02:55:28,479 --> 02:55:30,560
Estou mostrando isso porque é

4460
02:55:30,560 --> 02:55:32,800
É muito bom ter uma ideia de como

4461
02:55:32,800 --> 02:55:35,359
A memória é alocada e usada pelo seu

4462
02:55:35,359 --> 02:55:38,000
programar outra boa razão é que alguns

4463
02:55:38,000 --> 02:55:40,319
c plus recurso exige que você tenha

4464
02:55:40,319 --> 02:55:42,720
Uma compreensão de um modelo de memória como

4465
02:55:42,720 --> 02:55:44,640
para entender como eles trabalham

4466
02:55:44,640 --> 02:55:46,880
Um exemplo, você viu que chamar isso

4467
02:55:46,880 --> 02:55:49,359
função do programa teve que saltar de

4468
02:55:49,359 --> 02:55:53,040
Endereço 6 a 30 e isso é realmente pesado

4469
02:55:53,040 --> 02:55:55,040
Principalmente se você estiver executando um simples

4470
02:55:55,040 --> 02:55:57,120
Função como estamos fazendo aqui para adicionar

4471
02:55:57,120 --> 02:55:59,920
dois números para que o cpu possa perceber que

4472
02:55:59,920 --> 02:56:02,880
e otimizar esta chamada para a função

4473
02:56:02,880 --> 02:56:06,080
para uma função em linha e adicionar estes dois

4474
02:56:06,080 --> 02:56:08,800
números aqui no endereço seis

4475
02:56:08,800 --> 02:56:10,800
sem saltar para este endereço aqui e

4476
02:56:10,800 --> 02:56:12,880
Isso pode ser útil e você precisa de um

4477
02:56:12,880 --> 02:56:14,960
compreensão deste modelo de memória para

4478
02:56:14,960 --> 02:56:17,279
realmente entender essas características que isso é

4479
02:56:17,279 --> 02:56:19,439
Um exemplo que estou lhe dando é

4480
02:56:19,439 --> 02:56:22,000
Vou reutilizar muito este modelo em sua

4481
02:56:22,000 --> 02:56:24,560
carreira como desenvolvedor de classe mais e i

4482
02:56:24,560 --> 02:56:26,479
Pensei que era uma ideia muito boa para

4483
02:56:26,479 --> 02:56:29,120
você para entender isso em primeira mão, isso é

4484
02:56:29,120 --> 02:56:30,640
Realmente tudo que eu tinha para compartilhar isso

4485
02:56:30,640 --> 02:56:33,040
Uma palestra espero que você tenha achado interessante

4486
02:56:33,040 --> 02:56:34,720
No próximo vamos tentar

4487
02:56:34,720 --> 02:56:36,720
Entenda a diferença entre três

4488
02:56:36,720 --> 02:56:38,960
componentes chave do c plus mais

4489
02:56:38,960 --> 02:56:41,040
A linguagem de programação segue em frente e termina

4490
02:56:41,040 --> 02:56:43,200
Aqui e me encontre lá nisso

4491
02:56:43,200 --> 02:56:45,120
palestra eu quero destacar o

4492
02:56:45,120 --> 02:56:47,680
diferenças entre o que chamamos de c

4493
02:56:47,680 --> 02:56:50,640
plus recurso de linguagem principal ou um

4494
02:56:50,640 --> 02:56:53,359
recurso de biblioteca padrão ou um stl

4495
02:56:53,359 --> 02:56:55,279
porque estes são termos que

4496
02:56:55,279 --> 02:56:57,920
Aprossem-se muito se você ler alguns

4497
02:56:57,920 --> 02:57:00,479
documentação sobre c plus mais um núcleo

4498
02:57:00,479 --> 02:57:03,920
A característica é realmente um bloco de construção básico

4499
02:57:03,920 --> 02:57:05,840
que compõe o c plus mais

4500
02:57:05,840 --> 02:57:08,240
Linguagem de programação que você pode pensar nisso

4501
02:57:08,240 --> 02:57:10,880
Por exemplo, como você define as variáveis

4502
02:57:10,880 --> 02:57:13,760
regras que regem como você pode definir e

4503
02:57:13,760 --> 02:57:16,160
usar uma função em c plus mais as regras

4504
02:57:16,160 --> 02:57:18,800
que dizem o que você pode fazer e não fazer com

4505
02:57:18,800 --> 02:57:21,359
as características básicas de c plus plus que é

4506
02:57:21,359 --> 02:57:24,240
O que pode ser qualificado como núcleo

4507
02:57:24,240 --> 02:57:26,800
característica do c plus programação

4508
02:57:26,800 --> 02:57:29,040
Linguagem não sei se isso faz algum

4509
02:57:29,040 --> 02:57:31,439
Sentir se voltarmos no estúdio visual

4510
02:57:31,439 --> 02:57:33,359
código que temos um programa em que usamos

4511
02:57:33,359 --> 02:57:35,920
As últimas palestras, por exemplo,

4512
02:57:35,920 --> 02:57:38,640
tipos básicos que você usa em c plus plus

4513
02:57:38,640 --> 02:57:41,359
as regras que definem como você pode definir

4514
02:57:41,359 --> 02:57:45,040
Uma função, por exemplo, se você colocar um

4515
02:57:45,040 --> 02:57:47,439
um suporte de ângulo aqui e tentar compilar

4516
02:57:47,439 --> 02:57:50,720
Este programa não vai funcionar

4517
02:57:50,720 --> 02:57:53,840
porque violamos as regras de

4518
02:57:53,840 --> 02:57:56,880
O c plus programas as regras básicas

4519
02:57:56,880 --> 02:57:59,120
definem como o c plus plus

4520
02:57:59,120 --> 02:58:01,439
A linguagem de programação funciona o básico

4521
02:58:01,439 --> 02:58:03,279
tipos que são definidos no c plus

4522
02:58:03,279 --> 02:58:05,279
além da linguagem de programação, estes pequenos

4523
02:58:05,279 --> 02:58:08,080
As coisas compõem os ingredientes crus que você

4524
02:58:08,080 --> 02:58:10,960
Use para fazer um c plus plus adequado

4525
02:58:10,960 --> 02:58:14,080
programas e estes pequenos componentes de linha

4526
02:58:14,080 --> 02:58:16,319
que você use para montar um c plus

4527
02:58:16,319 --> 02:58:18,960
O programa plus são chamados de recursos principais

4528
02:58:18,960 --> 02:58:19,920
Você pode

4529
02:58:19,920 --> 02:58:22,800
Pense neles como a base no topo

4530
02:58:22,800 --> 02:58:25,840
do qual nós realmente construímos o uso diário c

4531
02:58:25,840 --> 02:58:28,800
mais programas da biblioteca padrão

4532
02:58:28,800 --> 02:58:31,600
é um conjunto de pronto a usar

4533
02:58:31,600 --> 02:58:34,000
Componentes altamente especializados que nós

4534
02:58:34,000 --> 02:58:36,080
pode facilmente usar em nosso c plus plus

4535
02:58:36,080 --> 02:58:38,479
programas e novamente voltando para o nosso

4536
02:58:38,479 --> 02:58:41,760
programa em código de estúdio visual iostream

4537
02:58:41,760 --> 02:58:44,240
Aqui está um recurso de biblioteca padrão

4538
02:58:44,240 --> 02:58:46,880
string aqui é uma coisa de biblioteca padrão

4539
02:58:46,880 --> 02:58:49,040
temos na programação c plus plus

4540
02:58:49,040 --> 02:58:51,920
linguagem e novamente o c plus mais

4541
02:58:51,920 --> 02:58:54,960
biblioteca padrão tenta fornecer muito

4542
02:58:54,960 --> 02:58:57,680
componentes especializados que podemos usar

4543
02:58:57,680 --> 02:59:00,800
em programas regulares c plus plus quando você

4544
02:59:00,800 --> 02:59:02,800
usar a c plus mais linguagem de programação

4545
02:59:02,800 --> 02:59:05,520
Você realmente não quer estender o c

4546
02:59:05,520 --> 02:59:08,319
além de linguagem de programação que você deseja

4547
02:59:08,319 --> 02:59:10,720
para usá-lo para construir algo próprio

4548
02:59:10,720 --> 02:59:13,520
e uh os recursos da biblioteca padrão são

4549
02:59:13,520 --> 02:59:16,000
Coisas que você usa para trabalhar em seus programas

4550
02:59:16,000 --> 02:59:18,880
muito rápido, por exemplo, usamos sddc

4551
02:59:18,880 --> 02:59:20,800
fora sem realmente entrar no

4552
02:59:20,800 --> 02:59:23,120
detalhes de como os dados são retirados

4553
02:59:23,120 --> 02:59:25,040
Este programa para o terminal que é

4554
02:59:25,040 --> 02:59:27,680
Realmente avançado e provavelmente complicado

4555
02:59:27,680 --> 02:59:30,319
mas está embrulhado neste reutilizável

4556
02:59:30,319 --> 02:59:33,120
Componentes e um deles é o iostream

4557
02:59:33,120 --> 02:59:36,080
e nós podemos usá-lo com relativa facilidade em

4558
02:59:36,080 --> 02:59:38,800
nosso c plus plus programa OK eu espero agora

4559
02:59:38,800 --> 02:59:40,880
Você tem uma ideia melhor do que c

4560
02:59:40,880 --> 02:59:43,600
plus mais biblioteca padrão é agora o que

4561
02:59:43,600 --> 02:59:47,359
é o stl o stl é realmente parte do

4562
02:59:47,359 --> 02:59:50,319
c plus biblioteca padrão, mas é um

4563
02:59:50,319 --> 02:59:53,279
Coleção de tipos de contêineres pense

4564
02:59:53,279 --> 02:59:56,080
como coleções de coisas e nós

4565
02:59:56,080 --> 02:59:58,720
ter um conjunto de tipos que nos permitem

4566
02:59:58,720 --> 03:00:02,240
coleções de lojas que temos algoritmos ou

4567
03:00:02,240 --> 03:00:04,960
funções que trabalham nessas coleções

4568
03:00:04,960 --> 03:00:08,080
e nós temos tipos especializados que são

4569
03:00:08,080 --> 03:00:10,800
chamados iteradores que nos permitem

4570
03:00:10,800 --> 03:00:12,960
navegar por esses contêineres

4571
03:00:12,960 --> 03:00:16,080
potencialmente executando esses algoritmos em

4572
03:00:16,080 --> 03:00:18,640
Cada elemento da coleção é

4573
03:00:18,640 --> 03:00:21,040
provavelmente não fazendo sentido agora, mas você

4574
03:00:21,040 --> 03:00:24,160
pode pensar no stl como um

4575
03:00:24,160 --> 03:00:26,560
parte especializada do c plus plus

4576
03:00:26,560 --> 03:00:28,080
biblioteca padrão e nós vamos

4577
03:00:28,080 --> 03:00:30,000
Saiba mais sobre muitas características destes

4578
03:00:30,000 --> 03:00:32,240
coisas ao longo do curso, mas eu quero

4579
03:00:32,240 --> 03:00:35,120
você tem uma compreensão básica

4580
03:00:35,120 --> 03:00:37,680
Entre estes três termos, uma característica central

4581
03:00:37,680 --> 03:00:40,080
da c plus linguagem de programação

4582
03:00:40,080 --> 03:00:43,279
é o recurso padrão da biblioteca e o stl

4583
03:00:43,279 --> 03:00:46,399
E eu realmente espero que isso seja claro para você

4584
03:00:46,399 --> 03:00:48,560
Agora, neste capítulo, vamos

4585
03:00:48,560 --> 03:00:51,439
Saiba mais sobre variáveis e tipos de dados

4586
03:00:51,439 --> 03:00:53,520
antes de falar sobre variáveis e dados

4587
03:00:53,520 --> 03:00:55,520
tipos que eu gostaria de ter um momento e

4588
03:00:55,520 --> 03:00:58,080
recapitulação sobre o que sabemos até agora

4589
03:00:58,080 --> 03:01:00,240
e se você olhar para essas cartas, muitos

4590
03:01:00,240 --> 03:01:01,920
Essas coisas devem fazer sentido agora você

4591
03:01:01,920 --> 03:01:03,520
Conheça a função principal que você conhece

4592
03:01:03,520 --> 03:01:05,200
que é o ponto de entrada do seu

4593
03:01:05,200 --> 03:01:07,439
Você sabe que seu programa é

4594
03:01:07,439 --> 03:01:09,600
será composta de declarações e

4595
03:01:09,600 --> 03:01:12,000
declarações e com um ponto e-vírgula em c

4596
03:01:12,000 --> 03:01:13,040
plus plus

4597
03:01:13,040 --> 03:01:15,680
você sabe sobre avisos de erros de funções

4598
03:01:15,680 --> 03:01:18,160
Você agora tem uma ideia de como você pode

4599
03:01:18,160 --> 03:01:20,319
lidar com a entrada e a saída do seu

4600
03:01:20,319 --> 03:01:22,880
programa que você pode usar comentários que você conhece

4601
03:01:22,880 --> 03:01:25,359
sobre o modelo de memória e a execução

4602
03:01:25,359 --> 03:01:27,520
modelo de que falamos no último

4603
03:01:27,520 --> 03:01:29,520
palestra que você sabe muito agora que temos

4604
03:01:29,520 --> 03:01:31,760
estava usando um programa como este para fazer

4605
03:01:31,760 --> 03:01:34,080
coisas no último capítulo, mas há

4606
03:01:34,080 --> 03:01:36,479
Uma coisa que não é realmente explicada

4607
03:01:36,479 --> 03:01:39,439
ainda e isso é esta formista este fim é um

4608
03:01:39,439 --> 03:01:42,880
tipo que é predefinido em c plus mais

4609
03:01:42,880 --> 03:01:46,160
e c plus mais predefine muitos tipos

4610
03:01:46,160 --> 03:01:48,960
Aqui temos alguns desses tipos para

4611
03:01:48,960 --> 03:01:51,760
Veja como exemplos é um deles

4612
03:01:51,760 --> 03:01:53,920
Nós já vimos isso muitas vezes no

4613
03:01:53,920 --> 03:01:56,800
O último capítulo é usado para representar

4614
03:01:56,800 --> 03:01:59,520
números inteiros como um dois e três, mas

4615
03:01:59,520 --> 03:02:02,160
Temos outros, por exemplo, duplos e

4616
03:02:02,160 --> 03:02:05,200
float são usados para representar fracionários

4617
03:02:05,200 --> 03:02:08,160
Números de números que têm pontos decimais

4618
03:02:08,160 --> 03:02:12,319
por exemplo 2.5 7.3 e números semelhantes

4619
03:02:12,319 --> 03:02:13,840
Isso e nós vamos ver o

4620
03:02:13,840 --> 03:02:15,840
diferença entre esses dois outro

4621
03:02:15,840 --> 03:02:19,359
que é comumente usado é char ou carro e

4622
03:02:19,359 --> 03:02:22,000
é usado para representar caracteres em

4623
03:02:22,000 --> 03:02:25,279
memória e você pode armazenar em personagens

4624
03:02:25,279 --> 03:02:28,080
como um b c e d e todos os outros

4625
03:02:28,080 --> 03:02:30,000
Personagens que você pode realmente colocar em nós

4626
03:02:30,000 --> 03:02:32,560
um touro que é um tipo que vai

4627
03:02:32,560 --> 03:02:35,040
Armazenar dois possíveis estados o único

4628
03:02:35,040 --> 03:02:37,359
Os valores que você pode realmente armazenar aqui são

4629
03:02:37,359 --> 03:02:39,520
verdadeiro ou falso e vamos ver como

4630
03:02:39,520 --> 03:02:43,279
este trabalho vazio é uh um pouco confuso

4631
03:02:43,279 --> 03:02:46,240
porque representa um tipo de tipo

4632
03:02:46,240 --> 03:02:49,200
E é realmente significativo quando o que temos

4633
03:02:49,200 --> 03:02:51,760
para falar sobre funções em detalhes, então

4634
03:02:51,760 --> 03:02:53,920
Vamos aprender mais sobre o vazio

4635
03:02:53,920 --> 03:02:56,319
digite um pouco mais tarde no curso

4636
03:02:56,319 --> 03:02:59,120
também tem o tipo automático que é realmente

4637
03:02:59,120 --> 03:03:02,160
não é uma palavra-chave que você usa em c

4638
03:03:02,160 --> 03:03:04,720
mais plus para deduzir outros tipos e

4639
03:03:04,720 --> 03:03:06,960
Vamos ver como isso funciona mais tarde

4640
03:03:06,960 --> 03:03:09,200
No curso são alguns exemplos

4641
03:03:09,200 --> 03:03:12,160
dos tipos que podemos usar em c plus plus e

4642
03:03:12,160 --> 03:03:14,479
Vamos jogar com a maioria deles

4643
03:03:14,479 --> 03:03:16,399
Neste capítulo outra coisa eu realmente

4644
03:03:16,399 --> 03:03:19,120
Você quer que você veja é o que significa

4645
03:03:19,120 --> 03:03:21,840
realmente colocar um 4 em uma variável em seu

4646
03:03:21,840 --> 03:03:23,680
Programe tudo o que você tem neste

4647
03:03:23,680 --> 03:03:26,800
O programa aqui é representado por uns e

4648
03:03:26,800 --> 03:03:29,520
zeros na memória do computador realmente

4649
03:03:29,520 --> 03:03:31,760
Parece que é um monte de gente e

4650
03:03:31,760 --> 03:03:34,800
zeros no carneiro do seu computador e

4651
03:03:34,800 --> 03:03:36,560
Deve haver uma técnica para fazer sentido

4652
03:03:36,560 --> 03:03:39,359
deste gibberish aqui e armazenar dados

4653
03:03:39,359 --> 03:03:41,760
Isso faz sentido para os humanos e para o

4654
03:03:41,760 --> 03:03:44,560
O ponto de partida é agrupar esses

4655
03:03:44,560 --> 03:03:47,439
e zeros em pequenos pedaços que nós podemos

4656
03:03:47,439 --> 03:03:49,760
manipular cada um desses e zeros

4657
03:03:49,760 --> 03:03:52,640
é chamado de aposta, então este zero aqui é um

4658
03:03:52,640 --> 03:03:55,040
bit este aqui é uma aposta e se nós

4659
03:03:55,040 --> 03:03:57,040
grupo oito batidas juntos eles são

4660
03:03:57,040 --> 03:03:59,840
Vou formar o que chamamos de byte OK

4661
03:03:59,840 --> 03:04:01,920
Se faz sentido você pode agrupar seu

4662
03:04:01,920 --> 03:04:04,960
bits em bytes ou se faz sentido para

4663
03:04:04,960 --> 03:04:07,439
agrupá-los em grupos de 16 que você pode fazer

4664
03:04:07,439 --> 03:04:09,200
Como vemos aqui, vamos ver

4665
03:04:09,200 --> 03:04:11,200
um pouco mais de detalhes sobre isso no

4666
03:04:11,200 --> 03:04:13,359
A próxima palestra, aqui você vê que se

4667
03:04:13,359 --> 03:04:16,160
Você realmente quer que você possa tratar cada bit

4668
03:04:16,160 --> 03:04:19,520
como um pedaço de dados auto-contido, mas

4669
03:04:19,520 --> 03:04:21,840
Isso realmente não é muito útil, mas lá

4670
03:04:21,840 --> 03:04:24,640
são alguns casos de uso de canto para isso ok

4671
03:04:24,640 --> 03:04:26,800
Agora nós realmente temos dois lados no

4672
03:04:26,800 --> 03:04:29,520
corretamente temos dados no formato que

4673
03:04:29,520 --> 03:04:32,319
realmente conveniente e compreensível por

4674
03:04:32,319 --> 03:04:35,120
humanos e à esquerda temos como dados

4675
03:04:35,120 --> 03:04:37,680
é representado na memória, então deve

4676
03:04:37,680 --> 03:04:40,319
ser uma forma de transformar entre estes dois

4677
03:04:40,319 --> 03:04:42,720
formas de dados porque os humanos não podem

4678
03:04:42,720 --> 03:04:44,960
realmente lidar com estes e zeros bem

4679
03:04:44,960 --> 03:04:47,120
e nós fazemos a transformação entre

4680
03:04:47,120 --> 03:04:50,399
estas duas representações de dados utilizando

4681
03:04:50,399 --> 03:04:52,640
sistemas de números temos um número

4682
03:04:52,640 --> 03:04:55,200
sistemas disponíveis para nós que podemos usar

4683
03:04:55,200 --> 03:04:58,080
O hexadecimal binário é um pouco

4684
03:04:58,080 --> 03:05:00,240
Exemplos e vamos aprender sobre

4685
03:05:00,240 --> 03:05:02,720
eles começando na próxima palestra, então vá

4686
03:05:02,720 --> 03:05:04,720
Na frente e terminar aqui e me encontrar

4687
03:05:04,720 --> 03:05:06,640
lá nesta palestra vamos

4688
03:05:06,640 --> 03:05:09,600
Aprenda um pouco mais sobre sistemas numéricos

4689
03:05:09,600 --> 03:05:11,840
Os sistemas numéricos nos permitem transformar

4690
03:05:11,840 --> 03:05:14,080
dados do formulário que é realmente

4691
03:05:14,080 --> 03:05:16,720
conveniente para os seres humanos em uma forma que é

4692
03:05:16,720 --> 03:05:19,200
conveniente para computadores nestes

4693
03:05:19,200 --> 03:05:21,359
e zeros que você vê à esquerda nós

4694
03:05:21,359 --> 03:05:23,680
também pode usá-los para fazer o inverso ir

4695
03:05:23,680 --> 03:05:26,160
de uns e zeros e ir no formato

4696
03:05:26,160 --> 03:05:28,560
que é conveniente para os seres humanos assim

4697
03:05:28,560 --> 03:05:31,600
22 ou este nome de estémoro aqui para fazer sentido

4698
03:05:31,600 --> 03:05:33,920
de como esses sistemas numéricos funcionam, vamos

4699
03:05:33,920 --> 03:05:36,560
Analisar o sistema decimal que nós

4700
03:05:36,560 --> 03:05:38,880
realmente usar na vida diária e isso é

4701
03:05:38,880 --> 03:05:41,279
geralmente chamado de base 10. então se você olhar

4702
03:05:41,279 --> 03:05:43,080
De acordo com isso

4703
03:05:43,080 --> 03:05:46,479
2371 número aqui nós podemos realmente dividi-lo

4704
03:05:46,479 --> 03:05:48,720
Na forma que você vê à direita

4705
03:05:48,720 --> 03:05:51,200
Aqui se você tentar tomar esta expressão

4706
03:05:51,200 --> 03:05:53,600
Temos aqui direito e avaliamos

4707
03:05:53,600 --> 03:05:55,359
Você vai ter esse número aqui

4708
03:05:55,359 --> 03:05:58,080
2 vezes 10 ao poder de 3 isso

4709
03:05:58,080 --> 03:06:01,200
avalia para 2000 e este aqui é

4710
03:06:01,200 --> 03:06:03,760
vai avaliar até 300 este é

4711
03:06:03,760 --> 03:06:06,560
vai avaliar até 70 e o último

4712
03:06:06,560 --> 03:06:08,960
vai avaliar para um e se você

4713
03:06:08,960 --> 03:06:11,200
Adicione essas coisas que você vai acabar

4714
03:06:11,200 --> 03:06:12,960
Para cima com este número, então é assim que nós

4715
03:06:12,960 --> 03:06:16,160
pode pegar um número e uh fazer uma base

4716
03:06:16,160 --> 03:06:18,319
10 representação dela nós podemos fazer o

4717
03:06:18,319 --> 03:06:22,319
A mesma coisa para 924 aqui ou 47 aqui

4718
03:06:22,319 --> 03:06:25,120
realmente é matemática básica que você não precisa

4719
03:06:25,120 --> 03:06:27,520
ter um monte de fundo em matemática para fazer

4720
03:06:27,520 --> 03:06:30,080
senso disso, então vamos usar isso

4721
03:06:30,080 --> 03:06:33,359
forma exata e entender números binários

4722
03:06:33,359 --> 03:06:35,120
Se você olhar para o que temos aqui, temos

4723
03:06:35,120 --> 03:06:37,760
alguns números binários que são feitos de

4724
03:06:37,760 --> 03:06:40,240
uns e zeros é por isso que é chamado

4725
03:06:40,240 --> 03:06:42,479
binário porque você só pode ter dois

4726
03:06:42,479 --> 03:06:46,080
estados ou zero ou um em seus números, então

4727
03:06:46,080 --> 03:06:48,960
Podemos realmente fazer a mesma coisa que somos

4728
03:06:48,960 --> 03:06:51,760
na base dois, então em vez de usar um dez

4729
03:06:51,760 --> 03:06:53,920
Aqui vamos usar um dois, mas

4730
03:06:53,920 --> 03:06:55,920
São as mesmas operações que realmente fizemos

4731
03:06:55,920 --> 03:06:58,640
se você pegar isso e multiplicar e adicionar

4732
03:06:58,640 --> 03:07:00,479
essas coisas para o que você vai acabar

4733
03:07:00,479 --> 03:07:03,920
up é uma representação base 10 deste

4734
03:07:03,920 --> 03:07:05,840
número se formos no meio aqui,

4735
03:07:05,840 --> 03:07:08,240
Tenho algo que podemos facilmente fazer sem

4736
03:07:08,240 --> 03:07:10,800
usando uma calculadora, a expressão no

4737
03:07:10,800 --> 03:07:13,359
Deixado aqui vai avaliar para

4738
03:07:13,359 --> 03:07:15,359
zero porque estamos multiplicando com

4739
03:07:15,359 --> 03:07:18,000
zero o segundo vai ser um dois

4740
03:07:18,000 --> 03:07:20,160
porque estamos tomando um e

4741
03:07:20,160 --> 03:07:22,479
multiplicando isso por dois os outros

4742
03:07:22,479 --> 03:07:24,479
serão zeros, mas o último é

4743
03:07:24,479 --> 03:07:27,920
vai ser 2 para o poder de 4 que é

4744
03:07:27,920 --> 03:07:30,640
16 e vamos adicionar um 2 e este

4745
03:07:30,640 --> 03:07:33,760
vai avaliar para 18.

4746
03:07:33,760 --> 03:07:36,160
realmente trazer a nossa calculadora em

4747
03:07:36,160 --> 03:07:38,800
Windows 10 Eu acho que pode ajudar nisso a

4748
03:07:38,800 --> 03:07:40,720
Um pouco nós vamos trazê-lo

4749
03:07:40,720 --> 03:07:44,160
e queremos colocá-lo em um programador

4750
03:07:44,160 --> 03:07:46,479
Modo e vamos voltar para o nosso

4751
03:07:46,479 --> 03:07:48,880
deslizar e encontrar o nosso número que é um

4752
03:07:48,880 --> 03:07:51,200
zero zero um zero, então nós vamos

4753
03:07:51,200 --> 03:07:55,120
digite-o um zero zero um zero um zero em

4754
03:07:55,120 --> 03:07:58,080
binário este é binário que nós tipamos

4755
03:07:58,080 --> 03:08:01,760
Então vamos limpar isso e fazer um zero

4756
03:08:01,760 --> 03:08:04,399
zero um zero e você vai ver

4757
03:08:04,399 --> 03:08:06,960
que no decimal é 18 que é

4758
03:08:06,960 --> 03:08:10,000
o que nós viemos calculando isso em nosso

4759
03:08:10,000 --> 03:08:12,240
cérebro vamos tentar o que tivemos antes

4760
03:08:12,240 --> 03:08:14,479
que não poderíamos realmente fazer em nosso cérebro

4761
03:08:14,479 --> 03:08:16,399
nós vamos dizer um zero zero um

4762
03:08:16,399 --> 03:08:18,800
zero um vamos fazer isso, vamos

4763
03:08:18,800 --> 03:08:22,640
claro um zero zero zero um zero, este é

4764
03:08:22,640 --> 03:08:26,160
vai avaliar até 37 em decimal e

4765
03:08:26,160 --> 03:08:28,319
você pode usar calculadoras como esta para

4766
03:08:28,319 --> 03:08:30,479
Realmente fazer as transformações entre

4767
03:08:30,479 --> 03:08:33,200
Estas diferentes representações numéricas

4768
03:08:33,200 --> 03:08:35,439
Ok abaixo, temos um um um

4769
03:08:35,439 --> 03:08:38,240
que vai avaliar para um sete em

4770
03:08:38,240 --> 03:08:40,880
base dez bem se nós temos três dígitos nós

4771
03:08:40,880 --> 03:08:43,120
pode realmente representar números entre

4772
03:08:43,120 --> 03:08:45,760
zero e sete e você vê uma mesa aqui

4773
03:08:45,760 --> 03:08:48,000
que vai provar que zero zero

4774
03:08:48,000 --> 03:08:50,000
zero vai avaliar para zero em

4775
03:08:50,000 --> 03:08:52,399
decimal zero zero um vai ser um

4776
03:08:52,399 --> 03:08:55,279
Um e se você descer para um um

4777
03:08:55,279 --> 03:08:57,920
que vai avaliar para um sete você

4778
03:08:57,920 --> 03:09:00,240
pode tentar usar uma calculadora para provar

4779
03:09:00,240 --> 03:09:02,479
Isso e realmente entender como isso

4780
03:09:02,479 --> 03:09:05,080
funciona se usarmos os três dígitos

4781
03:09:05,080 --> 03:09:07,439
representação dos nossos números vão

4782
03:09:07,439 --> 03:09:09,279
Olha algo assim na memória nós somos

4783
03:09:09,279 --> 03:09:11,520
Vou levar os bits na memória e

4784
03:09:11,520 --> 03:09:14,399
agrupá-los em grupos de três e nós somos

4785
03:09:14,399 --> 03:09:16,240
usar o binário para realmente fazer

4786
03:09:16,240 --> 03:09:18,319
sentido desses números, por exemplo, aqui

4787
03:09:18,319 --> 03:09:20,560
Na esquerda isto vai ser um

4788
03:09:20,560 --> 03:09:22,479
O segundo da esquerda vai

4789
03:09:22,479 --> 03:09:25,120
ser um seis e isso vai ser um seis

4790
03:09:25,120 --> 03:09:27,840
E isso vai ser um zero isso

4791
03:09:27,840 --> 03:09:30,640
Vai ser um três porque nós temos

4792
03:09:30,640 --> 03:09:33,359
Um e dois aqui nós somamos aqueles que temos

4793
03:09:33,359 --> 03:09:35,200
um três se isso não faz sentido você

4794
03:09:35,200 --> 03:09:37,200
pode tentar usar uma calculadora que você é

4795
03:09:37,200 --> 03:09:39,680
Vou ver que faz sentido bem, então

4796
03:09:39,680 --> 03:09:42,800
E se quisermos agrupar nossos dígitos em

4797
03:09:42,800 --> 03:09:45,200
grupos de quatro podemos fazer isso e nós somos

4798
03:09:45,200 --> 03:09:47,120
Vou acabar com algo assim

4799
03:09:47,120 --> 03:09:49,600
Os valores que podemos representar vão

4800
03:09:49,600 --> 03:09:52,720
ir de 0 todo o caminho para 15 e você pode

4801
03:09:52,720 --> 03:09:55,760
Tente provar isso usando a calculadora

4802
03:09:55,760 --> 03:09:58,319
Como nós apenas fizemos e vai olhar

4803
03:09:58,319 --> 03:10:00,319
Assim na memória, então o que realmente

4804
03:10:00,319 --> 03:10:03,359
estão fazendo é agrupar os bits em

4805
03:10:03,359 --> 03:10:06,640
diferentes tamanhos de dados e temos um

4806
03:10:06,640 --> 03:10:09,120
tipo de fórmula que podemos usar para fazer

4807
03:10:09,120 --> 03:10:11,760
Sensação dos dados na memória, por exemplo

4808
03:10:11,760 --> 03:10:14,239
à esquerda aqui temos zero um

4809
03:10:14,239 --> 03:10:16,479
zero se voltarmos à nossa mesa e

4810
03:10:16,479 --> 03:10:20,000
definido zero um zero, este é um seis

4811
03:10:20,000 --> 03:10:21,840
E nós vamos saber que esses quatro

4812
03:10:21,840 --> 03:10:24,800
bits aqui estão realmente armazenando o s6 e

4813
03:10:24,800 --> 03:10:27,120
Existem maneiras que você pode manipular isso

4814
03:10:27,120 --> 03:10:29,359
em seu programa c plus plus que estamos indo

4815
03:10:29,359 --> 03:10:31,920
para ver que você também pode usar cinco dígitos

4816
03:10:31,920 --> 03:10:33,359
E você vai acabar com

4817
03:10:33,359 --> 03:10:35,439
Algo assim e os números são

4818
03:10:35,439 --> 03:10:38,720
indo para ir de 0 todo o caminho para 32 e

4819
03:10:38,720 --> 03:10:40,880
É assim que vai parecer na memória

4820
03:10:40,880 --> 03:10:43,760
você pode tentar e vir com o que isso

4821
03:10:43,760 --> 03:10:46,000
representa em decimal eu não vou

4822
03:10:46,000 --> 03:10:48,319
Diga-lhe isso, mas nós podemos tentar e figurar

4823
03:10:48,319 --> 03:10:51,200
fora o da esquerda aqui para que seja 0

4824
03:10:51,200 --> 03:10:54,800
1 1 0 1. se voltarmos, vamos

4825
03:10:54,800 --> 03:10:59,439
vem até 0 1 1 0 1 que é um 13 aqui

4826
03:10:59,439 --> 03:11:02,800
Então esta localização de memória estes cinco bits

4827
03:11:02,800 --> 03:11:06,080
representar um número 17, então se quisermos

4828
03:11:06,080 --> 03:11:08,880
Um tipo de generalizar o que falamos

4829
03:11:08,880 --> 03:11:11,760
nos últimos slides, se você tiver um

4830
03:11:11,760 --> 03:11:14,000
Dígito você pode realmente representar dois

4831
03:11:14,000 --> 03:11:16,399
estados zero e um se você tiver três

4832
03:11:16,399 --> 03:11:18,479
dígitos que você pode representar números entre

4833
03:11:18,479 --> 03:11:20,640
zero e sete e você pode ir todo o

4834
03:11:20,640 --> 03:11:24,080
descendo e se generalizarmos isso em um

4835
03:11:24,080 --> 03:11:27,040
Fórmula matemática podemos dizer que se

4836
03:11:27,040 --> 03:11:29,120
nós temos n dígitos nós vamos ser capazes

4837
03:11:29,120 --> 03:11:31,760
representar entre 0 e 2 para o

4838
03:11:31,760 --> 03:11:34,720
poder de n menos 1. e se você tentar

4839
03:11:34,720 --> 03:11:36,880
conectar qualquer número de dígitos que você é

4840
03:11:36,880 --> 03:11:39,200
Vou ver que esta fórmula funciona

4841
03:11:39,200 --> 03:11:43,279
Tudo bem, então estes são alguns agrupamentos de bits

4842
03:11:43,279 --> 03:11:45,680
Temos na prática que podemos usar oito

4843
03:11:45,680 --> 03:11:47,840
dígitos e podemos representar números

4844
03:11:47,840 --> 03:11:51,359
entre zero e dois 255 se tivermos 16

4845
03:11:51,359 --> 03:11:54,160
bits nós podemos representar este intervalo se nós

4846
03:11:54,160 --> 03:11:56,000
Temos 32 bits nós podemos

4847
03:11:56,000 --> 03:11:59,520
representar este intervalo se tivermos 64 apostas

4848
03:11:59,520 --> 03:12:02,319
Podemos realmente representar um realmente enorme

4849
03:12:02,319 --> 03:12:04,800
range Eu não posso nem dizer este número que é

4850
03:12:04,800 --> 03:12:06,720
Realmente ruim ok agora você deve ter um

4851
03:12:06,720 --> 03:12:09,600
Boa ideia do sistema binário

4852
03:12:09,600 --> 03:12:12,720
e diferentes representações que podemos usar

4853
03:12:12,720 --> 03:12:16,080
para dar sentido a números binários em um

4854
03:12:16,080 --> 03:12:18,160
A memória do computador é a última coisa que eu quero

4855
03:12:18,160 --> 03:12:21,439
Você para ver é o que chamamos de hexadecimal

4856
03:12:21,439 --> 03:12:24,399
sistema numérico e é uma técnica

4857
03:12:24,399 --> 03:12:27,439
Use para encurtar o comprimento de como nós

4858
03:12:27,439 --> 03:12:30,239
Representar um número binário na memória como

4859
03:12:30,239 --> 03:12:32,960
que funciona bem, pegamos nosso número e

4860
03:12:32,960 --> 03:12:36,399
Dividi-lo em grupos de quatro apostas e cada um

4861
03:12:36,399 --> 03:12:38,880
grupo é atribuído um símbolo que podemos usar para

4862
03:12:38,880 --> 03:12:41,200
representá-lo se tivermos quatro zeros

4863
03:12:41,200 --> 03:12:43,120
que vai significar um zero em

4864
03:12:43,120 --> 03:12:46,000
hexadecimal se tivermos zero zero zero

4865
03:12:46,000 --> 03:12:48,560
Um que vamos representar um e

4866
03:12:48,560 --> 03:12:51,279
você pode ver que se vamos até nove

4867
03:12:51,279 --> 03:12:53,920
Isso é realmente semelhante ao que temos

4868
03:12:53,920 --> 03:12:56,160
no sistema de números decimais, mas uma vez

4869
03:12:56,160 --> 03:12:58,160
hit 10 nós vamos representar isso

4870
03:12:58,160 --> 03:13:00,960
com um a in hexadecimal 11 vai

4871
03:13:00,960 --> 03:13:04,000
ser b 12 vai ser c 13 vai

4872
03:13:04,000 --> 03:13:07,040
ser d 14 vai ser e 15 está indo

4873
03:13:07,040 --> 03:13:09,040
para ser, então como usar isso para

4874
03:13:09,040 --> 03:13:11,680
Representar números binários, vamos ver um

4875
03:13:11,680 --> 03:13:14,080
O exemplo aqui temos um número enorme que

4876
03:13:14,080 --> 03:13:16,160
Nós representamos na memória que começa com

4877
03:13:16,160 --> 03:13:18,560
zero e termina com o aqui, então o

4878
03:13:18,560 --> 03:13:20,160
A primeira coisa que vamos fazer é

4879
03:13:20,160 --> 03:13:23,279
Dividiu isso em grupos de quatro e um

4880
03:13:23,279 --> 03:13:25,760
Na esquerda vai ser um um um

4881
03:13:25,760 --> 03:13:28,000
Um se voltarmos para a nossa mesa aqui

4882
03:13:28,000 --> 03:13:30,479
um um um significa f, então nós vamos

4883
03:13:30,479 --> 03:13:32,880
para representar isso com um f se você for para

4884
03:13:32,880 --> 03:13:35,840
O segundo grupo de quatro apostas que temos

4885
03:13:35,840 --> 03:13:39,040
zero zero um um se voltarmos zero

4886
03:13:39,040 --> 03:13:42,000
zero um significa três, então vamos

4887
03:13:42,000 --> 03:13:44,319
para ter um três aqui eu espero que isso faça

4888
03:13:44,319 --> 03:13:46,319
Sentir e vamos continuar usando o

4889
03:13:46,319 --> 03:13:48,399
As mesmas transformações e nós vamos

4890
03:13:48,399 --> 03:13:52,319
Venha com um f 0 3 e 6 e nós podemos

4891
03:13:52,319 --> 03:13:55,520
representar este número binário usando estes

4892
03:13:55,520 --> 03:13:57,520
símbolos que você pode ver que vamos de

4893
03:13:57,520 --> 03:14:01,359
Usando 32 bits para usar um dois três

4894
03:14:01,359 --> 03:14:03,920
quatro cinco seis sete oito símbolos para

4895
03:14:03,920 --> 03:14:06,239
representar isso e isso é mais curto e

4896
03:14:06,239 --> 03:14:09,200
facilmente manipulável pelos humanos e nós usamos

4897
03:14:09,200 --> 03:14:13,040
um zero x na frente para significar que este é um

4898
03:14:13,040 --> 03:14:15,120
hexadecimal número eu realmente espero que isso

4899
03:14:15,120 --> 03:14:18,160
Faz sentido se temos números que

4900
03:14:18,160 --> 03:14:20,880
não se encaixam em grupos de quatro que somos

4901
03:14:20,880 --> 03:14:23,200
ir pela esquerda e dividir isso

4902
03:14:23,200 --> 03:14:25,439
em grupos de quatro e vamos acabar

4903
03:14:25,439 --> 03:14:28,640
acima com um grupo à esquerda que não

4904
03:14:28,640 --> 03:14:30,960
Realmente atender nossas necessidades e o que nós

4905
03:14:30,960 --> 03:14:34,160
pode fazer é adicionar os bits faltando e fazer

4906
03:14:34,160 --> 03:14:36,479
Eles zeros e chamamos esta operação

4907
03:14:36,479 --> 03:14:38,640
O preenchimento é isso que você pode fazer

4908
03:14:38,640 --> 03:14:40,560
realmente representar qualquer número em

4909
03:14:40,560 --> 03:14:42,960
hexadecimal se você não tiver o suficiente

4910
03:14:42,960 --> 03:14:45,279
bits à esquerda também temos outro

4911
03:14:45,279 --> 03:14:47,840
sistema que não é amplamente utilizado

4912
03:14:47,840 --> 03:14:51,040
Hoje, mas estou mencionando isso aqui para

4913
03:14:51,040 --> 03:14:53,680
Exaustividade é chamada de sistema octal

4914
03:14:53,680 --> 03:14:56,000
Vai do zero todo o caminho para sete

4915
03:14:56,000 --> 03:14:59,439
e nós podemos dividir o nosso número binário em

4916
03:14:59,439 --> 03:15:02,399
grupos de três e representam o uso

4917
03:15:02,399 --> 03:15:04,640
estes zeros e aqueles para encurtar a

4918
03:15:04,640 --> 03:15:06,319
comprimento do número binário que podemos

4919
03:15:06,319 --> 03:15:07,920
Realmente fazer a mesma coisa que fizemos com

4920
03:15:07,920 --> 03:15:10,319
hexadecimal, então vamos levar o nosso

4921
03:15:10,319 --> 03:15:13,200
número binário e dividir isso em grupos

4922
03:15:13,200 --> 03:15:15,439
De três o da esquerda vai

4923
03:15:15,439 --> 03:15:19,120
avaliar para um 7 porque é 1 1 1 e

4924
03:15:19,120 --> 03:15:22,080
um um avalia para sete em octal

4925
03:15:22,080 --> 03:15:23,920
sistema o segundo também vai

4926
03:15:23,920 --> 03:15:26,239
ser um um um, o terceiro está indo

4927
03:15:26,239 --> 03:15:29,279
para ser um zero zero se formos em nosso

4928
03:15:29,279 --> 03:15:31,680
tabela será um zero zero

4929
03:15:31,680 --> 03:15:33,439
Vai ser um quatro e você vê que nós

4930
03:15:33,439 --> 03:15:35,680
Tenho um 4 aqui e você pode fazer o mesmo

4931
03:15:35,680 --> 03:15:37,840
coisas até que você tenha descoberto o

4932
03:15:37,840 --> 03:15:39,760
Número inteiro aqui e você vê no

4933
03:15:39,760 --> 03:15:42,239
à esquerda, estamos fazendo estofamento e adicionando um

4934
03:15:42,239 --> 03:15:44,880
faltando bit e fazendo isso para 0 por isso estamos

4935
03:15:44,880 --> 03:15:48,080
chegando com 0 0 1 e se voltarmos

4936
03:15:48,080 --> 03:15:51,520
para a nossa mesa aqui 0 0 1 é um 1 e

4937
03:15:51,520 --> 03:15:53,120
Isso é o que colocamos aqui, então estamos indo

4938
03:15:53,120 --> 03:15:55,120
para colocar este número aqui vai ser

4939
03:15:55,120 --> 03:15:59,680
15 61 41 70 47 7 e vamos adicionar

4940
03:15:59,680 --> 03:16:03,040
um zero na frente para significar que este é um

4941
03:16:03,040 --> 03:16:05,760
número representado no sistema octal i

4942
03:16:05,760 --> 03:16:07,920
realmente espero que isso faça sentido ok, então nós

4943
03:16:07,920 --> 03:16:10,560
viram todos esses números binários e

4944
03:16:10,560 --> 03:16:12,800
diferentes sistemas de números que podemos usar para

4945
03:16:12,800 --> 03:16:15,840
representá-los, mas como usá-los em

4946
03:16:15,840 --> 03:16:18,479
um c plus plus programa bem Eu estou feliz que você

4947
03:16:18,479 --> 03:16:20,560
Perguntamos aqui é um simples exemplo de como

4948
03:16:20,560 --> 03:16:23,520
você pode representar o número 15 a

4949
03:16:23,520 --> 03:16:26,560
diferentes sistemas de números em c plus mais

4950
03:16:26,560 --> 03:16:28,640
Se você disser 15 assim, está indo

4951
03:16:28,640 --> 03:16:31,600
estar em decimal se você adicionar um zero em

4952
03:16:31,600 --> 03:16:34,399
frente vai significar que o número

4953
03:16:34,399 --> 03:16:37,040
está no sistema octal, então isso pode ser

4954
03:16:37,040 --> 03:16:40,160
confuso às vezes se você fizer 0 17 é

4955
03:16:40,160 --> 03:16:43,439
não serão 17. então se você disser 0 17 c

4956
03:16:43,439 --> 03:16:45,520
O plus plus vai interpretar isso

4957
03:16:45,520 --> 03:16:48,239
número como se estivesse em sistema octal e

4958
03:16:48,239 --> 03:16:50,800
vai transformar isso em 15.

4959
03:16:50,800 --> 03:16:53,520
Aqui você vê a mesma representação em

4960
03:16:53,520 --> 03:16:56,319
hexadecimal vimos que você usa um 0x em

4961
03:16:56,319 --> 03:16:58,319
frente para representar que está em

4962
03:16:58,319 --> 03:17:01,439
Hexadecimal e isso vai ser 15

4963
03:17:01,439 --> 03:17:03,040
na memória e aqui temos

4964
03:17:03,040 --> 03:17:06,319
representação em binário usando zeros e

4965
03:17:06,319 --> 03:17:09,040
e você usa zero b na frente como

4966
03:17:09,040 --> 03:17:11,040
Eu tenho que dizer que isso foi apenas

4967
03:17:11,040 --> 03:17:14,239
Possível desde c mais mais 14. então se você

4968
03:17:14,239 --> 03:17:17,120
estão usando um padrão mais antigo de c plus

4969
03:17:17,120 --> 03:17:18,880
Além de você querer ser capaz de representar

4970
03:17:18,880 --> 03:17:21,040
Binário como este e se nós executarmos isso

4971
03:17:21,040 --> 03:17:22,960
Programa que vai imprimir o mesmo

4972
03:17:22,960 --> 03:17:25,279
O que vai imprimir 15, mas nós

4973
03:17:25,279 --> 03:17:27,680
armazenados o número usando um número diferente

4974
03:17:27,680 --> 03:17:30,000
sistemas, vamos ao código do estúdio visual

4975
03:17:30,000 --> 03:17:32,880
e tente isso bem aqui estamos em um

4976
03:17:32,880 --> 03:17:35,200
pasta que eu tenho no meu sistema onde eu estou

4977
03:17:35,200 --> 03:17:37,359
Vou armazenar meus projetos para isso

4978
03:17:37,359 --> 03:17:39,520
capítulo A primeira coisa que vou fazer

4979
03:17:39,520 --> 03:17:42,800
é código de cópia de um projeto de modelo i

4980
03:17:42,800 --> 03:17:45,359
Vou entrar e copiar as coisas

4981
03:17:45,359 --> 03:17:48,640
e eu vou colocar estes em 4 2

4982
03:17:48,640 --> 03:17:51,040
sistemas de números eu vou abrir isso

4983
03:17:51,040 --> 03:17:53,279
pasta em código de estúdio visual assim que eu sou

4984
03:17:53,279 --> 03:17:55,920
indo para ir para arquivo fechar a pasta que nós

4985
03:17:55,920 --> 03:17:58,239
Eu tenho agora e eu vou abrir um novo

4986
03:17:58,239 --> 03:18:01,040
uma pasta aberta e vou navegar

4987
03:18:01,040 --> 03:18:03,680
para a localização do meu projeto eu vou

4988
03:18:03,680 --> 03:18:05,920
para abrir este projeto aqui que diz

4989
03:18:05,920 --> 03:18:08,319
sistemas de números que vamos nos livrar

4990
03:18:08,319 --> 03:18:11,040
da tela de boas-vindas e abra nosso principal

4991
03:18:11,040 --> 03:18:13,359
arquivo cpp vamos nos livrar disso

4992
03:18:13,359 --> 03:18:16,239
coisa constival e limpar tudo o que nós

4993
03:18:16,239 --> 03:18:19,279
ter na função principal aqui o primeiro

4994
03:18:19,279 --> 03:18:21,439
O que queremos fazer é armazenar um

4995
03:18:21,439 --> 03:18:23,680
inteiro que é 15 e nós vamos

4996
03:18:23,680 --> 03:18:26,479
Diga e número um exatamente a mesma coisa

4997
03:18:26,479 --> 03:18:28,239
nós tínhamos nos slides e nós vamos

4998
03:18:28,239 --> 03:18:31,040
armazenar 15 nesta variável aqui este é

4999
03:18:31,040 --> 03:18:33,680
será representado em decimal e

5000
03:18:33,680 --> 03:18:36,319
se quisermos armazenar o seminúmero em

5001
03:18:36,319 --> 03:18:39,840
octo nós vimos que em nossos slides poderíamos

5002
03:18:39,840 --> 03:18:42,960
armazená-lo como 0 17. então vamos fazer isso

5003
03:18:42,960 --> 03:18:45,520
nós vamos dizer isso número 2 e nós somos

5004
03:18:45,520 --> 03:18:48,960
indo para a loja em 0 17. isso não é

5005
03:18:48,960 --> 03:18:51,279
E serão 17, isso vai ser um

5006
03:18:51,279 --> 03:18:54,239
Representação de um número em octo

5007
03:18:54,239 --> 03:18:56,239
sistema, então vamos dizer que isso

5008
03:18:56,239 --> 03:18:58,880
é octo e podemos representar o número

5009
03:18:58,880 --> 03:19:01,600
em hexadecimal também, então vamos

5010
03:19:01,600 --> 03:19:04,399
Diga-o número três e vai

5011
03:19:04,399 --> 03:19:05,120
ser

5012
03:19:05,120 --> 03:19:08,160
0x porque é hexadecimal e nós somos

5013
03:19:08,160 --> 03:19:10,640
Vamos dizer zero f é assim que nós

5014
03:19:10,640 --> 03:19:12,880
representá-lo você pode usar minúsculo ou

5015
03:19:12,880 --> 03:19:15,040
Mais alto não vai realmente importar, vamos

5016
03:19:15,040 --> 03:19:17,520
usar uppercase aqui e podemos usar binário

5017
03:19:17,520 --> 03:19:19,760
porque estamos usando c plus mais 20.

5018
03:19:19,760 --> 03:19:22,000
nós vamos dizer e número quatro e

5019
03:19:22,000 --> 03:19:24,399
Nós vamos armazenar em uma representação

5020
03:19:24,399 --> 03:19:28,160
de 15 em binário e acontece que

5021
03:19:28,160 --> 03:19:31,840
quatro zeros e quatro e temos que

5022
03:19:31,840 --> 03:19:35,279
prefixo isso com um zero b é assim

5023
03:19:35,279 --> 03:19:37,840
Funciona para que isso seja em binário

5024
03:19:37,840 --> 03:19:40,239
e se imprimirmos todos esses números

5025
03:19:40,239 --> 03:19:42,640
nós vamos ver deixe-me não te dizer

5026
03:19:42,640 --> 03:19:44,800
O que você acha que veremos bem, então

5027
03:19:44,800 --> 03:19:47,920
Eu fui em frente e digitei isso o que fazer

5028
03:19:47,920 --> 03:19:50,399
você acha que vamos ver quando construirmos e

5029
03:19:50,399 --> 03:19:52,399
executar este programa antes de fazermos isso nós

5030
03:19:52,399 --> 03:19:54,640
abrir um terminal para que possamos ver

5031
03:19:54,640 --> 03:19:56,399
Aqui e nós vamos para

5032
03:19:56,399 --> 03:19:58,640
tarefa de corrida terminal que vamos construir

5033
03:19:58,640 --> 03:20:01,439
com gcc vamos esperar e ver se o mundo

5034
03:20:01,439 --> 03:20:03,600
É um mundo bem sucedido acabado

5035
03:20:03,600 --> 03:20:05,840
Temos um programa de galo

5036
03:20:05,840 --> 03:20:07,520
Aqui nós vamos

5037
03:20:07,520 --> 03:20:10,239
clique em algum lugar neste terminal e nosso

5038
03:20:10,239 --> 03:20:12,080
O terminal vai aparecer se o fizermos

5039
03:20:12,080 --> 03:20:14,080
dur você vai ver que o nosso galo

5040
03:20:14,080 --> 03:20:16,560
O programa está aqui e se executá-lo eu quero

5041
03:20:16,560 --> 03:20:18,319
para tirar um momento e adivinhar o que

5042
03:20:18,319 --> 03:20:21,120
nós vamos ver hmm número um 15

5043
03:20:21,120 --> 03:20:24,160
número 215 no número 315 e número quatro

5044
03:20:24,160 --> 03:20:26,560
15. este é realmente o mesmo número que nós

5045
03:20:26,560 --> 03:20:28,800
estamos armazenando nessas variáveis, mas nós

5046
03:20:28,800 --> 03:20:31,680
estão usando uma representação diferente

5047
03:20:31,680 --> 03:20:33,840
que vai ser conveniente dependendo

5048
03:20:33,840 --> 03:20:36,160
em tudo o que estamos fazendo se é

5049
03:20:36,160 --> 03:20:37,920
Mais conveniente para usar binário nós somos

5050
03:20:37,920 --> 03:20:39,920
usar binário se for mais

5051
03:20:39,920 --> 03:20:42,560
uso conveniente hexadecimal por favor use

5052
03:20:42,560 --> 03:20:45,359
Hexadecimal, mas a representação de

5053
03:20:45,359 --> 03:20:48,319
Este número na memória vai realmente

5054
03:20:48,319 --> 03:20:50,080
Seja o mesmo que eu realmente quero que você tome

5055
03:20:50,080 --> 03:20:52,560
algum tempo e deixar isso afundar porque

5056
03:20:52,560 --> 03:20:54,399
Você vai ver essas coisas muito

5057
03:20:54,399 --> 03:20:57,279
momentos em sua carreira como um software

5058
03:20:57,279 --> 03:21:00,160
Desenvolvedor, por favor, faça um favor a si mesmo

5059
03:21:00,160 --> 03:21:02,319
E certifique-se de que você realmente entende isso

5060
03:21:02,319 --> 03:21:04,160
Tudo bem, isso é realmente tudo o que nós estabelecemos para fazer

5061
03:21:04,160 --> 03:21:06,239
Nesta palestra tentando dar sentido a

5062
03:21:06,239 --> 03:21:08,720
os números binários que temos na memória e

5063
03:21:08,720 --> 03:21:10,960
Como nos transformamos entre eles e

5064
03:21:10,960 --> 03:21:13,840
diferentes formas de dados que são facilmente

5065
03:21:13,840 --> 03:21:16,560
manipulado por seres humanos todos os dados são

5066
03:21:16,560 --> 03:21:18,880
representado por um grupo de células agrupadas

5067
03:21:18,880 --> 03:21:21,359
de zeros e aqueles que temos visto isso como

5068
03:21:21,359 --> 03:21:23,439
a gama de seus dados cresce, assim será

5069
03:21:23,439 --> 03:21:25,040
O número de dígitos que você precisa

5070
03:21:25,040 --> 03:21:27,040
representar os dados na memória que temos

5071
03:21:27,040 --> 03:21:29,520
visto que o sistema hexadecimal faz

5072
03:21:29,520 --> 03:21:31,760
É um pouco mais fácil para os humanos lidarem

5073
03:21:31,760 --> 03:21:34,239
fluxos de dados em um e zeros octo

5074
03:21:34,239 --> 03:21:36,800
tem o mesmo objetivo que hexadecimal, mas

5075
03:21:36,800 --> 03:21:39,200
Quase não é mais usado na modernidade

5076
03:21:39,200 --> 03:21:41,760
Os tempos que acabei de mencionar isso aqui para

5077
03:21:41,760 --> 03:21:44,000
Completo, vamos parar aqui

5078
03:21:44,000 --> 03:21:46,080
Nesta palestra no próximo somos

5079
03:21:46,080 --> 03:21:48,160
Vou olhar para os inteiros em um pouco

5080
03:21:48,160 --> 03:21:50,560
mais detalhes para ir em frente e terminar

5081
03:21:50,560 --> 03:21:53,200
Aqui e encontre-me lá nesta palestra

5082
03:21:53,200 --> 03:21:55,200
Vamos aprender um pouco mais sobre

5083
03:21:55,200 --> 03:21:58,080
inteiros em c plus mais inteiros são

5084
03:21:58,080 --> 03:22:00,960
representado por formiga e z plus é

5085
03:22:00,960 --> 03:22:03,600
O que você vê na esquerda aqui e eles

5086
03:22:03,600 --> 03:22:06,239
são usados para armazenar coisas de números inteiros

5087
03:22:06,239 --> 03:22:09,680
como 1 2 e 3. eles normalmente ocupam 4

5088
03:22:09,680 --> 03:22:12,319
bytes ou mais na memória, mas na maioria

5089
03:22:12,319 --> 03:22:14,800
tempos, serão 4 bytes, então para

5090
03:22:14,800 --> 03:22:17,040
exemplo se você tem uma variável chamada

5091
03:22:17,040 --> 03:22:19,680
idade e é um inteiro, é assim

5092
03:22:19,680 --> 03:22:21,439
É mais provável que vá olhar para dentro

5093
03:22:21,439 --> 03:22:23,680
memória vai levar quatro bytes e

5094
03:22:23,680 --> 03:22:25,840
Eu realmente quero deixar claro o que

5095
03:22:25,840 --> 03:22:28,560
variável é uma peça nomeada de

5096
03:22:28,560 --> 03:22:31,359
memória que você usa para armazenar específico

5097
03:22:31,359 --> 03:22:34,319
Tipos de dados estão bem, então aqui se tivermos um

5098
03:22:34,319 --> 03:22:37,520
variável chamada idade é uma peça nomeada

5099
03:22:37,520 --> 03:22:39,840
de memory edge vai ser o nome

5100
03:22:39,840 --> 03:22:42,399
desse pedaço de memória e podemos armazenar

5101
03:22:42,399 --> 03:22:44,560
dados nessa memória vão parecer

5102
03:22:44,560 --> 03:22:46,560
assim na memória, mas o valor é

5103
03:22:46,560 --> 03:22:48,880
vai ser armazenado aqui em binário

5104
03:22:48,880 --> 03:22:51,040
formato eu realmente espero que isso faça sentido a

5105
03:22:51,040 --> 03:22:54,080
variável é um pedaço de memória chamado que

5106
03:22:54,080 --> 03:22:56,399
nós podemos usar para armazenar diferentes tipos de

5107
03:22:56,399 --> 03:22:58,479
dados e tudo bem agora vamos olhar para

5108
03:22:58,479 --> 03:23:01,200
Alguns exemplos de como você pode trabalhar

5109
03:23:01,200 --> 03:23:04,319
inteiros em seu programa c plus você pode

5110
03:23:04,319 --> 03:23:07,040
Definir algumas variáveis aqui que temos uma

5111
03:23:07,040 --> 03:23:09,120
que vai armazenar o número de

5112
03:23:09,120 --> 03:23:11,840
Elefantes que temos, você pode declará-lo

5113
03:23:11,840 --> 03:23:14,960
assim e não colocar um valor e se

5114
03:23:14,960 --> 03:23:17,279
você faz isso, esse compilador é apenas

5115
03:23:17,279 --> 03:23:19,760
Vou colocar algum valor de lixo que

5116
03:23:19,760 --> 03:23:21,920
Não é realmente significativo para o seu

5117
03:23:21,920 --> 03:23:24,800
programa para que você veja o aviso que temos

5118
03:23:24,800 --> 03:23:27,040
aqui, como comentário, a variável pode

5119
03:23:27,040 --> 03:23:29,600
contém valor de lixo aleatório e este é

5120
03:23:29,600 --> 03:23:31,359
Algo que você precisa estar ciente

5121
03:23:31,359 --> 03:23:33,760
outra maneira de definir números inteiros em

5122
03:23:33,760 --> 03:23:36,160
nosso programa c plus plus é este

5123
03:23:36,160 --> 03:23:38,720
declaração aqui que declara uma variável

5124
03:23:38,720 --> 03:23:40,479
chamado de contagem de leões, vai

5125
03:23:40,479 --> 03:23:43,120
inicializar para zero se usarmos curly

5126
03:23:43,120 --> 03:23:44,800
As chaves assim vão

5127
03:23:44,800 --> 03:23:47,200
inicialize para 0 por padrão também podemos

5128
03:23:47,200 --> 03:23:49,680
explicitamente colocar em um valor que podemos fazer o

5129
03:23:49,680 --> 03:23:52,560
mesmo com contagem de gatos e podemos usar estes

5130
03:23:52,560 --> 03:23:55,520
variáveis para fazer operações, por exemplo

5131
03:23:55,520 --> 03:23:57,760
podemos declarar outra variável e

5132
03:23:57,760 --> 03:24:00,080
Vai armazenar o número de

5133
03:24:00,080 --> 03:24:02,399
animais domesticados e nós vamos

5134
03:24:02,399 --> 03:24:05,680
adicionar os números para cães e gatos e

5135
03:24:05,680 --> 03:24:07,760
Vamos armazenar o resultado disso

5136
03:24:07,760 --> 03:24:09,920
em nossa variável que é chamada

5137
03:24:09,920 --> 03:24:11,760
animais domesticados, isso é algo

5138
03:24:11,760 --> 03:24:14,000
Você pode fazer outra coisa que pode ser

5139
03:24:14,000 --> 03:24:16,800
problemático é tentar usar variáveis

5140
03:24:16,800 --> 03:24:19,680
que você não definiu ou declarou em

5141
03:24:19,680 --> 03:24:21,600
O seu programa que lhe dará um

5142
03:24:21,600 --> 03:24:23,520
O erro do compilador e do compilador é

5143
03:24:23,520 --> 03:24:25,439
basicamente vou dizer que eu não sei o que

5144
03:24:25,439 --> 03:24:27,680
Não existe um aqui é que eu não sei

5145
03:24:27,680 --> 03:24:30,399
O que isso não existe é que não

5146
03:24:30,399 --> 03:24:33,040
definido em qualquer lugar do programa outro

5147
03:24:33,040 --> 03:24:36,560
O que você pode fazer é tentar e armazenar um

5148
03:24:36,560 --> 03:24:39,120
número fracionário em uma variável que você

5149
03:24:39,120 --> 03:24:41,279
declarado como um inteiro e isso está acontecendo

5150
03:24:41,279 --> 03:24:43,840
para lhe dar um aviso porque fracionário

5151
03:24:43,840 --> 03:24:47,359
Os números são geralmente maiores em tamanho do que

5152
03:24:47,359 --> 03:24:49,760
inteiros e isso vai perder alguns

5153
03:24:49,760 --> 03:24:51,840
dos seus dados que não temos realmente o suficiente

5154
03:24:51,840 --> 03:24:54,080
ferramentas para entender isso agora, mas nós somos

5155
03:24:54,080 --> 03:24:55,520
Vou entender isso um pouco

5156
03:24:55,520 --> 03:24:57,040
Mais tarde no curso, mas isso é

5157
03:24:57,040 --> 03:24:58,880
Algo que você pode fazer você pode tomar um

5158
03:24:58,880 --> 03:25:01,600
número fracionário e armazená-lo em um

5159
03:25:01,600 --> 03:25:03,840
variável inteiro e vamos fazer

5160
03:25:03,840 --> 03:25:06,720
um exemplo e ver como isso se comporta com

5161
03:25:06,720 --> 03:25:10,000
nosso compilador que é gcc10 ok aqui nós

5162
03:25:10,000 --> 03:25:12,960
têm usado principalmente aparelhos encaracolados para

5163
03:25:12,960 --> 03:25:15,520
inicializar nossas variáveis, mas também podemos

5164
03:25:15,520 --> 03:25:18,080
use parêntesis e isso vai ser

5165
03:25:18,080 --> 03:25:20,239
Geralmente referido para

5166
03:25:20,239 --> 03:25:23,279
como a inicialização funcional da variável

5167
03:25:23,279 --> 03:25:25,279
porque estamos usando parênteses e

5168
03:25:25,279 --> 03:25:26,880
Isso vai fazer o mesmo

5169
03:25:26,880 --> 03:25:29,520
coisa que vimos no último slide com

5170
03:25:29,520 --> 03:25:33,040
curly se prepara, mas quando chegamos ao

5171
03:25:33,040 --> 03:25:35,200
Um exemplo aqui onde estamos armazenando um

5172
03:25:35,200 --> 03:25:38,000
Número fracionário que isso vai

5173
03:25:38,000 --> 03:25:41,040
pique silenciosamente os dados que você tem em um

5174
03:25:41,040 --> 03:25:43,680
número fracionário e transformar isso em um

5175
03:25:43,680 --> 03:25:45,680
inteiro e isso é chamado de implícita

5176
03:25:45,680 --> 03:25:47,680
conversões, mas se formos para o último

5177
03:25:47,680 --> 03:25:50,640
Exemplo aqui em que estamos armazenando 2,9

5178
03:25:50,640 --> 03:25:52,640
em um inteiro isso vai levar

5179
03:25:52,640 --> 03:25:54,800
Este número fracionário corta o

5180
03:25:54,800 --> 03:25:57,680
ponto decimal e apenas armazenar 2 neste

5181
03:25:57,680 --> 03:25:59,520
inteiro e isso pode não ser o que você

5182
03:25:59,520 --> 03:26:02,080
Querer e vai acontecer em silêncio

5183
03:26:02,080 --> 03:26:04,479
então esta é uma maneira muito ruim de fazer isso

5184
03:26:04,479 --> 03:26:06,560
Se você quiser fazer algo assim

5185
03:26:06,560 --> 03:26:09,840
é preferível usar chaves encaracoladas

5186
03:26:09,840 --> 03:26:12,160
Porque você vai ter um

5187
03:26:12,160 --> 03:26:14,080
Avisando que isso vai te perder

5188
03:26:14,080 --> 03:26:16,319
dados ou você vai obter um compilador

5189
03:26:16,319 --> 03:26:18,080
Erro e que o compilador vai

5190
03:26:18,080 --> 03:26:20,479
Para que você faça isso e

5191
03:26:20,479 --> 03:26:22,960
Mais uma vez se alguma coisa disso não faz

5192
03:26:22,960 --> 03:26:25,200
Sentir que vamos para o estúdio visual

5193
03:26:25,200 --> 03:26:27,279
código para jogar conosco e ver como

5194
03:26:27,279 --> 03:26:29,840
O compilador se comporta com essas coisas que nós

5195
03:26:29,840 --> 03:26:32,479
Temos outra maneira de inicializar o nosso

5196
03:26:32,479 --> 03:26:34,640
variáveis em excedente mais podemos usar

5197
03:26:34,640 --> 03:26:36,960
atribuição e nós fizemos isso a

5198
03:26:36,960 --> 03:26:39,840
Algumas vezes no curso, mas isso

5199
03:26:39,840 --> 03:26:41,680
É algo que você pode fazer e nós vamos

5200
03:26:41,680 --> 03:26:44,160
para jogar com isso em código de estúdio visual

5201
03:26:44,160 --> 03:26:45,920
em um minuto e você vai ver como

5202
03:26:45,920 --> 03:26:48,479
Funciona bem agora já vimos três

5203
03:26:48,479 --> 03:26:50,800
maneiras pelas quais podemos inicializar nosso inteiro

5204
03:26:50,800 --> 03:26:53,040
variáveis que podemos usar a mama

5205
03:26:53,040 --> 03:26:55,439
inicialização que é basicamente usando

5206
03:26:55,439 --> 03:26:58,000
curly chaves que podemos usar funcional

5207
03:26:58,000 --> 03:27:01,279
notação que está usando o parêntese

5208
03:27:01,279 --> 03:27:03,200
e nós podemos usar a tarefa

5209
03:27:03,200 --> 03:27:05,520
inicialização, que é o que temos

5210
03:27:05,520 --> 03:27:07,600
Aqui outra coisa eu realmente quero que você

5211
03:27:07,600 --> 03:27:09,920
Veja é que é possível

5212
03:27:09,920 --> 03:27:13,279
consultar para o tamanho da variável

5213
03:27:13,279 --> 03:27:16,160
Aqui estamos tentando imprimir o tamanho e

5214
03:27:16,160 --> 03:27:17,920
O inteiro vai enfrentar o nosso

5215
03:27:17,920 --> 03:27:20,319
sistema operacional e compilador e se nós

5216
03:27:20,319 --> 03:27:22,800
tentar executar isso em nosso compilador é

5217
03:27:22,800 --> 03:27:25,120
Vamos nos dizer exatamente quanta memória

5218
03:27:25,120 --> 03:27:28,720
Um inteiro ocupa em nosso programa

5219
03:27:28,720 --> 03:27:31,840
pode passar e explicitamente assim

5220
03:27:31,840 --> 03:27:34,000
ou podemos passar um nome variável e é

5221
03:27:34,000 --> 03:27:36,560
indo trabalhar igualmente bem, formigas estão bem

5222
03:27:36,560 --> 03:27:38,560
principalmente indo para pegar quatro bytes em

5223
03:27:38,560 --> 03:27:40,600
Uma nova memória, então aqui temos um

5224
03:27:40,600 --> 03:27:43,680
Representação de três formigas na memória

5225
03:27:43,680 --> 03:27:45,760
Se vamos deste zero para este zero

5226
03:27:45,760 --> 03:27:48,000
Isso vai ser exatamente quatro bytes

5227
03:27:48,000 --> 03:27:50,479
E é assim que pode parecer na memória

5228
03:27:50,479 --> 03:27:52,479
Uma outra coisa que eu realmente não falei

5229
03:27:52,479 --> 03:27:55,359
sobre o propósito é que existem alguns

5230
03:27:55,359 --> 03:27:57,920
regras que você deve seguir para nomear o seu

5231
03:27:57,920 --> 03:28:00,479
variáveis em c mais mais um desses

5232
03:28:00,479 --> 03:28:03,359
regras é que uma variável deve começar com

5233
03:28:03,359 --> 03:28:06,800
uma letra como um b c d até z ou um

5234
03:28:06,800 --> 03:28:08,880
sublinhar que você não pode iniciar uma variável

5235
03:28:08,880 --> 03:28:10,720
Por exemplo, com um número que está indo

5236
03:28:10,720 --> 03:28:13,120
Para ser um problema depois do primeiro

5237
03:28:13,120 --> 03:28:15,760
personagem em seu nome variável que você pode

5238
03:28:15,760 --> 03:28:17,840
realmente colocar em qualquer coisa que você pode colocar

5239
03:28:17,840 --> 03:28:20,239
números que você pode colocar em letras que você pode

5240
03:28:20,239 --> 03:28:22,080
Coloque tudo o que quiser, mas

5241
03:28:22,080 --> 03:28:24,479
primeiro não pode ser uma variável numérica

5242
03:28:24,479 --> 03:28:27,600
Os nomes também são sensíveis se você

5243
03:28:27,600 --> 03:28:30,160
ter uma variável chamada conta de bicicleta com

5244
03:28:30,160 --> 03:28:31,920
O minúsculo b

5245
03:28:31,920 --> 03:28:34,080
E você tem outro que começa

5246
03:28:34,080 --> 03:28:36,479
e com maiúsculas b

5247
03:28:36,479 --> 03:28:38,080
Estes serão dois diferentes

5248
03:28:38,080 --> 03:28:40,640
variáveis e uh você tem que estar ciente de

5249
03:28:40,640 --> 03:28:44,000
Estes não há espaços ou caracteres espaciais

5250
03:28:44,000 --> 03:28:46,560
permitido em suas variáveis que você pode usar

5251
03:28:46,560 --> 03:28:48,800
ressalta, mas você não pode usar algo

5252
03:28:48,800 --> 03:28:50,640
como mais porque isso vai ser

5253
03:28:50,640 --> 03:28:52,960
confuso para o seu compilador e estes são

5254
03:28:52,960 --> 03:28:54,960
Algumas regras que você realmente precisa estar ciente

5255
03:28:54,960 --> 03:28:57,279
e você vai ficar bem

5256
03:28:57,279 --> 03:29:00,000
a forma geral para declarar e

5257
03:29:00,000 --> 03:29:02,720
inicializar sua variável é o que você

5258
03:29:02,720 --> 03:29:04,960
Veja aqui você vai passar o tipo

5259
03:29:04,960 --> 03:29:07,359
Neste caso temos usado e porque nós

5260
03:29:07,359 --> 03:29:09,680
Estão aprendendo sobre formigas que você vai fazer

5261
03:29:09,680 --> 03:29:11,600
Passe o nome da variável e você está indo

5262
03:29:11,600 --> 03:29:13,359
para colocar o que você é

5263
03:29:13,359 --> 03:29:15,760
inicializando sua variável com

5264
03:29:15,760 --> 03:29:18,080
O curso isso é inicialização profissional

5265
03:29:18,080 --> 03:29:21,439
porque está usando aparelhos encaracolados, mas você

5266
03:29:21,439 --> 03:29:23,920
também pode usar inicialização funcional

5267
03:29:23,920 --> 03:29:26,640
ou inicialização de atribuição e é

5268
03:29:26,640 --> 03:29:28,560
indo trabalhar igualmente bem bem agora nós

5269
03:29:28,560 --> 03:29:31,040
Tenho informações suficientes para ir em visual

5270
03:29:31,040 --> 03:29:34,479
código de estúdio e jogar com a gente bem aqui eu

5271
03:29:34,479 --> 03:29:37,520
Estou na minha pasta para os projetos deste

5272
03:29:37,520 --> 03:29:40,239
capítulo Eu vou pular na minha

5273
03:29:40,239 --> 03:29:43,359
modelar e copiar os arquivos que

5274
03:29:43,359 --> 03:29:46,080
Eu preciso que eu vou subir de novo

5275
03:29:46,080 --> 03:29:48,960
e ir para o projeto que é chamado

5276
03:29:48,960 --> 03:29:50,479
Tipos de inteiros

5277
03:29:50,479 --> 03:29:52,720
Eu vou entrar e colar no meu

5278
03:29:52,720 --> 03:29:55,279
Arquivos e eu vou abrir isso

5279
03:29:55,279 --> 03:29:58,080
pasta no código do estúdio visual i

5280
03:29:58,080 --> 03:30:00,160
para fechar a tela de boas-vindas aqui e

5281
03:30:00,160 --> 03:30:02,399
abrir meu arquivo principal cpp

5282
03:30:02,399 --> 03:30:05,040
E eu vou fazer a tomada de sempre

5283
03:30:05,040 --> 03:30:07,920
As coisas que não precisamos economizar no tempo

5284
03:30:07,920 --> 03:30:10,160
Eu vou colocar um pedaço de código

5285
03:30:10,160 --> 03:30:13,520
que eu tenho deitado na minha unidade e nós estamos

5286
03:30:13,520 --> 03:30:14,640
Indo para dentro de nós.

5287
03:30:14,640 --> 03:30:17,200
passar por isso para economizar no tempo de digitação i

5288
03:30:17,200 --> 03:30:19,200
Não quero que você sofra me observando

5289
03:30:19,200 --> 03:30:21,439
Digite isso, a primeira coisa que temos é o

5290
03:30:21,439 --> 03:30:23,439
A contagem de elefantes é uma variável que

5291
03:30:23,439 --> 03:30:25,840
não é inicializado, então isso vai

5292
03:30:25,840 --> 03:30:28,399
conter dados de lixo que não vai

5293
03:30:28,399 --> 03:30:30,800
Contém tudo o que é útil para nós

5294
03:30:30,800 --> 03:30:33,120
mas alguns compiladores vão ser úteis

5295
03:30:33,120 --> 03:30:35,600
colocar em zero porque isso é lógico

5296
03:30:35,600 --> 03:30:37,760
número para colocar aqui se você não fez

5297
03:30:37,760 --> 03:30:40,080
Coloque explicitamente um número aqui o

5298
03:30:40,080 --> 03:30:43,120
O segundo é usar aparelhos encaracolados e

5299
03:30:43,120 --> 03:30:45,200
Isso vai automaticamente

5300
03:30:45,200 --> 03:30:47,439
inicializar para zero o terceiro é

5301
03:30:47,439 --> 03:30:50,399
será explicitamente inicializado com

5302
03:30:50,399 --> 03:30:53,120
O 10 e a contagem de gatos vai ser

5303
03:30:53,120 --> 03:30:55,920
inicializado com 15. você pode tentar e

5304
03:30:55,920 --> 03:30:58,000
Imprima isso e veja o que você vem

5305
03:30:58,000 --> 03:31:00,319
após a compilação desta aplicação

5306
03:31:00,319 --> 03:31:02,239
Outra coisa que temos visto é que nós

5307
03:31:02,239 --> 03:31:04,479
pode fazer algo assim e colocar um

5308
03:31:04,479 --> 03:31:09,520
expressão em nossos aparelhos encaracolados e

5309
03:31:09,520 --> 03:31:12,640
valor que esta avaliação vai

5310
03:31:12,640 --> 03:31:15,359
inicializar esses animais domesticados

5311
03:31:15,359 --> 03:31:18,239
variável e agora você deve saber que

5312
03:31:18,239 --> 03:31:20,239
Isso provavelmente vai levar 4 bytes

5313
03:31:20,239 --> 03:31:22,640
na memória, porque é um inteiro

5314
03:31:22,640 --> 03:31:25,760
Isto é realmente como c plus plus funciona

5315
03:31:25,760 --> 03:31:28,640
Cada tipo fundamental tem

5316
03:31:28,640 --> 03:31:31,439
Um tamanho associado a ele

5317
03:31:31,439 --> 03:31:34,239
na maioria das vezes, então inteiros estão indo principalmente

5318
03:31:34,239 --> 03:31:36,160
para ser quatro bytes em seu sistema e

5319
03:31:36,160 --> 03:31:38,800
vamos consultar isso um pouco mais tarde

5320
03:31:38,800 --> 03:31:41,520
neste vídeo OK vamos tentar compilar

5321
03:31:41,520 --> 03:31:44,479
Este programa e ver se realmente

5322
03:31:44,479 --> 03:31:46,479
que vamos começar o mundo e você

5323
03:31:46,479 --> 03:31:49,120
Veja que o mundo é bem sucedido outro

5324
03:31:49,120 --> 03:31:51,840
O que podemos fazer é tentar e usar variáveis

5325
03:31:51,840 --> 03:31:53,520
nós realmente não declaramos em nosso

5326
03:31:53,520 --> 03:31:55,359
programa e você pode adivinhar o que está acontecendo

5327
03:31:55,359 --> 03:31:57,840
para acontecer se tentarmos fazer

5328
03:31:57,840 --> 03:32:01,040
e novo número, por exemplo e putin

5329
03:32:01,040 --> 03:32:03,120
Não existe você sabe que é um número

5330
03:32:03,120 --> 03:32:05,359
que não existe o compilador não é

5331
03:32:05,359 --> 03:32:07,359
Vou saber o que é isso porque nós

5332
03:32:07,359 --> 03:32:10,399
Não declarou uma variável chamada não

5333
03:32:10,399 --> 03:32:12,160
existir se você tentar compilar isso, você está

5334
03:32:12,160 --> 03:32:13,920
Vou ter um problema, você vê que nós

5335
03:32:13,920 --> 03:32:16,640
ter um problema antes mesmo de compilarmos assim

5336
03:32:16,640 --> 03:32:19,359
Código de estúdio visual é tão inteligente que pode

5337
03:32:19,359 --> 03:32:22,080
analisar o nosso código antes de compilá-lo

5338
03:32:22,080 --> 03:32:24,960
e dar dicas para os problemas que podem

5339
03:32:24,960 --> 03:32:27,120
Você vê aqui está dizendo

5340
03:32:27,120 --> 03:32:30,160
não existe não é definido, então se tentarmos

5341
03:32:30,160 --> 03:32:32,479
para compilar isso, vamos conseguir um

5342
03:32:32,479 --> 03:32:34,640
Erro que esperamos que diga

5343
03:32:34,640 --> 03:32:36,720
Não existe realmente não existo

5344
03:32:36,720 --> 03:32:38,560
Não sei o que é, então você não deveria

5345
03:32:38,560 --> 03:32:40,479
Realmente faça isso que você não deve tentar usar

5346
03:32:40,479 --> 03:32:43,600
variáveis que você não declarou que isso é

5347
03:32:43,600 --> 03:32:45,840
A inicialização do braced

5348
03:32:45,840 --> 03:32:48,800
nós também podemos fazer a inicialização funcional

5349
03:32:48,800 --> 03:32:50,560
Como já vimos

5350
03:32:50,560 --> 03:32:53,200
OK outra coisa que podemos fazer é armazenar um

5351
03:32:53,200 --> 03:32:56,080
Número fracionário em uma variável vazia

5352
03:32:56,080 --> 03:32:57,840
E nós vamos ver o que isso faz

5353
03:32:57,840 --> 03:32:59,760
Vamos tentar compilar este código

5354
03:32:59,760 --> 03:33:02,000
Você vê que temos um 2.9 que estamos tentando

5355
03:33:02,000 --> 03:33:04,319
armazená-lo em um inteiro se tentarmos

5356
03:33:04,319 --> 03:33:07,760
compilar isso vamos tentar usar gcc

5357
03:33:07,760 --> 03:33:11,279
claro isso vamos trazer um terminal e

5358
03:33:11,279 --> 03:33:13,840
Tente construir isso, vamos tentar

5359
03:33:13,840 --> 03:33:16,880
executar o nosso compilador gcc neste programa

5360
03:33:16,880 --> 03:33:19,359
vai dizer errol estreitando a

5361
03:33:19,359 --> 03:33:21,800
A conversão de

5362
03:33:21,800 --> 03:33:25,120
2.899 de duplo para inteiro c plus plus

5363
03:33:25,120 --> 03:33:28,080
20 nem vai permitir isso, então

5364
03:33:28,080 --> 03:33:30,880
Isso é uma coisa boa porque você pode

5365
03:33:30,880 --> 03:33:34,080
Pense que você tem um 2,9 e alguns

5366
03:33:34,080 --> 03:33:36,640
Os compiladores vão cortar isso e

5367
03:33:36,640 --> 03:33:39,920
armazenar um 2 em vez disso, então este é um dos

5368
03:33:39,920 --> 03:33:42,160
coisas seguras sobre essa maneira de fazer

5369
03:33:42,160 --> 03:33:44,560
Obrigado, então eu vou comentar isso

5370
03:33:44,560 --> 03:33:46,880
Porque, caso contrário, o nosso programa não

5371
03:33:46,880 --> 03:33:49,520
compilar agora que sabemos como usar

5372
03:33:49,520 --> 03:33:51,840
Essas coisas podemos tentar imprimir o

5373
03:33:51,840 --> 03:33:54,399
valores aqui ok eu vou colocar em

5374
03:33:54,399 --> 03:33:57,040
um pedaço de código que eu tenho ao redor

5375
03:33:57,040 --> 03:33:59,279
Meu drive eu vou remover estes

5376
03:33:59,279 --> 03:34:01,520
espaços dentro porque é irritante

5377
03:34:01,520 --> 03:34:04,160
Vamos fazer isso e se tentarmos construir

5378
03:34:04,160 --> 03:34:06,160
Este programa deve compilar

5379
03:34:06,160 --> 03:34:08,720
Com sucesso e se executarmos, devemos

5380
03:34:08,720 --> 03:34:11,120
Veja nossos números que vamos entrar em nosso

5381
03:34:11,120 --> 03:34:13,600
terminal aqui e fazer der e nós vamos

5382
03:34:13,600 --> 03:34:15,760
para correr galo e nós vamos ver

5383
03:34:15,760 --> 03:34:19,279
A contagem de elefantes é um porque este é um

5384
03:34:19,279 --> 03:34:21,279
valor do lixo para que pudesse realmente ser

5385
03:34:21,279 --> 03:34:22,319
Qualquer coisa

5386
03:34:22,319 --> 03:34:24,560
A contagem de leões deve ser zero

5387
03:34:24,560 --> 03:34:26,880
A conta do cão deve ser 10

5388
03:34:26,880 --> 03:34:29,200
A contagem de gatos deve ser 15 é o que nós

5389
03:34:29,200 --> 03:34:32,800
ter e uma contagem de animais domesticados é

5390
03:34:32,800 --> 03:34:35,840
25 porque temos conta de drogas

5391
03:34:35,840 --> 03:34:38,239
e nós adicionamos isso à contagem de gatos e nós somos

5392
03:34:38,239 --> 03:34:41,120
Vou acabar com 25. isto é o que nós

5393
03:34:41,120 --> 03:34:43,279
Espere agora que sabemos como trabalhar com

5394
03:34:43,279 --> 03:34:45,600
Isso também podemos tentar jogar com

5395
03:34:45,600 --> 03:34:48,479
inicialização funcional antes de colocar

5396
03:34:48,479 --> 03:34:50,720
no meu código eu vou comentar tudo

5397
03:34:50,720 --> 03:34:52,880
Isso porque eu não quero isso

5398
03:34:52,880 --> 03:34:55,200
perturbar-nos enquanto trabalhamos com o nosso

5399
03:34:55,200 --> 03:34:57,680
código de inicialização funcional para que eu seja

5400
03:34:57,680 --> 03:35:00,000
Vou comentar tudo isso e ir tudo

5401
03:35:00,000 --> 03:35:02,479
o caminho para baixo e colocar no meu código para

5402
03:35:02,479 --> 03:35:04,960
A inicialização funcional

5403
03:35:04,960 --> 03:35:06,880
E você vê aqui que temos uma variável

5404
03:35:06,880 --> 03:35:09,840
chamado ethel, inicializamos isso para 5 nós

5405
03:35:09,840 --> 03:35:12,399
tem contagem de laranja que é 10 nós temos

5406
03:35:12,399 --> 03:35:13,920
contagem de frutos

5407
03:35:13,920 --> 03:35:16,000
e temos uma má inicialização que é

5408
03:35:16,000 --> 03:35:18,239
não vai funcionar, não existe 3 e

5409
03:35:18,239 --> 03:35:21,600
Não existe 4 realmente não existe, então

5410
03:35:21,600 --> 03:35:23,359
Isto vai dar-nos um compilador

5411
03:35:23,359 --> 03:35:24,479
Erro de erro

5412
03:35:24,479 --> 03:35:27,600
e se fizermos algo como fazemos

5413
03:35:27,600 --> 03:35:30,399
estreitando a função de conversão aqui

5414
03:35:30,399 --> 03:35:32,960
Isso vai principalmente compilar e isso

5415
03:35:32,960 --> 03:35:36,239
vai cortar dados e armazenar um 2

5416
03:35:36,239 --> 03:35:39,040
em vez do 2.9, isso é algo que você

5417
03:35:39,040 --> 03:35:41,520
Deve realmente estar ciente e você vê

5418
03:35:41,520 --> 03:35:43,920
O comentário aqui diz informações perdidas

5419
03:35:43,920 --> 03:35:46,239
Isto é menos seguro do que braced

5420
03:35:46,239 --> 03:35:49,040
inicializador porque um inicializador de mama

5421
03:35:49,040 --> 03:35:50,479
Está indo para nós.

5422
03:35:50,479 --> 03:35:52,640
dar-lhe um erro de compilador se você tentar

5423
03:35:52,640 --> 03:35:54,800
fazer isso e isso é uma coisa boa

5424
03:35:54,800 --> 03:35:57,520
então nós também tentamos imprimi-los para que eu

5425
03:35:57,520 --> 03:36:00,239
Vou arrumar isso um pouco

5426
03:36:00,239 --> 03:36:02,399
e vou tentar compilar isso

5427
03:36:02,399 --> 03:36:05,040
pedaço de código executar tarefa e mundo com

5428
03:36:05,040 --> 03:36:08,000
gcc que o mundo vai passar

5429
03:36:08,000 --> 03:36:09,600
Sem um problema

5430
03:36:09,600 --> 03:36:13,120
E se nós limparmos e corrermos o galo, nós somos

5431
03:36:13,120 --> 03:36:16,239
ver que conta da maçã é 5, o que é

5432
03:36:16,239 --> 03:36:18,640
O que temos aqui conta laranja é

5433
03:36:18,640 --> 03:36:21,600
indo para ser 10, então este é o fruto certo

5434
03:36:21,600 --> 03:36:24,000
A contagem vai ser 15 porque é 5

5435
03:36:24,000 --> 03:36:25,279
+ 10

5436
03:36:25,279 --> 03:36:29,120
O que é realmente preocupante é que

5437
03:36:29,120 --> 03:36:31,680
A redução da conversão é 2 mas não

5438
03:36:31,680 --> 03:36:34,880
loja em um 2 que começamos em um 2,9

5439
03:36:34,880 --> 03:36:38,160
e porque um inteiro pode realmente armazenar

5440
03:36:38,160 --> 03:36:43,120
4 bytes 2,9 é mais do que 4 bytes e

5441
03:36:43,120 --> 03:36:46,000
vai armazenar o que pode e é

5442
03:36:46,000 --> 03:36:48,960
vai cortar este 2,9 e apenas

5443
03:36:48,960 --> 03:36:51,439
loja em um 2, então isso é realmente algo

5444
03:36:51,439 --> 03:36:54,239
Você deve estar ciente de que às vezes isso é

5445
03:36:54,239 --> 03:36:56,960
causar problemas em seu programa

5446
03:36:56,960 --> 03:36:58,080
E a

5447
03:36:58,080 --> 03:37:00,800
Realmente realmente se você está tentando armazenar

5448
03:37:00,800 --> 03:37:03,680
números fracionários em um inteiro, por favor

5449
03:37:03,680 --> 03:37:06,560
usar uma inicialização braced

5450
03:37:06,560 --> 03:37:08,399
porque o compilador está indo para

5451
03:37:08,399 --> 03:37:11,279
impedi-lo de fazer isso se você tentar bem

5452
03:37:11,279 --> 03:37:13,359
Essa é realmente a diferença entre

5453
03:37:13,359 --> 03:37:15,279
notação funcional e mama

5454
03:37:15,279 --> 03:37:18,399
notação de notação inicializadora funcional

5455
03:37:18,399 --> 03:37:20,399
não vai te dar uma flecha se você

5456
03:37:20,399 --> 03:37:23,279
Tente armazenar algo que não pode realmente

5457
03:37:23,279 --> 03:37:25,840
encaixar em uma rede que vai silenciosamente

5458
03:37:25,840 --> 03:37:28,960
pique-o e coloque o que puder

5459
03:37:28,960 --> 03:37:31,359
e inicializador braced vai dar

5460
03:37:31,359 --> 03:37:33,279
você é um erro de compilador, então este é o

5461
03:37:33,279 --> 03:37:36,000
diferença entre esses dois, eu estou

5462
03:37:36,000 --> 03:37:39,040
Vou comentar isso também e eu

5463
03:37:39,040 --> 03:37:41,359
Vou colocar o comentário inicial

5464
03:37:41,359 --> 03:37:43,760
Aqui e eu vou descer e mostrar

5465
03:37:43,760 --> 03:37:45,600
você que você pode fazer atribuição

5466
03:37:45,600 --> 03:37:48,319
A inicialização também vou colocar

5467
03:37:48,319 --> 03:37:50,160
no meu código aqui porque eu não quero

5468
03:37:50,160 --> 03:37:52,399
digite-o realmente e eu vou imprimir

5469
03:37:52,399 --> 03:37:54,960
tudo isso e temos uma conta de bicicleta

5470
03:37:54,960 --> 03:37:57,279
variável que inicializamos usando o

5471
03:37:57,279 --> 03:37:59,840
A contagem de trilhas de notação de atribuição está indo

5472
03:37:59,840 --> 03:38:02,319
para ser sete contas falsas vai ser

5473
03:38:02,319 --> 03:38:04,800
conta de bicicleta mais contagem de trilhas e nós somos

5474
03:38:04,800 --> 03:38:06,640
vai estreitar a conversão aqui

5475
03:38:06,640 --> 03:38:08,800
e nós vamos ver se isso realmente

5476
03:38:08,800 --> 03:38:11,760
nos vão tentar soldar isso

5477
03:38:11,760 --> 03:38:13,600
Vamos executar a tarefa para o mundo

5478
03:38:13,600 --> 03:38:15,120
com o Gcc

5479
03:38:15,120 --> 03:38:17,120
Vai passar por você pode

5480
03:38:17,120 --> 03:38:19,600
Adivinho o que vamos ver se corremos

5481
03:38:19,600 --> 03:38:21,279
o programa

5482
03:38:21,279 --> 03:38:24,319
Conta de bicicleta é 2 contagem de faixas é 7 que

5483
03:38:24,319 --> 03:38:28,080
é o que esperamos que a contagem de veículos seja nove

5484
03:38:28,080 --> 03:38:31,040
E uh a conversão de estreitamento também é

5485
03:38:31,040 --> 03:38:33,840
cortando o que temos aqui, então isso

5486
03:38:33,840 --> 03:38:35,600
É algo que você precisa ter cuidado

5487
03:38:35,600 --> 03:38:37,840
sobre outra coisa que eu quero que você veja é

5488
03:38:37,840 --> 03:38:39,680
que você pode verificar o tamanho do seu

5489
03:38:39,680 --> 03:38:42,000
variáveis na memória, então vamos

5490
03:38:42,000 --> 03:38:45,120
Verifique o tamanho

5491
03:38:45,120 --> 03:38:46,479
em

5492
03:38:46,479 --> 03:38:48,640
Tamanho de

5493
03:38:48,640 --> 03:38:50,720
e vou colocar um pedaço de código

5494
03:38:50,720 --> 03:38:52,239
Para realmente brincar com isso eu não quero

5495
03:38:52,239 --> 03:38:55,080
Digite tudo isso porque é realmente

5496
03:38:55,080 --> 03:38:57,439
auto-explicativas agora vamos

5497
03:38:57,439 --> 03:38:59,760
locais de impressão de formi e dentro estamos

5498
03:38:59,760 --> 03:39:02,560
vamos dizer o tamanho da formi e isso é

5499
03:39:02,560 --> 03:39:04,479
Vamos nos dar quanta memória é

5500
03:39:04,479 --> 03:39:07,279
realmente ocupados por um fim e nós podemos usar

5501
03:39:07,279 --> 03:39:09,680
Esta forma aqui passando em uma variável

5502
03:39:09,680 --> 03:39:12,560
name track count é uma variável que temos

5503
03:39:12,560 --> 03:39:15,359
declarados e inicializados aqui

5504
03:39:15,359 --> 03:39:18,080
Se construirmos este programa

5505
03:39:18,080 --> 03:39:20,880
Vamos fazer isso com gcc a construção é

5506
03:39:20,880 --> 03:39:23,120
indo para passar e se corrermos

5507
03:39:23,120 --> 03:39:25,439
Galo vamos ver que do tamanho

5508
03:39:25,439 --> 03:39:28,160
de int é quatro você vai ver que

5509
03:39:28,160 --> 03:39:31,199
Isto é em bytes e tamanho da contagem de faixas

5510
03:39:31,199 --> 03:39:34,399
é para também porque a conta de rastreamento é

5511
03:39:34,399 --> 03:39:37,439
também um inteiro, então estes são todos pequenos

5512
03:39:37,439 --> 03:39:39,920
ferramentas que você pode realmente usar para

5513
03:39:39,920 --> 03:39:42,640
Saiba quanto a memória é realmente ser

5514
03:39:42,640 --> 03:39:45,760
usado e ocupado pelo seu programa e

5515
03:39:45,760 --> 03:39:47,279
Isso é realmente tudo o que nos preparamos para fazer

5516
03:39:47,279 --> 03:39:49,760
Esta palestra para aprender o máximo que pudermos

5517
03:39:49,760 --> 03:39:53,120
sobre inteiros inteiros ocupam 4 bytes

5518
03:39:53,120 --> 03:39:56,239
na memória para a maior parte e nós temos

5519
03:39:56,239 --> 03:39:58,880
visto maneiras diferentes de inicializar

5520
03:39:58,880 --> 03:40:01,920
nossas variáveis de inteiros podemos usar a mama

5521
03:40:01,920 --> 03:40:04,800
inicializadores que usarão curly

5522
03:40:04,800 --> 03:40:07,120
chaves nós podemos fazer funcional

5523
03:40:07,120 --> 03:40:09,439
inicialização usando parênteses como

5524
03:40:09,439 --> 03:40:12,960
isso também podemos fazer a notação de atribuição

5525
03:40:12,960 --> 03:40:15,439
usando a partir deste tipo e podemos usar

5526
03:40:15,439 --> 03:40:18,560
tamanho para verificar o tamanho do nosso inteiro

5527
03:40:18,560 --> 03:40:21,359
variáveis eu tenho que dizer que esses tipos

5528
03:40:21,359 --> 03:40:24,080
A inicialização também funciona em outros

5529
03:40:24,080 --> 03:40:27,040
variáveis, mas aproveitámos a oportunidade para

5530
03:40:27,040 --> 03:40:29,520
Introduza todos esses conceitos usando

5531
03:40:29,520 --> 03:40:31,439
inteiros isso é realmente tudo o que estabelecemos

5532
03:40:31,439 --> 03:40:33,120
para fazer nesta palestra espero que você tenha encontrado

5533
03:40:33,120 --> 03:40:35,840
É interessante que vamos parar por aqui

5534
03:40:35,840 --> 03:40:37,680
Nesta palestra o próximo vamos

5535
03:40:37,680 --> 03:40:40,319
para começar e aprender sobre inteiros

5536
03:40:40,319 --> 03:40:43,120
Os modificadores vão em frente e terminam aqui

5537
03:40:43,120 --> 03:40:44,560
e me encontrar lá

5538
03:40:44,560 --> 03:40:46,000
Nesta palestra vamos aprender

5539
03:40:46,000 --> 03:40:49,359
sobre os modificadores inteiros e estes são

5540
03:40:49,359 --> 03:40:51,439
pequenas coisas que você pode polvilhar

5541
03:40:51,439 --> 03:40:54,239
seus tipos inteiros para modificar

5542
03:40:54,239 --> 03:40:56,880
Comportamento um pouco, mas antes de mergulhar

5543
03:40:56,880 --> 03:40:58,399
profundamente sobre isso

5544
03:40:58,399 --> 03:41:00,960
Vamos falar sobre como podemos armazenar

5545
03:41:00,960 --> 03:41:03,920
números positivos ou negativos em inteiros

5546
03:41:03,920 --> 03:41:06,800
e nós podemos fazer algo assim se nós

5547
03:41:06,800 --> 03:41:10,399
colocar um bronzeado dentro do nosso valor 1 variável

5548
03:41:10,399 --> 03:41:12,080
O que é um inteiro

5549
03:41:12,080 --> 03:41:14,560
vai funcionar, nós também podemos colocar em um

5550
03:41:14,560 --> 03:41:18,000
Número negativo como menos 300

5551
03:41:18,000 --> 03:41:20,160
e vai funcionar, então o que é

5552
03:41:20,160 --> 03:41:21,520
A magia aqui

5553
03:41:21,520 --> 03:41:22,479
Bem

5554
03:41:22,479 --> 03:41:24,880
Isto é assinado por padrão e este é um

5555
03:41:24,880 --> 03:41:28,399
Modificador podemos aplicar à nossa variável

5556
03:41:28,399 --> 03:41:31,199
para sinalizar que temos a possibilidade

5557
03:41:31,199 --> 03:41:33,920
para armazenar em números negativos ou positivos

5558
03:41:33,920 --> 03:41:36,319
E vai funcionar se você quiser

5559
03:41:36,319 --> 03:41:38,560
para armazenar números positivos no seu final

5560
03:41:38,560 --> 03:41:41,120
variáveis que você pode usar outro

5561
03:41:41,120 --> 03:41:44,479
modificador chamado não assinado e se você colocar

5562
03:41:44,479 --> 03:41:46,319
em um número negativo que você vai conseguir

5563
03:41:46,319 --> 03:41:48,000
um erro do compilador, vamos ver como

5564
03:41:48,000 --> 03:41:50,479
isso funciona em um minuto, ok independentemente

5565
03:41:50,479 --> 03:41:53,199
se suas variáveis de inteiro são

5566
03:41:53,199 --> 03:41:56,080
não assinados ou assinados, eles vão

5567
03:41:56,080 --> 03:41:58,720
ainda ocupam 4 bytes na memória, então isso

5568
03:41:58,720 --> 03:42:01,040
É assim que vai parecer na memória e

5569
03:42:01,040 --> 03:42:03,359
Aqui está uma fórmula simples que podemos usar para

5570
03:42:03,359 --> 03:42:04,720
Venha com

5571
03:42:04,720 --> 03:42:07,600
a gama de valores que podemos armazenar em nosso

5572
03:42:07,600 --> 03:42:08,960
valores de int

5573
03:42:08,960 --> 03:42:12,160
se não forem assinados ou assinados se o

5574
03:42:12,160 --> 03:42:14,640
O número está dentro, você pode usar isso

5575
03:42:14,640 --> 03:42:17,279
fórmula de alcance não assinado e conectar o

5576
03:42:17,279 --> 03:42:19,359
Número de bits que você tem

5577
03:42:19,359 --> 03:42:22,800
em seu tipo de dados se você estiver usando um

5578
03:42:22,800 --> 03:42:24,399
Assinado inteiro

5579
03:42:24,399 --> 03:42:26,399
Isto é o que você vai usar e

5580
03:42:26,399 --> 03:42:28,720
Aqui está um exemplo simples, por exemplo, se

5581
03:42:28,720 --> 03:42:31,279
Temos um não assinado e este é o

5582
03:42:31,279 --> 03:42:33,520
gama de valores que podemos armazenar nós podemos

5583
03:42:33,520 --> 03:42:36,080
basicamente ir de 0 todo o caminho para 4

5584
03:42:36,080 --> 03:42:38,640
bilhões se o número for assinado

5585
03:42:38,640 --> 03:42:40,800
O alcance será basicamente dividido

5586
03:42:40,800 --> 03:42:42,880
em metade da metade vai ir no

5587
03:42:42,880 --> 03:42:45,199
esquerda e armazenar números negativos e

5588
03:42:45,199 --> 03:42:47,279
A outra metade vai para a direita

5589
03:42:47,279 --> 03:42:49,840
e armazenar números positivos e você pode

5590
03:42:49,840 --> 03:42:52,239
Veja que podemos basicamente ir de menos

5591
03:42:52,239 --> 03:42:55,680
Dois bilhões a dois bilhões, se o número

5592
03:42:55,680 --> 03:42:58,160
Já está assinado por agora temos visto dois

5593
03:42:58,160 --> 03:43:01,520
modificadores não assinados e projetados, mas

5594
03:43:01,520 --> 03:43:04,319
Há outros, por exemplo, você pode

5595
03:43:04,319 --> 03:43:07,920
sinalizar seus tipos inteiros como curto ou longo

5596
03:43:07,920 --> 03:43:11,279
O que isso faz bem, isso é uma mesa

5597
03:43:11,279 --> 03:43:14,080
que eu juntei para tentar subir

5598
03:43:14,080 --> 03:43:15,920
em todas as combinações que você pode vir

5599
03:43:15,920 --> 03:43:19,120
up se você tem uma variável curta

5600
03:43:19,120 --> 03:43:21,279
Vai ser dois bytes na memória

5601
03:43:21,279 --> 03:43:23,600
é a modificação que este modificador

5602
03:43:23,600 --> 03:43:26,399
faz o seu tipo se você tem curto e

5603
03:43:26,399 --> 03:43:28,640
Vai ser dois bytes se você tem um

5604
03:43:28,640 --> 03:43:30,720
Assinado curto e vai ser dois

5605
03:43:30,720 --> 03:43:33,439
bytes se você tem camisa não assinada e

5606
03:43:33,439 --> 03:43:35,920
Vai ser duas mordidas que você pode ver

5607
03:43:35,920 --> 03:43:38,960
que o efeito de curto é realmente

5608
03:43:38,960 --> 03:43:43,120
encurtando o tamanho original na memória

5609
03:43:43,120 --> 03:43:46,319
para qualquer tipo que você aplicou isso em

5610
03:43:46,319 --> 03:43:48,640
Isso está realmente trabalhando em um editor, mesmo

5611
03:43:48,640 --> 03:43:51,120
se não especificarmos aqui, por exemplo,

5612
03:43:51,120 --> 03:43:53,040
curta curta aqui vai

5613
03:43:53,040 --> 03:43:55,600
Igualmente ser e é por isso

5614
03:43:55,600 --> 03:43:58,000
Temos dois bytes porque é basicamente

5615
03:43:58,000 --> 03:44:01,359
Um fim em que nos dividimos aqui em

5616
03:44:01,359 --> 03:44:04,399
a segunda coluna que temos formi, que é

5617
03:44:04,399 --> 03:44:07,199
vai ser 4 bytes se for atribuído

5618
03:44:07,199 --> 03:44:09,520
E vai ser 4 bytes este é

5619
03:44:09,520 --> 03:44:11,279
Realmente os tamanhos que você vai subir

5620
03:44:11,279 --> 03:44:14,880
se você usar essas combinações de

5621
03:44:14,880 --> 03:44:17,920
modificadores em seus tipos inteiros um

5622
03:44:17,920 --> 03:44:19,520
O que eu realmente quero que você tenha cuidado

5623
03:44:19,520 --> 03:44:22,560
É que esses modificadores só funcionam

5624
03:44:22,560 --> 03:44:26,479
para tipos integrais para que eles funcionem para dados

5625
03:44:26,479 --> 03:44:28,800
tipos em que você pode armazenar

5626
03:44:28,800 --> 03:44:31,439
decimal ou números inteiros que você não pode usar

5627
03:44:31,439 --> 03:44:34,239
em tipos em que você pode armazenar

5628
03:44:34,239 --> 03:44:37,359
números fracionários como 2,9 que estão indo

5629
03:44:37,359 --> 03:44:39,520
para dar-lhe um erro de compilador agora que

5630
03:44:39,520 --> 03:44:42,080
Você tem uma ideia sobre isso por que não

5631
03:44:42,080 --> 03:44:44,560
entrar no código do estúdio visual e, na verdade,

5632
03:44:44,560 --> 03:44:47,359
jogar com a gente bem aqui estamos em nosso

5633
03:44:47,359 --> 03:44:50,160
pasta que contém os nossos projetos que somos

5634
03:44:50,160 --> 03:44:53,040
indo para fazer o habitual e copiar os arquivos

5635
03:44:53,040 --> 03:44:55,760
do nosso projeto de template e nós somos

5636
03:44:55,760 --> 03:44:58,960
Vou colocar esses arquivos em nosso inteiro inteiro

5637
03:44:58,960 --> 03:45:02,160
Projeto de modificadores aqui vamos abri-lo

5638
03:45:02,160 --> 03:45:04,239
e colar nos arquivos que vamos embora

5639
03:45:04,239 --> 03:45:06,479
de novo e vamos abrir isso

5640
03:45:06,479 --> 03:45:08,640
em código de estúdio visual a primeira coisa que eu

5641
03:45:08,640 --> 03:45:10,800
Quer jogar com está armazenando positivo

5642
03:45:10,800 --> 03:45:13,040
e números negativos em nosso número inteiro

5643
03:45:13,040 --> 03:45:15,199
Tipos, então vamos dizer valor final

5644
03:45:15,199 --> 03:45:17,920
Um e nós vamos guardar em um 10 para

5645
03:45:17,920 --> 03:45:20,479
exemplo e vamos fazer qualquer valor

5646
03:45:20,479 --> 03:45:21,439
2

5647
03:45:21,439 --> 03:45:24,239
e vamos colocar um menos 300.

5648
03:45:24,239 --> 03:45:25,760
Acho que é isso que tivemos você sabe a

5649
03:45:25,760 --> 03:45:27,760
slide para que vamos manter isso

5650
03:45:27,760 --> 03:45:29,920
Se você tentar imprimir isso para que nós sejamos

5651
03:45:29,920 --> 03:45:31,920
vamos dizer valor 1 e nós vamos

5652
03:45:31,920 --> 03:45:33,760
Diga valor 2

5653
03:45:33,760 --> 03:45:36,640
e nós vamos tentar construir isso assim

5654
03:45:36,640 --> 03:45:38,399
vamos abrir nosso terminal para que

5655
03:45:38,399 --> 03:45:40,479
Podemos brincar com ele imediatamente

5656
03:45:40,479 --> 03:45:42,720
e nós vamos executar a tarefa para o mundo

5657
03:45:42,720 --> 03:45:44,880
com gcc o mundo vai ser

5658
03:45:44,880 --> 03:45:48,160
bem sucedidos se executarmos nosso programa, estamos

5659
03:45:48,160 --> 03:45:49,520
Vou ver que vai dizer

5660
03:45:49,520 --> 03:45:52,479
O valor 1 é 10 e o valor 2

5661
03:45:52,479 --> 03:45:55,760
é -3 300 isso é muito legal nós podemos

5662
03:45:55,760 --> 03:45:57,840
armazenar números positivos e negativos

5663
03:45:57,840 --> 03:46:00,319
números em nossos tempos finais e isso é

5664
03:46:00,319 --> 03:46:01,760
Indo para ocupar

5665
03:46:01,760 --> 03:46:04,000
4 bytes na memória podemos provar isso por

5666
03:46:04,000 --> 03:46:06,160
imprimir o tamanho do valor 1 e do valor

5667
03:46:06,160 --> 03:46:08,880
2. vamos fazer isso para que vamos dizer

5668
03:46:08,880 --> 03:46:12,880
tamanho do valor 1 é o tamanho do valor 1. nós

5669
03:46:12,880 --> 03:46:16,720
também pode fazê-lo para o valor 2 tamanho de valor

5670
03:46:16,720 --> 03:46:21,600
2 e vai ser tamanho do valor dois

5671
03:46:21,600 --> 03:46:24,319
std e sim se construirmos isso de novo

5672
03:46:24,319 --> 03:46:26,319
Nós vamos executar o mundo de teste com

5673
03:46:26,319 --> 03:46:30,080
gcc e uh nós executamos a nossa aplicação é

5674
03:46:30,080 --> 03:46:31,920
Vou salvar quatro bytes para que não

5675
03:46:31,920 --> 03:46:34,000
realmente importa se nós armazenamos em um positivo

5676
03:46:34,000 --> 03:46:36,160
número ou um número negativo que está indo

5677
03:46:36,160 --> 03:46:38,800
ser 4 bytes este é o ponto que eu quero

5678
03:46:38,800 --> 03:46:41,600
fazer aqui outra coisa que você pode fazer é

5679
03:46:41,600 --> 03:46:43,120
Na verdade, faça isso

5680
03:46:43,120 --> 03:46:46,080
Muito claro que você assinou números

5681
03:46:46,080 --> 03:46:49,359
Aqui e você pode usar o

5682
03:46:49,359 --> 03:46:52,160
modificador inteiro aqui, então isso está acontecendo

5683
03:46:52,160 --> 03:46:55,199
para nos dar o mesmo resultado e se tentarmos

5684
03:46:55,199 --> 03:46:56,960
para ambos novamente

5685
03:46:56,960 --> 03:47:00,160
executar a tarefa para construir com Gcc o mundo

5686
03:47:00,160 --> 03:47:02,720
vai ser bem sucedido se corrermos o

5687
03:47:02,720 --> 03:47:04,800
programa, vamos ter o mesmo

5688
03:47:04,800 --> 03:47:07,840
resultará se você não deixar de lado ou se

5689
03:47:07,840 --> 03:47:09,920
Você colocou aqui, vai ser exatamente

5690
03:47:09,920 --> 03:47:12,000
A mesma coisa outra coisa que você pode fazer

5691
03:47:12,000 --> 03:47:14,960
É deixar bem claro que você quer

5692
03:47:14,960 --> 03:47:16,160
loja

5693
03:47:16,160 --> 03:47:18,960
números positivos nas suas variáveis

5694
03:47:18,960 --> 03:47:21,920
pode fazer isso usando o não assinado

5695
03:47:21,920 --> 03:47:24,000
Um modificador inteiro, então vamos dizer

5696
03:47:24,000 --> 03:47:25,439
não assinado

5697
03:47:25,439 --> 03:47:28,239
e valor três, por exemplo, e nós somos

5698
03:47:28,239 --> 03:47:30,239
Vou colocar em um quatro

5699
03:47:30,239 --> 03:47:32,720
Isso vai ficar bem, mas se você fizer

5700
03:47:32,720 --> 03:47:37,120
não assinado e valor 4 e colocar em um minus

5701
03:47:37,120 --> 03:47:38,720
5 Por exemplo

5702
03:47:38,720 --> 03:47:40,479
Isto vai dar-lhe um compilador

5703
03:47:40,479 --> 03:47:43,199
Erro porque você salva isso não é assinado

5704
03:47:43,199 --> 03:47:45,520
E isso realmente significa que você quer

5705
03:47:45,520 --> 03:47:48,560
armazene apenas números positivos, mas você

5706
03:47:48,560 --> 03:47:51,120
estão tentando colocar um número negativo

5707
03:47:51,120 --> 03:47:53,520
se você tentar construir isso vamos tentar isso

5708
03:47:53,520 --> 03:47:55,199
Vamos executar a tarefa de construir

5709
03:47:55,199 --> 03:47:58,080
com gcc vamos ter um compilador

5710
03:47:58,080 --> 03:48:02,000
seta dizendo conversão de -5 para form

5711
03:48:02,000 --> 03:48:03,600
isso não é permitido que você vai conseguir

5712
03:48:03,600 --> 03:48:05,760
uma seta do compilador que seu programa não é

5713
03:48:05,760 --> 03:48:08,239
indo para compilar assim este é um compilador

5714
03:48:08,239 --> 03:48:10,880
Erro, vamos dizer isso aqui e isso é

5715
03:48:10,880 --> 03:48:13,120
realmente tudo que eu tinha que compartilhar sobre estes

5716
03:48:13,120 --> 03:48:15,840
Modificadores assinados e não assinados

5717
03:48:15,840 --> 03:48:17,520
Assinado vai significar que você pode

5718
03:48:17,520 --> 03:48:19,600
armazenar números positivos e negativos

5719
03:48:19,600 --> 03:48:22,160
não assinado vai significar que você pode

5720
03:48:22,160 --> 03:48:25,040
Coloque apenas números positivos e se você

5721
03:48:25,040 --> 03:48:26,720
Tente colocar um número negativo que você é

5722
03:48:26,720 --> 03:48:29,439
obterá um erro de compilador agora que

5723
03:48:29,439 --> 03:48:32,160
Isso é comentado se você tentar correr

5724
03:48:32,160 --> 03:48:34,720
Teste para o mundo com gcc

5725
03:48:34,720 --> 03:48:36,720
O mundo vai ser bom e nós

5726
03:48:36,720 --> 03:48:39,199
será capaz de executar o nosso programa

5727
03:48:39,199 --> 03:48:40,800
E vai fazer o que fosse

5728
03:48:40,800 --> 03:48:44,080
Fazendo antes, como vemos aqui, também vimos

5729
03:48:44,080 --> 03:48:46,720
que poderíamos usar o curto e

5730
03:48:46,720 --> 03:48:49,199
modificadores longos e vamos colocar um

5731
03:48:49,199 --> 03:48:51,040
pedaço de código aqui que vai chegar

5732
03:48:51,040 --> 03:48:53,199
Deixe-nos brincar com eles para que eu não

5733
03:48:53,199 --> 03:48:56,080
Quero digitar isso e se você não quiser

5734
03:48:56,080 --> 03:48:58,319
para digitar isso também você pode obter isso

5735
03:48:58,319 --> 03:49:00,560
código da seção de recursos que é

5736
03:49:00,560 --> 03:49:03,040
Será deixado você pode abrir o link

5737
03:49:03,040 --> 03:49:05,120
usar o código copiar o código e colá-lo

5738
03:49:05,120 --> 03:49:07,040
aqui e realmente brincar com isso porque

5739
03:49:07,040 --> 03:49:09,279
O ponto é realmente não digitar tudo isso

5740
03:49:09,279 --> 03:49:11,439
O ponto é entender o que estes

5741
03:49:11,439 --> 03:49:13,279
Os modificadores fazem

5742
03:49:13,279 --> 03:49:15,279
às suas variáveis o que vamos

5743
03:49:15,279 --> 03:49:17,199
Nós vamos tentar imprimi-los

5744
03:49:17,199 --> 03:49:20,160
e imprimir o tamanho que eles realmente têm em

5745
03:49:20,160 --> 03:49:22,319
memória, vamos fazer isso em quatro

5746
03:49:22,319 --> 03:49:24,399
grupos que vamos fazer um para breve

5747
03:49:24,399 --> 03:49:26,800
E por muito tempo vamos fazer um para formi

5748
03:49:26,800 --> 03:49:29,520
Aqui vamos fazer um por muito tempo e

5749
03:49:29,520 --> 03:49:31,359
nós vamos fazer um por muito tempo

5750
03:49:31,359 --> 03:49:33,600
Estas são coisas que você pode fazer e nós somos

5751
03:49:33,600 --> 03:49:35,600
Vou ver quanta memória é realmente

5752
03:49:35,600 --> 03:49:38,560
sendo usado por todas essas variáveis que somos

5753
03:49:38,560 --> 03:49:41,520
Começando com o primeiro grupo aqui

5754
03:49:41,520 --> 03:49:43,840
então nós vamos descer e imprimir o

5755
03:49:43,840 --> 03:49:47,680
O tamanho está fora e isso pode ser muito difícil

5756
03:49:47,680 --> 03:49:50,239
para envolver seu cérebro ao redor, mas eles são

5757
03:49:50,239 --> 03:49:51,840
simples velho

5758
03:49:51,840 --> 03:49:53,840
ver declarações que temos sido

5759
03:49:53,840 --> 03:49:56,720
Fazendo o tempo todo eu vou dividir isso

5760
03:49:56,720 --> 03:49:59,040
em diferentes linhas para que você possa

5761
03:49:59,040 --> 03:50:01,279
Realmente diga isso assim

5762
03:50:01,279 --> 03:50:04,640
temos uma declaração de saída para um curto

5763
03:50:04,640 --> 03:50:07,279
var que é o que temos aqui, então nós

5764
03:50:07,279 --> 03:50:09,520
Espero que isso tome dois bytes e todos

5765
03:50:09,520 --> 03:50:11,279
Essas coisas provavelmente vão levar

5766
03:50:11,279 --> 03:50:13,760
Dois bytes vamos tentar construir o

5767
03:50:13,760 --> 03:50:16,399
programa com gcc a bala vai

5768
03:50:16,399 --> 03:50:18,640
ser bem sucedido, vamos correr

5769
03:50:18,640 --> 03:50:20,640
Galo e você vai ver isso

5770
03:50:20,640 --> 03:50:23,840
final curto é que dois bytes assinados curto são

5771
03:50:23,840 --> 03:50:26,160
Dois bytes e tudo é basicamente

5772
03:50:26,160 --> 03:50:27,359
Dois bytes

5773
03:50:27,359 --> 03:50:30,399
Neste grupo aqui e nós adivinhamos

5774
03:50:30,399 --> 03:50:32,160
certo a próxima coisa que queremos experimentar

5775
03:50:32,160 --> 03:50:35,199
Este grupo de formigas, então

5776
03:50:35,199 --> 03:50:37,199
Vamos descer e dar

5777
03:50:37,199 --> 03:50:39,600
um pouco de espaço para respirar

5778
03:50:39,600 --> 03:50:41,680
e nós vamos colar isso dentro e

5779
03:50:41,680 --> 03:50:43,680
vamos separá-los novamente, então

5780
03:50:43,680 --> 03:50:45,840
que podemos ver o que realmente está acontecendo

5781
03:50:45,840 --> 03:50:48,800
Aqui e eu acho que isso é realmente o suficiente

5782
03:50:48,800 --> 03:50:51,520
Então vamos ver os tamanhos para o

5783
03:50:51,520 --> 03:50:54,479
Obrigado que temos neste grupo aqui e nós

5784
03:50:54,479 --> 03:50:57,520
Espere que isso leve quatro bytes, então vamos

5785
03:50:57,520 --> 03:51:00,560
Tente executar a tarefa mundial para construir com

5786
03:51:00,560 --> 03:51:03,040
gcc o mundo vai ser bom nós podemos

5787
03:51:03,040 --> 03:51:05,760
executar o programa como normalmente fazemos e

5788
03:51:05,760 --> 03:51:08,239
Você verá que a variável de formi é

5789
03:51:08,239 --> 03:51:11,600
4 bytes e tudo nesse grupo é

5790
03:51:11,600 --> 03:51:15,439
4 bytes e isso diz que

5791
03:51:15,439 --> 03:51:19,680
Independentemente do lado e deslate

5792
03:51:19,680 --> 03:51:22,479
Modificadores que você coloca aqui vai

5793
03:51:22,479 --> 03:51:25,279
realmente usar o tamanho dele aqui ok é

5794
03:51:25,279 --> 03:51:27,840
Vou levar quatro bytes na memória, vamos

5795
03:51:27,840 --> 03:51:30,399
Tente este grupo aqui nós vamos embora

5796
03:51:30,399 --> 03:51:33,040
para baixo e colocar no código para imprimir o

5797
03:51:33,040 --> 03:51:34,640
Tamanhos para eles

5798
03:51:34,640 --> 03:51:38,239
E isso é o que devemos usar

5799
03:51:38,239 --> 03:51:40,399
Vamos dividir isso em linhas diferentes, então

5800
03:51:40,399 --> 03:51:43,439
Que é mais fácil para os olhos e novamente

5801
03:51:43,439 --> 03:51:44,960
Se você realmente não quer digitar isso

5802
03:51:44,960 --> 03:51:46,960
você pode obter o código a partir do comprimento

5803
03:51:46,960 --> 03:51:49,279
seção de recursos que você vai encontrar

5804
03:51:49,279 --> 03:51:51,520
o código aqui e você pode copiar e colar

5805
03:51:51,520 --> 03:51:53,680
E realmente brincar com a gente, mas é

5806
03:51:53,680 --> 03:51:56,239
útil para realmente digitar essas coisas

5807
03:51:56,239 --> 03:51:58,960
e realmente trazer essas coisas em músculo

5808
03:51:58,960 --> 03:52:00,960
memória porque vai ajudar bem

5809
03:52:00,960 --> 03:52:03,600
então nós temos isso e nós vamos tentar

5810
03:52:03,600 --> 03:52:06,960
e executar a tarefa do mundo com gcc

5811
03:52:06,960 --> 03:52:09,199
A construção é boa, vamos entrar aqui

5812
03:52:09,199 --> 03:52:10,720
e correr o galo

5813
03:52:10,720 --> 03:52:13,279
e vai dizer que a variável longa é

5814
03:52:13,279 --> 03:52:16,080
Quatro bytes e tudo neste grupo

5815
03:52:16,080 --> 03:52:19,279
Será basicamente quatro bytes

5816
03:52:19,279 --> 03:52:22,560
Aqui o último é este longo tempo

5817
03:52:22,560 --> 03:52:23,439
uma coisa

5818
03:52:23,439 --> 03:52:25,600
vai realmente te dar um enorme

5819
03:52:25,600 --> 03:52:26,399
gama de alcance

5820
03:52:26,399 --> 03:52:28,560
para seus valores que você pode armazenar no

5821
03:52:28,560 --> 03:52:31,520
variável mas não confie no meu mundo

5822
03:52:31,520 --> 03:52:33,359
Vamos tentar isso para que você possa ver

5823
03:52:33,359 --> 03:52:35,680
para si mesmo, nós vamos descer e

5824
03:52:35,680 --> 03:52:38,000
Realmente coloque isso para que nós vamos

5825
03:52:38,000 --> 03:52:40,720
dar-nos algum espaço para respirar

5826
03:52:40,720 --> 03:52:42,960
e colar o código em

5827
03:52:42,960 --> 03:52:45,120
então eu estou indo para

5828
03:52:45,120 --> 03:52:47,439
trazer isso para a próxima linha

5829
03:52:47,439 --> 03:52:50,399
O que estamos realmente fazendo é imprimir

5830
03:52:50,399 --> 03:52:53,760
os tamanhos para as variáveis que temos

5831
03:52:53,760 --> 03:52:55,520
Neste grupo aqui

5832
03:52:55,520 --> 03:52:57,120
Vamos construir e ver

5833
03:52:57,120 --> 03:52:59,680
Se isso passar pelo mundo

5834
03:52:59,680 --> 03:53:01,680
O mundo vai ser bom

5835
03:53:01,680 --> 03:53:04,000
Agora podemos correr um galo

5836
03:53:04,000 --> 03:53:06,160
e nós vamos ver que longo é longo

5837
03:53:06,160 --> 03:53:09,199
Oito bytes oito bytes nos dão um

5838
03:53:09,199 --> 03:53:12,560
Uma enorme variedade de valores está tudo bem

5839
03:53:12,560 --> 03:53:14,160
Realmente tudo o que nos posicionamos para fazer nisso

5840
03:53:14,160 --> 03:53:16,080
palestra para aprender sobre esses inteiros

5841
03:53:16,080 --> 03:53:18,640
modificadores que eles modificam a maneira como você

5842
03:53:18,640 --> 03:53:20,880
variáveis de inteiros se comportam, por exemplo,

5843
03:53:20,880 --> 03:53:23,359
Podemos especificar que queremos apenas positivo

5844
03:53:23,359 --> 03:53:26,000
números tudo o que queremos armazenar

5845
03:53:26,000 --> 03:53:28,080
Números positivos e negativos para isso

5846
03:53:28,080 --> 03:53:30,720
você vai usar projetado ou não assinado

5847
03:53:30,720 --> 03:53:33,359
modificadores que você também pode encurtar ou

5848
03:53:33,359 --> 03:53:35,920
alongar a gama de valores que você pode

5849
03:53:35,920 --> 03:53:38,319
armazene em sua variável usando o

5850
03:53:38,319 --> 03:53:41,120
modificadores curtos e longos e do

5851
03:53:41,120 --> 03:53:43,920
saída de um programa aqui você pode realmente

5852
03:53:43,920 --> 03:53:46,239
Veja todos esses efeitos aqui é

5853
03:53:46,239 --> 03:53:48,319
Realmente tudo o que nos posicionamos para fazer nisso

5854
03:53:48,319 --> 03:53:50,560
Uma palestra espero que você tenha achado interessante

5855
03:53:50,560 --> 03:53:52,080
Vamos parar aqui neste

5856
03:53:52,080 --> 03:53:53,760
palestra no próximo, vamos

5857
03:53:53,760 --> 03:53:56,960
começar e aprender sobre números fracionários

5858
03:53:56,960 --> 03:53:59,600
Vá em frente e termine aqui e me encontre

5859
03:53:59,600 --> 03:54:01,199
lá nesta palestra vamos

5860
03:54:01,199 --> 03:54:04,399
Saiba mais sobre números fracionários e como nós

5861
03:54:04,399 --> 03:54:06,000
trabalhar com esses números que eu quero que você

5862
03:54:06,000 --> 03:54:08,239
Lembre-se de que qualquer pedaço de dados você

5863
03:54:08,239 --> 03:54:11,279
trabalhar com o seu programa c plus

5864
03:54:11,279 --> 03:54:13,760
Em última análise, será armazenado no

5865
03:54:13,760 --> 03:54:17,120
forma de uns e zeros na memória

5866
03:54:17,120 --> 03:54:18,880
O número funcional também é chamado

5867
03:54:18,880 --> 03:54:22,080
tipos flutuantes em termos técnicos

5868
03:54:22,080 --> 03:54:24,479
são usados para representar números com

5869
03:54:24,479 --> 03:54:27,520
peças fracionárias em c plus plus e muitas

5870
03:54:27,520 --> 03:54:30,160
Outras línguas e temos três tipos

5871
03:54:30,160 --> 03:54:32,319
que podemos usar em c plus plus que temos

5872
03:54:32,319 --> 03:54:33,279
float

5873
03:54:33,279 --> 03:54:35,920
duplo e longo duplo e o principal

5874
03:54:35,920 --> 03:54:39,040
A diferença está no tamanho em que ocupam

5875
03:54:39,040 --> 03:54:41,920
memória um float leva quatro bytes um duplo

5876
03:54:41,920 --> 03:54:44,399
leva oito bytes e o longo duplo

5877
03:54:44,399 --> 03:54:47,760
leva 12 bytes normalmente como o tamanho

5878
03:54:47,760 --> 03:54:50,000
sobe você também pode notar que o

5879
03:54:50,000 --> 03:54:52,399
A precisão sobe, então o que é

5880
03:54:52,399 --> 03:54:54,880
A precisão da precisão é basicamente a

5881
03:54:54,880 --> 03:54:58,239
número de bits que você pode representar com

5882
03:54:58,239 --> 03:55:01,040
que tipo a partir do número em

5883
03:55:01,040 --> 03:55:03,040
diante do ponto decimal, então se olharmos

5884
03:55:03,040 --> 03:55:05,359
Neste número aqui podemos tentar e

5885
03:55:05,359 --> 03:55:07,840
descobrir sua precisão para que vamos

5886
03:55:07,840 --> 03:55:13,920
para contar 1 2 3 4 5 6 7 8 9 10 11 12.

5887
03:55:13,920 --> 03:55:16,399
A precisão aqui é 12.

5888
03:55:16,399 --> 03:55:19,040
Se voltarmos para a nossa mesa

5889
03:55:19,040 --> 03:55:21,359
Realmente não somos capazes de representar um

5890
03:55:21,359 --> 03:55:24,319
um número como este com um flutuador

5891
03:55:24,319 --> 03:55:26,399
A menor coisa que podemos usar para

5892
03:55:26,399 --> 03:55:28,720
Representar bem este número

5893
03:55:28,720 --> 03:55:32,080
É um duplo porque a precisão é 15

5894
03:55:32,080 --> 03:55:34,319
E é mais do que precisamos para

5895
03:55:34,319 --> 03:55:36,479
Este número é 12. uma coisa que você

5896
03:55:36,479 --> 03:55:38,560
Deve lembrar que o número em

5897
03:55:38,560 --> 03:55:40,479
diante do ponto decimal também é

5898
03:55:40,479 --> 03:55:42,640
Contado então quando você está tentando

5899
03:55:42,640 --> 03:55:44,640
Descobrir a precisão para o seu

5900
03:55:44,640 --> 03:55:48,000
números de ponto flutuante em c plus plus assim

5901
03:55:48,000 --> 03:55:50,800
Aqui temos um exemplo de como podemos

5902
03:55:50,800 --> 03:55:53,359
declarar e inicializar o ponto flutuante

5903
03:55:53,359 --> 03:55:56,160
números em nosso programa c plus

5904
03:55:56,160 --> 03:55:58,960
O número um é um número realmente grande, então

5905
03:55:58,960 --> 03:56:01,120
Você pode adivinhar que isso é mais do que nós

5906
03:56:01,120 --> 03:56:03,439
pode lidar com o float que vamos

5907
03:56:03,439 --> 03:56:06,640
Veja como isso é tratado pelo nosso compilador

5908
03:56:06,640 --> 03:56:10,800
um duplo tem uma precisão de 15, então nós

5909
03:56:10,800 --> 03:56:12,960
Esperava armazenar mais números do que

5910
03:56:12,960 --> 03:56:15,600
nós fizemos em um flutuador um longo duplo deve

5911
03:56:15,600 --> 03:56:18,399
ser capaz de lidar com isso sem um problema

5912
03:56:18,399 --> 03:56:21,439
porque se voltarmos para a nossa mesa aqui

5913
03:56:21,439 --> 03:56:23,680
O nosso longo duplo aqui deve ser capaz de

5914
03:56:23,680 --> 03:56:26,960
lidar com isso melhor do que o dobro, mas é

5915
03:56:26,960 --> 03:56:29,279
É possível que seja a mesma coisa que

5916
03:56:29,279 --> 03:56:31,680
duplo dependendo do compilador

5917
03:56:31,680 --> 03:56:33,920
implementação e se tentarmos imprimir

5918
03:56:33,920 --> 03:56:35,600
fora os tamanhos aqui nós vamos ver

5919
03:56:35,600 --> 03:56:37,760
O que o compilador nos dá, estamos indo

5920
03:56:37,760 --> 03:56:40,080
para fazer isso quando tentamos isso em

5921
03:56:40,080 --> 03:56:42,479
código de estúdio bem e aqui estamos tentando

5922
03:56:42,479 --> 03:56:44,880
para imprimir a precisão destes

5923
03:56:44,880 --> 03:56:49,840
números que podemos usar uma configuração especial em

5924
03:56:49,840 --> 03:56:53,199
nosso fluxo para controlar o máximo

5925
03:56:53,199 --> 03:56:55,359
precisão que podemos ver aqui você vê

5926
03:56:55,359 --> 03:56:57,439
que estamos tentando mostrar a precisão

5927
03:56:57,439 --> 03:56:59,359
para cada número há um especial

5928
03:56:59,359 --> 03:57:02,720
configuração que podemos colocar stdc para fora para fazer

5929
03:57:02,720 --> 03:57:04,880
controla a precisão a um dado

5930
03:57:04,880 --> 03:57:07,520
Número aqui estamos usando 20 e estamos

5931
03:57:07,520 --> 03:57:09,279
Vou ver que para o número um é

5932
03:57:09,279 --> 03:57:12,080
Vai ser sete dígitos para o número dois

5933
03:57:12,080 --> 03:57:14,479
Deve ser 15 dígitos ou algo assim

5934
03:57:14,479 --> 03:57:16,800
perto disso, os detalhes são realmente

5935
03:57:16,800 --> 03:57:19,439
Dependendo da implementação do compilador

5936
03:57:19,439 --> 03:57:22,239
e para o duplo longo deve pelo menos

5937
03:57:22,239 --> 03:57:24,960
ser o mesmo que duplo ou ainda mais em

5938
03:57:24,960 --> 03:57:27,520
alguns casos bem aqui queremos ver que

5939
03:57:27,520 --> 03:57:30,319
Também podemos ter erros de estreitamento

5940
03:57:30,319 --> 03:57:32,800
Se tentarmos armazenar algo de volta em um

5941
03:57:32,800 --> 03:57:35,760
float e um flutuador não pode realmente lidar com isso

5942
03:57:35,760 --> 03:57:38,399
Aqui temos um número com muito

5943
03:57:38,399 --> 03:57:41,840
dígitos um dois três quatro cinco seis sete

5944
03:57:41,840 --> 03:57:44,640
8 nove e sabemos que o carro alegórico

5945
03:57:44,640 --> 03:57:47,439
só pode lidar com sete dígitos assim

5946
03:57:47,439 --> 03:57:48,960
Isso provavelmente vai nos dar a

5947
03:57:48,960 --> 03:57:51,880
Erro do compilador como vimos para a mama

5948
03:57:51,880 --> 03:57:54,800
inicialização se usarmos funcionais

5949
03:57:54,800 --> 03:57:56,960
inicialização este problema não vai

5950
03:57:56,960 --> 03:58:00,080
ser código em tempo de compilação, então nós somos

5951
03:58:00,080 --> 03:58:02,399
indo acabar com um pedaço de pedaço de

5952
03:58:02,399 --> 03:58:04,399
dados e vamos ver isso quando

5953
03:58:04,399 --> 03:58:06,880
jogar com isso com código de estúdio visual

5954
03:58:06,880 --> 03:58:09,040
e outro formato que podemos usar

5955
03:58:09,040 --> 03:58:11,920
Pontos flutuantes é que podemos usar

5956
03:58:11,920 --> 03:58:15,279
notação científica e é basicamente

5957
03:58:15,279 --> 03:58:18,479
Uma maneira de usar um poder de 10

5958
03:58:18,479 --> 03:58:22,000
multiplicador para multiplicar com a nossa flutuação

5959
03:58:22,000 --> 03:58:24,479
Número de ponto, por exemplo, aqui número

5960
03:58:24,479 --> 03:58:28,160
5 vai ser este número 1 9 2 4 0 0

5961
03:58:28,160 --> 03:58:31,920
0 23 podemos usar um ponto flutuante

5962
03:58:31,920 --> 03:58:34,880
notação científica para representar isso

5963
03:58:34,880 --> 03:58:36,560
Então o que vamos fazer, vamos

5964
03:58:36,560 --> 03:58:40,319
digamos 1.9 e vamos multiplicar isso

5965
03:58:40,319 --> 03:58:42,960
10 para o poder de 8. isto é o que

5966
03:58:42,960 --> 03:58:47,760
Isto significa que este 8 aqui significa multiplicar

5967
03:58:47,760 --> 03:58:50,479
10 para o poder de 8. e se nós

5968
03:58:50,479 --> 03:58:52,880
multiplicar com isso que basicamente significa

5969
03:58:52,880 --> 03:58:55,840
movendo o ponto decimal 8 dígitos para o

5970
03:58:55,840 --> 03:58:59,840
Para que possamos ir um dois três quatro

5971
03:58:59,840 --> 03:59:02,640
cinco seis sete oito e vai

5972
03:59:02,640 --> 03:59:05,439
terminar nestes três aqui e está indo

5973
03:59:05,439 --> 03:59:07,439
ser basicamente o mesmo número

5974
03:59:07,439 --> 03:59:09,920
sete também é outro e se o fizermos

5975
03:59:09,920 --> 03:59:12,160
Estamos indo para padar com zeros depois

5976
03:59:12,160 --> 03:59:14,800
Estes quatro e nós vamos acabar em

5977
03:59:14,800 --> 03:59:17,439
Este mesmo local que os três, mas

5978
03:59:17,439 --> 03:59:18,960
Vai ser um zero que vamos ver

5979
03:59:18,960 --> 03:59:21,760
A respeito disso em um minuto e número oito

5980
03:59:21,760 --> 03:59:24,160
é outro número de ponto flutuante e nós

5981
03:59:24,160 --> 03:59:27,359
pode usar notação científica para representar

5982
03:59:27,359 --> 03:59:30,560
Como você vê com o número nove

5983
03:59:30,560 --> 03:59:32,160
Nós basicamente vamos ter o mesmo

5984
03:59:32,160 --> 03:59:34,479
coisa quando temos um menos aqui dentro

5985
03:59:34,479 --> 03:59:37,120
significa que vamos multiplicar com 10 a

5986
03:59:37,120 --> 03:59:40,319
o poder de menos 11 e isso está acontecendo

5987
03:59:40,319 --> 03:59:43,520
para nos dar um número abaixo de uma coisa zero

5988
03:59:43,520 --> 03:59:45,840
ponto zero zero sete ou algo como

5989
03:59:45,840 --> 03:59:48,479
que vamos passar 11 dígitos

5990
03:59:48,479 --> 03:59:51,840
depois do zero aqui e se contarmos um

5991
03:59:51,840 --> 03:59:57,600
dois três quatro 5 6 7 8 9 10 11 e

5992
03:59:57,600 --> 04:00:00,479
O ponto decimal vai atrás de três

5993
04:00:00,479 --> 04:00:02,319
e nós vamos basicamente acabar com

5994
04:00:02,319 --> 04:00:04,160
A mesma coisa aqui vamos jogar

5995
04:00:04,160 --> 04:00:05,520
com isso em um minuto e você está indo

5996
04:00:05,520 --> 04:00:07,680
ver que tudo isso faz sentido e

5997
04:00:07,680 --> 04:00:09,920
Não se esqueça de que qualquer dado de dados nós

5998
04:00:09,920 --> 04:00:12,160
Armazenar em um computador vai ser

5999
04:00:12,160 --> 04:00:15,600
Em última análise, representado por uns e zeros

6000
04:00:15,600 --> 04:00:18,319
na memória e para os pontos flutuantes

6001
04:00:18,319 --> 04:00:20,720
Não use os sistemas de números como nós

6002
04:00:20,720 --> 04:00:22,800
feito para inteiros há um especial

6003
04:00:22,800 --> 04:00:25,680
sistema que é usado para fazer isso, mas é

6004
04:00:25,680 --> 04:00:27,760
Um pouco complicado de cobrir em um

6005
04:00:27,760 --> 04:00:29,920
Curso como este eu vou apenas para

6006
04:00:29,920 --> 04:00:32,239
aponte para isso se você estiver interessado

6007
04:00:32,239 --> 04:00:34,000
Quando você terminar este curso

6008
04:00:34,000 --> 04:00:36,319
Você pode vir e ler sobre isso

6009
04:00:36,319 --> 04:00:38,399
O ponto principal é que qualquer pedaço de dados

6010
04:00:38,399 --> 04:00:40,560
que você representa em seu c plus plus

6011
04:00:40,560 --> 04:00:43,120
O programa será representado em

6012
04:00:43,120 --> 04:00:46,479
termos e zeros na memória de

6013
04:00:46,479 --> 04:00:48,399
Seu computador está bem, existem alguns

6014
04:00:48,399 --> 04:00:50,720
Coisas que você pode fazer com pontos flutuantes

6015
04:00:50,720 --> 04:00:53,040
que você realmente não pode fazer com inteiros

6016
04:00:53,040 --> 04:00:56,080
Por exemplo, você pode dividir com zero se

6017
04:00:56,080 --> 04:00:58,239
Você pega um número de ponto flutuante e

6018
04:00:58,239 --> 04:01:00,479
Divida isso com zero que você vai

6019
04:01:00,479 --> 04:01:03,279
obter o que chamamos de infinito se o número

6020
04:01:03,279 --> 04:01:05,040
É positivo que você vai ficar positivo

6021
04:01:05,040 --> 04:01:06,800
infinito se o número for negativo

6022
04:01:06,800 --> 04:01:09,199
Você vai ter um infinito negativo

6023
04:01:09,199 --> 04:01:11,359
e você pode tomar dois pontos flutuantes

6024
04:01:11,359 --> 04:01:14,239
números que são zeros e dividi-los

6025
04:01:14,239 --> 04:01:15,680
O que você vai ter realmente é

6026
04:01:15,680 --> 04:01:18,160
Não é um número, é algo chamado Nan

6027
04:01:18,160 --> 04:01:20,399
que significa um número impertinente

6028
04:01:20,399 --> 04:01:23,120
E uh o seu programa não vai

6029
04:01:23,120 --> 04:01:25,600
crash, mas poucas coisas que você não pode fazer

6030
04:01:25,600 --> 04:01:27,040
com essas coisas, por exemplo, você não pode

6031
04:01:27,040 --> 04:01:29,040
Adicione-os, você não deve realmente fazer isso

6032
04:01:29,040 --> 04:01:31,520
Provavelmente vai acabar mal por

6033
04:01:31,520 --> 04:01:34,640
Seu programa aqui temos alguns exemplos

6034
04:01:34,640 --> 04:01:37,040
Temos três números declarados que são

6035
04:01:37,040 --> 04:01:39,359
Os duplos devem ocupar oito

6036
04:01:39,359 --> 04:01:42,560
bytes na memória número 10 é inicializado

6037
04:01:42,560 --> 04:01:46,080
5,6 11 é inicializado a zero porque

6038
04:01:46,080 --> 04:01:48,880
Estamos usando a inicialização braced

6039
04:01:48,880 --> 04:01:50,880
E nós não temos nada aqui

6040
04:01:50,880 --> 04:01:53,680
e infinito aqui é o resultado de

6041
04:01:53,680 --> 04:01:56,479
dividindo um número por zero, então ele está indo

6042
04:01:56,479 --> 04:01:59,359
ser um infinito positivo porque número

6043
04:01:59,359 --> 04:02:01,920
10 é um número positivo se você descer

6044
04:02:01,920 --> 04:02:04,160
vamos imprimir o número 10 dividido

6045
04:02:04,160 --> 04:02:06,479
pelo número 11 e vamos dizer

6046
04:02:06,479 --> 04:02:08,640
Rendimentos que vamos colocar o resultado para fora

6047
04:02:08,640 --> 04:02:10,880
nós vamos ver isso aqui em baixo no

6048
04:02:10,880 --> 04:02:12,560
Segunda linha você vê que estamos tentando

6049
04:02:12,560 --> 04:02:14,720
para adicionar algo ao infinito e isso é

6050
04:02:14,720 --> 04:02:17,600
também vai produzir infinito porque

6051
04:02:17,600 --> 04:02:21,120
Pense no infinito como algo super grande

6052
04:02:21,120 --> 04:02:23,120
e se você adicionar algo pequeno para

6053
04:02:23,120 --> 04:02:24,800
Algo grande ainda vai ser

6054
04:02:24,800 --> 04:02:26,640
Algo grande aqui você vê isso

6055
04:02:26,640 --> 04:02:29,199
O resultado é igual ao número 11 dividido por

6056
04:02:29,199 --> 04:02:31,760
número 12 e estes dois são zeros, então

6057
04:02:31,760 --> 04:02:33,520
nós vamos acabar com nenhum e

6058
04:02:33,520 --> 04:02:35,520
Isso é o que vamos imprimir nisso

6059
04:02:35,520 --> 04:02:37,120
Declaração aqui

6060
04:02:37,120 --> 04:02:39,520
para baixo ok você deve

6061
04:02:39,520 --> 04:02:41,600
realmente lembre-se de colocar nos sufixos

6062
04:02:41,600 --> 04:02:44,000
Quando você está inicializando sua flutuação

6063
04:02:44,000 --> 04:02:46,880
números de pontos caso contrário o padrão é

6064
04:02:46,880 --> 04:02:49,040
Vou ser o dobro disso é o que queremos dizer

6065
04:02:49,040 --> 04:02:51,600
Por isso você vê este número flutuante

6066
04:02:51,600 --> 04:02:54,319
ter um sufixo que é f para significar que ele

6067
04:02:54,319 --> 04:02:56,399
é um número flutuante se você não colocar

6068
04:02:56,399 --> 04:02:58,640
Que nisso vai ser interpretado

6069
04:02:58,640 --> 04:03:00,880
como duplo e o compilador vai

6070
04:03:00,880 --> 04:03:03,279
Tente transformar isso em um flutuador por

6071
04:03:03,279 --> 04:03:05,199
cortar coisas que não podem realmente

6072
04:03:05,199 --> 04:03:07,439
encaixar em um flutuador, então para realmente fazê-lo

6073
04:03:07,439 --> 04:03:09,359
claro que você está se mexendo e

6074
04:03:09,359 --> 04:03:12,239
número de carregamento por favor coloque este sufixo f

6075
04:03:12,239 --> 04:03:13,920
aqui para o dobro você não precisa colocar

6076
04:03:13,920 --> 04:03:16,880
qualquer coisa porque é o padrão

6077
04:03:16,880 --> 04:03:19,520
Assumido pelo compilador, mas por um longo

6078
04:03:19,520 --> 04:03:22,160
O dobro você tem que sufixar isso com l

6079
04:03:22,160 --> 04:03:24,560
assim, então é isso que realmente somos

6080
04:03:24,560 --> 04:03:26,319
Aqui vimos que o

6081
04:03:26,319 --> 04:03:29,120
Precisão para float não é realmente suficiente

6082
04:03:29,120 --> 04:03:31,600
para muitas das computações que poderíamos

6083
04:03:31,600 --> 04:03:33,840
Queremos fazer em nosso c plus plus

6084
04:03:33,840 --> 04:03:36,479
Aplicações OK, falamos muito

6085
04:03:36,479 --> 04:03:39,040
sobre números de ponto flutuante, vamos cabeça

6086
04:03:39,040 --> 04:03:41,359
para código de estúdio visual e realmente jogar

6087
04:03:41,359 --> 04:03:44,319
com eles ok aqui estamos em nossa pasta

6088
04:03:44,319 --> 04:03:46,319
que vai conter o nosso projeto

6089
04:03:46,319 --> 04:03:48,160
O projeto será chamado de fracionário

6090
04:03:48,160 --> 04:03:51,600
números para que possamos copiar nossos arquivos

6091
04:03:51,600 --> 04:03:53,279
subir um pouco

6092
04:03:53,279 --> 04:03:55,760
e colocá-los dentro e eu vou subir

6093
04:03:55,760 --> 04:03:58,160
novamente e abra isso em estúdio visual

6094
04:03:58,160 --> 04:04:00,000
Código, vamos fechar o que quer que seja

6095
04:04:00,000 --> 04:04:02,720
Abrimos agora vamos fechar

6096
04:04:02,720 --> 04:04:04,720
pasta e vamos abrir o nosso

6097
04:04:04,720 --> 04:04:07,279
projeto em código de estúdio visual e nós somos

6098
04:04:07,279 --> 04:04:09,199
Vou fazer o habitual e remover coisas

6099
04:04:09,199 --> 04:04:11,439
Nós não precisamos aqui na primeira coisa que nós

6100
04:04:11,439 --> 04:04:14,160
Quer fazer é armazenar alguns carros alegóricos em

6101
04:04:14,160 --> 04:04:16,640
nosso programa vamos declarar e

6102
04:04:16,640 --> 04:04:18,880
inicialize alguns números de ponto flutuante

6103
04:04:18,880 --> 04:04:20,960
Temos número um número dois e número

6104
04:04:20,960 --> 04:04:23,680
Três e queremos deixar claro que

6105
04:04:23,680 --> 04:04:26,160
Os tamanhos são o que esperamos que sejamos

6106
04:04:26,160 --> 04:04:28,479
abrir uma janela do terminal aqui e

6107
04:04:28,479 --> 04:04:31,120
Nós vamos construir com gcc executar o

6108
04:04:31,120 --> 04:04:34,000
tarefa de soldar com gcc o mundo está indo

6109
04:04:34,000 --> 04:04:36,160
para sermos bem sucedidos, vamos chegar

6110
04:04:36,160 --> 04:04:37,920
Nosso terminal clique um pouco e

6111
04:04:37,920 --> 04:04:39,600
nós vamos digitar dir que nós vamos

6112
04:04:39,600 --> 04:04:42,239
Veja que um programa está em vigor se executarmos

6113
04:04:42,239 --> 04:04:44,479
Vamos ver esse tamanho de

6114
04:04:44,479 --> 04:04:48,399
float é 4 tamanho de duplo é oito e

6115
04:04:48,399 --> 04:04:51,760
tamanho do duplo longo é 16. isto é o que

6116
04:04:51,760 --> 04:04:54,160
esperávamos outra coisa que podemos fazer é

6117
04:04:54,160 --> 04:04:57,040
Tente brincar com a precisão destes

6118
04:04:57,040 --> 04:04:59,600
números e ver o que realmente podemos ir

6119
04:04:59,600 --> 04:05:01,439
fora com ok, então nós vamos

6120
04:05:01,439 --> 04:05:04,080
realmente colocar em um pedaço de código para jogar

6121
04:05:04,080 --> 04:05:06,239
Como isso, vamos adicionar uma configuração

6122
04:05:06,239 --> 04:05:09,279
para o nosso fluxo de esddc para que possamos

6123
04:05:09,279 --> 04:05:11,520
controlar a precisão, mas para isso

6124
04:05:11,520 --> 04:05:14,000
trabalho que precisamos trazer uma biblioteca que

6125
04:05:14,000 --> 04:05:17,040
é chamado i ou manip, então nós vamos

6126
04:05:17,040 --> 04:05:20,399
incluir que i ou manip e como eu sei

6127
04:05:20,399 --> 04:05:22,640
este eu costumo consultar o c plus mais

6128
04:05:22,640 --> 04:05:25,600
documentação padrão da biblioteca e você

6129
04:05:25,600 --> 04:05:27,199
não estão no ponto em que você pode

6130
04:05:27,199 --> 04:05:29,600
realmente entender isso agora, então estamos

6131
04:05:29,600 --> 04:05:32,720
Vou colocar essas coisas aqui

6132
04:05:32,720 --> 04:05:35,040
e explicando-os como nós vamos e eu fiz

6133
04:05:35,040 --> 04:05:38,319
o tipo aqui é io manip e você vê

6134
04:05:38,319 --> 04:05:39,120
que

6135
04:05:39,120 --> 04:05:41,120
Agora isso é reconhecido o nosso programa

6136
04:05:41,120 --> 04:05:43,680
Devemos compilar, então vamos tentar

6137
04:05:43,680 --> 04:05:45,520
solde para que possamos experimentar isso

6138
04:05:45,520 --> 04:05:47,840
vamos construir com o Gcc o mundo

6139
04:05:47,840 --> 04:05:49,920
Vai passar por nós podemos executar o nosso

6140
04:05:49,920 --> 04:05:52,479
programa, vamos fazer dur e claro

6141
04:05:52,479 --> 04:05:55,040
e galo para correr você vê que as coisas

6142
04:05:55,040 --> 04:05:57,840
começar a fazer sexo e se contarmos

6143
04:05:57,840 --> 04:06:01,120
O que temos aqui é um dois três

6144
04:06:01,120 --> 04:06:03,520
Quatro cinco seis sete só podemos

6145
04:06:03,520 --> 04:06:07,040
represente sete números com precisão

6146
04:06:07,040 --> 04:06:09,120
um flutuador e depois disso estamos apenas indo

6147
04:06:09,120 --> 04:06:11,120
ter lixo porque computador

6148
04:06:11,120 --> 04:06:13,199
Não pode realmente fazer sentido de tudo o que nós

6149
04:06:13,199 --> 04:06:15,120
ter depois do nosso

6150
04:06:15,120 --> 04:06:17,359
Sete dígitos que podemos legalmente

6151
04:06:17,359 --> 04:06:19,199
represente com a inundação para que o

6152
04:06:19,199 --> 04:06:21,359
precisão para o nosso número de ponto flutuante

6153
04:06:21,359 --> 04:06:23,920
Aqui estão sete eu realmente espero que isso faça

6154
04:06:23,920 --> 04:06:26,479
Sensato vamos verificar o número dois

6155
04:06:26,479 --> 04:06:29,279
Estamos usando o dobro, então a precisão deve

6156
04:06:29,279 --> 04:06:32,640
estar em torno de algo como 15. então nós estamos

6157
04:06:32,640 --> 04:06:35,279
colocando um número um a nove e

6158
04:06:35,279 --> 04:06:37,439
Estamos começando ao longo de zero um dois três

6159
04:06:37,439 --> 04:06:40,479
quatro cinco até zero novamente se olharmos para

6160
04:06:40,479 --> 04:06:43,439
o que temos na saída aqui que temos

6161
04:06:43,439 --> 04:06:45,600
um dois três quatro cinco seis sete oito

6162
04:06:45,600 --> 04:06:47,040
Nove zero

6163
04:06:47,040 --> 04:06:48,720
Um dois três

6164
04:06:48,720 --> 04:06:52,000
Quatro cinco seis e aqui começam as coisas

6165
04:06:52,000 --> 04:06:54,880
caindo depois do sexto ano e se

6166
04:06:54,880 --> 04:06:59,760
Nós contamos que vamos ter 1 2 3 4 5 6

6167
04:06:59,760 --> 04:07:07,040
7 8 9 10 11 12 13 14 15 16 17 dígitos

6168
04:07:07,040 --> 04:07:09,120
Esta é a precisão que estamos tendo isso

6169
04:07:09,120 --> 04:07:12,160
compilador para duplo 17 por isso é

6170
04:07:12,160 --> 04:07:14,960
algo em torno de 15 e devemos esperar

6171
04:07:14,960 --> 04:07:17,439
Ter algo mais do que isso ou em

6172
04:07:17,439 --> 04:07:20,319
o mesmo que o dobro com o longo

6173
04:07:20,319 --> 04:07:23,040
dobro, então se olharmos para isso você vê

6174
04:07:23,040 --> 04:07:25,359
que é um dois três quatro cinco seis

6175
04:07:25,359 --> 04:07:28,239
sete oito nove zero um dois três quatro

6176
04:07:28,239 --> 04:07:32,239
cinco seis sete oito nove, somos capazes de

6177
04:07:32,239 --> 04:07:36,000
represente até 20 e você pode ver que

6178
04:07:36,000 --> 04:07:38,159
longas folhas duplas até a

6179
04:07:38,159 --> 04:07:41,680
precisão de 20 que estabelecemos com

6180
04:07:41,680 --> 04:07:44,239
std set precisão aqui ok eu realmente

6181
04:07:44,239 --> 04:07:46,479
Espero agora que você tem uma ideia sobre

6182
04:07:46,479 --> 04:07:48,640
Essas Precisões que temos com o nosso

6183
04:07:48,640 --> 04:07:51,680
tipos de ponto flutuante em c plus mais

6184
04:07:51,680 --> 04:07:54,560
Programas outra coisa que eu quero que você veja

6185
04:07:54,560 --> 04:07:55,359
É

6186
04:07:55,359 --> 04:07:58,239
Que tipo de erros de estreitamento podemos obter

6187
04:07:58,239 --> 04:08:01,199
Se tentarmos inicializar com alguma coisa

6188
04:08:01,199 --> 04:08:03,439
que não pode realmente ser representado por um

6189
04:08:03,439 --> 04:08:05,760
número de ponto flutuante e aqui temos um

6190
04:08:05,760 --> 04:08:08,319
float é chamado número quatro e nós

6191
04:08:08,319 --> 04:08:10,159
estão tentando colocar em algo que é

6192
04:08:10,159 --> 04:08:12,560
maior do que podemos realmente caber nele tem

6193
04:08:12,560 --> 04:08:15,520
mais de sete dígitos, então um dois três

6194
04:08:15,520 --> 04:08:18,800
quatro cinco seis sete oito nove é

6195
04:08:18,800 --> 04:08:21,120
Mais de sete dígitos e nós

6196
04:08:21,120 --> 04:08:23,040
Espero ter um problema com isso

6197
04:08:23,040 --> 04:08:24,840
porque estamos usando braced

6198
04:08:24,840 --> 04:08:27,920
A inicialização, vamos tentar construir isso

6199
04:08:27,920 --> 04:08:30,720
com gcc nós vamos fazer aquilo e isso

6200
04:08:30,720 --> 04:08:32,800
vai funcionar com sucesso, então isso é

6201
04:08:32,800 --> 04:08:35,760
indo silenciosamente cortar o nosso número se

6202
04:08:35,760 --> 04:08:37,439
Nós tentamos imprimi-lo nós vamos

6203
04:08:37,439 --> 04:08:40,960
Diga o esddc para fora o número quatro e nós vamos

6204
04:08:40,960 --> 04:08:43,120
para o mundo novamente executar o mundo do tubo de ensaio

6205
04:08:43,120 --> 04:08:45,760
para que nossas mudanças sejam tomadas

6206
04:08:45,760 --> 04:08:47,920
Efeito eu vou fazer dur e fazer

6207
04:08:47,920 --> 04:08:49,840
galo e isso vai imprimir o nosso

6208
04:08:49,840 --> 04:08:52,000
número que você vai ver isso depois

6209
04:08:52,000 --> 04:08:53,359
Os zeros

6210
04:08:53,359 --> 04:08:55,199
Temos lixo que nosso número tem sido

6211
04:08:55,199 --> 04:08:57,760
basicamente cortado e isso é lixo

6212
04:08:57,760 --> 04:08:59,680
Porque não podemos realmente representar isso

6213
04:08:59,680 --> 04:09:02,000
com o duplo 16 aqui foi

6214
04:09:02,000 --> 04:09:03,760
cortados porque não podemos basicamente

6215
04:09:03,760 --> 04:09:05,840
Representar isso com o ponto flutuante

6216
04:09:05,840 --> 04:09:08,000
número se mudarmos para dobrar isso

6217
04:09:08,000 --> 04:09:10,239
Provavelmente nos dará o que nós

6218
04:09:10,239 --> 04:09:13,279
espere assim vamos correr novamente mundo com gcc

6219
04:09:13,279 --> 04:09:15,199
O mundo vai ser bom se corrermos

6220
04:09:15,199 --> 04:09:17,760
O programa que vai nos mostrar o

6221
04:09:17,760 --> 04:09:19,840
A mesma coisa, tudo isso é realmente bom

6222
04:09:19,840 --> 04:09:22,080
A aprendizagem muda por que estamos tendo o

6223
04:09:22,080 --> 04:09:24,239
Os mesmos resultados que

6224
04:09:24,239 --> 04:09:27,439
antes mesmo se nós mudamos o tipo para

6225
04:09:27,439 --> 04:09:29,920
Dupla tente pensar sobre isso a razão

6226
04:09:29,920 --> 04:09:34,000
é o sufixo aqui ainda está dizendo f e

6227
04:09:34,000 --> 04:09:36,239
isso será armazenado como float em

6228
04:09:36,239 --> 04:09:38,720
Memória, então se queremos que isso realmente seja

6229
04:09:38,720 --> 04:09:41,199
tratado como um duplo que podemos tirar

6230
04:09:41,199 --> 04:09:42,479
O flutuador aqui

6231
04:09:42,479 --> 04:09:44,560
e se construirmos novamente e executarmos o

6232
04:09:44,560 --> 04:09:46,479
Aplicação agora você vai ver isso

6233
04:09:46,479 --> 04:09:49,520
Vemos os 23 que estão basicamente sendo

6234
04:09:49,520 --> 04:09:52,319
corretamente armazenado como um duplo este é um

6235
04:09:52,319 --> 04:09:53,840
Ainda bem que você deve manter

6236
04:09:53,840 --> 04:09:56,800
mente se você não colocar em seus sufixos

6237
04:09:56,800 --> 04:09:58,399
Aqui o número vai ser

6238
04:09:58,399 --> 04:10:00,560
Interpretado como o duplo

6239
04:10:00,560 --> 04:10:03,439
Agora espero que você veja isso se você realmente

6240
04:10:03,439 --> 04:10:06,399
Tente colocar mais do que o seu ponto flutuante

6241
04:10:06,399 --> 04:10:07,920
pode lidar com

6242
04:10:07,920 --> 04:10:09,920
O número vai ser cortado

6243
04:10:09,920 --> 04:10:12,399
E somente a precisão de que ele pode

6244
04:10:12,399 --> 04:10:14,640
alça vai ser armazenado em i esperança

6245
04:10:14,640 --> 04:10:16,960
Isso faz sentido e você vê que

6246
04:10:16,960 --> 04:10:19,279
O comportamento dos números é realmente diferente

6247
04:10:19,279 --> 04:10:22,080
Temos o erro do compilador quando tentamos

6248
04:10:22,080 --> 04:10:24,720
estreitamento da conversão com inteiros

6249
04:10:24,720 --> 04:10:27,199
mas agora está silenciosamente cortando o nosso

6250
04:10:27,199 --> 04:10:29,680
número se tentarmos usar funcional

6251
04:10:29,680 --> 04:10:31,520
notação eu acho que nós vamos conseguir o

6252
04:10:31,520 --> 04:10:34,560
mesmo resultado e mudar isso de volta para a

6253
04:10:34,560 --> 04:10:37,520
flutuar e usar flutuar aqui e se nós

6254
04:10:37,520 --> 04:10:40,640
ambos novamente vamos para a tarefa de corrida terminal

6255
04:10:40,640 --> 04:10:43,920
usar gcc nós vamos executar isso

6256
04:10:43,920 --> 04:10:46,239
Vamos correr o galo e você vê que nós

6257
04:10:46,239 --> 04:10:49,279
obter os mesmos resultados nossos 23 são picados

6258
04:10:49,279 --> 04:10:52,080
Aqui também podemos usar a tarefa

6259
04:10:52,080 --> 04:10:54,080
notação aqui, assim como fizemos com

6260
04:10:54,080 --> 04:10:57,199
inteiros e isso vai fazer exatamente

6261
04:10:57,199 --> 04:10:59,040
a mesma coisa que vai cortar

6262
04:10:59,040 --> 04:11:01,520
o 23 aqui e nós vamos ter alguns

6263
04:11:01,520 --> 04:11:04,479
lixo que é 16 neste caso, se nós

6264
04:11:04,479 --> 04:11:06,319
soldar a arma o mundo vai embora

6265
04:11:06,319 --> 04:11:08,800
E se corrermos, vamos ver

6266
04:11:08,800 --> 04:11:10,880
como está aqui bem estreitando

6267
04:11:10,880 --> 04:11:12,880
As conversões são algo que você deve ser

6268
04:11:12,880 --> 04:11:15,439
Consciente de quando armazena a sua flutuação

6269
04:11:15,439 --> 04:11:17,279
números de pontos e você deve realmente

6270
04:11:17,279 --> 04:11:19,680
Lembre-se de colocar seus sufixos aqui

6271
04:11:19,680 --> 04:11:21,920
e outra coisa que temos visto que nós

6272
04:11:21,920 --> 04:11:24,159
deveria realmente brincar com é científico

6273
04:11:24,159 --> 04:11:25,439
A notação

6274
04:11:25,439 --> 04:11:27,359
Como o comentário aqui diz o que temos

6275
04:11:27,359 --> 04:11:31,199
Visto até agora em números de ponto flutuante é

6276
04:11:31,199 --> 04:11:33,920
fixa notação é o que temos aqui

6277
04:11:33,920 --> 04:11:37,040
mas também podemos usar notação científica

6278
04:11:37,040 --> 04:11:39,199
Que é exatamente o que descrevemos em

6279
04:11:39,199 --> 04:11:41,680
Os slides e o que temos aqui para

6280
04:11:41,680 --> 04:11:45,600
O exemplo é e8 e significa que somos

6281
04:11:45,600 --> 04:11:48,399
vai multiplicar esse número aqui

6282
04:11:48,399 --> 04:11:51,279
com 10 para o poder de 8. se você for

6283
04:11:51,279 --> 04:11:53,680
Aqui temos o número 9, então temos

6284
04:11:53,680 --> 04:11:56,479
3.498

6285
04:11:56,479 --> 04:12:00,000
e nós temos e menos 11 e o que isso é

6286
04:12:00,000 --> 04:12:02,880
indo fazer é multiplicar com 10 para a

6287
04:12:02,880 --> 04:12:05,840
poder de menos 11. é assim que eu posso

6288
04:12:05,840 --> 04:12:08,080
representar isso aqui e podemos imprimir

6289
04:12:08,080 --> 04:12:10,000
esses números para realmente brincar com

6290
04:12:10,000 --> 04:12:12,239
para fazer a diferença com o que nós

6291
04:12:12,239 --> 04:12:14,560
Eu tenho feito antes de nós vamos fazer

6292
04:12:14,560 --> 04:12:18,319
sddc out e colocar uma linha divisória aqui

6293
04:12:18,319 --> 04:12:20,159
Esta é uma maneira de fazermos isso para que sejamos

6294
04:12:20,159 --> 04:12:22,560
indo para fazer stdndl

6295
04:12:22,560 --> 04:12:24,399
nós vamos soldar isso para que vamos

6296
04:12:24,399 --> 04:12:27,520
para executar o mundo anexado com gcc 10

6297
04:12:27,520 --> 04:12:29,600
O mundo vai passar se nós

6298
04:12:29,600 --> 04:12:32,159
do galo vamos ver que

6299
04:12:32,159 --> 04:12:35,120
O número aqui número cinco é o que nós

6300
04:12:35,120 --> 04:12:39,279
Esperar o número seis é a mesma coisa, mas

6301
04:12:39,279 --> 04:12:42,399
Usamos notação científica para fazer isso

6302
04:12:42,399 --> 04:12:44,080
porque nós tomamos esse número e

6303
04:12:44,080 --> 04:12:46,880
multiplicado por 10 ao poder de oito

6304
04:12:46,880 --> 04:12:48,800
O número sete deve ser quase o mesmo

6305
04:12:48,800 --> 04:12:51,840
coisa, mas o mais baixo 23 aqui vai

6306
04:12:51,840 --> 04:12:54,080
ser cortado fora porque nós não temos

6307
04:12:54,080 --> 04:12:56,239
Especificou-o que estamos apenas multiplicando com

6308
04:12:56,239 --> 04:12:58,560
10 para o poder de 8, então é por isso que nós

6309
04:12:58,560 --> 04:13:01,920
Tenho 0 0 aqui espero que faça sentido

6310
04:13:01,920 --> 04:13:04,159
e se você olhar para o número 8 você vê que

6311
04:13:04,159 --> 04:13:06,159
nós o armazenamos assim sem usar

6312
04:13:06,159 --> 04:13:08,560
notação científica que usamos fixa

6313
04:13:08,560 --> 04:13:11,120
notação, mas no terminal está indo

6314
04:13:11,120 --> 04:13:13,920
ser impresso em notação científica

6315
04:13:13,920 --> 04:13:15,920
e isso pode ser muito legal o principal

6316
04:13:15,920 --> 04:13:19,520
O uso para notação científica é fazer

6317
04:13:19,520 --> 04:13:22,479
Sensação de números que são realmente enormes, então

6318
04:13:22,479 --> 04:13:24,239
A maneira como você interpreta isso, você está indo

6319
04:13:24,239 --> 04:13:25,359
A sua forma de

6320
04:13:25,359 --> 04:13:27,840
mover esses números após o decimal

6321
04:13:27,840 --> 04:13:30,239
pontos com 0 na frente e é

6322
04:13:30,239 --> 04:13:32,000
basicamente vai ser assim, então se

6323
04:13:32,000 --> 04:13:33,920
Você conta os zeros que você tem aqui estamos

6324
04:13:33,920 --> 04:13:36,399
Vai ter 1 2

6325
04:13:36,399 --> 04:13:42,239
3 4 5 6 7 8 9 10 e 11 vai ser

6326
04:13:42,239 --> 04:13:44,319
diretamente depois de três e você vai

6327
04:13:44,319 --> 04:13:46,560
Veja o número aqui é isso que queremos dizer

6328
04:13:46,560 --> 04:13:49,760
e o número nove foi explicitamente armazenado em

6329
04:13:49,760 --> 04:13:52,080
usando notação científica e você vê

6330
04:13:52,080 --> 04:13:54,080
que temos a mesma coisa que você pode jogar

6331
04:13:54,080 --> 04:13:56,239
com essas coisas e realmente faz sentido

6332
04:13:56,239 --> 04:13:59,520
deles e novamente não especificamos nenhum

6333
04:13:59,520 --> 04:14:01,680
sufixo aqui, então estes vão ser

6334
04:14:01,680 --> 04:14:04,319
interpretado como duplas, mas isso não é um

6335
04:14:04,319 --> 04:14:06,640
problema porque são duplas aqui

6336
04:14:06,640 --> 04:14:08,640
Tudo bem, estamos fazendo algum progresso com

6337
04:14:08,640 --> 04:14:11,120
Esta palestra que é um pouco longa

6338
04:14:11,120 --> 04:14:13,040
A última coisa que queremos fazer é jogar

6339
04:14:13,040 --> 04:14:15,359
com infinito e nan

6340
04:14:15,359 --> 04:14:17,040
Vamos colocar uma mensagem aqui para dizer

6341
04:14:17,040 --> 04:14:18,960
O que queremos fazer e vamos

6342
04:14:18,960 --> 04:14:20,479
Tenho o número 10 que vai ser

6343
04:14:20,479 --> 04:14:22,319
A certeza que teremos o número 11

6344
04:14:22,319 --> 04:14:24,800
que será zero número 12 é

6345
04:14:24,800 --> 04:14:26,560
Também vai ser zero

6346
04:14:26,560 --> 04:14:30,000
Se pegarmos 10 e dividirmos isso com 11

6347
04:14:30,000 --> 04:14:32,239
nós vamos ter o infinito porque nós

6348
04:14:32,239 --> 04:14:35,359
estão dividindo um número flutuante com zero

6349
04:14:35,359 --> 04:14:37,040
Se tentarmos imprimir isso, vamos

6350
04:14:37,040 --> 04:14:38,560
para obter o infinito

6351
04:14:38,560 --> 04:14:40,399
e nós vamos ter o infinito para isso

6352
04:14:40,399 --> 04:14:42,479
resultado aqui porque estamos tentando adicionar

6353
04:14:42,479 --> 04:14:44,880
algo pequeno para o infinito que é

6354
04:14:44,880 --> 04:14:47,199
Algo realmente grande e se todos nós

6355
04:14:47,199 --> 04:14:49,279
Tentando dividir zero com zero em

6356
04:14:49,279 --> 04:14:50,479
ponto flutuante

6357
04:14:50,479 --> 04:14:52,080
nós vamos conseguir o que é chamado

6358
04:14:52,080 --> 04:14:54,080
número impertinente e se imprimirmos isso

6359
04:14:54,080 --> 04:14:55,920
nós vamos ver isso em um minuto

6360
04:14:55,920 --> 04:14:59,920
Vamos construir isso com gcc que vamos

6361
04:14:59,920 --> 04:15:02,319
soldar com sucesso, vamos limpar isso

6362
04:15:02,319 --> 04:15:05,439
para que não tenhamos barulho aqui e

6363
04:15:05,439 --> 04:15:07,600
nós vamos correr o galo e você vê

6364
04:15:07,600 --> 04:15:11,199
aqui diz infinito e nenhum que é

6365
04:15:11,199 --> 04:15:12,720
O que dissemos aqui

6366
04:15:12,720 --> 04:15:14,720
E se descermos aqui está dizendo

6367
04:15:14,720 --> 04:15:17,920
número 10 dividido pelo número 11 e

6368
04:15:17,920 --> 04:15:20,720
O número 11 é zero, você vê que aqui é

6369
04:15:20,720 --> 04:15:23,760
vai produzir infinito se adicionarmos cinco

6370
04:15:23,760 --> 04:15:26,640
ao infinito, vamos ter infinito

6371
04:15:26,640 --> 04:15:29,120
e se tentarmos dividir um zero por um zero

6372
04:15:29,120 --> 04:15:31,600
nós não vamos ter nenhum que seja realmente

6373
04:15:31,600 --> 04:15:33,199
uma maneira de te dizer que você está fazendo

6374
04:15:33,199 --> 04:15:34,960
Algo errado você realmente deveria estar

6375
04:15:34,960 --> 04:15:35,920
De forma cuidadosa

6376
04:15:35,920 --> 04:15:37,600
Uma outra coisa que eu quero que você veja é

6377
04:15:37,600 --> 04:15:40,319
que se você transformar esses cinco em um menos

6378
04:15:40,319 --> 04:15:42,640
Cinco e construir novamente nós vamos

6379
04:15:42,640 --> 04:15:45,279
construir com gcc e vamos correr

6380
04:15:45,279 --> 04:15:46,960
Este galo

6381
04:15:46,960 --> 04:15:49,520
nós vamos ter menos infinito, então se

6382
04:15:49,520 --> 04:15:52,239
você divide um número positivo com zero

6383
04:15:52,239 --> 04:15:54,319
Você vai ter um infinito positivo

6384
04:15:54,319 --> 04:15:56,479
e se você dividir um número negativo com

6385
04:15:56,479 --> 04:15:58,319
infinito você vai ficar negativo

6386
04:15:58,319 --> 04:16:00,800
infinito e isso é o que vemos aqui

6387
04:16:00,800 --> 04:16:02,399
Isso é realmente tudo o que nos prossamos fazer em

6388
04:16:02,399 --> 04:16:03,920
Esta palestra espero que você a tenha encontrado

6389
04:16:03,920 --> 04:16:06,399
interessante e novamente a grande mensagem é

6390
04:16:06,399 --> 04:16:08,479
que qualquer tipo de dados que você vai ser

6391
04:16:08,479 --> 04:16:11,439
manuseio em seu programa c plus mais é

6392
04:16:11,439 --> 04:16:13,920
Em última análise, será armazenado como uns

6393
04:16:13,920 --> 04:16:16,000
e zeros na memória e nós aprendemos

6394
04:16:16,000 --> 04:16:17,920
sobre números de ponto flutuante flutuam

6395
04:16:17,920 --> 04:16:20,080
duplo e longo e eles têm estes

6396
04:16:20,080 --> 04:16:22,080
propriedades que você vê aqui e você deve

6397
04:16:22,080 --> 04:16:24,479
Use-os com isso em mente de outra forma

6398
04:16:24,479 --> 04:16:26,319
Você vai ter problemas com seu

6399
04:16:26,319 --> 04:16:28,560
A precisão certifique-se de que você está usando o

6400
04:16:28,560 --> 04:16:30,640
precisão correta que você precisa em seu

6401
04:16:30,640 --> 04:16:32,640
Programa que vamos parar por aqui

6402
04:16:32,640 --> 04:16:34,560
Esta palestra é a próxima que vamos

6403
04:16:34,560 --> 04:16:37,520
Tente aprender sobre booleans ir em frente

6404
04:16:37,520 --> 04:16:40,159
e terminar aqui e encontrar-me lá dentro

6405
04:16:40,159 --> 04:16:41,840
Esta palestra vamos aprender sobre

6406
04:16:41,840 --> 04:16:44,880
booleans booleans são tipos que podem

6407
04:16:44,880 --> 04:16:47,600
armazenar dois estados em c mais parcelas que pode

6408
04:16:47,600 --> 04:16:51,040
armazenar verdadeiro ou falso e nós podemos

6409
04:16:51,040 --> 04:16:53,359
Use isso para realmente fazer decisões em nosso

6410
04:16:53,359 --> 04:16:55,279
programa se você olhar para o programa nós

6411
04:16:55,279 --> 04:16:57,680
Temos aqui duas variáveis declaradas

6412
04:16:57,680 --> 04:16:59,840
O tipo de dados é bull

6413
04:16:59,840 --> 04:17:02,159
e um é chamado de luz vermelha, o outro é

6414
04:17:02,159 --> 04:17:03,760
Chamada de luz verde

6415
04:17:03,760 --> 04:17:06,720
e nós temos verdadeiro e falso dentro de um

6416
04:17:06,720 --> 04:17:09,120
O que podemos fazer em c plus plus é fazer

6417
04:17:09,120 --> 04:17:12,239
decisões que podemos dizer se a luz vermelha é

6418
04:17:12,239 --> 04:17:13,439
Verdadeiro nós podemos

6419
04:17:13,439 --> 04:17:16,319
imprimir uma mensagem que diz parar e se

6420
04:17:16,319 --> 04:17:19,199
Não é vermelho, podemos imprimir uma mensagem que

6421
04:17:19,199 --> 04:17:21,600
Diz que podemos fazer isso e

6422
04:17:21,600 --> 04:17:24,080
booleans são realmente usados desta forma para

6423
04:17:24,080 --> 04:17:26,399
tomar decisões em seu c plus plus

6424
04:17:26,399 --> 04:17:29,040
Programa sobre o qual não aprendemos

6425
04:17:29,040 --> 04:17:31,760
se declarações neste curso, mas eu sou

6426
04:17:31,760 --> 04:17:33,920
jogando isso aqui para realmente dirigir

6427
04:17:33,920 --> 04:17:36,080
o ponto de casa que podemos usar isso para

6428
04:17:36,080 --> 04:17:38,640
tomar decisões em nosso programa aqui em baixo

6429
04:17:38,640 --> 04:17:40,640
Temos outra maneira de fazer isso nós

6430
04:17:40,640 --> 04:17:42,880
pode realmente usar a variável em si

6431
04:17:42,880 --> 04:17:46,239
sem verificar se é igual a verdade

6432
04:17:46,239 --> 04:17:48,479
ou falso e nós vamos conseguir o

6433
04:17:48,479 --> 04:17:50,960
A mesma mensagem aqui é que se

6434
04:17:50,960 --> 04:17:53,040
Luz verde é verdade, vamos dizer

6435
04:17:53,040 --> 04:17:55,359
A luz é verde se não somos

6436
04:17:55,359 --> 04:17:57,279
Vamos dizer que a luz não é verde você

6437
04:17:57,279 --> 04:17:59,600
pode fazer algo assim e novamente

6438
04:17:59,600 --> 04:18:02,080
O grande ponto aqui é que os booleans datam

6439
04:18:02,080 --> 04:18:05,199
Os tipos são usados para armazenar dois estados verdadeiros

6440
04:18:05,199 --> 04:18:07,760
ou falso em seu programa c plus plus

6441
04:18:07,760 --> 04:18:11,120
Tudo bem por padrão se você imprimir um boolean

6442
04:18:11,120 --> 04:18:13,520
que tem dois nele você vai ficar

6443
04:18:13,520 --> 04:18:15,680
Verdade e isso é o que você vê aqui e

6444
04:18:15,680 --> 04:18:18,640
Se você imprimir um que tem zero nele

6445
04:18:18,640 --> 04:18:20,800
Você vai ficar falso, podemos mudar

6446
04:18:20,800 --> 04:18:22,720
que com um ambiente especial que podemos

6447
04:18:22,720 --> 04:18:25,840
aplique ao nosso fluxo std out e você faz

6448
04:18:25,840 --> 04:18:28,720
que assim com std bull alpha e

6449
04:18:28,720 --> 04:18:29,840
nós vamos jogar com isso em um

6450
04:18:29,840 --> 04:18:31,279
Minuto que você vai ver

6451
04:18:31,279 --> 04:18:33,359
se tentarmos imprimir com esta configuração

6452
04:18:33,359 --> 04:18:35,920
Aplicado que vamos ver true em false

6453
04:18:35,920 --> 04:18:38,880
e não c 0 e 1 como fizemos antes

6454
04:18:38,880 --> 04:18:40,080
nós vamos jogar com isso em um

6455
04:18:40,080 --> 04:18:42,159
minuto e você vai ver outro

6456
04:18:42,159 --> 04:18:44,319
O que você deve saber é que booleans

6457
04:18:44,319 --> 04:18:45,680
Ocupar

6458
04:18:45,680 --> 04:18:48,720
8 bits na memória que eles ocupam um todo

6459
04:18:48,720 --> 04:18:50,800
mordadela para que você possa pensar que isso é

6460
04:18:50,800 --> 04:18:53,520
desperdício e é apenas com a quantidade

6461
04:18:53,520 --> 04:18:55,840
de memória que temos hoje que isto é

6462
04:18:55,840 --> 04:18:58,479
Realmente não é um grande problema, mas se você é

6463
04:18:58,479 --> 04:19:00,960
trabalhar em um dispositivo onde a memória está

6464
04:19:00,960 --> 04:19:03,120
Realmente um problema existem técnicas

6465
04:19:03,120 --> 04:19:05,439
você pode usar para embalar ainda mais dados em um

6466
04:19:05,439 --> 04:19:07,600
byte e vamos aprender sobre isso

6467
04:19:07,600 --> 04:19:10,080
mais tarde no curso ok, então isso é

6468
04:19:10,080 --> 04:19:12,880
realmente tudo que eu tenho a dizer sobre booleans

6469
04:19:12,880 --> 04:19:14,960
nós vamos para o código do estúdio visual

6470
04:19:14,960 --> 04:19:17,680
e jogar com eles em código bem aqui eu

6471
04:19:17,680 --> 04:19:20,640
Estou na pasta para o meu projeto aqui

6472
04:19:20,640 --> 04:19:22,560
Vou fazer o habitual e copiar o

6473
04:19:22,560 --> 04:19:23,760
Arquivos sobre

6474
04:19:23,760 --> 04:19:26,000
e eu vou entrar no meu projeto em

6475
04:19:26,000 --> 04:19:28,800
booleans eu vou subir e abrir

6476
04:19:28,800 --> 04:19:31,040
isso no código do estúdio visual eu vou

6477
04:19:31,040 --> 04:19:33,520
para fechar a pasta atual abra o novo

6478
04:19:33,520 --> 04:19:35,920
um e navegar para o meu projeto este é

6479
04:19:35,920 --> 04:19:38,319
vai abrir no código do estúdio visual

6480
04:19:38,319 --> 04:19:40,239
E eu vou fechar as boas-vindas

6481
04:19:40,239 --> 04:19:42,560
tela aqui eu não preciso mais dele

6482
04:19:42,560 --> 04:19:45,279
Então eu vou remover o que eu não preciso

6483
04:19:45,279 --> 04:19:48,000
e nós vamos jogar com o exato

6484
04:19:48,000 --> 04:19:50,720
código que tínhamos nos slides que nós somos

6485
04:19:50,720 --> 04:19:52,880
vai declarar duas variáveis uma é

6486
04:19:52,880 --> 04:19:54,880
Vai ser luz vermelha o outro está indo

6487
04:19:54,880 --> 04:19:56,800
para ser luz verde eles vão ser

6488
04:19:56,800 --> 04:19:59,199
booleans e em luz vermelha, vamos

6489
04:19:59,199 --> 04:20:02,159
Armazenar um verdadeiro e a história falsa em verde

6490
04:20:02,159 --> 04:20:04,239
Luz e podemos tomar uma decisão como

6491
04:20:04,239 --> 04:20:06,720
Então tente adivinhar o que vamos

6492
04:20:06,720 --> 04:20:09,600
planta neste programa vamos tentar

6493
04:20:09,600 --> 04:20:12,640
e decidir e dizer se a luz vermelha é

6494
04:20:12,640 --> 04:20:14,800
Verdade que vamos imprimir parada

6495
04:20:14,800 --> 04:20:16,800
Se não é verdade, vamos cair

6496
04:20:16,800 --> 04:20:19,120
Este bloco aqui e dizer

6497
04:20:19,120 --> 04:20:22,319
passarmos se olharmos para o nosso programa em

6498
04:20:22,319 --> 04:20:25,520
luz vermelha temos um verdadeiro, então isso deve

6499
04:20:25,520 --> 04:20:27,760
Realmente ganhar e devemos entrar nisso

6500
04:20:27,760 --> 04:20:30,319
bloco aqui eu espero que isso faça sentido assim

6501
04:20:30,319 --> 04:20:32,479
Vamos tentar construir este programa para ver

6502
04:20:32,479 --> 04:20:34,800
que realmente funciona, então nós vamos

6503
04:20:34,800 --> 04:20:36,960
construir com o gcc que vamos correr

6504
04:20:36,960 --> 04:20:39,600
nosso programa e nosso terminal acabou de ir

6505
04:20:39,600 --> 04:20:41,760
Vamos criar um novo no

6506
04:20:41,760 --> 04:20:43,120
Grande negócio

6507
04:20:43,120 --> 04:20:46,800
E uh se fizermos o dir, vamos ver

6508
04:20:46,800 --> 04:20:48,560
laoster.exe

6509
04:20:48,560 --> 04:20:51,600
nós corremos, vai dizer parar bem, então

6510
04:20:51,600 --> 04:20:54,800
na luz vermelha nós temos verdadeiro o teste é

6511
04:20:54,800 --> 04:20:56,640
indo para ter sucesso aqui e nós vamos

6512
04:20:56,640 --> 04:20:59,199
cair neste bloco e dizer parar eu espero

6513
04:20:59,199 --> 04:21:01,520
Isso faz sentido, você pode tentar armazenar um

6514
04:21:01,520 --> 04:21:03,120
falso aqui em

6515
04:21:03,120 --> 04:21:06,800
e ambos novamente indo para o mundo com gcc

6516
04:21:06,800 --> 04:21:09,439
Se executarmos este programa agora, ele vai

6517
04:21:09,439 --> 04:21:12,159
Diga que passe porque a luz vermelha não é

6518
04:21:12,159 --> 04:21:14,399
Verdadei mais, isso é realmente o que queremos dizer

6519
04:21:14,399 --> 04:21:16,880
Quando dizemos que podemos tomar decisões

6520
04:21:16,880 --> 04:21:19,840
baseado em booleans em nosso c plus plus

6521
04:21:19,840 --> 04:21:22,880
Código também podemos tentar outro exemplo

6522
04:21:22,880 --> 04:21:26,000
nós vamos dizer se a luz verde é

6523
04:21:26,000 --> 04:21:26,880
Verdadeiro

6524
04:21:26,880 --> 04:21:28,880
nós vamos dizer que a luz é verde se

6525
04:21:28,880 --> 04:21:30,560
Não é nós vamos dizer que a luz é

6526
04:21:30,560 --> 04:21:32,399
Não verde e esta é outra forma que nós

6527
04:21:32,399 --> 04:21:35,680
pode usar em vez de digitar o todo

6528
04:21:35,680 --> 04:21:36,560
uma coisa

6529
04:21:36,560 --> 04:21:39,359
Comparando a luz vermelha com a verdade aqui e

6530
04:21:39,359 --> 04:21:40,800
Mais uma vez vamos aprender sobre tudo

6531
04:21:40,800 --> 04:21:43,040
Essas comparações aqui

6532
04:21:43,040 --> 04:21:45,760
É só porque eu pensei que

6533
04:21:45,760 --> 04:21:48,000
falando sobre touros sem mostrar

6534
04:21:48,000 --> 04:21:50,560
Testes como este realmente não vão

6535
04:21:50,560 --> 04:21:53,439
conduzir o ponto para casa para você, então tente

6536
04:21:53,439 --> 04:21:55,520
Entenrece isso como testes simples que você pode

6537
04:21:55,520 --> 04:21:57,920
fazer em matemática se um valor é verdadeiro eu sou

6538
04:21:57,920 --> 04:21:59,920
Vou fazer algo se não for verdade

6539
04:21:59,920 --> 04:22:01,840
Eu vou fazer outra coisa que isto é

6540
04:22:01,840 --> 04:22:04,000
O que estamos fazendo aqui está bem este programa

6541
04:22:04,000 --> 04:22:06,159
Aqui vai verificar se o verde

6542
04:22:06,159 --> 04:22:08,560
A luz é verdadeira, então vamos olhar

6543
04:22:08,560 --> 04:22:11,120
Aqui luz verde não é verdade, então nós

6544
04:22:11,120 --> 04:22:14,159
deve cair aqui e imprimir esta mensagem

6545
04:22:14,159 --> 04:22:16,319
Que a luz não é verde

6546
04:22:16,319 --> 04:22:18,560
Vamos construir o programa que o mundo é

6547
04:22:18,560 --> 04:22:20,720
indo para passar, vamos correr

6548
04:22:20,720 --> 04:22:21,520
Isto é

6549
04:22:21,520 --> 04:22:23,520
e você vai ver passar e

6550
04:22:23,520 --> 04:22:25,760
A luz não é verde isto é o que nós

6551
04:22:25,760 --> 04:22:27,359
Tenho aqui outra coisa que podemos realmente

6552
04:22:27,359 --> 04:22:30,319
Tentar ver é a quantidade de memória que

6553
04:22:30,319 --> 04:22:33,439
um booleano assume para que possamos usar tamanhoof

6554
04:22:33,439 --> 04:22:36,239
para fazer isso, já vimos isso antes, se

6555
04:22:36,239 --> 04:22:39,040
nós construímos com gcc vamos embora

6556
04:22:39,040 --> 04:22:39,920
Por meio de

6557
04:22:39,920 --> 04:22:42,000
e nós podemos executar o nosso programa para realmente

6558
04:22:42,000 --> 04:22:43,840
Esta mensagem e você vai ver

6559
04:22:43,840 --> 04:22:46,319
que o touro vai realmente assumir

6560
04:22:46,319 --> 04:22:48,640
Um byte na memória é o que vimos

6561
04:22:48,640 --> 04:22:50,960
nos slides outra coisa que pode ser

6562
04:22:50,960 --> 04:22:53,760
Realmente confuso é imprimir para fora boolean

6563
04:22:53,760 --> 04:22:56,640
valores, por exemplo, aqui estamos tentando

6564
04:22:56,640 --> 04:22:59,439
imprimir grande luz e luz verde, vamos

6565
04:22:59,439 --> 04:23:01,279
Vai subir e realmente mudá-los um pouco

6566
04:23:01,279 --> 04:23:04,399
bit, por exemplo, tome luz verde aqui

6567
04:23:04,399 --> 04:23:06,080
E torná-lo verdadeiro

6568
04:23:06,080 --> 04:23:08,560
e nós vamos descer de novo e

6569
04:23:08,560 --> 04:23:11,359
Aqui estamos tentando imprimi-los vermelho

6570
04:23:11,359 --> 04:23:13,680
A luz vai imprimir qualquer valor

6571
04:23:13,680 --> 04:23:15,920
armazenamos então e a luz verde é

6572
04:23:15,920 --> 04:23:17,520
Vou armazenar qualquer valor que tenhamos

6573
04:23:17,520 --> 04:23:19,920
armazenado e novamente verdadeiro será

6574
04:23:19,920 --> 04:23:21,760
Impresso fora como um

6575
04:23:21,760 --> 04:23:24,080
e falso vai ser impresso como

6576
04:23:24,080 --> 04:23:26,640
um zero vamos tentar construir isso que somos

6577
04:23:26,640 --> 04:23:29,840
vou construir com o nosso compilador gcc

6578
04:23:29,840 --> 04:23:31,600
O mundo vai ser bom, vamos

6579
04:23:31,600 --> 04:23:33,680
Executar isso e você vai ver aquilo

6580
04:23:33,680 --> 04:23:36,640
A luz vermelha é zero porque temos um

6581
04:23:36,640 --> 04:23:38,319
O sol aqui

6582
04:23:38,319 --> 04:23:41,040
E a luz verde vai ser uma

6583
04:23:41,040 --> 04:23:44,720
Porque nós não temos um verdadeiro aqui se você

6584
04:23:44,720 --> 04:23:47,199
Tente imprimir variáveis booleanas

6585
04:23:47,199 --> 04:23:48,960
você vai ter um e zero por

6586
04:23:48,960 --> 04:23:51,600
padrão se você realmente quer ver verdade

6587
04:23:51,600 --> 04:23:53,439
e falso há uma configuração especial que você

6588
04:23:53,439 --> 04:23:56,399
pode aplicar a htdc para fora e você faz isso por

6589
04:23:56,399 --> 04:24:01,040
dizendo stdc para fora std bull

6590
04:24:01,040 --> 04:24:03,600
Alfa e você faz assim

6591
04:24:03,600 --> 04:24:06,479
E se você tentar imprimir novamente, nós somos

6592
04:24:06,479 --> 04:24:08,479
vai ficar verdadeiro e falso agora

6593
04:24:08,479 --> 04:24:10,800
OK, vamos tentar imprimir novamente e nós somos

6594
04:24:10,800 --> 04:24:13,840
vou trabalhar isso com gcc e nós somos

6595
04:24:13,840 --> 04:24:15,279
indo para executar isso

6596
04:24:15,279 --> 04:24:17,840
E agora você vê que vemos que a luz vermelha é

6597
04:24:17,840 --> 04:24:20,399
A falsa luz verde é verdadeira

6598
04:24:20,399 --> 04:24:22,640
Isso é realmente tudo o que eu tinha que compartilhar sobre

6599
04:24:22,640 --> 04:24:25,760
booleans nesta palestra eu realmente espero

6600
04:24:25,760 --> 04:24:28,399
ele dirige o ponto para casa que booleans

6601
04:24:28,399 --> 04:24:30,880
são usados principalmente na tomada de decisões em

6602
04:24:30,880 --> 04:24:32,640
Seu programa e é isso que você é

6603
04:24:32,640 --> 04:24:35,359
será principalmente usá-los para e

6604
04:24:35,359 --> 04:24:37,520
Outra coisa é que eles tomam um

6605
04:24:37,520 --> 04:24:40,479
morder em sua memória nós vamos parar

6606
04:24:40,479 --> 04:24:42,319
Aqui nesta palestra o próximo somos

6607
04:24:42,319 --> 04:24:44,880
Vou aprender sobre os personagens

6608
04:24:44,880 --> 04:24:46,319
e o texto

6609
04:24:46,319 --> 04:24:48,720
Vá em frente e termine aqui e me encontre

6610
04:24:48,720 --> 04:24:50,479
lá nesta palestra vamos

6611
04:24:50,479 --> 04:24:53,279
Saiba mais sobre caracteres e textos e nós

6612
04:24:53,279 --> 04:24:56,080
usar um tipo de dados chamado carro em c plus

6613
04:24:56,080 --> 04:24:58,479
mais para representar personagens e isso é

6614
04:24:58,479 --> 04:25:00,239
basicamente como você usá-lo você armazena em

6615
04:25:00,239 --> 04:25:02,960
personagens como abc e aqui você vê

6616
04:25:02,960 --> 04:25:05,199
que temos um r

6617
04:25:05,199 --> 04:25:08,319
o w e você coloca seus personagens em

6618
04:25:08,319 --> 04:25:10,560
Citações individuais como isso para significar que

6619
04:25:10,560 --> 04:25:12,560
Eles são personagens se você não fizer isso

6620
04:25:12,560 --> 04:25:14,239
você vai ter um erro de compilador

6621
04:25:14,239 --> 04:25:16,800
Depois de ter seus personagens declarados

6622
04:25:16,800 --> 04:25:19,760
e definido como este você pode imprimi-los

6623
04:25:19,760 --> 04:25:22,560
fora com stdc para fora e nós vamos ver

6624
04:25:22,560 --> 04:25:26,399
eles no carro terminal ocupa um

6625
04:25:26,399 --> 04:25:28,479
byte na memória, então vai assumir

6626
04:25:28,479 --> 04:25:31,279
Oito bits estão bem, então uma coisa que podemos fazer

6627
04:25:31,279 --> 04:25:35,760
é mapear cada valor nestes 256 possíveis

6628
04:25:35,760 --> 04:25:38,319
valores para um personagem e nós podemos fazer

6629
04:25:38,319 --> 04:25:40,159
Algo assim, por exemplo, podemos

6630
04:25:40,159 --> 04:25:41,520
Diga isso

6631
04:25:41,520 --> 04:25:44,800
33 representa o ponto de exclamação

6632
04:25:44,800 --> 04:25:47,840
48 representa o caractere 0 49

6633
04:25:47,840 --> 04:25:50,560
Representa o caractere 1 50 representa

6634
04:25:50,560 --> 04:25:53,600
o personagem 2 e podemos continuar subindo

6635
04:25:53,600 --> 04:25:56,720
e dizer, por exemplo, 70 representa f 71

6636
04:25:56,720 --> 04:25:58,319
representa g

6637
04:25:58,319 --> 04:25:59,000
ou

6638
04:25:59,000 --> 04:26:02,399
112 representa p você pode realmente usar um

6639
04:26:02,399 --> 04:26:05,159
mapeamento como este e chegar com

6640
04:26:05,159 --> 04:26:07,840
Representações de seus personagens em

6641
04:26:07,840 --> 04:26:10,000
memória e isso é o que podemos fazer

6642
04:26:10,000 --> 04:26:12,560
Saiba mais sobre esta codificação e sobre o

6643
04:26:12,560 --> 04:26:15,120
link aqui esta é uma coisa real e é

6644
04:26:15,120 --> 04:26:18,720
chamado de codificação ascii que leva

6645
04:26:18,720 --> 04:26:21,600
Personagens e armazená-los em um byte

6646
04:26:21,600 --> 04:26:23,520
e o tipo de dados para armazenar estes

6647
04:26:23,520 --> 04:26:26,640
caracteres em c plus mais é carro se este

6648
04:26:26,640 --> 04:26:28,720
Não faz sentido, por favor, tenha paciência comigo

6649
04:26:28,720 --> 04:26:30,560
nós vamos brincar com isso em vídeo

6650
04:26:30,560 --> 04:26:32,800
código de estúdio e é muito provavelmente

6651
04:26:32,800 --> 04:26:35,279
Vou fazer sentido bem, é possível

6652
04:26:35,279 --> 04:26:38,960
para atribuir um código ascii válido a

6653
04:26:38,960 --> 04:26:41,680
uma variável de carro e o correspondente

6654
04:26:41,680 --> 04:26:44,000
O caráter será armazenado nessa peça

6655
04:26:44,000 --> 04:26:46,560
de memória, uma vez que você tem que você pode

6656
04:26:46,560 --> 04:26:48,479
Escolha interpretar isso como uma

6657
04:26:48,479 --> 04:26:51,120
personagem ou como um número que

6658
04:26:51,120 --> 04:26:53,040
Algo como um inteiro é o que

6659
04:26:53,040 --> 04:26:55,680
Realmente queremos dizer se declararmos uma variável

6660
04:26:55,680 --> 04:26:59,199
denominado valor que é do tipo de carro 65 é

6661
04:26:59,199 --> 04:27:02,239
vai ser armazenado na memória, mas o c

6662
04:27:02,239 --> 04:27:04,800
O plus plus programa vai interpretar

6663
04:27:04,800 --> 04:27:07,840
isso como um personagem se voltarmos para o nosso

6664
04:27:07,840 --> 04:27:10,880
e ver o que é representado por 65

6665
04:27:10,880 --> 04:27:12,239
Isto é o que vamos encontrar nós somos

6666
04:27:12,239 --> 04:27:15,840
descobrir que 65 representa um

6667
04:27:15,840 --> 04:27:18,080
e se imprimirmos isso por padrão, é

6668
04:27:18,080 --> 04:27:20,159
Vou imprimir um que não vai imprimir

6669
04:27:20,159 --> 04:27:22,800
65 mas há uma maneira de tomar isso

6670
04:27:22,800 --> 04:27:26,000
valor de caráter e transformá-lo em um

6671
04:27:26,000 --> 04:27:28,880
inteiro e imprimi-lo para fora e você vê

6672
04:27:28,880 --> 04:27:32,000
Aqui estamos dizendo valor e nós

6673
04:27:32,000 --> 04:27:34,159
Estamos dizendo elenco estático

6674
04:27:34,159 --> 04:27:36,880
e nos pais temos um valor

6675
04:27:36,880 --> 04:27:38,960
Esta é basicamente uma maneira de dizer que queríamos

6676
04:27:38,960 --> 04:27:42,319
tomar o valor e interpretar isso como

6677
04:27:42,319 --> 04:27:44,080
Um inteiro e nós vamos aprender um

6678
04:27:44,080 --> 04:27:46,399
pouco mais sobre elenco estático mais tarde em

6679
04:27:46,399 --> 04:27:48,800
O curso, mas é basicamente uma maneira de

6680
04:27:48,800 --> 04:27:51,199
transformar entre tipos de dados e nesta

6681
04:27:51,199 --> 04:27:54,000
Caso que estamos tentando transformar do carro

6682
04:27:54,000 --> 04:27:56,399
para terminar e vamos imprimir isso

6683
04:27:56,399 --> 04:27:59,120
O que acabamos de descrever são os ascii

6684
04:27:59,120 --> 04:28:01,680
codificando uma técnica pela qual podemos mapear

6685
04:28:01,680 --> 04:28:05,279
Os primeiros 128 números em

6686
04:28:05,279 --> 04:28:08,000
um byte dois personagens e use isso para

6687
04:28:08,000 --> 04:28:10,000
Representar personagens esta técnica

6688
04:28:10,000 --> 04:28:13,040
Não funciona bem se você tem línguas

6689
04:28:13,040 --> 04:28:15,680
como um japonês árabe e chinês porque

6690
04:28:15,680 --> 04:28:18,319
São bestas completamente diferentes

6691
04:28:18,319 --> 04:28:19,680
Há melhores maneiras de representar

6692
04:28:19,680 --> 04:28:21,920
Personagens em seu programa c plus e

6693
04:28:21,920 --> 04:28:24,800
Isso geralmente é unicode, mas isso é realmente

6694
04:28:24,800 --> 04:28:27,120
fora do escopo para um curso como este, então

6695
04:28:27,120 --> 04:28:29,199
Eu não vou mais descrever isso

6696
04:28:29,199 --> 04:28:30,880
Tudo bem é tudo o que precisamos aprender

6697
04:28:30,880 --> 04:28:32,800
sobre os personagens que vamos nos dirigir

6698
04:28:32,800 --> 04:28:35,199
código de estúdio visual e jogar com eles

6699
04:28:35,199 --> 04:28:38,560
Tudo bem aqui eu estou na minha pasta de trabalho eu sou

6700
04:28:38,560 --> 04:28:40,640
indo para ir no meu projeto de template eu sou

6701
04:28:40,640 --> 04:28:43,120
Vou copiar as coisas sobre eu vou

6702
04:28:43,120 --> 04:28:45,760
colocar isso em meus personagens e texto

6703
04:28:45,760 --> 04:28:48,560
Projeto e eu vou subir e abrir

6704
04:28:48,560 --> 04:28:50,239
isso no código do estúdio visual, nós somos

6705
04:28:50,239 --> 04:28:52,080
Vou fechar a tela de boas-vindas aqui

6706
04:28:52,080 --> 04:28:54,640
nós vamos abrir cpp principal e

6707
04:28:54,640 --> 04:28:57,279
Vamos colocar o código para jogar

6708
04:28:57,279 --> 04:28:59,600
com caracteres e texto

6709
04:28:59,600 --> 04:29:02,000
A primeira coisa que podemos fazer é declarar

6710
04:29:02,000 --> 04:29:05,120
personagens como este, podemos colocar em um r

6711
04:29:05,120 --> 04:29:08,159
O w aqui e nós vamos ver isso

6712
04:29:08,159 --> 04:29:10,800
impresso fora se executarmos este programa nós

6713
04:29:10,800 --> 04:29:12,960
eles vão colocar em algum código para jogar

6714
04:29:12,960 --> 04:29:14,560
E com os personagens

6715
04:29:14,560 --> 04:29:17,439
Temos algumas variáveis declaradas que

6716
04:29:17,439 --> 04:29:19,760
São do tipo de carro

6717
04:29:19,760 --> 04:29:22,080
Vamos do personagem 1 ao personagem

6718
04:29:22,080 --> 04:29:24,000
5 e estes são os personagens que somos

6719
04:29:24,000 --> 04:29:25,840
Armazenar e isto é e este é o

6720
04:29:25,840 --> 04:29:27,760
formato que você realmente vai usar para

6721
04:29:27,760 --> 04:29:30,399
Declarar seus personagens depois que temos

6722
04:29:30,399 --> 04:29:33,199
eles declararam que podemos imprimi-los como

6723
04:29:33,199 --> 04:29:36,239
nós imprimimos qualquer outra variável e nós podemos

6724
04:29:36,239 --> 04:29:38,239
Tente compilar este programa e ver

6725
04:29:38,239 --> 04:29:40,399
o que vamos conseguir, mas antes de fazermos

6726
04:29:40,399 --> 04:29:42,560
que eu iria convidá-lo a tentar e adivinhar

6727
04:29:42,560 --> 04:29:44,960
Então vamos abrir o nosso terminal

6728
04:29:44,960 --> 04:29:48,239
e nós vamos construir com o nosso gcc

6729
04:29:48,239 --> 04:29:50,399
tarefa que estamos indo para o mundo a construção é

6730
04:29:50,399 --> 04:29:52,640
indo para passar e se corrermos

6731
04:29:52,640 --> 04:29:54,720
Galo vamos ver que estamos

6732
04:29:54,720 --> 04:29:56,159
impressão para fora

6733
04:29:56,159 --> 04:30:00,239
a

6734
04:30:00,239 --> 04:30:02,960
e nós somos capazes de imprimi-los

6735
04:30:02,960 --> 04:30:04,640
É assim que você trabalha com estes

6736
04:30:04,640 --> 04:30:06,880
Caras outra coisa que eu quero que você veja é

6737
04:30:06,880 --> 04:30:10,640
O tamanho que um personagem ocupa

6738
04:30:10,640 --> 04:30:13,760
na memória por que eu quero dizer tipo de cartão é

6739
04:30:13,760 --> 04:30:16,239
Vai ocupar um byte na memória e

6740
04:30:16,239 --> 04:30:19,560
Isso significa que só podemos ter

6741
04:30:19,560 --> 04:30:23,040
256 valores diferentes que vão entre 0

6742
04:30:23,040 --> 04:30:26,800
e 255 se tivermos decidido guardar em

6743
04:30:26,800 --> 04:30:28,720
números positivos que estamos usando o

6744
04:30:28,720 --> 04:30:30,880
conhecimento que aprendemos com os inteiros

6745
04:30:30,880 --> 04:30:33,279
palestra se esses cálculos somos

6746
04:30:33,279 --> 04:30:35,680
Fazendo aqui não faz sentido, por favor vá

6747
04:30:35,680 --> 04:30:38,319
Volte e verifique isso, então aqui em baixo nós

6748
04:30:38,319 --> 04:30:41,040
estão declarando um tipo de caractere o nome

6749
04:30:41,040 --> 04:30:44,159
é valor e estamos colocando em um 65.

6750
04:30:44,159 --> 04:30:46,720
A coisa é se você tentar imprimir esse valor

6751
04:30:46,720 --> 04:30:48,960
Aqui não vai imprimir 65 é

6752
04:30:48,960 --> 04:30:51,920
Vou imprimir um que é um personagem

6753
04:30:51,920 --> 04:30:54,960
Representação de 65. se você se lembrar

6754
04:30:54,960 --> 04:30:58,479
Da nossa mesa ascii tivemos estes

6755
04:30:58,479 --> 04:31:01,520
mapeamentos entre caracteres e inteiros

6756
04:31:01,520 --> 04:31:05,600
e 65 mapeadas para o personagem a

6757
04:31:05,600 --> 04:31:08,479
na parte superior, então se imprimirmos isso, isso

6758
04:31:08,479 --> 04:31:10,800
vai nos dar um, mas nós temos o

6759
04:31:10,800 --> 04:31:12,319
opção para

6760
04:31:12,319 --> 04:31:14,960
interpretar isso como um número e nós podemos

6761
04:31:14,960 --> 04:31:18,000
passar isso através de um molde estático e ele

6762
04:31:18,000 --> 04:31:20,239
Vai tomar um valor transformar isso em

6763
04:31:20,239 --> 04:31:22,080
Um inteiro e nós vamos ser

6764
04:31:22,080 --> 04:31:24,800
imprimindo este inteiro no console e

6765
04:31:24,800 --> 04:31:26,880
nós vamos ver isso nós vamos tentar

6766
04:31:26,880 --> 04:31:28,800
Isso para que vamos executar a tarefa

6767
04:31:28,800 --> 04:31:31,439
para construir com gcc a construção está indo para

6768
04:31:31,439 --> 04:31:34,399
passarmos nós vamos correr o galo

6769
04:31:34,399 --> 04:31:36,880
e você verá que o valor é um

6770
04:31:36,880 --> 04:31:39,040
para a primeira linha aqui

6771
04:31:39,040 --> 04:31:42,800
e o valor e é 65 porque nós

6772
04:31:42,800 --> 04:31:46,000
Decidi interpretar o que está nisso

6773
04:31:46,000 --> 04:31:48,720
valor como um inteiro e não como um

6774
04:31:48,720 --> 04:31:51,359
personagem como é feito por padrão

6775
04:31:51,359 --> 04:31:52,800
É realmente tudo o que nos prossamos fazer nisso

6776
04:31:52,800 --> 04:31:55,120
Uma palestra espero que você tenha achado interessante

6777
04:31:55,120 --> 04:31:56,800
Vamos parar aqui neste

6778
04:31:56,800 --> 04:31:58,399
palestra no próximo, vamos

6779
04:31:58,399 --> 04:32:01,600
Tente aprender sobre o mundo das chaves automáticas

6780
04:32:01,600 --> 04:32:03,279
em c plus plus

6781
04:32:03,279 --> 04:32:05,520
Vá em frente e termine aqui e me encontre

6782
04:32:05,520 --> 04:32:07,199
lá nesta palestra vamos

6783
04:32:07,199 --> 04:32:10,239
Saiba mais sobre a palavra-chave automática em c plus

6784
04:32:10,239 --> 04:32:11,279
+ a vantagem

6785
04:32:11,279 --> 04:32:14,159
Esta é uma palavra-chave que vai deixar

6786
04:32:14,159 --> 04:32:16,640
o compilador deduz o tipo para você e

6787
04:32:16,640 --> 04:32:18,800
Isso vai ser útil quando você

6788
04:32:18,800 --> 04:32:22,239
têm nomes de tipos mais longos que são realmente

6789
04:32:22,239 --> 04:32:24,800
É difícil digitar não podemos realmente dar-lhe um

6790
04:32:24,800 --> 04:32:27,359
Um exemplo disso, porque isso requer

6791
04:32:27,359 --> 04:32:31,359
ter um bom número de conceitos dominados

6792
04:32:31,359 --> 04:32:34,000
na cláusula mais, mas estamos medindo isso

6793
04:32:34,000 --> 04:32:35,920
aqui para a integridade, porque nós somos

6794
04:32:35,920 --> 04:32:38,399
falando sobre variáveis e tipos de dados

6795
04:32:38,399 --> 04:32:40,560
Então vamos ouvir como podemos usar isso aqui

6796
04:32:40,560 --> 04:32:42,800
Temos um exemplo em que estamos dizendo

6797
04:32:42,800 --> 04:32:46,239
autovar um e o que nós inicializamos isso

6798
04:32:46,239 --> 04:32:49,199
Com é um inteiro, então o compilador é

6799
04:32:49,199 --> 04:32:51,920
Realmente vou tentar adivinhar o tipo

6800
04:32:51,920 --> 04:32:54,080
desta coisa e esse é o tipo que é

6801
04:32:54,080 --> 04:32:56,560
vai atribuir à variável que este é

6802
04:32:56,560 --> 04:32:59,840
O que ocho é realmente usado se passarmos

6803
04:32:59,840 --> 04:33:01,439
um duplo

6804
04:33:01,439 --> 04:33:03,439
dentro e é um duplo porque nós

6805
04:33:03,439 --> 04:33:04,959
Não tenha

6806
04:33:04,959 --> 04:33:06,639
suffix aqui

6807
04:33:06,639 --> 04:33:09,520
Então vai deduzir um duplo se nós

6808
04:33:09,520 --> 04:33:12,160
passar um sufixo de f ele vai

6809
04:33:12,160 --> 04:33:15,119
interpretar isso como um fluido se passarmos l

6810
04:33:15,119 --> 04:33:17,359
vai interpretar isso enquanto

6811
04:33:17,359 --> 04:33:19,680
duplo e se passarmos num personagem

6812
04:33:19,680 --> 04:33:21,920
vai interpretar isso como um

6813
04:33:21,920 --> 04:33:24,160
personagem e esta é realmente a essência

6814
04:33:24,160 --> 04:33:27,520
O que é usado para ele é usado quando

6815
04:33:27,520 --> 04:33:30,879
Você realmente não quer digitar explicitamente

6816
04:33:30,879 --> 04:33:33,439
o tipo de sua variável e você quer

6817
04:33:33,439 --> 04:33:36,959
O compilador para preencher isso para você ou

6818
04:33:36,959 --> 04:33:38,799
ele consegue isso para você aqui você vê

6819
04:33:38,799 --> 04:33:40,400
que temos alguns exemplos com

6820
04:33:40,400 --> 04:33:43,119
inteiros para que possamos fazer isso sem assinatura

6821
04:33:43,119 --> 04:33:45,439
pulmão através deste sufixo e do

6822
04:33:45,439 --> 04:33:48,080
O compilador vai deduzir o tipo

6823
04:33:48,080 --> 04:33:51,119
com base no que passamos em nosso inicializador

6824
04:33:51,119 --> 04:33:52,879
Aqui em baixo você vê que temos um

6825
04:33:52,879 --> 04:33:55,520
poucos exemplos com inteiros se passarmos por um

6826
04:33:55,520 --> 04:33:57,920
sufixo de u isso significa que nós somos

6827
04:33:57,920 --> 04:34:01,039
armazenando um inteiro não assinado, então isso é

6828
04:34:01,039 --> 04:34:03,439
o que o compilador vai deduzir se

6829
04:34:03,439 --> 04:34:06,639
Passamos ul, não será assinado

6830
04:34:06,639 --> 04:34:09,359
longo se passarmos em ll isso vai

6831
04:34:09,359 --> 04:34:11,359
ser longo por muito tempo e isso é o que

6832
04:34:11,359 --> 04:34:13,600
compilador vai deduzir aqui você ver

6833
04:34:13,600 --> 04:34:15,840
que estamos tentando imprimir os tamanhos de

6834
04:34:15,840 --> 04:34:19,199
essas variáveis e estamos tentando

6835
04:34:19,199 --> 04:34:21,039
Prove para nós mesmos

6836
04:34:21,039 --> 04:34:24,080
que o compilador deduziu o tipo certo

6837
04:34:24,080 --> 04:34:26,080
e nós vamos para o estúdio visual

6838
04:34:26,080 --> 04:34:28,639
código e realmente tentar isso

6839
04:34:28,639 --> 04:34:32,480
Tudo bem aqui eu estou na minha pasta de trabalho eu sou

6840
04:34:32,480 --> 04:34:34,719
Vou abrir meu projeto de template i'm

6841
04:34:34,719 --> 04:34:36,240
Vou copiar isso

6842
04:34:36,240 --> 04:34:37,840
E eu estou indo para

6843
04:34:37,840 --> 04:34:41,920
salvar meus arquivos no projeto automático aqui

6844
04:34:41,920 --> 04:34:44,160
então eu vou entrar e colocar na minha

6845
04:34:44,160 --> 04:34:47,119
Arquivos eu vou subir de novo e eu estou

6846
04:34:47,119 --> 04:34:49,680
Vou fechar tudo o que eu tenho em

6847
04:34:49,680 --> 04:34:51,279
código de estúdio visual porque estamos indo

6848
04:34:51,279 --> 04:34:53,600
para criar um novo projeto que eu vou

6849
04:34:53,600 --> 04:34:55,680
abrir minha nova pasta que vamos fechar

6850
04:34:55,680 --> 04:34:57,600
A tela de boas-vindas aqui e nós vamos

6851
04:34:57,600 --> 04:34:59,760
para remover o que quer que seja que não precisamos

6852
04:34:59,760 --> 04:35:01,600
para este projeto

6853
04:35:01,600 --> 04:35:03,920
e vamos colocar no código que nós

6854
04:35:03,920 --> 04:35:07,199
basicamente tinha nos slides eu estou colando

6855
04:35:07,199 --> 04:35:10,080
Este código para economizar em algum tempo

6856
04:35:10,080 --> 04:35:11,760
Porque eu não quero que você me veja tipo

6857
04:35:11,760 --> 04:35:13,520
Essas coisas nós vamos salvar alguns

6858
04:35:13,520 --> 04:35:14,799
segundos aqui

6859
04:35:14,799 --> 04:35:17,520
assim, a primeira declaração aqui declara um

6860
04:35:17,520 --> 04:35:20,561
variável var1 o tipo que nós realmente não

6861
04:35:20,561 --> 04:35:22,639
Eu sei, mas vamos deixar o compilador

6862
04:35:22,639 --> 04:35:24,320
Deduza isso para nós

6863
04:35:24,320 --> 04:35:26,799
e nós podemos tentar e realmente pairar sobre

6864
04:35:26,799 --> 04:35:28,480
Isso e vamos ver que

6865
04:35:28,480 --> 04:35:30,959
O compilador já deduziu que este é um

6866
04:35:30,959 --> 04:35:33,920
inteiro se formos para vira 2 este é um

6867
04:35:33,920 --> 04:35:36,400
duplo se formos para var3 você vê que é um

6868
04:35:36,400 --> 04:35:40,080
float se você for para var4 é longo duplo

6869
04:35:40,080 --> 04:35:42,320
Se você vai para o fio 5 é um personagem que você

6870
04:35:42,320 --> 04:35:45,119
pode ver que o código visual do estúdio pode até

6871
04:35:45,119 --> 04:35:47,760
ver o que o compilador vai deduzir

6872
04:35:47,760 --> 04:35:50,320
antes mesmo de compilarmos o código que este é

6873
04:35:50,320 --> 04:35:52,959
A beleza do código do estúdio visual que somos

6874
04:35:52,959 --> 04:35:55,119
Vou olhar para o vírus 6 que você vai

6875
04:35:55,119 --> 04:35:57,600
Veja que não será assinado e

6876
04:35:57,600 --> 04:35:59,680
Se formos para var 7 vai ser

6877
04:35:59,680 --> 04:36:03,279
sem sinal por muito tempo se formos para var 8 é

6878
04:36:03,279 --> 04:36:05,680
Vou demorar muito, isso é realmente

6879
04:36:05,680 --> 04:36:07,920
legal e você pode ver que nossos tipos são

6880
04:36:07,920 --> 04:36:10,719
corretamente deduzido código de vídeo visual foi

6881
04:36:10,719 --> 04:36:13,680
muito útil para nos mostrar esses tipos

6882
04:36:13,680 --> 04:36:16,561
Mas queremos ter certeza executando isso

6883
04:36:16,561 --> 04:36:19,520
pedaço de código e ver qualquer tamanho

6884
04:36:19,520 --> 04:36:22,879
o tipo deduzido é, por exemplo, para var1

6885
04:36:22,879 --> 04:36:25,199
Nós adivinhamos que ele vai deduzir um

6886
04:36:25,199 --> 04:36:28,080
Para que seja melhor ser um quatro

6887
04:36:28,080 --> 04:36:30,879
Em tamanho, vamos tentar correr isso

6888
04:36:30,879 --> 04:36:33,439
Vamos abrir nosso terminal aqui

6889
04:36:33,439 --> 04:36:35,359
e nós vamos para o terminal e

6890
04:36:35,359 --> 04:36:38,639
executar a tarefa que vamos construir com gcc

6891
04:36:38,639 --> 04:36:40,719
e, a propósito, se você quiser, você pode construir

6892
04:36:40,719 --> 04:36:43,760
com o compilador da microsoft por

6893
04:36:43,760 --> 04:36:46,000
vindo para o terminal aqui e escolher

6894
04:36:46,000 --> 04:36:49,520
com o mundo com msvc mas gcc é o meu

6895
04:36:49,520 --> 04:36:51,840
compilador favorito e eu vou usar

6896
04:36:51,840 --> 04:36:55,039
Se eu puder, vamos bater Enter

6897
04:36:55,039 --> 04:36:58,359
e entrar nós vamos ver que nosso

6898
04:36:58,359 --> 04:37:01,680
O arquivo galoster.exe está no lugar se executarmos

6899
04:37:01,680 --> 04:37:04,480
Vamos ver nossos tamanhos, então var

6900
04:37:04,480 --> 04:37:07,680
um ocupa quatro bytes na memória

6901
04:37:07,680 --> 04:37:11,199
var2 ocupa oito bytes na memória

6902
04:37:11,199 --> 04:37:13,039
Porque é

6903
04:37:13,039 --> 04:37:15,840
O fogo duplo 3 ocupa 3 bytes porque

6904
04:37:15,840 --> 04:37:18,879
é um flutuador var4 ocupa 16 bytes

6905
04:37:18,879 --> 04:37:20,959
Porque é um duplo longo

6906
04:37:20,959 --> 04:37:24,080
e var 5 melhor ocupar 1 byte porque

6907
04:37:24,080 --> 04:37:26,080
É um personagem e vemos o mesmo

6908
04:37:26,080 --> 04:37:27,520
Os dados para

6909
04:37:27,520 --> 04:37:30,959
vera 6 vírus 7 e var 8 e isso prova

6910
04:37:30,959 --> 04:37:33,840
que a palavra-chave automática está realmente fazendo

6911
04:37:33,840 --> 04:37:36,879
seu trabalho é deduzir os tipos para o nosso

6912
04:37:36,879 --> 04:37:40,080
Variáveis sem nós explicitamente

6913
04:37:40,080 --> 04:37:42,959
especificando o tipo de variável que não

6914
04:37:42,959 --> 04:37:45,279
Tenho que fazer algo como e ou dobrar

6915
04:37:45,279 --> 04:37:47,680
ou o que quer que possamos deixar o compilador fazer

6916
04:37:47,680 --> 04:37:50,480
que para nós e isso virá à mão

6917
04:37:50,480 --> 04:37:53,039
Muitas vezes isso é realmente tudo o que estabelecemos

6918
04:37:53,039 --> 04:37:54,719
para fazer nesta palestra e eu espero que você

6919
04:37:54,719 --> 04:37:56,719
Achei interessante no próximo

6920
04:37:56,719 --> 04:37:58,719
nós vamos ver como podemos fazer

6921
04:37:58,719 --> 04:38:01,359
atribuições e atribuir dados para o nosso

6922
04:38:01,359 --> 04:38:04,320
variáveis de forma unificada vão em frente e

6923
04:38:04,320 --> 04:38:07,199
Termine aqui e nós estaríamos lá nisso

6924
04:38:07,199 --> 04:38:08,879
palestra que vamos aprender sobre

6925
04:38:08,879 --> 04:38:12,240
atribuições e a ideia básica que eu realmente

6926
04:38:12,240 --> 04:38:15,600
Quero dirigir para casa aqui é que depois de um

6927
04:38:15,600 --> 04:38:18,320
A variável é inicializada como nós fomos

6928
04:38:18,320 --> 04:38:21,439
fazendo o tempo todo você pode mais tarde atribuir um

6929
04:38:21,439 --> 04:38:24,561
Novo valor para ele, por exemplo, aqui temos

6930
04:38:24,561 --> 04:38:27,039
nosso único declarou que é um inteiro que podemos

6931
04:38:27,039 --> 04:38:28,719
imprimi-lo e vai imprimir

6932
04:38:28,719 --> 04:38:31,600
um dois três, mas depois no programa

6933
04:38:31,600 --> 04:38:33,520
Podemos colocar outro valor, por exemplo

6934
04:38:33,520 --> 04:38:36,080
Aqui estamos colocando um 55 e se nós

6935
04:38:36,080 --> 04:38:39,760
imprimir var1 vai ser 55 desta vez

6936
04:38:39,760 --> 04:38:42,400
A mesma ideia pode ser estendida para duplas

6937
04:38:42,400 --> 04:38:44,799
Você vê aqui que estamos fazendo a mesma coisa

6938
04:38:44,799 --> 04:38:46,719
booleans estamos fazendo a mesma coisa

6939
04:38:46,719 --> 04:38:49,760
Aqui o estado é declarado força e nós

6940
04:38:49,760 --> 04:38:51,760
estão imprimindo isso e depois que estamos

6941
04:38:51,760 --> 04:38:54,240
mudando isso para um verdadeiro valor e se

6942
04:38:54,240 --> 04:38:56,879
imprimir que vai ser verdadeiro

6943
04:38:56,879 --> 04:38:58,320
O que você realmente precisa ter cuidado

6944
04:38:58,320 --> 04:39:01,119
sobre é se você está fazendo o tipo automático

6945
04:39:01,119 --> 04:39:04,000
Dedução do tipo não é muito aparente

6946
04:39:04,000 --> 04:39:06,320
olhando para a declaração do

6947
04:39:06,320 --> 04:39:08,480
variável aqui, por exemplo, aqui por

6948
04:39:08,480 --> 04:39:12,400
Olhando para o2 var 3 nós realmente não sabemos

6949
04:39:12,400 --> 04:39:15,199
O que é e é muito fácil tentar

6950
04:39:15,199 --> 04:39:17,439
e colocar um valor que é ilegal para

6951
04:39:17,439 --> 04:39:20,719
O exemplo aqui deduzimos um não assinado

6952
04:39:20,719 --> 04:39:23,520
inteiro que só vai armazenar

6953
04:39:23,520 --> 04:39:26,000
números positivos, mas estamos colocando em um

6954
04:39:26,000 --> 04:39:28,240
menos 22 e isso vai ser um

6955
04:39:28,240 --> 04:39:30,080
Desastre, vamos conseguir um compilador

6956
04:39:30,080 --> 04:39:33,439
Erro e isso vai ser ruim, então seja

6957
04:39:33,439 --> 04:39:35,520
Cuidado quando você está fazendo um tipo

6958
04:39:35,520 --> 04:39:38,240
dedução em suas atribuições que você

6959
04:39:38,240 --> 04:39:40,638
fazer com suas variáveis isso é realmente tudo

6960
04:39:40,638 --> 04:39:43,040
Temos que compartilhar esta palestra, vamos

6961
04:39:43,040 --> 04:39:45,520
suba para estúdio visual e mostre-lhe

6962
04:39:45,520 --> 04:39:48,718
Isso em ação bem aqui estou no meu

6963
04:39:48,718 --> 04:39:50,638
pasta de trabalho o projeto que estamos indo

6964
04:39:50,638 --> 04:39:52,718
Estar trabalhando é quatro nove aqui

6965
04:39:52,718 --> 04:39:55,120
atribuições eu vou pegar o meu

6966
04:39:55,120 --> 04:39:57,920
template files e colocar isso neste

6967
04:39:57,920 --> 04:40:00,400
pasta aqui e eu vou abrir este

6968
04:40:00,400 --> 04:40:02,878
em código de estúdio visual, então vamos fechar

6969
04:40:02,878 --> 04:40:05,840
O que quer que seja que temos agora

6970
04:40:05,840 --> 04:40:08,798
e abrir a pasta e vamos

6971
04:40:08,798 --> 04:40:10,878
fechar a tela de boas-vindas aqui não

6972
04:40:10,878 --> 04:40:13,280
Quero e remova o que não queremos

6973
04:40:13,280 --> 04:40:16,000
Quero deste arquivo aqui a primeira coisa

6974
04:40:16,000 --> 04:40:18,638
Queremos fazer isso é colocar o código para o nosso

6975
04:40:18,638 --> 04:40:21,840
inteiro variável var1 e mostrar que

6976
04:40:21,840 --> 04:40:22,958
Você pode

6977
04:40:22,958 --> 04:40:25,600
atribuir um novo valor a ele depois que ele foi

6978
04:40:25,600 --> 04:40:27,920
inicializado e se executarmos este código

6979
04:40:27,920 --> 04:40:31,680
nós vamos ver var1 para b123 e

6980
04:40:31,680 --> 04:40:34,560
Segunda declaração vai dizer var1

6981
04:40:34,560 --> 04:40:35,920
iguais

6982
04:40:35,920 --> 04:40:38,400
55. Isso é o que nós vamos ver vamos

6983
04:40:38,400 --> 04:40:40,958
trazer o nosso terminal e nós estamos indo

6984
04:40:40,958 --> 04:40:44,798
para executar a tarefa para construir com gcc

6985
04:40:44,798 --> 04:40:48,400
e se saltarmos para cá no terminal

6986
04:40:48,400 --> 04:40:49,920
e fazer dir

6987
04:40:49,920 --> 04:40:52,638
Vamos ver que o nosso galo.exe

6988
04:40:52,638 --> 04:40:55,840
O arquivo está aqui se nós executá-lo, nós vamos

6989
04:40:55,840 --> 04:40:59,040
para ver var um um dois dois três var 155

6990
04:40:59,040 --> 04:41:01,680
exatamente o que esperamos que tenhamos armazenado em

6991
04:41:01,680 --> 04:41:05,280
um um dois três na inicialização usando

6992
04:41:05,280 --> 04:41:08,320
inicialização braced aqui, mas depois

6993
04:41:08,320 --> 04:41:11,760
Mais tarde, em nosso programa, decidimos

6994
04:41:11,760 --> 04:41:14,160
para colocar um valor diferente nisso

6995
04:41:14,160 --> 04:41:15,520
variável aqui

6996
04:41:15,520 --> 04:41:17,760
essencialmente reutilizando-o para armazenar

6997
04:41:17,760 --> 04:41:20,080
Algo mais esta é a ideia básica

6998
04:41:20,080 --> 04:41:22,240
Aqui podemos fazer as mesmas coisas com

6999
04:41:22,240 --> 04:41:24,480
Duplas, mas antes de fazermos isso, vamos colocar

7000
04:41:24,480 --> 04:41:27,600
em uma linha de separação para que possamos ver

7001
04:41:27,600 --> 04:41:30,958
estas aberturas claramente no terminal e

7002
04:41:30,958 --> 04:41:32,718
nós vamos descer e colocar em nosso

7003
04:41:32,718 --> 04:41:34,160
Código para um duplo

7004
04:41:34,160 --> 04:41:37,280
Assim temos uma variável dupla chamada var2

7005
04:41:37,280 --> 04:41:40,560
inicialmente tem 44.50

7006
04:41:40,560 --> 04:41:43,040
em e então nós vamos atribuir um novo

7007
04:41:43,040 --> 04:41:46,480
valor para isso e isso vai ser 99,99

7008
04:41:46,480 --> 04:41:48,320
Se imprimirmos isso, vamos ver

7009
04:41:48,320 --> 04:41:49,280
que

7010
04:41:49,280 --> 04:41:51,440
Vamos trabalhar e ver isso em ação que estamos

7011
04:41:51,440 --> 04:41:54,000
indo para construir com gcc

7012
04:41:54,000 --> 04:41:56,000
Se nós

7013
04:41:56,000 --> 04:41:58,560
executar o programa agora que vai salvar

7014
04:41:58,560 --> 04:42:01,440
r1 é um dois três três quatro um e cinquenta e cinco

7015
04:42:01,440 --> 04:42:03,600
mas também vamos ver esse viral

7016
04:42:03,600 --> 04:42:06,878
duas partidas para 44.55

7017
04:42:06,878 --> 04:42:09,240
Mas depois de colocarmos no

7018
04:42:09,240 --> 04:42:12,000
99,99 vai aparecer aqui bem

7019
04:42:12,000 --> 04:42:15,120
Vamos colocar em outra linha de separação

7020
04:42:15,120 --> 04:42:16,878
Porque nós vamos precisar disso em um

7021
04:42:16,878 --> 04:42:18,320
minuto de conta

7022
04:42:18,320 --> 04:42:21,040
Podemos fazer as mesmas coisas com booleanos

7023
04:42:21,040 --> 04:42:24,000
Aqui estamos usando isso como apenas um

7024
04:42:24,000 --> 04:42:26,560
exemplo, mas esse mesmo conceito

7025
04:42:26,560 --> 04:42:29,520
essencialmente estende-se a qualquer outro tipo de

7026
04:42:29,520 --> 04:42:31,840
variável que você vai ter em seu c

7027
04:42:31,840 --> 04:42:34,560
mais além de código se você inicializá-lo com

7028
04:42:34,560 --> 04:42:37,200
algum valor que você tem a opção de mudar

7029
04:42:37,200 --> 04:42:40,638
esse valor mais tarde em seu programa por

7030
04:42:40,638 --> 04:42:42,958
Atribuir esse valor a essa variável

7031
04:42:42,958 --> 04:42:45,280
essencialmente o que estamos fazendo aqui o

7032
04:42:45,280 --> 04:42:47,600
estado variável que é um touro

7033
04:42:47,600 --> 04:42:50,240
Foi inicializado para falso, vamos

7034
04:42:50,240 --> 04:42:52,480
imprimir isso e perceber que temos

7035
04:42:52,480 --> 04:42:54,878
Este cenário para nos permitir ver verdade ou

7036
04:42:54,878 --> 04:42:57,200
falso em vez de uns e zeros que temos

7037
04:42:57,200 --> 04:43:00,240
Veja isso em algumas palestras de volta

7038
04:43:00,240 --> 04:43:02,958
e mais tarde estamos atribuindo true para

7039
04:43:02,958 --> 04:43:05,520
Este estado e estamos imprimindo que

7040
04:43:05,520 --> 04:43:07,520
Se imprimirmos essas coisas, vamos

7041
04:43:07,520 --> 04:43:11,840
ver falso e verdadeiro para o estado aqui

7042
04:43:11,840 --> 04:43:13,680
então vamos construir

7043
04:43:13,680 --> 04:43:16,000
nós vamos usar gcc

7044
04:43:16,000 --> 04:43:18,400
E o mundo é bom se corrermos o

7045
04:43:18,400 --> 04:43:19,520
O programa

7046
04:43:19,520 --> 04:43:22,080
nós vamos ver falso e verdadeiro e isso

7047
04:43:22,080 --> 04:43:24,480
É exatamente o que esperamos novamente você

7048
04:43:24,480 --> 04:43:26,400
Você realmente precisa ter cuidado quando você está

7049
04:43:26,400 --> 04:43:29,040
usando a dedução do tipo automático porque você

7050
04:43:29,040 --> 04:43:31,280
Pode ter alguns problemas sérios se você

7051
04:43:31,280 --> 04:43:33,760
não estão prestando atenção, vamos colocar

7052
04:43:33,760 --> 04:43:36,240
o código para que possamos brincar com ele

7053
04:43:36,240 --> 04:43:39,120
Aqui temos uma variável chamada var 3 e

7054
04:43:39,120 --> 04:43:41,920
O tipo de ele não é especificado

7055
04:43:41,920 --> 04:43:44,320
explicitamente estamos deixando o compilador

7056
04:43:44,320 --> 04:43:47,520
Deduza isso e porque nosso inicializador

7057
04:43:47,520 --> 04:43:50,480
Aqui está um inteiro não assinado, o compilador

7058
04:43:50,480 --> 04:43:53,040
vai deduzir que é um

7059
04:43:53,040 --> 04:43:55,760
não assinado inteiro o problema virá

7060
04:43:55,760 --> 04:43:58,638
Se você tentar armazenar em um número negativo

7061
04:43:58,638 --> 04:44:00,638
o compilador não lhe dará um

7062
04:44:00,638 --> 04:44:03,200
seta do compilador que vai silenciosamente

7063
04:44:03,200 --> 04:44:05,440
colocar em algum valor de lixo

7064
04:44:05,440 --> 04:44:07,600
que nós realmente não queremos lá

7065
04:44:07,600 --> 04:44:11,120
Quer um menos 22 e você pode ver que

7066
04:44:11,120 --> 04:44:13,520
Isto é o que o compilador está girando

7067
04:44:13,520 --> 04:44:16,878
valor em nós queremos um menos 22 neste

7068
04:44:16,878 --> 04:44:19,520
para três, mas se você pairar sobre isso

7069
04:44:19,520 --> 04:44:22,160
menos sinal aqui no código do estúdio visual

7070
04:44:22,160 --> 04:44:23,600
você vai ver que o valor que

7071
04:44:23,600 --> 04:44:26,000
Nós não temos o que colocamos

7072
04:44:26,000 --> 04:44:29,120
em menos 22 e estamos recebendo um

7073
04:44:29,120 --> 04:44:32,000
Número muito grande perto de 4 bilhões

7074
04:44:32,000 --> 04:44:34,240
Então isso é realmente algo que pode ir

7075
04:44:34,240 --> 04:44:36,638
silenciosamente errado em seu código e você está

7076
04:44:36,638 --> 04:44:37,840
Vou ter

7077
04:44:37,840 --> 04:44:39,920
É difícil tentar descobrir por que

7078
04:44:39,920 --> 04:44:41,680
Seu código não está fazendo o que quer que seja

7079
04:44:41,680 --> 04:44:44,320
Você quer ter cuidado com isso, vamos

7080
04:44:44,320 --> 04:44:46,320
Tente soldar isso para que vamos

7081
04:44:46,320 --> 04:44:48,000
construção com gcc

7082
04:44:48,000 --> 04:44:49,360
O mundo vai ser bom você

7083
04:44:49,360 --> 04:44:50,958
Vou ver que não estamos indo

7084
04:44:50,958 --> 04:44:54,160
para obter uma seta do compilador se executarmos isso

7085
04:44:54,160 --> 04:44:56,878
e nós vamos ver que viral 3 é

7086
04:44:56,878 --> 04:44:59,520
exatamente o que o estúdio visual poderia adivinhar

7087
04:44:59,520 --> 04:45:02,400
E não é bom que seja esse valor aqui

7088
04:45:02,400 --> 04:45:04,718
O problema é que o compilador é

7089
04:45:04,718 --> 04:45:07,520
silenciosamente colocando um valor de lixo e

7090
04:45:07,520 --> 04:45:10,638
Não o que queremos aqui porque o vírus 3 é

7091
04:45:10,638 --> 04:45:12,638
basicamente não é capaz de armazenar

7092
04:45:12,638 --> 04:45:14,638
números negativos para que o compilador seja

7093
04:45:14,638 --> 04:45:16,638
indo fazer o seu melhor e colocar em um

7094
04:45:16,638 --> 04:45:18,958
Valor do lixo e isso não é o que você

7095
04:45:18,958 --> 04:45:21,680
Querer e você precisa estar ciente disso

7096
04:45:21,680 --> 04:45:23,200
Isso é realmente tudo o que nos prossamos fazer em

7097
04:45:23,200 --> 04:45:25,120
Esta palestra espero que você saiba sobre

7098
04:45:25,120 --> 04:45:28,000
atribuições e tenha cuidado quando você estiver

7099
04:45:28,000 --> 04:45:30,400
fazer atribuições em variáveis cuja

7100
04:45:30,400 --> 04:45:33,600
tipos são deduzidos com auto e nós somos

7101
04:45:33,600 --> 04:45:35,200
Vou parar aqui nesta palestra em

7102
04:45:35,200 --> 04:45:36,638
O próximo vamos tentar e

7103
04:45:36,638 --> 04:45:39,520
recapitula o que vimos neste capítulo ir

7104
04:45:39,520 --> 04:45:41,440
à frente e terminar aqui

7105
04:45:41,440 --> 04:45:43,600
e encontrar-me lá nesta palestra nós somos

7106
04:45:43,600 --> 04:45:46,400
Vamos recapitular o que vimos nisso

7107
04:45:46,400 --> 04:45:48,878
O capítulo e este capítulo foram realmente todos

7108
04:45:48,878 --> 04:45:52,000
sobre variáveis e tipos de dados que tivemos a

7109
04:45:52,000 --> 04:45:54,000
chance de olhar para diferentes tipos que

7110
04:45:54,000 --> 04:45:56,560
nós podemos usar em c plus plus que vimos que nós

7111
04:45:56,560 --> 04:45:58,798
Temos tipos fundamentais que podemos usar para

7112
04:45:58,798 --> 04:46:01,840
representar pontos flutuantes inteiros

7113
04:46:01,840 --> 04:46:05,200
booleans e também vimos que podemos fazer

7114
04:46:05,200 --> 04:46:08,160
tipo dedução com auto tivemos uma chance

7115
04:46:08,160 --> 04:46:10,400
para deixar claro que os dados são

7116
04:46:10,400 --> 04:46:13,440
representado na memória como zeros e uns

7117
04:46:13,440 --> 04:46:15,520
E que existem alguns tipos de

7118
04:46:15,520 --> 04:46:18,160
transformações que fazemos nessas peças de

7119
04:46:18,160 --> 04:46:21,280
dados para transformá-los em um formulário que é

7120
04:46:21,280 --> 04:46:24,638
facilmente utilizável e manipulável por humanos

7121
04:46:24,638 --> 04:46:27,680
e vimos isso para tipos integrais ou

7122
04:46:27,680 --> 04:46:30,320
Integers nós poderíamos fazer isso através do número

7123
04:46:30,320 --> 04:46:32,798
sistemas e tivemos a oportunidade de olhar para um

7124
04:46:32,798 --> 04:46:35,760
poucos sistemas números, como octal binário e

7125
04:46:35,760 --> 04:46:38,240
hexadecimal e tivemos a oportunidade de jogar

7126
04:46:38,240 --> 04:46:41,360
com todos esses tipos variáveis em

7127
04:46:41,360 --> 04:46:44,320
código de estúdio e ver as nuances de como

7128
04:46:44,320 --> 04:46:46,718
Você realmente trabalha com eles eu gostaria

7129
04:46:46,718 --> 04:46:49,520
para recebê-lo neste novo capítulo e

7130
04:46:49,520 --> 04:46:51,440
Este nós vamos estar olhando

7131
04:46:51,440 --> 04:46:55,200
operações que podemos fazer em nossos dados e

7132
04:46:55,200 --> 04:46:57,120
Há um monte deles que podemos acrescentar

7133
04:46:57,120 --> 04:46:59,280
Coisas para subtrair números que podemos

7134
04:46:59,280 --> 04:47:01,360
Dividir números que vamos ver tudo

7135
04:47:01,360 --> 04:47:04,400
tipos de operações loucas que podemos fazer

7136
04:47:04,400 --> 04:47:06,958
sobre os dados todas as variáveis que

7137
04:47:06,958 --> 04:47:10,320
Temos em nosso programa c plus plus que somos

7138
04:47:10,320 --> 04:47:11,920
Também ter a chance de olhar

7139
04:47:11,920 --> 04:47:14,240
Como podemos formatar as coisas quando imprimimos

7140
04:47:14,240 --> 04:47:17,440
eles para fora para stdc para fora e nós vamos para

7141
04:47:17,440 --> 04:47:20,000
usar alguns utilitários do c plus

7142
04:47:20,000 --> 04:47:22,160
além da biblioteca padrão para fazer alguns

7143
04:47:22,160 --> 04:47:25,040
operações em nossas variáveis, isso é

7144
04:47:25,040 --> 04:47:27,200
Vou ser um capítulo divertido que eu não posso esperar

7145
04:47:27,200 --> 04:47:29,440
Para começar, vamos para o próximo

7146
04:47:29,440 --> 04:47:31,920
Dirija e comece a fazer isso

7147
04:47:31,920 --> 04:47:33,280
Nesta palestra vamos ser

7148
04:47:33,280 --> 04:47:35,840
olhando para algumas operações básicas que você pode

7149
04:47:35,840 --> 04:47:36,718
- É assim.

7150
04:47:36,718 --> 04:47:39,680
sobre os dados em seu programa c plus plus

7151
04:47:39,680 --> 04:47:41,520
E nós vamos ser especificamente

7152
04:47:41,520 --> 04:47:44,240
olhando para subtração de adição dividindo

7153
04:47:44,240 --> 04:47:46,958
números do operador do módulo e

7154
04:47:46,958 --> 04:47:49,600
multiplicando as coisas que vimos adição

7155
04:47:49,600 --> 04:47:50,560
Antes de

7156
04:47:50,560 --> 04:47:53,280
Aqui temos um exemplo simples que temos a

7157
04:47:53,280 --> 04:47:55,840
variável chamada soma e nós somos

7158
04:47:55,840 --> 04:47:58,638
inicializando-o com dois números que nós

7159
04:47:58,638 --> 04:48:00,878
estão somando o número um e o número dois

7160
04:48:00,878 --> 04:48:02,798
Isso é algo que você pode fazer em seu c

7161
04:48:02,798 --> 04:48:05,760
além do programa de ônibus que você também pode fazer

7162
04:48:05,760 --> 04:48:07,600
Algumas outras coisas, por exemplo, temos

7163
04:48:07,600 --> 04:48:10,240
outro chamado outra soma e nós somos

7164
04:48:10,240 --> 04:48:12,878
somando alguns outros números e nós somos

7165
04:48:12,878 --> 04:48:15,600
vai coletar o resultado para isso

7166
04:48:15,600 --> 04:48:16,958
A outra soma

7167
04:48:16,958 --> 04:48:19,200
variável e vamos imprimir estes

7168
04:48:19,200 --> 04:48:21,920
coisas para que você possa vê-las

7169
04:48:21,920 --> 04:48:24,320
Seu prompt de comando é assim que você pode

7170
04:48:24,320 --> 04:48:25,920
fazer a adição e nós vamos ter um

7171
04:48:25,920 --> 04:48:27,600
chance de jogar com isso em visual

7172
04:48:27,600 --> 04:48:30,560
código de estúdio em um minuto que também podemos fazer

7173
04:48:30,560 --> 04:48:33,440
subtração podemos tomar um número e fazer

7174
04:48:33,440 --> 04:48:35,600
menos outro número como estamos fazendo

7175
04:48:35,600 --> 04:48:37,840
Aqui vamos armazenar os resultados em

7176
04:48:37,840 --> 04:48:40,480
esta variável div e nós podemos fazer alguns

7177
04:48:40,480 --> 04:48:41,600
Outras coisas

7178
04:48:41,600 --> 04:48:44,638
e aqui você vê outro exemplo em

7179
04:48:44,638 --> 04:48:46,718
Outro diff aqui nós vamos subtrair

7180
04:48:46,718 --> 04:48:49,600
números e armazenar o resultado em outros

7181
04:48:49,600 --> 04:48:52,080
Def e nós também vamos imprimir isso

7182
04:48:52,080 --> 04:48:54,400
Você também pode multiplicar coisas que isso é

7183
04:48:54,400 --> 04:48:56,240
Como você pode fazer isso, você usa isso

7184
04:48:56,240 --> 04:48:59,760
operador aqui é o operador estrela

7185
04:48:59,760 --> 04:49:01,840
Este é um operador que muitos

7186
04:49:01,840 --> 04:49:03,760
Linguagens de programação usadas para fazer

7187
04:49:03,760 --> 04:49:06,878
multiplicação que você deve se familiarizar

7188
04:49:06,878 --> 04:49:09,280
com isso e novamente nós imprimimos o

7189
04:49:09,280 --> 04:49:11,440
Resultar para que você possa ver que isso é

7190
04:49:11,440 --> 04:49:15,120
realmente trabalhando nós também podemos fazer divisão

7191
04:49:15,120 --> 04:49:17,920
Divisão para inteiros é um pouco complicado

7192
04:49:17,920 --> 04:49:19,840
Se você está vendo isso pela primeira vez

7193
04:49:19,840 --> 04:49:20,878
O tempo

7194
04:49:20,878 --> 04:49:22,400
Se tomarmos, por exemplo

7195
04:49:22,400 --> 04:49:26,160
31 e dividir isso por 10

7196
04:49:26,160 --> 04:49:27,760
Nós não vamos ficar fracionários

7197
04:49:27,760 --> 04:49:30,240
números c plus plus vai tentar e

7198
04:49:30,240 --> 04:49:33,840
Descobrir quantas vezes ele pode caber 10

7199
04:49:33,840 --> 04:49:37,440
em 31 e estamos visualizando isso aqui

7200
04:49:37,440 --> 04:49:41,440
assim, em 31 só podemos caber 10 três vezes

7201
04:49:41,440 --> 04:49:44,240
O resultado de 31 será três

7202
04:49:44,240 --> 04:49:46,000
Este é o significado aqui

7203
04:49:46,000 --> 04:49:47,920
OK com a divisão do inteiro você não é

7204
04:49:47,920 --> 04:49:50,080
obterá números fracionários

7205
04:49:50,080 --> 04:49:51,680
Isso é algo que você realmente deveria

7206
04:49:51,680 --> 04:49:54,798
Entendemos que temos um outro operador que

7207
04:49:54,798 --> 04:49:57,680
é chamado de operador de módulo e este

7208
04:49:57,680 --> 04:49:59,680
O operador é representado por este

7209
04:49:59,680 --> 04:50:02,320
Um símbolo percentual que estamos fazendo aqui

7210
04:50:02,320 --> 04:50:04,480
O resultado desta operação aqui é

7211
04:50:04,480 --> 04:50:06,878
Vai ser o que resta

7212
04:50:06,878 --> 04:50:10,000
Depois de ter feito a divisão de 31

7213
04:50:10,000 --> 04:50:12,560
e 10. e aqui o resultado vai

7214
04:50:12,560 --> 04:50:14,878
ser um e você pode estar se perguntando por que

7215
04:50:14,878 --> 04:50:16,958
Isso é útil, vai ser útil

7216
04:50:16,958 --> 04:50:18,480
em muitas aplicações

7217
04:50:18,480 --> 04:50:19,840
E eu acho que nós vamos ter uma chance

7218
04:50:19,840 --> 04:50:22,000
para jogar com isso mais tarde no curso

7219
04:50:22,000 --> 04:50:24,080
Mas agora você só precisa estar ciente

7220
04:50:24,080 --> 04:50:27,040
desta operação e do que faz bem

7221
04:50:27,040 --> 04:50:28,560
Estas são as operações que vamos

7222
04:50:28,560 --> 04:50:30,878
aprender e brincar com ele

7223
04:50:30,878 --> 04:50:33,680
Esta palestra vamos para o estúdio visual

7224
04:50:33,680 --> 04:50:36,560
código e realmente jogar com isso ok

7225
04:50:36,560 --> 04:50:39,600
Aqui estamos em nossa pasta de trabalho para

7226
04:50:39,600 --> 04:50:41,280
Este capítulo você vê que eu tenho

7227
04:50:41,280 --> 04:50:43,120
preparou todas as palestras para as quais vamos

7228
04:50:43,120 --> 04:50:46,400
fazer neste capítulo e eu tenho meu c plus

7229
04:50:46,400 --> 04:50:49,360
Projeto de 20 modelos em que estou indo

7230
04:50:49,360 --> 04:50:52,320
para fazer o que temos feito o tempo todo

7231
04:50:52,320 --> 04:50:54,638
então eu vou pegar esses arquivos e

7232
04:50:54,638 --> 04:50:55,760
Coloque-os

7233
04:50:55,760 --> 04:50:58,000
na palestra atual que é básica

7234
04:50:58,000 --> 04:50:59,280
as operações

7235
04:50:59,280 --> 04:51:02,240
E eu vou colar aqueles dentro e eu

7236
04:51:02,240 --> 04:51:04,160
Vou abrir esta pasta no visual

7237
04:51:04,160 --> 04:51:06,400
Código de estúdio, então vamos fazer isso bonito

7238
04:51:06,400 --> 04:51:08,638
rápido vamos fechar as boas-vindas

7239
04:51:08,638 --> 04:51:10,560
tela aqui e nós vamos abrir o nosso

7240
04:51:10,560 --> 04:51:14,240
arquivo cpp principal e vamos remover

7241
04:51:14,240 --> 04:51:16,240
Coisas que não precisamos aqui o primeiro

7242
04:51:16,240 --> 04:51:18,240
O que queremos brincar é a adição

7243
04:51:18,240 --> 04:51:20,480
Então nós vamos dizer isso e nós somos

7244
04:51:20,480 --> 04:51:23,280
vamos declarar duas variáveis finais que somos

7245
04:51:23,280 --> 04:51:25,120
Vou chamar este número um e nós somos

7246
04:51:25,120 --> 04:51:27,680
Vou colocar em um dois, por exemplo

7247
04:51:27,680 --> 04:51:30,718
E nós vamos fazer um número dois

7248
04:51:30,718 --> 04:51:32,798
e nós vamos colocar em um sete porquê

7249
04:51:32,798 --> 04:51:35,600
Não e o que podemos fazer podemos dizer

7250
04:51:35,600 --> 04:51:39,440
resultado é igual ao número um mais o número dois

7251
04:51:39,440 --> 04:51:41,200
e nós vamos armazenar o resultado de

7252
04:51:41,200 --> 04:51:44,000
Esta operação e a variável de resultado

7253
04:51:44,000 --> 04:51:47,520
Então o que podemos fazer é dizer sddcl e

7254
04:51:47,520 --> 04:51:50,000
Vamos imprimir o resultado que podemos

7255
04:51:50,000 --> 04:51:53,040
Tente compilar isso e ver o resultado

7256
04:51:53,040 --> 04:51:55,440
Vamos abrir o nosso terminal aqui

7257
04:51:55,440 --> 04:51:58,480
e nós vamos construir com gcc como nós

7258
04:51:58,480 --> 04:51:59,840
Sempre faça

7259
04:51:59,840 --> 04:52:02,000
O mundo vai passar e se

7260
04:52:02,000 --> 04:52:04,320
nós corremos o galo aqui nós vamos ver

7261
04:52:04,320 --> 04:52:08,160
O resultado da nossa operação é 9.

7262
04:52:08,160 --> 04:52:10,480
Então é assim que você pode fazer a adição

7263
04:52:10,480 --> 04:52:13,360
Você também pode fazer subtração e aqui nós

7264
04:52:13,360 --> 04:52:15,200
para declarar uma nova variável que somos

7265
04:52:15,200 --> 04:52:17,120
Vou armazenar o resultado

7266
04:52:17,120 --> 04:52:17,920
Os de que a si a si a do que sobre a, a , a , a , aja, a , a, a, a

7267
04:52:17,920 --> 04:52:20,320
nosso resultado variável aqui, então o que somos

7268
04:52:20,320 --> 04:52:23,280
ir fazer aqui é dizer subtração e

7269
04:52:23,280 --> 04:52:25,280
nós vamos dizer resultado

7270
04:52:25,280 --> 04:52:28,878
igual, por exemplo, vamos tomar o número dois

7271
04:52:28,878 --> 04:52:31,600
menos o número um, esta é a operação

7272
04:52:31,600 --> 04:52:34,320
Queremos fazer isso é o número dois, o que nós

7273
04:52:34,320 --> 04:52:36,560
vai estar armazenando neste resultado

7274
04:52:36,560 --> 04:52:39,440
Aqui vai ser um 5 porque nós somos

7275
04:52:39,440 --> 04:52:42,878
tomando 7 e subtraindo 2. espero que isso

7276
04:52:42,878 --> 04:52:46,480
Faz sentido, então se pegarmos essa linha aqui

7277
04:52:46,480 --> 04:52:48,958
e colá-lo aqui para que nós economizemos em

7278
04:52:48,958 --> 04:52:51,040
algum tempo de digitação

7279
04:52:51,040 --> 04:52:53,200
E eu tento construir novamente

7280
04:52:53,200 --> 04:52:54,320
nós vamos

7281
04:52:54,320 --> 04:52:57,600
executar a tarefa mundial com gcc

7282
04:52:57,600 --> 04:53:00,000
e nós vamos executar o galo novamente

7283
04:53:00,000 --> 04:53:02,878
Vamos dizer que o resultado é 5 porque nós

7284
04:53:02,878 --> 04:53:03,600
São

7285
04:53:03,600 --> 04:53:06,320
tomando 7 menos dois aqui o resultado é

7286
04:53:06,320 --> 04:53:09,200
serão cinco, também podemos fazer a

7287
04:53:09,200 --> 04:53:11,840
operação de subtração que vai

7288
04:53:11,840 --> 04:53:14,320
resultar em um número negativo para

7289
04:53:14,320 --> 04:53:18,080
Exemplo podemos dizer que resultados são iguais

7290
04:53:18,080 --> 04:53:20,878
Número um menos o número dois

7291
04:53:20,878 --> 04:53:22,638
E isso vai nos dar um negativo

7292
04:53:22,638 --> 04:53:24,638
número porque dois menos sete estão indo

7293
04:53:24,638 --> 04:53:27,200
Para ser menos cinco assim

7294
04:53:27,200 --> 04:53:29,680
nós vamos imprimir que aqui eu estou indo

7295
04:53:29,680 --> 04:53:31,600
para colar esse fim porque eu ainda tenho

7296
04:53:31,600 --> 04:53:33,520
Isso na minha área de transferência

7297
04:53:33,520 --> 04:53:37,280
se eu aparar com gcc e executar o meu programa

7298
04:53:37,280 --> 04:53:40,798
nós vamos conseguir -5 como resultado de

7299
04:53:40,798 --> 04:53:43,040
Esta operação aqui é assim que você pode

7300
04:53:43,040 --> 04:53:45,040
fazer subtração que nós também podemos fazer

7301
04:53:45,040 --> 04:53:47,520
multiplicação então vamos descer aqui e

7302
04:53:47,520 --> 04:53:50,480
Diga isso e vamos dizer resultado

7303
04:53:50,480 --> 04:53:53,760
igual ao número um multiplicado pelo número

7304
04:53:53,760 --> 04:53:56,320
dois e este é o operador que costumávamos

7305
04:53:56,320 --> 04:53:58,320
fazer a multiplicação na programação

7306
04:53:58,320 --> 04:54:00,560
línguas que vamos colocar em nosso

7307
04:54:00,560 --> 04:54:02,798
declaração de impressão aqui

7308
04:54:02,798 --> 04:54:05,920
e nós vamos para o mundo com gcc

7309
04:54:05,920 --> 04:54:08,718
E se corrermos o galo agora vamos

7310
04:54:08,718 --> 04:54:12,000
obter 14 porque estamos tomando

7311
04:54:12,000 --> 04:54:14,798
2 e multiplicando isso com 7.

7312
04:54:14,798 --> 04:54:17,200
Como você pode fazer multiplicação

7313
04:54:17,200 --> 04:54:20,000
Então o que acontece se você tomar

7314
04:54:20,000 --> 04:54:22,718
sete e dividir isso com dois tentam

7315
04:54:22,718 --> 04:54:24,718
dar isso um palpite com base no que vimos

7316
04:54:24,718 --> 04:54:26,638
nos slides nós vamos descer

7317
04:54:26,638 --> 04:54:28,878
aqui e fazer divisão e nós vamos

7318
04:54:28,878 --> 04:54:32,400
O resultado é igual ao número dois dividido por

7319
04:54:32,400 --> 04:54:34,480
Número um e uh

7320
04:54:34,480 --> 04:54:36,638
nós vamos tentar imprimir isso se

7321
04:54:36,638 --> 04:54:38,718
Construímos isso o mundo vai embora

7322
04:54:38,718 --> 04:54:41,040
E se corrermos isso, vamos

7323
04:54:41,040 --> 04:54:43,920
ver que esse resultado é três

7324
04:54:43,920 --> 04:54:45,920
para realmente fazer sentido disso vamos

7325
04:54:45,920 --> 04:54:47,520
Veja esses números que estamos tomando

7326
04:54:47,520 --> 04:54:49,680
número dois e dividindo isso com o número

7327
04:54:49,680 --> 04:54:51,760
Um assim é sete

7328
04:54:51,760 --> 04:54:53,440
Dividido por dois

7329
04:54:53,440 --> 04:54:55,840
e porque não podemos armazenar fracionários

7330
04:54:55,840 --> 04:54:58,878
números em um inteiro do fracionário

7331
04:54:58,878 --> 04:55:01,040
parte vai ser basicamente picada

7332
04:55:01,040 --> 04:55:03,600
Vamos guardar um três

7333
04:55:03,600 --> 04:55:04,718
porque

7334
04:55:04,718 --> 04:55:06,638
Dois podem caber em sete

7335
04:55:06,638 --> 04:55:08,480
Apenas três vezes eu realmente espero que isso

7336
04:55:08,480 --> 04:55:10,320
Faz sentido a última operação que somos

7337
04:55:10,320 --> 04:55:12,400
indo olhar para o módulo

7338
04:55:12,400 --> 04:55:15,200
e é uma maneira de capturar o lembrete

7339
04:55:15,200 --> 04:55:18,160
de uma operação de divisão, então vamos

7340
04:55:18,160 --> 04:55:20,718
para fazer resultados para jogar conosco

7341
04:55:20,718 --> 04:55:23,040
e vamos dizer o número dois e

7342
04:55:23,040 --> 04:55:25,600
vamos dizer módulo usando o

7343
04:55:25,600 --> 04:55:27,920
Percentr operador aqui e nós vamos

7344
04:55:27,920 --> 04:55:29,520
para dizer o número um

7345
04:55:29,520 --> 04:55:31,840
e vamos imprimir o resultado de

7346
04:55:31,840 --> 04:55:33,680
Isto e uh

7347
04:55:33,680 --> 04:55:35,520
Veja isso aqui e tente

7348
04:55:35,520 --> 04:55:37,200
Adivinha o que vamos fazer o que

7349
04:55:37,200 --> 04:55:39,520
Estamos fazendo aqui é realmente

7350
04:55:39,520 --> 04:55:40,400
sete

7351
04:55:40,400 --> 04:55:41,920
o módulo

7352
04:55:41,920 --> 04:55:43,200
Dois dos dois

7353
04:55:43,200 --> 04:55:45,440
E nós vamos ter sete divisões

7354
04:55:45,440 --> 04:55:46,878
Isso por dois

7355
04:55:46,878 --> 04:55:49,360
e o lembrete disso vai ser

7356
04:55:49,360 --> 04:55:52,000
Um e é isso que vamos guardar

7357
04:55:52,000 --> 04:55:54,560
nesta variável de resultados aqui e se nós

7358
04:55:54,560 --> 04:55:57,520
impressão que esperamos obter um aqui

7359
04:55:57,520 --> 04:56:00,480
Isto é o que o módulo faz, vamos construir

7360
04:56:00,480 --> 04:56:03,440
e construir com gcc o mundo vai

7361
04:56:03,440 --> 04:56:06,080
Vamos passar se corrermos o galo aqui estamos

7362
04:56:06,080 --> 04:56:08,718
Vou ter um um, vamos fazer o que usamos

7363
04:56:08,718 --> 04:56:10,878
no slide para que isso realmente faça

7364
04:56:10,878 --> 04:56:13,520
Sentimos que vamos descer aqui e eu

7365
04:56:13,520 --> 04:56:14,400
- É assim.

7366
04:56:14,400 --> 04:56:18,400
igual a 31 módulo 10. isto é o que nós

7367
04:56:18,400 --> 04:56:20,000
usado nos slides

7368
04:56:20,000 --> 04:56:22,320
Então vamos imprimir o resultado aqui

7369
04:56:22,320 --> 04:56:24,878
E aqui estamos realmente perguntando

7370
04:56:24,878 --> 04:56:27,040
O que vai ser o lembrete se nós

7371
04:56:27,040 --> 04:56:30,160
tomar 31 e dividir isso por 10 e que

7372
04:56:30,160 --> 04:56:32,080
O lembrete será armazenado neste

7373
04:56:32,080 --> 04:56:34,320
pesquisa variável então aqui também estamos

7374
04:56:34,320 --> 04:56:37,600
vou ter um, então vamos soldar com

7375
04:56:37,600 --> 04:56:40,718
gcc e nós vamos executar o programa

7376
04:56:40,718 --> 04:56:43,680
E nós também vamos ter um para baixo

7377
04:56:43,680 --> 04:56:46,878
Aqui novamente o operador do módulo pode ser

7378
04:56:46,878 --> 04:56:49,520
É difícil de entender para iniciantes, mas

7379
04:56:49,520 --> 04:56:51,920
está realmente capturando o lembrete do

7380
04:56:51,920 --> 04:56:54,638
Divisão novamente, podemos ver que aqui estamos

7381
04:56:54,638 --> 04:56:58,240
estão perguntando quantas vezes 10 podem caber em

7382
04:56:58,240 --> 04:57:01,040
31 e nós visualizamos isso aqui pode

7383
04:57:01,040 --> 04:57:04,160
Basta caber em três vezes e o lembrete

7384
04:57:04,160 --> 04:57:06,080
Vai ser essa coisa vermelha que você vê

7385
04:57:06,080 --> 04:57:08,400
Aqui vai ser um e quando o fizermos

7386
04:57:08,400 --> 04:57:10,480
uma operação de módulo aqui estamos

7387
04:57:10,480 --> 04:57:12,798
interessado nesse lembrete e isso é

7388
04:57:12,798 --> 04:57:14,638
O que vamos armazenar em

7389
04:57:14,638 --> 04:57:16,638
Seja qual for a variável que esteja capturando a

7390
04:57:16,638 --> 04:57:20,240
resultado desta operação de módulos

7391
04:57:20,240 --> 04:57:22,878
E é isso que basicamente temos aqui

7392
04:57:22,878 --> 04:57:24,480
E isso é realmente tudo o que nos prossistimos

7393
04:57:24,480 --> 04:57:26,718
nesta palestra agora espero que você tenha um

7394
04:57:26,718 --> 04:57:28,638
Boa compreensão dessas operações

7395
04:57:28,638 --> 04:57:31,520
você pode fazer em inteiros que usamos

7396
04:57:31,520 --> 04:57:34,000
inteiros aqui, mas você pode realmente fazer

7397
04:57:34,000 --> 04:57:37,040
essas operações em números, exceto

7398
04:57:37,040 --> 04:57:39,360
o operador do módulo que é realmente

7399
04:57:39,360 --> 04:57:42,320
vai fazer sentido para os tipos integrais

7400
04:57:42,320 --> 04:57:43,040
Então,

7401
04:57:43,040 --> 04:57:45,760
você não pode realmente fazer o módulo em flutuação

7402
04:57:45,760 --> 04:57:48,240
pontos ou números fracionários que não são

7403
04:57:48,240 --> 04:57:50,160
Vou fazer qualquer sentido em tudo que somos

7404
04:57:50,160 --> 04:57:52,080
Vou parar aqui nesta palestra em

7405
04:57:52,080 --> 04:57:53,760
O próximo que vamos aprender sobre

7406
04:57:53,760 --> 04:57:56,480
precedência e associatividade muito

7407
04:57:56,480 --> 04:57:59,120
Conceito importante para suas operações em

7408
04:57:59,120 --> 04:58:01,440
seus c plus mais programas

7409
04:58:01,440 --> 04:58:02,878
Nesta palestra vamos aprender

7410
04:58:02,878 --> 04:58:05,600
sobre a precedência e a associatividade assim

7411
04:58:05,600 --> 04:58:07,600
O que queremos dizer com precedência e

7412
04:58:07,600 --> 04:58:10,000
A associatividade realmente o que queremos dizer com

7413
04:58:10,000 --> 04:58:12,480
Este é um conjunto de regras que podemos

7414
04:58:12,480 --> 04:58:13,520
Seguir

7415
04:58:13,520 --> 04:58:15,680
Para saber o que fazer

7416
04:58:15,680 --> 04:58:18,240
quando temos vários operadores no

7417
04:58:18,240 --> 04:58:19,760
A mesma expressão

7418
04:58:19,760 --> 04:58:22,240
como no exemplo que temos aqui se eles

7419
04:58:22,240 --> 04:58:24,798
Diga-lhe para avaliar o resultado disso

7420
04:58:24,798 --> 04:58:26,080
expressão

7421
04:58:26,080 --> 04:58:28,560
Se não temos regras claras a seguir

7422
04:58:28,560 --> 04:58:31,280
Podemos ter várias respostas e nós

7423
04:58:31,280 --> 04:58:33,600
Quer saber qual é certo ou errado

7424
04:58:33,600 --> 04:58:36,638
Por exemplo, pode-se querer fazer a e b

7425
04:58:36,638 --> 04:58:39,600
primeiro e depois fazer c e depois fazer d mas

7426
04:58:39,600 --> 04:58:43,360
um pode querer fazer e minus f

7427
04:58:43,360 --> 04:58:46,240
e b multiplicar por c e então fazer

7428
04:58:46,240 --> 04:58:48,320
coisas de maneiras diferentes e chegar

7429
04:58:48,320 --> 04:58:49,920
Resultados diferentes

7430
04:58:49,920 --> 04:58:52,080
Espero que você esteja dizendo que isso pode

7431
04:58:52,080 --> 04:58:54,798
ser um grande problema do que obtemos

7432
04:58:54,798 --> 04:58:57,120
A precedência e a associatividade são

7433
04:58:57,120 --> 04:58:59,360
regras que podemos seguir para saber quais

7434
04:58:59,360 --> 04:59:02,400
Operador temos que fazer primeiro, por exemplo

7435
04:59:02,400 --> 04:59:04,000
em c plus plus

7436
04:59:04,000 --> 04:59:07,440
O operador de multiplicação e divisão

7437
04:59:07,440 --> 04:59:10,000
tem que ser feito antes de fazer a adição

7438
04:59:10,000 --> 04:59:12,718
e subtração e se você quiser

7439
04:59:12,718 --> 04:59:15,040
Avalie esta expressão aqui você

7440
04:59:15,040 --> 04:59:18,000
ter que fazer b e c primeiro e

7441
04:59:18,000 --> 04:59:21,120
então do d e e uma vez que você tem esses

7442
04:59:21,120 --> 04:59:23,920
resultados, então você pode fazer adição e

7443
04:59:23,920 --> 04:59:26,560
subtração, mas a questão permanece

7444
04:59:26,560 --> 04:59:27,680
Ainda assim

7445
04:59:27,680 --> 04:59:30,798
O que fazemos primeiro se tivermos apenas

7446
04:59:30,798 --> 04:59:32,798
adição e subtração em um

7447
04:59:32,798 --> 04:59:35,440
expiração e resolvemos esse problema

7448
04:59:35,440 --> 04:59:38,638
A associatividade associatividade define

7449
04:59:38,638 --> 04:59:41,120
Se você fizer as operações da esquerda

7450
04:59:41,120 --> 04:59:42,638
ou a partir da direita

7451
04:59:42,638 --> 04:59:44,638
e novamente essas coisas podem não fazer

7452
04:59:44,638 --> 04:59:47,040
Sentir, mas vamos fazer um exemplo

7453
04:59:47,040 --> 04:59:49,600
Você vai realmente ver o que é

7454
04:59:49,600 --> 04:59:50,958
Significado por isso

7455
04:59:50,958 --> 04:59:53,680
para resumir a precedência diz qual

7456
04:59:53,680 --> 04:59:56,400
operação que você pode fazer primeiro e

7457
04:59:56,400 --> 04:59:58,560
A associatividade vai te dizer em

7458
04:59:58,560 --> 05:00:00,400
de qual direção você vai seguir

7459
05:00:00,400 --> 05:00:02,480
A esquerda ou da direita e alguns

7460
05:00:02,480 --> 05:00:04,000
Os operadores vão ficar

7461
05:00:04,000 --> 05:00:06,480
associativo e isso significa que você é

7462
05:00:06,480 --> 05:00:08,798
Vou começar a avaliá-los a partir do

7463
05:00:08,798 --> 05:00:11,200
Algumas operações vão ser

7464
05:00:11,200 --> 05:00:13,360
associativo direito e você vai

7465
05:00:13,360 --> 05:00:16,480
Comece a avaliá-los pela direita e

7466
05:00:16,480 --> 05:00:18,638
Eu não estou fazendo essas coisas lá em cima

7467
05:00:18,638 --> 05:00:20,798
Na verdade um c plus mais operador

7468
05:00:20,798 --> 05:00:24,480
tabela de precedência que você pode consultar

7469
05:00:24,480 --> 05:00:26,400
Saiba quais operadores

7470
05:00:26,400 --> 05:00:29,280
Você deve fazer primeiro se você realmente é

7471
05:00:29,280 --> 05:00:31,760
Avaliando essa coisa com sua mente

7472
05:00:31,760 --> 05:00:33,680
Por exemplo, se você olhar para isso

7473
05:00:33,680 --> 05:00:35,920
tabela existem muitos operadores que nós

7474
05:00:35,920 --> 05:00:37,840
Ainda não vi, mas não é o

7475
05:00:37,840 --> 05:00:40,400
O problema, o mais importante aqui é

7476
05:00:40,400 --> 05:00:42,160
para saber que precedência e

7477
05:00:42,160 --> 05:00:45,040
A associatividade é e quando chegamos a

7478
05:00:45,040 --> 05:00:47,600
Saiba mais sobre esses novos operadores que você pode

7479
05:00:47,600 --> 05:00:50,400
Venha aqui e saiba onde eles se sentam

7480
05:00:50,400 --> 05:00:52,878
Este quadro de precedência, por exemplo,

7481
05:00:52,878 --> 05:00:56,320
Saiba como fazer multiplicação de adição

7482
05:00:56,320 --> 05:00:57,920
e o módulo

7483
05:00:57,920 --> 05:01:00,160
Vemos que a precedência para

7484
05:01:00,160 --> 05:01:03,360
divisão e módulo de multiplicação

7485
05:01:03,360 --> 05:01:06,240
é maior do que para a adição e

7486
05:01:06,240 --> 05:01:07,520
Subtração

7487
05:01:07,520 --> 05:01:10,400
e nós podemos usar isso em nossos operadores para

7488
05:01:10,400 --> 05:01:11,360
- Conhecer

7489
05:01:11,360 --> 05:01:13,920
Qual vai ser avaliado por

7490
05:01:13,920 --> 05:01:16,798
nosso compilador primeiro outra coisa que eu quero

7491
05:01:16,798 --> 05:01:18,798
Você notar nesta tabela é esta

7492
05:01:18,798 --> 05:01:21,680
coluna aqui sobre associatividade se você for

7493
05:01:21,680 --> 05:01:24,320
de volta aos nossos operadores familiares aqui

7494
05:01:24,320 --> 05:01:25,840
Você vai ver isso

7495
05:01:25,840 --> 05:01:28,958
Esses operadores são da esquerda para a direita, então você

7496
05:01:28,958 --> 05:01:31,920
Deve começar a avaliar as coisas da esquerda

7497
05:01:31,920 --> 05:01:35,200
para o direito, mas alguns operadores têm direito

7498
05:01:35,200 --> 05:01:38,320
para deixar a associatividade e quando chegarmos

7499
05:01:38,320 --> 05:01:40,320
Esses operadores você começará a fazer

7500
05:01:40,320 --> 05:01:42,958
coisas da direita para a esquerda ok eu

7501
05:01:42,958 --> 05:01:45,040
Acho que é hora de irmos para o visual

7502
05:01:45,040 --> 05:01:47,120
código de estúdio e realmente jogou com

7503
05:01:47,120 --> 05:01:49,920
Agradecimentos aqui estamos no estúdio visual

7504
05:01:49,920 --> 05:01:53,120
código que estamos em nossa pasta de trabalho que somos

7505
05:01:53,120 --> 05:01:55,200
Vou pegar nossos projetos de template

7506
05:01:55,200 --> 05:01:57,840
Vamos copiar isso e colocar isso em

7507
05:01:57,840 --> 05:02:00,000
nossa palestra sobre precedência e

7508
05:02:00,000 --> 05:02:02,480
associatividade em que vamos colocar isso

7509
05:02:02,480 --> 05:02:05,280
Aqui vamos abrir este projeto

7510
05:02:05,280 --> 05:02:07,760
em código de estúdio visual que vamos

7511
05:02:07,760 --> 05:02:09,920
Livre-se das coisas que não precisamos e

7512
05:02:09,920 --> 05:02:12,878
Remova isso aqui no corpo e estamos

7513
05:02:12,878 --> 05:02:15,920
vamos colocar o nosso código de teste para que

7514
05:02:15,920 --> 05:02:18,400
não precisa digitar isso e economizar tempo

7515
05:02:18,400 --> 05:02:21,600
temos algumas variáveis aqui através de g

7516
05:02:21,600 --> 05:02:24,160
e nós temos uma expressão aqui ou a

7517
05:02:24,160 --> 05:02:25,520
Declaração

7518
05:02:25,520 --> 05:02:28,320
que está combinando multiplicação

7519
05:02:28,320 --> 05:02:31,760
adição e subtração de divisão e nós

7520
05:02:31,760 --> 05:02:34,000
Tenho que descobrir qual operação somos

7521
05:02:34,000 --> 05:02:35,680
Vou fazer primeiro

7522
05:02:35,680 --> 05:02:38,320
Eu desafiaria você a fazer isso em seu

7523
05:02:38,320 --> 05:02:40,480
mente e tentar adivinhar qual é o resultado

7524
05:02:40,480 --> 05:02:43,680
Vou ser antes de corrermos isso em nosso

7525
05:02:43,680 --> 05:02:46,400
compilador, vamos compilar isso

7526
05:02:46,400 --> 05:02:49,360
Com gcc e vamos abrir o nosso

7527
05:02:49,360 --> 05:02:50,718
O terminal aqui

7528
05:02:50,718 --> 05:02:53,200
E se fizermos durham, vamos ver

7529
05:02:53,200 --> 05:02:55,840
que temos galo.exe

7530
05:02:55,840 --> 05:02:58,160
Se nós executarmos, vamos ver que o

7531
05:02:58,160 --> 05:03:01,120
O resultado é 30. como chegamos a

7532
05:03:01,120 --> 05:03:03,760
que bem a precedência e

7533
05:03:03,760 --> 05:03:06,000
A tabela de associatividade diz que

7534
05:03:06,000 --> 05:03:08,560
A multiplicação e a divisão

7535
05:03:08,560 --> 05:03:10,798
É preciso fazer primeiro

7536
05:03:10,798 --> 05:03:14,000
antes da adição e subtração, somos

7537
05:03:14,000 --> 05:03:16,560
indo tomar b e c e multiplicar aqueles

7538
05:03:16,560 --> 05:03:19,040
então b e c multiplicaram que nós vamos ter

7539
05:03:19,040 --> 05:03:21,600
24 vamos tentar fazer isso em

7540
05:03:21,600 --> 05:03:24,080
nosso cérebro d dividido por um que vamos

7541
05:03:24,080 --> 05:03:25,040
- Faz isso.

7542
05:03:25,040 --> 05:03:28,320
então d dividido por e nós vamos ter um 3

7543
05:03:28,320 --> 05:03:31,040
Então vamos ter um 3 aqui e

7544
05:03:31,040 --> 05:03:33,120
Depois que temos isso, vamos fazer

7545
05:03:33,120 --> 05:03:36,400
adição e subtração, então estamos indo

7546
05:03:36,400 --> 05:03:39,680
tomar um e adicionar isso ao resultado de

7547
05:03:39,680 --> 05:03:42,480
b e c então nós vamos dizer

7548
05:03:42,480 --> 05:03:46,638
6 mais 24 que é o resultado de b e c

7549
05:03:46,638 --> 05:03:48,718
nós vamos menos os resultados de d

7550
05:03:48,718 --> 05:03:51,920
e e e nós vamos fazer menos aqui eu

7551
05:03:51,920 --> 05:03:53,760
Espero que você esteja seguindo e então nós somos

7552
05:03:53,760 --> 05:03:56,798
indo para menos f e mais g nós estamos indo

7553
05:03:56,798 --> 05:03:59,520
para menos f que é 2

7554
05:03:59,520 --> 05:04:01,600
e fazer um plus g

7555
05:04:01,600 --> 05:04:05,520
que é 5. Ok, então este é o nosso

7556
05:04:05,520 --> 05:04:07,600
expressão aqui e agora que temos

7557
05:04:07,600 --> 05:04:09,440
Temos que pensar em como somos

7558
05:04:09,440 --> 05:04:11,600
Vou fazer isso, podemos tentar fazer isso

7559
05:04:11,600 --> 05:04:14,958
da direita fazer dois mais cinco e, em seguida,

7560
05:04:14,958 --> 05:04:18,400
fazer três menos dois mais cinco e ir de

7561
05:04:18,400 --> 05:04:21,440
de direita para a esquerda, mas nossa associatividade

7562
05:04:21,440 --> 05:04:25,280
A tabela diz que adição e subtração

7563
05:04:25,280 --> 05:04:28,000
Temos deixado para a direita associatividade para que nós

7564
05:04:28,000 --> 05:04:30,560
Vou começar pela esquerda, então vamos

7565
05:04:30,560 --> 05:04:34,080
Para fazer 6 mais 24, vamos ter 30

7566
05:04:34,080 --> 05:04:36,560
nós vamos para menos 3 e nós vamos

7567
05:04:36,560 --> 05:04:38,798
Para obter 27 nós vamos para menos 2 nós somos

7568
05:04:38,798 --> 05:04:41,680
Vou ter 25, vamos adicionar 5

7569
05:04:41,680 --> 05:04:43,440
nós vamos ter 30 anos. Eu espero que você esteja

7570
05:04:43,440 --> 05:04:45,760
Seguindo e estamos realmente seguindo

7571
05:04:45,760 --> 05:04:48,480
as regras do nosso operador c plus plus

7572
05:04:48,480 --> 05:04:50,958
Tabela de precedência aqui ok, então isso é

7573
05:04:50,958 --> 05:04:53,920
realmente como você usaria essa precedência

7574
05:04:53,920 --> 05:04:56,240
e as regras de atividade de pesquisa para

7575
05:04:56,240 --> 05:05:00,000
Avalie suas expressões ok aqui

7576
05:05:00,000 --> 05:05:03,600
Tenho outro exemplo para você, então tente

7577
05:05:03,600 --> 05:05:05,840
avaliar o que vamos obter

7578
05:05:05,840 --> 05:05:07,520
Esta expressão aqui

7579
05:05:07,520 --> 05:05:10,718
temos uma divisão por b dividida por c mais

7580
05:05:10,718 --> 05:05:13,440
d menos e mais f tentar fazer isso em seu

7581
05:05:13,440 --> 05:05:15,680
cérebro e tentar adivinhar o que estamos indo

7582
05:05:15,680 --> 05:05:18,560
para obter do compilador se imprimirmos

7583
05:05:18,560 --> 05:05:20,000
Isto para fora

7584
05:05:20,000 --> 05:05:22,798
nós vamos colocar em nosso htdc para fora

7585
05:05:22,798 --> 05:05:24,798
Declaração aqui e nós vamos tentar

7586
05:05:24,798 --> 05:05:28,400
e construir isso com gcc, claro que nós somos

7587
05:05:28,400 --> 05:05:30,240
indo para correr o galo e você está

7588
05:05:30,240 --> 05:05:33,200
Vou ter um 24. então como chegamos

7589
05:05:33,200 --> 05:05:35,600
Com isso, vamos começar

7590
05:05:35,600 --> 05:05:39,600
divisão e multiplicação e novamente

7591
05:05:39,600 --> 05:05:42,798
Onde começamos, fazemos b e c primeiro

7592
05:05:42,798 --> 05:05:46,160
ou fazemos a e b primeiro bem podemos

7593
05:05:46,160 --> 05:05:48,958
Confira nossa tabela de precedência aqui

7594
05:05:48,958 --> 05:05:50,080
e nós vamos verificar o

7595
05:05:50,080 --> 05:05:53,360
associatividade da multiplicação e

7596
05:05:53,360 --> 05:05:56,080
Divisão vamos para esta entrada

7597
05:05:56,080 --> 05:05:59,280
aqui 13 e vemos que é deixado para

7598
05:05:59,280 --> 05:06:02,560
direito associativo dessas operações aqui

7599
05:06:02,560 --> 05:06:05,440
são de esquerda para direita associativa para que

7600
05:06:05,440 --> 05:06:06,878
nós vamos fazer nós vamos começar

7601
05:06:06,878 --> 05:06:09,440
da esquerda e ir para a direita, então estamos

7602
05:06:09,440 --> 05:06:12,320
vamos tomar um e dividir por b se nós

7603
05:06:12,320 --> 05:06:14,560
tomar um dividido por b

7604
05:06:14,560 --> 05:06:17,680
2 então vamos digitar que aqui, então

7605
05:06:17,680 --> 05:06:20,160
O resultado disso vai ser multiplicado

7606
05:06:20,160 --> 05:06:22,320
por c e se subirmos, vamos ver

7607
05:06:22,320 --> 05:06:24,560
que c é oito, então nós vamos

7608
05:06:24,560 --> 05:06:26,320
Multiplicar por oito

7609
05:06:26,320 --> 05:06:29,440
e obter seis para que possamos substituir isso com

7610
05:06:29,440 --> 05:06:30,958
a 16

7611
05:06:30,958 --> 05:06:32,718
E nós deveríamos estar aqui

7612
05:06:32,718 --> 05:06:36,958
então nós vamos adicionar d d é nove, então

7613
05:06:36,958 --> 05:06:38,400
Nós vamos subtrair

7614
05:06:38,400 --> 05:06:39,440
eo

7615
05:06:39,440 --> 05:06:40,798
O que é

7616
05:06:40,798 --> 05:06:44,480
três, então nós vamos adicionar f que é

7617
05:06:44,480 --> 05:06:47,280
um cinco, então temos 16 mais nove este é

7618
05:06:47,280 --> 05:06:50,560
vamos nos dar 25 menos três

7619
05:06:50,560 --> 05:06:52,718
Tudo bem ao verificar isso eu vejo que eu

7620
05:06:52,718 --> 05:06:54,240
Cometeu um erro

7621
05:06:54,240 --> 05:06:55,680
O f não é

7622
05:06:55,680 --> 05:06:58,638
Cinco é um dois que temos aqui

7623
05:06:58,638 --> 05:07:01,200
E se fizermos isso da esquerda para a direita

7624
05:07:01,200 --> 05:07:03,360
porque adição e subtração são

7625
05:07:03,360 --> 05:07:05,920
Deixados associativos, temos que fazê-los a partir de

7626
05:07:05,920 --> 05:07:08,400
para a direita vamos levar 16

7627
05:07:08,400 --> 05:07:11,440
e adicione um 9 que vamos chegar aos 25

7628
05:07:11,440 --> 05:07:14,718
menos 3 nós vamos ter 22 mais 2 nós

7629
05:07:14,718 --> 05:07:17,200
Vamos ter 24 e é isso que nós

7630
05:07:17,200 --> 05:07:19,840
Tenho aqui eu realmente espero que isso faça sentido

7631
05:07:19,840 --> 05:07:22,320
Tudo bem, então vimos como podemos usar isso

7632
05:07:22,320 --> 05:07:24,000
tabela de precedência

7633
05:07:24,000 --> 05:07:26,560
Mas às vezes você quer realmente fazê-lo

7634
05:07:26,560 --> 05:07:29,280
claro quais operações devem ser feitas

7635
05:07:29,280 --> 05:07:30,240
Primeiro

7636
05:07:30,240 --> 05:07:33,120
e você pode fazer isso usando parênteses

7637
05:07:33,120 --> 05:07:36,000
em torno de suas expressões vamos pegar o

7638
05:07:36,000 --> 05:07:38,560
Primeira expressão aqui e fazê-lo novamente

7639
05:07:38,560 --> 05:07:40,320
nós vamos copiá-lo

7640
05:07:40,320 --> 05:07:41,920
E vá para baixo

7641
05:07:41,920 --> 05:07:44,400
e colocar isso no lugar e nós vamos

7642
05:07:44,400 --> 05:07:48,638
armazenar o resultado em nossa variável de resultados

7643
05:07:48,638 --> 05:07:51,120
e observe que estamos reatribuindo estes

7644
05:07:51,120 --> 05:07:53,680
coisas para variáveis de resultados para que

7645
05:07:53,680 --> 05:07:55,680
não precisa declarar outra variável i

7646
05:07:55,680 --> 05:07:56,958
Acho que isto é

7647
05:07:56,958 --> 05:07:59,680
limpo e é isso que estamos fazendo aqui

7648
05:07:59,680 --> 05:08:02,560
Então o que podemos fazer aqui é deixar claro

7649
05:08:02,560 --> 05:08:05,440
Que queremos a multiplicação feita primeiro

7650
05:08:05,440 --> 05:08:07,440
usando parênteses

7651
05:08:07,440 --> 05:08:08,320
E a

7652
05:08:08,320 --> 05:08:11,040
deixar claro que nós queremos o

7653
05:08:11,040 --> 05:08:13,360
Divisão a ser feita primeiro

7654
05:08:13,360 --> 05:08:15,360
e quando você faz isso, o compilador é

7655
05:08:15,360 --> 05:08:16,878
Vou ver que você quer isso

7656
05:08:16,878 --> 05:08:19,360
operação aqui feita primeiro e isso é

7657
05:08:19,360 --> 05:08:22,560
O que vai fazer e se imprimirmos

7658
05:08:22,560 --> 05:08:25,360
Resultar novamente, vamos conseguir exatamente

7659
05:08:25,360 --> 05:08:28,958
A mesma coisa que tínhamos antes de stdc fora

7660
05:08:28,958 --> 05:08:30,480
O resultado

7661
05:08:30,480 --> 05:08:32,878
e nós vamos colocar o resultado para fora e

7662
05:08:32,878 --> 05:08:35,040
Vamos deixar claro que estamos usando

7663
05:08:35,040 --> 05:08:37,120
Pais aqui para

7664
05:08:37,120 --> 05:08:39,440
Sinal de qual operação queremos ser

7665
05:08:39,440 --> 05:08:42,958
feito primeiro podemos compilar isso com gcc

7666
05:08:42,958 --> 05:08:45,680
Vamos executar a tarefa para

7667
05:08:45,680 --> 05:08:47,920
construção com gcc

7668
05:08:47,920 --> 05:08:50,878
E se executarmos o programa

7669
05:08:50,878 --> 05:08:53,680
Vamos ver que o resultado é 30

7670
05:08:53,680 --> 05:08:56,878
exatamente o que tínhamos antes, mas agora é

7671
05:08:56,878 --> 05:08:59,200
Muito claro para o leitor desta peça

7672
05:08:59,200 --> 05:09:02,560
de código que queremos b e c feito primeiro

7673
05:09:02,560 --> 05:09:04,400
Eles não têm que passar pelo

7674
05:09:04,400 --> 05:09:06,718
tabela de precedência para realmente tentar e

7675
05:09:06,718 --> 05:09:09,040
descobrir isso potencialmente desperdiçando

7676
05:09:09,040 --> 05:09:11,040
Tempo precioso outra coisa que você pode fazer

7677
05:09:11,040 --> 05:09:14,320
Isto é, por exemplo, o que se

7678
05:09:14,320 --> 05:09:16,480
A tabela de precedência não está funcionando

7679
05:09:16,480 --> 05:09:19,200
de acordo com suas necessidades, por exemplo,

7680
05:09:19,200 --> 05:09:21,360
realmente quero a e b

7681
05:09:21,360 --> 05:09:23,840
feito primeiro você pode especificar isso com

7682
05:09:23,840 --> 05:09:26,320
pais aqui e o que isso é basicamente

7683
05:09:26,320 --> 05:09:28,560
O fazer é forçar o

7684
05:09:28,560 --> 05:09:31,280
compilador para fazer isso primeiro não é mais

7685
05:09:31,280 --> 05:09:33,920
indo fazer b multiplicar por c e d

7686
05:09:33,920 --> 05:09:37,120
Dividido por e vai avaliar isso

7687
05:09:37,120 --> 05:09:39,360
primeiro, então vai seguir o

7688
05:09:39,360 --> 05:09:41,840
ordem na tabela de precedência que nós

7689
05:09:41,840 --> 05:09:44,240
Já vi antes, então tente adivinhar o que

7690
05:09:44,240 --> 05:09:46,480
nós vamos ficar agora e eu estou indo para

7691
05:09:46,480 --> 05:09:48,718
executar o código e nós vamos

7692
05:09:48,718 --> 05:09:51,360
passar por isso juntos, então vamos correr

7693
05:09:51,360 --> 05:09:54,480
tarefa e vamos correr um galo agora

7694
05:09:54,480 --> 05:09:57,520
Você vê que o resultado é 72. o que é

7695
05:09:57,520 --> 05:10:00,160
Acontecendo aqui bem, vamos passar

7696
05:10:00,160 --> 05:10:03,520
esta linha por linha estamos fazendo um plus b

7697
05:10:03,520 --> 05:10:05,520
O que é um

7698
05:10:05,520 --> 05:10:08,000
9 então vamos ter um nove aqui

7699
05:10:08,000 --> 05:10:09,840
nós vamos colocar isso aqui como um

7700
05:10:09,840 --> 05:10:11,520
Comentário, então vamos multiplicar

7701
05:10:11,520 --> 05:10:13,120
que por c

7702
05:10:13,120 --> 05:10:16,718
Então vamos fazer 9 multiplicar por 8 e

7703
05:10:16,718 --> 05:10:20,160
que vai render um 72

7704
05:10:20,160 --> 05:10:23,440
E por esse tempo vamos estar aqui

7705
05:10:23,440 --> 05:10:26,958
e vamos fazer a divisão primeiro

7706
05:10:26,958 --> 05:10:28,560
d por e

7707
05:10:28,560 --> 05:10:30,878
Então vamos levar nove e dividir

7708
05:10:30,878 --> 05:10:33,040
por três que vai render os três

7709
05:10:33,040 --> 05:10:35,120
Então vamos ter um três aqui

7710
05:10:35,120 --> 05:10:36,718
Mino 3

7711
05:10:36,718 --> 05:10:39,760
nós vamos para menos f que é um 2 e

7712
05:10:39,760 --> 05:10:42,798
vamos fazer mais g, que é um 5.

7713
05:10:42,798 --> 05:10:44,958
Se avaliarmos isso

7714
05:10:44,958 --> 05:10:47,440
nós vamos ter 72 menos 3, que é

7715
05:10:47,440 --> 05:10:50,878
vai ser 69 menos 2 que vai ser

7716
05:10:50,878 --> 05:10:54,958
67 mais 2 vai ser 72 e isso é

7717
05:10:54,958 --> 05:10:57,040
O que temos aqui espero que você possa ver

7718
05:10:57,040 --> 05:11:00,080
Usar os pais não só pode

7719
05:11:00,080 --> 05:11:02,480
deixar bem claro qual operação você

7720
05:11:02,480 --> 05:11:04,400
Quero ser feito primeiro você também pode

7721
05:11:04,400 --> 05:11:07,680
definir as regras que são prescritas por

7722
05:11:07,680 --> 05:11:10,080
As tabelas de precedência que são definidas

7723
05:11:10,080 --> 05:11:12,878
em c plus mais espero que isso faça sentido

7724
05:11:12,878 --> 05:11:14,400
E isso é realmente tudo o que estabelecemos para fazer

7725
05:11:14,400 --> 05:11:16,480
Nesta palestra para aprender um pouco mais

7726
05:11:16,480 --> 05:11:19,200
sobre a precedência e a associatividade

7727
05:11:19,200 --> 05:11:22,000
e meu conselho para começar os programadores

7728
05:11:22,000 --> 05:11:24,958
Não é confiar na mesa do presidente

7729
05:11:24,958 --> 05:11:27,760
demais é para tentar fazer seu

7730
05:11:27,760 --> 05:11:30,958
intenção muito clara usando parênteses e

7731
05:11:30,958 --> 05:11:32,560
Qualquer pessoa que leia o seu código que você quer

7732
05:11:32,560 --> 05:11:35,200
Tenho que verificar estas regras em

7733
05:11:35,200 --> 05:11:37,680
A referência c plus mais documentação

7734
05:11:37,680 --> 05:11:39,840
eles vão entender diretamente

7735
05:11:39,840 --> 05:11:42,160
O que sua expressão vai fazer e

7736
05:11:42,160 --> 05:11:44,718
Isso é uma boa leitura da sua

7737
05:11:44,718 --> 05:11:46,718
Código é realmente algo que você deveria

7738
05:11:46,718 --> 05:11:48,798
Esforce-se para isso é realmente tudo o que estabelecemos

7739
05:11:48,798 --> 05:11:50,878
para fazer nesta palestra eu espero que você tenha um

7740
05:11:50,878 --> 05:11:54,080
Melhor ideia sobre a precedência

7741
05:11:54,080 --> 05:11:56,560
E associatividade vamos parar

7742
05:11:56,560 --> 05:11:58,480
aqui nesta palestra e na próxima

7743
05:11:58,480 --> 05:12:00,000
Vamos aprender sobre algum legal

7744
05:12:00,000 --> 05:12:02,320
Coisas que podemos fazer com adição e

7745
05:12:02,320 --> 05:12:03,840
Subtração

7746
05:12:03,840 --> 05:12:06,080
Vá em frente e termine aqui e me encontre

7747
05:12:06,080 --> 05:12:07,840
lá nesta palestra vamos estar

7748
05:12:07,840 --> 05:12:10,400
aprender sobre prefixo e postfix

7749
05:12:10,400 --> 05:12:13,120
adição e subtração, temos um

7750
05:12:13,120 --> 05:12:15,600
Exemplo aqui e é um exemplo simples

7751
05:12:15,600 --> 05:12:18,718
Já vimos muitas vezes agora que temos

7752
05:12:18,718 --> 05:12:21,360
um valor variável é um inteiro e nós

7753
05:12:21,360 --> 05:12:25,440
ter um 5 dentro, podemos adicionar um 1 a ele ou

7754
05:12:25,440 --> 05:12:28,000
Podemos incrementá-lo por um só:

7755
05:12:28,000 --> 05:12:30,000
outro termo que usamos na programação

7756
05:12:30,000 --> 05:12:31,840
línguas quando dizemos que somos

7757
05:12:31,840 --> 05:12:34,560
incrementando um valor que estamos adicionando

7758
05:12:34,560 --> 05:12:36,798
algo para isso neste caso, estamos

7759
05:12:36,798 --> 05:12:40,160
incrementando-o por um e nós somos

7760
05:12:40,160 --> 05:12:42,560
basicamente indo armazenar um seis e isso

7761
05:12:42,560 --> 05:12:45,040
valor aqui, então se imprimirmos isso, estamos

7762
05:12:45,040 --> 05:12:47,440
Vou ter um seis aqui

7763
05:12:47,440 --> 05:12:49,600
Isto é o que nós esperamos que sejamos

7764
05:12:49,600 --> 05:12:51,840
redefinindo o valor para cinco e que nós

7765
05:12:51,840 --> 05:12:54,718
estão indo para menos um ou decrement por

7766
05:12:54,718 --> 05:12:57,120
Um e o resultado serão salvos

7767
05:12:57,120 --> 05:13:00,400
em valor novamente para o segundo stdc para fora

7768
05:13:00,400 --> 05:13:03,600
A declaração aqui vai imprimir um 4.

7769
05:13:03,600 --> 05:13:06,080
Isso é algo que você deve esperar

7770
05:13:06,080 --> 05:13:08,560
Agora outra coisa que podemos fazer em c plus

7771
05:13:08,560 --> 05:13:11,680
plus é fazer algo como valor mais

7772
05:13:11,680 --> 05:13:13,040
Mais aqui

7773
05:13:13,040 --> 05:13:15,680
e o que queremos dizer com isso quando você usa

7774
05:13:15,680 --> 05:13:17,200
um postfix

7775
05:13:17,200 --> 05:13:19,360
incrementar o operador como este

7776
05:13:19,360 --> 05:13:21,040
A primeira coisa que você deve saber é que

7777
05:13:21,040 --> 05:13:23,280
Isso vai incrementar por um é

7778
05:13:23,280 --> 05:13:25,120
Não vá aumentar por qualquer outro

7779
05:13:25,120 --> 05:13:28,240
O valor c plus não fornece um caminho

7780
05:13:28,240 --> 05:13:30,718
para você especificar outro número para

7781
05:13:30,718 --> 05:13:33,840
incremento por valor plus plus aqui é

7782
05:13:33,840 --> 05:13:36,160
indo para incrementar por um, menos um outro

7783
05:13:36,160 --> 05:13:37,600
A coisa que você deve saber

7784
05:13:37,600 --> 05:13:39,840
É que não vai incrementar

7785
05:13:39,840 --> 05:13:41,920
diretamente o que vai acontecer aqui se

7786
05:13:41,920 --> 05:13:44,000
Você olha para o topo aqui temos um valor

7787
05:13:44,000 --> 05:13:47,920
5 quando a execução atinge este stdcl

7788
05:13:47,920 --> 05:13:49,120
Declaração

7789
05:13:49,120 --> 05:13:52,160
Vamos pegar o valor aqui, então

7790
05:13:52,160 --> 05:13:54,798
Aqui vamos realmente imprimir um 5, mas

7791
05:13:54,798 --> 05:13:57,600
assim que esta declaração é feita a

7792
05:13:57,600 --> 05:14:00,240
O valor vai aumentar por um, então

7793
05:14:00,240 --> 05:14:02,160
da próxima vez que alguém vai usar

7794
05:14:02,160 --> 05:14:04,718
Este valor aqui é que ele vai encontrar em

7795
05:14:04,718 --> 05:14:07,440
um 6 e é isso que temos aqui, então

7796
05:14:07,440 --> 05:14:09,120
O primeiro vai imprimir um cinco

7797
05:14:09,120 --> 05:14:11,440
Porque nós vamos pegar o valor

7798
05:14:11,440 --> 05:14:14,878
Aqui como está, mas assim que temos

7799
05:14:14,878 --> 05:14:17,360
valor que isso vai aumentar por um

7800
05:14:17,360 --> 05:14:19,520
Isto é o que queremos dizer com este valor mais

7801
05:14:19,520 --> 05:14:21,920
mais aqui e a segunda declaração é

7802
05:14:21,920 --> 05:14:24,958
indo para imprimir sx porque já é

7803
05:14:24,958 --> 05:14:27,840
incrementado e chamamos isso de postfix

7804
05:14:27,840 --> 05:14:30,958
incremento porque plus plus é depois do

7805
05:14:30,958 --> 05:14:33,680
valor aqui e isso é realmente o que isso

7806
05:14:33,680 --> 05:14:36,240
Operador faz e às vezes está indo

7807
05:14:36,240 --> 05:14:38,320
para vir a calar em seu c plus mais

7808
05:14:38,320 --> 05:14:40,718
aplicações que também podemos fazer o mesmo

7809
05:14:40,718 --> 05:14:43,440
coisa com menos menos, vai

7810
05:14:43,440 --> 05:14:45,600
Agarr qualquer valor que temos neste

7811
05:14:45,600 --> 05:14:47,840
variável, então temos em um cinco, então isso é

7812
05:14:47,840 --> 05:14:49,920
O que vamos imprimir aqui

7813
05:14:49,920 --> 05:14:52,878
e a próxima declaração vai encontrar

7814
05:14:52,878 --> 05:14:55,280
já decrementado por um, porque

7815
05:14:55,280 --> 05:14:57,360
Depois que temos nossos cinco, vamos

7816
05:14:57,360 --> 05:14:59,280
Decrement por um que é o que nós somos

7817
05:14:59,280 --> 05:15:01,440
dizendo aqui e vamos encontrar o

7818
05:15:01,440 --> 05:15:05,360
nf4 porque 5 cremented por 1 torna-se um

7819
05:15:05,360 --> 05:15:08,400
4. Eu realmente espero que isso faça sentido ok assim

7820
05:15:08,400 --> 05:15:11,280
O que vimos aqui é postfix

7821
05:15:11,280 --> 05:15:14,240
incremento e decremento, mas também podemos

7822
05:15:14,240 --> 05:15:17,200
fazer uma versão de prefixo desta coisa se você

7823
05:15:17,200 --> 05:15:19,200
Veja o exemplo que temos aqui que temos

7824
05:15:19,200 --> 05:15:20,320
um cinco

7825
05:15:20,320 --> 05:15:23,280
e estamos dizendo mais mais valor, então

7826
05:15:23,280 --> 05:15:25,760
Isso vai aumentar o valor

7827
05:15:25,760 --> 05:15:28,958
diretamente assim que esta declaração for

7828
05:15:28,958 --> 05:15:31,520
executou a mais mais declaração de valor

7829
05:15:31,520 --> 05:15:35,040
Aqui vamos ter um 6 dentro e

7830
05:15:35,040 --> 05:15:37,120
Se imprimirmos, vamos ter um 6

7831
05:15:37,120 --> 05:15:39,040
E isso é o que você vê aqui se formos

7832
05:15:39,040 --> 05:15:41,760
Estamos redefinindo nosso valor e nós

7833
05:15:41,760 --> 05:15:42,958
Eles estão indo para

7834
05:15:42,958 --> 05:15:45,760
incremento do prefixo no lugar

7835
05:15:45,760 --> 05:15:48,400
Então aqui vamos incrementar o

7836
05:15:48,400 --> 05:15:51,360
valor antes de realmente imprimi-lo aqui

7837
05:15:51,360 --> 05:15:54,080
e também vamos ter um ano de seis anos

7838
05:15:54,080 --> 05:15:56,480
Espero que isso faça sentido e se você tem

7839
05:15:56,480 --> 05:15:58,878
Qualquer problema com isso eu acho que se formos

7840
05:15:58,878 --> 05:16:01,120
em código de estúdio visual que você vai

7841
05:16:01,120 --> 05:16:02,718
Tenho uma maneira melhor de dizer que você é

7842
05:16:02,718 --> 05:16:04,400
indo ver o código rodando e fazer

7843
05:16:04,400 --> 05:16:07,520
Sensação disso tudo bem, então eu acho que

7844
05:16:07,520 --> 05:16:09,360
Agora você entende por que vamos

7845
05:16:09,360 --> 05:16:11,920
ter esses números impressos se formos para baixo

7846
05:16:11,920 --> 05:16:13,440
Podemos fazer o mesmo com

7847
05:16:13,440 --> 05:16:15,680
decrementando que temos um valor aqui é

7848
05:16:15,680 --> 05:16:16,560
Cinco

7849
05:16:16,560 --> 05:16:17,600
Se nós

7850
05:16:17,600 --> 05:16:20,160
prefixo decrement que vai ser um

7851
05:16:20,160 --> 05:16:22,560
Quatro aqui e se imprimirmos, vamos

7852
05:16:22,560 --> 05:16:23,920
para obter um quatro

7853
05:16:23,920 --> 05:16:25,680
Se você for aqui, estamos redefinindo

7854
05:16:25,680 --> 05:16:29,280
Isso para cinco e vamos prefixar

7855
05:16:29,280 --> 05:16:32,000
decrement no lugar e isso também é

7856
05:16:32,000 --> 05:16:34,320
Vou imprimir um quatro porque temos um

7857
05:16:34,320 --> 05:16:37,600
cinco aqui e se decrementarmos por um

7858
05:16:37,600 --> 05:16:38,958
nós vamos ter um quatro e isso é

7859
05:16:38,958 --> 05:16:41,200
O que vamos chegar aqui bem isso

7860
05:16:41,200 --> 05:16:44,240
é realmente todos esses prefixo e postfix

7861
05:16:44,240 --> 05:16:46,638
operadores de incremento e decremento são

7862
05:16:46,638 --> 05:16:49,040
sobre nós vamos entrar no visual

7863
05:16:49,040 --> 05:16:51,280
código de estúdio e realmente ver isso

7864
05:16:51,280 --> 05:16:54,160
correndo bem aqui estamos em nosso trabalho

7865
05:16:54,160 --> 05:16:56,000
diretório vamos fazer o habitual

7866
05:16:56,000 --> 05:16:57,920
Vamos copiar o código do nosso

7867
05:16:57,920 --> 05:17:00,240
modelo de projeto, vamos colocar isso

7868
05:17:00,240 --> 05:17:02,560
Aqui vamos subir e abrir

7869
05:17:02,560 --> 05:17:05,200
Isso em código de estúdio visual, então estamos

7870
05:17:05,200 --> 05:17:08,080
vamos remover coisas que não precisamos e

7871
05:17:08,080 --> 05:17:09,680
nós vamos remover isso

7872
05:17:09,680 --> 05:17:11,840
e vamos colocar no código que nós

7873
05:17:11,840 --> 05:17:15,200
exatamente visto nos slides aqui temos um

7874
05:17:15,200 --> 05:17:18,638
valor é um inteiro e é cinco

7875
05:17:18,638 --> 05:17:20,798
Se incrementá-lo por um, vamos

7876
05:17:20,798 --> 05:17:24,320
conseguir um seis aqui ok e se imprimirmos

7877
05:17:24,320 --> 05:17:26,160
Isso é o que nós vamos conseguir, nós somos

7878
05:17:26,160 --> 05:17:28,718
redefinindo isso para cinco e se nós

7879
05:17:28,718 --> 05:17:30,958
Decrement isso por um, nós vamos ter um

7880
05:17:30,958 --> 05:17:32,400
Quatro aqui

7881
05:17:32,400 --> 05:17:35,040
então, se executarmos este pedaço de código nós

7882
05:17:35,040 --> 05:17:37,840
Deve ter um seis aqui impressos

7883
05:17:37,840 --> 05:17:39,680
e um quatro

7884
05:17:39,680 --> 05:17:40,958
Aqui em baixo

7885
05:17:40,958 --> 05:17:43,920
Nós vamos trazer o nosso terminal

7886
05:17:43,920 --> 05:17:47,120
e construir isso com gcc a solda é

7887
05:17:47,120 --> 05:17:48,560
indo para ir através

7888
05:17:48,560 --> 05:17:51,280
E se executarmos o programa, vamos

7889
05:17:51,280 --> 05:17:54,638
obter o valor a6 e é quatro e este

7890
05:17:54,638 --> 05:17:57,360
é realmente o que esperamos aqui bem agora

7891
05:17:57,360 --> 05:17:59,200
que isso é realmente claro que nós vamos

7892
05:17:59,200 --> 05:18:02,160
descer e jogar com post fix

7893
05:18:02,160 --> 05:18:04,718
incremento e decréscimo

7894
05:18:04,718 --> 05:18:07,600
Eu vou colocar um separador aqui, então

7895
05:18:07,600 --> 05:18:10,638
que podemos ver claramente em nosso terminal

7896
05:18:10,638 --> 05:18:13,760
Aqui e vamos dar o nosso teste

7897
05:18:13,760 --> 05:18:16,000
código que vamos usar

7898
05:18:16,000 --> 05:18:19,040
para brincar com isso vamos derrubar isso

7899
05:18:19,040 --> 05:18:20,798
Um pouco para que você possa ver

7900
05:18:20,798 --> 05:18:23,680
Tudo que podemos remover essas coisas que nós

7901
05:18:23,680 --> 05:18:26,320
Não preciso mais deles, nós estamos

7902
05:18:26,320 --> 05:18:28,000
Vou tomar o valor que tínhamos nós somos

7903
05:18:28,000 --> 05:18:29,840
Indo para dentro de nós.

7904
05:18:29,840 --> 05:18:32,000
Redefinir isso para um cinco

7905
05:18:32,000 --> 05:18:34,958
e se valorizamos mais mais mais aqui

7906
05:18:34,958 --> 05:18:37,120
Isto vai ser um cinco porque nós somos

7907
05:18:37,120 --> 05:18:40,080
Vou capturar o valor como é assim aqui

7908
05:18:40,080 --> 05:18:41,920
nós vamos ter um cinco

7909
05:18:41,920 --> 05:18:44,160
Mas da próxima vez que o obtermos esse valor é

7910
05:18:44,160 --> 05:18:46,320
Já vai ser um sexo porque nós

7911
05:18:46,320 --> 05:18:49,680
incremento imediatamente após a captura

7912
05:18:49,680 --> 05:18:52,080
O valor aqui, então aqui vamos

7913
05:18:52,080 --> 05:18:55,520
ter um 5 e aqui vamos ter um 6.

7914
05:18:55,520 --> 05:18:57,600
Espero que isso faça sentido

7915
05:18:57,600 --> 05:19:00,560
e se formos aqui, estamos redefinindo

7916
05:19:00,560 --> 05:19:03,200
nosso valor para 5 antes de fazer qualquer

7917
05:19:03,200 --> 05:19:04,798
decrementação

7918
05:19:04,798 --> 05:19:07,600
Vamos capturar o valor como está

7919
05:19:07,600 --> 05:19:09,440
porque estamos fazendo post fixo

7920
05:19:09,440 --> 05:19:10,718
O decréscimo

7921
05:19:10,718 --> 05:19:13,040
e aqui vamos ter um 5 porque

7922
05:19:13,040 --> 05:19:15,840
Estamos capturando o valor como s

7923
05:19:15,840 --> 05:19:18,080
mas assim que captamos o nosso valor

7924
05:19:18,080 --> 05:19:20,560
nós vamos decrementar isso e a

7925
05:19:20,560 --> 05:19:22,958
Outra declaração aqui vai ter um

7926
05:19:22,958 --> 05:19:25,680
decrement valor e isso vai ser

7927
05:19:25,680 --> 05:19:29,440
a 4. então aqui vamos imprimir 5 6 5

7928
05:19:29,440 --> 05:19:30,560
4.

7929
05:19:30,560 --> 05:19:34,718
Vamos tentar construir isso com gcc

7930
05:19:34,718 --> 05:19:36,638
para ver que não temos problemas que temos

7931
05:19:36,638 --> 05:19:39,360
Sem problemas o mundo é bom se tentarmos

7932
05:19:39,360 --> 05:19:41,200
para correr o galo agora

7933
05:19:41,200 --> 05:19:44,638
nós vamos conseguir o

7934
05:19:44,638 --> 05:19:47,440
Os resultados que tivemos antes

7935
05:19:47,440 --> 05:19:51,040
Mas para este código acabamos de colocar aqui

7936
05:19:51,040 --> 05:19:53,200
O valor vai ser um 5 e isso é

7937
05:19:53,200 --> 05:19:55,040
O que temos aqui

7938
05:19:55,040 --> 05:19:56,878
e nós vamos ter um 6 que é

7939
05:19:56,878 --> 05:19:58,638
vindo daqui

7940
05:19:58,638 --> 05:20:01,280
Depois que vamos ao decréscer e nós

7941
05:20:01,280 --> 05:20:03,760
vai capturar o valor como está

7942
05:20:03,760 --> 05:20:06,480
nós vamos conseguir este 5 aqui e para

7943
05:20:06,480 --> 05:20:08,400
a última declaração que vamos ter um

7944
05:20:08,400 --> 05:20:11,520
4 porque o valor já é

7945
05:20:11,520 --> 05:20:14,240
decrementado e isso é o para que nós somos

7946
05:20:14,240 --> 05:20:15,520
Vendo aqui

7947
05:20:15,520 --> 05:20:18,240
Eu realmente espero que isso faça sentido e isso

7948
05:20:18,240 --> 05:20:19,600
Realmente cobre

7949
05:20:19,600 --> 05:20:22,320
O incremento e decréscimento de postfix

7950
05:20:22,320 --> 05:20:24,798
Operadores a última coisa que queremos ver

7951
05:20:24,798 --> 05:20:28,240
Nesta palestra é que também podemos fazer

7952
05:20:28,240 --> 05:20:31,680
incremento e decrementação de prefixo

7953
05:20:31,680 --> 05:20:34,160
Vamos descer aqui e

7954
05:20:34,160 --> 05:20:35,840
configurar um lugar onde vamos estar

7955
05:20:35,840 --> 05:20:37,680
brincando com isso, então vamos dizer

7956
05:20:37,680 --> 05:20:39,440
prefixo

7957
05:20:39,440 --> 05:20:41,360
e vamos colocar em nosso código

7958
05:20:41,360 --> 05:20:43,440
Porque eu não quero digitar tudo isso

7959
05:20:43,440 --> 05:20:46,320
Isso desperdiçaria seu tempo valioso, mas

7960
05:20:46,320 --> 05:20:48,240
Eu encorajo você a digitar essas coisas

7961
05:20:48,240 --> 05:20:49,680
para fora e realmente

7962
05:20:49,680 --> 05:20:51,920
perfurá-los em seu cérebro, porque isso é

7963
05:20:51,920 --> 05:20:53,760
Como você vai aprender bem, vamos

7964
05:20:53,760 --> 05:20:55,360
derrubar isso para que possamos

7965
05:20:55,360 --> 05:20:58,320
Entenda esse pedaço de código para que possamos

7966
05:20:58,320 --> 05:21:01,600
começando por redefinir o nosso valor para 5 e

7967
05:21:01,600 --> 05:21:04,320
note aqui que fazemos mais mais mais valor

7968
05:21:04,320 --> 05:21:06,878
isso vai aumentar o valor certo

7969
05:21:06,878 --> 05:21:08,958
Afaste por este tempo o valor vai

7970
05:21:08,958 --> 05:21:12,240
ser seis e se nós imprimi-lo aqui estamos

7971
05:21:12,240 --> 05:21:14,558
Vou ter um seis impressos para baixo, estamos

7972
05:21:14,558 --> 05:21:16,718
indo redefini-lo para cinco e então nós somos

7973
05:21:16,718 --> 05:21:19,680
vou implementar isso no lugar que é

7974
05:21:19,680 --> 05:21:22,320
também vai imprimir seis e se você

7975
05:21:22,320 --> 05:21:23,920
Vamos para baixo nós vamos fazer o mesmo

7976
05:21:23,920 --> 05:21:25,840
versão da mesma coisa, mas nós somos

7977
05:21:25,840 --> 05:21:27,680
vai ser decréscia, então vamos

7978
05:21:27,680 --> 05:21:30,000
para degradar o valor que nós apenas

7979
05:21:30,000 --> 05:21:31,280
reset aqui

7980
05:21:31,280 --> 05:21:33,280
Aqui vai se tornar um 4 e isso é

7981
05:21:33,280 --> 05:21:35,600
O que vamos imprimir e se formos

7982
05:21:35,600 --> 05:21:38,240
Aqui em baixo nós o redefinimos novamente para um 5 e

7983
05:21:38,240 --> 05:21:41,600
nós prefixo decrementá-lo no lugar

7984
05:21:41,600 --> 05:21:44,878
Então o 5 aqui vai se tornar um 4

7985
05:21:44,878 --> 05:21:46,638
Aqui e é isso que vamos

7986
05:21:46,638 --> 05:21:48,958
imprimir se construirmos e executarmos isso

7987
05:21:48,958 --> 05:21:50,400
O que vamos conseguir, vamos

7988
05:21:50,400 --> 05:21:53,200
executar a nossa tarefa para construir com gcc

7989
05:21:53,200 --> 05:21:56,400
A construção é boa e se nós corremos o nosso

7990
05:21:56,400 --> 05:22:00,000
listar os resultados para a

7991
05:22:00,000 --> 05:22:01,920
O código que acabamos de colocar aqui está apenas indo

7992
05:22:01,920 --> 05:22:03,360
para aparecer aqui

7993
05:22:03,360 --> 05:22:05,840
E você vê que nós temos um seis seis isso

7994
05:22:05,840 --> 05:22:06,958
São seis

7995
05:22:06,958 --> 05:22:09,600
os outros seis e para os dois últimos

7996
05:22:09,600 --> 05:22:11,280
declarações que vamos receber

7997
05:22:11,280 --> 05:22:13,840
Quatros e isso é o que temos aqui eu

7998
05:22:13,840 --> 05:22:15,680
Realmente espero que agora você tem um melhor

7999
05:22:15,680 --> 05:22:18,638
ideia deste prefixo e postfix

8000
05:22:18,638 --> 05:22:21,520
operadores de incremento e decremento e

8001
05:22:21,520 --> 05:22:24,080
você vai fazer uso deles quando

8002
05:22:24,080 --> 05:22:26,160
Eles realmente ajudaram você a projetar o seu

8003
05:22:26,160 --> 05:22:28,480
Aplicações melhor estão bem, então estes são

8004
05:22:28,480 --> 05:22:31,280
suas ferramentas os usam quando fazem sentido

8005
05:22:31,280 --> 05:22:33,040
Outra coisa que eu quero enfatizar

8006
05:22:33,040 --> 05:22:35,200
Aqui é que esses operadores apenas

8007
05:22:35,200 --> 05:22:38,558
incremento ou um decréscia por um você

8008
05:22:38,558 --> 05:22:40,400
Não pode fazê-los

8009
05:22:40,400 --> 05:22:43,200
fazer coisas em incrementos de cinco ou sete

8010
05:22:43,200 --> 05:22:45,840
ou dez eles vão trabalhar em

8011
05:22:45,840 --> 05:22:48,160
incrementos ou decrestos de um que somos

8012
05:22:48,160 --> 05:22:50,000
Vamos ver uma maneira de fazer isso com

8013
05:22:50,000 --> 05:22:52,320
outros operadores na última palestra, mas

8014
05:22:52,320 --> 05:22:55,120
esses operadores de prefixo e postfix não podem

8015
05:22:55,120 --> 05:22:58,080
fazer isso e outra coisa que um pouco

8016
05:22:58,080 --> 05:23:00,798
Você pode estar se perguntando se nós

8017
05:23:00,798 --> 05:23:03,440
ter o mesmo tipo de operadores com

8018
05:23:03,440 --> 05:23:06,080
multiplicação ou divisão e nós não

8019
05:23:06,080 --> 05:23:08,480
ter esses operadores em c plus plus

8020
05:23:08,480 --> 05:23:10,000
Talvez nós vamos tê-los no

8021
05:23:10,000 --> 05:23:12,240
futuro quando fazem sentido, mas no

8022
05:23:12,240 --> 05:23:14,798
versão atual de c plus plus não

8023
05:23:14,798 --> 05:23:16,638
tê-los, vamos parar por aqui

8024
05:23:16,638 --> 05:23:18,558
Esta palestra no próximo vamos

8025
05:23:18,558 --> 05:23:21,200
aprender sobre atribuição de compostos

8026
05:23:21,200 --> 05:23:23,520
operadores nesta palestra vamos

8027
05:23:23,520 --> 05:23:26,000
Aprenda sobre a atribuição de compostos

8028
05:23:26,000 --> 05:23:27,360
Os operadores

8029
05:23:27,360 --> 05:23:30,080
e estes são operadores que permitem que você

8030
05:23:30,080 --> 05:23:33,120
para fazer uma operação aritmética como

8031
05:23:33,120 --> 05:23:35,920
Multiplicação de subtração de adição

8032
05:23:35,920 --> 05:23:39,360
divisão e módulo e atribuir a

8033
05:23:39,360 --> 05:23:43,040
resultar em um valor em um ir, vamos olhar

8034
05:23:43,040 --> 05:23:45,360
Em um exemplo aqui temos valor aqui

8035
05:23:45,360 --> 05:23:48,160
que é 45 é um inteiro e nós somos

8036
05:23:48,160 --> 05:23:49,920
Vou imprimir isso, mas se você for

8037
05:23:49,920 --> 05:23:54,080
Aqui estamos fazendo valor mais igual

8038
05:23:54,080 --> 05:23:56,400
cinco e se você olhar para o comentário aqui

8039
05:23:56,400 --> 05:23:59,440
Isso é equivalente a se você valorizar

8040
05:23:59,440 --> 05:24:02,080
igual a valor mais cinco, então o que isso é

8041
05:24:02,080 --> 05:24:03,920
indo fazer, vai levar qualquer coisa

8042
05:24:03,920 --> 05:24:06,320
O valor está nesse valor aqui está indo

8043
05:24:06,320 --> 05:24:08,480
incremente isso por cinco, então isso é

8044
05:24:08,480 --> 05:24:10,798
vai se tornar um 50 e nós vamos

8045
05:24:10,798 --> 05:24:14,160
armazenar que 50 resultados de volta neste

8046
05:24:14,160 --> 05:24:16,400
variável aqui por esta altura, se nós

8047
05:24:16,400 --> 05:24:17,840
imprimindo isso, vamos conseguir um

8048
05:24:17,840 --> 05:24:20,320
50. novamente vamos tomar o valor

8049
05:24:20,320 --> 05:24:23,200
É um 45 que vamos adicionar um 5 é

8050
05:24:23,200 --> 05:24:25,360
vai se tornar um 50 e nós vamos

8051
05:24:25,360 --> 05:24:28,718
armazenar que resultam de volta neste valor

8052
05:24:28,718 --> 05:24:31,600
variável aqui vai se tornar 50

8053
05:24:31,600 --> 05:24:33,440
E se imprimirmos aqui, vamos conseguir

8054
05:24:33,440 --> 05:24:36,480
a 50. esta é a versão de adição de

8055
05:24:36,480 --> 05:24:39,520
o operador de atribuição composto também

8056
05:24:39,520 --> 05:24:42,240
ter uma versão para subtração e nós

8057
05:24:42,240 --> 05:24:44,400
Eu tenho um exemplo disso aqui, então é

8058
05:24:44,400 --> 05:24:46,638
Vou tomar qualquer valor que esteja neste

8059
05:24:46,638 --> 05:24:48,798
valor variável que vai encontrar em um

8060
05:24:48,798 --> 05:24:51,920
50 nós vamos subtrair 5 nós vamos

8061
05:24:51,920 --> 05:24:54,480
para obter um 45 e é isso que estamos indo

8062
05:24:54,480 --> 05:24:56,878
para armazenar neste valor aqui

8063
05:24:56,878 --> 05:25:00,558
e no momento em que atingimos este stdc para fora

8064
05:25:00,558 --> 05:25:03,200
Declaração vamos imprimir um 45.

8065
05:25:03,200 --> 05:25:05,120
Mais uma vez temos outra versão para o

8066
05:25:05,120 --> 05:25:07,280
multiplicação aqui para que possamos

8067
05:25:07,280 --> 05:25:09,680
Realmente brincar com todas essas coisas

8068
05:25:09,680 --> 05:25:11,520
Vamos pegar o que quer que haja valor

8069
05:25:11,520 --> 05:25:14,000
Aqui vamos multiplicar isso por 2

8070
05:25:14,000 --> 05:25:16,878
Aqui vamos ter um 90 e isso é

8071
05:25:16,878 --> 05:25:18,638
o que vamos guardar nisto

8072
05:25:18,638 --> 05:25:20,958
valor e se imprimirmos aqui estamos indo

8073
05:25:20,958 --> 05:25:22,718
para obter um 90

8074
05:25:22,718 --> 05:25:24,638
impressos, vamos descer e

8075
05:25:24,638 --> 05:25:27,600
fazer uma versão para uma divisão o valor é

8076
05:25:27,600 --> 05:25:30,558
90 nós vamos dividir isso por 30 e

8077
05:25:30,558 --> 05:25:32,958
vamos armazenar o resultado de volta

8078
05:25:32,958 --> 05:25:36,080
valor aqui e vamos ter um 30

8079
05:25:36,080 --> 05:25:38,878
armazenados aqui e se imprimirmos

8080
05:25:38,878 --> 05:25:41,040
Isso é o que nós vamos chegar aqui

8081
05:25:41,040 --> 05:25:43,520
Também temos uma versão de módulo deste

8082
05:25:43,520 --> 05:25:45,440
E funciona muito bem

8083
05:25:45,440 --> 05:25:47,600
Aqui temos a unidade 30 que vamos levar

8084
05:25:47,600 --> 05:25:51,200
Ele e fazer o módulo 11 e o que é

8085
05:25:51,200 --> 05:25:54,240
Lembrete de dividir 30

8086
05:25:54,240 --> 05:25:57,120
por 11. o lembrete será 8

8087
05:25:57,120 --> 05:25:58,240
porque

8088
05:25:58,240 --> 05:26:02,320
11 só pode caber em 30 duas vezes e

8089
05:26:02,320 --> 05:26:04,000
Vamos ficar com o cavaleiro

8090
05:26:04,000 --> 05:26:05,040
porque

8091
05:26:05,040 --> 05:26:08,240
30 menos 22 é oito e é isso que

8092
05:26:08,240 --> 05:26:10,400
nós vamos armazenar o valor aqui

8093
05:26:10,400 --> 05:26:12,558
E se imprimirmos isso é o que somos

8094
05:26:12,558 --> 05:26:14,400
indo para chegar de novo

8095
05:26:14,400 --> 05:26:16,320
Se você tem dificuldade em entender isso

8096
05:26:16,320 --> 05:26:19,040
Modulus operador aqui, por favor volte

8097
05:26:19,040 --> 05:26:21,200
Algumas palestras de volta, tivemos a chance de

8098
05:26:21,200 --> 05:26:23,440
Aprenda sobre isso certifique-se de entender

8099
05:26:23,440 --> 05:26:25,760
ele e então voltar aqui e isso é

8100
05:26:25,760 --> 05:26:27,440
Tudo vai fazer sentido

8101
05:26:27,440 --> 05:26:30,480
Esta é realmente toda tarefa composta

8102
05:26:30,480 --> 05:26:32,878
É tudo sobre nós vamos ir para

8103
05:26:32,878 --> 05:26:35,200
código de estúdio visual e realmente jogar

8104
05:26:35,200 --> 05:26:39,040
conosco ok aqui estamos em nosso trabalho

8105
05:26:39,040 --> 05:26:41,520
diretório, vamos copiar o nosso

8106
05:26:41,520 --> 05:26:44,798
modelo de projeto como sempre fazemos

8107
05:26:44,798 --> 05:26:48,240
e nós vamos colocar isso em nosso

8108
05:26:48,240 --> 05:26:50,798
Operadores de atribuição de compostos

8109
05:26:50,798 --> 05:26:52,320
A palestra aqui

8110
05:26:52,320 --> 05:26:54,558
nós vamos subir e nós vamos

8111
05:26:54,558 --> 05:26:56,798
para abrir esta pasta no estúdio visual

8112
05:26:56,798 --> 05:26:58,878
código que o projeto vai aparecer

8113
05:26:58,878 --> 05:27:01,280
Aqui e nós vamos abrir o nosso principal

8114
05:27:01,280 --> 05:27:04,718
arquivo cpp e vamos remover o que

8115
05:27:04,718 --> 05:27:06,558
Não precisamos

8116
05:27:06,558 --> 05:27:08,718
vamos colocar nosso código para que

8117
05:27:08,718 --> 05:27:12,400
Podemos começar a explorar isso, temos um 45

8118
05:27:12,400 --> 05:27:14,400
e esta variável aqui que é um

8119
05:27:14,400 --> 05:27:16,558
inteiro se imprimirmos isso, vamos

8120
05:27:16,558 --> 05:27:18,160
para obter um 45

8121
05:27:18,160 --> 05:27:19,920
e aqui em baixo

8122
05:27:19,920 --> 05:27:23,280
Estamos fazendo uma adição composta

8123
05:27:23,280 --> 05:27:25,440
Então, o que estamos fazendo aqui, vamos

8124
05:27:25,440 --> 05:27:28,400
Agarr qualquer valor que esteja nesta variável

8125
05:27:28,400 --> 05:27:30,480
nós vamos adicionar um cinco nós vamos

8126
05:27:30,480 --> 05:27:32,480
conseguir um 50 e é isso que vai ser

8127
05:27:32,480 --> 05:27:34,240
armazenado aqui em

8128
05:27:34,240 --> 05:27:36,240
E se imprimirmos isso, vamos

8129
05:27:36,240 --> 05:27:40,638
pegar um 50. vamos colocar um terminal aqui

8130
05:27:40,638 --> 05:27:42,878
para que possamos ver esta corrida e

8131
05:27:42,878 --> 05:27:45,040
Vamos executar a tarefa de construir

8132
05:27:45,040 --> 05:27:48,400
com gcc como sempre fazemos aqui

8133
05:27:48,400 --> 05:27:50,840
e se corrermos o nosso galo

8134
05:27:50,840 --> 05:27:53,360
executável, vamos obter o valor

8135
05:27:53,360 --> 05:27:56,798
são 50 e é isso que esperamos aqui

8136
05:27:56,798 --> 05:27:58,718
Tudo bem este é o

8137
05:27:58,718 --> 05:28:01,520
versão do nosso composto

8138
05:28:01,520 --> 05:28:04,400
operador de atribuição e é realmente

8139
05:28:04,400 --> 05:28:07,760
equivalente a fazer isso em dois passos

8140
05:28:07,760 --> 05:28:10,320
Dizendo valor igual a valor mais cinco

8141
05:28:10,320 --> 05:28:12,080
Você vai obter o mesmo resultado se

8142
05:28:12,080 --> 05:28:14,400
Você faz isso aqui, na verdade, vamos fazer isso

8143
05:28:14,400 --> 05:28:17,360
para que você não pense que estou fazendo

8144
05:28:17,360 --> 05:28:20,240
para cima, então vamos comentar isso e nós

8145
05:28:20,240 --> 05:28:22,160
Vai dizer o volume

8146
05:28:22,160 --> 05:28:25,920
igual valor mais cinco e se construirmos

8147
05:28:25,920 --> 05:28:29,040
novamente executar a tarefa gcc

8148
05:28:29,040 --> 05:28:31,280
e executar o aplicativo

8149
05:28:31,280 --> 05:28:33,600
nós vamos ver a mesma coisa que pudermos

8150
05:28:33,600 --> 05:28:37,040
também ir para baixo e executar a subtração

8151
05:28:37,040 --> 05:28:40,000
Versão deste exemplo aqui estamos

8152
05:28:40,000 --> 05:28:42,000
Tomando o valor que temos aqui

8153
05:28:42,000 --> 05:28:43,600
que é um 50

8154
05:28:43,600 --> 05:28:45,680
Estamos subtraindo 5 que vamos conseguir

8155
05:28:45,680 --> 05:28:49,440
um 45 e 45 é o que vamos armazenar

8156
05:28:49,440 --> 05:28:51,200
Neste valor aqui

8157
05:28:51,200 --> 05:28:53,040
Isso é o que vamos ver se nós

8158
05:28:53,040 --> 05:28:54,718
imprimir isso para fora assim

8159
05:28:54,718 --> 05:28:57,840
Vamos executar o mundo dos testes com gcc

8160
05:28:57,840 --> 05:29:01,200
para que nossas mudanças sejam refletidas em nossa

8161
05:29:01,200 --> 05:29:03,360
saída, vamos executar isso e nós somos

8162
05:29:03,360 --> 05:29:06,558
Vou ter um 45 é o que esperamos

8163
05:29:06,558 --> 05:29:08,798
nós vamos descer e fazer a

8164
05:29:08,798 --> 05:29:11,360
A versão de multiplicação disso

8165
05:29:11,360 --> 05:29:14,240
Aqui temos nossa tarefa composta

8166
05:29:14,240 --> 05:29:16,718
Declaração que estamos tomando qualquer valor

8167
05:29:16,718 --> 05:29:18,798
Temos aqui que é um 45 que somos

8168
05:29:18,798 --> 05:29:21,520
vai multiplicar isso por 2 e

8169
05:29:21,520 --> 05:29:24,240
O resultado disso vai ser 90 e

8170
05:29:24,240 --> 05:29:26,480
nós vamos armazenar isso de volta em valor

8171
05:29:26,480 --> 05:29:28,320
Aqui e se imprimirmos valor aqui estamos

8172
05:29:28,320 --> 05:29:31,040
vai ter um 19. vamos construir esta corrida

8173
05:29:31,040 --> 05:29:33,840
a tarefa gcc e nós vamos executar o nosso

8174
05:29:33,840 --> 05:29:35,520
programa e nós vamos ver isso

8175
05:29:35,520 --> 05:29:37,760
nós vamos ver este 90 aqui nós podemos

8176
05:29:37,760 --> 05:29:40,080
descer por algumas linhas e colocar no

8177
05:29:40,080 --> 05:29:42,798
código para jogar com uma versão de divisão de

8178
05:29:42,798 --> 05:29:43,600
Isto é

8179
05:29:43,600 --> 05:29:46,000
Mais uma vez, isso vai realmente fazer o

8180
05:29:46,000 --> 05:29:48,160
A mesma coisa só vai estar fazendo

8181
05:29:48,160 --> 05:29:50,240
Isso para a divisão vamos levar

8182
05:29:50,240 --> 05:29:52,160
Qual o valor que temos aqui, que é

8183
05:29:52,160 --> 05:29:54,798
Vou ser um 90 nós vamos dividir

8184
05:29:54,798 --> 05:29:57,840
que por 3 nós vamos ter um 30 e

8185
05:29:57,840 --> 05:30:01,040
30 resultados serão armazenados

8186
05:30:01,040 --> 05:30:04,000
de volta em valor aqui e se imprimirmos isso

8187
05:30:04,000 --> 05:30:06,480
Isso é o que vamos conseguir

8188
05:30:06,480 --> 05:30:08,798
Vamos construir novamente e a construção está indo

8189
05:30:08,798 --> 05:30:11,040
para passar se corrermos

8190
05:30:11,040 --> 05:30:13,680
O nosso programa vamos ter um 30.

8191
05:30:13,680 --> 05:30:15,840
vai descer por algumas linhas e

8192
05:30:15,840 --> 05:30:19,040
colocar em uma versão de módulo deste que somos

8193
05:30:19,040 --> 05:30:21,040
Vamos agarrar qualquer valor que tenhamos e

8194
05:30:21,040 --> 05:30:23,600
Esta variável aqui que vai ser

8195
05:30:23,600 --> 05:30:27,360
30 nós vamos fazer o módulo 11 sobre isso

8196
05:30:27,360 --> 05:30:28,320
valor

8197
05:30:28,320 --> 05:30:30,878
E isso vai ser basicamente 30

8198
05:30:30,878 --> 05:30:33,760
módulo 11. o resultado disso está acontecendo

8199
05:30:33,760 --> 05:30:35,200
para ser 8

8200
05:30:35,200 --> 05:30:37,760
e vamos armazenar esse resultado em

8201
05:30:37,760 --> 05:30:40,638
valor aqui e se imprimirmos isso

8202
05:30:40,638 --> 05:30:42,480
Isso é o que vamos ver nisso

8203
05:30:42,480 --> 05:30:45,600
declaração de saída aqui que podemos construir novamente

8204
05:30:45,600 --> 05:30:49,440
correr com gcc e se executarmos o nosso galo

8205
05:30:49,440 --> 05:30:52,480
programa vamos ter um 8 impressos

8206
05:30:52,480 --> 05:30:55,040
fora e isso é realmente tudo

8207
05:30:55,040 --> 05:30:58,320
Estas atribuições compostas são sobre e

8208
05:30:58,320 --> 05:31:00,160
Você pode estar perguntando

8209
05:31:00,160 --> 05:31:01,920
Por que passar pelo trabalho de fazer

8210
05:31:01,920 --> 05:31:04,080
Algo assim se eu puder fazer isso

8211
05:31:04,080 --> 05:31:06,480
Como este poço c plus plus dá você

8212
05:31:06,480 --> 05:31:08,718
Uma maneira diferente de fazer coisas diferentes

8213
05:31:08,718 --> 05:31:11,120
As pessoas têm preferências diferentes e

8214
05:31:11,120 --> 05:31:14,160
Algumas pessoas incluídas gostam de fazer

8215
05:31:14,160 --> 05:31:16,400
Coisas assim porque é compacto

8216
05:31:16,400 --> 05:31:18,480
E uma vez que você usar isso você vai

8217
05:31:18,480 --> 05:31:20,160
Acostumar-se com isso, você nem está indo

8218
05:31:20,160 --> 05:31:22,638
para pensar nisso nesta palestra aqui i

8219
05:31:22,638 --> 05:31:25,280
Só queria que você estivesse ciente disso

8220
05:31:25,280 --> 05:31:27,760
possibilidade porque você é definitivamente

8221
05:31:27,760 --> 05:31:30,798
indo vê-lo em c plus mais código para fora

8222
05:31:30,798 --> 05:31:31,680
lá

8223
05:31:31,680 --> 05:31:33,360
Isso é realmente tudo o que nos prossamos fazer em

8224
05:31:33,360 --> 05:31:34,958
Esta palestra espero que você a tenha encontrado

8225
05:31:34,958 --> 05:31:37,280
interessante, vamos parar por aqui

8226
05:31:37,280 --> 05:31:39,120
Esta palestra no próximo vamos

8227
05:31:39,120 --> 05:31:42,558
para aprender sobre operadores relacionais em c

8228
05:31:42,558 --> 05:31:44,638
mais mais nesta palestra vamos

8229
05:31:44,638 --> 05:31:47,760
Saiba mais sobre operadores relacionais em c

8230
05:31:47,760 --> 05:31:49,920
mais plus e estes são basicamente

8231
05:31:49,920 --> 05:31:53,280
operadores que você usa para comparar coisas, vamos

8232
05:31:53,280 --> 05:31:56,160
Olhe para um pedaço de código aqui temos dois

8233
05:31:56,160 --> 05:32:00,240
números um é 45 e outro é 60 eles

8234
05:32:00,240 --> 05:32:03,040
são armazenados em número de variáveis inteiros

8235
05:32:03,040 --> 05:32:04,958
Um e o número dois

8236
05:32:04,958 --> 05:32:06,718
nós podemos imprimi-los e nós vamos

8237
05:32:06,718 --> 05:32:10,558
Veja-os no console ou no nosso terminal

8238
05:32:10,558 --> 05:32:13,200
E se descermos, podemos realmente comparar

8239
05:32:13,200 --> 05:32:16,320
podemos usar o menos do que o operador

8240
05:32:16,320 --> 05:32:19,120
menos ou igual operador

8241
05:32:19,120 --> 05:32:22,080
superior a um operador maior ou igual

8242
05:32:22,080 --> 05:32:24,958
Podemos verificar se dois números são

8243
05:32:24,958 --> 05:32:27,840
igual ao usar dois sinais iguais aqui ser

8244
05:32:27,840 --> 05:32:30,080
Cuidado com esses dois sinais iguais

8245
05:32:30,080 --> 05:32:32,320
Porque se você usar um você não está indo

8246
05:32:32,320 --> 05:32:34,798
para comparar os números que você vai

8247
05:32:34,798 --> 05:32:36,638
estar levando a coisa certa e

8248
05:32:36,638 --> 05:32:39,360
Atribuindo isso à coisa à esquerda

8249
05:32:39,360 --> 05:32:41,600
Se você quiser comparar você está indo

8250
05:32:41,600 --> 05:32:44,480
para ter que digitar dois sinais iguais outro

8251
05:32:44,480 --> 05:32:47,280
Operador que podemos usar para comparar coisas é

8252
05:32:47,280 --> 05:32:50,080
ponto de exclamação e igual que é

8253
05:32:50,080 --> 05:32:52,798
vai testar basicamente se dois números

8254
05:32:52,798 --> 05:32:54,000
São iguais

8255
05:32:54,000 --> 05:32:56,400
e nós vamos conseguir o resultado um

8256
05:32:56,400 --> 05:32:59,120
O que você deve notar aqui é que nós

8257
05:32:59,120 --> 05:33:02,958
estão envolvendo nossa expressão de comparação

8258
05:33:02,958 --> 05:33:05,920
em parêntesis isso é porque se nós

8259
05:33:05,920 --> 05:33:07,680
Não vamos ter um estranho

8260
05:33:07,680 --> 05:33:10,160
Erro do compilador que vou mostrar

8261
05:33:10,160 --> 05:33:12,718
você quando entramos em código de estúdio visual

8262
05:33:12,718 --> 05:33:15,040
mas não temos ferramentas suficientes para realmente

8263
05:33:15,040 --> 05:33:17,040
Entenda este erro

8264
05:33:17,040 --> 05:33:19,680
Neste momento, então o que vamos

8265
05:33:19,680 --> 05:33:22,160
fazer é evitar esse problema, colocando

8266
05:33:22,160 --> 05:33:24,878
parênteses em torno de nossa comparação

8267
05:33:24,878 --> 05:33:26,958
expressão aqui nós vamos para

8268
05:33:26,958 --> 05:33:29,520
código de estúdio visual e realmente ver isso

8269
05:33:29,520 --> 05:33:32,958
em ação aqui estamos trabalhando

8270
05:33:32,958 --> 05:33:35,040
diretório, vamos pegar o código

8271
05:33:35,040 --> 05:33:37,280
do nosso modelo aqui e nós vamos

8272
05:33:37,280 --> 05:33:39,840
colocar isso no projeto atual que

8273
05:33:39,840 --> 05:33:40,840
É

8274
05:33:40,840 --> 05:33:42,958
operadores relacionais, vamos embora

8275
05:33:42,958 --> 05:33:46,000
e colocar em nosso código e nós vamos

8276
05:33:46,000 --> 05:33:48,160
para abrir isso no código do estúdio visual

8277
05:33:48,160 --> 05:33:50,160
nós vamos nos livrar das coisas que nós

8278
05:33:50,160 --> 05:33:52,798
Não preciso aqui vamos colocar

8279
05:33:52,798 --> 05:33:55,040
nosso código para que possamos explorar estes

8280
05:33:55,040 --> 05:33:57,760
Coisas que temos duas variáveis em uma

8281
05:33:57,760 --> 05:34:00,878
Temos um 45 em outro temos um 60 e

8282
05:34:00,878 --> 05:34:02,878
Estes são números inteiros o nome para estes

8283
05:34:02,878 --> 05:34:05,840
As variáveis são o número um e o número dois

8284
05:34:05,840 --> 05:34:07,600
nós vamos imprimi-los e nós estamos

8285
05:34:07,600 --> 05:34:10,240
vamos vê-los no console agora nós

8286
05:34:10,240 --> 05:34:11,920
Eles vão compará-los

8287
05:34:11,920 --> 05:34:14,400
Uma coisa que eu não disse ainda é que

8288
05:34:14,400 --> 05:34:18,798
esses operadores de comparação avaliam

8289
05:34:18,798 --> 05:34:21,600
booleans, em outras palavras, eles estão indo

8290
05:34:21,600 --> 05:34:24,480
para retornar verdadeiro tudo falso se você olhar

8291
05:34:24,480 --> 05:34:25,760
Aqui em baixo

8292
05:34:25,760 --> 05:34:28,958
Queremos saber se o número um é menor

8293
05:34:28,958 --> 05:34:31,600
do que o número dois e o resultado disso

8294
05:34:31,600 --> 05:34:33,760
É se isso é verdadeiro ou falso e isso

8295
05:34:33,760 --> 05:34:35,280
Realmente faz sentido

8296
05:34:35,280 --> 05:34:39,280
então, por causa disso, estamos usando std bull

8297
05:34:39,280 --> 05:34:42,798
alfa aqui para forçar o sddc a imprimir

8298
05:34:42,798 --> 05:34:45,840
Este valor booleano aqui como um verdadeiro ou

8299
05:34:45,840 --> 05:34:48,718
falso em vez de um ou um zero e nós

8300
05:34:48,718 --> 05:34:51,600
Tenho visto isso antes, então se tentarmos

8301
05:34:51,600 --> 05:34:54,718
construir isso e executar isso vamos trazer uma

8302
05:34:54,718 --> 05:34:56,638
O terminal que nós podemos usar

8303
05:34:56,638 --> 05:34:58,558
e vamos fazer o teste para construir

8304
05:34:58,558 --> 05:35:02,160
com gcc se descermos aqui e corrermos

8305
05:35:02,160 --> 05:35:04,320
Programa de galo vamos ter o nosso

8306
05:35:04,320 --> 05:35:07,760
dois números 45 e seis e queremos

8307
05:35:07,760 --> 05:35:10,480
saber se o número um é menor que o número

8308
05:35:10,480 --> 05:35:14,080
Dois e isso é verdade 45 é menos de 60

8309
05:35:14,080 --> 05:35:16,240
O resultado dessa expressão é

8310
05:35:16,240 --> 05:35:18,638
Vai ser verdade agora que você sabe como usar

8311
05:35:18,638 --> 05:35:20,958
Este operador uma coisa eu quero que você

8312
05:35:20,958 --> 05:35:23,440
Veja é o que poderia acontecer

8313
05:35:23,440 --> 05:35:24,718
Se você

8314
05:35:24,718 --> 05:35:27,680
Não usou este parêntese em torno deste

8315
05:35:27,680 --> 05:35:30,160
expressão aqui vamos tentar isso fora que estamos

8316
05:35:30,160 --> 05:35:32,160
vai remover este parêntese e

8317
05:35:32,160 --> 05:35:34,718
nós vamos tentar e o mundo nós estamos indo

8318
05:35:34,718 --> 05:35:37,920
para executar a tarefa para o mundo com gcc e

8319
05:35:37,920 --> 05:35:40,320
Vamos ter um erro muito estranho

8320
05:35:40,320 --> 05:35:41,760
porque

8321
05:35:41,760 --> 05:35:43,840
o compilador vai tentar e

8322
05:35:43,840 --> 05:35:47,120
Avalie este operador primeiro se formos

8323
05:35:47,120 --> 05:35:49,760
de volta ao nosso operador c plus plus

8324
05:35:49,760 --> 05:35:51,360
tabela de precedência

8325
05:35:51,360 --> 05:35:53,920
e olhar para os operadores que estamos tentando

8326
05:35:53,920 --> 05:35:57,200
para usar na declaração do sddc out estamos

8327
05:35:57,200 --> 05:35:59,360
Vou ver que o

8328
05:35:59,360 --> 05:36:02,240
operador para imprimir ventiladores no console

8329
05:36:02,240 --> 05:36:05,680
tem alta precedência do que nossa comparação

8330
05:36:05,680 --> 05:36:08,718
operadores aqui, portanto, a precedência para o nosso

8331
05:36:08,718 --> 05:36:11,680
Operador para imprimir coisas para sdd out é

8332
05:36:11,680 --> 05:36:15,200
11 assim é mais alto e

8333
05:36:15,200 --> 05:36:18,240
precedência para nossos operadores de comparação

8334
05:36:18,240 --> 05:36:21,360
é nove e oito, então o compilador é

8335
05:36:21,360 --> 05:36:23,920
Vou tentar fazer este operador primeiro

8336
05:36:23,920 --> 05:36:26,000
Se voltarmos no código do estúdio visual

8337
05:36:26,000 --> 05:36:27,760
O compilador vai tentar pensar

8338
05:36:27,760 --> 05:36:30,320
Você está imprimindo o número um, mas

8339
05:36:30,320 --> 05:36:32,240
Então, novamente, vai ver isso menos

8340
05:36:32,240 --> 05:36:34,798
do que sinal e as coisas vão soprar

8341
05:36:34,798 --> 05:36:37,120
Na verdade, não temos ferramentas suficientes para

8342
05:36:37,120 --> 05:36:39,200
Entenda o que está acontecendo agora

8343
05:36:39,200 --> 05:36:41,680
Mas eu só não quero que você veja isso

8344
05:36:41,680 --> 05:36:46,080
seta e mostrar-lhe uma maneira de dar a volta

8345
05:36:46,080 --> 05:36:48,400
e seguir em frente com sua vida, comparando

8346
05:36:48,400 --> 05:36:51,280
coisas em seus programas c plus plus se

8347
05:36:51,280 --> 05:36:53,360
você colocou parênteses por aqui o

8348
05:36:53,360 --> 05:36:55,200
O problema vai desaparecer, vamos tentar

8349
05:36:55,200 --> 05:36:56,718
e construir novamente

8350
05:36:56,718 --> 05:36:59,360
Vamos construir com gcc

8351
05:36:59,360 --> 05:37:01,280
E tudo vai voltar para

8352
05:37:01,280 --> 05:37:04,080
normal e vamos ver a nossa produção

8353
05:37:04,080 --> 05:37:07,600
Se executarmos nosso programa de galo aqui

8354
05:37:07,600 --> 05:37:10,000
É assim que você pode fazer isso ok agora

8355
05:37:10,000 --> 05:37:11,760
que temos uma compreensão básica de

8356
05:37:11,760 --> 05:37:14,638
Podemos experimentar os outros operadores e

8357
05:37:14,638 --> 05:37:17,760
Vai ser um passeio no parque

8358
05:37:17,760 --> 05:37:20,480
Vou descer aqui e colocar no nosso

8359
05:37:20,480 --> 05:37:24,400
operadores restantes podemos usar menos ou

8360
05:37:24,400 --> 05:37:28,080
operador eco para testar e ver se o número

8361
05:37:28,080 --> 05:37:31,120
Um é menor ou igual ao número dois nós

8362
05:37:31,120 --> 05:37:33,440
pode usar o maior do que o operador para

8363
05:37:33,440 --> 05:37:36,080
testar e ver se o número um é maior

8364
05:37:36,080 --> 05:37:38,638
do que o número dois podemos usar o maior

8365
05:37:38,638 --> 05:37:40,400
ou igual operador

8366
05:37:40,400 --> 05:37:42,480
nós podemos usar o operador igual igual para

8367
05:37:42,480 --> 05:37:44,718
Teste que o número um é igual ao número

8368
05:37:44,718 --> 05:37:47,440
dois e podemos usar este operador aqui

8369
05:37:47,440 --> 05:37:50,400
que é composto do ponto de exclamação

8370
05:37:50,400 --> 05:37:53,600
e um sinal de igual para testar e ver

8371
05:37:53,600 --> 05:37:56,000
Se dois números não são iguais

8372
05:37:56,000 --> 05:37:58,320
e todos esses operadores vão

8373
05:37:58,320 --> 05:38:00,718
Avaliar para um booleano

8374
05:38:00,718 --> 05:38:03,520
basicamente dizendo se o que você está testando

8375
05:38:03,520 --> 05:38:06,638
pois é verdadeiro ou falso e nós podemos imprimir

8376
05:38:06,638 --> 05:38:08,878
e note que temos isso

8377
05:38:08,878 --> 05:38:11,200
parênteses ao redor para evitar o problema

8378
05:38:11,200 --> 05:38:14,240
Eu só te mostrei alguns minutos antes

8379
05:38:14,240 --> 05:38:16,160
E se nós executarmos isso nós vamos ver

8380
05:38:16,160 --> 05:38:17,920
os resultados

8381
05:38:17,920 --> 05:38:22,638
Vamos soldar isso com gcc como de costume

8382
05:38:22,638 --> 05:38:24,958
Vamos executar nosso programa e

8383
05:38:24,958 --> 05:38:27,200
Você vai ver que o número um é

8384
05:38:27,200 --> 05:38:30,160
menos do que o número dois é verdade

8385
05:38:30,160 --> 05:38:32,638
número um menos ou igual ao número dois

8386
05:38:32,638 --> 05:38:34,240
Isso também é verdade

8387
05:38:34,240 --> 05:38:37,600
número um maior que um número dois 45

8388
05:38:37,600 --> 05:38:40,558
não é maior que 60, então isso é falso

8389
05:38:40,558 --> 05:38:43,200
não é maior do que igual, então isso é

8390
05:38:43,200 --> 05:38:44,718
E também falso

8391
05:38:44,718 --> 05:38:46,958
número um é igual ao número dois este é

8392
05:38:46,958 --> 05:38:49,200
vai ser falso e o último

8393
05:38:49,200 --> 05:38:51,680
declaração que vai testar e ver

8394
05:38:51,680 --> 05:38:54,878
Se o número um não é igual ao número dois

8395
05:38:54,878 --> 05:38:57,680
vai avaliar para verdadeiro porque

8396
05:38:57,680 --> 05:39:00,320
o número um não é igual ao número dois se

8397
05:39:00,320 --> 05:39:02,638
Isso não está fazendo sentido, mas por favor vá

8398
05:39:02,638 --> 05:39:05,040
através dele algumas vezes e se você

8399
05:39:05,040 --> 05:39:07,920
Tenho um problema, por favor, pergunte-me que eu vou

8400
05:39:07,920 --> 05:39:10,320
fazer o melhor que puder para te ajudar

8401
05:39:10,320 --> 05:39:12,320
Outra coisa que eu quero que você veja antes de eu

8402
05:39:12,320 --> 05:39:13,600
Deixe você ir

8403
05:39:13,600 --> 05:39:16,718
É que você pode armazenar os resultados de

8404
05:39:16,718 --> 05:39:20,320
esses operadores em uma variável e em uso

8405
05:39:20,320 --> 05:39:22,638
que mais tarde no seu programa, por exemplo

8406
05:39:22,638 --> 05:39:24,638
Aqui podemos levar nossa expressão para

8407
05:39:24,638 --> 05:39:25,840
Comparar

8408
05:39:25,840 --> 05:39:29,200
número um e número dois o resultado de

8409
05:39:29,200 --> 05:39:31,200
que vai ser instalado neste

8410
05:39:31,200 --> 05:39:32,558
Variável em negrito

8411
05:39:32,558 --> 05:39:35,040
e nós podemos imprimi-lo mais tarde

8412
05:39:35,040 --> 05:39:36,400
Como este

8413
05:39:36,400 --> 05:39:37,760
Se nós corremos isto

8414
05:39:37,760 --> 05:39:40,400
nós vamos construir com gcc e nós somos

8415
05:39:40,400 --> 05:39:42,480
Vai executar o programa

8416
05:39:42,480 --> 05:39:46,400
nós vamos ver que 45 é igual a 60

8417
05:39:46,400 --> 05:39:49,520
É falso e vem disso

8418
05:39:49,520 --> 05:39:51,840
Declaração aqui você pode tentar e mudar

8419
05:39:51,840 --> 05:39:54,080
Esses números, por exemplo, alteram isso para

8420
05:39:54,080 --> 05:39:57,920
um 20 e ver os resultados que temos e

8421
05:39:57,920 --> 05:40:00,400
Você pode tentar executá-los em sua mente

8422
05:40:00,400 --> 05:40:03,200
e ver que eles realmente fazem sentido se

8423
05:40:03,200 --> 05:40:05,520
nós corremos o galo agora que vamos chegar

8424
05:40:05,520 --> 05:40:07,520
Resultados diferentes porque estamos agora

8425
05:40:07,520 --> 05:40:12,558
Comparando 45 e 20 e aqui no último

8426
05:40:12,558 --> 05:40:14,400
A declaração você vê que eles não são

8427
05:40:14,400 --> 05:40:16,558
igual se colocarmos em números iguais, nós somos

8428
05:40:16,558 --> 05:40:19,840
Vou ter um verdadeiro lá vamos tentar isso

8429
05:40:19,840 --> 05:40:22,400
Vamos executar a tarefa de construir

8430
05:40:22,400 --> 05:40:25,920
com gcc e se limparmos para que o tenhamos

8431
05:40:25,920 --> 05:40:29,120
livrar-se de todo esse barulho e correr galo

8432
05:40:29,120 --> 05:40:30,558
nós vamos conseguir

8433
05:40:30,558 --> 05:40:34,080
20 é igual a 20 e isso é verdade

8434
05:40:34,080 --> 05:40:35,680
É realmente tudo o que nos prossamos fazer nisso

8435
05:40:35,680 --> 05:40:38,160
palestra espero que você tenha uma ideia melhor de

8436
05:40:38,160 --> 05:40:40,558
estes operadores relacionais em z plus

8437
05:40:40,558 --> 05:40:41,440
+ a vantagem

8438
05:40:41,440 --> 05:40:43,760
Vamos parar aqui nesta palestra

8439
05:40:43,760 --> 05:40:45,360
Na próxima palestra vamos aprender

8440
05:40:45,360 --> 05:40:48,798
sobre operadores lógicos em c plus plus

8441
05:40:48,798 --> 05:40:51,200
Vá em frente e termine aqui e me encontre

8442
05:40:51,200 --> 05:40:53,120
lá nesta palestra vamos

8443
05:40:53,120 --> 05:40:56,000
Aprenda sobre os operadores lógicos estes

8444
05:40:56,000 --> 05:40:59,360
Operadores trabalharão em operandos booleanos

8445
05:40:59,360 --> 05:41:01,280
nós vamos olhar para o fim primeiro para

8446
05:41:01,280 --> 05:41:03,760
Realmente faz sentido de como eles trabalham aqui

8447
05:41:03,760 --> 05:41:06,638
é uma tabela simples que podemos usar para experimentar

8448
05:41:06,638 --> 05:41:09,040
A operação final será

8449
05:41:09,040 --> 05:41:12,080
trabalhando em dois operandos a e b

8450
05:41:12,080 --> 05:41:14,798
e na terceira coluna aqui vamos

8451
05:41:14,798 --> 05:41:18,000
ter o resultado se é falso e

8452
05:41:18,000 --> 05:41:21,600
b é falso e nós fazemos a e b

8453
05:41:21,600 --> 05:41:24,320
o resultado será falso se a

8454
05:41:24,320 --> 05:41:27,280
falso e b é verdadeiro o resultado está indo

8455
05:41:27,280 --> 05:41:31,120
ser falso se a é verdadeiro e b é falso

8456
05:41:31,120 --> 05:41:34,160
o resultado será falso se a

8457
05:41:34,160 --> 05:41:37,120
true e b é verdadeiro o resultado

8458
05:41:37,120 --> 05:41:39,600
para ser verdade do jeito que você pode pensar

8459
05:41:39,600 --> 05:41:42,798
Isso e o operador é que

8460
05:41:42,798 --> 05:41:47,040
se algum dos operandos é falso o

8461
05:41:47,040 --> 05:41:49,440
O resultado vai ser falso e se você

8462
05:41:49,440 --> 05:41:52,000
realmente usar essa maneira de entender

8463
05:41:52,000 --> 05:41:54,400
Isso vai ser realmente fácil e

8464
05:41:54,400 --> 05:41:56,400
A primeira linha aqui temos um falso, então

8465
05:41:56,400 --> 05:41:58,638
O resultado será falso e

8466
05:41:58,638 --> 05:42:00,320
Segunda linha temos uma força que está indo

8467
05:42:00,320 --> 05:42:02,718
para ser forçado na terceira linha, temos um

8468
05:42:02,718 --> 05:42:04,958
false o resultado vai ser falso

8469
05:42:04,958 --> 05:42:08,000
mas na linha número quatro aqui nós

8470
05:42:08,000 --> 05:42:10,638
Não tenha um falso a é verdadeiro e b é

8471
05:42:10,638 --> 05:42:13,200
É verdade para que o resultado seja verdade

8472
05:42:13,200 --> 05:42:16,160
Outro operador que temos é ou

8473
05:42:16,160 --> 05:42:20,400
e vai avaliar para a verdade

8474
05:42:20,400 --> 05:42:24,080
Se algum dos operandos for verdadeiro, vamos

8475
05:42:24,080 --> 05:42:26,400
olhar para a primeira linha aqui é falso

8476
05:42:26,400 --> 05:42:29,440
E b é falso, então não temos um verdadeiro

8477
05:42:29,440 --> 05:42:31,600
O resultado será falso no

8478
05:42:31,600 --> 05:42:33,440
Segunda linha temos uma verdadeira pesquisa

8479
05:42:33,440 --> 05:42:35,920
Será verdade na terceira linha

8480
05:42:35,920 --> 05:42:37,840
ter um verdadeiro que a pesquisa vai ser

8481
05:42:37,840 --> 05:42:41,120
true on line número quatro nós temos um verdadeiro

8482
05:42:41,120 --> 05:42:43,600
O resultado vai ser verdade e você

8483
05:42:43,600 --> 05:42:45,920
Não precisa memorizar isso

8484
05:42:45,920 --> 05:42:49,040
tabelas se você usar esses operadores longos

8485
05:42:49,040 --> 05:42:51,200
bastante essas coisas vão ser

8486
05:42:51,200 --> 05:42:53,760
perfurado em sua memória se você tiver alguma

8487
05:42:53,760 --> 05:42:56,480
problema com esses operadores apenas olhar

8488
05:42:56,480 --> 05:42:58,638
para cima mesas como esta e você pode encontrar

8489
05:42:58,638 --> 05:43:00,798
O que você precisa sem realmente

8490
05:43:00,798 --> 05:43:03,680
memorizando essas coisas, outro operador

8491
05:43:03,680 --> 05:43:06,320
Não é o operador que vai

8492
05:43:06,320 --> 05:43:09,360
Negar o que você dá, então se a

8493
05:43:09,360 --> 05:43:11,280
Verdade e nós negamos que vamos

8494
05:43:11,280 --> 05:43:14,320
obter um falso se a é falso e quando você

8495
05:43:14,320 --> 05:43:16,320
Para isso, vamos conseguir que seja verdade

8496
05:43:16,320 --> 05:43:19,440
e usamos esta marca de esfoliação para dizer

8497
05:43:19,440 --> 05:43:21,680
que estamos negando algo se você for

8498
05:43:21,680 --> 05:43:25,760
de volta ou é denotado por estes dois

8499
05:43:25,760 --> 05:43:29,040
Barras verticais e o operador final é

8500
05:43:29,040 --> 05:43:31,920
denotado por estes dois ampersand

8501
05:43:31,920 --> 05:43:34,400
símbolos aqui estão bem agora que sabemos sobre

8502
05:43:34,400 --> 05:43:36,958
Essas tabelas lógicas para essas lógicas

8503
05:43:36,958 --> 05:43:39,440
operadores que podemos realmente tentar usar

8504
05:43:39,440 --> 05:43:41,360
eles em código

8505
05:43:41,360 --> 05:43:44,000
Aqui temos três variáveis booleanas que nós

8506
05:43:44,000 --> 05:43:45,520
ter um b c

8507
05:43:45,520 --> 05:43:49,600
a é verdadeiro b é falso c é verdade que podemos

8508
05:43:49,600 --> 05:43:51,520
imprimi-los e você vê que nós somos

8509
05:43:51,520 --> 05:43:54,080
configurando o sddc para nos dar o

8510
05:43:54,080 --> 05:43:57,120
resultados no formato de true e false

8511
05:43:57,120 --> 05:43:59,360
em vez de uns e zeros

8512
05:43:59,360 --> 05:44:01,680
E aqui você vê que estamos tentando

8513
05:44:01,680 --> 05:44:04,878
para usar o operador lógico e

8514
05:44:04,878 --> 05:44:08,958
Aqui você tem um e b a e c e

8515
05:44:08,958 --> 05:44:11,440
Estamos fazendo isso em três operadores e

8516
05:44:11,440 --> 05:44:13,680
Encadeando essas coisas para que nós estejamos

8517
05:44:13,680 --> 05:44:17,360
dizendo a e b e c e vamos tentar

8518
05:44:17,360 --> 05:44:19,520
fazer isso em nossa mente para ver que nós

8519
05:44:19,520 --> 05:44:22,080
realmente entender isso, vimos que

8520
05:44:22,080 --> 05:44:25,040
o operador final avalia como verdadeiro

8521
05:44:25,040 --> 05:44:27,920
Quando todos os operandos são verdadeiros de outro jeito

8522
05:44:27,920 --> 05:44:30,718
para dizer que este é o operador final

8523
05:44:30,718 --> 05:44:33,280
Avalia a false se qualquer um dos

8524
05:44:33,280 --> 05:44:36,000
operandos é falso, então vamos acabar

8525
05:44:36,000 --> 05:44:39,360
a e b a é verdadeiro b é falso, então o

8526
05:44:39,360 --> 05:44:41,600
O resultado será falso porque nós

8527
05:44:41,600 --> 05:44:44,558
ter um falso aqui a e c vai

8528
05:44:44,558 --> 05:44:47,440
avaliar para verdadeiro porque a e c são

8529
05:44:47,440 --> 05:44:50,878
true a e b e c vai avaliar

8530
05:44:50,878 --> 05:44:53,840
para falso porque temos uma falsa aqui

8531
05:44:53,840 --> 05:44:57,040
mesmo que você tenha 1 000 ferramentas e termine

8532
05:44:57,040 --> 05:44:59,760
que com um falso que vai ser

8533
05:44:59,760 --> 05:45:03,040
arrastado para baixo para avaliar o falso que é

8534
05:45:03,040 --> 05:45:05,680
O que estamos vendo aqui também podemos fazer

8535
05:45:05,680 --> 05:45:08,878
todas as operações sobre essas coisas e

8536
05:45:08,878 --> 05:45:11,840
Isso vai te dar um verdadeiro se houver

8537
05:45:11,840 --> 05:45:13,520
dos operandos

8538
05:45:13,520 --> 05:45:16,958
é verdade, sabemos que a é verdadeira e b

8539
05:45:16,958 --> 05:45:19,120
falso, então isso vai avaliar para

8540
05:45:19,120 --> 05:45:21,920
true a e c também vai avaliar

8541
05:45:21,920 --> 05:45:24,000
para verdadeiro porque a é verdade

8542
05:45:24,000 --> 05:45:26,480
a e b e c vai avaliar o

8543
05:45:26,480 --> 05:45:29,760
true porque a é verdade

8544
05:45:29,760 --> 05:45:31,840
então vamos voltar e ver que estes são

8545
05:45:31,840 --> 05:45:34,000
os valores que vamos usar aqui

8546
05:45:34,000 --> 05:45:36,878
nós também podemos experimentar o operador da porca e

8547
05:45:36,878 --> 05:45:38,718
Vai negar tudo o que demos

8548
05:45:38,718 --> 05:45:41,200
então, se a é verdade, vamos conseguir um

8549
05:45:41,200 --> 05:45:43,760
false b é falso, nós vamos obtê-lo

8550
05:45:43,760 --> 05:45:46,400
true c é verdade que vamos ter um

8551
05:45:46,400 --> 05:45:48,240
Outra coisa que você pode fazer é

8552
05:45:48,240 --> 05:45:51,840
combinar esses operadores lógicos para que possamos

8553
05:45:51,840 --> 05:45:54,400
fazer algo como a e b e tudo

8554
05:45:54,400 --> 05:45:55,680
Isso com um c

8555
05:45:55,680 --> 05:45:57,840
e você deve notar que nós somos

8556
05:45:57,840 --> 05:46:00,480
Envolvendo nossas expressões aqui em

8557
05:46:00,480 --> 05:46:02,718
parênteses para que não tenhamos o

8558
05:46:02,718 --> 05:46:04,958
O mesmo problema que experimentamos e

8559
05:46:04,958 --> 05:46:07,360
explicado na última palestra e uma

8560
05:46:07,360 --> 05:46:09,280
O que você deve saber é que para o

8561
05:46:09,280 --> 05:46:12,718
compilador para avaliar essas coisas que somos

8562
05:46:12,718 --> 05:46:15,200
seguir as regras em nossa mesa

8563
05:46:15,200 --> 05:46:18,080
para precedência e associatividade, mas nós

8564
05:46:18,080 --> 05:46:20,080
Tratos usados para realmente fazer isso

8565
05:46:20,080 --> 05:46:23,680
Fácil de seguir, então vamos acabar com um

8566
05:46:23,680 --> 05:46:24,718
e b

8567
05:46:24,718 --> 05:46:26,798
E o resultado disso vai ser

8568
05:46:26,798 --> 05:46:29,760
ored com c e você pode tentar fazer isso

8569
05:46:29,760 --> 05:46:31,280
em sua mente e você vai figurar

8570
05:46:31,280 --> 05:46:33,360
Isso fora, mas nós também vamos para

8571
05:46:33,360 --> 05:46:35,120
código de estúdio visual em um minuto e nós somos

8572
05:46:35,120 --> 05:46:37,680
Vou ver todas essas coisas em ação

8573
05:46:37,680 --> 05:46:40,000
A última coisa que você pode fazer é combinar

8574
05:46:40,000 --> 05:46:43,040
Operadores lógicos e relacionais em

8575
05:46:43,040 --> 05:46:46,080
expressões, por exemplo, aqui temos d e

8576
05:46:46,080 --> 05:46:48,878
e f são inteiros e nós podemos imprimir

8577
05:46:48,878 --> 05:46:51,440
Eles saem como estamos fazendo aqui, mas nós

8578
05:46:51,440 --> 05:46:53,040
Pode fazer algo como

8579
05:46:53,040 --> 05:46:55,200
d Maior do que e

8580
05:46:55,200 --> 05:46:57,200
e vamos acabar com o resultado de

8581
05:46:57,200 --> 05:47:00,958
que com d maior que f

8582
05:47:00,958 --> 05:47:03,920
e sabemos que estes relacionais

8583
05:47:03,920 --> 05:47:07,840
operadores avaliam os booleanos para que possamos

8584
05:47:07,840 --> 05:47:10,000
Use estes booleanos com lógica

8585
05:47:10,000 --> 05:47:12,718
operadores como temos feito tudo

8586
05:47:12,718 --> 05:47:15,360
junto nesta palestra, por exemplo

8587
05:47:15,360 --> 05:47:17,760
Vamos avaliar o primeiro aqui em

8588
05:47:17,760 --> 05:47:20,558
mente para que você realmente veja o que isso é

8589
05:47:20,558 --> 05:47:22,320
Tudo sobre

8590
05:47:22,320 --> 05:47:27,680
d é 45 e é 20, então d maior do que e é

8591
05:47:27,680 --> 05:47:29,600
Vou avaliar para a verdade

8592
05:47:29,600 --> 05:47:31,360
d Maior do que f

8593
05:47:31,360 --> 05:47:34,000
que também vai avaliar para verdadeiro, então

8594
05:47:34,000 --> 05:47:35,760
Verdadeiro e verdadeiro

8595
05:47:35,760 --> 05:47:37,760
que vai avaliar para verdadeiro e

8596
05:47:37,760 --> 05:47:39,760
Isso deve imprimir um verdadeiro

8597
05:47:39,760 --> 05:47:41,440
no terminal

8598
05:47:41,440 --> 05:47:43,600
nós vamos para o código do estúdio visual

8599
05:47:43,600 --> 05:47:46,000
e realmente jogar com isso, obrigado

8600
05:47:46,000 --> 05:47:48,080
Tudo bem aqui estamos em nosso trabalho

8601
05:47:48,080 --> 05:47:50,080
diretório, vamos pular em nosso

8602
05:47:50,080 --> 05:47:52,638
modelo de projeto e copiar os arquivos que nós

8603
05:47:52,638 --> 05:47:55,840
necessidade e vamos colocá-los em nosso

8604
05:47:55,840 --> 05:47:58,558
palestra sobre operadores lógicos que estamos indo

8605
05:47:58,558 --> 05:48:00,558
para colocar isso aqui

8606
05:48:00,558 --> 05:48:02,638
Vamos abrir esta pasta em

8607
05:48:02,638 --> 05:48:04,558
código visual do estúdio e vai

8608
05:48:04,558 --> 05:48:06,798
aparecer aqui no código do estúdio visual, nós somos

8609
05:48:06,798 --> 05:48:08,958
Vamos nos livrar do que não precisamos

8610
05:48:08,958 --> 05:48:10,958
e vamos colocar no código para

8611
05:48:10,958 --> 05:48:14,080
brincar com essas coisas que temos três

8612
05:48:14,080 --> 05:48:18,798
variáveis booleanas a é verdadeiro b é falso c

8613
05:48:18,798 --> 05:48:20,080
É verdade

8614
05:48:20,080 --> 05:48:21,680
E nós podemos imprimi-los e nós somos

8615
05:48:21,680 --> 05:48:23,440
Vou ver seus valores e você vê

8616
05:48:23,440 --> 05:48:26,718
A configuração aqui para que o sddc saia vai

8617
05:48:26,718 --> 05:48:29,600
para mostrar graças no formato de verdade e

8618
05:48:29,600 --> 05:48:33,680
falso e aqui estamos terminando alguns

8619
05:48:33,680 --> 05:48:36,958
valores que usamos e operador e

8620
05:48:36,958 --> 05:48:39,920
é denotado por estes dois ampersand

8621
05:48:39,920 --> 05:48:41,040
Sinais de sinalização

8622
05:48:41,040 --> 05:48:41,760
Então,

8623
05:48:41,760 --> 05:48:45,920
a é verdadeiro e b é falso e c é verdadeiro

8624
05:48:45,920 --> 05:48:48,878
a e b vai avaliar

8625
05:48:48,878 --> 05:48:51,600
para falso porque temos uma falsa aqui

8626
05:48:51,600 --> 05:48:53,680
e novamente se isso não faz sentido

8627
05:48:53,680 --> 05:48:56,480
Por favor, consulte as mesas para todos

8628
05:48:56,480 --> 05:48:58,718
Esses operadores lógicos e tudo isso

8629
05:48:58,718 --> 05:49:00,400
As coisas vão fazer sentido, isto é

8630
05:49:00,400 --> 05:49:02,718
vamos avaliar o falso porque nós

8631
05:49:02,718 --> 05:49:06,718
ter um falso aqui e a e c temos

8632
05:49:06,718 --> 05:49:08,958
verdadeiro e verdadeiro, então isso vai

8633
05:49:08,958 --> 05:49:11,440
avaliar para verdadeiro e

8634
05:49:11,440 --> 05:49:14,558
a e b e c isto vai avaliar

8635
05:49:14,558 --> 05:49:16,798
para falso porque temos uma falsa aqui

8636
05:49:16,798 --> 05:49:19,760
Lembre-se assim que você tem um falso em

8637
05:49:19,760 --> 05:49:23,200
sua e lógica operação você está indo

8638
05:49:23,200 --> 05:49:26,240
para obter uma falsa em seu resultado, então nós somos

8639
05:49:26,240 --> 05:49:28,638
Vou ter um falso aqui, podemos tentar

8640
05:49:28,638 --> 05:49:30,878
e compilar isso e ver se isso é

8641
05:49:30,878 --> 05:49:33,200
Na verdade, o que esperamos que vamos

8642
05:49:33,200 --> 05:49:35,120
trazer um terminal que vamos usar

8643
05:49:35,120 --> 05:49:37,680
Aqui e vamos executar as tarefas para

8644
05:49:37,680 --> 05:49:39,600
construção com gcc

8645
05:49:39,600 --> 05:49:43,040
e se executarmos o nosso programa de galo, nós somos

8646
05:49:43,040 --> 05:49:46,558
Vou ver que a e b é falsa

8647
05:49:46,558 --> 05:49:48,480
Isto é o que nós esperamos

8648
05:49:48,480 --> 05:49:52,480
a e c é verdade, isto é o que esperamos

8649
05:49:52,480 --> 05:49:54,160
a e b e c

8650
05:49:54,160 --> 05:49:56,958
É falso e isso é o que esperamos

8651
05:49:56,958 --> 05:49:58,878
É assim que você pode realmente jogar com

8652
05:49:58,878 --> 05:50:02,000
seu e o operador lógico, se você quiser

8653
05:50:02,000 --> 05:50:04,718
Você pode mudar as coisas para realmente

8654
05:50:04,718 --> 05:50:07,680
Tente ver se eles vivem até o seu

8655
05:50:07,680 --> 05:50:09,200
Expectativas

8656
05:50:09,200 --> 05:50:12,240
Agora nós mudamos um para falso, vamos tentar

8657
05:50:12,240 --> 05:50:15,520
e construir novamente nós construímos com gcc

8658
05:50:15,520 --> 05:50:18,480
e nós vamos executar o nosso programa

8659
05:50:18,480 --> 05:50:20,878
e nós vamos ter um e b é falso

8660
05:50:20,878 --> 05:50:23,600
porque são todos falsos a e b são

8661
05:50:23,600 --> 05:50:27,120
falso tão falso e falso avalia para

8662
05:50:27,120 --> 05:50:28,080
Falso

8663
05:50:28,080 --> 05:50:31,840
a e c é falso porque a é falsa

8664
05:50:31,840 --> 05:50:34,638
Vamos obter um falso como resultado

8665
05:50:34,638 --> 05:50:37,200
a e b e c também vão avaliar

8666
05:50:37,200 --> 05:50:40,400
para falso, temos essa tensão aqui

8667
05:50:40,400 --> 05:50:42,718
Vamos trazer isso de volta ao que era

8668
05:50:42,718 --> 05:50:45,440
antes, então a será verdade b é

8669
05:50:45,440 --> 05:50:48,000
Vai ser falso c vai ser verdade

8670
05:50:48,000 --> 05:50:50,480
e nós vamos tentar brincar com o

8671
05:50:50,480 --> 05:50:53,360
ou operador, vamos descer e

8672
05:50:53,360 --> 05:50:57,200
colocar em código para realmente jogar com isso

8673
05:50:57,200 --> 05:50:59,440
E não é realmente nada de especial que somos

8674
05:50:59,440 --> 05:51:01,840
apenas usando o ou o operador aqui que é

8675
05:51:01,840 --> 05:51:04,320
denotado por estes dois verticais

8676
05:51:04,320 --> 05:51:07,440
símbolos e ou vai avaliar para

8677
05:51:07,440 --> 05:51:08,240
Verdadeiro

8678
05:51:08,240 --> 05:51:11,360
Quando pelo menos um dos operandos é

8679
05:51:11,360 --> 05:51:14,160
Verdadeiro bom, então temos nossos valores aqui

8680
05:51:14,160 --> 05:51:17,760
é verdade b é falso c é verdadeiro ou b é

8681
05:51:17,760 --> 05:51:20,320
vai avaliar para verdadeiro porque a

8682
05:51:20,320 --> 05:51:21,280
Verdadeiro

8683
05:51:21,280 --> 05:51:23,760
a ou c vai avaliar para verdadeiro

8684
05:51:23,760 --> 05:51:25,520
Porque a é verdade

8685
05:51:25,520 --> 05:51:29,760
a ou b ou c vai avaliar para verdadeiro

8686
05:51:29,760 --> 05:51:32,240
porque uma dessas coisas é verdadeira e

8687
05:51:32,240 --> 05:51:34,320
A é verdade aqui

8688
05:51:34,320 --> 05:51:36,558
Podemos tentar correr isso, vamos

8689
05:51:36,558 --> 05:51:38,558
Construa isso primeiro

8690
05:51:38,558 --> 05:51:43,440
com gcc e se executarmos isso

8691
05:51:43,440 --> 05:51:46,160
Vamos descer aqui e correr

8692
05:51:46,160 --> 05:51:48,080
Galo outra vez

8693
05:51:48,080 --> 05:51:49,840
E você vai ver que tudo isso

8694
05:51:49,840 --> 05:51:52,400
As coisas são verdadeiras aqui porque uma das

8695
05:51:52,400 --> 05:51:55,520
Essas coisas são mostradas e enquanto você

8696
05:51:55,520 --> 05:51:59,280
ter um verdadeiro operando seu ou operação

8697
05:51:59,280 --> 05:52:02,480
vai avaliar para verdadeiro e novamente

8698
05:52:02,480 --> 05:52:04,558
Isto segue a precedência e

8699
05:52:04,558 --> 05:52:07,200
Regras de associatividade que temos se formos

8700
05:52:07,200 --> 05:52:10,160
de volta à nossa tabela em nosso navegador, estamos

8701
05:52:10,160 --> 05:52:13,280
tentar olhar para a lógica ou

8702
05:52:13,280 --> 05:52:14,320
É

8703
05:52:14,320 --> 05:52:16,638
Deixado associativo, então vamos tentar

8704
05:52:16,638 --> 05:52:19,440
e avaliar isso da esquerda para a direita assim

8705
05:52:19,440 --> 05:52:22,958
nós vamos ou a e b e o resultado

8706
05:52:22,958 --> 05:52:26,160
disso vai ser oud com c

8707
05:52:26,160 --> 05:52:29,280
Também viu o não operador que é

8708
05:52:29,280 --> 05:52:32,480
denotado pelo ponto de exclamação aqui e

8709
05:52:32,480 --> 05:52:34,878
O que vai fazer é basicamente

8710
05:52:34,878 --> 05:52:37,360
Vire ou negue o que for você

8711
05:52:37,360 --> 05:52:39,440
Se você tem isso verdade em seu

8712
05:52:39,440 --> 05:52:42,240
variável o resultado vai ser falso

8713
05:52:42,240 --> 05:52:44,320
Se você tem uniformes, o resultado está indo

8714
05:52:44,320 --> 05:52:45,440
para ser verdade

8715
05:52:45,440 --> 05:52:49,040
e não vai ser falso porque a

8716
05:52:49,040 --> 05:52:51,680
É verdade não b vai ser verdade

8717
05:52:51,680 --> 05:52:53,440
Porque b

8718
05:52:53,440 --> 05:52:56,320
É falso e não c

8719
05:52:56,320 --> 05:52:59,280
vai ser falso porque c é verdadeiro

8720
05:52:59,280 --> 05:53:01,920
como podemos ver aqui, então vamos correr o

8721
05:53:01,920 --> 05:53:04,160
aplicar e ver se isso é o que nós

8722
05:53:04,160 --> 05:53:05,440
Esperar

8723
05:53:05,440 --> 05:53:08,718
nós vamos correr e construir com gcc

8724
05:53:08,718 --> 05:53:11,360
e nós vamos correr o galo e nós estamos

8725
05:53:11,360 --> 05:53:14,878
Vou ver que a nota a é falsa não b

8726
05:53:14,878 --> 05:53:18,718
é verdadeiro e não c é falso e isso é

8727
05:53:18,718 --> 05:53:21,120
O que esperamos também vimos que

8728
05:53:21,120 --> 05:53:24,080
pode fazer combinações desses operadores

8729
05:53:24,080 --> 05:53:26,400
Por exemplo, podemos olhar para o

8730
05:53:26,400 --> 05:53:28,558
A expressão que temos aqui

8731
05:53:28,558 --> 05:53:29,840
nós vamos

8732
05:53:29,840 --> 05:53:33,440
tomar a e b vai avaliar

8733
05:53:33,440 --> 05:53:36,160
para falso porque b é falso

8734
05:53:36,160 --> 05:53:38,320
nós vamos negar isso e nós somos

8735
05:53:38,320 --> 05:53:40,480
Vou ficar um verdadeiro e nós vamos

8736
05:53:40,480 --> 05:53:42,160
ordenar isso com c

8737
05:53:42,160 --> 05:53:44,000
Mas porque é verdade

8738
05:53:44,000 --> 05:53:46,400
Sabemos que o resultado de ordenar isso

8739
05:53:46,400 --> 05:53:48,878
com qualquer coisa vai ser verdade, então nós

8740
05:53:48,878 --> 05:53:52,000
Espero que esta expressão aqui avalie

8741
05:53:52,000 --> 05:53:55,040
para verdadeiro se nós executarmos isso

8742
05:53:55,040 --> 05:53:57,200
nós vamos ver que isso vai

8743
05:53:57,200 --> 05:53:59,680
avaliar para verdadeiro e é o que nós

8744
05:53:59,680 --> 05:54:00,958
Esperar

8745
05:54:00,958 --> 05:54:02,558
A última coisa que queremos ver nisso

8746
05:54:02,558 --> 05:54:05,200
A palestra é que podemos combinar

8747
05:54:05,200 --> 05:54:08,000
Esses operadores lógicos com o

8748
05:54:08,000 --> 05:54:10,798
operadores relacionais que temos visto no

8749
05:54:10,798 --> 05:54:13,440
A última palestra vamos colocar em um

8750
05:54:13,440 --> 05:54:16,878
pedaço de código para jogar com isso este é

8751
05:54:16,878 --> 05:54:19,280
longo, mas você pode jogar com isso e

8752
05:54:19,280 --> 05:54:22,718
Veja o que isso vai avaliar para

8753
05:54:22,718 --> 05:54:24,638
Comece você fora nós vamos fazer o

8754
05:54:24,638 --> 05:54:28,558
primeiro um juntos para que ele teste se d

8755
05:54:28,558 --> 05:54:31,200
é maior do que e e se você olhar aqui

8756
05:54:31,200 --> 05:54:33,920
45 é maior que 20, então isso está acontecendo

8757
05:54:33,920 --> 05:54:36,000
para avaliar para a verdade

8758
05:54:36,000 --> 05:54:38,638
e nós vamos entrar nisso com d

8759
05:54:38,638 --> 05:54:40,718
Maior do que f

8760
05:54:40,718 --> 05:54:43,840
O resultado disso vai ser verdade

8761
05:54:43,840 --> 05:54:46,558
Então nós vamos estar terminando um verdadeiro e um

8762
05:54:46,558 --> 05:54:48,958
verdadeiro e o resultado disso vai

8763
05:54:48,958 --> 05:54:51,360
ser verdadeiro e novamente você percebe que nós

8764
05:54:51,360 --> 05:54:53,440
estão envolvendo isso entre parênteses para

8765
05:54:53,440 --> 05:54:55,120
Evite os problemas

8766
05:54:55,120 --> 05:54:58,558
com o compilador sendo confundido com

8767
05:54:58,558 --> 05:55:00,480
O que estamos tentando imprimir isso é

8768
05:55:00,480 --> 05:55:03,040
Vou se livrar do de outra forma feio

8769
05:55:03,040 --> 05:55:05,440
problemas com os quais precisamos lidar se

8770
05:55:05,440 --> 05:55:07,840
nós não envolvemos isso em parênteses

8771
05:55:07,840 --> 05:55:10,320
Assim, então esperamos ver um verdadeiro

8772
05:55:10,320 --> 05:55:13,040
Aqui e nós vamos soldar

8773
05:55:13,040 --> 05:55:16,320
e executar a tarefa para construir com gcc

8774
05:55:16,320 --> 05:55:19,040
e nós vamos correr o galo e se nós

8775
05:55:19,040 --> 05:55:21,680
Olhe para a primeira coisa aqui que é

8776
05:55:21,680 --> 05:55:24,160
Vai ser verdade e você pode tentar fazer

8777
05:55:24,160 --> 05:55:26,558
os outros em sua mente como um

8778
05:55:26,558 --> 05:55:29,120
Se exercitar e se você tiver um problema, não

8779
05:55:29,120 --> 05:55:31,680
hesite em me perguntar que eu vou fazer o

8780
05:55:31,680 --> 05:55:34,080
O melhor que posso para te ajudar

8781
05:55:34,080 --> 05:55:35,760
Isso é realmente tudo o que nos prossamos fazer em

8782
05:55:35,760 --> 05:55:37,920
Esta palestra espero que você tenha um melhor

8783
05:55:37,920 --> 05:55:41,040
compreensão desses operadores lógicos

8784
05:55:41,040 --> 05:55:43,360
Mais uma vez você não tem que realmente memorizar

8785
05:55:43,360 --> 05:55:46,320
Tudo o que você tem a fazer é consultar o

8786
05:55:46,320 --> 05:55:48,558
mesas e você vai basicamente

8787
05:55:48,558 --> 05:55:51,280
Conheça o resultado de seus dois operandos

8788
05:55:51,280 --> 05:55:53,920
dependendo dos valores que você tem dentro

8789
05:55:53,920 --> 05:55:57,760
para e ou e não operador que somos

8790
05:55:57,760 --> 05:56:00,000
Vou parar aqui nesta palestra em

8791
05:56:00,000 --> 05:56:01,520
O próximo vamos ver como nós

8792
05:56:01,520 --> 05:56:05,200
pode formatar a nossa saída para torná-lo realmente

8793
05:56:05,200 --> 05:56:08,080
olhar melhor ir em frente e terminar aqui

8794
05:56:08,080 --> 05:56:10,320
e encontrar-me lá nesta palestra nós somos

8795
05:56:10,320 --> 05:56:13,360
vai olhar para a formatação de saída e c

8796
05:56:13,360 --> 05:56:15,760
além disso e é assim que podemos formatar

8797
05:56:15,760 --> 05:56:18,080
coisas que nós enviamos para o terminal através

8798
05:56:18,080 --> 05:56:21,520


8799
05:56:21,520 --> 05:56:24,080
Um exemplo, digamos que temos uma mesa

8800
05:56:24,080 --> 05:56:27,440
Aqui que tem nomes e idades

8801
05:56:27,440 --> 05:56:30,240
e você vê que eles estão apertados e

8802
05:56:30,240 --> 05:56:32,638
através da formatação da saída que podemos tomar

8803
05:56:32,638 --> 05:56:35,600
Isso e transformar isso em este

8804
05:56:35,600 --> 05:56:38,000
e esperamos concordar que isso é

8805
05:56:38,000 --> 05:56:38,878
O melhor

8806
05:56:38,878 --> 05:56:41,360
há um conjunto de ferramentas que podemos usar em c

8807
05:56:41,360 --> 05:56:43,680
mais mais e aqueles que vamos ser

8808
05:56:43,680 --> 05:56:46,558
Usando nesta palestra vai ser

8809
05:56:46,558 --> 05:56:49,520
vindos destas duas bibliotecas ios e

8810
05:56:49,520 --> 05:56:53,040
io manip e há muitas coisas

8811
05:56:53,040 --> 05:56:56,638
nestas duas bibliotecas aqui é um conjunto

8812
05:56:56,638 --> 05:57:00,400
de cartões que mostram muitos deles que somos

8813
05:57:00,400 --> 05:57:01,840
indo para jogar com um monte destes em

8814
05:57:01,840 --> 05:57:03,840
Esta palestra não precisa se preocupar

8815
05:57:03,840 --> 05:57:06,400
Se alguns deles parecem assustadores

8816
05:57:06,400 --> 05:57:08,798
Agora, antes de começarmos a olhar

8817
05:57:08,798 --> 05:57:11,200
Eles eu quero trazer à sua atenção

8818
05:57:11,200 --> 05:57:13,440
Existe um pedaço de documentação

8819
05:57:13,440 --> 05:57:15,680
nessas coisas o link está aqui o

8820
05:57:15,680 --> 05:57:17,480
O site é chamado

8821
05:57:17,480 --> 05:57:19,040
cppreference.com (em inglês)

8822
05:57:19,040 --> 05:57:21,600
e você pode abrir isso e olhar para

8823
05:57:21,600 --> 05:57:23,200
Algumas das coisas que vamos falar

8824
05:57:23,200 --> 05:57:25,680
sobre nesta palestra OK o primeiro

8825
05:57:25,680 --> 05:57:29,440
nós vamos olhar para é stdendl

8826
05:57:29,440 --> 05:57:31,840
Isso não é novo que temos usado

8827
05:57:31,840 --> 05:57:34,400
durante todo o dia para imprimir uma nova linha

8828
05:57:34,400 --> 05:57:38,000
personagem para que nossas declarações htdcl

8829
05:57:38,000 --> 05:57:40,718
imprimir coisas em linhas diferentes e se

8830
05:57:40,718 --> 05:57:43,280
Não temos este manipulador que você vê

8831
05:57:43,280 --> 05:57:46,240
Aqui no topo temos olá e o mundo

8832
05:57:46,240 --> 05:57:48,080
E se nós os imprimirmos, eles estão indo

8833
05:57:48,080 --> 05:57:50,480
para aparecer em uma linha porque nós somos

8834
05:57:50,480 --> 05:57:53,600
não separar as linhas com std e

8835
05:57:53,600 --> 05:57:56,638
dl abaixo aqui temos outra maneira

8836
05:57:56,638 --> 05:57:59,760
nós podemos fazer isso, podemos postar uma reação n

8837
05:57:59,760 --> 05:58:02,718
após o nosso texto e que vai adicionar um

8838
05:58:02,718 --> 05:58:06,320
novo personagem de linha, assim como std endl

8839
05:58:06,320 --> 05:58:10,958
faz OK stdndl e cortar n aqui

8840
05:58:10,958 --> 05:58:13,600
Aparentemente fazem a mesma coisa

8841
05:58:13,600 --> 05:58:15,760
Mas eles são diferentes, mas nós não temos

8842
05:58:15,760 --> 05:58:17,600
ferramentas suficientes para realmente entender o

8843
05:58:17,600 --> 05:58:20,400
diferenças agora, por enquanto, pense

8844
05:58:20,400 --> 05:58:23,360
deles como duas coisas que fazem o mesmo

8845
05:58:23,360 --> 05:58:26,320
A coisa que eles imprimem um novo personagem

8846
05:58:26,320 --> 05:58:28,400
que permite que seu texto apareça

8847
05:58:28,400 --> 05:58:31,200
linhas diferentes como temos olá e

8848
05:58:31,200 --> 05:58:34,400
O mundo aqui OK stdndl é o primeiro

8849
05:58:34,400 --> 05:58:36,558
manipulador com quem vamos brincar

8850
05:58:36,558 --> 05:58:38,240
Esta palestra é a próxima que vamos

8851
05:58:38,240 --> 05:58:40,480
olhar para é sdd flush

8852
05:58:40,480 --> 05:58:43,040
E isso vai enviar o que está dentro

8853
05:58:43,040 --> 05:58:46,160
o buffer de saída para o terminal

8854
05:58:46,160 --> 05:58:48,878
e o que diabos é um buffer de saída

8855
05:58:48,878 --> 05:58:51,440
Vejamos um exemplo, suponha que temos

8856
05:58:51,440 --> 05:58:54,240
Oddc aqui e queremos imprimir em

8857
05:58:54,240 --> 05:58:56,798
Este terminal e a mensagem que queremos

8858
05:58:56,798 --> 05:59:00,400
A impressão é olá mundo como você é, então o que

8859
05:59:00,400 --> 05:59:03,360
vai acontecer se o sddc para fora

8860
05:59:03,360 --> 05:59:06,000
A afirmação é executada, coisas não

8861
05:59:06,000 --> 05:59:07,760
ser enviado diretamente para o

8862
05:59:07,760 --> 05:59:10,400
terminal eles vão entrar em um

8863
05:59:10,400 --> 05:59:12,718
amortecedores intermediários que você pode pensar

8864
05:59:12,718 --> 05:59:15,120
Isso como algum tipo de armazenamento em que

8865
05:59:15,120 --> 05:59:18,320
Os dados vão antes de ir para o terminal

8866
05:59:18,320 --> 05:59:20,000
E isso é o que vai acontecer nós

8867
05:59:20,000 --> 05:59:21,920
imprimir fora hello hello hello não vai ir

8868
05:59:21,920 --> 05:59:23,760
para o terminal diretamente

8869
05:59:23,760 --> 05:59:25,760
nós imprimimos o mundo

8870
05:59:25,760 --> 05:59:28,080
não vai para o terminal

8871
05:59:28,080 --> 05:59:30,320
imprimir fora como você está

8872
05:59:30,320 --> 05:59:32,320
não vai para o terminal e

8873
05:59:32,320 --> 05:59:34,558
Quando o buffer está cheio

8874
05:59:34,558 --> 05:59:36,638
Os dados serão enviados para o

8875
05:59:36,638 --> 05:59:39,920
terminal em uma só tentativa e isso pode entrar

8876
05:59:39,920 --> 05:59:42,878
à mão em algumas situações, então se você quiser

8877
05:59:42,878 --> 05:59:45,600
os dados para ir diretamente ao terminal

8878
05:59:45,600 --> 05:59:48,400
você vai adicionar um sdd flash

8879
05:59:48,400 --> 05:59:52,000
após sua declaração de hddc e nós estamos

8880
05:59:52,000 --> 05:59:54,160
Vou jogar com isso em um minuto

8881
05:59:54,160 --> 05:59:55,760
código de estúdio visual e você vai

8882
05:59:55,760 --> 05:59:58,000
Veja como isso funciona outro manipulador

8883
05:59:58,000 --> 06:00:01,520
nós temos que é realmente legal é definido com

8884
06:00:01,520 --> 06:00:05,680
e é std set w aqui e o que ele

8885
06:00:05,680 --> 06:00:09,600
Isso especifica uma largura para qualquer

8886
06:00:09,600 --> 06:00:12,480
Texto que você quer imprimir aqui temos dois

8887
06:00:12,480 --> 06:00:15,920
Exemplos, o primeiro é a nossa tabela que

8888
06:00:15,920 --> 06:00:18,320
Não é formatado bem e você vê que nós

8889
06:00:18,320 --> 06:00:20,320
Basta imprimir os dados e ele está indo

8890
06:00:20,320 --> 06:00:23,680
para aparecer como vemos aqui à direita

8891
06:00:23,680 --> 06:00:27,840
podemos usar std conjunto com para definir a largura

8892
06:00:27,840 --> 06:00:30,480
do texto aqui e, por exemplo,

8893
06:00:30,480 --> 06:00:32,958
O sobrenome aqui vai aparecer em um

8894
06:00:32,958 --> 06:00:36,480
campo que é 10 caracteres branco este

8895
06:00:36,480 --> 06:00:38,718
É o que queremos dizer aqui e fazemos o mesmo

8896
06:00:38,718 --> 06:00:41,920
para o primeiro nome e a idade e se

8897
06:00:41,920 --> 06:00:43,040
Faz isto

8898
06:00:43,040 --> 06:00:45,440
Os dados vão aparecer muito bem como nós

8899
06:00:45,440 --> 06:00:48,558
ver aqui e novamente espero que nós concordamos que

8900
06:00:48,558 --> 06:00:51,120
O que temos abaixo aqui é muito

8901
06:00:51,120 --> 06:00:53,760
melhor do que aquilo que tivemos aqui

8902
06:00:53,760 --> 06:00:56,878
que não foi formatado com largura definida

8903
06:00:56,878 --> 06:00:59,120
E é assim que você usa esse manipulador

8904
06:00:59,120 --> 06:01:01,120
Aqui também podemos usar o que chamamos de

8905
06:01:01,120 --> 06:01:03,200
justificativa para controlar se o nosso

8906
06:01:03,200 --> 06:01:06,080
Os dados aparecem à direita ou no

8907
06:01:06,080 --> 06:01:06,958
para a esquerda

8908
06:01:06,958 --> 06:01:10,080
na largura que lhe é atribuída para

8909
06:01:10,080 --> 06:01:11,840
Um exemplo aqui

8910
06:01:11,840 --> 06:01:14,878
A justificativa é sdd direita, então os dados

8911
06:01:14,878 --> 06:01:16,958
vai aparecer à direita em sua

8912
06:01:16,958 --> 06:01:19,840
As respectivas células também podemos usar o que nós

8913
06:01:19,840 --> 06:01:23,040
chamar a justificação interna pelo qual se

8914
06:01:23,040 --> 06:01:25,760
Estamos mostrando um número negativo

8915
06:01:25,760 --> 06:01:28,240
O sinal vai ser deixado justificado para que

8916
06:01:28,240 --> 06:01:30,638
vai aparecer à esquerda, mas a

8917
06:01:30,638 --> 06:01:33,200
Os dados serão justificados e

8918
06:01:33,200 --> 06:01:35,200
Isso pode ser útil se você quiser

8919
06:01:35,200 --> 06:01:37,600
Exibir alguns dados tabulares

8920
06:01:37,600 --> 06:01:41,440
em seu terminal também podemos usar std set

8921
06:01:41,440 --> 06:01:44,000
campo para especificar o caractere de campo em

8922
06:01:44,000 --> 06:01:47,040
nossos espaços vazios, por exemplo, aqui que estabelecemos

8923
06:01:47,040 --> 06:01:49,680
O traço como um personagem de campo e

8924
06:01:49,680 --> 06:01:52,878
O resultado é o que você vê aqui embaixo

8925
06:01:52,878 --> 06:01:56,240
temos visto std ball alpha e é

8926
06:01:56,240 --> 06:01:58,320
O efeito é forçar

8927
06:01:58,320 --> 06:02:02,480
stdc out para mostrar a saída boolean no

8928
06:02:02,480 --> 06:02:05,920
forma de verdadeiro e falso se você não colocar

8929
06:02:05,920 --> 06:02:08,480
Este manipulador em você vai ver

8930
06:02:08,480 --> 06:02:11,440
esses dados como uns e zeros

8931
06:02:11,440 --> 06:02:12,878
Assim, por exemplo, aqui temos dois

8932
06:02:12,878 --> 06:02:15,440
variáveis condição e outras condições

8933
06:02:15,440 --> 06:02:17,200
Se nós os imprimirmos, eles vão

8934
06:02:17,200 --> 06:02:19,840
aparecer como um e zero nós vamos

8935
06:02:19,840 --> 06:02:22,240
definir o nosso manipulador aqui para que os dados sejam

8936
06:02:22,240 --> 06:02:24,958
indo aparecer como verdadeiro e falso nós

8937
06:02:24,958 --> 06:02:28,240
pode desativar este manipulador aqui com

8938
06:02:28,240 --> 06:02:31,600
std noble alpha e os dados vão

8939
06:02:31,600 --> 06:02:34,638
Volte para ser mostrado na forma de um

8940
06:02:34,638 --> 06:02:37,360
E zero é isso que este manipulador

8941
06:02:37,360 --> 06:02:39,520
nós também temos um para mostrar o

8942
06:02:39,520 --> 06:02:42,320
sinal positivo para números positivos

8943
06:02:42,320 --> 06:02:43,200
Então,

8944
06:02:43,200 --> 06:02:45,280
se não permitirmos que os dados aqui estejam

8945
06:02:45,280 --> 06:02:48,080
vai aparecer assim 34 e menos

8946
06:02:48,080 --> 06:02:50,878
45 você vê que o sinal de menos está indo

8947
06:02:50,878 --> 06:02:53,760
ser mostrado independentemente da configuração

8948
06:02:53,760 --> 06:02:56,958
Você tem para este manipulador, mas se nós

8949
06:02:56,958 --> 06:02:59,760
enable std show pose

8950
06:02:59,760 --> 06:03:02,160
Vamos mostrar o número positivo

8951
06:03:02,160 --> 06:03:04,320
E isso pode fazer sentido para o que

8952
06:03:04,320 --> 06:03:06,480
Aplicação que você pode estar fazendo

8953
06:03:06,480 --> 06:03:09,520
nós podemos desabilitar isso com std no show

8954
06:03:09,520 --> 06:03:12,320
posts e depois que fazemos isso, os dados são

8955
06:03:12,320 --> 06:03:15,520
vai aparecer em seu formato padrão

8956
06:03:15,520 --> 06:03:17,840
que já vimos antes é assim que você

8957
06:03:17,840 --> 06:03:20,798
usar std mostrar posts que também temos

8958
06:03:20,798 --> 06:03:23,120
Os manipuladores para controlar

8959
06:03:23,120 --> 06:03:26,080
a base na qual os dados são mostrados e

8960
06:03:26,080 --> 06:03:28,798
podemos mostrar os dados em um decimal

8961
06:03:28,798 --> 06:03:31,760
em octo ou em hexodecimal se você olhar para

8962
06:03:31,760 --> 06:03:34,080
os dados aqui temos um inteiro que

8963
06:03:34,080 --> 06:03:35,920
É positivo que temos um inteiro.

8964
06:03:35,920 --> 06:03:38,718
negativo e temos uma variável dupla

8965
06:03:38,718 --> 06:03:41,360
aqui e temos alguns dados n para nós

8966
06:03:41,360 --> 06:03:43,040
jogar com nós vamos mostrar o nosso

8967
06:03:43,040 --> 06:03:45,840
inteiro positivo nessas três bases

8968
06:03:45,840 --> 06:03:48,558
decimal hex e octo

8969
06:03:48,558 --> 06:03:51,200
O resultado é o que você vê aqui e

8970
06:03:51,200 --> 06:03:53,520
Isso não deve ser nenhuma surpresa você já

8971
06:03:53,520 --> 06:03:54,480
- Conhecer

8972
06:03:54,480 --> 06:03:57,680
esses sistemas numéricos e como funcionam

8973
06:03:57,680 --> 06:03:59,840
nós podemos tomar o número negativo e também

8974
06:03:59,840 --> 06:04:02,160
mostrá-lo em diferentes bases decimal

8975
06:04:02,160 --> 06:04:05,280
hexadecimal e octo e é o que você

8976
06:04:05,280 --> 06:04:08,400
Tenho à direita aqui no nosso terminal

8977
06:04:08,400 --> 06:04:10,958
Se descermos e tentarmos mostrar

8978
06:04:10,958 --> 06:04:14,320
um número de ponto duplo ou flutuante em

8979
06:04:14,320 --> 06:04:17,040
Essas bases o resultado não vai

8980
06:04:17,040 --> 06:04:20,160
mudar porque esses sistemas numéricos têm

8981
06:04:20,160 --> 06:04:22,958
sem efeito sobre os números de ponto flutuante se

8982
06:04:22,958 --> 06:04:25,360
Você se lembra que vimos isso flutuando

8983
06:04:25,360 --> 06:04:26,878
Números de pontos

8984
06:04:26,878 --> 06:04:29,520
são representados na memória seguindo

8985
06:04:29,520 --> 06:04:32,320
Outro protocolo que é realmente avançado

8986
06:04:32,320 --> 06:04:33,200
para a

8987
06:04:33,200 --> 06:04:35,840
Um curso como este, então estamos apenas indo

8988
06:04:35,840 --> 06:04:37,600
para usar isso, mas não vamos tentar

8989
06:04:37,600 --> 06:04:39,840
e entendê-lo porque está fora de

8990
06:04:39,840 --> 06:04:42,480
Espaço para o que estamos fazendo aqui podemos

8991
06:04:42,480 --> 06:04:45,440
também usar std show base

8992
06:04:45,440 --> 06:04:48,718
para mostrar a base de nossa saída

8993
06:04:48,718 --> 06:04:50,878
Então aqui temos um número positivo que

8994
06:04:50,878 --> 06:04:54,638
é um inteiro e podemos mostrá-lo em

8995
06:04:54,638 --> 06:04:57,200
decimal hex e agir e nós vamos

8996
06:04:57,200 --> 06:05:00,080
Veja o que vemos aqui à direita, mas nós

8997
06:05:00,080 --> 06:05:03,200
pode escolher também mostrar a base de

8998
06:05:03,200 --> 06:05:05,440
Seja o que for que produzamos se quisermos

8999
06:05:05,440 --> 06:05:08,480
especificar que a saída está emcimal

9000
06:05:08,480 --> 06:05:11,040
nós vamos dizer isso aqui, mas nós podemos

9001
06:05:11,040 --> 06:05:13,440
também decidir mostrar a base e nós

9002
06:05:13,440 --> 06:05:18,240
permitir isso com std show base como este

9003
06:05:18,240 --> 06:05:20,240
E se fizermos isso, vamos ver

9004
06:05:20,240 --> 06:05:22,160
Decimal não vai ter nada em

9005
06:05:22,160 --> 06:05:25,840
frontal hex terá um 0x na frente

9006
06:05:25,840 --> 06:05:29,280
Oct vai ter um zero na frente e

9007
06:05:29,280 --> 06:05:31,680
Por isso vai ser muito fácil

9008
06:05:31,680 --> 06:05:32,558
Veja

9009
06:05:32,558 --> 06:05:35,760
a base na qual seus dados são exibidos

9010
06:05:35,760 --> 06:05:38,160
nós também podemos usar std upper case para o

9011
06:05:38,160 --> 06:05:40,160
dados que imprimimos para serem mostrados em

9012
06:05:40,160 --> 06:05:43,120
Alto, onde faz sentido para

9013
06:05:43,120 --> 06:05:44,878
O exemplo aqui estamos tentando imprimir

9014
06:05:44,878 --> 06:05:47,520
números em hexadecimal aqui no

9015
06:05:47,520 --> 06:05:50,320
meio, então se não usarmos maiúsculas

9016
06:05:50,320 --> 06:05:51,920
Qual é o padrão

9017
06:05:51,920 --> 06:05:53,840
O número vai aparecer assim

9018
06:05:53,840 --> 06:05:57,760
Você vê a e f são minúsculas, mas se nós

9019
06:05:57,760 --> 06:06:00,080
permitir maiúsculas que vamos ver isso

9020
06:06:00,080 --> 06:06:02,718
em maiúsculas e às vezes isso está indo

9021
06:06:02,718 --> 06:06:05,280
para ser útil para qualquer aplicação

9022
06:06:05,280 --> 06:06:08,400
Você está usando o sol, também temos alguns

9023
06:06:08,400 --> 06:06:10,638
manipuladores para controlar como flutuar

9024
06:06:10,638 --> 06:06:13,440
Os dados pontuais são mostrados no terminal e

9025
06:06:13,440 --> 06:06:16,160
Os dois são científicos e

9026
06:06:16,160 --> 06:06:19,440
sdd fixado por padrão stdc para fora está indo

9027
06:06:19,440 --> 06:06:20,878
para mostrar

9028
06:06:20,878 --> 06:06:23,680
em formato científico, quando necessário e

9029
06:06:23,680 --> 06:06:26,558
ele vai usar fixo por padrão, então

9030
06:06:26,558 --> 06:06:28,240
O que temos aqui

9031
06:06:28,240 --> 06:06:31,120
Nós temos três variáveis abc

9032
06:06:31,120 --> 06:06:33,360
E se nós apenas os imprimirmos, eles são

9033
06:06:33,360 --> 06:06:36,080
vai aparecer neste formato aqui se

9034
06:06:36,080 --> 06:06:38,320
nós usamos fixo, vamos forçar o

9035
06:06:38,320 --> 06:06:40,878
saída para estar em formato fixo e você está

9036
06:06:40,878 --> 06:06:43,120
ver que o terceiro número em c

9037
06:06:43,120 --> 06:06:46,798
Aqui vai aparecer como 0,0 e um

9038
06:06:46,798 --> 06:06:49,840
Poucos zeros depois disso, porque no

9039
06:06:49,840 --> 06:06:52,080
precisão que temos agora não podemos

9040
06:06:52,080 --> 06:06:55,440
realmente mostrar um número tão baixo quanto

9041
06:06:55,440 --> 06:06:57,840
Temos aqui em c novamente temos visto

9042
06:06:57,840 --> 06:07:00,320
Este formato científico é

9043
06:07:00,320 --> 06:07:03,120
basicamente 1.34

9044
06:07:03,120 --> 06:07:06,080
multiplicado por 10 ao poder de menos

9045
06:07:06,080 --> 06:07:08,480
10 e isso é realmente muito baixo

9046
06:07:08,480 --> 06:07:10,840
Número, então nós vamos fazer

9047
06:07:10,840 --> 06:07:14,480
0.000 até 10 e é quando isso

9048
06:07:14,480 --> 06:07:16,798
O ponto decimal vai mostrar, então é um

9049
06:07:16,798 --> 06:07:19,120
Número que é realmente perto de zero

9050
06:07:19,120 --> 06:07:21,760
É por isso que estamos mostrando isso como 0,0

9051
06:07:21,760 --> 06:07:24,638
Aqui espero que isso faça sentido, também podemos

9052
06:07:24,638 --> 06:07:27,520
usar notação científica se quisermos isso

9053
06:07:27,520 --> 06:07:30,320
E se forçamos a notação científica

9054
06:07:30,320 --> 06:07:32,000
Tudo vai ser mostrado em

9055
06:07:32,000 --> 06:07:34,878
notação científica outra coisa que eu

9056
06:07:34,878 --> 06:07:37,520
Eu realmente quero que você esteja ciente é que

9057
06:07:37,520 --> 06:07:40,958
Não há uma maneira oficial de definir

9058
06:07:40,958 --> 06:07:41,760
O que é

9059
06:07:41,760 --> 06:07:45,600
saída de ponto flutuante para seus padrões

9060
06:07:45,600 --> 06:07:48,080
e aqui está um hack que eu realmente aprendi

9061
06:07:48,080 --> 06:07:50,558
sobre quando eu estava fazendo este curso o

9062
06:07:50,558 --> 06:07:52,798
A explicação disto está realmente fora de

9063
06:07:52,798 --> 06:07:55,680
espaço para este curso, mas apenas use isso

9064
06:07:55,680 --> 06:07:57,360
para definir

9065
06:07:57,360 --> 06:08:00,480
o formato de saída do ponto flutuante para o

9066
06:08:00,480 --> 06:08:02,160
padrões e se você fizer isso você está indo

9067
06:08:02,160 --> 06:08:04,080
para obter o que tínhamos

9068
06:08:04,080 --> 06:08:06,638
Aqui com os padrões que você vai

9069
06:08:06,638 --> 06:08:08,558
Veja que são as mesmas coisas na próxima

9070
06:08:08,558 --> 06:08:10,958
O que vamos olhar para é std set

9071
06:08:10,958 --> 06:08:13,360
precisão que já vimos antes e

9072
06:08:13,360 --> 06:08:16,160
Isso vai definir a precisão

9073
06:08:16,160 --> 06:08:18,558
com o qual os dados serão exibidos

9074
06:08:18,558 --> 06:08:20,958
no terminal se você usar uma precisão

9075
06:08:20,958 --> 06:08:23,120
de 10 que é o que você vai conseguir

9076
06:08:23,120 --> 06:08:26,000
Aqui você vê que temos um duplo

9077
06:08:26,000 --> 06:08:29,440
número é um número que tem muito

9078
06:08:29,440 --> 06:08:32,000
números após o ponto decimal se nós

9079
06:08:32,000 --> 06:08:33,760
mostre-o por padrão, ele vai aparecer

9080
06:08:33,760 --> 06:08:35,520
Como isso, a precisão vai ser

9081
06:08:35,520 --> 06:08:38,080
sexo podemos aumentar a precisão para 10

9082
06:08:38,080 --> 06:08:41,440
para 20 e 50 e vai aparecer

9083
06:08:41,440 --> 06:08:43,680
em qualquer precisão que você especifique

9084
06:08:43,680 --> 06:08:44,558
aqui

9085
06:08:44,558 --> 06:08:46,878
Saiba que essa precisão está indo

9086
06:08:46,878 --> 06:08:49,520
para ser limitado pelo tipo deste

9087
06:08:49,520 --> 06:08:50,558
a variável

9088
06:08:50,558 --> 06:08:52,878
se é um ponto flutuante a precisão

9089
06:08:52,878 --> 06:08:55,040
Vai ser algo como 7 que temos

9090
06:08:55,040 --> 06:08:57,040
visto que se é um duplo o

9091
06:08:57,040 --> 06:08:59,440
A precisão vai basicamente dobrar

9092
06:08:59,440 --> 06:09:02,480
para algo como 15 e se você tem um

9093
06:09:02,480 --> 06:09:04,958
O dobro da precisão vai ser

9094
06:09:04,958 --> 06:09:07,280
Algo maior que o dobro, mas

9095
06:09:07,280 --> 06:09:10,320
Não pode ir abaixo do dobro que temos

9096
06:09:10,320 --> 06:09:12,958
visto isso antes também temos um show point

9097
06:09:12,958 --> 06:09:15,040
que vai forçar

9098
06:09:15,040 --> 06:09:17,600
mostrando o ponto decimal para flutuar

9099
06:09:17,600 --> 06:09:21,440
valores de ponto que você vê aqui temos um 12.0

9100
06:09:21,440 --> 06:09:23,280
Este é o mais importante pedaço de dados

9101
06:09:23,280 --> 06:09:24,558
nós temos aqui

9102
06:09:24,558 --> 06:09:27,360
se não fizermos o ponto de exibição, isso está indo

9103
06:09:27,360 --> 06:09:31,280
para aparecer como 12 na saída aqui, mas

9104
06:09:31,280 --> 06:09:34,558
nós podemos usar o ponto de exibição para forçar o

9105
06:09:34,558 --> 06:09:36,798
ponto decimal a ser mostrado e você vê

9106
06:09:36,798 --> 06:09:37,638
que

9107
06:09:37,638 --> 06:09:41,760
12.00 aqui é mostrado outro efeito colateral

9108
06:09:41,760 --> 06:09:43,200
Isto é aquilo que

9109
06:09:43,200 --> 06:09:45,440
O ponto do show vai forçar a exibição

9110
06:09:45,440 --> 06:09:48,160
de trailing zeros e é o que vemos

9111
06:09:48,160 --> 06:09:51,360
aqui em d e f temos visto um monte de

9112
06:09:51,360 --> 06:09:53,520
Os manipuladores aqui é uma mesa que

9113
06:09:53,520 --> 06:09:55,680
Vou mostrar onde muitos deles estão

9114
06:09:55,680 --> 06:09:58,878
vai viver, então se você precisar usar

9115
06:09:58,878 --> 06:10:01,520
largura de conjunto, isso vai estar vivo

9116
06:10:01,520 --> 06:10:05,200
no i o manip header e aqui temos

9117
06:10:05,200 --> 06:10:07,760
alguns outros, então, se você quiser usar um

9118
06:10:07,760 --> 06:10:10,080
Algumas dessas coisas são estas

9119
06:10:10,080 --> 06:10:12,320
bibliotecas que você precisará incluir

9120
06:10:12,320 --> 06:10:14,878
com libra incluem como temos sido

9121
06:10:14,878 --> 06:10:17,520
incluindo i o stream e novamente o

9122
06:10:17,520 --> 06:10:19,920
A documentação para essas coisas é mostrada

9123
06:10:19,920 --> 06:10:20,600
A este.

9124
06:10:20,600 --> 06:10:23,520
cppreference.com este é o link exato

9125
06:10:23,520 --> 06:10:26,000
e você pode verificar isso se isso ajuda

9126
06:10:26,000 --> 06:10:26,958
para fora.

9127
06:10:26,958 --> 06:10:28,798
Agora que temos uma ideia sobre isso

9128
06:10:28,798 --> 06:10:30,638
Coisas que vamos entrar no visual

9129
06:10:30,638 --> 06:10:33,440
código de estúdio e realmente ver estes em

9130
06:10:33,440 --> 06:10:36,400
ação bem aqui estamos no estúdio visual

9131
06:10:36,400 --> 06:10:37,920
codificar o projeto que vamos ser

9132
06:10:37,920 --> 06:10:41,120
trabalhar aqui é formatação de saída, então

9133
06:10:41,120 --> 06:10:42,638
nós vamos ser

9134
06:10:42,638 --> 06:10:43,840
Agarrando

9135
06:10:43,840 --> 06:10:45,920
os nossos ficheiros de modelo

9136
06:10:45,920 --> 06:10:49,120
e coloque isso em nosso projeto aqui

9137
06:10:49,120 --> 06:10:51,280
e nós vamos subir de novo e abrir

9138
06:10:51,280 --> 06:10:53,440
até esta pasta no código do estúdio visual

9139
06:10:53,440 --> 06:10:55,200
Vamos fazer isso, vamos fechar o

9140
06:10:55,200 --> 06:10:57,520
tela de boas-vindas aqui e nós vamos

9141
06:10:57,520 --> 06:10:59,680
Remova o que quer que seja que não precisamos

9142
06:10:59,680 --> 06:11:01,520
nós vamos tirar isso

9143
06:11:01,520 --> 06:11:03,520
E vamos colocar no primeiro

9144
06:11:03,520 --> 06:11:05,920
código que queremos brincar e isso é

9145
06:11:05,920 --> 06:11:07,680


9146
06:11:07,680 --> 06:11:09,200
Você realmente não precisa de um monte de

9147
06:11:09,200 --> 06:11:11,360
explicações para isso porque nós usamos

9148
06:11:11,360 --> 06:11:13,120
Isso o tempo todo

9149
06:11:13,120 --> 06:11:14,718
se você não colocá-lo para fora os dados é

9150
06:11:14,718 --> 06:11:17,040
indo aparecer em uma linha e uh

9151
06:11:17,040 --> 06:11:19,280
você vai ter olá mundo em um

9152
06:11:19,280 --> 06:11:20,160
linha de linha

9153
06:11:20,160 --> 06:11:23,120
Se colocarmos stdndl assim, vamos

9154
06:11:23,120 --> 06:11:25,040
para que os dados apareçam em diferentes

9155
06:11:25,040 --> 06:11:27,040
linhas, então vamos ter olá e

9156
06:11:27,040 --> 06:11:29,760
mundo em diferentes linhas e é

9157
06:11:29,760 --> 06:11:33,120
Possível usar uma barra de fundo n para alcançar

9158
06:11:33,120 --> 06:11:35,920
A mesma coisa, mas estes funcionam muito

9159
06:11:35,920 --> 06:11:38,558
Diferentemente subterrâneo e nós não

9160
06:11:38,558 --> 06:11:40,400
ter ferramentas suficientes para realmente entender

9161
06:11:40,400 --> 06:11:43,440
A diferença, então por enquanto basta tomar isso

9162
06:11:43,440 --> 06:11:45,920
como a verdade e eu sei que há

9163
06:11:45,920 --> 06:11:48,480
Diferenças e a coisa mais importante

9164
06:11:48,480 --> 06:11:50,878
É que você reconhece essas coisas se

9165
06:11:50,878 --> 06:11:53,760
Você os vê em código lá fora, nós somos

9166
06:11:53,760 --> 06:11:56,718
vamos trazer a nossa terminologia e construir

9167
06:11:56,718 --> 06:11:59,280
Isso com nossa tarefa que vai

9168
06:11:59,280 --> 06:12:01,040
construção com gcc

9169
06:12:01,040 --> 06:12:02,400
Você vai ver que o mundo é

9170
06:12:02,400 --> 06:12:04,000
indo para ir através

9171
06:12:04,000 --> 06:12:06,638
e que podemos fazer o nosso galo

9172
06:12:06,638 --> 06:12:09,840
binário para ver a saída que você vê que nós

9173
06:12:09,840 --> 06:12:12,480
ter o hello mundo em uma linha

9174
06:12:12,480 --> 06:12:14,958
Temos olá e o mundo em diferentes

9175
06:12:14,958 --> 06:12:17,120
linhas e isso é resultado disso

9176
06:12:17,120 --> 06:12:19,558
eventos que temos aqui você vê que temos

9177
06:12:19,558 --> 06:12:22,400
stdndl isso vai forçar

9178
06:12:22,400 --> 06:12:24,638
o terminal para ir para a próxima linha e

9179
06:12:24,638 --> 06:12:26,878
mundo impresso e depois disso estamos indo

9180
06:12:26,878 --> 06:12:29,200
para forçar o terminal a ir para o próximo

9181
06:12:29,200 --> 06:12:31,680
linha e é aí que o próximo texto é

9182
06:12:31,680 --> 06:12:34,080
vamos aparecer depois que temos

9183
06:12:34,080 --> 06:12:36,320
Olá e mundo aqui em baixo no

9184
06:12:36,320 --> 06:12:39,760
terminal e é a saída gerada

9185
06:12:39,760 --> 06:12:42,400
pelas declarações que temos aqui

9186
06:12:42,400 --> 06:12:44,480
e você pode ver que vai

9187
06:12:44,480 --> 06:12:47,680
basicamente fazer a mesma coisa que stdendl

9188
06:12:47,680 --> 06:12:50,240
Mas novamente eles trabalham de forma muito diferente

9189
06:12:50,240 --> 06:12:52,878
sob o capô ok, então isso é realmente

9190
06:12:52,878 --> 06:12:56,718
Como std endl funciona e você tem acesso a

9191
06:12:56,718 --> 06:12:59,520
incluindo o i o stream

9192
06:12:59,520 --> 06:13:01,520
Biblioteca aqui a próxima coisa que estamos indo

9193
06:13:01,520 --> 06:13:04,320
para brincar com é std flash

9194
06:13:04,320 --> 06:13:07,600
isso vai piscar o buffer de saída

9195
06:13:07,600 --> 06:13:09,760
ao seu destino final e isso é

9196
06:13:09,760 --> 06:13:10,878
Vou ser

9197
06:13:10,878 --> 06:13:13,920
O terminal neste caso e se adicionarmos

9198
06:13:13,920 --> 06:13:16,160
Isso para o nosso

9199
06:13:16,160 --> 06:13:18,798
declaração de stdcl como esta

9200
06:13:18,798 --> 06:13:22,080
Isso será enviado diretamente para o

9201
06:13:22,080 --> 06:13:24,480
terminal e isso pode ser útil em

9202
06:13:24,480 --> 06:13:27,120
Algumas aplicações se executarmos isso, estamos

9203
06:13:27,120 --> 06:13:30,000
Não vai realmente ver uma diferença, mas

9204
06:13:30,000 --> 06:13:32,718
No subsolo sob o capô, os dados são

9205
06:13:32,718 --> 06:13:35,120
enviado diretamente para o terminal e tivemos

9206
06:13:35,120 --> 06:13:37,280
A chance de explicar isso nos slides

9207
06:13:37,280 --> 06:13:40,638
Anteriormente podemos trabalhar este programa e eu

9208
06:13:40,638 --> 06:13:43,120
vê-lo correndo o mundo vai ir

9209
06:13:43,120 --> 06:13:45,200
através de se corrermos o galo, estamos

9210
06:13:45,200 --> 06:13:47,200
Vou ver que esta é uma boa mensagem

9211
06:13:47,200 --> 06:13:48,480
é enviado

9212
06:13:48,480 --> 06:13:50,638
para o terminal a próxima coisa que somos

9213
06:13:50,638 --> 06:13:52,878
Ir olhar para é definido com eu estou indo

9214
06:13:52,878 --> 06:13:54,958
para colocar o código aqui porque eu não

9215
06:13:54,958 --> 06:13:57,840
Quero digitar tudo isso e novamente você pode

9216
06:13:57,840 --> 06:14:00,240
obter o código fonte para isso

9217
06:14:00,240 --> 06:14:03,280
na seção de resultados desta palestra

9218
06:14:03,280 --> 06:14:04,958
Você realmente não tem que digitar tudo isso

9219
06:14:04,958 --> 06:14:06,878
As coisas mais importantes é que

9220
06:14:06,878 --> 06:14:09,280
Você realmente entende como eles funcionam bem

9221
06:14:09,280 --> 06:14:11,840
Você vê aqui que vamos usar o set

9222
06:14:11,840 --> 06:14:14,480
com mas nós realmente não incluímos o

9223
06:14:14,480 --> 06:14:16,958
Biblioteca que nos dará acesso

9224
06:14:16,958 --> 06:14:18,638
para isso e se você não sabe qual

9225
06:14:18,638 --> 06:14:20,718
Biblioteca que você precisará incluir para obter

9226
06:14:20,718 --> 06:14:22,718
acesso a este poço você pode verificar o

9227
06:14:22,718 --> 06:14:25,680
documentação e para ter acesso ao

9228
06:14:25,680 --> 06:14:28,000
documentação que você pode querer consultar

9229
06:14:28,000 --> 06:14:30,480
seu motor de busca favorito eu estou indo

9230
06:14:30,480 --> 06:14:34,718
para ir no google aqui e digitar std

9231
06:14:34,718 --> 06:14:38,558
set w e eu vou procurar e isso

9232
06:14:38,558 --> 06:14:40,480
vai chegar a algumas entradas i

9233
06:14:40,480 --> 06:14:42,520
Vou clicar sobre o de

9234
06:14:42,520 --> 06:14:44,798
cppreference.com porque isso é

9235
06:14:44,798 --> 06:14:47,920
confiável na minha opinião e se abrirmos

9236
06:14:47,920 --> 06:14:49,840
Isso vamos ver isso para trabalhar

9237
06:14:49,840 --> 06:14:52,958
conosco você precisa incluir i o minha rede

9238
06:14:52,958 --> 06:14:55,360
Então é isso que precisamos colocar em visual

9239
06:14:55,360 --> 06:14:57,840
Código de estúdio para se livrar deste problema

9240
06:14:57,840 --> 06:15:00,638
Vamos fazer isso que eu realmente queria que você visse

9241
06:15:00,638 --> 06:15:02,878
Este processo pelo qual você pode passar

9242
06:15:02,878 --> 06:15:05,520
para saber o que você precisa incluir, somos

9243
06:15:05,520 --> 06:15:07,760
indo para colocar isso e espero que o

9244
06:15:07,760 --> 06:15:10,240
A seta vai embora e nós podemos

9245
06:15:10,240 --> 06:15:13,200
Concentre-se em estudar os efeitos destes

9246
06:15:13,200 --> 06:15:15,600
As coisas aqui vão imprimir e

9247
06:15:15,600 --> 06:15:17,680
formatados para que os dados sejam

9248
06:15:17,680 --> 06:15:20,638
Cropped perto um do outro, mas nós podemos

9249
06:15:20,638 --> 06:15:23,840
formatar isso usando a largura definida e se nós

9250
06:15:23,840 --> 06:15:25,760
Passe em um 10 aqui estamos basicamente

9251
06:15:25,760 --> 06:15:28,958
Dizer sobrenome vai levar o

9252
06:15:28,958 --> 06:15:31,920
largura de 10 caracteres mesmo se não o fizermos

9253
06:15:31,920 --> 06:15:34,480
realmente tem 10 personagens nisso, então

9254
06:15:34,480 --> 06:15:36,798
Você vai ter espaços preenchendo o

9255
06:15:36,798 --> 06:15:39,760
espaços restantes para que os dados apresentem

9256
06:15:39,760 --> 06:15:42,558
bem isso é realmente difícil de dizer em

9257
06:15:42,558 --> 06:15:44,480
mundo assim eu vou correr isso em um

9258
06:15:44,480 --> 06:15:46,400
Minuto para que você possa ver isso, mas

9259
06:15:46,400 --> 06:15:48,798
Antes de correr, eu quero que você veja que você

9260
06:15:48,798 --> 06:15:51,440
também pode armazenar as informações de largura em

9261
06:15:51,440 --> 06:15:53,920
uma variável como esta e eu uso que

9262
06:15:53,920 --> 06:15:56,638
em seu std declarações de

9263
06:15:56,638 --> 06:15:59,360
benefício com isso é que é realmente

9264
06:15:59,360 --> 06:16:01,920
É fácil mudar isso se você acontecer

9265
06:16:01,920 --> 06:16:04,480
para mudar sua mente caso contrário você

9266
06:16:04,480 --> 06:16:06,718
Tenho que mudar muitas coisas e isso

9267
06:16:06,718 --> 06:16:08,958
é realmente mau design que eu fiz isso para mostrar

9268
06:16:08,958 --> 06:16:11,360
Como você pode usar isso, mas em verdade

9269
06:16:11,360 --> 06:16:14,000
código que você provavelmente vai

9270
06:16:14,000 --> 06:16:14,958
loja

9271
06:16:14,958 --> 06:16:17,600
suas informações de weft em uma variável e

9272
06:16:17,600 --> 06:16:20,080
Dessa forma, vai ser realmente fácil

9273
06:16:20,080 --> 06:16:22,718
Alterar e atualizar se você precisar

9274
06:16:22,718 --> 06:16:26,638
que podemos construir este programa com gcc

9275
06:16:26,638 --> 06:16:28,958
E se corrermos, vamos trazer isso para cima

9276
06:16:28,958 --> 06:16:30,798
Um pouco vamos ter nossos dados

9277
06:16:30,798 --> 06:16:32,718
que não é formatado e você vê que

9278
06:16:32,718 --> 06:16:35,600
é realmente feio, mas lá embaixo aqui nós

9279
06:16:35,600 --> 06:16:38,080
ter nossa tabela formatada e é

9280
06:16:38,080 --> 06:16:40,320
Realmente bom temos sobrenome primeiro nome

9281
06:16:40,320 --> 06:16:43,200
e idade e é mais fácil ver estes

9282
06:16:43,200 --> 06:16:45,360
coisas que vamos ver que é

9283
06:16:45,360 --> 06:16:46,718
Possível para

9284
06:16:46,718 --> 06:16:49,120
forçar os dados a mostrar à esquerda ou

9285
06:16:49,120 --> 06:16:51,440
O direito com justificação e nós somos

9286
06:16:51,440 --> 06:16:53,920
Vou olhar para o código que faz isso

9287
06:16:53,920 --> 06:16:55,040
Em seguida

9288
06:16:55,040 --> 06:16:57,200
Se descermos aqui e colocarmos no próximo

9289
06:16:57,200 --> 06:16:59,360
pedaço de código que queremos brincar com

9290
06:16:59,360 --> 06:17:01,680
ver que os dados estão certos

9291
06:17:01,680 --> 06:17:03,840
justificado por padrão, mas vimos

9292
06:17:03,840 --> 06:17:06,480
Isso também você vê que o cinza é apertado

9293
06:17:06,480 --> 06:17:08,718
à direita da largura da célula

9294
06:17:08,718 --> 06:17:10,798
para o primeiro nome para que os dados estejam certos

9295
06:17:10,798 --> 06:17:13,200
justificado por padrão e é o mesmo

9296
06:17:13,200 --> 06:17:14,000
aqui

9297
06:17:14,000 --> 06:17:15,040
Se nós

9298
06:17:15,040 --> 06:17:18,080
Mudar a largura do nosso

9299
06:17:18,080 --> 06:17:20,798
dados aqui e tentando correr, estamos indo

9300
06:17:20,798 --> 06:17:23,280
para ter uma melhor visualização disso

9301
06:17:23,280 --> 06:17:25,200
então vamos correr um pouco que vamos

9302
06:17:25,200 --> 06:17:27,200
Construa o mundo vai passar

9303
06:17:27,200 --> 06:17:29,360
E se nós executarmos isso nós vamos ver

9304
06:17:29,360 --> 06:17:31,440
que os dados vão aparecer para o

9305
06:17:31,440 --> 06:17:33,920
cinza direito é para a floresta certa é para

9306
06:17:33,920 --> 06:17:36,240
o direito e este é o padrão

9307
06:17:36,240 --> 06:17:38,160
Justificação que você recebe

9308
06:17:38,160 --> 06:17:40,878
Quando você definir assim você também pode

9309
06:17:40,878 --> 06:17:43,680
Causa para que os dados sejam deixados justificados

9310
06:17:43,680 --> 06:17:47,120
e você faz isso vindo aqui e

9311
06:17:47,120 --> 06:17:49,840
mudando isso para a esquerda, você pode fazer aquilo

9312
06:17:49,840 --> 06:17:52,878
mas vamos manter isso aqui em vez disso

9313
06:17:52,878 --> 06:17:55,120
para sua referência e vamos colocar em

9314
06:17:55,120 --> 06:17:57,120
Outro código para justificar o

9315
06:17:57,120 --> 06:18:00,160
dados para a esquerda OK vamos para baixo e

9316
06:18:00,160 --> 06:18:02,558
para que possamos justificar os dados

9317
06:18:02,558 --> 06:18:05,760
para a esquerda e se imprimirmos isso para fora

9318
06:18:05,760 --> 06:18:08,320
dados aqui cinza deve vir para a esquerda

9319
06:18:08,320 --> 06:18:10,798
e estar alinhado com o primeiro nome aqui

9320
06:18:10,798 --> 06:18:12,480
Espero que isso faça sentido, vamos fazer

9321
06:18:12,480 --> 06:18:16,160
executar nós construímos com gcc e se nós corremos

9322
06:18:16,160 --> 06:18:19,760
O galo cinza vai ser justificado para

9323
06:18:19,760 --> 06:18:23,360
A esquerda este é o significado de std esquerda

9324
06:18:23,360 --> 06:18:26,638
e std certo que nós apenas vimos e sabemos

9325
06:18:26,638 --> 06:18:29,280
que os dados são justificados ao direito por

9326
06:18:29,280 --> 06:18:31,840
padrão e é importante manter o

9327
06:18:31,840 --> 06:18:33,680
padrões em sua mente

9328
06:18:33,680 --> 06:18:35,920
Os dados serão justificados para o

9329
06:18:35,920 --> 06:18:38,480
corretamente por padrão a próxima coisa que podemos

9330
06:18:38,480 --> 06:18:41,440
fazer nossos dados internos

9331
06:18:41,440 --> 06:18:43,920
Justificado e o que isso vai fazer

9332
06:18:43,920 --> 06:18:47,120
faz com que o sinal seja justificado e o

9333
06:18:47,120 --> 06:18:50,000
Os dados serão justificados e

9334
06:18:50,000 --> 06:18:52,000
A melhor maneira de salvar isso é realmente para

9335
06:18:52,000 --> 06:18:53,520
Veja um exemplo

9336
06:18:53,520 --> 06:18:55,920
Então aqui temos os dados de que é negativo

9337
06:18:55,920 --> 06:18:58,638
número do ponto flutuante que a largura é definida

9338
06:18:58,638 --> 06:19:01,440
Para 10 vai ser certo justificado

9339
06:19:01,440 --> 06:19:03,760
mas também vamos definir o

9340
06:19:03,760 --> 06:19:06,400
justificação para interno e ver o

9341
06:19:06,400 --> 06:19:07,440
A diferença

9342
06:19:07,440 --> 06:19:09,840
Vamos soldar e correr isso nós vamos

9343
06:19:09,840 --> 06:19:12,558
mundo com gcc e vamos correr

9344
06:19:12,558 --> 06:19:15,600
nosso programa de galo e se olharmos para

9345
06:19:15,600 --> 06:19:18,798
A saída aqui você vê que se tivermos

9346
06:19:18,798 --> 06:19:20,798
Justificação correta

9347
06:19:20,798 --> 06:19:23,680
O sinal vai com os dados

9348
06:19:23,680 --> 06:19:27,280
Considerando que se fazemos justificação interna

9349
06:19:27,280 --> 06:19:29,040
O sinal vai para a esquerda e

9350
06:19:29,040 --> 06:19:31,680
Os dados vão para a direita e

9351
06:19:31,680 --> 06:19:34,240
às vezes isso é útil dependendo

9352
06:19:34,240 --> 06:19:36,080
O aplicativo que você está soldado

9353
06:19:36,080 --> 06:19:38,718
Principalmente em aplicações onde você

9354
06:19:38,718 --> 06:19:41,840
tem que exibir dados tabulares no

9355
06:19:41,840 --> 06:19:44,400
console ou do terminal nós também podemos

9356
06:19:44,400 --> 06:19:47,280
especificar o caractere de campo usando o conjunto

9357
06:19:47,280 --> 06:19:48,320
o campo

9358
06:19:48,320 --> 06:19:50,958
E é assim que funciona os dados

9359
06:19:50,958 --> 06:19:53,360
Será justificado, mas nós somos

9360
06:19:53,360 --> 06:19:55,040
indo para encher o vazio

9361
06:19:55,040 --> 06:19:58,878
espaços com um traço aqui e podemos trazer

9362
06:19:58,878 --> 06:20:01,120
Isso para que você veja a coisa toda

9363
06:20:01,120 --> 06:20:02,798
Mas você realmente não tem que digitar isso

9364
06:20:02,798 --> 06:20:05,360
Você pode usar o código que eu forneci

9365
06:20:05,360 --> 06:20:08,240
na seção de recursos desta palestra

9366
06:20:08,240 --> 06:20:10,638
Você pode copiá-lo colando aqui

9367
06:20:10,638 --> 06:20:12,798
e usá-lo para brincar com essas coisas

9368
06:20:12,798 --> 06:20:15,280
Tudo bem com isso nossos espaços vazios são

9369
06:20:15,280 --> 06:20:18,080
Vai ser preenchido com este traço

9370
06:20:18,080 --> 06:20:19,200
personagem

9371
06:20:19,200 --> 06:20:22,958
Vamos ao mundo e construir com gcc nós somos

9372
06:20:22,958 --> 06:20:24,878
indo para executar isso e você está indo para

9373
06:20:24,878 --> 06:20:27,360
Veja que temos um personagem de campo aqui

9374
06:20:27,360 --> 06:20:29,200
e você pode mudar isso basicamente para

9375
06:20:29,200 --> 06:20:31,520
O que você quiser, se eu quiser, eu posso mudar

9376
06:20:31,520 --> 06:20:34,798
Isso para uma estrela vamos fazer aquilo e eu posso

9377
06:20:34,798 --> 06:20:37,280
construir novamente se eu executar isso, ele vai

9378
06:20:37,280 --> 06:20:39,360
ser preenchido com estrelas agora no próximo

9379
06:20:39,360 --> 06:20:41,920
O que vamos olhar para é std bull

9380
06:20:41,920 --> 06:20:44,958
Alpha já vimos isso antes, mas o que

9381
06:20:44,958 --> 06:20:46,958
Isso realmente vai fazer é forçar o

9382
06:20:46,958 --> 06:20:49,680
saída para estar no formato do verdadeiro e

9383
06:20:49,680 --> 06:20:50,558
Falso

9384
06:20:50,558 --> 06:20:52,958
e o padrão está na forma de um

9385
06:20:52,958 --> 06:20:56,478
E zero aqui temos algumas variáveis

9386
06:20:56,478 --> 06:20:59,120
e que são do tipo de touro

9387
06:20:59,120 --> 06:21:02,478
O primeiro conjunto de declarações stdcl aqui

9388
06:21:02,478 --> 06:21:04,400
vai imprimir no formato de um

9389
06:21:04,400 --> 06:21:07,360
e zero nós vamos definir a saída

9390
06:21:07,360 --> 06:21:09,360
para alfa e vai estar em

9391
06:21:09,360 --> 06:21:12,320
o formato do verdadeiro e falso e então nós

9392
06:21:12,320 --> 06:21:14,958
pode desativar o touro alfa com isso

9393
06:21:14,958 --> 06:21:18,400
configuração aqui que diz hdd no pull

9394
06:21:18,400 --> 06:21:21,760
alfa, podemos votar e ver o

9395
06:21:21,760 --> 06:21:24,320
Efeito disso para que vamos correr

9396
06:21:24,320 --> 06:21:26,320
galo novamente e você vai ver

9397
06:21:26,320 --> 06:21:29,440
Que condição 1 0 condição true false

9398
06:21:29,440 --> 06:21:33,040
condição 1 0 somos capazes de modificar como

9399
06:21:33,040 --> 06:21:36,080
nossos dados booleanos são exibidos no

9400
06:21:36,080 --> 06:21:39,280
console usando essas duas configurações aqui

9401
06:21:39,280 --> 06:21:41,760
usá-los se eles fazem sentido para o seu

9402
06:21:41,760 --> 06:21:43,440
Aplicação a próxima coisa que vamos

9403
06:21:43,440 --> 06:21:46,080
olhar para é show pose e nós estamos indo

9404
06:21:46,080 --> 06:21:48,080
para apenas colocar os dados

9405
06:21:48,080 --> 06:21:50,558
Temos dois números positivos

9406
06:21:50,558 --> 06:21:52,718
que é 34 um número negativo que é

9407
06:21:52,718 --> 06:21:56,240
menos 45 e podemos decidir se queremos

9408
06:21:56,240 --> 06:21:57,280
show

9409
06:21:57,280 --> 06:22:00,240
o sinal de mais para números positivos por

9410
06:22:00,240 --> 06:22:02,400
padrão o sinal de mais vai ser

9411
06:22:02,400 --> 06:22:04,718
escondido, não vai ser mostrado se você

9412
06:22:04,718 --> 06:22:07,840
Você pode usar a pose do show

9413
06:22:07,840 --> 06:22:10,798
manipulador e se você quiser desativar

9414
06:22:10,798 --> 06:22:13,680
que quando foi ativado você pode usar não

9415
06:22:13,680 --> 06:22:15,600
mostrar pose e isso vai fazer o que

9416
06:22:15,600 --> 06:22:19,040
você quer que possamos construir isso novamente e se

9417
06:22:19,040 --> 06:22:20,958
nós olhamos para a saída que vamos ver

9418
06:22:20,958 --> 06:22:23,360
que post número não tem um sinal de mais

9419
06:22:23,360 --> 06:22:26,160
na frente porque por padrão o show

9420
06:22:26,160 --> 06:22:29,920
A pausa está desativada e nós definimos a configuração

9421
06:22:29,920 --> 06:22:31,920
aqui e nós vamos ver a vantagem

9422
06:22:31,920 --> 06:22:34,798
Assine e se desativarmos isso, não somos

9423
06:22:34,798 --> 06:22:36,718
Vou ver o sinal de mais novamente este é

9424
06:22:36,718 --> 06:22:39,840
o efeito de std mostrar postes e std

9425
06:22:39,840 --> 06:22:42,878
Manipuladores de pose neutras nós também podemos

9426
06:22:42,878 --> 06:22:45,520
afetar a base em que os dados são

9427
06:22:45,520 --> 06:22:48,080
exibido no terminal e fazemos isso

9428
06:22:48,080 --> 06:22:51,280
definindo o sistema de base de saída

9429
06:22:51,280 --> 06:22:55,440
nós podemos definir std deck para forçar a saída

9430
06:22:55,440 --> 06:22:56,878
em decimal

9431
06:22:56,878 --> 06:22:59,360
std hex para forçar a saída a ser em

9432
06:22:59,360 --> 06:23:02,638
hexadecimal e std age para forçar o

9433
06:23:02,638 --> 06:23:06,798
saída em octal e isso é apenas para tomar

9434
06:23:06,798 --> 06:23:09,520
efeito para tipos integrais este não é

9435
06:23:09,520 --> 06:23:12,240
vai ter efeito para o ponto flutuante

9436
06:23:12,240 --> 06:23:14,160
números, por exemplo, aqui temos alguns

9437
06:23:14,160 --> 06:23:16,240
variáveis um inteiro positivo e

9438
06:23:16,240 --> 06:23:18,958
inteiro negativo e um ponto flutuante

9439
06:23:18,958 --> 06:23:20,878
O número que é o duplo

9440
06:23:20,878 --> 06:23:22,958
e nós vamos tentar imprimir estes

9441
06:23:22,958 --> 06:23:26,320
coisas em todos esses sistemas básicos que somos

9442
06:23:26,320 --> 06:23:27,360
Indo para dentro de nós.

9443
06:23:27,360 --> 06:23:29,440
Imprimindo essas coisas no formato padrão

9444
06:23:29,440 --> 06:23:31,280
nós vamos ver como eles olham nós somos

9445
06:23:31,280 --> 06:23:33,040
Vou tomar o número positivo e

9446
06:23:33,040 --> 06:23:36,000
Mostrar isso neste número diferente

9447
06:23:36,000 --> 06:23:37,680
sistemas que vamos fazer o mesmo para

9448
06:23:37,680 --> 06:23:39,600
O número negativo e nós vamos

9449
06:23:39,600 --> 06:23:40,798
- Mostrar que

9450
06:23:40,798 --> 06:23:43,760
Isso não tem efeito sobre a flutuação

9451
06:23:43,760 --> 06:23:46,718
números de pontos, porque este número

9452
06:23:46,718 --> 06:23:48,878
Os sistemas realmente não funcionam para flutuar

9453
06:23:48,878 --> 06:23:52,240
pontos que podemos executar isso e ver o

9454
06:23:52,240 --> 06:23:54,798
saída, vamos executar a tarefa que

9455
06:23:54,798 --> 06:23:57,360
vai construir com gcc e nós somos

9456
06:23:57,360 --> 06:24:00,240
indo para limpar e correr galo e o que

9457
06:24:00,240 --> 06:24:03,040
Vamos ver que por padrão

9458
06:24:03,040 --> 06:24:04,798
O número positivo vai ser isso

9459
06:24:04,798 --> 06:24:06,878
O número negativo vai ser isso e

9460
06:24:06,878 --> 06:24:09,200
Nosso duplo var vai ser isso e

9461
06:24:09,200 --> 06:24:10,958
Vamos levar o número positivo

9462
06:24:10,958 --> 06:24:13,120
mostrá-lo em diferentes sistemas de base em

9463
06:24:13,120 --> 06:24:15,200
decimal vai ser assim em

9464
06:24:15,200 --> 06:24:18,000
hex, vai ser assim em ato

9465
06:24:18,000 --> 06:24:20,638
Vai ser assim o negativo

9466
06:24:20,638 --> 06:24:22,638
O número também vai ser

9467
06:24:22,638 --> 06:24:25,120
neste formato aqui, então se mostrarmos em

9468
06:24:25,120 --> 06:24:27,680
decimal vai ser como este hex

9469
06:24:27,680 --> 06:24:29,920
Vai ser assim e o octo é

9470
06:24:29,920 --> 06:24:32,638
Vai ser assim você pode ver que

9471
06:24:32,638 --> 06:24:35,280
o duplo var que é um ponto flutuante

9472
06:24:35,280 --> 06:24:37,040
Não é realmente afetado, vai ser

9473
06:24:37,040 --> 06:24:39,840
mostrando no mesmo formato, independentemente de

9474
06:24:39,840 --> 06:24:42,160
A base que nós estabelecemos aqui uma coisa você

9475
06:24:42,160 --> 06:24:44,798
deveria saber que esta configuração de base

9476
06:24:44,798 --> 06:24:47,280
Aqui vai ficar tão aqui para

9477
06:24:47,280 --> 06:24:49,920
O exemplo você vê que nós definimos saída

9478
06:24:49,920 --> 06:24:51,200
em outubro

9479
06:24:51,200 --> 06:24:53,280
Então, qualquer outra coisa que nós vamos

9480
06:24:53,280 --> 06:24:56,638
print out vai ser mostrado em outubro

9481
06:24:56,638 --> 06:24:58,798
e temos que ter certeza de que é isso que nós

9482
06:24:58,798 --> 06:25:00,958
Se isso não é o que queremos, vamos

9483
06:25:00,958 --> 06:25:02,400
Você tem que redefinir

9484
06:25:02,400 --> 06:25:03,760
A saída

9485
06:25:03,760 --> 06:25:06,000
sistema de números e vai demorar

9486
06:25:06,000 --> 06:25:08,000
Isso é como você pode usar estes

9487
06:25:08,000 --> 06:25:09,520
Coisas a afectar

9488
06:25:09,520 --> 06:25:12,160
diferentes sistemas de números para saída em

9489
06:25:12,160 --> 06:25:14,878
seu terminal, vimos que você pode

9490
06:25:14,878 --> 06:25:17,040
Além disso, forçar as coisas a aparecer

9491
06:25:17,040 --> 06:25:19,520
submero se isso é importante para o seu

9492
06:25:19,520 --> 06:25:21,680
Aplicação, por exemplo, aqui temos a

9493
06:25:21,680 --> 06:25:24,478
número positivo se mostrarmos isso em hex

9494
06:25:24,478 --> 06:25:26,000
Isto vai conter alguns

9495
06:25:26,000 --> 06:25:27,200
Personagens

9496
06:25:27,200 --> 06:25:30,478
e se não definirmos maiúsculas

9497
06:25:30,478 --> 06:25:32,718
vai aparecer em minúsculas e

9498
06:25:32,718 --> 06:25:34,878
se nós o queremos em maiúsculas podemos definir

9499
06:25:34,878 --> 06:25:37,040
Este cenário e vai aparecer

9500
06:25:37,040 --> 06:25:40,080
em maiúsculas isso pode ser útil em alguns

9501
06:25:40,080 --> 06:25:42,320
Aplicações e eu só quero que você seja

9502
06:25:42,320 --> 06:25:44,718
Conscientes dessas coisas para as quais vamos

9503
06:25:44,718 --> 06:25:48,638
mundo e executar a nossa aplicação

9504
06:25:48,638 --> 06:25:50,240
nós vamos ver isso

9505
06:25:50,240 --> 06:25:52,080
Vamos trazer isso um pouco para que

9506
06:25:52,080 --> 06:25:55,520
temos algum espaço para respirar nosso positivo

9507
06:25:55,520 --> 06:25:57,600
O inteiro aqui vai aparecer em

9508
06:25:57,600 --> 06:26:00,718
minúsculo aqui em hex porque isto é

9509
06:26:00,718 --> 06:26:03,360
vou conter personagens e se nós

9510
06:26:03,360 --> 06:26:05,360
set maiúsculo você vai ver isso

9511
06:26:05,360 --> 06:26:08,160
Os personagens vão aparecer em

9512
06:26:08,160 --> 06:26:11,200
em maiúsculas e este é o efeito deste

9513
06:26:11,200 --> 06:26:13,680
Estar aqui também podemos afetar como

9514
06:26:13,680 --> 06:26:15,600
dados do ponto flutuante

9515
06:26:15,600 --> 06:26:19,040
é impresso no terminal

9516
06:26:19,040 --> 06:26:21,600
por exemplo, aqui temos algumas variáveis

9517
06:26:21,600 --> 06:26:23,280
a b e c

9518
06:26:23,280 --> 06:26:25,760
e por padrão eles vão aparecer

9519
06:26:25,760 --> 06:26:28,558
com pontos decimais e uso científico

9520
06:26:28,558 --> 06:26:31,760
notação quando necessário, mas nós podemos

9521
06:26:31,760 --> 06:26:33,440
Escolha para usar

9522
06:26:33,440 --> 06:26:35,920
corrigido, por exemplo, se é isso que precisamos

9523
06:26:35,920 --> 06:26:39,040
em nossa aplicação e a saída é

9524
06:26:39,040 --> 06:26:41,680
será mostrado usando notação fixa

9525
06:26:41,680 --> 06:26:44,080
com pontos decimais, se quisermos, podemos

9526
06:26:44,080 --> 06:26:46,478
forçar o formato científico e nós fazemos isso

9527
06:26:46,478 --> 06:26:49,440
Assim e toda a produção será

9528
06:26:49,440 --> 06:26:52,320
em formato científico e podemos desativar

9529
06:26:52,320 --> 06:26:54,798
todas essas configurações e redefinir isso para o

9530
06:26:54,798 --> 06:26:56,080
os padrões

9531
06:26:56,080 --> 06:26:59,440
com esta peça de comando aqui está

9532
06:26:59,440 --> 06:27:01,440
Não há caminho oficial para

9533
06:27:01,440 --> 06:27:04,558
definir saída de ponto flutuante para o

9534
06:27:04,558 --> 06:27:07,600
padrões e este é um hack i na verdade

9535
06:27:07,600 --> 06:27:09,760
Aprendi sobre quando eu estava preparando o

9536
06:27:09,760 --> 06:27:12,558
código para este curso e o bom

9537
06:27:12,558 --> 06:27:15,280
As explicações para isso estão realmente fora de

9538
06:27:15,280 --> 06:27:17,760
escopo para este curso, portanto, se você quiser

9539
06:27:17,760 --> 06:27:20,718
Redefinir o formato de saída de ponto flutuante

9540
06:27:20,718 --> 06:27:23,600
para o padrão que você vai usar isso

9541
06:27:23,600 --> 06:27:25,840
Mas nós realmente não temos ferramentas suficientes para

9542
06:27:25,840 --> 06:27:29,200
Entenda isso ainda, então tome-o

9543
06:27:29,200 --> 06:27:31,520
Fé e você vai ver isso se nós

9544
06:27:31,520 --> 06:27:33,600
executar isso que vai funcionar vamos tentar

9545
06:27:33,600 --> 06:27:36,320
e executar isso através do compilador e

9546
06:27:36,320 --> 06:27:38,400
que o mundo vai passar se

9547
06:27:38,400 --> 06:27:40,638
nós corremos isso e eu trago isso um pouco

9548
06:27:40,638 --> 06:27:43,120
Um pouco para que tenhamos um pouco de

9549
06:27:43,120 --> 06:27:45,040
sala de respiração, vamos ver isso

9550
06:27:45,040 --> 06:27:48,478
nossos valores duplos são um b e c e

9551
06:27:48,478 --> 06:27:51,440
Isso é o que temos em nosso código aqui e

9552
06:27:51,440 --> 06:27:53,200
por padrão, não será capaz de

9553
06:27:53,200 --> 06:27:55,200
mostrar essas coisas por causa do

9554
06:27:55,200 --> 06:27:57,920
limites de precisão para que tenhamos

9555
06:27:57,920 --> 06:28:00,320
3.14159

9556
06:28:00,320 --> 06:28:02,478
Vai subir até aqui e ao resto

9557
06:28:02,478 --> 06:28:04,878
vai ser cortado se usarmos

9558
06:28:04,878 --> 06:28:07,120
formatos fixos que você vai ver isso

9559
06:28:07,120 --> 06:28:10,240
O que tivermos em formato científico

9560
06:28:10,240 --> 06:28:13,200
vai aparecer em formato fixo

9561
06:28:13,200 --> 06:28:15,600
e novamente este é um número muito baixo

9562
06:28:15,600 --> 06:28:18,478
É por isso que temos 0,000

9563
06:28:18,478 --> 06:28:19,440
aqui

9564
06:28:19,440 --> 06:28:22,160
nós podemos forçar a produção a ser científica

9565
06:28:22,160 --> 06:28:23,840
Como nós fizemos

9566
06:28:23,840 --> 06:28:25,360
Aqui mesmo

9567
06:28:25,360 --> 06:28:27,680
e toda a saída vai estar em

9568
06:28:27,680 --> 06:28:29,440
o formato científico

9569
06:28:29,440 --> 06:28:32,080
Abaixo aqui nós usamos o nosso hack para definir

9570
06:28:32,080 --> 06:28:33,120
A sua forma de

9571
06:28:33,120 --> 06:28:35,760
os padrões e você vê que está indo

9572
06:28:35,760 --> 06:28:39,040
para voltar ao formato inicial que nós

9573
06:28:39,040 --> 06:28:42,558
tinha antes disso é como você usa std fixo

9574
06:28:42,558 --> 06:28:44,878
e std científico

9575
06:28:44,878 --> 06:28:45,680
A sua forma de

9576
06:28:45,680 --> 06:28:48,080
manipular como seu ponto flutuante

9577
06:28:48,080 --> 06:28:51,280
Os números são impressos no terminal

9578
06:28:51,280 --> 06:28:53,600
Também vimos que podemos definir o

9579
06:28:53,600 --> 06:28:57,680
precisão de nossa saída no terminal

9580
06:28:57,680 --> 06:29:00,400
Aqui temos uma variável a que é do tipo

9581
06:29:00,400 --> 06:29:02,958
duplo como você pode ver em um estúdio visual

9582
06:29:02,958 --> 06:29:05,120
código aqui se você passar o mouse sobre uma variável

9583
06:29:05,120 --> 06:29:07,360
Você vai ser capaz de ver o seu tipo

9584
06:29:07,360 --> 06:29:09,680
Podemos escolher ver isso em qualquer coisa

9585
06:29:09,680 --> 06:29:12,638
A precisão que queremos 6 é o padrão em

9586
06:29:12,638 --> 06:29:15,680
nosso caso aqui, mas podemos escolher definir

9587
06:29:15,680 --> 06:29:18,958
a precisão para 10 20 ou o que quer que seja

9588
06:29:18,958 --> 06:29:20,798
Realmente nós queremos

9589
06:29:20,798 --> 06:29:22,638
Por favor, note que isso vai ser

9590
06:29:22,638 --> 06:29:24,878
limitado pela precisão que seu tipo

9591
06:29:24,878 --> 06:29:27,280
Suporta, por exemplo, sabemos que a

9592
06:29:27,280 --> 06:29:30,558
O duplo tem uma precisão de 15 e se nós

9593
06:29:30,558 --> 06:29:33,440
Tem mais de 15 dígitos aqui o

9594
06:29:33,440 --> 06:29:35,760
O descanso vai ser lixo apenas ser

9595
06:29:35,760 --> 06:29:38,000
Conscientes de que vamos tentar

9596
06:29:38,000 --> 06:29:40,878
construir isso e vamos usar gcc como

9597
06:29:40,878 --> 06:29:44,320
de costume e se executarmos isso

9598
06:29:44,320 --> 06:29:46,160
nós vamos ter nossos números em

9599
06:29:46,160 --> 06:29:48,320
Precisões diferentes, a primeira é

9600
06:29:48,320 --> 06:29:50,400
usando o padrão que será

9601
06:29:50,400 --> 06:29:51,360
6.

9602
06:29:51,360 --> 06:29:53,120
Se usarmos 10 nós vamos ter 10

9603
06:29:53,120 --> 06:29:54,958
dígitos se usarmos 20, vamos conseguir

9604
06:29:54,958 --> 06:29:57,760
20 dígitos, mas se passarmos por cima do

9605
06:29:57,760 --> 06:30:00,638
precisão que nosso tipo aqui suporta

9606
06:30:00,638 --> 06:30:02,958
nós vamos ter lixo, eu espero que isso

9607
06:30:02,958 --> 06:30:04,958
Faz sentido a última coisa que estamos indo

9608
06:30:04,958 --> 06:30:07,840
ver é um ponto de exibição e vimos

9609
06:30:07,840 --> 06:30:08,718
que

9610
06:30:08,718 --> 06:30:11,200
Isso é usado para forçar

9611
06:30:11,200 --> 06:30:13,680
produzindo o ponto decimal, digamos

9612
06:30:13,680 --> 06:30:16,798
Aqui e um bom exemplo para isso é

9613
06:30:16,798 --> 06:30:18,320
Este 12 aqui

9614
06:30:18,320 --> 06:30:19,840
Se nós imprimi-lo para fora

9615
06:30:19,840 --> 06:30:22,798
Aqui nós não vamos ter o decimal

9616
06:30:22,798 --> 06:30:25,840
ponto por padrão ele vai imprimir 12

9617
06:30:25,840 --> 06:30:28,958
mas se descermos e forçarmos a saída de

9618
06:30:28,958 --> 06:30:31,200
O ponto decimal aqui vamos

9619
06:30:31,200 --> 06:30:34,718
obter algo como 12.0

9620
06:30:34,718 --> 06:30:37,360
E outro efeito disso é que é

9621
06:30:37,360 --> 06:30:40,558
indo para adicionar zeros de trilha para preencher

9622
06:30:40,558 --> 06:30:43,120
Seja qual for o espaço alocado para o seu

9623
06:30:43,120 --> 06:30:45,920
variável de saída no terminal

9624
06:30:45,920 --> 06:30:48,160
Vamos tentar correr isso para que possamos

9625
06:30:48,160 --> 06:30:50,400
realmente ver esta corrida que nós vamos

9626
06:30:50,400 --> 06:30:54,240
executar o nosso galo executável e no

9627
06:30:54,240 --> 06:30:56,958
Primeiro grupo aqui não temos o

9628
06:30:56,958 --> 06:30:59,760
configuração para mostrar ponto e se você olhar

9629
06:30:59,760 --> 06:31:02,478
nos números que tínhamos em nosso código

9630
06:31:02,478 --> 06:31:05,360
o primeiro número é 34.1 e você vê

9631
06:31:05,360 --> 06:31:07,440
que estamos preenchendo um monte de números

9632
06:31:07,440 --> 06:31:10,400
porque tínhamos definido a nossa precisão para um

9633
06:31:10,400 --> 06:31:13,040
Um grande número no último exemplo

9634
06:31:13,040 --> 06:31:15,440
que nós corremos, vamos lá

9635
06:31:15,440 --> 06:31:16,798
e mostrar que é por isso que nós somos

9636
06:31:16,798 --> 06:31:19,040
Ver a precisão de 20

9637
06:31:19,040 --> 06:31:21,680
É realmente enorme, mas não é grande coisa que podemos

9638
06:31:21,680 --> 06:31:24,080
redefinir isso para o que quisermos se isso

9639
06:31:24,080 --> 06:31:26,240
É demais para nós

9640
06:31:26,240 --> 06:31:29,798
O importante aqui é que temos

9641
06:31:29,798 --> 06:31:32,958
34.1 e isso é o que estamos vendo e

9642
06:31:32,958 --> 06:31:36,520
Se você for aos nossos 12 aqui você vê que temos

9643
06:31:36,520 --> 06:31:40,958
12.0 mas nossa saída não está mostrando

9644
06:31:40,958 --> 06:31:43,280
O ponto decimal aqui, se for

9645
06:31:43,280 --> 06:31:45,280
É importante mostrar o ponto decimal que nós

9646
06:31:45,280 --> 06:31:48,638
pode fazer std show point aqui e é

9647
06:31:48,638 --> 06:31:50,718
Vou aparecer, isso é realmente o que é

9648
06:31:50,718 --> 06:31:53,440
importante neste pedaço de código aqui e

9649
06:31:53,440 --> 06:31:54,878
Isso é realmente tudo o que nos prossamos fazer em

9650
06:31:54,878 --> 06:31:56,638
Esta palestra tivemos a chance de jogar

9651
06:31:56,638 --> 06:31:59,520
com muitos desses manipuladores e

9652
06:31:59,520 --> 06:32:01,280
A melhor maneira de aprender sobre essas coisas é

9653
06:32:01,280 --> 06:32:04,160
realmente para experimentá-los em código

9654
06:32:04,160 --> 06:32:06,320
e tentar mudar algumas coisas e ver

9655
06:32:06,320 --> 06:32:09,520
Como isso afeta a saída que você obtém

9656
06:32:09,520 --> 06:32:11,920
O terminal e tivemos a oportunidade de jogar

9657
06:32:11,920 --> 06:32:14,160
com muitas dessas coisas nesta

9658
06:32:14,160 --> 06:32:17,040
A palestra há muitos desses caras eu

9659
06:32:17,040 --> 06:32:19,920
Tentou fazer esta palestra como extensa

9660
06:32:19,920 --> 06:32:22,878
Como eu posso, é por isso que acabou por ser

9661
06:32:22,878 --> 06:32:24,958
Muito tempo, mas uma vez que você aprendeu

9662
06:32:24,958 --> 06:32:27,120
E esses fãs e brincaram com eles em

9663
06:32:27,120 --> 06:32:29,680
código que você nunca vai esquecê-los

9664
06:32:29,680 --> 06:32:32,718
Um último ponto eu quero enfatizar novamente

9665
06:32:32,718 --> 06:32:36,320
é que a documentação é do máximo

9666
06:32:36,320 --> 06:32:39,040
Importância é realmente bom vir

9667
06:32:39,040 --> 06:32:41,280
aqui e confira as coisas, por exemplo, se

9668
06:32:41,280 --> 06:32:43,760
nós vamos mostrar ponto aqui que vamos

9669
06:32:43,760 --> 06:32:46,240
obter uma boa explicação do que isso

9670
06:32:46,240 --> 06:32:48,958
O manipulador permite todas as desabilitações

9671
06:32:48,958 --> 06:32:50,958
A inclusão incondicional do

9672
06:32:50,958 --> 06:32:53,280
caractere de ponto decimal e você pode ler

9673
06:32:53,280 --> 06:32:54,320
Tudo isso

9674
06:32:54,320 --> 06:32:56,558
E o bom é que se você for

9675
06:32:56,558 --> 06:32:58,638
Você vai ter um pedaço de

9676
06:32:58,638 --> 06:32:59,520
o código

9677
06:32:59,520 --> 06:33:01,360
que você pode usar para realmente entender

9678
06:33:01,360 --> 06:33:03,520
Seja o que for que eles estão falando

9679
06:33:03,520 --> 06:33:05,760
E isso é inestimável se você é

9680
06:33:05,760 --> 06:33:08,000
Aprender é uma coisa boa ser capaz

9681
06:33:08,000 --> 06:33:10,958
para usar a documentação, isso é realmente

9682
06:33:10,958 --> 06:33:13,600
Tudo o que nos prosseguimos para fazer nesta palestra

9683
06:33:13,600 --> 06:33:16,320
acabou sendo muito longo, mas eu

9684
06:33:16,320 --> 06:33:18,400
realmente espero que valeu a pena para você

9685
06:33:18,400 --> 06:33:20,320
Vamos parar aqui nesta palestra

9686
06:33:20,320 --> 06:33:21,520
No próximo vamos aprender

9687
06:33:21,520 --> 06:33:24,718
sobre os limites numéricos vão adiante e terminam

9688
06:33:24,718 --> 06:33:27,200
Aqui e me encontre lá nisso

9689
06:33:27,200 --> 06:33:29,200
palestra que vamos tocar com um

9690
06:33:29,200 --> 06:33:31,920
Poucas funções desta biblioteca

9691
06:33:31,920 --> 06:33:33,680
especificamente nós vamos estar olhando

9692
06:33:33,680 --> 06:33:36,240
no mínimo o máximo e o

9693
06:33:36,240 --> 06:33:38,000
funções mais baixas

9694
06:33:38,000 --> 06:33:40,400
E é assim que você os usa

9695
06:33:40,400 --> 06:33:43,520
pode pensar nisso como um espaço reservado para

9696
06:33:43,520 --> 06:33:46,080
O tipo para o qual você quer saber o

9697
06:33:46,080 --> 06:33:48,958
mínimo o máximo e o ponto mais baixo

9698
06:33:48,958 --> 06:33:51,200
respectivamente, eu sei que isso pode ser

9699
06:33:51,200 --> 06:33:53,440
enigmática para alguns de vocês, então vamos

9700
06:33:53,440 --> 06:33:56,320
Veja alguns exemplos específicos aqui:

9701
06:33:56,320 --> 06:33:58,878
ter uma explicação simples do que estes

9702
06:33:58,878 --> 06:34:00,558
As funções significam

9703
06:34:00,558 --> 06:34:02,878
para valores de ponto flutuante

9704
06:34:02,878 --> 06:34:05,440
o mínimo vai representar o

9705
06:34:05,440 --> 06:34:07,760
menor número positivo

9706
06:34:07,760 --> 06:34:10,478
que é representável com essa flutuação

9707
06:34:10,478 --> 06:34:12,638
tipo de ponto o máximo vai ser

9708
06:34:12,638 --> 06:34:14,478
o número de ponto flutuante máximo que você

9709
06:34:14,478 --> 06:34:17,280
pode representar e no menor número

9710
06:34:17,280 --> 06:34:20,080
Será o menor negativo

9711
06:34:20,080 --> 06:34:22,718
número que você pode representar com esse tipo

9712
06:34:22,718 --> 06:34:24,240
As coisas mudam um pouco quando você

9713
06:34:24,240 --> 06:34:27,200
começar a lidar com inteiros e estes

9714
06:34:27,200 --> 06:34:29,120
As funções vão se parecer com isso

9715
06:34:29,120 --> 06:34:31,280
O mínimo será o mínimo

9716
06:34:31,280 --> 06:34:32,878
Número que você pode representar com isso

9717
06:34:32,878 --> 06:34:35,680
inteiro e mais baixo não significa realmente

9718
06:34:35,680 --> 06:34:38,958
qualquer coisa para tipos integrais o máximo

9719
06:34:38,958 --> 06:34:41,040
Será o número um máximo

9720
06:34:41,040 --> 06:34:42,958
O que você tem que ter em mente é que

9721
06:34:42,958 --> 06:34:45,520
O mínimo pode ser negativo

9722
06:34:45,520 --> 06:34:49,200
se você estiver usando um inteiro conectado se você

9723
06:34:49,200 --> 06:34:51,280
estão usando um inteiro não assinado para

9724
06:34:51,280 --> 06:34:53,760
Por exemplo, o mínimo curto será

9725
06:34:53,760 --> 06:34:56,160
zero e o máximo será o

9726
06:34:56,160 --> 06:34:59,280
Número máximo representável com isso

9727
06:34:59,280 --> 06:35:01,840
tipo inteiro aqui estamos olhando

9728
06:35:01,840 --> 06:35:04,878
números curtos e apenas a mesma história

9729
06:35:04,878 --> 06:35:07,760
aplica-se a qualquer tipo inteiro que você é

9730
06:35:07,760 --> 06:35:10,000
usando mesmo se você estiver usando

9731
06:35:10,000 --> 06:35:13,600
extremidade longa ou fim sem qualquer modificador

9732
06:35:13,600 --> 06:35:15,680
Lembre-se que nós tínhamos que fazer um monte de

9733
06:35:15,680 --> 06:35:19,440
coisas para obter este alcance e foi

9734
06:35:19,440 --> 06:35:22,080
É realmente difícil fazer isso para flutuar

9735
06:35:22,080 --> 06:35:26,400
tipos de ponto, então esta biblioteca é útil

9736
06:35:26,400 --> 06:35:28,240
em ter uma noção do que podemos

9737
06:35:28,240 --> 06:35:30,718
representar com o tipo dado b8

9738
06:35:30,718 --> 06:35:33,440
ponto flutuante ou integral para ir

9739
06:35:33,440 --> 06:35:35,840
código de estúdio visual e jogar conosco aqui

9740
06:35:35,840 --> 06:35:38,878
Estamos em nossa pasta de trabalho

9741
06:35:38,878 --> 06:35:40,798
Vamos copiar o código do nosso

9742
06:35:40,798 --> 06:35:42,638
projeto de modelo

9743
06:35:42,638 --> 06:35:44,718
e nós vamos para a corrente

9744
06:35:44,718 --> 06:35:46,718
projeto que são limites numéricos que somos

9745
06:35:46,718 --> 06:35:49,520
indo para ir e colocar em nossos arquivos

9746
06:35:49,520 --> 06:35:52,718
suba novamente e abra este arquivo em

9747
06:35:52,718 --> 06:35:54,558
código de estúdio visual que vamos fechar

9748
06:35:54,558 --> 06:35:57,440
isso abre o arquivo principal do cpp removido

9749
06:35:57,440 --> 06:35:59,840
Seja lá o que não precisamos, somos

9750
06:35:59,840 --> 06:36:02,240
Incluindo a biblioteca de limites

9751
06:36:02,240 --> 06:36:04,000
Lembre-se que esta é a primeira coisa que precisamos

9752
06:36:04,000 --> 06:36:05,120
para fazer

9753
06:36:05,120 --> 06:36:09,040
Se quisermos brincar com essas instalações

9754
06:36:09,040 --> 06:36:11,440
que nós apenas olhamos nos slides

9755
06:36:11,440 --> 06:36:13,760
e nós vamos descer aqui e colocar

9756
06:36:13,760 --> 06:36:16,558
no código que queremos jogar com

9757
06:36:16,558 --> 06:36:19,280
E é ridiculamente simples

9758
06:36:19,280 --> 06:36:21,440
Se você já assistiu os slides, nós apenas

9759
06:36:21,440 --> 06:36:23,680
Fiz em um minuto, então o que vamos fazer

9760
06:36:23,680 --> 06:36:25,360
Estou fazendo aqui nós vamos estar imprimindo

9761
06:36:25,360 --> 06:36:28,000
fora do alcance para cada tipo possível de nós

9762
06:36:28,000 --> 06:36:30,160
Quero brincar com aqui, então vamos

9763
06:36:30,160 --> 06:36:33,520
Diga o intervalo para curto e é de

9764
06:36:33,520 --> 06:36:35,920
e nós vamos dizer st monmeric

9765
06:36:35,920 --> 06:36:37,040
Os limites

9766
06:36:37,040 --> 06:36:39,520
curto que é com isso que queremos lidar

9767
06:36:39,520 --> 06:36:42,000
Agora e vamos chamar o mínimo

9768
06:36:42,000 --> 06:36:44,320
Função que isso vai nos dar

9769
06:36:44,320 --> 06:36:46,718
o valor mínimo que podemos representar com

9770
06:36:46,718 --> 06:36:49,520
curto e nós vamos dizer std numérico

9771
06:36:49,520 --> 06:36:51,200
limites e vamos chamar o máximo

9772
06:36:51,200 --> 06:36:52,160
A função

9773
06:36:52,160 --> 06:36:55,120
passando no tipo pelo qual queremos

9774
06:36:55,120 --> 06:36:56,798
obter o alcance para

9775
06:36:56,798 --> 06:37:00,718
E a mesma história se aplica para

9776
06:37:00,718 --> 06:37:02,478
não assinado

9777
06:37:02,478 --> 06:37:03,840
curto

9778
06:37:03,840 --> 06:37:05,680
Você vê que é o tipo que estamos usando

9779
06:37:05,680 --> 06:37:08,798
Aqui também vamos brincar com formi

9780
06:37:08,798 --> 06:37:10,958
obter o alcance que vamos usar

9781
06:37:10,958 --> 06:37:12,478
não assinado e

9782
06:37:12,478 --> 06:37:14,878
para ver como essas coisas se comportam, nós somos

9783
06:37:14,878 --> 06:37:16,400
indo para usar por muito tempo

9784
06:37:16,400 --> 06:37:18,798
e chegar ao alcance e nós também

9785
06:37:18,798 --> 06:37:21,840
Vou jogar com o ponto flutuante

9786
06:37:21,840 --> 06:37:24,080
tipos, então vamos calcular o

9787
06:37:24,080 --> 06:37:26,878
intervalo usando a função mínima e o

9788
06:37:26,878 --> 06:37:29,440
A função máxima e nós vamos ser

9789
06:37:29,440 --> 06:37:32,478
também usando a função mais baixa para ver

9790
06:37:32,478 --> 06:37:35,280
que isso é realmente a mesma coisa que nós

9791
06:37:35,280 --> 06:37:37,760
descritos nos slides que vamos

9792
06:37:37,760 --> 06:37:40,080
fazer isso para o duplo e longo duplo e

9793
06:37:40,080 --> 06:37:41,840
Veja como esses intervalos

9794
06:37:41,840 --> 06:37:44,000
Venha neste programa o que estamos indo

9795
06:37:44,000 --> 06:37:47,040
fazer é abrir um terminal aqui estamos

9796
06:37:47,040 --> 06:37:50,240
indo para executar a tarefa para construir com gcc

9797
06:37:50,240 --> 06:37:52,638
E a construção vai ser boa

9798
06:37:52,638 --> 06:37:56,320
e nós podemos descer e correr galo e

9799
06:37:56,320 --> 06:37:57,920
nós vamos ter nossos valores aqui o

9800
06:37:57,920 --> 06:38:02,638
alcance curto e é de menos 32 768

9801
06:38:02,638 --> 06:38:04,120
até 32

9802
06:38:04,120 --> 06:38:07,280
767 e você vê que este é exatamente o

9803
06:38:07,280 --> 06:38:09,440
A mesma coisa que vimos na palestra onde

9804
06:38:09,440 --> 06:38:11,760
Falamos sobre sistemas numéricos que vimos a

9805
06:38:11,760 --> 06:38:14,320
Como você pode fazer isso manualmente conectando

9806
06:38:14,320 --> 06:38:15,360
O que é

9807
06:38:15,360 --> 06:38:18,000
número de dígitos em alguma fórmula que nós

9808
06:38:18,000 --> 06:38:20,160
Veio você pode voltar e verificar isso

9809
06:38:20,160 --> 06:38:22,320
Se você quiser, fazemos o mesmo para

9810
06:38:22,320 --> 06:38:25,040
não assinado curto e, em seguida, olhamos para

9811
06:38:25,040 --> 06:38:27,280
tipos de ponto flutuante que vamos

9812
06:38:27,280 --> 06:38:29,760
imprimir a gama para float

9813
06:38:29,760 --> 06:38:32,000
E se usarmos o

9814
06:38:32,000 --> 06:38:34,798
função mínima para obter o início do

9815
06:38:34,798 --> 06:38:37,600
alcance, vamos obter o mínimo

9816
06:38:37,600 --> 06:38:40,478
Número positivo que podemos representar com

9817
06:38:40,478 --> 06:38:42,718
flutuar se usarmos o mais baixo, vamos

9818
06:38:42,718 --> 06:38:45,440
obter o menor número mínimo e que

9819
06:38:45,440 --> 06:38:47,760
O máximo será o mesmo se

9820
06:38:47,760 --> 06:38:50,000
Você acha que isso é realmente pequeno você tem

9821
06:38:50,000 --> 06:38:52,638
a opção de abrir esta pasta em

9822
06:38:52,638 --> 06:38:56,478
file explorer e você pode abrir um comando

9823
06:38:56,478 --> 06:38:58,958
janela prompt ou powershell batendo

9824
06:38:58,958 --> 06:39:01,520
shift e clique direito e escolha

9825
06:39:01,520 --> 06:39:04,320
esta opção aqui open powershell janela

9826
06:39:04,320 --> 06:39:05,120
aqui

9827
06:39:05,120 --> 06:39:07,040
E você vai ter uma janela maior

9828
06:39:07,040 --> 06:39:08,718
em que você pode digitar coisas que estamos indo

9829
06:39:08,718 --> 06:39:10,638
para correr galo e nós vamos ver

9830
06:39:10,638 --> 06:39:13,600
coisas de uma forma muito mais fácil aqui

9831
06:39:13,600 --> 06:39:15,920
Esta é uma opção que você pode usar ou você pode

9832
06:39:15,920 --> 06:39:19,440
até mesmo usar o terminal integrado dentro

9833
06:39:19,440 --> 06:39:21,920
código visual do estúdio aqui como se já estivemos

9834
06:39:21,920 --> 06:39:24,320
Fazendo o tempo todo há alguns outros

9835
06:39:24,320 --> 06:39:27,360
instalações que você pode usar nesta biblioteca

9836
06:39:27,360 --> 06:39:32,240
de limites, por exemplo, podemos tentar e

9837
06:39:32,240 --> 06:39:34,798
impressão se um número é assinado ou

9838
06:39:34,798 --> 06:39:37,680
não assinado ou obter o número de dígitos que

9839
06:39:37,680 --> 06:39:40,638
pode representar em um tipo inteiro

9840
06:39:40,638 --> 06:39:42,878
Estes são alguns exemplos que acabei de escolher

9841
06:39:42,878 --> 06:39:44,878
porque são fáceis de entender e

9842
06:39:44,878 --> 06:39:47,280
Realmente útil, mas você pode encontrar mais

9843
06:39:47,280 --> 06:39:49,360
sobre esta biblioteca

9844
06:39:49,360 --> 06:39:51,120
na documentação

9845
06:39:51,120 --> 06:39:54,000
e se você vier aqui em cppreference.com

9846
06:39:54,000 --> 06:39:56,558
O link está aqui você pode realmente encontrar tudo

9847
06:39:56,558 --> 06:39:59,040
sobre esta biblioteca aqui nesta biblioteca

9848
06:39:59,040 --> 06:40:01,200
fornece uma maneira padronizada de transportar

9849
06:40:01,200 --> 06:40:04,000
várias propriedades dos tipos aritméticos

9850
06:40:04,000 --> 06:40:06,160
Por exemplo, o maior valor possível

9851
06:40:06,160 --> 06:40:08,878
Tipo e é isto

9852
06:40:08,878 --> 06:40:10,638
E nós temos um monte de coisas que podemos fazer

9853
06:40:10,638 --> 06:40:13,680
Aqui não tenha medo deste modelo

9854
06:40:13,680 --> 06:40:14,558
uma coisa

9855
06:40:14,558 --> 06:40:18,000
Pense neles como placeholders para

9856
06:40:18,000 --> 06:40:19,920
O tipo pelo qual você está tentando

9857
06:40:19,920 --> 06:40:22,478
informações de consulta para que haja alguns

9858
06:40:22,478 --> 06:40:24,718
funções que você pode chamar essas coisas

9859
06:40:24,718 --> 06:40:27,840
Por exemplo, há média mais baixo máximo

9860
06:40:27,840 --> 06:40:29,840
que apenas brincamos em visual

9861
06:40:29,840 --> 06:40:32,558
código de estúdio, mas uh você pode ver isso

9862
06:40:32,558 --> 06:40:34,638
Há muitas coisas que você pode jogar

9863
06:40:34,638 --> 06:40:36,798
especialmente se você tem alguma matemática

9864
06:40:36,798 --> 06:40:38,958
Fundo para entender tudo isso

9865
06:40:38,958 --> 06:40:41,440
conceitos aqui você pode jogar conosco e

9866
06:40:41,440 --> 06:40:44,160
Veja se é útil para o que quer que seja

9867
06:40:44,160 --> 06:40:46,160
Aplicação que você está fazendo bem, isso é

9868
06:40:46,160 --> 06:40:47,520
Realmente tudo o que nos posicionamos para fazer nisso

9869
06:40:47,520 --> 06:40:49,920
palestra para aprender um pouco sobre o

9870
06:40:49,920 --> 06:40:53,120
limita a biblioteca em que é útil

9871
06:40:53,120 --> 06:40:55,360
Tentando entender os intervalos para o seu

9872
06:40:55,360 --> 06:40:57,280
tipos se você precisar desses tipos

9873
06:40:57,280 --> 06:40:59,840
das coisas que isso vai ser útil

9874
06:40:59,840 --> 06:41:01,680
Vamos parar aqui nesta palestra

9875
06:41:01,680 --> 06:41:03,040
No próximo vamos aprender

9876
06:41:03,040 --> 06:41:06,240
sobre algumas funções matemáticas que podemos usar em

9877
06:41:06,240 --> 06:41:09,680
c plus vá em frente e termine aqui

9878
06:41:09,680 --> 06:41:11,760
e encontrar-me lá nesta palestra nós somos

9879
06:41:11,760 --> 06:41:14,400
Vou aprender sobre funções matemáticas e

9880
06:41:14,400 --> 06:41:16,718
Estas são funções que são construídas em

9881
06:41:16,718 --> 06:41:19,600
A biblioteca z plus plus que nós

9882
06:41:19,600 --> 06:41:22,160
pode usar para fazer algumas contas se você estiver fazendo

9883
06:41:22,160 --> 06:41:24,160
Algumas operações de matemática que você vai

9884
06:41:24,160 --> 06:41:25,760
Encontre isso útil

9885
06:41:25,760 --> 06:41:30,000
eles vivem na biblioteca de matemática c e se

9886
06:41:30,000 --> 06:41:31,440
você quer usá-los você está apenas indo

9887
06:41:31,440 --> 06:41:33,280
para incluir isso e você vai ter

9888
06:41:33,280 --> 06:41:35,360
acesso a eles o que você vê aqui é um

9889
06:41:35,360 --> 06:41:37,760
Um resumo simples de algumas das coisas que você

9890
06:41:37,760 --> 06:41:40,878
pode usar nestas funções matemáticas que você pode

9891
06:41:40,878 --> 06:41:45,360
usar std flor para arredondar para baixo ou hdd selo

9892
06:41:45,360 --> 06:41:46,080
A sua forma de

9893
06:41:46,080 --> 06:41:49,440
arredondar você pode usar a função abs para

9894
06:41:49,440 --> 06:41:51,840
calcular o valor absoluto de um número

9895
06:41:51,840 --> 06:41:54,718
você pode fazer trigonometria, você pode fazer o

9896
06:41:54,718 --> 06:41:57,920
sinais de cosseno e coisas assim que você pode

9897
06:41:57,920 --> 06:42:00,080
calcular o exponencial de um número

9898
06:42:00,080 --> 06:42:01,760
Você vai ver o que isso significa em um

9899
06:42:01,760 --> 06:42:04,798
poucas palestras que você pode usar std log e

9900
06:42:04,798 --> 06:42:07,200
novamente se você tem algum fundo de matemática

9901
06:42:07,200 --> 06:42:09,200
Estes conceitos não vão ser

9902
06:42:09,200 --> 06:42:11,440
estranhos para você, muitas dessas funções

9903
06:42:11,440 --> 06:42:14,240
são documentados aqui em cpp referência assim

9904
06:42:14,240 --> 06:42:17,040
Pode valer a pena ir para lá e

9905
06:42:17,040 --> 06:42:19,440
Verifique quais funções estão disponíveis lá

9906
06:42:19,440 --> 06:42:21,280
Aqui está um exemplo de algo que você

9907
06:42:21,280 --> 06:42:23,520
Talvez queira fazer, por exemplo, você tem um

9908
06:42:23,520 --> 06:42:25,920
variável é chamado de peso dentro de nós

9909
06:42:25,920 --> 06:42:30,558
tem um 7,7 e se você faz std floor de

9910
06:42:30,558 --> 06:42:32,240
Esta variável vai ser

9911
06:42:32,240 --> 06:42:35,200
arredondado para um 7. se você quiser

9912
06:42:35,200 --> 06:42:37,680
round up você vai usar std seal

9913
06:42:37,680 --> 06:42:39,360
E você vai conseguir isso e nós

9914
06:42:39,360 --> 06:42:41,280
Vou ver o que isso vai dar

9915
06:42:41,280 --> 06:42:44,160
Nós em um minuto quando chegamos ao estúdio visual

9916
06:42:44,160 --> 06:42:46,400
Código aqui é como você usaria o

9917
06:42:46,400 --> 06:42:48,718
Função de valor absoluto você tem alguns

9918
06:42:48,718 --> 06:42:52,080
variáveis aqui e se você tentar conectar

9919
06:42:52,080 --> 06:42:54,798
nesta função de valor absoluto

9920
06:42:54,798 --> 06:42:56,638
Você basicamente vai obter o peso

9921
06:42:56,638 --> 06:43:00,320
do número sem qualquer sinal na frente

9922
06:43:00,320 --> 06:43:02,878
do número positivo ou negativo do

9923
06:43:02,878 --> 06:43:04,798
O valor absoluto é o peso do

9924
06:43:04,798 --> 06:43:07,760
número sem se importar com o sinal se

9925
06:43:07,760 --> 06:43:10,320
Eu posso dizer assim que tudo bem, nós também temos

9926
06:43:10,320 --> 06:43:12,718
a função x que vai calcular

9927
06:43:12,718 --> 06:43:15,520
O exponencial de um número este é um

9928
06:43:15,520 --> 06:43:17,520
conceito de matemática, então se você não tem um

9929
06:43:17,520 --> 06:43:19,760
fundo em matemática isso vai ser um

9930
06:43:19,760 --> 06:43:22,000
Pouco difícil de envolver seus cérebros ao redor

9931
06:43:22,000 --> 06:43:24,240
mas em matemática temos este número que é

9932
06:43:24,240 --> 06:43:25,520
chamado e

9933
06:43:25,520 --> 06:43:30,478
e seu valor é de aproximadamente 2,7 18 28

9934
06:43:30,478 --> 06:43:32,558
Como você vê aqui o exponencial

9935
06:43:32,558 --> 06:43:35,440
A função vai fazer o que f x aqui é

9936
06:43:35,440 --> 06:43:38,400
Fazendo isso vai pegar e e elevar

9937
06:43:38,400 --> 06:43:41,760
que para o poder de x e, por exemplo

9938
06:43:41,760 --> 06:43:44,080
em nosso código aqui vamos conseguir o

9939
06:43:44,080 --> 06:43:46,878
Expoencial de 10 que vai ser e

9940
06:43:46,878 --> 06:43:49,680
elevado ao poder do bronzeado e nós somos

9941
06:43:49,680 --> 06:43:51,680
Vou jogar com isso em estúdio visual

9942
06:43:51,680 --> 06:43:53,200
código e você vai ver o valor

9943
06:43:53,200 --> 06:43:55,680
disso também temos a função de poder

9944
06:43:55,680 --> 06:43:57,360
Aqui, o que vai levar o primeiro

9945
06:43:57,360 --> 06:43:59,840
parâmetro e elevar isso à potência

9946
06:43:59,840 --> 06:44:01,680
O segundo parâmetro

9947
06:44:01,680 --> 06:44:02,878
Então,

9948
06:44:02,878 --> 06:44:05,440
Isso vai ser 3 para o poder de 4

9949
06:44:05,440 --> 06:44:08,080
e 9 para o poder de 3 e nós vamos

9950
06:44:08,080 --> 06:44:10,400
para obter a resposta se conectarmos isso

9951
06:44:10,400 --> 06:44:13,520
código de estúdio visual e temos olhar

9952
06:44:13,520 --> 06:44:16,080
funções que são basicamente o inverso

9953
06:44:16,080 --> 06:44:18,718
da função de poder que nós apenas

9954
06:44:18,718 --> 06:44:20,080
Olhei para o

9955
06:44:20,080 --> 06:44:24,478
se você fizer login 8 na base 2, por exemplo

9956
06:44:24,478 --> 06:44:27,360
É como se você estivesse pedindo para qual poder

9957
06:44:27,360 --> 06:44:29,920
Devo elevar 2

9958
06:44:29,920 --> 06:44:31,920
para que eu tenha 8.

9959
06:44:31,920 --> 06:44:33,840
E a resposta aqui vai ser um 3

9960
06:44:33,840 --> 06:44:36,478
Claro, mas a captura é que o log

9961
06:44:36,478 --> 06:44:39,920
A função por padrão funciona na base e

9962
06:44:39,920 --> 06:44:42,478
O que estamos pedindo, por exemplo, se

9963
06:44:42,478 --> 06:44:46,200
Diga log 54.59

9964
06:44:46,400 --> 06:44:49,920
é para qual poder devemos elevar e

9965
06:44:49,920 --> 06:44:52,638
para obter este número aqui e é

9966
06:44:52,638 --> 06:44:54,240
vai ser computado e você vai

9967
06:44:54,240 --> 06:44:56,878
Veja isso se você conectar isso

9968
06:44:56,878 --> 06:44:59,280
código de estúdio visual ou você pode tentar usar

9969
06:44:59,280 --> 06:45:01,760
uma das calculadoras disponíveis para você

9970
06:45:01,760 --> 06:45:03,360
e você vai ver que isso faz

9971
06:45:03,360 --> 06:45:06,240
Sensação também temos uma função especial

9972
06:45:06,240 --> 06:45:08,160
que vai fazer a mesma coisa, mas

9973
06:45:08,160 --> 06:45:09,680
na base 10

9974
06:45:09,680 --> 06:45:11,600
E isso vai ser mais fácil

9975
06:45:11,600 --> 06:45:14,000
Entenda, por exemplo, aqui estamos

9976
06:45:14,000 --> 06:45:16,160
Log de computação 10

9977
06:45:16,160 --> 06:45:17,200
Então,

9978
06:45:17,200 --> 06:45:19,680
O que estamos realmente dizendo é para que

9979
06:45:19,680 --> 06:45:22,320
Poder devemos elevar 10

9980
06:45:22,320 --> 06:45:25,280
para obter 10 000 e isso é fácil porque

9981
06:45:25,280 --> 06:45:28,958
A resposta é um 4 10 para o poder de 4

9982
06:45:28,958 --> 06:45:32,638
é 10 000 eu realmente espero que isso faça sentido

9983
06:45:32,638 --> 06:45:35,440
também temos uma função de rota quadrada

9984
06:45:35,440 --> 06:45:38,240
pode usar tão quadrado de 81 vai

9985
06:45:38,240 --> 06:45:39,360
ser nove

9986
06:45:39,360 --> 06:45:42,240
temos uma função chamada std round

9987
06:45:42,240 --> 06:45:43,840
que pode arredondar

9988
06:45:43,840 --> 06:45:46,958
e uh o que vai fazer por padrão

9989
06:45:46,958 --> 06:45:49,200
A metade dos pontos será arredondado

9990
06:45:49,200 --> 06:45:52,320
longe de zero, então se você tem um 2.5 é

9991
06:45:52,320 --> 06:45:55,200
vai ser arredondado até um 3 e se você

9992
06:45:55,200 --> 06:45:58,320
tem 2.4 vai ser arredondado para baixo

9993
06:45:58,320 --> 06:46:01,760
para um 2. também temos uma série de funções

9994
06:46:01,760 --> 06:46:04,400
Podemos usar em trigonometria que temos um

9995
06:46:04,400 --> 06:46:06,478
função senoid nós temos uma função de cosseno

9996
06:46:06,478 --> 06:46:08,878
temos uma função bronzeada se você souber destes

9997
06:46:08,878 --> 06:46:11,200
Conceitos em matemática que virão

9998
06:46:11,200 --> 06:46:14,400
em muito útil se você quiser fazer isso eu

9999
06:46:14,400 --> 06:46:16,240
Tenho que dizer que o que acabamos de falar

10000
06:46:16,240 --> 06:46:19,760
sobre é um pequeno conjunto do que podemos fazer

10001
06:46:19,760 --> 06:46:23,120
com essas funções aqui em c matemática e

10002
06:46:23,120 --> 06:46:26,798
uh estamos aqui em cppreference.com

10003
06:46:26,798 --> 06:46:29,360
e podemos ver todas essas funções aqui

10004
06:46:29,360 --> 06:46:32,080
Podemos fazer lembrete de que podemos fazer f homens e

10005
06:46:32,080 --> 06:46:34,478
Se você quiser, você pode verificar isso em

10006
06:46:34,478 --> 06:46:37,200
A documentação, por exemplo, se você for

10007
06:46:37,200 --> 06:46:40,400
para pode aqui e clicar nele você está

10008
06:46:40,400 --> 06:46:42,478
Vou obter a descrição e

10009
06:46:42,478 --> 06:46:44,878
explicação do que essa função faz

10010
06:46:44,878 --> 06:46:46,160
E você vai ter um simples

10011
06:46:46,160 --> 06:46:49,120
Exemplo de como você pode jogar conosco bem

10012
06:46:49,120 --> 06:46:51,440
Agora espero que você tenha uma ideia melhor de

10013
06:46:51,440 --> 06:46:54,000
O que podemos fazer com essas funções em

10014
06:46:54,000 --> 06:46:56,878
a biblioteca cmat que vamos ir para

10015
06:46:56,878 --> 06:46:58,400
código de estúdio visual

10016
06:46:58,400 --> 06:47:00,558
e brincar com algumas dessas funções

10017
06:47:00,558 --> 06:47:03,120
Aqui estamos no código visual do estúdio o

10018
06:47:03,120 --> 06:47:05,040
Projeto atual em que vamos trabalhar

10019
06:47:05,040 --> 06:47:07,360
são funções matemáticas que vamos copiar

10020
06:47:07,360 --> 06:47:10,080
sobre nossos arquivos de modelo

10021
06:47:10,080 --> 06:47:12,958
e nós vamos colocá-los em nosso

10022
06:47:12,958 --> 06:47:15,680
diretório aqui funções matemáticas

10023
06:47:15,680 --> 06:47:17,840
e nós vamos abrir isso em

10024
06:47:17,840 --> 06:47:21,280
código de estúdio visual e vamos

10025
06:47:21,280 --> 06:47:23,760
Remova o que quer que seja que não precisamos

10026
06:47:23,760 --> 06:47:26,400
e vamos incluir a nossa biblioteca

10027
06:47:26,400 --> 06:47:28,320
que é c matemática

10028
06:47:28,320 --> 06:47:30,798
e nós vamos colocar em nosso código assim

10029
06:47:30,798 --> 06:47:32,798
que podemos brincar conosco

10030
06:47:32,798 --> 06:47:35,120
e aqui temos uma variável chamada

10031
06:47:35,120 --> 06:47:36,000
o peso

10032
06:47:36,000 --> 06:47:38,160
e nós vamos tentar usar alguns

10033
06:47:38,160 --> 06:47:41,040
funções matemáticas nele para que possamos usar sdd

10034
06:47:41,040 --> 06:47:43,360
piso para arredondar para baixo

10035
06:47:43,360 --> 06:47:46,718
e std selo para arredondar para cima tão pesado

10036
06:47:46,718 --> 06:47:49,360
arredondado para o chão vai ser impresso

10037
06:47:49,360 --> 06:47:51,920
fora e caminho para redondar para selar está indo

10038
06:47:51,920 --> 06:47:53,360
para ser impresso para fora

10039
06:47:53,360 --> 06:47:55,440
nós vamos ter um número aqui

10040
06:47:55,440 --> 06:47:57,440
Nesta variável de poupança vai

10041
06:47:57,440 --> 06:47:59,840
ser um número negativo e nós vamos

10042
06:47:59,840 --> 06:48:02,240
Tente calcular o valor absoluto de

10043
06:48:02,240 --> 06:48:04,320
Isso vamos vê-lo impresso

10044
06:48:04,320 --> 06:48:06,478
Outra coisa que nós vamos

10045
06:48:06,478 --> 06:48:09,760
A computação é a exponencial do valor

10046
06:48:09,760 --> 06:48:12,798
nós vamos fazer stdx 10

10047
06:48:12,798 --> 06:48:15,520
O que isso vai fazer é ir

10048
06:48:15,520 --> 06:48:16,798
take e

10049
06:48:16,798 --> 06:48:19,600
e levantá-lo ao poder de 10 e

10050
06:48:19,600 --> 06:48:21,200
Isso é o que vamos ser impressos

10051
06:48:21,200 --> 06:48:23,120
Aqui, outra coisa que queremos fazer aqui

10052
06:48:23,120 --> 06:48:25,040
é calcular o poder de um número que somos

10053
06:48:25,040 --> 06:48:26,958
indo tomar 3 e levantá-lo para o

10054
06:48:26,958 --> 06:48:30,400
poder de 4 e tomar 9 e elevá-lo para

10055
06:48:30,400 --> 06:48:33,040
o poder de 3 e vamos ver

10056
06:48:33,040 --> 06:48:35,680
O que essas coisas avaliam para nós somos

10057
06:48:35,680 --> 06:48:38,638
Vou abrir o nosso terminal aqui e

10058
06:48:38,638 --> 06:48:40,958
Vamos executar a tarefa de construir

10059
06:48:40,958 --> 06:48:43,920
com gcc o mundo vai ser bom

10060
06:48:43,920 --> 06:48:46,240
E se corrermos o galo, vamos conseguir

10061
06:48:46,240 --> 06:48:49,600
Essas coisas aqui são 7.7 arredondadas para

10062
06:48:49,600 --> 06:48:51,120
O chão vai ser sete, então nós somos

10063
06:48:51,120 --> 06:48:54,400
indo para arredondar para baixo 7,7 arredondado para a venda

10064
06:48:54,400 --> 06:48:56,478
vai ser oito e é isso que

10065
06:48:56,478 --> 06:48:59,600
nós vamos conseguir e o absoluto

10066
06:48:59,600 --> 06:49:02,360
O valor do peso vai ser

10067
06:49:02,360 --> 06:49:06,000
7.7 porque é um número positivo e

10068
06:49:06,000 --> 06:49:09,280
o valor absoluto de menos 5000 é

10069
06:49:09,280 --> 06:49:11,760
vai ser 5 000. e novamente quando você

10070
06:49:11,760 --> 06:49:14,878
calcular o valor absoluto de algo

10071
06:49:14,878 --> 06:49:17,920
Você está interessado no peso disso

10072
06:49:17,920 --> 06:49:21,120
A coisa sem considerar o sinal

10073
06:49:21,120 --> 06:49:23,760
sem realmente se preocupar se é

10074
06:49:23,760 --> 06:49:25,600
positivo ou negativo você só quer

10075
06:49:25,600 --> 06:49:27,920
obter a magnitude de um número que é

10076
06:49:27,920 --> 06:49:30,000
o que usamos em matemática para significar que

10077
06:49:30,000 --> 06:49:32,478
magnitude bom, então se vamos para baixo nós estamos

10078
06:49:32,478 --> 06:49:35,200
Indo para obter o Exposencial de 10 é

10079
06:49:35,200 --> 06:49:36,478
exponencial

10080
06:49:36,478 --> 06:49:38,718
e você vai conseguir isso aqui e

10081
06:49:38,718 --> 06:49:42,080
novamente o que esta função faz é tomar e

10082
06:49:42,080 --> 06:49:45,440
e elevá-lo ao poder de 10

10083
06:49:45,440 --> 06:49:47,680
E essa é a resposta aqui que podemos tentar

10084
06:49:47,680 --> 06:49:50,080
e provar isso com uma calculadora, então eu sou

10085
06:49:50,080 --> 06:49:52,160
Vou abrir a minha calculadora de janelas

10086
06:49:52,160 --> 06:49:54,478
pode usar qualquer calculadora que você tem

10087
06:49:54,478 --> 06:49:55,840
Acesso a

10088
06:49:55,840 --> 06:49:58,718
Eu vou usar um científico

10089
06:49:58,718 --> 06:50:02,400
calculadora aqui e você vê que podemos

10090
06:50:02,400 --> 06:50:04,718
hit e e nós vamos obter o valor

10091
06:50:04,718 --> 06:50:07,360
Este e número em matemática aqui é

10092
06:50:07,360 --> 06:50:11,200
simplificado, mas se eu pegá-lo e elevá-lo

10093
06:50:11,200 --> 06:50:14,798
para o poder de 10 a resposta está indo

10094
06:50:14,798 --> 06:50:18,360
para ser 22.026

10095
06:50:19,280 --> 06:50:22,400
e se olharmos para o nosso programa temos 22

10096
06:50:22,400 --> 06:50:23,638
0 - 0

10097
06:50:23,638 --> 06:50:26,958
26.5 OK é arredondado um pouco

10098
06:50:26,958 --> 06:50:29,840
Mas é quase a mesma coisa ok nós

10099
06:50:29,840 --> 06:50:32,558
também quer jogar com funções de log a

10100
06:50:32,558 --> 06:50:33,680
Um pouco

10101
06:50:33,680 --> 06:50:36,638
O log é basicamente o inverso do

10102
06:50:36,638 --> 06:50:38,400
função de potência

10103
06:50:38,400 --> 06:50:40,240
e nós apenas falamos sobre isso no

10104
06:50:40,240 --> 06:50:41,520
slides

10105
06:50:41,520 --> 06:50:42,558


10106
06:50:42,558 --> 06:50:45,360
se fizermos log 18 base 2 nós somos basicamente

10107
06:50:45,360 --> 06:50:48,240
perguntando a qual poder devemos elevar 2

10108
06:50:48,240 --> 06:50:50,000
para obter um 8

10109
06:50:50,000 --> 06:50:52,080
E a resposta para isso vai ser

10110
06:50:52,080 --> 06:50:53,680
O que este log

10111
06:50:53,680 --> 06:50:55,840
O número em número base está indo para

10112
06:50:55,840 --> 06:50:58,638
avaliar para a captura é que o log

10113
06:50:58,638 --> 06:51:02,080
função se você usá-lo linha como esta

10114
06:51:02,080 --> 06:51:05,200
vai usar a base e e nós apenas

10115
06:51:05,200 --> 06:51:08,320
viu que e é 2 para o poder de 7 ou

10116
06:51:08,320 --> 06:51:09,680
Algo vamos voltar para o nosso

10117
06:51:09,680 --> 06:51:12,558
Calculadora e ver se podemos ver isso

10118
06:51:12,558 --> 06:51:14,718
Por que não por que tentar adivinhar quando temos um

10119
06:51:14,718 --> 06:51:17,280
Boa calculadora em nossas mãos nós somos

10120
06:51:17,280 --> 06:51:20,080
usando a calculadora científica se nós

10121
06:51:20,080 --> 06:51:22,400
hit e aqui

10122
06:51:22,400 --> 06:51:24,400
Este é o valor da e

10123
06:51:24,400 --> 06:51:25,440
Tudo bem, então

10124
06:51:25,440 --> 06:51:27,040
Quando fazemos o log

10125
06:51:27,040 --> 06:51:29,360
Estamos basicamente perguntando para qual poder

10126
06:51:29,360 --> 06:51:31,760
Devemos levantar e

10127
06:51:31,760 --> 06:51:33,878
para que possamos conseguir isso

10128
06:51:33,878 --> 06:51:36,000
54.59 e a resposta será

10129
06:51:36,000 --> 06:51:38,478
Calculado e impresso aqui

10130
06:51:38,478 --> 06:51:41,120
Nós temos uma versão disso que está indo

10131
06:51:41,120 --> 06:51:44,320
para usar a base 10, então se usarmos isso

10132
06:51:44,320 --> 06:51:46,400
Estamos basicamente dizendo a qual poder

10133
06:51:46,400 --> 06:51:49,280
Devemos aumentar 10 para obter 10 000 e a

10134
06:51:49,280 --> 06:51:51,360
A resposta vai ser impressa aqui

10135
06:51:51,360 --> 06:51:53,760
e vai ser um quatro porque

10136
06:51:53,760 --> 06:51:57,040
Isso é fácil de fazer em sua mente, então vamos

10137
06:51:57,040 --> 06:52:00,320
executam isso, vamos construir a tarefa

10138
06:52:00,320 --> 06:52:02,718
Vamos executar a tarefa de construir

10139
06:52:02,718 --> 06:52:05,680
com gcc e vamos executar o nosso

10140
06:52:05,680 --> 06:52:08,240
programa e uh vamos conseguir o nosso

10141
06:52:08,240 --> 06:52:10,840
Saída aqui para obter

10142
06:52:10,840 --> 06:52:14,240
54.59 você elevaria e ao poder

10143
06:52:14,240 --> 06:52:16,958
Este número aqui é a resposta

10144
06:52:16,958 --> 06:52:18,638
e se você quiser você pode provar isso com

10145
06:52:18,638 --> 06:52:20,718
sua calculadora favorita que você vai

10146
06:52:20,718 --> 06:52:22,878
chegar algo perto disso para obter 10

10147
06:52:22,878 --> 06:52:25,040
000 Você precisaria elevar 10 para o

10148
06:52:25,040 --> 06:52:27,360
O poder de 4. é para isso que vamos

10149
06:52:27,360 --> 06:52:30,000
entrar aqui vamos imprimir isso de novo

10150
06:52:30,000 --> 06:52:32,558
Muitos erros arrependidos, mas espero que você tenha

10151
06:52:32,558 --> 06:52:35,600
O ponto se construirmos novamente para que

10152
06:52:35,600 --> 06:52:38,638
pode ver as coisas corretamente e correr que somos

10153
06:52:38,638 --> 06:52:40,958
obterá dados adequados e isso é

10154
06:52:40,958 --> 06:52:42,958
realmente o que esperávamos ter um

10155
06:52:42,958 --> 06:52:44,958
Mais algumas funções com as quais podemos jogar como

10156
06:52:44,958 --> 06:52:47,760
Vimos em nossos slides

10157
06:52:47,760 --> 06:52:51,360
Vamos brincar com a raiz quadrada e o std

10158
06:52:51,360 --> 06:52:53,440
A função redonda aqui vamos conseguir

10159
06:52:53,440 --> 06:52:56,000
A raiz quadrada de 81 que vamos conseguir

10160
06:52:56,000 --> 06:52:58,080
ele imprimiu para baixo e nós vamos ver

10161
06:52:58,080 --> 06:53:01,440
O que std round faz isso vai

10162
06:53:01,440 --> 06:53:05,200
fora de zero se estamos na metade

10163
06:53:05,200 --> 06:53:08,558
e se não estamos na metade do ponto se

10164
06:53:08,558 --> 06:53:10,240
Estamos abaixo que vamos dar a volta

10165
06:53:10,240 --> 06:53:12,958
para baixo se estamos mais alto do que isso nós somos

10166
06:53:12,958 --> 06:53:14,798
indo para round up nós vamos correr

10167
06:53:14,798 --> 06:53:16,958
para que você possa ver essa corrida

10168
06:53:16,958 --> 06:53:19,440
e nós vamos chamar o galo e

10169
06:53:19,440 --> 06:53:23,120
2.5 é arredondado para 3. 2.4 é arredondado para

10170
06:53:23,120 --> 06:53:26,478
2. 3.6 é arredondado para 4.

10171
06:53:26,478 --> 06:53:30,160
espera e a raiz quadrada de 81

10172
06:53:30,160 --> 06:53:32,878
é 9. isso é realmente tudo o que nos prossíncamos

10173
06:53:32,878 --> 06:53:35,680
fazer nesta palestra para brincar com alguns de

10174
06:53:35,680 --> 06:53:37,760
estes c função matemática

10175
06:53:37,760 --> 06:53:40,478
Eles não são realmente difíceis de usar quando você

10176
06:53:40,478 --> 06:53:43,680
ter o básico da matemática pregado e

10177
06:53:43,680 --> 06:53:46,080
novamente se você quiser verificar a lista completa

10178
06:53:46,080 --> 06:53:48,320
dessas funções, por favor, venham para o nosso

10179
06:53:48,320 --> 06:53:50,000
documentação de referência aqui você é

10180
06:53:50,000 --> 06:53:52,240
Vou encontrar muitos deles

10181
06:53:52,240 --> 06:53:54,798
e se você quiser ver como usar um de

10182
06:53:54,798 --> 06:53:57,600
estes, por exemplo, se você clicar em log 10

10183
06:53:57,600 --> 06:53:59,440
Aqui você vai vir aqui você está

10184
06:53:59,440 --> 06:54:00,958
Vou obter uma explicação para a

10185
06:54:00,958 --> 06:54:03,120
Função e melhor ainda você vai

10186
06:54:03,120 --> 06:54:05,360
descer e obter um bom pedaço de código você

10187
06:54:05,360 --> 06:54:08,000
pode brincar e realmente fazer sentido de

10188
06:54:08,000 --> 06:54:09,760
O que está acontecendo nessas funções

10189
06:54:09,760 --> 06:54:11,680
Aqui, isso é realmente tudo o que nos demos

10190
06:54:11,680 --> 06:54:13,200
Nesta palestra espero que você a tenha encontrado

10191
06:54:13,200 --> 06:54:15,360
interessante, vamos parar por aqui

10192
06:54:15,360 --> 06:54:17,280
Esta palestra é a próxima que vamos

10193
06:54:17,280 --> 06:54:21,040
Saiba mais sobre alguns tipos integrais estranhos

10194
06:54:21,040 --> 06:54:23,440
Vá em frente e termine aqui e me encontre

10195
06:54:23,440 --> 06:54:25,200
lá nesta palestra vamos

10196
06:54:25,200 --> 06:54:28,160
Saiba mais sobre alguns tipos integrais estranhos

10197
06:54:28,160 --> 06:54:30,958
e o que quero dizer com isso bem se você

10198
06:54:30,958 --> 06:54:33,680
olhar aqui tipos integrais menos de 4

10199
06:54:33,680 --> 06:54:36,240
bytes em tamanho não suporta aritmética

10200
06:54:36,240 --> 06:54:39,440
operações e estas são operações como

10201
06:54:39,440 --> 06:54:41,680
Multiplicação de subtração de adição

10202
06:54:41,680 --> 06:54:44,400
divisão em que você pode fazer essas operações

10203
06:54:44,400 --> 06:54:45,760
Esses tipos

10204
06:54:45,760 --> 06:54:48,400
E aqui tenho um exemplo de alguns

10205
06:54:48,400 --> 06:54:51,840
Esses tipos temos um carro é um byte

10206
06:54:51,840 --> 06:54:54,000
em tamanho e final curto

10207
06:54:54,000 --> 06:54:57,360
é dois bytes em tamanho na maioria dos processadores

10208
06:54:57,360 --> 06:55:00,400
então você não pode fazer operações aritméticas se

10209
06:55:00,400 --> 06:55:03,360
seu valor inteiro é armazenado nestes

10210
06:55:03,360 --> 06:55:04,638
Os tipos de tipos

10211
06:55:04,638 --> 06:55:06,958
por que isso tem a ver com

10212
06:55:06,958 --> 06:55:08,478
design do processador

10213
06:55:08,478 --> 06:55:11,040
e decidiram escolher e como

10214
06:55:11,040 --> 06:55:12,798
tipo menor

10215
06:55:12,798 --> 06:55:15,040
Tipo integral para o qual eles podem fazer

10216
06:55:15,040 --> 06:55:17,680
essas operações aritméticas, mas

10217
06:55:17,680 --> 06:55:19,760
Os compiladores são inteligentes o suficiente para

10218
06:55:19,760 --> 06:55:22,080
perceber se você está tentando fazer

10219
06:55:22,080 --> 06:55:24,718
operações aritméticas nestes tipos e

10220
06:55:24,718 --> 06:55:27,120
eles vão se converter implicitamente

10221
06:55:27,120 --> 06:55:28,320
A partir de

10222
06:55:28,320 --> 06:55:30,958
Estes tipos menores para terminar

10223
06:55:30,958 --> 06:55:32,400
E isso é algo que você precisa ser

10224
06:55:32,400 --> 06:55:35,760
Consciente se olharmos para este programa aqui

10225
06:55:35,760 --> 06:55:39,200
Por exemplo, temos var1 e var2 eles

10226
06:55:39,200 --> 06:55:42,240
são armazenados em variáveis que são do tipo

10227
06:55:42,240 --> 06:55:43,600
curto e

10228
06:55:43,600 --> 06:55:46,878
e nós temos var 3 var 4 que são armazenados

10229
06:55:46,878 --> 06:55:50,000
em uma variável do tipo carro podemos tentar e

10230
06:55:50,000 --> 06:55:52,320
imprimir os redimentos e nós vamos conseguir

10231
06:55:52,320 --> 06:55:54,878
Dois dois um para essas variáveis

10232
06:55:54,878 --> 06:55:57,200
Porque um fim curto

10233
06:55:57,200 --> 06:55:59,600
ocupa dois bytes na memória para o meu

10234
06:55:59,600 --> 06:56:02,240
computador aqui e o carro ocupa um

10235
06:56:02,240 --> 06:56:05,920
byte na memória, mas a captura é para baixo

10236
06:56:05,920 --> 06:56:06,878
aqui

10237
06:56:06,878 --> 06:56:08,878
Se você tentar adicioná-los

10238
06:56:08,878 --> 06:56:10,638
O resultado não vai ser o mesmo

10239
06:56:10,638 --> 06:56:13,440
digite como defesa você adicionou e você

10240
06:56:13,440 --> 06:56:14,798
Seria de esperar

10241
06:56:14,798 --> 06:56:15,840
Auto

10242
06:56:15,840 --> 06:56:19,040
para deduzir para o mesmo tipo que var um

10243
06:56:19,040 --> 06:56:20,400
e var2

10244
06:56:20,400 --> 06:56:22,798
e não é que o resort vai ser um

10245
06:56:22,798 --> 06:56:26,000
inteiro porque e é o menor tipo

10246
06:56:26,000 --> 06:56:27,920
para o qual podemos apoiar estes

10247
06:56:27,920 --> 06:56:30,638
operações aritméticas por isso, se imprimirmos o

10248
06:56:30,638 --> 06:56:32,558
tamanho do resultado um e reservado dois

10249
06:56:32,558 --> 06:56:34,958
nós vamos ter quatro, mas este é o

10250
06:56:34,958 --> 06:56:37,200
comportamento que você vai conseguir e nós precisamos

10251
06:56:37,200 --> 06:56:39,760
para estar ciente disso, o mesmo comportamento pode

10252
06:56:39,760 --> 06:56:42,320
ser observado em outros operadores que nós

10253
06:56:42,320 --> 06:56:44,798
terá a chance de olhar em alguns

10254
06:56:44,798 --> 06:56:47,200
capítulos à frente e estes são chamados

10255
06:56:47,200 --> 06:56:49,360
shift operadores que você os usa para mudar

10256
06:56:49,360 --> 06:56:51,680
Apostas, mas eu não quero mais falar

10257
06:56:51,680 --> 06:56:53,200
sobre eles porque nós vamos ter um

10258
06:56:53,200 --> 06:56:55,760
A chance de aprender sobre eles em detalhes

10259
06:56:55,760 --> 06:56:58,400
Ok agora é hora de ir para o visual

10260
06:56:58,400 --> 06:57:00,558
código de estúdio e realmente ver isso em

10261
06:57:00,558 --> 06:57:03,600
ação aqui estamos em nosso trabalho

10262
06:57:03,600 --> 06:57:05,680
diretório vamos copiar o nosso

10263
06:57:05,680 --> 06:57:07,680
projeto de template que vamos copiar

10264
06:57:07,680 --> 06:57:08,558
Isto é

10265
06:57:08,558 --> 06:57:12,638
Coloque isso rapidamente em nossa pasta em estranho

10266
06:57:12,638 --> 06:57:14,638
tipos integrais, este é o nosso atual

10267
06:57:14,638 --> 06:57:16,638
Projeto aqui e nós vamos abrir

10268
06:57:16,638 --> 06:57:18,638
isso no código do estúdio visual, nós somos

10269
06:57:18,638 --> 06:57:20,798
vamos abrir isso e nós vamos

10270
06:57:20,798 --> 06:57:23,520
abrir nosso arquivo principal de cpp remover o que for

10271
06:57:23,520 --> 06:57:25,760
É que não precisamos e vamos

10272
06:57:25,760 --> 06:57:28,320
colocar em nosso código isso deve ser muito

10273
06:57:28,320 --> 06:57:30,558
familiar porque é o que acabamos de ver

10274
06:57:30,558 --> 06:57:31,920
nos slides

10275
06:57:31,920 --> 06:57:34,558
Então o que estamos fazendo aqui temos quatro

10276
06:57:34,558 --> 06:57:36,798
variáveis var um e var dois são curtos

10277
06:57:36,798 --> 06:57:39,520
e assim estes vão levar dois bytes

10278
06:57:39,520 --> 06:57:43,040
na memória no meu computador aqui e uh carro

10279
06:57:43,040 --> 06:57:45,200
vai pegar um byte e nós estamos

10280
06:57:45,200 --> 06:57:46,798
vamos imprimir seus tamanhos, vamos

10281
06:57:46,798 --> 06:57:48,878
para vê-los impressos e nós somos

10282
06:57:48,878 --> 06:57:51,360
As coisas aqui estamos tomando dois

10283
06:57:51,360 --> 06:57:54,000
variáveis de extremidade curta e adicioná-las

10284
06:57:54,000 --> 06:57:56,160
Então o que o compilador vai fazer é

10285
06:57:56,160 --> 06:57:58,080
Vou tomar este transformá-lo em um fim

10286
06:57:58,080 --> 06:58:00,320
e, em seguida, fazer a adição e o resultado é

10287
06:58:00,320 --> 06:58:02,558
Vai acabar que a mesma história é

10288
06:58:02,558 --> 06:58:05,360
Vai acontecer para reservado 2 aqui

10289
06:58:05,360 --> 06:58:09,520
var 3 é um carro por isso é um byte em

10290
06:58:09,520 --> 06:58:12,160
memória, mas o compilador não pode realmente adicionar

10291
06:58:12,160 --> 06:58:14,878
em tipos integrais que são menores do que

10292
06:58:14,878 --> 06:58:17,280
Quatro bytes na memória, então o que vai

10293
06:58:17,280 --> 06:58:18,798
Acontece var 3 vai ser

10294
06:58:18,798 --> 06:58:22,160
Transformado implicitamente nos bastidores

10295
06:58:22,160 --> 06:58:24,878
para uma rede e var 4 vai ser

10296
06:58:24,878 --> 06:58:26,638
Transformado para uma rede e então nós somos

10297
06:58:26,638 --> 06:58:28,798
vamos somar isso e nós vamos

10298
06:58:28,798 --> 06:58:31,040
armazenar isso em uma variável limpa que é

10299
06:58:31,040 --> 06:58:32,478
Resort aqui

10300
06:58:32,478 --> 06:58:34,080
Se imprimirmos isso, vamos ver

10301
06:58:34,080 --> 06:58:37,280
esse tamanho do resultado 1 e resultado 2 é um

10302
06:58:37,280 --> 06:58:40,400
4 e isso é o que esperamos aqui e

10303
06:58:40,400 --> 06:58:42,558
Este é um comportamento que você precisa estar ciente

10304
06:58:42,558 --> 06:58:44,878
por vezes a sua aplicação

10305
06:58:44,878 --> 06:58:47,600
A lógica dependerá do tamanho de

10306
06:58:47,600 --> 06:58:50,080
dados se esse for o caso que você precisa se importar

10307
06:58:50,080 --> 06:58:51,120
sobre isso

10308
06:58:51,120 --> 06:58:52,638
E se você não sabe isso, você está indo

10309
06:58:52,638 --> 06:58:55,360
para ser batido por isso e é realmente

10310
06:58:55,360 --> 06:58:58,718
É difícil encontrar problemas como este

10311
06:58:58,718 --> 06:59:01,040
Então o que podemos fazer é abrir o nosso

10312
06:59:01,040 --> 06:59:03,600
terminal e vamos construir isso

10313
06:59:03,600 --> 06:59:06,478
com gcc como costumamos fazer e que

10314
06:59:06,478 --> 06:59:09,040
pode executar o nosso galo de programa e nós somos

10315
06:59:09,040 --> 06:59:10,958
Vou ver que isso é o que esperamos

10316
06:59:10,958 --> 06:59:14,478
var1 é dois bytes no tamanho var2 é dois

10317
06:59:14,478 --> 06:59:16,798
bytes em tamanho fio três e cachoeira

10318
06:59:16,798 --> 06:59:19,680
são um byte em tamanho, mas nosso resultado é

10319
06:59:19,680 --> 06:59:21,920
quatro bytes porque o compilador

10320
06:59:21,920 --> 06:59:24,080
implicitamente convertido

10321
06:59:24,080 --> 06:59:27,280
nossos operandos aqui para x para ser capaz de

10322
06:59:27,280 --> 06:59:30,160
realizar esta operação aritmética esta

10323
06:59:30,160 --> 06:59:31,600
é realmente tudo o que nós montamos para fazer nisso

10324
06:59:31,600 --> 06:59:34,000
Uma palestra espero que você tenha achado interessante

10325
06:59:34,000 --> 06:59:35,360
Vamos parar aqui neste

10326
06:59:35,360 --> 06:59:37,520
ensinar o próximo que vamos tentar

10327
06:59:37,520 --> 06:59:41,240
e recapitular o que vimos no capítulo

10328
06:59:41,240 --> 06:59:43,520
Parabéns pelo fim de

10329
06:59:43,520 --> 06:59:46,080
Este capítulo e este capítulo foi realmente

10330
06:59:46,080 --> 06:59:47,360
sobre

10331
06:59:47,360 --> 06:59:50,320
fazer operações e manipular o

10332
06:59:50,320 --> 06:59:53,040
dados que você armazenou em seu

10333
06:59:53,040 --> 06:59:55,280
variáveis a primeira coisa que vimos foi

10334
06:59:55,280 --> 06:59:57,920
que poderíamos fazer operações aritméticas

10335
06:59:57,920 --> 06:59:59,920
sobre os dados que podemos adicionar coisas

10336
06:59:59,920 --> 07:00:02,878
multiplicar a divisão também vimos o módulo

10337
07:00:02,878 --> 07:00:05,040
Operador que pode parecer estranho para

10338
07:00:05,040 --> 07:00:07,120
iniciantes, mas tivemos a chance de realmente

10339
07:00:07,120 --> 07:00:09,440
brincar conosco depois que aprendemos sobre

10340
07:00:09,440 --> 07:00:11,760
precedence e associatividade vimos que

10341
07:00:11,760 --> 07:00:13,760
Isso é um conjunto de regras

10342
07:00:13,760 --> 07:00:16,240
Temos que seguir para saber quais

10343
07:00:16,240 --> 07:00:18,558
Operação a fazer primeiro se tivermos

10344
07:00:18,558 --> 07:00:22,240
vários operadores em nossa expressão

10345
07:00:22,240 --> 07:00:24,718
também teve a chance de aprender sobre o prefixo

10346
07:00:24,718 --> 07:00:26,958
e incremento e decremento pósfix

10347
07:00:26,958 --> 07:00:29,360
operadores tivemos a chance de fazer compostos

10348
07:00:29,360 --> 07:00:32,478
atribuições coisas como mais igual menos

10349
07:00:32,478 --> 07:00:35,600
igual multiplicar igual módulo igual agora

10350
07:00:35,600 --> 07:00:37,840
Essas coisas devem fazer sentido para você

10351
07:00:37,840 --> 07:00:39,920
Tivemos a chance de ver como poderíamos

10352
07:00:39,920 --> 07:00:42,160
Compare as coisas usando relacional

10353
07:00:42,160 --> 07:00:45,120
operadores gostam mais do que menos do que

10354
07:00:45,120 --> 07:00:47,840
e igual ou não igual, também tivemos um

10355
07:00:47,840 --> 07:00:50,240
chance de olhar para a formatação de saída e

10356
07:00:50,240 --> 07:00:53,680
Vimos uma série de coisas que poderíamos fazer

10357
07:00:53,680 --> 07:00:57,360
fazer os dados aparecerem melhor com o sddc out

10358
07:00:57,360 --> 07:00:59,280
Depois disso aprendemos sobre numérico

10359
07:00:59,280 --> 07:01:02,080
limites e esta é uma maneira legal de saber

10360
07:01:02,080 --> 07:01:04,478
os intervalos para seus tipos de dados, mas

10361
07:01:04,478 --> 07:01:06,878
são uma série de outras propriedades que você pode

10362
07:01:06,878 --> 07:01:09,600
usar nesta biblioteca de limites que aprendemos a

10363
07:01:09,600 --> 07:01:11,600
Um pouco sobre funções matemáticas e nós

10364
07:01:11,600 --> 07:01:13,840
brincado com coisas como o poder de

10365
07:01:13,840 --> 07:01:16,798
Algo o Exposencial dos poucos

10366
07:01:16,798 --> 07:01:18,798
funções de arredondamento que temos no

10367
07:01:18,798 --> 07:01:21,360
cmat biblioteca e agora você deve ter um

10368
07:01:21,360 --> 07:01:24,160
Boa ideia sobre essas funções que você

10369
07:01:24,160 --> 07:01:26,400
pode usar para manipular e fazer matemática em

10370
07:01:26,400 --> 07:01:29,040
suas variáveis terminamos o capítulo por

10371
07:01:29,040 --> 07:01:32,240
olhando para alguns tipos integrais estranhos e

10372
07:01:32,240 --> 07:01:34,718
A mensagem principal nessa palestra foi

10373
07:01:34,718 --> 07:01:37,840
que você não pode fazer operações aritméticas

10374
07:01:37,840 --> 07:01:41,040
em tipos de dados cujo tamanho seja inferior a 4

10375
07:01:41,040 --> 07:01:43,440
bytes na memória se você tentar fazer isso

10376
07:01:43,440 --> 07:01:45,760
o compilador vai inserir

10377
07:01:45,760 --> 07:01:48,320
conversões implícitas e se você

10378
07:01:48,320 --> 07:01:50,718
A aplicação depende do tamanho de

10379
07:01:50,718 --> 07:01:51,840
Coisas

10380
07:01:51,840 --> 07:01:53,600
Isso é algo que você precisa ter cuidado

10381
07:01:53,600 --> 07:01:55,840
sobre o contrário você vai ter um

10382
07:01:55,840 --> 07:01:57,200
Tempo difícil

10383
07:01:57,200 --> 07:01:59,440
Encontrar esses problemas eu gostaria de

10384
07:01:59,440 --> 07:02:02,000
recebê-lo neste novo capítulo onde

10385
07:02:02,000 --> 07:02:04,320
Vamos aprender sobre um novo

10386
07:02:04,320 --> 07:02:06,718
Como podemos fazer as coisas em c plus plus e

10387
07:02:06,718 --> 07:02:09,200
nós vamos estar fazendo condicional

10388
07:02:09,200 --> 07:02:11,600
programação em outras palavras, estamos indo

10389
07:02:11,600 --> 07:02:14,638
para ser capaz de fazer coisas diferentes

10390
07:02:14,638 --> 07:02:17,200
Com base nas condições que estabelecemos

10391
07:02:17,200 --> 07:02:19,360
em nosso código apenas para lhe dar um

10392
07:02:19,360 --> 07:02:21,360
Exemplo aqui temos algumas variáveis

10393
07:02:21,360 --> 07:02:23,680
São booleans e temos alguns

10394
07:02:23,680 --> 07:02:26,558
inicializadores em lá vermelho é falso verde

10395
07:02:26,558 --> 07:02:29,040
é verdadeiro amarelo é falsa polícia parar

10396
07:02:29,040 --> 07:02:31,040
Verdadeiro e nós podemos fazer

10397
07:02:31,040 --> 07:02:33,760
Coisas diferentes baseadas na disciplina

10398
07:02:33,760 --> 07:02:35,600
As condições, por exemplo

10399
07:02:35,600 --> 07:02:38,558
Se a luz é vermelha, podemos ser

10400
07:02:38,558 --> 07:02:40,000
Dissedo para parar

10401
07:02:40,000 --> 07:02:42,320
Se a luz é amarela, podemos ser informados

10402
07:02:42,320 --> 07:02:44,958
para desacelerar se a luz é verde nós

10403
07:02:44,958 --> 07:02:47,440
Pode ser dito para ir e fazer o que quer que seja

10404
07:02:47,440 --> 07:02:49,200
É que nós queremos fazer isso nós vamos ser

10405
07:02:49,200 --> 07:02:51,600
capaz de fazer esses tipos de coisas e c

10406
07:02:51,600 --> 07:02:53,920
plus plus fornece diferentes construções

10407
07:02:53,920 --> 07:02:56,478
ser capaz de fazer programação condicional

10408
07:02:56,478 --> 07:02:57,600
em uc

10409
07:02:57,600 --> 07:03:00,080
Código temos apenas um deles neste

10410
07:03:00,080 --> 07:03:02,958
slide qual é este se a declaração aqui

10411
07:03:02,958 --> 07:03:05,600
se a palavra-chave permitir que você faça as coisas

10412
07:03:05,600 --> 07:03:07,840
Como este temos alguns outros que temos

10413
07:03:07,840 --> 07:03:09,760
A palavra-chave que temos o switch

10414
07:03:09,760 --> 07:03:12,558
palavra-chave também temos um completamente

10415
07:03:12,558 --> 07:03:15,600
operador separado que é chamado ternário

10416
07:03:15,600 --> 07:03:18,080
Operador que permite que você faça isso

10417
07:03:18,080 --> 07:03:19,680
Tipos de coisas e nós vamos ser

10418
07:03:19,680 --> 07:03:22,080
Aprendendo sobre todas essas coisas e muito mais

10419
07:03:22,080 --> 07:03:24,000
Neste capítulo vamos começar

10420
07:03:24,000 --> 07:03:26,240
e aprender sobre a declaração se no

10421
07:03:26,240 --> 07:03:27,520
A próxima palestra

10422
07:03:27,520 --> 07:03:29,840
Vá em frente e termine aqui e me encontre

10423
07:03:29,840 --> 07:03:30,638
lá

10424
07:03:30,638 --> 07:03:32,080
Nesta palestra vamos aprender

10425
07:03:32,080 --> 07:03:34,798
sobre a declaração se e isso é um

10426
07:03:34,798 --> 07:03:36,878
declaração que vai permitir que você

10427
07:03:36,878 --> 07:03:39,680
fazer as coisas com base em alguma condição ser

10428
07:03:39,680 --> 07:03:40,558
Verdadeiro

10429
07:03:40,558 --> 07:03:43,680
ou falso aqui é um simples exemplo de código

10430
07:03:43,680 --> 07:03:45,440
temos duas variáveis número um e

10431
07:03:45,440 --> 07:03:46,558
O número dois

10432
07:03:46,558 --> 07:03:48,798
e temos uma declaração aqui que é

10433
07:03:48,798 --> 07:03:51,280
Vou comparar o número um e o número

10434
07:03:51,280 --> 07:03:53,680
Dois e vamos guardar o resultado

10435
07:03:53,680 --> 07:03:56,478
Nesta variável booleana

10436
07:03:56,478 --> 07:03:58,320
que temos à esquerda, então estamos

10437
07:03:58,320 --> 07:04:01,040
Vai fazer algo baseado no valor

10438
07:04:01,040 --> 07:04:04,160
que estamos armazenando neste resultado aqui

10439
07:04:04,160 --> 07:04:05,840
Se o resultado lá é verdade, nós somos

10440
07:04:05,840 --> 07:04:07,200
indo para imprimir

10441
07:04:07,200 --> 07:04:09,760
O número um é menor que o número dois se

10442
07:04:09,760 --> 07:04:11,600
O resultado não é verdade que vamos

10443
07:04:11,600 --> 07:04:14,478
Digamos que o número um não é menor do que

10444
07:04:14,478 --> 07:04:17,520
número dois e note no primeiro se

10445
07:04:17,520 --> 07:04:20,240
próximo ano estamos testando para o caso

10446
07:04:20,240 --> 07:04:23,280
onde o resultado é verdadeiro, mas às vezes

10447
07:04:23,280 --> 07:04:25,520
Precisamos fazer algo quando isso

10448
07:04:25,520 --> 07:04:28,558
A condição aqui não é verdadeira uma maneira de fazer

10449
07:04:28,558 --> 07:04:31,040
Isso é negar o que temos aqui

10450
07:04:31,040 --> 07:04:34,160
dentro do parêntese e teste para

10451
07:04:34,160 --> 07:04:37,280
o inverso de tudo o que temos aqui

10452
07:04:37,280 --> 07:04:39,600
Se isso está fazendo algum sentido se você olhar

10453
07:04:39,600 --> 07:04:42,320
Aqui estamos testando o caso em que

10454
07:04:42,320 --> 07:04:45,760
Se não o resultado é um verdadeiro e no outro

10455
07:04:45,760 --> 07:04:47,760
palavras que estamos testando para o caso em que

10456
07:04:47,760 --> 07:04:50,000
O resultado aqui é falso e nós vamos

10457
07:04:50,000 --> 07:04:52,878
dizer que o número um não é menor do que

10458
07:04:52,878 --> 07:04:54,718
O número dois é um caminho que podemos seguir

10459
07:04:54,718 --> 07:04:57,280
Mais uma vez, sobre isso, se a declaração é

10460
07:04:57,280 --> 07:04:59,600
usado para fazer programação condicional este

10461
07:04:59,600 --> 07:05:01,840
é a sintaxe que usamos para fazê-lo em c plus

10462
07:05:01,840 --> 07:05:04,160
Além disso, dizemos que se colocamos um conjunto de

10463
07:05:04,160 --> 07:05:06,958
parênteses e dentro do parêntese

10464
07:05:06,958 --> 07:05:10,000
Colocamos a condição para a qual queremos testar

10465
07:05:10,000 --> 07:05:11,760
E depois disso vamos ter um

10466
07:05:11,760 --> 07:05:14,718
par de chaves encaracoladas e o que temos

10467
07:05:14,718 --> 07:05:17,360
Dentro destes cintas encaracolados vai ser

10468
07:05:17,360 --> 07:05:20,878
O corpo da nossa afirmação e é

10469
07:05:20,878 --> 07:05:22,958
basicamente será o código que queremos

10470
07:05:22,958 --> 07:05:26,558
para correr se o teste aqui for bem-sucedido

10471
07:05:26,558 --> 07:05:28,878
também pode usar uma outra cláusula para pegar o

10472
07:05:28,878 --> 07:05:31,280
Caso em que o teste não foi

10473
07:05:31,280 --> 07:05:33,760
neste caso podemos dizer se

10474
07:05:33,760 --> 07:05:35,920
resultado é verdade que vamos fazer

10475
07:05:35,920 --> 07:05:37,120
alguma coisa

10476
07:05:37,120 --> 07:05:39,760
E então nós vamos fazer alguma coisa

10477
07:05:39,760 --> 07:05:42,240
Em outras palavras, se a pesquisa é verdadeira

10478
07:05:42,240 --> 07:05:44,798
nós vamos dizer que é menos do que se for

10479
07:05:44,798 --> 07:05:46,878
Não é verdade, vamos dizer que não é menos

10480
07:05:46,878 --> 07:05:49,360
do que e esta é uma forma mais compacta de

10481
07:05:49,360 --> 07:05:52,638
Fazendo o que acabamos de fazer no slide aqui

10482
07:05:52,638 --> 07:05:54,718
Você também pode usar diretamente o seu

10483
07:05:54,718 --> 07:05:57,680
expressão como condição e

10484
07:05:57,680 --> 07:06:00,558
A exigência aqui é que a expressão

10485
07:06:00,558 --> 07:06:03,360
Avalia para algo que podemos tratar

10486
07:06:03,360 --> 07:06:05,680
como um booleano porque a condição tem

10487
07:06:05,680 --> 07:06:08,320
Para ser um booleano, tem que ser verdade ou

10488
07:06:08,320 --> 07:06:10,478
false OK aqui é outro simples

10489
07:06:10,478 --> 07:06:12,320
O exemplo temos visto isso no último

10490
07:06:12,320 --> 07:06:14,878
palestra, temos algumas variáveis

10491
07:06:14,878 --> 07:06:18,000
contendo nossas condições e nós somos

10492
07:06:18,000 --> 07:06:20,798
dizendo se a luz é vermelha, por exemplo

10493
07:06:20,798 --> 07:06:22,400
nós vamos fazer alguma coisa se for

10494
07:06:22,400 --> 07:06:24,240
amarelo, vamos fazer alguma coisa se

10495
07:06:24,240 --> 07:06:26,400
É verde, vamos fazer alguma coisa

10496
07:06:26,400 --> 07:06:29,440
Podemos também aninhar condições, por exemplo

10497
07:06:29,440 --> 07:06:32,320
Podemos colocar o nosso exterior

10498
07:06:32,320 --> 07:06:34,878
se declaração e dentro disso se

10499
07:06:34,878 --> 07:06:38,000
declaração configurando outras declarações se e

10500
07:06:38,000 --> 07:06:40,718
Se a nossa lógica precisa de algo assim

10501
07:06:40,718 --> 07:06:42,320
você pode fazer isso e você pode tomar

10502
07:06:42,320 --> 07:06:44,400
vantagem disso para conseguir o que quer que seja

10503
07:06:44,400 --> 07:06:46,718
Você quer fazer neste caso, se o

10504
07:06:46,718 --> 07:06:48,400
A luz é verde, nós vamos

10505
07:06:48,400 --> 07:06:50,160
cair aqui e nós vamos fazer

10506
07:06:50,160 --> 07:06:52,000
Outra condição se a luz é

10507
07:06:52,000 --> 07:06:54,718
verde e se o policial tem

10508
07:06:54,718 --> 07:06:57,040
Parou você você vai parar e se

10509
07:06:57,040 --> 07:06:58,638
Eles não pararam você que você vai

10510
07:06:58,638 --> 07:07:00,718
Vai porque a luz é verde e você

10511
07:07:00,718 --> 07:07:02,558
Pode fazer algo assim

10512
07:07:02,558 --> 07:07:04,718
também podemos usar operadores lógicos para

10513
07:07:04,718 --> 07:07:06,958
tipo de alcançar a mesma coisa e nós

10514
07:07:06,958 --> 07:07:09,920
Diga se a luz é verde e a polícia

10515
07:07:09,920 --> 07:07:11,600
O oficial não te impediu de ir

10516
07:07:11,600 --> 07:07:14,320
Para ir mais você vai parar e você

10517
07:07:14,320 --> 07:07:16,320
Pode fazer algo assim e você vê

10518
07:07:16,320 --> 07:07:18,478
que você pode combinar a lógica

10519
07:07:18,478 --> 07:07:21,360
operadores que aprendemos com o

10520
07:07:21,360 --> 07:07:23,360
técnicas de programação condicional que nós

10521
07:07:23,360 --> 07:07:25,520
estão aprendendo aqui para fazer realmente

10522
07:07:25,520 --> 07:07:27,120
Coisas poderosas e nós vamos ser

10523
07:07:27,120 --> 07:07:29,520
Fazendo isso em todo o lugar no

10524
07:07:29,520 --> 07:07:31,760
curso, então vamos nos dirigir para

10525
07:07:31,760 --> 07:07:34,240
código de estúdio visual e jogar conosco aqui

10526
07:07:34,240 --> 07:07:36,798
Estamos em nosso diretório de trabalho, estamos

10527
07:07:36,798 --> 07:07:39,600
vai trabalhar sobre se declarações e

10528
07:07:39,600 --> 07:07:42,638
Vamos pegar nosso projeto de modelo

10529
07:07:42,638 --> 07:07:45,120
Os arquivos de modelo eu deveria dizer e

10530
07:07:45,120 --> 07:07:47,360
nós vamos colocá-los aqui

10531
07:07:47,360 --> 07:07:49,120
E nós vamos abrir isso para dentro

10532
07:07:49,120 --> 07:07:51,600
código de estúdio visual como sempre fazemos

10533
07:07:51,600 --> 07:07:54,080
Vamos fazer essa pasta aberta e devemos

10534
07:07:54,080 --> 07:07:57,200
cair aqui e abrir o nosso arquivo cpp principal

10535
07:07:57,200 --> 07:07:59,200
Vamos fazer o habitual e remover o que nós

10536
07:07:59,200 --> 07:08:00,478
Não precisa de

10537
07:08:00,478 --> 07:08:02,798
e nós vamos colocar em nosso código assim

10538
07:08:02,798 --> 07:08:04,798
que nós podemos realmente brincar com a gente que temos

10539
07:08:04,798 --> 07:08:07,040
duas variáveis aqui no número um e

10540
07:08:07,040 --> 07:08:09,840
número dois eles são inteiros e nós temos

10541
07:08:09,840 --> 07:08:14,240
os valores 55 e 60 dentro podemos fazer

10542
07:08:14,240 --> 07:08:16,958
Comparação entre essas duas variáveis

10543
07:08:16,958 --> 07:08:18,958
e o que essa comparação vai fazer

10544
07:08:18,958 --> 07:08:22,000
O rendimento é um valor booleano que nós somos

10545
07:08:22,000 --> 07:08:24,558
indo para armazenar em nossa variável booleana

10546
07:08:24,558 --> 07:08:26,638
Aqui, o que é chamado de resultado

10547
07:08:26,638 --> 07:08:29,200
e o que podemos fazer é usar isso para fazer

10548
07:08:29,200 --> 07:08:31,360
alguma programação condicional, então nós somos

10549
07:08:31,360 --> 07:08:33,280
Vamos dizer se o resultado é verdadeiro, nós somos

10550
07:08:33,280 --> 07:08:35,760
Vou fazer alguma coisa e se for o resultado

10551
07:08:35,760 --> 07:08:38,080
Não é verdade que vamos fazer alguma coisa

10552
07:08:38,080 --> 07:08:40,558
E é assim que dizemos isso

10553
07:08:40,558 --> 07:08:43,440
A sintaxe aqui pode ser confusa para o novo

10554
07:08:43,440 --> 07:08:47,040
estudantes, mas tente pensar nisso se não

10555
07:08:47,040 --> 07:08:49,520
A pesquisa é verdadeira e isso é realmente o

10556
07:08:49,520 --> 07:08:53,040
A mesma coisa como dizer se o resultado é falso

10557
07:08:53,040 --> 07:08:55,040
Tente transmitir isso em sua mente um pouco

10558
07:08:55,040 --> 07:08:56,240
Um pouco e você realmente vai

10559
07:08:56,240 --> 07:08:58,320
Entente bem, então agora que você tem

10560
07:08:58,320 --> 07:09:00,320
Vi este pedaço de código

10561
07:09:00,320 --> 07:09:01,600
Tente tentar

10562
07:09:01,600 --> 07:09:03,600
Adivinho o que vamos ver se corremos

10563
07:09:03,600 --> 07:09:05,280
Isso o que vamos ver no

10564
07:09:05,280 --> 07:09:07,920
console OK dar-lhe uma tentativa, então nós somos

10565
07:09:07,920 --> 07:09:10,000
indo para executar isso em código de estúdio visual

10566
07:09:10,000 --> 07:09:12,320
Vamos abrir um terminal primeiro

10567
07:09:12,320 --> 07:09:14,958
e nós vamos para o mundo com gcc como nós

10568
07:09:14,958 --> 07:09:16,320
Sempre faça

10569
07:09:16,320 --> 07:09:17,840
nós vamos trazer isso um pouco

10570
07:09:17,840 --> 07:09:20,320
Um pouco para que tenhamos algum espaço para respirar

10571
07:09:20,320 --> 07:09:22,478
e nós vamos correr o galo, vamos ver

10572
07:09:22,478 --> 07:09:24,320
O que temos aqui nós reservamos

10573
07:09:24,320 --> 07:09:27,280
é verdade e isso vem disso

10574
07:09:27,280 --> 07:09:28,798
Declaração aqui

10575
07:09:28,798 --> 07:09:32,000
e temos a declaração independente se

10576
07:09:32,000 --> 07:09:34,080
que está vindo de

10577
07:09:34,080 --> 07:09:36,878
Aqui e temos a nossa carne disto

10578
07:09:36,878 --> 07:09:39,440
programa no que realmente estamos interessados

10579
07:09:39,440 --> 07:09:43,840
temos 55 é menos de 60. então nosso teste

10580
07:09:43,840 --> 07:09:47,120
Aqui foi bem sucedido e nós caímos neste corpo

10581
07:09:47,120 --> 07:09:50,718
e executou esta declaração sddc para fora

10582
07:09:50,718 --> 07:09:52,958
É por isso que estamos dizendo que o número um é

10583
07:09:52,958 --> 07:09:54,080
Menos do que

10584
07:09:54,080 --> 07:09:56,878
O número dois e o número um é 55, que é

10585
07:09:56,878 --> 07:10:00,240
O que vemos aqui e o número dois é 60

10586
07:10:00,240 --> 07:10:02,478
Que é o que estamos vendo aqui

10587
07:10:02,478 --> 07:10:05,520
O que podemos fazer para fazer

10588
07:10:05,520 --> 07:10:08,320
A segunda declaração aqui executa você

10589
07:10:08,320 --> 07:10:11,040
Saiba que está testando o caso em que

10590
07:10:11,040 --> 07:10:13,520
Não é verdade o resultado, então vai

10591
07:10:13,520 --> 07:10:16,160
Exatamente fazer o inverso do que este teste

10592
07:10:16,160 --> 07:10:17,520
Aqui está fazendo

10593
07:10:17,520 --> 07:10:19,680
E se isso falhar, este vai

10594
07:10:19,680 --> 07:10:22,160
ter sucesso, que é o que temos agora

10595
07:10:22,160 --> 07:10:23,760
O que podemos fazer para realmente brincar com isso

10596
07:10:23,760 --> 07:10:26,718
Podemos subir e mudar, por exemplo

10597
07:10:26,718 --> 07:10:29,200
Número um a 65

10598
07:10:29,200 --> 07:10:31,600
Isso vai virar a ordem destes

10599
07:10:31,600 --> 07:10:34,160
números se eu posso dizer assim e se

10600
07:10:34,160 --> 07:10:37,440
nós o executamos, vamos construir com gcc

10601
07:10:37,440 --> 07:10:39,040
e correr isso

10602
07:10:39,040 --> 07:10:42,240
nós vamos ver que resultado é falso, então

10603
07:10:42,240 --> 07:10:45,200
O resultado tornou-se falso porque o número um

10604
07:10:45,200 --> 07:10:47,520
Não é menos que o número dois, então isso é

10605
07:10:47,520 --> 07:10:50,878
Vai ser falso e o teste aqui é

10606
07:10:50,878 --> 07:10:53,120
O resultado do fracasso não é verdade,

10607
07:10:53,120 --> 07:10:56,000
nós não vamos entrar aqui e olhar

10608
07:10:56,000 --> 07:10:59,040
Aqui, se não, o resultado é verdade,

10609
07:10:59,040 --> 07:11:01,040
A pesquisa é verdadeira é falsa

10610
07:11:01,040 --> 07:11:03,360
Se negarmos isso, isso vai

10611
07:11:03,360 --> 07:11:06,080
tornar-se verdadeiro e este teste aqui está indo

10612
07:11:06,080 --> 07:11:08,478
para ter sucesso e nós vamos cair em

10613
07:11:08,478 --> 07:11:10,798
Aqui, tome algum tempo para realmente entender

10614
07:11:10,798 --> 07:11:13,040
Isso e se você tiver um problema, pergunte-me eu

10615
07:11:13,040 --> 07:11:14,878
Vou fazer o melhor que posso para ajudar

10616
07:11:14,878 --> 07:11:17,200
Você sai, mas certifique-se de entender

10617
07:11:17,200 --> 07:11:19,680
porque isso é realmente fundamental

10618
07:11:19,680 --> 07:11:22,000
em sua jornada como desenvolvedor de software

10619
07:11:22,000 --> 07:11:24,878
não apenas em c plus mais qualquer carreira como um

10620
07:11:24,878 --> 07:11:26,558
desenvolvedor de software que você vai precisar

10621
07:11:26,558 --> 07:11:28,718
para entender isso está bem o que estamos indo

10622
07:11:28,718 --> 07:11:31,040
O fazer é comentar

10623
07:11:31,040 --> 07:11:32,718
O que acabamos de fazer aqui porque estamos

10624
07:11:32,718 --> 07:11:34,638
Vou ver outra maneira de fazer isso e

10625
07:11:34,638 --> 07:11:37,120
Nós não queremos ter saída de ruído em

10626
07:11:37,120 --> 07:11:39,440
Nosso terminal vai fazer

10627
07:11:39,440 --> 07:11:42,080
Coisas difíceis para nós ver o que somos

10628
07:11:42,080 --> 07:11:43,360
Vou fazer isso

10629
07:11:43,360 --> 07:11:45,120
nós vamos descer aqui e colocar

10630
07:11:45,120 --> 07:11:47,600
em outro pedaço de código e

10631
07:11:47,600 --> 07:11:49,920
O resultado foi comentado fora que não

10632
07:11:49,920 --> 07:11:51,360
Quero comentar isso para que vamos

10633
07:11:51,360 --> 07:11:53,200
para tirar isso porque este é nosso

10634
07:11:53,200 --> 07:11:55,600
condição que nós vamos agarrá-lo e colocar

10635
07:11:55,600 --> 07:11:58,400
que fora da nossa seção de comentários este é

10636
07:11:58,400 --> 07:12:00,718
indo fazer e se nós descermos de novo

10637
07:12:00,718 --> 07:12:02,958
vamos clicar neste ícone do arquivo

10638
07:12:02,958 --> 07:12:05,040
E uh dar-nos um pouco mais

10639
07:12:05,040 --> 07:12:06,798
Sala de estar aqui não precisamos

10640
07:12:06,798 --> 07:12:09,360
para ver esse arquivo cpp principal de qualquer maneira

10641
07:12:09,360 --> 07:12:11,520
Então, se viermos aqui, podemos usar a outra vez

10642
07:12:11,520 --> 07:12:12,478
A cláusula

10643
07:12:12,478 --> 07:12:14,958
para testar o caso onde nossa condição

10644
07:12:14,958 --> 07:12:15,920
Falha

10645
07:12:15,920 --> 07:12:18,160
E se você olhar aqui nós somos essencialmente

10646
07:12:18,160 --> 07:12:20,160
dizendo a mesma coisa que estamos dizendo se

10647
07:12:20,160 --> 07:12:22,558
O resultado é verdade que vamos cair

10648
07:12:22,558 --> 07:12:25,520
Aqui e então nós vamos cair

10649
07:12:25,520 --> 07:12:27,840
Aqui para que não precisemos fazer o duplo

10650
07:12:27,840 --> 07:12:30,240
se declarações que acabamos de fazer

10651
07:12:30,240 --> 07:12:32,798
Aqui e isso é muito mais compacto e

10652
07:12:32,798 --> 07:12:34,798
Fácil de ler, vamos olhar novamente para o

10653
07:12:34,798 --> 07:12:37,040
Os números que temos aqui número um é 65

10654
07:12:37,040 --> 07:12:39,760
O número 2 é 60. esta expressão aqui é

10655
07:12:39,760 --> 07:12:43,360
Será falso porque 65 não é menos

10656
07:12:43,360 --> 07:12:45,840
do que 60 nós vamos ter um falso em

10657
07:12:45,840 --> 07:12:48,400
Aqui e se descermos

10658
07:12:48,400 --> 07:12:50,160
O resultado vai ser falso, isto é

10659
07:12:50,160 --> 07:12:52,320
vamos falhar e nós vamos cair

10660
07:12:52,320 --> 07:12:54,478
Aqui em baixo nós vamos dizer

10661
07:12:54,478 --> 07:12:55,840
Número um

10662
07:12:55,840 --> 07:12:59,840
ou 65 não é inferior a 60, que é o que

10663
07:12:59,840 --> 07:13:02,638
Temos em nossos valores, então vamos

10664
07:13:02,638 --> 07:13:04,958
construir isso de novo e vamos correr

10665
07:13:04,958 --> 07:13:06,878
galo que é claro para que tenhamos

10666
07:13:06,878 --> 07:13:08,478
algum espaço para respirar, vamos correr

10667
07:13:08,478 --> 07:13:11,520
Galo e você vai ver isso 65

10668
07:13:11,520 --> 07:13:13,200
Não é menos do que

10669
07:13:13,200 --> 07:13:15,760
60 que é o que esperamos novamente se você

10670
07:13:15,760 --> 07:13:17,680
subir e mudar esses números para

10671
07:13:17,680 --> 07:13:19,920
O que você quiser tentar mudar isso

10672
07:13:19,920 --> 07:13:22,638
números para valores diferentes para ver o que

10673
07:13:22,638 --> 07:13:25,600
Você obtém como saída se fizermos isso, nós somos

10674
07:13:25,600 --> 07:13:27,280
Vou ver que o número um é menor

10675
07:13:27,280 --> 07:13:30,000
do que 60, então isso vai ser verdade

10676
07:13:30,000 --> 07:13:31,840
e nós vamos ter um verdadeiro nisso

10677
07:13:31,840 --> 07:13:34,558
resultado variável aqui se descermos

10678
07:13:34,558 --> 07:13:37,200
O resultado é verdadeiro esta condição de teste aqui

10679
07:13:37,200 --> 07:13:39,360
vai ter sucesso e nós vamos

10680
07:13:39,360 --> 07:13:42,160
cair aqui vamos clicar em nosso terminal

10681
07:13:42,160 --> 07:13:44,000
e hit enter nós vamos correr galo

10682
07:13:44,000 --> 07:13:46,798
Vamos ver que 55 é menos de 60

10683
07:13:46,798 --> 07:13:49,120
que é o que temos aqui ok agora eu

10684
07:13:49,120 --> 07:13:51,200
Espero que você tenha uma ideia melhor de como você

10685
07:13:51,200 --> 07:13:54,160
pode usar o outro perto de fazer você se

10686
07:13:54,160 --> 07:13:56,160
Declarações realmente compactas e isso é

10687
07:13:56,160 --> 07:13:58,320
muito legal ok, outra coisa que eu quero

10688
07:13:58,320 --> 07:14:00,400
Você ver é que você pode

10689
07:14:00,400 --> 07:14:03,200
não passar por uma variável como esta e

10690
07:14:03,200 --> 07:14:05,760
Usar uma expressão como condição

10691
07:14:05,760 --> 07:14:07,680
diretamente c plus plus permite que você faça

10692
07:14:07,680 --> 07:14:09,280
Então o que vamos fazer nós somos

10693
07:14:09,280 --> 07:14:11,360
Vou comentar o que acabamos de fazer

10694
07:14:11,360 --> 07:14:13,600
Vamos fazer isso eu vou usar um bloco

10695
07:14:13,600 --> 07:14:15,600
comentário Espero que você saiba como usar isso

10696
07:14:15,600 --> 07:14:16,558
Já

10697
07:14:16,558 --> 07:14:18,478
e nós vamos descer e colocar

10698
07:14:18,478 --> 07:14:21,040
nosso código é exatamente a mesma coisa

10699
07:14:21,040 --> 07:14:23,520
Mas nós tomamos a expressão e colocamos isso

10700
07:14:23,520 --> 07:14:25,920
no lugar da nossa condição variável

10701
07:14:25,920 --> 07:14:28,718
aqui porque isso vai avaliar

10702
07:14:28,718 --> 07:14:31,120
para um booleano de qualquer maneira para que possamos usar isso

10703
07:14:31,120 --> 07:14:33,440
como condição e isso é algo

10704
07:14:33,440 --> 07:14:36,478
muito legal para fazer em c plus plus então se nós

10705
07:14:36,478 --> 07:14:38,160
correr isso nós vamos ver vamos ver

10706
07:14:38,160 --> 07:14:39,680
O que temos nos números que tenho

10707
07:14:39,680 --> 07:14:40,878
Esquecido

10708
07:14:40,878 --> 07:14:44,798
Agora, então 55 número um sessenta número dois

10709
07:14:44,798 --> 07:14:46,638
O número um é menor que o número dois.

10710
07:14:46,638 --> 07:14:48,320
Vai ser verdade

10711
07:14:48,320 --> 07:14:51,040
Então o teste aqui vai ter sucesso e

10712
07:14:51,040 --> 07:14:52,558
nós vamos cair aqui que é isso

10713
07:14:52,558 --> 07:14:55,120
nós vamos dizer que nós vamos soldar

10714
07:14:55,120 --> 07:14:57,520
com gcc como de costume

10715
07:14:57,520 --> 07:15:01,280
e eu vou limpar e correr galo

10716
07:15:01,280 --> 07:15:02,798
e você vai ver que este é o

10717
07:15:02,798 --> 07:15:05,120
saída que esperamos se mudarmos para cima

10718
07:15:05,120 --> 07:15:07,040
números novamente, vamos pegar e fazer

10719
07:15:07,040 --> 07:15:10,718
75 número um, então número um

10720
07:15:10,718 --> 07:15:12,638
É menos do que o número dois vai

10721
07:15:12,638 --> 07:15:15,600
avaliar para falso o teste aqui está indo

10722
07:15:15,600 --> 07:15:18,478
para falhar e nós vamos cair nisso

10723
07:15:18,478 --> 07:15:20,160
Bloco aqui nós vamos cair no

10724
07:15:20,160 --> 07:15:23,520
mais perto do nosso teste aqui estamos indo

10725
07:15:23,520 --> 07:15:24,478
para dizer

10726
07:15:24,478 --> 07:15:27,280
75 não é menos do que

10727
07:15:27,280 --> 07:15:29,600
55 é que o que temos lá é um

10728
07:15:29,600 --> 07:15:32,080
60 mas este bloco aqui vai

10729
07:15:32,080 --> 07:15:34,240
Executar isso é a coisa mais importante

10730
07:15:34,240 --> 07:15:36,080
Então nós vamos executar isso e nós somos

10731
07:15:36,080 --> 07:15:39,360
indo para tentar limpar e correr galo

10732
07:15:39,360 --> 07:15:41,520
nós vamos conseguir o que esperamos

10733
07:15:41,520 --> 07:15:43,600
É uma maneira de fazer isso e é

10734
07:15:43,600 --> 07:15:46,000
muito legal vamos comentar isso e

10735
07:15:46,000 --> 07:15:48,878
Veja outro exemplo e se cairmos

10736
07:15:48,878 --> 07:15:50,240
Pode ver

10737
07:15:50,240 --> 07:15:52,958
o exemplo que vimos nos slides que

10738
07:15:52,958 --> 07:15:56,798
estava usando verde vermelho e

10739
07:15:56,798 --> 07:15:57,920
amarelo

10740
07:15:57,920 --> 07:16:00,558
para simular um semáforo

10741
07:16:00,558 --> 07:16:02,958
Então o que realmente queremos ver aqui é

10742
07:16:02,958 --> 07:16:05,200
que nós podemos ninho coisas, mas antes de fazer

10743
07:16:05,200 --> 07:16:06,718
que precisamos

10744
07:16:06,718 --> 07:16:08,878
Tente usar essas condições porque

10745
07:16:08,878 --> 07:16:11,840
é apenas divertido, então se o vermelho é verdadeiro significado

10746
07:16:11,840 --> 07:16:14,718
que a luz vermelha está acesa nós vamos

10747
07:16:14,718 --> 07:16:16,718
parar se amarelo é verdade, vamos

10748
07:16:16,718 --> 07:16:19,040
Desacelere se o verde for verdade, estamos indo

10749
07:16:19,040 --> 07:16:20,160
para ir

10750
07:16:20,160 --> 07:16:23,040
E se olharmos para o que temos aqui

10751
07:16:23,040 --> 07:16:26,240
O vermelho é falso é verdadeiro falso é verdadeiro

10752
07:16:26,240 --> 07:16:28,638
e uma parada da polícia é a verdadeira parada da polícia é

10753
07:16:28,638 --> 07:16:30,878
Não ser usado, então o verde é verdadeiro

10754
07:16:30,878 --> 07:16:32,958
Vamos executar o verde

10755
07:16:32,958 --> 07:16:35,200
Declaração aqui e nós vamos dizer ir

10756
07:16:35,200 --> 07:16:37,200
Isso é o que vamos dizer vamos tentar

10757
07:16:37,200 --> 07:16:38,798
e correr isso

10758
07:16:38,798 --> 07:16:41,280
Vamos construir com gcc

10759
07:16:41,280 --> 07:16:43,040
trazer isso um pouco para que nós

10760
07:16:43,040 --> 07:16:45,200
ter algum espaço para respirar

10761
07:16:45,200 --> 07:16:47,360
E nós vamos limpar

10762
07:16:47,360 --> 07:16:49,920
e correr o galo e você vê que é

10763
07:16:49,920 --> 07:16:50,878
Dizendo

10764
07:16:50,878 --> 07:16:53,600
ir aqui você pode tentar e mudar estes

10765
07:16:53,600 --> 07:16:56,240
Variáveis booleanas para diferentes coisas

10766
07:16:56,240 --> 07:16:58,478
e veja o que está impresso aqui, isso é

10767
07:16:58,478 --> 07:17:00,958
uma ótima maneira de aprender, mas o que realmente

10768
07:17:00,958 --> 07:17:02,638
Quero tentar aqui

10769
07:17:02,638 --> 07:17:05,200
são declarações aninhadas e vamos cair

10770
07:17:05,200 --> 07:17:07,760
E fazer isso bem novamente, não queremos

10771
07:17:07,760 --> 07:17:09,920
O que temos no topo aqui para nos incomodar

10772
07:17:09,920 --> 07:17:11,600
Então nós vamos para

10773
07:17:11,600 --> 07:17:14,398
Comente isso e nós vamos embora

10774
07:17:14,398 --> 07:17:17,040
para baixo e colocar em nosso código

10775
07:17:17,040 --> 07:17:20,160
Para declarações aninhadas se

10776
07:17:20,160 --> 07:17:22,398
Então, o que vamos dizer

10777
07:17:22,398 --> 07:17:25,520
Se a luz é verde, devemos ir

10778
07:17:25,520 --> 07:17:28,080
Mas o policial tem o direito de

10779
07:17:28,080 --> 07:17:30,478
paremo-nos mesmo se a luz é verde em

10780
07:17:30,478 --> 07:17:32,638
Pelo menos estas são as leis do país

10781
07:17:32,638 --> 07:17:34,878
onde eu saio, então temos uma variável

10782
07:17:34,878 --> 07:17:37,840
A polícia parou aqui, então se eles pararem

10783
07:17:37,840 --> 07:17:40,000
Se a luz é verde você é

10784
07:17:40,000 --> 07:17:41,840
Vou parar e vamos ver

10785
07:17:41,840 --> 07:17:43,920
O que vemos aqui, então se a luz é

10786
07:17:43,920 --> 07:17:45,840
verde nós vamos cair neste corpo

10787
07:17:45,840 --> 07:17:49,040
Mais uma vez e nós vamos correr isso para dentro

10788
07:17:49,040 --> 07:17:51,920
ou aninhado se declaração e se o

10789
07:17:51,920 --> 07:17:53,520
O oficial nos parou, vamos

10790
07:17:53,520 --> 07:17:54,398
Parada

10791
07:17:54,398 --> 07:17:56,000
Se eles não nos impediram, vamos

10792
07:17:56,000 --> 07:17:59,200
para ir e ir em nosso caminho alegre este é

10793
07:17:59,200 --> 07:18:01,200
O que queremos ver aqui e novamente eu

10794
07:18:01,200 --> 07:18:03,840
Quero que você pare por um momento tente correr

10795
07:18:03,840 --> 07:18:06,638
através de seu cérebro e tentar vir

10796
07:18:06,638 --> 07:18:09,040
Para cima com o valor que vamos ver

10797
07:18:09,040 --> 07:18:11,440
quando executamos isso em código de estúdio visual

10798
07:18:11,440 --> 07:18:12,878
Pare por um minuto

10799
07:18:12,878 --> 07:18:15,040
nós vamos executar isso

10800
07:18:15,040 --> 07:18:17,600
Vamos construir com gcc

10801
07:18:17,600 --> 07:18:20,000
e nós vamos executar um programa e você

10802
07:18:20,000 --> 07:18:22,718
Veja que o policial pára

10803
07:18:22,718 --> 07:18:23,920
Parada

10804
07:18:23,920 --> 07:18:25,520
E por que é isso

10805
07:18:25,520 --> 07:18:28,638
A luz é verde, então devemos

10806
07:18:28,638 --> 07:18:31,680
geralmente vai, mas a polícia pára variável

10807
07:18:31,680 --> 07:18:34,878
Aqui também é verdade, então se cairmos aqui

10808
07:18:34,878 --> 07:18:37,040
Isso vai executar e está indo

10809
07:18:37,040 --> 07:18:39,920
para ter sucesso e vamos dizer parar

10810
07:18:39,920 --> 07:18:42,558
e uma vez que esta declaração executa o

10811
07:18:42,558 --> 07:18:45,120
outra declaração não vai executar

10812
07:18:45,120 --> 07:18:48,240
O controle vai cair lá fora

10813
07:18:48,240 --> 07:18:50,080
e nós vamos continuar fazendo qualquer coisa

10814
07:18:50,080 --> 07:18:53,200
Temos fora desta declaração se aqui

10815
07:18:53,200 --> 07:18:56,160
Isso é realmente crítico para entender se

10816
07:18:56,160 --> 07:18:57,120
Um só

10817
07:18:57,120 --> 07:19:00,320
Bloco de uma declaração sucede a todos os

10818
07:19:00,320 --> 07:19:03,040
Outros não vão executar e tentar

10819
07:19:03,040 --> 07:19:05,680
para realmente entender isso ok, temos

10820
07:19:05,680 --> 07:19:07,680
Já vimos isso, agora podemos comentar isso

10821
07:19:07,680 --> 07:19:10,718
Porque nós temos outra coisa que eu quero

10822
07:19:10,718 --> 07:19:11,760
Mostrar você

10823
07:19:11,760 --> 07:19:13,680
nós vamos comentar isso e

10824
07:19:13,680 --> 07:19:16,160
É que você pode combinar a se

10825
07:19:16,160 --> 07:19:18,080
declarações aqui ou condicionais

10826
07:19:18,080 --> 07:19:21,040
Programação com os operadores lógicos

10827
07:19:21,040 --> 07:19:23,440
Aprendemos sobre mais cedo no

10828
07:19:23,440 --> 07:19:25,920
curso e fazer coisas realmente poderosas para

10829
07:19:25,920 --> 07:19:28,160
Um exemplo aqui podemos realmente

10830
07:19:28,160 --> 07:19:31,200
não usar esta declaração aninhada e fazer

10831
07:19:31,200 --> 07:19:33,600
isso de uma só maneira e eu penso

10832
07:19:33,600 --> 07:19:35,920
Isso é muito mais limpo, então vamos

10833
07:19:35,920 --> 07:19:38,320
Diga se a luz é verde e a polícia

10834
07:19:38,320 --> 07:19:40,958
O oficial não nos impediu de que vamos

10835
07:19:40,958 --> 07:19:43,440
Vamos e se eles nos pararam, nós somos

10836
07:19:43,440 --> 07:19:44,958
vai parar e você vai ver

10837
07:19:44,958 --> 07:19:46,798
que vamos ter exatamente o mesmo

10838
07:19:46,798 --> 07:19:49,120
resultado que tivemos antes, mas isso é

10839
07:19:49,120 --> 07:19:51,200
Muito mais compacto, então vamos

10840
07:19:51,200 --> 07:19:53,840
correr e ver o resultado disto e

10841
07:19:53,840 --> 07:19:56,718
nós vamos limpar claramente

10842
07:19:56,718 --> 07:19:58,638
e correr galo você vai ver que

10843
07:19:58,638 --> 07:20:00,320
eles vão nos parar e isso é

10844
07:20:00,320 --> 07:20:02,478
Realmente legal você pode ir

10845
07:20:02,478 --> 07:20:04,478
novamente e alterar essas variáveis

10846
07:20:04,478 --> 07:20:07,200
para realmente qualquer coisa que você quer e ver o que

10847
07:20:07,200 --> 07:20:09,120
Você está tentando realmente entender o que

10848
07:20:09,120 --> 07:20:12,320
Está acontecendo aqui não é difícil e

10849
07:20:12,320 --> 07:20:14,958
O se a afirmação é realmente fundamental

10850
07:20:14,958 --> 07:20:17,600
para qualquer programação que você vai fazer isso

10851
07:20:17,600 --> 07:20:19,120
Isso é realmente tudo o que nos preparamos para fazer

10852
07:20:19,120 --> 07:20:21,360
Esta palestra para aprender sobre condições condicionais

10853
07:20:21,360 --> 07:20:24,160
programação usando a declaração se for

10854
07:20:24,160 --> 07:20:26,240
Uma coisa poderosa e você vai ver

10855
07:20:26,240 --> 07:20:29,360
tudo isso em seu desenvolvimento de software

10856
07:20:29,360 --> 07:20:31,280
A carreira, então certifique-se de que você realmente

10857
07:20:31,280 --> 07:20:33,200
Entenda isso, mas mesmo que não seja

10858
07:20:33,200 --> 07:20:35,040
claro agora vamos ter uma chance

10859
07:20:35,040 --> 07:20:37,200
para fazer muitos exemplos e você vai

10860
07:20:37,200 --> 07:20:40,000
realmente entender o que é tudo isso

10861
07:20:40,000 --> 07:20:41,280
Vamos parar aqui neste

10862
07:20:41,280 --> 07:20:43,280
dar uma palestra no próximo que vamos ver

10863
07:20:43,280 --> 07:20:46,798
Como podemos usar o outro se fechar

10864
07:20:46,798 --> 07:20:49,120
Vá em frente e termine aqui e me encontre

10865
07:20:49,120 --> 07:20:50,878
lá nesta palestra vamos

10866
07:20:50,878 --> 07:20:54,000
Saiba mais sobre a outra se perto que você

10867
07:20:54,000 --> 07:20:57,440
pode anexar à sua declaração se

10868
07:20:57,440 --> 07:20:59,440
e isso vai permitir que você teste

10869
07:20:59,440 --> 07:21:01,680
para várias condições em seu se

10870
07:21:01,680 --> 07:21:02,798
Declaração

10871
07:21:02,798 --> 07:21:03,600
E a

10872
07:21:03,600 --> 07:21:06,558
para realmente entender isso, suponha que somos

10873
07:21:06,558 --> 07:21:09,600
construir uma aplicação de desenho e em

10874
07:21:09,600 --> 07:21:12,240
qualquer momento que o usuário possa estar usando

10875
07:21:12,240 --> 07:21:14,958
a panela ou o marcador ou a borracha

10876
07:21:14,958 --> 07:21:17,040
já qualquer ferramenta que seja nós

10877
07:21:17,040 --> 07:21:19,920
fornecer em nossa aplicação

10878
07:21:19,920 --> 07:21:22,320
E se quisermos desenhar

10879
07:21:22,320 --> 07:21:24,718
Precisamos saber qual ferramenta é atualmente

10880
07:21:24,718 --> 07:21:27,360
selecionado pelo usuário e nós podemos fazer a

10881
07:21:27,360 --> 07:21:29,920
peça de lógica como esta, podemos ter o

10882
07:21:29,920 --> 07:21:32,958
ferramenta armazenada em algum lugar em nossa aplicação

10883
07:21:32,958 --> 07:21:35,200
E quando chegarmos ao momento em que

10884
07:21:35,200 --> 07:21:36,878
Quero fazer algo, por exemplo, quando

10885
07:21:36,878 --> 07:21:38,878
o usuário clica com o mouse e eles

10886
07:21:38,878 --> 07:21:41,440
querer arrastar e começar a fazer as coisas, então

10887
07:21:41,440 --> 07:21:44,000
vamos testar a ferramenta atual

10888
07:21:44,000 --> 07:21:45,520
Se a ferramenta é a panela que vamos

10889
07:21:45,520 --> 07:21:47,920
Use as configurações para a caneta se a ferramenta

10890
07:21:47,920 --> 07:21:49,280
é o marcador que vamos usar o

10891
07:21:49,280 --> 07:21:51,040
configurações do marcador e vamos

10892
07:21:51,040 --> 07:21:53,280
para continuar fazendo isso e selecionar

10893
07:21:53,280 --> 07:21:56,240
uma ferramenta que é realmente selecionada como

10894
07:21:56,240 --> 07:21:58,638
A ferramenta atual pelo usuário e quando

10895
07:21:58,638 --> 07:22:00,558
Você faz algo assim apenas um

10896
07:22:00,558 --> 07:22:03,680
Bloquear em toda essa cadeia de declarações

10897
07:22:03,680 --> 07:22:06,638
vai executar, por exemplo, se nós

10898
07:22:06,638 --> 07:22:09,440
ter o marcador como a ferramenta atual

10899
07:22:09,440 --> 07:22:11,520
O código dentro deste bloco vai

10900
07:22:11,520 --> 07:22:14,398
Executar e dizer que ferramenta ativa é marcador

10901
07:22:14,398 --> 07:22:17,280
Mas nada mais neste bloco está indo

10902
07:22:17,280 --> 07:22:20,398
para executar depois de executar esta declaração

10903
07:22:20,398 --> 07:22:22,878
O controle vai saltar no final de

10904
07:22:22,878 --> 07:22:25,680
toda essa cadeia de se e então se

10905
07:22:25,680 --> 07:22:27,600
Declarações aqui eu realmente espero que você

10906
07:22:27,600 --> 07:22:29,920
Entendo isso e uh isso é realmente

10907
07:22:29,920 --> 07:22:31,920
Coisas poderosas, por exemplo

10908
07:22:31,920 --> 07:22:34,000
Esta é uma das aplicações que tenho

10909
07:22:34,000 --> 07:22:36,398
feito em um dos meus cursos avançados sobre

10910
07:22:36,398 --> 07:22:39,040
qt e c mais qt é um framework que

10911
07:22:39,040 --> 07:22:40,478
permite que você faça um usuário gráfico

10912
07:22:40,478 --> 07:22:42,478
interfaces como esta e você pode construir

10913
07:22:42,478 --> 07:22:44,718
aplicações como esta, então o que eu fiz

10914
07:22:44,718 --> 07:22:47,920
Aqui estou eu fiz exatamente a mesma coisa que

10915
07:22:47,920 --> 07:22:50,398
Temos aqui eu tinha a cadeia do se e

10916
07:22:50,398 --> 07:22:53,600
outra das afirmações e qualquer ferramenta

10917
07:22:53,600 --> 07:22:56,320
foi selecionado como a ferramenta atual foi

10918
07:22:56,320 --> 07:22:58,478
usado para desenhar coisas na tela aqui

10919
07:22:58,478 --> 07:23:00,240
por exemplo, se a ferramenta atual era a

10920
07:23:00,240 --> 07:23:02,478
caneta e a caneta é esta pequena ferramenta de caneta

10921
07:23:02,478 --> 07:23:04,638
aqui, se estiver ativo, vamos desenhar

10922
07:23:04,638 --> 07:23:07,120
coisas como olá mundo aqui se tivermos

10923
07:23:07,120 --> 07:23:08,798
A estrela selecionou que vamos desenhar

10924
07:23:08,798 --> 07:23:11,040
estrelas se tivermos o retângulo selecionado

10925
07:23:11,040 --> 07:23:12,878
nós vamos desenhar rectângulos que poderíamos

10926
07:23:12,878 --> 07:23:15,120
fazer todos os tipos de coisas loucas usando isso

10927
07:23:15,120 --> 07:23:17,520
pedaço de lógica aqui, mas é poderoso

10928
07:23:17,520 --> 07:23:19,520
Coisas e você realmente tem que ter certeza

10929
07:23:19,520 --> 07:23:21,680
Você entende isso, então é assim que

10930
07:23:21,680 --> 07:23:24,080
outra opção se a cláusula pode realmente ajudá-lo

10931
07:23:24,080 --> 07:23:26,240
O principal é permitir que você teste para

10932
07:23:26,240 --> 07:23:28,398
várias condições diferentes que você poderia

10933
07:23:28,398 --> 07:23:30,718
fazer isso com muitas declarações, mas

10934
07:23:30,718 --> 07:23:32,398
que não vai ser muito legal é

10935
07:23:32,398 --> 07:23:34,878
Vai ser feio e difícil de ler isso

10936
07:23:34,878 --> 07:23:36,398
É o que você deve fazer

10937
07:23:36,398 --> 07:23:38,160
Agora que você tem uma ideia sobre isso

10938
07:23:38,160 --> 07:23:39,680
Vamos para o estúdio visual

10939
07:23:39,680 --> 07:23:41,840
codificar e realmente ver isso em ação

10940
07:23:41,840 --> 07:23:44,718
Aqui estamos em nosso diretório de trabalho

10941
07:23:44,718 --> 07:23:47,040
Vamos pegar nosso projeto de modelo

10942
07:23:47,040 --> 07:23:49,200
muito rápido e nós vamos usar o

10943
07:23:49,200 --> 07:23:51,600
Se projeto aqui é o nosso atual

10944
07:23:51,600 --> 07:23:54,240
Projeto para que vamos fazer isso e

10945
07:23:54,240 --> 07:23:56,718
abrir isso em código de estúdio visual como nós

10946
07:23:56,718 --> 07:23:58,638
Sempre vamos abrir isso

10947
07:23:58,638 --> 07:24:01,280
nós vamos abrir o cpp principal e nós somos

10948
07:24:01,280 --> 07:24:03,520
Vamos remover o que não precisamos

10949
07:24:03,520 --> 07:24:05,600
A primeira coisa que vou fazer é

10950
07:24:05,600 --> 07:24:08,558
colocar em um conjunto de variáveis que estão indo

10951
07:24:08,558 --> 07:24:10,878
para armazenar nossas ferramentas e podemos fazer

10952
07:24:10,878 --> 07:24:12,478
Algo assim temos uma variável

10953
07:24:12,478 --> 07:24:15,440
para pen marker eraser círculo retângulo

10954
07:24:15,440 --> 07:24:17,920
e elipse eu tenho que dizer que isso é

10955
07:24:17,920 --> 07:24:19,600
Não é o caminho para fazer isso, estamos indo

10956
07:24:19,600 --> 07:24:21,280
para aprender de outra maneira que podemos fazer

10957
07:24:21,280 --> 07:24:23,360
Isso mas isso vai estar lá no

10958
07:24:23,360 --> 07:24:25,040
curso quando temos ferramentas suficientes para

10959
07:24:25,040 --> 07:24:27,280
Entenda isso por enquanto, estamos apenas indo

10960
07:24:27,280 --> 07:24:29,600
para ser feliz com isso

10961
07:24:29,600 --> 07:24:32,558
OK 10 vai representar a panela 20

10962
07:24:32,558 --> 07:24:34,558
vai representar o marcador 30 é

10963
07:24:34,558 --> 07:24:36,398
vamos representar a navalha e nós podemos

10964
07:24:36,398 --> 07:24:38,240
continuar até atingirmos a elipse, que é

10965
07:24:38,240 --> 07:24:41,520
representado por 60. agora se formos em main

10966
07:24:41,520 --> 07:24:43,760
e configurar uma variável e chamá-lo de ferramenta

10967
07:24:43,760 --> 07:24:46,320
por exemplo e inicializá-lo com

10968
07:24:46,320 --> 07:24:48,878
qualquer ferramenta que pensamos que o usuário é

10969
07:24:48,878 --> 07:24:50,798
atualmente usando, por exemplo, podemos usar

10970
07:24:50,798 --> 07:24:53,760
Círculo e inicializar isso, podemos configurar

10971
07:24:53,760 --> 07:24:57,200
uma cadeia de anos e outras declarações para

10972
07:24:57,200 --> 07:24:59,600
fazer o que quisermos fazer quando

10973
07:24:59,600 --> 07:25:01,920
Esta ferramenta aqui é selecionada ok

10974
07:25:01,920 --> 07:25:04,320
indo para baixo e colocar em nosso código i

10975
07:25:04,320 --> 07:25:06,080
Não quero digitar tudo isso, então eu estou indo

10976
07:25:06,080 --> 07:25:08,320
para colocar isso aqui e se você quiser

10977
07:25:08,320 --> 07:25:10,478
pode copiar o código a partir do

10978
07:25:10,478 --> 07:25:12,398
seção de recursos o código será

10979
07:25:12,398 --> 07:25:14,160
lá você pode copiá-lo e colá-lo em

10980
07:25:14,160 --> 07:25:16,160
aqui e fazer coisas com isso ok

10981
07:25:16,160 --> 07:25:19,120
ter uma cadeia de se e então se perto é

10982
07:25:19,120 --> 07:25:21,520
Aqui e o primeiro vai

10983
07:25:21,520 --> 07:25:23,920
testar e ver se a ferramenta é a panela e

10984
07:25:23,920 --> 07:25:26,080
Veja que estamos usando o dobro igual

10985
07:25:26,080 --> 07:25:28,638
Sinais aqui é o que você usa para testar

10986
07:25:28,638 --> 07:25:30,958
para a igualdade você não usa um igual

10987
07:25:30,958 --> 07:25:33,280
assinar você deve usar dois sinais iguais se

10988
07:25:33,280 --> 07:25:35,040
Você usa um sinal de igual que vai

10989
07:25:35,040 --> 07:25:36,878
ser uma tarefa e isso vai

10990
07:25:36,878 --> 07:25:38,878
Sempre avalie para verdadeiro para que você não

10991
07:25:38,878 --> 07:25:41,200
Quer fazer isso novamente para testar

10992
07:25:41,200 --> 07:25:43,200
igualdade você vai usar o dobro

10993
07:25:43,200 --> 07:25:45,760
sinais iguais em c plus plus, então se o

10994
07:25:45,760 --> 07:25:47,280
A ferramenta atual é a caneta que vamos

10995
07:25:47,280 --> 07:25:49,760
Diga extensão de ferramenta ativa se a ferramenta atual

10996
07:25:49,760 --> 07:25:51,760
É marcador, vamos dizer que nós

10997
07:25:51,760 --> 07:25:54,080
Basicamente vai fazer isso por todos

10998
07:25:54,080 --> 07:25:57,120
as ferramentas que o nosso aplicativo suporta

10999
07:25:57,120 --> 07:25:59,600
Então o que você acha que vamos ver

11000
07:25:59,600 --> 07:26:01,680
Quando executamos isso, a ferramenta ativa é

11001
07:26:01,680 --> 07:26:02,638
Círculo

11002
07:26:02,638 --> 07:26:05,600
assim, devemos imprimir a ferramenta ativa é círculo

11003
07:26:05,600 --> 07:26:06,478
aqui

11004
07:26:06,478 --> 07:26:08,558
Vamos tentar isso, vamos abrir

11005
07:26:08,558 --> 07:26:10,160
O terminal para que possamos ver o

11006
07:26:10,160 --> 07:26:12,478
Saída bem e nós estamos indo para o mundo

11007
07:26:12,478 --> 07:26:14,958
com gcc e a construção vai embora

11008
07:26:14,958 --> 07:26:16,798
Por meio de se corrermos isso, vamos

11009
07:26:16,798 --> 07:26:19,760
ver ferramenta ativa é círculo que você pode subir

11010
07:26:19,760 --> 07:26:21,520
aqui e alterar a ferramenta para retângulo

11011
07:26:21,520 --> 07:26:23,680
Por exemplo, se você construir novamente você está

11012
07:26:23,680 --> 07:26:26,000
Vou ver que o bloco correto de

11013
07:26:26,000 --> 07:26:27,840
O código vai ser executado, vamos

11014
07:26:27,840 --> 07:26:30,718
para limpar e executar a ferramenta ativa do galo é

11015
07:26:30,718 --> 07:26:33,280
O retângulo se tentarmos colocar em algo

11016
07:26:33,280 --> 07:26:35,360
que não existe, digamos, vamos colocar

11017
07:26:35,360 --> 07:26:36,478
em pássaro

11018
07:26:36,478 --> 07:26:39,280
apenas para mexer com o nosso compilador aqui

11019
07:26:39,280 --> 07:26:40,638
vamos ter um erro de compilador

11020
07:26:40,638 --> 07:26:43,520
porque esse tipo não é conhecido por

11021
07:26:43,520 --> 07:26:45,840
nosso código aqui, então vamos pegar um pássaro

11022
07:26:45,840 --> 07:26:47,760
não foi declarado neste escopo que não

11023
07:26:47,760 --> 07:26:49,760
Saiba o que você tem que colocar

11024
07:26:49,760 --> 07:26:52,478
Seja qual for a coisa que você declarou

11025
07:26:52,478 --> 07:26:55,680
de antemão aqui, então se colocarmos em uma navalha

11026
07:26:55,680 --> 07:26:58,558
Por exemplo, vamos soldar com gcc

11027
07:26:58,558 --> 07:27:00,160
O mundo vai passar por

11028
07:27:00,160 --> 07:27:02,558
para limpar o galo de corrida a ferramenta está indo

11029
07:27:02,558 --> 07:27:04,958
ser borracha e isso é exatamente o que nós

11030
07:27:04,958 --> 07:27:07,680
Esperar novamente a mensagem principal neste

11031
07:27:07,680 --> 07:27:10,398
A palestra é que você pode usar isso se

11032
07:27:10,398 --> 07:27:12,558
fechar se você tiver várias condições

11033
07:27:12,558 --> 07:27:15,040
que você quer testar como nós

11034
07:27:15,040 --> 07:27:17,760
Tenho aqui e novamente um desses blocos

11035
07:27:17,760 --> 07:27:20,558
vai executar e uma vez que nós batemos o

11036
07:27:20,558 --> 07:27:23,120
fim desta cadeia de se e else

11037
07:27:23,120 --> 07:27:26,000
fecha, vamos cair aqui e codificar

11038
07:27:26,000 --> 07:27:28,320
Depois disso vai executar, então vamos

11039
07:27:28,320 --> 07:27:30,398
Diga seguir em frente para que você possa realmente ver

11040
07:27:30,398 --> 07:27:33,760
isso aqui muito claro seguindo em frente e se nós

11041
07:27:33,760 --> 07:27:36,398
Isso vamos ver apenas um

11042
07:27:36,398 --> 07:27:39,760
bloco de toda esta cadeia e uma vez

11043
07:27:39,760 --> 07:27:42,398
bloqueio executas o controle vai ir

11044
07:27:42,398 --> 07:27:45,120
depois de toda essa cadeia e executar

11045
07:27:45,120 --> 07:27:47,040
O que quer que seja depois disso, vamos

11046
07:27:47,040 --> 07:27:50,240
Digam seguir em frente depois de imprimirmos que o

11047
07:27:50,240 --> 07:27:52,878
ferramenta ativa é borracha aqui eu acho que nós

11048
07:27:52,878 --> 07:27:55,440
construímos isso, então vamos

11049
07:27:55,440 --> 07:27:58,160
Tente executá-lo e você vê a ferramenta ativa

11050
07:27:58,160 --> 07:28:01,680
é razer e se movendo em diante, então depois que nós imprimirmos

11051
07:28:01,680 --> 07:28:04,798
o código do bloco da borracha que não somos

11052
07:28:04,798 --> 07:28:07,360
indo para executar retângulo ou um círculo

11053
07:28:07,360 --> 07:28:10,080
ou elipse vai saltar no final

11054
07:28:10,080 --> 07:28:12,398
de todo esse bloco, isso é realmente

11055
07:28:12,398 --> 07:28:14,000
O que eu quero ser

11056
07:28:14,000 --> 07:28:16,000
super claro e novamente certifique-se de que você

11057
07:28:16,000 --> 07:28:18,080
Entenda a sintaxe aqui a outra se

11058
07:28:18,080 --> 07:28:20,478
A declaração é seguida por um conjunto de

11059
07:28:20,478 --> 07:28:23,360
parênteses e dentro do parêntese

11060
07:28:23,360 --> 07:28:25,760
temos a condição que queremos testar

11061
07:28:25,760 --> 07:28:28,638
para a condição tem que avaliar para

11062
07:28:28,638 --> 07:28:31,120
boolean e depois disso temos o bloco

11063
07:28:31,120 --> 07:28:33,520
de código que queremos executar e isso

11064
07:28:33,520 --> 07:28:35,840
É realmente tudo que você tem que fazer para conseguir isso

11065
07:28:35,840 --> 07:28:38,240
para trabalhar a seu favor

11066
07:28:38,240 --> 07:28:39,600
Vamos parar aqui neste

11067
07:28:39,600 --> 07:28:41,280
palestra no próximo, vamos

11068
07:28:41,280 --> 07:28:43,440
Aprenda sobre o switch

11069
07:28:43,440 --> 07:28:45,840
Vá em frente e termine aqui e me encontre

11070
07:28:45,840 --> 07:28:46,798
lá

11071
07:28:46,798 --> 07:28:48,240
Nesta palestra vamos aprender

11072
07:28:48,240 --> 07:28:51,520
sobre a declaração de mudança e isso é

11073
07:28:51,520 --> 07:28:54,398
Uma forma alternativa de fazer o que fizemos

11074
07:28:54,398 --> 07:28:56,958
destes outros, se cláusulas no último

11075
07:28:56,958 --> 07:28:59,440
palestra basicamente testando para vários

11076
07:28:59,440 --> 07:29:01,280
condições diferentes, mas vai

11077
07:29:01,280 --> 07:29:03,920
estar de uma maneira muito mais compacta do que

11078
07:29:03,920 --> 07:29:06,000
Fizemos na última palestra que vamos

11079
07:29:06,000 --> 07:29:08,398
para usar exatamente o mesmo exemplo

11080
07:29:08,398 --> 07:29:10,558
Fiz a última palestra e nós vamos

11081
07:29:10,558 --> 07:29:12,798
para olhar para a instrução switch e como

11082
07:29:12,798 --> 07:29:15,280
funciona em c plus plus e é assim que

11083
07:29:15,280 --> 07:29:17,760
é que temos a nossa variável que é

11084
07:29:17,760 --> 07:29:20,000
vai armazenar a ferramenta atual e

11085
07:29:20,000 --> 07:29:21,920
nós vamos dizer interruptor

11086
07:29:21,920 --> 07:29:23,840
Dentro do parêntese aqui estamos indo

11087
07:29:23,840 --> 07:29:24,558
A sua forma de

11088
07:29:24,558 --> 07:29:26,478
passar a variável que nós vamos ser

11089
07:29:26,478 --> 07:29:29,200
basicamente ligando ou testando o

11090
07:29:29,200 --> 07:29:30,798
As condições a seguir

11091
07:29:30,798 --> 07:29:33,280
E dentro do bloco nós vamos ser

11092
07:29:33,280 --> 07:29:36,160
basicamente testando para cada caso, então estamos

11093
07:29:36,160 --> 07:29:38,160
vai dizer se a ferramenta atual é a

11094
07:29:38,160 --> 07:29:40,160
pan nós vamos dizer case pan nós somos

11095
07:29:40,160 --> 07:29:42,478
Vou colocar um cólon aqui e nós estamos

11096
07:29:42,478 --> 07:29:44,558
Vou colocar o código que queremos executar

11097
07:29:44,558 --> 07:29:46,000
para o caso

11098
07:29:46,000 --> 07:29:48,398
onde a ferramenta atual é a panela em

11099
07:29:48,398 --> 07:29:51,440
Estes cintas encaracolados aqui e uma coisa

11100
07:29:51,440 --> 07:29:53,520
Você deve notar desde o início é isso

11101
07:29:53,520 --> 07:29:55,440
break statement aqui

11102
07:29:55,440 --> 07:29:58,240
Esta é uma declaração que diz c plus

11103
07:29:58,240 --> 07:29:59,360
+ a vantagem

11104
07:29:59,360 --> 07:30:02,718
que depois de executarmos com sucesso um

11105
07:30:02,718 --> 07:30:05,280
Bloco de código que vamos saltar para fora

11106
07:30:05,280 --> 07:30:07,760
esta declaração de mudança se você omitir isso

11107
07:30:07,760 --> 07:30:09,360
break statement

11108
07:30:09,360 --> 07:30:12,160
Tudo depois do caso que você apenas

11109
07:30:12,160 --> 07:30:14,638
executados vão executar e isso é

11110
07:30:14,638 --> 07:30:17,120
Não provavelmente vai ser o que você quer

11111
07:30:17,120 --> 07:30:19,520
Se isso não está fazendo sentido, mas por favor

11112
07:30:19,520 --> 07:30:21,680
bear comigo você vai vê-lo correr

11113
07:30:21,680 --> 07:30:23,600
em código de estúdio visual e você está indo

11114
07:30:23,600 --> 07:30:25,920
para entender isso o que você vai fazer

11115
07:30:25,920 --> 07:30:27,520
Você vai colocar todas as ferramentas que você

11116
07:30:27,520 --> 07:30:30,478
Quer testar em casos separados

11117
07:30:30,478 --> 07:30:33,680
Veja aqui temos um marcador e depois disso

11118
07:30:33,680 --> 07:30:36,558
você pode colocar um caso padrão que está acontecendo

11119
07:30:36,558 --> 07:30:39,200
para ser combinado quando nada foi

11120
07:30:39,200 --> 07:30:40,878
combinado em tudo o que você tem

11121
07:30:40,878 --> 07:30:44,320
testado para este bloco de comutação aqui e

11122
07:30:44,320 --> 07:30:45,920
Quando nós executamos este pedaço de código nós somos

11123
07:30:45,920 --> 07:30:47,920
obter exatamente os mesmos resultados

11124
07:30:47,920 --> 07:30:50,240
que tivemos na última palestra, mas

11125
07:30:50,240 --> 07:30:52,160
Espero que você possa ver que isso é muito

11126
07:30:52,160 --> 07:30:55,360
mais compacto do que a série de outros se

11127
07:30:55,360 --> 07:30:58,000
Feche o que tivemos na última palestra

11128
07:30:58,000 --> 07:31:00,160
novamente a declaração de quebra é realmente

11129
07:31:00,160 --> 07:31:02,798
útil se você não colocá-lo em c plus

11130
07:31:02,798 --> 07:31:04,958
Plus vai ficar confuso e depois

11131
07:31:04,958 --> 07:31:07,280
Você atingiu seu caso de sucesso

11132
07:31:07,280 --> 07:31:09,120
Tudo depois disso vai ser

11133
07:31:09,120 --> 07:31:11,520
executado assim que a instrução break é

11134
07:31:11,520 --> 07:31:14,320
basicamente dizendo c plus plus se você bater

11135
07:31:14,320 --> 07:31:17,760
Isso depois de um caso bem sucedido é

11136
07:31:17,760 --> 07:31:19,680
saltar para fora deste bloco de interruptor porque

11137
07:31:19,680 --> 07:31:21,120
Você está feito você não tem que fazer

11138
07:31:21,120 --> 07:31:23,520
Mais alguma coisa aqui e outra coisa

11139
07:31:23,520 --> 07:31:26,080
Você deve saber que a condição

11140
07:31:26,080 --> 07:31:27,840
que é o que temos dentro desta

11141
07:31:27,840 --> 07:31:31,040
O parêntese aqui só pode ser um inteiro

11142
07:31:31,040 --> 07:31:33,840
ou um enum, então basicamente pode ser formi

11143
07:31:33,840 --> 07:31:36,000
longo sem assinatura ou carro

11144
07:31:36,000 --> 07:31:38,160
basicamente cada tipo integral que temos

11145
07:31:38,160 --> 07:31:40,798
visto antes, mas não pode ser outro tipo

11146
07:31:40,798 --> 07:31:42,958
como string porque isso não

11147
07:31:42,958 --> 07:31:45,360
realmente faça sentido para ter certeza de manter

11148
07:31:45,360 --> 07:31:46,398
Isso em mente

11149
07:31:46,398 --> 07:31:48,478
Agora que você tem uma ideia sobre isso

11150
07:31:48,478 --> 07:31:50,958
declaração de mudança vamos cabeça para o visual

11151
07:31:50,958 --> 07:31:53,040
vídeo código e realmente ver isso em

11152
07:31:53,040 --> 07:31:56,320
ação aqui estamos em nossa pasta de trabalho

11153
07:31:56,320 --> 07:31:58,080
O projeto atual será

11154
07:31:58,080 --> 07:31:59,840
mudar para que nós vamos pegar o nosso

11155
07:31:59,840 --> 07:32:02,160
arquivos de modelo e vamos trazer

11156
07:32:02,160 --> 07:32:04,398
que aqui eu vou subir um pouco

11157
07:32:04,398 --> 07:32:07,120
bit e abrir isso em estúdio visual

11158
07:32:07,120 --> 07:32:09,600
código como sempre fazemos e vamos

11159
07:32:09,600 --> 07:32:11,360
abrir o nosso arquivo principal que vamos obter

11160
07:32:11,360 --> 07:32:13,840
Livres do que não precisamos, estamos indo

11161
07:32:13,840 --> 07:32:16,478
para sair da função principal aqui e

11162
07:32:16,478 --> 07:32:18,558
colocar em nossas ferramentas como no último

11163
07:32:18,558 --> 07:32:21,120
palestra que estamos usando inteiros cada um

11164
07:32:21,120 --> 07:32:24,638
é representado por 10 20 30 até 60 e

11165
07:32:24,638 --> 07:32:26,878
Estas são as ferramentas que temos e eu não

11166
07:32:26,878 --> 07:32:28,638
Acho que eu expliquei isso, mas nós somos

11167
07:32:28,638 --> 07:32:30,638
sinalizando eles const porque nós não

11168
07:32:30,638 --> 07:32:33,040
Quero que eles sejam modificáveis que vimos

11169
07:32:33,040 --> 07:32:36,320
sobre const no início do curso nós somos

11170
07:32:36,320 --> 07:32:38,320
indo saltar para o main e configurar o nosso

11171
07:32:38,320 --> 07:32:40,478
variável vai ser uma formi e nós somos

11172
07:32:40,478 --> 07:32:42,798
vamos chamar isso de ferramenta e nós vamos

11173
07:32:42,798 --> 07:32:44,798
inicialize esta ferramenta que quisermos

11174
07:32:44,798 --> 07:32:47,440
Vamos usar a borracha por que não e então nós somos

11175
07:32:47,440 --> 07:32:49,360
indo para colocar em nosso bloco de interruptor nós somos

11176
07:32:49,360 --> 07:32:50,958
indo para dizer interruptor

11177
07:32:50,958 --> 07:32:53,440
e se eu digitar isso você vê que visual

11178
07:32:53,440 --> 07:32:55,280
O código do estúdio vai me dar

11179
07:32:55,280 --> 07:32:57,840
Inteligência ou sugestões sobre o que

11180
07:32:57,840 --> 07:33:00,000
A coisa que eu poderia fazer uma coisa legal que

11181
07:33:00,000 --> 07:33:01,840
Código de estúdio visual faz você

11182
07:33:01,840 --> 07:33:03,840
snippets para realmente ajudá-lo a digitar as coisas

11183
07:33:03,840 --> 07:33:06,320
para que possamos clicar sobre isso e é

11184
07:33:06,320 --> 07:33:09,360
indo para completar automaticamente uma versão inicial

11185
07:33:09,360 --> 07:33:13,280
do nosso caso e podemos digitar em nosso

11186
07:33:13,280 --> 07:33:15,840
expressão aqui que vai ser

11187
07:33:15,840 --> 07:33:18,080
O que vamos mudar, então

11188
07:33:18,080 --> 07:33:19,680
vamos mudar a variável

11189
07:33:19,680 --> 07:33:22,398
ferramenta aqui e podemos colocar em nossos casos assim

11190
07:33:22,398 --> 07:33:24,798
No nosso caso, vamos começar com

11191
07:33:24,798 --> 07:33:26,638
Pan que é o que temos aqui, então nós somos

11192
07:33:26,638 --> 07:33:28,478
vamos dizer caso, vamos

11193
07:33:28,478 --> 07:33:30,638
Remova tudo isso

11194
07:33:30,638 --> 07:33:34,000
uh vamos remover isso e dizer caneta

11195
07:33:34,000 --> 07:33:35,760
Eu vou colocar uma coluna

11196
07:33:35,760 --> 07:33:37,600
e nós vamos colocar

11197
07:33:37,600 --> 07:33:40,478
um bloco de código que vai executar

11198
07:33:40,478 --> 07:33:42,638
quando a ferramenta atual é a caneta e

11199
07:33:42,638 --> 07:33:44,320
nós vamos colocar isso aqui, vamos

11200
07:33:44,320 --> 07:33:45,600
Trate isso

11201
07:33:45,600 --> 07:33:47,920
à direita um pouco e dentro do

11202
07:33:47,920 --> 07:33:51,760
bloco que podemos dizer sddc para fora ferramenta ativa é

11203
07:33:51,760 --> 07:33:54,240
pan Ok, então depois disso vamos

11204
07:33:54,240 --> 07:33:56,798
colocar esta declaração de quebra se não for

11205
07:33:56,798 --> 07:33:58,638
Aqui nós vamos ter um problema

11206
07:33:58,638 --> 07:34:00,638
porque quando a ferramenta atual é a panela

11207
07:34:00,638 --> 07:34:03,200
e este código aqui executa cada caso

11208
07:34:03,200 --> 07:34:05,200
Depois disso, vai executar e

11209
07:34:05,200 --> 07:34:06,718
Não é isso que queremos que tenhamos que

11210
07:34:06,718 --> 07:34:08,798
Lembre-se de colocar esta declaração de ruptura

11211
07:34:08,798 --> 07:34:10,798
Aqui está tudo bem, então nós vamos colocar tudo

11212
07:34:10,798 --> 07:34:12,878
nossos outros casos, então vamos copiar

11213
07:34:12,878 --> 07:34:14,000
Isto é

11214
07:34:14,000 --> 07:34:15,680
e olhar para o próximo que vai

11215
07:34:15,680 --> 07:34:18,398
ser marcador para que possamos ir na próxima linha

11216
07:34:18,398 --> 07:34:20,320
e colocar no marcador nós vamos colar

11217
07:34:20,320 --> 07:34:22,718
Isso em nós vamos dizer marcador e

11218
07:34:22,718 --> 07:34:25,040
nós vamos dizer que ferramenta ativa é marcador

11219
07:34:25,040 --> 07:34:27,280
e podemos continuar fazendo a mesma coisa

11220
07:34:27,280 --> 07:34:29,520
nós vamos fazer o download deles e

11221
07:34:29,520 --> 07:34:32,000
colar isso no próximo vai

11222
07:34:32,000 --> 07:34:34,160
ser apagão, então vamos fazer isso que estamos indo

11223
07:34:34,160 --> 07:34:36,240
para dizer borracha e nós vamos dizer

11224
07:34:36,240 --> 07:34:38,718
A ferramenta atual é razer e nós vamos

11225
07:34:38,718 --> 07:34:40,478
ir para baixo novamente

11226
07:34:40,478 --> 07:34:42,718
Eu estou fazendo isso ao vivo porque realmente

11227
07:34:42,718 --> 07:34:46,000
É importante para você ver-me digitar isso

11228
07:34:46,000 --> 07:34:47,840
Caso contrário, você pode estar confuso porque

11229
07:34:47,840 --> 07:34:50,558
Esta é uma construção um pouco confusa

11230
07:34:50,558 --> 07:34:54,160
temos em c plus mais o próximo é

11231
07:34:54,160 --> 07:34:56,638
Retângulo para que vamos usar isso e

11232
07:34:56,638 --> 07:34:58,160
Vamos dizer que a ferramenta atual é

11233
07:34:58,160 --> 07:35:01,520
O retângulo o próximo será

11234
07:35:01,520 --> 07:35:03,840
círculo e elipse, então vamos fazer isso

11235
07:35:03,840 --> 07:35:05,440
nós vamos colocar em círculo que estamos indo

11236
07:35:05,440 --> 07:35:08,320
para descer e colar isso e trazer

11237
07:35:08,320 --> 07:35:10,000
Isso de volta um pouco

11238
07:35:10,000 --> 07:35:12,160
E eu vou dizer círculo e nós estamos

11239
07:35:12,160 --> 07:35:15,440
indo para baixo e colocar o próximo em

11240
07:35:15,440 --> 07:35:17,680
que vai ser ellipse e depois

11241
07:35:17,680 --> 07:35:20,638
que percebe que o código do estúdio de vídeo também

11242
07:35:20,638 --> 07:35:23,280
inserir um bloco padrão e este é um

11243
07:35:23,280 --> 07:35:26,080
bloco que vai executar quando nada

11244
07:35:26,080 --> 07:35:27,840
dos casos aqui

11245
07:35:27,840 --> 07:35:29,200
É a cabeça

11246
07:35:29,200 --> 07:35:31,760
então isso é realmente importante para que você possa

11247
07:35:31,760 --> 07:35:34,320
Adicione também um bloco de código

11248
07:35:34,320 --> 07:35:37,520
e dizer que nenhum jogo encontrou ok, então nós queremos

11249
07:35:37,520 --> 07:35:39,360
para ver esta impressão e nós vamos

11250
07:35:39,360 --> 07:35:41,200
Experimente isto em um minuto

11251
07:35:41,200 --> 07:35:43,840
Tudo bem depois de fazermos isso, devemos conseguir isso

11252
07:35:43,840 --> 07:35:46,478
para trabalhar e fazer o que estávamos fazendo

11253
07:35:46,478 --> 07:35:48,958
a última palestra para que a ferramenta atual seja

11254
07:35:48,958 --> 07:35:50,718
indo para ser razer

11255
07:35:50,718 --> 07:35:52,638
O bloco aqui vai ser combinado assim

11256
07:35:52,638 --> 07:35:54,798
O código aqui vai executar

11257
07:35:54,798 --> 07:35:56,398
Depois disso, vamos nos encontrar com isso

11258
07:35:56,398 --> 07:35:59,440
Quebre e o que realmente está dizendo é

11259
07:35:59,440 --> 07:36:01,600
Você fez o que você tem que fazer saltar

11260
07:36:01,600 --> 07:36:03,840
fora deste bloco de interruptor aqui e nós estamos

11261
07:36:03,840 --> 07:36:05,360
indo para o final deste interruptor

11262
07:36:05,360 --> 07:36:07,120
bloco e vamos executar

11263
07:36:07,120 --> 07:36:09,520
O que quer que seja depois disso, assim como em

11264
07:36:09,520 --> 07:36:11,840
a última palestra que podemos dizer seguindo em frente

11265
07:36:11,840 --> 07:36:14,638
e se executarmos o programa como temos

11266
07:36:14,638 --> 07:36:15,920
Isso agora

11267
07:36:15,920 --> 07:36:18,958
vai dizer que a ferramenta ativa é razor

11268
07:36:18,958 --> 07:36:21,600
e vai imprimir em movimento

11269
07:36:21,600 --> 07:36:23,760
Vamos trazer o terminal para que nós

11270
07:36:23,760 --> 07:36:25,840
Eu posso realmente ver isso e nós vamos

11271
07:36:25,840 --> 07:36:28,398
construir com gcc o mundo vai ser

11272
07:36:28,398 --> 07:36:31,520
Bom e se corrermos o galo vamos limpar um

11273
07:36:31,520 --> 07:36:33,600
bit, vamos ver essa ferramenta ativa

11274
07:36:33,600 --> 07:36:36,240
é uma navalha e estamos nos movendo sobre isso é

11275
07:36:36,240 --> 07:36:38,160
muito legal e é exatamente o mesmo

11276
07:36:38,160 --> 07:36:39,600
A coisa que nós tínhamos

11277
07:36:39,600 --> 07:36:42,798
na última palestra, mas agora estamos usando

11278
07:36:42,798 --> 07:36:45,680
Uma construção muito mais limpa que switch

11279
07:36:45,680 --> 07:36:48,160
Fornece bem, podemos tentar mudar o

11280
07:36:48,160 --> 07:36:50,320
ferramentar e ver que isso realmente funciona

11281
07:36:50,320 --> 07:36:52,320
pode colocar em círculo

11282
07:36:52,320 --> 07:36:54,798
Por que não vou construir com gcc o

11283
07:36:54,798 --> 07:36:57,200
O mundo vai passar como você vê

11284
07:36:57,200 --> 07:36:59,840
Aqui e se corrermos o galo, vamos

11285
07:36:59,840 --> 07:37:01,760
para ver a ferramenta ativa um círculo que somos

11286
07:37:01,760 --> 07:37:03,600
movendo-se em frente, você pode tentar mudar isso

11287
07:37:03,600 --> 07:37:06,160
No entanto, você quer se colocarmos na elipse

11288
07:37:06,160 --> 07:37:08,160
E o mundo novamente vamos construir

11289
07:37:08,160 --> 07:37:11,200
com gcc e se corrermos, vamos

11290
07:37:11,200 --> 07:37:14,718
obter ferramenta ativa é pan e mover sobre por que

11291
07:37:14,718 --> 07:37:17,040
É essa elipse que estamos dizendo ativo

11292
07:37:17,040 --> 07:37:19,600
Ferramenta é caneta, não mudamos isso, então nós

11293
07:37:19,600 --> 07:37:22,878
basta codificar um saco muito ruim aqui, então vamos

11294
07:37:22,878 --> 07:37:25,280
conserte isso e vamos construir novamente

11295
07:37:25,280 --> 07:37:27,600
Estou feliz por ter encontrado isso, então vamos

11296
07:37:27,600 --> 07:37:29,840
claro e galo

11297
07:37:29,840 --> 07:37:31,600
e nós vamos ver que a ferramenta ativa é

11298
07:37:31,600 --> 07:37:33,840
elipse e nós estamos seguindo em frente

11299
07:37:33,840 --> 07:37:36,478
Tudo bem, então vamos ver o que poderia acontecer

11300
07:37:36,478 --> 07:37:40,160
se você esqueceu sua declaração de quebra depois

11301
07:37:40,160 --> 07:37:43,120
seu caso aqui para que a ferramenta atual seja

11302
07:37:43,120 --> 07:37:44,478
ellipse

11303
07:37:44,478 --> 07:37:46,798
E é a última coisa que temos aqui

11304
07:37:46,798 --> 07:37:49,040
Então não é um bom caso de teste

11305
07:37:49,040 --> 07:37:51,040
O que eu vou fazer

11306
07:37:51,040 --> 07:37:53,520
é fazer a ferramenta atual a caneta ou a

11307
07:37:53,520 --> 07:37:55,600
marcador vamos usar marcador que vai

11308
07:37:55,600 --> 07:37:57,040
- É assim.

11309
07:37:57,040 --> 07:37:59,120
E eu vou remover o intervalo

11310
07:37:59,120 --> 07:38:01,360
Declaração aqui

11311
07:38:01,360 --> 07:38:03,760
Tudo bem assim e eu vou remover todos os

11312
07:38:03,760 --> 07:38:07,120
declarações de pão que temos até bater

11313
07:38:07,120 --> 07:38:08,478
O que é

11314
07:38:08,478 --> 07:38:10,558
último padrão

11315
07:38:10,558 --> 07:38:11,600
O caso

11316
07:38:11,600 --> 07:38:13,360
Então nós vamos descer

11317
07:38:13,360 --> 07:38:16,000
e nós vamos mesmo remover isso para

11318
07:38:16,000 --> 07:38:18,718
O caso padrão aqui

11319
07:38:18,718 --> 07:38:20,958
E se nós dois vamos construir bem

11320
07:38:20,958 --> 07:38:22,558
Você vai ver que o mundo era

11321
07:38:22,558 --> 07:38:25,040
Bom, mas se corrermos esta tentativa de adivinhar

11322
07:38:25,040 --> 07:38:26,798
O que vamos ter a corrente

11323
07:38:26,798 --> 07:38:29,680
Fezes é o marcador, então devemos imprimir

11324
07:38:29,680 --> 07:38:30,798
marcador

11325
07:38:30,798 --> 07:38:34,080
e acertar a extremidade do bloco do interruptor e

11326
07:38:34,080 --> 07:38:37,280
fazer seguir em frente, mas vamos ver o que temos

11327
07:38:37,280 --> 07:38:39,600
nós construímos vamos construir novamente apenas para

11328
07:38:39,600 --> 07:38:42,558
ter certeza de que vamos correr o galo

11329
07:38:42,558 --> 07:38:44,398
e observe o que acontece

11330
07:38:44,398 --> 07:38:46,798
ferramenta ativa é o marker active thought is

11331
07:38:46,798 --> 07:38:48,878
A ferramenta ativa da borracha é retângulo nós

11332
07:38:48,878 --> 07:38:50,000
Basicamente,

11333
07:38:50,000 --> 07:38:53,200
imprimir todos os outros casos após a macro

11334
07:38:53,200 --> 07:38:54,798
O caso é a cabeça

11335
07:38:54,798 --> 07:38:57,440
e se tentarmos mudar isso por exemplo

11336
07:38:57,440 --> 07:39:00,000
não usar marcador e usar borracha

11337
07:39:00,000 --> 07:39:01,760
Mudar isso você vai ver aquilo

11338
07:39:01,760 --> 07:39:02,958
nós vamos

11339
07:39:02,958 --> 07:39:05,520
match the eraser case

11340
07:39:05,520 --> 07:39:07,840
E tudo depois disso também está indo

11341
07:39:07,840 --> 07:39:10,080
Executar e não é o que você quer

11342
07:39:10,080 --> 07:39:12,398
Então vamos limpar e correr galo você é

11343
07:39:12,398 --> 07:39:14,398
indo ver a borracha rectangle círculo

11344
07:39:14,398 --> 07:39:16,798
ellipse e nenhum fósforo encontrado, então você tem

11345
07:39:16,798 --> 07:39:18,958
Pronto para lembrar de colocar neste tijolo

11346
07:39:18,958 --> 07:39:21,520
declaração eu vou bater ctrl z a

11347
07:39:21,520 --> 07:39:24,240
Algumas vezes e trazer isso dentro e eu

11348
07:39:24,240 --> 07:39:26,558
Acho que isso é o suficiente para acertar

11349
07:39:26,558 --> 07:39:29,440
novamente para que o marcador também o tenha e se

11350
07:39:29,440 --> 07:39:31,360
nós corremos agora vamos conseguir o que nós

11351
07:39:31,360 --> 07:39:33,840
Espero vamos tentar usar uma borracha novamente

11352
07:39:33,840 --> 07:39:36,558
e se nós dois novamente e limpar e correr

11353
07:39:36,558 --> 07:39:38,718
Galo, vamos ver a ferramenta ativa

11354
07:39:38,718 --> 07:39:41,120
É razer e estamos seguindo em frente

11355
07:39:41,120 --> 07:39:43,200
Isto é o que esperamos, isto é

11356
07:39:43,200 --> 07:39:45,440
realmente como você trabalha com um interruptor

11357
07:39:45,440 --> 07:39:47,200
bloco que você tem que passar em seu

11358
07:39:47,200 --> 07:39:50,000
expressão ou seu caso de teste e você

11359
07:39:50,000 --> 07:39:52,718
pegar cada caso usando esta sintaxe do caso

11360
07:39:52,718 --> 07:39:55,520
Aqui você diz caso você passa em qualquer coisa

11361
07:39:55,520 --> 07:39:57,200
Você quer combinar e você coloca um

11362
07:39:57,200 --> 07:39:59,680
coluna e você coloca seu código dentro deste

11363
07:39:59,680 --> 07:40:02,638
Bloquear aqui e lembrar após cada caso

11364
07:40:02,638 --> 07:40:05,440
você tem que adicionar esta pausa de outra forma

11365
07:40:05,440 --> 07:40:07,120
Tudo o resto depois disso vai

11366
07:40:07,120 --> 07:40:09,600
executar e não vai ser o que

11367
07:40:09,600 --> 07:40:12,478
Você quer antes que eu deixe você ir eu quero

11368
07:40:12,478 --> 07:40:14,240
mostrar que você pode realmente agrupar

11369
07:40:14,240 --> 07:40:16,878
estas declarações de caso, se é o que é

11370
07:40:16,878 --> 07:40:19,680
fazer sentido para sua aplicação para

11371
07:40:19,680 --> 07:40:21,200
O exemplo

11372
07:40:21,200 --> 07:40:22,080
para a

11373
07:40:22,080 --> 07:40:25,520
círculo e elipse do retângulo

11374
07:40:25,520 --> 07:40:27,760
Isso pode ser agrupado no grupo de

11375
07:40:27,760 --> 07:40:28,798
formas

11376
07:40:28,798 --> 07:40:31,280
Então podemos realmente dizer

11377
07:40:31,280 --> 07:40:33,440
Retângulo do caso

11378
07:40:33,440 --> 07:40:36,478
E uh colocá-los em diferentes linhas

11379
07:40:36,478 --> 07:40:39,760
Algo assim, então vamos excluir isso

11380
07:40:39,760 --> 07:40:41,920
e dizer caso retângulo

11381
07:40:41,920 --> 07:40:43,680
e vamos apagar o outro

11382
07:40:43,680 --> 07:40:44,878
Coisas

11383
07:40:44,878 --> 07:40:46,080
E dizer

11384
07:40:46,080 --> 07:40:48,878
círculo de casos assim e nós somos

11385
07:40:48,878 --> 07:40:51,920
Vou dizer forma de desenho eu acho isso

11386
07:40:51,920 --> 07:40:54,798
A sintaxe é suportada em c plus mais OK

11387
07:40:54,798 --> 07:40:57,760
Então vamos tentar no mundo

11388
07:40:57,760 --> 07:41:01,520
E uh nós vamos para o mundo com gcc

11389
07:41:01,520 --> 07:41:03,920
E o mundo vai ser bom assim se

11390
07:41:03,920 --> 07:41:06,000
Temos uma navalha que é o que temos em

11391
07:41:06,000 --> 07:41:08,398
Aqui vamos dizer forma de desenho

11392
07:41:08,398 --> 07:41:10,240
Vamos limpar

11393
07:41:10,240 --> 07:41:12,240
e correr o galo

11394
07:41:12,240 --> 07:41:14,000
você vai ver formas de desenho

11395
07:41:14,000 --> 07:41:17,040
Em movimento, nós agrupamos diferentes

11396
07:41:17,040 --> 07:41:21,040
Casos e os manuseia com um bloco

11397
07:41:21,040 --> 07:41:23,280
E isso pode ser útil em alguns

11398
07:41:23,280 --> 07:41:24,878
As situações

11399
07:41:24,878 --> 07:41:26,558
Uma coisa que você deve ter em mente é

11400
07:41:26,558 --> 07:41:29,120
Existem limitações sobre o que você

11401
07:41:29,120 --> 07:41:32,320
pode usar como uma expressão ou condição

11402
07:41:32,320 --> 07:41:34,558
em sua declaração de mudança e isso tem que

11403
07:41:34,558 --> 07:41:37,520
ser um inteiro algo como um carro de formi

11404
07:41:37,520 --> 07:41:39,520
coisas mais curtas não assinadas como que nós

11405
07:41:39,520 --> 07:41:41,920
Eles viram todas essas coisas, mas pode

11406
07:41:41,920 --> 07:41:44,718
também ser um enum, mas enam é algo que nós

11407
07:41:44,718 --> 07:41:46,398
Ainda não aprendemos que vamos aprender

11408
07:41:46,398 --> 07:41:48,558
Mais tarde, quando temos ferramentas suficientes

11409
07:41:48,558 --> 07:41:50,878
para entender isso, mas saiba disso

11410
07:41:50,878 --> 07:41:52,160
Limitação de limitação

11411
07:41:52,160 --> 07:41:55,200
se pudermos em nosso projeto em visual

11412
07:41:55,200 --> 07:41:58,000
código de estúdio, por exemplo, e dizer

11413
07:41:58,000 --> 07:42:00,878
std string nome e dizer

11414
07:42:00,878 --> 07:42:03,600
john, por exemplo, e usar isso como um

11415
07:42:03,600 --> 07:42:06,638
condição ou expressão do interruptor que temos

11416
07:42:06,638 --> 07:42:08,558
para incluir string para que isso funcione, então

11417
07:42:08,558 --> 07:42:10,080
Vamos lá para cima

11418
07:42:10,080 --> 07:42:12,478
e incluir a biblioteca de strings que somos

11419
07:42:12,478 --> 07:42:14,798
indo para fazer corda e se vamos para baixo

11420
07:42:14,798 --> 07:42:17,840
novamente e tentar mudar e usar o nome

11421
07:42:17,840 --> 07:42:20,320
como expressão e tirar tudo

11422
07:42:20,320 --> 07:42:22,638
nós temos aqui e tentamos compilar isso

11423
07:42:22,638 --> 07:42:25,200
você vê que o compilador não está feliz

11424
07:42:25,200 --> 07:42:27,600
Tudo bem, vai dizer que a expressão deve

11425
07:42:27,600 --> 07:42:30,878
ter um tipo integral ou enum, então este é

11426
07:42:30,878 --> 07:42:32,478
Nem mesmo vou compilar isso é um

11427
07:42:32,478 --> 07:42:34,638
limitação que você tem e você tem que fazer

11428
07:42:34,638 --> 07:42:37,600
O que você passa como uma condição aqui

11429
07:42:37,600 --> 07:42:41,040
é um inteiro como formi ou carro

11430
07:42:41,040 --> 07:42:43,520
ou outros tipos integrais que aprendemos

11431
07:42:43,520 --> 07:42:46,638
sobre neste curso

11432
07:42:46,878 --> 07:42:48,558
Esta palestra vamos aprender sobre

11433
07:42:48,558 --> 07:42:51,280
operadores ternários e este é um

11434
07:42:51,280 --> 07:42:54,878
forma alternativa de fazer testes com a se

11435
07:42:54,878 --> 07:42:56,160
Declaração

11436
07:42:56,160 --> 07:42:58,398
Suponhamos aqui que temos uma variável chamada

11437
07:42:58,398 --> 07:43:01,280
máximo temos duas variáveis chamadas a e b

11438
07:43:01,280 --> 07:43:03,200
e queremos encontrar o máximo entre

11439
07:43:03,200 --> 07:43:04,718
Essas duas coisas

11440
07:43:04,718 --> 07:43:07,840
Uma maneira fácil de fazer isso é dizer se

11441
07:43:07,840 --> 07:43:09,600
é maior do que b vamos armazenar

11442
07:43:09,600 --> 07:43:12,878
o máximo no máximo, então b está indo

11443
07:43:12,878 --> 07:43:14,478
para ser o máximo e nós vamos

11444
07:43:14,478 --> 07:43:17,200
armazenar isso em nosso valor máximo e

11445
07:43:17,200 --> 07:43:18,878
nós vamos imprimir isso se o fizermos

11446
07:43:18,878 --> 07:43:20,798
Isso nós vamos conseguir o que for

11447
07:43:20,798 --> 07:43:23,360
máximo entre a e b a imprimir

11448
07:43:23,360 --> 07:43:25,280
fora no console e isso vai

11449
07:43:25,280 --> 07:43:28,000
trabalhar muito bem, mas também podemos usar um

11450
07:43:28,000 --> 07:43:30,398
A expressão ternária e o ternário

11451
07:43:30,398 --> 07:43:32,240
A expressão se parece com isso

11452
07:43:32,240 --> 07:43:34,958
e começa com um par de parênteses

11453
07:43:34,958 --> 07:43:36,398
Você vai colocar sua condição

11454
07:43:36,398 --> 07:43:38,320
Dentro do parêntese que você vai

11455
07:43:38,320 --> 07:43:40,240
Siga isso com o ponto de interrogação

11456
07:43:40,240 --> 07:43:42,478
Você vai colocar sua opção um e

11457
07:43:42,478 --> 07:43:44,080
Depois que você vai colocar uma coluna

11458
07:43:44,080 --> 07:43:46,718
e opção dois e porque isso é um

11459
07:43:46,718 --> 07:43:49,200
declaração em c plus mais vamos

11460
07:43:49,200 --> 07:43:52,558
terminar isso com um ponto e vírgula aqui é um

11461
07:43:52,558 --> 07:43:54,798
versão equivalente disso

11462
07:43:54,798 --> 07:43:57,840
usando f como temos feito o tempo todo

11463
07:43:57,840 --> 07:44:00,080
então dizemos se os resultados da condição são iguais

11464
07:44:00,080 --> 07:44:03,040
opção um se a condição for um resultado falso

11465
07:44:03,040 --> 07:44:05,040
será igual à opção dois e

11466
07:44:05,040 --> 07:44:07,040
É exatamente a mesma coisa que somos

11467
07:44:07,040 --> 07:44:09,520
Fazendo com nossa expressão ternária aqui

11468
07:44:09,520 --> 07:44:11,280
Se a condição for verdadeira, vamos

11469
07:44:11,280 --> 07:44:13,600
tomar a opção um e atribuir isso para

11470
07:44:13,600 --> 07:44:15,760
Resultado se for falso, vamos levar

11471
07:44:15,760 --> 07:44:18,958
opção dois e atribuir isso ao resort assim

11472
07:44:18,958 --> 07:44:21,360
Este é realmente um açúcar sintático ou um

11473
07:44:21,360 --> 07:44:24,160
A taquigrafia para esta coisa aqui e é

11474
07:44:24,160 --> 07:44:25,840
vai fazer o seu código mais curto e

11475
07:44:25,840 --> 07:44:27,360
você vai ver isso por toda parte

11476
07:44:27,360 --> 07:44:28,240
lugar

11477
07:44:28,240 --> 07:44:30,958
em c plus código lá fora, então você

11478
07:44:30,958 --> 07:44:32,320
Eu realmente precisa ser

11479
07:44:32,320 --> 07:44:35,600
familiar com isso ok, então aqui está o nosso

11480
07:44:35,600 --> 07:44:38,320
exemplo de calcular o máximo que você vê

11481
07:44:38,320 --> 07:44:40,638
que temos as mesmas variáveis max a

11482
07:44:40,638 --> 07:44:43,520
e b mas nós temos um único forro que é

11483
07:44:43,520 --> 07:44:45,760
indo para armazenar o máximo no máximo e nós

11484
07:44:45,760 --> 07:44:47,280
pode imprimir isso fora

11485
07:44:47,280 --> 07:44:49,680
E espero que você possa ver que isso é

11486
07:44:49,680 --> 07:44:52,638
mais curto e melhor do que este ok um

11487
07:44:52,638 --> 07:44:54,240
Outra coisa que você deve saber é que

11488
07:44:54,240 --> 07:44:57,520
opção um e a opção dois devem ser de

11489
07:44:57,520 --> 07:45:00,638
o mesmo tipo ou pelo menos os tipos devem

11490
07:45:00,638 --> 07:45:02,718
Ser conversível e se isso falhar você é

11491
07:45:02,718 --> 07:45:04,478
vamos ter um erro de compilador que podemos

11492
07:45:04,478 --> 07:45:06,798
Também fazemos a inicialização ternária aqui nós

11493
07:45:06,798 --> 07:45:09,360
Tenho um booleano chamado rápido

11494
07:45:09,360 --> 07:45:12,320
inicializamos isso para falso que podemos usar

11495
07:45:12,320 --> 07:45:14,320
Isso para

11496
07:45:14,320 --> 07:45:16,878
inicializar nossa variável de velocidade aqui

11497
07:45:16,878 --> 07:45:19,680
estão basicamente dizendo se inicializar rapidamente

11498
07:45:19,680 --> 07:45:23,040
Isso com 300 se não rápido

11499
07:45:23,040 --> 07:45:25,680
inicialize isso com 150

11500
07:45:25,680 --> 07:45:27,360
E nós vamos imprimir a velocidade aqui

11501
07:45:27,360 --> 07:45:29,440
E isso vai funcionar e aqui você

11502
07:45:29,440 --> 07:45:31,760
Veja que eu menti um pouco no meu

11503
07:45:31,760 --> 07:45:34,240
explicação para torná-lo realmente óbvio

11504
07:45:34,240 --> 07:45:36,958
O que tínhamos em nossa expressão ternária

11505
07:45:36,958 --> 07:45:39,200
Você não tem que sempre envolvê-lo

11506
07:45:39,200 --> 07:45:41,760
condição entre parênteses, mas faz

11507
07:45:41,760 --> 07:45:44,160
O código muito mais limpo está bem agora que você

11508
07:45:44,160 --> 07:45:47,040
Tenho uma ideia sobre a distância, é hora de nós

11509
07:45:47,040 --> 07:45:49,280
indo para o código do estúdio visual e

11510
07:45:49,280 --> 07:45:53,040
realmente tentei isso e assim para nós mesmos

11511
07:45:53,040 --> 07:45:56,000
Tudo bem aqui estamos em nossa pasta de trabalho

11512
07:45:56,000 --> 07:45:58,878
O projeto atual é operadores ternário

11513
07:45:58,878 --> 07:46:02,160
nós vamos pegar nossos arquivos de modelo

11514
07:46:02,160 --> 07:46:05,200
e colocar aqueles onde eles pertencem é em

11515
07:46:05,200 --> 07:46:08,080
esta palestra aqui sobre operadores ternário

11516
07:46:08,080 --> 07:46:09,760
E nós vamos abrir isso para dentro

11517
07:46:09,760 --> 07:46:12,558
código de estúdio visual como sempre fazemos

11518
07:46:12,558 --> 07:46:14,638
Vou abrir isso e nós vamos

11519
07:46:14,638 --> 07:46:17,280
abrir cpp principal e tirar o que quer que nós

11520
07:46:17,280 --> 07:46:19,840
Não precisamos que vamos descer e

11521
07:46:19,840 --> 07:46:22,718
colocar em nosso código de teste, basicamente, temos um

11522
07:46:22,718 --> 07:46:25,520
Algumas variáveis, vamos matar esses espaços, então

11523
07:46:25,520 --> 07:46:28,478
que o nosso código não está desordenado aqui e

11524
07:46:28,478 --> 07:46:31,360
Vamos imprimir o nosso máximo

11525
07:46:31,360 --> 07:46:33,440
e nós vamos usar um regular se

11526
07:46:33,440 --> 07:46:36,320
temos três variáveis max a e b

11527
07:46:36,320 --> 07:46:39,280
estão dizendo se a é maior que b

11528
07:46:39,280 --> 07:46:43,200
nós vamos armazenar o máximo e max

11529
07:46:43,200 --> 07:46:45,360
Caso contrário, vamos armazenar b

11530
07:46:45,360 --> 07:46:46,478
em max

11531
07:46:46,478 --> 07:46:48,398
e isso nos permitirá imprimir

11532
07:46:48,398 --> 07:46:50,798
Seja qual for o máximo entre 35 e

11533
07:46:50,798 --> 07:46:53,520
20. se construirmos isso vamos trazer um

11534
07:46:53,520 --> 07:46:54,958
O terminal

11535
07:46:54,958 --> 07:46:57,760
e nós vamos construir com gcc como nós

11536
07:46:57,760 --> 07:47:00,080
Sempre fazer vamos trazer isso um pouco

11537
07:47:00,080 --> 07:47:02,160
Um pouco e nós vamos limpar

11538
07:47:02,160 --> 07:47:04,160
e correr o galo, vamos ver isso

11539
07:47:04,160 --> 07:47:07,280
o máximo é 35 se colocarmos o nosso máximo

11540
07:47:07,280 --> 07:47:08,478
em um feixe

11541
07:47:08,478 --> 07:47:10,638
nós vamos obter o máximo de aço, então

11542
07:47:10,638 --> 07:47:12,240
nós vamos correr isso para construir

11543
07:47:12,240 --> 07:47:14,638
com o Gcc

11544
07:47:14,638 --> 07:47:16,958
e nós vamos correr tão claro

11545
07:47:16,958 --> 07:47:18,478
Galo

11546
07:47:18,478 --> 07:47:20,478
O máximo é 200, então nós vamos conseguir o

11547
07:47:20,478 --> 07:47:23,680
máximo independentemente de onde é armazenado

11548
07:47:23,680 --> 07:47:27,120
em a ou b é assim que o nosso código funciona, mas

11549
07:47:27,120 --> 07:47:30,080
nós podemos usar os operadores ternário para fazer o

11550
07:47:30,080 --> 07:47:31,280
A mesma coisa

11551
07:47:31,280 --> 07:47:32,638
Então o que vamos fazer aqui estamos

11552
07:47:32,638 --> 07:47:35,200
Vou comentar a nossa declaração se

11553
07:47:35,200 --> 07:47:36,320
e usar

11554
07:47:36,320 --> 07:47:39,280
uma versão ternária para o que vamos

11555
07:47:39,280 --> 07:47:42,160
Será que vamos dizer resultados iguais

11556
07:47:42,160 --> 07:47:44,958
e nós vamos dizer um maior que b

11557
07:47:44,958 --> 07:47:47,200
nós vamos colocar um ponto de interrogação para

11558
07:47:47,200 --> 07:47:48,320
sinal

11559
07:47:48,320 --> 07:47:49,520
O que é

11560
07:47:49,520 --> 07:47:51,920
O início da nossa opção de duas opções é

11561
07:47:51,920 --> 07:47:54,638
Será um porque se um é maior

11562
07:47:54,638 --> 07:47:57,600
do que b então a será o máximo

11563
07:47:57,600 --> 07:48:00,638
Então nós vamos pegar um aqui e se

11564
07:48:00,638 --> 07:48:02,558
Não é maior que b

11565
07:48:02,558 --> 07:48:04,558
então b deve ser o máximo, então nós somos

11566
07:48:04,558 --> 07:48:06,638
Vou colocar isso como uma segunda opção

11567
07:48:06,638 --> 07:48:08,878
Aqui é isso que queremos dizer com isso

11568
07:48:08,878 --> 07:48:10,638
Declaração e não temos uma variável

11569
07:48:10,638 --> 07:48:12,638
chamados resultados, é por isso que temos uma

11570
07:48:12,638 --> 07:48:14,718
problema aqui nós vamos colocar o nosso

11571
07:48:14,718 --> 07:48:17,360
Resultar no máximo e isso deve

11572
07:48:17,360 --> 07:48:19,040
resolver este problema

11573
07:48:19,040 --> 07:48:22,000
você vê as linhas esquiggly vão embora e

11574
07:48:22,000 --> 07:48:23,760
nós podemos construir isso e nós vamos conseguir

11575
07:48:23,760 --> 07:48:26,478
Exatamente o mesmo resultado, então este é nosso

11576
07:48:26,478 --> 07:48:29,200
operador ternário se nós construirmos isso é

11577
07:48:29,200 --> 07:48:31,920
indo para passar e se nós executarmos isso

11578
07:48:31,920 --> 07:48:33,520
nós vamos ter exatamente o mesmo

11579
07:48:33,520 --> 07:48:36,798
O resultado máximo é 200 e é o que nós

11580
07:48:36,798 --> 07:48:39,440
Esperar bem, então tome algum tempo e realmente

11581
07:48:39,440 --> 07:48:43,040
familiarizar-se com esta sintaxe

11582
07:48:43,040 --> 07:48:44,878
É realmente nada complicado você

11583
07:48:44,878 --> 07:48:47,760
Só precisa ter certeza de que seu cérebro está

11584
07:48:47,760 --> 07:48:49,840
Consciente de algo assim e você está

11585
07:48:49,840 --> 07:48:51,600
Vou reconhecer que em todos os lugares você

11586
07:48:51,600 --> 07:48:54,320
Veja isso em código lá fora, ok, temos

11587
07:48:54,320 --> 07:48:57,120
Mencionou que você não pode passar tipos que

11588
07:48:57,120 --> 07:48:59,680
não são compatíveis e a exigência

11589
07:48:59,680 --> 07:49:02,718
é que a e b são do mesmo tipo

11590
07:49:02,718 --> 07:49:05,680
ou pelo menos tipos que você pode fazer conversões

11591
07:49:05,680 --> 07:49:08,718
entre isso, por exemplo, se tentarmos fazer

11592
07:49:08,718 --> 07:49:10,558
Algo como

11593
07:49:10,558 --> 07:49:13,200
Passe um olá aqui

11594
07:49:13,200 --> 07:49:17,040
Nós não podemos realmente transformar uma força em um

11595
07:49:17,040 --> 07:49:19,360
inteiro e isso vai nos dar uma

11596
07:49:19,360 --> 07:49:21,760
Erro do compilador e vamos olhar para o

11597
07:49:21,760 --> 07:49:23,760
erro que vemos a partir do código do estúdio visual

11598
07:49:23,760 --> 07:49:26,558
Os tipos de ópera são incompatíveis e

11599
07:49:26,558 --> 07:49:29,200
O carro const não é compatível e

11600
07:49:29,200 --> 07:49:31,760
Eles têm que ser compatíveis se ignorarmos

11601
07:49:31,760 --> 07:49:33,520
Isto e vá em frente e construir estamos indo

11602
07:49:33,520 --> 07:49:36,478
para ver também um erro do compilador

11603
07:49:36,478 --> 07:49:39,840
e deve ser o mesmo erro assim

11604
07:49:39,840 --> 07:49:41,520
operandos para

11605
07:49:41,520 --> 07:49:43,760
O ponto de interrogação e a coluna têm diferentes

11606
07:49:43,760 --> 07:49:46,000
Tipos e carro de custo

11607
07:49:46,000 --> 07:49:47,840
E eles têm que ser

11608
07:49:47,840 --> 07:49:50,398
você pode realmente comparar, então para

11609
07:49:50,398 --> 07:49:52,878
Um exemplo, podemos tirar essa string aqui

11610
07:49:52,878 --> 07:49:55,680
e colocar em um ponto flutuante vamos colocar em

11611
07:49:55,680 --> 07:49:59,120
um 22,5 e dizer que este é um fluido

11612
07:49:59,120 --> 07:50:00,638
Você vai ver que o problema é

11613
07:50:00,638 --> 07:50:02,558
indo embora aqui vamos esperar por um

11614
07:50:02,558 --> 07:50:04,638
Minuto que não vai embora, nós vamos

11615
07:50:04,638 --> 07:50:06,638
para construir de qualquer maneira, você vê que o mundo é

11616
07:50:06,638 --> 07:50:08,958
Bom vamos limpar

11617
07:50:08,958 --> 07:50:10,878
para que não tenhamos toda essa desordem

11618
07:50:10,878 --> 07:50:13,440
você vê os problemas a propósito e se nós

11619
07:50:13,440 --> 07:50:15,840
Ambos novamente, vamos tentar fazer isso

11620
07:50:15,840 --> 07:50:17,520
O construtor vai passar e se nós

11621
07:50:17,520 --> 07:50:19,680
Executar isso, nós vamos conseguir

11622
07:50:19,680 --> 07:50:23,600
o máximo é 22 porque estamos comparando a e

11623
07:50:23,600 --> 07:50:26,240
22 aqui e que o compilador inseriu um

11624
07:50:26,240 --> 07:50:28,240
conversão implícita a partir desta flutuação

11625
07:50:28,240 --> 07:50:30,638
apontar para inteiro é por isso que somos

11626
07:50:30,638 --> 07:50:32,160
Vendo isso aqui

11627
07:50:32,160 --> 07:50:34,798
então qual é o tipo que é o compilador

11628
07:50:34,798 --> 07:50:37,120
realmente usado aqui bem para torná-lo realmente

11629
07:50:37,120 --> 07:50:39,760
claro o que está acontecendo, não vamos

11630
07:50:39,760 --> 07:50:40,878
A sua forma de

11631
07:50:40,878 --> 07:50:44,878
use max aqui, digamos, auto max one

11632
07:50:44,878 --> 07:50:46,718
e ver o que o compilador é realmente

11633
07:50:46,718 --> 07:50:48,320
deduzir para

11634
07:50:48,320 --> 07:50:50,878
Então nós vamos tirar isso

11635
07:50:50,878 --> 07:50:53,200
E por isso vamos ver

11636
07:50:53,200 --> 07:50:56,160
Qual é a conversão implícita do compilador

11637
07:50:56,160 --> 07:50:58,638
Realmente aqui porque o que tínhamos

11638
07:50:58,638 --> 07:51:00,718
antes de fazermos uma tarefa, então

11639
07:51:00,718 --> 07:51:03,040
O que estava à esquerda estava sendo

11640
07:51:03,040 --> 07:51:04,878
se transformou em um inteiro porque nós éramos

11641
07:51:04,878 --> 07:51:07,440
fazer uma conversão implícita de um

11642
07:51:07,440 --> 07:51:09,680
atribuição para que o que quer que esteja à esquerda é

11643
07:51:09,680 --> 07:51:12,080
transformados no tipo de tudo o que temos

11644
07:51:12,080 --> 07:51:14,160
à esquerda da missão eu espero que você

11645
07:51:14,160 --> 07:51:16,398
Saiba isso já, mas se fizermos as coisas

11646
07:51:16,398 --> 07:51:18,798
assim, nós vamos deduzir o que

11647
07:51:18,798 --> 07:51:21,360
está à esquerda e atribui isso ao máximo

11648
07:51:21,360 --> 07:51:23,200
um para que nós vamos fazer isso nós vamos

11649
07:51:23,200 --> 07:51:24,958
ver a conversão implícita que o

11650
07:51:24,958 --> 07:51:27,360
O compilador fez aqui e é bom

11651
07:51:27,360 --> 07:51:29,680
ser capaz de ver coisas assim que é um

11652
07:51:29,680 --> 07:51:31,520
A curiosidade assim

11653
07:51:31,520 --> 07:51:32,958
Vamos ver o que acontece aqui estamos indo

11654
07:51:32,958 --> 07:51:36,000
para imprimir max one e eu estou indo para o mundo

11655
07:51:36,000 --> 07:51:39,360
com gcc isso vai passar

11656
07:51:39,360 --> 07:51:41,360
e vamos ver o que é impresso

11657
07:51:41,360 --> 07:51:43,280
Então vamos correr o galo

11658
07:51:43,280 --> 07:51:44,478
E você vai ver que

11659
07:51:44,478 --> 07:51:47,360
A conversão implícita aconteceu de ponta a ponta

11660
07:51:47,360 --> 07:51:50,160
inundação e nós deduzimos a inundação aqui em

11661
07:51:50,160 --> 07:51:52,558
máximo um, então isso é realmente interessante

11662
07:51:52,558 --> 07:51:54,878
alguém poderia ter pensado que nós tínhamos um

11663
07:51:54,878 --> 07:51:56,798
A conversão do float

11664
07:51:56,798 --> 07:51:59,280
para terminar, mas foi realmente o inverso

11665
07:51:59,280 --> 07:52:01,440
E isso é bastante interessante, isso é

11666
07:52:01,440 --> 07:52:02,798
Realmente tudo o que nos posicionamos para fazer nisso

11667
07:52:02,798 --> 07:52:05,280
Uma palestra espero que você tenha achado interessante

11668
07:52:05,280 --> 07:52:07,440
novamente certifique-se de que você tem esta sintaxe

11669
07:52:07,440 --> 07:52:09,520
Aqui perfurado em seu cérebro porque

11670
07:52:09,520 --> 07:52:11,280
você vai estar vendo isso muito dentro

11671
07:52:11,280 --> 07:52:14,080
sua carreira como desenvolvedor de software não

11672
07:52:14,080 --> 07:52:16,478
apenas um c plus desenvolvedor realmente

11673
07:52:16,478 --> 07:52:18,558
E vai ser útil

11674
07:52:18,558 --> 07:52:20,120
para você saber isso

11675
07:52:20,120 --> 07:52:22,398
Parabéns pelo fim de

11676
07:52:22,398 --> 07:52:24,798
Este capítulo deste capítulo foi tudo sobre

11677
07:52:24,798 --> 07:52:26,878
controle de fluxo e tivemos a chance de

11678
07:52:26,878 --> 07:52:29,200
Saiba mais sobre muitas das ferramentas que c

11679
07:52:29,200 --> 07:52:32,000
Plus plus fornece para fazer condicionais

11680
07:52:32,000 --> 07:52:34,000
programação e fomos capazes de ver tudo

11681
07:52:34,000 --> 07:52:35,920
Tipos de coisas loucas que tivemos a chance

11682
07:52:35,920 --> 07:52:38,240
para fazer coisas como se o vermelho é verdade, nós somos

11683
07:52:38,240 --> 07:52:40,638
vai executar o código dentro se amarelo

11684
07:52:40,638 --> 07:52:42,638
É verdade que vamos executar o código dentro

11685
07:52:42,638 --> 07:52:44,478
Se o verde é verdade, vamos executar o código

11686
07:52:44,478 --> 07:52:46,320
Dentro e você teve a chance de brincar com

11687
07:52:46,320 --> 07:52:49,440
Essas coisas em muitas ocasiões temos

11688
07:52:49,440 --> 07:52:51,440
viu que as ferramentas que c plus mais

11689
07:52:51,440 --> 07:52:53,600
Os suprimentos realmente giram em torno destes

11690
07:52:53,600 --> 07:52:56,240
quatro coisas aqui que temos se declarações

11691
07:52:56,240 --> 07:52:58,478
Podemos fazer mais fechamentos

11692
07:52:58,478 --> 07:53:02,320
nisto, se afirmações podemos fazer mais se

11693
07:53:02,320 --> 07:53:05,120
para realmente fazer longas cadeias de coisas onde

11694
07:53:05,120 --> 07:53:07,360
Nós fazemos decisões diferentes para fazer as coisas

11695
07:53:07,360 --> 07:53:10,080
em nossas aplicações também vimos que

11696
07:53:10,080 --> 07:53:12,320
O switch é uma opção se você tiver vários

11697
07:53:12,320 --> 07:53:14,398
decisões que você pode tomar em seu

11698
07:53:14,398 --> 07:53:17,120
aplicação e vimos que um ternário

11699
07:53:17,120 --> 07:53:20,080
O operador pode realmente ser usado para fazer

11700
07:53:20,080 --> 07:53:22,718
duas decisões se você tiver duas decisões

11701
07:53:22,718 --> 07:53:25,120
Você será capaz de reduzir o

11702
07:53:25,120 --> 07:53:27,920
número de linhas que você costumava fazer isso

11703
07:53:27,920 --> 07:53:30,478
decisões com uma linha e tivemos uma

11704
07:53:30,478 --> 07:53:32,638
chance de realmente olhar para isso em detalhes

11705
07:53:32,638 --> 07:53:35,520
na palestra sobre operadores ternários este

11706
07:53:35,520 --> 07:53:37,520
É realmente tudo que eu tive que compartilhar disso

11707
07:53:37,520 --> 07:53:40,000
capítulo Espero que você o tenha achado interessante

11708
07:53:40,000 --> 07:53:41,440
Vamos parar aqui neste

11709
07:53:41,440 --> 07:53:43,200
palestra no próximo capítulo que vamos

11710
07:53:43,200 --> 07:53:46,080
para começar e aprender sobre loops

11711
07:53:46,080 --> 07:53:48,398
Vá em frente e termine aqui e me encontre

11712
07:53:48,398 --> 07:53:50,638
lá neste capítulo vamos ser

11713
07:53:50,638 --> 07:53:53,360
aprender sobre loops e isso é um

11714
07:53:53,360 --> 07:53:56,080
construção que é fornecida pelo c plus

11715
07:53:56,080 --> 07:53:58,638
além da linguagem de programação para permitir que você

11716
07:53:58,638 --> 07:54:03,360
fazer tarefas repetitivas com relativa facilidade

11717
07:54:03,360 --> 07:54:06,638
Suponha que temos uma tarefa para imprimir um

11718
07:54:06,638 --> 07:54:08,320
mensagem 10 vezes

11719
07:54:08,320 --> 07:54:10,878
Podemos ir para baixo e fazê-lo assim e

11720
07:54:10,878 --> 07:54:13,280
Vai funcionar, mas e se eles tentarem

11721
07:54:13,280 --> 07:54:14,398
e dizer-lhe

11722
07:54:14,398 --> 07:54:16,478
fazer isso 100 vezes, então você vai

11723
07:54:16,478 --> 07:54:18,000
Comece coçando sua cabeça que você está indo

11724
07:54:18,000 --> 07:54:20,080
para digitar isso 100 vezes e você está indo

11725
07:54:20,080 --> 07:54:22,000
para executar o seu programa e ele vai

11726
07:54:22,000 --> 07:54:24,160
trabalhar, então seu gerente aparece e eles

11727
07:54:24,160 --> 07:54:26,558
Eu quero que você faça isso 10 000 vezes

11728
07:54:26,558 --> 07:54:28,798
ou mesmo 100 000 vezes e então você está

11729
07:54:28,798 --> 07:54:30,558
começar a puxar o cabelo ou

11730
07:54:30,558 --> 07:54:32,718
correndo por aí quebrando aberturas porque

11731
07:54:32,718 --> 07:54:34,878
É impossível não se preocupar

11732
07:54:34,878 --> 07:54:37,840
Aqui c plus plus fornece uma maneira de fazer

11733
07:54:37,840 --> 07:54:40,000
Isso é relativamente fácil e nós vamos

11734
07:54:40,000 --> 07:54:42,320
para aprendermos sobre maneiras de fazer isso

11735
07:54:42,320 --> 07:54:45,120
em nosso programa neste capítulo o

11736
07:54:45,120 --> 07:54:46,878
As construções que vamos usar são

11737
07:54:46,878 --> 07:54:49,520
Estes que você vê aqui há um para loop a

11738
07:54:49,520 --> 07:54:51,760
base de alcance para um loop um loop de tempo e

11739
07:54:51,760 --> 07:54:54,398
fazer um loop de tempo e nós podemos fazer uso de

11740
07:54:54,398 --> 07:54:57,840
estas ferramentas para não enlouquecer a impressão de

11741
07:54:57,840 --> 07:55:00,798
mensagem um milhão de vezes, porque isso é

11742
07:55:00,798 --> 07:55:01,920
Realmente ruim

11743
07:55:01,920 --> 07:55:04,160
Tudo bem, então é isso que estamos enfrentando

11744
07:55:04,160 --> 07:55:05,600
Este capítulo vamos aprender

11745
07:55:05,600 --> 07:55:07,760
sobre essas construções de loop e você é

11746
07:55:07,760 --> 07:55:09,840
Vou descobrir que eles são muito legais

11747
07:55:09,840 --> 07:55:12,160
para sua inscrição eu estou animado para ser

11748
07:55:12,160 --> 07:55:14,320
Ensinando isso para começar

11749
07:55:14,320 --> 07:55:16,638
na próxima palestra e aprender sobre o

11750
07:55:16,638 --> 07:55:19,600
para loop vá em frente e termine aqui e

11751
07:55:19,600 --> 07:55:21,440
Encontre-me lá nesta palestra que estamos

11752
07:55:21,440 --> 07:55:24,240
Vou aprender sobre quatro loops

11753
07:55:24,240 --> 07:55:26,558
para loops são uma das construções que nós

11754
07:55:26,558 --> 07:55:29,120
ter em c plus plus para fazer repetitivo

11755
07:55:29,120 --> 07:55:31,440
tarefas nos permitem fazer algo como

11756
07:55:31,440 --> 07:55:33,520
Muito mais facilmente, por exemplo,

11757
07:55:33,520 --> 07:55:36,718
não tem que digitar stdc fora de c mais

11758
07:55:36,718 --> 07:55:40,240
mais 10 vezes ou 100 vezes que podemos fazer

11759
07:55:40,240 --> 07:55:42,398
Isso em menos de cinco linhas e você está

11760
07:55:42,398 --> 07:55:44,558
Vou ver como isso é legal

11761
07:55:44,558 --> 07:55:47,680
para loops se parece com isso e pode

11762
07:55:47,680 --> 07:55:50,398
olhar intimidante para os primeiros usuários, mas

11763
07:55:50,398 --> 07:55:53,200
nós vamos quebrar isso, temos um

11764
07:55:53,200 --> 07:55:56,160
Poucas partes aqui a primeira parte é a

11765
07:55:56,160 --> 07:55:58,638
iterador que é uma variável que somos

11766
07:55:58,638 --> 07:56:01,440
Vou usar para navegar através

11767
07:56:01,440 --> 07:56:03,520
o loop e essa variável é este

11768
07:56:03,520 --> 07:56:06,558
unsigned int i aqui nós vamos

11769
07:56:06,558 --> 07:56:09,440
inicializar isso para zero e o valor que nós

11770
07:56:09,440 --> 07:56:12,478
inicialize isso com

11771
07:56:12,478 --> 07:56:14,798
Começar o valor e essa é outra chave

11772
07:56:14,798 --> 07:56:17,360
ponto de qualquer loop qualquer loop que qualquer loop vai

11773
07:56:17,360 --> 07:56:19,600
Tenho um ponto de partida que também estamos indo

11774
07:56:19,600 --> 07:56:22,160
para ter um teste que vai controlar

11775
07:56:22,160 --> 07:56:25,200
quando o nosso loop termina, por exemplo, este loop

11776
07:56:25,200 --> 07:56:27,680
Vai começar com eu igual a zero

11777
07:56:27,680 --> 07:56:30,398
vai continuar fazendo coisas até

11778
07:56:30,398 --> 07:56:32,398
Eu não sou mais

11779
07:56:32,398 --> 07:56:35,520
menos de 10. enquanto eu for menor do que

11780
07:56:35,520 --> 07:56:37,360
10 vai continuar fazendo qualquer coisa

11781
07:56:37,360 --> 07:56:40,000
É que queremos fazer e a primeira parte de

11782
07:56:40,000 --> 07:56:43,280
o loop é esta coisa plus plus i aqui

11783
07:56:43,280 --> 07:56:45,280
e esta é uma parte de incrementação

11784
07:56:45,280 --> 07:56:46,798
É assim que eu vou chamá-lo para

11785
07:56:46,798 --> 07:56:49,200
simplicidade, mas pelo menos uma parte que

11786
07:56:49,200 --> 07:56:52,478
continua mudando nosso iterador para fazer o nosso

11787
07:56:52,478 --> 07:56:55,040
loop avança após esses quatro

11788
07:56:55,040 --> 07:56:57,520
pontos que vamos ter um par de

11789
07:56:57,520 --> 07:57:00,558
curly levanta e dentro destes encaracolados

11790
07:57:00,558 --> 07:57:03,120
As chaves nós vamos ter o corpo de

11791
07:57:03,120 --> 07:57:05,040
nosso loop e este é o código que queremos

11792
07:57:05,040 --> 07:57:08,240
Executar várias vezes e dentro disso

11793
07:57:08,240 --> 07:57:10,638
corpo de loop que nós podemos realmente fazer todos os tipos de

11794
07:57:10,638 --> 07:57:12,240
coisas loucas que você vai ver como

11795
07:57:12,240 --> 07:57:14,398
legal isso é novamente, temos algumas partes

11796
07:57:14,398 --> 07:57:16,958
com nosso loop temos nosso iterador que

11797
07:57:16,958 --> 07:57:19,280
é esta variável eu aqui estamos indo para

11798
07:57:19,280 --> 07:57:21,760
inicializando isso com um valor que

11799
07:57:21,760 --> 07:57:24,398
denota onde queremos que nosso loop comece

11800
07:57:24,398 --> 07:57:26,558
Então temos um teste que vai

11801
07:57:26,558 --> 07:57:28,958
controle quando o loop vai terminar

11802
07:57:28,958 --> 07:57:30,638
nós vamos ter o nosso incremento

11803
07:57:30,638 --> 07:57:33,200
parte que vai permitir que o nosso loop

11804
07:57:33,200 --> 07:57:35,120
Avre em frente e vai estar fazendo

11805
07:57:35,120 --> 07:57:36,798
que através de incrementação ou

11806
07:57:36,798 --> 07:57:39,520
decrementação, mas para fazer explicação

11807
07:57:39,520 --> 07:57:41,440
Mais fácil aqui vamos chamar isso

11808
07:57:41,440 --> 07:57:44,638
parte da parte de incrementação do loop

11809
07:57:44,638 --> 07:57:46,320
Depois disso, vamos ter o corpo

11810
07:57:46,320 --> 07:57:48,398
do loop e vai estar dentro

11811
07:57:48,398 --> 07:57:50,878
Esta cintas encaracoladas e vai ser

11812
07:57:50,878 --> 07:57:53,440
O que quer que queiramos executar dentro

11813
07:57:53,440 --> 07:57:55,840
Este loop OK estas são as partes de um

11814
07:57:55,840 --> 07:57:57,920
loop e você precisa manter isso em mente

11815
07:57:57,920 --> 07:58:00,240
Tudo bem agora que você conhece as principais partes de

11816
07:58:00,240 --> 07:58:01,280
o loop

11817
07:58:01,280 --> 07:58:03,280
Como isso realmente funciona, vamos passar

11818
07:58:03,280 --> 07:58:05,440
e veja como vai imprimir i

11819
07:58:05,440 --> 07:58:08,320
amor c mais mais 10 vezes assim quando isso

11820
07:58:08,320 --> 07:58:10,478
O código é executado, vamos começar

11821
07:58:10,478 --> 07:58:12,958
com i igual a 0 porque é isso que nós

11822
07:58:12,958 --> 07:58:15,840
estão inicializando esse valor com

11823
07:58:15,840 --> 07:58:18,000
Após a parte de incrementação, estamos

11824
07:58:18,000 --> 07:58:19,680
indo para executar o teste

11825
07:58:19,680 --> 07:58:23,120
e o teste vai dizer que eu sou 0

11826
07:58:23,120 --> 07:58:25,440
Menos de 10 e isso vai ser verdade

11827
07:58:25,440 --> 07:58:28,478
Então, se o teste for verdade

11828
07:58:28,478 --> 07:58:30,478
nós vamos pular para o corpo do loop

11829
07:58:30,478 --> 07:58:32,798
E se é falso, vamos pular para

11830
07:58:32,798 --> 07:58:36,320
o fim do loop e executar o que

11831
07:58:36,320 --> 07:58:39,440
é atrás do nosso loop é assim que funciona

11832
07:58:39,440 --> 07:58:41,600
Então, se saltarmos pela primeira vez quando

11833
07:58:41,600 --> 07:58:44,000
Eu é 0 nós vamos imprimir i love c

11834
07:58:44,000 --> 07:58:46,160
mais mais pela primeira vez depois depois

11835
07:58:46,160 --> 07:58:48,080
O corpo é executado que vamos

11836
07:58:48,080 --> 07:58:50,478
Executar a parte de incrementação

11837
07:58:50,478 --> 07:58:53,200
Isso vai fazer eu igual a 1 então

11838
07:58:53,200 --> 07:58:54,638
Vamos voltar ao teste

11839
07:58:54,638 --> 07:58:57,440
nós vamos dizer que é 1 menos de 10

11840
07:58:57,440 --> 07:58:59,280
Isso vai ser verdade que nós vamos

11841
07:58:59,280 --> 07:59:01,760
venha no corpo e imprima i love c plus

11842
07:59:01,760 --> 07:59:04,080
Mais pela segunda vez depois que o

11843
07:59:04,080 --> 07:59:05,680
Parte de incrementação vai correr

11844
07:59:05,680 --> 07:59:08,878
nós vamos ter um 2 dentro de eu aqui 2

11845
07:59:08,878 --> 07:59:11,360
É menos de 10 isso vai ser verdade

11846
07:59:11,360 --> 07:59:12,878
Vamos seguir-lhe o corpo

11847
07:59:12,878 --> 07:59:15,120
novamente e imprimir i love c plus plus para

11848
07:59:15,120 --> 07:59:17,520
A terceira vez vamos continuar fazendo

11849
07:59:17,520 --> 07:59:20,718
Isso até que atingamos nove, por exemplo, se

11850
07:59:20,718 --> 07:59:22,798
incrementa e obter um nove que vamos

11851
07:59:22,798 --> 07:59:25,920
formar o teste e dizer é nove menos do que

11852
07:59:25,920 --> 07:59:27,520
Dez que vai ser verdade, então nós somos

11853
07:59:27,520 --> 07:59:30,000
indo para cair aqui e imprimir i love c

11854
07:59:30,000 --> 07:59:31,360
plus mais novamente

11855
07:59:31,360 --> 07:59:33,520
e depois disso vamos correr o

11856
07:59:33,520 --> 07:59:36,558
incrementação parte novamente desta vez eu sou

11857
07:59:36,558 --> 07:59:38,878
indo para se tornar 10 nós vamos fazer o

11858
07:59:38,878 --> 07:59:42,240
O teste 10 não é inferior a 10, então o teste

11859
07:59:42,240 --> 07:59:43,680
Vai falhar

11860
07:59:43,680 --> 07:59:46,080
E nós vamos cair do lado de fora

11861
07:59:46,080 --> 07:59:48,878
do loop aqui e por esse tempo vamos

11862
07:59:48,878 --> 07:59:52,080
imprimiu i love c plus mais 10 vezes

11863
07:59:52,080 --> 07:59:54,398
E é assim que funciona um loop para

11864
07:59:54,398 --> 07:59:56,320
A primeira vez que vamos correr isto

11865
07:59:56,320 --> 07:59:59,040
initializer parte aqui para inicializar o nosso

11866
07:59:59,040 --> 08:00:01,520
iterador que é este valor i

11867
08:00:01,520 --> 08:00:03,040
E depois disso vamos correr

11868
08:00:03,040 --> 08:00:04,160
o teste

11869
08:00:04,160 --> 08:00:06,240
se o teste for bom se for bem sucedido

11870
08:00:06,240 --> 08:00:08,000
nós vamos cair no corpo que nós somos

11871
08:00:08,000 --> 08:00:09,840
vai executar qualquer código que esteja no

11872
08:00:09,840 --> 08:00:11,760
corpo e depois disso vamos continuar

11873
08:00:11,760 --> 08:00:14,240
fazendo o incremento do ciclo testar o corpo

11874
08:00:14,240 --> 08:00:16,320
corpo do teste de incremento

11875
08:00:16,320 --> 08:00:19,440
corpo do teste de incremento até

11876
08:00:19,440 --> 08:00:22,718
atingimos um ponto em que o teste falha e

11877
08:00:22,718 --> 08:00:24,798
Se o teste falhar, vamos cair

11878
08:00:24,798 --> 08:00:26,000
O lado de fora

11879
08:00:26,000 --> 08:00:28,398
este para loop aqui nós vamos

11880
08:00:28,398 --> 08:00:31,440
executar o que quer que seja depois deste fechamento

11881
08:00:31,440 --> 08:00:33,840
curly brace e é assim que um loop funciona

11882
08:00:33,840 --> 08:00:35,920
Eu quero que você passe por isso mais

11883
08:00:35,920 --> 08:00:38,798
tempo por imprimir i love c plus plus e

11884
08:00:38,798 --> 08:00:41,600
certificando-se de que isso é impresso 10

11885
08:00:41,600 --> 08:00:42,478
Os tempos de tempo

11886
08:00:42,478 --> 08:00:44,320
E uma coisa que você deveria ter notado

11887
08:00:44,320 --> 08:00:47,600
Agora é que usamos este teste para controlar

11888
08:00:47,600 --> 08:00:49,280
Quantas vezes o loop vai fazer

11889
08:00:49,280 --> 08:00:51,920
Comece, por exemplo, se quiséssemos que corresse

11890
08:00:51,920 --> 08:00:54,798
20 vezes que começaríamos do zero e

11891
08:00:54,798 --> 08:00:57,760
e aos 20. e você não precisa sempre

11892
08:00:57,760 --> 08:00:59,600
começar do zero você pode realmente começar

11893
08:00:59,600 --> 08:01:01,520
de qualquer lugar, por exemplo, você pode

11894
08:01:01,520 --> 08:01:04,958
inicializar i com um valor como 30 e

11895
08:01:04,958 --> 08:01:08,240
terminar quando eu é igual a 55. digamos

11896
08:01:08,240 --> 08:01:10,160
Como exemplo, você pode realmente fazer

11897
08:01:10,160 --> 08:01:13,120
Qualquer coisa importante que seja importante é

11898
08:01:13,120 --> 08:01:15,440
Entenda como um loop funciona uma coisa que eu

11899
08:01:15,440 --> 08:01:18,160
Quer que você perceba é que estamos dizendo

11900
08:01:18,160 --> 08:01:20,240
unsigned int aqui

11901
08:01:20,240 --> 08:01:23,280
Declarar o nosso iterador

11902
08:01:23,280 --> 08:01:26,080
iteradores são uma coisa comum em c plus

11903
08:01:26,080 --> 08:01:29,440
mais código e eles não são usados apenas para

11904
08:01:29,440 --> 08:01:31,760
loops como se nós estamos fazendo isso aqui é

11905
08:01:31,760 --> 08:01:34,958
um tipo que usamos para fazer iterators e ele

11906
08:01:34,958 --> 08:01:36,718
torna o nosso código muito mais legível e

11907
08:01:36,718 --> 08:01:38,878
Isso é chamado tamanho t

11908
08:01:38,878 --> 08:01:42,000
Este evento é uma representação de alguns

11909
08:01:42,000 --> 08:01:45,120
não assinado e digite em seu c plus mais

11910
08:01:45,120 --> 08:01:46,798
Compilador isso vai ser diferente

11911
08:01:46,798 --> 08:01:48,878
do compilador para o compilador, mas para

11912
08:01:48,878 --> 08:01:52,320
No meu sistema, são oito bytes

11913
08:01:52,320 --> 08:01:55,040
por isso tem uma boa gama de valores

11914
08:01:55,040 --> 08:01:57,520
você pode colocar lá se usarmos o tamanho t

11915
08:01:57,520 --> 08:02:00,478
digite para declarar o nosso iterador aqui

11916
08:02:00,478 --> 08:02:02,080
nós vamos dizer algo assim

11917
08:02:02,080 --> 08:02:04,160
para o tamanho t i

11918
08:02:04,160 --> 08:02:05,920
nós vamos colocar nossas chaves encaracoladas

11919
08:02:05,920 --> 08:02:07,840
nós vamos colocar um ponto e vírgula que estamos

11920
08:02:07,840 --> 08:02:09,840
vamos colocar nosso teste e nós vamos

11921
08:02:09,840 --> 08:02:12,638
Coloque nossa parte de incrementação e eu acho

11922
08:02:12,638 --> 08:02:15,040
Eu realmente enfatizo isso, mas o

11923
08:02:15,040 --> 08:02:17,360
partes do nosso loop dentro deste

11924
08:02:17,360 --> 08:02:20,958
Os parênteses são separados por ponto e vírgula

11925
08:02:20,958 --> 08:02:23,280
assim, então temos o iterador

11926
08:02:23,280 --> 08:02:25,680
Declaração que temos um ponto e vírgula que temos

11927
08:02:25,680 --> 08:02:28,240
O teste temos um ponto e vírgula e colocamos

11928
08:02:28,240 --> 08:02:30,478
nossa parte de incrementação e depois vamos

11929
08:02:30,478 --> 08:02:33,040
e colocar nossos curlies e dentro podemos

11930
08:02:33,040 --> 08:02:35,360
Faça o que quer que queiramos fazer

11931
08:02:35,360 --> 08:02:37,520
dentro do loop, então o tamanho t é algo

11932
08:02:37,520 --> 08:02:39,520
Você vai ver muito, certifique-se de que você

11933
08:02:39,520 --> 08:02:42,080
Saiba o que significa lembrar que é um

11934
08:02:42,080 --> 08:02:45,840
Representação de um não assinado e tipo

11935
08:02:45,840 --> 08:02:47,920
para que só possa representar positivo

11936
08:02:47,920 --> 08:02:50,558
números e é usado para representar

11937
08:02:50,558 --> 08:02:53,440
coisas como tamanhos em c plus mais agradecimento

11938
08:02:53,440 --> 08:02:56,160
Número de alunos em sala de aula

11939
08:02:56,160 --> 08:02:58,478
Por exemplo, isso nunca pode ser negativo

11940
08:02:58,478 --> 08:03:00,958
Pense no número de assentos em um carro

11941
08:03:00,958 --> 08:03:02,638
Isso é algo que sempre vai

11942
08:03:02,638 --> 08:03:05,520
ser positivo e não fará sentido para

11943
08:03:05,520 --> 08:03:08,000
Isso para ser negativo para esses tipos

11944
08:03:08,000 --> 08:03:11,360
das coisas que podemos usar o tamanho t para representar

11945
08:03:11,360 --> 08:03:13,600
O tamanho dessas coisas e você é

11946
08:03:13,600 --> 08:03:15,280
Vou ver como isso funciona em um minuto

11947
08:03:15,280 --> 08:03:17,280
Tudo bem agora que você tem um bem

11948
08:03:17,280 --> 08:03:20,080
ideia de como funciona um loop e a principal

11949
08:03:20,080 --> 08:03:22,240
Peças que fazem isso eu quero que você saiba

11950
08:03:22,240 --> 08:03:24,478
que você também pode fazer todos os tipos de loucos

11951
08:03:24,478 --> 08:03:27,360
operações dentro do corpo do seu loop

11952
08:03:27,360 --> 08:03:30,000
Por exemplo, aqui estamos imprimindo o

11953
08:03:30,000 --> 08:03:32,798
O valor atual do nosso iterador e nós somos

11954
08:03:32,798 --> 08:03:35,120
Vou imprimir o duplo que podemos fazer

11955
08:03:35,120 --> 08:03:37,840
Isso também podemos deixar de fora o encaracolado

11956
08:03:37,840 --> 08:03:40,638
chaves e isso só é válido se tivermos

11957
08:03:40,638 --> 08:03:43,040
Uma declaração que queremos correr no loop

11958
08:03:43,040 --> 08:03:45,120
então isso vai imprimir esta mensagem

11959
08:03:45,120 --> 08:03:47,200
Aqui cinco vezes porque este loop é

11960
08:03:47,200 --> 08:03:49,840
indo de zero todo o caminho para quatro

11961
08:03:49,840 --> 08:03:52,558
Vai parar quando eu parar de ser menos

11962
08:03:52,558 --> 08:03:54,878
mais de cinco e isso vai ser cinco

11963
08:03:54,878 --> 08:03:56,638
Tempos se você passar por isso você é

11964
08:03:56,638 --> 08:03:58,240
Vou ver que isso vai imprimir

11965
08:03:58,240 --> 08:04:00,398
Cinco vezes você também deve saber que

11966
08:04:00,398 --> 08:04:03,040
Este iterador que estamos declarando como

11967
08:04:03,040 --> 08:04:06,160
isso vai ser escopo dentro do

11968
08:04:06,160 --> 08:04:08,878
corpo do laço para que você só possa usá-lo

11969
08:04:08,878 --> 08:04:11,520
dentro desses aparelhos encaracolados e se você tentar

11970
08:04:11,520 --> 08:04:15,040
para usá-lo fora, por exemplo, aqui depois

11971
08:04:15,040 --> 08:04:17,680
O fechamento de chaves encaracoladas do corpo de

11972
08:04:17,680 --> 08:04:19,280
o loop que você vai ter um compilador

11973
08:04:19,280 --> 08:04:21,520
Erro novamente você só pode usar isso

11974
08:04:21,520 --> 08:04:24,240
variável i que é o nosso iterador

11975
08:04:24,240 --> 08:04:27,600
Dentro dos curismos que marcam o

11976
08:04:27,600 --> 08:04:30,478
começar e o fim do nosso corpo de loop se

11977
08:04:30,478 --> 08:04:32,558
Você quer que o iterador seja utilizável

11978
08:04:32,558 --> 08:04:35,760
fora do escopo do loop para loop

11979
08:04:35,760 --> 08:04:37,280
Você pode fazer algo assim que você pode

11980
08:04:37,280 --> 08:04:40,240
Declarar o seu iterador fora do loop

11981
08:04:40,240 --> 08:04:41,840
e você pode inicializar isso com

11982
08:04:41,840 --> 08:04:43,760
o que quiser e então você pode definir

11983
08:04:43,760 --> 08:04:46,478
up your loop como este você pode dizer para j

11984
08:04:46,478 --> 08:04:49,040
e colocar o seu teste e seu

11985
08:04:49,040 --> 08:04:51,520
parte de incrementação e dentro do

11986
08:04:51,520 --> 08:04:52,958
O que quer que você queira fazer no

11987
08:04:52,958 --> 08:04:55,520
corpo do olhar se fizermos assim

11988
08:04:55,520 --> 08:04:58,160
então j vai ser utilizável fora de

11989
08:04:58,160 --> 08:05:00,320
o loop e nós vamos ver isso

11990
08:05:00,320 --> 08:05:02,798
valor se imprimirmos assim, então

11991
08:05:02,798 --> 08:05:04,878
Isso também é algo que você pode fazer

11992
08:05:04,878 --> 08:05:08,558
você pode até ficar louco e deixar de fora

11993
08:05:08,558 --> 08:05:09,440
O que é

11994
08:05:09,440 --> 08:05:12,398
declaração parte se acontecer de você ter

11995
08:05:12,398 --> 08:05:13,280
O que é

11996
08:05:13,280 --> 08:05:16,478
iterador declarado fora, então se você fizer

11997
08:05:16,478 --> 08:05:18,240
Algo assim também vai

11998
08:05:18,240 --> 08:05:20,478
trabalhar ok a última coisa que eu quero que você faça

11999
08:05:20,478 --> 08:05:22,798
ver antes de ir para o estúdio visual

12000
08:05:22,798 --> 08:05:25,120
código e realmente tentar isso

12001
08:05:25,120 --> 08:05:27,840
é que é uma coisa ruim para o código duro

12002
08:05:27,840 --> 08:05:29,840
seus valores, por exemplo, você vê aqui

12003
08:05:29,840 --> 08:05:32,398
Estamos dizendo J menos de 10

12004
08:05:32,398 --> 08:05:34,958
Este é um design muito ruim, porque cada

12005
08:05:34,958 --> 08:05:37,280
Tempo que você precisa para alterar o número de

12006
08:05:37,280 --> 08:05:39,520
tempos em que seu loop vai correr

12007
08:05:39,520 --> 08:05:41,200
você vai ter que caçar por isso

12008
08:05:41,200 --> 08:05:43,360
loops e alterar esses valores e isso

12009
08:05:43,360 --> 08:05:45,920
Pode estar em muitos lugares no seu código

12010
08:05:45,920 --> 08:05:48,478
então uma coisa boa a fazer é colocar o

12011
08:05:48,478 --> 08:05:51,040
valor que controla quantas vezes você

12012
08:05:51,040 --> 08:05:53,040
loop vai rodar em uma variável como

12013
08:05:53,040 --> 08:05:55,120
Isso vamos armazenar esse valor em

12014
08:05:55,120 --> 08:05:56,958
Esta variável de contagem

12015
08:05:56,958 --> 08:05:59,360
notar que é do tamanho t porque

12016
08:05:59,360 --> 08:06:01,280
É uma representação do tamanho de

12017
08:06:01,280 --> 08:06:03,360
Coisas algo que nós realmente não queremos

12018
08:06:03,360 --> 08:06:05,760
ser negativo e vamos usar isso

12019
08:06:05,760 --> 08:06:09,280
em nossa parte de teste do nosso loop aqui

12020
08:06:09,280 --> 08:06:11,360
Em vez de dizer j menos de 10 estamos

12021
08:06:11,360 --> 08:06:14,080
vamos dizer j menos do que contar e se nós

12022
08:06:14,080 --> 08:06:16,798
Queremos mudar isso, temos um ponto de

12023
08:06:16,798 --> 08:06:19,280
controle para ir e alterar esse valor aqui

12024
08:06:19,280 --> 08:06:20,878
e isso é realmente bom design você

12025
08:06:20,878 --> 08:06:23,200
Devemos fazer isso ok, nós conversamos muito

12026
08:06:23,200 --> 08:06:25,760
sobre loops é hora de irmos para

12027
08:06:25,760 --> 08:06:28,320
código de estúdio visual e realmente tentou

12028
08:06:28,320 --> 08:06:30,798
Essas coisas aqui estamos no visual

12029
08:06:30,798 --> 08:06:33,280
código de estúdio para o qual é o projeto atual

12030
08:06:33,280 --> 08:06:35,360
loop aqui nós vamos pegar o código

12031
08:06:35,360 --> 08:06:37,920
a partir do nosso projeto de template

12032
08:06:37,920 --> 08:06:40,000
E nós vamos colocar isso no lugar

12033
08:06:40,000 --> 08:06:41,760
aqui

12034
08:06:41,760 --> 08:06:43,840
e nós vamos abrir isso em visual

12035
08:06:43,840 --> 08:06:46,958
Código de estúdio, então vamos fazer isso muito rápido

12036
08:06:46,958 --> 08:06:48,958
para loop que é o projeto atual

12037
08:06:48,958 --> 08:06:51,440
selecionado e abrimos isso em

12038
08:06:51,440 --> 08:06:52,718
código de estúdio

12039
08:06:52,718 --> 08:06:55,680
nós vamos abrir o nosso arquivo cpp principal

12040
08:06:55,680 --> 08:06:58,160
que vai aparecer aqui e estamos

12041
08:06:58,160 --> 08:07:00,000
Vamos remover coisas que não precisamos

12042
08:07:00,000 --> 08:07:00,878
aqui

12043
08:07:00,878 --> 08:07:03,040
então vamos remover isso o primeiro

12044
08:07:03,040 --> 08:07:05,360
O que eu quero que você faça é a maneira ruim de

12045
08:07:05,360 --> 08:07:06,718
Faz as coisas

12046
08:07:06,718 --> 08:07:09,120
novamente se quisermos imprimir i love c plus

12047
08:07:09,120 --> 08:07:12,478
mais 10 vezes que podemos fazer assim e

12048
08:07:12,478 --> 08:07:14,320
Se executarmos o programa, vai funcionar

12049
08:07:14,320 --> 08:07:16,558
Mas isso é realmente um design ruim, porque

12050
08:07:16,558 --> 08:07:18,798
você teria que copiar e colar isso

12051
08:07:18,798 --> 08:07:20,798
Por exemplo, mil vezes ou até mesmo uma

12052
08:07:20,798 --> 08:07:22,718
Cem mil vezes e isso é

12053
08:07:22,718 --> 08:07:24,958
É realmente ruim, então se trouxermos a nossa

12054
08:07:24,958 --> 08:07:26,398
O terminal

12055
08:07:26,398 --> 08:07:31,040
e construir com gcc como sempre fazemos

12056
08:07:31,920 --> 08:07:34,398
A construção vai passar por você ver

12057
08:07:34,398 --> 08:07:36,878
É bem sucedido, vamos limpar e

12058
08:07:36,878 --> 08:07:38,478
nós vamos correr o galo e é

12059
08:07:38,478 --> 08:07:40,958
vou dizer lfc mais mais 10 vezes se

12060
08:07:40,958 --> 08:07:43,120
Você conta isso, vai ser 10 vezes

12061
08:07:43,120 --> 08:07:45,120
Porque é isso que estamos fazendo aqui, mas

12062
08:07:45,120 --> 08:07:46,878
Este é realmente um mau design que você não quer

12063
08:07:46,878 --> 08:07:49,040
para fazer algo assim, então vamos

12064
08:07:49,040 --> 08:07:50,958
para comentar isso fora

12065
08:07:50,958 --> 08:07:53,600
e fazer isso melhor usando um loop para loop

12066
08:07:53,600 --> 08:07:55,680
Vamos dizer que este é o caminho ruim e

12067
08:07:55,680 --> 08:07:57,440
vamos usar para loop que é o

12068
08:07:57,440 --> 08:07:59,360
Boa maneira desculpe, então vamos começar

12069
08:07:59,360 --> 08:08:01,840
declarando nosso iterador, então vamos

12070
08:08:01,840 --> 08:08:04,798
para dizer para que vamos dizer tamanho t

12071
08:08:04,798 --> 08:08:06,798
Vamos usar o fim não assinado para mostrar que

12072
08:08:06,798 --> 08:08:08,478
você pode usar isso e nós vamos dizer

12073
08:08:08,478 --> 08:08:10,558
Eu e nós vamos inicializar isso

12074
08:08:10,558 --> 08:08:12,240
Com um zero

12075
08:08:12,240 --> 08:08:14,798
E esta será a declaração

12076
08:08:14,798 --> 08:08:18,000
do nosso iterador, esta é a primeira parte

12077
08:08:18,000 --> 08:08:20,320
nós temos neste parêntese aqui estamos

12078
08:08:20,320 --> 08:08:22,718
indo colocar um ponto e vírgula e colocar em

12079
08:08:22,718 --> 08:08:25,120
O teste que queremos o

12080
08:08:25,120 --> 08:08:27,360
loop para correr dez vezes, então ele vai

12081
08:08:27,360 --> 08:08:29,280
correr de zero a nove nós vamos

12082
08:08:29,280 --> 08:08:31,840
parar quando eu parar de ser

12083
08:08:31,840 --> 08:08:34,160
Menos de dez é uma maneira que você pode

12084
08:08:34,160 --> 08:08:36,638
Entenda isso depois que temos nosso teste

12085
08:08:36,638 --> 08:08:38,160
E nós vamos colocar o

12086
08:08:38,160 --> 08:08:40,398
parte de incrementação que vai

12087
08:08:40,398 --> 08:08:42,958
mudar o iterador para fazer o loop

12088
08:08:42,958 --> 08:08:45,040
Avançamos e vamos fazer isso

12089
08:08:45,040 --> 08:08:48,000
incrementando nosso iterador depois disso

12090
08:08:48,000 --> 08:08:50,478
nós vamos colocar um par de encaracolados

12091
08:08:50,478 --> 08:08:52,558


12092
08:08:52,558 --> 08:08:55,120
Vai cair dentro do corpo do

12093
08:08:55,120 --> 08:08:57,840
este bloco aqui delimitado pelo

12094
08:08:57,840 --> 08:09:00,638
curly chaves é o corpo do laço e

12095
08:09:00,638 --> 08:09:02,798
Dentro aqui nós vamos colocar o que quer que

12096
08:09:02,798 --> 08:09:04,798
nós queremos que o loop corra para que possamos ir

12097
08:09:04,798 --> 08:09:07,520
Aqui e dizer eu amo c plus mais 10

12098
08:09:07,520 --> 08:09:10,080
tempos, digamos, mas antes de fazermos

12099
08:09:10,080 --> 08:09:12,478
que vamos dizer eu para que saibamos o

12100
08:09:12,478 --> 08:09:15,040
iteração atual onde estamos em

12101
08:09:15,040 --> 08:09:17,120
e nós vamos colocar uma coluna e dizer

12102
08:09:17,120 --> 08:09:20,000
Eu amo c plus mais isso vai ser

12103
08:09:20,000 --> 08:09:23,200
Melhor seguir no terminal eu acho

12104
08:09:23,200 --> 08:09:25,680
e nós vamos colocar em nosso

12105
08:09:25,680 --> 08:09:28,000
novo personagem de linha

12106
08:09:28,000 --> 08:09:30,398
mover-se para a nova linha

12107
08:09:30,398 --> 08:09:33,440
e precisamos colocar nossa saída de fluxo

12108
08:09:33,440 --> 08:09:36,000
operador aqui para que isso faça sentido para

12109
08:09:36,000 --> 08:09:38,798
o compilador e este é o nosso loop agora se

12110
08:09:38,798 --> 08:09:40,718
nós executamos, nós vamos ver exatamente o

12111
08:09:40,718 --> 08:09:42,478
A mesma coisa assim, mas nós vamos

12112
08:09:42,478 --> 08:09:45,360
Se estes iterators se prepararem para o

12113
08:09:45,360 --> 08:09:47,600
mensagem para que se torne fácil

12114
08:09:47,600 --> 08:09:50,320
Siga isso e de novo como isso está indo

12115
08:09:50,320 --> 08:09:53,760
para trabalhar, vamos executar o nosso código para

12116
08:09:53,760 --> 08:09:56,718
Declarar e inicializar o iterador

12117
08:09:56,718 --> 08:09:58,958
Depois disso, vamos fazer o teste

12118
08:09:58,958 --> 08:10:01,760
Vou começar com i zero então zero

12119
08:10:01,760 --> 08:10:03,760
É menos de dez isso vai

12120
08:10:03,760 --> 08:10:05,760
O sucesso vamos cair no corpo

12121
08:10:05,760 --> 08:10:06,558
aqui

12122
08:10:06,558 --> 08:10:08,798
E depois disso vamos

12123
08:10:08,798 --> 08:10:11,600
imprimir sddc out i love c plus plus e

12124
08:10:11,600 --> 08:10:13,520
Isso vai ser zero nós vamos

12125
08:10:13,520 --> 08:10:15,120
incremento i

12126
08:10:15,120 --> 08:10:17,760
E nós vamos fazer o teste novamente

12127
08:10:17,760 --> 08:10:20,320
nós vamos ter que fazer é um a menos

12128
08:10:20,320 --> 08:10:21,920
mais de 10 o teste vai ser

12129
08:10:21,920 --> 08:10:23,600
bem sucedido para que vamos cair em

12130
08:10:23,600 --> 08:10:26,160
Aqui e nós vamos imprimir um

12131
08:10:26,160 --> 08:10:27,120
E nós vamos correr o

12132
08:10:27,120 --> 08:10:29,360
incrementação parte novamente nós vamos

12133
08:10:29,360 --> 08:10:31,120
executar o teste e nós vamos continuar

12134
08:10:31,120 --> 08:10:32,798
fazendo isso até que atingimos um ponto para

12135
08:10:32,798 --> 08:10:35,440
exemplo quando incrementamos isso para ser um

12136
08:10:35,440 --> 08:10:36,320
Nove

12137
08:10:36,320 --> 08:10:37,920
e depois disso vamos correr o

12138
08:10:37,920 --> 08:10:39,920
teste que vamos dizer é 9 menos do que

12139
08:10:39,920 --> 08:10:42,558
10 o teste vai ser bem sucedido assim

12140
08:10:42,558 --> 08:10:43,920
nós vamos seguir aqui e nós estamos

12141
08:10:43,920 --> 08:10:46,398
Vai imprimir nove

12142
08:10:46,398 --> 08:10:48,240
E depois disso vamos incrementar

12143
08:10:48,240 --> 08:10:49,200
Mais uma vez vamos correr o

12144
08:10:49,200 --> 08:10:50,878
incrementação parte e nós vamos

12145
08:10:50,878 --> 08:10:53,600
fazer i 10 se executarmos o teste que estamos indo

12146
08:10:53,600 --> 08:10:56,958
dizer que é 10 menos de 10 do teste aqui

12147
08:10:56,958 --> 08:10:58,878
Vai falhar, vamos parar

12148
08:10:58,878 --> 08:11:00,638
correndo o loop todos juntos e nós estamos

12149
08:11:00,638 --> 08:11:02,878
vai cair do lado de fora do loop

12150
08:11:02,878 --> 08:11:05,920
e dizer loop feito, digamos, para que

12151
08:11:05,920 --> 08:11:08,160
podemos ver isso no terminal e este

12152
08:11:08,160 --> 08:11:10,638
vai rodar e imprimir i love plus

12153
08:11:10,638 --> 08:11:13,760
mais 10 vezes e esperamos que eu vá de

12154
08:11:13,760 --> 08:11:16,080
zero todo o caminho para nove

12155
08:11:16,080 --> 08:11:18,240
Tente correr isso em sua mente

12156
08:11:18,240 --> 08:11:20,558
Deixe um pedaço de papel tentar

12157
08:11:20,558 --> 08:11:22,718
imprimir isso enquanto você cai no corpo de

12158
08:11:22,718 --> 08:11:24,240
O loop que você vai ver que é

12159
08:11:24,240 --> 08:11:26,878
exatamente o que está acontecendo aqui, então o que

12160
08:11:26,878 --> 08:11:28,878
nós vamos fazer nós vamos ferver

12161
08:11:28,878 --> 08:11:31,920
Isso novamente, então vamos correr o

12162
08:11:31,920 --> 08:11:33,360
A tarefa de

12163
08:11:33,360 --> 08:11:35,040
trabalhar com o gcc

12164
08:11:35,040 --> 08:11:37,360
O mundo é bom, vamos descer

12165
08:11:37,360 --> 08:11:40,718
e correr isso nós vamos limpar

12166
08:11:40,718 --> 08:11:42,160
e correr o galo

12167
08:11:42,160 --> 08:11:43,520
e você vai ver que temos

12168
08:11:43,520 --> 08:11:45,760
zero i love c plus plus todo o caminho para

12169
08:11:45,760 --> 08:11:48,638
nove i love c plus plus nosso loop é

12170
08:11:48,638 --> 08:11:51,040
trabalhando exatamente do jeito que queremos bem, então

12171
08:11:51,040 --> 08:11:53,200
Este é o primeiro passo que somos capazes de

12172
08:11:53,200 --> 08:11:55,520
executar o nosso código muitas vezes sem

12173
08:11:55,520 --> 08:11:57,840
realmente ter que fazer manualmente coisas como

12174
08:11:57,840 --> 08:12:00,398
este e o benefício disso é que se

12175
08:12:00,398 --> 08:12:02,638
Queremos que isso funcione, por exemplo, 100

12176
08:12:02,638 --> 08:12:05,600
Tempos, tudo o que temos a fazer é mudar nosso

12177
08:12:05,600 --> 08:12:06,478
teste

12178
08:12:06,478 --> 08:12:08,398
para ir até que eu

12179
08:12:08,398 --> 08:12:11,040
é igual a 100 e vamos parar

12180
08:12:11,040 --> 08:12:13,040
Quando eu pare de ser

12181
08:12:13,040 --> 08:12:15,920
Menos de 100 e se corrermos isso, estamos

12182
08:12:15,920 --> 08:12:17,040
Indo para ver

12183
08:12:17,040 --> 08:12:20,478
a mensagem de 0 até 99 e

12184
08:12:20,478 --> 08:12:22,398
Isso é muito legal o torso está indo

12185
08:12:22,398 --> 08:12:25,280
para ser 100 vezes, então vamos soldar novamente para

12186
08:12:25,280 --> 08:12:27,440
mostrar o quão frio isso é

12187
08:12:27,440 --> 08:12:29,200
nós vamos executar esta tarefa para soldar

12188
08:12:29,200 --> 08:12:31,200
com gcc novamente

12189
08:12:31,200 --> 08:12:33,120
E nós vamos limpar

12190
08:12:33,120 --> 08:12:37,120
corre o galo prepare-se para ser surpreendido correr e

12191
08:12:37,120 --> 08:12:39,440
Vai correr todo o caminho até 99 nós

12192
08:12:39,440 --> 08:12:42,638
pode mudar isso para até 1 000 ou até 10

12193
08:12:42,638 --> 08:12:45,840
000 porque não vamos soldar novamente

12194
08:12:45,840 --> 08:12:48,798
E nós vamos ser bem sucedidos

12195
08:12:48,798 --> 08:12:50,478
E nós vamos limpar

12196
08:12:50,478 --> 08:12:52,878
e correr galo e isso vai ir

12197
08:12:52,878 --> 08:12:54,718
todo o caminho para 10 000 vezes que estamos indo

12198
08:12:54,718 --> 08:12:56,478
para esperar que isso chegar lá

12199
08:12:56,478 --> 08:13:03,520
agora 3 000 4 000 5000 6000 7000 8000

12200
08:13:03,520 --> 08:13:05,200
Dez mil vai ir todo o

12201
08:13:05,200 --> 08:13:07,600
caminho para nove mil novecentos noventa

12202
08:13:07,600 --> 08:13:09,760
Nove e vai parar e

12203
08:13:09,760 --> 08:13:12,240
total de vezes o loop executado

12204
08:13:12,240 --> 08:13:15,520
Foi do zero todo o caminho para

12205
08:13:15,520 --> 08:13:18,240
Este número de armazenamento aqui está bem agora nós

12206
08:13:18,240 --> 08:13:20,080
pode ver que nosso loop está realmente funcionando

12207
08:13:20,080 --> 08:13:22,798
Tudo bem, não temos que fazer estes hddc para fora

12208
08:13:22,798 --> 08:13:25,680
Declarações uma quantidade louca de vezes bem

12209
08:13:25,680 --> 08:13:28,080
E o benefício novamente é que

12210
08:13:28,080 --> 08:13:31,600
independentemente do número de vezes

12211
08:13:31,600 --> 08:13:33,920
O código aqui vai executar nosso loop é

12212
08:13:33,920 --> 08:13:36,000
Vou ficar relativamente o mesmo que é

12213
08:13:36,000 --> 08:13:38,638
Só vai ser um dois três quatro

12214
08:13:38,638 --> 08:13:40,958
linhas de código e isso é muito legal

12215
08:13:40,958 --> 08:13:43,280
Tudo bem, então eu acho que isso agora faz isso muito

12216
08:13:43,280 --> 08:13:45,840
claro como os loops funcionam para que possamos

12217
08:13:45,840 --> 08:13:47,680
Comente e mostre-lhe outro

12218
08:13:47,680 --> 08:13:49,120
coisa e nós vamos te mostrar isso

12219
08:13:49,120 --> 08:13:51,600
você pode usar o tamanho t para realmente

12220
08:13:51,600 --> 08:13:54,478
denotar o tipo de seu iterador

12221
08:13:54,478 --> 08:13:57,040
E é fácil fazer isso, então estamos indo

12222
08:13:57,040 --> 08:14:00,080
para dizer usar o tamanho t e para que possamos

12223
08:14:00,080 --> 08:14:02,718
para ver tudo isto aqui vamos apertar este ficheiro

12224
08:14:02,718 --> 08:14:05,200
ícone aqui para fechar este painel e nós somos

12225
08:14:05,200 --> 08:14:06,638
ter uma melhor chance de ver

12226
08:14:06,638 --> 08:14:09,520
Nosso código aqui, então o que queremos fazer

12227
08:14:09,520 --> 08:14:11,040
vamos declarar um grupo que somos

12228
08:14:11,040 --> 08:14:12,958
indo para salvar para não vamos dizer

12229
08:14:12,958 --> 08:14:15,760
nosso projeto e vamos dizer tamanho t

12230
08:14:15,760 --> 08:14:18,160
E este vai ser o tipo de nosso

12231
08:14:18,160 --> 08:14:20,000
iterador vamos dizer que nós somos

12232
08:14:20,000 --> 08:14:22,398
vai inicializar isso com um zero

12233
08:14:22,398 --> 08:14:24,398
e nós vamos colocar um ponto e-vírgula como

12234
08:14:24,398 --> 08:14:26,320
Nós apenas fizemos nós vamos colocar no

12235
08:14:26,320 --> 08:14:29,440
fim teste, vamos colocar o teste

12236
08:14:29,440 --> 08:14:32,478
Vamos dizer menos de 10

12237
08:14:32,478 --> 08:14:34,080
Não há problema com a gente

12238
08:14:34,080 --> 08:14:36,798
e nós vamos aumentar para colocar em

12239
08:14:36,798 --> 08:14:39,600
Coloque nossa parte de incrementação que somos

12240
08:14:39,600 --> 08:14:41,040
Vou cair no loop que nós vamos

12241
08:14:41,040 --> 08:14:43,600
Diga stdc fora este é o código que queremos

12242
08:14:43,600 --> 08:14:45,840
correr para que nós vamos colocar em nosso

12243
08:14:45,840 --> 08:14:48,160
valor de cobertura para o iterador e

12244
08:14:48,160 --> 08:14:50,320
nós vamos dizer que eu amo c plus mais

12245
08:14:50,320 --> 08:14:52,558
de novo e vamos colocar no nosso novo

12246
08:14:52,558 --> 08:14:55,280
personagem de linha e se nós construímos e corremos

12247
08:14:55,280 --> 08:14:57,280
Isso vai funcionar e correr o mesmo

12248
08:14:57,280 --> 08:14:59,760
então vamos dizer loop feito aqui

12249
08:14:59,760 --> 08:15:01,520
para que saibamos quando está feito e estamos

12250
08:15:01,520 --> 08:15:03,360
Vou soldar e correr, vamos

12251
08:15:03,360 --> 08:15:05,600
Mundo com o Gcc

12252
08:15:05,600 --> 08:15:07,760
O mundo vai ser bom

12253
08:15:07,760 --> 08:15:09,440
E o que vamos fazer, vamos

12254
08:15:09,440 --> 08:15:10,958
para limpar

12255
08:15:10,958 --> 08:15:13,360
e correr o galo e isso vai dizer

12256
08:15:13,360 --> 08:15:18,080
Eu amo c mais 10 vezes de 0 a 9.

12257
08:15:18,080 --> 08:15:20,080
Mais uma vez a mensagem aqui é que você pode

12258
08:15:20,080 --> 08:15:23,120
usar o tamanho t para representar o tipo de seu

12259
08:15:23,120 --> 08:15:25,360
iteradores e este é o tipo que é

12260
08:15:25,360 --> 08:15:27,600
mesmo usado no c plus mais padrão

12261
08:15:27,600 --> 08:15:30,240
Biblioteca, então isso vai ser algo

12262
08:15:30,240 --> 08:15:32,638
As pessoas esperam do seu código se você estiver

12263
08:15:32,638 --> 08:15:35,360
representar tamanhos no código que deve

12264
08:15:35,360 --> 08:15:37,360
ser complacente com o c plus mais

12265
08:15:37,360 --> 08:15:40,000
biblioteca padrão nada impede você de

12266
08:15:40,000 --> 08:15:42,798
usando não assinado como fazemos aqui, mas

12267
08:15:42,798 --> 08:15:43,920
nós só vamos seguir o

12268
08:15:43,920 --> 08:15:46,080
Convenção do padrão c plus plus

12269
08:15:46,080 --> 08:15:48,478
biblioteca e usar este tipo aqui para

12270
08:15:48,478 --> 08:15:51,040
representar todos os tamanhos

12271
08:15:51,040 --> 08:15:53,200
E alguns de vocês podem estar se perguntando como

12272
08:15:53,200 --> 08:15:55,600
Grande é esta coisa que temos as ferramentas para

12273
08:15:55,600 --> 08:15:56,478
- Conhecer

12274
08:15:56,478 --> 08:15:58,558
Quão grande é, então vamos fazer isso bonito

12275
08:15:58,558 --> 08:16:01,200
rápido, então vamos descer aqui

12276
08:16:01,200 --> 08:16:03,920
e dizer ao sddc para fora e nós vamos dizer

12277
08:16:03,920 --> 08:16:05,520
Tamanho de

12278
08:16:05,520 --> 08:16:08,160
tamanho t e podemos imprimir isso fora e

12279
08:16:08,160 --> 08:16:10,160
Vamos dizer o que estamos fazendo aqui para que

12280
08:16:10,160 --> 08:16:11,760
É fácil

12281
08:16:11,760 --> 08:16:14,478
usar este código como referência e se nós

12282
08:16:14,478 --> 08:16:17,040
imprimir isso para fora que vamos ver

12283
08:16:17,040 --> 08:16:19,280
O tamanho dessa coisa no sistema

12284
08:16:19,280 --> 08:16:21,680
onde este código aqui vai rodar

12285
08:16:21,680 --> 08:16:23,360
Então nós vamos para

12286
08:16:23,360 --> 08:16:26,478
construir com gcc novamente

12287
08:16:26,478 --> 08:16:28,558
O parafuso vai ser bom, estamos indo

12288
08:16:28,558 --> 08:16:31,600
para ir aqui e limpar e correr galo

12289
08:16:31,600 --> 08:16:33,280
Você vai ver que são oito

12290
08:16:33,280 --> 08:16:35,120
bytes no meu sistema para que você vá

12291
08:16:35,120 --> 08:16:37,520
ter uma enorme variedade de números você

12292
08:16:37,520 --> 08:16:39,840
pode colocar aqui porque isso vai

12293
08:16:39,840 --> 08:16:41,760
Apenas seja positivo

12294
08:16:41,760 --> 08:16:43,920
Tudo bem se você tentar colocar um negativo

12295
08:16:43,920 --> 08:16:46,160
número que você vai ter um subfluoro

12296
08:16:46,160 --> 08:16:48,398
e aprendemos sobre o transbordamento e

12297
08:16:48,398 --> 08:16:51,680
piso inferior no capítulo anterior

12298
08:16:51,680 --> 08:16:53,760
Tudo bem, então vamos comentar isso e manter

12299
08:16:53,760 --> 08:16:56,478
Aprendendo mais coisas sobre loops

12300
08:16:56,478 --> 08:16:58,398
Ok, a próxima coisa que eu realmente quero que você

12301
08:16:58,398 --> 08:17:01,200
Foco e aprender é o escopo do

12302
08:17:01,200 --> 08:17:03,520
iterador e nós vamos agarrar o nosso

12303
08:17:03,520 --> 08:17:05,440
código novamente aqui

12304
08:17:05,440 --> 08:17:07,600
para que possamos usar isso

12305
08:17:07,600 --> 08:17:09,360
Como uma ferramenta de aprendizagem, então vamos

12306
08:17:09,360 --> 08:17:12,718
Aqui em baixo e colocar isso dentro

12307
08:17:12,718 --> 08:17:15,200
E o que vamos ter vamos nos mover

12308
08:17:15,200 --> 08:17:17,680
Isso um pouco para a direita eu acho

12309
08:17:17,680 --> 08:17:19,760
nós podemos fazer algo assim eu vou

12310
08:17:19,760 --> 08:17:22,080
para selecionar a coisa toda aqui e acertar

12311
08:17:22,080 --> 08:17:24,478
tabulação e ele vai estar alinhado com

12312
08:17:24,478 --> 08:17:26,558
O que quer que tenhamos aqui

12313
08:17:26,558 --> 08:17:28,638
Tudo bem, então temos nosso loop que vai

12314
08:17:28,638 --> 08:17:30,638
correr 10 vezes que vai imprimir i love

12315
08:17:30,638 --> 08:17:32,798
c plus de 0

12316
08:17:32,798 --> 08:17:34,160
to 9

12317
08:17:34,160 --> 08:17:34,958


12318
08:17:34,958 --> 08:17:37,680
Qual é o escopo disso eu penso aqui

12319
08:17:37,680 --> 08:17:40,958
e o fato é que é abrangido dentro deste

12320
08:17:40,958 --> 08:17:43,440
loop aqui você pode ter adivinhado que se

12321
08:17:43,440 --> 08:17:46,160
você tenta usá-lo fora do loop

12322
08:17:46,160 --> 08:17:47,680
você vai ter uma seta do compilador

12323
08:17:47,680 --> 08:17:50,240
porque só é utilizável dentro do

12324
08:17:50,240 --> 08:17:53,040
corpo do que você também pode usá-lo dentro

12325
08:17:53,040 --> 08:17:55,840
A parte de controle do loop aqui, mas

12326
08:17:55,840 --> 08:17:58,398
você não pode usá-lo fora do loop, então se

12327
08:17:58,398 --> 08:18:00,958
Você tenta imprimir aqui, por exemplo

12328
08:18:00,958 --> 08:18:02,638
você vai ter um erro de compilador, então

12329
08:18:02,638 --> 08:18:04,798
Vamos tentar fazer isso e mostrar-lhe como

12330
08:18:04,798 --> 08:18:06,398
errado isso pode ser

12331
08:18:06,398 --> 08:18:10,398
Então, se tentarmos imprimir, eu aqui vamos dizer

12332
08:18:10,398 --> 08:18:12,958
para deixar claro o que queremos imprimir

12333
08:18:12,958 --> 08:18:14,478
Se tentarmos fazer isso, vamos conseguir

12334
08:18:14,478 --> 08:18:17,440
um erro do compilador porque eu não estou em

12335
08:18:17,440 --> 08:18:20,558
escopo é apenas no escopo dentro destes

12336
08:18:20,558 --> 08:18:23,600
chaves encaracoladas que mostram a parte do corpo de

12337
08:18:23,600 --> 08:18:25,680
nosso loop OK código de estúdio visual é

12338
08:18:25,680 --> 08:18:27,200
mostrando o problema aqui está dizendo

12339
08:18:27,200 --> 08:18:29,840
olhos indefinidos aqui para que você não deve

12340
08:18:29,840 --> 08:18:32,240
realmente fazer isso, mas se seguirmos em frente e

12341
08:18:32,240 --> 08:18:34,080
Ignore a mensagem do estúdio visual

12342
08:18:34,080 --> 08:18:36,160
codificar e compilar

12343
08:18:36,160 --> 08:18:37,760
vamos ter um erro de compilador e

12344
08:18:37,760 --> 08:18:39,040
Vai dizer que

12345
08:18:39,040 --> 08:18:41,360
Eu não sei o que você está fazendo aqui eu

12346
08:18:41,360 --> 08:18:44,240
não foi declarado neste âmbito onde você

12347
08:18:44,240 --> 08:18:46,478
Estou usando-o e eu acho que está mesmo indo

12348
08:18:46,478 --> 08:18:48,240
para me dar uma linha um número que vai

12349
08:18:48,240 --> 08:18:51,440
Diga-me 46 que é onde você está fazendo

12350
08:18:51,440 --> 08:18:53,680
Algo errado e se formos em nosso código

12351
08:18:53,680 --> 08:18:55,840
nós vamos ver que esta é a linha

12352
08:18:55,840 --> 08:18:58,478
onde estamos cometendo o erro, então eu estou

12353
08:18:58,478 --> 08:19:00,638
Não no âmbito aqui vamos comentar

12354
08:19:00,638 --> 08:19:04,718
isso fora e dizer problema de compilador eu não é

12355
08:19:04,718 --> 08:19:06,638
no escopo que é o que você vai conseguir

12356
08:19:06,638 --> 08:19:08,718
se você tentar fazer isso e a principal

12357
08:19:08,718 --> 08:19:11,440
Mensagem é que se você declarar seu loop

12358
08:19:11,440 --> 08:19:14,318
Como este ah só vai ser escopo

12359
08:19:14,318 --> 08:19:16,080
no corpo do laço e esse é o

12360
08:19:16,080 --> 08:19:18,398
apenas o lugar onde você pode mencionar

12361
08:19:18,398 --> 08:19:20,638
nome e usá-lo se comentarmos isso

12362
08:19:20,638 --> 08:19:23,520
e mundo novamente o erro do compilador é

12363
08:19:23,520 --> 08:19:25,200
indo embora, você vai ver

12364
08:19:25,200 --> 08:19:27,440
que o mundo é bom, vamos claro

12365
08:19:27,440 --> 08:19:30,318
que nossa produção aqui é boa

12366
08:19:30,318 --> 08:19:31,760
Vamos construir de novo e mostrar a você

12367
08:19:31,760 --> 08:19:34,000
que a construção é boa e isso é

12368
08:19:34,000 --> 08:19:36,478
muito legal ambos terminaram com sucesso

12369
08:19:36,478 --> 08:19:39,200
Tudo bem, esta é uma maneira de configurar o nosso

12370
08:19:39,200 --> 08:19:42,160
loop, mas há uma maneira de fazer o nosso

12371
08:19:42,160 --> 08:19:45,600
iterador utilizável fora do corpo do

12372
08:19:45,600 --> 08:19:46,878
loop e nós vamos te mostrar como você

12373
08:19:46,878 --> 08:19:49,280
pode fazer isso a seguir, então vamos comentar isso

12374
08:19:49,280 --> 08:19:51,520
para fora e descer novamente

12375
08:19:51,520 --> 08:19:53,280
e nós vamos pegar o código porque

12376
08:19:53,280 --> 08:19:55,760
Nós não queremos digitar tudo isso novamente e

12377
08:19:55,760 --> 08:19:58,718
nós vamos dizer iterador declarado

12378
08:19:58,718 --> 08:20:01,680
Fora do loop, vamos descer

12379
08:20:01,680 --> 08:20:04,080
e colocar em nosso código

12380
08:20:04,080 --> 08:20:07,280
E nós vamos alinhar isso bem

12381
08:20:07,280 --> 08:20:10,718
e nós vamos pegar o iterador e

12382
08:20:10,718 --> 08:20:13,280
Declará-lo do lado de fora do loop, então

12383
08:20:13,280 --> 08:20:15,520
nós vamos dizer tamanho t

12384
08:20:15,520 --> 08:20:17,680
e nós vamos dizer eu e inicializar

12385
08:20:17,680 --> 08:20:19,440
Isso para 0

12386
08:20:19,440 --> 08:20:23,120
e nós vamos dizer isso muito claramente

12387
08:20:23,120 --> 08:20:25,520
iterador

12388
08:20:25,520 --> 08:20:28,398
Definição

12389
08:20:28,398 --> 08:20:30,240
O lado de fora

12390
08:20:30,240 --> 08:20:33,010
e nós vamos dizer em nosso

12391
08:20:33,010 --> 08:20:34,160
[Música]

12392
08:20:34,160 --> 08:20:36,718
declaração parte do iterador que somos

12393
08:20:36,718 --> 08:20:38,798
só vou dizer eu e isso vai

12394
08:20:38,798 --> 08:20:41,520
trabalhar muito bem se construirmos isso você é

12395
08:20:41,520 --> 08:20:43,600
Vamos ver que o mundo é bom e

12396
08:20:43,600 --> 08:20:45,600
Se nós executarmos isso, vai fazer o mesmo

12397
08:20:45,600 --> 08:20:47,280
O que está a fazer vai

12398
08:20:47,280 --> 08:20:50,160
imprimir i love c mais 10 vezes e se

12399
08:20:50,160 --> 08:20:52,798
você quer que eu seja utilizável no exterior do

12400
08:20:52,798 --> 08:20:55,040
loop agora você pode usá-lo nós podemos pegar o

12401
08:20:55,040 --> 08:20:57,920
Código aqui que estava falhando

12402
08:20:57,920 --> 08:21:01,280
na última execução do nosso código e colocar isso

12403
08:21:01,280 --> 08:21:03,360
Aqui e vamos alinhar isto a

12404
08:21:03,360 --> 08:21:05,040
Um pouco

12405
08:21:05,040 --> 08:21:07,360
e se nós compilarmos isso o livro está indo

12406
08:21:07,360 --> 08:21:08,878
para ser bom

12407
08:21:08,878 --> 08:21:11,200
E se tentarmos correr o galo, vamos

12408
08:21:11,200 --> 08:21:13,920
para ver eu amo c mais 10 vezes que estamos

12409
08:21:13,920 --> 08:21:15,600
vamos dizer loop feito e nós vamos

12410
08:21:15,600 --> 08:21:18,240
para imprimir o valor de eu e você vê que

12411
08:21:18,240 --> 08:21:20,398
Se fizermos coisas assim, eu vou

12412
08:21:20,398 --> 08:21:23,040
ser utilizável no lado de fora do loop

12413
08:21:23,040 --> 08:21:23,920
o corpo

12414
08:21:23,920 --> 08:21:26,718
e às vezes estes podem vir a dissim...

12415
08:21:26,718 --> 08:21:28,398
dependendo da lógica do

12416
08:21:28,398 --> 08:21:30,718
Aplicação que você está projetando apenas

12417
08:21:30,718 --> 08:21:33,040
Saiba que isso é algo que você pode fazer

12418
08:21:33,040 --> 08:21:34,878
em seus loops

12419
08:21:34,878 --> 08:21:38,318
Tudo bem, você pode ir ainda mais louco e sair

12420
08:21:38,318 --> 08:21:41,840
Esta declaração de iterador parte em

12421
08:21:41,840 --> 08:21:44,000
seu loop todos juntos para que você possa remover

12422
08:21:44,000 --> 08:21:45,680
Isso e nós vamos te mostrar como você

12423
08:21:45,680 --> 08:21:47,520
pode fazer isso em um minuto, então vamos comentar

12424
08:21:47,520 --> 08:21:49,520
Isso fora eu não quero remover o código

12425
08:21:49,520 --> 08:21:51,200
Porque eu quero que você tenha isso como um

12426
08:21:51,200 --> 08:21:53,120
referência se você precisa olhar para isso

12427
08:21:53,120 --> 08:21:56,080
Mais tarde, então vamos dizer deixar de fora

12428
08:21:56,080 --> 08:21:59,040
O que você pode fazer é pegar o código que nós

12429
08:21:59,040 --> 08:22:02,798
Eu tinha antes eu vou agarrá-lo

12430
08:22:02,798 --> 08:22:05,040
e nós vamos colar isso aqui

12431
08:22:05,040 --> 08:22:06,798
E o que vamos fazer é tirar

12432
08:22:06,798 --> 08:22:08,958
Este olho pode funcionar e você pode ver

12433
08:22:08,958 --> 08:22:12,398
código como este lá fora na natureza, então

12434
08:22:12,398 --> 08:22:14,080
vamos executar essa tarefa para construir

12435
08:22:14,080 --> 08:22:17,040
com gcc o mundo vai ser bom

12436
08:22:17,040 --> 08:22:19,440
e nós vamos limpar e correr galo

12437
08:22:19,440 --> 08:22:21,040
E vai fazer exatamente o mesmo

12438
08:22:21,040 --> 08:22:23,280
Uma coisa, então esta é uma maneira que você pode configurar

12439
08:22:23,280 --> 08:22:25,680
seus loops ok a última coisa que precisamos

12440
08:22:25,680 --> 08:22:28,318
ver sobre loops é que

12441
08:22:28,318 --> 08:22:30,958
Este teste aqui está usando um código rígido

12442
08:22:30,958 --> 08:22:33,280
valor e se precisávamos mudar isso

12443
08:22:33,280 --> 08:22:35,360
loop para correr, por exemplo, por mil

12444
08:22:35,360 --> 08:22:38,000
tempos que precisaríamos caçar manualmente

12445
08:22:38,000 --> 08:22:40,318
Esta linha de código altera esta e esta

12446
08:22:40,318 --> 08:22:43,040
Realmente não é um bom design, então o que é

12447
08:22:43,040 --> 08:22:45,360
Recomendado é armazenar esse valor em um

12448
08:22:45,360 --> 08:22:48,318
variável e teste contra essa variável

12449
08:22:48,318 --> 08:22:50,080
Nome em vez disso

12450
08:22:50,080 --> 08:22:52,558
Vamos comentar isso e mostrar que

12451
08:22:52,558 --> 08:22:54,000
Então nós vamos para

12452
08:22:54,000 --> 08:22:55,680
Comente isso para fora

12453
08:22:55,680 --> 08:22:58,958
e descer e copiar tudo isso

12454
08:22:58,958 --> 08:23:00,718
Eu não acho que eu quero fazer meus loops como

12455
08:23:00,718 --> 08:23:02,798
porque isso é realmente pouco intuitivo

12456
08:23:02,798 --> 08:23:06,080
na maioria das vezes, então eu vou declarar o meu

12457
08:23:06,080 --> 08:23:08,478
iterador dentro e eu vou copiar

12458
08:23:08,478 --> 08:23:10,878
O código que faz isso aqui estamos indo

12459
08:23:10,878 --> 08:23:12,318
para ir para baixo

12460
08:23:12,318 --> 08:23:13,680
E dizer

12461
08:23:13,680 --> 08:23:16,478
Não faça valores de hardcord ok, estamos indo

12462
08:23:16,478 --> 08:23:18,638
para dizer que é realmente ruim

12463
08:23:18,638 --> 08:23:20,318
e nós vamos descer e mostrar a você

12464
08:23:20,318 --> 08:23:22,718
uma maneira melhor de fazer as coisas e novamente

12465
08:23:22,718 --> 08:23:25,440
Agora estamos codificando muito nisso

12466
08:23:25,440 --> 08:23:28,080
valor mas podemos dizer const

12467
08:23:28,080 --> 08:23:30,318
Tamanho t

12468
08:23:30,318 --> 08:23:32,558
e podemos chamar essa contagem de valores para

12469
08:23:32,558 --> 08:23:34,478
exemplo e podemos inicializá-lo com

12470
08:23:34,478 --> 08:23:36,638
O que quisermos neste caso, queremos

12471
08:23:36,638 --> 08:23:39,760
controle nosso loop para executar 10 vezes assim

12472
08:23:39,760 --> 08:23:42,160
vamos colocar em um 10 e em vez disso

12473
08:23:42,160 --> 08:23:44,478
de codificação difícil e este 10 nós vamos

12474
08:23:44,478 --> 08:23:46,478
Para dizer a contagem

12475
08:23:46,478 --> 08:23:47,440
Está tudo bem

12476
08:23:47,440 --> 08:23:49,280
e se nós construímos e executamos, o loop é

12477
08:23:49,280 --> 08:23:51,040
Vou fazer exatamente a mesma coisa que é

12478
08:23:51,040 --> 08:23:53,280
indo para imprimir i love c plus mais 10

12479
08:23:53,280 --> 08:23:54,160
Os tempos de tempo

12480
08:23:54,160 --> 08:23:56,798
então vamos fazer isso

12481
08:23:56,798 --> 08:23:58,398
e correr o galo

12482
08:23:58,398 --> 08:24:00,558
Vai fazer a mesma coisa, mas agora

12483
08:24:00,558 --> 08:24:02,798
Temos um ponto de controle se quisermos

12484
08:24:02,798 --> 08:24:06,240
Isso para correr para vamos dizer 100 vezes

12485
08:24:06,240 --> 08:24:09,200
pode alterar o valor da contagem para 100 vezes

12486
08:24:09,200 --> 08:24:11,280
E se nós dois novamente é quantos

12487
08:24:11,280 --> 08:24:13,040
vezes o loop vai correr e isso

12488
08:24:13,040 --> 08:24:15,520
É muito mais limpo, então eu recomendo

12489
08:24:15,520 --> 08:24:16,558
loja

12490
08:24:16,558 --> 08:24:18,318
os valores que você usa em seus loops em

12491
08:24:18,318 --> 08:24:20,080
variáveis como esta e vai

12492
08:24:20,080 --> 08:24:22,798
fazer o seu código parecer melhor

12493
08:24:22,798 --> 08:24:25,520
Então vai correr 100 vezes e isso

12494
08:24:25,520 --> 08:24:27,680
É exatamente o que nós queremos

12495
08:24:27,680 --> 08:24:29,200
Isso é realmente tudo o que nos prossamos fazer em

12496
08:24:29,200 --> 08:24:30,718
Esta palestra espero que você a tenha encontrado

12497
08:24:30,718 --> 08:24:31,840
Interessante

12498
08:24:31,840 --> 08:24:34,398
Lamento que esta palestra tenha sido

12499
08:24:34,398 --> 08:24:36,240
longo porque tínhamos muitas coisas

12500
08:24:36,240 --> 08:24:39,360
para falar sobre, mas agora eu espero que você realmente

12501
08:24:39,360 --> 08:24:41,600
Saiba muitas coisas sobre como você pode

12502
08:24:41,600 --> 08:24:44,080
use seu para loops para fazê-los fazer

12503
08:24:44,080 --> 08:24:46,478
coisas e novamente muitos loops que nós somos

12504
08:24:46,478 --> 08:24:48,318
indo para usar em nosso c plus código são

12505
08:24:48,318 --> 08:24:50,398
Vou ter cinco partes para onde vamos

12506
08:24:50,398 --> 08:24:52,318
ter um iterador que vai ser um

12507
08:24:52,318 --> 08:24:55,200
variável que usamos para manipular como um loop

12508
08:24:55,200 --> 08:24:57,120
avança e faz as coisas

12509
08:24:57,120 --> 08:24:59,040
O ponto de partida será onde

12510
08:24:59,040 --> 08:25:00,798
O loop vai começar que vamos

12511
08:25:00,798 --> 08:25:02,398
ter um teste no lugar que vai

12512
08:25:02,398 --> 08:25:04,398
controle quando o loop termina e nós somos

12513
08:25:04,398 --> 08:25:06,718
ter o ponto final codificado em

12514
08:25:06,718 --> 08:25:08,240
Que teste vamos ter o

12515
08:25:08,240 --> 08:25:10,160
incrementação parte do loop que é

12516
08:25:10,160 --> 08:25:12,878
Vou controlar como o nosso loop se move

12517
08:25:12,878 --> 08:25:14,798
para a frente e nós vamos configurar um

12518
08:25:14,798 --> 08:25:18,000
par de aparelhos encaracolados que estão indo para

12519
08:25:18,000 --> 08:25:20,958
contenha o corpo do nosso loop neste

12520
08:25:20,958 --> 08:25:22,958
palestra sobre a qual vamos aprender enquanto

12521
08:25:22,958 --> 08:25:25,200
loops e esta é outra construção que nós

12522
08:25:25,200 --> 08:25:27,600
ter no c plus programação

12523
08:25:27,600 --> 08:25:29,680
linguagem que nos permite fazer repetitivos

12524
08:25:29,680 --> 08:25:32,558
tarefas da sintaxe para um tempo loop looks

12525
08:25:32,558 --> 08:25:35,520
Como este temos cinco partes em nosso loop

12526
08:25:35,520 --> 08:25:37,600
Temos o iterador do ponto de partida

12527
08:25:37,600 --> 08:25:40,000
o teste da incrementação e o loop

12528
08:25:40,000 --> 08:25:41,840
corpo, ele só vai ser configurado

12529
08:25:41,840 --> 08:25:45,280
diferente para enquanto loops o iterador

12530
08:25:45,280 --> 08:25:47,760
é declarado do lado de fora e você vê

12531
08:25:47,760 --> 08:25:49,760
Aqui nós não temos assinado em I que é

12532
08:25:49,760 --> 08:25:52,240
exatamente o mesmo tipo de iterador que temos

12533
08:25:52,240 --> 08:25:54,318
usado na última palestra, mas saiba que

12534
08:25:54,318 --> 08:25:56,798
você também pode usar o tamanho t aqui eu sou apenas

12535
08:25:56,798 --> 08:25:59,440
usando não assinado e para este caso após

12536
08:25:59,440 --> 08:26:02,718
Você tem seu iterador declarado que você é

12537
08:26:02,718 --> 08:26:04,958
vai cair para esta parte aqui e dizer

12538
08:26:04,958 --> 08:26:08,080
enquanto abre um conjunto de parênteses e

12539
08:26:08,080 --> 08:26:10,878
Dentro você vai colocar em seu teste

12540
08:26:10,878 --> 08:26:12,798
Depois disso, você vai abrir um par

12541
08:26:12,798 --> 08:26:15,200
de chaves encaracoladas e projetá-los que você é

12542
08:26:15,200 --> 08:26:17,920
Vou colocar o corpo do seu loop

12543
08:26:17,920 --> 08:26:19,360
E você vai fazer o que for

12544
08:26:19,360 --> 08:26:22,478
você quer fazer no loop lá e

12545
08:26:22,478 --> 08:26:24,398
após o seu código para fazer o que você é

12546
08:26:24,398 --> 08:26:26,718
Quer fazer é executado você vai

12547
08:26:26,718 --> 08:26:29,760
colocar em sua parte de incrementação depois

12548
08:26:29,760 --> 08:26:32,000
você codifica e é isso que temos aqui

12549
08:26:32,000 --> 08:26:33,680
E esta é a configuração que vamos ser

12550
08:26:33,680 --> 08:26:37,040
usando para o nosso tempo loops novamente

12551
08:26:37,040 --> 08:26:38,478
Temos o

12552
08:26:38,478 --> 08:26:41,200
iterador declarado do lado de fora e nós

12553
08:26:41,200 --> 08:26:43,520
pode inicializá-lo com o que quer que seja

12554
08:26:43,520 --> 08:26:44,798
Querê-lo

12555
08:26:44,798 --> 08:26:46,160
Comece com

12556
08:26:46,160 --> 08:26:48,080
então nós vamos colocar em nosso teste é

12557
08:26:48,080 --> 08:26:50,160
vai estar dentro deste parêntese e

12558
08:26:50,160 --> 08:26:52,318
Depois disso, vamos montar um par

12559
08:26:52,318 --> 08:26:54,798
de chaves encaracoladas e dentro deles nós somos

12560
08:26:54,798 --> 08:26:56,558
Vou colocar o código que quisermos

12561
08:26:56,558 --> 08:26:58,478
correr no loop e então nós vamos

12562
08:26:58,478 --> 08:27:01,200
Siga isso com a nossa parte de incrementação

12563
08:27:01,200 --> 08:27:03,040
E se tentarmos correr isso, vamos

12564
08:27:03,040 --> 08:27:05,120
correr esta linha vamos declarar o

12565
08:27:05,120 --> 08:27:07,440
iterador i e ele vai começar com

12566
08:27:07,440 --> 08:27:10,798
zero para que o teste seja executado e 0

12567
08:27:10,798 --> 08:27:12,558
é menos de 10

12568
08:27:12,558 --> 08:27:14,398
e nós vamos ter sucesso e nós somos

12569
08:27:14,398 --> 08:27:16,000
Vou correr o corpo aqui nós vamos

12570
08:27:16,000 --> 08:27:18,478
para dizer que eu amo c plus plus e depois disso

12571
08:27:18,478 --> 08:27:20,080
nós vamos executar o incremento

12572
08:27:20,080 --> 08:27:22,798
Parte eu vou me tornar um que nós somos

12573
08:27:22,798 --> 08:27:25,520
indo para executar o teste novamente para que um é

12574
08:27:25,520 --> 08:27:27,200
Menos de 10 nós vamos ter sucesso

12575
08:27:27,200 --> 08:27:29,520
nós vamos cair na impressão I love c

12576
08:27:29,520 --> 08:27:31,680
plus vamos incrementar novamente

12577
08:27:31,680 --> 08:27:34,478
Então nós vamos ter um 2 em I aqui

12578
08:27:34,478 --> 08:27:36,318
Vamos fazer o teste novamente, estamos

12579
08:27:36,318 --> 08:27:38,638
indo dizer que é 2 menos de 10 que é

12580
08:27:38,638 --> 08:27:40,160
Vou ser verdade, então nós vamos ser

12581
08:27:40,160 --> 08:27:42,478
bem sucedidos, vamos cair no

12582
08:27:42,478 --> 08:27:44,080
corpo do loop que nós vamos

12583
08:27:44,080 --> 08:27:46,080
incrementar e obter um três que vamos

12584
08:27:46,080 --> 08:27:48,878
O teste contra o nosso três valor três é

12585
08:27:48,878 --> 08:27:50,478
Menos de dez nós vamos ter sucesso

12586
08:27:50,478 --> 08:27:53,200
nós vamos imprimir i love c plus plus

12587
08:27:53,200 --> 08:27:55,120
Nós vamos incrementar novamente nós somos

12588
08:27:55,120 --> 08:27:57,280
Vou testar novamente e nós vamos

12589
08:27:57,280 --> 08:28:01,040
Dizem que é menos do que contar ou 10 nós somos

12590
08:28:01,040 --> 08:28:02,558
Vou ser bem sucedido e nós vamos

12591
08:28:02,558 --> 08:28:04,798
continuar correndo até incrementarmos e

12592
08:28:04,798 --> 08:28:07,360
obter um 9. uma vez que temos um 9 nós vamos

12593
08:28:07,360 --> 08:28:09,520
executar o teste novamente e nós vamos

12594
08:28:09,520 --> 08:28:12,000
Diz que é 9 menos de 10 que vai ser

12595
08:28:12,000 --> 08:28:14,958
para que possamos cair dentro

12596
08:28:14,958 --> 08:28:16,958
imprimir i love c plus plus vamos

12597
08:28:16,958 --> 08:28:18,958
incrementa e obter um 10

12598
08:28:18,958 --> 08:28:20,958
E se fizermos o teste novamente eu estou indo

12599
08:28:20,958 --> 08:28:23,920
dizer que é 10 menos que 10 que está indo

12600
08:28:23,920 --> 08:28:26,478
para falhar e nós vamos cair sobre o

12601
08:28:26,478 --> 08:28:27,920
fora do loop e nós vamos

12602
08:28:27,920 --> 08:28:30,318
executar qualquer código que estiver no exterior aqui

12603
08:28:30,318 --> 08:28:32,718
Isto é realmente como um loop de tempo funciona

12604
08:28:32,718 --> 08:28:34,718
e espero que você possa ver as semelhanças

12605
08:28:34,718 --> 08:28:36,878
Entre o loop, temos visto que é

12606
08:28:36,878 --> 08:28:38,878
Realmente a mesma coisa que nós apenas temos

12607
08:28:38,878 --> 08:28:41,200
diferentes sintaxes para fazer essas coisas

12608
08:28:41,200 --> 08:28:42,878
Tudo bem se você olhar para essas coisas nós

12609
08:28:42,878 --> 08:28:44,240
Já tem as mesmas peças de

12610
08:28:44,240 --> 08:28:46,318
Informações são apenas diferentes

12611
08:28:46,318 --> 08:28:48,878
sintasxas que o c plus plus fornece para fazer

12612
08:28:48,878 --> 08:28:51,040
As mesmas coisas e às vezes você

12613
08:28:51,040 --> 08:28:53,280
indo para encontrá-lo conveniente para usar enquanto

12614
08:28:53,280 --> 08:28:54,878
loops e às vezes você vai encontrar

12615
08:28:54,878 --> 08:28:57,440
é conveniente usar para loops e

12616
08:28:57,440 --> 08:28:59,040
Você vai ter que decidir o que

12617
08:28:59,040 --> 08:29:01,520
Funciona melhor para o que você é

12618
08:29:01,520 --> 08:29:03,600
trabalhando para agora que vamos cabeçar

12619
08:29:03,600 --> 08:29:05,840
mais para código de estúdio visual e tente isso

12620
08:29:05,840 --> 08:29:08,318
Ok aqui estamos no estúdio visual

12621
08:29:08,318 --> 08:29:10,958
codificar o projeto atual é enquanto loop

12622
08:29:10,958 --> 08:29:13,520
nós vamos pegar nossos arquivos de modelo

12623
08:29:13,520 --> 08:29:15,280
e nós vamos entrar em nosso projeto e

12624
08:29:15,280 --> 08:29:16,798
Coloque os que estão em

12625
08:29:16,798 --> 08:29:18,718
e nós vamos abrir isso em visual

12626
08:29:18,718 --> 08:29:21,680
Código de estúdio, então vamos fazer isso

12627
08:29:21,680 --> 08:29:24,080
Vamos abrir a pasta

12628
08:29:24,080 --> 08:29:26,000
e nós vamos trabalhar em loop

12629
08:29:26,000 --> 08:29:28,638
Aqui vamos abrir nosso cpp principal

12630
08:29:28,638 --> 08:29:30,638
arquivo muito rápido e nós vamos chegar

12631
08:29:30,638 --> 08:29:33,200
Livre disso e o que vamos fazer

12632
08:29:33,200 --> 08:29:35,520
é remover o que não precisamos e novamente

12633
08:29:35,520 --> 08:29:36,878
nós vamos te mostrar o caminho ruim para

12634
08:29:36,878 --> 08:29:38,478
fazer coisas que você realmente não quer fazer

12635
08:29:38,478 --> 08:29:40,478
Isso manualmente queremos imprimir i love c

12636
08:29:40,478 --> 08:29:42,318
mais mais 10 vezes

12637
08:29:42,318 --> 08:29:43,120
Então,

12638
08:29:43,120 --> 08:29:45,040
nós vamos construir vamos trazer um

12639
08:29:45,040 --> 08:29:47,120
Novo terminal para que possamos

12640
08:29:47,120 --> 08:29:49,920
Use isso quando corrermos graças e estamos

12641
08:29:49,920 --> 08:29:52,558
indo para o mundo com gcc vamos fazer isso

12642
08:29:52,558 --> 08:29:55,040
E muito rápido o mundo é bom

12643
08:29:55,040 --> 08:29:57,680
para que possamos limpar e correr galo e

12644
08:29:57,680 --> 08:29:59,520
nós vamos ter que eu amo c plus

12645
08:29:59,520 --> 08:30:02,478
impresso 10 vezes para o que podemos fazer

12646
08:30:02,478 --> 08:30:05,840
é comentar isso e usar um loop de tempo

12647
08:30:05,840 --> 08:30:08,080
Como queremos fazer nesta palestra aqui

12648
08:30:08,080 --> 08:30:11,040
e como vimos com os slides

12649
08:30:11,040 --> 08:30:13,520
A primeira coisa que precisamos fazer é declarar

12650
08:30:13,520 --> 08:30:15,520
nosso iterador do lado de fora, então nós somos

12651
08:30:15,520 --> 08:30:17,280
vamos dizer tamanho ti nós vamos

12652
08:30:17,280 --> 08:30:19,280
inicialize isso com zero

12653
08:30:19,280 --> 08:30:21,360
E isso vai ser o nosso iterador

12654
08:30:21,360 --> 08:30:24,240
declaração e vamos dizer enquanto

12655
08:30:24,240 --> 08:30:26,558
Eu sou menos do que o valor onde queremos

12656
08:30:26,558 --> 08:30:28,798
para parar e de novo não queremos muito

12657
08:30:28,798 --> 08:30:30,718
codificar esses valores e o que somos

12658
08:30:30,718 --> 08:30:32,398
Vou dizer que é realmente

12659
08:30:32,398 --> 08:30:35,200
Const tamanho t e nós vamos ligar

12660
08:30:35,200 --> 08:30:38,080
esta contagem e torná-lo maiúsculo este é

12661
08:30:38,080 --> 08:30:40,160
uma convenção que usamos para declarar constantes

12662
08:30:40,160 --> 08:30:42,160
em c plus plus mas você não tem que

12663
08:30:42,160 --> 08:30:43,840
fazê-los maiúsculo é apenas um

12664
08:30:43,840 --> 08:30:45,840
convenção que vai fazer seu

12665
08:30:45,840 --> 08:30:48,478
código mais fácil de ler para outras pessoas, então

12666
08:30:48,478 --> 08:30:50,000
nós vamos

12667
08:30:50,000 --> 08:30:52,558
colocar um 10 aqui porque nós queremos o nosso

12668
08:30:52,558 --> 08:30:54,478
loop para correr 10 vezes

12669
08:30:54,478 --> 08:30:56,798
E nós vamos dizer y i

12670
08:30:56,798 --> 08:30:58,798
é menos do que contar e nós vamos

12671
08:30:58,798 --> 08:31:02,000
configurar um par de chaves encaracoladas e eles

12672
08:31:02,000 --> 08:31:03,920
Eles vão delimitar

12673
08:31:03,920 --> 08:31:07,200
O início e o fim do corpo de um

12674
08:31:07,200 --> 08:31:09,200
loop aqui e dentro vamos colocar

12675
08:31:09,200 --> 08:31:11,440
em qualquer código que queremos que o loop seja executado

12676
08:31:11,440 --> 08:31:14,638
várias vezes e o código agora é muito

12677
08:31:14,638 --> 08:31:17,920
familiar, vamos dizer sddc para fora

12678
08:31:17,920 --> 08:31:19,680
E nós vamos imprimir o

12679
08:31:19,680 --> 08:31:22,160
iteração atual e vamos dizer

12680
08:31:22,160 --> 08:31:25,920
Eu amo c plus plus sdd endl para o nosso novo

12681
08:31:25,920 --> 08:31:28,000
personagem de linha e depois disso vamos

12682
08:31:28,000 --> 08:31:30,558
Precisamos colocar em nosso próprio incremento

12683
08:31:30,558 --> 08:31:32,718
parte se você esquecer que você está indo para

12684
08:31:32,718 --> 08:31:34,798
ter algo realmente ruim acontecer, nós somos

12685
08:31:34,798 --> 08:31:37,120
realmente vou olhar para isso mais tarde em

12686
08:31:37,120 --> 08:31:40,240
o capítulo, mas por enquanto lembre-se de colocar

12687
08:31:40,240 --> 08:31:42,718
A parte de incrementação e nós vamos

12688
08:31:42,718 --> 08:31:45,440
para dizer plus plus i é realmente fácil

12689
08:31:45,440 --> 08:31:47,440
e nós vamos dizer que este é o

12690
08:31:47,440 --> 08:31:49,200
teste

12691
08:31:49,200 --> 08:31:51,440
E isso vai fazer o que queremos, mas

12692
08:31:51,440 --> 08:31:54,160
Vamos descer aqui e dizer que o loop é

12693
08:31:54,160 --> 08:31:56,318
feito quando for feito, então vamos

12694
08:31:56,318 --> 08:31:59,760
Diga loop feito

12695
08:31:59,760 --> 08:32:03,440
E nós vamos dizer stdendya

12696
08:32:03,440 --> 08:32:05,200
E antes de corrermos isso, vamos embora

12697
08:32:05,200 --> 08:32:07,440
através dele e veja como ele vai

12698
08:32:07,440 --> 08:32:10,558
para que possamos clicar neste ícone de arquivo

12699
08:32:10,558 --> 08:32:12,878
aqui para fechar este painel para que tenhamos

12700
08:32:12,878 --> 08:32:15,280
algum espaço para respirar, vou abrir um

12701
08:32:15,280 --> 08:32:17,760
arquivo do bloco de notas que vamos usar para ver

12702
08:32:17,760 --> 08:32:20,398
Essas coisas realmente acontecem

12703
08:32:20,398 --> 08:32:22,318
Quando este loop corre, vamos

12704
08:32:22,318 --> 08:32:25,120
inicialize o iterador aqui o que somos

12705
08:32:25,120 --> 08:32:27,200
Indo fazer é colocar em um 0 e nós estamos

12706
08:32:27,200 --> 08:32:29,840
indo para executar o teste para ver se 0 é

12707
08:32:29,840 --> 08:32:31,840
menos de 10 e o teste será

12708
08:32:31,840 --> 08:32:34,240
bem sucedido para que vamos cair em

12709
08:32:34,240 --> 08:32:35,920
aqui e dizer

12710
08:32:35,920 --> 08:32:38,558
0 eu amo c plus plus então vamos dizer que

12711
08:32:38,558 --> 08:32:41,200
aqui para deixar isso super claro dentro do

12712
08:32:41,200 --> 08:32:42,798
loop vamos imprimir esta mensagem

12713
08:32:42,798 --> 08:32:45,200
zero eu amo c plus plus e depois nós

12714
08:32:45,200 --> 08:32:47,040
Executar esta linha que vamos

12715
08:32:47,040 --> 08:32:49,840
incremento Eu vou me tornar um que somos

12716
08:32:49,840 --> 08:32:51,680
indo para subir novamente e executar o teste

12717
08:32:51,680 --> 08:32:54,080
e nós vamos dizer que é 1

12718
08:32:54,080 --> 08:32:57,520
menos do que contar ou é 1 menos de 10.

12719
08:32:57,520 --> 08:32:59,520
O teste será bem sucedido, nós somos

12720
08:32:59,520 --> 08:33:01,360
indo correr dentro do loop e nós estamos

12721
08:33:01,360 --> 08:33:03,920
indo para imprimir 1 i love plus plus

12722
08:33:03,920 --> 08:33:05,200
Isso é o que vamos fazer aqui, então

12723
08:33:05,200 --> 08:33:07,120
Vamos fazer isso

12724
08:33:07,120 --> 08:33:08,718
E depois que fazemos isso, vamos correr

12725
08:33:08,718 --> 08:33:11,200
nossa parte de incrementação novamente

12726
08:33:11,200 --> 08:33:13,600
Eu vou me tornar dois que vamos

12727
08:33:13,600 --> 08:33:15,680
executar o teste que vamos dizer é 2

12728
08:33:15,680 --> 08:33:17,920
Menos de 10 que vai ser verdade para

12729
08:33:17,920 --> 08:33:19,600
curso e nós vamos cair no

12730
08:33:19,600 --> 08:33:22,718
corpo novamente e dizer dois eu amo c mais

12731
08:33:22,718 --> 08:33:23,920
+ a vantagem

12732
08:33:23,920 --> 08:33:25,840
então vamos dizer que

12733
08:33:25,840 --> 08:33:27,280
Nós vamos aumentar e nós vamos

12734
08:33:27,280 --> 08:33:28,878
para obter um três, vamos correr o

12735
08:33:28,878 --> 08:33:30,398
testar novamente o teste vai ser

12736
08:33:30,398 --> 08:33:32,558
Sucesso porque três é menos do que

12737
08:33:32,558 --> 08:33:35,200
Dez nós vamos cair aqui e dizer

12738
08:33:35,200 --> 08:33:38,000
três eu amo c plus plus bom para que possamos

12739
08:33:38,000 --> 08:33:40,240
Realmente siga isso

12740
08:33:40,240 --> 08:33:42,080
e nós vamos aumentar para obter um

12741
08:33:42,080 --> 08:33:44,718
Quatro e o teste vai dizer é

12742
08:33:44,718 --> 08:33:47,120
Quatro a menos de dez que vai ser

12743
08:33:47,120 --> 08:33:48,638
É verdade que vamos ter sucesso e

12744
08:33:48,638 --> 08:33:50,478
Seguindo o corpo novamente e nós vamos

12745
08:33:50,478 --> 08:33:53,760
para dizer 4 eu amo z mais blocos

12746
08:33:53,760 --> 08:33:55,280
nós vamos continuar fazendo isso e nós estamos

12747
08:33:55,280 --> 08:33:56,638
indo para incrementar novamente nós vamos

12748
08:33:56,638 --> 08:33:59,120
obter um 5. o teste vai funcionar novamente

12749
08:33:59,120 --> 08:34:01,200
Vamos dizer que é menos de 10

12750
08:34:01,200 --> 08:34:03,280
Isso vai ser verdade, claro e

12751
08:34:03,280 --> 08:34:05,600
Vamos executar o código para imprimir

12752
08:34:05,600 --> 08:34:08,398
5 i love c plus mais

12753
08:34:08,398 --> 08:34:10,080
nós vamos incrementar novamente para obter um

12754
08:34:10,080 --> 08:34:11,760
seis

12755
08:34:11,760 --> 08:34:13,520
nós vamos fazer o teste que estamos indo

12756
08:34:13,520 --> 08:34:16,000
dizer que é 6 menos do que 10 que vai

12757
08:34:16,000 --> 08:34:18,160
ser verdadeiro, claro, novamente e nós vamos

12758
08:34:18,160 --> 08:34:21,280
para imprimir conjuntos i love c plus plus e

12759
08:34:21,280 --> 08:34:23,120
Vamos aumentar para obter um 7

12760
08:34:23,120 --> 08:34:25,760
vamos fazer o teste nosso iterador

12761
08:34:25,760 --> 08:34:28,798
nós vamos dizer que é 7 menos do que contar

12762
08:34:28,798 --> 08:34:30,878
Isso vai ser verdade que nós vamos

12763
08:34:30,878 --> 08:34:33,600
Imprima a mensagem novamente e diga sete i

12764
08:34:33,600 --> 08:34:35,680
Ame c plus plus e nós vamos

12765
08:34:35,680 --> 08:34:37,680
incremento novamente para obter um oito, nós somos

12766
08:34:37,680 --> 08:34:39,360
indo dizer que são oito menos do que e

12767
08:34:39,360 --> 08:34:40,318
Contagem de contas

12768
08:34:40,318 --> 08:34:41,840
Isso vai ser verdade que nós vamos

12769
08:34:41,840 --> 08:34:44,718
cair no corpo e dizer oito eu amo c

12770
08:34:44,718 --> 08:34:47,200
mais plus vamos incrementar para

12771
08:34:47,200 --> 08:34:48,798
obter um nove

12772
08:34:48,798 --> 08:34:50,718
nós vamos fazer o teste contra o nosso

12773
08:34:50,718 --> 08:34:54,000
Nove, claro, nove é menos de dez, então

12774
08:34:54,000 --> 08:34:55,680
Isso vai ser verdade que nós vamos

12775
08:34:55,680 --> 08:34:58,878
cair dentro e nós vamos dizer nove

12776
08:34:58,878 --> 08:35:00,398
Eu amo c plus plus

12777
08:35:00,398 --> 08:35:02,080
E depois disso vamos incrementar

12778
08:35:02,080 --> 08:35:04,240
Mais uma vez e vamos ter um 10.

12779
08:35:04,240 --> 08:35:06,160
Agora, se fizermos o teste, vamos

12780
08:35:06,160 --> 08:35:09,360
Diga é 10 menos de 10 e que está indo

12781
08:35:09,360 --> 08:35:12,000
ser falso porque 10 não é menor do que

12782
08:35:12,000 --> 08:35:15,360
10 e se o teste aqui falhar, não estamos

12783
08:35:15,360 --> 08:35:17,280
Vai cair no corpo do laço

12784
08:35:17,280 --> 08:35:20,080
O controle vai cair no final de

12785
08:35:20,080 --> 08:35:22,240
o corpo do loop e vamos imprimir

12786
08:35:22,240 --> 08:35:24,160
loop feito isso é o que vamos dizer

12787
08:35:24,160 --> 08:35:26,840
Aqui nós vamos dizer loop

12788
08:35:26,840 --> 08:35:31,360
feito e nosso loop terá executado 10 vezes

12789
08:35:31,360 --> 08:35:33,440
no momento em que imprimimos este loop para baixo

12790
08:35:33,440 --> 08:35:35,200
mensagem aqui se você contar aqui você vê

12791
08:35:35,200 --> 08:35:37,440
que o loop vai correr 10 vezes

12792
08:35:37,440 --> 08:35:39,520
e vai dizer que eu amo c mais

12793
08:35:39,520 --> 08:35:41,680
mais 10 vezes, o que é realmente o que nós

12794
08:35:41,680 --> 08:35:43,840
Quero ok, eu realmente tive que te mostrar isso

12795
08:35:43,840 --> 08:35:46,000
manualmente para que você possa realmente ver o que

12796
08:35:46,000 --> 08:35:48,478
Está acontecendo, mas agora podemos soldar e correr

12797
08:35:48,478 --> 08:35:50,878
e deixe o computador fazer o pesado

12798
08:35:50,878 --> 08:35:53,200
dever de executar isso e mostrar a todos nós

12799
08:35:53,200 --> 08:35:54,638
Essas mensagens

12800
08:35:54,638 --> 08:35:56,478
para que a construção seja bem-sucedida

12801
08:35:56,478 --> 08:35:57,840
É claro que é

12802
08:35:57,840 --> 08:35:59,680
nós vamos correr o galo e é

12803
08:35:59,680 --> 08:36:01,520
Vou mostrar exatamente a mesma coisa que nós

12804
08:36:01,520 --> 08:36:05,680
Acabámos de aparecer no nosso fiel arquivo do bloco de notas

12805
08:36:05,680 --> 08:36:08,160
Aqui você vê que é a mesma coisa, mas

12806
08:36:08,160 --> 08:36:10,240
A beleza é que não temos que fazer

12807
08:36:10,240 --> 08:36:12,878
Todos esses cálculos loucos novamente o que

12808
08:36:12,878 --> 08:36:15,280
nós podemos fazer é que podemos até mudar o

12809
08:36:15,280 --> 08:36:17,840
conte até 100, então vai correr para

12810
08:36:17,840 --> 08:36:19,440
100 vezes mais

12811
08:36:19,440 --> 08:36:21,440
Isso é muito legal

12812
08:36:21,440 --> 08:36:22,958
para que possamos

12813
08:36:22,958 --> 08:36:25,840
claro e correr galo e vai fazer

12814
08:36:25,840 --> 08:36:28,718
100 vezes e isso é muito rápido

12815
08:36:28,718 --> 08:36:30,160
para os computadores

12816
08:36:30,160 --> 08:36:32,638
Isso é realmente tudo o que tínhamos para compartilhar

12817
08:36:32,638 --> 08:36:35,280
você nesta palestra o principal é

12818
08:36:35,280 --> 08:36:37,840
Aprenda sobre a sintaxe de um loop de tempo

12819
08:36:37,840 --> 08:36:40,160
e novamente notar que temos esses cinco

12820
08:36:40,160 --> 08:36:42,958
peças que compõem o nosso loop temos um

12821
08:36:42,958 --> 08:36:44,638
iterador temos o ponto de partida que

12822
08:36:44,638 --> 08:36:46,878
ter um teste que temos a incrementação

12823
08:36:46,878 --> 08:36:49,520
parte e nós temos o corpo do loop que é

12824
08:36:49,520 --> 08:36:52,000
apenas configurado de forma diferente com um tempo

12825
08:36:52,000 --> 08:36:54,638
loop como podemos ver aqui neste

12826
08:36:54,638 --> 08:36:56,558
palestra que vamos aprender sobre fazer

12827
08:36:56,558 --> 08:36:58,798
enquanto loops e este é mais um

12828
08:36:58,798 --> 08:37:01,120
construção que temos em c plus plus para fazer

12829
08:37:01,120 --> 08:37:03,040
Tarefas repetitivas

12830
08:37:03,040 --> 08:37:05,520
Vejamos a sintaxe aqui que temos

12831
08:37:05,520 --> 08:37:08,558
nossa declaração do iterador sobre o

12832
08:37:08,558 --> 08:37:10,638
Fora e depois disso você vai

12833
08:37:10,638 --> 08:37:13,440
Diga se você vai colocar um par de

12834
08:37:13,440 --> 08:37:15,760
curly brasce como este que você está indo para

12835
08:37:15,760 --> 08:37:18,398
Coloque o código que você deseja executar

12836
08:37:18,398 --> 08:37:20,398
dentro do loop e então você está indo para

12837
08:37:20,398 --> 08:37:22,958
fazer o seu incremento e depois do

12838
08:37:22,958 --> 08:37:25,840
fechando braçadeira encaracolada você vai dizer

12839
08:37:25,840 --> 08:37:27,440
Enquanto e você vai colocar em seu

12840
08:37:27,440 --> 08:37:29,600
Texto este é realmente a estrutura novamente

12841
08:37:29,600 --> 08:37:32,318
notar que temos essas cinco partes e

12842
08:37:32,318 --> 08:37:33,600
Este é o

12843
08:37:33,600 --> 08:37:36,240
Declaração do nosso iterador e nós somos

12844
08:37:36,240 --> 08:37:38,318
vai inicializar isso em vigor para

12845
08:37:38,318 --> 08:37:40,558
Um exemplo se queremos fazer isso

12846
08:37:40,558 --> 08:37:42,240
Depois disso, nós vamos

12847
08:37:42,240 --> 08:37:44,718
queda no corpo do loop

12848
08:37:44,718 --> 08:37:46,558
e depois disso vamos fazer o

12849
08:37:46,558 --> 08:37:48,798
incrementação depois de executar o código

12850
08:37:48,798 --> 08:37:50,958
Queremos correr no corpo do

12851
08:37:50,958 --> 08:37:53,440
loop e então vamos fazer o teste

12852
08:37:53,440 --> 08:37:56,798
Mais tarde e a coisa especial sobre um fazer

12853
08:37:56,798 --> 08:38:00,478
enquanto o loop é que ele vai correr

12854
08:38:00,478 --> 08:38:03,520
primeiro e então você faz o teste por último

12855
08:38:03,520 --> 08:38:05,200
Isso é realmente algo que você precisa ser

12856
08:38:05,200 --> 08:38:07,760
Cuidado para ter certeza de que quando ele

12857
08:38:07,760 --> 08:38:09,680
corre, está fazendo o que quer que você queira

12858
08:38:09,680 --> 08:38:12,160
para fazer porque o teste vai correr

12859
08:38:12,160 --> 08:38:15,200
após o seu código ter realmente funcionado e você

12860
08:38:15,200 --> 08:38:17,120
pode ajustar isso para fazer o que quer que seja

12861
08:38:17,120 --> 08:38:19,680
Quero que ele faça o que vamos ver

12862
08:38:19,680 --> 08:38:21,840
quando atingimos código de estúdio visual em um

12863
08:38:21,840 --> 08:38:24,000
minuto ok novamente uma coisa que você precisa

12864
08:38:24,000 --> 08:38:26,798
Tenha em mente que o fazer enquanto loop

12865
08:38:26,798 --> 08:38:28,798
Vai correr o corpo

12866
08:38:28,798 --> 08:38:31,600
do laço e, em seguida, fazer o cheque ou o

12867
08:38:31,600 --> 08:38:34,240
teste e que pode vir a dissim.

12868
08:38:34,240 --> 08:38:36,558
das aplicações que você vai fazer

12869
08:38:36,558 --> 08:38:38,718
dentro de sua carreira como um c plus mais

12870
08:38:38,718 --> 08:38:40,798
Desenvolvedor OK esta é realmente a sintaxe

12871
08:38:40,798 --> 08:38:42,478
nós vamos estar usando nós vamos

12872
08:38:42,478 --> 08:38:44,878
cabeça para código de estúdio visual e jogar

12873
08:38:44,878 --> 08:38:48,318
conosco ok aqui estamos em nosso trabalho

12874
08:38:48,318 --> 08:38:50,318
pasta O projeto atual está indo para

12875
08:38:50,318 --> 08:38:52,080
ser fazer enquanto loop

12876
08:38:52,080 --> 08:38:54,718
nós vamos pegar os arquivos do modelo

12877
08:38:54,718 --> 08:38:57,360
muito rápido e nós vamos colocá-los

12878
08:38:57,360 --> 08:39:00,000
em nosso projeto atual, vamos abrir isso

12879
08:39:00,000 --> 08:39:02,160
para cima e colocá-los lá

12880
08:39:02,160 --> 08:39:04,638
e nós vamos abrir isso em

12881
08:39:04,638 --> 08:39:07,280
studio code do while loop é o nosso projeto

12882
08:39:07,280 --> 08:39:09,520
nós vamos abrir isso e o principal

12883
08:39:09,520 --> 08:39:12,478
cpp é aberto assim que vamos remover

12884
08:39:12,478 --> 08:39:14,798
O que quer que seja que não precisamos e nós somos

12885
08:39:14,798 --> 08:39:16,958
Vou te mostrar a maneira ruim de fazer

12886
08:39:16,958 --> 08:39:19,600
A maneira ruim de fazer as coisas é

12887
08:39:19,600 --> 08:39:22,000
digitando seu código para fazer as coisas manualmente

12888
08:39:22,000 --> 08:39:24,080
Se você quisesse que eles fossem feitos múltiplos

12889
08:39:24,080 --> 08:39:26,318
tempos e isso é algo ruim se nós

12890
08:39:26,318 --> 08:39:28,240
Comprei isto e corremos vamos embora

12891
08:39:28,240 --> 08:39:30,878
para baixo e correr este claro não

12892
08:39:30,878 --> 08:39:32,878
que é g escova que vamos correr

12893
08:39:32,878 --> 08:39:34,000
Galo

12894
08:39:34,000 --> 08:39:35,840
e nós vamos receber eu amar c mais

12895
08:39:35,840 --> 08:39:37,760
mais 10 vezes e você não quer fazer

12896
08:39:37,760 --> 08:39:40,240
Algo assim o que queremos nisso

12897
08:39:40,240 --> 08:39:42,080
A palestra é para usar

12898
08:39:42,080 --> 08:39:45,120
fazer enquanto loops para resolver este problema

12899
08:39:45,120 --> 08:39:46,958
nós vamos comentar isso porque

12900
08:39:46,958 --> 08:39:49,040
É realmente ruim

12901
08:39:49,040 --> 08:39:51,200
E nós vamos descer e configurar

12902
08:39:51,200 --> 08:39:53,840
o nosso fazer enquanto loop a primeira coisa que nós

12903
08:39:53,840 --> 08:39:56,080
A necessidade é configurar a contagem

12904
08:39:56,080 --> 08:39:57,920
Porque queremos armazenar isso em alguns

12905
08:39:57,920 --> 08:39:59,600
variáveis então vamos dizer const

12906
08:39:59,600 --> 08:40:00,478
E a

12907
08:40:00,478 --> 08:40:01,840
Contagem de contas

12908
08:40:01,840 --> 08:40:03,360
e nós vamos colocar em nosso valor

12909
08:40:03,360 --> 08:40:05,280
Vamos colocar em um 10

12910
08:40:05,280 --> 08:40:08,958
Não 190 vamos dizer 10 vezes

12911
08:40:08,958 --> 08:40:11,360
e nós vamos montar o nosso iterador

12912
08:40:11,360 --> 08:40:14,558
nós vamos dizer tamanho t

12913
08:40:14,558 --> 08:40:16,558
e nós vamos dizer eu e inicializar

12914
08:40:16,558 --> 08:40:18,958
Isso com o nosso ponto de partida, vamos

12915
08:40:18,958 --> 08:40:20,638
para começar do zero

12916
08:40:20,638 --> 08:40:24,080
E o que vamos fazer é dizer fazer

12917
08:40:24,080 --> 08:40:27,360
e colocar um par de chaves encaracoladas

12918
08:40:27,360 --> 08:40:30,318
e dentro deste par de aparelhos encaracolados

12919
08:40:30,318 --> 08:40:31,840
vamos colocar o que quer que seja

12920
08:40:31,840 --> 08:40:33,120
Quero fazer

12921
08:40:33,120 --> 08:40:35,600
várias vezes, então queremos imprimir i

12922
08:40:35,600 --> 08:40:37,360
Ame c plus plus, então é isso que nós somos

12923
08:40:37,360 --> 08:40:38,958
Vou dizer que vamos

12924
08:40:38,958 --> 08:40:41,440
Colocar na iteração atual

12925
08:40:41,440 --> 08:40:43,200
e nós vamos colocar uma coluna e dizer

12926
08:40:43,200 --> 08:40:46,160
Eu amo c plus plus

12927
08:40:46,160 --> 08:40:48,240
E então nós vamos pular para o novo

12928
08:40:48,240 --> 08:40:51,200
linha com stdendl

12929
08:40:51,200 --> 08:40:53,600
E depois disso não queremos esquecer

12930
08:40:53,600 --> 08:40:55,520
nossa parte de incrementação, então estamos indo

12931
08:40:55,520 --> 08:40:57,680
para dizer mais mais mais i

12932
08:40:57,680 --> 08:40:59,680
E isso vai ser

12933
08:40:59,680 --> 08:41:02,638
A parte que move o nosso iterador para o

12934
08:41:02,638 --> 08:41:04,718
O próximo passo vai ser o

12935
08:41:04,718 --> 08:41:07,040
incrementação e isso vai ser

12936
08:41:07,040 --> 08:41:08,398
O iterador

12937
08:41:08,398 --> 08:41:11,040
Declaração de

12938
08:41:11,040 --> 08:41:14,240
e depois da cinta de fechamento precisamos

12939
08:41:14,240 --> 08:41:16,160
Diga o nosso teste

12940
08:41:16,160 --> 08:41:18,398
então nós vamos dizer enquanto e nós estamos

12941
08:41:18,398 --> 08:41:19,920
vamos colocar o nosso teste aqui e nós

12942
08:41:19,920 --> 08:41:22,718
Quero continuar fazendo isso enquanto eu estiver

12943
08:41:22,718 --> 08:41:24,958
menos do que a contagem, é claro

12944
08:41:24,958 --> 08:41:27,040
e nós vamos colocar em nosso fechamento

12945
08:41:27,040 --> 08:41:28,718
ponto e vírgula aqui

12946
08:41:28,718 --> 08:41:31,920
Agora este código vai rodar 10 vezes

12947
08:41:31,920 --> 08:41:34,318
Mas vamos passar por como ele vai fazer

12948
08:41:34,318 --> 08:41:36,318
correr para que você possa realmente ver

12949
08:41:36,318 --> 08:41:37,520
Tudo tudo

12950
08:41:37,520 --> 08:41:40,240
que está acontecendo aqui bem, então quando isso

12951
08:41:40,240 --> 08:41:42,440
O código aqui é executado, vamos acertar o

12952
08:41:42,440 --> 08:41:44,958
linha de inicialização aqui nós vamos

12953
08:41:44,958 --> 08:41:48,160
Declaro e vamos colocar um 0.

12954
08:41:48,160 --> 08:41:50,558
nós vamos dizer fazer e por dentro estamos

12955
08:41:50,558 --> 08:41:52,878
Vou imprimir o que temos em I e

12956
08:41:52,878 --> 08:41:55,520
Eu amo c plus plus, então nós vamos

12957
08:41:55,520 --> 08:41:58,558
dizer 0 porque eu é 0 neste ponto e

12958
08:41:58,558 --> 08:42:02,398
nós vamos dizer que eu amo c plus mais

12959
08:42:02,398 --> 08:42:04,478
E depois disso vamos incrementar

12960
08:42:04,478 --> 08:42:07,680
Eu vou me tornar um

12961
08:42:07,680 --> 08:42:09,680
e nós vamos fazer o teste neste

12962
08:42:09,680 --> 08:42:10,478
O tempo

12963
08:42:10,478 --> 08:42:12,878
Vamos dizer que é menos de dez

12964
08:42:12,878 --> 08:42:14,798
que vai ser bem sucedido, então nós somos

12965
08:42:14,798 --> 08:42:17,600
Vou correr o corpo novamente

12966
08:42:17,600 --> 08:42:20,318
e nós vamos dizer 1 eu amo c mais

12967
08:42:20,318 --> 08:42:22,398
vamos copiar isso e imprimir isso novamente, então

12968
08:42:22,398 --> 08:42:24,398
que não temos que digitar tudo isso

12969
08:42:24,398 --> 08:42:26,160
Tempo que vamos dizer 1

12970
08:42:26,160 --> 08:42:28,638
Eu amo c plus e depois disso estamos indo

12971
08:42:28,638 --> 08:42:31,120
para executar a parte de incrementação novamente assim

12972
08:42:31,120 --> 08:42:33,440
nós vamos ter um 2 dentro eu estamos

12973
08:42:33,440 --> 08:42:36,398
indo para testar e dizer é 2 menos de 10

12974
08:42:36,398 --> 08:42:38,160
Isso vai ser verdade, então vamos

12975
08:42:38,160 --> 08:42:41,280
para correr o corpo novamente e imprimir 2 eu amo

12976
08:42:41,280 --> 08:42:43,440
c plus plus

12977
08:42:43,440 --> 08:42:45,440
e nós vamos aumentar para obter um

12978
08:42:45,440 --> 08:42:46,958
Três lá dentro

12979
08:42:46,958 --> 08:42:49,120
nós vamos fazer o teste contra o nosso

12980
08:42:49,120 --> 08:42:51,200
Três é menos de dez, o que é

12981
08:42:51,200 --> 08:42:52,798
Vai ser verdade, então vamos cair

12982
08:42:52,798 --> 08:42:55,520
no corpo novamente e imprimir três

12983
08:42:55,520 --> 08:42:58,000
Eu amo c plus plus vamos fazer isso

12984
08:42:58,000 --> 08:42:59,680
Vou fazer o incremento que somos

12985
08:42:59,680 --> 08:43:02,240
vai ter um 4 dentro desta variável i

12986
08:43:02,240 --> 08:43:04,398
Aqui vamos fazer o teste que estamos

12987
08:43:04,398 --> 08:43:06,478
Vou dizer que é 4 menos do que 10 que é

12988
08:43:06,478 --> 08:43:08,398
Vou ser verdade, é claro que vamos

12989
08:43:08,398 --> 08:43:11,520
para dizer quatro eu amo c plus plus quando nós

12990
08:43:11,520 --> 08:43:13,120
queda no corpo novamente

12991
08:43:13,120 --> 08:43:14,718
Vamos fazer a implementação e

12992
08:43:14,718 --> 08:43:17,200
obter um cinco nós vamos fazer o teste

12993
08:43:17,200 --> 08:43:19,120
São cinco menos do que dez que vão

12994
08:43:19,120 --> 08:43:21,280
ser verdadeiro, então vamos cair no

12995
08:43:21,280 --> 08:43:24,160
corpo novamente e dizer cinco eu amo c mais

12996
08:43:24,160 --> 08:43:25,920
+ a vantagem

12997
08:43:25,920 --> 08:43:27,280
Vamos dizer que

12998
08:43:27,280 --> 08:43:30,000
nós vamos incrementar novamente

12999
08:43:30,000 --> 08:43:31,920
nós vamos conseguir um seis, o teste é

13000
08:43:31,920 --> 08:43:34,878
vamos correr e vamos dizer que é

13001
08:43:34,878 --> 08:43:36,798
Seis menos de dez

13002
08:43:36,798 --> 08:43:38,878
que vai ser verdade novamente, então

13003
08:43:38,878 --> 08:43:42,160
O corpo vai executar e dizer

13004
08:43:42,160 --> 08:43:44,478
6 Eu amo c plus plus que vamos fazer

13005
08:43:44,478 --> 08:43:47,120
O incremento e obter um 7. estamos

13006
08:43:47,120 --> 08:43:49,360
indo para executar o teste contra o nosso 7 assim

13007
08:43:49,360 --> 08:43:51,520
vamos dizer que é 7 menos de 10

13008
08:43:51,520 --> 08:43:53,040
Isso vai ser verdade

13009
08:43:53,040 --> 08:43:55,360
Vamos cair no corpo novamente

13010
08:43:55,360 --> 08:43:58,398
e dizer 7 i love c plus plus

13011
08:43:58,398 --> 08:44:00,478
Vamos fazer o incremento que nós

13012
08:44:00,478 --> 08:44:03,120
Vamos ter 8, vamos dizer que é

13013
08:44:03,120 --> 08:44:06,000
8 menos de 10 que vai ser verdade

13014
08:44:06,000 --> 08:44:08,000
Vamos cair no corpo novamente

13015
08:44:08,000 --> 08:44:10,878
e dizer 8 eu amo c plus plus estamos indo

13016
08:44:10,878 --> 08:44:12,398
para fazer o incremento que vamos

13017
08:44:12,398 --> 08:44:14,878
obter um 9 e vamos fazer o teste

13018
08:44:14,878 --> 08:44:16,958
Vamos dizer que é 9 menos de 10

13019
08:44:16,958 --> 08:44:18,478
Isso vai ser verdade, então vamos

13020
08:44:18,478 --> 08:44:21,760
para ir para dentro e dizer 9 i love c plus

13021
08:44:21,760 --> 08:44:23,360
+ a vantagem

13022
08:44:23,360 --> 08:44:25,040
e vamos fazer o incremento

13023
08:44:25,040 --> 08:44:27,680
Mais uma vez agora vamos ter um 10 e

13024
08:44:27,680 --> 08:44:30,958
O teste vai dizer que é 10 menos do que

13025
08:44:30,958 --> 08:44:31,760
10

13026
08:44:31,760 --> 08:44:33,680
e isso vai ser falso agora o

13027
08:44:33,680 --> 08:44:35,520
O teste vai falhar

13028
08:44:35,520 --> 08:44:38,398
E nós vamos cair depois do tempo

13029
08:44:38,398 --> 08:44:40,878
loop aqui, então se tivéssemos uma declaração aqui

13030
08:44:40,878 --> 08:44:44,160
que disse stdc out loop feito que faríamos

13031
08:44:44,160 --> 08:44:46,478
imprimir que nós iria para baixo aqui e dizer

13032
08:44:46,478 --> 08:44:48,798
loop feito

13033
08:44:48,798 --> 08:44:50,398
E isso é o que vamos conseguir se

13034
08:44:50,398 --> 08:44:52,398
nós executamos este programa e novamente eu

13035
08:44:52,398 --> 08:44:54,240
Incentive você a experimentar isso em seu

13036
08:44:54,240 --> 08:44:56,798
mind print isto em algum ficheiro que tem sobre

13037
08:44:56,798 --> 08:44:59,200
o seu computador ou você pode até usar um

13038
08:44:59,200 --> 08:45:01,680
pedaço de papel normal, mas certifique-se de que você

13039
08:45:01,680 --> 08:45:04,000
entender o fluxo que passamos para obter

13040
08:45:04,000 --> 08:45:06,478
este código para executar várias vezes bem agora

13041
08:45:06,478 --> 08:45:08,718
que fizemos isso, podemos trabalhar isso

13042
08:45:08,718 --> 08:45:10,478
E deixe o computador

13043
08:45:10,478 --> 08:45:12,798
fazer o trabalho pesado para nós e executar isso

13044
08:45:12,798 --> 08:45:14,958
Cerca várias vezes o mundo está indo

13045
08:45:14,958 --> 08:45:16,958
para ser bom, então o que vamos fazer

13046
08:45:16,958 --> 08:45:18,798
nós vamos dizer claro

13047
08:45:18,798 --> 08:45:21,040
e correr galo e vai dizer

13048
08:45:21,040 --> 08:45:23,360
exatamente o que esperamos eu vou ter c plus

13049
08:45:23,360 --> 08:45:25,760
10 vezes e então vai dizer

13050
08:45:25,760 --> 08:45:28,080
loop feito bem uma coisa que eu quero que você

13051
08:45:28,080 --> 08:45:29,040
Veja

13052
08:45:29,040 --> 08:45:32,958
é que o fazer enquanto o loop é executado antes dele

13053
08:45:32,958 --> 08:45:35,920
faz o teste e isso pode causar loucura

13054
08:45:35,920 --> 08:45:38,398
Coisas acontecendo em seu programa se

13055
08:45:38,398 --> 08:45:40,080
Você realmente não tem cuidado

13056
08:45:40,080 --> 08:45:42,478
Vamos dizer que você queria este programa

13057
08:45:42,478 --> 08:45:44,958
Não correr e inicializar essa coisa

13058
08:45:44,958 --> 08:45:47,200
com um zero para a contagem, então está indo

13059
08:45:47,200 --> 08:45:49,760
para correr zero vezes, mas isso não está indo

13060
08:45:49,760 --> 08:45:51,840
para fazer o que você espera com fazer enquanto

13061
08:45:51,840 --> 08:45:53,360
O loop porque

13062
08:45:53,360 --> 08:45:57,280
ele executa as coisas antes de fazer o teste

13063
08:45:57,280 --> 08:45:59,200
Então, se você executar este programa, não é

13064
08:45:59,200 --> 08:46:01,440
indo apenas dizer loop feito isso está indo

13065
08:46:01,440 --> 08:46:03,760
para dizer eu amo c plus plus e ter zero

13066
08:46:03,760 --> 08:46:06,080
valor aqui e vai dizer loop

13067
08:46:06,080 --> 08:46:07,600
feito apenas

13068
08:46:07,600 --> 08:46:10,000
que não vai ser provavelmente o que você

13069
08:46:10,000 --> 08:46:12,558
pretendido por colocar um zero aqui você

13070
08:46:12,558 --> 08:46:15,280
Coloque um zero aqui se você quiser este código

13071
08:46:15,280 --> 08:46:17,840
para executar zero vezes ou o código no

13072
08:46:17,840 --> 08:46:20,318
corpo para não correr que é outro caminho para

13073
08:46:20,318 --> 08:46:22,878
Diga isso, mas neste caso um tempo

13074
08:46:22,878 --> 08:46:25,120
O loop não vai fazer o que você espera

13075
08:46:25,120 --> 08:46:28,878
porque ele funciona antes de fazer o teste

13076
08:46:28,878 --> 08:46:29,840
aqui

13077
08:46:29,840 --> 08:46:33,360
Vamos construir isso e mostrar isso

13078
08:46:33,360 --> 08:46:35,520
Então nós vamos passar pelo mundo

13079
08:46:35,520 --> 08:46:38,240
é bem sucedido

13080
08:46:38,398 --> 08:46:40,798
E nós vamos limpar

13081
08:46:40,798 --> 08:46:42,558
e correr galo você vai ver que

13082
08:46:42,558 --> 08:46:44,718
está dizendo zero i love c plus plus loop

13083
08:46:44,718 --> 08:46:47,920
fazer isso é correr mesmo se definirmos o nosso

13084
08:46:47,920 --> 08:46:51,040
conte a zero aqui, por isso certifique-se de fazer

13085
08:46:51,040 --> 08:46:53,520
enquanto loop está fazendo o que você quer, mas se

13086
08:46:53,520 --> 08:46:55,360
Você é cuidadoso com isso

13087
08:46:55,360 --> 08:46:57,840
Você não vai ter problemas e se

13088
08:46:57,840 --> 08:47:00,240
Você quer que a corda não faça

13089
08:47:00,240 --> 08:47:01,360
Qualquer coisa

13090
08:47:01,360 --> 08:47:03,840
Quando você tem zero contando aqui você pode

13091
08:47:03,840 --> 08:47:06,798
use o loop do tempo ou a aparência completa como

13092
08:47:06,798 --> 08:47:08,398
Temos visto antes

13093
08:47:08,398 --> 08:47:10,638
Eu gostaria de recebê-lo neste novo

13094
08:47:10,638 --> 08:47:11,600
O capítulo

13095
08:47:11,600 --> 08:47:13,680
Onde vamos aprender sobre

13096
08:47:13,680 --> 08:47:17,520
arrays e arrays são uma maneira de

13097
08:47:17,520 --> 08:47:19,840
configurar coleções em nosso c plus plus

13098
08:47:19,840 --> 08:47:22,318
programa até agora temos trabalhado com

13099
08:47:22,318 --> 08:47:24,318
variáveis individuais, por exemplo, você tem a

13100
08:47:24,318 --> 08:47:26,878
Um monte de variáveis de inteiros você pode até mesmo

13101
08:47:26,878 --> 08:47:30,478
tem 10 ou 20 variáveis de tipo inteiro

13102
08:47:30,478 --> 08:47:32,080
E isso vai ficar bem, mas

13103
08:47:32,080 --> 08:47:34,240
às vezes você não quer gerenciar tudo

13104
08:47:34,240 --> 08:47:37,680
Essas variáveis é realmente desejável

13105
08:47:37,680 --> 08:47:40,718
agrupar todas essas variáveis em uma

13106
08:47:40,718 --> 08:47:43,520
unidade única e gerenciá-los como um

13107
08:47:43,520 --> 08:47:45,920
Uma entidade e nós podemos fazer algo

13108
08:47:45,920 --> 08:47:48,478
como este grupo juntos e dar

13109
08:47:48,478 --> 08:47:50,958
um nome para que possamos nos referir a eles

13110
08:47:50,958 --> 08:47:52,798
ou manipule os

13111
08:47:52,798 --> 08:47:55,840
sob este nome aqui e c plus plus tem

13112
08:47:55,840 --> 08:47:59,680
a construção do array para nos ajudar a fazer isso

13113
08:47:59,680 --> 08:48:02,558
Tudo bem, então novamente se você olhar na memória como

13114
08:48:02,558 --> 08:48:04,160
As coisas estão dispostas para fora que você vai ter

13115
08:48:04,160 --> 08:48:06,318
um monte de zeros e outros, por exemplo

13116
08:48:06,318 --> 08:48:09,840
Aqui cada defesa vermelha é uma rede que é quatro

13117
08:48:09,840 --> 08:48:12,398
bytes em tamanho e pode ser usado para

13118
08:48:12,398 --> 08:48:15,120
representar uma rede, então se tivermos um monte de

13119
08:48:15,120 --> 08:48:17,280
eventos como este, podemos querer agrupar

13120
08:48:17,280 --> 08:48:19,680
juntos e dar-lhes um nome e

13121
08:48:19,680 --> 08:48:22,478
manipulá-los sob este nome este é

13122
08:48:22,478 --> 08:48:24,160
Outra maneira de olhar para o que nós apenas

13123
08:48:24,160 --> 08:48:27,200
Falamos aqui e de novo arrays são um

13124
08:48:27,200 --> 08:48:29,520
maneira de fazer esses tipos de coisas em c

13125
08:48:29,520 --> 08:48:31,920
mais e mais e vamos aprender

13126
08:48:31,920 --> 08:48:34,398
tudo sobre isso neste capítulo, nós somos

13127
08:48:34,398 --> 08:48:36,478
Vou parar aqui nesta palestra e

13128
08:48:36,478 --> 08:48:38,240
Vamos começar e ver como

13129
08:48:38,240 --> 08:48:40,878
você pode declarar e inicializar um array

13130
08:48:40,878 --> 08:48:42,318
Na próxima palestra

13131
08:48:42,318 --> 08:48:44,240
Vá em frente e termine aqui

13132
08:48:44,240 --> 08:48:46,318
e encontrar-me lá nesta palestra nós somos

13133
08:48:46,318 --> 08:48:48,718
Vamos ver como podemos declarar e usar

13134
08:48:48,718 --> 08:48:52,160
arrays em nosso programa c plus plus e

13135
08:48:52,160 --> 08:48:55,120
matrizes novamente são uma facilidade que temos em

13136
08:48:55,120 --> 08:48:57,680
a c plus linguagem de programação para

13137
08:48:57,680 --> 08:49:00,558
agrupar muitas variáveis em conjunto e

13138
08:49:00,558 --> 08:49:03,840
manipulá-los como uma única unidade para

13139
08:49:03,840 --> 08:49:06,318
O exemplo aqui temos um monte de inteiros

13140
08:49:06,318 --> 08:49:08,638
em memória cada uma dessas coisas vermelhas é

13141
08:49:08,638 --> 08:49:11,120
Vou ser quatro bytes em tamanho para que possamos

13142
08:49:11,120 --> 08:49:13,360
Pense nisso como um inteiro e nós podemos

13143
08:49:13,360 --> 08:49:16,000
agrupá-los e dar-lhes uma

13144
08:49:16,000 --> 08:49:18,398
nós os chamamos de pontuações aqui e eles são

13145
08:49:18,398 --> 08:49:21,440
Vai viver sob essas pontuações

13146
08:49:21,440 --> 08:49:24,000
entidade assim se quisermos

13147
08:49:24,000 --> 08:49:26,558
Refere-se a cada uma dessas coisas z mais

13148
08:49:26,558 --> 08:49:29,440
Plus fornece um sistema de indexação para que possamos

13149
08:49:29,440 --> 08:49:32,558
não pode usar suportes de ângulo como este e

13150
08:49:32,558 --> 08:49:36,318
referem-se ao primeiro desses inteiros como

13151
08:49:36,318 --> 08:49:39,040
zero para que possamos ir de zero todo o caminho

13152
08:49:39,040 --> 08:49:42,318
para nove aqui, mas sua matriz pode até ser

13153
08:49:42,318 --> 08:49:44,558
maior do que isso muitas vezes maior do que

13154
08:49:44,558 --> 08:49:46,478
Isso e vamos ver exemplos de

13155
08:49:46,478 --> 08:49:48,318
Como podemos fazer isso, mas isto é um

13156
08:49:48,318 --> 08:49:51,040
Exemplo de como você pode levar muitos

13157
08:49:51,040 --> 08:49:54,638
variáveis agrupando-as sob uma entidade

13158
08:49:54,638 --> 08:49:56,718
dar-lhes um nome e ser capaz de

13159
08:49:56,718 --> 08:49:59,120
Cada um desses eventos

13160
08:49:59,120 --> 08:50:01,760
sob essa entidade e agora que a ideia

13161
08:50:01,760 --> 08:50:04,318
É bastante claro, vamos ver como podemos fazer

13162
08:50:04,318 --> 08:50:06,718
isso em c plus mais a maneira de fazer isso

13163
08:50:06,718 --> 08:50:09,200
é dizer e você tem que especificar o

13164
08:50:09,200 --> 08:50:11,600
Tipo de sua coleção que você tem que

13165
08:50:11,600 --> 08:50:13,520
especificar o nome depois disso e, em seguida,

13166
08:50:13,520 --> 08:50:16,000
Você vai colocar um par de ângulo

13167
08:50:16,000 --> 08:50:18,240
colchetes como este e dentro desses

13168
08:50:18,240 --> 08:50:21,120
Suportes de ângulo você pode especificar o tamanho

13169
08:50:21,120 --> 08:50:23,520
Você quer que essa coleção tenha ou que

13170
08:50:23,520 --> 08:50:26,718
array para ter e após esta declaração

13171
08:50:26,718 --> 08:50:29,120
é executado que nós vamos basicamente ter

13172
08:50:29,120 --> 08:50:30,558
Algo assim na memória nós somos

13173
08:50:30,558 --> 08:50:32,558
vai ter 10 inteiros, então se você

13174
08:50:32,558 --> 08:50:35,280
conte aqui 0 todo o caminho através de 9

13175
08:50:35,280 --> 08:50:37,360
que são 10 inteiros que eles vão ser

13176
08:50:37,360 --> 08:50:39,840
agrupados sob uma entidade lógica

13177
08:50:39,840 --> 08:50:41,760
essa entidade lógica será chamada

13178
08:50:41,760 --> 08:50:44,638
pontuações e podemos passar por esse nome

13179
08:50:44,638 --> 08:50:47,440
para manipular todas essas coisas que são

13180
08:50:47,440 --> 08:50:50,160
nesta entidade ok depois que sua matriz é

13181
08:50:50,160 --> 08:50:52,398
declarado e você tem espaço para isso em

13182
08:50:52,398 --> 08:50:54,638
Memória basicamente algo assim nós

13183
08:50:54,638 --> 08:50:57,120
Precisa de uma maneira de ler os dados de e

13184
08:50:57,120 --> 08:50:59,120
Vamos ver como podemos fazer isso

13185
08:50:59,120 --> 08:51:01,360
É o que temos aqui, por exemplo

13186
08:51:01,360 --> 08:51:03,360
Se quisermos imprimir o primeiro destes

13187
08:51:03,360 --> 08:51:05,600
Elementos que vamos dizer pontuações

13188
08:51:05,600 --> 08:51:08,080
suportes de ângulo e especificar o índice de

13189
08:51:08,080 --> 08:51:11,280
O primeiro elemento nesse array ou aquilo

13190
08:51:11,280 --> 08:51:13,840
coleção de inteiros que se chama

13191
08:51:13,840 --> 08:51:16,160
Pontuação OK uma coisa que você realmente deveria

13192
08:51:16,160 --> 08:51:19,440
Lembre-se que os arrays são indexados

13193
08:51:19,440 --> 08:51:21,840
de zero eles não começam a partir de um, então

13194
08:51:21,840 --> 08:51:23,920
O primeiro elemento vai viver em

13195
08:51:23,920 --> 08:51:26,080
índice zero não vai viver em

13196
08:51:26,080 --> 08:51:28,638
índice um, então aqui marca zero está indo

13197
08:51:28,638 --> 08:51:30,958
para imprimir o primeiro elemento e pontuações

13198
08:51:30,958 --> 08:51:32,878
Nove vai imprimir o último elemento

13199
08:51:32,878 --> 08:51:35,120
que passa a ser o último em nosso

13200
08:51:35,120 --> 08:51:38,000
Coleção aqui de inteiros ok uma vez

13201
08:51:38,000 --> 08:51:40,798
nossa matriz é declarada que não vai

13202
08:51:40,798 --> 08:51:42,958
ter dados nele, haverá

13203
08:51:42,958 --> 08:51:45,440
Dados, mas não serão dados

13204
08:51:45,440 --> 08:51:48,160
que colocamos para que possamos pensar nisso

13205
08:51:48,160 --> 08:51:51,120
Dados basicamente como lixo outra coisa

13206
08:51:51,120 --> 08:51:53,600
Eu queria chamar a sua atenção é

13207
08:51:53,600 --> 08:51:54,478
que

13208
08:51:54,478 --> 08:51:58,398
Sua matriz tem limites claros quando nós

13209
08:51:58,398 --> 08:52:00,558
declarar um array como este aviso que

13210
08:52:00,558 --> 08:52:04,558
nós especificamos 10 como o tamanho da nossa matriz

13211
08:52:04,558 --> 08:52:06,638
Só vai ter 10 elementos

13212
08:52:06,638 --> 08:52:08,798
Dentro e você pode ver que temos de

13213
08:52:08,798 --> 08:52:11,520
index 0 todo o caminho para 9 e dentro nós

13214
08:52:11,520 --> 08:52:13,760
ter dados de lixo, mas vamos consertar

13215
08:52:13,760 --> 08:52:15,920
que em um minuto o que eu quero que você veja

13216
08:52:15,920 --> 08:52:18,318
Aqui é que você pode tentar ler

13217
08:52:18,318 --> 08:52:20,958
Fora dos limites da sua matriz

13218
08:52:20,958 --> 08:52:23,280
c plus é engraçado em que permite

13219
08:52:23,280 --> 08:52:25,360
Você faz isso, mas se você fizer isso você é

13220
08:52:25,360 --> 08:52:27,280
Vou ter problemas estranhos, por exemplo

13221
08:52:27,280 --> 08:52:29,760
Seu programa iria falhar ou fazer algo

13222
08:52:29,760 --> 08:52:31,680
muito ruim, então você não deveria realmente fazer

13223
08:52:31,680 --> 08:52:35,200
Este esteja ciente dos limites de sua

13224
08:52:35,200 --> 08:52:37,760
array se você tentar ler os dados de

13225
08:52:37,760 --> 08:52:40,080
O exterior do seu saldo você pode ler

13226
08:52:40,080 --> 08:52:42,798
dados de lixo que você pode até causar falhas

13227
08:52:42,798 --> 08:52:44,718
do sistema operacional porque você

13228
08:52:44,718 --> 08:52:46,958
Não sei realmente de quem você é a memória

13229
08:52:46,958 --> 08:52:49,200
Ler não vai ser memória que

13230
08:52:49,200 --> 08:52:51,840
é alocado para o seu programa, então array

13231
08:52:51,840 --> 08:52:53,360
limites são algo que você precisa

13232
08:52:53,360 --> 08:52:56,160
Lembre-se ao trabalhar com arrays

13233
08:52:56,160 --> 08:52:58,638
Ok, acabamos de ver que poderíamos ler dados

13234
08:52:58,638 --> 08:53:00,958
do array usando este suporte de ângulo

13235
08:53:00,958 --> 08:53:03,920
sintaxe, podemos até fazer isso através do

13236
08:53:03,920 --> 08:53:05,360
loops e

13237
08:53:05,360 --> 08:53:07,200
ler todos os elementos na matriz e

13238
08:53:07,200 --> 08:53:09,200
É assim que podemos fazer isso e você pode

13239
08:53:09,200 --> 08:53:11,040
Veja os loops que aprendemos em

13240
08:53:11,040 --> 08:53:12,398
O último capítulo

13241
08:53:12,398 --> 08:53:14,318
Estamos começando a vir a dissim, tudo bem

13242
08:53:14,318 --> 08:53:16,878
Vimos como podemos ler os dados do

13243
08:53:16,878 --> 08:53:17,920
Array

13244
08:53:17,920 --> 08:53:20,160
Mas e se quisermos colocar alguma coisa

13245
08:53:20,160 --> 08:53:22,558
E se quisermos escrever o nosso próprio

13246
08:53:22,558 --> 08:53:25,840
dados em um array bem a sintaxe é

13247
08:53:25,840 --> 08:53:28,000
praticamente o que você esperaria

13248
08:53:28,000 --> 08:53:30,558
também usar esta sintaxe do bracket do ângulo, mas

13249
08:53:30,558 --> 08:53:33,680
Vamos atribuir dados a isso

13250
08:53:33,680 --> 08:53:35,680
elemento no array, por exemplo, se nós

13251
08:53:35,680 --> 08:53:38,558
Queria atribuir dados ao primeiro

13252
08:53:38,558 --> 08:53:41,280
elemento em nossa matriz, vamos dizer

13253
08:53:41,280 --> 08:53:42,318
Pontuações

13254
08:53:42,318 --> 08:53:44,398
ângulo brackets 0 e nós vamos

13255
08:53:44,398 --> 08:53:47,360
atribuir um 20 nele e podemos atribuir um 21

13256
08:53:47,360 --> 08:53:51,520
no elemento no índice 1 e no 22

13257
08:53:51,520 --> 08:53:54,798
no elemento no índice 2 e se o fizermos

13258
08:53:54,798 --> 08:53:56,240
que nós vamos ter algo como

13259
08:53:56,240 --> 08:53:59,040
Isso em nossa matriz para o índice 0, temos um

13260
08:53:59,040 --> 08:54:02,160
20 índice 1 temos um índice 21 2 que temos

13261
08:54:02,160 --> 08:54:05,520
a 22 e o resto ainda é lixo

13262
08:54:05,520 --> 08:54:08,000
porque não colocamos nossos dados que podemos

13263
08:54:08,000 --> 08:54:10,318
também escrever dados em um loop por exemplo

13264
08:54:10,318 --> 08:54:13,440
Aqui temos nosso array declarado

13265
08:54:13,440 --> 08:54:15,520
e nós vamos fazer loop em torno de colocar

13266
08:54:15,520 --> 08:54:18,398
dados em diferentes índices notam que

13267
08:54:18,398 --> 08:54:20,478
O índice será o atual

13268
08:54:20,478 --> 08:54:23,280
iteração em que estamos, então isso é comum

13269
08:54:23,280 --> 08:54:25,680
maneira de fazer as coisas em c plus plus e você

13270
08:54:25,680 --> 08:54:27,840
precisa estar familiarizado com isso e depois

13271
08:54:27,840 --> 08:54:30,398
Colocamos os dados que podemos ler isso de volta

13272
08:54:30,398 --> 08:54:32,798
e certifique-se de que são os dados reais

13273
08:54:32,798 --> 08:54:34,718
que nós colocamos e nós vamos ter um

13274
08:54:34,718 --> 08:54:36,240
chance de jogar com isso em visual

13275
08:54:36,240 --> 08:54:38,638
Código de estúdio em um minuto, então não se preocupe

13276
08:54:38,638 --> 08:54:40,798
Se algumas dessas coisas não fazem sentido

13277
08:54:40,798 --> 08:54:43,280
Mas novamente a coisa principal aqui é

13278
08:54:43,280 --> 08:54:45,680
este ângulo bracket sintaxe que podemos usar

13279
08:54:45,680 --> 08:54:49,040
que para escrever dados no elemento

13280
08:54:49,040 --> 08:54:51,600
da matriz ou dados de leitura do

13281
08:54:51,600 --> 08:54:53,280
elemento do array e este é o

13282
08:54:53,280 --> 08:54:56,558
sintaxe aqui pontua suportes angulares i OK

13283
08:54:56,558 --> 08:54:59,840
até agora nossa matriz foi declarada e

13284
08:54:59,840 --> 08:55:01,920
nós realmente não colocamos dados e lá

13285
08:55:01,920 --> 08:55:04,398
Era lixo dentro, mas há um caminho

13286
08:55:04,398 --> 08:55:07,520
você pode declarar uma matriz e colocar dados em

13287
08:55:07,520 --> 08:55:10,240
em uma única declaração e é assim que

13288
08:55:10,240 --> 08:55:12,160
Você faria isso aqui temos outro

13289
08:55:12,160 --> 08:55:14,240
array que vai estar agrupando o dobro

13290
08:55:14,240 --> 08:55:15,440
As variáveis

13291
08:55:15,440 --> 08:55:17,440
nós chamamos os salários da matriz e nós

13292
08:55:17,440 --> 08:55:19,840
Especifique que vai ser

13293
08:55:19,840 --> 08:55:23,280
do tamanho cinco e podemos colocar estes

13294
08:55:23,280 --> 08:55:27,360
elementos em uma lista separada de vírgula usando

13295
08:55:27,360 --> 08:55:29,520
Tomou a inicialização como esta e

13296
08:55:29,520 --> 08:55:31,440
vai funcionar se tentarmos imprimi-lo

13297
08:55:31,440 --> 08:55:32,958
Vamos ver esses elementos

13298
08:55:32,958 --> 08:55:35,120
Aqui e você vê que podemos ler isso

13299
08:55:35,120 --> 08:55:36,798
usando a mesma sintaxe que aprendemos

13300
08:55:36,798 --> 08:55:40,240
sobre os salários que dizemos o nome do array

13301
08:55:40,240 --> 08:55:42,318
do ângulo brackets e dentro colocamos o

13302
08:55:42,318 --> 08:55:44,878
índice do elemento que estamos lendo a partir de

13303
08:55:44,878 --> 08:55:47,680
e este índice vem do nosso loop

13304
08:55:47,680 --> 08:55:49,840
Aqui e vai trabalhar você está

13305
08:55:49,840 --> 08:55:51,840
Vou imprimir este elemento

13306
08:55:51,840 --> 08:55:54,080
Isso é muito legal ao inicializar

13307
08:55:54,080 --> 08:55:55,600
a sua matriz

13308
08:55:55,600 --> 08:55:57,360
Você pode deixar de fora elementos, por exemplo

13309
08:55:57,360 --> 08:56:00,080
Aqui temos uma matriz limpa que é chamada

13310
08:56:00,080 --> 08:56:03,040
Famílias vai ser do tamanho 5, mas

13311
08:56:03,040 --> 08:56:05,440
Estamos apenas colocando em três elementos

13312
08:56:05,440 --> 08:56:08,080
O resto será inicializado para

13313
08:56:08,080 --> 08:56:10,558
zero quando fazemos coisas assim e

13314
08:56:10,558 --> 08:56:12,398
Isso é algo que você precisa estar ciente

13315
08:56:12,398 --> 08:56:14,478
e nós vamos experimentar isso em

13316
08:56:14,478 --> 08:56:16,080
código de estúdio visual e você vai

13317
08:56:16,080 --> 08:56:18,240
Veja que isso é realmente verdade

13318
08:56:18,240 --> 08:56:21,280
Possível também omitir o tamanho quando você

13319
08:56:21,280 --> 08:56:23,360
estão declarando sua matriz e a

13320
08:56:23,360 --> 08:56:25,600
O compilador vai deduzir o tamanho

13321
08:56:25,600 --> 08:56:28,000
dos elementos que você inicializa

13322
08:56:28,000 --> 08:56:30,638
sua matriz com, por exemplo, aqui temos

13323
08:56:30,638 --> 08:56:33,360
em um dois três, quatro cinco seis elementos

13324
08:56:33,360 --> 08:56:35,920
Este array terá um tamanho de

13325
08:56:35,920 --> 08:56:38,000
Seis e se imprimirmos elementos, vamos

13326
08:56:38,000 --> 08:56:40,080
para obter esses avisos impressos aqui

13327
08:56:40,080 --> 08:56:43,520
que estamos usando uma base variada para loop

13328
08:56:43,520 --> 08:56:44,958
E a

13329
08:56:44,958 --> 08:56:46,798
Espero que você possa ver que é mais fácil

13330
08:56:46,798 --> 08:56:49,280
ler dados de uma coleção como esta

13331
08:56:49,280 --> 08:56:51,440
usando uma base de gama para loop porque nós

13332
08:56:51,440 --> 08:56:53,840
Não precisa criar um iterador

13333
08:56:53,840 --> 08:56:55,920
inicializá-lo para fazer o teste fazer o

13334
08:56:55,920 --> 08:56:58,000
incrementação podemos apenas ler o

13335
08:56:58,000 --> 08:57:01,280
valor e use-o e esteja no nosso caminho alegre

13336
08:57:01,280 --> 08:57:03,360
Isso é muito legal é possível

13337
08:57:03,360 --> 08:57:06,318
também declarar sua matriz constante e

13338
08:57:06,318 --> 08:57:08,080
Quando você fizer isso, você não será capaz de

13339
08:57:08,080 --> 08:57:10,478
modificar elementos dessa matriz

13340
08:57:10,478 --> 08:57:12,478
Isso é o que significa se você fizer isso

13341
08:57:12,478 --> 08:57:14,878
constante você basicamente quer que ele fique

13342
08:57:14,878 --> 08:57:17,280
constante e você não quer permitir

13343
08:57:17,280 --> 08:57:19,760
modificações do seu array e nós somos

13344
08:57:19,760 --> 08:57:21,440
Vou ver isso em um minuto quando nós

13345
08:57:21,440 --> 08:57:23,760
obter em código de estúdio visual a última coisa

13346
08:57:23,760 --> 08:57:25,280
Eu quero que você veja é que você pode

13347
08:57:25,280 --> 08:57:27,760
realmente fazer operações nos dados que

13348
08:57:27,760 --> 08:57:30,398
você tem armazenado em um array, por exemplo

13349
08:57:30,398 --> 08:57:32,240
Aqui podemos resumir os elementos e

13350
08:57:32,240 --> 08:57:34,798
armazenar o resultado de volta em nossa variável

13351
08:57:34,798 --> 08:57:36,798
soma e isso é algo que você faria

13352
08:57:36,798 --> 08:57:39,920
e pode ser útil em muitas vezes

13353
08:57:39,920 --> 08:57:42,318
Ok uma coisa que eu quero que você veja antes

13354
08:57:42,318 --> 08:57:44,398
vamos ao código do estúdio visual e

13355
08:57:44,398 --> 08:57:47,600
brincar com a gente é que os arrays store

13356
08:57:47,600 --> 08:57:49,920
Elementos do mesmo tipo

13357
08:57:49,920 --> 08:57:53,600
repetir depois de me arrays armazenar elementos de

13358
08:57:53,600 --> 08:57:56,160
o mesmo tipo que você não pode tentar e armazenar

13359
08:57:56,160 --> 08:57:58,478
variáveis de diferentes tipos em um array

13360
08:57:58,478 --> 08:58:00,080
Eu nem sei como você realmente faria

13361
08:58:00,080 --> 08:58:02,878
Declara isso e se você tentar armazenar um

13362
08:58:02,878 --> 08:58:04,318
Tipo diferente

13363
08:58:04,318 --> 08:58:06,798
do tipo que foi declarado para

13364
08:58:06,798 --> 08:58:08,878
array você vai ter um compilador

13365
08:58:08,878 --> 08:58:10,318
Erro, então isso é algo que você deveria

13366
08:58:10,318 --> 08:58:13,680
Lembre-se, mas faz sentido porque

13367
08:58:13,680 --> 08:58:15,440
quando você declara uma matriz que você está indo

13368
08:58:15,440 --> 08:58:18,958
para ser dado um monte de bytes na memória

13369
08:58:18,958 --> 08:58:20,478
E esses bytes vão ser

13370
08:58:20,478 --> 08:58:23,840
coleções de dados que são da mesma

13371
08:58:23,840 --> 08:58:26,160
Digite, por exemplo, aqui temos um monte de

13372
08:58:26,160 --> 08:58:28,638
inteiros novamente cada um desses eventos vermelhos

13373
08:58:28,638 --> 08:58:31,360
é um inteiro e se você tentar colocar

13374
08:58:31,360 --> 08:58:34,240
Algo que é menor ou maior do que

13375
08:58:34,240 --> 08:58:36,558
uma vantagem, então o compilador vai ser

13376
08:58:36,558 --> 08:58:38,958
confuso sobre como ler estes

13377
08:58:38,958 --> 08:58:42,240
texto para arrays para trabalhar os tipos

13378
08:58:42,240 --> 08:58:44,798
que você armazene na matriz tem que ser

13379
08:58:44,798 --> 08:58:47,600
O mesmo e eles precisam ser consistentes

13380
08:58:47,600 --> 08:58:49,360
Isso é algo que você deve saber e se

13381
08:58:49,360 --> 08:58:51,600
Você tenta quebrar essa regra que você está indo

13382
08:58:51,600 --> 08:58:53,440
para obter um erro do compilador

13383
08:58:53,440 --> 08:58:55,600
Agora que você sabe sobre arrays, nós somos

13384
08:58:55,600 --> 08:58:57,840
indo para a cabeça para o código de estúdio visual

13385
08:58:57,840 --> 08:58:59,680
e brincar com eles um pouco bem

13386
08:58:59,680 --> 08:59:02,718
Aqui estamos em nossa pasta de trabalho o

13387
08:59:02,718 --> 08:59:04,958
O capítulo atual é levantado o atual

13388
08:59:04,958 --> 08:59:07,840
O projeto está declarando e usando arrays

13389
08:59:07,840 --> 08:59:10,798
Vamos pegar nosso código de modelo

13390
08:59:10,798 --> 08:59:12,958
e nós vamos copiar e mover o

13391
08:59:12,958 --> 08:59:14,478
Arquivos sobre

13392
08:59:14,478 --> 08:59:16,558
E nós vamos abrir essa coisa

13393
08:59:16,558 --> 08:59:18,318
Código de estúdio visual muito rápido

13394
08:59:18,318 --> 08:59:20,958
abrir o arquivo principal cpp e

13395
08:59:20,958 --> 08:59:23,520
Remova as coisas que não precisamos

13396
08:59:23,520 --> 08:59:24,718
E nós vamos ver como podemos

13397
08:59:24,718 --> 08:59:28,398
Declarar uma matriz de formigas

13398
08:59:28,398 --> 08:59:30,478
Ok do jeito que você faz que você diz

13399
08:59:30,478 --> 08:59:33,520
nome dos arrays e você coloca estes

13400
08:59:33,520 --> 08:59:36,160
suportes de ângulo e especificar o tamanho de

13401
08:59:36,160 --> 08:59:38,638
sua matriz, se você quiser, você pode colocar um

13402
08:59:38,638 --> 08:59:40,240
espaço aqui não vai

13403
08:59:40,240 --> 08:59:42,000
fazer a diferença e você vai

13404
08:59:42,000 --> 08:59:44,878
Coloque um ponto e-vírgula no final do momento

13405
08:59:44,878 --> 08:59:47,600
Esta linha executa que vamos ter

13406
08:59:47,600 --> 08:59:50,398
o espaço para 10 inteiros destinados a

13407
08:59:50,398 --> 08:59:52,798
Nós na memória e esse espaço vai

13408
08:59:52,798 --> 08:59:54,638
sermos chamados de partituras e nós vamos ser

13409
08:59:54,638 --> 08:59:57,040
capaz de ler os dados ou até mesmo escrever

13410
08:59:57,040 --> 08:59:59,840
dados de volta para ele por agora, vamos ver como

13411
08:59:59,840 --> 09:00:01,920
podemos ler os dados e é realmente

13412
09:00:01,920 --> 09:00:03,920
Simples vamos usar esse ângulo

13413
09:00:03,920 --> 09:00:05,920
Sintaxe de suporte que acabamos de ver no

13414
09:00:05,920 --> 09:00:08,318
slides assim, se quisermos ler o primeiro

13415
09:00:08,318 --> 09:00:10,080
Elemento que podemos dizer

13416
09:00:10,080 --> 09:00:12,798
para fora, queremos imprimi-lo e

13417
09:00:12,798 --> 09:00:14,878
nós vamos dizer pontuações

13418
09:00:14,878 --> 09:00:17,200
especificar o índice que queremos ler a partir de

13419
09:00:17,200 --> 09:00:19,040
E assim dizemos zero

13420
09:00:19,040 --> 09:00:22,080
e nós vamos dizer std endl para se mover

13421
09:00:22,080 --> 09:00:24,240
para a próxima linha se você tiver este digitado

13422
09:00:24,240 --> 09:00:25,680
Você vai ver que isso é

13423
09:00:25,680 --> 09:00:27,920
indo para o trabalho e vai imprimir

13424
09:00:27,920 --> 09:00:31,120
O que é armazenado no primeiro elemento

13425
09:00:31,120 --> 09:00:33,680
Neste array aqui e novamente eu quero você

13426
09:00:33,680 --> 09:00:36,878
para ter em mente a estrutura da memória de

13427
09:00:36,878 --> 09:00:38,718
seus dados quando você está trabalhando

13428
09:00:38,718 --> 09:00:40,718
arrays para o que vamos imprimir

13429
09:00:40,718 --> 09:00:44,558
Agora é tudo o que os dados lixo estão em

13430
09:00:44,558 --> 09:00:47,120
Este primeiro elemento aqui está bem aqui

13431
09:00:47,120 --> 09:00:48,558
nós vamos dizer que nós não temos

13432
09:00:48,558 --> 09:00:50,798
Saltou ainda

13433
09:00:50,798 --> 09:00:53,520
e vamos trazer um terminal

13434
09:00:53,520 --> 09:00:55,520
para que possamos brincar conosco e

13435
09:00:55,520 --> 09:00:58,160
vou construir isso com gcc como nós

13436
09:00:58,160 --> 09:00:59,520
Sempre faça

13437
09:00:59,520 --> 09:01:01,520
A construção vai ser boa

13438
09:01:01,520 --> 09:01:03,680
E nós vamos limpar

13439
09:01:03,680 --> 09:01:06,478
e correr galo você vê que este é o

13440
09:01:06,478 --> 09:01:08,718
valor de lixo que temos aqui não temos

13441
09:01:08,718 --> 09:01:09,600
Qualquer um

13442
09:01:09,600 --> 09:01:12,638
dados úteis aqui são apenas dados inúteis

13443
09:01:12,638 --> 09:01:15,040
porque nós não inicializamos esse array

13444
09:01:15,040 --> 09:01:17,600
Também podemos ler o elemento no local

13445
09:01:17,600 --> 09:01:19,520
dois e ver o que temos lá quando

13446
09:01:19,520 --> 09:01:22,318
você executa o programa eu nem tenho certeza se

13447
09:01:22,318 --> 09:01:23,840
É garantido que você vai

13448
09:01:23,840 --> 09:01:26,240
obter os mesmos dados se você executar o programa

13449
09:01:26,240 --> 09:01:28,558
Várias vezes, mas nós realmente não nos importamos

13450
09:01:28,558 --> 09:01:31,360
nós sabemos que são dados inúteis para que não possamos

13451
09:01:31,360 --> 09:01:33,360
Use isso em nosso programa

13452
09:01:33,360 --> 09:01:35,520
O que vamos fazer é correr isto

13453
09:01:35,520 --> 09:01:38,318
e ver o valor para o elemento em

13454
09:01:38,318 --> 09:01:39,840
índice um

13455
09:01:39,840 --> 09:01:42,958
Vamos construir com gcc

13456
09:01:42,958 --> 09:01:44,798
O mundo vai ser bom nós somos

13457
09:01:44,798 --> 09:01:46,718
indo para limpar

13458
09:01:46,718 --> 09:01:48,638
e nós vamos correr o galo e

13459
09:01:48,638 --> 09:01:50,398
você vai ver isso no índice 1 nós

13460
09:01:50,398 --> 09:01:51,840
ter um zero fim

13461
09:01:51,840 --> 09:01:52,878


13462
09:01:52,878 --> 09:01:55,120
Fazer isso manualmente como se fosse realmente

13463
09:01:55,120 --> 09:01:58,080
demorado e é possível

13464
09:01:58,080 --> 09:02:00,398
realmente fazer isso em um loop

13465
09:02:00,398 --> 09:02:02,878
nós sabemos o tamanho deste array, então é um

13466
09:02:02,878 --> 09:02:06,478
10. e nós podemos fazer loop em torno de 10 vezes

13467
09:02:06,478 --> 09:02:09,600
Finja cada elemento em cada iteração

13468
09:02:09,600 --> 09:02:11,040
e a maneira como fazemos isso vamos

13469
09:02:11,040 --> 09:02:13,200
Leia com esse loop e nós vamos

13470
09:02:13,200 --> 09:02:14,878
Diga para que

13471
09:02:14,878 --> 09:02:16,558
OK tamanho t

13472
09:02:16,558 --> 09:02:18,878
e vamos começar do índice para

13473
09:02:18,878 --> 09:02:20,878
zero isso é realmente importante porque

13474
09:02:20,878 --> 09:02:23,760
arrays são indexados a partir de zero eles não

13475
09:02:23,760 --> 09:02:25,680
Comece de novo isso é algo

13476
09:02:25,680 --> 09:02:27,840
Você precisa perfurar seu cérebro

13477
09:02:27,840 --> 09:02:29,680
e nós vamos colocar em nosso caso de teste

13478
09:02:29,680 --> 09:02:32,240
nós vamos dizer eu menos de 10

13479
09:02:32,240 --> 09:02:34,958
porque queremos ir de 0 a 9

13480
09:02:34,958 --> 09:02:37,440
e nós vamos incrementar o nosso

13481
09:02:37,440 --> 09:02:40,000
iterador depois que fazemos isso, vamos

13482
09:02:40,000 --> 09:02:41,200
Tenho que

13483
09:02:41,200 --> 09:02:44,080
saltar para o corpo do laço e nós

13484
09:02:44,080 --> 09:02:46,160
Não nomeei nosso iterador, é por isso

13485
09:02:46,160 --> 09:02:48,160
nós estamos tendo essa linha aqui

13486
09:02:48,160 --> 09:02:50,080
Vamos fazer isso muito rápido que estamos indo

13487
09:02:50,080 --> 09:02:53,520
para saltar para o corpo do nosso laço e nós

13488
09:02:53,520 --> 09:02:55,840
Vou dizer o sddc para fora

13489
09:02:55,840 --> 09:02:58,160
e nós vamos dizer pontuações

13490
09:02:58,160 --> 09:03:00,160
Precisamos ter cuidado com a forma como

13491
09:03:00,160 --> 09:03:02,478
formato isso porque eu não sou algo

13492
09:03:02,478 --> 09:03:04,638
nós temos que vamos ter isso

13493
09:03:04,638 --> 09:03:06,718
do nosso iterador aqui, então vamos

13494
09:03:06,718 --> 09:03:08,558
imprimi-lo assim e isso vai

13495
09:03:08,558 --> 09:03:10,718
Não há grande problema

13496
09:03:10,718 --> 09:03:12,840
e nós vamos dizer

13497
09:03:12,840 --> 09:03:15,920
quadrados e nós vamos dizer que eu é

13498
09:03:15,920 --> 09:03:18,478
Será o nosso índice que queremos

13499
09:03:18,478 --> 09:03:20,160
Imprimir os dados para

13500
09:03:20,160 --> 09:03:23,520
e nós vamos dizer stdendl

13501
09:03:23,520 --> 09:03:25,840
E porque nós não queremos isso

13502
09:03:25,840 --> 09:03:27,040
Nos confunde

13503
09:03:27,040 --> 09:03:29,440
Nós vamos comentar isso

13504
09:03:29,440 --> 09:03:32,718
e nós vamos subir e ter certeza

13505
09:03:32,718 --> 09:03:35,680
nosso comentário é agradável e limpo

13506
09:03:35,680 --> 09:03:37,440
e vamos tentar executá-lo e

13507
09:03:37,440 --> 09:03:39,280
O que você espera ver

13508
09:03:39,280 --> 09:03:42,318
Bem, não temos dados reais aqui

13509
09:03:42,318 --> 09:03:44,240
nós vamos ter alguns dados inúteis para isso

13510
09:03:44,240 --> 09:03:46,638
poderia realmente ser qualquer coisa que somos impressos

13511
09:03:46,638 --> 09:03:50,000
Então vamos construir com gcc e nós somos

13512
09:03:50,000 --> 09:03:52,240
Vou dar uma respiração

13513
09:03:52,240 --> 09:03:54,398
quarto, vamos descer e limpar

13514
09:03:54,398 --> 09:03:57,360
e correr galo e você vê que isso

13515
09:03:57,360 --> 09:03:59,680
é realmente alguns dados de lixo e se corrermos

13516
09:03:59,680 --> 09:04:01,840
Mais uma vez vamos ver que nós temos o mesmo

13517
09:04:01,840 --> 09:04:03,040
a saída

13518
09:04:03,040 --> 09:04:05,280
são os mesmos dados aqui se quisermos

13519
09:04:05,280 --> 09:04:08,240
para ter em alguns dados confiáveis que precisamos

13520
09:04:08,240 --> 09:04:10,478
Escreva em nossos próprios dados e vamos

13521
09:04:10,478 --> 09:04:12,080
Veja como podemos fazer isso, vamos

13522
09:04:12,080 --> 09:04:16,398
Veja como podemos gravar dados em um array

13523
09:04:16,398 --> 09:04:19,280
e a sintaxe é muito simples, então o

13524
09:04:19,280 --> 09:04:20,798
Como você faz isso

13525
09:04:20,798 --> 09:04:22,638
Você apenas diz o índice para o qual você

13526
09:04:22,638 --> 09:04:26,318
Quero escrever dados e você diz pontuações

13527
09:04:26,318 --> 09:04:29,440
e você especificar o índice vamos dizer zero

13528
09:04:29,440 --> 09:04:31,840
e eu vou colocar em um 20, por exemplo

13529
09:04:31,840 --> 09:04:33,760
É assim que você faz isso

13530
09:04:33,760 --> 09:04:36,240
Você diz 20 vamos dizer pontuações

13531
09:04:36,240 --> 09:04:38,398
nós vamos pegar o índice um

13532
09:04:38,398 --> 09:04:40,478
Primeiro elemento e vamos colocar em

13533
09:04:40,478 --> 09:04:42,798
um 21 por que não

13534
09:04:42,798 --> 09:04:44,878
E nós vamos dizer que pontuações nós somos

13535
09:04:44,878 --> 09:04:47,520
vamos dizer 2 para o índice 2 e nós somos

13536
09:04:47,520 --> 09:04:49,920
Vou colocar em um 22

13537
09:04:49,920 --> 09:04:53,360
Por que não e depois de fazermos isso, podemos

13538
09:04:53,360 --> 09:04:55,680
imprimir estes dados ou ler com o

13539
09:04:55,680 --> 09:04:57,920
loop e certifique-se de que os dados que fizemos

13540
09:04:57,920 --> 09:05:00,240
A escrita é na verdade n

13541
09:05:00,240 --> 09:05:02,000
Então vamos copiar isso

13542
09:05:02,000 --> 09:05:04,000
e comentar isso porque não

13543
09:05:04,000 --> 09:05:06,958
Quero que isso nos confunda no console

13544
09:05:06,958 --> 09:05:08,638
e nós vamos fazer isso, nós vamos

13545
09:05:08,638 --> 09:05:12,160
para vir aqui e imprimir os dados

13546
09:05:12,160 --> 09:05:14,398
Vamos dizer o que estamos fazendo aqui e se

13547
09:05:14,398 --> 09:05:17,120
Construímos isso que esperamos ver

13548
09:05:17,120 --> 09:05:20,160
que no índice 0 1 e 2 temos o

13549
09:05:20,160 --> 09:05:23,440
Valores 20 21 e 22.

13550
09:05:23,440 --> 09:05:25,120
Vamos construir e ver que vamos correr

13551
09:05:25,120 --> 09:05:27,920
Teste para construir com gcc

13552
09:05:27,920 --> 09:05:29,360
A construção vai passar por nós somos

13553
09:05:29,360 --> 09:05:32,000
indo para limpar e executar o galo

13554
09:05:32,000 --> 09:05:35,680
e olhar para esta pontuação é uma pontuação de 0 20

13555
09:05:35,680 --> 09:05:38,878
é 1 21 pontuação é 2 22

13556
09:05:38,878 --> 09:05:41,520
e nossos dados estão realmente obtendo ganho

13557
09:05:41,520 --> 09:05:43,280
Agora vamos ver que também podemos

13558
09:05:43,280 --> 09:05:45,440
escrever os dados usando o loop para fazê-lo

13559
09:05:45,440 --> 09:05:48,478
Realmente fácil sem que façamos manualmente

13560
09:05:48,478 --> 09:05:49,920
Coisas assim

13561
09:05:49,920 --> 09:05:52,240
para isso vamos copiar o que nós

13562
09:05:52,240 --> 09:05:54,638
Tenho aqui para imprimir os dados

13563
09:05:54,638 --> 09:05:56,478
e vamos comentar o que tivemos

13564
09:05:56,478 --> 09:05:57,600
Aqui fora

13565
09:05:57,600 --> 09:05:59,440
Então vamos comentar isso e nós estamos

13566
09:05:59,440 --> 09:06:01,120
Indo para baixo

13567
09:06:01,120 --> 09:06:03,520
e uh imprimir os dados novamente nós vamos

13568
09:06:03,520 --> 09:06:06,240
para colocar o código aqui e antes de

13569
09:06:06,240 --> 09:06:08,238
imprimir os dados que vamos colocar dados

13570
09:06:08,238 --> 09:06:08,960
Os de que a si a si a do que sobre a, a , a , a , aja, a , a, a, a

13571
09:06:08,960 --> 09:06:11,122
com o loop para que o loop seja basicamente

13572
09:06:11,122 --> 09:06:12,398
Vai ser a mesma coisa que vamos

13573
09:06:12,398 --> 09:06:14,000
para dizer o tamanho

13574
09:06:14,000 --> 09:06:16,398
ti nós vamos inicializar isso nós somos

13575
09:06:16,398 --> 09:06:18,640
Vou dizer menos de 10 porque nós

13576
09:06:18,640 --> 09:06:20,800
Queremos fazer um loop 10 vezes que vamos

13577
09:06:20,800 --> 09:06:22,078
incremento

13578
09:06:22,078 --> 09:06:23,598
e nós vamos cair no corpo de

13579
09:06:23,598 --> 09:06:26,078
O loop que vamos fazer é escrever

13580
09:06:26,078 --> 09:06:28,000
dados no índice da corrente

13581
09:06:28,000 --> 09:06:30,320
iteração devo dizer o que somos

13582
09:06:30,320 --> 09:06:32,480
Vou fazer, vamos dizer pontuações i

13583
09:06:32,480 --> 09:06:34,960
e nós podemos realmente colocar em qualquer coisa para

13584
09:06:34,960 --> 09:06:37,840
Agora vamos dizer que nós queremos colocar um eu

13585
09:06:37,840 --> 09:06:40,320
multiplicado por 10, então vamos levar

13586
09:06:40,320 --> 09:06:43,598
o índice atual multiplicá-lo por 10 e

13587
09:06:43,598 --> 09:06:45,758
nós vamos armazenar isso no índice

13588
09:06:45,758 --> 09:06:47,840
na iteração atual, isso é o que

13589
09:06:47,840 --> 09:06:49,122
Estão fazendo aqui

13590
09:06:49,122 --> 09:06:51,122
e se imprimirmos isso para tentar pensar

13591
09:06:51,122 --> 09:06:53,122
sobre o que vamos chegar aqui

13592
09:06:53,122 --> 09:06:54,160
Então,

13593
09:06:54,160 --> 09:06:56,878
no índice 0 vamos colocar em um 0 para ser super

13594
09:06:56,878 --> 09:06:59,040
claro aqui que estamos começando a partir

13595
09:06:59,040 --> 09:07:01,598
índice 0. no índice 0 vamos tomar

13596
09:07:01,598 --> 09:07:03,598
0 e multiplique isso com o 10, então nós somos

13597
09:07:03,598 --> 09:07:07,122
indo para armazenar 0 no índice 0. o loop é

13598
09:07:07,122 --> 09:07:08,878
Vou correr novamente no índice 1 estamos

13599
09:07:08,878 --> 09:07:10,960
Vou tomar uma multiplicação 1 com 10 nós somos

13600
09:07:10,960 --> 09:07:13,278
indo para obtê-lo 10 no índice 2 nós somos

13601
09:07:13,278 --> 09:07:16,160
vai multiplicar 2 com um 10 e armazenar

13602
09:07:16,160 --> 09:07:19,040
um 20 no índice 2 e vamos manter

13603
09:07:19,040 --> 09:07:21,438
indo e basicamente tem 0

13604
09:07:21,438 --> 09:07:24,640
10 20 até 90 armazenados em nosso

13605
09:07:24,640 --> 09:07:26,480
Aqui, então se nós imprimi-lo para fora nós

13606
09:07:26,480 --> 09:07:29,918
espere ver 0 10 20 até 90.

13607
09:07:29,918 --> 09:07:32,000
Vamos soldar e ver que isso é realmente

13608
09:07:32,000 --> 09:07:34,878
o que temos em nossa matriz, vamos

13609
09:07:34,878 --> 09:07:37,200
trabalhar com sucesso, vamos limpar e correr

13610
09:07:37,200 --> 09:07:39,758
Galo e você vê que isso é exatamente

13611
09:07:39,758 --> 09:07:42,558
A mesma coisa que temos em nosso array como

13612
09:07:42,558 --> 09:07:44,800
legal é que tudo bem outra coisa que eu quero

13613
09:07:44,800 --> 09:07:47,438
Veja é que podemos declarar e

13614
09:07:47,438 --> 09:07:49,680
inicializar um array

13615
09:07:49,680 --> 09:07:52,000
no lugar, mas antes de fazermos isso, digamos

13616
09:07:52,000 --> 09:07:54,078
O que estávamos fazendo aqui estávamos tentando

13617
09:07:54,078 --> 09:07:56,078
para escrever dados em um loop e nós estamos indo

13618
09:07:56,078 --> 09:07:58,160
para comentar isso porque nós não

13619
09:07:58,160 --> 09:08:01,360
Quer muito rendimento confuso

13620
09:08:01,360 --> 09:08:03,520
em nosso console e nós vamos embora

13621
09:08:03,520 --> 09:08:05,680
para baixo e colocar os dados porque eu não

13622
09:08:05,680 --> 09:08:07,598
Quero digitar tudo isso graças

13623
09:08:07,598 --> 09:08:09,840
para que possamos declarar e inicializar uma

13624
09:08:09,840 --> 09:08:13,278
Array no lugar e a maneira como fazemos isso

13625
09:08:13,278 --> 09:08:15,758
O array vai armazenar duplas agora

13626
09:08:15,758 --> 09:08:17,680
Podemos realmente declarar uma variedade de

13627
09:08:17,680 --> 09:08:20,000
Tudo menos até agora já vimos que

13628
09:08:20,000 --> 09:08:22,320
pode fazer isso por form, agora vamos tentar um

13629
09:08:22,320 --> 09:08:23,918
Um pouco e mostrar que você pode fazer

13630
09:08:23,918 --> 09:08:26,320
a mesma coisa para tempos duplos, então nós

13631
09:08:26,320 --> 09:08:28,800
pode declarar uma matriz de tipos duplos

13632
09:08:28,800 --> 09:08:31,040
O tamanho vai ser cinco e nós vamos

13633
09:08:31,040 --> 09:08:33,360
para inicializar isso com esses dados aqui

13634
09:08:33,360 --> 09:08:35,278
então, no índice zero, vamos ter um

13635
09:08:35,278 --> 09:08:41,758
12.7 índice um a 7.5 índice 2 a 13,2

13636
09:08:41,758 --> 09:08:43,122
índice 3

13637
09:08:43,122 --> 09:08:47,598
um 8.1 e índice 4 e 9.3 e isso é

13638
09:08:47,598 --> 09:08:49,520
O que vamos ter se imprimirmos

13639
09:08:49,520 --> 09:08:51,438
Aqui temos um loop simples para

13640
09:08:51,438 --> 09:08:53,122
imprimi-lo e ele vai basicamente

13641
09:08:53,122 --> 09:08:54,680
Diga salário 0

13642
09:08:54,680 --> 09:08:57,360
12.7 e vai percorrer todo o caminho para

13643
09:08:57,360 --> 09:09:01,360
salário 4 e imprimir um 9,3 e isso é

13644
09:09:01,360 --> 09:09:02,800
Algo que você pode fazer

13645
09:09:02,800 --> 09:09:04,878
Se faz sentido para o que você é

13646
09:09:04,878 --> 09:09:07,840
projetando com c plus plus que estamos indo

13647
09:09:07,840 --> 09:09:10,480
para construir isso com gcc

13648
09:09:10,480 --> 09:09:13,200
Vamos limpar e correr e você vê isso

13649
09:09:13,200 --> 09:09:16,238
Isso é exatamente o que esperamos agora

13650
09:09:16,238 --> 09:09:18,640
Isto é super claro a próxima coisa que nós somos

13651
09:09:18,640 --> 09:09:20,800
Vou ver que se você não fizer isso

13652
09:09:20,800 --> 09:09:24,078
inicializar todos os elementos na matriz

13653
09:09:24,078 --> 09:09:26,320
Os que você deixar de fora vão ser

13654
09:09:26,320 --> 09:09:28,558
inicializado para zero e vamos

13655
09:09:28,558 --> 09:09:31,438
colocar em um pedaço de código para jogar com isso

13656
09:09:31,438 --> 09:09:33,360
então aqui temos um array é uma rede

13657
09:09:33,360 --> 09:09:35,520
array será chamado de famílias

13658
09:09:35,520 --> 09:09:38,160
e o tamanho vai ser cinco, mas nós

13659
09:09:38,160 --> 09:09:41,360
estão apenas inicializando três elementos e

13660
09:09:41,360 --> 09:09:43,200
Esses elementos serão elementos

13661
09:09:43,200 --> 09:09:47,200
na frente, os elementos no índice 3 e

13662
09:09:47,200 --> 09:09:49,680
4 vão ser deixados de fora e eles estão

13663
09:09:49,680 --> 09:09:52,480
será inicializado para 0 pelo

13664
09:09:52,480 --> 09:09:54,800
Compilador, então se imprimirmos isso, nós

13665
09:09:54,800 --> 09:09:58,960
esperar obter 12 7 5 e 0 em

13666
09:09:58,960 --> 09:10:01,520
diferentes índices nesta matriz aqui

13667
09:10:01,520 --> 09:10:03,040
Vamos construir isso

13668
09:10:03,040 --> 09:10:04,960
com o Gcc

13669
09:10:04,960 --> 09:10:07,278
nós vamos limpar porque a construção

13670
09:10:07,278 --> 09:10:08,800
é bem sucedido

13671
09:10:08,800 --> 09:10:11,040
E nós vamos correr isso

13672
09:10:11,040 --> 09:10:13,040
Isto é exatamente o que esperamos que tenhamos a

13673
09:10:13,040 --> 09:10:16,398
12 um 7 e 5 e os dois últimos elementos

13674
09:10:16,398 --> 09:10:18,960
são inicializados para zero e isso pode

13675
09:10:18,960 --> 09:10:21,438
Venha a dia às vezes bem, vamos

13676
09:10:21,438 --> 09:10:23,438
Comente esta outra coisa que queremos

13677
09:10:23,438 --> 09:10:26,238
Ver é que nós podemos realmente

13678
09:10:26,238 --> 09:10:29,278
omita o tamanho quando estamos declarando o nosso

13679
09:10:29,278 --> 09:10:30,320
Array

13680
09:10:30,320 --> 09:10:33,040
e inicializá-lo, então aqui está uma simples

13681
09:10:33,040 --> 09:10:35,278
exemplo, temos um intervalo chamado

13682
09:10:35,278 --> 09:10:38,398
tamanhos de classe que não especificamos o tamanho

13683
09:10:38,398 --> 09:10:41,360
mas inicializamos e o compilador é

13684
09:10:41,360 --> 09:10:44,000
indo para deduzir o tamanho deste array

13685
09:10:44,000 --> 09:10:46,718
dos elementos que colocamos aqui, então se

13686
09:10:46,718 --> 09:10:49,122
colocamos dois elementos para que ele vá

13687
09:10:49,122 --> 09:10:51,520
ser do tamanho 2 se colocarmos em 10 elementos

13688
09:10:51,520 --> 09:10:54,238
Vai ser do tamanho 10 e isso é

13689
09:10:54,238 --> 09:10:56,960
Como isso funciona, mas se você fizer algo

13690
09:10:56,960 --> 09:10:59,200
assim e não inicializar o

13691
09:10:59,200 --> 09:11:02,398
array vamos tirar isso, por exemplo

13692
09:11:02,398 --> 09:11:03,918
você vai ter um erro de compilador

13693
09:11:03,918 --> 09:11:06,320
porque o compilador agora não sabe

13694
09:11:06,320 --> 09:11:08,320
Qual tamanho vai dar a isso

13695
09:11:08,320 --> 09:11:10,960
Array para ter certeza de

13696
09:11:10,960 --> 09:11:12,238
Ou também o a

13697
09:11:12,238 --> 09:11:15,122
colocar o tamanho ou inicializar a sua matriz

13698
09:11:15,122 --> 09:11:17,360
assim e vai funcionar em

13699
09:11:17,360 --> 09:11:19,278
Este caso vamos ter seis

13700
09:11:19,278 --> 09:11:21,758
Elementos e você vê que um intervalo

13701
09:11:21,758 --> 09:11:23,918
Baseado para loop vai ser útil

13702
09:11:23,918 --> 09:11:26,320
aqui porque nós realmente não sabemos o

13703
09:11:26,320 --> 09:11:28,558
tamanho dessa matriz se alguém vier e

13704
09:11:28,558 --> 09:11:31,598
acrescenta outro elemento, digamos 23

13705
09:11:31,598 --> 09:11:33,758
O tamanho vai mudar e se nós

13706
09:11:33,758 --> 09:11:36,558
Dito para codificar o tamanho em nosso loop completo

13707
09:11:36,558 --> 09:11:38,960
o código vai quebrar, mas um intervalo

13708
09:11:38,960 --> 09:11:41,680
Baseado para loop vai usar qualquer coisa

13709
09:11:41,680 --> 09:11:43,598
tamanho que já tem, então vamos

13710
09:11:43,598 --> 09:11:45,360
Tente construir isso que vamos construir

13711
09:11:45,360 --> 09:11:47,918
com gcc como de costume

13712
09:11:47,918 --> 09:11:49,680
e o mundo vai passar se

13713
09:11:49,680 --> 09:11:51,840
nós corremos o galo, nós vamos pegar o

13714
09:11:51,840 --> 09:11:56,160
elementos temos 10 12 15 11 18 17 23 se

13715
09:11:56,160 --> 09:11:58,000
nós adicionamos um novo elemento que isso vai

13716
09:11:58,000 --> 09:11:58,960
trabalho

13717
09:11:58,960 --> 09:12:00,960
Você vê que não precisamos modificar a

13718
09:12:00,960 --> 09:12:02,320
loop aqui para

13719
09:12:02,320 --> 09:12:04,640
Coloque o novo tamanho e isso é realmente

13720
09:12:04,640 --> 09:12:06,960
legal eu gosto disso sobre a faixa baseada para

13721
09:12:06,960 --> 09:12:09,040
loops que vamos construir novamente

13722
09:12:09,040 --> 09:12:11,040
E nós vamos limpar

13723
09:12:11,040 --> 09:12:12,558
correr o galo e isso vai

13724
09:12:12,558 --> 09:12:15,122
dar a nós exatamente os dados que temos no

13725
09:12:15,122 --> 09:12:17,520
array assim que esta é uma maneira que você pode fazer

13726
09:12:17,520 --> 09:12:19,840
Coisas que outra coisa que vimos é que você

13727
09:12:19,840 --> 09:12:22,558
Não pode modificar arrays de const

13728
09:12:22,558 --> 09:12:25,040
Então vamos fazer um exemplo aqui, por exemplo

13729
09:12:25,040 --> 09:12:27,360
nós vamos pegar essa coisa e uh

13730
09:12:27,360 --> 09:12:30,320
colocar um array declarado aqui em baixo nós somos

13731
09:12:30,320 --> 09:12:32,718
Vou copiar isso e usar isso aqui e

13732
09:12:32,718 --> 09:12:34,800
nós vamos fazer esse custo

13733
09:12:34,800 --> 09:12:37,520
Vamos dar um nome, vamos dizer

13734
09:12:37,520 --> 09:12:39,680
As aves, por exemplo, queremos

13735
09:12:39,680 --> 09:12:40,558
Mantenha

13736
09:12:40,558 --> 09:12:42,398
O rastreito de

13737
09:12:42,398 --> 09:12:44,960
linhas de pássaros ou o que quer que seja justo

13738
09:12:44,960 --> 09:12:46,640
Um exemplo para mostrar que você não pode

13739
09:12:46,640 --> 09:12:49,438
modificar este array, então se você tentar fazer

13740
09:12:49,438 --> 09:12:51,840
Algo como os pássaros

13741
09:12:51,840 --> 09:12:54,718
e índice 2, por exemplo, e você quer

13742
09:12:54,718 --> 09:12:57,520
Mudar isso para um 8

13743
09:12:57,520 --> 09:12:59,758
O compilador vai reclamar você

13744
09:12:59,758 --> 09:13:01,758
Veja que o código visual do estúdio é

13745
09:13:01,758 --> 09:13:03,438
Queixar já

13746
09:13:03,438 --> 09:13:06,160
a expiração deve ser um valor modificável, então

13747
09:13:06,160 --> 09:13:09,360
está dizendo que a matriz armazena const

13748
09:13:09,360 --> 09:13:12,398
elementos para que você não possa modificar elementos de

13749
09:13:12,398 --> 09:13:14,878
Este array está bem, então isso é algo que você

13750
09:13:14,878 --> 09:13:16,800
Você não quer que as pessoas sejam

13751
09:13:16,800 --> 09:13:20,398
capaz de modificar dados em sua matriz e

13752
09:13:20,398 --> 09:13:22,718
A última coisa que eu vou te mostrar é

13753
09:13:22,718 --> 09:13:26,078
que você pode fazer operações sobre os dados

13754
09:13:26,078 --> 09:13:27,598
em uma matriz

13755
09:13:27,598 --> 09:13:30,238
então, vamos trazer nossa matriz de pontuações novamente

13756
09:13:30,238 --> 09:13:31,918
Vamos subir e copiá-lo

13757
09:13:31,918 --> 09:13:34,078
porque o código está usando lá, então vamos

13758
09:13:34,078 --> 09:13:37,520
colocar em nossa própria matriz de pontuações

13759
09:13:37,520 --> 09:13:39,520
Vai ser muito rápido e nós somos

13760
09:13:39,520 --> 09:13:41,200
vai dizer que é uma matriz com

13761
09:13:41,200 --> 09:13:42,718
Este suporte de ângulo vamos

13762
09:13:42,718 --> 09:13:44,800
inicialize isso vamos colocar em um monte de

13763
09:13:44,800 --> 09:13:47,520
Valores e o que podemos fazer é somar estes

13764
09:13:47,520 --> 09:13:49,520
As coisas vamos armazenar o nosso

13765
09:13:49,520 --> 09:13:52,078
resulta em uma variável de soma e nós somos

13766
09:13:52,078 --> 09:13:54,480
indo para loop em torno de um alcance baseado

13767
09:13:54,480 --> 09:13:56,800
para loop porque nós realmente não sabemos

13768
09:13:56,800 --> 09:13:58,718
o tamanho deste array pode mudar qualquer

13769
09:13:58,718 --> 09:14:02,238
Com muitos elementos e um

13770
09:14:02,238 --> 09:14:04,558
alcance baseado em loop é muito legal em

13771
09:14:04,558 --> 09:14:06,398
que não precisamos acompanhar o

13772
09:14:06,398 --> 09:14:07,918
O tamanho de nós mesmos

13773
09:14:07,918 --> 09:14:10,800
Então nós vamos entrar aqui

13774
09:14:10,800 --> 09:14:12,640
e obter cada elemento

13775
09:14:12,640 --> 09:14:14,718
E acrescente isso a alguns

13776
09:14:14,718 --> 09:14:17,122
por exemplo, a primeira vez que a soma é

13777
09:14:17,122 --> 09:14:18,800
Será 0 porque é isso que nós

13778
09:14:18,800 --> 09:14:20,640
inicializá-lo com que vamos conseguir

13779
09:14:20,640 --> 09:14:23,598
neste loop aqui o primeiro elemento é

13780
09:14:23,598 --> 09:14:25,520
indo para 2 vamos acrescentar isso para

13781
09:14:25,520 --> 09:14:28,480
0 e obter 2 nós vamos adicionar um 5 nós somos

13782
09:14:28,480 --> 09:14:29,918
Vou ter um 7 que vamos manter

13783
09:14:29,918 --> 09:14:33,122
adicionando este elemento e na soma final

13784
09:14:33,122 --> 09:14:35,758
vai conter a soma de tudo isso

13785
09:14:35,758 --> 09:14:37,918
elementos na matriz aqui e isso é

13786
09:14:37,918 --> 09:14:40,398
uma maneira legal que você pode resumir os elementos

13787
09:14:40,398 --> 09:14:43,040
em sua matriz, então se nós executarmos isso, nós somos

13788
09:14:43,040 --> 09:14:44,800
Vou imprimir o sol para fora, vamos

13789
09:14:44,800 --> 09:14:46,960
fazer isso muito rápido que vamos correr

13790
09:14:46,960 --> 09:14:50,000
Isto tem que construir com gcc e nós temos

13791
09:14:50,000 --> 09:14:52,320
um erro do compilador

13792
09:14:52,320 --> 09:14:54,960
O que está acontecendo aqui vai dizer

13793
09:14:54,960 --> 09:14:58,238
redeclaração de pontuações onde fizemos

13794
09:14:58,238 --> 09:15:00,640
Declarar pontuações antes de subir e

13795
09:15:00,640 --> 09:15:03,122
Certifique-se de que não seja declarado em algum lugar

13796
09:15:03,122 --> 09:15:05,040
E é declarado aqui

13797
09:15:05,040 --> 09:15:07,438
Então queremos comentar isso

13798
09:15:07,438 --> 09:15:09,598
Volte ao nosso código para que possamos ver

13799
09:15:09,598 --> 09:15:10,320


13800
09:15:10,320 --> 09:15:14,160
e nós vamos construir novamente com gcc

13801
09:15:14,160 --> 09:15:16,078
E agora o mundo está passando por nós

13802
09:15:16,078 --> 09:15:17,278
indo para limpar

13803
09:15:17,278 --> 09:15:19,122
e se corrermos o galote

13804
09:15:19,122 --> 09:15:20,160
Pontuação

13805
09:15:20,160 --> 09:15:23,758
A soma é 37 e se você resumir essas coisas

13806
09:15:23,758 --> 09:15:26,640
Tenho certeza que você tem 37. isso é realmente tudo

13807
09:15:26,640 --> 09:15:28,398
nos proponhamos a fazer nesta palestra eu espero

13808
09:15:28,398 --> 09:15:30,398
Você tem uma ideia melhor de como você pode

13809
09:15:30,398 --> 09:15:33,680
Declarar seus arrays colocar dados em leitura

13810
09:15:33,680 --> 09:15:36,320
Os dados desses arrays os tornam const

13811
09:15:36,320 --> 09:15:38,800
ou mesmo fazer todos os tipos de operações em

13812
09:15:38,800 --> 09:15:40,718
E isso foi realmente o que isso

13813
09:15:40,718 --> 09:15:42,718
A palestra era tudo sobre

13814
09:15:42,718 --> 09:15:44,160
Vamos parar aqui neste

13815
09:15:44,160 --> 09:15:46,000
palestra no próximo, vamos

13816
09:15:46,000 --> 09:15:48,398
ver uma maneira legal que podemos usar para obter o

13817
09:15:48,398 --> 09:15:50,640
Tamanho de um array

13818
09:15:50,640 --> 09:15:52,480
Vá em frente e termine aqui

13819
09:15:52,480 --> 09:15:54,718
e encontrar-me lá nesta palestra nós somos

13820
09:15:54,718 --> 09:15:56,718
ver uma maneira que possamos consultar para o

13821
09:15:56,718 --> 09:15:58,398
Tamanho de um array

13822
09:15:58,398 --> 09:16:00,718
em tempo de execução se você se lembrar no último

13823
09:16:00,718 --> 09:16:02,800
palestra que tivemos um exemplo como este

13824
09:16:02,800 --> 09:16:05,278
mostrando como podemos declarar uma matriz e

13825
09:16:05,278 --> 09:16:08,000
inicializá-lo em uma única declaração como

13826
09:16:08,000 --> 09:16:08,800
Isto é

13827
09:16:08,800 --> 09:16:11,680
Mas o problema que tivemos com isso é que

13828
09:16:11,680 --> 09:16:14,800
se tentamos imprimir o array usando um

13829
09:16:14,800 --> 09:16:17,040
para loop, por exemplo, teríamos que

13830
09:16:17,040 --> 09:16:19,680
usar o tamanho e o tamanho deste array

13831
09:16:19,680 --> 09:16:22,000
pode mudar se alguém decide adicionar

13832
09:16:22,000 --> 09:16:24,078
elementos ou remover elementos, em seguida, o

13833
09:16:24,078 --> 09:16:26,398
tamanho vai ser irrelevante c plus

13834
09:16:26,398 --> 09:16:29,200
Plus fornece uma maneira que podemos consultar para o

13835
09:16:29,200 --> 09:16:31,918
tamanho de uma matriz em tempo de execução e nós somos

13836
09:16:31,918 --> 09:16:34,480
obter a contabilidade de tamanho real

13837
09:16:34,480 --> 09:16:36,878
para o número atual de elementos que

13838
09:16:36,878 --> 09:16:39,360
temos na matriz e para isso usamos

13839
09:16:39,360 --> 09:16:42,320
a função do tamanho do std

13840
09:16:42,320 --> 09:16:44,558
Esta é uma função que vem com o c

13841
09:16:44,558 --> 09:16:46,238
mais além de biblioteca padrão para que você esteja

13842
09:16:46,238 --> 09:16:48,480
indo tê-lo já se você tem um

13843
09:16:48,480 --> 09:16:50,800
Compstandard compatível se você ver aqui você

13844
09:16:50,800 --> 09:16:54,000
Veja que foi introduzido em c mais 17

13845
09:16:54,000 --> 09:16:56,000
e é uma adição legal, podemos usá-lo

13846
09:16:56,000 --> 09:16:58,320
para tornar o nosso código mais fácil de trabalhar se

13847
09:16:58,320 --> 09:16:59,840
Você olha aqui nós temos um loop simples

13848
09:16:59,840 --> 09:17:02,000
que vai imprimir dados para fora é

13849
09:17:02,000 --> 09:17:04,320
indo para loop a partir de zero todo o

13850
09:17:04,320 --> 09:17:06,878
caminho para o tamanho da matriz que você vê

13851
09:17:06,878 --> 09:17:09,598
que usamos isso para controlar quando

13852
09:17:09,598 --> 09:17:12,000
O loop vai acabar, em seguida, colocar em nosso

13853
09:17:12,000 --> 09:17:14,078
incrementação parte e, em seguida, saltamos

13854
09:17:14,078 --> 09:17:16,238
no corpo do laço e imprimir o

13855
09:17:16,238 --> 09:17:18,320
elemento atual no loop e se o fizermos

13856
09:17:18,320 --> 09:17:19,680
Coisas assim que vamos ser capazes

13857
09:17:19,680 --> 09:17:22,238
para imprimir todos os elementos no array

13858
09:17:22,238 --> 09:17:24,960
Independentemente do número que inicializamos

13859
09:17:24,960 --> 09:17:27,680
Tudo bem, então este é um caminho e

13860
09:17:27,680 --> 09:17:30,558
foi introduzido em c mais mais 17. mas

13861
09:17:30,558 --> 09:17:32,718
Alguns de vocês devem estar perguntando

13862
09:17:32,718 --> 09:17:35,200
Como fizemos as coisas antes de z plus plus

13863
09:17:35,200 --> 09:17:36,398
17

13864
09:17:36,398 --> 09:17:39,598
Bem, tivemos que fazer um hack para conseguir

13865
09:17:39,598 --> 09:17:42,160
Algo assim usamos o tamanho de

13866
09:17:42,160 --> 09:17:44,718
Operador temos visto muitas vezes

13867
09:17:44,718 --> 09:17:45,680
Agora mesmo

13868
09:17:45,680 --> 09:17:47,520
E a maneira como você usa isso

13869
09:17:47,520 --> 09:17:50,960
se você fizer o tamanho e passar o array

13870
09:17:50,960 --> 09:17:52,960
Você vai ter todo o tamanho de

13871
09:17:52,960 --> 09:17:56,238
a matriz, então se tomarmos isso e dividirmos

13872
09:17:56,238 --> 09:17:58,960
que, com o tamanho de um único elemento

13873
09:17:58,960 --> 09:18:00,960
na matriz, nós vamos ter o

13874
09:18:00,960 --> 09:18:03,200
número de elementos da matriz e isso

13875
09:18:03,200 --> 09:18:05,278
é realmente o que estamos fazendo aqui estamos

13876
09:18:05,278 --> 09:18:07,680
configurando uma variável de contagem e nós estamos

13877
09:18:07,680 --> 09:18:09,918
tomando o tamanho da matriz e

13878
09:18:09,918 --> 09:18:12,480
Dividindo isso com o tamanho de um único

13879
09:18:12,480 --> 09:18:14,800
elemento na matriz e nós somos apenas

13880
09:18:14,800 --> 09:18:17,040
agarrando o primeiro elemento porque você

13881
09:18:17,040 --> 09:18:19,598
pode realmente usar qualquer elemento aqui e uma vez

13882
09:18:19,598 --> 09:18:22,078
nós temos isso que podemos usar essa contagem para fazer

13883
09:18:22,078 --> 09:18:24,078
um loop como este e está funcionando

13884
09:18:24,078 --> 09:18:25,122
muito bem

13885
09:18:25,122 --> 09:18:27,598
Por favor, lembre-se que você não precisa

13886
09:18:27,598 --> 09:18:29,360
passar por essa loucura que estamos fazendo

13887
09:18:29,360 --> 09:18:32,480
Aqui você nem precisa usar o tamanho do std

13888
09:18:32,480 --> 09:18:35,520
porque você pode usar uma base de alcance para

13889
09:18:35,520 --> 09:18:37,840
loop e ter acesso aos elementos que você

13890
09:18:37,840 --> 09:18:39,438
ter na matriz e ele vai

13891
09:18:39,438 --> 09:18:41,598
Trabalhe muito bem agora que você tem um

13892
09:18:41,598 --> 09:18:44,000
ideia sobre isso vamos para o visual

13893
09:18:44,000 --> 09:18:46,718
código de estúdio e realmente jogar com a gente

13894
09:18:46,718 --> 09:18:49,680
Tudo bem, então aqui estamos em nosso trabalho

13895
09:18:49,680 --> 09:18:52,000
pasta em que vamos trabalhar

13896
09:18:52,000 --> 09:18:54,558
Este tamanho de projeto de um array que somos

13897
09:18:54,558 --> 09:18:56,558
Vou pegar nosso projeto de templates que somos

13898
09:18:56,558 --> 09:18:59,122
vai copiar os arquivos e colocá-los em

13899
09:18:59,122 --> 09:19:00,238
lugar

13900
09:19:00,238 --> 09:19:01,758
E nós vamos abrir isso para dentro

13901
09:19:01,758 --> 09:19:03,918
Código de estúdio visual, vamos fazer que seja

13902
09:19:03,918 --> 09:19:05,840
vai abrir no código do estúdio visual

13903
09:19:05,840 --> 09:19:08,078
E nós vamos tentar e

13904
09:19:08,078 --> 09:19:10,238
Limpe-o um pouco e nós estamos

13905
09:19:10,238 --> 09:19:12,800
vamos declarar uma matriz se quisermos

13906
09:19:12,800 --> 09:19:14,480
Imprima esta coisa

13907
09:19:14,480 --> 09:19:16,640
Precisamos saber quantas vezes somos

13908
09:19:16,640 --> 09:19:19,360
indo para loop e imprimir elementos aqui

13909
09:19:19,360 --> 09:19:21,596
Então, uma coisa que você pode querer fazer é

13910
09:19:21,596 --> 09:19:24,320
Diga ok, temos 10 elementos aqui, então

13911
09:19:24,320 --> 09:19:26,640
Eu vou fazer loop por 10 vezes que você pode

13912
09:19:26,640 --> 09:19:28,720
Acho que isso vai funcionar e é

13913
09:19:28,720 --> 09:19:30,480
Vou trabalhar se nós

13914
09:19:30,480 --> 09:19:32,400
trazer um terminal

13915
09:19:32,400 --> 09:19:35,840
e construir isso com gcc como nós geralmente

13916
09:19:35,840 --> 09:19:36,960
- É assim.

13917
09:19:36,960 --> 09:19:39,596
e uh claro

13918
09:19:39,596 --> 09:19:42,160
e correr galo nós vamos ter o nosso

13919
09:19:42,160 --> 09:19:44,240
números isto é o que temos no

13920
09:19:44,240 --> 09:19:46,160
Arrendamento de um a dez

13921
09:19:46,160 --> 09:19:49,360
Mas e se alguém vier e mudar

13922
09:19:49,360 --> 09:19:51,200
os elementos que temos aqui vamos adicionar

13923
09:19:51,200 --> 09:19:54,080
um 11 e um 12.

13924
09:19:54,080 --> 09:19:54,960
E a

13925
09:19:54,960 --> 09:19:57,040
No momento em que mudarmos isso, vamos precisar

13926
09:19:57,040 --> 09:19:59,520
para vir e mudar o tamanho aqui e

13927
09:19:59,520 --> 09:20:01,840
Este loop aqui pode ser enterrado em algum lugar

13928
09:20:01,840 --> 09:20:04,720
profundamente em seu projeto e pode não ser

13929
09:20:04,720 --> 09:20:08,320
por mais fácil que seja agora ver que também

13930
09:20:08,320 --> 09:20:10,880
precisa mudar isso, isso pode ser realmente

13931
09:20:10,880 --> 09:20:14,400
grande fonte de problemas difíceis de depurar, então

13932
09:20:14,400 --> 09:20:17,680
O que realmente precisamos é uma maneira de obter o

13933
09:20:17,680 --> 09:20:21,276
tamanho do array em tempo de execução e ser capaz

13934
09:20:21,276 --> 09:20:23,756
para consultar de forma dinâmica para esse tamanho e

13935
09:20:23,756 --> 09:20:26,080
use-o em nosso programa e isso é exatamente

13936
09:20:26,080 --> 09:20:30,080
O que o std tamanho fornece para que vamos

13937
09:20:30,080 --> 09:20:32,080
Diga a contagem final

13938
09:20:32,080 --> 09:20:34,400
e nós vamos colocar um valor, vamos

13939
09:20:34,400 --> 09:20:36,400
usar um inicializador braced para que vamos

13940
09:20:36,400 --> 09:20:38,800
para dizer std tamanho

13941
09:20:38,800 --> 09:20:40,480
e nós vamos passar a matriz nós

13942
09:20:40,480 --> 09:20:42,640
Quero obter o tamanho para

13943
09:20:42,640 --> 09:20:44,400
E se fizermos isso, vamos conseguir

13944
09:20:44,400 --> 09:20:46,000
Este tamanho aqui

13945
09:20:46,000 --> 09:20:48,320
e nós vamos fazer loop para isso

13946
09:20:48,320 --> 09:20:50,320
Número de vezes, então vamos testar

13947
09:20:50,320 --> 09:20:53,840
Porque eu é menos do que a contagem aqui

13948
09:20:53,840 --> 09:20:56,160
E agora não importa quantos

13949
09:20:56,160 --> 09:20:58,000
Elementos que temos aqui vamos

13950
09:20:58,000 --> 09:21:00,480
obtê-los no tempo de execução, precisamos apenas

13951
09:21:00,480 --> 09:21:03,120
atualizar este inicializador aqui, então o que nós

13952
09:21:03,120 --> 09:21:04,880
Pode fazer é

13953
09:21:04,880 --> 09:21:07,756
solda com gcc novamente agora

13954
09:21:07,756 --> 09:21:09,756
nós vamos vir aqui

13955
09:21:09,756 --> 09:21:12,400
e correr galo e nós vamos conseguir

13956
09:21:12,400 --> 09:21:14,160
Os números aqui você vê que nós temos tudo

13957
09:21:14,160 --> 09:21:17,276
os elementos se tirarmos alguns de

13958
09:21:17,276 --> 09:21:19,596
Esses elementos vamos tirar alguns dos

13959
09:21:19,596 --> 09:21:22,080
Estes vamos deixá-lo até sete ou

13960
09:21:22,080 --> 09:21:22,960
Oito

13961
09:21:22,960 --> 09:21:25,596
Vamos construir de novo e nós vamos

13962
09:21:25,596 --> 09:21:28,000
clear e run galo que vamos conseguir

13963
09:21:28,000 --> 09:21:30,400
No entanto, muitos elementos que temos lá

13964
09:21:30,400 --> 09:21:33,200
E isso é muito legal novamente você pode

13965
09:21:33,200 --> 09:21:35,840
Pergunte como fizemos as coisas antes de c plus

13966
09:21:35,840 --> 09:21:39,916
mais 17 porque o tamanho do std foi introduzido

13967
09:21:39,916 --> 09:21:42,960
em c mais mais 17 vamos dizer que aqui

13968
09:21:42,960 --> 09:21:46,240
Antes disso, tivemos que obter o tamanho de

13969
09:21:46,240 --> 09:21:49,756
Toda a matriz e dividir isso com

13970
09:21:49,756 --> 09:21:52,480
o tamanho de cada elemento na matriz

13971
09:21:52,480 --> 09:21:55,120
e nós poderíamos usar o tamanho do operador para

13972
09:21:55,120 --> 09:21:58,400
fazer isso, então antes de fazermos isso

13973
09:21:58,400 --> 09:22:00,960
Quer jogar com o tamanho do método para

13974
09:22:00,960 --> 09:22:02,800
realmente te mostrar o que ele faz

13975
09:22:02,800 --> 09:22:05,520
Então o que vamos fazer é dizer

13976
09:22:05,520 --> 09:22:08,480
fora do tamanho de

13977
09:22:08,480 --> 09:22:11,120
marca toda a matriz e estamos indo

13978
09:22:11,120 --> 09:22:13,120
para imprimir isso e nós vamos dizer

13979
09:22:13,120 --> 09:22:15,436
o esddcl

13980
09:22:15,436 --> 09:22:17,200
Tamanho de

13981
09:22:17,200 --> 09:22:20,840
Você conhece um elemento, digamos

13982
09:22:20,840 --> 09:22:24,480
pontuações e usar o primeiro elemento deste é

13983
09:22:24,480 --> 09:22:27,200
A coisa mais fácil que podemos encontrar aqui, mas

13984
09:22:27,200 --> 09:22:29,040
você pode usar qualquer elemento para que possamos

13985
09:22:29,040 --> 09:22:31,360
para dizer o tamanho daqui e nós vamos

13986
09:22:31,360 --> 09:22:34,560
Diga pontuações e pegue o primeiro elemento

13987
09:22:34,560 --> 09:22:36,880
que está no índice 0 e nós vamos

13988
09:22:36,880 --> 09:22:39,360
imprimir seu tamanho se construirmos e executarmos isso

13989
09:22:39,360 --> 09:22:40,880
O programa

13990
09:22:40,880 --> 09:22:43,520
Nós vamos construir e correr

13991
09:22:43,520 --> 09:22:46,400
E o mundo é bom, podemos limpar agora

13992
09:22:46,400 --> 09:22:48,560
e correr galo você vai ver que

13993
09:22:48,560 --> 09:22:51,596
nós vamos obter o tamanho das pontuações é 32

13994
09:22:51,596 --> 09:22:54,640
Todo o array do tamanho de um elemento

13995
09:22:54,640 --> 09:22:56,560
são quatro porque estamos armazenando em

13996
09:22:56,560 --> 09:23:00,080
inteiros e eu quero que você veja que 32

13997
09:23:00,080 --> 09:23:03,120
é quatro vezes oito porque temos um

13998
09:23:03,120 --> 09:23:05,436
oito elementos, então ele vai te dar

13999
09:23:05,436 --> 09:23:08,320
O tamanho combinado de todos os elementos

14000
09:23:08,320 --> 09:23:11,200
que temos aqui se você fizer o tamanho de

14001
09:23:11,200 --> 09:23:12,560
um array

14002
09:23:12,560 --> 09:23:14,880
mas se você fizer o tamanho de um único elemento

14003
09:23:14,880 --> 09:23:16,640
Você vai ter o tamanho de um único

14004
09:23:16,640 --> 09:23:19,200
Elemento assim c plus desenvolvedores foram

14005
09:23:19,200 --> 09:23:21,596
Inteligente o suficiente para ver isso

14006
09:23:21,596 --> 09:23:23,756
e ver que poderíamos usar isso

14007
09:23:23,756 --> 09:23:25,596
informações e obter a contagem de

14008
09:23:25,596 --> 09:23:28,240
Elementos dentro para que possamos fazer algo

14009
09:23:28,240 --> 09:23:30,240
Como uma conta de formi

14010
09:23:30,240 --> 09:23:32,960
e vamos atribuir um valor a

14011
09:23:32,960 --> 09:23:33,756
Isto é

14012
09:23:33,756 --> 09:23:36,240
em nosso inicializador braced, então estamos indo

14013
09:23:36,240 --> 09:23:37,840
para dizer o tamanho

14014
09:23:37,840 --> 09:23:38,880
de

14015
09:23:38,880 --> 09:23:41,040
nós vamos dizer pontuações

14016
09:23:41,040 --> 09:23:43,756
E nós vamos dividir isso com o tamanho

14017
09:23:43,756 --> 09:23:46,720
de e eu vou pegar pontuações que podemos

14018
09:23:46,720 --> 09:23:49,120
realmente usar qualquer elemento na matriz, mas

14019
09:23:49,120 --> 09:23:51,680
nós vamos pegar o do índice 0

14020
09:23:51,680 --> 09:23:53,360
E agora vamos ter a contagem

14021
09:23:53,360 --> 09:23:55,840
armazenado em nossa variável de conta sem

14022
09:23:55,840 --> 09:23:59,520
usando std tamanho e podemos descomentar o nosso

14023
09:23:59,520 --> 09:24:00,880
Array aqui

14024
09:24:00,880 --> 09:24:03,520
ou o código para imprimir o array e se nós

14025
09:24:03,520 --> 09:24:05,360
correr agora que vai funcionar exatamente o

14026
09:24:05,360 --> 09:24:07,680
A mesma coisa, independentemente da quantidade de

14027
09:24:07,680 --> 09:24:10,320
Elementos que você tem aqui vamos colocar um

14028
09:24:10,320 --> 09:24:13,916
poucos números aleatoriamente e se nós vamos, então

14029
09:24:13,916 --> 09:24:16,640
correr, vamos limpar e correr

14030
09:24:16,640 --> 09:24:18,720
Galo e nós vamos ter tudo

14031
09:24:18,720 --> 09:24:20,640
Os elementos aqui e

14032
09:24:20,640 --> 09:24:22,480
você pode realmente usar qualquer um destes

14033
09:24:22,480 --> 09:24:24,720
Técnicas apenas escolhem o que você sente

14034
09:24:24,720 --> 09:24:27,840
funciona melhor para você, estamos indo

14035
09:24:27,840 --> 09:24:30,080
através de todo esse problema para criar um

14036
09:24:30,080 --> 09:24:32,240
iterador vamos fazer o teste

14037
09:24:32,240 --> 09:24:34,160
nós vamos incrementar isso é realmente

14038
09:24:34,160 --> 09:24:37,596
muito trabalho para tentar obter dados de um

14039
09:24:37,596 --> 09:24:40,320
coleção como um array para que possamos

14040
09:24:40,320 --> 09:24:43,520
Em vez disso, é comentar tudo isso difícil

14041
09:24:43,520 --> 09:24:44,800
trabalhar aqui

14042
09:24:44,800 --> 09:24:47,436
e nós podemos usar um ranged baseado para loop

14043
09:24:47,436 --> 09:24:49,200
Como já vimos antes e é

14044
09:24:49,200 --> 09:24:52,240
ridiculamente fácil e conveniente para trabalhar

14045
09:24:52,240 --> 09:24:55,200
O que você pode fazer é dizer

14046
09:24:55,200 --> 09:24:57,436
Carro eu vamos fazer

14047
09:24:57,436 --> 09:24:59,756
tipo dedução sobre o que quer que seja que temos

14048
09:24:59,756 --> 09:25:02,160
armazenado em nossa matriz para que possamos

14049
09:25:02,160 --> 09:25:04,400
Coloque uma coluna e diga pontuações

14050
09:25:04,400 --> 09:25:07,120
e vamos imprimir o elemento

14051
09:25:07,120 --> 09:25:10,720
então vamos fazer isso, vamos imprimir

14052
09:25:10,720 --> 09:25:14,000
stdcl e aqui vamos dizer valor

14053
09:25:14,000 --> 09:25:16,480
Vamos dizer valor na matriz e nós somos

14054
09:25:16,480 --> 09:25:17,756
Vou dizer que

14055
09:25:17,756 --> 09:25:20,000
Eu e isso vai imprimir tudo

14056
09:25:20,000 --> 09:25:22,560
Elementos e podemos trabalhar com os valores

14057
09:25:22,560 --> 09:25:25,120
Se queremos isso, mas você vê isso

14058
09:25:25,120 --> 09:25:27,520
Perdemos a informação

14059
09:25:27,520 --> 09:25:29,840
nos índices, por isso, se você realmente precisa do

14060
09:25:29,840 --> 09:25:32,320
índices que você precisará passar

14061
09:25:32,320 --> 09:25:34,800
Algo assim e se você só precisa

14062
09:25:34,800 --> 09:25:38,160
os valores na matriz variada baseada para

14063
09:25:38,160 --> 09:25:40,080
loops vão ser muito legais, vamos

14064
09:25:40,080 --> 09:25:42,320
Diga base de alcance para loop e se fervemos

14065
09:25:42,320 --> 09:25:44,320
e correr isso vai funcionar bonito

14066
09:25:44,320 --> 09:25:45,200
Bem

14067
09:25:45,200 --> 09:25:47,840
Assim, o mundo vai passar

14068
09:25:47,840 --> 09:25:50,480
Vamos trazer isso para que tenhamos alguns

14069
09:25:50,480 --> 09:25:53,120
sala de respiração, vamos limpar

14070
09:25:53,120 --> 09:25:55,120
e correr o galo

14071
09:25:55,120 --> 09:25:56,800
e nós vamos ter nossos elementos

14072
09:25:56,800 --> 09:25:58,720
impresso aqui e você vê que é

14073
09:25:58,720 --> 09:26:01,120
A mesma coisa que temos em pontuações

14074
09:26:01,120 --> 09:26:01,916
aqui

14075
09:26:01,916 --> 09:26:03,840
então isso é realmente tudo o que nos iam fazer

14076
09:26:03,840 --> 09:26:05,840
Nesta palestra eu só queria que você fosse

14077
09:26:05,840 --> 09:26:08,800
Consciente do tamanho do sdd

14078
09:26:08,800 --> 09:26:11,276
facilidade que temos no c plus mais

14079
09:26:11,276 --> 09:26:13,360
biblioteca padrão se você não quiser

14080
09:26:13,360 --> 09:26:16,000
usá-lo por qualquer motivo que você também pode entrar

14081
09:26:16,000 --> 09:26:18,560
e fazer a divisão que fizemos aqui para obter

14082
09:26:18,560 --> 09:26:21,840
contagem de elementos na matriz

14083
09:26:21,840 --> 09:26:24,800
E uh fazer o seu melhor para tentar usar

14084
09:26:24,800 --> 09:26:27,120
base variada para loops porque eles fazem

14085
09:26:27,120 --> 09:26:30,160
mais fácil e mais limpo obter dados de um

14086
09:26:30,160 --> 09:26:32,800
Coleção como estamos fazendo aqui com

14087
09:26:32,800 --> 09:26:35,520
uma matriz que vamos parar por aqui

14088
09:26:35,520 --> 09:26:37,120
Esta palestra e a próxima que somos

14089
09:26:37,120 --> 09:26:39,520
Vou ver como podemos trabalhar com arrays

14090
09:26:39,520 --> 09:26:41,276
dos personagens

14091
09:26:41,276 --> 09:26:43,596
Vá em frente e termine aqui e me encontre

14092
09:26:43,596 --> 09:26:45,120
lá

14093
09:26:45,120 --> 09:26:47,120
Nesta palestra vamos trabalhar

14094
09:26:47,120 --> 09:26:49,520
variedade de personagens e mostrar como especial

14095
09:26:49,520 --> 09:26:50,480
Eles são

14096
09:26:50,480 --> 09:26:53,120
Você pode declarar uma matriz de caracteres

14097
09:26:53,120 --> 09:26:55,276
assim como qualquer outro array, então aqui nós

14098
09:26:55,276 --> 09:26:56,400


14099
09:26:56,400 --> 09:26:58,640
um array chamado mensagem que armazena

14100
09:26:58,640 --> 09:27:01,360
elementos do tipo de caráter o tamanho é

14101
09:27:01,360 --> 09:27:04,240
cinco e nós inicializamos com um monte

14102
09:27:04,240 --> 09:27:05,520
dos personagens

14103
09:27:05,520 --> 09:27:07,756
Se quisermos imprimi-lo, podemos olhar

14104
09:27:07,756 --> 09:27:10,640
como nós fazemos loop através de qualquer outro array em

14105
09:27:10,640 --> 09:27:12,480
Este caso, vamos usar um

14106
09:27:12,480 --> 09:27:15,520
base variada para loop, dizemos para auto c

14107
09:27:15,520 --> 09:27:17,276
Passamos a mensagem e depois vamos

14108
09:27:17,276 --> 09:27:19,596
imprimir cada personagem no

14109
09:27:19,596 --> 09:27:21,680
mensagem e se fizermos isso, vamos

14110
09:27:21,680 --> 09:27:24,000
ver olá impresso no console

14111
09:27:24,000 --> 09:27:27,040
também pode modificar elementos em nossa matriz

14112
09:27:27,040 --> 09:27:29,200
Por exemplo, podemos dizer mensagem1 e

14113
09:27:29,200 --> 09:27:31,596
mudar o e aqui para um

14114
09:27:31,596 --> 09:27:33,840
E se imprimirmos, devemos ver olá

14115
09:27:33,840 --> 09:27:36,000
impresso no console nada

14116
09:27:36,000 --> 09:27:38,880
realmente especial até agora a coisa legal que você

14117
09:27:38,880 --> 09:27:41,596
pode fazer com arrays de caracteres

14118
09:27:41,596 --> 09:27:43,276
é que você pode imprimi-los para o

14119
09:27:43,276 --> 09:27:45,596
console diretamente sem fazer o

14120
09:27:45,596 --> 09:27:47,596
loop você pode fazer algo assim você

14121
09:27:47,596 --> 09:27:50,160
pode fazer esddc para fora você dizer o que quer que você

14122
09:27:50,160 --> 09:27:52,240
Quero fazer em citações aqui e você está

14123
09:27:52,240 --> 09:27:54,640
Vou imprimir a mensagem, mas às vezes

14124
09:27:54,640 --> 09:27:57,596
Este é fazer o que você espera, porque

14125
09:27:57,596 --> 09:28:01,276
Somente as strings c apropriadas podem ser impressas

14126
09:28:01,276 --> 09:28:04,560
O console e o que compõe um c adequado

14127
09:28:04,560 --> 09:28:07,840
string a correcto c string tem esta coisa

14128
09:28:07,840 --> 09:28:10,480
você vê no final aqui esta barragem

14129
09:28:10,480 --> 09:28:11,436
zero

14130
09:28:11,436 --> 09:28:14,400
é chamado de uma string de terminação nula e

14131
09:28:14,400 --> 09:28:16,480
é o que vai dizer c plus plus

14132
09:28:16,480 --> 09:28:19,040
que nós atingimos o final da corda

14133
09:28:19,040 --> 09:28:21,276
e nós vamos parar de imprimi-lo se

14134
09:28:21,276 --> 09:28:24,240
estamos imprimindo com coisas como stdcl

14135
09:28:24,240 --> 09:28:26,800
Então isso é realmente importante para estar em

14136
09:28:26,800 --> 09:28:29,360
Sua força se não estiver lá pode

14137
09:28:29,360 --> 09:28:31,520
trabalho, mas às vezes também vai

14138
09:28:31,520 --> 09:28:34,240
imprimir alguns caracteres de lixo depois disso

14139
09:28:34,240 --> 09:28:37,596
Porque o que diz ao esddc que temos

14140
09:28:37,596 --> 09:28:39,840
Chegar ao fim da corda é este

14141
09:28:39,840 --> 09:28:42,320
backslash zero aqui se não estiver lá

14142
09:28:42,320 --> 09:28:44,240
Vai continuar imprimindo até

14143
09:28:44,240 --> 09:28:46,480
vê um e então você vai

14144
09:28:46,480 --> 09:28:48,720
Provavelmente tem alguns personagens de lixo

14145
09:28:48,720 --> 09:28:51,120
adicionado à sua corda e isso não é o que

14146
09:28:51,120 --> 09:28:53,040
Você quer ter seus pontos fortes

14147
09:28:53,040 --> 09:28:56,080
impressos corretamente, certifique-se de ter em

14148
09:28:56,080 --> 09:28:58,720
este personagem nulo de terminação aqui e

14149
09:28:58,720 --> 09:29:00,400
Se o imprimirmos, vamos pesá-lo

14150
09:29:00,400 --> 09:29:02,000
e vamos ver o tamanho impresso

14151
09:29:02,000 --> 09:29:05,120
fora corretamente se fizermos coisas assim

14152
09:29:05,120 --> 09:29:07,840
mas é possível chegar a este carro

14153
09:29:07,840 --> 09:29:10,000
campo para nós, se você olhar aqui nós temos um

14154
09:29:10,000 --> 09:29:12,960
matriz de caracteres chamada message2 dentro

14155
09:29:12,960 --> 09:29:15,680
Nós dissemos que precisamos de seis elementos

14156
09:29:15,680 --> 09:29:18,400
e nós dizemos olá, então temos um dois

14157
09:29:18,400 --> 09:29:20,880
Três quatro cinco elementos e o

14158
09:29:20,880 --> 09:29:24,000
Os elementos que não inicializamos corretamente são

14159
09:29:24,000 --> 09:29:26,640
será inicializado com um zero

14160
09:29:26,640 --> 09:29:28,960
versão de um personagem e isso acontece

14161
09:29:28,960 --> 09:29:31,756
ser o terminador nulo do nulo

14162
09:29:31,756 --> 09:29:34,320
personagem de rescisão, então isso está indo

14163
09:29:34,320 --> 09:29:36,000
para imprimir corretamente e nós vamos

14164
09:29:36,000 --> 09:29:37,596
Se você

14165
09:29:37,596 --> 09:29:40,720
backslash n anexado a isso para nós por

14166
09:29:40,720 --> 09:29:42,960
O compilador, mas certifique-se de entender

14167
09:29:42,960 --> 09:29:45,756
A diferença entre isto e este

14168
09:29:45,756 --> 09:29:48,240
Aqui nós especificamos o tamanho para ser um

14169
09:29:48,240 --> 09:29:50,960
5 e estamos colocando em cinco elementos assim

14170
09:29:50,960 --> 09:29:53,360
Nós não temos nenhum personagem nulo anexado a

14171
09:29:53,360 --> 09:29:55,596
Esta corda mas aqui já dissemos que

14172
09:29:55,596 --> 09:29:58,400
Podemos colocar seis elementos e temos

14173
09:29:58,400 --> 09:30:01,680
Coloque apenas cinco e o compilador está indo

14174
09:30:01,680 --> 09:30:05,120
para preencher automaticamente o término nulo

14175
09:30:05,120 --> 09:30:07,200
Personagem dessas duas coisas são diferentes

14176
09:30:07,200 --> 09:30:08,560
e certifique-se de entender o

14177
09:30:08,560 --> 09:30:11,040
diferença ok, então agora dê uma olhada

14178
09:30:11,040 --> 09:30:13,436
O que temos aqui temos uma vertente nós

14179
09:30:13,436 --> 09:30:15,916
não especificou o tamanho e apenas

14180
09:30:15,916 --> 09:30:18,640
inicializá-lo com olá alguém pode

14181
09:30:18,640 --> 09:30:20,640
Pense em ah isso também vai preencher automaticamente

14182
09:30:20,640 --> 09:30:23,040
mas não é porque o compilador é

14183
09:30:23,040 --> 09:30:25,756
indo para deduzir o tamanho deste array

14184
09:30:25,756 --> 09:30:28,240
usando o que você inicializa com e

14185
09:30:28,240 --> 09:30:30,560
Você não colocou um personagem nulo, então

14186
09:30:30,560 --> 09:30:32,080
Não vai ser contabilizado

14187
09:30:32,080 --> 09:30:34,240
Você só vai ter isso aqui e

14188
09:30:34,240 --> 09:30:36,480
Se você imprimir isso, você pode obter

14189
09:30:36,480 --> 09:30:38,560
caracteres de lixo anexados ao seu

14190
09:30:38,560 --> 09:30:40,800
string aqui, então tenha cuidado, mas é

14191
09:30:40,800 --> 09:30:44,000
Possível fazer strings c literais e

14192
09:30:44,000 --> 09:30:47,040
Apenas diga olá assim em citações e

14193
09:30:47,040 --> 09:30:49,276
você vai ter o fim nulo

14194
09:30:49,276 --> 09:30:52,480
personagem anexado à sua string aqui

14195
09:30:52,480 --> 09:30:54,320
então, se imprimirmos isso, isso vai

14196
09:30:54,320 --> 09:30:56,720
muito bem e este é o

14197
09:30:56,720 --> 09:30:58,960
maneira recomendada de inicializar seu

14198
09:30:58,960 --> 09:31:01,680
arrays de caracteres se você quiser colocar

14199
09:31:01,680 --> 09:31:04,880
dados de string como este que você tem que usar

14200
09:31:04,880 --> 09:31:06,960
Citações duplas e a coisa legal sobre

14201
09:31:06,960 --> 09:31:09,360
Isto é que você pode até mesmo colocar em

14202
09:31:09,360 --> 09:31:11,520
espaços entre palavras como esta é

14203
09:31:11,520 --> 09:31:13,916
indo para trabalhar isso realmente parece como

14204
09:31:13,916 --> 09:31:16,640
você gostaria de digitar texto e armazenar

14205
09:31:16,640 --> 09:31:19,596
Isso em suas matrizes de personagens e nós somos

14206
09:31:19,596 --> 09:31:21,360
Vou usar isso muito no

14207
09:31:21,360 --> 09:31:23,120
curso novamente eu quero trazer para o seu

14208
09:31:23,120 --> 09:31:25,520
atenção que os arrays de personagens são

14209
09:31:25,520 --> 09:31:26,640
Especial

14210
09:31:26,640 --> 09:31:29,276
em que você pode imprimi-los diretamente

14211
09:31:29,276 --> 09:31:30,480
O console

14212
09:31:30,480 --> 09:31:32,240
Como estamos fazendo aqui você vê que este é um

14213
09:31:32,240 --> 09:31:35,436
matriz de caracteres e estamos dizendo stdc

14214
09:31:35,436 --> 09:31:38,080
para que você não possa fazer isso com

14215
09:31:38,080 --> 09:31:40,880
outros arrays e isso é realmente tudo que eu

14216
09:31:40,880 --> 09:31:43,840
tinha que compartilhar sobre arrays de personagens, então

14217
09:31:43,840 --> 09:31:45,840
O que vamos fazer a seguir é ir

14218
09:31:45,840 --> 09:31:48,160
código de estúdio visual e jogar com a gente bem

14219
09:31:48,160 --> 09:31:51,276
Aqui estamos em nosso diretório de trabalho o

14220
09:31:51,276 --> 09:31:54,400
O projeto atual é matrizes de caracteres

14221
09:31:54,400 --> 09:31:57,360
Vamos pegar nosso projeto de modelo

14222
09:31:57,360 --> 09:31:59,276
e vamos copiar os arquivos

14223
09:31:59,276 --> 09:32:01,916
Tragam-nos para cá

14224
09:32:01,916 --> 09:32:04,720
e vamos abrir a nossa pasta

14225
09:32:04,720 --> 09:32:06,880
nós vamos abrir o arquivo cpp principal

14226
09:32:06,880 --> 09:32:08,560
E nós vamos nos livrar do que nós

14227
09:32:08,560 --> 09:32:10,640
Não preciso aqui vamos colocar alguns

14228
09:32:10,640 --> 09:32:12,480
código de inicialização para que possamos começar

14229
09:32:12,480 --> 09:32:14,400
brincando com isso sem digitar isso

14230
09:32:14,400 --> 09:32:16,720
Demasio para que vamos declarar um

14231
09:32:16,720 --> 09:32:18,960
variedade de personagens que vai ser

14232
09:32:18,960 --> 09:32:20,880
chamada mensagem, o tamanho vai ser

14233
09:32:20,880 --> 09:32:22,800
Cinco e nós vamos preencher com

14234
09:32:22,800 --> 09:32:25,040
personagens como este, então se fizermos isso, nós

14235
09:32:25,040 --> 09:32:27,756
pode querer imprimi-lo como nós imprimimos qualquer

14236
09:32:27,756 --> 09:32:30,400
outro array que vamos usar loops e

14237
09:32:30,400 --> 09:32:32,720
Neste caso, optamos por usar

14238
09:32:32,720 --> 09:32:35,200
uma base de gama para loop por isso tomamos um brinde

14239
09:32:35,200 --> 09:32:37,120
c c para o carácter

14240
09:32:37,120 --> 09:32:39,276
na mensagem e vamos imprimir

14241
09:32:39,276 --> 09:32:41,276
Cada personagem percebe que não somos

14242
09:32:41,276 --> 09:32:44,880
adicionando std endl aqui porque nós queremos o

14243
09:32:44,880 --> 09:32:47,360
Personagens impressos próximos uns dos outros

14244
09:32:47,360 --> 09:32:49,916
para que possamos ler isso com facilidade e

14245
09:32:49,916 --> 09:32:51,840
Depois disso, precisaremos ir para o

14246
09:32:51,840 --> 09:32:53,520
a próxima linha para que a próxima coisa

14247
09:32:53,520 --> 09:32:55,840
A impressão não nos incomoda, então vamos

14248
09:32:55,840 --> 09:32:59,916
para dizer sddc fora std endl e se o fizermos

14249
09:32:59,916 --> 09:33:01,916
Isso nós vamos ver olá impresso

14250
09:33:01,916 --> 09:33:04,400
fora no console, mas nós tivemos que fazer também

14251
09:33:04,400 --> 09:33:07,040
Muito trabalho para imprimir algo simples

14252
09:33:07,040 --> 09:33:09,360
como olá, mas vamos fazer isso nós somos

14253
09:33:09,360 --> 09:33:10,320
Aprendizagem

14254
09:33:10,320 --> 09:33:12,800
Vamos trazer o nosso terminal

14255
09:33:12,800 --> 09:33:15,360
e nós vamos construir com gcc vamos

14256
09:33:15,360 --> 09:33:16,960
- Faz isso.

14257
09:33:16,960 --> 09:33:19,040
O mundo vai passar e

14258
09:33:19,040 --> 09:33:20,400
nós vamos limpar

14259
09:33:20,400 --> 09:33:22,480
e correr galo você vai ver que

14260
09:33:22,480 --> 09:33:24,240
vai dizer que mensagem é olá e

14261
09:33:24,240 --> 09:33:26,080
Isto é o que esperamos e isto é

14262
09:33:26,080 --> 09:33:28,480
realmente como você declararia uma série de

14263
09:33:28,480 --> 09:33:30,560
Personagens e inicializá-lo com

14264
09:33:30,560 --> 09:33:32,480
Seja o que for que você queira inicializá-lo

14265
09:33:32,480 --> 09:33:34,720
com mas você percebe que não é realmente

14266
09:33:34,720 --> 09:33:37,916
É conveniente colocar dados aqui se você

14267
09:33:37,916 --> 09:33:40,960
Quero armazenar uma mensagem, por exemplo,

14268
09:33:40,960 --> 09:33:43,840
Alguém que você não quer fazer essa coisa

14269
09:33:43,840 --> 09:33:45,520
Você vê aqui que é realmente feio é

14270
09:33:45,520 --> 09:33:48,000
conveniente e ninguém definitivamente

14271
09:33:48,000 --> 09:33:50,880
use seu programa se você precisar

14272
09:33:50,880 --> 09:33:53,200
usuários para digitar coisas assim, então nós

14273
09:33:53,200 --> 09:33:55,596
precisamos mudar isso e nós vamos, mas

14274
09:33:55,596 --> 09:33:57,756
Antes de chegarmos lá, vamos também ver que

14275
09:33:57,756 --> 09:34:00,640
nós podemos mudar os personagens em nossa matriz assim

14276
09:34:00,640 --> 09:34:03,520
Se você olhar aqui este e aqui está no índice

14277
09:34:03,520 --> 09:34:07,120
O que podemos dizer é uma mensagem e

14278
09:34:07,120 --> 09:34:10,080
uh nós vamos direcionar o elemento em

14279
09:34:10,080 --> 09:34:11,040
o índice

14280
09:34:11,040 --> 09:34:13,680
dois oh é o índice um

14281
09:34:13,680 --> 09:34:16,240
Vamos usar isso para que este seja o índice zero

14282
09:34:16,240 --> 09:34:19,360
h e e está no índice um vamos fazer

14283
09:34:19,360 --> 09:34:21,520
Temos certeza que nós temos isso direito e nós estamos

14284
09:34:21,520 --> 09:34:23,596
indo para armazenar em um

14285
09:34:23,596 --> 09:34:27,120
em citações, lembre-se que os personagens são

14286
09:34:27,120 --> 09:34:29,840
Cercado por citações individuais como esta

14287
09:34:29,840 --> 09:34:32,720
uma vez que fazemos isso e tentamos imprimir o

14288
09:34:32,720 --> 09:34:35,680
array fora novamente usando o nosso

14289
09:34:35,680 --> 09:34:37,520
técnica aqui vamos copiar o

14290
09:34:37,520 --> 09:34:39,520
código e vamos colar para baixo

14291
09:34:39,520 --> 09:34:40,320
aqui

14292
09:34:40,320 --> 09:34:42,800
Só para fazer isso simplesmente

14293
09:34:42,800 --> 09:34:45,436
E se fizermos isso, vamos ver o

14294
09:34:45,436 --> 09:34:48,880
mensagem impressa aqui para ser olá

14295
09:34:48,880 --> 09:34:50,800
E a segunda mensagem vai ser

14296
09:34:50,800 --> 09:34:53,040
Olá com um

14297
09:34:53,040 --> 09:34:56,160
Porque nós mudamos o segundo elemento

14298
09:34:56,160 --> 09:34:58,800
para um a não é mais um e assim que

14299
09:34:58,800 --> 09:35:00,960
O que esperamos que vamos correr o

14300
09:35:00,960 --> 09:35:03,840
teste para construir com gcc e vamos

14301
09:35:03,840 --> 09:35:06,080
para trazer isso para cima e claro e nós somos

14302
09:35:06,080 --> 09:35:07,916
indo para correr galo você vê que nós

14303
09:35:07,916 --> 09:35:11,120
ter mensagem Olá e mensagem Olá e

14304
09:35:11,120 --> 09:35:13,596
Somos capazes de imprimir as coisas com sucesso

14305
09:35:13,596 --> 09:35:16,000
Isso é muito legal, mas estamos fazendo também

14306
09:35:16,000 --> 09:35:18,800
Muito trabalho realmente para imprimir algo

14307
09:35:18,800 --> 09:35:20,640
O console e deve haver um

14308
09:35:20,640 --> 09:35:23,276
maneira mais fácil de fazer isso e há assim

14309
09:35:23,276 --> 09:35:25,520
O que vamos fazer é comentar isso

14310
09:35:25,520 --> 09:35:28,080
porque não queremos saída de ruído

14311
09:35:28,080 --> 09:35:30,240
no console quando tentamos fazer

14312
09:35:30,240 --> 09:35:31,756
Algo mais

14313
09:35:31,756 --> 09:35:34,160
Então, o que vamos fazer é comentar

14314
09:35:34,160 --> 09:35:35,840
Tudo o que fizemos até agora, vamos

14315
09:35:35,840 --> 09:35:38,240
Deixe na nossa mensagem aqui e estamos

14316
09:35:38,240 --> 09:35:40,560
Vou tentar imprimi-lo diretamente em

14317
09:35:40,560 --> 09:35:44,000
O console para que possamos dizer sddcl

14318
09:35:44,000 --> 09:35:46,160
e dizer a mensagem

14319
09:35:46,160 --> 09:35:48,720
e vamos imprimir a mensagem

14320
09:35:48,720 --> 09:35:51,520
e tome um momento e olhe para isso

14321
09:35:51,520 --> 09:35:54,480
e tentar compilar isso vai

14322
09:35:54,480 --> 09:35:56,560
passar por isso vai compilar

14323
09:35:56,560 --> 09:35:58,720
porque c mais mais

14324
09:35:58,720 --> 09:36:01,756
suporta matrizes de caracteres de impressão como

14325
09:36:01,756 --> 09:36:02,560
Isto é

14326
09:36:02,560 --> 09:36:03,916
Mas uh

14327
09:36:03,916 --> 09:36:05,756
Na maioria das vezes isso não vai fazer

14328
09:36:05,756 --> 09:36:09,120
O que você espera, vamos tentar correr isso

14329
09:36:09,120 --> 09:36:11,360
e ver o que nós temos

14330
09:36:11,360 --> 09:36:13,200
nós vamos correr o galo

14331
09:36:13,200 --> 09:36:14,800
E você vê que

14332
09:36:14,800 --> 09:36:17,276
Temos sorte de conseguir algo que realmente

14333
09:36:17,276 --> 09:36:19,120
Não é o que nós esperamos

14334
09:36:19,120 --> 09:36:21,360
É lindo olá e você vê que nós

14335
09:36:21,360 --> 09:36:23,520
Tenho um monte de outras coisas e

14336
09:36:23,520 --> 09:36:25,840
A razão é o que temos discutido em

14337
09:36:25,840 --> 09:36:28,880
esses slides para matrizes de caracteres como

14338
09:36:28,880 --> 09:36:31,436
Isso deve ser impresso corretamente

14339
09:36:31,436 --> 09:36:34,400
no console, eles precisam ser nulos

14340
09:36:34,400 --> 09:36:36,880
encerrados em outras palavras, eles precisam

14341
09:36:36,880 --> 09:36:39,360
ter o caráter nulo que é um

14342
09:36:39,360 --> 09:36:42,240
backslash zero anexado à string

14343
09:36:42,240 --> 09:36:45,680
para sddc para fora para saber que ele chegou

14344
09:36:45,680 --> 09:36:47,756
o fim da corda, então isso é o que

14345
09:36:47,756 --> 09:36:51,276
torna suas cadeias de caracteres legais

14346
09:36:51,276 --> 09:36:52,720
Agora você vê que estamos recebendo um

14347
09:36:52,720 --> 09:36:55,360
Erro do compilador porque nós temos overflown

14348
09:36:55,360 --> 09:36:57,840
o tamanho da matriz eu acho que é a

14349
09:36:57,840 --> 09:36:59,840
enviar muitos valores inicializadores e

14350
09:36:59,840 --> 09:37:02,240
Isto é exatamente o que nós fizemos

14351
09:37:02,240 --> 09:37:05,120
Agora podemos tentar mudar esse cara para um

14352
09:37:05,120 --> 09:37:07,840
Seis para dizer que temos seis elementos em

14353
09:37:07,840 --> 09:37:08,640
aqui

14354
09:37:08,640 --> 09:37:11,120
esta linha wiggly deve ir embora e se

14355
09:37:11,120 --> 09:37:13,276
Tentamos construir e correr

14356
09:37:13,276 --> 09:37:15,840
Vamos construir com gcc

14357
09:37:15,840 --> 09:37:18,480
vamos trazer isso um pouco e

14358
09:37:18,480 --> 09:37:20,080
nós vamos limpar

14359
09:37:20,080 --> 09:37:22,400
e correr o galo agora

14360
09:37:22,400 --> 09:37:24,000
E você vê que agora temos olá

14361
09:37:24,000 --> 09:37:26,720
impresso corretamente se virarmos isso

14362
09:37:26,720 --> 09:37:29,360
de volta a cinco elementos

14363
09:37:29,360 --> 09:37:33,120
e tirar o terminador nulo

14364
09:37:33,120 --> 09:37:35,276
Vamos tentar construir de novo e

14365
09:37:35,276 --> 09:37:37,840
nós vamos limpar e correr o galo

14366
09:37:37,840 --> 09:37:39,120
você vai ver que nós temos o

14367
09:37:39,120 --> 09:37:41,756
lixo de volta para que suas cordas sejam

14368
09:37:41,756 --> 09:37:44,560
impressos corretamente, eles precisam ser

14369
09:37:44,560 --> 09:37:48,000
Agora terminado é por isso que não é seguro

14370
09:37:48,000 --> 09:37:50,640
para jogar algo assim

14371
09:37:50,640 --> 09:37:53,596
quando sua matriz de personagens não é agora

14372
09:37:53,596 --> 09:37:55,276
terminado eu realmente quero que você

14373
09:37:55,276 --> 09:37:58,000
Entenda isso assim em c plus plus

14374
09:37:58,000 --> 09:38:00,960
ter um nome próprio para essas cordas

14375
09:38:00,960 --> 09:38:03,436
que são null terminado um null

14376
09:38:03,436 --> 09:38:05,756
Corda terminada é chamada de string c

14377
09:38:05,756 --> 09:38:07,916
Porque essas coisas vêm do c

14378
09:38:07,916 --> 09:38:09,756
Linguagem de programação está bem e nós somos

14379
09:38:09,756 --> 09:38:11,916
Vou ver algumas maneiras de configurar c

14380
09:38:11,916 --> 09:38:15,360
strings agora e a primeira é dizer

14381
09:38:15,360 --> 09:38:18,480
Carro podemos chamar essa mensagem de um

14382
09:38:18,480 --> 09:38:20,080
E vai ser uma matriz de

14383
09:38:20,080 --> 09:38:22,240
Personagens e vamos inicializar

14384
09:38:22,240 --> 09:38:24,400
Isso com olá vamos copiar isso porque

14385
09:38:24,400 --> 09:38:26,720
Eu não quero digitar tudo isso

14386
09:38:26,720 --> 09:38:29,756
Coisas aqui então vamos copiar isso

14387
09:38:29,756 --> 09:38:31,916
e inicialize isso corretamente observe que

14388
09:38:31,916 --> 09:38:33,916
não especificamos o tamanho, então o

14389
09:38:33,916 --> 09:38:36,160
O compilador vai obter o tamanho de

14390
09:38:36,160 --> 09:38:38,640
No entanto, muitos elementos que colocamos aqui e

14391
09:38:38,640 --> 09:38:41,120
nós vamos colocar em nosso nulo

14392
09:38:41,120 --> 09:38:43,360
terminator aqui e se imprimirmos isso

14393
09:38:43,360 --> 09:38:46,160
Isso vai funcionar e nós vamos

14394
09:38:46,160 --> 09:38:48,240
para comentar isso e eu vou dizer

14395
09:38:48,240 --> 09:38:50,880
que isso lhe dará lixo bem se

14396
09:38:50,880 --> 09:38:52,160
nós descemos aqui, vamos ver

14397
09:38:52,160 --> 09:38:55,040
que temos uma matriz de carros que é chamada

14398
09:38:55,040 --> 09:38:57,916
message1 e nós inicializamos com

14399
09:38:57,916 --> 09:39:00,720
dados que temos olá e temos uma nula

14400
09:39:00,720 --> 09:39:03,120
terminator aqui e o compilador é

14401
09:39:03,120 --> 09:39:04,800
vai deduzir o tamanho, então este é

14402
09:39:04,800 --> 09:39:07,200
Vou ser uma corda c adequada e nós

14403
09:39:07,200 --> 09:39:09,200
irá imprimi-lo corretamente

14404
09:39:09,200 --> 09:39:11,756
Vamos tentar soldar que o tabuleiro é

14405
09:39:11,756 --> 09:39:14,160
indo para passar se nós limparmos e corrermos

14406
09:39:14,160 --> 09:39:15,680
Galo vamos receber a nossa mensagem

14407
09:39:15,680 --> 09:39:18,640
Aqui e esta é uma maneira de montar um

14408
09:39:18,640 --> 09:39:21,756
C string adequada c O segundo caminho é para

14409
09:39:21,756 --> 09:39:25,680
Na verdade, não colocar o terminador nulo

14410
09:39:25,680 --> 09:39:28,560
mas deixe o compilador adicionar isso para você

14411
09:39:28,560 --> 09:39:30,160
E a maneira como podemos fazer isso, podemos dizer

14412
09:39:30,160 --> 09:39:33,200
Mensagem do carro para e nós vamos dizer

14413
09:39:33,200 --> 09:39:37,276
Este array é de tamanho 6. digamos que

14414
09:39:37,276 --> 09:39:39,120
nós vamos colocar em um seis

14415
09:39:39,120 --> 09:39:41,276
E uma correção de como terminamos as coisas aqui estamos

14416
09:39:41,276 --> 09:39:43,276
Vou colocar o nosso código

14417
09:39:43,276 --> 09:39:46,080
e acabar com isso com um ponto-e-vírgula agora o que

14418
09:39:46,080 --> 09:39:48,000
Vai acontecer é que o compilador é

14419
09:39:48,000 --> 09:39:50,160
indo para ver que este array é de tamanho

14420
09:39:50,160 --> 09:39:53,200
6 mas estamos colocando cinco elementos assim

14421
09:39:53,200 --> 09:39:55,520
os slots restantes serão automáticos

14422
09:39:55,520 --> 09:39:58,480
preenchido e vai usar

14423
09:39:58,480 --> 09:40:01,276
Terminadores nulos para preencher automaticamente isso então

14424
09:40:01,276 --> 09:40:03,520
Se tentarmos imprimir o tamanho aqui, estamos

14425
09:40:03,520 --> 09:40:05,840
Vou buscar um

14426
09:40:05,840 --> 09:40:09,276
porque o terminador nulo é adicionado em

14427
09:40:09,276 --> 09:40:12,240
pelo compilador vamos tentar imprimir o

14428
09:40:12,240 --> 09:40:14,960
tamanhos aqui, na verdade, para que você possa ver

14429
09:40:14,960 --> 09:40:17,520
Essas coisas, então vamos dizer tamanho

14430
09:40:17,520 --> 09:40:19,436
e nós vamos dizer esse tamanho de

14431
09:40:19,436 --> 09:40:21,756
mensagem um e nós vamos colocar em um

14432
09:40:21,756 --> 09:40:24,720
Novo personagem de linha e isso deve ser

14433
09:40:24,720 --> 09:40:27,200
O que esperamos, então o que vamos fazer

14434
09:40:27,200 --> 09:40:28,960
nós vamos copiar isso

14435
09:40:28,960 --> 09:40:30,960
E eu coloco isso aqui porque nós somos

14436
09:40:30,960 --> 09:40:32,480
Vou fazer a mesma coisa para

14437
09:40:32,480 --> 09:40:34,320
Mensagem para isso vamos dizer mensagem

14438
09:40:34,320 --> 09:40:36,320
para vamos selecionar isso

14439
09:40:36,320 --> 09:40:38,800
e eu digo tamanho da mensagem para e fazer

14440
09:40:38,800 --> 09:40:40,640
Sinais de mensagem também, então o que estamos indo

14441
09:40:40,640 --> 09:40:43,200
ver é uma mensagem 1 e mensagem 2

14442
09:40:43,200 --> 09:40:45,680
Imprimindo e esperamos ver um tamanho

14443
09:40:45,680 --> 09:40:48,400
de 6 porque ambos têm seis

14444
09:40:48,400 --> 09:40:51,200
Elementos dentro, então vamos correr

14445
09:40:51,200 --> 09:40:54,240
A tarefa de construir com gcc

14446
09:40:54,240 --> 09:40:56,800
e trazer isso à tona claro

14447
09:40:56,800 --> 09:40:58,080
Galo

14448
09:40:58,080 --> 09:41:00,720
E isso é exatamente o que esperamos

14449
09:41:00,720 --> 09:41:03,436
Mensagem um é olá o tamanho é seis

14450
09:41:03,436 --> 09:41:05,840
Mensagem dois é olá e o tamanho é seis

14451
09:41:05,840 --> 09:41:07,916
e estas são algumas maneiras que você pode declarar

14452
09:41:07,916 --> 09:41:10,160
seus arrays de personagens e inicialização

14453
09:41:10,160 --> 09:41:12,960
eles com os dados adequados que vão

14454
09:41:12,960 --> 09:41:16,400
imprimir corretamente com stdc para fora certifique-se

14455
09:41:16,400 --> 09:41:18,960
Você não faz algo como fizemos aqui

14456
09:41:18,960 --> 09:41:21,840
imprimindo a mensagem aqui porque é

14457
09:41:21,840 --> 09:41:24,160
não null terminado, isso vai fazer

14458
09:41:24,160 --> 09:41:27,120
dar-lhe um monte de problemas novamente eu quero

14459
09:41:27,120 --> 09:41:29,200
para torná-lo realmente claro

14460
09:41:29,200 --> 09:41:32,800
essa mensagem três aqui não é adequada

14461
09:41:32,800 --> 09:41:35,596
c string porque o compilador está indo

14462
09:41:35,596 --> 09:41:37,756
para deduzir muitos elementos que temos

14463
09:41:37,756 --> 09:41:40,400
Aqui e esta coisa vai ser de

14464
09:41:40,400 --> 09:41:42,240
tamanho cinco

14465
09:41:42,240 --> 09:41:43,840
E nós não vamos ter um null

14466
09:41:43,840 --> 09:41:45,680
Terminator e se imprimirmos, estamos

14467
09:41:45,680 --> 09:41:47,756
Vou pegar um pouco de lixo, então vamos tentar

14468
09:41:47,756 --> 09:41:50,240
Copie isso para que sejamos consistentes

14469
09:41:50,240 --> 09:41:51,040
em

14470
09:41:51,040 --> 09:41:53,916
o que fizemos aqui e se nós

14471
09:41:53,916 --> 09:41:56,640
Compilar com Gcc

14472
09:41:56,640 --> 09:41:58,960
Vamos compilar com sucesso, mas

14473
09:41:58,960 --> 09:42:01,916
Podemos ter coisas estranhas se imprimirmos

14474
09:42:01,916 --> 09:42:04,320
mensagem três como nós fazemos aqui e você está

14475
09:42:04,320 --> 09:42:06,160
Vou ver que o tamanho é cinco

14476
09:42:06,160 --> 09:42:09,040
Porque só temos cinco elementos em

14477
09:42:09,040 --> 09:42:13,200
aqui então vamos limpar e correr o galo e

14478
09:42:13,200 --> 09:42:14,880
Você vai ver isso

14479
09:42:14,880 --> 09:42:17,120
Nós temos olá para enviar uma mensagem que temos

14480
09:42:17,120 --> 09:42:19,520
Olá para a mensagem dois, mas para mensagem

14481
09:42:19,520 --> 09:42:22,560
Três temos coisas que não esperamos

14482
09:42:22,560 --> 09:42:24,720
porque vai continuar a imprimir e

14483
09:42:24,720 --> 09:42:26,640
vai ultrapassar e é

14484
09:42:26,640 --> 09:42:29,520
Vou parar quando atingir o primeiro

14485
09:42:29,520 --> 09:42:32,320
Sem caráter de terminação

14486
09:42:32,320 --> 09:42:34,800
Como o que temos aqui, tudo bem, então isso

14487
09:42:34,800 --> 09:42:37,436
Não é seguro, não faça isso, certifique-se de que você

14488
09:42:37,436 --> 09:42:39,276
Os pontos fortes são nulos

14489
09:42:39,276 --> 09:42:42,320
se você pretende imprimi-los com sddc

14490
09:42:42,320 --> 09:42:44,800
fora assim ok, então trabalhe com

14491
09:42:44,800 --> 09:42:46,800
arrays de caracteres como este para imprimir

14492
09:42:46,800 --> 09:42:48,640
mensagens e fazer todos os tipos de loucura

14493
09:42:48,640 --> 09:42:51,120
As coisas são boas, mas realmente não é

14494
09:42:51,120 --> 09:42:53,436
conveniente como eu disse antes

14495
09:42:53,436 --> 09:42:55,840
você não esperaria que seus usuários digitassem

14496
09:42:55,840 --> 09:42:58,720
personagens como este, cercando-os

14497
09:42:58,720 --> 09:43:01,436
Algumas citações, isso é realmente feio

14498
09:43:01,436 --> 09:43:04,480
e é doloroso fazer se você quiser

14499
09:43:04,480 --> 09:43:07,436
fazer algum trabalho produtivo, então c plus mais

14500
09:43:07,436 --> 09:43:10,240
permite que você use o que chamamos de string

14501
09:43:10,240 --> 09:43:11,916
Litementos e nós vamos ver um

14502
09:43:11,916 --> 09:43:13,436
Um exemplo disso

14503
09:43:13,436 --> 09:43:15,040
Abaixo, vamos dizer corda

14504
09:43:15,040 --> 09:43:18,400
Literais e uh o que podemos fazer é carro

14505
09:43:18,400 --> 09:43:21,756
mensagem para ele vai ser um array como

14506
09:43:21,756 --> 09:43:22,880
O habitual

14507
09:43:22,880 --> 09:43:25,200
e nós podemos inicializá-lo

14508
09:43:25,200 --> 09:43:27,916
com uma string que é cercada por

14509
09:43:27,916 --> 09:43:30,400
Citações duplas e o que isso vai fazer

14510
09:43:30,400 --> 09:43:32,240
Diga c mais mais mais

14511
09:43:32,240 --> 09:43:35,120
Você sabe que tomar essas coisas quebrem

14512
09:43:35,120 --> 09:43:38,400
em personagens e armazene isso neste

14513
09:43:38,400 --> 09:43:41,840
array aqui e certifique-se de que você corretamente

14514
09:43:41,840 --> 09:43:44,880
Agora termina esta string aqui, então se nós

14515
09:43:44,880 --> 09:43:47,520
imprimir o tamanho da mensagem quatro não somos

14516
09:43:47,520 --> 09:43:50,000
Vou ter cinco, vamos ter seis

14517
09:43:50,000 --> 09:43:52,000
porque c plus plus vai ver

14518
09:43:52,000 --> 09:43:54,320
Estas duplas citações e sabemos que nós

14519
09:43:54,320 --> 09:43:56,320
Tencione que essas coisas sejam adequadas

14520
09:43:56,320 --> 09:43:58,880
null terminou e vai adicionar um

14521
09:43:58,880 --> 09:44:02,400
null terminator então vamos tentar imprimir

14522
09:44:02,400 --> 09:44:05,200
Isso para que realmente tenhamos certeza e

14523
09:44:05,200 --> 09:44:08,160
nós vamos soldar isso com gcc como nós

14524
09:44:08,160 --> 09:44:09,360
Sempre faça

14525
09:44:09,360 --> 09:44:11,360
O mundo vai passar por vamos

14526
09:44:11,360 --> 09:44:13,520
subir e limpar e nós vamos correr

14527
09:44:13,520 --> 09:44:14,640
Galo

14528
09:44:14,640 --> 09:44:17,200
e você vê que a mensagem 4 é olá

14529
09:44:17,200 --> 09:44:20,320
E o tamanho é realmente um sexo

14530
09:44:20,320 --> 09:44:22,960
Esta é uma maneira que temos que fazer as coisas

14531
09:44:22,960 --> 09:44:25,200
e podemos até mesmo colocar espaços

14532
09:44:25,200 --> 09:44:27,916
e fazer todos os tipos de coisas loucas e

14533
09:44:27,916 --> 09:44:30,560
É muito legal e se tentarmos construir

14534
09:44:30,560 --> 09:44:32,320
Isso nós vamos obter o adequado

14535
09:44:32,320 --> 09:44:34,400
Mensagem impressa para fora você vê que o mundo é

14536
09:44:34,400 --> 09:44:38,080
Bom se limparmos e corrermos galo, estamos

14537
09:44:38,080 --> 09:44:40,240
Vou ver o próprio mundo como você está

14538
09:44:40,240 --> 09:44:42,720
fazer e isso é muito legal, então

14539
09:44:42,720 --> 09:44:45,680
Agora, se precisarmos armazenar uma corda em

14540
09:44:45,680 --> 09:44:47,756
Nosso programa é assim que vamos

14541
09:44:47,756 --> 09:44:49,520
fazê-lo porque isso é muito mais

14542
09:44:49,520 --> 09:44:52,160
civilizado e é assim que você realmente

14543
09:44:52,160 --> 09:44:54,400
Gosta de digitar caracteres no seu programa

14544
09:44:54,400 --> 09:44:57,276
Eu já disse que arrays de personagens são

14545
09:44:57,276 --> 09:44:59,596
Realmente especial porque você pode diretamente

14546
09:44:59,596 --> 09:45:03,680
imprimi-los com stdc para fora como este eu

14547
09:45:03,680 --> 09:45:05,360
Quero provar isso para que vamos tentar

14548
09:45:05,360 --> 09:45:07,436
e declarar outra matriz para que nós vamos

14549
09:45:07,436 --> 09:45:09,756
para chamar esses números

14550
09:45:09,756 --> 09:45:11,596
e nós vamos fazer isso um array

14551
09:45:11,596 --> 09:45:14,080
e nós vamos inicializar com um

14552
09:45:14,080 --> 09:45:17,596
Dois três quatro cinco isso vai fazer

14553
09:45:17,596 --> 09:45:19,596
E nós vamos colocar o nosso fechamento

14554
09:45:19,596 --> 09:45:21,436
ponto e vírgula e vamos tentar

14555
09:45:21,436 --> 09:45:24,880
imprimi-lo para fora eu vou dizer std

14556
09:45:24,880 --> 09:45:27,120
ver fora e dizer números

14557
09:45:27,120 --> 09:45:29,360
Vamos ver o que temos

14558
09:45:29,360 --> 09:45:31,276
Vamos tentar compilar isso e ver o que

14559
09:45:31,276 --> 09:45:33,680
nós conseguimos que não vai realmente dar

14560
09:45:33,680 --> 09:45:36,160
um erro de compilador, mas não está indo

14561
09:45:36,160 --> 09:45:38,080
para imprimir o que esperamos e vamos colocar um

14562
09:45:38,080 --> 09:45:39,840
mensagem aqui para que saibamos que é

14563
09:45:39,840 --> 09:45:42,400
Esta coisa que estamos vendo aqui, então estamos

14564
09:45:42,400 --> 09:45:44,560
vamos dizer números e nós vamos

14565
09:45:44,560 --> 09:45:47,120
Coloque uma coluna aqui

14566
09:45:47,120 --> 09:45:49,756
E nós vamos soldar isso

14567
09:45:49,756 --> 09:45:52,480
com o Gcc

14568
09:45:52,480 --> 09:45:54,880
E nós vamos limpar

14569
09:45:54,880 --> 09:45:57,916
e se um galo de corrida olhar para fora para o

14570
09:45:57,916 --> 09:46:00,240
saída que diz números aqui, então vamos

14571
09:46:00,240 --> 09:46:02,560
corrida de galo não é um um dois três

14572
09:46:02,560 --> 09:46:05,040
Quatro cinco é algo que nós realmente não fazemos

14573
09:46:05,040 --> 09:46:05,840
- Conhecer

14574
09:46:05,840 --> 09:46:08,000
e vamos começar a entender o que é

14575
09:46:08,000 --> 09:46:09,436
A acontecer aqui

14576
09:46:09,436 --> 09:46:12,160
no próximo capítulo, por enquanto, observe que

14577
09:46:12,160 --> 09:46:14,960
você não pode imprimir diretamente arrays outros

14578
09:46:14,960 --> 09:46:17,520
dos personagens se você tentar

14579
09:46:17,520 --> 09:46:19,120
fazer que você vai ficar estranho

14580
09:46:19,120 --> 09:46:21,120
Números impressos e nós vamos

14581
09:46:21,120 --> 09:46:23,276
Saiba por que isso é

14582
09:46:23,276 --> 09:46:25,756
O próximo capítulo então vamos dizer que aqui

14583
09:46:25,756 --> 09:46:27,596
Tudo bem é realmente tudo o que nos prossamos fazer

14584
09:46:27,596 --> 09:46:29,360
Nesta palestra espero que você a tenha encontrado

14585
09:46:29,360 --> 09:46:32,240
arrays de personagens interessantes têm alguns

14586
09:46:32,240 --> 09:46:34,480
Coisas que você precisa ter cuidado e

14587
09:46:34,480 --> 09:46:37,120
Tentamos cobrir aqueles nesta palestra que

14588
09:46:37,120 --> 09:46:39,040
Vou parar aqui nesta palestra

14589
09:46:39,040 --> 09:46:40,880
E o próximo vamos tentar

14590
09:46:40,880 --> 09:46:43,680
olhar para os limites de matriz

14591
09:46:43,680 --> 09:46:46,000
Vá em frente e termine aqui e me encontre

14592
09:46:46,000 --> 09:46:48,320
lá nesta palestra vamos

14593
09:46:48,320 --> 09:46:50,960
Veja o que pode acontecer se você tentar

14594
09:46:50,960 --> 09:46:53,680
manipular dados fora dos limites de

14595
09:46:53,680 --> 09:46:56,480
Sua matriz vimos isso quando você

14596
09:46:56,480 --> 09:46:59,680
alocar espaço para uma matriz do computador

14597
09:46:59,680 --> 09:47:01,520
Vai dar-lhe um monte de memória

14598
09:47:01,520 --> 09:47:03,916
locais que você pode usar para armazenar seus dados

14599
09:47:03,916 --> 09:47:06,240
E vai ser do tamanho que

14600
09:47:06,240 --> 09:47:08,640
você especificou ou que é deduzido por

14601
09:47:08,640 --> 09:47:11,360
O compilador, então aqui está um exemplo de

14602
09:47:11,360 --> 09:47:13,360
array que vai armazenar sete

14603
09:47:13,360 --> 09:47:16,000
Elementos e temos slots verdes para

14604
09:47:16,000 --> 09:47:18,000
Esses elementos e estes são os

14605
09:47:18,000 --> 09:47:21,200
Locais que podemos manipular

14606
09:47:21,200 --> 09:47:23,916
em nosso programa c plus plus se tentarmos

14607
09:47:23,916 --> 09:47:26,160
ir por cima, por exemplo, se tentarmos

14608
09:47:26,160 --> 09:47:29,520
modificar algo antes do nosso array ou

14609
09:47:29,520 --> 09:47:31,520
Depois do nosso array

14610
09:47:31,520 --> 09:47:33,360
Pode ser um local de memória que é

14611
09:47:33,360 --> 09:47:35,840
propriedade de outro programa pode ser um

14612
09:47:35,840 --> 09:47:38,000
Localização da memória que está sendo usada

14613
09:47:38,000 --> 09:47:40,640
pelo sistema operacional tão ruim

14614
09:47:40,640 --> 09:47:44,000
pode realmente acontecer se você tentar usar dados

14615
09:47:44,000 --> 09:47:47,200
que está fora dos limites da sua matriz

14616
09:47:47,200 --> 09:47:49,120
Vamos tentar olhar para um simples exemplo

14617
09:47:49,120 --> 09:47:50,640
Aqui temos um array chamado

14618
09:47:50,640 --> 09:47:54,000
números que temos 10 slots dentro, então nós

14619
09:47:54,000 --> 09:47:57,520
Só são permitidos para modificar a memória

14620
09:47:57,520 --> 09:48:00,400
locais para estes 10 números e se nós

14621
09:48:00,400 --> 09:48:03,120
Tente acessar algo fora do

14622
09:48:03,120 --> 09:48:05,520
limites desta matriz algo pode

14623
09:48:05,520 --> 09:48:07,916
Acontece, mas algumas pessoas dizem que c plus

14624
09:48:07,916 --> 09:48:10,480
Plus é muito engraçado porque deveria

14625
09:48:10,480 --> 09:48:12,320
Estar impedindo você de fazer algo

14626
09:48:12,320 --> 09:48:14,480
assim, mas c plus plus permite que você

14627
09:48:14,480 --> 09:48:17,360
fazer isso se você olhar para o código aqui que temos

14628
09:48:17,360 --> 09:48:20,240
um array temos 10 elementos n para

14629
09:48:20,240 --> 09:48:23,120
Os índices válidos que podemos realmente usar são de

14630
09:48:23,120 --> 09:48:26,320
0 a 9. mas se tentarmos acessar

14631
09:48:26,320 --> 09:48:29,200
Algo no índice 12 o código está indo

14632
09:48:29,200 --> 09:48:31,276
para compilar e se nós executarmos, nós estamos indo

14633
09:48:31,276 --> 09:48:33,200
para obter algo impresso, mas isso é

14634
09:48:33,200 --> 09:48:35,360
Algo que isso vai lhe dar

14635
09:48:35,360 --> 09:48:37,916
dados de lixo ou você pode até tentar

14636
09:48:37,916 --> 09:48:40,640
para ler alguma memória restrita e sua

14637
09:48:40,640 --> 09:48:42,240
O programa vai terminar

14638
09:48:42,240 --> 09:48:44,720
Imediatamente e vamos dizer isso

14639
09:48:44,720 --> 09:48:47,840
ele caiu se você tentar escrever sobre

14640
09:48:47,840 --> 09:48:50,080
bounce the compiler também vai

14641
09:48:50,080 --> 09:48:52,960
permitir, mas você não possui a memória assim

14642
09:48:52,960 --> 09:48:55,040
Outros programas podem vir e mudar

14643
09:48:55,040 --> 09:48:57,360
A localização da memória e se você tentar

14644
09:48:57,360 --> 09:48:58,960
Leia novamente você não vai

14645
09:48:58,960 --> 09:49:00,960
obter o que você espera outra coisa que

14646
09:49:00,960 --> 09:49:03,436
Pode acontecer é que você tenta modificar

14647
09:49:03,436 --> 09:49:06,320
dados que são de propriedade de outros programas e

14648
09:49:06,320 --> 09:49:09,596
Você pode imaginar o quão ruim isso realmente é

14649
09:49:09,596 --> 09:49:12,800
então a mensagem aqui é não passar

14650
09:49:12,800 --> 09:49:14,800
seu equilíbrio de matriz e você vai

14651
09:49:14,800 --> 09:49:17,596
estar jogando na zona segura, vamos cabeça

14652
09:49:17,596 --> 09:49:20,000
sobre o código do estúdio visual e jogar com

14653
09:49:20,000 --> 09:49:22,720
Nós um pouco aqui estamos em nosso

14654
09:49:22,720 --> 09:49:25,436
diretório de trabalho do projeto atual é

14655
09:49:25,436 --> 09:49:27,520
equilíbrio de matriz, nós vamos pegar o

14656
09:49:27,520 --> 09:49:29,436
Arquivos de modelo

14657
09:49:29,436 --> 09:49:30,960
E nós vamos para

14658
09:49:30,960 --> 09:49:33,276
Coloque-os no lugar

14659
09:49:33,276 --> 09:49:34,640
E nós vamos abrir isso para dentro

14660
09:49:34,640 --> 09:49:36,640
código de estúdio visual que vamos

14661
09:49:36,640 --> 09:49:40,240
Declarar uma matriz e tentar ler além

14662
09:49:40,240 --> 09:49:43,436
os limites legais da nossa matriz, então vamos

14663
09:49:43,436 --> 09:49:46,320
Tente trazer um terminal aqui e nós

14664
09:49:46,320 --> 09:49:48,800
vamos construir isso com gcc o

14665
09:49:48,800 --> 09:49:50,640
O mundo vai passar por você não é

14666
09:49:50,640 --> 09:49:53,436
vai ter um erro de compilador, mas se nós

14667
09:49:53,436 --> 09:49:55,520
correr isso, podemos realmente conseguir qualquer coisa e

14668
09:49:55,520 --> 09:49:58,080
Você vê que temos um número que nós realmente não

14669
09:49:58,080 --> 09:50:01,040
Saiba o que significa e isso significa que

14670
09:50:01,040 --> 09:50:02,720
Você já leu

14671
09:50:02,720 --> 09:50:05,436
fora dos limites legais de sua matriz

14672
09:50:05,436 --> 09:50:07,276
e c mais mais

14673
09:50:07,276 --> 09:50:09,756
permite que você faça isso e a razão

14674
09:50:09,756 --> 09:50:13,120
Eles fazem isso porque esperam você

14675
09:50:13,120 --> 09:50:15,680
O desenvolvedor para saber o que você está fazendo

14676
09:50:15,680 --> 09:50:17,840
Quando você tenta manipular coisas como

14677
09:50:17,840 --> 09:50:20,640
Raio e agora você sabe disso e tenha cuidado

14678
09:50:20,640 --> 09:50:22,560
quando você está trabalhando com arrays como

14679
09:50:22,560 --> 09:50:25,040
Isso então não vá por cima que é o

14680
09:50:25,040 --> 09:50:28,480
mensagem também podemos tentar modificar dados

14681
09:50:28,480 --> 09:50:31,680
além do equilíbrio, então vamos descer e colocar

14682
09:50:31,680 --> 09:50:34,000
no código para modificar graças e eu tenho

14683
09:50:34,000 --> 09:50:36,960
Coloque uma mensagem clara aqui como um comentário para

14684
09:50:36,960 --> 09:50:38,560
Deixe você saber que isso é realmente

14685
09:50:38,560 --> 09:50:40,800
Algo que você deveria ser muito

14686
09:50:40,800 --> 09:50:42,640
Cuidado, então vamos tentar e

14687
09:50:42,640 --> 09:50:44,880
Mudar esse número para 1000 e nós somos

14688
09:50:44,880 --> 09:50:46,400
Vou tentar imprimi-lo e ver

14689
09:50:46,400 --> 09:50:49,520
O que temos, mas este local de memória em

14690
09:50:49,520 --> 09:50:51,040
índice 12

14691
09:50:51,040 --> 09:50:53,596
Não é algo que nós possuímos mais

14692
09:50:53,596 --> 09:50:55,916
Os programas podem vir e escrever para isso

14693
09:50:55,916 --> 09:50:58,400
Localização e se tentarmos ler a partir dele

14694
09:50:58,400 --> 09:51:01,120
Mais uma vez, podemos não conseguir o que colocamos

14695
09:51:01,120 --> 09:51:03,520
aqui ainda pior esta localização de memória

14696
09:51:03,520 --> 09:51:06,240
pode ser de propriedade de outros programas e se

14697
09:51:06,240 --> 09:51:08,080
Eles lêem eles vão conseguir o que eles

14698
09:51:08,080 --> 09:51:10,640
Não colocaram eles vão conseguir o que

14699
09:51:10,640 --> 09:51:13,120
Você coloca e isso é algo ruim

14700
09:51:13,120 --> 09:51:15,436
pode tentar e realmente ficar louco com a gente

14701
09:51:15,436 --> 09:51:17,520
Vamos colocar um número realmente enorme e

14702
09:51:17,520 --> 09:51:19,680
Veja que nós podemos fazer isso

14703
09:51:19,680 --> 09:51:21,520
Esta é uma boa maneira de aprender pelo caminho

14704
09:51:21,520 --> 09:51:23,040
Isso vai compilar

14705
09:51:23,040 --> 09:51:25,596
e vamos tentar imprimir o que temos em

14706
09:51:25,596 --> 09:51:28,480
lá e nós vamos dizer

14707
09:51:28,480 --> 09:51:30,560
Esta localização aqui

14708
09:51:30,560 --> 09:51:32,720
E é isso que vamos dizer aqui

14709
09:51:32,720 --> 09:51:34,880
E nós vamos construir novamente o mundo

14710
09:51:34,880 --> 09:51:36,480
Vai passar por você ver que nós

14711
09:51:36,480 --> 09:51:39,040
estão fazendo algo realmente louco nosso

14712
09:51:39,040 --> 09:51:41,916
array tem 10 elementos, mas estamos tentando

14713
09:51:41,916 --> 09:51:44,560
para modificar algo

14714
09:51:44,560 --> 09:51:48,480
1 milhão de locais de memória de distância e uh

14715
09:51:48,480 --> 09:51:50,640
isso é realmente louco e c plus plus

14716
09:51:50,640 --> 09:51:52,400
permite que você faça isso

14717
09:51:52,400 --> 09:51:54,720
Então, vamos limpar e correr, nós do mundo

14718
09:51:54,720 --> 09:51:58,240
Vamos ter certeza de que temos o mundo, então vamos

14719
09:51:58,240 --> 09:52:00,320
construção com gcc

14720
09:52:00,320 --> 09:52:02,160
e claro

14721
09:52:02,160 --> 09:52:04,720
e executar galo nosso programa está travando

14722
09:52:04,720 --> 09:52:06,240
Porque estamos tentando acessar

14723
09:52:06,240 --> 09:52:07,756
alguma coisa

14724
09:52:07,756 --> 09:52:09,596
Isso não é realmente nosso e você vê

14725
09:52:09,596 --> 09:52:10,960
Já caiu

14726
09:52:10,960 --> 09:52:13,120
Por exemplo, se tivermos alguma coisa

14727
09:52:13,120 --> 09:52:16,160
impresso fora depois disso vamos dizer std

14728
09:52:16,160 --> 09:52:18,160
O programa

14729
09:52:18,160 --> 09:52:19,916
e então para que você possa vê-lo é

14730
09:52:19,916 --> 09:52:21,680
Realmente batendo

14731
09:52:21,680 --> 09:52:23,916
e dizer stdndl

14732
09:52:23,916 --> 09:52:26,400
Esta declaração aqui não vai

14733
09:52:26,400 --> 09:52:29,040
imprimir porque uma vez que atingimos este local

14734
09:52:29,040 --> 09:52:31,276
Vamos tentar modificar isso e

14735
09:52:31,276 --> 09:52:33,120
O programa não será capaz de

14736
09:52:33,120 --> 09:52:34,480
Faz isso que vai bater o

14737
09:52:34,480 --> 09:52:36,160
O sistema operacional vai notar que

14738
09:52:36,160 --> 09:52:38,560
Estamos tentando fazer algo louco e

14739
09:52:38,560 --> 09:52:40,880
vai dizer que este programa é realmente

14740
09:52:40,880 --> 09:52:43,200
louco não sabe o que está fazendo eu

14741
09:52:43,200 --> 09:52:44,880
Vou matá-lo e ele vai

14742
09:52:44,880 --> 09:52:47,040
Parada que é basicamente o que está acontecendo

14743
09:52:47,040 --> 09:52:50,880
Aqui então vamos soldar novamente com gcc

14744
09:52:50,880 --> 09:52:53,200
E nós vamos limpar

14745
09:52:53,200 --> 09:52:55,120
Vamos limpar

14746
09:52:55,120 --> 09:52:57,680
e correr galo você vê que está indo

14747
09:52:57,680 --> 09:52:59,520
para tentar fazer isso, vai tentar

14748
09:52:59,520 --> 09:53:01,756
colocar um valor aqui o programa está indo

14749
09:53:01,756 --> 09:53:04,400
Para terminar aqui e isso é realmente ruim

14750
09:53:04,400 --> 09:53:06,320
Porque os locais de memória que você tem

14751
09:53:06,320 --> 09:53:09,040
alocados para antes daqui não são

14752
09:53:09,040 --> 09:53:11,360
devidamente liberado e devolvido ao

14753
09:53:11,360 --> 09:53:13,520
sistema operacional e isso é algo

14754
09:53:13,520 --> 09:53:16,400
Muito ruim, então a mensagem é

14755
09:53:16,400 --> 09:53:19,520
Não vá por cima, certifique-se de que você está

14756
09:53:19,520 --> 09:53:22,560
trabalhando dentro dos limites legais de

14757
09:53:22,560 --> 09:53:25,520
sua matriz bem-vinda para este novo capítulo

14758
09:53:25,520 --> 09:53:27,436
E nós vamos falar sobre

14759
09:53:27,436 --> 09:53:29,680
ponteiros ponteiros são um dos

14760
09:53:29,680 --> 09:53:32,240
tópicos importantes em c plus plus e eles

14761
09:53:32,240 --> 09:53:34,480
permitir que você faça algumas das coisas

14762
09:53:34,480 --> 09:53:36,720
convenientemente e nós vamos ser

14763
09:53:36,720 --> 09:53:38,960
aprendendo sobre todas essas coisas complicadas

14764
09:53:38,960 --> 09:53:41,200
você pode fazer com eles neste capítulo, mas

14765
09:53:41,200 --> 09:53:43,200
Agora eu quero que você tenha um básico

14766
09:53:43,200 --> 09:53:45,436
compreensão do que um ponteiro realmente

14767
09:53:45,436 --> 09:53:46,240
É

14768
09:53:46,240 --> 09:53:47,916
Até agora temos trabalhado com

14769
09:53:47,916 --> 09:53:50,000
variáveis como esta, configuramos uma variável

14770
09:53:50,000 --> 09:53:52,400
em nosso c plus código que chegamos a um

14771
09:53:52,400 --> 09:53:54,480
ponto em que colocamos um valor dentro disso

14772
09:53:54,480 --> 09:53:56,880
variável e poderíamos usá-lo, por exemplo

14773
09:53:56,880 --> 09:54:00,000
nós poderíamos imprimi-lo no stdc para fora ou nós

14774
09:54:00,000 --> 09:54:02,000
poderia até mesmo armazenar um valor ou atribuir

14775
09:54:02,000 --> 09:54:04,240
Outro valor para a variável que temos sido

14776
09:54:04,240 --> 09:54:06,800
fazendo isso bastante, mas há um

14777
09:54:06,800 --> 09:54:08,640
Ponto que nós realmente não temos falado

14778
09:54:08,640 --> 09:54:11,276
essas variáveis têm um endereço em

14779
09:54:11,276 --> 09:54:13,840
memória e aqui, por exemplo, você vê que

14780
09:54:13,840 --> 09:54:15,200
nosso var

14781
09:54:15,200 --> 09:54:17,756
é armazenado no local um zero zero

14782
09:54:17,756 --> 09:54:19,756
Oito, claro, este é um exemplo simples

14783
09:54:19,756 --> 09:54:21,120
Eu vim com

14784
09:54:21,120 --> 09:54:24,080
Mas eu espero que ele conduz o ponto para casa todos

14785
09:54:24,080 --> 09:54:26,320
as variáveis que você usa em seu código têm

14786
09:54:26,320 --> 09:54:28,720
algum tipo de endereço na memória

14787
09:54:28,720 --> 09:54:31,756
e podemos pegar esse endereço e armazenar

14788
09:54:31,756 --> 09:54:34,400
em uma variável especial que

14789
09:54:34,400 --> 09:54:36,800
é realmente um ponteiro, então podemos dizer que

14790
09:54:36,800 --> 09:54:37,840
O ponteiro

14791
09:54:37,840 --> 09:54:40,240
é um tipo especial de variável

14792
09:54:40,240 --> 09:54:43,436
que armazena endereços de outras variáveis

14793
09:54:43,436 --> 09:54:45,276
Certifique-se de que você realmente entende isso

14794
09:54:45,276 --> 09:54:47,680
aqui temos p var, então é um ponteiro

14795
09:54:47,680 --> 09:54:50,880
seu tipo é o ponteiro final e nós denotamos

14796
09:54:50,880 --> 09:54:54,400
ponteiro usando este símbolo de estrela após o nosso

14797
09:54:54,400 --> 09:54:56,480
Digite se você ver algo assim

14798
09:54:56,480 --> 09:54:58,160
você vai saber que este tipo é um

14799
09:54:58,160 --> 09:55:00,720
ponteiro para terminar seu nome vai ser p

14800
09:55:00,720 --> 09:55:02,560
var porque é uma variável

14801
09:55:02,560 --> 09:55:04,960
e seu valor será o endereço

14802
09:55:04,960 --> 09:55:06,640
de outra variável que você vê que é

14803
09:55:06,640 --> 09:55:10,240
armazenamento 1 0 0 8 que por acaso é o

14804
09:55:10,240 --> 09:55:13,596
endereço do nosso var aqui na memória

14805
09:55:13,596 --> 09:55:15,596
ponteiros e variáveis que temos sido

14806
09:55:15,596 --> 09:55:17,596
falar sobre pode trabalhar de mãos dadas e

14807
09:55:17,596 --> 09:55:19,596
nós vamos estar vendo como isso é

14808
09:55:19,596 --> 09:55:21,436
feito nas próximas palestras no

14809
09:55:21,436 --> 09:55:24,400
capítulo, mas a ideia básica é realmente a

14810
09:55:24,400 --> 09:55:26,960
Aqui você vê que temos um ponteiro

14811
09:55:26,960 --> 09:55:29,120
para ele, mas você pode ter um ponteiro pronto

14812
09:55:29,120 --> 09:55:30,960
para qualquer coisa em seu código você pode ter um

14813
09:55:30,960 --> 09:55:33,436
ponteiro para o carro que você pode ter um ponteiro para

14814
09:55:33,436 --> 09:55:35,840
duplo você pode ter um ponteiro para flutuar

14815
09:55:35,840 --> 09:55:39,120
até ponteiros para tipos personalizados que não temos

14816
09:55:39,120 --> 09:55:40,880
Eu realmente falou sobre agora, mas nós vamos

14817
09:55:40,880 --> 09:55:42,880
Aprenda sobre eles mais tarde no curso

14818
09:55:42,880 --> 09:55:45,520
novamente um ponteiro é um tipo especial de

14819
09:55:45,520 --> 09:55:48,640
variável em seu programa c plus que é

14820
09:55:48,640 --> 09:55:51,120
indo para armazenar endereços para outros

14821
09:55:51,120 --> 09:55:54,000
variáveis que é o que realmente é e

14822
09:55:54,000 --> 09:55:55,680
Vamos começar e ver como você pode

14823
09:55:55,680 --> 09:55:58,080
declarar inicializá-los e usá-los em seu

14824
09:55:58,080 --> 09:56:00,800
código que começa na próxima palestra

14825
09:56:00,800 --> 09:56:03,120
Vá em frente e termine aqui e me encontre

14826
09:56:03,120 --> 09:56:04,000
lá

14827
09:56:04,000 --> 09:56:05,596
Nesta palestra vamos ver como

14828
09:56:05,596 --> 09:56:08,720
podemos declarar e usar ponteiros em nosso c

14829
09:56:08,720 --> 09:56:10,880
mais mais código na última palestra

14830
09:56:10,880 --> 09:56:13,436
Diga que um ponteiro é um tipo especial de

14831
09:56:13,436 --> 09:56:14,480
a variável

14832
09:56:14,480 --> 09:56:17,120
que podem armazenar endereços para outros

14833
09:56:17,120 --> 09:56:20,000
variáveis em nosso c plus mais código e nós

14834
09:56:20,000 --> 09:56:22,080
ter visto um slide como este para conduzir o

14835
09:56:22,080 --> 09:56:24,160
Ponto para casa agora vamos ver como nós

14836
09:56:24,160 --> 09:56:27,040
pode realmente usar ponteiros em nosso código

14837
09:56:27,040 --> 09:56:29,596
Aqui está um exemplo simples de como você pode

14838
09:56:29,596 --> 09:56:32,000
Declarar uma variável ponteiro em seu c

14839
09:56:32,000 --> 09:56:34,560
mais o código que você diz ent você colocar um

14840
09:56:34,560 --> 09:56:36,960
estrela após o tipo

14841
09:56:36,960 --> 09:56:39,520
significando que esta variável não é

14842
09:56:39,520 --> 09:56:41,680
Variável regular como vimos

14843
09:56:41,680 --> 09:56:45,360
antes que seja um tipo especial de variável

14844
09:56:45,360 --> 09:56:47,120
que vai para a loja

14845
09:56:47,120 --> 09:56:49,520
endereços para outras variáveis e aqui i

14846
09:56:49,520 --> 09:56:51,596
Tenho que dizer que você tem que ser realmente

14847
09:56:51,596 --> 09:56:54,960
Endereços de armazenamento cuidadosos e únicos para

14848
09:56:54,960 --> 09:56:57,596
Valorize os tipos de variável

14849
09:56:57,596 --> 09:57:00,000
em seus ponteiros, por exemplo, este é um

14850
09:57:00,000 --> 09:57:02,640
ponteiro para terminar só pode armazenar um

14851
09:57:02,640 --> 09:57:05,596
endereço de uma variável de tipo e para

14852
09:57:05,596 --> 09:57:08,240
outros tipos se você tentar colocar em seus

14853
09:57:08,240 --> 09:57:10,320
endereços aqui você vai ter um

14854
09:57:10,320 --> 09:57:12,560
erro de compilador aqui você vê que temos

14855
09:57:12,560 --> 09:57:14,960
Outro exemplo e é chamado p

14856
09:57:14,960 --> 09:57:17,120
número fracionário porque é um duplo

14857
09:57:17,120 --> 09:57:19,520
E você vê que nossos ponteiros aqui são

14858
09:57:19,520 --> 09:57:22,960
inicializado usando inicializadores braced

14859
09:57:22,960 --> 09:57:24,640
E isso vai inicializar o

14860
09:57:24,640 --> 09:57:28,000
ponteiros com um endereço especial que

14861
09:57:28,000 --> 09:57:30,080
realmente denota que esses ponteiros são

14862
09:57:30,080 --> 09:57:32,560
Não apontando para nada ainda bem você

14863
09:57:32,560 --> 09:57:35,916
também pode dizer isso explicitamente e colocar agora

14864
09:57:35,916 --> 09:57:38,400
ptr dentro e isso vai significar

14865
09:57:38,400 --> 09:57:41,040
que esses ponteiros não estão apontando

14866
09:57:41,040 --> 09:57:43,276
em qualquer lugar que você não possa usar os valores

14867
09:57:43,276 --> 09:57:46,160
nos endereços em que apontam isso

14868
09:57:46,160 --> 09:57:48,800
é a mensagem aqui não use ponteiros

14869
09:57:48,800 --> 09:57:51,756
que contêm ponteiro nulo todos os ponteiros

14870
09:57:51,756 --> 09:57:54,240
Em um determinado sistema vai ter o

14871
09:57:54,240 --> 09:57:56,800
O mesmo tamanho, por exemplo, se você tem um

14872
09:57:56,800 --> 09:57:59,436
ponteiro para o fim e o ponteiro para dobrar

14873
09:57:59,436 --> 09:58:01,040
eles vão ter o mesmo tamanho

14874
09:58:01,040 --> 09:58:03,596
Porque eles realmente armazenam a mesma coisa

14875
09:58:03,596 --> 09:58:06,240
armazenam endereços para variáveis e

14876
09:58:06,240 --> 09:58:08,880
endereços para variáveis diferentes, mesmo se

14877
09:58:08,880 --> 09:58:10,800
Acontece que eles são do mesmo tipo em

14878
09:58:10,800 --> 09:58:13,520
O mesmo sistema é do mesmo tamanho

14879
09:58:13,520 --> 09:58:15,840
É por isso que todos os ponteiros que você está indo

14880
09:58:15,840 --> 09:58:17,520
para usar em seu código vai ter

14881
09:58:17,520 --> 09:58:19,276
O mesmo tamanho e isso é algo que você

14882
09:58:19,276 --> 09:58:21,520
deve ter em mente e aqui está uma simples

14883
09:58:21,520 --> 09:58:23,680
Um exemplo para realmente brincar com isso que temos

14884
09:58:23,680 --> 09:58:26,800
Um tamanho impresso temos um tamanho

14885
09:58:26,800 --> 09:58:28,960
de nossos ponteiros impressos e nós estamos

14886
09:58:28,960 --> 09:58:30,720
vamos comparar essas coisas quando

14887
09:58:30,720 --> 09:58:32,640
chegar ao código do estúdio visual em um minuto

14888
09:58:32,640 --> 09:58:33,756
E você vai ver isso tudo

14889
09:58:33,756 --> 09:58:36,480
ponteiros são do mesmo tamanho uma questão

14890
09:58:36,480 --> 09:58:39,200
Eu recebo de muitas pessoas é se o

14891
09:58:39,200 --> 09:58:42,080
posição deste símbolo da estrela

14892
09:58:42,080 --> 09:58:44,320
realmente importa e eu tenho que quebrá-lo para

14893
09:58:44,320 --> 09:58:47,276
você não faz, mas eu prefiro colocá-lo

14894
09:58:47,276 --> 09:58:49,276
A esquerda algumas pessoas preferem colocá-lo

14895
09:58:49,276 --> 09:58:51,680
O certo, mas definitivamente não colocá-lo em

14896
09:58:51,680 --> 09:58:53,680
O meio eu nunca vi ninguém fazer

14897
09:58:53,680 --> 09:58:55,756
Isso mas vai funcionar, está indo

14898
09:58:55,756 --> 09:58:58,560
para ser legal c plus mais código outro

14899
09:58:58,560 --> 09:59:00,240
A coisa que eu vejo as pessoas fazem o que é realmente

14900
09:59:00,240 --> 09:59:03,120
A confusão é declarar suas dicas sobre

14901
09:59:03,120 --> 09:59:05,680
A mesma linha e fazer uma vírgula como esta

14902
09:59:05,680 --> 09:59:08,400
Isso vai ser confuso e

14903
09:59:08,400 --> 09:59:11,596
Agora eu quero que você agite e veja o que é

14904
09:59:11,596 --> 09:59:15,120
Acontecendo aqui ou é var a

14905
09:59:15,120 --> 09:59:17,916
ponteiro ou é um fim regular eu quero você

14906
09:59:17,916 --> 09:59:19,520
para ter isso em mente eu não vou

14907
09:59:19,520 --> 09:59:21,520
Diga que vamos tentar isso

14908
09:59:21,520 --> 09:59:23,596
Na verdade, em código de estúdio visual e nós somos

14909
09:59:23,596 --> 09:59:25,680
vou descobrir isso juntos, mas

14910
09:59:25,680 --> 09:59:27,680
Agora eu quero que você tente pensar sobre isso

14911
09:59:27,680 --> 09:59:29,276
nós vamos deixar essa pergunta

14912
09:59:29,276 --> 09:59:31,276
sem resposta e nós vamos respondê-lo

14913
09:59:31,276 --> 09:59:33,680
daqui a pouco, mas por enquanto

14914
09:59:33,680 --> 09:59:35,756
Não faça isso porque é

14915
09:59:35,756 --> 09:59:37,840
confuso e vai fazer o seu

14916
09:59:37,840 --> 09:59:40,160
código menos legível se você tiver que fazer

14917
09:59:40,160 --> 09:59:42,000
Algo assim certifique-se de que você apenas

14918
09:59:42,000 --> 09:59:44,160
Coloque-os em linhas diferentes e não é

14919
09:59:44,160 --> 09:59:46,480
Será confuso, por exemplo, se você

14920
09:59:46,480 --> 09:59:48,320
Olhe aqui, você vai saber que

14921
09:59:48,320 --> 09:59:50,480
O p número sete é um outro ponteiro

14922
09:59:50,480 --> 09:59:52,960
O intervalo é um fim regular e há

14923
09:59:52,960 --> 09:59:55,756
sem espaço para confusão desta vez usar código

14924
09:59:55,756 --> 09:59:57,840
Assim e não coloque as coisas no

14925
09:59:57,840 --> 10:00:00,800
A mesma linha como nós temos no topo aqui bem

14926
10:00:00,800 --> 10:00:02,960
Agora vimos que podemos declarar e

14927
10:00:02,960 --> 10:00:06,320
inicialize ponteiros com ponteiro nulo

14928
10:00:06,320 --> 10:00:09,276
Agora é a hora de ver como podemos colocar

14929
10:00:09,276 --> 10:00:12,000
dados reais nessas variáveis de ponteiro

14930
10:00:12,000 --> 10:00:13,916
Aqui temos uma variável que é chamada

14931
10:00:13,916 --> 10:00:17,120
em var é do tipo e e seu valor

14932
10:00:17,120 --> 10:00:18,560
É um 43

14933
10:00:18,560 --> 10:00:20,880
Também podemos configurar outro ponteiro

14934
10:00:20,880 --> 10:00:23,040
ponteiro de extremidade variável

14935
10:00:23,040 --> 10:00:25,276
Seu nome é p

14936
10:00:25,276 --> 10:00:28,560
sublinhar o int e podemos inicializá-lo

14937
10:00:28,560 --> 10:00:31,680
com o endereço de outra variável e

14938
10:00:31,680 --> 10:00:34,000
Aqui está um novo operador que não vimos

14939
10:00:34,000 --> 10:00:37,120
antes desta variável ampersand aqui

14940
10:00:37,120 --> 10:00:39,596
realmente significa o endereço desta formi

14941
10:00:39,596 --> 10:00:41,360
variável isso é o que queremos dizer aqui, então

14942
10:00:41,360 --> 10:00:43,596
nós vamos inicializar este final de p

14943
10:00:43,596 --> 10:00:46,320
variável com o endereço de enter

14944
10:00:46,320 --> 10:00:48,560
variável e é assim que fazemos

14945
10:00:48,560 --> 10:00:50,720
Se viermos aqui imprimimos o antivírus

14946
10:00:50,720 --> 10:00:52,240
Vamos obter o valor impresso

14947
10:00:52,240 --> 10:00:55,276
para baixo se imprimirmos o ponteiro diretamente

14948
10:00:55,276 --> 10:00:57,200
nós vamos conseguir o endereço disto

14949
10:00:57,200 --> 10:00:59,520
Um garotinho impresso no console

14950
10:00:59,520 --> 10:01:01,596
e nós vamos ver tudo bem, então isso

14951
10:01:01,596 --> 10:01:03,680
É como você pode armazenar as coisas em seu

14952
10:01:03,680 --> 10:01:05,520
variáveis de ponteiro e o que você precisa

14953
10:01:05,520 --> 10:01:08,080
armazenar e deve ser um endereço de

14954
10:01:08,080 --> 10:01:09,436
Outra variável

14955
10:01:09,436 --> 10:01:10,800
Aqui você vê que temos outro

14956
10:01:10,800 --> 10:01:13,120
variável chamada em r1 dentro temos um

14957
10:01:13,120 --> 10:01:16,560
65 e se você for aqui, você vê que

14958
10:01:16,560 --> 10:01:19,200
Estamos armazenando outra coisa

14959
10:01:19,200 --> 10:01:21,916
em nosso ponto de variável aqui que tivemos em

14960
10:01:21,916 --> 10:01:24,400
O endereço de para var agora estamos

14961
10:01:24,400 --> 10:01:27,436
Colocar no endereço de var1

14962
10:01:27,436 --> 10:01:29,916
usando um operador de atribuição e este é

14963
10:01:29,916 --> 10:01:32,080
Algo que você pode definitivamente fazer é

14964
10:01:32,080 --> 10:01:34,640
legal c plus plus vai funcionar se

14965
10:01:34,640 --> 10:01:36,400
nós o imprimimos, vamos ter um

14966
10:01:36,400 --> 10:01:38,640
Endereço diferente impresso para fora é

14967
10:01:38,640 --> 10:01:41,200
Como você pode armazenar valores em seu ponteiro

14968
10:01:41,200 --> 10:01:44,160
variáveis novamente você não pode cruzar um sinal

14969
10:01:44,160 --> 10:01:46,800
antes de diferentes tipos de ponteiro aqui nós

14970
10:01:46,800 --> 10:01:48,840
ter um ponteiro oito que é chamado

14971
10:01:48,840 --> 10:01:51,360
O pn1 e temos uma variável dupla é

14972
10:01:51,360 --> 10:01:53,756
chamado var duplo, não podemos tomar o

14973
10:01:53,756 --> 10:01:56,880
endereço de var duplo e armazene isso em

14974
10:01:56,880 --> 10:01:59,200
pnt1 isso vai ser um compilador

14975
10:01:59,200 --> 10:02:01,916
Erro as variáveis cujos endereços você

14976
10:02:01,916 --> 10:02:05,680
armazenar em pagamento 1 deve ser do tipo

14977
10:02:05,680 --> 10:02:07,840
e novamente a idéia básica é que a

14978
10:02:07,840 --> 10:02:10,560
O ponteiro é realmente um tipo especial de

14979
10:02:10,560 --> 10:02:12,960
variável que vai armazenar

14980
10:02:12,960 --> 10:02:15,840
endereços para outras variáveis e se você

14981
10:02:15,840 --> 10:02:18,480
O ponteiro é um ponteiro para terminar

14982
10:02:18,480 --> 10:02:20,720
As variáveis cujos endereços você pode

14983
10:02:20,720 --> 10:02:23,756
armazenar neste ponteiro para o fim só pode ser

14984
10:02:23,756 --> 10:02:26,400
termina se você tentar colocar em duplas

14985
10:02:26,400 --> 10:02:27,596
Você vai estar em apuros você está

14986
10:02:27,596 --> 10:02:29,520
vai ter um erro do compilador e é

14987
10:02:29,520 --> 10:02:31,520
Não vou trabalhar agora que vamos

14988
10:02:31,520 --> 10:02:33,596
dirija-se ao código do estúdio visual e

14989
10:02:33,596 --> 10:02:36,240
realmente brincar com essas coisas aqui nós

14990
10:02:36,240 --> 10:02:39,360
estão em nosso diretório de trabalho o atual

14991
10:02:39,360 --> 10:02:41,756
Capítulo é ponteiros da palestra atual

14992
10:02:41,756 --> 10:02:43,916
está declarando e usando ponteiros

14993
10:02:43,916 --> 10:02:46,160
Vou pegar nossos arquivos de modelo e colocar

14994
10:02:46,160 --> 10:02:48,000
Eles no lugar

14995
10:02:48,000 --> 10:02:51,120
Coloque-os em nosso projeto aqui e

14996
10:02:51,120 --> 10:02:52,720
vamos abrir isso em visual

14997
10:02:52,720 --> 10:02:54,400
Código do estúdio é a primeira coisa que vamos

14998
10:02:54,400 --> 10:02:56,560
Ver é como podemos declarar

14999
10:02:56,560 --> 10:02:58,800
e inicializar ponteiros e nós vamos

15000
10:02:58,800 --> 10:03:00,800
usar um ponteiro para terminar como um primeiro

15001
10:03:00,800 --> 10:03:02,720
O exemplo vamos montar uma polegada

15002
10:03:02,720 --> 10:03:05,200
ponteiro e nós dizemos na loja que vamos

15003
10:03:05,200 --> 10:03:06,480
para dar um nome, vamos chamar

15004
10:03:06,480 --> 10:03:09,200
este número p e você pode deixá-lo como

15005
10:03:09,200 --> 10:03:11,840
Isso é unnitralizado, mas é realmente

15006
10:03:11,840 --> 10:03:14,160
aconselhado a inicializar sempre o seu

15007
10:03:14,160 --> 10:03:16,560
apontadores, então vamos fazer isso com

15008
10:03:16,560 --> 10:03:19,276
um iniciador de brist que vai fazer

15009
10:03:19,276 --> 10:03:21,840
Que para nós isso vai implicitamente

15010
10:03:21,840 --> 10:03:24,240
inicializá-lo com zero equivalente de

15011
10:03:24,240 --> 10:03:26,400
ponteiros e isso é nulo

15012
10:03:26,400 --> 10:03:29,680
ponteiro para que possamos inicializar ok para que isso

15013
10:03:29,680 --> 10:03:31,360
É o que vamos inicializar com

15014
10:03:31,360 --> 10:03:32,080
Não

15015
10:03:32,080 --> 10:03:34,720
ponteiro, dizemos que não há ptr

15016
10:03:34,720 --> 10:03:37,436
E é assim que você deve fazer as coisas que você

15017
10:03:37,436 --> 10:03:39,680
também pode fazer um ponteiro para dobrar por que não

15018
10:03:39,680 --> 10:03:41,520
Vamos fazer o ponteiro duplo e nós vamos

15019
10:03:41,520 --> 10:03:44,080
dizer ponteiro de números fracionários para

15020
10:03:44,080 --> 10:03:45,916
número fracionário e nós também podemos

15021
10:03:45,916 --> 10:03:48,960
inicialize isso com ponteiro nulo

15022
10:03:48,960 --> 10:03:50,400
Implícitamente

15023
10:03:50,400 --> 10:03:51,276
E a

15024
10:03:51,276 --> 10:03:53,200
Uma vez que você faça isso, o programa vai

15025
10:03:53,200 --> 10:03:57,120
ser legal se tentarmos no mundo com gcc

15026
10:03:57,120 --> 10:03:59,276
Como nós sempre fazemos a construção vai

15027
10:03:59,276 --> 10:04:01,436
ser bom, mas nós realmente não temos nenhum

15028
10:04:01,436 --> 10:04:03,680
A coisa útil que podemos ver

15029
10:04:03,680 --> 10:04:05,596
Se executarmos este programa, somos apenas

15030
10:04:05,596 --> 10:04:07,680
Começando, vamos ver

15031
10:04:07,680 --> 10:04:10,720
As coisas mais tarde, por enquanto, apenas entendam

15032
10:04:10,720 --> 10:04:13,680
que o número p é uma variável que temos em

15033
10:04:13,680 --> 10:04:16,400
nosso código esta variável só pode armazenar

15034
10:04:16,400 --> 10:04:19,360
endereços para outras variáveis que acontecem

15035
10:04:19,360 --> 10:04:22,800
ser do tipo e se você tentar e armazenar

15036
10:04:22,800 --> 10:04:25,436
em um endereço de uma variável que é de

15037
10:04:25,436 --> 10:04:27,916
tipo duplo, por exemplo ou flauta que você é

15038
10:04:27,916 --> 10:04:29,200
obter um erro do compilador você

15039
10:04:29,200 --> 10:04:31,436
Não deveria fazer o mesmo para p

15040
10:04:31,436 --> 10:04:34,080
Número fracionário que só pode armazenar

15041
10:04:34,080 --> 10:04:36,880
endereços para outras variáveis que

15042
10:04:36,880 --> 10:04:39,596
Acontece que é do tipo duplo manter isso em

15043
10:04:39,596 --> 10:04:41,436
A mente nós também podemos

15044
10:04:41,436 --> 10:04:44,320
inicializar explicitamente sem ponteiro, então

15045
10:04:44,320 --> 10:04:47,120
podemos dizer ponteiro final e dizer p número

15046
10:04:47,120 --> 10:04:49,200
um por que não e nós vamos

15047
10:04:49,200 --> 10:04:51,520
Use explicitamente o não

15048
10:04:51,520 --> 10:04:53,756
ptr como este e isso vai funcionar

15049
10:04:53,756 --> 10:04:56,480
E você também pode dizer

15050
10:04:56,480 --> 10:04:59,756
p número fracionário e dizer

15051
10:04:59,756 --> 10:05:03,436
um por que não e dizer agora pqr isso é

15052
10:05:03,436 --> 10:05:05,120
Vou trabalhar isso é algo que você pode

15053
10:05:05,120 --> 10:05:06,720
Você vai ver isso se nós

15054
10:05:06,720 --> 10:05:08,720
compilar isso o compilador vai ser

15055
10:05:08,720 --> 10:05:11,756
Feliz com isso o mundo é bom

15056
10:05:11,756 --> 10:05:13,360
Agora você sabe como pode declarar e

15057
10:05:13,360 --> 10:05:15,360
inicialize seus ponteiros agora que queremos

15058
10:05:15,360 --> 10:05:16,080
Veja

15059
10:05:16,080 --> 10:05:18,880
que apontar para diferentes variáveis são

15060
10:05:18,880 --> 10:05:21,120
Na verdade do mesmo tamanho

15061
10:05:21,120 --> 10:05:23,596
em qualquer sistema em que você esteja trabalhando

15062
10:05:23,596 --> 10:05:25,840
não é consistente em toda a operação

15063
10:05:25,840 --> 10:05:28,480
sistemas ou sistemas de riffing, mas é

15064
10:05:28,480 --> 10:05:31,360
garantido para ser do mesmo tamanho no

15065
10:05:31,360 --> 10:05:32,560
a mesma máquina

15066
10:05:32,560 --> 10:05:34,880
Eu vou descer e colocar um pedaço

15067
10:05:34,880 --> 10:05:36,800
Código que vai nos mostrar a todos

15068
10:05:36,800 --> 10:05:39,040
essas coisas no console e eu sou

15069
10:05:39,040 --> 10:05:41,276
Vou clicar neste ícone do arquivo aqui

15070
10:05:41,276 --> 10:05:43,040
E dar a nós mesmos

15071
10:05:43,040 --> 10:05:45,040
algum espaço para respirar para que possamos ver

15072
10:05:45,040 --> 10:05:46,960
A coisa toda aqui se você olhar aqui

15073
10:05:46,960 --> 10:05:48,960
nós estamos imprimindo o tamanho da formista que conhecemos

15074
10:05:48,960 --> 10:05:51,596
Que isto vai ser um quatro

15075
10:05:51,596 --> 10:05:53,520
Tamanho do dobro, isso vai ser um

15076
10:05:53,520 --> 10:05:55,916
Oito no nosso sistema aqui, mas nós não

15077
10:05:55,916 --> 10:05:58,240
Saiba qual o tamanho de um ponteiro duplo

15078
10:05:58,240 --> 10:06:00,800
é ou o tamanho de um ponteiro final e

15079
10:06:00,800 --> 10:06:03,120
nós vamos ver isso em um minuto aqui

15080
10:06:03,120 --> 10:06:04,960
Você vê que também estamos usando o

15081
10:06:04,960 --> 10:06:06,880
variáveis do ponteiro imediatamente este é

15082
10:06:06,880 --> 10:06:08,960
Algo que você pode fazer você vê esse visual

15083
10:06:08,960 --> 10:06:11,276
O código do estúdio não está reclamando e nós

15084
10:06:11,276 --> 10:06:14,800
pode ir em cima aqui e pedregulho com gcc

15085
10:06:14,800 --> 10:06:16,400
Vamos fazer isso

15086
10:06:16,400 --> 10:06:19,360
O mundo vai ser bom agora que podemos

15087
10:06:19,360 --> 10:06:21,680
abrir um terminal e realmente executar isso

15088
10:06:21,680 --> 10:06:23,520
programa aqui vamos limpar se nós

15089
10:06:23,520 --> 10:06:24,800
Faz lá

15090
10:06:24,800 --> 10:06:26,480
nós vamos ver isso

15091
10:06:26,480 --> 10:06:27,756
Os de que a si a si a do que sobre a, a , a , a , aja, a , a, a, a

15092
10:06:27,756 --> 10:06:29,916
nosso diretório aqui para que você veja que nós

15093
10:06:29,916 --> 10:06:32,240
você tem galo.exe

15094
10:06:32,240 --> 10:06:34,240
e nós podemos executar isso e vai

15095
10:06:34,240 --> 10:06:35,520
Dizê

15096
10:06:35,520 --> 10:06:38,640
sizeofant é quatro tamanhos de duplo é

15097
10:06:38,640 --> 10:06:39,680
Oito

15098
10:06:39,680 --> 10:06:43,360
isso é esperado, mas os tipos de ponteiro são

15099
10:06:43,360 --> 10:06:47,120
de tamanho 8 no meu sistema eles ocupam 8

15100
10:06:47,120 --> 10:06:49,916
bytes na memória para que não importe o

15101
10:06:49,916 --> 10:06:52,400
tipo que estamos apontando para um ponteiro para ele

15102
10:06:52,400 --> 10:06:55,436
Será sempre 8 bytes na memória

15103
10:06:55,436 --> 10:06:57,756
Isso é algo que você realmente deve saber

15104
10:06:57,756 --> 10:06:59,756
e manter em sua mente outra coisa nós

15105
10:06:59,756 --> 10:07:01,916
Eu disse que eu quero jogar com a direita

15106
10:07:01,916 --> 10:07:02,960
E agora

15107
10:07:02,960 --> 10:07:05,276
é a localização do símbolo da estrela alguns

15108
10:07:05,276 --> 10:07:07,040
As pessoas dizem que você deve colocá-lo à esquerda

15109
10:07:07,040 --> 10:07:08,640
Algumas pessoas dizem que você deve colocá-lo para o

15110
10:07:08,640 --> 10:07:11,360
direito eu realmente não acho nada disso

15111
10:07:11,360 --> 10:07:13,520
assuntos densos eu prefiro colocá-lo para o

15112
10:07:13,520 --> 10:07:15,360
para a esquerda, mas se você colocá-lo à direita é

15113
10:07:15,360 --> 10:07:17,840
Também é possível que funcione você vê

15114
10:07:17,840 --> 10:07:19,436
que mesmo se você colocá-lo no meio

15115
10:07:19,436 --> 10:07:21,360
Aqui, o que é realmente louco o compilador

15116
10:07:21,360 --> 10:07:23,756
Vai levar isso, podemos correr o

15117
10:07:23,756 --> 10:07:25,520
tarefa para construir isso para garantir que

15118
10:07:25,520 --> 10:07:27,120
O compilador está muito feliz e você vê

15119
10:07:27,120 --> 10:07:29,040
que não há nenhum problema o compilador é

15120
10:07:29,040 --> 10:07:31,200
vamos aceitar isso e nós vamos

15121
10:07:31,200 --> 10:07:34,000
construir com sucesso se você colocar o seu

15122
10:07:34,000 --> 10:07:36,480
declaração em uma única linha como esta

15123
10:07:36,480 --> 10:07:39,200
O que é outro ant var vai ser é

15124
10:07:39,200 --> 10:07:41,436
vai ser uma variável de extremidade regular é

15125
10:07:41,436 --> 10:07:43,756
Vai ser um ponteiro para acabar

15126
10:07:43,756 --> 10:07:45,756
nós realmente não sabemos agora e eu não sei

15127
10:07:45,756 --> 10:07:47,680
Quero te dizer que vamos descobrir

15128
10:07:47,680 --> 10:07:49,436
juntos, então o que vamos fazer nós somos

15129
10:07:49,436 --> 10:07:52,080
Vou imprimir o tamanho dessas coisas

15130
10:07:52,080 --> 10:07:54,000
Eu vou descer aqui e colocar

15131
10:07:54,000 --> 10:07:56,320
o código e voltar em um minuto aqui

15132
10:07:56,320 --> 10:07:59,200
é o nosso código digitado e nós vamos

15133
10:07:59,200 --> 10:08:01,840
Veja o tamanho dessas coisas o que somos

15134
10:08:01,840 --> 10:08:04,240
Ir fazer é executar a tarefa de construir

15135
10:08:04,240 --> 10:08:07,520
com gcc como sempre fazemos, vamos limpar

15136
10:08:07,520 --> 10:08:08,800
corretamente

15137
10:08:08,800 --> 10:08:10,720
e correr o galo

15138
10:08:10,720 --> 10:08:14,640
e você vê o tamanho de p número cinco é

15139
10:08:14,640 --> 10:08:15,596
Oito

15140
10:08:15,596 --> 10:08:17,756
porque é um tamanho de ponteiro de qualquer um

15141
10:08:17,756 --> 10:08:20,880
O fim é quatro e o mesmo se aplica ao

15142
10:08:20,880 --> 10:08:22,640
Segunda linha aqui

15143
10:08:22,640 --> 10:08:24,640
Assim, a partir disso, podemos dizer que outro

15144
10:08:24,640 --> 10:08:28,000
intervalo e outras formem versus x não

15145
10:08:28,000 --> 10:08:30,640
apontadores eles são inteiros regulares e

15146
10:08:30,640 --> 10:08:34,560
Isso pode ser realmente confuso, então para evitar

15147
10:08:34,560 --> 10:08:37,520
Esta confusão eu aconselharia a não

15148
10:08:37,520 --> 10:08:38,560
Declarar

15149
10:08:38,560 --> 10:08:40,480
seus agradecimentos quando você tem dicas

15150
10:08:40,480 --> 10:08:42,240
Por dentro assim, porque isso vai

15151
10:08:42,240 --> 10:08:44,560
Estar realmente confuso, o que você pode fazer é

15152
10:08:44,560 --> 10:08:46,560
Coloque-os em linhas separadas e faça

15153
10:08:46,560 --> 10:08:49,040
Algo assim, então aqui é muito

15154
10:08:49,040 --> 10:08:51,596
claro que o p número sete é um ponteiro

15155
10:08:51,596 --> 10:08:54,000
outros oito var sete é um regular

15156
10:08:54,000 --> 10:08:55,916
variável e não há espaço para

15157
10:08:55,916 --> 10:08:58,960
confusão com essa maneira de fazer isso

15158
10:08:58,960 --> 10:09:00,640
Certifique-se de colocar as coisas separadas

15159
10:09:00,640 --> 10:09:02,480
Linhas como esta e você vai ser

15160
10:09:02,480 --> 10:09:05,200
Tudo bem agora o que eu quero que você veja é que

15161
10:09:05,200 --> 10:09:07,436
Podemos realmente armazenar dados em todos os

15162
10:09:07,436 --> 10:09:10,240
ponteiros quero dizer dados válidos que não são

15163
10:09:10,240 --> 10:09:12,400
Ir ponteiro null neste caso, vamos

15164
10:09:12,400 --> 10:09:14,720
configurar uma variável uma variável de extremidade regular

15165
10:09:14,720 --> 10:09:17,276
vai armazenar um 43 dentro e

15166
10:09:17,276 --> 10:09:19,200
nós vamos configurar outro ponteiro

15167
10:09:19,200 --> 10:09:22,240
e inicialize isso com o endereço de

15168
10:09:22,240 --> 10:09:24,640
isso é variável e isso vai

15169
10:09:24,640 --> 10:09:27,360
trabalhar corretamente o que podemos fazer agora

15170
10:09:27,360 --> 10:09:29,200
é imprimir o intervalo que vamos

15171
10:09:29,200 --> 10:09:31,360
imprimi-lo se tentarmos imprimir o

15172
10:09:31,360 --> 10:09:33,520
ponteiro, vamos conseguir o endereço

15173
10:09:33,520 --> 10:09:36,480
disso em var na memória e isso é

15174
10:09:36,480 --> 10:09:38,560
Algo que você precisa ver com seus olhos

15175
10:09:38,560 --> 10:09:40,400
Esta é a primeira vez que estamos imprimindo

15176
10:09:40,400 --> 10:09:42,640
um endereço que é armazenado em um

15177
10:09:42,640 --> 10:09:44,720
ponteiro e vamos ver isso

15178
10:09:44,720 --> 10:09:46,880
O console aqui o que eu vou fazer

15179
10:09:46,880 --> 10:09:49,200
antes de construir e executar isso eu estou indo

15180
10:09:49,200 --> 10:09:50,880
para comentar tudo o que fizemos

15181
10:09:50,880 --> 10:09:53,120
antes porque nosso console é agora

15182
10:09:53,120 --> 10:09:54,320
Desordenado

15183
10:09:54,320 --> 10:09:58,960
Então vamos vir e comentar tudo

15184
10:09:58,960 --> 10:10:01,520
e vamos descer novamente agora se imprimirmos

15185
10:10:01,520 --> 10:10:03,360
nós vamos ver essas duas declarações

15186
10:10:03,360 --> 10:10:07,120
E isso vai ser mais fácil de seguir

15187
10:10:07,120 --> 10:10:09,596
no console aqui a construção é bom

15188
10:10:09,596 --> 10:10:11,200
Somos legais

15189
10:10:11,200 --> 10:10:13,276
Vamos correr o galo

15190
10:10:13,276 --> 10:10:16,080
e o var é 43 e seu endereço em

15191
10:10:16,080 --> 10:10:18,720
A memória é esse número aqui em

15192
10:10:18,720 --> 10:10:21,360
hexadecimal, então este é o endereço em

15193
10:10:21,360 --> 10:10:24,400
memória e podemos imprimir isso e ver

15194
10:10:24,400 --> 10:10:26,640
O que é bom, então isso é muito legal

15195
10:10:26,640 --> 10:10:29,120
mas também podemos alterar o que é armazenado em

15196
10:10:29,120 --> 10:10:31,276
nosso ponteiro aqui, por exemplo, podemos definir

15197
10:10:31,276 --> 10:10:34,240
para uma outra variável chamá-lo para o nosso

15198
10:10:34,240 --> 10:10:37,756
e uh mudar pnt que é um ponteiro para

15199
10:10:37,756 --> 10:10:40,320
conter o endereço desta nova variável

15200
10:10:40,320 --> 10:10:42,880
e podemos fazer isso agora se imprimirmos

15201
10:10:42,880 --> 10:10:44,880
Pagamento, vamos ver que

15202
10:10:44,880 --> 10:10:46,800
contém um endereço diferente e nós podemos

15203
10:10:46,800 --> 10:10:48,240
- Faz isso.

15204
10:10:48,240 --> 10:10:51,276
Então vamos construir com gcc novamente

15205
10:10:51,276 --> 10:10:53,276
nós vamos descer e limpar e correr

15206
10:10:53,276 --> 10:10:55,360
Galo e nós vamos ver isso agora

15207
10:10:55,360 --> 10:10:57,520
Temos um endereço diferente aquele que

15208
10:10:57,520 --> 10:11:01,756
tinha terminado em d e4 agora terminamos em de0

15209
10:11:01,756 --> 10:11:04,240
Estes são endereços diferentes e nós somos

15210
10:11:04,240 --> 10:11:06,560
Armazenar coisas diferentes em nosso ponteiro

15211
10:11:06,560 --> 10:11:08,240
Isso é muito legal você pode fazer algo

15212
10:11:08,240 --> 10:11:10,560
assim e a próxima coisa que queremos

15213
10:11:10,560 --> 10:11:14,000
Veja agora é que não podemos cruzar um sinal

15214
10:11:14,000 --> 10:11:16,960
entre ponteiros de diferentes tipos e

15215
10:11:16,960 --> 10:11:19,276
O que quero dizer aqui é que, por exemplo, se

15216
10:11:19,276 --> 10:11:21,840
Temos duas variáveis aqui uma

15217
10:11:21,840 --> 10:11:24,480
pontodor para terminar é inicializado sem

15218
10:11:24,480 --> 10:11:26,640
ponteiro e temos outra variável

15219
10:11:26,640 --> 10:11:28,560
que é uma var dupla que vai ser

15220
10:11:28,560 --> 10:11:30,000
do tipo duplo

15221
10:11:30,000 --> 10:11:33,916
e não podemos fazer algo como pagamento

15222
10:11:33,916 --> 10:11:37,360
igual endereço da barra dupla que você não pode

15223
10:11:37,360 --> 10:11:38,960
fazer algo assim se você fizer isso

15224
10:11:38,960 --> 10:11:40,880
você vai receber um erro de compilador e

15225
10:11:40,880 --> 10:11:43,436
Você vê que nós temos linhas...

15226
10:11:43,436 --> 10:11:45,360
em código de estúdio visual este é um bom

15227
10:11:45,360 --> 10:11:47,596
Indicar que algo pode estar errado

15228
10:11:47,596 --> 10:11:49,916
Se abrirmos a aba de problemas, vamos

15229
10:11:49,916 --> 10:11:52,560
dizer que um valor de ponteiro duplo não pode

15230
10:11:52,560 --> 10:11:54,800
ser atribuído a uma entidade do tipo 8

15231
10:11:54,800 --> 10:11:57,840
pointer, então isso não é algo que você pode

15232
10:11:57,840 --> 10:11:59,436
Faz se você fizer isso, você vai ter um

15233
10:11:59,436 --> 10:12:02,560
Erro do compilador estar ciente deste visual

15234
10:12:02,560 --> 10:12:05,276
O código do estúdio nos alertou o suficiente, mas nós

15235
10:12:05,276 --> 10:12:07,436
Também pode tentar e obter

15236
10:12:07,436 --> 10:12:10,240
um erro claro do compilador através da construção deste

15237
10:12:10,240 --> 10:12:12,720
com gcc e nós vamos chegar

15238
10:12:12,720 --> 10:12:14,880
basicamente a mesma coisa que você não pode

15239
10:12:14,880 --> 10:12:16,800
Atribuição cruzada entre ponteiros de

15240
10:12:16,800 --> 10:12:20,240
Tipos diferentes que estamos tentando atribuir

15241
10:12:20,240 --> 10:12:22,000
um duplo endereço

15242
10:12:22,000 --> 10:12:24,240
em um ponteiro para entrar e isso não é

15243
10:12:24,240 --> 10:12:26,640
indo para o trabalho, então vamos comentar isso

15244
10:12:26,640 --> 10:12:28,320
porque não queremos este compilador

15245
10:12:28,320 --> 10:12:31,200
Erro agora você sabe disso e antes de nós

15246
10:12:31,200 --> 10:12:33,436
Feche esta palestra que quero mencionar

15247
10:12:33,436 --> 10:12:36,240
o que é chamado de referência e que

15248
10:12:36,240 --> 10:12:39,520
É o ato de ler algo

15249
10:12:39,520 --> 10:12:41,680
através de um ponteiro, então se tivermos uma

15250
10:12:41,680 --> 10:12:43,680
endereço em um ponteiro que podemos passar

15251
10:12:43,680 --> 10:12:46,480
esse endereço e realmente ler o valor

15252
10:12:46,480 --> 10:12:48,800
contidos nesse endereço e nós podemos fazer

15253
10:12:48,800 --> 10:12:51,040
Algo assim, então se tivermos

15254
10:12:51,040 --> 10:12:54,160
exemplo um ponteiro final, vamos chamá-lo p

15255
10:12:54,160 --> 10:12:57,276
e dois temos uma variável como esta

15256
10:12:57,276 --> 10:12:59,436
então vamos dizer que nós inicializamos isso com

15257
10:12:59,436 --> 10:13:02,480
nodepointer e temos um fim

15258
10:13:02,480 --> 10:13:06,400
variável e este é um 56, por exemplo

15259
10:13:06,400 --> 10:13:09,436
E fazemos algo como dizemos

15260
10:13:09,436 --> 10:13:12,400
pnt2 vamos fazê-lo conter o

15261
10:13:12,400 --> 10:13:14,560
endereço de dados int isso é algo

15262
10:13:14,560 --> 10:13:16,960
Você sabe que pode fazer agora agora que queremos

15263
10:13:16,960 --> 10:13:19,680
passar as 14h para ler o que é

15264
10:13:19,680 --> 10:13:23,200
contidas em interdata porque pn 2

15265
10:13:23,200 --> 10:13:26,400
contém o endereço do nosso inteiro aqui

15266
10:13:26,400 --> 10:13:29,916
Então o que podemos fazer, podemos fazer stdc out e

15267
10:13:29,916 --> 10:13:32,560
Diga valor e a sintaxe que usamos em c

15268
10:13:32,560 --> 10:13:35,040
plus plus é assim que dizemos armazenar e

15269
10:13:35,040 --> 10:13:37,120
Dizemos nossa variável de ponteiro que estamos indo

15270
10:13:37,120 --> 10:13:40,160
para dizer pnt2 e agora, se corrermos, estamos

15271
10:13:40,160 --> 10:13:42,640
Vou obter o valor aqui impresso

15272
10:13:42,640 --> 10:13:44,560
Tudo bem agora, se tentarmos construir, estamos indo

15273
10:13:44,560 --> 10:13:48,320
para construir fino vamos tentar com gcc

15274
10:13:48,320 --> 10:13:49,840
O mundo é bom

15275
10:13:49,840 --> 10:13:51,200
nós podemos limpar

15276
10:13:51,200 --> 10:13:53,520
para que as flechas de

15277
10:13:53,520 --> 10:13:56,800
uma corrida anterior é eliminada

15278
10:13:56,800 --> 10:13:59,680
Você vê que a bala é boa que podemos agora

15279
10:13:59,680 --> 10:14:01,200
correr o galo

15280
10:14:01,200 --> 10:14:03,520
e vamos ver que o valor é 56

15281
10:14:03,520 --> 10:14:05,120
nós somos com sucesso

15282
10:14:05,120 --> 10:14:07,680
Ler o valor armazenado no endereço

15283
10:14:07,680 --> 10:14:10,240
apontado pelo nosso ponteiro aqui e este

15284
10:14:10,240 --> 10:14:12,960
é a sintaxe usada e isso se chama

15285
10:14:12,960 --> 10:14:14,800
A referência a um ponteiro que somos

15286
10:14:14,800 --> 10:14:17,436
Leia basicamente algo armazenado em

15287
10:14:17,436 --> 10:14:19,360
O endereço de um ponteiro é o que nós

15288
10:14:19,360 --> 10:14:21,520
Quer dizer aqui isso é realmente tudo o que estabelecemos

15289
10:14:21,520 --> 10:14:23,276
para fazer nesta palestra a palestra virou

15290
10:14:23,276 --> 10:14:26,400
para ser longo, mas tivemos um monte de

15291
10:14:26,400 --> 10:14:29,200
chão para cobrir e agora eu espero que você tenha

15292
10:14:29,200 --> 10:14:31,680
Boa compreensão de como declarar

15293
10:14:31,680 --> 10:14:34,480
inicialize e use seus ponteiros para fazer

15294
10:14:34,480 --> 10:14:36,560
Todos os tipos de coisas loucas

15295
10:14:36,560 --> 10:14:38,240
Vamos parar aqui neste

15296
10:14:38,240 --> 10:14:40,160
palestra no próximo, vamos

15297
10:14:40,160 --> 10:14:42,480
Aprenda um pouco mais sobre ponteiro para

15298
10:14:42,480 --> 10:14:45,040
Tipos de caracteres porque eles também são

15299
10:14:45,040 --> 10:14:46,160
Especial

15300
10:14:46,160 --> 10:14:48,480
Vá em frente e termine aqui e me encontre

15301
10:14:48,480 --> 10:14:50,560
lá nesta palestra vamos

15302
10:14:50,560 --> 10:14:53,596
Explorar ponteiro para personagens

15303
10:14:53,596 --> 10:14:55,756
e você pode declarar um ponteiro para um

15304
10:14:55,756 --> 10:14:58,160
personagem assim temos carro

15305
10:14:58,160 --> 10:14:59,200
O ponteiro

15306
10:14:59,200 --> 10:15:02,080
e nós dizemos p carvar para dar-lhe um

15307
10:15:02,080 --> 10:15:04,240
A variável nome inicializamos isso com um

15308
10:15:04,240 --> 10:15:06,880
ponteiro null e depois disso nós configuramos um

15309
10:15:06,880 --> 10:15:09,360
variável de caracteres e é chamado

15310
10:15:09,360 --> 10:15:12,880
corvar e nós armazenamos em um maiúsculo

15311
10:15:12,880 --> 10:15:16,400
Depois disso, tomamos o endereço do carro

15312
10:15:16,400 --> 10:15:19,276
de r e atribuir isso ao nosso ponteiro

15313
10:15:19,276 --> 10:15:21,680
variável é assim que armazenamos dados em um

15314
10:15:21,680 --> 10:15:23,916
ponteiro e nós podemos passar por isso

15315
10:15:23,916 --> 10:15:26,720
ponteiro para acessar dados neste personagem

15316
10:15:26,720 --> 10:15:28,880
variável se fizermos algo assim

15317
10:15:28,880 --> 10:15:30,880
nós vamos imprimir um aqui em baixo nós

15318
10:15:30,880 --> 10:15:33,360
declarar outra variável que armazenamos em um c

15319
10:15:33,360 --> 10:15:34,880
E nós

15320
10:15:34,880 --> 10:15:37,756
Atribuir o endereço deste novo personagem

15321
10:15:37,756 --> 10:15:40,480
variável para a nossa variável ponteiro e se

15322
10:15:40,480 --> 10:15:42,960
nós imprimimos isso novamente, vamos ter um

15323
10:15:42,960 --> 10:15:45,040
c impresso para fora este é realmente o que nós

15324
10:15:45,040 --> 10:15:46,720
Fizemos na última palestra que somos

15325
10:15:46,720 --> 10:15:48,720
apenas estendendo isso ao personagem

15326
10:15:48,720 --> 10:15:51,120
ponteiros, mas com os ponteiros de caráter

15327
10:15:51,120 --> 10:15:53,520
Pode fazer algo realmente especial

15328
10:15:53,520 --> 10:15:55,200
pode fazer isso é especial que você pode

15329
10:15:55,200 --> 10:15:58,000
inicialize isso com uma string literal

15330
10:15:58,000 --> 10:16:00,160
Algo como o hello world que é

15331
10:16:00,160 --> 10:16:03,040
envolto em citações como esta quando você faz

15332
10:16:03,040 --> 10:16:05,040
Algo assim que a corda aqui é

15333
10:16:05,040 --> 10:16:07,840
Será expandido para um personagem

15334
10:16:07,840 --> 10:16:11,040
A matriz e o primeiro personagem do nosso

15335
10:16:11,040 --> 10:16:14,080
A matriz será apontada por p

15336
10:16:14,080 --> 10:16:16,800
Mensagem aqui é o que queremos dizer eu

15337
10:16:16,800 --> 10:16:18,880
Percebe que eu poderia estar jogando um monte de

15338
10:16:18,880 --> 10:16:21,436
Coisas em você agora estou me misturando

15339
10:16:21,436 --> 10:16:23,756
arrays e ponteiros, mas eles têm um

15340
10:16:23,756 --> 10:16:25,916
Relacionamento muito forte e nós somos

15341
10:16:25,916 --> 10:16:28,000
Vou aprender sobre isso em detalhes em um

15342
10:16:28,000 --> 10:16:30,640
Poucas palestras à frente, mas por enquanto

15343
10:16:30,640 --> 10:16:33,200
Pense nisso assim este hello mundo

15344
10:16:33,200 --> 10:16:34,880
string vai ser transformada em um

15345
10:16:34,880 --> 10:16:37,596
A matriz de caracteres e a mensagem p é

15346
10:16:37,596 --> 10:16:40,240
Vou apontar para o primeiro personagem

15347
10:16:40,240 --> 10:16:42,400
Neste array aqui é isso que está acontecendo

15348
10:16:42,400 --> 10:16:44,400
para acontecer e isso vai nos dar

15349
10:16:44,400 --> 10:16:46,480
A flexibilidade de tratar o nosso

15350
10:16:46,480 --> 10:16:49,840
pontos fortes como ponteiros de caráter e isso

15351
10:16:49,840 --> 10:16:51,756
Vai ser útil para muitos

15352
10:16:51,756 --> 10:16:52,960
Ocasiões

15353
10:16:52,960 --> 10:16:54,800
Uma coisa que eu deveria te dizer é

15354
10:16:54,800 --> 10:16:57,200
que alguns compiladores se recusarão a

15355
10:16:57,200 --> 10:17:00,080
compilar este código por exemplo visual

15356
10:17:00,080 --> 10:17:02,560
studio 19 que eu tenho instalado no meu

15357
10:17:02,560 --> 10:17:04,720
O computador agora vai recusar-se a

15358
10:17:04,720 --> 10:17:07,200
compilar este código e a razão é o

15359
10:17:07,200 --> 10:17:09,360
O compilador vai expandir isso

15360
10:17:09,360 --> 10:17:11,120
A força em

15361
10:17:11,120 --> 10:17:14,960
uma matriz de caráter de carro const

15362
10:17:14,960 --> 10:17:17,756
Aqui o que estamos usando para apontar para

15363
10:17:17,756 --> 10:17:20,560
que não é um ponteiro de carro de custo

15364
10:17:20,560 --> 10:17:23,756
assim, este ponteiro aqui pode ser usado para tentar

15365
10:17:23,756 --> 10:17:27,040
e modificar dados em uma matriz de custos

15366
10:17:27,040 --> 10:17:29,120
Carros e isso vai ser desastroso

15367
10:17:29,120 --> 10:17:31,360
porque se você tentar modificar isso

15368
10:17:31,360 --> 10:17:33,200
que vai falhar e isso não é

15369
10:17:33,200 --> 10:17:35,200
Vai ser bom, então alguns compiladores são

15370
10:17:35,200 --> 10:17:37,756
Vou tentar protegê-lo disso

15371
10:17:37,756 --> 10:17:41,276
e forçar você a usar ponteiros que são

15372
10:17:41,276 --> 10:17:43,756
qualificado com custo para realmente significar que

15373
10:17:43,756 --> 10:17:46,320
eles são ponteiros de carro fechados e para obter

15374
10:17:46,320 --> 10:17:48,240
o código para trabalhar que teremos que fazer isso

15375
10:17:48,240 --> 10:17:49,840
E eu vou te mostrar como fazemos isso em

15376
10:17:49,840 --> 10:17:52,000
código de estúdio visual, mas eu tenho que dizer

15377
10:17:52,000 --> 10:17:54,320
Você, neste caso, você só quer pular

15378
10:17:54,320 --> 10:17:56,640
à frente e tente este código se você conseguir um

15379
10:17:56,640 --> 10:17:58,640
Erro do compilador que vai ser o

15380
10:17:58,640 --> 10:18:00,480
Razão agora que temos a nossa força

15381
10:18:00,480 --> 10:18:02,400
armazenados na memória, podemos realmente imprimi-lo

15382
10:18:02,400 --> 10:18:04,800
fora assim se você imprimir p message

15383
10:18:04,800 --> 10:18:06,400
Você vai imprimir este anel

15384
10:18:06,400 --> 10:18:09,040
fora, mas eu quero te dar uma pergunta

15385
10:18:09,040 --> 10:18:09,916
aqui

15386
10:18:09,916 --> 10:18:12,720
O que você acha que vamos conseguir se nós

15387
10:18:12,720 --> 10:18:14,960
dereference p message

15388
10:18:14,960 --> 10:18:16,720
Tente pensar sobre isso

15389
10:18:16,720 --> 10:18:19,120
Eu disse que o compilador está indo para

15390
10:18:19,120 --> 10:18:21,840
expandir esta corda do mundo hello em um

15391
10:18:21,840 --> 10:18:25,120
variedade de caracteres ou para ser específico

15392
10:18:25,120 --> 10:18:27,436
matriz de cartões de const

15393
10:18:27,436 --> 10:18:30,080
e p mensagem vai apontar para

15394
10:18:30,080 --> 10:18:31,680
O primeiro personagem

15395
10:18:31,680 --> 10:18:33,360
em essa matriz

15396
10:18:33,360 --> 10:18:36,480
então, se dereferenciamos p mensagem, somos

15397
10:18:36,480 --> 10:18:38,480
Vou imprimir esse personagem

15398
10:18:38,480 --> 10:18:40,960
Neste caso, vamos ter um h e isso é

15399
10:18:40,960 --> 10:18:42,640
O que vai acontecer aqui mas

15400
10:18:42,640 --> 10:18:45,756
Os ponteiros de caráter são especiais nisso

15401
10:18:45,756 --> 10:18:48,400
se você imprimi-los para fora diretório

15402
10:18:48,400 --> 10:18:51,120
O compilador vai fazer a sua magia e

15403
10:18:51,120 --> 10:18:53,840
tornar possível imprimir o todo

15404
10:18:53,840 --> 10:18:56,640
string que é armazenado em p message aqui

15405
10:18:56,640 --> 10:18:58,800
É assim que os ponteiros de personagens são

15406
10:18:58,800 --> 10:19:00,800
especial e você realmente precisa estar ciente

15407
10:19:00,800 --> 10:19:02,640
Isto porque isso vai entrar

15408
10:19:02,640 --> 10:19:06,400
muitas vezes para enfatizar que

15409
10:19:06,400 --> 10:19:08,640
Isso vai ser expandido em um

15410
10:19:08,640 --> 10:19:11,520
variedade de caracteres constantes se tentarmos

15411
10:19:11,520 --> 10:19:12,800
para modificar

15412
10:19:12,800 --> 10:19:15,200
algo dentro da mensagem p aqui para

15413
10:19:15,200 --> 10:19:18,400
Um exemplo, tentamos transformar o h em um b

15414
10:19:18,400 --> 10:19:20,880
Podemos tentar fazer isso porque p message

15415
10:19:20,880 --> 10:19:23,436
está apontando para o primeiro personagem, então nós

15416
10:19:23,436 --> 10:19:26,320
pode tentar desreferenciar e atribuir um novo

15417
10:19:26,320 --> 10:19:28,960
valor e se fizermos isso, vamos

15418
10:19:28,960 --> 10:19:31,200
obter uma seta do compilador ou ainda pior nós

15419
10:19:31,200 --> 10:19:34,080
pode ter um acidente no tempo de execução, então isso é

15420
10:19:34,080 --> 10:19:36,400
Algo que você realmente não deve fazer e

15421
10:19:36,400 --> 10:19:38,160
Você deve realmente sinalizar

15422
10:19:38,160 --> 10:19:41,040
sua mensagem p aqui como o cartão de custo

15423
10:19:41,040 --> 10:19:43,120
O ponteiro e isso vai te impedir

15424
10:19:43,120 --> 10:19:45,040
de fazer coisas assim, o que pode

15425
10:19:45,040 --> 10:19:47,520
A ser muito ruim, mas a maioria

15426
10:19:47,520 --> 10:19:50,320
Os compiladores vão até mesmo impedir você

15427
10:19:50,320 --> 10:19:52,960
de compilar essa coisa no moderno

15428
10:19:52,960 --> 10:19:55,360
por exemplo, se você estiver usando um

15429
10:19:55,360 --> 10:19:57,120
Uma versão muito recente

15430
10:19:57,120 --> 10:19:59,680
de estúdio visual que você vai ter um

15431
10:19:59,680 --> 10:20:02,640
erro do compilador, mas eu não acredito no gcc

15432
10:20:02,640 --> 10:20:04,960
vai nos dar um erro de compilador, então

15433
10:20:04,960 --> 10:20:07,276
teremos que experimentar isso e ver como

15434
10:20:07,276 --> 10:20:10,240
ele se comporta, mas a mensagem é se você

15435
10:20:10,240 --> 10:20:12,400
Tenho que fazer algo assim, certifique-se de

15436
10:20:12,400 --> 10:20:15,040
você usa o ponteiro do carro de custo e você está

15437
10:20:15,040 --> 10:20:17,200
Vou jogar no lado seguro

15438
10:20:17,200 --> 10:20:19,596
Ok agora eu acho que você sabe o suficiente sobre

15439
10:20:19,596 --> 10:20:21,916
Personagem ponteiros e se quisermos

15440
10:20:21,916 --> 10:20:24,800
usuários para ser capaz de alterar esta string

15441
10:20:24,800 --> 10:20:26,560
e fazer com que seja outra coisa para

15442
10:20:26,560 --> 10:20:28,880
O exemplo muda o primeiro personagem aqui

15443
10:20:28,880 --> 10:20:31,680
em um poço b nesse caso não use

15444
10:20:31,680 --> 10:20:34,720
ponteiros de caracteres usam arrays regulares

15445
10:20:34,720 --> 10:20:37,436
Como já vimos antes para que você possa definir

15446
10:20:37,436 --> 10:20:40,080
Um array como este, vai ser um

15447
10:20:40,080 --> 10:20:43,360
array de caracteres e você pode inicializar

15448
10:20:43,360 --> 10:20:45,916
Isso com a string literal e isso é

15449
10:20:45,916 --> 10:20:47,680
permitindo que você modifique as coisas

15450
10:20:47,680 --> 10:20:50,160
Por dentro, se fizermos algo assim

15451
10:20:50,160 --> 10:20:52,880
Vamos imprimir a mensagem e

15452
10:20:52,880 --> 10:20:54,400
A mensagem será adaptada

15453
10:20:54,400 --> 10:20:57,276
porque nós mudamos a borda para ser

15454
10:20:57,276 --> 10:21:00,320
a t e isso vai funcionar, então isso é

15455
10:21:00,320 --> 10:21:02,480
Algo que você realmente precisa estar ciente

15456
10:21:02,480 --> 10:21:05,200
Mas ponteiros de personagens são muito úteis

15457
10:21:05,200 --> 10:21:07,756
em muitos casos e na maioria dos casos você apenas

15458
10:21:07,756 --> 10:21:09,840
querer armazenar a string e imprimi-la

15459
10:21:09,840 --> 10:21:12,000
Você não está interessado em mudá-lo

15460
10:21:12,000 --> 10:21:13,756
Então é por isso que isso vai entrar

15461
10:21:13,756 --> 10:21:17,040
útil em muitas ocasiões agora que você

15462
10:21:17,040 --> 10:21:18,400
Eu sei que vamos nos dirigir para

15463
10:21:18,400 --> 10:21:20,720
código de estúdio visual e realmente tentar isso

15464
10:21:20,720 --> 10:21:23,840
Tudo bem aqui estamos em nosso trabalho

15465
10:21:23,840 --> 10:21:26,320
pasta a projeto atual é ponteiro para

15466
10:21:26,320 --> 10:21:29,520
Carro é o que estamos explorando aqui, então

15467
10:21:29,520 --> 10:21:31,276
nós vamos pegar nossos arquivos de modelo

15468
10:21:31,276 --> 10:21:34,080
e colocá-los no lugar e nós vamos

15469
10:21:34,080 --> 10:21:36,560
para abrir essa coisa em estúdio visual

15470
10:21:36,560 --> 10:21:38,800
código e nós vamos saltar para aqui

15471
10:21:38,800 --> 10:21:42,320
e configurar o nosso primeiro const car pointer

15472
10:21:42,320 --> 10:21:44,720
Vamos fazer um ponteiro para ver como isso

15473
10:21:44,720 --> 10:21:46,800
A coisa se comporta, vamos chamar isso

15474
10:21:46,800 --> 10:21:48,960
mensagem e vamos inicializar

15475
10:21:48,960 --> 10:21:52,240
Isso com a nossa fiel mensagem aqui, olá

15476
10:21:52,240 --> 10:21:54,080
Mundo ok uma vez que você faz algo como

15477
10:21:54,080 --> 10:21:56,560
esta sua string vai ser referida

15478
10:21:56,560 --> 10:21:57,276
A sua forma de

15479
10:21:57,276 --> 10:21:59,680
por mensagem, vamos tentar compilar isso

15480
10:21:59,680 --> 10:22:02,720
e ver que gcc está feliz que podemos compilar

15481
10:22:02,720 --> 10:22:04,640
com o Gcc

15482
10:22:04,640 --> 10:22:06,880
E uh vai nos dizer que não podemos

15483
10:22:06,880 --> 10:22:09,436
Realmente fazer aquilo e isso é realmente bom

15484
10:22:09,436 --> 10:22:11,680
para base convertendo uma string em constante

15485
10:22:11,680 --> 10:22:14,400
ponto de vista de cartão, então o que estamos fazendo realmente

15486
10:22:14,400 --> 10:22:19,040
está fazendo uma série de personagens de const

15487
10:22:19,040 --> 10:22:22,560
e refira-se a ele como um ponteiro de carro e

15488
10:22:22,560 --> 10:22:24,320
Isso não vai funcionar, isso é um bom

15489
10:22:24,320 --> 10:22:26,640
Uma coisa para que você não possa realmente fazer isso e

15490
10:22:26,640 --> 10:22:28,560
Isto é uma coisa boa

15491
10:22:28,560 --> 10:22:32,320
e vamos tentar ver se estúdio visual

15492
10:22:32,320 --> 10:22:34,320
Podemos realmente fazer isso, nós vamos

15493
10:22:34,320 --> 10:22:37,276
construir com msvc neste caso vamos fazer

15494
10:22:37,276 --> 10:22:40,080
ler para o galo antes de fazermos que podemos

15495
10:22:40,080 --> 10:22:43,040
Clique direito para adicionar e dizer excluir

15496
10:22:43,040 --> 10:22:45,436
Vamos clicar em primeiro lugar

15497
10:22:45,436 --> 10:22:48,240
certifique-se de que ele está selecionado e clique em excluir

15498
10:22:48,240 --> 10:22:49,596
para removê-lo

15499
10:22:49,596 --> 10:22:52,000
mover-se para a lixeira neste caso

15500
10:22:52,000 --> 10:22:53,840
Agora nós vamos limpar aqui vamos

15501
10:22:53,840 --> 10:22:56,640
trazer para cima o nosso terminal novamente

15502
10:22:56,640 --> 10:22:58,960
E nós vamos limpar

15503
10:22:58,960 --> 10:23:02,320
e nós vamos construir com gcc

15504
10:23:02,320 --> 10:23:05,200
nós vamos escolher o compilador msvc

15505
10:23:05,200 --> 10:23:08,320
Se você está tentando construir isso

15506
10:23:08,320 --> 10:23:10,080
O mundo acaba com isso

15507
10:23:10,080 --> 10:23:12,960
com erros e o erro vai ser

15508
10:23:12,960 --> 10:23:15,360
basicamente a mesma coisa nesta linha aqui

15509
10:23:15,360 --> 10:23:17,756
Não vai trabalhar o que podemos fazer é fazer isso

15510
10:23:17,756 --> 10:23:20,560
custo e torná-lo super claro

15511
10:23:20,560 --> 10:23:23,596
essa mensagem aqui vai apontar para

15512
10:23:23,596 --> 10:23:26,080
uma variedade de const carro

15513
10:23:26,080 --> 10:23:27,680
Se tentarmos construir de novo eu acho que estamos

15514
10:23:27,680 --> 10:23:30,640
Vou ser bom agora, então vamos tentar fazer

15515
10:23:30,640 --> 10:23:31,756
que

15516
10:23:31,756 --> 10:23:35,360
Vamos construir com msvc desta vez

15517
10:23:35,360 --> 10:23:38,240
E o mundo terminou com sucesso

15518
10:23:38,240 --> 10:23:40,240
Agora isso é muito legal e podemos imprimir

15519
10:23:40,240 --> 10:23:42,960
Isso podemos dizer sddc para fora

15520
10:23:42,960 --> 10:23:44,960
Mensagem de mensagem

15521
10:23:44,960 --> 10:23:48,880
E nós vamos dizer mensagem

15522
10:23:49,360 --> 10:23:51,040
E isso vai funcionar

15523
10:23:51,040 --> 10:23:53,200
Vamos voltar ao Gcc porque isso é meu

15524
10:23:53,200 --> 10:23:55,120
O compilador favorito e você vê que

15525
10:23:55,120 --> 10:23:57,040
Compilador de estúdio visual está indo para

15526
10:23:57,040 --> 10:23:59,120
bagtter nossa pasta aqui com um monte de

15527
10:23:59,120 --> 10:24:00,240
Arquivos de arquivos

15528
10:24:00,240 --> 10:24:02,480
nós não queremos isso o que eu vou fazer

15529
10:24:02,480 --> 10:24:04,320
Eu vou selecionar todo esse colecionador

15530
10:24:04,320 --> 10:24:06,880
aqui e remover isso e eu vou

15531
10:24:06,880 --> 10:24:09,360
hit delete com o clique direito

15532
10:24:09,360 --> 10:24:11,120
E vai desaparecer

15533
10:24:11,120 --> 10:24:14,160
nós vamos voltar para o gcc e usá-lo

15534
10:24:14,160 --> 10:24:16,640
e construir com gcc

15535
10:24:16,640 --> 10:24:18,240
A construção vai passar porque

15536
10:24:18,240 --> 10:24:21,436
nós qualificou nosso ponteiro de caráter com

15537
10:24:21,436 --> 10:24:24,080
Custo aqui e tudo vai ser

15538
10:24:24,080 --> 10:24:25,756
Bom ter certeza

15539
10:24:25,756 --> 10:24:28,480
Você sabe o que está acontecendo aqui porque

15540
10:24:28,480 --> 10:24:31,040
Este tipo de problemas pode ser muito difícil

15541
10:24:31,040 --> 10:24:33,596
para resolver ok agora que temos isso nós

15542
10:24:33,596 --> 10:24:35,756
pode tentar mudar algo por dentro, mas

15543
10:24:35,756 --> 10:24:37,756
o compilador não vai permitir isso

15544
10:24:37,756 --> 10:24:40,080
Se tentarmos fazer algo assim é

15545
10:24:40,080 --> 10:24:43,040
não vai funcionar porque a mensagem é uma

15546
10:24:43,040 --> 10:24:45,756
ponteiro para o carro fechado

15547
10:24:45,756 --> 10:24:47,680
e não podemos passar por este ponteiro para

15548
10:24:47,680 --> 10:24:50,480
modificar algo para que vamos ter um

15549
10:24:50,480 --> 10:24:52,160
seta do compilador, isso é algo que você

15550
10:24:52,160 --> 10:24:55,680
deve saber, mas podemos adicionar a referência

15551
10:24:55,680 --> 10:24:58,000
este ponteiro e imprimir algo que é

15552
10:24:58,000 --> 10:25:00,320
dentro e eu quero que você adivinhe novamente e

15553
10:25:00,320 --> 10:25:02,080
Veja que você pode vir com o que é

15554
10:25:02,080 --> 10:25:03,680
vai ser impresso se com o

15555
10:25:03,680 --> 10:25:06,640
mensagem de referência e impressão quando nós

15556
10:25:06,640 --> 10:25:09,436
executar este programa se tivermos essa coisa

15557
10:25:09,436 --> 10:25:11,276
Imprimido aqui novamente nós somos o

15558
10:25:11,276 --> 10:25:13,276
Referindo o ponteiro

15559
10:25:13,276 --> 10:25:16,160
e imprimir qualquer resultado que ocorramos

15560
10:25:16,160 --> 10:25:19,916
que lembram que esta cadeia literal

15561
10:25:19,916 --> 10:25:23,040
vai ser transformado em uma matriz de

15562
10:25:23,040 --> 10:25:25,916
const carros e o primeiro elemento disso

15563
10:25:25,916 --> 10:25:28,320
A matriz vai ser apontada para

15564
10:25:28,320 --> 10:25:32,240
por esta mensagem de carro ponteiro aqui, então se

15565
10:25:32,240 --> 10:25:35,436
nós dereferênciamos essa coisa que devemos obter

15566
10:25:35,436 --> 10:25:37,756
o h aqui impresso é isso que eu

15567
10:25:37,756 --> 10:25:39,436
Acho que devemos conseguir

15568
10:25:39,436 --> 10:25:41,200
Vamos tentar e fugir

15569
10:25:41,200 --> 10:25:43,436
E o Gcc, claro

15570
10:25:43,436 --> 10:25:45,596
O parafuso vai ser bom, vamos limpar

15571
10:25:45,596 --> 10:25:47,436
e correr o galo

15572
10:25:47,436 --> 10:25:50,560
Veja que a mensagem h é exatamente

15573
10:25:50,560 --> 10:25:52,640
O que esperamos aqui agora que temos

15574
10:25:52,640 --> 10:25:54,080
Este trabalho

15575
10:25:54,080 --> 10:25:57,436
E se realmente queremos essa coisa aqui

15576
10:25:57,436 --> 10:25:59,756
para trabalhar o que se quiséssemos permitir o nosso

15577
10:25:59,756 --> 10:26:01,680
Usuários para passar

15578
10:26:01,680 --> 10:26:04,320
esta mensagem e modificar o que é

15579
10:26:04,320 --> 10:26:06,160
armazenado dentro porque às vezes isso é

15580
10:26:06,160 --> 10:26:07,276
Vou ser

15581
10:26:07,276 --> 10:26:10,000
útil bem, queríamos permitir que nossos usuários

15582
10:26:10,000 --> 10:26:11,916
para modificar essa tendência se você quiser fazer

15583
10:26:11,916 --> 10:26:15,680
que você pode usar arrays de caracteres de linha

15584
10:26:15,680 --> 10:26:17,680
E a maneira como fazemos isso, podemos dizer carro

15585
10:26:17,680 --> 10:26:20,880
mensagem um e nós podemos torná-lo um array

15586
10:26:20,880 --> 10:26:23,360
e inicializar isso com olá mundo e

15587
10:26:23,360 --> 10:26:25,276
Uma vez que fazemos isso, podemos passar pelo

15588
10:26:25,276 --> 10:26:28,400
ângulo bracket sintaxe e modificar o

15589
10:26:28,400 --> 10:26:31,276
primeiro personagem ou qualquer personagem que

15590
10:26:31,276 --> 10:26:33,200
realmente quer modificar nesta string

15591
10:26:33,200 --> 10:26:36,240
Aqui, neste caso, vamos atacar

15592
10:26:36,240 --> 10:26:38,240
Primeiro, então vamos dizer mensagem

15593
10:26:38,240 --> 10:26:42,240
1 e nós vamos pegar o índice 0

15594
10:26:42,240 --> 10:26:43,916
Porque isso vai ser o primeiro

15595
10:26:43,916 --> 10:26:46,240
personagem aqui e vamos atribuir

15596
10:26:46,240 --> 10:26:48,800
Um novo personagem, digamos

15597
10:26:48,800 --> 10:26:51,840
b como dissemos e se imprimimos isso

15598
10:26:51,840 --> 10:26:56,080
para dizer mensagem um e uh colocar isso para fora

15599
10:26:56,080 --> 10:26:58,000
nós vamos ver o que sai se nós

15600
10:26:58,000 --> 10:26:59,680
executar este programa que vamos construir

15601
10:26:59,680 --> 10:27:01,120
com o Gcc

15602
10:27:01,120 --> 10:27:03,436
então vamos fazer isso

15603
10:27:03,436 --> 10:27:06,800
O mundo é bom, então estamos bem aqui

15604
10:27:06,800 --> 10:27:08,640
Se nós estamos, vamos ficar abaixo

15605
10:27:08,640 --> 10:27:11,040
impresso para baixo e temos com sucesso

15606
10:27:11,040 --> 10:27:13,680
Mudou esta coisa aqui, então se você não mudar

15607
10:27:13,680 --> 10:27:15,596
quer permitir modificações para o seu

15608
10:27:15,596 --> 10:27:18,640
A força use essa coisa aqui se quiser

15609
10:27:18,640 --> 10:27:21,200
para permitir a modificação em sua força

15610
10:27:21,200 --> 10:27:23,596
Use esta sintaxe aqui e isso é realmente

15611
10:27:23,596 --> 10:27:25,520
Tudo o que tínhamos a dizer

15612
10:27:25,520 --> 10:27:27,596
Nesta palestra nesta palestra estamos

15613
10:27:27,596 --> 10:27:31,120
Vamos revisitar a nossa ideia de um c plus

15614
10:27:31,120 --> 10:27:32,560
mais o programa

15615
10:27:32,560 --> 10:27:34,960
mapa de memória que vimos que o c plus

15616
10:27:34,960 --> 10:27:37,120
além do fluxo de trabalho de desenvolvimento realmente vai

15617
10:27:37,120 --> 10:27:39,276
assim, temos um programa digitado para fora

15618
10:27:39,276 --> 10:27:41,520
nosso ide nós passamos isso através do

15619
10:27:41,520 --> 10:27:44,320
Compilador e nós temos um executável binário

15620
10:27:44,320 --> 10:27:47,276
que é uma representação binária do

15621
10:27:47,276 --> 10:27:50,320
código que temos em nosso programa c plus plus

15622
10:27:50,320 --> 10:27:52,960
Você pode executar esse programa em um

15623
10:27:52,960 --> 10:27:55,200
sistema operacional, por exemplo, aqui estou

15624
10:27:55,200 --> 10:27:58,480
nas janelas se eu clicar duas vezes no meu pontão

15625
10:27:58,480 --> 10:28:01,360
exe file, por exemplo, nossas aplicações

15626
10:28:01,360 --> 10:28:02,596
São chamados

15627
10:28:02,596 --> 10:28:05,520
galo.exe você viu-me correr este

15628
10:28:05,520 --> 10:28:07,360
Mil vezes até agora

15629
10:28:07,360 --> 10:28:09,596
Se clicarmos duas vezes este programa está indo

15630
10:28:09,596 --> 10:28:12,800
ser carregado na memória do nosso computador e

15631
10:28:12,800 --> 10:28:15,680
pela memória i quero dizer memória de acesso aleatório

15632
10:28:15,680 --> 10:28:17,756
A memória que vai ser ativa

15633
10:28:17,756 --> 10:28:19,840
executando as coisas quando elas acontecem em seu

15634
10:28:19,840 --> 10:28:22,240
computador é diferente do difícil

15635
10:28:22,240 --> 10:28:23,120
conduzir

15636
10:28:23,120 --> 10:28:25,436
armazenamento que também pode ser chamado de memória

15637
10:28:25,436 --> 10:28:27,276
E isso pode jogar fora um monte de

15638
10:28:27,276 --> 10:28:30,080
iniciantes, estamos falando de ram aqui

15639
10:28:30,080 --> 10:28:32,240
quando queremos dizer memória de memória de acesso aleatório

15640
10:28:32,240 --> 10:28:34,480
para ser exato se você clicar duas vezes em seu

15641
10:28:34,480 --> 10:28:36,880
programar ou abri-lo no terminal como

15642
10:28:36,880 --> 10:28:39,276
Estamos fazendo o programa para

15643
10:28:39,276 --> 10:28:41,680
ser carregado na memória e vai ser

15644
10:28:41,680 --> 10:28:44,880
armazenado em uma seção especial de memória

15645
10:28:44,880 --> 10:28:47,520
chamada área do programa e até agora temos

15646
10:28:47,520 --> 10:28:50,160
Tenho pensado que nosso programa é realmente

15647
10:28:50,160 --> 10:28:53,436
carregado em memória real em nosso computador

15648
10:28:53,436 --> 10:28:57,276
Mas não é esse o caso, é uma ideia de

15649
10:28:57,276 --> 10:28:59,840
A memória que o programa pensa

15650
10:28:59,840 --> 10:29:02,480
Eu tenho, mas não é a coisa real e eu sou

15651
10:29:02,480 --> 10:29:04,880
Vou explicar, mas antes de explicar

15652
10:29:04,880 --> 10:29:07,680
Deixe-me elaborar a razão pela qual isso

15653
10:29:07,680 --> 10:29:10,000
é feito se tivermos muitos programas e

15654
10:29:10,000 --> 10:29:12,320
Cada programa vai usar a memória real

15655
10:29:12,320 --> 10:29:15,436
em nosso computador podemos rapidamente acabar

15656
10:29:15,436 --> 10:29:17,040
de memória porque há muitos

15657
10:29:17,040 --> 10:29:19,276
programas que você pode até ter centenas ou

15658
10:29:19,276 --> 10:29:20,960
milhares de programas em execução em seu

15659
10:29:20,960 --> 10:29:22,960
computador que você pode nunca ter o suficiente

15660
10:29:22,960 --> 10:29:26,080
memória para executar todos eles se a memória real

15661
10:29:26,080 --> 10:29:28,240
Foi utilizado por cada programa

15662
10:29:28,240 --> 10:29:30,400
Então a ideia nasceu

15663
10:29:30,400 --> 10:29:31,120
A sua forma de

15664
10:29:31,120 --> 10:29:34,400
criar o que é chamado de memória virtual e

15665
10:29:34,400 --> 10:29:36,640
É um truque que puxa o seu programa

15666
10:29:36,640 --> 10:29:39,120
Pensar que é o único programa

15667
10:29:39,120 --> 10:29:41,916
rodando em seus sistemas operacionais e ele

15668
10:29:41,916 --> 10:29:44,960
possui ou o espaço de endereço ou todo o

15669
10:29:44,960 --> 10:29:46,720
memória em seu computador que é o que você tem

15670
10:29:46,720 --> 10:29:49,680


15671
10:29:49,680 --> 10:29:52,880
O programa tem dessa memória é chamado de

15672
10:29:52,880 --> 10:29:55,840
mapa de memória cada programa é abstraído

15673
10:29:55,840 --> 10:29:58,000
no que chamamos de processo que você pode

15674
10:29:58,000 --> 10:30:00,160
Pense em galo.exe

15675
10:30:00,160 --> 10:30:03,360
que estamos soldando como um processo

15676
10:30:03,360 --> 10:30:05,596
no sistema e cada processo tem

15677
10:30:05,596 --> 10:30:08,640
acesso ao intervalo de memória entre 0 e 0

15678
10:30:08,640 --> 10:30:11,436
2 para o poder de n onde n é o

15679
10:30:11,436 --> 10:30:14,560
número de bits que você está operando

15680
10:30:14,560 --> 10:30:17,240
suportes de sistema, por exemplo, eu estou em um

15681
10:30:17,240 --> 10:30:20,560
Sistema operacional de 64 bits para

15682
10:30:20,560 --> 10:30:23,200
A minha memória vai ficar entre 0 e 2

15683
10:30:23,200 --> 10:30:25,916
para o poder de 64. e isso é um monte de

15684
10:30:25,916 --> 10:30:28,320
memória do meu programa vai pensar que

15685
10:30:28,320 --> 10:30:31,276
ele possui tudo isso e nunca pode

15686
10:30:31,276 --> 10:30:32,880
correr para fora vai fazer o que quer que seja

15687
10:30:32,880 --> 10:30:35,520
quer se você estiver em um sistema de 32 bits

15688
10:30:35,520 --> 10:30:37,436
que vai ser entre 0 e 2 para

15689
10:30:37,436 --> 10:30:39,916
o poder de 32 e isso vai ser

15690
10:30:39,916 --> 10:30:42,640
Sua memória virtual a quantidade de memória

15691
10:30:42,640 --> 10:30:45,596
que seus fãs de programa que ele possui e

15692
10:30:45,596 --> 10:30:47,680
Acontece que é a totalidade de você

15693
10:30:47,680 --> 10:30:50,080
ra que você tem em seu sistema cada

15694
10:30:50,080 --> 10:30:52,720
O programa basicamente pensa que ele é dono

15695
10:30:52,720 --> 10:30:55,276
Toda a memória e pode fazer o que

15696
10:30:55,276 --> 10:30:58,000
Ele quer ok, então temos a memória do rio

15697
10:30:58,000 --> 10:31:00,160
que é memória de acesso aleatório e nós

15698
10:31:00,160 --> 10:31:02,720
ter memória virtual que vai ser

15699
10:31:02,720 --> 10:31:06,000
entre 0 e 2 para o poder de n OK

15700
10:31:06,000 --> 10:31:09,680
então agora vamos atualizar sobre a ideia

15701
10:31:09,680 --> 10:31:12,240
do modelo de execução do programa, pois

15702
10:31:12,240 --> 10:31:14,240
Agora sabemos mais que sabemos sobre o virtual

15703
10:31:14,240 --> 10:31:16,800
A memória aqui é o nosso programa c plus que é

15704
10:31:16,800 --> 10:31:18,800
indo passar pelo compilador e nós

15705
10:31:18,800 --> 10:31:21,200
vai gerar um arquivo binário

15706
10:31:21,200 --> 10:31:23,916
que vai ser uma representação de

15707
10:31:23,916 --> 10:31:25,916
Como as coisas vão ser dispostas em

15708
10:31:25,916 --> 10:31:27,916
memória em nosso programa

15709
10:31:27,916 --> 10:31:30,800
E se executarmos o programa

15710
10:31:30,800 --> 10:31:33,200
Vai passar por uma seção de

15711
10:31:33,200 --> 10:31:36,720
o cpu chamado unidade de gerenciamento de memória ou

15712
10:31:36,720 --> 10:31:40,800
mmu para abreviar de modo que o mmu seja

15713
10:31:40,800 --> 10:31:43,276
Basicamente, transformando-se entre o

15714
10:31:43,276 --> 10:31:47,200
mapa de memória de cada processo e do rádio

15715
10:31:47,200 --> 10:31:49,756
layout de memória que temos em ram o que

15716
10:31:49,756 --> 10:31:51,840
A unidade de gerenciamento de memória é

15717
10:31:51,840 --> 10:31:54,320
Realmente transformar entre o

15718
10:31:54,320 --> 10:31:56,640
representação que temos no mapa de memória

15719
10:31:56,640 --> 10:31:58,800
e a coisa real que temos em carneiro

15720
10:31:58,800 --> 10:32:00,720
Todo o programa não é carregado de verdade

15721
10:32:00,720 --> 10:32:02,480
Memória por Cpu

15722
10:32:02,480 --> 10:32:05,120
apenas partes do programa que são

15723
10:32:05,120 --> 10:32:07,436
realmente vai ser usado em breve descarregado em

15724
10:32:07,436 --> 10:32:09,360
memória e isso vai fazer

15725
10:32:09,360 --> 10:32:12,240
uso efetivo das partes de memória que

15726
10:32:12,240 --> 10:32:14,400
Não é provável que sejam usados

15727
10:32:14,400 --> 10:32:17,040
ser descartado da memória e armazenado

15728
10:32:17,040 --> 10:32:18,720
o disco rígido em vez disso e isso é

15729
10:32:18,720 --> 10:32:21,520
Muito legal, por favor, note que o real

15730
10:32:21,520 --> 10:32:23,120
A maneira como essas coisas são feitas é realmente

15731
10:32:23,120 --> 10:32:26,000
complicado, mas está enterrado em

15732
10:32:26,000 --> 10:32:28,480
A lógica do cpu e tudo o que você

15733
10:32:28,480 --> 10:32:30,080
Não precisa realmente se preocupar com isso como

15734
10:32:30,080 --> 10:32:32,480
um super plus programador, mas há um

15735
10:32:32,480 --> 10:32:34,320
Poucas coisas que você precisa saber como nós somos

15736
10:32:34,320 --> 10:32:36,880
Vamos ver nesta palestra tão memória

15737
10:32:36,880 --> 10:32:39,840
Unidade de gestão ajuda no mapeamento

15738
10:32:39,840 --> 10:32:40,960
Entre

15739
10:32:40,960 --> 10:32:42,880
o mapa de memória que você tem em seu programa

15740
10:32:42,880 --> 10:32:46,160
basicamente a ideia de que seu programa tem

15741
10:32:46,160 --> 10:32:49,120
da memória e da coisa real

15742
10:32:49,120 --> 10:32:51,916
que temos na memória ok aqui é um

15743
10:32:51,916 --> 10:32:53,756
slide que vai levar isso para casa

15744
10:32:53,756 --> 10:32:56,560
Temos alguns programas com seus próprios

15745
10:32:56,560 --> 10:32:59,120
mapas de memória separados que temos programa um

15746
10:32:59,120 --> 10:33:00,320
através de quatro

15747
10:33:00,320 --> 10:33:02,480
Se nós os executarmos, eles vão embora

15748
10:33:02,480 --> 10:33:05,360
através da unidade de gerenciamento de memória e

15749
10:33:05,360 --> 10:33:07,276
A unidade de gerenciamento de memória está indo para

15750
10:33:07,276 --> 10:33:10,160
Atribuir seções sobre o real

15751
10:33:10,160 --> 10:33:12,000
carneiro que temos em nosso computador e

15752
10:33:12,000 --> 10:33:14,800
eles vão usar essa seção

15753
10:33:14,800 --> 10:33:17,360
na memória de acesso aleatório real que nós

15754
10:33:17,360 --> 10:33:19,436
Tenho em nosso computador a coisa é sua

15755
10:33:19,436 --> 10:33:22,320
O programa vai realmente pensar que é dono

15756
10:33:22,320 --> 10:33:23,916
A coisa toda

15757
10:33:23,916 --> 10:33:26,080
mas não vai usar apenas um

15758
10:33:26,080 --> 10:33:28,240
parte dele e a gestão da memória

15759
10:33:28,240 --> 10:33:30,800
A unidade vai se transformar entre

15760
10:33:30,800 --> 10:33:33,596
A ideia de que o seu programa tem e

15761
10:33:33,596 --> 10:33:36,320
memória real que temos em nosso computador

15762
10:33:36,320 --> 10:33:39,040
e o mapa de memória é um formato padrão

15763
10:33:39,040 --> 10:33:41,840
que é definido pelo sistema operacional

15764
10:33:41,840 --> 10:33:43,916
É por isso que, por exemplo, você não pode tomar

15765
10:33:43,916 --> 10:33:46,960
um executável que foi configurado nas janelas

15766
10:33:46,960 --> 10:33:49,436
e executá-lo diretamente em linux este é um

15767
10:33:49,436 --> 10:33:52,160
coisa do sistema operacional que o mapa da memória ou

15768
10:33:52,160 --> 10:33:55,200
A estrutura do seu programa é definida

15769
10:33:55,200 --> 10:33:57,520
pelo sistema operacional que vai

15770
10:33:57,520 --> 10:34:01,200
estar executando esse programa para que todos os programas

15771
10:34:01,200 --> 10:34:03,360
escrito para um sistema operacional deve

15772
10:34:03,360 --> 10:34:05,916
conformar-se ao mapa de memória que é

15773
10:34:05,916 --> 10:34:08,640
definido por esse sistema operacional, então tudo

15774
10:34:08,640 --> 10:34:11,040
programas nas janelas se você tivesse um jeito de

15775
10:34:11,040 --> 10:34:13,436
entrar e olhar para o mapa de memória que eles

15776
10:34:13,436 --> 10:34:15,360
vai ser muito parecido, então nós

15777
10:34:15,360 --> 10:34:17,436
tem falado sobre o mapa da memória

15778
10:34:17,436 --> 10:34:18,160


15779
10:34:18,160 --> 10:34:20,080
O que parece ser

15780
10:34:20,080 --> 10:34:22,720
Bem aqui está um slide que vai

15781
10:34:22,720 --> 10:34:25,040
Tente limpar isso para que vamos

15782
10:34:25,040 --> 10:34:27,276
tem um monte de locais de memória de 0

15783
10:34:27,276 --> 10:34:29,916
todo o caminho para 2 para o poder de m

15784
10:34:29,916 --> 10:34:32,080
O mapa da memória está realmente dividido

15785
10:34:32,080 --> 10:34:34,720
em muitas partes, por exemplo, temos

15786
10:34:34,720 --> 10:34:36,320
A seção de texto temos os dados

15787
10:34:36,320 --> 10:34:38,080
seção temos a pilha de pilha e

15788
10:34:38,080 --> 10:34:39,040
sistema

15789
10:34:39,040 --> 10:34:41,120
e esta é uma visão que você pode ter

15790
10:34:41,120 --> 10:34:43,360
Existem algumas versões diferentes

15791
10:34:43,360 --> 10:34:45,120
deste slide que você vai ver

15792
10:34:45,120 --> 10:34:47,120
na internet, mas o que é realmente

15793
10:34:47,120 --> 10:34:50,640
Importante é pilha e quadril para o nosso

15794
10:34:50,640 --> 10:34:53,276
Os propósitos aqui stack é o que vai fazer

15795
10:34:53,276 --> 10:34:56,480
armazenar nossas variáveis locais, agradeça a

15796
10:34:56,480 --> 10:34:59,360
que temos aqui no bc principal graças nós

15797
10:34:59,360 --> 10:35:01,680
tinha funções internas que essas coisas são

15798
10:35:01,680 --> 10:35:05,120
armazenado dentro da seção de pilha do nosso

15799
10:35:05,120 --> 10:35:06,400
mapa da memória

15800
10:35:06,400 --> 10:35:08,880
Além da pilha também temos o quadril

15801
10:35:08,880 --> 10:35:10,880
que será o local onde

15802
10:35:10,880 --> 10:35:13,596
nós temos memória adicional que podemos usar para

15803
10:35:13,596 --> 10:35:16,080
tornar as coisas melhores para o nosso programa

15804
10:35:16,080 --> 10:35:17,840
também tem a seção de texto que é

15805
10:35:17,840 --> 10:35:20,400
indo para carregar o binário real do nosso

15806
10:35:20,400 --> 10:35:23,120
programa para que o cpu possa executá-lo

15807
10:35:23,120 --> 10:35:24,880
Mas não vamos nos preocupar muito

15808
10:35:24,880 --> 10:35:26,560
sobre esta seção neste curso

15809
10:35:26,560 --> 10:35:28,880
porque está fora do escopo para

15810
10:35:28,880 --> 10:35:31,040
O que estamos tentando fazer aqui estamos

15811
10:35:31,040 --> 10:35:33,840
vai focar na pilha e no quadril porque

15812
10:35:33,840 --> 10:35:35,520
O quadril vai realmente ser muito

15813
10:35:35,520 --> 10:35:38,480
importante da próxima palestra quando

15814
10:35:38,480 --> 10:35:41,200
começar a falar sobre memória dinâmica quadril

15815
10:35:41,200 --> 10:35:43,120
Vai ser uma memória adicional que

15816
10:35:43,120 --> 10:35:45,276
você pode usar em seu programa se você executar

15817
10:35:45,276 --> 10:35:47,360
fora da memória de pilha e nós vamos

15818
10:35:47,360 --> 10:35:49,436
Veja algumas outras razões pelas quais você pode

15819
10:35:49,436 --> 10:35:51,916
Queremos usar isso à medida que progredimos nisso

15820
10:35:51,916 --> 10:35:54,240
capítulo para que o nosso mapa de memória vá

15821
10:35:54,240 --> 10:35:57,436
têm muitas partes, mas as partes que

15822
10:35:57,436 --> 10:35:59,916
nós realmente nos preocupamos neste curso

15823
10:35:59,916 --> 10:36:02,480
empilhar e pilha isso é realmente tudo que nós estabelecemos

15824
10:36:02,480 --> 10:36:04,000
para fazer nesta palestra eu espero que você

15825
10:36:04,000 --> 10:36:06,480
ter uma ideia melhor do mapa da memória e

15826
10:36:06,480 --> 10:36:09,200
Como isso realmente funciona, nós introduzimos

15827
10:36:09,200 --> 10:36:11,596
Outra visão que você pode ter sobre como

15828
10:36:11,596 --> 10:36:14,800
seu c plus programa é executado e

15829
10:36:14,800 --> 10:36:16,720
Espero que você tenha uma ideia melhor do

15830
10:36:16,720 --> 10:36:18,800
sistema de memória e vamos começar

15831
10:36:18,800 --> 10:36:21,436
e ver como você pode trabalhar com dinâmica

15832
10:36:21,436 --> 10:36:23,840
alocação de memória que vai fazer

15833
10:36:23,840 --> 10:36:25,520
realmente usar o heap

15834
10:36:25,520 --> 10:36:27,596
Começando na próxima palestra

15835
10:36:27,596 --> 10:36:30,000
Vá em frente e termine aqui e me encontre

15836
10:36:30,000 --> 10:36:30,880
lá

15837
10:36:30,880 --> 10:36:32,800
Nesta palestra vamos começar e

15838
10:36:32,800 --> 10:36:36,080
Saiba mais sobre a alocação de memória dinâmica

15839
10:36:36,080 --> 10:36:38,480
e esta é uma técnica que podemos usar para

15840
10:36:38,480 --> 10:36:42,080
começar a usar o armazenamento de quadril que temos em

15841
10:36:42,080 --> 10:36:44,400
o mapa de memória do nosso c plus

15842
10:36:44,400 --> 10:36:46,480
Programa que podemos usar isso para obter

15843
10:36:46,480 --> 10:36:48,560
memória adicional que podemos usar e fazer

15844
10:36:48,560 --> 10:36:51,840
coisas se a memória de pilha não é suficiente para

15845
10:36:51,840 --> 10:36:54,080
Nossos propósitos é assim que temos sido

15846
10:36:54,080 --> 10:36:56,080
Usando ponteiros até agora, por exemplo,

15847
10:36:56,080 --> 10:36:58,320
temos uma variável nós configuramos um ponteiro e

15848
10:36:58,320 --> 10:37:00,960
nós armazenamos o endereço da variável n

15849
10:37:00,960 --> 10:37:03,840
para que possamos ir em frente e usar este ponteiro

15850
10:37:03,840 --> 10:37:06,480
para manipular a variável ou fazer tudo

15851
10:37:06,480 --> 10:37:08,880
Tipos de coisas loucas se você descer

15852
10:37:08,880 --> 10:37:11,756
Aqui temos um ponteiro p número um

15853
10:37:11,756 --> 10:37:14,400
e nós temos uma variável número um e nós

15854
10:37:14,400 --> 10:37:16,640
pode armazenar o endereço do número um em

15855
10:37:16,640 --> 10:37:18,720
Este ponteiro é realmente a mesma coisa

15856
10:37:18,720 --> 10:37:21,520
Como temos no topo aqui, mas o ponteiro

15857
10:37:21,520 --> 10:37:24,800
Não é inicializado na declaração aqui

15858
10:37:24,800 --> 10:37:26,400
e você tem que ter certeza de colocar

15859
10:37:26,400 --> 10:37:28,480
Dados inválidos e uma coisa que eu não tenho

15860
10:37:28,480 --> 10:37:30,960
Realmente estressado o suficiente é que é

15861
10:37:30,960 --> 10:37:32,320
Realmente ruim

15862
10:37:32,320 --> 10:37:34,800
É muito ruim tentar usar um ponteiro que

15863
10:37:34,800 --> 10:37:37,360
Não é inicializado, por exemplo, aqui nós

15864
10:37:37,360 --> 10:37:39,916
tem p número dois, que é um ponteiro

15865
10:37:39,916 --> 10:37:43,200
Não é inicializado, contém lixo

15866
10:37:43,200 --> 10:37:47,200
e nós tentamos e escrevemos nisso tudo bem, então tente

15867
10:37:47,200 --> 10:37:49,276
Pense sobre o que realmente estamos fazendo

15868
10:37:49,276 --> 10:37:51,120
Aqui este é um ponteiro que estabelecemos

15869
10:37:51,120 --> 10:37:54,160
Para cima, nós realmente não inicializamos isso, então

15870
10:37:54,160 --> 10:37:56,480
Vai conter qualquer endereço

15871
10:37:56,480 --> 10:37:58,800
é possível que possa conter um endereço

15872
10:37:58,800 --> 10:38:00,800
que é usado por outro programa que pode

15873
10:38:00,800 --> 10:38:02,640
conter um endereço que está sendo usado por

15874
10:38:02,640 --> 10:38:04,800
O sistema operacional não é seu

15875
10:38:04,800 --> 10:38:07,680
endereço para mexer e aqui estamos

15876
10:38:07,680 --> 10:38:09,520
Na verdade, tentando mexer com isso por

15877
10:38:09,520 --> 10:38:13,276
Armazenar em um 55, então isso vai

15878
10:38:13,276 --> 10:38:16,080
causar o acidente possivelmente ou mesmo

15879
10:38:16,080 --> 10:38:18,560
dados corrompidos que estão sendo usados por outros

15880
10:38:18,560 --> 10:38:21,276
As pessoas então não façam isso outra coisa é

15881
10:38:21,276 --> 10:38:23,436
para tentar usar um ponteiro que é

15882
10:38:23,436 --> 10:38:25,916
inicializado para saber, por exemplo, aqui nós

15883
10:38:25,916 --> 10:38:29,200
tem um ponteiro p número três e é

15884
10:38:29,200 --> 10:38:31,360


15885
10:38:31,360 --> 10:38:34,000
inicializá-lo para o ponteiro nulo, mas nós somos

15886
10:38:34,000 --> 10:38:37,276
Tentar e armazenar em um valor aqui, então

15887
10:38:37,276 --> 10:38:39,360
Isso também vai ser ruim, não é

15888
10:38:39,360 --> 10:38:40,960
A quem você vai conseguir

15889
10:38:40,960 --> 10:38:43,120
Na verdade c plus não lhe dá nenhum

15890
10:38:43,120 --> 10:38:45,120
As garantias são chamadas de

15891
10:38:45,120 --> 10:38:47,200
Comportamento para que você vai ter um acidente

15892
10:38:47,200 --> 10:38:50,160
e não faça isso como uma boa prática

15893
10:38:50,160 --> 10:38:51,916
A primeira coisa que você deve fazer é inicializar

15894
10:38:51,916 --> 10:38:53,200
os seus ponteiros

15895
10:38:53,200 --> 10:38:55,520
antes de usá-los, você pode inicializar

15896
10:38:55,520 --> 10:38:58,800
sem nenhum ponteiro e certifique-se de que

15897
10:38:58,800 --> 10:39:00,000
Você é

15898
10:39:00,000 --> 10:39:02,720
Modificar endereços válidos para aqueles

15899
10:39:02,720 --> 10:39:04,400
apontam se você não sabe o que está em um

15900
10:39:04,400 --> 10:39:06,960
O ponteiro não use esse ponteiro porque

15901
10:39:06,960 --> 10:39:09,520
Coisas ruins podem acontecer bem número de regra

15902
10:39:09,520 --> 10:39:12,080
Não tente usar um ponteiro que você

15903
10:39:12,080 --> 10:39:13,680
Não inicializou

15904
10:39:13,680 --> 10:39:16,720
A regra número dois não tenta trabalhar com um

15905
10:39:16,720 --> 10:39:19,436
pontodor que está apontando para nenhum ptr

15906
10:39:19,436 --> 10:39:21,120
que vai te dar coisas ruins você

15907
10:39:21,120 --> 10:39:23,276
Não quero realmente lidar bem, então

15908
10:39:23,276 --> 10:39:26,080
Até agora temos usado a memória que vive

15909
10:39:26,080 --> 10:39:28,880
na seção de pilha do nosso mapa de memória

15910
10:39:28,880 --> 10:39:30,800
estávamos usando variáveis que temos

15911
10:39:30,800 --> 10:39:32,960
declaradas na função principal que fomos

15912
10:39:32,960 --> 10:39:34,640
Usando as variáveis que temos

15913
10:39:34,640 --> 10:39:37,200
declaradas dentro de algumas funções e

15914
10:39:37,200 --> 10:39:39,756
Isso é tudo coisas que vivem na pilha

15915
10:39:39,756 --> 10:39:41,520
Agora queremos ver como podemos usar o

15916
10:39:41,520 --> 10:39:44,240
hip OK vamos dar uma olhada no nosso

15917
10:39:44,240 --> 10:39:46,800
mapa de memória que temos a pilha que temos

15918
10:39:46,800 --> 10:39:47,596
heap

15919
10:39:47,596 --> 10:39:49,436
E as diferenças entre esses dois

15920
10:39:49,436 --> 10:39:50,880
Os rapazes são

15921
10:39:50,880 --> 10:39:52,480
expostas aqui

15922
10:39:52,480 --> 10:39:55,756
a memória de pilha é finita para que você não

15923
10:39:55,756 --> 10:39:58,720
tem memória infinita, mas o mesmo é

15924
10:39:58,720 --> 10:40:00,960
verdadeiro para o heap mas o quadril é adicional

15925
10:40:00,960 --> 10:40:03,200
memória que você pode usar se você não usar

15926
10:40:03,200 --> 10:40:05,680
querer ficar sem memória de estoque para um

15927
10:40:05,680 --> 10:40:08,400
empilhar memória que o desenvolvedor não está na íntegra

15928
10:40:08,400 --> 10:40:11,680
controle da vida útil da memória, portanto, se você

15929
10:40:11,680 --> 10:40:13,680
Declarar algo na pilha para

15930
10:40:13,680 --> 10:40:16,480
exemplo se você diz int var1 e você

15931
10:40:16,480 --> 10:40:19,520
inicialize que para 23 você não controla

15932
10:40:19,520 --> 10:40:22,000
quando essa variável é eliminada de

15933
10:40:22,000 --> 10:40:24,320
memória que a variável vai ser

15934
10:40:24,320 --> 10:40:26,800
morto quando é o escopo em que foi

15935
10:40:26,800 --> 10:40:29,840
Declara que vai acabar

15936
10:40:29,840 --> 10:40:32,560
e você desenvolvedor não diz quando

15937
10:40:32,560 --> 10:40:34,720
a variável morre e às vezes você

15938
10:40:34,720 --> 10:40:36,480
Realmente quero controlar

15939
10:40:36,480 --> 10:40:38,240
quando sua variável morre, isso é um

15940
10:40:38,240 --> 10:40:40,880
limitação que temos com a memória de pilha

15941
10:40:40,880 --> 10:40:42,960
Tudo bem, então para a vida útil da memória da pilha é

15942
10:40:42,960 --> 10:40:44,720
controlado pelo mecanismo de escopo que nós

15943
10:40:44,720 --> 10:40:47,916
apenas diga que para heap o desenvolvedor é

15944
10:40:47,916 --> 10:40:50,720
no controle total de quando a variável

15945
10:40:50,720 --> 10:40:53,520
vem à vida e quando a variável morre

15946
10:40:53,520 --> 10:40:55,200
e este é um benefício que você pode ter

15947
10:40:55,200 --> 10:40:57,756
com armazenamento de pilha e você pode querer

15948
10:40:57,756 --> 10:40:59,276
usar isso e vamos ver como nós

15949
10:40:59,276 --> 10:41:01,840
pode usar isso nas próximas palestras

15950
10:41:01,840 --> 10:41:03,436
Tudo bem, então certifique-se de entender o

15951
10:41:03,436 --> 10:41:05,756
diferença entre stack e hip aqui se

15952
10:41:05,756 --> 10:41:07,436
Você olha para o exemplo aqui temos um

15953
10:41:07,436 --> 10:41:10,240
variável que é chamada locoscope var

15954
10:41:10,240 --> 10:41:13,276
é armazenado dentro deste bloco delimitado

15955
10:41:13,276 --> 10:41:16,000
pelos aparelhos encaracolados e a variável é

15956
10:41:16,000 --> 10:41:17,756
Vou ganhar a vida quando isto

15957
10:41:17,756 --> 10:41:20,720
A declaração é executada, mas vai

15958
10:41:20,720 --> 10:41:21,520
Morrer

15959
10:41:21,520 --> 10:41:24,640
quando atingimos a cinta fechada aqui

15960
10:41:24,640 --> 10:41:26,640
assim, o tempo de vida desta variável é

15961
10:41:26,640 --> 10:41:29,840
controlado pelo mecanismo de escopo, mas

15962
10:41:29,840 --> 10:41:33,116
é possível usar memória dinâmica ou usar

15963
10:41:33,116 --> 10:41:34,720
memória no monte e nós vamos

15964
10:41:34,720 --> 10:41:37,116
ver uma sintaxe que você pode usar para fazer isso

15965
10:41:37,116 --> 10:41:38,880
Primeira coisa que queremos fazer para configurar

15966
10:41:38,880 --> 10:41:41,116
empregador que vai apontar para

15967
10:41:41,116 --> 10:41:44,240
que heap alocou a memória do jeito que você

15968
10:41:44,240 --> 10:41:45,840
para que você monte um ponteiro aqui nós

15969
10:41:45,840 --> 10:41:48,640
Temos p número quatro nós inicializamos com

15970
10:41:48,640 --> 10:41:50,160
sem ptr

15971
10:41:50,160 --> 10:41:52,880
Mas o que fazemos para alocar a memória é a

15972
10:41:52,880 --> 10:41:54,960
Segunda declaração aqui dizemos p número

15973
10:41:54,960 --> 10:41:58,240
Quatro e dizemos novo fim

15974
10:41:58,240 --> 10:42:00,400
O momento em que esta declaração será

15975
10:42:00,400 --> 10:42:03,040
executar o sistema operacional está indo

15976
10:42:03,040 --> 10:42:06,080
para alocar um pedaço de memória no

15977
10:42:06,080 --> 10:42:07,840
monte a memória vai ser grande

15978
10:42:07,840 --> 10:42:10,000
o suficiente para acomodar um inteiro assim

15979
10:42:10,000 --> 10:42:12,160
Vai ser quatro bytes longos

15980
10:42:12,160 --> 10:42:14,320
E é a sua memória agora o seu programa

15981
10:42:14,320 --> 10:42:16,880
pode usá-lo para fazer o que quiser e

15982
10:42:16,880 --> 10:42:19,116
nenhum outro programa no sistema pode usar

15983
10:42:19,116 --> 10:42:21,520
Este pedaço de memória para que ele vai

15984
10:42:21,520 --> 10:42:25,276
Seja seu até retornar explicitamente

15985
10:42:25,276 --> 10:42:27,520
Este pedaço de memória para o sistema e

15986
10:42:27,520 --> 10:42:29,040
nós vamos ver como você pode fazer isso

15987
10:42:29,040 --> 10:42:31,436
Em um minuto, uma vez que esta memória é sua

15988
10:42:31,436 --> 10:42:33,436
Você pode usá-lo você vê aqui já

15989
10:42:33,436 --> 10:42:35,200
Referindo a memória e a história

15990
10:42:35,200 --> 10:42:37,680
Mais uma vez é 77 e se estamos tentando imprimir

15991
10:42:37,680 --> 10:42:39,680
Este 77 nós vamos fazer com que ele seja impresso

15992
10:42:39,680 --> 10:42:41,916
Ok, é assim que você pode usar dinâmico

15993
10:42:41,916 --> 10:42:44,480
memória e quando você faz isso

15994
10:42:44,480 --> 10:42:47,596
As coisas não estão sendo armazenadas na pilha

15995
10:42:47,596 --> 10:42:49,756
As coisas estão sendo armazenadas no heap i

15996
10:42:49,756 --> 10:42:51,360
Espero que você entenda isso porque

15997
10:42:51,360 --> 10:42:54,640
É muito importante ok, então aqui está o nosso

15998
10:42:54,640 --> 10:42:58,000
visão da pilha e heap assim se você usar novo

15999
10:42:58,000 --> 10:43:00,560
para alocar para coisas de memória estão indo

16000
10:43:00,560 --> 10:43:03,840
para ser armazenado nesta seção de quadril aqui de

16001
10:43:03,840 --> 10:43:06,160
Seu mapa de memória aqui é outro exemplo

16002
10:43:06,160 --> 10:43:08,880
para tentar entender a vida de

16003
10:43:08,880 --> 10:43:11,840
nossas variáveis docovar novamente é limitado

16004
10:43:11,840 --> 10:43:13,756
Para este escopo, ele vai entrar

16005
10:43:13,756 --> 10:43:15,756
Vida quando esta afirmação aqui é

16006
10:43:15,756 --> 10:43:19,040
executado e vai morrer quando nós

16007
10:43:19,040 --> 10:43:21,520
ficar fora deste escopo aqui, então se você tentar

16008
10:43:21,520 --> 10:43:24,320
executar o código fora deste escopo locovar

16009
10:43:24,320 --> 10:43:26,480
Não estará mais disponível você

16010
10:43:26,480 --> 10:43:29,360
Não posso usá-lo, mas esse não é o caso para

16011
10:43:29,360 --> 10:43:33,116
locro ptr var porque este é um ponteiro

16012
10:43:33,116 --> 10:43:35,040
Ele vive no monte

16013
10:43:35,040 --> 10:43:38,160
e se você sair desse escopo

16014
10:43:38,160 --> 10:43:40,720
A memória ainda vai ser sua se você

16015
10:43:40,720 --> 10:43:42,800
ter uma maneira que você pode acessá-lo e usá-lo

16016
10:43:42,800 --> 10:43:44,960
você vai ser capaz de usá-lo e ele

16017
10:43:44,960 --> 10:43:48,320
Vai ser seu até que você decida

16018
10:43:48,320 --> 10:43:50,960
Devolvê-lo ao sistema operacional para que possamos

16019
10:43:50,960 --> 10:43:52,880
têm falado sobre o retorno

16020
10:43:52,880 --> 10:43:54,560
Memória para o Sistema

16021
10:43:54,560 --> 10:43:57,756
Como fazemos isso bem, você usa o delete

16022
10:43:57,756 --> 10:44:00,400
palavra-chave em c plus plus aqui nós temos o nosso

16023
10:44:00,400 --> 10:44:03,200
memória que é alocada usando novos e

16024
10:44:03,200 --> 10:44:05,520
assim, o sistema operacional vai dar

16025
10:44:05,520 --> 10:44:07,840
Nós um novo pedaço de memória que vai

16026
10:44:07,840 --> 10:44:09,436
ser quatro bytes porque nós vamos

16027
10:44:09,436 --> 10:44:11,596
loja em um inteiro e nós vamos

16028
10:44:11,596 --> 10:44:14,000
estar apontando para essa memória através de p

16029
10:44:14,000 --> 10:44:16,320
número quatro aqui podemos usar esta memória

16030
10:44:16,320 --> 10:44:18,160
No entanto, queremos através da referência

16031
10:44:18,160 --> 10:44:20,320
e fazer todos os tipos de coisas loucas e

16032
10:44:20,320 --> 10:44:22,480
Quando terminamos com essa memória, somos

16033
10:44:22,480 --> 10:44:24,640
indo para dizer delete p número quatro e

16034
10:44:24,640 --> 10:44:26,400
Esta declaração vai devolver o

16035
10:44:26,400 --> 10:44:28,080
memória para o sistema operacional

16036
10:44:28,080 --> 10:44:30,720
A memória já não vai demorar horas

16037
10:44:30,720 --> 10:44:33,276
Após esta declaração e uma coisa boa para

16038
10:44:33,276 --> 10:44:35,916
fazer depois que você liberar sua memória é para

16039
10:44:35,916 --> 10:44:37,680
Redefini-lo para

16040
10:44:37,680 --> 10:44:40,640
Não há ptr para que outras pessoas saibam que

16041
10:44:40,640 --> 10:44:43,360
Você realmente não tem nenhum dado válido em

16042
10:44:43,360 --> 10:44:46,560
que memória, porque se você tentar usar um

16043
10:44:46,560 --> 10:44:47,840
suprimido

16044
10:44:47,840 --> 10:44:50,080
Seção de memória coisas ruins vão

16045
10:44:50,080 --> 10:44:51,596
Acontece que não vai ser o seu

16046
10:44:51,596 --> 10:44:53,680
memória, vamos cair no mesmo

16047
10:44:53,680 --> 10:44:55,520
Problema de tentar usar um

16048
10:44:55,520 --> 10:44:58,160
Peça de memória não inicializada não faz

16049
10:44:58,160 --> 10:45:01,200
Assim, sempre que você liberar memória também

16050
10:45:01,200 --> 10:45:04,240
redefini-lo para nenhuma ptr para jogar pelo seguro

16051
10:45:04,240 --> 10:45:06,640
também pode inicializar nossos ponteiros com

16052
10:45:06,640 --> 10:45:09,360
memória dinâmica quando os declaramos e

16053
10:45:09,360 --> 10:45:11,276
É assim que você pode fazer isso, dizemos p

16054
10:45:11,276 --> 10:45:14,080
número cinco e inicializamos isso com

16055
10:45:14,080 --> 10:45:15,916
Novo e isso vai nos dar um novo

16056
10:45:15,916 --> 10:45:18,640
pedaço de memória no monte e é

16057
10:45:18,640 --> 10:45:21,040
será apontado por p número cinco

16058
10:45:21,040 --> 10:45:23,436
Nós temos a mesma coisa aqui, mas uh aqui

16059
10:45:23,436 --> 10:45:25,840
estamos apenas apontando em novos valores e p

16060
10:45:25,840 --> 10:45:27,276
O número seis e

16061
10:45:27,276 --> 10:45:29,840
número sete dos locais de memória no

16062
10:45:29,840 --> 10:45:32,320
O monte vai conter 22 e

16063
10:45:32,320 --> 10:45:35,756
23 para p número seis e p número sete

16064
10:45:35,756 --> 10:45:38,000
e aqui temos alguns exemplos de como

16065
10:45:38,000 --> 10:45:40,400
Podemos imprimir o conteúdo destes

16066
10:45:40,400 --> 10:45:43,436
locais de memória em htdc para fora

16067
10:45:43,436 --> 10:45:46,480
e depois que você terminar usando seu quadril

16068
10:45:46,480 --> 10:45:49,200
memória que você vai liberá-lo usando

16069
10:45:49,200 --> 10:45:51,360
na palavra-chave delete e você está indo para

16070
10:45:51,360 --> 10:45:54,320
redefinir isso para nenhum ptr para realmente jogar

16071
10:45:54,320 --> 10:45:57,040
É assim que você deve usar dinâmico

16072
10:45:57,040 --> 10:46:00,080
memória alocada no heap outro

16073
10:46:00,080 --> 10:46:02,560
O que você deve saber é que é

16074
10:46:02,560 --> 10:46:05,916
É muito ruim chamar exclua duas vezes em um

16075
10:46:05,916 --> 10:46:08,080
Pontor, então aqui temos uma memória

16076
10:46:08,080 --> 10:46:10,160
localização que alocamos na pilha

16077
10:46:10,160 --> 10:46:12,560
armazenam isso em um ponteiro e

16078
10:46:12,560 --> 10:46:15,840
Estamos tentando usá-lo aqui no sddc

16079
10:46:15,840 --> 10:46:18,160
Saída de tudo o que está dentro

16080
10:46:18,160 --> 10:46:20,240
e se o eliminarmos pela primeira vez

16081
10:46:20,240 --> 10:46:21,756
que vai ser legal, vai

16082
10:46:21,756 --> 10:46:23,916
ser devolvido ao sistema, mas se você tentar

16083
10:46:23,916 --> 10:46:26,320
para excluí-lo pela segunda vez que você está

16084
10:46:26,320 --> 10:46:28,640
Vou ter um acidente, não faça isso

16085
10:46:28,640 --> 10:46:31,200
É realmente ruim ok agora que temos um

16086
10:46:31,200 --> 10:46:34,320
Ideia um pouco mais clara sobre ponteiros e

16087
10:46:34,320 --> 10:46:36,960
alocação de memória dinâmica eu acho que é

16088
10:46:36,960 --> 10:46:38,960
tempo que fomos para o código do estúdio visual e

16089
10:46:38,960 --> 10:46:40,960
Na verdade, brincamos com alguns desses

16090
10:46:40,960 --> 10:46:44,000
conceitos aqui estamos em nosso trabalho

16091
10:46:44,000 --> 10:46:46,400
diretório do projeto atual é dinâmico

16092
10:46:46,400 --> 10:46:48,480
alocação de memória que vamos pegar

16093
10:46:48,480 --> 10:46:50,640
nossos arquivos de modelo e vamos

16094
10:46:50,640 --> 10:46:52,960
Coloque-os no lugar memória dinâmica

16095
10:46:52,960 --> 10:46:55,276
alocação, vamos fazer isso e nós vamos

16096
10:46:55,276 --> 10:46:57,520
para abrir isso em código de estúdio visual o

16097
10:46:57,520 --> 10:46:59,360
A primeira coisa que vamos fazer é rever

16098
10:46:59,360 --> 10:47:02,080
Como temos usado jogadores até agora

16099
10:47:02,080 --> 10:47:04,080
Temos vindo a usá-los assim que tivemos

16100
10:47:04,080 --> 10:47:06,560
uma variável armazenada em algum lugar na pilha

16101
10:47:06,560 --> 10:47:09,200
Mais uma vez esta é a memória de pilha que nós

16102
10:47:09,200 --> 10:47:11,840
Estamos usando aqui e nós

16103
10:47:11,840 --> 10:47:14,080
Endereços armazenados de algumas variáveis que você

16104
10:47:14,080 --> 10:47:16,080
Conhecer ponteiros algo assim e nós

16105
10:47:16,080 --> 10:47:17,360
poderia passar pelo ponteiro para

16106
10:47:17,360 --> 10:47:19,360
manipular esse local de memória para

16107
10:47:19,360 --> 10:47:20,320
O exemplo

16108
10:47:20,320 --> 10:47:22,240
Podemos imprimir o endereço dessa memória

16109
10:47:22,240 --> 10:47:24,400
nós podemos até mesmo a referência e imprimir o

16110
10:47:24,400 --> 10:47:26,000
valor aqui em

16111
10:47:26,000 --> 10:47:29,360
fazendo algo como fazemos aqui e

16112
10:47:29,360 --> 10:47:31,360
Não estamos imprimindo aqui, então digamos

16113
10:47:31,360 --> 10:47:33,596
e dizer p número que podemos fazer

16114
10:47:33,596 --> 10:47:35,360
Algo assim e nós temos sido

16115
10:47:35,360 --> 10:47:38,880
Fazendo isso bastante até agora podemos

16116
10:47:38,880 --> 10:47:40,720
Também tem um pedaço de memória que é

16117
10:47:40,720 --> 10:47:43,520
não inicializado e nós armazenamos o endereço

16118
10:47:43,520 --> 10:47:46,080
de alguma variável nesse pedaço de memória

16119
10:47:46,080 --> 10:47:47,916
e nós podemos fazer o mesmo, por exemplo

16120
10:47:47,916 --> 10:47:49,520
Se imprimirmos p número um, vamos

16121
10:47:49,520 --> 10:47:52,480
obter o valor 12 impresso aqui e nós

16122
10:47:52,480 --> 10:47:54,400
poderia executar isso então vamos tentar fazer isso

16123
10:47:54,400 --> 10:47:56,640
nós vamos trazer um terminal primeiro

16124
10:47:56,640 --> 10:47:58,720
e feche este painel para que tenhamos alguns

16125
10:47:58,720 --> 10:48:01,276
espaço para respirar e vamos construir

16126
10:48:01,276 --> 10:48:04,320
com gcc como sempre fazemos

16127
10:48:04,320 --> 10:48:06,640
Vamos construir com sucesso

16128
10:48:06,640 --> 10:48:08,720
para limpar e correr galo e nós vamos

16129
10:48:08,720 --> 10:48:10,640
para ver que nós temos essas coisas impressas

16130
10:48:10,640 --> 10:48:13,040
Aqui, a variável que temos aqui é

16131
10:48:13,040 --> 10:48:14,960
22 então nós vamos conseguir isso se nós

16132
10:48:14,960 --> 10:48:17,040
imprimir a variável diretamente

16133
10:48:17,040 --> 10:48:18,720
Se imprimirmos ponteiro, vamos conseguir

16134
10:48:18,720 --> 10:48:20,880
o endereço impresso para fora nós também podemos ir

16135
10:48:20,880 --> 10:48:23,276
através do endereço do operador para imprimir

16136
10:48:23,276 --> 10:48:26,320
O endereço desta variável aqui, mas nós

16137
10:48:26,320 --> 10:48:28,480
também pode imprimir o nosso valor através do

16138
10:48:28,480 --> 10:48:31,116
Referindo nosso ponteiro e podemos chegar

16139
10:48:31,116 --> 10:48:33,200
acesso a ele aqui em baixo temos um

16140
10:48:33,200 --> 10:48:35,520
ponteiro que não é inicializado, então

16141
10:48:35,520 --> 10:48:37,520
vai conter um endereço lixo que você

16142
10:48:37,520 --> 10:48:39,756
Não deveria realmente usar, mas nós não vamos

16143
10:48:39,756 --> 10:48:41,596
para fazer isso porque vamos guardar

16144
10:48:41,596 --> 10:48:44,480
no endereço do número um aqui e nós

16145
10:48:44,480 --> 10:48:47,200
pode manipular o valor aqui através de

16146
10:48:47,200 --> 10:48:50,080
O ponteiro usando a referência

16147
10:48:50,080 --> 10:48:52,320
operador aqui e se nós imprimimos este p

16148
10:48:52,320 --> 10:48:54,800
Número um, vamos imprimir 12

16149
10:48:54,800 --> 10:48:57,200
Isso é muito legal ok, então isso é

16150
10:48:57,200 --> 10:49:00,640
como temos usado ponteiros até agora

16151
10:49:00,640 --> 10:49:02,320
Vamos comentar isso porque nós somos

16152
10:49:02,320 --> 10:49:04,240
Vou ver algumas outras coisas bem

16153
10:49:04,240 --> 10:49:06,640
antes realmente de olharmos para o quão dinâmico

16154
10:49:06,640 --> 10:49:08,800
A memória funciona, vamos mostrar-lhe um

16155
10:49:08,800 --> 10:49:11,680
Poucas coisas ruins que você precisa conhecer

16156
10:49:11,680 --> 10:49:13,916
então vamos colocar um pedaço de código para nós

16157
10:49:13,916 --> 10:49:15,276
para jogar com

16158
10:49:15,276 --> 10:49:18,360
e aqui estamos nós dizendo que escrever em

16159
10:49:18,360 --> 10:49:21,520
A memória não inicializada é realmente ruim, então

16160
10:49:21,520 --> 10:49:23,276
Aqui temos um ponteiro que é

16161
10:49:23,276 --> 10:49:25,840
unnincializado e nós estamos tentando e

16162
10:49:25,840 --> 10:49:28,240
diretamente diretamente para ele através do

16163
10:49:28,240 --> 10:49:30,560
Referência e isso vai ser ruim

16164
10:49:30,560 --> 10:49:31,756
Você vê que

16165
10:49:31,756 --> 10:49:34,240
Código de estúdio visual não está reclamando

16166
10:49:34,240 --> 10:49:36,480
Pensa que nós sabemos o que estamos fazendo

16167
10:49:36,480 --> 10:49:39,116
Aqui e não vai nos avisar, mas

16168
10:49:39,116 --> 10:49:41,200
este ponteiro poderia realmente estar apontando

16169
10:49:41,200 --> 10:49:43,840
em qualquer lugar, incluindo sistema operacional

16170
10:49:43,840 --> 10:49:46,080
memória específica e aqui você pode estar

16171
10:49:46,080 --> 10:49:47,360
A tentar

16172
10:49:47,360 --> 10:49:50,080
modificar as coisas que seu sistema operacional

16173
10:49:50,080 --> 10:49:53,040
vai precisar de tão claramente o

16174
10:49:53,040 --> 10:49:54,720
O sistema operacional não vai ser

16175
10:49:54,720 --> 10:49:57,276
Feliz com isso e as coisas ruins podem

16176
10:49:57,276 --> 10:49:59,040
Acontecer a este programa

16177
10:49:59,040 --> 10:50:01,040
Então agora temos essa localização de memória

16178
10:50:01,040 --> 10:50:03,116
nós vamos tentar escrever nele e

16179
10:50:03,116 --> 10:50:04,720
nós vamos ver o que acontece se nós

16180
10:50:04,720 --> 10:50:07,040
executar este programa por agora vamos tentar e

16181
10:50:07,040 --> 10:50:08,640
pegue esta pequena seção aqui e

16182
10:50:08,640 --> 10:50:10,560
Compromete para fora

16183
10:50:10,560 --> 10:50:13,756
E queremos ver o que acontece no

16184
10:50:13,756 --> 10:50:16,160
programa aqui o código aqui que podemos

16185
10:50:16,160 --> 10:50:17,756
Quero correr

16186
10:50:17,756 --> 10:50:20,800
Vamos tentar construí-lo com gcc nós somos

16187
10:50:20,800 --> 10:50:23,200
Vou executar a tarefa para fazer isso

16188
10:50:23,200 --> 10:50:24,720
A construção vai ser bom você ver

16189
10:50:24,720 --> 10:50:26,720
que nem sequer temos um erro de compilador

16190
10:50:26,720 --> 10:50:28,960
E se estamos tentando correr galo você

16191
10:50:28,960 --> 10:50:30,640
Veja que o programa vai tentar e

16192
10:50:30,640 --> 10:50:32,560
Você sabe que o sistema operacional é

16193
10:50:32,560 --> 10:50:34,640
Vou dizer que esse cara não sabe o que

16194
10:50:34,640 --> 10:50:37,116
Eles estão fazendo e eu vou fechar

16195
10:50:37,116 --> 10:50:39,596
Você vê que não é nem mesmo

16196
10:50:39,596 --> 10:50:40,640
correndo

16197
10:50:40,640 --> 10:50:43,520
Esta declaração aqui vamos no topo aqui

16198
10:50:43,520 --> 10:50:46,080
e colocar em uma declaração sddc out para que

16199
10:50:46,080 --> 10:50:47,680
nós podemos realmente ver

16200
10:50:47,680 --> 10:50:50,160
Onde este programa está falhando

16201
10:50:50,160 --> 10:50:52,800
Vamos dizer que stdc para fora

16202
10:50:52,800 --> 10:50:54,960
Escrevendo no 55

16203
10:50:54,960 --> 10:50:56,640
Tudo bem, então isso é o que temos que temos

16204
10:50:56,640 --> 10:50:58,800
Poucas declarações além de e nós queremos

16205
10:50:58,800 --> 10:51:01,360
Veja se realmente conseguimos correr esses dois

16206
10:51:01,360 --> 10:51:03,116
Coisas para ver

16207
10:51:03,116 --> 10:51:06,000
onde o programa está realmente falhando

16208
10:51:06,000 --> 10:51:09,596
Vamos construí-lo novamente com gcc

16209
10:51:09,596 --> 10:51:11,596
E nós vamos limpar

16210
10:51:11,596 --> 10:51:13,680
e correr galo você vê que está indo

16211
10:51:13,680 --> 10:51:17,040
para dizer escrevendo em um 55, mas isso

16212
10:51:17,040 --> 10:51:18,960
A declaração aqui vai falhar porque

16213
10:51:18,960 --> 10:51:22,160
Estamos tentando entrar na memória que

16214
10:51:22,160 --> 10:51:24,560
Não é nosso e o sistema operacional é

16215
10:51:24,560 --> 10:51:27,040
Vou nos parar para que nosso programa seja

16216
10:51:27,040 --> 10:51:30,000
batendo e está terminando antes dele

16217
10:51:30,000 --> 10:51:32,560
até mesmo correr as coisas que estão aqui embaixo

16218
10:51:32,560 --> 10:51:34,880
Espero que você possa ver o quão ruim isso é

16219
10:51:34,880 --> 10:51:36,800
Você criou seu programa para fazer

16220
10:51:36,800 --> 10:51:39,360
coisas, mas vai parar

16221
10:51:39,360 --> 10:51:41,756
Sem ter feito nenhum outro

16222
10:51:41,756 --> 10:51:44,080
Coisas que você projetou abaixo, então

16223
10:51:44,080 --> 10:51:46,720
Isso é realmente ruim e outra coisa ruim

16224
10:51:46,720 --> 10:51:47,916
É isso que

16225
10:51:47,916 --> 10:51:50,480
Você pode ter alocado alguma dinâmica

16226
10:51:50,480 --> 10:51:53,436
memória de antemão e seu programa é

16227
10:51:53,436 --> 10:51:56,640
indo para o fim antes mesmo de liberar

16228
10:51:56,640 --> 10:51:58,880
essa memória corretamente e retorna isso para

16229
10:51:58,880 --> 10:52:01,436
O sistema operacional, então isso é ruim você

16230
10:52:01,436 --> 10:52:04,000
Não quero falhas em seus programas e

16231
10:52:04,000 --> 10:52:07,200
Nunca tente usar e fazer referência

16232
10:52:07,200 --> 10:52:10,400
memória que você não inicializou isso

16233
10:52:10,400 --> 10:52:12,320
É uma coisa ruim que vamos comentar

16234
10:52:12,320 --> 10:52:15,360
Isso eu espero que você realmente saiba o quão ruim

16235
10:52:15,360 --> 10:52:18,080
Isto é e nós vamos descer novamente

16236
10:52:18,080 --> 10:52:21,916
e descompensar o que fizemos aqui

16237
10:52:21,916 --> 10:52:23,840
E uh vai ser outro mal

16238
10:52:23,840 --> 10:52:26,080
Porque estamos tentando escrever

16239
10:52:26,080 --> 10:52:27,756
na memória

16240
10:52:27,756 --> 10:52:30,400
inicializado para null pqr OK aqui nós

16241
10:52:30,400 --> 10:52:32,240
ter um ponteiro que é chamado p número

16242
10:52:32,240 --> 10:52:36,160
três e é inicializado sem ptr

16243
10:52:36,160 --> 10:52:38,720
você pode pensar na ptr como um endereço que

16244
10:52:38,720 --> 10:52:42,400
diz que eu não tenho nenhuma coisa válida em mim

16245
10:52:42,400 --> 10:52:44,480
Não me use que é o que não há ptr

16246
10:52:44,480 --> 10:52:46,160
Dizendo isso, temos o ponteiro

16247
10:52:46,160 --> 10:52:48,880
inicializado para ptr, mas estamos tentando

16248
10:52:48,880 --> 10:52:51,596
Armazenar algo aqui e você pode

16249
10:52:51,596 --> 10:52:54,880
Imagine como isso é ruim, isso é memória

16250
10:52:54,880 --> 10:52:56,960
que não é realmente válido a memória

16251
10:52:56,960 --> 10:52:58,720
Ele mesmo está dizendo que eu não contro

16252
10:52:58,720 --> 10:53:00,960
Qualquer coisa válida não tente me usar e

16253
10:53:00,960 --> 10:53:02,720
Se você tentar usá-lo coisas ruins são

16254
10:53:02,720 --> 10:53:05,040
vai acontecer, então se tentarmos compilar

16255
10:53:05,040 --> 10:53:07,040
Este programa vai compilar o

16256
10:53:07,040 --> 10:53:08,880
O compilador não vai nos impedir de fazer

16257
10:53:08,880 --> 10:53:10,480
Algo assim

16258
10:53:10,480 --> 10:53:12,320
E estas são algumas coisas que você precisa ser

16259
10:53:12,320 --> 10:53:14,720
consciente de em c plus plus, mas se tentarmos

16260
10:53:14,720 --> 10:53:16,480
Executá-lo você vai ver que estamos

16261
10:53:16,480 --> 10:53:18,880
também vai ter um acidente novamente, vamos

16262
10:53:18,880 --> 10:53:21,040
Tente colocar uma declaração na frente disso

16263
10:53:21,040 --> 10:53:24,000
falha de linha e uh abaixo desta linha i

16264
10:53:24,000 --> 10:53:25,276
Pode dizer que

16265
10:53:25,276 --> 10:53:27,880
Fazendo a escrita e eu posso fazer

16266
10:53:27,880 --> 10:53:30,320
stdndl aqui

16267
10:53:30,320 --> 10:53:32,240
e ambos os programas para que possamos

16268
10:53:32,240 --> 10:53:35,680
Veja quais declarações std correm e quais

16269
10:53:35,680 --> 10:53:39,040
ponto depois que nosso programa falha, então estamos

16270
10:53:39,040 --> 10:53:40,960
Indo para limpar o mundo é bom e correr

16271
10:53:40,960 --> 10:53:42,240
Galo que você vai ver que está indo

16272
10:53:42,240 --> 10:53:44,640
para dizer o que está fazendo, vai tentar

16273
10:53:44,640 --> 10:53:46,720
e falha e o sistema operacional é

16274
10:53:46,720 --> 10:53:48,640
vai matar este programa porque é

16275
10:53:48,640 --> 10:53:50,640
É uma loucura fazer o que não deveria

16276
10:53:50,640 --> 10:53:53,200
Realmente está fazendo isso, isso é algo ruim

16277
10:53:53,200 --> 10:53:55,756
Não faça, esteja ciente dessa coisa bem

16278
10:53:55,756 --> 10:53:57,040
nós vamos comentar isso e

16279
10:53:57,040 --> 10:54:00,000
Na verdade, veja como podemos fazer dinamicamente

16280
10:54:00,000 --> 10:54:02,560
alocar a memória do monte e nós somos

16281
10:54:02,560 --> 10:54:04,240
Vou colocar um pedaço de código para jogar

16282
10:54:04,240 --> 10:54:05,360
E com isso

16283
10:54:05,360 --> 10:54:07,040
Não é realmente complicado, temos um

16284
10:54:07,040 --> 10:54:09,840
ponteiro inicializamos sem ponteiro

16285
10:54:09,840 --> 10:54:12,160
para dizer que este ponteiro não aponta

16286
10:54:12,160 --> 10:54:15,200
para qualquer lugar válido não use e nós

16287
10:54:15,200 --> 10:54:16,080
São

16288
10:54:16,080 --> 10:54:19,520
chamando novos e quando fazemos isso

16289
10:54:19,520 --> 10:54:21,520
O sistema operacional vai nos dar uma

16290
10:54:21,520 --> 10:54:23,840
Novo pedaço de memória no monte

16291
10:54:23,840 --> 10:54:25,520
Este pedaço de memória vai ter

16292
10:54:25,520 --> 10:54:27,520
o tamanho suficiente para contê-lo, então é

16293
10:54:27,520 --> 10:54:29,680
Vou ser quatro bytes na memória e nós

16294
10:54:29,680 --> 10:54:31,680
estará apontando para essa peça

16295
10:54:31,680 --> 10:54:34,320
de memória usando p número quatro aqui este

16296
10:54:34,320 --> 10:54:36,160
É o que estamos tentando dizer aqui o

16297
10:54:36,160 --> 10:54:38,320
No momento em que fazemos isso, nós possuímos este pedaço de

16298
10:54:38,320 --> 10:54:40,640
memória e mais ninguém na operação

16299
10:54:40,640 --> 10:54:42,480
O sistema pode usá-lo para que isso seja algo

16300
10:54:42,480 --> 10:54:44,720
você deve saber uma vez que você tem isso você pode

16301
10:54:44,720 --> 10:54:46,880
manipulá-lo através do ponteiro aqui

16302
10:54:46,880 --> 10:54:48,480
Aqui podemos passar pelo

16303
10:54:48,480 --> 10:54:51,916
operador de referência e loja em 77 e

16304
10:54:51,916 --> 10:54:53,596
Se imprimirmos, vamos conseguir

16305
10:54:53,596 --> 10:54:55,916
que impresso aqui está tudo bem

16306
10:54:55,916 --> 10:54:57,680
Muito legal, esta é a primeira vez que

16307
10:54:57,680 --> 10:55:00,480
Use a memória do quadril e eu estou animado com

16308
10:55:00,480 --> 10:55:02,320
mostrando-lhe isso, obrigado, vamos

16309
10:55:02,320 --> 10:55:04,800
Tente construir este programa e a construção

16310
10:55:04,800 --> 10:55:06,880
vai ser bom e nós vamos

16311
10:55:06,880 --> 10:55:08,080
limpar isso

16312
10:55:08,080 --> 10:55:11,200
E se corrermos o galo, devemos ver um 77

16313
10:55:11,200 --> 10:55:13,520
De baixo, vamos fazer isso

16314
10:55:13,520 --> 10:55:16,960
Eu vou ter o nosso 77, mas este 77 é

16315
10:55:16,960 --> 10:55:19,756
armazenado no heap agora não é armazenado

16316
10:55:19,756 --> 10:55:21,840
na pilha e isso é realmente

16317
10:55:21,840 --> 10:55:24,800
É muito legal que podemos controlar quando isso

16318
10:55:24,800 --> 10:55:27,116
A variável ganha vida por alocação

16319
10:55:27,116 --> 10:55:29,756
memória no monte e nós exatamente

16320
10:55:29,756 --> 10:55:32,640
controle quando esta variável morre

16321
10:55:32,640 --> 10:55:34,320
Se quisermos e vamos ver como nós

16322
10:55:34,320 --> 10:55:36,800
pode matar essa variável da memória, mas

16323
10:55:36,800 --> 10:55:39,040
por agora basta tomar um momento e

16324
10:55:39,040 --> 10:55:41,436
Apreciar o quão bom é ser capaz de

16325
10:55:41,436 --> 10:55:43,596
alocar coisas no monte, é realmente

16326
10:55:43,596 --> 10:55:46,080
legal agora que você usou a memória

16327
10:55:46,080 --> 10:55:48,640
É realmente hora de devolvê-lo ao

16328
10:55:48,640 --> 10:55:50,800
sistema porque não temos mais uso para

16329
10:55:50,800 --> 10:55:52,640
É a maneira como você libera memória para o

16330
10:55:52,640 --> 10:55:56,720
O sistema é chamar a palavra-chave delete

16331
10:55:56,720 --> 10:55:58,880
e dizer o ponteiro apontando para o

16332
10:55:58,880 --> 10:56:01,436
memória que você está tentando liberar para

16333
10:56:01,436 --> 10:56:03,200
O sistema, então vamos dizer p

16334
10:56:03,200 --> 10:56:05,680
Número quatro aqui vamos trazer isto para baixo um

16335
10:56:05,680 --> 10:56:07,276
Um pouquinho para que você possa ver o

16336
10:56:07,276 --> 10:56:09,840
história inteira, então temos um ponteiro aqui

16337
10:56:09,840 --> 10:56:11,916
e está apontando para dinâmicamente

16338
10:56:11,916 --> 10:56:13,916
Afastou a memória do monte este

16339
10:56:13,916 --> 10:56:15,916
A memória é quatro bytes

16340
10:56:15,916 --> 10:56:18,560
grande porque ele armazena um inteiro

16341
10:56:18,560 --> 10:56:21,840
temos isso dinamicamente alocado que usamos

16342
10:56:21,840 --> 10:56:24,400
Aqui e é hora de devolvê-lo a

16343
10:56:24,400 --> 10:56:26,720
O sistema operacional está bem, eu espero que isso seja

16344
10:56:26,720 --> 10:56:28,880
limpar o momento em que você chamar o delete

16345
10:56:28,880 --> 10:56:30,320
palavra-chave

16346
10:56:30,320 --> 10:56:32,720
Agora a memória vai conter

16347
10:56:32,720 --> 10:56:34,880
algum lixo e você não quer realmente

16348
10:56:34,880 --> 10:56:37,200
Use isso se você tentar usá-lo

16349
10:56:37,200 --> 10:56:39,116
Não é a sua memória que você vai correr

16350
10:56:39,116 --> 10:56:41,116
em apuros, por exemplo, depois de

16351
10:56:41,116 --> 10:56:43,040
excluir essa memória se tentarmos usá-la

16352
10:56:43,040 --> 10:56:45,360
Eu vou te mostrar aqui eu acho que eu posso

16353
10:56:45,360 --> 10:56:48,720
vamos dizer p número quatro e um armazenamento

16354
10:56:48,720 --> 10:56:50,960
Algo note que estamos usando o

16355
10:56:50,960 --> 10:56:53,200
o operador de referência e vamos tentar e

16356
10:56:53,200 --> 10:56:55,520
colocar em um 45 por que não

16357
10:56:55,520 --> 10:56:58,080
Então vamos construir isso com gcc como nós

16358
10:56:58,080 --> 10:57:00,400
sempre fazê-lo vai para um compilador mundial

16359
10:57:00,400 --> 10:57:02,000
Não vai impedi-lo de fazer

16360
10:57:02,000 --> 10:57:03,916
Algo assim

16361
10:57:03,916 --> 10:57:05,596
Escrever na memória que você tem

16362
10:57:05,596 --> 10:57:06,400
Já

16363
10:57:06,400 --> 10:57:08,800
liberado para o sistema, mas nós vamos

16364
10:57:08,800 --> 10:57:12,000
para ver o que acontece assim correr galo e

16365
10:57:12,000 --> 10:57:14,080
vai dizer que fez a escrita, mas você

16366
10:57:14,080 --> 10:57:17,276
Veja que o programa realmente caiu

16367
10:57:17,276 --> 10:57:20,400
porque aqui estamos tentando escrever em

16368
10:57:20,400 --> 10:57:22,560
memória que nós realmente não possuímos e isso

16369
10:57:22,560 --> 10:57:25,520
É ruim não faça isso, então no momento em que você

16370
10:57:25,520 --> 10:57:27,916
excluir a memória ou o momento em que você

16371
10:57:27,916 --> 10:57:29,596
Retorne a memória para a operação

16372
10:57:29,596 --> 10:57:32,400
sistema é uma boa prática redefinir isso

16373
10:57:32,400 --> 10:57:35,040
memória para não ptr, então vamos dizer p

16374
10:57:35,040 --> 10:57:36,880
O número quatro e

16375
10:57:36,880 --> 10:57:40,640
certifique-se de que ele contém nenhum ptor

16376
10:57:40,640 --> 10:57:42,800
Pelo menos quando fazemos essas outras pessoas

16377
10:57:42,800 --> 10:57:45,200
ter a chance de verificar e ver que

16378
10:57:45,200 --> 10:57:47,436
que é memória válida antes de usá-lo

16379
10:57:47,436 --> 10:57:49,756
que é o uso de redefinir sua memória

16380
10:57:49,756 --> 10:57:51,916
Aqui, então isso é algo que você deve fazer

16381
10:57:51,916 --> 10:57:54,400
novamente o fluxo para usar a memória dinâmica é

16382
10:57:54,400 --> 10:57:56,400
muito simples você configurar um ponteiro que

16383
10:57:56,400 --> 10:57:58,720
vai apontar para sua memória

16384
10:57:58,720 --> 10:57:59,916
Você está indo para

16385
10:57:59,916 --> 10:58:02,400
alocar a memória do heap usando

16386
10:58:02,400 --> 10:58:04,800
O novo operador que você especificará

16387
10:58:04,800 --> 10:58:07,436
o tipo que deseja alocar memória para

16388
10:58:07,436 --> 10:58:08,960
O sistema operacional vai dar

16389
10:58:08,960 --> 10:58:10,400
Você que memória e você vai ser

16390
10:58:10,400 --> 10:58:12,000
apontando para essa memória com o seu

16391
10:58:12,000 --> 10:58:14,320
ponteiro que você vai manipular isso

16392
10:58:14,320 --> 10:58:16,720
memória usando seu ponteiro e fazendo tudo

16393
10:58:16,720 --> 10:58:19,116
Tipos de coisas loucas e depois de você

16394
10:58:19,116 --> 10:58:20,640
feito com essa memória que você vai

16395
10:58:20,640 --> 10:58:23,596
libere-o para o sistema operacional e

16396
10:58:23,596 --> 10:58:24,640
Por favor

16397
10:58:24,640 --> 10:58:27,040
Lembre-se de redefinir suas dicas

16398
10:58:27,040 --> 10:58:29,916
Depois de excluí-los assim

16399
10:58:29,916 --> 10:58:31,840
que vai fazer sua vida inteira

16400
10:58:31,840 --> 10:58:34,560
Muito mais fácil e outros desenvolvedores são

16401
10:58:34,560 --> 10:58:36,640
Vou agradecer por fazer isso

16402
10:58:36,640 --> 10:58:38,640
quando eles conseguem usar seu código porque

16403
10:58:38,640 --> 10:58:40,960
Seu código será muito mais seguro para

16404
10:58:40,960 --> 10:58:43,040
trabalhar com OK vamos comentar isso

16405
10:58:43,040 --> 10:58:45,520
e mostrar-lhe um outro exemplo do que

16406
10:58:45,520 --> 10:58:47,840
coisas legais que você pode fazer com pilha dinâmica

16407
10:58:47,840 --> 10:58:49,916
memória, vamos descer e colocar

16408
10:58:49,916 --> 10:58:51,520
um pedaço de código e mostrar que você

16409
10:58:51,520 --> 10:58:52,880
Pode realmente

16410
10:58:52,880 --> 10:58:55,520
inicialize de forma dinâmica seus ponteiros em

16411
10:58:55,520 --> 10:58:57,916
Declaração é algo que você pode fazer

16412
10:58:57,916 --> 10:59:00,000
O primeiro não é inicializado, então é

16413
10:59:00,000 --> 10:59:02,080
vai conter o volume de lixo p número

16414
10:59:02,080 --> 10:59:03,756
Cinco se tentarmos imprimi-lo, vamos

16415
10:59:03,756 --> 10:59:06,320
para obter algum endereço de lixo imprimi-lo para fora

16416
10:59:06,320 --> 10:59:08,400
Número seis, vamos desreferenciar isso

16417
10:59:08,400 --> 10:59:10,320
e imprimir o valor dentro para que nós sejamos

16418
10:59:10,320 --> 10:59:12,240
Vamos ver isso e nós podemos fazer o mesmo

16419
10:59:12,240 --> 10:59:14,160
coisa para p número seis e número p

16420
10:59:14,160 --> 10:59:16,160
Sete depois de terminarmos de usar o

16421
10:59:16,160 --> 10:59:18,400
ponteiros, vamos liberar o

16422
10:59:18,400 --> 10:59:20,320
memória aqui e observe que estamos

16423
10:59:20,320 --> 10:59:22,480
redefinindo os ponteiros para nenhum ponteiro para

16424
10:59:22,480 --> 10:59:24,240
Diga que eles realmente não contêm

16425
10:59:24,240 --> 10:59:27,040
Qualquer coisa útil não usá-los certifique-se de

16426
10:59:27,040 --> 10:59:29,040
Você tem algo válido e diante de você

16427
10:59:29,040 --> 10:59:31,040
usá-los este é o significado aqui se

16428
10:59:31,040 --> 10:59:32,720
Você está tentando executar o programa que você pode

16429
10:59:32,720 --> 10:59:34,640
Adivinha o que vamos ver, então tente e

16430
10:59:34,640 --> 10:59:36,800
guess e nós vamos construir nós somos

16431
10:59:36,800 --> 10:59:38,880
indo para soldar com sucesso indo com sucesso

16432
10:59:38,880 --> 10:59:39,680
claro

16433
10:59:39,680 --> 10:59:42,080
claro não claro e nós vamos correr

16434
10:59:42,080 --> 10:59:44,000
Galo e nós vamos ver isso

16435
10:59:44,000 --> 10:59:46,640
número cinco contém algum endereço lixo

16436
10:59:46,640 --> 10:59:49,040
Tudo bem e se tentarmos desreferir que

16437
10:59:49,040 --> 10:59:51,520
nós vamos ter um valor de lixo que é

16438
10:59:51,520 --> 10:59:54,000
Realmente não é útil não usar esse valor

16439
10:59:54,000 --> 10:59:56,480
Porque você não colocou esse valor em

16440
10:59:56,480 --> 10:59:58,400
O primeiro lugar que você vai ver isso

16441
10:59:58,400 --> 11:00:00,400
p número 6 vai apontar para alguns

16442
11:00:00,400 --> 11:00:02,400
outro endereço, mas nós vamos ter um

16443
11:00:02,400 --> 11:00:05,680
valor válido dentro porque nós colocamos

16444
11:00:05,680 --> 11:00:09,040
que n na inicialização aqui o mesmo

16445
11:00:09,040 --> 11:00:10,960
é verdade para p número sete que vai

16446
11:00:10,960 --> 11:00:13,116
apontar para algum endereço e nós vamos

16447
11:00:13,116 --> 11:00:17,040
Temos 23 e porque colocamos nos nossos 23.

16448
11:00:17,040 --> 11:00:18,480
É assim que você realmente usa isso

16449
11:00:18,480 --> 11:00:20,320
apontam outra coisa que eu quero que você

16450
11:00:20,320 --> 11:00:23,360
Saiba que mesmo que tenhamos chamado

16451
11:00:23,360 --> 11:00:26,480
excluir e redefinir esses ponteiros que são

16452
11:00:26,480 --> 11:00:28,880
ainda disponível para uso em nosso programa

16453
11:00:28,880 --> 11:00:30,800
então, se quisermos, podemos reutilizá-los

16454
11:00:30,800 --> 11:00:32,960
apontadores, por exemplo, p número cinco

16455
11:00:32,960 --> 11:00:34,800
pode levá-lo

16456
11:00:34,800 --> 11:00:36,960
e usá-lo para alocar nova memória para que nós

16457
11:00:36,960 --> 11:00:38,720
Pode dizer novo e

16458
11:00:38,720 --> 11:00:42,000
e uh armazenar um 81 por que não

16459
11:00:42,000 --> 11:00:44,400
Tudo bem para que possamos ir aqui e usar isso

16460
11:00:44,400 --> 11:00:46,400
isso vai ser válido c plus plus

16461
11:00:46,400 --> 11:00:47,680
o código

16462
11:00:47,680 --> 11:00:49,840
Ok, tome um momento e olhe para ele é

16463
11:00:49,840 --> 11:00:52,880
p número cinco não número p

16464
11:00:52,880 --> 11:00:54,560
e o código do estúdio visual vai

16465
11:00:54,560 --> 11:00:56,400
tomar isso porque é válido c mais

16466
11:00:56,400 --> 11:00:59,276
além do código, a memória foi retornada

16467
11:00:59,276 --> 11:01:01,756
ao sistema operacional e ao ponteiro

16468
11:01:01,756 --> 11:01:04,560
foi redefinido para nenhum ptr, mas nós podemos

16469
11:01:04,560 --> 11:01:06,800
reutilizar este ponteiro final para alocar novos

16470
11:01:06,800 --> 11:01:09,040
Memória para que possamos alocar nova memória

16471
11:01:09,040 --> 11:01:11,520
no monte a memória vai ser

16472
11:01:11,520 --> 11:01:14,320
Quatro bytes porque é

16473
11:01:14,320 --> 11:01:16,720
vamos conter um inteiro e nós

16474
11:01:16,720 --> 11:01:18,400
Usando este ponteiro

16475
11:01:18,400 --> 11:01:20,560
para apontar para essa nova memória, então isso

16476
11:01:20,560 --> 11:01:22,880
O ponteiro está sendo reutilizado que estava apontando

16477
11:01:22,880 --> 11:01:23,596
A sua forma de

16478
11:01:23,596 --> 11:01:25,840
A memória que alocamos aqui, que

16479
11:01:25,840 --> 11:01:28,560
Foi unnitorializado e estamos usando isso

16480
11:01:28,560 --> 11:01:30,240
para apontar para o novo

16481
11:01:30,240 --> 11:01:32,240
Localização da memória no quadril eu realmente quero

16482
11:01:32,240 --> 11:01:35,200
você para entender essas coisas porque

16483
11:01:35,200 --> 11:01:37,916
Muitos iniciantes dão errado e é

16484
11:01:37,916 --> 11:01:40,160
É difícil corrigir essas coisas em seu

16485
11:01:40,160 --> 11:01:43,116
mente uma vez que você tem uma ideia errada sobre

16486
11:01:43,116 --> 11:01:45,276
em primeiro lugar, então certifique-se de que você

16487
11:01:45,276 --> 11:01:47,276
Entenda isso se imprimirmos isso

16488
11:01:47,276 --> 11:01:50,240
Vamos tirar os 81 impressos

16489
11:01:50,240 --> 11:01:51,276


16490
11:01:51,276 --> 11:01:53,680
Atribuímos nova memória a que temos que

16491
11:01:53,680 --> 11:01:55,756
Lembre-se de liberá-lo novamente, então nós temos

16492
11:01:55,756 --> 11:01:58,160
para vir e dizer excluir

16493
11:01:58,160 --> 11:02:01,276
p número cinco e precisamos redefini-lo para

16494
11:02:01,276 --> 11:02:03,040
sem ponteiro

16495
11:02:03,040 --> 11:02:04,800
E nós vamos fazer isso

16496
11:02:04,800 --> 11:02:05,916
Aqui mesmo

16497
11:02:05,916 --> 11:02:07,840
Uma vez que façamos isso, vamos ser

16498
11:02:07,840 --> 11:02:09,680
jogando pelo seguro, vamos tentar correr e

16499
11:02:09,680 --> 11:02:12,240
Veja que vemos o at1 impresso

16500
11:02:12,240 --> 11:02:14,160
vamos construir com o Gcc o mundo

16501
11:02:14,160 --> 11:02:16,000
Vai passar por aqui

16502
11:02:16,000 --> 11:02:18,320
e nós vamos limpar e correr

16503
11:02:18,320 --> 11:02:21,200
Galo e você vê que vemos o nosso 81

16504
11:02:21,200 --> 11:02:23,840
e nós não temos nenhum acidente louco por

16505
11:02:23,840 --> 11:02:25,680
Um exemplo para provar que não temos um

16506
11:02:25,680 --> 11:02:28,560
Podemos dizer que nosso programa é

16507
11:02:28,560 --> 11:02:30,640
terminando bem

16508
11:02:30,640 --> 11:02:32,480
Está terminando bem

16509
11:02:32,480 --> 11:02:33,436
E uh

16510
11:02:33,436 --> 11:02:34,960
nós vamos saber

16511
11:02:34,960 --> 11:02:37,840
se o programa realmente atingiu o

16512
11:02:37,840 --> 11:02:40,880
No fim antes que ele morra, vamos construir

16513
11:02:40,880 --> 11:02:42,480
Mais uma vez

16514
11:02:42,480 --> 11:02:44,080
com o Gcc

16515
11:02:44,080 --> 11:02:46,960
E nós vamos limpar

16516
11:02:46,960 --> 11:02:49,436
e correr galo e você vai ver

16517
11:02:49,436 --> 11:02:51,596
que o programa está terminando bem

16518
11:02:51,596 --> 11:02:53,360
A outra coisa que eu quero que você veja é

16519
11:02:53,360 --> 11:02:57,436
que é realmente ruim chamar excluir

16520
11:02:57,436 --> 11:03:01,360
duas vezes em um ponteiro novamente é realmente

16521
11:03:01,360 --> 11:03:04,800
ruim para chamar excluir duas vezes em um ponteiro

16522
11:03:04,800 --> 11:03:06,560
Não faça isso bem, vamos ver um

16523
11:03:06,560 --> 11:03:08,560
Um exemplo disso aqui

16524
11:03:08,560 --> 11:03:10,160
Então vamos alocar nova memória

16525
11:03:10,160 --> 11:03:12,240
usando p número cinco, por que não para que não seja

16526
11:03:12,240 --> 11:03:14,560
vamos dizer p número cinco e nós somos

16527
11:03:14,560 --> 11:03:17,276
vamos dizer novo e ir alocar

16528
11:03:17,276 --> 11:03:18,800
Nova memória no monte e nós vamos

16529
11:03:18,800 --> 11:03:22,240
para armazenar em um 99 nessa memória que podemos

16530
11:03:22,240 --> 11:03:24,720
imprimir o 99, então vamos dizer

16531
11:03:24,720 --> 11:03:26,960
e depois que terminamos de usar essa memória

16532
11:03:26,960 --> 11:03:28,960
Somos um bom c plus mais cidadão, então

16533
11:03:28,960 --> 11:03:31,520
Vamos chamar o delete

16534
11:03:31,520 --> 11:03:33,756
e dizer p número cinco

16535
11:03:33,756 --> 11:03:35,840
Tudo bem, isso é bom que vai funcionar se

16536
11:03:35,840 --> 11:03:38,240
Vamos então correr, vamos conseguir o que

16537
11:03:38,240 --> 11:03:42,160
Nós esperamos ter um 99 impressos

16538
11:03:42,160 --> 11:03:45,680
último em nosso programa antes que ele termine e

16539
11:03:45,680 --> 11:03:47,916
Nós vemos isso impresso aqui programa

16540
11:03:47,916 --> 11:03:49,916
terminando bem isso é muito legal

16541
11:03:49,916 --> 11:03:53,596
mas se tentarmos chamar excluir duas vezes

16542
11:03:53,596 --> 11:03:56,080
e dizer p número cinco novamente

16543
11:03:56,080 --> 11:03:57,596
e tente ferver você vê que o

16544
11:03:57,596 --> 11:03:59,520
O compilador não vai nos parar porque

16545
11:03:59,520 --> 11:04:00,800
Isso agradece

16546
11:04:00,800 --> 11:04:02,720
nós sabemos o que estamos fazendo

16547
11:04:02,720 --> 11:04:04,240
Então isso é algo que você precisa ser

16548
11:04:04,240 --> 11:04:06,720
ciente de em c plus plus se executarmos isso

16549
11:04:06,720 --> 11:04:07,840
O programa

16550
11:04:07,840 --> 11:04:09,756
Você vai ver ah o programa é

16551
11:04:09,756 --> 11:04:11,840
não vai terminar bem o c plus mais

16552
11:04:11,840 --> 11:04:14,320
tempo de execução ou o sistema operacional está indo

16553
11:04:14,320 --> 11:04:16,160
para chegar aqui e ver que esse cara é

16554
11:04:16,160 --> 11:04:18,400
Tentando liberar a memória duas vezes e eu

16555
11:04:18,400 --> 11:04:20,560
Não faça que este é um programa ruim eu sou

16556
11:04:20,560 --> 11:04:22,160
Vou matá-lo e vai ser

16557
11:04:22,160 --> 11:04:24,640
A coisa ruim novamente é que

16558
11:04:24,640 --> 11:04:27,116
qualquer coisa que você tenha em seu programa depois

16559
11:04:27,116 --> 11:04:29,680
Estas linhas não vão correr porque

16560
11:04:29,680 --> 11:04:31,840
O sistema operacional vai matar

16561
11:04:31,840 --> 11:04:34,640
seu programa nesta linha aqui, então se você

16562
11:04:34,640 --> 11:04:37,200
tinha memória alocada que você planejava

16563
11:04:37,200 --> 11:04:39,840
divulgue mais tarde no seu programa

16564
11:04:39,840 --> 11:04:41,436
A memória não será liberada

16565
11:04:41,436 --> 11:04:43,436
Porque essas declarações para liberar o

16566
11:04:43,436 --> 11:04:45,916
A memória nunca será executada, é onde

16567
11:04:45,916 --> 11:04:47,916
O programa vai ser morto

16568
11:04:47,916 --> 11:04:49,596
O sistema operacional vai ver que

16569
11:04:49,596 --> 11:04:52,160
você é um programa de tapetes e ele vai

16570
11:04:52,160 --> 11:04:55,200
matar o programa para não apagar seu

16571
11:04:55,200 --> 11:04:57,276
Memória duas vezes isso é algo que você

16572
11:04:57,276 --> 11:04:59,116
Deve realmente tomar cuidado e você

16573
11:04:59,116 --> 11:05:01,116
poderia pensar uh-huh eu sei isso por que

16574
11:05:01,116 --> 11:05:03,596
Eu chamo excluído duas vezes em uma única linha

16575
11:05:03,596 --> 11:05:06,080
Aqui bem você pode não fazer assim

16576
11:05:06,080 --> 11:05:08,640
mas o seu programa pode ter múltiplos

16577
11:05:08,640 --> 11:05:09,756
Arquivos de arquivos

16578
11:05:09,756 --> 11:05:11,596
onde você tem ponteiros apontando para o

16579
11:05:11,596 --> 11:05:13,680
a mesma memória e se você tentar excluir

16580
11:05:13,680 --> 11:05:15,840
Que memória duas vezes você vai ter

16581
11:05:15,840 --> 11:05:17,840
Este erro e isso é realmente bom

16582
11:05:17,840 --> 11:05:19,680
cuidado com esses tipos de coisas e

16583
11:05:19,680 --> 11:05:21,116
nós vamos ver maneiras diferentes de você

16584
11:05:21,116 --> 11:05:22,080
pode

16585
11:05:22,080 --> 11:05:24,960
Use para realmente ter certeza de que você está fazendo

16586
11:05:24,960 --> 11:05:26,960
coisas certas em c plus plus este é

16587
11:05:26,960 --> 11:05:28,400
Realmente tudo o que nos posicionamos para fazer nisso

16588
11:05:28,400 --> 11:05:31,276
palestrando dando-lhe prática em primeira mão

16589
11:05:31,276 --> 11:05:34,800
sobre como fazer alocação de memória dinâmica i

16590
11:05:34,800 --> 11:05:37,040
Espero que você tenha encontrado isso útil, estamos indo

16591
11:05:37,040 --> 11:05:38,800
para parar aqui nesta palestra e

16592
11:05:38,800 --> 11:05:40,560
Em seguida, vamos aprender sobre

16593
11:05:40,560 --> 11:05:42,240
peningando ponteiros

16594
11:05:42,240 --> 11:05:44,720
Vá em frente e termine aqui e nós seríamos

16595
11:05:44,720 --> 11:05:46,800
lá nesta palestra vamos

16596
11:05:46,800 --> 11:05:49,040
Concentre-se em ponteiros pendurados e mostre-lhe

16597
11:05:49,040 --> 11:05:51,360
Como eles podem ser ruins, um ponteiro pendurado

16598
11:05:51,360 --> 11:05:54,160
é um ponteiro que está apontando para um

16599
11:05:54,160 --> 11:05:56,160
abordar e vimos alguns exemplos

16600
11:05:56,160 --> 11:05:58,160
disso já, mas nesta palestra

16601
11:05:58,160 --> 11:06:00,160
Vamos nos concentrar nisso e mostrar

16602
11:06:00,160 --> 11:06:02,320
soluções comuns às quais podemos aplicar

16603
11:06:02,320 --> 11:06:04,800
Estes problemas aqui e download

16604
11:06:04,800 --> 11:06:06,960
Os ponteiros são realmente ruins que estão indo

16605
11:06:06,960 --> 11:06:09,040
para levar seus programas a não definidos

16606
11:06:09,040 --> 11:06:11,680
Comportamento e vimos que isso pode

16607
11:06:11,680 --> 11:06:13,276
esmagar o seu programa

16608
11:06:13,276 --> 11:06:16,240
Muitas vezes existem três tipos de

16609
11:06:16,240 --> 11:06:17,916
pendurando ponteiros que vamos olhar

16610
11:06:17,916 --> 11:06:19,916
Nesta palestra o primeiro é a

16611
11:06:19,916 --> 11:06:22,400
pontor que não é inicializado o

16612
11:06:22,400 --> 11:06:25,360
O segundo é um ponteiro excluído e o

16613
11:06:25,360 --> 11:06:28,000
O terceiro caso pode vir se você tiver vários

16614
11:06:28,000 --> 11:06:29,916
ponteiros apontando para a mesma memória

16615
11:06:29,916 --> 11:06:32,880
localização e vamos olhar para estes casos

16616
11:06:32,880 --> 11:06:35,200
Um por um, temos um exemplo de

16617
11:06:35,200 --> 11:06:37,840
Pontor que não é devidamente inicializado

16618
11:06:37,840 --> 11:06:40,160
este é p número cinco é um ponteiro para

16619
11:06:40,160 --> 11:06:40,960
O fim

16620
11:06:40,960 --> 11:06:42,720
e não é inicializado, não

16621
11:06:42,720 --> 11:06:44,880
realmente apontar em qualquer lugar e vai

16622
11:06:44,880 --> 11:06:47,276
conter endereço de lixo se tentarmos

16623
11:06:47,276 --> 11:06:49,040
dereferência, nós vamos ficar ruins

16624
11:06:49,040 --> 11:06:51,360
Coisas para acontecer porque nós realmente não

16625
11:06:51,360 --> 11:06:54,240
saber qual endereço está armazenado lá

16626
11:06:54,240 --> 11:06:56,160
e colocar algo lá pode

16627
11:06:56,160 --> 11:06:58,880
levar a um acidente, então isso é algo que você

16628
11:06:58,880 --> 11:07:01,116
precisa ter cuidado com o segundo tipo de

16629
11:07:01,116 --> 11:07:03,276
pendurar ponteiro que pode realmente liderar

16630
11:07:03,276 --> 11:07:06,240
você para lugares ruins é um ponteiro excluído

16631
11:07:06,240 --> 11:07:09,276
Aqui está um ponteiro p número um que é

16632
11:07:09,276 --> 11:07:12,080
inicializado com memória dinâmica e nós

16633
11:07:12,080 --> 11:07:14,080
pode usá-lo, por exemplo, aqui estamos

16634
11:07:14,080 --> 11:07:16,240
dereferenciando o ponteiro e impressão

16635
11:07:16,240 --> 11:07:18,720
o valor dentro e excluindo o

16636
11:07:18,720 --> 11:07:21,276
ponteiro depois que nós excluímos o ponteiro

16637
11:07:21,276 --> 11:07:23,840
realmente não usá-lo antes de você corretamente

16638
11:07:23,840 --> 11:07:26,320
inicializá-lo com algum tipo de memória

16639
11:07:26,320 --> 11:07:28,800
Se tentarmos fazer que isso vai ser

16640
11:07:28,800 --> 11:07:31,276
Comportamento indefinido e seu programa

16641
11:07:31,276 --> 11:07:33,756
pode falhar, então certifique-se de não fazer

16642
11:07:33,756 --> 11:07:36,080
Algo como este outro caso é se

16643
11:07:36,080 --> 11:07:38,080
você tem vários ponteiros apontando para

16644
11:07:38,080 --> 11:07:40,880
O mesmo endereço e aqui está um simples

16645
11:07:40,880 --> 11:07:43,520
exemplo para conduzir o ponto para casa que temos

16646
11:07:43,520 --> 11:07:46,160
pontodor três que está apontando para

16647
11:07:46,160 --> 11:07:49,200
memória dinâmica aqui estamos usando nova formista

16648
11:07:49,200 --> 11:07:52,560
em nosso inicializador braced e nós somos

16649
11:07:52,560 --> 11:07:55,360
colocando valor 83 nesse ponteiro

16650
11:07:55,360 --> 11:07:56,480
A localização

16651
11:07:56,480 --> 11:07:58,640
e aqui nós configuramos outro ponteiro p

16652
11:07:58,640 --> 11:08:01,436
número quatro e inicializamos isso com

16653
11:08:01,436 --> 11:08:03,680
outro ponteiro e se imprimirmos estes

16654
11:08:03,680 --> 11:08:05,200
Coisas fora nós vamos ter que eles

16655
11:08:05,200 --> 11:08:07,276
Contêm o mesmo endereço e

16656
11:08:07,276 --> 11:08:08,800
Contém o mesmo valor para o qual vamos

16657
11:08:08,800 --> 11:08:09,840
Veja que

16658
11:08:09,840 --> 11:08:12,560
se eliminarmos p número três

16659
11:08:12,560 --> 11:08:15,040
e tentar usar p número quatro mais tarde

16660
11:08:15,040 --> 11:08:16,960
Vou ter problemas porque isso

16661
11:08:16,960 --> 11:08:19,360
A memória foi apagada pelo número p

16662
11:08:19,360 --> 11:08:20,320
Três

16663
11:08:20,320 --> 11:08:22,800
mas p número quatro ainda está apontando para

16664
11:08:22,800 --> 11:08:24,800
Isso e se tenta usar que é

16665
11:08:24,800 --> 11:08:27,360
será basicamente apagado memória e

16666
11:08:27,360 --> 11:08:29,200
Nós vamos ter um comportamento indefinido, então

16667
11:08:29,200 --> 11:08:32,480
Certifique-se de conhecer esses problemas e tentar

16668
11:08:32,480 --> 11:08:34,880
para evitá-los em seus programas ok

16669
11:08:34,880 --> 11:08:37,360
Estes são problemas, mas como resolver

16670
11:08:37,360 --> 11:08:40,240
Bem, existem algumas soluções

16671
11:08:40,240 --> 11:08:42,400
É sempre inicializar suas dicas

16672
11:08:42,400 --> 11:08:44,640
no momento em que você declara um ponteiro

16673
11:08:44,640 --> 11:08:46,960
É inicializado se você não sabe

16674
11:08:46,960 --> 11:08:48,800
O que você pode inicializar esse ponteiro

16675
11:08:48,800 --> 11:08:51,360
com colocar em ponteiro nulo primeiro e, em seguida,

16676
11:08:51,360 --> 11:08:53,200
Você vai colocar em um endereço mais tarde

16677
11:08:53,200 --> 11:08:56,000
quando você tem uma ideia clara de qual

16678
11:08:56,000 --> 11:08:57,916
Endereço que você pode armazenar no segundo

16679
11:08:57,916 --> 11:09:00,720
A solução é redefinir seus ponteiros para

16680
11:09:00,720 --> 11:09:04,240
agora ptr depois de apagar a memória

16681
11:09:04,240 --> 11:09:06,000
É a segunda coisa que você deve fazer

16682
11:09:06,000 --> 11:09:08,320
Cada vez que você chama excluir que está indo

16683
11:09:08,320 --> 11:09:10,400
para dar outros desenvolvedores ou até mesmo

16684
11:09:10,400 --> 11:09:12,880
você mesmo a chance de verificar e ver se

16685
11:09:12,880 --> 11:09:14,480
essa localização de memória

16686
11:09:14,480 --> 11:09:16,960
Contém um endereço válido antes de fazer

16687
11:09:16,960 --> 11:09:19,436
Isso e para múltiplos ponteiros apontando

16688
11:09:19,436 --> 11:09:22,080
para o mesmo endereço que você tem que escolher

16689
11:09:22,080 --> 11:09:24,960
e fazer um ponteiro o mestre do

16690
11:09:24,960 --> 11:09:26,960
Controlador da memória

16691
11:09:26,960 --> 11:09:29,116
e todos os ponteiros estão basicamente indo para

16692
11:09:29,116 --> 11:09:32,080
ser escravos que não podem liberar a memória

16693
11:09:32,080 --> 11:09:34,400
Mas eles podem ler e fazer algo com

16694
11:09:34,400 --> 11:09:36,240
A memória que eles não têm

16695
11:09:36,240 --> 11:09:39,276
tarefa de liberar essa memória e aqui

16696
11:09:39,276 --> 11:09:41,200
é como você pode aplicar a solução para

16697
11:09:41,200 --> 11:09:43,756
exemplo, temos o ponteiro número cinco e

16698
11:09:43,756 --> 11:09:45,840
nós vamos preparar para inicializar isso

16699
11:09:45,840 --> 11:09:48,640
vai inicializá-lo para

16700
11:09:48,640 --> 11:09:50,800
null pointer a outra coisa que você pode fazer

16701
11:09:50,800 --> 11:09:53,276
é inicializar o ponteiro com dinâmica

16702
11:09:53,276 --> 11:09:55,276
Memória como estamos fazendo aqui com p

16703
11:09:55,276 --> 11:09:57,436
número seis e isso vai colocar em

16704
11:09:57,436 --> 11:09:59,360
O valor e vamos jogar

16705
11:09:59,360 --> 11:10:00,880
no lado seguro

16706
11:10:00,880 --> 11:10:03,520
Agora, se seus ponteiros forem inicializados

16707
11:10:03,520 --> 11:10:05,436
Os desenvolvedores têm a chance de verificar o seu

16708
11:10:05,436 --> 11:10:08,560
apontadores contra nenhuma ptr para ver que eles

16709
11:10:08,560 --> 11:10:11,596
conter algo válido antes de usar

16710
11:10:11,596 --> 11:10:13,916
e se eles vêem que não contém

16711
11:10:13,916 --> 11:10:16,400
ptr eles não vão tentar usá-lo

16712
11:10:16,400 --> 11:10:19,040
E isso vai ser muito seguro para

16713
11:10:19,040 --> 11:10:21,916
O segundo problema com ponteiros excluídos

16714
11:10:21,916 --> 11:10:24,400
Vamos redefinir nossas dicas depois

16715
11:10:24,400 --> 11:10:26,160
chamamos exclusão, por exemplo, aqui temos

16716
11:10:26,160 --> 11:10:28,480
pino número sete inicializado com

16717
11:10:28,480 --> 11:10:31,756
memória dinâmica e 82 são armazenados em nós

16718
11:10:31,756 --> 11:10:33,916
pode imprimi-lo tudo com ele

16719
11:10:33,916 --> 11:10:35,840
Quando apagamos a memória, vamos

16720
11:10:35,840 --> 11:10:38,480
redefini-lo para null p2r de modo que outros

16721
11:10:38,480 --> 11:10:40,800
Desenvolvedores ou até que nós mesmos podemos verificar

16722
11:10:40,800 --> 11:10:43,596
Esta memória contra nenhuma ptr e se é

16723
11:10:43,596 --> 11:10:46,800
diferente de nenhum ptr nós podemos usá-lo se

16724
11:10:46,800 --> 11:10:48,800
É igual a nenhum ptr nós vamos

16725
11:10:48,800 --> 11:10:50,560
Deixe em paz e faça outra coisa

16726
11:10:50,560 --> 11:10:53,116
Isso vai ser muito seguro se você

16727
11:10:53,116 --> 11:10:55,040
ter vários ponteiros apontando para o

16728
11:10:55,040 --> 11:10:56,880
O mesmo endereço como temos aqui, então

16729
11:10:56,880 --> 11:10:58,720
você vai ter que decidir qual

16730
11:10:58,720 --> 11:11:01,116
O ponteiro é o ponteiro mestre e outro

16731
11:11:01,116 --> 11:11:03,200
Os ponteiros vão ser

16732
11:11:03,200 --> 11:11:06,480
ponteiros escravos e antes do uso

16733
11:11:06,480 --> 11:11:08,160
Todos os outros ponteiros vão

16734
11:11:08,160 --> 11:11:10,800
Verifique em relação ao ponteiro mestre e veja

16735
11:11:10,800 --> 11:11:13,116
que contém memória válida porque

16736
11:11:13,116 --> 11:11:15,276
O ponteiro mestre tem a tarefa de

16737
11:11:15,276 --> 11:11:17,436
Excluindo essa memória, vamos passar

16738
11:11:17,436 --> 11:11:19,276
e veja como isso poderia funcionar em

16739
11:11:19,276 --> 11:11:20,720
A prática

16740
11:11:20,720 --> 11:11:23,680
então o p número cinco é o nosso ponteiro mestre

16741
11:11:23,680 --> 11:11:26,240
nós estamos definindo p número cinco e

16742
11:11:26,240 --> 11:11:29,360
inicializando-o com p número oito nós

16743
11:11:29,360 --> 11:11:31,360
estão criando coisas usando p número oito

16744
11:11:31,360 --> 11:11:33,360
nós podemos usar p número oito ou pino

16745
11:11:33,360 --> 11:11:35,360
olho urbano isso vai funcionar, mas

16746
11:11:35,360 --> 11:11:37,916
antes de usarmos a localização da memória, somos

16747
11:11:37,916 --> 11:11:40,080
Vou verificar contra o mestre

16748
11:11:40,080 --> 11:11:42,320
ponteiro se o ponteiro mestre contém

16749
11:11:42,320 --> 11:11:44,240
Não há ptr, não vamos usar isso

16750
11:11:44,240 --> 11:11:46,720
memória se o ponteiro mestre não

16751
11:11:46,720 --> 11:11:49,276
conter agora ptr nós vamos usar isso

16752
11:11:49,276 --> 11:11:51,116
memória aqui está bem se você descer, você vê

16753
11:11:51,116 --> 11:11:53,276
que o ponteiro mestre vai ser

16754
11:11:53,276 --> 11:11:55,200
liberando a memória e se tentarmos

16755
11:11:55,200 --> 11:11:58,160
usar essa memória depois que foi excluída

16756
11:11:58,160 --> 11:11:59,840
nós vamos ver que ele contém agora

16757
11:11:59,840 --> 11:12:02,160
ptr e nós não vamos usá-lo

16758
11:12:02,160 --> 11:12:04,320
Isso é algo legal e é realmente

16759
11:12:04,320 --> 11:12:06,800
Fácil de implementar essas diretrizes de segurança

16760
11:12:06,800 --> 11:12:08,960
em seus programas agora que você conhece

16761
11:12:08,960 --> 11:12:10,640
Isso nós vamos para o estúdio visual

16762
11:12:10,640 --> 11:12:13,116
código e mostrar-lhe isso em ação ok

16763
11:12:13,116 --> 11:12:16,160
Aqui estamos em nosso diretório de trabalho o

16764
11:12:16,160 --> 11:12:18,880
O projeto atual está pendurando ponteiros, então

16765
11:12:18,880 --> 11:12:21,116
nós vamos pegar nossos arquivos de modelo

16766
11:12:21,116 --> 11:12:24,720
muito rápido e colocar isso em nosso projeto

16767
11:12:24,720 --> 11:12:26,240
e nós vamos abrir isso em visual

16768
11:12:26,240 --> 11:12:29,200
Código de estúdio que vamos olhar para o

16769
11:12:29,200 --> 11:12:31,520
primeiro caso de um ponteiro pendurado e

16770
11:12:31,520 --> 11:12:33,116
Este é um ponteiro que não é

16771
11:12:33,116 --> 11:12:36,400
inicializado corretamente como p número aqui

16772
11:12:36,400 --> 11:12:38,240
Se tentarmos fazer referência, vamos

16773
11:12:38,240 --> 11:12:40,560
obter algo ruim para acontecer

16774
11:12:40,560 --> 11:12:43,040
Então vamos ver isso e vamos descer e

16775
11:12:43,040 --> 11:12:45,756
Digamos que o programa está terminando bem apenas para

16776
11:12:45,756 --> 11:12:47,680
Eu sei que não tivemos um acidente porque

16777
11:12:47,680 --> 11:12:49,596
Um acidente basicamente vai terminar

16778
11:12:49,596 --> 11:12:52,320
seu programa na linha ofensiva

16779
11:12:52,320 --> 11:12:54,400
Isso é o que vai fazer se

16780
11:12:54,400 --> 11:12:55,520
O programa

16781
11:12:55,520 --> 11:12:57,756
Trabalha bem e termina bem, vamos

16782
11:12:57,756 --> 11:12:59,360
Imprima esta linha aqui

16783
11:12:59,360 --> 11:13:01,520
Vamos trazer para dentro

16784
11:13:01,520 --> 11:13:04,240
gcc para construir este programa e vamos abrir

16785
11:13:04,240 --> 11:13:06,480
Um terminal para que possamos

16786
11:13:06,480 --> 11:13:08,000
Executá-lo, vamos limpar o mundo

16787
11:13:08,000 --> 11:13:09,436
Foi bom

16788
11:13:09,436 --> 11:13:11,520
E nós vamos correr o galo

16789
11:13:11,520 --> 11:13:14,800
Você vê que o programa não terminou bem

16790
11:13:14,800 --> 11:13:17,520
ele caiu e ele caiu porque nós estamos

16791
11:13:17,520 --> 11:13:18,960
Tentando usar

16792
11:13:18,960 --> 11:13:21,520
Memória não inicializada quando funciona

16793
11:13:21,520 --> 11:13:23,276
O sistema vai tentar executá-lo

16794
11:13:23,276 --> 11:13:25,200
O que vai ver ah esse cara é

16795
11:13:25,200 --> 11:13:27,756
Tentando modificar a memória que não

16796
11:13:27,756 --> 11:13:29,756
realmente pertence a ele que é um caminho

16797
11:13:29,756 --> 11:13:31,840
Programa eu vou matá-lo e é

16798
11:13:31,840 --> 11:13:34,400
vai ser encerrado nesta linha aqui

16799
11:13:34,400 --> 11:13:35,840
Isso é realmente ruim

16800
11:13:35,840 --> 11:13:37,200
Você deve evitar esses tipos de

16801
11:13:37,200 --> 11:13:40,080
situações então não faça isso, estamos indo

16802
11:13:40,080 --> 11:13:41,840
para comentar isso e mostrar a você outro

16803
11:13:41,840 --> 11:13:44,400
evento ofensivo que podemos fazer em nosso programa

16804
11:13:44,400 --> 11:13:47,596
e que está usando um ponteiro excluído se

16805
11:13:47,596 --> 11:13:48,800
Você faz isso que você vai conseguir

16806
11:13:48,800 --> 11:13:51,040
Algo ruim em seus programas

16807
11:13:51,040 --> 11:13:53,916
então aqui temos um pequeno exemplo que temos

16808
11:13:53,916 --> 11:13:57,276
um ponteiro para terminar, inicializamos isso com

16809
11:13:57,276 --> 11:13:59,360
Um pedaço dinâmico de memória e nós somos

16810
11:13:59,360 --> 11:14:01,520
indo para a loja em um 67

16811
11:14:01,520 --> 11:14:03,276
e nós podemos imprimir isso, isso está acontecendo

16812
11:14:03,276 --> 11:14:04,880
Para trabalhar muito bem

16813
11:14:04,880 --> 11:14:05,680


16814
11:14:05,680 --> 11:14:07,680
nós apagamos a memória aqui e nós

16815
11:14:07,680 --> 11:14:10,320
Tente usá-lo depois de excluirmos o

16816
11:14:10,320 --> 11:14:12,640
memória para que o sistema operacional não seja

16817
11:14:12,640 --> 11:14:14,480
Vou ficar feliz com isso porque

16818
11:14:14,480 --> 11:14:17,200
uma vez que a memória é excluída, não é

16819
11:14:17,200 --> 11:14:20,320
mais longa nossa memória, então não temos nenhum negócio

16820
11:14:20,320 --> 11:14:22,320
O ponteiro de referência um e tentar

16821
11:14:22,320 --> 11:14:24,720
para usar isso aqui e nós vamos conseguir

16822
11:14:24,720 --> 11:14:26,000
um crush

16823
11:14:26,000 --> 11:14:27,680
E isso é algo que você deve evitar

16824
11:14:27,680 --> 11:14:30,400
então vamos tentar construir isso e mostrar a você

16825
11:14:30,400 --> 11:14:33,276
Isso em ação, vamos limpar

16826
11:14:33,276 --> 11:14:35,276
e correr o galo

16827
11:14:35,276 --> 11:14:37,116
e você vai ver que o programa é

16828
11:14:37,116 --> 11:14:39,756
terminando bem, mas em alguns casos pode

16829
11:14:39,756 --> 11:14:42,640
bater e espero que isso lhe mostre o

16830
11:14:42,640 --> 11:14:43,840
O perigo

16831
11:14:43,840 --> 11:14:46,720
para que essas coisas possam colocá-lo em

16832
11:14:46,720 --> 11:14:49,040
às vezes seu programa vai parecer

16833
11:14:49,040 --> 11:14:51,756
trabalhando bem, mas às vezes quando isso

16834
11:14:51,756 --> 11:14:54,160
memória que estamos apontando em p

16835
11:14:54,160 --> 11:14:56,480
O número um aqui está sendo usado para fazer

16836
11:14:56,480 --> 11:14:58,000
Algo realmente importante pelo

16837
11:14:58,000 --> 11:15:00,400
sistema operacional que você vai ter um

16838
11:15:00,400 --> 11:15:02,720
acidente para que você não está garantido para obter

16839
11:15:02,720 --> 11:15:05,276
O mesmo comportamento toda vez que você corre

16840
11:15:05,276 --> 11:15:07,360
Seu programa, alguns de vocês podem estar dizendo

16841
11:15:07,360 --> 11:15:09,916
aha o programa está funcionando aqui daniel

16842
11:15:09,916 --> 11:15:13,276
Por que você está fazendo isso um grande negócio

16843
11:15:13,276 --> 11:15:15,916
Bem, é um grande negócio, porque você é

16844
11:15:15,916 --> 11:15:18,240
Não garantido para obter os mesmos resultados

16845
11:15:18,240 --> 11:15:21,436
Sempre que você executar este programa, então seja

16846
11:15:21,436 --> 11:15:24,000
Você realmente evita esses tipos de

16847
11:15:24,000 --> 11:15:26,000
situações, vamos tentar limpar e correr

16848
11:15:26,000 --> 11:15:27,596
O programa novamente espero que estejamos indo

16849
11:15:27,596 --> 11:15:30,640
para vê-lo cair, mas não estamos bem, então

16850
11:15:30,640 --> 11:15:33,200
Vamos limpar e reconstruir novamente

16851
11:15:33,200 --> 11:15:35,116
e ver que temos uma melhor sorte que

16852
11:15:35,116 --> 11:15:36,720
O tempo

16853
11:15:36,720 --> 11:15:38,400
Isso é claro

16854
11:15:38,400 --> 11:15:41,040
e correr galo que vai acabar bem

16855
11:15:41,040 --> 11:15:43,116
Mas você percebe que estamos tentando usar

16856
11:15:43,116 --> 11:15:45,596
Um pedaço de memória que já foi

16857
11:15:45,596 --> 11:15:48,480
Apagado e isso é ruim, não faça isso

16858
11:15:48,480 --> 11:15:51,040
Certifique-se de não fazer algo como

16859
11:15:51,040 --> 11:15:52,640
Isso vamos comentar isso

16860
11:15:52,640 --> 11:15:55,200
novamente e mostrar-lhe outra ofensa

16861
11:15:55,200 --> 11:15:57,916
O que podemos fazer com nossos programas e

16862
11:15:57,916 --> 11:16:00,160
Coisas ruins podem acontecer se você tentar

16863
11:16:00,160 --> 11:16:02,880
ter múltiplos ponteiros jogados no

16864
11:16:02,880 --> 11:16:04,640
O mesmo endereço e é isso que temos

16865
11:16:04,640 --> 11:16:07,040
Aqui temos p número três e p número

16866
11:16:07,040 --> 11:16:09,596
Quatro aqui p número três está alocando

16867
11:16:09,596 --> 11:16:12,080
Novo espaço e está apontando para ele

16868
11:16:12,080 --> 11:16:15,680
tem um 83 dentro e um p número quatro é

16869
11:16:15,680 --> 11:16:17,840
inicializado com p número três nós podemos

16870
11:16:17,840 --> 11:16:20,320
fazer isso para que essas duas dicas sejam

16871
11:16:20,320 --> 11:16:23,436
basicamente apontando para a mesma memória

16872
11:16:23,436 --> 11:16:24,720
A localização

16873
11:16:24,720 --> 11:16:27,040
Vamos executar isso e mostrar-lhe isso

16874
11:16:27,040 --> 11:16:28,960
vamos comentar esta exclusão

16875
11:16:28,960 --> 11:16:32,080
declaração aqui e executar o programa primeiro

16876
11:16:32,080 --> 11:16:34,480
para realmente provar que eles estão apontando

16877
11:16:34,480 --> 11:16:36,720
para os mesmos endereços e eles contêm

16878
11:16:36,720 --> 11:16:40,080
os mesmos valores, vamos construir e executar

16879
11:16:40,080 --> 11:16:43,200
Vamos usar o gcc para isso

16880
11:16:43,200 --> 11:16:45,200
e nós vamos limpar e correr galo

16881
11:16:45,200 --> 11:16:46,720
E você vê que

16882
11:16:46,720 --> 11:16:48,960
p número três o endereço é este e

16883
11:16:48,960 --> 11:16:51,276
contém um número de 83 p quatro

16884
11:16:51,276 --> 11:16:52,800
O mesmo agradecimento

16885
11:16:52,800 --> 11:16:55,200
Então vamos ver o que acontece se tentarmos

16886
11:16:55,200 --> 11:16:58,480
excluir usando p número três

16887
11:16:58,480 --> 11:17:01,520
e usando p número quatro depois para tentar e

16888
11:17:01,520 --> 11:17:03,360
Leia coisas que é isso que estamos fazendo

16889
11:17:03,360 --> 11:17:04,160
Aqui

16890
11:17:04,160 --> 11:17:06,400
e vamos ver se o programa

16891
11:17:06,400 --> 11:17:08,800
Na verdade, consegue terminar bem

16892
11:17:08,800 --> 11:17:10,480
Vamos construir de novo o mundo

16893
11:17:10,480 --> 11:17:12,560
Vou ser bom vamos trazer isso para cima e

16894
11:17:12,560 --> 11:17:14,880
clear e run galo

16895
11:17:14,880 --> 11:17:16,560
e você vai ver que o programa

16896
11:17:16,560 --> 11:17:18,480
Também vai acabar bem

16897
11:17:18,480 --> 11:17:21,116
mas estamos usando um pedaço deletado de

16898
11:17:21,116 --> 11:17:23,596
Memória aqui e qualquer coisa pode realmente

16899
11:17:23,596 --> 11:17:26,240
Acontecer bem para que você possa pegar lixo em você

16900
11:17:26,240 --> 11:17:28,480
pode ter realmente qualquer pedaço de lixo

16901
11:17:28,480 --> 11:17:32,160
dentro ou você pode obter uma paixão em alguns

16902
11:17:32,160 --> 11:17:34,720
Casos extremos, então isso é realmente ruim

16903
11:17:34,720 --> 11:17:37,436
Não faça isso, não tente usar um pedaço de

16904
11:17:37,436 --> 11:17:40,080
memória que você já excluiu

16905
11:17:40,080 --> 11:17:42,320
através de um ponteiro e estes são problemas

16906
11:17:42,320 --> 11:17:44,320
você pode se deparar com seus programas se

16907
11:17:44,320 --> 11:17:47,116
você tenta usar a alocação de memória dinâmica

16908
11:17:47,116 --> 11:17:49,756
Vejamos como podemos resolvê-los

16909
11:17:49,756 --> 11:17:51,040
E o

16910
11:17:51,040 --> 11:17:52,400
O melhor conselho

16911
11:17:52,400 --> 11:17:53,680
É para

16912
11:17:53,680 --> 11:17:56,080
Certifique-se de colocar um pouco de ptr em um

16913
11:17:56,080 --> 11:17:58,960
ponteiro se você não sabe o que isso

16914
11:17:58,960 --> 11:18:01,116
O ponteiro é realmente armazenado no OK vamos

16915
11:18:01,116 --> 11:18:03,520
descer e olhar para a solução um

16916
11:18:03,520 --> 11:18:05,360
A solução é inicializar o seu

16917
11:18:05,360 --> 11:18:08,240
pontor para nenhum ponteiro todas as vezes se você

16918
11:18:08,240 --> 11:18:10,160
Não tem um valor que você pode colocar em uso

16919
11:18:10,160 --> 11:18:12,720
null ptr que é o que estamos usando aqui

16920
11:18:12,720 --> 11:18:15,360
implicitamente, mas podemos explicitamente colocar

16921
11:18:15,360 --> 11:18:18,080
Porque é bom e antes

16922
11:18:18,080 --> 11:18:20,640
você usa um ponteiro que você tem que verificar e

16923
11:18:20,640 --> 11:18:23,436
Veja se não contém ponteiro nulo

16924
11:18:23,436 --> 11:18:26,000
É assim que fazemos isso se o ponteiro seis é

16925
11:18:26,000 --> 11:18:28,160
diferente de null ponteiro que estamos indo

16926
11:18:28,160 --> 11:18:30,640
para usá-lo se for igual a nenhum ponteiro

16927
11:18:30,640 --> 11:18:31,916
Não vamos usá-lo e estamos

16928
11:18:31,916 --> 11:18:34,160
Vou jogar no lado seguro e

16929
11:18:34,160 --> 11:18:35,680
Você vai ver que o programa é

16930
11:18:35,680 --> 11:18:38,160
vou acabar bem aqui se tivermos um null

16931
11:18:38,160 --> 11:18:41,360
ptr dentro podemos dizer

16932
11:18:41,360 --> 11:18:42,720
O outro aqui

16933
11:18:42,720 --> 11:18:44,400
E dizer

16934
11:18:44,400 --> 11:18:47,360
Endereço inválido bem e que o usuário

16935
11:18:47,360 --> 11:18:49,756
vai saber que eles estão tentando

16936
11:18:49,756 --> 11:18:52,320
fazer algo realmente ruim, então vamos tentar

16937
11:18:52,320 --> 11:18:54,800
verificar em relação ao p número cinco

16938
11:18:54,800 --> 11:18:57,756
então vamos e armazenar um ponteiro nulo em

16939
11:18:57,756 --> 11:19:00,800
p número seis para realmente experimentar isso e

16940
11:19:00,800 --> 11:19:02,880
mostrar a você que nós vamos conseguir isso

16941
11:19:02,880 --> 11:19:05,200
Avisando se estamos tentando usá-lo

16942
11:19:05,200 --> 11:19:07,756
e nós vamos construir com gcc e

16943
11:19:07,756 --> 11:19:10,240
nós vamos limpar e correr o galo

16944
11:19:10,240 --> 11:19:12,320
você vai ver esse endereço inválido

16945
11:19:12,320 --> 11:19:14,640
E o programa vai acabar bem

16946
11:19:14,640 --> 11:19:17,680
e se tentarmos colocar esta declaração

16947
11:19:17,680 --> 11:19:19,680
Em algum lugar onde não estamos tremendo

16948
11:19:19,680 --> 11:19:21,520
contra

16949
11:19:21,520 --> 11:19:23,916
sem ponteiro, vamos ter um acidente

16950
11:19:23,916 --> 11:19:26,080
então vamos comentar isso para que seja

16951
11:19:26,080 --> 11:19:29,116
claro o que é que estamos correndo aqui

16952
11:19:29,116 --> 11:19:30,640
Então, se nós executarmos isso, vamos ter um

16953
11:19:30,640 --> 11:19:32,720
crash nós vimos isso, mas vamos mostrar

16954
11:19:32,720 --> 11:19:34,240
Isso de novo

16955
11:19:34,240 --> 11:19:37,200
e realmente destacar que estamos resolvendo

16956
11:19:37,200 --> 11:19:39,596
o problema aqui se executarmos o galo

16957
11:19:39,596 --> 11:19:41,520
O programa vai cair porque nós estamos

16958
11:19:41,520 --> 11:19:43,160
Tentando usar

16959
11:19:43,160 --> 11:19:44,800
unnincializado

16960
11:19:44,800 --> 11:19:48,000
memória, mas se tentarmos verificar

16961
11:19:48,000 --> 11:19:50,880
Não há ptr como estamos fazendo aqui vamos fazer

16962
11:19:50,880 --> 11:19:52,800
que vamos jogar no

16963
11:19:52,800 --> 11:19:54,800
lado seguro porque vai nos dizer

16964
11:19:54,800 --> 11:19:56,960
Endereço inválido e não vamos

16965
11:19:56,960 --> 11:19:59,360
obter uma paixão e o programa vai

16966
11:19:59,360 --> 11:20:01,200
acabar bem isso é muito legal, então vamos

16967
11:20:01,200 --> 11:20:02,720
Tente fazer isso novamente, vamos

16968
11:20:02,720 --> 11:20:05,116
o mundo

16969
11:20:05,436 --> 11:20:07,200
O mundo vai ser bom nós podemos

16970
11:20:07,200 --> 11:20:10,000
galo claro e executado e o programa é

16971
11:20:10,000 --> 11:20:13,520
indo para terminar bem bem, então se nós temos um

16972
11:20:13,520 --> 11:20:15,840
valor dentro, vamos conseguir isso, então

16973
11:20:15,840 --> 11:20:18,320
vamos colocar isso n e dizer nova formista e colocar

16974
11:20:18,320 --> 11:20:21,116
em um 87, por exemplo, ele realmente não

16975
11:20:21,116 --> 11:20:23,040
importa o que colocamos

16976
11:20:23,040 --> 11:20:24,800
Então vamos construir novamente o trabalho

16977
11:20:24,800 --> 11:20:26,880
Vai ser bom e nós podemos correr

16978
11:20:26,880 --> 11:20:29,200
Galo e você vê que estamos recebendo

16979
11:20:29,200 --> 11:20:31,916
um valor aqui se não estivermos armazenando não

16980
11:20:31,916 --> 11:20:34,640


16981
11:20:34,640 --> 11:20:37,360
mesmo verificações contra o p número cinco, mas i

16982
11:20:37,360 --> 11:20:40,240
Acho que isso é realmente suficiente, então isso é

16983
11:20:40,240 --> 11:20:43,840
Uma maneira você pode evitar ponteiros pendurados

16984
11:20:43,840 --> 11:20:45,596
A próxima coisa que vamos olhar é

16985
11:20:45,596 --> 11:20:48,240
se estivermos usando um ponteiro excluído e

16986
11:20:48,240 --> 11:20:50,480
novamente a solução é definir um ponteiro

16987
11:20:50,480 --> 11:20:52,880
para nenhum ptr

16988
11:20:52,880 --> 11:20:55,596
depois de excluí-lo aqui temos p número

16989
11:20:55,596 --> 11:20:59,040
sete tem 82 dentro, estamos usando

16990
11:20:59,040 --> 11:21:01,116
aqui e imprimindo coisas que estamos indo

16991
11:21:01,116 --> 11:21:03,360
para excluí-lo depois que terminarmos de usá-lo

16992
11:21:03,360 --> 11:21:05,276
E depois disso

16993
11:21:05,276 --> 11:21:07,840
A primeira coisa que fazemos é redefini-lo para

16994
11:21:07,840 --> 11:21:11,116
não há ptr quando fazemos essas outras pessoas ou

16995
11:21:11,116 --> 11:21:13,360
Mesmo nós temos a chance de verificá-lo

16996
11:21:13,360 --> 11:21:15,916
contra nenhuma ptr e nós vamos saber

16997
11:21:15,916 --> 11:21:18,320
que não contém nada

16998
11:21:18,320 --> 11:21:19,360
úteis

16999
11:21:19,360 --> 11:21:21,680
para o nosso programa e se fizermos algo

17000
11:21:21,680 --> 11:21:23,116
Como este

17001
11:21:23,116 --> 11:21:25,116
nós não vamos nos deparar com tudo isso

17002
11:21:25,116 --> 11:21:27,276
Problemas estranhos

17003
11:21:27,276 --> 11:21:28,880
e nosso programa vai ter

17004
11:21:28,880 --> 11:21:30,800
Comportamento consistente

17005
11:21:30,800 --> 11:21:32,960
através de diferentes corridas e isso é realmente

17006
11:21:32,960 --> 11:21:34,640
É legal, então vamos correr isso, estamos

17007
11:21:34,640 --> 11:21:36,880
Vou fazer com que as coisas sejam impressas e a

17008
11:21:36,880 --> 11:21:39,756
O programa vai acabar bem porque

17009
11:21:39,756 --> 11:21:43,680
Agora estamos verificando contra nenhum ptr

17010
11:21:43,680 --> 11:21:45,916
Podemos até ser explícitos em mostrar o

17011
11:21:45,916 --> 11:21:48,720
Advertindo aqui podemos dizer memória inválida

17012
11:21:48,720 --> 11:21:51,756
acesso e se você executar este programa

17013
11:21:51,756 --> 11:21:53,276
Você vai realmente saber isso, então

17014
11:21:53,276 --> 11:21:55,276
Vamos terminar isso e nós vamos

17015
11:21:55,276 --> 11:21:57,840
parafuso e o volume vai ser bom se

17016
11:21:57,840 --> 11:21:59,840
nós executamos isso e corremos o galo nós vamos

17017
11:21:59,840 --> 11:22:02,000
para saber que estamos fazendo qualquer

17018
11:22:02,000 --> 11:22:04,800
acesso à memória depois de apagarmos o

17019
11:22:04,800 --> 11:22:06,480
ponteiro e isso vai te salvar

17020
11:22:06,480 --> 11:22:09,276
de possíveis acidentes que você pode

17021
11:22:09,276 --> 11:22:11,916
experiência se você não fizer isso, então isso

17022
11:22:11,916 --> 11:22:14,400
É uma segunda solução que você pode querer

17023
11:22:14,400 --> 11:22:16,400
implementar em seus programas

17024
11:22:16,400 --> 11:22:18,400
e eu vou comentar e mostrar

17025
11:22:18,400 --> 11:22:20,800
Como você pode ficar longe do

17026
11:22:20,800 --> 11:22:23,436
Problema de quando você tem

17027
11:22:23,436 --> 11:22:25,680
Vários ponteiros apontando para o mesmo

17028
11:22:25,680 --> 11:22:27,840
endereço, vamos descer e colocar

17029
11:22:27,840 --> 11:22:29,916
no código é o que você viu em

17030
11:22:29,916 --> 11:22:32,560
os slides e não é realmente nada novo

17031
11:22:32,560 --> 11:22:34,960
Temos o ponteiro oito e o ponteiro

17032
11:22:34,960 --> 11:22:37,276
Nove aqui e p número oito aqui é

17033
11:22:37,276 --> 11:22:38,720
apontando para

17034
11:22:38,720 --> 11:22:40,560
memória dinâmica

17035
11:22:40,560 --> 11:22:43,840
e o valor dentro é 382

17036
11:22:43,840 --> 11:22:45,840
p número nove é inicializado com

17037
11:22:45,840 --> 11:22:48,080
o que tivermos em p número oito, então

17038
11:22:48,080 --> 11:22:49,360
eles vão apontar para o

17039
11:22:49,360 --> 11:22:52,640
Os mesmos endereços aqui, mas nós fizemos p

17040
11:22:52,640 --> 11:22:55,116
número oito o ponteiro mestre, então é

17041
11:22:55,116 --> 11:22:57,040
O único ponteiro que vai ser

17042
11:22:57,040 --> 11:22:59,680
capaz de excluir esta localização de memória mesmo

17043
11:22:59,680 --> 11:23:01,520
se temos vários ponteiros apontando para

17044
11:23:01,520 --> 11:23:02,640
que

17045
11:23:02,640 --> 11:23:04,640
Tudo bem, então toda vez que queremos usar isso

17046
11:23:04,640 --> 11:23:07,360
Memória temos a opção de verificar

17047
11:23:07,360 --> 11:23:09,596
contra o ponteiro mestre e veja isso

17048
11:23:09,596 --> 11:23:12,640
temos alguns dados válidos dentro se for

17049
11:23:12,640 --> 11:23:14,720
Não há ponteiro, não vamos usar isso

17050
11:23:14,720 --> 11:23:16,640
E nós vamos estar jogando no

17051
11:23:16,640 --> 11:23:18,720
O lado seguro é realmente o que somos

17052
11:23:18,720 --> 11:23:20,560
Fazendo aqui se corrermos isso, vamos

17053
11:23:20,560 --> 11:23:22,240
Veja que o programa vai acabar

17054
11:23:22,240 --> 11:23:23,360
Bem

17055
11:23:23,360 --> 11:23:25,276
O mundo vai ser bom e se nós

17056
11:23:25,276 --> 11:23:26,720
corre o galo nós vamos ver que nós

17057
11:23:26,720 --> 11:23:28,480
obter as coisas impressas, vamos embora

17058
11:23:28,480 --> 11:23:29,916
através de p número oito nós vamos

17059
11:23:29,916 --> 11:23:31,680
imprimir coisas que nós vamos passar por p

17060
11:23:31,680 --> 11:23:33,596
Número nove nós vamos imprimir coisas

17061
11:23:33,596 --> 11:23:36,400
e se tentarmos usar o ponteiro

17062
11:23:36,400 --> 11:23:38,320
Depois do

17063
11:23:38,320 --> 11:23:40,480
A memória foi excluída, vamos

17064
11:23:40,480 --> 11:23:42,880
obter um aviso claro que estamos tentando

17065
11:23:42,880 --> 11:23:45,116
para fazer algo realmente ruim e isso é

17066
11:23:45,116 --> 11:23:48,160
realmente o que você deve apontar em seu c

17067
11:23:48,160 --> 11:23:50,880
além de programas que usam dinâmica

17068
11:23:50,880 --> 11:23:53,436
alocação de memória e ponteiros

17069
11:23:53,436 --> 11:23:55,040
Isso é realmente tudo o que nos prossamos fazer em

17070
11:23:55,040 --> 11:23:56,960
Nesta palestra espero que você saiba como você pode

17071
11:23:56,960 --> 11:23:58,880
evitar estes problemas com pendurar

17072
11:23:58,880 --> 11:24:00,960
ponteiros, vamos parar por aqui

17073
11:24:00,960 --> 11:24:02,720
Esta palestra é a próxima palestra que somos

17074
11:24:02,720 --> 11:24:05,040
Vou ver o que pode acontecer

17075
11:24:05,040 --> 11:24:07,360
Se este novo operador

17076
11:24:07,360 --> 11:24:09,436
Não lhe dá a memória que você

17077
11:24:09,436 --> 11:24:11,596
Quero alocar no monte e isso é

17078
11:24:11,596 --> 11:24:14,240
Possível ir em frente e terminar aqui

17079
11:24:14,240 --> 11:24:16,400
e encontrar-me lá nesta palestra nós somos

17080
11:24:16,400 --> 11:24:20,000
Vou explorar o que acontece quando novo

17081
11:24:20,000 --> 11:24:22,400
falha na última palestra que vimos que

17082
11:24:22,400 --> 11:24:25,040
poderia usar o novo operador para alocar

17083
11:24:25,040 --> 11:24:28,000
para nova memória no heap e usar isso

17084
11:24:28,000 --> 11:24:30,880
para fazer as coisas e na maioria dos casos o novo

17085
11:24:30,880 --> 11:24:33,276
O operador vai ter sucesso, mas em alguns

17086
11:24:33,276 --> 11:24:36,400
casos raros vão falhar e quando

17087
11:24:36,400 --> 11:24:38,400
Você não faz nada sobre esse fracasso

17088
11:24:38,400 --> 11:24:40,640
Seu programa vai simplesmente bater e

17089
11:24:40,640 --> 11:24:42,800
Você pode querer fazer algo sobre

17090
11:24:42,800 --> 11:24:45,756
Eu tenho que dizer que é muito raro

17091
11:24:45,756 --> 11:24:48,080
para novo para falhar na prática, então você é

17092
11:24:48,080 --> 11:24:50,880
Vou ver um monte de código lá fora

17093
11:24:50,880 --> 11:24:53,360
que apenas usa o novo operador

17094
11:24:53,360 --> 11:24:55,756
Realmente não se importa

17095
11:24:55,756 --> 11:24:58,480
Verificando se a operação realmente

17096
11:24:58,480 --> 11:25:01,200
falhou ou teve sucesso, então este é um

17097
11:25:01,200 --> 11:25:03,520
Caso raro, mas se você precisar lidar com isso

17098
11:25:03,520 --> 11:25:05,200
nós vamos ver como você pode fazer isso

17099
11:25:05,200 --> 11:25:08,000
Nesta palestra aqui é um exemplo simples

17100
11:25:08,000 --> 11:25:10,880
que vai tentar forçar o novo

17101
11:25:10,880 --> 11:25:12,560
Operador para falhar

17102
11:25:12,560 --> 11:25:14,640
No primeiro segmento aqui estamos usando

17103
11:25:14,640 --> 11:25:17,360
O novo operador, mas estamos usando um

17104
11:25:17,360 --> 11:25:20,640
sintaxe que vai tentar alocar

17105
11:25:20,640 --> 11:25:23,756
um monte de inteiros em uma só vez você vê que

17106
11:25:23,756 --> 11:25:25,756
é uma matriz, mas nós realmente não

17107
11:25:25,756 --> 11:25:27,680
Viu como podemos usar um array como este

17108
11:25:27,680 --> 11:25:30,640
Pense neste código como um pedaço de

17109
11:25:30,640 --> 11:25:33,200
Código que vai alocar um monte de

17110
11:25:33,200 --> 11:25:35,596
inteiros em uma só tentativa e nós vamos

17111
11:25:35,596 --> 11:25:38,240
Tente fazer isso falhar

17112
11:25:38,240 --> 11:25:40,400
Eu tenho que dizer que isso pode lhe dar um

17113
11:25:40,400 --> 11:25:42,720
Erro em alguns compiladores dizendo que você

17114
11:25:42,720 --> 11:25:45,040
estão excedendo o tamanho da matriz se isso é

17115
11:25:45,040 --> 11:25:46,800
O caso não há problema que vamos encontrar

17116
11:25:46,800 --> 11:25:49,040
Outra maneira de obter este novo operador para

17117
11:25:49,040 --> 11:25:51,116
falharemos, vamos colocar uma coisa como

17118
11:25:51,116 --> 11:25:52,960
isso em um loop e nós vamos fazer um loop

17119
11:25:52,960 --> 11:25:56,240
Muitas vezes suficiente para esgotar o monte

17120
11:25:56,240 --> 11:25:59,116
que é atribuído ao nosso programa aqui

17121
11:25:59,116 --> 11:26:00,480
E quando isso acontece você vai

17122
11:26:00,480 --> 11:26:02,400
Veja que o programa vai cair

17123
11:26:02,400 --> 11:26:05,840
e é ruim tão novo pode falhar e se você

17124
11:26:05,840 --> 11:26:08,720
Você precisa jogar no lado do servidor

17125
11:26:08,720 --> 11:26:09,680
Indo para dentro de nós.

17126
11:26:09,680 --> 11:26:12,480
lidar com esse problema e temos duas maneiras

17127
11:26:12,480 --> 11:26:15,040
nós podemos lidar com este problema que podemos ir

17128
11:26:15,040 --> 11:26:17,596
através do mecanismo de exceção este é

17129
11:26:17,596 --> 11:26:20,720
uma maneira integrada que temos em c plus plus

17130
11:26:20,720 --> 11:26:23,116
verificar se há setas e lidar com eles podemos

17131
11:26:23,116 --> 11:26:26,480
também usar a configuração de std no lançamento

17132
11:26:26,480 --> 11:26:29,520
em nosso novo operador e forçá-lo a

17133
11:26:29,520 --> 11:26:31,680
jogar uma exceção e ele vai para

17134
11:26:31,680 --> 11:26:33,916
não nos dê nenhum ponteiro se alocação

17135
11:26:33,916 --> 11:26:36,320
Falha eu sei que isso pode soar enigmático

17136
11:26:36,320 --> 11:26:37,916
Agora, mas nós vamos ver um

17137
11:26:37,916 --> 11:26:39,680
Um exemplo em breve e você vai

17138
11:26:39,680 --> 11:26:41,916
Entendo isso, vamos ver como podemos

17139
11:26:41,916 --> 11:26:43,756
Use o mecanismo de exceção

17140
11:26:43,756 --> 11:26:46,400
O mecanismo de exceção está lá em c plus

17141
11:26:46,400 --> 11:26:49,040
além de deixar você lidar com problemas quando

17142
11:26:49,040 --> 11:26:51,840
Eles surgem e a maneira como você usa

17143
11:26:51,840 --> 11:26:54,480
código de embalagem que está potencialmente indo para

17144
11:26:54,480 --> 11:26:56,160
dar-lhe problemas

17145
11:26:56,160 --> 11:26:59,276
e tente pegar blocos que você vê aqui

17146
11:26:59,276 --> 11:27:01,916
Dentro do loop estamos dizendo tentar

17147
11:27:01,916 --> 11:27:04,400
e dentro dos tri blocos temos o

17148
11:27:04,400 --> 11:27:06,800
Código que poderia falhar temos o nosso novo

17149
11:27:06,800 --> 11:27:07,916
o operador

17150
11:27:07,916 --> 11:27:10,880
e no bloco de captura você vê que temos um

17151
11:27:10,880 --> 11:27:13,360
bloco de captura aqui nós vamos

17152
11:27:13,360 --> 11:27:15,916
Diga que temos um problema

17153
11:27:15,916 --> 11:27:17,520
e nós temos uma maneira de pegar o

17154
11:27:17,520 --> 11:27:19,520
problema e se você olhar para essa coisa nós

17155
11:27:19,520 --> 11:27:22,880
ter neste parêntese após a captura

17156
11:27:22,880 --> 11:27:26,800
ter uma variável ex e podemos perguntar

17157
11:27:26,800 --> 11:27:29,276
Que tipo de problema aconteceu

17158
11:27:29,276 --> 11:27:31,520
levando a esta exceção acontecendo em

17159
11:27:31,520 --> 11:27:33,596
nosso código você pode pensar assim

17160
11:27:33,596 --> 11:27:35,840
Eu percebo que nós realmente não falamos

17161
11:27:35,840 --> 11:27:38,160
Exceções sobre as quais vamos falar

17162
11:27:38,160 --> 11:27:39,916
mais tarde no curso, quando temos

17163
11:27:39,916 --> 11:27:41,680
ferramentas suficientes para realmente entender o que

17164
11:27:41,680 --> 11:27:43,756
Está acontecendo, mas agora

17165
11:27:43,756 --> 11:27:46,720
Pense neles como uma ferramenta para lidar

17166
11:27:46,720 --> 11:27:49,276
quando o novo operador falha e você está

17167
11:27:49,276 --> 11:27:51,200
Não vai falhar o seu programa

17168
11:27:51,200 --> 11:27:53,360
O programa continuará sendo executado

17169
11:27:53,360 --> 11:27:55,840
através do fim, mas a nova operação

17170
11:27:55,840 --> 11:27:58,400
que você queria fazer aqui vai falhar e

17171
11:27:58,400 --> 11:28:00,160
você será capaz de pegar aquilo e isso

17172
11:28:00,160 --> 11:28:02,240
É uma coisa boa se você não quer usar

17173
11:28:02,240 --> 11:28:04,800
exceções que você pode usar o std no lançamento

17174
11:28:04,800 --> 11:28:06,160
opção

17175
11:28:06,160 --> 11:28:08,240
e esta é uma nova versão do novo

17176
11:28:08,240 --> 11:28:11,436
Operador que você pode usar para dizer o c plus

17177
11:28:11,436 --> 11:28:13,840
além do sistema para não lançar uma exceção

17178
11:28:13,840 --> 11:28:16,160
Quando a operação falha é apenas

17179
11:28:16,160 --> 11:28:18,080
indo para retornar nenhum ponteiro e você pode

17180
11:28:18,080 --> 11:28:19,756
Verifique se há isso e conheça essa memória

17181
11:28:19,756 --> 11:28:22,560
A alocação realmente falhou é isso que

17182
11:28:22,560 --> 11:28:23,840
nós vamos falar sobre isso

17183
11:28:23,840 --> 11:28:25,680
palestra espero que você tenha uma ideia sobre

17184
11:28:25,680 --> 11:28:27,520
Isso nós vamos ir para o visual

17185
11:28:27,520 --> 11:28:29,916
código de estúdio e realmente tentar isso em

17186
11:28:29,916 --> 11:28:32,960
ação ok aqui estamos em nosso trabalho

17187
11:28:32,960 --> 11:28:35,200
diretório do projeto atual é quando

17188
11:28:35,200 --> 11:28:36,400
As novas falham

17189
11:28:36,400 --> 11:28:38,880
vamos pegar nossos arquivos de modelo

17190
11:28:38,880 --> 11:28:41,436
Como sempre fazemos e vamos colocar

17191
11:28:41,436 --> 11:28:44,560
eles no lugar, então quando o novo falhar isso é

17192
11:28:44,560 --> 11:28:46,720
A palestra para que vamos fazer isso

17193
11:28:46,720 --> 11:28:49,200
e abra isso em código de estúdio visual

17194
11:28:49,200 --> 11:28:51,436
muito rápido e vamos tentar e

17195
11:28:51,436 --> 11:28:54,240
alocar um grande pedaço de memória em um

17196
11:28:54,240 --> 11:28:56,320
Vamos do jeito que você faz que podemos dizer

17197
11:28:56,320 --> 11:28:57,596
final ponteiro

17198
11:28:57,596 --> 11:28:59,520
Vamos chamar a esses dados de que realmente não

17199
11:28:59,520 --> 11:29:02,480
importa e vamos dizer novo e

17200
11:29:02,480 --> 11:29:04,240
e nós vamos dizer que nós queremos um

17201
11:29:04,240 --> 11:29:05,916
Grande quantidade de eventos

17202
11:29:05,916 --> 11:29:08,480
Vamos tentar fazer isso e nós vamos

17203
11:29:08,480 --> 11:29:11,116
descer e dizer programa

17204
11:29:11,116 --> 11:29:13,200
Terminar bem para ter certeza

17205
11:29:13,200 --> 11:29:16,960
Sabemos quando estamos terminando este programa

17206
11:29:16,960 --> 11:29:19,520
corretamente, vamos tentar compilar isso

17207
11:29:19,520 --> 11:29:21,756
Nós vamos trazer o terminal e

17208
11:29:21,756 --> 11:29:24,800
Nós vamos soldar com gcc como nós

17209
11:29:24,800 --> 11:29:26,800
Sempre faça e a construção será

17210
11:29:26,800 --> 11:29:29,040
Bom, vamos tentar aumentar esse número

17211
11:29:29,040 --> 11:29:31,680
e empurre-o para um número realmente grande e

17212
11:29:31,680 --> 11:29:33,116
Você vê que nós

17213
11:29:33,116 --> 11:29:36,320
ter feito o código do estúdio visual louco aqui

17214
11:29:36,320 --> 11:29:38,720
A matriz é muito grande, então eles não podem realmente

17215
11:29:38,720 --> 11:29:39,840
Permita-nos

17216
11:29:39,840 --> 11:29:40,800
para fazer

17217
11:29:40,800 --> 11:29:43,200
uma grande matriz aqui bem, então

17218
11:29:43,200 --> 11:29:45,520
Vamos trazer isso um pouco para baixo

17219
11:29:45,520 --> 11:29:47,520
e se estamos tentando compilar o

17220
11:29:47,520 --> 11:29:49,596
A bala vai ser boa e se corrermos

17221
11:29:49,596 --> 11:29:53,116
Galo você vê que o programa

17222
11:29:53,116 --> 11:29:56,800
não vai acabar bem bem, então isso é

17223
11:29:56,800 --> 11:29:59,116
Realmente um caso em que novas falhas não podemos

17224
11:29:59,116 --> 11:30:01,520
Realmente aloca tanto isso

17225
11:30:01,520 --> 11:30:04,160
no armazenamento de pilhas que é alocado para

17226
11:30:04,160 --> 11:30:06,720
Este programa aqui lembra quando nós

17227
11:30:06,720 --> 11:30:09,596
Revisitado a ideia do mapa de memória que vimos

17228
11:30:09,596 --> 11:30:11,436
que cada programa vai ter

17229
11:30:11,436 --> 11:30:13,596
seu mapa de memória que o mapa de memória está indo

17230
11:30:13,596 --> 11:30:15,436
para ter um monte de seções dentro de nós temos

17231
11:30:15,436 --> 11:30:17,756
a pilha que temos o monte nosso quadril é

17232
11:30:17,756 --> 11:30:20,240
Não é infinito para que possamos fugir e nós

17233
11:30:20,240 --> 11:30:22,240
acabou de acabar com essa alocação que

17234
11:30:22,240 --> 11:30:25,040
nós fizemos aqui e nosso programa está indo para

17235
11:30:25,040 --> 11:30:26,960
Termina imediatamente você vê que é

17236
11:30:26,960 --> 11:30:28,480
Não terminando bem

17237
11:30:28,480 --> 11:30:30,400
Se isso não está funcionando para o que

17238
11:30:30,400 --> 11:30:33,436
Compilador que você está usando podemos ir e fazer

17239
11:30:33,436 --> 11:30:35,680
através de um loop para que possamos fazer

17240
11:30:35,680 --> 11:30:36,400
pode

17241
11:30:36,400 --> 11:30:38,640
comente isso e podemos realmente fazer loop

17242
11:30:38,640 --> 11:30:40,960
Muitas vezes o suficiente para esgotar o

17243
11:30:40,960 --> 11:30:44,240
memória que é alocada para isso

17244
11:30:44,240 --> 11:30:46,960
Processo aqui galo.exe

17245
11:30:46,960 --> 11:30:49,040
no mapa de memória na seção do quadril

17246
11:30:49,040 --> 11:30:52,320
Isso é o que eu quero dizer e se fizermos isso em

17247
11:30:52,320 --> 11:30:54,640
em alguns pontos, o programa vai falhar

17248
11:30:54,640 --> 11:30:56,400
E nós vamos ter o mesmo problema

17249
11:30:56,400 --> 11:30:58,720
Então vamos construir de novo

17250
11:30:58,720 --> 11:31:01,756
Vamos construir com gcc

17251
11:31:01,756 --> 11:31:04,000
e nós vamos limpar e correr

17252
11:31:04,000 --> 11:31:05,520
Galo e nós vamos ver que é

17253
11:31:05,520 --> 11:31:07,116
indo para loop loop loop e está indo

17254
11:31:07,116 --> 11:31:09,276
para falhar, vamos ver

17255
11:31:09,276 --> 11:31:11,276
o fracasso em um minuto e precisamos

17256
11:31:11,276 --> 11:31:13,680
encontrar uma maneira de resolver este problema que temos

17257
11:31:13,680 --> 11:31:15,840
Veja que temos duas opções, vamos

17258
11:31:15,840 --> 11:31:17,360
Comente isso para fora

17259
11:31:17,360 --> 11:31:19,840
e uh olhar para essas soluções aqui o

17260
11:31:19,840 --> 11:31:21,756
A primeira opção é passar pelo

17261
11:31:21,756 --> 11:31:24,160
mecanismo de exceção que também podemos usar o

17262
11:31:24,160 --> 11:31:27,040
std no lance opção que vamos tentar

17263
11:31:27,040 --> 11:31:29,756
O mecanismo de exceção primeiro e uh

17264
11:31:29,756 --> 11:31:31,360
O que fazemos

17265
11:31:31,360 --> 11:31:34,880
está embrulhe o código possivelmente ofensivo na tentativa

17266
11:31:34,880 --> 11:31:38,080
e pegar blocos e nós vamos dizer

17267
11:31:38,080 --> 11:31:40,480
Tente aqui e coloque um bloco e nós vamos

17268
11:31:40,480 --> 11:31:41,520
para dizer

17269
11:31:41,520 --> 11:31:44,160
pegar e nós vamos dizer std

17270
11:31:44,160 --> 11:31:46,560
exceção e nós vamos colocar um

17271
11:31:46,560 --> 11:31:49,276
ampersand símbolo aqui basta usar isso como

17272
11:31:49,276 --> 11:31:51,200
Isso e nós vamos ter a chance de

17273
11:31:51,200 --> 11:31:53,596
realmente explicar essas coisas quando temos

17274
11:31:53,596 --> 11:31:56,000
ferramentas suficientes para entender isso por enquanto

17275
11:31:56,000 --> 11:31:58,800
Pense nisso como se eu tivesse um código que é

17276
11:31:58,800 --> 11:32:01,040
potencialmente indo para falhar

17277
11:32:01,040 --> 11:32:03,200
Como o novo operador aqui eu vou

17278
11:32:03,200 --> 11:32:05,520
Coloque isso no bloco de tentativa

17279
11:32:05,520 --> 11:32:08,000
E se algo der errado, vamos

17280
11:32:08,000 --> 11:32:10,800
para obter o erro no bloco de captura este

17281
11:32:10,800 --> 11:32:12,960
É a maneira como fazemos essas coisas aqui, então

17282
11:32:12,960 --> 11:32:16,000
Por exemplo, eu posso tomar meu loop aqui

17283
11:32:16,000 --> 11:32:17,520
e copiá-lo

17284
11:32:17,520 --> 11:32:20,640
e colocar isso lá embaixo aqui

17285
11:32:20,640 --> 11:32:21,520
Está tudo bem

17286
11:32:21,520 --> 11:32:24,400
e eu sei que esta linha de código poderia

17287
11:32:24,400 --> 11:32:26,160
falhar bem

17288
11:32:26,160 --> 11:32:28,960
então eu vou embrulhar isso dentro da tentativa

17289
11:32:28,960 --> 11:32:31,116
e pegar blocos para que eu vou pegar

17290
11:32:31,116 --> 11:32:32,160
que

17291
11:32:32,160 --> 11:32:35,116
e colocar isso no meu loop

17292
11:32:35,116 --> 11:32:37,520
Vamos fazer isso e alinhar isso um pouco

17293
11:32:37,520 --> 11:32:38,640
Um pouco

17294
11:32:38,640 --> 11:32:41,596
e nós vamos levar o potencialmente

17295
11:32:41,596 --> 11:32:43,436
Código ofensivo

17296
11:32:43,436 --> 11:32:45,596
E colocar isso

17297
11:32:45,596 --> 11:32:48,880
no bloco de tentativa e quando o operador

17298
11:32:48,880 --> 11:32:50,240
Aqui falha

17299
11:32:50,240 --> 11:32:51,840
Algo dá errado e nós vamos

17300
11:32:51,840 --> 11:32:53,756
pegar o problema no bloco de captura

17301
11:32:53,756 --> 11:32:56,400
Isto é o que queremos dizer aqui novamente não

17302
11:32:56,400 --> 11:32:58,720
ter ferramentas suficientes para entender por que nós

17303
11:32:58,720 --> 11:33:00,320
estão fazendo essa coisa aqui o que é

17304
11:33:00,320 --> 11:33:02,640
Significado deste ampersand símbolo que somos

17305
11:33:02,640 --> 11:33:04,240
Vou aprender sobre isso mais tarde no

17306
11:33:04,240 --> 11:33:06,480
Claro, mas por enquanto queremos colocar

17307
11:33:06,480 --> 11:33:09,520
juntos algo bom o suficiente para isso

17308
11:33:09,520 --> 11:33:13,200
programa para não bater como estava fazendo

17309
11:33:13,200 --> 11:33:14,800
Aqui bem, vamos pegar o

17310
11:33:14,800 --> 11:33:17,840
seta e dizer que algo deu errado

17311
11:33:17,840 --> 11:33:19,360
e nós vamos imprimir o que

17312
11:33:19,360 --> 11:33:21,200
Na verdade, errei, vamos dizer

17313
11:33:21,200 --> 11:33:23,520
Ex e nós podemos ligar

17314
11:33:23,520 --> 11:33:26,400
uma função chamada assim

17315
11:33:26,400 --> 11:33:28,840
E nós podemos dizer sdd

17316
11:33:28,840 --> 11:33:30,640
endl

17317
11:33:30,640 --> 11:33:33,360
Vamos esconder esta caneta aqui porque nós queremos

17318
11:33:33,360 --> 11:33:36,080
para ver claramente o que está acontecendo aqui

17319
11:33:36,080 --> 11:33:38,720
É assim que você pode impedir o seu programa

17320
11:33:38,720 --> 11:33:40,800
de bater e vai acabar

17321
11:33:40,800 --> 11:33:42,840
Bem porque agora nós lidamos com o

17322
11:33:42,840 --> 11:33:45,916
problema e que não causamos a

17323
11:33:45,916 --> 11:33:46,960
Que acidente

17324
11:33:46,960 --> 11:33:49,360
Como estávamos fazendo aqui em baixo agora estamos

17325
11:33:49,360 --> 11:33:51,436
Vou tentar construir este código, vamos

17326
11:33:51,436 --> 11:33:53,520
trazê-lo um pouco para que seja

17327
11:33:53,520 --> 11:33:55,596
Não estourando aqui

17328
11:33:55,596 --> 11:33:57,756
e nós vamos soldar com gcc

17329
11:33:57,756 --> 11:33:59,756
O parafuso vai ser bom e nós vamos

17330
11:33:59,756 --> 11:34:02,560
para limpar e correr galo e está indo

17331
11:34:02,560 --> 11:34:04,160
Para fazer a sua coisa, ele vai manter

17332
11:34:04,160 --> 11:34:06,320
looping em torno de

17333
11:34:06,320 --> 11:34:08,160
E vai dizer que algo correu mal

17334
11:34:08,160 --> 11:34:09,520
Vai atingir um ponto em que tudo

17335
11:34:09,520 --> 11:34:11,756
Essas alocações vão falhar e

17336
11:34:11,756 --> 11:34:13,756
Se nós realmente esperarmos por isso vai

17337
11:34:13,756 --> 11:34:15,596
Fim e vamos ver que é

17338
11:34:15,596 --> 11:34:16,960
Vou acabar bem

17339
11:34:16,960 --> 11:34:19,680
Vamos tentar bater ctrl c e terminar

17340
11:34:19,680 --> 11:34:21,200
Porque não queremos esperar

17341
11:34:21,200 --> 11:34:22,800
Esta quantidade de tempo

17342
11:34:22,800 --> 11:34:24,480
E vamos trazer isso

17343
11:34:24,480 --> 11:34:27,040
até 100 e aumente esse número

17344
11:34:27,040 --> 11:34:27,916
Aqui

17345
11:34:27,916 --> 11:34:30,480
Vamos ver se isso realmente funciona assim

17346
11:34:30,480 --> 11:34:32,400
Vamos ferver por agora só queremos

17347
11:34:32,400 --> 11:34:34,320
ver que o programa não é realmente

17348
11:34:34,320 --> 11:34:35,680
esmagamento

17349
11:34:35,680 --> 11:34:38,000
então nós vamos correr o galo e você

17350
11:34:38,000 --> 11:34:38,960
Veja que

17351
11:34:38,960 --> 11:34:41,200
vai continuar correndo e em alguns

17352
11:34:41,200 --> 11:34:42,320
Ponto do ponto

17353
11:34:42,320 --> 11:34:44,160
não vai alocar a memória

17354
11:34:44,160 --> 11:34:45,756
E vai dizer que algo deu certo

17355
11:34:45,756 --> 11:34:48,000
errado, mas se você continuar indo para baixo você está

17356
11:34:48,000 --> 11:34:50,240
Vai ver que o programa está terminando

17357
11:34:50,240 --> 11:34:51,116
Bem

17358
11:34:51,116 --> 11:34:53,680
Então o que está acontecendo aqui é que

17359
11:34:53,680 --> 11:34:56,160
O novo operador realmente falhou

17360
11:34:56,160 --> 11:34:59,040
Mas nós codificamos o problema e podemos lidar com

17361
11:34:59,040 --> 11:35:02,160
Aqui, então o que é chamado de manuseio

17362
11:35:02,160 --> 11:35:03,360
O problema

17363
11:35:03,360 --> 11:35:04,880
você vai lidar com isso em qualquer coisa

17364
11:35:04,880 --> 11:35:07,200
Faz sentido no seu programa se formos

17365
11:35:07,200 --> 11:35:09,680
Por exemplo, tentar configurar uma cor em

17366
11:35:09,680 --> 11:35:10,640
Alguns

17367
11:35:10,640 --> 11:35:13,116
widgets na sua aplicação e no

17368
11:35:13,116 --> 11:35:15,360
A cor falha e você não consegue configurar o

17369
11:35:15,360 --> 11:35:17,360
cor que você pode mostrar sua interface de usuário

17370
11:35:17,360 --> 11:35:19,680
em preto e branco e continue correndo o seu

17371
11:35:19,680 --> 11:35:21,840
programa em vez de fazê-lo cair

17372
11:35:21,840 --> 11:35:24,080
Esta é apenas uma maneira de te mostrar

17373
11:35:24,080 --> 11:35:26,000
que você pode lidar com coisas

17374
11:35:26,000 --> 11:35:28,800
Quando o novo fracasso é uma maneira que podemos

17375
11:35:28,800 --> 11:35:30,240
resolver o problema para que vamos olhar

17376
11:35:30,240 --> 11:35:31,916
Na segunda maneira

17377
11:35:31,916 --> 11:35:34,640
O mecanismo de exceção é o primeiro

17378
11:35:34,640 --> 11:35:36,240
Vamos comentar isso

17379
11:35:36,240 --> 11:35:38,560
porque nós vamos ver outro caminho

17380
11:35:38,560 --> 11:35:40,960
e vamos fazer isso também podemos usar o

17381
11:35:40,960 --> 11:35:44,640
std no lançamento de configuração em nosso novo operador

17382
11:35:44,640 --> 11:35:46,160
Quando nós somos

17383
11:35:46,160 --> 11:35:48,640
alocando para uma nova memória, então estamos indo

17384
11:35:48,640 --> 11:35:51,276
para fazer isso e nós vamos trazer

17385
11:35:51,276 --> 11:35:52,640
nosso loop aqui

17386
11:35:52,640 --> 11:35:54,640
Vamos reutilizar isso para isso aqui

17387
11:35:54,640 --> 11:35:56,240
nós não vamos usar o

17388
11:35:56,240 --> 11:35:58,160
mecanismo de exceção, então vamos fazer

17389
11:35:58,160 --> 11:36:00,400
Algo como isso se livrar da tentativa

17390
11:36:00,400 --> 11:36:02,720
e pegar bloco, mas nós vamos ainda

17391
11:36:02,720 --> 11:36:04,480
Estar em um loop aqui

17392
11:36:04,480 --> 11:36:07,040
Então o que podemos fazer é passar o novo

17393
11:36:07,040 --> 11:36:10,400
Operar um parâmetro e dizer std no

17394
11:36:10,400 --> 11:36:14,080
jogar e quando fazemos isso se o novo falhar

17395
11:36:14,080 --> 11:36:16,640
não vamos conseguir nenhum ponteiro armazenado

17396
11:36:16,640 --> 11:36:18,640
dados aqui para que possamos verificar isso

17397
11:36:18,640 --> 11:36:20,560
O ponteiro nulo podemos dizer

17398
11:36:20,560 --> 11:36:21,840
f

17399
11:36:21,840 --> 11:36:25,520
Os dados são diferentes do ponteiro nulo

17400
11:36:25,520 --> 11:36:27,840
e nós podemos fazer o que quisermos fazer

17401
11:36:27,840 --> 11:36:29,680
Pode fazer isso e dizer

17402
11:36:29,680 --> 11:36:32,400
O sddc para fora

17403
11:36:32,400 --> 11:36:34,160
obtê-lo alocado e podemos tentar e

17404
11:36:34,160 --> 11:36:35,916
compilar este programa

17405
11:36:35,916 --> 11:36:38,080
Então o que vamos fazer é executar isso

17406
11:36:38,080 --> 11:36:42,160
através do nosso compilador através do gcc

17407
11:36:42,160 --> 11:36:43,520
Você vai ver que o mundo

17408
11:36:43,520 --> 11:36:45,756
Vai ser bom e você vê isso

17409
11:36:45,756 --> 11:36:47,596
Código de estúdio visual estava nos dando um

17410
11:36:47,596 --> 11:36:49,436
linha irritante porque não pode realmente

17411
11:36:49,436 --> 11:36:51,436
Entenda isso, mas isso vai acontecer

17412
11:36:51,436 --> 11:36:53,596
através do compilador e ele vai

17413
11:36:53,596 --> 11:36:56,320
Trabalhar exatamente como esperamos

17414
11:36:56,320 --> 11:36:59,040
então vamos tentar executar este programa

17415
11:36:59,040 --> 11:37:00,720
Vamos ignorar o código do estúdio visual

17416
11:37:00,720 --> 11:37:02,480
por agora porque o mundo era bom

17417
11:37:02,480 --> 11:37:05,436
poderia construir com gcc e vimos que

17418
11:37:05,436 --> 11:37:08,640
esta foi soldagem com sucesso para que possamos

17419
11:37:08,640 --> 11:37:10,080
claro

17420
11:37:10,080 --> 11:37:12,560
Vamos limpar corretamente e executar o galo e

17421
11:37:12,560 --> 11:37:14,720
vai dizer que os dados alocaram alguns

17422
11:37:14,720 --> 11:37:16,560
Outras vezes e o programa vai

17423
11:37:16,560 --> 11:37:18,880
No final, você vê que o programa não é

17424
11:37:18,880 --> 11:37:21,040
batendo porque estamos lidando também

17425
11:37:21,040 --> 11:37:23,360
O problema, mas estamos passando por um

17426
11:37:23,360 --> 11:37:25,520
Novo mecanismo para fazer isso e isso é

17427
11:37:25,520 --> 11:37:28,640
usando a opção std no lançamento com o nosso

17428
11:37:28,640 --> 11:37:31,116
O novo operador aqui é realmente tudo o que nós

17429
11:37:31,116 --> 11:37:32,960
definido para fazer nesta palestra eu espero que

17430
11:37:32,960 --> 11:37:35,840
É muito claro que o novo operador pode

17431
11:37:35,840 --> 11:37:38,560
falhar e você tem algumas opções em

17432
11:37:38,560 --> 11:37:41,116
Suas mãos para lidar com coisas quando novo

17433
11:37:41,116 --> 11:37:43,200
falha que você pode passar pelo

17434
11:37:43,200 --> 11:37:45,200
mecanismo de exceção usando tentar e

17435
11:37:45,200 --> 11:37:47,756
pegar blocos como fizemos aqui ou você pode

17436
11:37:47,756 --> 11:37:51,436
Use a opção std no lance que estamos indo

17437
11:37:51,436 --> 11:37:53,596
para parar aqui nesta palestra e

17438
11:37:53,596 --> 11:37:55,680
A seguir, vamos aprender sobre não

17439
11:37:55,680 --> 11:37:57,840
segurança do ponteiro

17440
11:37:57,840 --> 11:38:00,240
Vá em frente e termine aqui e me encontre

17441
11:38:00,240 --> 11:38:02,320
lá nesta palestra vamos

17442
11:38:02,320 --> 11:38:05,520
Explorar o conceito chamado ponteiro nulo

17443
11:38:05,520 --> 11:38:07,916
Segurança e esta é uma série de medidas

17444
11:38:07,916 --> 11:38:10,400
Você toma para ter certeza de que quando você está

17445
11:38:10,400 --> 11:38:13,200
usando um ponteiro que contém um

17446
11:38:13,200 --> 11:38:15,040
endereço se você não tiver um

17447
11:38:15,040 --> 11:38:17,040
Endereço dentro você não usa isso

17448
11:38:17,040 --> 11:38:19,436
ponteiro e nós fazemos isso através de uma série

17449
11:38:19,436 --> 11:38:21,680
de cheques que podemos fazer contra o nulo

17450
11:38:21,680 --> 11:38:23,360
ponteiro, por exemplo, aqui temos um

17451
11:38:23,360 --> 11:38:25,916
ponteiro que é inicializado para null

17452
11:38:25,916 --> 11:38:26,880
O ponteiro

17453
11:38:26,880 --> 11:38:30,400
implicitamente através de inicializadores apoiados

17454
11:38:30,400 --> 11:38:33,916
e o que podemos fazer é verificar se número p

17455
11:38:33,916 --> 11:38:35,436
Não contém

17456
11:38:35,436 --> 11:38:36,960
Ir ponteiro nulo e é assim que dizemos

17457
11:38:36,960 --> 11:38:39,916
em c plus e se não contém nenhum ponteiro

17458
11:38:39,916 --> 11:38:41,360
nós não vamos usá-lo nós vamos

17459
11:38:41,360 --> 11:38:44,160
Diz que aponta para um endereço inválido deste

17460
11:38:44,160 --> 11:38:46,400
É algo que você pode fazer é simples em

17461
11:38:46,400 --> 11:38:49,200
natureza, mas vai te salvar muito

17462
11:38:49,200 --> 11:38:51,596
de problemas esta é uma versão que podemos fazer

17463
11:38:51,596 --> 11:38:54,240
isso, mas também podemos conectar diretamente

17464
11:38:54,240 --> 11:38:57,276
p número e usá-lo assim se ele

17465
11:38:57,276 --> 11:38:58,960
Não contém nenhum ponteiro que vamos conseguir

17466
11:38:58,960 --> 11:39:00,880
A mensagem impressa de que temos um

17467
11:39:00,880 --> 11:39:04,000
Endereço inválido se tivermos alguma coisa

17468
11:39:04,000 --> 11:39:05,596
Além de nenhum ponteiro, vamos

17469
11:39:05,596 --> 11:39:07,520
ter um endereço válido e nós podemos fazer

17470
11:39:07,520 --> 11:39:09,040
Algo com que isso vai

17471
11:39:09,040 --> 11:39:11,596
trabalho porque um ponteiro também pode ser

17472
11:39:11,596 --> 11:39:14,080
implicitamente convertido em um booleano

17473
11:39:14,080 --> 11:39:17,200
expressão que nossa declaração se espera

17474
11:39:17,200 --> 11:39:19,436
Aqui e vai funcionar exatamente como

17475
11:39:19,436 --> 11:39:21,360
Queremos aqui, então vamos ver isso

17476
11:39:21,360 --> 11:39:23,436
em um minuto quando chegamos ao estúdio visual

17477
11:39:23,436 --> 11:39:25,680
código antes de fazer isso, embora eu queira você

17478
11:39:25,680 --> 11:39:28,960
para estar ciente de que você pode ligar

17479
11:39:28,960 --> 11:39:31,360
excluir em um ponteiro contendo não

17480
11:39:31,360 --> 11:39:33,596
ponteiro sem fazer o cheque aqui

17481
11:39:33,596 --> 11:39:35,520
Vai ficar bem, nós vimos muitos

17482
11:39:35,520 --> 11:39:37,520
regras sobre ponteiros e muitos estudantes

17483
11:39:37,520 --> 11:39:40,000
desenvolverá uma intuição que você tem

17484
11:39:40,000 --> 11:39:42,400
para verificar se não há ponteiro antes de fazer

17485
11:39:42,400 --> 11:39:44,560
qualquer coisa em seu ponteiro e eles até

17486
11:39:44,560 --> 11:39:46,880
fazer isso antes que eles chamem delete eu tenho

17487
11:39:46,880 --> 11:39:48,960
para quebrá-lo para você que é seguro

17488
11:39:48,960 --> 11:39:51,116
call delete em um ponteiro que contenha

17489
11:39:51,116 --> 11:39:53,756
Ir ponteiro nulo para que você não precise fazer

17490
11:39:53,756 --> 11:39:55,680
Algo como temos aqui dizer e

17491
11:39:55,680 --> 11:39:57,756
Verifique se é p número um e depois excluir p

17492
11:39:57,756 --> 11:40:00,000
número um e redefinir isso para o ponteiro baixo

17493
11:40:00,000 --> 11:40:02,160
Isso é realmente um exagero que você pode chamar

17494
11:40:02,160 --> 11:40:04,160
excluir no ponteiro e ele vai

17495
11:40:04,160 --> 11:40:06,720
Esteja bem mesmo se não contiver nenhum ponteiro

17496
11:40:06,720 --> 11:40:08,480
Agora vamos para o estúdio visual

17497
11:40:08,480 --> 11:40:10,880
codifica e ver essas coisas em ação aqui

17498
11:40:10,880 --> 11:40:13,756
Estamos em nosso diretório de trabalho o

17499
11:40:13,756 --> 11:40:16,560
O projeto atual não é uma segurança de ponteiro

17500
11:40:16,560 --> 11:40:18,880
Vamos pegar nosso projeto de modelo

17501
11:40:18,880 --> 11:40:20,560
e nós vamos colocar isso no

17502
11:40:20,560 --> 11:40:23,436
Projeto atual que estamos interessados

17503
11:40:23,436 --> 11:40:24,160
Os de que a si a si a do que sobre a, a , a , a , aja, a , a, a, a

17504
11:40:24,160 --> 11:40:26,320
e nós vamos abrir isso em

17505
11:40:26,320 --> 11:40:28,800
studio code open folder e estamos indo

17506
11:40:28,800 --> 11:40:31,436
para colocar em um verbose no ponteiro check

17507
11:40:31,436 --> 11:40:33,680
O que estamos fazendo aqui não é novidade

17508
11:40:33,680 --> 11:40:35,840
ter um ponteiro chamado p número é um

17509
11:40:35,840 --> 11:40:39,116
ponteiro para form e é inicializado para

17510
11:40:39,116 --> 11:40:41,840
ponteiro nulo através implícito

17511
11:40:41,840 --> 11:40:44,360
inicialização aqui usando braced

17512
11:40:44,360 --> 11:40:47,040
inicialização e estamos verificando para

17513
11:40:47,040 --> 11:40:49,276
ver se ele contém ponteiro nulo se ele

17514
11:40:49,276 --> 11:40:50,080
faz

17515
11:40:50,080 --> 11:40:51,520
nós vamos dizer que ele contém um

17516
11:40:51,520 --> 11:40:53,360
Endereço inválido se não o fizermos

17517
11:40:53,360 --> 11:40:55,596
vai dizer que tem um endereço válido

17518
11:40:55,596 --> 11:40:57,520
e você vê que estamos usando uma negação

17519
11:40:57,520 --> 11:40:59,756
Aqui você pode fazer isso como quiser se

17520
11:40:59,756 --> 11:41:01,436
Tentamos construir isso

17521
11:41:01,436 --> 11:41:04,560
com gcc vamos ver o que temos

17522
11:41:04,560 --> 11:41:07,040
A votação vai passar

17523
11:41:07,040 --> 11:41:09,436
E se corrermos o galo, vamos ver

17524
11:41:09,436 --> 11:41:12,080
que p número aponta para um inválido

17525
11:41:12,080 --> 11:41:14,400
Endereço porque contém

17526
11:41:14,400 --> 11:41:17,276
ponteiro null, mas se tentarmos configurar um

17527
11:41:17,276 --> 11:41:19,680
Nova variável, por exemplo, e dizer p

17528
11:41:19,680 --> 11:41:21,436
O número

17529
11:41:21,436 --> 11:41:23,680
e vamos usar a memória dinâmica que temos

17530
11:41:23,680 --> 11:41:26,320
Aprenda isso e inicialize isso

17531
11:41:26,320 --> 11:41:28,720
com um 7, por exemplo, e quando aponta

17532
11:41:28,720 --> 11:41:30,400
para um endereço válido que vamos imprimir

17533
11:41:30,400 --> 11:41:32,400
O que quer que esteja lá, nós sabemos como fazer

17534
11:41:32,400 --> 11:41:35,520
para que possamos dizer p número e nós somos

17535
11:41:35,520 --> 11:41:37,520
Vou imprimir o que está dentro e

17536
11:41:37,520 --> 11:41:40,480
Diga p número através do fim de referência

17537
11:41:40,480 --> 11:41:43,200
e nós vamos dizer stdndl agora o

17538
11:41:43,200 --> 11:41:45,436
O ponteiro não vai conter

17539
11:41:45,436 --> 11:41:47,916
sem ponteiro porque contém o

17540
11:41:47,916 --> 11:41:48,960
Endereço

17541
11:41:48,960 --> 11:41:51,436
da memória que foi alocada no

17542
11:41:51,436 --> 11:41:52,640
quadril aqui

17543
11:41:52,640 --> 11:41:55,276
Mas uma vez que fazemos isso, temos que lembrar

17544
11:41:55,276 --> 11:41:57,840
para liberar essa memória, então por favor

17545
11:41:57,840 --> 11:41:59,756
Lembre-se de liberar sua memória depois

17546
11:41:59,756 --> 11:42:01,840
Você está feito usando isso para que nós vamos

17547
11:42:01,840 --> 11:42:04,960
dizer apagar o número p depois disso e nós

17548
11:42:04,960 --> 11:42:07,360
precisa redefini-lo para nenhum ponteiro nisso

17549
11:42:07,360 --> 11:42:10,000
Caso seja realmente inútil porque ninguém

17550
11:42:10,000 --> 11:42:11,520
Vai usar este ponteiro

17551
11:42:11,520 --> 11:42:14,800
O programa está prestes a terminar, mas

17552
11:42:14,800 --> 11:42:17,520
É uma boa prática fazer isso mesmo em

17553
11:42:17,520 --> 11:42:20,400
este caso porque uma vez esta maneira de fazer

17554
11:42:20,400 --> 11:42:23,680
eventos são queimados em sua memória que tem

17555
11:42:23,680 --> 11:42:25,596
tornar-se seu hábito que você vai ser

17556
11:42:25,596 --> 11:42:28,400
escrevendo cifra c plus código agora

17557
11:42:28,400 --> 11:42:30,080
nós vamos tentar executá-lo, então nós somos

17558
11:42:30,080 --> 11:42:31,756
Vou construir novamente o ousado está indo

17559
11:42:31,756 --> 11:42:34,400
para passar e vai dizer

17560
11:42:34,400 --> 11:42:35,436
que

17561
11:42:35,436 --> 11:42:37,360
temos um endereço válido na memória que

17562
11:42:37,360 --> 11:42:40,160
É esse cara e o que está dentro é um

17563
11:42:40,160 --> 11:42:42,960
Sete e agora estamos escrevendo cifra c

17564
11:42:42,960 --> 11:42:45,756
mais mais código através de ponteiro nulo

17565
11:42:45,756 --> 11:42:48,160
segurança aqui também podemos fazer uma

17566
11:42:48,160 --> 11:42:51,040
verificar usando p número sem verificar se

17567
11:42:51,040 --> 11:42:53,116
é igual ao ponteiro nulo porque este

17568
11:42:53,116 --> 11:42:55,916
é verbose, mas é algo que você vai

17569
11:42:55,916 --> 11:42:57,916
Veja na prática você também pode fazer

17570
11:42:57,916 --> 11:42:59,916
algo assim e dizer se p número

17571
11:42:59,916 --> 11:43:01,596
E você vai ter exatamente o mesmo

17572
11:43:01,596 --> 11:43:04,400
Algo assim, se tivermos alguns válidos

17573
11:43:04,400 --> 11:43:06,800
Endereço dentro, vamos imprimir

17574
11:43:06,800 --> 11:43:09,436
que vamos imprimir a mesma coisa que

17575
11:43:09,436 --> 11:43:10,400
No

17576
11:43:10,400 --> 11:43:12,160
Código anterior aqui

17577
11:43:12,160 --> 11:43:13,840
E se construímos e corremos, vamos

17578
11:43:13,840 --> 11:43:16,480
obter exatamente a mesma coisa

17579
11:43:16,480 --> 11:43:18,160
Tudo bem, então isso é

17580
11:43:18,160 --> 11:43:20,320
claro porque o mundo é bom, vamos

17581
11:43:20,320 --> 11:43:22,240
clear e run galo você vê que nós

17582
11:43:22,240 --> 11:43:25,276
obter exatamente a mesma coisa e se nós

17583
11:43:25,276 --> 11:43:27,916
Não inicializou esse cara com o novo

17584
11:43:27,916 --> 11:43:30,240
peça dinâmica de memória que vamos

17585
11:43:30,240 --> 11:43:32,720
obter que a memória é inválida

17586
11:43:32,720 --> 11:43:34,240
O endereço que temos no ponteiro está indo

17587
11:43:34,240 --> 11:43:36,080
para ser inválido e vamos imprimir

17588
11:43:36,080 --> 11:43:38,240
que através do nosso código aqui

17589
11:43:38,240 --> 11:43:41,116
executar o endereço inválido do galo

17590
11:43:41,116 --> 11:43:43,276
Ok, a última coisa que eu quero que você veja é

17591
11:43:43,276 --> 11:43:46,720
que é bom chamar excluir

17592
11:43:46,720 --> 11:43:48,800
em um ponteiro nulo e nós vamos dizer

17593
11:43:48,800 --> 11:43:50,800
que aqui vamos para cá

17594
11:43:50,800 --> 11:43:52,960
e colocar um pedaço de código nós somos

17595
11:43:52,960 --> 11:43:55,360
a criação de um novo ponteiro p número um

17596
11:43:55,360 --> 11:43:58,160
inicializado sem ponteiro se ligarmos

17597
11:43:58,160 --> 11:44:00,080
Excluir sobre ele isso vai funcionar

17598
11:44:00,080 --> 11:44:01,916
muito bem e você não vai conseguir

17599
11:44:01,916 --> 11:44:04,240
uma paixão ou qualquer coisa que seja válida c plus

17600
11:44:04,240 --> 11:44:06,560
além do código, portanto, se estivermos tentando compilar

17601
11:44:06,560 --> 11:44:09,520
Isso vai funcionar bem e você

17602
11:44:09,520 --> 11:44:11,916
Não tem que realmente ter que

17603
11:44:11,916 --> 11:44:14,640
não verifique sem ponteiro antes de excluir

17604
11:44:14,640 --> 11:44:16,960
Assim porque isso é matar você

17605
11:44:16,960 --> 11:44:19,596
Veja que o programa ambos com sucesso

17606
11:44:19,596 --> 11:44:21,360
e nós podemos limpar e correr e nós somos

17607
11:44:21,360 --> 11:44:23,040
Vou ter exatamente as mesmas coisas que nós

17608
11:44:23,040 --> 11:44:25,520
Antes, algumas pessoas estavam indo para

17609
11:44:25,520 --> 11:44:27,680
fazer algo como

17610
11:44:27,680 --> 11:44:29,596
Eles vão verificar se não há ponteiro

17611
11:44:29,596 --> 11:44:31,756
e eles vão dizer se p número um

17612
11:44:31,756 --> 11:44:34,480
Por exemplo, não é igual a nenhum ponteiro

17613
11:44:34,480 --> 11:44:36,160
E eles vão dizer algo como

17614
11:44:36,160 --> 11:44:38,080
excluir aqui e eles vão fazer

17615
11:44:38,080 --> 11:44:39,436
Algo assim

17616
11:44:39,436 --> 11:44:41,436
E isso vai funcionar, mas é

17617
11:44:41,436 --> 11:44:43,116
A exagero que você não precisa fazer

17618
11:44:43,116 --> 11:44:46,240
este teste porque é seguro chamar

17619
11:44:46,240 --> 11:44:49,276
excluir em um ponteiro, mesmo se ele contém

17620
11:44:49,276 --> 11:44:51,756
Não há ponteiro em primeiro lugar, então você

17621
11:44:51,756 --> 11:44:53,916
Não precisa fazer coisas assim

17622
11:44:53,916 --> 11:44:56,400
Vai trabalhar muito bem, não seja

17623
11:44:56,400 --> 11:44:59,276
medo de chamar excluir em um ponteiro

17624
11:44:59,276 --> 11:45:02,480
porque pode conter ponteiro nulo

17625
11:45:02,480 --> 11:45:04,880
Isso é realmente tudo o que queremos dizer com null

17626
11:45:04,880 --> 11:45:06,960
ponto de segurança e espero que eu lhe tenha dado um

17627
11:45:06,960 --> 11:45:09,520
Poucos exemplos para deixar isso bem claro

17628
11:45:09,520 --> 11:45:11,040
Vamos parar aqui neste

17629
11:45:11,040 --> 11:45:12,560
dar uma palestra no próximo que vamos

17630
11:45:12,560 --> 11:45:15,276
Saiba mais sobre as lambidas de memória

17631
11:45:15,276 --> 11:45:17,756
Vá em frente e termine aqui e me encontre

17632
11:45:17,756 --> 11:45:19,596
lá nesta palestra vamos

17633
11:45:19,596 --> 11:45:21,840
Saiba mais sobre vazamentos de memória

17634
11:45:21,840 --> 11:45:24,880
E um vazamento de memória é quando você perdeu

17635
11:45:24,880 --> 11:45:28,000
acesso a um pedaço de memória que foi

17636
11:45:28,000 --> 11:45:30,640
alocado dinamicamente para o seu programa

17637
11:45:30,640 --> 11:45:32,960
Você basicamente perde o ponteiro que foi

17638
11:45:32,960 --> 11:45:35,116
apontando para isso dinamicamente alocado

17639
11:45:35,116 --> 11:45:37,200
Um pedaço de memória aqui temos alguns

17640
11:45:37,200 --> 11:45:39,040
Exemplos disso, por exemplo, aqui estamos

17641
11:45:39,040 --> 11:45:41,276
ter o número p que contém um

17642
11:45:41,276 --> 11:45:43,520
peça de memória alocada dinamicamente

17643
11:45:43,520 --> 11:45:44,960
que vai conter um inteiro

17644
11:45:44,960 --> 11:45:47,360
Vai ser 4 byte o valor dentro

17645
11:45:47,360 --> 11:45:50,640
vai ser um 67. este número p é

17646
11:45:50,640 --> 11:45:53,520
Nossa única chave para manipular essa memória

17647
11:45:53,520 --> 11:45:55,756
e é a chave através da qual nós até

17648
11:45:55,756 --> 11:45:58,640
ir liberar essa memória e voltar

17649
11:45:58,640 --> 11:46:01,360
Isso para o sistema operacional, mas observe

17650
11:46:01,360 --> 11:46:02,960
O que fazemos aqui em baixo

17651
11:46:02,960 --> 11:46:06,000
Estamos criando uma nova variável numérica

17652
11:46:06,000 --> 11:46:08,400
é um inteiro e é alocado em

17653
11:46:08,400 --> 11:46:09,916
a pilha, porque este é um local

17654
11:46:09,916 --> 11:46:11,916
variável não é um ponteiro que não é

17655
11:46:11,916 --> 11:46:15,116
alocado dinamicamente e tomamos o

17656
11:46:15,116 --> 11:46:17,916
endereço de número e atribuir isso ao nosso

17657
11:46:17,916 --> 11:46:20,400
ponteiro no momento em que fazemos isso

17658
11:46:20,400 --> 11:46:23,596
Não temos como liberar a memória

17659
11:46:23,596 --> 11:46:26,080
que foi atribuído ao número p no

17660
11:46:26,080 --> 11:46:27,276
Primeiro lugar

17661
11:46:27,276 --> 11:46:29,680
e se fizermos isso o sistema operacional

17662
11:46:29,680 --> 11:46:31,756
Vai pensar que essa memória é

17663
11:46:31,756 --> 11:46:34,880
Nós, mas não temos uma maneira de liberar

17664
11:46:34,880 --> 11:46:37,116
Esta memória mais porque o ponteiro

17665
11:46:37,116 --> 11:46:38,240
que foi

17666
11:46:38,240 --> 11:46:41,116
Ajudar-nos a acessar essa memória tem sido

17667
11:46:41,116 --> 11:46:43,520
reaproveitado para apontar para este número

17668
11:46:43,520 --> 11:46:45,840
variável aqui espero que você veja que

17669
11:46:45,840 --> 11:46:47,756
E o vazamento de memória é algo como

17670
11:46:47,756 --> 11:46:49,840
Isso quando você perde o ponteiro que

17671
11:46:49,840 --> 11:46:52,400
Seria usado de outra forma para liberar o

17672
11:46:52,400 --> 11:46:54,480
A memória e seu programa são basicamente

17673
11:46:54,480 --> 11:46:56,640
Vou continuar usando essa memória e a

17674
11:46:56,640 --> 11:46:58,720
O sistema operacional não terá um

17675
11:46:58,720 --> 11:47:01,200
maneira de recuperar essa memória para que ela seja

17676
11:47:01,200 --> 11:47:03,756
inútil para que você não esteja mais usando isso

17677
11:47:03,756 --> 11:47:05,436
memória porque você não pode acessá-lo e

17678
11:47:05,436 --> 11:47:07,436
fazer as coisas com ele e a operação

17679
11:47:07,436 --> 11:47:09,596
O sistema também não pode usá-lo porque

17680
11:47:09,596 --> 11:47:11,840
cercas sua memória espero que você possa ver

17681
11:47:11,840 --> 11:47:14,320
que esta é uma situação muito ruim e

17682
11:47:14,320 --> 11:47:16,720
Você deve evitar essas coisas em seu

17683
11:47:16,720 --> 11:47:19,840
Aplicação assim evitar vazamentos de memória

17684
11:47:19,840 --> 11:47:21,200
Como uma praga

17685
11:47:21,200 --> 11:47:23,200
Esta é uma situação em que podemos

17686
11:47:23,200 --> 11:47:25,756
ter um vazamento de memória aqui é outro

17687
11:47:25,756 --> 11:47:28,400
Exemplo em que temos dupla alocação

17688
11:47:28,400 --> 11:47:30,640
temos um ponteiro p número um que é

17689
11:47:30,640 --> 11:47:33,200
apontando para memória alocada dinamicamente

17690
11:47:33,200 --> 11:47:37,040
Mais uma vez e o valor dentro é um 55.

17691
11:47:37,040 --> 11:47:39,276
se usarmos este ponteiro para alocar novos

17692
11:47:39,276 --> 11:47:41,596
memória da primeira lembrança que nós éramos

17693
11:47:41,596 --> 11:47:43,840
Aponte para vai vazar

17694
11:47:43,840 --> 11:47:46,720
Mais uma vez é a mesma coisa que perdemos

17695
11:47:46,720 --> 11:47:49,756
acesso à primeira memória agora que somos

17696
11:47:49,756 --> 11:47:52,560
apontando para a segunda dinâmica

17697
11:47:52,560 --> 11:47:54,880
memória que foi alocada para conter o

17698
11:47:54,880 --> 11:47:58,000
44 aqui e novamente isso é um vazamento de memória

17699
11:47:58,000 --> 11:47:59,916
O seu programa perdeu o acesso ao

17700
11:47:59,916 --> 11:48:03,200
memória contendo 55 aqui e a

17701
11:48:03,200 --> 11:48:05,520
O sistema operacional também pensa que você

17702
11:48:05,520 --> 11:48:08,480
estão usando essa memória porque você não

17703
11:48:08,480 --> 11:48:11,200
Retorne-o explicitamente à operação

17704
11:48:11,200 --> 11:48:14,880
sistema através do operador de exclusão novamente

17705
11:48:14,880 --> 11:48:17,756
Vazamentos de memória são ruins para evitá-los em

17706
11:48:17,756 --> 11:48:20,160
Os seus programas aqui são mais simples

17707
11:48:20,160 --> 11:48:22,160
Exemplo de um caso em que você pode ter um

17708
11:48:22,160 --> 11:48:24,800
vazamento de memória que você vai em um escopo aninhado

17709
11:48:24,800 --> 11:48:27,200
assim e alocar um novo pedaço de

17710
11:48:27,200 --> 11:48:29,840
memória dinamicamente, é claro e pontua

17711
11:48:29,840 --> 11:48:32,720
para isso através do número dois aqui, mas p

17712
11:48:32,720 --> 11:48:34,000
O número dois

17713
11:48:34,000 --> 11:48:36,800
em si é um ponteiro e é um local

17714
11:48:36,800 --> 11:48:39,520
variável aninhada neste âmbito

17715
11:48:39,520 --> 11:48:41,756
quando este escopo termina p número dois é

17716
11:48:41,756 --> 11:48:44,320
Vai morrer, mas a memória dinâmica

17717
11:48:44,320 --> 11:48:46,640
em si não vai morrer você acabou de perder

17718
11:48:46,640 --> 11:48:48,720
acesso a ele e você não pode acessá-lo

17719
11:48:48,720 --> 11:48:50,960
Mais uma vez isso é um vazamento de memória e você

17720
11:48:50,960 --> 11:48:53,276
Deve evitar isso em seus programas

17721
11:48:53,276 --> 11:48:56,080
Os vazamentos de memória são realmente ruins e em

17722
11:48:56,080 --> 11:48:58,560
Casos extremos que eles podem até levar a

17723
11:48:58,560 --> 11:49:01,200
seu programa travando se o seu programa

17724
11:49:01,200 --> 11:49:03,596
continua funcionando por um período prolongado de

17725
11:49:03,596 --> 11:49:06,400
Tempo pense em programas como esses

17726
11:49:06,400 --> 11:49:08,800
executando em servidores, por exemplo, eles podem

17727
11:49:08,800 --> 11:49:10,880
mesmo correndo por três meses sem

17728
11:49:10,880 --> 11:49:14,000
parar e se o seu programa é

17729
11:49:14,000 --> 11:49:16,400
cada vez mais a memória a

17730
11:49:16,400 --> 11:49:18,160
O sistema operacional vai pensar que

17731
11:49:18,160 --> 11:49:20,400
você está tomando muita memória do quadril que é

17732
11:49:20,400 --> 11:49:22,640
Vou encerrar seu programa como nós

17733
11:49:22,640 --> 11:49:23,520
serra

17734
11:49:23,520 --> 11:49:26,000
na palestra onde aprendemos sobre

17735
11:49:26,000 --> 11:49:28,480
condições em que o novo operador falhou

17736
11:49:28,480 --> 11:49:31,436
Então, se você alocar muita memória, então

17737
11:49:31,436 --> 11:49:33,840
Seu programa pode realmente tomar o próximo

17738
11:49:33,840 --> 11:49:35,436
operações que você vai fazer com novos

17739
11:49:35,436 --> 11:49:37,200
vai falhar e seu programa é

17740
11:49:37,200 --> 11:49:39,756
Vou terminar a mensagem aqui é

17741
11:49:39,756 --> 11:49:41,840
Vazamentos de memória são ruins que você deve evitar

17742
11:49:41,840 --> 11:49:44,240
em seus programas e sempre que você

17743
11:49:44,240 --> 11:49:46,000
Pense que você não está mais usando um

17744
11:49:46,000 --> 11:49:48,560
peça de memória certifique-se de excluí-lo

17745
11:49:48,560 --> 11:49:50,720
e devolvê-lo ao sistema operacional

17746
11:49:50,720 --> 11:49:53,276
você vai escrever muito mais seguro c

17747
11:49:53,276 --> 11:49:55,200
mais além de código, vamos nos dirigir

17748
11:49:55,200 --> 11:49:57,520
para código de estúdio visual e realmente tentar

17749
11:49:57,520 --> 11:50:00,560
Aqui estamos em nosso trabalho

17750
11:50:00,560 --> 11:50:02,880
diretório do projeto atual é memória

17751
11:50:02,880 --> 11:50:05,040
Vazamentos que vamos trazer em nosso

17752
11:50:05,040 --> 11:50:06,880
Arquivos de modelo

17753
11:50:06,880 --> 11:50:08,960
E nós vamos colocá-los no lugar

17754
11:50:08,960 --> 11:50:12,080
A palestra sobre vazamentos de memória e nós somos

17755
11:50:12,080 --> 11:50:14,240
abrir isso em código de estúdio visual

17756
11:50:14,240 --> 11:50:15,916
nós vamos limpar isso um pouco

17757
11:50:15,916 --> 11:50:18,320
Um pouco trazer isso aqui nós temos um

17758
11:50:18,320 --> 11:50:20,240
variável chamada p número é um ponteiro

17759
11:50:20,240 --> 11:50:22,880
para terminar e nós inicializamos isso com o

17760
11:50:22,880 --> 11:50:25,756
Endereço de um pedaço de memória que é

17761
11:50:25,756 --> 11:50:28,480
alocados dinamicamente na pilha

17762
11:50:28,480 --> 11:50:31,916
armazenar um 67 dentro e aqui em baixo você vê

17763
11:50:31,916 --> 11:50:34,160
nós configuramos outra variável na pilha

17764
11:50:34,160 --> 11:50:37,116
Mais uma vez isso diz uma variável de pilha

17765
11:50:37,116 --> 11:50:39,116
ele vive na pilha que não está no

17766
11:50:39,116 --> 11:50:41,116
heap e enviamos mensagens de texto para o endereço deste

17767
11:50:41,116 --> 11:50:43,116
coisa e atribuir isso ao nosso ponteiro

17768
11:50:43,116 --> 11:50:45,436
Aqui no momento em que fazemos que não temos

17769
11:50:45,436 --> 11:50:47,756
Mais como podemos aceder a esta dinâmica

17770
11:50:47,756 --> 11:50:50,320
memória e nós vazamos e isso é

17771
11:50:50,320 --> 11:50:52,640
É realmente ruim a coisa que este programa é

17772
11:50:52,640 --> 11:50:54,000
indo para a compilação

17773
11:50:54,000 --> 11:50:56,160
Eu não acho que os compiladores tenham um jeito de

17774
11:50:56,160 --> 11:50:58,400
impedi-lo de cometer erros como este

17775
11:50:58,400 --> 11:51:00,160
Você realmente tem que ter cuidado e

17776
11:51:00,160 --> 11:51:02,080
Certifique-se de que você não está vazando

17777
11:51:02,080 --> 11:51:04,880
memória em seu programa, então se executarmos isso

17778
11:51:04,880 --> 11:51:06,640
programa que vai executá-lo vai

17779
11:51:06,640 --> 11:51:08,560
correr e terminar vamos dizer que é

17780
11:51:08,560 --> 11:51:11,680
terminando bem bem, então vamos construir

17781
11:51:11,680 --> 11:51:14,560
e ver esta corrida a construção é bom para que nós

17782
11:51:14,560 --> 11:51:16,560
pode limpar e correr galo e nós somos

17783
11:51:16,560 --> 11:51:18,560
Vai ver que o programa está terminando

17784
11:51:18,560 --> 11:51:20,720
Bem, mas nós somos

17785
11:51:20,720 --> 11:51:22,880
vazando memória aqui porque o

17786
11:51:22,880 --> 11:51:24,880
Um pedaço de memória que nós

17787
11:51:24,880 --> 11:51:26,560
atribuído aqui

17788
11:51:26,560 --> 11:51:29,276
não foi liberado para o sistema e quando

17789
11:51:29,276 --> 11:51:32,160
Fizemos esta tarefa aqui que acabamos de perder

17790
11:51:32,160 --> 11:51:34,560
acesso a ele para que o sistema operacional seja

17791
11:51:34,560 --> 11:51:36,400
Vou agradecer a esta memória pertence a

17792
11:51:36,400 --> 11:51:39,436
Este programa que é nosso aqui, mas seu

17793
11:51:39,436 --> 11:51:41,756
O programa também não vai usar

17794
11:51:41,756 --> 11:51:44,240
Este pedaço de memória porque nós temos

17795
11:51:44,240 --> 11:51:46,320
Acabei de perder a chave

17796
11:51:46,320 --> 11:51:48,160
que nos permitiria ir e fazer

17797
11:51:48,160 --> 11:51:50,800
Algo útil com essa memória aqui

17798
11:51:50,800 --> 11:51:52,480
então isso é algo ruim e você deve

17799
11:51:52,480 --> 11:51:55,200
Evite isso o segundo exemplo da memória

17800
11:51:55,200 --> 11:51:57,680
vazamentos é quando você faz dupla alocação

17801
11:51:57,680 --> 11:51:59,916
em um ponteiro, por exemplo, aqui temos

17802
11:51:59,916 --> 11:52:02,160
pino número um novamente e nós vamos

17803
11:52:02,160 --> 11:52:04,080
fazer este ponto para

17804
11:52:04,080 --> 11:52:05,596
um endereço

17805
11:52:05,596 --> 11:52:09,116
de um pedaço de memória que foi atribuído

17806
11:52:09,116 --> 11:52:12,160
dinamicamente no heap o valor dentro

17807
11:52:12,160 --> 11:52:15,116
serão 55, mas estamos usando isso

17808
11:52:15,116 --> 11:52:18,960
ponteiro novamente para fazê-lo apontar para um novo

17809
11:52:18,960 --> 11:52:22,000
pedaço de memória contendo o endereço

17810
11:52:22,000 --> 11:52:25,116
do pedaço de memória recém-atribuído

17811
11:52:25,116 --> 11:52:27,680
na pilha no heap eu quero dizer e isso

17812
11:52:27,680 --> 11:52:29,680
é realmente ruim porque mais uma vez que fazemos

17813
11:52:29,680 --> 11:52:32,320
Isso perdemos o acesso a essa memória aqui

17814
11:52:32,320 --> 11:52:33,916
E está ligado

17815
11:52:33,916 --> 11:52:35,596
O programa aqui não vai ter

17816
11:52:35,596 --> 11:52:37,596
acesso a ele e ao sistema operacional é

17817
11:52:37,596 --> 11:52:40,320
Vou agradecer por possuir essa memória e ela

17818
11:52:40,320 --> 11:52:43,276
vai ser ruim e uh aqui em baixo

17819
11:52:43,276 --> 11:52:45,436
Talvez você possa ir e dizer o número de exclusão

17820
11:52:45,436 --> 11:52:48,000
um p número um, mas isso não vai

17821
11:52:48,000 --> 11:52:50,480
para liberar a memória aqui está indo

17822
11:52:50,480 --> 11:52:53,116
para liberar a memória aqui com o 44

17823
11:52:53,116 --> 11:52:55,436
e a memória que contém 55 aqui é

17824
11:52:55,436 --> 11:52:58,160
Vou vazar, vamos ser bons c mais

17825
11:52:58,160 --> 11:53:00,720
além dos cidadãos e redefinir nossos ponteiros

17826
11:53:00,720 --> 11:53:02,880
depois que nós excluímos, então nós vamos dizer p

17827
11:53:02,880 --> 11:53:05,756
O número um não é igual a nenhum ponteiro e nós somos

17828
11:53:05,756 --> 11:53:08,160
Vou jogar pelo seguro aqui e

17829
11:53:08,160 --> 11:53:10,960
novamente nós apenas levantamos a memória aqui e é

17830
11:53:10,960 --> 11:53:12,400
Algo que você deve evitar em seu

17831
11:53:12,400 --> 11:53:15,200
programas se você executar este programa é

17832
11:53:15,200 --> 11:53:18,400
indo correr muito bem, então vamos ver isso

17833
11:53:18,400 --> 11:53:20,160
Porque eu não quero te deixar com

17834
11:53:20,160 --> 11:53:22,960
programas que contêm erros

17835
11:53:22,960 --> 11:53:25,040
Se eu correr galo novamente vai acabar

17836
11:53:25,040 --> 11:53:27,680
Bem, mas vai vazar

17837
11:53:27,680 --> 11:53:28,960
A memória aqui

17838
11:53:28,960 --> 11:53:31,756
para que não queremos vazar memória evitar

17839
11:53:31,756 --> 11:53:33,916
Como uma praga, vamos

17840
11:53:33,916 --> 11:53:35,520
Comente isso para fora

17841
11:53:35,520 --> 11:53:37,200
e mostrar que você também pode vazar

17842
11:53:37,200 --> 11:53:40,000
memória quando você tem alguns escopos aninhados

17843
11:53:40,000 --> 11:53:42,320
em seus programas, ok, vamos para cá

17844
11:53:42,320 --> 11:53:44,800
e colocar isso dentro e aqui é um simples

17845
11:53:44,800 --> 11:53:47,360
exemplo, temos um âmbito aninhado aninhado

17846
11:53:47,360 --> 11:53:49,840
dentro da função principal e dentro do

17847
11:53:49,840 --> 11:53:52,160
escopo aqui estamos criando um novo

17848
11:53:52,160 --> 11:53:53,276
O ponteiro

17849
11:53:53,276 --> 11:53:55,276
E isso vai apontar para

17850
11:53:55,276 --> 11:53:57,840
memória alocada dinamicamente e que

17851
11:53:57,840 --> 11:54:00,320
A memória vai conter um 57.

17852
11:54:00,320 --> 11:54:02,400
A única chave que temos para esta dinâmica

17853
11:54:02,400 --> 11:54:05,596
A memória é este p número dois ponteiro aqui

17854
11:54:05,596 --> 11:54:08,240
mas este p número dois ponteiro vive em

17855
11:54:08,240 --> 11:54:11,276
A pilha em si assim quando o escopo aqui

17856
11:54:11,276 --> 11:54:13,200
vai terminar p número dois não é

17857
11:54:13,200 --> 11:54:15,756
mais tempo vai ser acessível e o

17858
11:54:15,756 --> 11:54:17,756
A memória será ligada se você

17859
11:54:17,756 --> 11:54:20,000
realmente quer jogar pelo seguro você pode ir

17860
11:54:20,000 --> 11:54:22,080
Faça o que quiser com a dinâmica

17861
11:54:22,080 --> 11:54:24,480
memória e quando você terminar com isso

17862
11:54:24,480 --> 11:54:26,800
você pode excluir esse pedaço de memória aqui

17863
11:54:26,800 --> 11:54:28,800
enquanto você ainda tem acesso ao número p

17864
11:54:28,800 --> 11:54:30,400
Dois, mas se você não fizer

17865
11:54:30,400 --> 11:54:31,756
excluir aqui

17866
11:54:31,756 --> 11:54:34,240
no escopo onde essa coisa estava

17867
11:54:34,240 --> 11:54:35,596
Declarado

17868
11:54:35,596 --> 11:54:38,080
Se você atingir o final deste escopo, você está

17869
11:54:38,080 --> 11:54:40,320
vai perder o acesso a este ponteiro e

17870
11:54:40,320 --> 11:54:42,480
Você perderá o acesso a isso

17871
11:54:42,480 --> 11:54:44,400
peça dinâmica de memória

17872
11:54:44,400 --> 11:54:46,080
e você vai estar vazando memória

17873
11:54:46,080 --> 11:54:48,560
porque você não está excluindo isso, mesmo se

17874
11:54:48,560 --> 11:54:50,320
você quer excluí-lo que você não será capaz

17875
11:54:50,320 --> 11:54:52,720
para fazer isso porque você não tem uma chave

17876
11:54:52,720 --> 11:54:54,160
que vai te levar a isso

17877
11:54:54,160 --> 11:54:56,480
memória dinâmica por isso, se tentarmos fazer

17878
11:54:56,480 --> 11:54:59,040
excluir p número dois aqui este não é

17879
11:54:59,040 --> 11:55:01,040
vamos compilar porque não temos

17880
11:55:01,040 --> 11:55:03,520
O acesso ao p número dois p número dois é

17881
11:55:03,520 --> 11:55:06,640
escopo dentro deste escopo aninhado aqui

17882
11:55:06,640 --> 11:55:09,756
Isto é o que quero dizer, então tenha certeza de que você está

17883
11:55:09,756 --> 11:55:12,960
Conscientes desse problema de vazamento de memória

17884
11:55:12,960 --> 11:55:15,916
Os casos que vimos aqui são realmente

17885
11:55:15,916 --> 11:55:17,596
extenso o suficiente para lhe dar uma

17886
11:55:17,596 --> 11:55:20,880
intuição sobre como isso é ruim e você é

17887
11:55:20,880 --> 11:55:23,200
Vou evitar esses novos programas

17888
11:55:23,200 --> 11:55:24,960
e você estará no seu caminho para

17889
11:55:24,960 --> 11:55:28,000
tornar-se um melhor c plus desenvolvedor

17890
11:55:28,000 --> 11:55:29,520
Isso é realmente tudo o que nos prossamos fazer em

17891
11:55:29,520 --> 11:55:31,436
Esta palestra para aprender sobre leads de memória

17892
11:55:31,436 --> 11:55:33,756
mostrar-lhe alguns exemplos deles eu espero

17893
11:55:33,756 --> 11:55:36,000
Agora você os entende, nós vamos

17894
11:55:36,000 --> 11:55:37,680
Parar aqui nesta palestra e no próximo

17895
11:55:37,680 --> 11:55:38,960
Um que nós vamos aprender sobre

17896
11:55:38,960 --> 11:55:42,080
arrays alocados dinamicamente

17897
11:55:42,080 --> 11:55:44,480
Vá em frente e termine aqui e me encontre

17898
11:55:44,480 --> 11:55:45,360
lá

17899
11:55:45,360 --> 11:55:47,360
Nesta palestra vamos olhar

17900
11:55:47,360 --> 11:55:51,040
arrays dinâmicos e estes são arrays você

17901
11:55:51,040 --> 11:55:53,840
pode alocar no monte e eles não são

17902
11:55:53,840 --> 11:55:55,840
vai ser armazenado na pilha como nós

17903
11:55:55,840 --> 11:55:57,436
já vimos antes das matrizes que temos

17904
11:55:57,436 --> 11:56:00,320
Aprendendo sobre que até agora tem vivido

17905
11:56:00,320 --> 11:56:03,040
A pilha que queremos ver como podemos

17906
11:56:03,040 --> 11:56:05,436
alocar arrays no heap se acontecermos

17907
11:56:05,436 --> 11:56:08,400
para precisar disso em nossos arrays de aplicativos

17908
11:56:08,400 --> 11:56:10,800
são alocados no quadril com o novo

17909
11:56:10,800 --> 11:56:13,116
operador, nós também podemos usar o sdd no

17910
11:56:13,116 --> 11:56:16,720
lançar a versão do novo operador se nós

17911
11:56:16,720 --> 11:56:19,116
Não quero exceções em nosso c plus mais

17912
11:56:19,116 --> 11:56:21,916
programas aqui é um exemplo simples de como

17913
11:56:21,916 --> 11:56:23,840
Você pode fazer isso, temos um ponteiro chamado

17914
11:56:23,840 --> 11:56:25,596
salário salarial vai ser um ponteiro para

17915
11:56:25,596 --> 11:56:28,320
duplo e vai conter o

17916
11:56:28,320 --> 11:56:31,360
endereçamento para a memória dinâmica que nós

17917
11:56:31,360 --> 11:56:33,040
alocar no monte que vai

17918
11:56:33,040 --> 11:56:35,040
Contém um array

17919
11:56:35,040 --> 11:56:38,400
de duplos deste tamanho aqui ok este

17920
11:56:38,400 --> 11:56:40,160
É um array que vai ser

17921
11:56:40,160 --> 11:56:42,720
inicializado com valores de lixo porque nós

17922
11:56:42,720 --> 11:56:45,040
Não estão inicializando isso

17923
11:56:45,040 --> 11:56:47,116
explicitamente, isso é algo que você precisa

17924
11:56:47,116 --> 11:56:49,360
Estar ciente de OK p estudantes também é

17925
11:56:49,360 --> 11:56:52,720
vai conter o endereço de um

17926
11:56:52,720 --> 11:56:54,960
array que vai ser alocado em

17927
11:56:54,960 --> 11:56:57,916
o monte que estamos usando o sdd nothro

17928
11:56:57,916 --> 11:57:00,400
versão do novo operador porque em

17929
11:57:00,400 --> 11:57:02,400
Este caso, por exemplo, podemos não querer

17930
11:57:02,400 --> 11:57:04,480
Exceções e vamos dizer que

17931
11:57:04,480 --> 11:57:06,000
É uma variedade de eventos que vai

17932
11:57:06,000 --> 11:57:09,116
Este é o tamanho, mas estamos usando mama

17933
11:57:09,116 --> 11:57:11,680
inicializador, então isso vai ser

17934
11:57:11,680 --> 11:57:13,680
inicializado a zero

17935
11:57:13,680 --> 11:57:15,436
Todos os valores dentro serão

17936
11:57:15,436 --> 11:57:17,360
inicializado para zero isso é o que queremos dizer

17937
11:57:17,360 --> 11:57:20,400
aqui também temos uma matriz de pontuações p nós

17938
11:57:20,400 --> 11:57:22,800
estão usando a versão std no lançamento de

17939
11:57:22,800 --> 11:57:25,436
Novo e vai ser deste tamanho e

17940
11:57:25,436 --> 11:57:28,320
inicializado com um dois três quatro cinco

17941
11:57:28,320 --> 11:57:29,436
Tudo bem se for

17942
11:57:29,436 --> 11:57:31,596
O array é maior que cinco

17943
11:57:31,596 --> 11:57:33,200
As vagas restantes serão

17944
11:57:33,200 --> 11:57:35,916
inicializado com zeros como vimos

17945
11:57:35,916 --> 11:57:37,840
com as matrizes que aprendemos sobre

17946
11:57:37,840 --> 11:57:40,160
Anteriormente, estamos armazenados no

17947
11:57:40,160 --> 11:57:41,840
empilhar isso é realmente como você trabalha com

17948
11:57:41,840 --> 11:57:44,000
essas coisas e espero que seja super

17949
11:57:44,000 --> 11:57:46,800
claro novamente estamos chamando o novo

17950
11:57:46,800 --> 11:57:47,916
o operador

17951
11:57:47,916 --> 11:57:50,720
Isso vai alocar, no entanto, a memória

17952
11:57:50,720 --> 11:57:53,360
O espaço é necessário para armazenar essas coisas em

17953
11:57:53,360 --> 11:57:55,680
a pilha assim se este array vai

17954
11:57:55,680 --> 11:57:57,916
Contém 10 elementos que vamos

17955
11:57:57,916 --> 11:58:00,240
alocar espaço suficiente para conter 10

17956
11:58:00,240 --> 11:58:02,400
dois elementos no monte e nós somos

17957
11:58:02,400 --> 11:58:04,880
Vou apontar para isso com o p

17958
11:58:04,880 --> 11:58:06,480
O ponteiro de salários é o que queremos dizer

17959
11:58:06,480 --> 11:58:09,276
aqui uma vez que você tem sua matriz dinâmica

17960
11:58:09,276 --> 11:58:11,916
alocado no quadril que você pode tentar fazer

17961
11:58:11,916 --> 11:58:13,596
Coisas com ele, por exemplo, podemos tentar

17962
11:58:13,596 --> 11:58:15,276
e loop através dos esquilos e imprimir

17963
11:58:15,276 --> 11:58:18,000
Aqui você vê que estamos usando

17964
11:58:18,000 --> 11:58:21,360
a sintaxe do suporte do ângulo e o

17965
11:58:21,360 --> 11:58:23,756
ponteiro sintaxe aritmética que vai

17966
11:58:23,756 --> 11:58:25,360
trabalhar igualmente bem você pode escolher

17967
11:58:25,360 --> 11:58:27,596
O que você quiser, mas eu só quero você

17968
11:58:27,596 --> 11:58:29,680
para ver que você pode usar ambas as versões

17969
11:58:29,680 --> 11:58:31,680
Aqui a próxima coisa lógica a pensar

17970
11:58:31,680 --> 11:58:34,000
Quando você fala sobre memória dinâmica

17971
11:58:34,000 --> 11:58:36,640
alocação é como você libera a memória

17972
11:58:36,640 --> 11:58:38,800
para o sistema operacional quando você não é

17973
11:58:38,800 --> 11:58:41,040
mais tempo usando-o e esta é a sintaxe

17974
11:58:41,040 --> 11:58:43,596
para fazê-lo com arrays que você diz excluí-lo

17975
11:58:43,596 --> 11:58:45,436
Coloque braquetes de ângulo e você diz o

17976
11:58:45,436 --> 11:58:48,240
pontodor que foi usado para alocar que

17977
11:58:48,240 --> 11:58:50,640
memória em primeiro lugar e depois de você

17978
11:58:50,640 --> 11:58:52,640
Você tem que lembrar de redefinir

17979
11:58:52,640 --> 11:58:54,640
o ponteiro para o ponteiro nulo porque você

17980
11:58:54,640 --> 11:58:57,596
são um bom c plus mais cidadão e este

17981
11:58:57,596 --> 11:58:59,436
É realmente tudo o que tínhamos a dizer neste

17982
11:58:59,436 --> 11:59:01,200
Palestra é assim que você está dinamicamente

17983
11:59:01,200 --> 11:59:04,480
alocar um aumento no quadril antes de

17984
11:59:04,480 --> 11:59:06,640
cabeça para código de estúdio visual e jogar

17985
11:59:06,640 --> 11:59:08,960
com isso, porém, eu quero que você continue

17986
11:59:08,960 --> 11:59:11,840
sua mente que você aloca

17987
11:59:11,840 --> 11:59:14,160
dinamicamente no heap são muito

17988
11:59:14,160 --> 11:59:16,560
diferente das matrizes que temos

17989
11:59:16,560 --> 11:59:18,480
Aprendi antes e isso é porque

17990
11:59:18,480 --> 11:59:21,360
eles não trabalham com std tamanho e eles

17991
11:59:21,360 --> 11:59:24,640
Não trabalhe para a faixa baseada em loops

17992
11:59:24,640 --> 11:59:26,400
e que a razão para tudo isso

17993
11:59:26,400 --> 11:59:28,480
Limitações é que quando você faz

17994
11:59:28,480 --> 11:59:30,640
Algo como este a matriz realmente

17995
11:59:30,640 --> 11:59:34,000
decai em um ponteiro e ele perde

17996
11:59:34,000 --> 11:59:36,800
informações que de outra forma seriam usadas

17997
11:59:36,800 --> 11:59:39,276
para deduzir o tamanho que é usado pelo sdd

17998
11:59:39,276 --> 11:59:41,840
Tamanho e há outras coisas que são

17999
11:59:41,840 --> 11:59:44,640
usado pela base de alcance para loop que

18000
11:59:44,640 --> 11:59:46,960
eles perdem quando você armazena e se refere a

18001
11:59:46,960 --> 11:59:48,960
usando um ponteiro como este que é

18002
11:59:48,960 --> 11:59:51,520
Porque temos essa limitação para manter isso em

18003
11:59:51,520 --> 11:59:53,840
mente se você estiver usando um

18004
11:59:53,840 --> 11:59:56,240
Array alocado no heap que você está indo

18005
11:59:56,240 --> 11:59:58,480
usar outras técnicas para deduzir

18006
11:59:58,480 --> 12:00:01,040
seu tamanho e não vai funcionar

18007
12:00:01,040 --> 12:00:03,200
com uma base de alcance para loop assim vamos

18008
12:00:03,200 --> 12:00:05,916
temos que usar outros tipos de loops que nós

18009
12:00:05,916 --> 12:00:08,000
aprenderam sobre este curso e

18010
12:00:08,000 --> 12:00:09,840
Vai funcionar muito bem

18011
12:00:09,840 --> 12:00:11,916
Isso é realmente tudo que eu tinha para compartilhar

18012
12:00:11,916 --> 12:00:14,240
Esta palestra agora eu acho que é hora de nós

18013
12:00:14,240 --> 12:00:16,720
Fui ao código do estúdio visual e, na verdade,

18014
12:00:16,720 --> 12:00:18,640
Experimente isso

18015
12:00:18,640 --> 12:00:21,520
Aqui estamos em nossa pasta de trabalho o

18016
12:00:21,520 --> 12:00:24,320
O projeto atual é alocado dinamicamente

18017
12:00:24,320 --> 12:00:25,436
matrizes

18018
12:00:25,436 --> 12:00:27,756
vamos pegar nossos arquivos de modelo

18019
12:00:27,756 --> 12:00:29,680
E colocá-los no lugar

18020
12:00:29,680 --> 12:00:31,436
e nós vamos colocar isso no

18021
12:00:31,436 --> 12:00:34,240
projeto atual e abrir isso em

18022
12:00:34,240 --> 12:00:36,960
código de estúdio como sempre fazemos e nós somos

18023
12:00:36,960 --> 12:00:39,360
ir para baixo e colocar em algum começo

18024
12:00:39,360 --> 12:00:41,596
código com o que podemos jogar aqui estamos indo

18025
12:00:41,596 --> 12:00:43,756
para clicar sobre isso

18026
12:00:43,756 --> 12:00:46,480
ícone do arquivo para remover este painel

18027
12:00:46,480 --> 12:00:48,880
e vamos tentar mostrar o código

18028
12:00:48,880 --> 12:00:50,560
Aqui e novamente você vê esse visual

18029
12:00:50,560 --> 12:00:53,116
O código do estúdio está surtando quando vê

18030
12:00:53,116 --> 12:00:55,360
a versão std no lançamento do novo

18031
12:00:55,360 --> 12:00:57,520
Operador aqui, mas vai funcionar

18032
12:00:57,520 --> 12:00:59,916
quando atingimos o compilador ok, então estamos

18033
12:00:59,916 --> 12:01:02,800
alocando três matrizes no heap

18034
12:01:02,800 --> 12:01:04,880
Dinâmico e nós vamos ser

18035
12:01:04,880 --> 12:01:07,756
Armazenar os endereços para esses arrays

18036
12:01:07,756 --> 12:01:10,240
e esses ponteiros, por exemplo, p

18037
12:01:10,240 --> 12:01:12,640
Os salários vão armazenar o endereço

18038
12:01:12,640 --> 12:01:14,560
para esta matriz dinâmica que vai

18039
12:01:14,560 --> 12:01:16,400
Estou saindo no monte e está indo

18040
12:01:16,400 --> 12:01:18,560
para ser o mesmo caso para os alunos p aqui

18041
12:01:18,560 --> 12:01:20,880
e p pontuals Eu não acho que há muito

18042
12:01:20,880 --> 12:01:23,360
para explicar aqui porque já temos

18043
12:01:23,360 --> 12:01:25,040
Aprendendo sobre arrays que conhecemos sobre o

18044
12:01:25,040 --> 12:01:27,680
tamanho de um array, sabemos que é um

18045
12:01:27,680 --> 12:01:29,916
parte da localização da memória contígua que

18046
12:01:29,916 --> 12:01:32,000
vai armazenar variáveis do

18047
12:01:32,000 --> 12:01:33,520
O mesmo tipo é realmente o que somos

18048
12:01:33,520 --> 12:01:34,720
Vou ter

18049
12:01:34,720 --> 12:01:36,720
então vamos tentar compilar isso e ver

18050
12:01:36,720 --> 12:01:39,520
que realmente passa pelo nosso gcc

18051
12:01:39,520 --> 12:01:42,240
Compilador e vai funcionar bem

18052
12:01:42,240 --> 12:01:44,080
E outra coisa que você deve notar é

18053
12:01:44,080 --> 12:01:46,720
que isso está realmente compilando mesmo se

18054
12:01:46,720 --> 12:01:49,360
O que estamos usando para armazenar o tamanho de

18055
12:01:49,360 --> 12:01:52,640
a matriz não é const lembre-se para

18056
12:01:52,640 --> 12:01:55,040
matrizes de pilhas ou matrizes estáticas que nós

18057
12:01:55,040 --> 12:01:56,560
Tinha na pilha

18058
12:01:56,560 --> 12:01:58,720
Tivemos que ter certeza que esse cara aqui é

18059
12:01:58,720 --> 12:01:59,756
const

18060
12:01:59,756 --> 12:02:02,000
Tudo bem que foi

18061
12:02:02,000 --> 12:02:04,480
uma exigência e se você não cumpriu

18062
12:02:04,480 --> 12:02:07,276
que seu código não compilaria agora você

18063
12:02:07,276 --> 12:02:09,916
ver que com matrizes dinâmicas o código é

18064
12:02:09,916 --> 12:02:12,480
realmente compilando mesmo se não é custo

18065
12:02:12,480 --> 12:02:14,160
E isso é algo que você deveria ser

18066
12:02:14,160 --> 12:02:16,960
Conscientes de vamos construir isso de novo eu apenas

18067
12:02:16,960 --> 12:02:19,436
estragueis as minhas coisas aqui

18068
12:02:19,436 --> 12:02:22,320
E o mundo é bom se descermos e

18069
12:02:22,320 --> 12:02:23,756
Executá-lo, não vamos ver nada

18070
12:02:23,756 --> 12:02:26,400
Realmente porque não estamos tendo nenhum

18071
12:02:26,400 --> 12:02:28,640
saída neste programa, mas é assim que

18072
12:02:28,640 --> 12:02:30,160
Você pode alocar

18073
12:02:30,160 --> 12:02:33,680
espaço para uma matriz dinâmica na pilha

18074
12:02:33,680 --> 12:02:36,320
Agora vamos tentar imprimir alguns dos dados

18075
12:02:36,320 --> 12:02:38,560
Neste curso aqui vamos para baixo aqui

18076
12:02:38,560 --> 12:02:41,360
e realmente fazer isso nós vamos fazer

18077
12:02:41,360 --> 12:02:43,520
um no ponteiro porque queremos

18078
12:02:43,520 --> 12:02:45,276
Certifique-se de que a memória era realmente

18079
12:02:45,276 --> 12:02:48,000
alocado para a matriz de pontuações p

18080
12:02:48,000 --> 12:02:50,160
E depois que fazemos isso, vamos fazer loop

18081
12:02:50,160 --> 12:02:52,480
para os tempos de tamanho

18082
12:02:52,480 --> 12:02:54,080
e nós vamos imprimir qualquer coisa

18083
12:02:54,080 --> 12:02:56,880
O elemento é em cada iteração o índice

18084
12:02:56,880 --> 12:02:59,040
em cada iteração e você vê que nós

18085
12:02:59,040 --> 12:03:01,436
pode usar os suportes de ângulo

18086
12:03:01,436 --> 12:03:04,640
notação ou a aritmética do ponteiro

18087
12:03:04,640 --> 12:03:06,560
notação vai funcionar igualmente

18088
12:03:06,560 --> 12:03:07,360
Bem

18089
12:03:07,360 --> 12:03:08,960
Se nós construímos isso

18090
12:03:08,960 --> 12:03:10,800
Vamos trazer o nosso terminal, nós não temos

18091
12:03:10,800 --> 12:03:13,596
Abriu um e vamos descer e limpar

18092
12:03:13,596 --> 12:03:15,360
e correr o galo

18093
12:03:15,360 --> 12:03:16,800
Você vai ver isso

18094
12:03:16,800 --> 12:03:18,960
alocados com sucesso

18095
12:03:18,960 --> 12:03:20,640
memória para pontuações

18096
12:03:20,640 --> 12:03:22,880
e vamos imprimir os dados

18097
12:03:22,880 --> 12:03:25,756
primeiro usando a notação de faixas de ângulo

18098
12:03:25,756 --> 12:03:28,000
segundo usando aritmética do ponteiro e você

18099
12:03:28,000 --> 12:03:30,800
Veja que está funcionando muito bem

18100
12:03:30,800 --> 12:03:32,880
Uma coisa que você deveria ter notado agora é

18101
12:03:32,880 --> 12:03:34,480
que nós realmente não

18102
12:03:34,480 --> 12:03:36,160
Lançado a memória que temos

18103
12:03:36,160 --> 12:03:37,840
alocado aqui e isso é algo

18104
12:03:37,840 --> 12:03:39,756
É muito ruim, então vamos ver como nós

18105
12:03:39,756 --> 12:03:42,240
Podemos fazer isso, alocamos espaço para

18106
12:03:42,240 --> 12:03:45,436
Os salários dos alunos e pontuações assim vamos

18107
12:03:45,436 --> 12:03:47,276
descer e fazer isso e nós vamos

18108
12:03:47,276 --> 12:03:48,960
Diga exclua

18109
12:03:48,960 --> 12:03:50,720
e nós vamos ter suportes angulares

18110
12:03:50,720 --> 12:03:53,520
Porque este é um array que nós somos

18111
12:03:53,520 --> 12:03:56,480
liberar a memória para ou ser exato

18112
12:03:56,480 --> 12:03:59,360
matriz dinâmica que foi alocada no

18113
12:03:59,360 --> 12:04:01,916
monte assim vamos dizer p

18114
12:04:01,916 --> 12:04:03,680
os salários

18115
12:04:03,680 --> 12:04:06,640
e vamos redefinir esse ponteiro

18116
12:04:06,640 --> 12:04:09,360
para nenhum ponteiro porque somos bons c mais

18117
12:04:09,360 --> 12:04:11,840
além dos cidadãos, então vamos fazer isso

18118
12:04:11,840 --> 12:04:13,916
sem ponteiro e nós vamos fazer o

18119
12:04:13,916 --> 12:04:15,916
a mesma coisa delete

18120
12:04:15,916 --> 12:04:17,680
Estamos a apagar

18121
12:04:17,680 --> 12:04:20,320
espaço para uma matriz dinâmica para o ângulo

18122
12:04:20,320 --> 12:04:21,520
brackets aqui

18123
12:04:21,520 --> 12:04:24,400
os colchetes que devo dizer e nós

18124
12:04:24,400 --> 12:04:27,916
vamos excluir p alunos i think

18125
12:04:27,916 --> 12:04:30,800
Sim, então vamos dizer p estudante

18126
12:04:30,800 --> 12:04:32,960
e vamos dizer p estudantes e

18127
12:04:32,960 --> 12:04:35,520
nós vamos redefinir isso sem nenhum ponteiro

18128
12:04:35,520 --> 12:04:37,116
e vamos fazer o mesmo por p

18129
12:04:37,116 --> 12:04:38,880
Pontuações

18130
12:04:38,880 --> 12:04:42,160
Vamos pegar isso aqui que é o que queremos

18131
12:04:42,160 --> 12:04:44,080
Não, não é isso que queremos, estamos indo

18132
12:04:44,080 --> 12:04:46,480
para dizer excluir e dizer colchetes

18133
12:04:46,480 --> 12:04:48,000
nós mesmos e nós vamos dizer p

18134
12:04:48,000 --> 12:04:50,720
Pontuações e vamos liberar isso

18135
12:04:50,720 --> 12:04:52,960
e dizer p escores

18136
12:04:52,960 --> 12:04:56,080
e redefinir isso para o ponteiro nulo agora nós

18137
12:04:56,080 --> 12:04:57,916
estamos realmente jogando pelo seguro e nosso

18138
12:04:57,916 --> 12:05:00,320
O programa vai liberar a memória

18139
12:05:00,320 --> 12:05:02,480
que alocamos nestes três

18140
12:05:02,480 --> 12:05:03,840
Declarações aqui

18141
12:05:03,840 --> 12:05:05,680
Se construirmos o programa, ele vai

18142
12:05:05,680 --> 12:05:07,436
passar bem para que vamos construir

18143
12:05:07,436 --> 12:05:10,240
com o Gcc

18144
12:05:10,240 --> 12:05:13,040
E nós vamos limpar

18145
12:05:13,040 --> 12:05:15,916
e correr o galo e vai correr

18146
12:05:15,916 --> 12:05:17,680
Bem, você vê isso para a paz

18147
12:05:17,680 --> 12:05:18,720
cadáver

18148
12:05:18,720 --> 12:05:22,160
inicializamos os primeiros cinco elementos

18149
12:05:22,160 --> 12:05:24,160
E os restantes elementos foram

18150
12:05:24,160 --> 12:05:25,520
inicializado

18151
12:05:25,520 --> 12:05:28,080
implicitamente pelo compilador para zero e

18152
12:05:28,080 --> 12:05:29,756
você pode ver que aqui eu não acho que eu

18153
12:05:29,756 --> 12:05:32,000
explicou isso, mas esta é a minha chance de

18154
12:05:32,000 --> 12:05:33,680
Explique isso, espero que você entenda o

18155
12:05:33,680 --> 12:05:35,916
A próxima coisa que eu queria explorar antes de nós

18156
12:05:35,916 --> 12:05:37,596
fechar este vídeo é a diferença

18157
12:05:37,596 --> 12:05:40,080
entre matrizes estáticas e matrizes dinâmicas

18158
12:05:40,080 --> 12:05:42,480
uma matriz estática é um array que você aloca

18159
12:05:42,480 --> 12:05:44,320
na pilha como estamos fazendo

18160
12:05:44,320 --> 12:05:47,276
antes e você faz isso usando uma sintaxe como

18161
12:05:47,276 --> 12:05:49,840
Vamos dizer pontuações por que não e está indo

18162
12:05:49,840 --> 12:05:51,840
para ser um array que diz que vai

18163
12:05:51,840 --> 12:05:54,080
Contém 10 elementos

18164
12:05:54,080 --> 12:05:56,080
e vamos colocar em nossos valores em

18165
12:05:56,080 --> 12:05:57,840
O formato que conhecemos

18166
12:05:57,840 --> 12:06:00,080
e nós vamos todo o caminho para 10

18167
12:06:00,080 --> 12:06:01,840
Vamos colocar um 10 aqui e nós vamos

18168
12:06:01,840 --> 12:06:04,400
para terminar com um ponto e vírgula

18169
12:06:04,400 --> 12:06:06,640
Este array é legal e você pode loop

18170
12:06:06,640 --> 12:06:08,400
através dele você pode fazer todos os tipos de loucura

18171
12:06:08,400 --> 12:06:10,480
coisas com ele, mas eu vou

18172
12:06:10,480 --> 12:06:13,200
Enfatize duas diferenças que temos com

18173
12:06:13,200 --> 12:06:15,680
Dynamic arrays um é que este cara é

18174
12:06:15,680 --> 12:06:17,520
vou trabalhar com o tamanho sdd, então nós somos

18175
12:06:17,520 --> 12:06:19,436
Vou dizer a saída

18176
12:06:19,436 --> 12:06:21,360
Tudo bem, isso vai funcionar se compilarmos

18177
12:06:21,360 --> 12:06:22,720
Isto é

18178
12:06:22,720 --> 12:06:25,436
Vamos ter um bom mundo, pelo menos

18179
12:06:25,436 --> 12:06:27,680
Espero que sim, o mundo é bom e se nós

18180
12:06:27,680 --> 12:06:30,240
correr o galo

18181
12:06:30,240 --> 12:06:32,480
nós vamos obter pontuações o tamanho é

18182
12:06:32,480 --> 12:06:33,436
10.

18183
12:06:33,436 --> 12:06:35,436
A outra coisa é que você pode usar um

18184
12:06:35,436 --> 12:06:37,520
alcance baseado para loop para loop através

18185
12:06:37,520 --> 12:06:40,240
Este cara aqui, por exemplo, podemos dizer

18186
12:06:40,240 --> 12:06:41,360
para a

18187
12:06:41,360 --> 12:06:45,116
Auto score s para pontuação em pontuações

18188
12:06:45,116 --> 12:06:47,916
e vai funcionar, então vamos descer

18189
12:06:47,916 --> 12:06:50,000
e dizer o que estamos fazendo aqui ou podemos

18190
12:06:50,000 --> 12:06:52,960
até mesmo dizer uma única linha para separar a cerca

18191
12:06:52,960 --> 12:06:55,360
Aqui eu não quero estar confuso, então eu sou

18192
12:06:55,360 --> 12:06:57,436
Vou fazer algo assim para que

18193
12:06:57,436 --> 12:07:00,000
Eu sei onde minha saída aqui vai

18194
12:07:00,000 --> 12:07:01,276
começar

18195
12:07:01,276 --> 12:07:03,840
então eu vou construir isso

18196
12:07:03,840 --> 12:07:07,200
com gcc, claro, o mundo vai

18197
12:07:07,200 --> 12:07:08,880
passar por aí

18198
12:07:08,880 --> 12:07:10,640
E se eu limpar

18199
12:07:10,640 --> 12:07:12,320
e correr o galo

18200
12:07:12,320 --> 12:07:14,480
Eu vou ver que o tamanho é 10

18201
12:07:14,480 --> 12:07:17,360
e vou imprimir meus elementos aqui

18202
12:07:17,360 --> 12:07:21,040
com uma gama baseada para loop

18203
12:07:21,040 --> 12:07:23,200
OK, vamos ver como essas coisas se comportam

18204
12:07:23,200 --> 12:07:25,436
Quando usamos uma matriz dinâmica, estamos indo

18205
12:07:25,436 --> 12:07:28,720
para configurar uma matriz semelhante, mas no quadril

18206
12:07:28,720 --> 12:07:31,436
que vai deixar no quadril isso

18207
12:07:31,436 --> 12:07:33,520
array aqui é o array estático em que

18208
12:07:33,520 --> 12:07:35,360
ele vai viver na pilha você

18209
12:07:35,360 --> 12:07:37,360
tem que estar ciente dessas diferenças

18210
12:07:37,360 --> 12:07:38,960
Tudo bem, vamos fazer outro que

18211
12:07:38,960 --> 12:07:40,640
Vai sair na pilha e no

18212
12:07:40,640 --> 12:07:43,040
Como fazemos isso, dizemos ponto final, vamos

18213
12:07:43,040 --> 12:07:45,360
Diga p pontua um para se certificar de que este é

18214
12:07:45,360 --> 12:07:47,436
diferente dos quadrados p que temos

18215
12:07:47,436 --> 12:07:49,116
No topo e vamos ter 10

18216
12:07:49,116 --> 12:07:51,276
Elementos dentro e podemos até

18217
12:07:51,276 --> 12:07:53,840
inicialize esse cara exatamente como nós somos

18218
12:07:53,840 --> 12:07:56,560
fazendo aqui, mas os dados não vão

18219
12:07:56,560 --> 12:07:58,640
Deixe na pilha os dados vão

18220
12:07:58,640 --> 12:08:00,160
leave on the heap

18221
12:08:00,160 --> 12:08:02,960
Se fizermos algo assim primeiro, vamos

18222
12:08:02,960 --> 12:08:04,720
Certifique-se de que o código compila que nós somos

18223
12:08:04,720 --> 12:08:06,800
Vou tentar e correr isso

18224
12:08:06,800 --> 12:08:08,320
através do gcc

18225
12:08:08,320 --> 12:08:10,640
e observe a saída do compilador aqui o

18226
12:08:10,640 --> 12:08:12,960
O parafuso é bom, então este é válido c plus

18227
12:08:12,960 --> 12:08:14,400
mais o código

18228
12:08:14,400 --> 12:08:17,596
nós podemos tentar e usar o tamanho do hdd sobre isso e

18229
12:08:17,596 --> 12:08:21,040
nós vamos descer e fazer isso

18230
12:08:21,360 --> 12:08:24,080
e se fizermos isso, vamos dizer p

18231
12:08:24,080 --> 12:08:26,560
Tamanho das pontuações

18232
12:08:26,560 --> 12:08:29,596
um tamanho e dizer p escores se tentarmos

18233
12:08:29,596 --> 12:08:31,436
Passe este ponteiro aqui você vai

18234
12:08:31,436 --> 12:08:33,520
Veja que o código visual do estúdio está indo para

18235
12:08:33,520 --> 12:08:36,240
surtar porque isso não vai funcionar

18236
12:08:36,240 --> 12:08:37,436
O que é

18237
12:08:37,436 --> 12:08:40,880
A matriz aqui decaiu em um ponteiro

18238
12:08:40,880 --> 12:08:43,680
quando nos referimos a ele usando um ponteiro de linha

18239
12:08:43,680 --> 12:08:46,000
Como isso, então não podemos realmente usá-lo

18240
12:08:46,000 --> 12:08:48,800
dentro do std tamanho

18241
12:08:48,800 --> 12:08:50,480
então, se olharmos para isso, vamos conseguir

18242
12:08:50,480 --> 12:08:53,040
um estranho erro do compilador, mas isso está acontecendo

18243
12:08:53,040 --> 12:08:54,880
para ser o problema aqui

18244
12:08:54,880 --> 12:08:57,200
Tudo bem para que você não possa fazer isso com dinâmica

18245
12:08:57,200 --> 12:09:00,160
arrays este é uma limitação do outro

18246
12:09:00,160 --> 12:09:03,040
é que você não pode usar arrays dinâmicos

18247
12:09:03,040 --> 12:09:06,160
Como estamos usando um alcance baseado em loop

18248
12:09:06,160 --> 12:09:09,680
Aqui, então se pegarmos este loop e tentarmos

18249
12:09:09,680 --> 12:09:12,720
trabalhar com ele em pontuações de p, por exemplo

18250
12:09:12,720 --> 12:09:14,960
Isso é algo que alguém pode querer

18251
12:09:14,960 --> 12:09:15,680
- É assim.

18252
12:09:15,680 --> 12:09:16,680
Vamos dizer que

18253
12:09:16,680 --> 12:09:19,596
As pontuações1 OK e tentar imprimir algo

18254
12:09:19,596 --> 12:09:21,040
Dentro você vai ver que isso é

18255
12:09:21,040 --> 12:09:23,040
não vai funcionar os visuais do compilador

18256
12:09:23,040 --> 12:09:25,596
Vídeo não vai gostar primeiro

18257
12:09:25,596 --> 12:09:29,840
e se tentarmos e executar isso através do gcc

18258
12:09:29,840 --> 12:09:31,840
nós também vamos ter um compilador estranho

18259
12:09:31,840 --> 12:09:34,000
A flecha e o problema vão ser

18260
12:09:34,000 --> 12:09:37,040
que as pontuações de p não são realmente uma matriz

18261
12:09:37,040 --> 12:09:39,276
é apenas um ponteiro que está apontando para

18262
12:09:39,276 --> 12:09:42,000
alguma localização na memória que é tudo que é

18263
12:09:42,000 --> 12:09:44,480
e não tem informações que

18264
12:09:44,480 --> 12:09:46,720
poderia ser usado de outra forma para loop através

18265
12:09:46,720 --> 12:09:47,756
Elementos

18266
12:09:47,756 --> 12:09:52,000
como nós podemos fazer para uma verdadeira matriz estática

18267
12:09:52,000 --> 12:09:54,800
que está saindo na pilha novamente, vamos

18268
12:09:54,800 --> 12:09:57,360
ser super claro aqui e dizer que isso

18269
12:09:57,360 --> 12:09:59,916
A matriz vai sair

18270
12:09:59,916 --> 12:10:02,000
no monte você tem que entender estes

18271
12:10:02,000 --> 12:10:04,080
coisas, mas isso não é realmente um grande

18272
12:10:04,080 --> 12:10:06,880
limitação porque você pode armazenar o

18273
12:10:06,880 --> 12:10:09,116
tamanho desse cara em alguma variável e

18274
12:10:09,116 --> 12:10:11,360
Consulte-o se precisar disso e puder

18275
12:10:11,360 --> 12:10:13,436
loop através da matriz exatamente como nós

18276
12:10:13,436 --> 12:10:15,840
fez aqui usando o tamanho e ele vai

18277
12:10:15,840 --> 12:10:18,480
Trabalhe muito bem, então não tenha medo

18278
12:10:18,480 --> 12:10:20,880
Armazene suas matrizes no monte se isso for

18279
12:10:20,880 --> 12:10:23,200
O que você precisa na sua aplicação é

18280
12:10:23,200 --> 12:10:25,116
indo trabalhar muito bem você só tem

18281
12:10:25,116 --> 12:10:28,080
estar ciente de algumas limitações que

18282
12:10:28,080 --> 12:10:31,840
Venha fazer as coisas dessa maneira aqui

18283
12:10:31,840 --> 12:10:33,596
Isso é realmente tudo o que nos prossamos fazer em

18284
12:10:33,596 --> 12:10:35,360
Esta palestra espero que você tenha um melhor

18285
12:10:35,360 --> 12:10:38,560
ideia sobre matrizes dinâmicas que você define

18286
12:10:38,560 --> 12:10:40,960
Assim como este tamanho aqui não tem

18287
12:10:40,960 --> 12:10:43,360
para ser um custo como temos com estática

18288
12:10:43,360 --> 12:10:45,840
arrays e eles têm algumas diferenças

18289
12:10:45,840 --> 12:10:48,480
comparados com matrizes estáticas que foram

18290
12:10:48,480 --> 12:10:51,756
armazenado na pilha e nesse tamanho std

18291
12:10:51,756 --> 12:10:53,756
não funciona para eles e eles não

18292
12:10:53,756 --> 12:10:57,200
trabalho com alcance baseado em loops outros

18293
12:10:57,200 --> 12:10:59,916
do que que as matrizes dinâmicas são ridicularizados

18294
12:10:59,916 --> 12:11:02,480
e você deve usá-los quando isso ajuda

18295
12:11:02,480 --> 12:11:04,640
O que quer que você esteja projetando

18296
12:11:04,640 --> 12:11:07,276
Seja bem-vindo a este novo capítulo onde estamos

18297
12:11:07,276 --> 12:11:10,320
Vou falar de referências

18298
12:11:10,320 --> 12:11:12,480
As referências são uma maneira que você pode configurar

18299
12:11:12,480 --> 12:11:15,680
alianças para suas variáveis e ter

18300
12:11:15,680 --> 12:11:18,240
Outros nomes de variáveis que você pode passar

18301
12:11:18,240 --> 12:11:21,116
para modificar essa mesma variável, por exemplo

18302
12:11:21,116 --> 12:11:23,436
Aqui temos uma variável chamada var que é

18303
12:11:23,436 --> 12:11:25,840
um inteiro que deixa neste endereço

18304
12:11:25,840 --> 12:11:29,436
Aqui e o valor dentro é 33.

18305
12:11:29,436 --> 12:11:32,560
se estabelecermos outra aliança com ela como

18306
12:11:32,560 --> 12:11:35,596
var elias nós podemos passar por esta var

18307
12:11:35,596 --> 12:11:38,880
elias variável e usá-lo em praticamente

18308
12:11:38,880 --> 12:11:40,640
Da mesma forma que usamos o original

18309
12:11:40,640 --> 12:11:42,560
Valor e isso vai entrar

18310
12:11:42,560 --> 12:11:45,840
dissimcio em muitas situações como somos sobre

18311
12:11:45,840 --> 12:11:48,320
para ver neste capítulo vamos

18312
12:11:48,320 --> 12:11:50,320
começar na próxima palestra e ver como nós

18313
12:11:50,320 --> 12:11:52,400
pode declarar inicializar e usar

18314
12:11:52,400 --> 12:11:54,400
referências em nosso c plus plus

18315
12:11:54,400 --> 12:11:55,680
As aplicações

18316
12:11:55,680 --> 12:11:58,000
Vá em frente e termine aqui e me encontre

18317
12:11:58,000 --> 12:11:59,916
lá nesta palestra vamos ver

18318
12:11:59,916 --> 12:12:02,720
como podemos declarar e usar referências em

18319
12:12:02,720 --> 12:12:05,916
nossa aplicação c plus novamente uma referência

18320
12:12:05,916 --> 12:12:09,040
é uma variável elias que você pode usar para

18321
12:12:09,040 --> 12:12:11,520
fazer referência a uma variável e usar originais

18322
12:12:11,520 --> 12:12:13,680
essa referência em praticamente o mesmo

18323
12:12:13,680 --> 12:12:16,800
Como você usa a variável original vamos

18324
12:12:16,800 --> 12:12:19,276
Veja como isso pode funcionar em c plus plus

18325
12:12:19,276 --> 12:12:21,520
Aqui está um exemplo simples, temos dois

18326
12:12:21,520 --> 12:12:24,720
variáveis um é um inteiro temos 45 n

18327
12:12:24,720 --> 12:12:28,160
O outro é um duplo que temos 33.65

18328
12:12:28,160 --> 12:12:28,960
n

18329
12:12:28,960 --> 12:12:31,200
Queremos estabelecer referências a este

18330
12:12:31,200 --> 12:12:33,756
A variável e a sintaxe é ridiculamente

18331
12:12:33,756 --> 12:12:34,720
fácil de usar

18332
12:12:34,720 --> 12:12:37,040
para o valor de borda sua referência é

18333
12:12:37,040 --> 12:12:39,840
Vai ser algo como ampersand

18334
12:12:39,840 --> 12:12:42,640
Você coloca o ampersand símbolo que você diz o

18335
12:12:42,640 --> 12:12:45,040
nome da referência e inicializa

18336
12:12:45,040 --> 12:12:48,080
Isso com o valor na variável que

18337
12:12:48,080 --> 12:12:50,240
você quer que isso faça referência tão referência

18338
12:12:50,240 --> 12:12:52,400
para h valor vai estar referenciando

18339
12:12:52,400 --> 12:12:54,960
nosso inteiro aqui e podemos usar isso

18340
12:12:54,960 --> 12:12:58,880
nome para referência a esta variável aqui e

18341
12:12:58,880 --> 12:13:00,800
Será como se estamos usando o

18342
12:13:00,800 --> 12:13:03,276
variável original que é o intervalo aqui

18343
12:13:03,276 --> 12:13:04,640
nós vamos ver como isso funciona em um

18344
12:13:04,640 --> 12:13:06,640
minuto podemos fazer o mesmo usando

18345
12:13:06,640 --> 12:13:09,200
Inicialização de atribuição e aqui em baixo

18346
12:13:09,200 --> 12:13:11,116
Veja que temos um exemplo para

18347
12:13:11,116 --> 12:13:13,436
duplo valor e temos uma referência a

18348
12:13:13,436 --> 12:13:15,680
Uma vez que temos essas referências, podemos

18349
12:13:15,680 --> 12:13:17,680
Use como usamos

18350
12:13:17,680 --> 12:13:19,436
As variáveis originais, por exemplo, se

18351
12:13:19,436 --> 12:13:20,960
Você vem aqui, você vê que estamos imprimindo

18352
12:13:20,960 --> 12:13:23,116
coisas para fora se imprimirmos qualquer valor que nós somos

18353
12:13:23,116 --> 12:13:25,276
Vou obter o valor impresso se nós

18354
12:13:25,276 --> 12:13:26,720
imprimir duplo valor que vamos obter

18355
12:13:26,720 --> 12:13:28,880
o valor impresso para fora nós podemos igualmente imprimir

18356
12:13:28,880 --> 12:13:30,240
através de referências você vai ver

18357
12:13:30,240 --> 12:13:32,080
que eles vão imprimir exatamente o

18358
12:13:32,080 --> 12:13:34,720
O mesmo valor que temos no original

18359
12:13:34,720 --> 12:13:36,000
As variáveis

18360
12:13:36,000 --> 12:13:38,560
Mas o interessante vai ser

18361
12:13:38,560 --> 12:13:39,360
que

18362
12:13:39,360 --> 12:13:41,520
se você imprimir os endereços através do

18363
12:13:41,520 --> 12:13:44,640
valores originais e imprimir os endereços

18364
12:13:44,640 --> 12:13:46,560
através das referências que você vai

18365
12:13:46,560 --> 12:13:49,040
obter os mesmos endereços impressos quais

18366
12:13:49,040 --> 12:13:51,680
vai realmente dizer isso para variável

18367
12:13:51,680 --> 12:13:55,116
Os nomes são quase exatamente a mesma coisa

18368
12:13:55,116 --> 12:13:57,360
em c plus plus e isso é muito legal

18369
12:13:57,360 --> 12:14:00,000
você pode usar a referência como se você é

18370
12:14:00,000 --> 12:14:02,640
usando o nome da variável original em seu

18371
12:14:02,640 --> 12:14:05,116
c plus código que vamos até tentar

18372
12:14:05,116 --> 12:14:06,880
e passar pelos tamanhos e imprimi-los

18373
12:14:06,880 --> 12:14:08,080
fora e você vai ver que eles

18374
12:14:08,080 --> 12:14:10,400
Vai ser exatamente a mesma coisa

18375
12:14:10,400 --> 12:14:12,240
e vamos ver o quão importante

18376
12:14:12,240 --> 12:14:15,040
isso pode tornar-se em c plus código como

18377
12:14:15,040 --> 12:14:16,960
nós passamos por este capítulo ok agora que

18378
12:14:16,960 --> 12:14:19,436
nós temos a referência declarada que podemos ir

18379
12:14:19,436 --> 12:14:21,916
através disso e modificar o valor e se

18380
12:14:21,916 --> 12:14:24,160
Fazemos que as mudanças sejam

18381
12:14:24,160 --> 12:14:27,116
refletido nas variáveis originais e

18382
12:14:27,116 --> 12:14:29,116
Se imprimirmos coisas assim novamente, estamos

18383
12:14:29,116 --> 12:14:31,040
Vou ver que as mudanças estão acontecendo

18384
12:14:31,040 --> 12:14:33,360
refletir-se no original

18385
12:14:33,360 --> 12:14:36,080
variáveis bem se você modificar o

18386
12:14:36,080 --> 12:14:38,640
variável original As mudanças também são

18387
12:14:38,640 --> 12:14:41,116
Será refletido em nossas referências

18388
12:14:41,116 --> 12:14:43,276
E isso é exatamente o que nós esperamos

18389
12:14:43,276 --> 12:14:45,360
de nossas referências ok, então isso é

18390
12:14:45,360 --> 12:14:47,276
Realmente tudo o que há sobre referências

18391
12:14:47,276 --> 12:14:49,840
são alianças com suas variáveis e

18392
12:14:49,840 --> 12:14:51,756
Você pode usá-los praticamente da mesma forma

18393
12:14:51,756 --> 12:14:54,160
Como você usa suas variáveis, vamos cabeça

18394
12:14:54,160 --> 12:14:56,640
mais para o código de estúdio visual e veja alguns

18395
12:14:56,640 --> 12:14:59,520
dessas coisas em ação aqui estamos em

18396
12:14:59,520 --> 12:15:02,080
nosso diretório de trabalho o capítulo é

18397
12:15:02,080 --> 12:15:04,640
As referências e a palestra estão declarando

18398
12:15:04,640 --> 12:15:06,880
e usando referências que vamos

18399
12:15:06,880 --> 12:15:09,596
pegue nossos arquivos de modelo aqui

18400
12:15:09,596 --> 12:15:12,080
e nós vamos colocá-los no lugar e

18401
12:15:12,080 --> 12:15:14,240
Vamos abrir isso em visual

18402
12:15:14,240 --> 12:15:16,400
Código de estúdio vamos configurar um novo

18403
12:15:16,400 --> 12:15:19,276
variable, vamos chamar esses dados ou é

18404
12:15:19,276 --> 12:15:21,520
Os dados serão muito mais

18405
12:15:21,520 --> 12:15:23,276
Descritivo e nós vamos

18406
12:15:23,276 --> 12:15:26,560
inicialize isso com um 33 por que não e

18407
12:15:26,560 --> 12:15:28,560
Vamos fazer um duplo e dizer

18408
12:15:28,560 --> 12:15:31,360
dados duplos e vamos colocar em um

18409
12:15:31,360 --> 12:15:32,960
55 em 5

18410
12:15:32,960 --> 12:15:34,800
e vamos criar referências a

18411
12:15:34,800 --> 12:15:36,800
Essas variáveis

18412
12:15:36,800 --> 12:15:39,680
e novamente uma referência é um elias que

18413
12:15:39,680 --> 12:15:41,840
Você pode usar da mesma maneira

18414
12:15:41,840 --> 12:15:44,000
você usa a variável original, então nós somos

18415
12:15:44,000 --> 12:15:46,240
criar uma referência aos dados int

18416
12:15:46,240 --> 12:15:47,596
nós vamos dizer

18417
12:15:47,596 --> 12:15:49,200
E a

18418
12:15:49,200 --> 12:15:51,596
referência média referência, colocando o

18419
12:15:51,596 --> 12:15:54,560
ampersand símbolo aqui e nós vamos

18420
12:15:54,560 --> 12:15:55,756
Diga áspero

18421
12:15:55,756 --> 12:15:56,880
E a

18422
12:15:56,880 --> 12:16:00,240
Sim e você inicializa isso

18423
12:16:00,240 --> 12:16:03,436
com o nome da variável que você quer isso

18424
12:16:03,436 --> 12:16:05,680
Referência à referência

18425
12:16:05,680 --> 12:16:07,840
E uh aqui queremos fazer referência a

18426
12:16:07,840 --> 12:16:10,480
Dados para que possamos passar para dados

18427
12:16:10,480 --> 12:16:12,800
e esta será a nossa referência

18428
12:16:12,800 --> 12:16:14,560
É declarado que podemos fazer o mesmo para

18429
12:16:14,560 --> 12:16:16,800
Dados duplos, então vamos fazer isso

18430
12:16:16,800 --> 12:16:18,400
dobro e vamos dizer que é um

18431
12:16:18,400 --> 12:16:20,480
referência, vamos dizer áspero

18432
12:16:20,480 --> 12:16:22,720
Dados duplos e vamos fazer referência

18433
12:16:22,720 --> 12:16:25,596
devo dados aqui, então vamos fazer isso ok

18434
12:16:25,596 --> 12:16:28,000
vamos trazer o nosso terminal e ver se

18435
12:16:28,000 --> 12:16:29,680
Podemos compilar este código aqui estamos

18436
12:16:29,680 --> 12:16:32,480
vamos compilar com gcc como sempre

18437
12:16:32,480 --> 12:16:35,360
faça e vamos fechar isso então à esquerda

18438
12:16:35,360 --> 12:16:37,756
Porque ele se levanta

18439
12:16:37,756 --> 12:16:40,800
Alguns do espaço aqui o mundo é bom

18440
12:16:40,800 --> 12:16:43,200
assim, esta sintaxe é válida c plus plus

18441
12:16:43,200 --> 12:16:44,400
Sintaxe

18442
12:16:44,400 --> 12:16:47,756
O que podemos fazer é ler valores a partir de

18443
12:16:47,756 --> 12:16:49,680
todas essas coisas e mostrar que

18444
12:16:49,680 --> 12:16:51,756
São realmente as mesmas coisas, então nós somos

18445
12:16:51,756 --> 12:16:54,000
Vou imprimir coisas e eu vou

18446
12:16:54,000 --> 12:16:56,240
para colocar aqui algum código e eu vou

18447
12:16:56,240 --> 12:16:58,560
Volte quando eu digitei isso eu não

18448
12:16:58,560 --> 12:17:01,116
Quer que você sofra me assistindo tipo

18449
12:17:01,116 --> 12:17:03,680
Essas coisas estão bem aqui eu tenho o código

18450
12:17:03,680 --> 12:17:05,756
digite para baixo e você vê que eu sou apenas

18451
12:17:05,756 --> 12:17:08,400
indo para imprimir dana através do original

18452
12:17:08,400 --> 12:17:10,400
variáveis que vou imprimir o real

18453
12:17:10,400 --> 12:17:12,480
dados e imprimir o endereço do

18454
12:17:12,480 --> 12:17:15,116
variável e fazer o mesmo para dobo

18455
12:17:15,116 --> 12:17:17,680
Dados que são do tipo duplo

18456
12:17:17,680 --> 12:17:20,000
Como é conveniente e vamos imprimir

18457
12:17:20,000 --> 12:17:21,360
referências que vamos imprimir o

18458
12:17:21,360 --> 12:17:23,200
referência e endereço do

18459
12:17:23,200 --> 12:17:25,200
referência e vamos fazer o mesmo

18460
12:17:25,200 --> 12:17:28,560
coisa para os nossos dados de diabo aqui vamos

18461
12:17:28,560 --> 12:17:31,916
Tente e construa isso com gcc

18462
12:17:31,916 --> 12:17:33,840
então vamos executar a tarefa a fazer

18463
12:17:33,840 --> 12:17:35,276
que

18464
12:17:35,276 --> 12:17:37,596
E nós vamos limpar que o livro é

18465
12:17:37,596 --> 12:17:40,480
bom e correr galo se corrermos o galo

18466
12:17:40,480 --> 12:17:43,040
Você vê que vamos colocar um fim separado

18467
12:17:43,040 --> 12:17:44,800
linha aqui para que vejamos o todo

18468
12:17:44,800 --> 12:17:45,916
tal coisa assim

18469
12:17:45,916 --> 12:17:49,040
Eu realmente gosto de ver meus fãs facilmente

18470
12:17:49,040 --> 12:17:51,276
então vamos fazer isso e construir novamente ok

18471
12:17:51,276 --> 12:17:53,276
a construção é boa nós podemos limpar e correr

18472
12:17:53,276 --> 12:17:55,520
Galo agora e vamos ver o

18473
12:17:55,520 --> 12:17:59,360
Os dados e dados originais são 33 do endereço

18474
12:17:59,360 --> 12:18:02,400
Este cara aqui temos dados de demonstração

18475
12:18:02,400 --> 12:18:05,276
O valor é 55 e este é o endereço se

18476
12:18:05,276 --> 12:18:07,040
Olhemos para as nossas referências que temos

18477
12:18:07,040 --> 12:18:09,116
exatamente a mesma coisa que os endereços são

18478
12:18:09,116 --> 12:18:11,596
Mesmo assim é como nós somos

18479
12:18:11,596 --> 12:18:13,360
usando a variável original e esta é

18480
12:18:13,360 --> 12:18:16,080
Muito legal pode permitir que você passe

18481
12:18:16,080 --> 12:18:18,720
Dados em torno de muito facilmente

18482
12:18:18,720 --> 12:18:21,040
Usando referências e o que você é

18483
12:18:21,040 --> 12:18:23,360
usando quando você enviou esses dados para

18484
12:18:23,360 --> 12:18:25,276
exemplo para outro arquivo ou outro

18485
12:18:25,276 --> 12:18:27,360
Função que você vai ser

18486
12:18:27,360 --> 12:18:29,680
afetando os mesmos dados, então você está

18487
12:18:29,680 --> 12:18:31,756
Não vou fazer cópias e nós

18488
12:18:31,756 --> 12:18:33,916
Vou ver o quão frio isso pode ser

18489
12:18:33,916 --> 12:18:36,000
Especialmente quando começamos a trabalhar com

18490
12:18:36,000 --> 12:18:38,640
funções isso vai ser super legal

18491
12:18:38,640 --> 12:18:40,800
Tudo bem agora nós vimos que o

18492
12:18:40,800 --> 12:18:43,520
As referências estão realmente referenciando o

18493
12:18:43,520 --> 12:18:46,400
Os valores originais, vamos tentar modificar o

18494
12:18:46,400 --> 12:18:48,080
Os dados através de

18495
12:18:48,080 --> 12:18:50,080
os valores originais e ver que

18496
12:18:50,080 --> 12:18:51,436
As referências vão pegar o

18497
12:18:51,436 --> 12:18:53,436
Mudanças, vamos fazer isso, vamos

18498
12:18:53,436 --> 12:18:56,436
tomar 80 dados e alterar isso para

18499
12:18:56,436 --> 12:18:58,960
111 e nós vamos levar a maçã

18500
12:18:58,960 --> 12:19:03,360
dados e alterações para 67.2

18501
12:19:03,360 --> 12:19:05,200
Por que não e depois de fazermos isso, vamos

18502
12:19:05,200 --> 12:19:07,436
para imprimir os dados novamente para que vamos

18503
12:19:07,436 --> 12:19:10,160
Pegue o código aqui

18504
12:19:10,160 --> 12:19:11,520
E a

18505
12:19:11,520 --> 12:19:13,596
Use isso novamente aqui e devemos ver

18506
12:19:13,596 --> 12:19:15,916
As mesmas alterações aplicadas

18507
12:19:15,916 --> 12:19:18,720
Então nós vamos soldar com dcc o parafuso

18508
12:19:18,720 --> 12:19:20,320
Vai ser bom

18509
12:19:20,320 --> 12:19:23,276
Como você vê aqui e se nós limpamos e corremos

18510
12:19:23,276 --> 12:19:24,640
Galo

18511
12:19:24,640 --> 12:19:26,880
nós vamos ver isso

18512
12:19:26,880 --> 12:19:30,320
O valor é 55 vamos colocar uma separação

18513
12:19:30,320 --> 12:19:33,200
linha aqui esta é apertada e é

18514
12:19:33,200 --> 12:19:35,276
É realmente difícil ver o que está acontecendo

18515
12:19:35,276 --> 12:19:39,916
aqui, então eu vou colocar um std endl em

18516
12:19:39,916 --> 12:19:43,596
aqui e soldar novamente então vamos fazer isso e

18517
12:19:43,596 --> 12:19:46,000
O livro é bom para que possamos limpar e correr

18518
12:19:46,000 --> 12:19:48,400
Galo novamente e agora vemos as coisas

18519
12:19:48,400 --> 12:19:50,800
Separados e é mais fácil no

18520
12:19:50,800 --> 12:19:53,596
olho aqui temos dados vazios para b33 e

18521
12:19:53,596 --> 12:19:56,320
Os dados do depósito são 55 e nós vamos

18522
12:19:56,320 --> 12:19:58,080
Imprimir nossas referências que vão

18523
12:19:58,080 --> 12:20:00,080
pegue as mesmas coisas porque a

18524
12:20:00,080 --> 12:20:02,880
A referência é realmente analisada para

18525
12:20:02,880 --> 12:20:05,116
as variáveis originais, mas se você for

18526
12:20:05,116 --> 12:20:06,640
para baixo você vai ver que os dados

18527
12:20:06,640 --> 12:20:08,720
Na verdade, mudou e juntos

18528
12:20:08,720 --> 12:20:10,800
Mudou para 111

18529
12:20:10,800 --> 12:20:14,560
e nabodana mudou para 67.2

18530
12:20:14,560 --> 12:20:16,560
O interessante é que o

18531
12:20:16,560 --> 12:20:18,800
As referências também os captaram

18532
12:20:18,800 --> 12:20:20,720
mudanças porque realmente são

18533
12:20:20,720 --> 12:20:22,640
Referindo as mesmas coisas na memória

18534
12:20:22,640 --> 12:20:24,240
É como se estamos usando o original

18535
12:20:24,240 --> 12:20:26,800
variável para

18536
12:20:26,800 --> 12:20:29,200
Leia essas coisas como estamos fazendo com

18537
12:20:29,200 --> 12:20:31,116
Referências aqui e isso é muito legal

18538
12:20:31,116 --> 12:20:33,040
Aqui usamos as variáveis originais

18539
12:20:33,040 --> 12:20:35,360
para modificar dados, mas também podemos modificar

18540
12:20:35,360 --> 12:20:37,116
os dados através de referências e

18541
12:20:37,116 --> 12:20:38,960
As variáveis originais vão pegar

18542
12:20:38,960 --> 12:20:40,960
Essas mudanças, então vamos fazer isso

18543
12:20:40,960 --> 12:20:43,360
vamos dizer dados de ref e nós vamos

18544
12:20:43,360 --> 12:20:45,040
Mudar isso para

18545
12:20:45,040 --> 12:20:47,680
12, por exemplo,

18546
12:20:47,680 --> 12:20:50,560
e vamos usar

18547
12:20:50,840 --> 12:20:53,680
1014 ou 12. Isto vai fazer

18548
12:20:53,680 --> 12:20:57,040
indo para fazer dados duplos ref e colocar em

18549
12:20:57,040 --> 12:21:00,960
Outro grande número vamos dizer 1000.45

18550
12:21:00,960 --> 12:21:02,880
Por que não e vamos imprimir o

18551
12:21:02,880 --> 12:21:04,840
Dados novamente, então vamos pegar

18552
12:21:04,840 --> 12:21:08,560
Isso e imprimir coisas de novo, então estamos

18553
12:21:08,560 --> 12:21:10,720
indo para baixo e colocar no código para

18554
12:21:10,720 --> 12:21:12,320
imprimir coisas e você vê que vai

18555
12:21:12,320 --> 12:21:14,080
Use as variáveis originais e

18556
12:21:14,080 --> 12:21:16,800
referências e devemos ver as mudanças

18557
12:21:16,800 --> 12:21:19,116
refletido em nosso terminal aqui

18558
12:21:19,116 --> 12:21:20,560
então vamos fazer isso

18559
12:21:20,560 --> 12:21:23,520
e nós vamos soldar com gcc como nós

18560
12:21:23,520 --> 12:21:24,640
Sempre faça

18561
12:21:24,640 --> 12:21:26,320
A bala vai ser legal nós somos

18562
12:21:26,320 --> 12:21:28,640
indo para limpar e correr galo, nós somos

18563
12:21:28,640 --> 12:21:31,916
Vamos ver que temos 33 e 55 a

18564
12:21:31,916 --> 12:21:33,680
As referências vão pegar isso

18565
12:21:33,680 --> 12:21:35,596
Isso é o que temos aqui vamos

18566
12:21:35,596 --> 12:21:36,680
colocar em in

18567
12:21:36,680 --> 12:21:39,596
111 e 67 através do original

18568
12:21:39,596 --> 12:21:41,520
As variáveis e as referências estão indo

18569
12:21:41,520 --> 12:21:43,596
para estar pegando isso e nós vamos

18570
12:21:43,596 --> 12:21:46,320
usar referências e modificar dados que você vê

18571
12:21:46,320 --> 12:21:48,800
que as variáveis originais também são

18572
12:21:48,800 --> 12:21:51,116
pegando isso porque nós somos realmente

18573
12:21:51,116 --> 12:21:53,436
Modificar dados na mesma memória

18574
12:21:53,436 --> 12:21:55,680
localização é por isso que essas mudanças são

18575
12:21:55,680 --> 12:21:57,840
sendo compartilhado entre referências e

18576
12:21:57,840 --> 12:22:00,000
variáveis originais e isso é realmente

18577
12:22:00,000 --> 12:22:01,596
Tudo o que nos referimos a fazer nesta palestra para

18578
12:22:01,596 --> 12:22:03,680
mostrar como você pode configurar uma referência

18579
12:22:03,680 --> 12:22:06,400
e provar que as mudanças que fazemos

18580
12:22:06,400 --> 12:22:09,040
através de dados originais ou referências são

18581
12:22:09,040 --> 12:22:11,276
refletido entre esses dois caras significando

18582
12:22:11,276 --> 12:22:13,596
As referências e a original

18583
12:22:13,596 --> 12:22:14,880
As variáveis

18584
12:22:14,880 --> 12:22:16,480
Vamos parar aqui neste

18585
12:22:16,480 --> 12:22:18,000
palestra no próximo, vamos

18586
12:22:18,000 --> 12:22:20,560
fazer uma comparação entre ponteiros e

18587
12:22:20,560 --> 12:22:23,360
referências porque parecem estar fazendo

18588
12:22:23,360 --> 12:22:25,116
E a mesma coisa

18589
12:22:25,116 --> 12:22:27,040
Vá em frente e termine aqui

18590
12:22:27,040 --> 12:22:29,360
e encontrar-me lá e esta palestra nós somos

18591
12:22:29,360 --> 12:22:32,080
Vou olhar para as semelhanças

18592
12:22:32,080 --> 12:22:34,240
As diferenças entre referências

18593
12:22:34,240 --> 12:22:36,640
e ponteiros estão bem, sabemos que um ponteiro

18594
12:22:36,640 --> 12:22:38,480
É realmente algo que vai

18595
12:22:38,480 --> 12:22:40,880
armazenar o endereço da variável e nós

18596
12:22:40,880 --> 12:22:43,276
pode passar por esse ponteiro e modificar

18597
12:22:43,276 --> 12:22:45,596
a variável original ou realmente fazer

18598
12:22:45,596 --> 12:22:47,596
Coisas com isso, mas na última palestra

18599
12:22:47,596 --> 12:22:49,680
Vimos que também poderíamos fazer o mesmo

18600
12:22:49,680 --> 12:22:52,560
coisa com referências, então por que fazer isso

18601
12:22:52,560 --> 12:22:54,880
Dois mecanismos em vigor

18602
12:22:54,880 --> 12:22:56,720
Quais são as diferenças entre

18603
12:22:56,720 --> 12:22:59,840
eles aqui é um simples slide que eu coloco

18604
12:22:59,840 --> 12:23:02,160
juntos para colocar os pontos importantes

18605
12:23:02,160 --> 12:23:04,880
sobre referências e ponteiros juntos

18606
12:23:04,880 --> 12:23:06,560
A primeira coisa é que se você usar

18607
12:23:06,560 --> 12:23:08,880
Referências que você não vai

18608
12:23:08,880 --> 12:23:11,520
através do símbolo da estrela para a referência

18609
12:23:11,520 --> 12:23:12,960
e chegar ao valor que você é

18610
12:23:12,960 --> 12:23:15,436
manipular de modo que isso realmente vai

18611
12:23:15,436 --> 12:23:17,436
Sente-se que você está usando o original

18612
12:23:17,436 --> 12:23:19,840
variável mas com ponteiros você está indo

18613
12:23:19,840 --> 12:23:21,596
para passar pela referência, então isso é

18614
12:23:21,596 --> 12:23:23,116
A primeira diferença

18615
12:23:23,116 --> 12:23:25,200
Outra coisa sobre referências é que

18616
12:23:25,200 --> 12:23:27,916
Você não pode alterá-los para referência

18617
12:23:27,916 --> 12:23:30,400
Mais uma coisa depois, mas com ponteiros

18618
12:23:30,400 --> 12:23:31,916
Vimos que poderíamos fazer aquilo que podemos

18619
12:23:31,916 --> 12:23:34,640
mudar um ponteiro para apontar para outro lugar

18620
12:23:34,640 --> 12:23:37,276
se acontecer de ser um ponteiro não consumidor

18621
12:23:37,276 --> 12:23:39,520
A outra coisa é que para referências

18622
12:23:39,520 --> 12:23:41,756
você tem que inicializá-los em

18623
12:23:41,756 --> 12:23:43,680
Declaração que você não pode declarar a

18624
12:23:43,680 --> 12:23:46,160
referência e não inicializar isso se você

18625
12:23:46,160 --> 12:23:47,596
fazer isso você vai ter um compilador

18626
12:23:47,596 --> 12:23:49,040
erro e vamos ver isso em um

18627
12:23:49,040 --> 12:23:52,400
minuto mas para ponteiros você pode declarar

18628
12:23:52,400 --> 12:23:54,560
um ponteiro e não inicializá-lo e

18629
12:23:54,560 --> 12:23:57,040
vai apenas conter um lixo

18630
12:23:57,040 --> 12:23:59,596
e se você tentar usar esse não inicializado

18631
12:23:59,596 --> 12:24:01,840
Você vai estar se preparando

18632
12:24:01,840 --> 12:24:04,000
por problemas, então vimos que estes são

18633
12:24:04,000 --> 12:24:06,080
As principais diferenças entre ponteiros

18634
12:24:06,080 --> 12:24:08,480
e referências e agora estamos apenas indo

18635
12:24:08,480 --> 12:24:11,520
para ver como estes se traduzem em

18636
12:24:11,520 --> 12:24:14,000
O código aqui é um exemplo simples que temos a

18637
12:24:14,000 --> 12:24:15,756
variável chamada valor duplo que

18638
12:24:15,756 --> 12:24:17,916
Acontece que é duplo e nós temos um

18639
12:24:17,916 --> 12:24:20,640
referência a ele e um ponteiro para ele, então

18640
12:24:20,640 --> 12:24:22,880
Você já conhece esses conceitos

18641
12:24:22,880 --> 12:24:25,680
Agora, se quisermos ler o valor aqui

18642
12:24:25,680 --> 12:24:27,916
através do nosso ponteiro e referências nós somos

18643
12:24:27,916 --> 12:24:30,560
Vou usar duas sintaxes diferentes

18644
12:24:30,560 --> 12:24:32,800
Se passarmos pela referência, podemos

18645
12:24:32,800 --> 12:24:35,116
Use este nome de variável de referência

18646
12:24:35,116 --> 12:24:38,080
diretamente e ler o valor ou alterá-lo

18647
12:24:38,080 --> 12:24:39,916
e nós podemos fazer algo como

18648
12:24:39,916 --> 12:24:42,400
ref duplo valor para imprimir isso

18649
12:24:42,400 --> 12:24:44,640
Vai trabalhar, mas se quisermos ir

18650
12:24:44,640 --> 12:24:47,200
através do ponteiro, teremos que ir

18651
12:24:47,200 --> 12:24:49,276
através da referência e isso é

18652
12:24:49,276 --> 12:24:50,400
Realmente ruim

18653
12:24:50,400 --> 12:24:52,400
Você sabe que às vezes as pessoas não gostam

18654
12:24:52,400 --> 12:24:55,116
Esta sintaxe eles pensam que não é

18655
12:24:55,116 --> 12:24:57,840
direto o suficiente para que eles preferem usar

18656
12:24:57,840 --> 12:25:00,160
Referências para fazer esse tipo de coisa

18657
12:25:00,160 --> 12:25:02,320
Mas ponteiros ainda são importantes como nós

18658
12:25:02,320 --> 12:25:04,240
veremos mais tarde à medida que progredimos na

18659
12:25:04,240 --> 12:25:06,720
curso, então esta é uma diferença com

18660
12:25:06,720 --> 12:25:08,560
referências que você não precisa passar

18661
12:25:08,560 --> 12:25:11,040
o mecanismo de desreferenciamento para usar isso

18662
12:25:11,040 --> 12:25:13,360
estrela aqui para imprimir coisas ou até mesmo

18663
12:25:13,360 --> 12:25:15,840
manipular os dados dentro de você apenas usar

18664
12:25:15,840 --> 12:25:17,360
o nome da variável e vai

18665
12:25:17,360 --> 12:25:19,916
trabalhar com ponteiros que você tem que referenciar

18666
12:25:19,916 --> 12:25:21,520
Porque se você não fizer a referência

18667
12:25:21,520 --> 12:25:23,116
Você vai se referir ao

18668
12:25:23,116 --> 12:25:25,756
endereço armazenado neste ponteiro este é

18669
12:25:25,756 --> 12:25:28,080
A primeira diferença e vemos que o

18670
12:25:28,080 --> 12:25:30,880
O mesmo se aplica se estamos tentando

18671
12:25:30,880 --> 12:25:33,916
gravar dados em nossa variável se formos

18672
12:25:33,916 --> 12:25:35,596
através do ponteiro, teremos que

18673
12:25:35,596 --> 12:25:37,840
desativar e usar este símbolo de dólar

18674
12:25:37,840 --> 12:25:39,116
Na frente aqui

18675
12:25:39,116 --> 12:25:41,116
Se estivermos usando uma referência, podemos fazer

18676
12:25:41,116 --> 12:25:44,080
que diretamente como se estamos modificando o

18677
12:25:44,080 --> 12:25:46,800
variável original, então essa sintaxe é muito

18678
12:25:46,800 --> 12:25:48,640
mais legível a outra diferença é

18679
12:25:48,640 --> 12:25:51,200
que não podemos fazer uma referência

18680
12:25:51,200 --> 12:25:53,276
fazer referência a outra coisa, mas nós podemos

18681
12:25:53,276 --> 12:25:55,040
mudar um ponteiro para apontar para algo

18682
12:25:55,040 --> 12:25:57,680
Vejamos um exemplo aqui estamos

18683
12:25:57,680 --> 12:25:59,596
têm ref double value que é um

18684
12:25:59,596 --> 12:26:01,680
Referência ao duplo valor

18685
12:26:01,680 --> 12:26:02,960
E aqui

18686
12:26:02,960 --> 12:26:05,520
Estamos fazendo uma tarefa para essa coisa

18687
12:26:05,520 --> 12:26:07,840
Aqui estamos dizendo qualquer valor duplo

18688
12:26:07,840 --> 12:26:09,520
E atribuindo isso

18689
12:26:09,520 --> 12:26:12,560
para nossa referência, mas o que estamos fazendo

18690
12:26:12,560 --> 12:26:15,040
Aqui não está fazendo ref double value

18691
12:26:15,040 --> 12:26:17,596
referência a esta outra variável que somos

18692
12:26:17,596 --> 12:26:19,680
apenas agarrando o valor em outro duplo

18693
12:26:19,680 --> 12:26:21,596
valor e atribuir isso ao nosso

18694
12:26:21,596 --> 12:26:24,320
referência e o valor em qualquer duplo

18695
12:26:24,320 --> 12:26:26,720
O valor será refletido no

18696
12:26:26,720 --> 12:26:29,040
Valor original aqui, então isso é o que nós

18697
12:26:29,040 --> 12:26:31,916
Estamos fazendo, não estamos realocar para o nosso

18698
12:26:31,916 --> 12:26:33,916
referência para fazer referência a algo

18699
12:26:33,916 --> 12:26:36,240
Caso atribuamos valor ao

18700
12:26:36,240 --> 12:26:38,800
Referência como é agora e está indo

18701
12:26:38,800 --> 12:26:40,640
Ainda estar referenciando o mesmo

18702
12:26:40,640 --> 12:26:43,040
variável na memória se você imprimir o

18703
12:26:43,040 --> 12:26:44,400
endereço na memória que você vai ver

18704
12:26:44,400 --> 12:26:46,880
O endereço da referência aqui

18705
12:26:46,880 --> 12:26:48,880
Não mudou, então isso é algo que você

18706
12:26:48,880 --> 12:26:50,800
Devemos ter em mente, mas sabemos que

18707
12:26:50,800 --> 12:26:52,880
O ponteiro pode apontar para outro lugar se nós

18708
12:26:52,880 --> 12:26:54,720
ter um ponteiro aqui, por exemplo, p duplo

18709
12:26:54,720 --> 12:26:57,756
valor podemos reatribuir-lhe outro endereço

18710
12:26:57,756 --> 12:27:00,560
e fazer isso apontar para esse novo endereço assim

18711
12:27:00,560 --> 12:27:02,240
A este respeito, podemos pensar em

18712
12:27:02,240 --> 12:27:05,040
referências como ponteiros de custo porque custo

18713
12:27:05,040 --> 12:27:07,840
Os ponteiros também não podem ser feitos para apontar

18714
12:27:07,840 --> 12:27:09,596
Em outro lugar e se você está tentando

18715
12:27:09,596 --> 12:27:11,916
fazer isso, por exemplo, aqui temos um custo

18716
12:27:11,916 --> 12:27:15,756
ponteiro é chamado custo p duplo valor

18717
12:27:15,756 --> 12:27:17,520
e se tentarmos fazer isso apontar

18718
12:27:17,520 --> 12:27:19,520
Em outro lugar através desta tarefa

18719
12:27:19,520 --> 12:27:21,596
Aqui vamos receber um erro de compilador

18720
12:27:21,596 --> 12:27:24,160
Tudo bem, então isso é realmente tudo em termos de

18721
12:27:24,160 --> 12:27:26,240
as comparações que tivemos que fazer

18722
12:27:26,240 --> 12:27:28,400
entre referências e ponteiros agora

18723
12:27:28,400 --> 12:27:30,000
nós vamos ir para o visual

18724
12:27:30,000 --> 12:27:32,160
código de estúdio e ver como essas coisas

18725
12:27:32,160 --> 12:27:35,360
trabalhar em código real, então aqui estamos em nosso

18726
12:27:35,360 --> 12:27:37,840
pasta de trabalho o projeto atual é

18727
12:27:37,840 --> 12:27:40,400
Comparando ponteiros e referências que somos

18728
12:27:40,400 --> 12:27:43,200
Vou pegar nossos arquivos de modelo e colocar

18729
12:27:43,200 --> 12:27:44,800
Eles no lugar

18730
12:27:44,800 --> 12:27:47,520
e vamos abrir este projeto em

18731
12:27:47,520 --> 12:27:50,400
código de estúdio visual como sempre fazemos

18732
12:27:50,400 --> 12:27:52,160
Eles vão descer e colocar em alguns

18733
12:27:52,160 --> 12:27:54,720
código de início e vamos alinhar este

18734
12:27:54,720 --> 12:27:56,080
Um pouco melhor

18735
12:27:56,080 --> 12:27:58,480
assim e podemos fechar este painel para que nós

18736
12:27:58,480 --> 12:28:00,720
ter algum espaço para respirar aqui temos um

18737
12:28:00,720 --> 12:28:03,116
variável de tipo duplo e configuramos um

18738
12:28:03,116 --> 12:28:05,360
referência a ele e um ponteiro para isso

18739
12:28:05,360 --> 12:28:07,116
É como fazemos isso graças a você já

18740
12:28:07,116 --> 12:28:08,160
Saiba disso

18741
12:28:08,160 --> 12:28:11,200
e nós podemos tentar e ler através

18742
12:28:11,200 --> 12:28:12,880
a variável original através do

18743
12:28:12,880 --> 12:28:15,596
referência e através do ponteiro e

18744
12:28:15,596 --> 12:28:18,960
Veja como essas sintaxes diferem e como

18745
12:28:18,960 --> 12:28:21,520
Um pode ser melhor do que o outro para

18746
12:28:21,520 --> 12:28:24,480
exemplo, se olharmos como estamos usando

18747
12:28:24,480 --> 12:28:26,320
A referência é realmente como se nós sou

18748
12:28:26,320 --> 12:28:28,400
usando o valor original aqui não

18749
12:28:28,400 --> 12:28:30,800
Tenho que fazer referência se tentarmos imprimir

18750
12:28:30,800 --> 12:28:32,560
O ponteiro como este sem

18751
12:28:32,560 --> 12:28:34,800
A referência que isso vai imprimir

18752
12:28:34,800 --> 12:28:37,840
o endereço real armazenado neste

18753
12:28:37,840 --> 12:28:40,160
pointer não vai imprimir o

18754
12:28:40,160 --> 12:28:43,436
Valor real armazenado no endereço

18755
12:28:43,436 --> 12:28:45,360
apontado para este ponteiro que eu realmente quero

18756
12:28:45,360 --> 12:28:47,840
Isso para ser claro, então esta é a sintaxe

18757
12:28:47,840 --> 12:28:50,080
Podemos usar para ler coisas também

18758
12:28:50,080 --> 12:28:52,320
através de referências ou ponteiros podemos

18759
12:28:52,320 --> 12:28:54,640
também use essas sintaxes para escrever coisas

18760
12:28:54,640 --> 12:28:56,960
em nossas variáveis, por exemplo, aqui nós

18761
12:28:56,960 --> 12:28:58,800
pode passar pelo ponteiro e nós temos

18762
12:28:58,800 --> 12:29:01,116
para a referência e podemos passar

18763
12:29:01,116 --> 12:29:03,200
A referência para realmente fazer o mesmo

18764
12:29:03,200 --> 12:29:04,800
coisa e vamos ver que

18765
12:29:04,800 --> 12:29:07,040
As sintaxes aqui vão pegar o

18766
12:29:07,040 --> 12:29:08,080
Mudanças

18767
12:29:08,080 --> 12:29:10,720
independentemente de escrevermos através de

18768
12:29:10,720 --> 12:29:13,756
ponteiro ou referência porque tudo isso

18769
12:29:13,756 --> 12:29:15,040
As coisas realmente vão ser

18770
12:29:15,040 --> 12:29:18,480
Referindo o mesmo local na memória

18771
12:29:18,480 --> 12:29:21,756
Vamos tentar trazer um terminal aqui

18772
12:29:21,756 --> 12:29:24,560
e nós estamos indo para o mundo com gcc vamos

18773
12:29:24,560 --> 12:29:26,800
para que a construção seja boa

18774
12:29:26,800 --> 12:29:29,436
e nós vamos limpar e correr galo

18775
12:29:29,436 --> 12:29:31,200
E você vai ver isso no início

18776
12:29:31,200 --> 12:29:33,436
nós vamos ter um 12

18777
12:29:33,436 --> 12:29:35,200
Ponto 34 em

18778
12:29:35,200 --> 12:29:37,040
que vai ser o valor que podemos obter

18779
12:29:37,040 --> 12:29:39,596
através do valor original da referência

18780
12:29:39,596 --> 12:29:42,160
ou o ponteiro através da referência

18781
12:29:42,160 --> 12:29:44,800
E o endereço é este aqui

18782
12:29:44,800 --> 12:29:46,320
Se mudarmos o valor através do

18783
12:29:46,320 --> 12:29:48,240
ponteiro, vamos ver as mudanças

18784
12:29:48,240 --> 12:29:50,400
refletido aqui e se mudarmos o

18785
12:29:50,400 --> 12:29:52,160
valor através da referência que estamos indo

18786
12:29:52,160 --> 12:29:54,240
para ver as mudanças refletidas aqui, então

18787
12:29:54,240 --> 12:29:56,560
É assim que você pode usar ponteiros e

18788
12:29:56,560 --> 12:29:59,040
referências para fazer essas coisas aqui e

18789
12:29:59,040 --> 12:30:00,720
Você pode realmente escolher o que faz sentido

18790
12:30:00,720 --> 12:30:02,560
para sua aplicação, eles fazem principalmente o

18791
12:30:02,560 --> 12:30:04,880
As mesmas coisas, mas algumas pessoas dizem que

18792
12:30:04,880 --> 12:30:07,360
sintaxe para a referência o ponteiro aqui

18793
12:30:07,360 --> 12:30:09,596
É realmente feio, é por isso que a maioria das pessoas

18794
12:30:09,596 --> 12:30:11,840
Prefira usar referências como esta, mas

18795
12:30:11,840 --> 12:30:14,320
As referências também têm outros benefícios

18796
12:30:14,320 --> 12:30:16,640
como vamos ver à medida que avançamos

18797
12:30:16,640 --> 12:30:18,320
O curso outra coisa que eu quero que você

18798
12:30:18,320 --> 12:30:20,240
Veja que você não pode alterar uma referência

18799
12:30:20,240 --> 12:30:22,960
Para fazer referência a algo mais na memória

18800
12:30:22,960 --> 12:30:24,720
Por exemplo, aqui temos nossa referência

18801
12:30:24,720 --> 12:30:27,756
que é ref double value se tentarmos e

18802
12:30:27,756 --> 12:30:30,160
Fazê-lo fazer referência a outra coisa

18803
12:30:30,160 --> 12:30:31,916
nós não vamos conseguir esse resultado, vamos

18804
12:30:31,916 --> 12:30:33,840
descer e tentar fazer isso

18805
12:30:33,840 --> 12:30:35,436
Vamos montar outro duplo

18806
12:30:35,436 --> 12:30:38,800
variável assim se tentarmos

18807
12:30:38,800 --> 12:30:41,916
fazer o nosso ref double value referência a esta referência

18808
12:30:41,916 --> 12:30:42,880
O cara

18809
12:30:42,880 --> 12:30:45,436
A sintaxe que vem à mente é dizer

18810
12:30:45,436 --> 12:30:46,880
Ref

18811
12:30:46,880 --> 12:30:50,480
valor duplo e atribuir que alguns

18812
12:30:50,480 --> 12:30:51,360
O outro

18813
12:30:51,360 --> 12:30:53,520
O dobro valor aqui agora vamos ver o que

18814
12:30:53,520 --> 12:30:55,680
acontece se fizermos isso, vamos tentar

18815
12:30:55,680 --> 12:30:58,480
e imprimir o que temos na memória

18816
12:30:58,480 --> 12:31:00,320
Usando o

18817
12:31:00,320 --> 12:31:04,000
ref double value aqui vamos pegar isso

18818
12:31:04,000 --> 12:31:06,480
e ir aqui e dizer que nós somos

18819
12:31:06,480 --> 12:31:08,800
Alterar a referência fazendo o

18820
12:31:08,800 --> 12:31:11,040
referência de referência outra coisa, vamos

18821
12:31:11,040 --> 12:31:13,436
Diga isso se tentarmos construir isso

18822
12:31:13,436 --> 12:31:15,756
Vamos ver o que temos, vamos correr

18823
12:31:15,756 --> 12:31:18,240
e construir com gcc

18824
12:31:18,240 --> 12:31:20,720
e nós vamos tentar executá-lo

18825
12:31:20,720 --> 12:31:22,800
claro não claro e nós vamos correr

18826
12:31:22,800 --> 12:31:24,080
Galo

18827
12:31:24,080 --> 12:31:25,680
nós vamos ver isso

18828
12:31:25,680 --> 12:31:31,640
A última linha de produção aqui diz 78.45

18829
12:31:31,756 --> 12:31:35,116
Mas o endereço ainda é o mesmo, então nós

18830
12:31:35,116 --> 12:31:38,000
Ainda estão referenciando a mesma memória

18831
12:31:38,000 --> 12:31:40,480
A nossa referência e o que acabamos de fazer

18832
12:31:40,480 --> 12:31:43,360
Aqui estava apenas agarrar o valor em alguns

18833
12:31:43,360 --> 12:31:45,116
O outro duplo valor

18834
12:31:45,116 --> 12:31:46,960
e atribuir isso aqui, mas o

18835
12:31:46,960 --> 12:31:49,916
A referência está referenciando a mesma memória

18836
12:31:49,916 --> 12:31:52,240
localização tem sido referenciando assim em c

18837
12:31:52,240 --> 12:31:55,200
plus que você não tem uma maneira que você pode

18838
12:31:55,200 --> 12:31:56,320
passar por aí

18839
12:31:56,320 --> 12:31:58,800
fazer uma referência de referência algo

18840
12:31:58,800 --> 12:32:01,360
então a única chance que você tem de fazê-lo

18841
12:32:01,360 --> 12:32:03,360
Referência alguma coisa é através

18842
12:32:03,360 --> 12:32:06,720
Declaração aqui e essa é a razão

18843
12:32:06,720 --> 12:32:09,436
você não pode declarar uma referência e não

18844
12:32:09,436 --> 12:32:10,960
inicialize-o se você fizer isso você é

18845
12:32:10,960 --> 12:32:13,040
obter um erro de compilador, então vamos

18846
12:32:13,040 --> 12:32:14,400
Tente fazer algo assim que estamos

18847
12:32:14,400 --> 12:32:16,880
Vou tirar esse valor duplo e

18848
12:32:16,880 --> 12:32:18,240
No momento em que fazemos isso, você está indo

18849
12:32:18,240 --> 12:32:20,080
Veja que o código visual do estúdio está indo para

18850
12:32:20,080 --> 12:32:22,640
ser infeliz você vê a linha e

18851
12:32:22,640 --> 12:32:24,880
vai dizer o valor inicial de

18852
12:32:24,880 --> 12:32:27,436
A referência ao non-cos deve ser um valor l

18853
12:32:27,436 --> 12:32:29,116
Então, o que é isso

18854
12:32:29,116 --> 12:32:31,596
Tudo bem se tirarmos a inicialização

18855
12:32:31,596 --> 12:32:33,680
ao todo vai nos dar a

18856
12:32:33,680 --> 12:32:35,840
melhor erro i think reference variável

18857
12:32:35,840 --> 12:32:38,800
requer um inicializador assim que cada vez

18858
12:32:38,800 --> 12:32:41,436
Você declara uma referência que você tem que

18859
12:32:41,436 --> 12:32:44,640
inicializá-lo e devemos fazer como nós

18860
12:32:44,640 --> 12:32:46,960
Acabei de fazer antes e nós vamos

18861
12:32:46,960 --> 12:32:49,116
Estar bem novamente você não pode declarar um

18862
12:32:49,116 --> 12:32:51,756
fazer referência e não inicializá-lo se você

18863
12:32:51,756 --> 12:32:53,276
fazer isso você vai ter um compilador

18864
12:32:53,276 --> 12:32:56,080
O erro e a razão é que

18865
12:32:56,080 --> 12:32:58,240
Este é o único tiro que você consegue fazer

18866
12:32:58,240 --> 12:33:00,880
sua referência de referência outra coisa

18867
12:33:00,880 --> 12:33:02,560
Tudo bem se houvesse uma maneira de você

18868
12:33:02,560 --> 12:33:05,840
ignorar isso e deixar o compilador compilar

18869
12:33:05,840 --> 12:33:08,000
Isso você nunca teria outra chance

18870
12:33:08,000 --> 12:33:09,916
para fazer esse cara realmente fazer referência

18871
12:33:09,916 --> 12:33:12,080
Algo e seria realmente um

18872
12:33:12,080 --> 12:33:14,320
Referência inútil para que você

18873
12:33:14,320 --> 12:33:16,320
Entenda isso você não pode fazer um

18874
12:33:16,320 --> 12:33:19,116
referência de referência outra coisa e

18875
12:33:19,116 --> 12:33:21,276
Se você tentar fazer algo através de um

18876
12:33:21,276 --> 12:33:23,116
Sintaxe como esta

18877
12:33:23,116 --> 12:33:24,960
Você vai atribuir o valor

18878
12:33:24,960 --> 12:33:27,756
de qualquer variável que você tenha para o

18879
12:33:27,756 --> 12:33:29,436
referência que você não vai fazer

18880
12:33:29,436 --> 12:33:31,916
a referência referenciando outra coisa

18881
12:33:31,916 --> 12:33:33,360
A referência vai manter

18882
12:33:33,360 --> 12:33:35,596
referenciando a mesma variável na memória

18883
12:33:35,596 --> 12:33:37,916
como vimos aqui, então vamos dizer o que

18884
12:33:37,916 --> 12:33:39,916
Estávamos tentando fazer aqui, mas nós sabemos

18885
12:33:39,916 --> 12:33:42,400
que podemos fazer referências de ponteiros

18886
12:33:42,400 --> 12:33:44,720
Outra coisa, então aqui temos um ponteiro

18887
12:33:44,720 --> 12:33:45,596
Mais uma vez

18888
12:33:45,596 --> 12:33:47,756
Este ponteiro chamado p double value

18889
12:33:47,756 --> 12:33:50,000
e tem o endereço de duplo valor

18890
12:33:50,000 --> 12:33:51,040
Por dentro

18891
12:33:51,040 --> 12:33:53,916
mas podemos configurar outra variável

18892
12:33:53,916 --> 12:33:57,276
Tudo bem para que possamos fazer essa referência a isso

18893
12:33:57,276 --> 12:33:58,960
Outra variável aqui e vamos fazer isso

18894
12:33:58,960 --> 12:34:00,480
Você vai ver o nosso ponteiro agora

18895
12:34:00,480 --> 12:34:02,320
vai conter outro

18896
12:34:02,320 --> 12:34:04,960
Endereço para o que podemos fazer

18897
12:34:04,960 --> 12:34:07,436
é dizer p duplo valor

18898
12:34:07,436 --> 12:34:09,360
que é o nosso novo ponteiro e nós vamos

18899
12:34:09,360 --> 12:34:10,880
para atribuí-lo

18900
12:34:10,880 --> 12:34:15,040
Endereço de algum outro duplo valor

18901
12:34:15,040 --> 12:34:19,596
e se imprimirmos os dados agora e descermos

18902
12:34:19,596 --> 12:34:22,240
nós vamos dizer para fazer o ponteiro

18903
12:34:22,240 --> 12:34:24,240
apontar para outra coisa que é o que nós

18904
12:34:24,240 --> 12:34:26,480
Estamos fazendo aqui e nós vamos dizer

18905
12:34:26,480 --> 12:34:29,116
A mesma coisa através de uma vírgula e

18906
12:34:29,116 --> 12:34:31,040
Se imprimirmos esta tentativa de adivinhar o que somos

18907
12:34:31,040 --> 12:34:32,400
indo para chegar

18908
12:34:32,400 --> 12:34:34,240
O ponteiro vai conter um

18909
12:34:34,240 --> 12:34:36,720
Endereço completamente novo porque podemos fazer

18910
12:34:36,720 --> 12:34:38,400
que podemos fazer isso apontar

18911
12:34:38,400 --> 12:34:40,560
para outro lugar

18912
12:34:40,560 --> 12:34:42,480
Vamos correr o galo

18913
12:34:42,480 --> 12:34:44,960
e vamos ver os nossos dados aqui

18914
12:34:44,960 --> 12:34:48,560
Vamos ter certeza de que vemos o fã inteiro

18915
12:34:48,560 --> 12:34:51,520
Eu acho que estes são os dados que temos

18916
12:34:51,520 --> 12:34:53,436
Vamos subir de novo

18917
12:34:53,436 --> 12:34:56,000
Não há mal nisso, então temos o nosso

18918
12:34:56,000 --> 12:34:58,640
Cerca que já vimos antes, mas o que

18919
12:34:58,640 --> 12:35:01,840
Vai ser importante aqui é que pw

18920
12:35:01,840 --> 12:35:05,040
O valor agora contém um novo endereço

18921
12:35:05,040 --> 12:35:07,916
Tudo bem, então isso é realmente importante e você

18922
12:35:07,916 --> 12:35:10,240
Tenho que entender isso para que tenhamos feito o

18923
12:35:10,240 --> 12:35:12,160
O ponteiro aponta com sucesso para algo

18924
12:35:12,160 --> 12:35:14,960
E se alterarmos os dados no

18925
12:35:14,960 --> 12:35:16,160
pointer agora

18926
12:35:16,160 --> 12:35:18,560
Não vamos afetar os dados

18927
12:35:18,560 --> 12:35:20,880
Temos aqui em duplo valor que somos

18928
12:35:20,880 --> 12:35:23,360
Vamos afetar os dados que temos

18929
12:35:23,360 --> 12:35:25,756
E algum outro valor duplo aqui vamos

18930
12:35:25,756 --> 12:35:27,436
Fazê-lo, vamos alterar os dados

18931
12:35:27,436 --> 12:35:28,960
através do ponteiro, então nós vamos

18932
12:35:28,960 --> 12:35:31,200
Diga p valor duplo e nós vamos

18933
12:35:31,200 --> 12:35:32,560
Mudar isso para

18934
12:35:32,560 --> 12:35:35,200
555

18935
12:35:35,200 --> 12:35:37,520
e agora podemos imprimir os dados e ver

18936
12:35:37,520 --> 12:35:39,916
que as coisas mudaram na memória e

18937
12:35:39,916 --> 12:35:42,000
Podemos imprimir isso para ver as diferenças

18938
12:35:42,000 --> 12:35:44,720
Aqui, mas antes de fazermos isso, vamos também

18939
12:35:44,720 --> 12:35:46,880
Imprimindo o endereço do original

18940
12:35:46,880 --> 12:35:49,116
variável e endereço porque por enquanto

18941
12:35:49,116 --> 12:35:52,240
estamos apenas imprimindo apenas o endereço

18942
12:35:52,240 --> 12:35:54,160
através do ponteiro para o que podemos fazer

18943
12:35:54,160 --> 12:35:58,080
aqui é pegar htdc para fora e dizer

18944
12:35:58,080 --> 12:36:00,320
endereço de duplo volume e vamos

18945
12:36:00,320 --> 12:36:03,116
para colocar isso para fora através de htdc aqui

18946
12:36:03,116 --> 12:36:04,880
nós vamos fazer isso e nós vamos

18947
12:36:04,880 --> 12:36:07,276
para imprimir o endereço da referência

18948
12:36:07,276 --> 12:36:08,960
Por que não

18949
12:36:08,960 --> 12:36:11,680
ref double value e vamos colocar

18950
12:36:11,680 --> 12:36:13,520
Isso também eu vou dizer

18951
12:36:13,520 --> 12:36:15,276
Endereço de ref

18952
12:36:15,276 --> 12:36:16,480
O dobro do valor

18953
12:36:16,480 --> 12:36:19,200
e nós vamos dizer std endn e

18954
12:36:19,200 --> 12:36:21,360
Depois disso, vamos pegar o

18955
12:36:21,360 --> 12:36:24,160
Tudo aqui e imprimi-lo depois

18956
12:36:24,160 --> 12:36:27,436
nós modificamos o valor no ponteiro

18957
12:36:27,436 --> 12:36:29,360
Espero que isso mostre graças em um

18958
12:36:29,360 --> 12:36:30,640
Muito mais

18959
12:36:30,640 --> 12:36:33,040
de forma clara, então nós vamos soldar isso

18960
12:36:33,040 --> 12:36:36,480
com gcc vamos fazer que a construção é boa

18961
12:36:36,480 --> 12:36:39,276
Então, vamos limpar e correr galo e o que

18962
12:36:39,276 --> 12:36:41,360
Você vai ver que

18963
12:36:41,360 --> 12:36:42,400
E agora

18964
12:36:42,400 --> 12:36:45,360
A variável original está vivendo em

18965
12:36:45,360 --> 12:36:47,520
Endereço aqui

18966
12:36:47,520 --> 12:36:49,436
que podemos ver em nossa referência, mas

18967
12:36:49,436 --> 12:36:51,436
O ponteiro agora está apontando para algo

18968
12:36:51,436 --> 12:36:52,320
Mais uma vez

18969
12:36:52,320 --> 12:36:54,480
Não admira que as mudanças que fizemos

18970
12:36:54,480 --> 12:36:56,080
O ponteiro não está sendo

18971
12:36:56,080 --> 12:36:58,160
refletido em nosso valor duplo porque

18972
12:36:58,160 --> 12:37:00,240
Essas duas variáveis agora

18973
12:37:00,240 --> 12:37:03,436
estão vivendo em diferentes locais de memória

18974
12:37:03,436 --> 12:37:05,520
Eu realmente espero que você veja isso e isso é

18975
12:37:05,520 --> 12:37:08,240
Realmente tudo que tínhamos para compartilhar em termos

18976
12:37:08,240 --> 12:37:10,240
das diferenças entre ponteiros e

18977
12:37:10,240 --> 12:37:12,640
Referências espero que você tenha um claro

18978
12:37:12,640 --> 12:37:15,520
imagem do que são essas duas coisas e

18979
12:37:15,520 --> 12:37:16,720
Vamos parar aqui neste

18980
12:37:16,720 --> 12:37:18,880
dar palestra este vamos ver como

18981
12:37:18,880 --> 12:37:21,520
O mundo chave do const funciona com

18982
12:37:21,520 --> 12:37:22,956
Referências

18983
12:37:22,956 --> 12:37:25,200
Vá em frente e termine aqui e me encontre

18984
12:37:25,200 --> 12:37:27,116
lá nesta palestra vamos ver

18985
12:37:27,116 --> 12:37:30,160
como o mundo das chaves const pode ser usado com

18986
12:37:30,160 --> 12:37:31,436
Referências

18987
12:37:31,436 --> 12:37:34,000
e novamente a ideia é criar um pseudônimo

18988
12:37:34,000 --> 12:37:37,520
para uma variável e torná-la const de modo que

18989
12:37:37,520 --> 12:37:40,080
Não podemos passar por isso para modificar o

18990
12:37:40,080 --> 12:37:42,480
variável original esta é a sintaxe que nós

18991
12:37:42,480 --> 12:37:44,800
usado para criar uma referência não const

18992
12:37:44,800 --> 12:37:47,040
que vimos até agora, por exemplo

18993
12:37:47,040 --> 12:37:50,080
Podemos dizer que na idade em um valor de 27 em

18994
12:37:50,080 --> 12:37:52,956
este caso e estabelecer uma referência à idade

18995
12:37:52,956 --> 12:37:54,880
e inicializar que

18996
12:37:54,880 --> 12:37:57,360
com a variável idade, uma vez que fazemos isso

18997
12:37:57,360 --> 12:37:59,916
riff edge pode ser usado para modificar

18998
12:37:59,916 --> 12:38:02,240
esta variável de borda aqui e tudo o que é

18999
12:38:02,240 --> 12:38:05,116
Por exemplo, podemos passar por ref

19000
12:38:05,116 --> 12:38:08,160
idade para incrementar a idade e se imprimir

19001
12:38:08,160 --> 12:38:10,400
a borda agora devemos obter um 28 impresso

19002
12:38:10,400 --> 12:38:12,956
porque esta referência vai

19003
12:38:12,956 --> 12:38:15,680
Mudar essas duas coisas ao mesmo tempo

19004
12:38:15,680 --> 12:38:18,160
ou outra maneira de dizer isso esses dois

19005
12:38:18,160 --> 12:38:20,880
coisas que idade e ref age estão referenciando

19006
12:38:20,880 --> 12:38:22,720
A mesma memória

19007
12:38:22,720 --> 12:38:25,116
em seu computador, então se você mudar um

19008
12:38:25,116 --> 12:38:27,040
O outro vai pegar a mudança

19009
12:38:27,040 --> 12:38:28,880
também podemos configurar a referência de contas

19010
12:38:28,880 --> 12:38:31,436
e a sintaxe é ridiculamente fácil

19011
12:38:31,436 --> 12:38:34,080
Diga referência constante como esta e

19012
12:38:34,080 --> 12:38:36,956
sua referência é repentinamente causada e

19013
12:38:36,956 --> 12:38:39,436
você não pode passar por isso para modificar o

19014
12:38:39,436 --> 12:38:40,880
variável original

19015
12:38:40,880 --> 12:38:42,640
se você precisar de algo assim em seu

19016
12:38:42,640 --> 12:38:44,560
Aplicação é assim que você faz você

19017
12:38:44,560 --> 12:38:46,480
Também pode duplicar o comportamento com

19018
12:38:46,480 --> 12:38:48,560
contar referências com ponteiros e para

19019
12:38:48,560 --> 12:38:51,200
que podemos usar uma construção como const

19020
12:38:51,200 --> 12:38:53,680
custo do ponteiro final isso vai configurar

19021
12:38:53,680 --> 12:38:56,400
um ponteiro de custo para o custo que não podemos

19022
12:38:56,400 --> 12:38:58,320
Use para modificar o valor que somos

19023
12:38:58,320 --> 12:38:59,520
apontando para

19024
12:38:59,520 --> 12:39:02,160
mas também não pode ser usado para apontar para

19025
12:39:02,160 --> 12:39:04,240
Algo mais, então isso vai fazer

19026
12:39:04,240 --> 12:39:06,000
simular o comportamento que temos com

19027
12:39:06,000 --> 12:39:08,160
referências e você pode fazer isso se você

19028
12:39:08,160 --> 12:39:10,400
Querer e, por favor, saiba que não temos

19029
12:39:10,400 --> 12:39:13,436
tal coisa como custo de referência constante

19030
12:39:13,436 --> 12:39:15,360
Isto vai dar-lhe um compilador

19031
12:39:15,360 --> 12:39:17,756
Erro porque não temos tal conceito em

19032
12:39:17,756 --> 12:39:20,800
c plus plus e minha cabeça está doendo direito

19033
12:39:20,800 --> 12:39:23,200
Agora tentando pensar sobre o que isso

19034
12:39:23,200 --> 12:39:25,520
Até significaria e outra coisa que eu quero

19035
12:39:25,520 --> 12:39:27,680
para deixar claro antes de ir para

19036
12:39:27,680 --> 12:39:30,320
O código de vídeo do vg e jogar conosco é que

19037
12:39:30,320 --> 12:39:32,880
o mundo chave const vai se inscrever para

19038
12:39:32,880 --> 12:39:34,560
o nome da variável

19039
12:39:34,560 --> 12:39:37,276
que você aplica isso, por exemplo, aqui estamos

19040
12:39:37,276 --> 12:39:39,200
ter idade de referência de custo que está indo

19041
12:39:39,200 --> 12:39:42,400
ser uma referência const, mas isso não

19042
12:39:42,400 --> 12:39:44,880
significa que a variável de borda aqui tem que

19043
12:39:44,880 --> 12:39:46,240
ser o custo

19044
12:39:46,240 --> 12:39:48,560
Ok pode custar ou pode não ser

19045
12:39:48,560 --> 12:39:51,116
custo, mas o custo aqui se aplica a isso

19046
12:39:51,116 --> 12:39:53,840
idade de restrição de nome variável e nós

19047
12:39:53,840 --> 12:39:55,916
não pode passar por este nome variável e

19048
12:39:55,916 --> 12:39:58,080
modificar a idade se você está tentando fazer

19049
12:39:58,080 --> 12:40:00,320
que vamos ter um erro de compilador

19050
12:40:00,320 --> 12:40:02,400
Agora podemos ir para o estúdio visual

19051
12:40:02,400 --> 12:40:05,840
código e jogar conosco aqui estamos em nosso

19052
12:40:05,840 --> 12:40:08,640
diretório de trabalho do projeto atual é

19053
12:40:08,640 --> 12:40:11,360
Referência e custo que vamos pegar

19054
12:40:11,360 --> 12:40:14,080
nossos arquivos de modelo muito rápidos, vamos fazer

19055
12:40:14,080 --> 12:40:14,880
que

19056
12:40:14,880 --> 12:40:17,756
E nós vamos colocá-los no lugar

19057
12:40:17,756 --> 12:40:20,000
e nós vamos abrir isso em

19058
12:40:20,000 --> 12:40:22,560
Código do estúdio que vamos rever o

19059
12:40:22,560 --> 12:40:24,956
referências que temos visto até agora nesta

19060
12:40:24,956 --> 12:40:27,276
Um pequeno exemplo aqui temos a borda

19061
12:40:27,276 --> 12:40:30,320
variável tem um 27 dentro e é um

19062
12:40:30,320 --> 12:40:33,040
Net e nós temos uma referência a isso

19063
12:40:33,040 --> 12:40:35,680
e esta referência não é const, então nós

19064
12:40:35,680 --> 12:40:37,756
pode passar por esta referência modificar o

19065
12:40:37,756 --> 12:40:40,400
idade e se fizermos isso isso vai

19066
12:40:40,400 --> 12:40:42,160
trabalho e se imprimirmos a borda aqui, estamos

19067
12:40:42,160 --> 12:40:45,116
Vou ver que se transformou em um

19068
12:40:45,116 --> 12:40:48,480
28 e podemos tentar imprimir isso através

19069
12:40:48,480 --> 12:40:50,720
O terminal para que você possa ver isso

19070
12:40:50,720 --> 12:40:53,116
para si mesmo, então vamos executar a tarefa para

19071
12:40:53,116 --> 12:40:55,116
construção com gcc

19072
12:40:55,116 --> 12:40:57,116
nós vamos limpar

19073
12:40:57,116 --> 12:40:59,756
e correr o galo

19074
12:40:59,756 --> 12:41:01,200
E se fizermos isso, você vai ver

19075
12:41:01,200 --> 12:41:04,400
A borda é 27 agora é 28 e nós temos

19076
12:41:04,400 --> 12:41:06,956
Modificar com sucesso os dados através do nosso

19077
12:41:06,956 --> 12:41:08,320
referência aqui

19078
12:41:08,320 --> 12:41:10,560
mas se mudarmos essa referência para ser

19079
12:41:10,560 --> 12:41:12,480
Const não seremos capazes de fazer isso

19080
12:41:12,480 --> 12:41:14,640
mais para que vamos tentar torná-lo um const

19081
12:41:14,640 --> 12:41:15,680
Referência

19082
12:41:15,680 --> 12:41:17,680
Se fizermos isso, vamos ter um

19083
12:41:17,680 --> 12:41:19,756
Erro do compilador se tentarmos fazer algo

19084
12:41:19,756 --> 12:41:22,240
assim porque isso agora é um const

19085
12:41:22,240 --> 12:41:24,240
referência que não podemos passar por isso para

19086
12:41:24,240 --> 12:41:26,240
modificar nossos dados aqui e nós vamos

19087
12:41:26,240 --> 12:41:28,160
obter um erro de compilador aqui que temos visual

19088
12:41:28,160 --> 12:41:30,956
O estúdio ligou reclamando aqui, mas se nós

19089
12:41:30,956 --> 12:41:34,480
Ignorar isso e passar pelo compilador

19090
12:41:34,480 --> 12:41:36,000
nós vamos ver que nós temos o mesmo

19091
12:41:36,000 --> 12:41:38,560
Erro do compilador não podemos implementar uma leitura

19092
12:41:38,560 --> 12:41:41,040
apenas a referência que é este ref age

19093
12:41:41,040 --> 12:41:43,436
Então é isso que é uma referência de custo

19094
12:41:43,436 --> 12:41:45,436
realmente é que você não pode passar por isso

19095
12:41:45,436 --> 12:41:48,320
modificar os dados que estão sendo referenciados

19096
12:41:48,320 --> 12:41:49,916
E outra coisa eu quero que você realmente

19097
12:41:49,916 --> 12:41:52,240
Entende-se que esta palavra-chave const

19098
12:41:52,240 --> 12:41:55,040
Aqui não tem nada a ver com o original

19099
12:41:55,040 --> 12:41:57,276
variável esta é uma referência constante que nós

19100
12:41:57,276 --> 12:41:59,360
Não pode passar por isso para modificar a borda

19101
12:41:59,360 --> 12:42:02,720
variável, mas isso não importa se a idade

19102
12:42:02,720 --> 12:42:04,880
é const ou não const o

19103
12:42:04,880 --> 12:42:08,320
constantes aqui se aplica a esta variável

19104
12:42:08,320 --> 12:42:11,436
nome aqui para que este custo h pode ser custo se

19105
12:42:11,436 --> 12:42:13,200
É custo que vai funcionar igualmente

19106
12:42:13,200 --> 12:42:14,956
Bem e nós ainda vamos ter um

19107
12:42:14,956 --> 12:42:17,360
Erro do compilador aqui se não for o custo

19108
12:42:17,360 --> 12:42:19,436
Vai ser o mesmo custo que nós

19109
12:42:19,436 --> 12:42:22,480
A nossa referência se aplica a isso

19110
12:42:22,480 --> 12:42:24,400
nome da variável de referência aqui é

19111
12:42:24,400 --> 12:42:26,956
O que eu quero que você entenda bem isso

19112
12:42:26,956 --> 12:42:29,840
é o que é uma referência de custo

19113
12:42:29,840 --> 12:42:32,480
Outra coisa que queremos que você veja

19114
12:42:32,480 --> 12:42:34,160
é que nós podemos simular o mesmo

19115
12:42:34,160 --> 12:42:35,276
Comportamento

19116
12:42:35,276 --> 12:42:37,840
com ponteiros, então vamos configurar um const

19117
12:42:37,840 --> 12:42:40,400
ponteiro para const nesta borda aqui e

19118
12:42:40,400 --> 12:42:41,756
nós vamos ver que nós podemos ter o

19119
12:42:41,756 --> 12:42:43,680
O mesmo comportamento, mas por isso estamos indo

19120
12:42:43,680 --> 12:42:45,756
ter que comentar isso porque nós

19121
12:42:45,756 --> 12:42:48,080
Não queremos saída de ruído e estamos indo

19122
12:42:48,080 --> 12:42:50,880
para ir no topo aqui e comentar isso

19123
12:42:50,880 --> 12:42:53,360
e dizer o que pretendemos fazer

19124
12:42:53,360 --> 12:42:56,640
Podemos dizer que estamos simulando a referência

19125
12:42:56,640 --> 12:42:58,640
Comportamento com ponteiros e a maneira como somos

19126
12:42:58,640 --> 12:42:59,916
Vou fazer isso, vamos dizer

19127
12:42:59,916 --> 12:43:02,880
const e ponteiro custo e estamos indo

19128
12:43:02,880 --> 12:43:04,480
para dizer ph

19129
12:43:04,480 --> 12:43:06,480
e nós vamos inicializar isso com

19130
12:43:06,480 --> 12:43:09,116
nossa variável de idade ou endereço do nosso

19131
12:43:09,116 --> 12:43:12,480
Idade para ser super claro ok, então temos

19132
12:43:12,480 --> 12:43:15,200
nosso ponteiro configurado para tentar ir

19133
12:43:15,200 --> 12:43:17,436
através dele e modificar a idade vamos ver

19134
12:43:17,436 --> 12:43:19,756
O que acontece nós a referência porque

19135
12:43:19,756 --> 12:43:21,756
Este é um ponteiro e nós vamos dizer

19136
12:43:21,756 --> 12:43:25,520
ph e dizer plus plus ou até mesmo mudar isso

19137
12:43:25,520 --> 12:43:28,560
para outra idade, digamos 45 e se o fizermos

19138
12:43:28,560 --> 12:43:29,680
Isso nós vamos ter o mesmo

19139
12:43:29,680 --> 12:43:33,360
Erro do compilador, então se nós construirmos isso

19140
12:43:33,360 --> 12:43:36,880
vamos limpar aqui claramente não claro

19141
12:43:36,880 --> 12:43:38,560
E acima de novo vamos conseguir

19142
12:43:38,560 --> 12:43:40,880
outro erro do compilador dizendo que nós

19143
12:43:40,880 --> 12:43:43,360
Não pode modificar algo que é lido apenas

19144
12:43:43,360 --> 12:43:46,160
atribuição de leitura apenas local este

19145
12:43:46,160 --> 12:43:50,400
O ponteiro não pode ser usado para modificar os dados

19146
12:43:50,400 --> 12:43:53,840
Neste local de idade aqui, então este é o

19147
12:43:53,840 --> 12:43:56,560
O mesmo comportamento com referências porque

19148
12:43:56,560 --> 12:43:58,956
A referência por padrão não pode ser feita

19149
12:43:58,956 --> 12:44:01,756
para apontar para outro lugar que tivemos que fazer

19150
12:44:01,756 --> 12:44:04,640
Este ponteiro também um const pointer

19151
12:44:04,640 --> 12:44:07,040
impedir que isso aponte para

19152
12:44:07,040 --> 12:44:08,956
Outros locais, então é assim que você pode

19153
12:44:08,956 --> 12:44:12,400
simular referências com ponteiros e

19154
12:44:12,400 --> 12:44:14,240
Isso é realmente tudo o que nos prossamos fazer em

19155
12:44:14,240 --> 12:44:15,680
Esta palestra espero que você a tenha encontrado

19156
12:44:15,680 --> 12:44:16,880
Interessante

19157
12:44:16,880 --> 12:44:19,520
A ideia principal era deixar você saber como

19158
12:44:19,520 --> 12:44:21,840
você pode trabalhar com referências de custos e

19159
12:44:21,840 --> 12:44:23,360
uma vez que você tem sua referência de const você

19160
12:44:23,360 --> 12:44:25,520
não pode passar por isso para modificar o

19161
12:44:25,520 --> 12:44:27,756
Dados originais se você fizer isso

19162
12:44:27,756 --> 12:44:29,596
obter um erro do compilador

19163
12:44:29,596 --> 12:44:31,360
boas-vindas a este novo capítulo onde

19164
12:44:31,360 --> 12:44:34,880
estará fazendo coisas legais com dados de texto

19165
12:44:34,880 --> 12:44:36,720
Vimos que podemos modelar um

19166
12:44:36,720 --> 12:44:39,276
matriz de caracteres e loja em um monte de

19167
12:44:39,276 --> 12:44:41,596
Personagens e poderíamos, por exemplo, chamar

19168
12:44:41,596 --> 12:44:43,436
esta mensagem de matriz de caracteres e

19169
12:44:43,436 --> 12:44:45,756
Manipulá-lo em memória neste

19170
12:44:45,756 --> 12:44:47,840
estrutura vamos ver que isso é

19171
12:44:47,840 --> 12:44:50,560
Na verdade, a forma como os dados de texto são armazenados em

19172
12:44:50,560 --> 12:44:52,880
c plus plus e temos muito

19173
12:44:52,880 --> 12:44:55,116
instalações construídas sobre este

19174
12:44:55,116 --> 12:44:57,840
personagem já constrói para fazê-lo

19175
12:44:57,840 --> 12:45:01,040
fácil de trabalhar com dados de texto que veremos

19176
12:45:01,040 --> 12:45:03,200
que podemos usar arrays de caracteres para

19177
12:45:03,200 --> 12:45:05,840
modelo c strings que são uma facilidade que nós

19178
12:45:05,840 --> 12:45:09,680
uso em c plus plus para lidar com dados de texto

19179
12:45:09,680 --> 12:45:12,080
E veremos que há alguns

19180
12:45:12,080 --> 12:45:13,916
Instalações integradas que podemos usar para

19181
12:45:13,916 --> 12:45:16,080
manipular que podemos obter o comprimento de

19182
12:45:16,080 --> 12:45:18,080
uma string nós podemos agrupar strings e

19183
12:45:18,080 --> 12:45:20,480
montá-los juntos podemos copiar strings nós

19184
12:45:20,480 --> 12:45:22,956
pode procurar dados dentro de strings que nós

19185
12:45:22,956 --> 12:45:25,200
pode fazer todos os tipos de coisas loucas, mas nós

19186
12:45:25,200 --> 12:45:27,680
verá que c strings não são isso

19187
12:45:27,680 --> 12:45:30,320
fácil ou conveniente para trabalhar para

19188
12:45:30,320 --> 12:45:32,800
Um exemplo que você precisa acompanhar como

19189
12:45:32,800 --> 12:45:35,520
grande a corda está na memória que você precisa para

19190
12:45:35,520 --> 12:45:38,160
Lembre-se também de garantir que ele termine

19191
12:45:38,160 --> 12:45:39,916
corretamente e veremos os detalhes

19192
12:45:39,916 --> 12:45:42,320
A respeito disso nesta longa história do capítulo

19193
12:45:42,320 --> 12:45:44,800
strings c curtos não são seguros ou

19194
12:45:44,800 --> 12:45:47,360
conveniente para trabalhar com em c mais plus

19195
12:45:47,360 --> 12:45:50,000
e c plus fornecer outro tipo

19196
12:45:50,000 --> 12:45:52,640
que realmente se baseia no topo do personagem

19197
12:45:52,640 --> 12:45:55,520
arrays, mas isso nos dá um mais fácil

19198
12:45:55,520 --> 12:45:58,160
interface para trabalhar e podemos apenas

19199
12:45:58,160 --> 12:46:00,480
foco em armazenar nos dados e fazer

19200
12:46:00,480 --> 12:46:03,520
coisas com ele em nossos programas c plus e

19201
12:46:03,520 --> 12:46:05,200
A grande ideia sobre o que vamos fazer

19202
12:46:05,200 --> 12:46:08,000
fazer neste capítulo é aprender sobre

19203
12:46:08,000 --> 12:46:10,720
as instalações que temos em c plus plus para

19204
12:46:10,720 --> 12:46:13,436
lidar com dados de texto em nosso c plus mais

19205
12:46:13,436 --> 12:46:15,520
programas na próxima palestra vamos

19206
12:46:15,520 --> 12:46:17,360
para começar e mostrar como você pode

19207
12:46:17,360 --> 12:46:18,400
manipular

19208
12:46:18,400 --> 12:46:20,560
Personagens individuais em um personagem

19209
12:46:20,560 --> 12:46:21,520
Array

19210
12:46:21,520 --> 12:46:23,756
Vá em frente e termine aqui e me encontre

19211
12:46:23,756 --> 12:46:24,720
lá

19212
12:46:24,720 --> 12:46:25,916
Nesta palestra vamos ser

19213
12:46:25,916 --> 12:46:28,240
aprender sobre algumas instalações no c

19214
12:46:28,240 --> 12:46:30,560
plus plus biblioteca padrão

19215
12:46:30,560 --> 12:46:33,916
que podem nos ajudar a manipular personagens

19216
12:46:33,916 --> 12:46:35,916
E aqui estão algumas coisas que você pode querer

19217
12:46:35,916 --> 12:46:38,320
A ver com essas instalações, por exemplo

19218
12:46:38,320 --> 12:46:40,880
Você pode querer saber se um personagem é

19219
12:46:40,880 --> 12:46:43,596
alfanumérico ou se for um número ou um

19220
12:46:43,596 --> 12:46:45,916
Personagem que você pode querer saber se

19221
12:46:45,916 --> 12:46:48,160
É alfabético que você pode querer saber se

19222
12:46:48,160 --> 12:46:50,560
É um personagem em branco que você pode querer

19223
12:46:50,560 --> 12:46:52,640
Saiba se é uma maiúscula ou maiúscula.

19224
12:46:52,640 --> 12:46:54,400
Personagem dependendo do que você quer

19225
12:46:54,400 --> 12:46:56,800
fazer em sua aplicação, claro lá

19226
12:46:56,800 --> 12:46:58,800
são instalações para verificar se os personagens

19227
12:46:58,800 --> 12:47:01,840
são dígitos, existem mesmo aqueles que

19228
12:47:01,840 --> 12:47:04,160
Ajude-nos a conhecer a transformação de personagens

19229
12:47:04,160 --> 12:47:06,480
torná-los minúsculos ou maiúsculos e

19230
12:47:06,480 --> 12:47:07,840
nós vamos ver

19231
12:47:07,840 --> 12:47:10,000
Estes exemplos aqui são

19232
12:47:10,000 --> 12:47:11,880
Documentado em

19233
12:47:11,880 --> 12:47:14,240
cppreference.com para que você possa ir lá e

19234
12:47:14,240 --> 12:47:17,116
Encontre a documentação aqui é a mesma

19235
12:47:17,116 --> 12:47:19,840
link aberto no meu navegador você vê que

19236
12:47:19,840 --> 12:47:23,360
eles saem na biblioteca tipo cc para que você

19237
12:47:23,360 --> 12:47:25,276
Preciso disso incluído se você quiser usar

19238
12:47:25,276 --> 12:47:27,756
eles e você vê que há um grande

19239
12:47:27,756 --> 12:47:30,160
Um monte deles vamos cobrir apenas

19240
12:47:30,160 --> 12:47:32,560
uma seção deles e eu vou deixar você

19241
12:47:32,560 --> 12:47:34,880
para usar a documentação se você precisar

19242
12:47:34,880 --> 12:47:37,276
Use mais esses caras nosso primeiro

19243
12:47:37,276 --> 12:47:39,360
O exemplo aqui vai nos ajudar a verificar

19244
12:47:39,360 --> 12:47:42,400
se um caractere é alfa numérico e o

19245
12:47:42,400 --> 12:47:44,080
Função que vamos usar a partir do c

19246
12:47:44,080 --> 12:47:48,160
plus plus biblioteca padrão é std is l

19247
12:47:48,160 --> 12:47:48,956
num em série

19248
12:47:48,956 --> 12:47:51,840
e você simplesmente passa um parâmetro de um

19249
12:47:51,840 --> 12:47:54,400
personagem e vai te dizer se

19250
12:47:54,400 --> 12:47:57,276
um caractere é alfanumérico ou se

19251
12:47:57,276 --> 12:47:59,200
Não é se é alfanumérico você é

19252
12:47:59,200 --> 12:48:00,880
obter um valor diferente

19253
12:48:00,880 --> 12:48:02,956
de zero que pode ser tratado como um

19254
12:48:02,956 --> 12:48:04,956
Verdadeiro se não é você vai ter um

19255
12:48:04,956 --> 12:48:07,276
valor que você pode tratar como um zero e

19256
12:48:07,276 --> 12:48:09,756
Como eu sei bem que podemos verificar o

19257
12:48:09,756 --> 12:48:12,560
documentação para que eu volte para o nosso

19258
12:48:12,560 --> 12:48:13,840
link aqui

19259
12:48:13,840 --> 12:48:16,640
e há uma função aqui é i'll num

19260
12:48:16,640 --> 12:48:19,680
Eu posso abri-lo em outra guia e é

19261
12:48:19,680 --> 12:48:21,520
Vou me dizer o que essa função faz

19262
12:48:21,520 --> 12:48:23,596
Verifica se for dado o personagem que você

19263
12:48:23,596 --> 12:48:26,276
passar como um parâmetro aqui é um

19264
12:48:26,276 --> 12:48:29,040
Caráter alfanumérico conforme classificado por

19265
12:48:29,040 --> 12:48:30,880
a siluca atual

19266
12:48:30,880 --> 12:48:31,756
Então,

19267
12:48:31,756 --> 12:48:34,000
Vai nos dizer se o personagem

19268
12:48:34,000 --> 12:48:34,956
É

19269
12:48:34,956 --> 12:48:37,360
alfanumérico ou não você dá um

19270
12:48:37,360 --> 12:48:40,160
Personagem e o que você obtém dele é

19271
12:48:40,160 --> 12:48:42,160
O valor de retorno aqui vai

19272
12:48:42,160 --> 12:48:44,800
retornar um valor diferente de zero se o personagem

19273
12:48:44,800 --> 12:48:47,916
é alfa numérico, então esse valor diferente de zero

19274
12:48:47,916 --> 12:48:49,756
que é um inteiro porque é isso que

19275
12:48:49,756 --> 12:48:51,840
Vamos sair desta função

19276
12:48:51,840 --> 12:48:53,840
ser tratado como um verdadeiro

19277
12:48:53,840 --> 12:48:56,160
e se este personagem aqui não é alfa

19278
12:48:56,160 --> 12:48:58,640
Numérico, vamos conseguir zero que nós

19279
12:48:58,640 --> 12:49:00,480
pode tratar como um falso, isso é realmente

19280
12:49:00,480 --> 12:49:01,916
legal e se você descer aqui você está

19281
12:49:01,916 --> 12:49:03,840
Vou encontrar alguns exemplos que eu não

19282
12:49:03,840 --> 12:49:06,000
Quer que você se preocupe com este c local

19283
12:49:06,000 --> 12:49:06,880
uma coisa

19284
12:49:06,880 --> 12:49:08,560
É um

19285
12:49:08,560 --> 12:49:10,956
A configuração que lhe permite

19286
12:49:10,956 --> 12:49:12,800
Diga mais sobre o significado do

19287
12:49:12,800 --> 12:49:14,480
Personagens que você está armazenando

19288
12:49:14,480 --> 12:49:16,240
memória, mas por enquanto vamos apenas

19289
12:49:16,240 --> 12:49:18,956
Ficar feliz com os padrões e usar isso

19290
12:49:18,956 --> 12:49:21,200
Função como é que vai funcionar

19291
12:49:21,200 --> 12:49:23,596
o suficiente bem bem aqui é a nossa função

19292
12:49:23,596 --> 12:49:26,640
novamente assim aqui c é alfanumérico nós

19293
12:49:26,640 --> 12:49:28,720
Espera obter um valor

19294
12:49:28,720 --> 12:49:30,720
diferente de zero porque c é

19295
12:49:30,720 --> 12:49:33,116
alfanumérico e o segundo exemplo aqui

19296
12:49:33,116 --> 12:49:35,756
não é alfanumérico, então esperamos obter

19297
12:49:35,756 --> 12:49:38,400
Um valor igual a zero e que podemos

19298
12:49:38,400 --> 12:49:40,720
Use o retorno desta função

19299
12:49:40,720 --> 12:49:42,880
em um teste, por exemplo, podemos dizer a

19300
12:49:42,880 --> 12:49:44,720
personagem que colocamos em uma estrela aqui é

19301
12:49:44,720 --> 12:49:48,720
chamado carro de entrada e dizemos f is al num

19302
12:49:48,720 --> 12:49:50,800
E nós passamos esse personagem que estamos indo

19303
12:49:50,800 --> 12:49:52,800
para imprimir esse personagem é alfa

19304
12:49:52,800 --> 12:49:54,956
Numérico se não for, vamos imprimir

19305
12:49:54,956 --> 12:49:57,200
Não é alfa numérico você pode fazer isso e

19306
12:49:57,200 --> 12:49:59,680
você pode fazer todos os tipos de testes loucos em

19307
12:49:59,680 --> 12:50:02,400
suas aplicações c plus mais aqui é

19308
12:50:02,400 --> 12:50:04,720
Outro exemplo que podemos usar para conhecer

19309
12:50:04,720 --> 12:50:08,400
se o caractere é alfabético, então é

19310
12:50:08,400 --> 12:50:11,040
retornar um valor diferente de

19311
12:50:11,040 --> 12:50:14,160
zero se o caractere é um alfabeto

19312
12:50:14,160 --> 12:50:16,956
personagem a through z que vai

19313
12:50:16,956 --> 12:50:19,520
Retorne algo diferente do zero e

19314
12:50:19,520 --> 12:50:21,520
Se passarmos por algo que não é para

19315
12:50:21,520 --> 12:50:22,720
O exemplo

19316
12:50:22,720 --> 12:50:25,436
Esta segunda linha aqui ou os sete em

19317
12:50:25,436 --> 12:50:27,596
A terceira linha aqui vamos conseguir um

19318
12:50:27,596 --> 12:50:29,916
valor igual a zero, porque isso não é

19319
12:50:29,916 --> 12:50:32,160
alfabético, temos outra instalação para

19320
12:50:32,160 --> 12:50:34,720
ajudar a verificar se um personagem é um preto

19321
12:50:34,720 --> 12:50:37,040
personagem e vemos um exemplo que

19322
12:50:37,040 --> 12:50:39,040
Aqui temos um array de caracteres chamado

19323
12:50:39,040 --> 12:50:41,116
Mensagem temos um par de espaços em branco

19324
12:50:41,116 --> 12:50:44,560
dentro e podemos caçar por eles usando

19325
12:50:44,560 --> 12:50:47,596
a facilidade em branco a partir do c plus

19326
12:50:47,596 --> 12:50:49,680
mais biblioteca padrão aqui temos um

19327
12:50:49,680 --> 12:50:51,756
variável que vai acompanhar

19328
12:50:51,756 --> 12:50:54,640
Quantos personagens negros estão aqui

19329
12:50:54,640 --> 12:50:56,240
é inicializado para zero e nós vamos

19330
12:50:56,240 --> 12:50:58,640
para dar a volta bem e nós vamos

19331
12:50:58,640 --> 12:51:02,400
olhar pela quantidade igual ao tamanho de

19332
12:51:02,400 --> 12:51:04,720
o array da mensagem aqui nós podemos usar std

19333
12:51:04,720 --> 12:51:07,200
tamanho novamente porque este é um array de linha

19334
12:51:07,200 --> 12:51:09,916
é uma matriz estática e podemos usar o sdd

19335
12:51:09,916 --> 12:51:11,756
Tamanho vai nos dar quantos

19336
12:51:11,756 --> 12:51:13,916
personagens que temos nesta matriz você

19337
12:51:13,916 --> 12:51:16,320
Já sabe disso e se chegarmos dentro

19338
12:51:16,320 --> 12:51:19,040
Vamos tentar verificar e ver se

19339
12:51:19,040 --> 12:51:20,800
O personagem atual

19340
12:51:20,800 --> 12:51:23,520
é um branco se é que vamos imprimir

19341
12:51:23,520 --> 12:51:26,320
Isso fora e nós vamos incrementar

19342
12:51:26,320 --> 12:51:29,840
nossa conta em branco no momento em que este loop

19343
12:51:29,840 --> 12:51:32,240
Está feito, teremos impresso muito

19344
12:51:32,240 --> 12:51:34,880
de caracteres em branco se acontecermos com

19345
12:51:34,880 --> 12:51:37,596
tê-los em nossa mensagem e no final

19346
12:51:37,596 --> 12:51:39,436
nós vamos dizer no total que encontramos

19347
12:51:39,436 --> 12:51:41,680
No entanto, muitos caracteres em branco este é

19348
12:51:41,680 --> 12:51:43,040
O que nós vamos ver

19349
12:51:43,040 --> 12:51:45,360
Se executarmos este programa e espero que você

19350
12:51:45,360 --> 12:51:47,116
Pode ver quão útil

19351
12:51:47,116 --> 12:51:49,276
Isso pode ser em processamento de texto

19352
12:51:49,276 --> 12:51:52,240
aplicações se isso acontecer com o que

19353
12:51:52,240 --> 12:51:54,320
Você está trabalhando em que vamos correr

19354
12:51:54,320 --> 12:51:56,480
este exemplo em código de estúdio visual em um

19355
12:51:56,480 --> 12:51:58,480
Minuto aqui é outro exemplo que nós

19356
12:51:58,480 --> 12:52:00,400
pode ser usado para verificar se um personagem é

19357
12:52:00,400 --> 12:52:02,320
maiúscula ou

19358
12:52:02,320 --> 12:52:04,956
Em minúsculas, temos uma variedade de personagens

19359
12:52:04,956 --> 12:52:07,596
Aqui dentro temos algum texto

19360
12:52:07,596 --> 12:52:10,240
e temos algumas variáveis para manter

19361
12:52:10,240 --> 12:52:12,956
faixa de quantos personagens são

19362
12:52:12,956 --> 12:52:15,680
minúsculo ou maiúsculo que vamos

19363
12:52:15,680 --> 12:52:17,596
configurar um loop que vai ser um

19364
12:52:17,596 --> 12:52:20,400
alcance baseado em loop e sabemos que

19365
12:52:20,400 --> 12:52:22,956
Por std é mais baixo

19366
12:52:22,956 --> 12:52:25,276
Vamos aumentar o minúsculo

19367
12:52:25,276 --> 12:52:27,276
contar se for maiúsculo, vamos

19368
12:52:27,276 --> 12:52:29,040
incrementar a contagem maiúscula esta é

19369
12:52:29,040 --> 12:52:30,640
Como podemos fazer isso

19370
12:52:30,640 --> 12:52:32,880
e nós vamos imprimir isso

19371
12:52:32,880 --> 12:52:35,116
informações quando o loop aqui é feito

19372
12:52:35,116 --> 12:52:37,436
OK, ainda temos alguns exemplos pela frente

19373
12:52:37,436 --> 12:52:38,956
o atual vai verificar se um

19374
12:52:38,956 --> 12:52:40,800
Personagem é um dígito se você quiser fazer

19375
12:52:40,800 --> 12:52:43,276
que você pode usar isso e nós temos um

19376
12:52:43,276 --> 12:52:45,520
matriz de personagens aqui e nós vamos

19377
12:52:45,520 --> 12:52:49,520
ter para dígitos dentro desta mensagem aqui

19378
12:52:49,520 --> 12:52:51,596
Vamos fazer basicamente o mesmo

19379
12:52:51,596 --> 12:52:53,520
O que vamos configurar uma variável

19380
12:52:53,520 --> 12:52:56,400
que vai manter o controle de quantos

19381
12:52:56,400 --> 12:52:59,116
Os dígitos que temos nesta mensagem somos

19382
12:52:59,116 --> 12:53:01,276
indo para loop em torno de usando um alcance baseado

19383
12:53:01,276 --> 12:53:03,596
para loop, vamos verificar se

19384
12:53:03,596 --> 12:53:05,680
O personagem atual é um dígito e nós somos

19385
12:53:05,680 --> 12:53:06,880
Indo para dentro de nós.

19386
12:53:06,880 --> 12:53:08,480
incremento

19387
12:53:08,480 --> 12:53:10,640
nossa variável aqui se acontecer de

19388
12:53:10,640 --> 12:53:12,880
o caso e no final nós vamos

19389
12:53:12,880 --> 12:53:16,080
Diga quantos dígitos encontramos em nosso

19390
12:53:16,080 --> 12:53:18,640
Mensagem aqui é este simples o último

19391
12:53:18,640 --> 12:53:20,640
O exemplo que vamos olhar para

19392
12:53:20,640 --> 12:53:23,840
Ajude-nos a transformar um personagem em minúsculas

19393
12:53:23,840 --> 12:53:26,320
ou maiúsculas e aqui está um exemplo de que

19394
12:53:26,320 --> 12:53:28,880
Vai nos ajudar a brincar conosco, nós somos

19395
12:53:28,880 --> 12:53:30,480
Vou ter um

19396
12:53:30,480 --> 12:53:33,040
matriz de caracteres chamada home the feeling

19397
12:53:33,040 --> 12:53:35,276
de pertencimento e vamos montar um

19398
12:53:35,276 --> 12:53:38,080
array de caracteres de destino

19399
12:53:38,080 --> 12:53:40,160
que nós vamos armazenar o que quer que seja

19400
12:53:40,160 --> 12:53:41,916
Quer se estabelecer em

19401
12:53:41,916 --> 12:53:43,436
Aqui você vê um loop que vai

19402
12:53:43,436 --> 12:53:47,116
transformar nossa mensagem aqui em maiúsculas

19403
12:53:47,116 --> 12:53:49,596
e você vê que nós vamos dar uma volta

19404
12:53:49,596 --> 12:53:52,000
por esta quantidade o tamanho do original

19405
12:53:52,000 --> 12:53:52,956
A força

19406
12:53:52,956 --> 12:53:55,360
E nós vamos pegar cada um

19407
12:53:55,360 --> 12:53:57,916
personagem em cada iteração

19408
12:53:57,916 --> 12:54:00,720
e virando isso para o maiúsculo isso é

19409
12:54:00,720 --> 12:54:04,080
O que std para função superior faz o

19410
12:54:04,080 --> 12:54:06,640
O resultado será armazenado em

19411
12:54:06,640 --> 12:54:09,200
nossa cadeia de destino e pelo tempo

19412
12:54:09,200 --> 12:54:11,520
nós terminamos aqui a string original é

19413
12:54:11,520 --> 12:54:14,400
No entanto, foi apenas maiúsculas

19414
12:54:14,400 --> 12:54:16,956
string vai ser armazenado em nosso

19415
12:54:16,956 --> 12:54:19,360
array de destino e se nós imprimi-lo para fora

19416
12:54:19,360 --> 12:54:21,840
Devemos ver essa coisa impressa em

19417
12:54:21,840 --> 12:54:24,240
O maiúsculo podemos basicamente fazer o mesmo

19418
12:54:24,240 --> 12:54:27,520
coisa e transformar a corda em minúsculas

19419
12:54:27,520 --> 12:54:29,680
e nossa string de destino vai

19420
12:54:29,680 --> 12:54:31,596
ser agora minúsculo e você vai ver

19421
12:54:31,596 --> 12:54:34,000
que isso funciona muito bem

19422
12:54:34,000 --> 12:54:36,956
Agora que você tem uma compreensão básica

19423
12:54:36,956 --> 12:54:39,116
sobre como essas coisas funcionam, estamos indo

19424
12:54:39,116 --> 12:54:41,520
para ir ao código do estúdio vg e jogar

19425
12:54:41,520 --> 12:54:44,480
conosco ok aqui estamos em nosso trabalho

19426
12:54:44,480 --> 12:54:46,240
diretório do projeto atual é

19427
12:54:46,240 --> 12:54:48,320
Manipulação de personagens

19428
12:54:48,320 --> 12:54:50,800
vamos pegar nossos arquivos de modelo

19429
12:54:50,800 --> 12:54:53,040
Como sempre fazemos e vamos colocar

19430
12:54:53,040 --> 12:54:55,200
Isso no lugar e nós vamos abrir

19431
12:54:55,200 --> 12:54:57,840
Isso em código de estúdio visual muito rápido

19432
12:54:57,840 --> 12:54:59,840
e nós vamos descer e colocar

19433
12:54:59,840 --> 12:55:02,160
nosso primeiro exemplo, este exemplo está indo

19434
12:55:02,160 --> 12:55:06,240
usar o std é uma instalação num

19435
12:55:06,240 --> 12:55:08,160
E isso vai verificar se o

19436
12:55:08,160 --> 12:55:10,000
Personagem é alfa numérico que vamos

19437
12:55:10,000 --> 12:55:12,240
para ver o que temos a partir disso se imprimirmos

19438
12:55:12,240 --> 12:55:14,800
Isso vamos verificar se c o

19439
12:55:14,800 --> 12:55:17,040
O personagem c é alfanumérico que estamos indo

19440
12:55:17,040 --> 12:55:18,880
para ver o que temos e vamos

19441
12:55:18,880 --> 12:55:21,276
Verifique se esse personagem aqui eu não

19442
12:55:21,276 --> 12:55:23,756
Saiba como pronunciá-lo Eu sinto muito

19443
12:55:23,756 --> 12:55:25,596
nós vamos verificar se é

19444
12:55:25,596 --> 12:55:27,596
alfa numérico, vamos ver isso

19445
12:55:27,596 --> 12:55:29,680
e nós vamos usar isso em

19446
12:55:29,680 --> 12:55:31,680
condição que vamos verificar e ver

19447
12:55:31,680 --> 12:55:34,000
Se o nosso personagem estrela aqui é

19448
12:55:34,000 --> 12:55:35,756
alfanumérico e vamos imprimir

19449
12:55:35,756 --> 12:55:37,436
que vamos dizer que é alfa

19450
12:55:37,436 --> 12:55:39,520
numérico ou não é do

19451
12:55:39,520 --> 12:55:41,756
Documentação sabemos que esta coisa

19452
12:55:41,756 --> 12:55:44,240
Vive no cctype

19453
12:55:44,240 --> 12:55:46,720
Biblioteca para que possamos querer incluir isso

19454
12:55:46,720 --> 12:55:49,116
Mas é possível que esteja chegando

19455
12:55:49,116 --> 12:55:51,520
do iostream aqui é por isso que não

19456
12:55:51,520 --> 12:55:52,640
Veja

19457
12:55:52,640 --> 12:55:54,640
código de estúdio visual reclamando aqui como

19458
12:55:54,640 --> 12:55:56,880
Um exemplo se tentarmos e comentarmos

19459
12:55:56,880 --> 12:55:58,480
Isso inclui aqui

19460
12:55:58,480 --> 12:56:00,560
Você vai ver isso

19461
12:56:00,560 --> 12:56:02,880
Isso não vai fazer mais sentido

19462
12:56:02,880 --> 12:56:06,000
Tudo bem para que o inclua necessário para usá-los

19463
12:56:06,000 --> 12:56:09,360
Caras aqui está vindo do io stream OK

19464
12:56:09,360 --> 12:56:11,840
então nós não vamos incluir isso aqui

19465
12:56:11,840 --> 12:56:15,756
Vamos abrir um terminal

19466
12:56:15,756 --> 12:56:18,800
e construir isso com gcc e você está indo

19467
12:56:18,800 --> 12:56:20,720
ver que o bloco é bom se formos

19468
12:56:20,720 --> 12:56:23,756
para baixo e claro, vamos limpar corretamente e

19469
12:56:23,756 --> 12:56:26,240
correr galo vamos ver que c é

19470
12:56:26,240 --> 12:56:28,640
alfanumérico porque temos um

19471
12:56:28,640 --> 12:56:30,956
Um pode ser tratado como um verdadeiro e

19472
12:56:30,956 --> 12:56:33,040
O caráter aqui não é alfanumérico

19473
12:56:33,040 --> 12:56:35,680
Porque resultado é zero

19474
12:56:35,680 --> 12:56:37,840
E você vê que a estrela aqui também é

19475
12:56:37,840 --> 12:56:40,480
Não é alfa numérico e sabemos disso

19476
12:56:40,480 --> 12:56:42,800
através do nosso teste aqui e você vê que

19477
12:56:42,800 --> 12:56:44,956
Podemos fazer coisas assim

19478
12:56:44,956 --> 12:56:47,756
Com esta facilidade aqui, se você quiser

19479
12:56:47,756 --> 12:56:50,640
se tornar verdadeiro ou falso desta função você

19480
12:56:50,640 --> 12:56:53,680
pode transformar isso em booleanos usando estática

19481
12:56:53,680 --> 12:56:55,756
elenco, mas não vamos fazer isso aqui

19482
12:56:55,756 --> 12:56:58,240
Você já sabe que podemos comentar

19483
12:56:58,240 --> 12:57:00,320
Isso fora por enquanto e olhe para outro

19484
12:57:00,320 --> 12:57:02,560
Instalações a partir do

19485
12:57:02,560 --> 12:57:05,436
cctype library existem muitos destes

19486
12:57:05,436 --> 12:57:07,116
nós vamos olhar para alguns de

19487
12:57:07,116 --> 12:57:09,520
Vamos comentar isso e

19488
12:57:09,520 --> 12:57:12,400
ir para baixo e colocar em um código aqui e isso

19489
12:57:12,400 --> 12:57:14,560
Vai verificar se um personagem é

19490
12:57:14,560 --> 12:57:17,040
alfabética se for um alfabeto

19491
12:57:17,040 --> 12:57:18,080
personagem

19492
12:57:18,080 --> 12:57:21,116
a de z minúsculo e maiúsculo

19493
12:57:21,116 --> 12:57:23,680
c é alfabético o caractere aqui é

19494
12:57:23,680 --> 12:57:26,400
Não alfabético e sete aqui não é

19495
12:57:26,400 --> 12:57:29,436
alfabeto assim para o primeiro aqui

19496
12:57:29,436 --> 12:57:31,680
nós vamos conseguir alguma coisa

19497
12:57:31,680 --> 12:57:34,720
Não igual a zero devemos obter um

19498
12:57:34,720 --> 12:57:37,840
Isso é o que eles usam na maioria dos casos para

19499
12:57:37,840 --> 12:57:39,360
Isso nós vamos ter um zero o

19500
12:57:39,360 --> 12:57:41,276
segundo e para o terceiro somos

19501
12:57:41,276 --> 12:57:43,596
também obter um zero é isso que nós

19502
12:57:43,596 --> 12:57:44,640
Esperar

19503
12:57:44,640 --> 12:57:47,756
vamos construir com gcc, é claro

19504
12:57:47,756 --> 12:57:50,240
e nós vamos limpar e correr

19505
12:57:50,240 --> 12:57:51,436
Galo

19506
12:57:51,436 --> 12:57:53,596
e nós vamos conseguir que c é

19507
12:57:53,596 --> 12:57:56,720
alfabético, esse cara não é alfabético

19508
12:57:56,720 --> 12:57:59,596
e sete não é alfabético se mudarmos

19509
12:57:59,596 --> 12:58:01,680
este c para uh

19510
12:58:01,680 --> 12:58:03,840
e por exemplo, minúscula

19511
12:58:03,840 --> 12:58:05,520
E ambos novamente você vai ver isso

19512
12:58:05,520 --> 12:58:07,116
Os resultados serão o que nós

19513
12:58:07,116 --> 12:58:09,680
Esperar e é alfabético

19514
12:58:09,680 --> 12:58:12,240
Vamos limpar e correr galo este é

19515
12:58:12,240 --> 12:58:14,400
Será exatamente o que esperamos, mas

19516
12:58:14,400 --> 12:58:16,800
você vê que não é um e este é

19517
12:58:16,800 --> 12:58:19,596
Não garantido para sempre dar-lhe um

19518
12:58:19,596 --> 12:58:21,756
É garantido para lhe dar algo

19519
12:58:21,756 --> 12:58:24,400
diferente de zero se o personagem é

19520
12:58:24,400 --> 12:58:27,916
alfabética e zero se não e nós podemos

19521
12:58:27,916 --> 12:58:30,160
Use este cara aqui em um teste

19522
12:58:30,160 --> 12:58:31,596
Por exemplo,

19523
12:58:31,596 --> 12:58:35,596
Podemos dizer que f esdd é alfa e se estamos

19524
12:58:35,596 --> 12:58:37,840
Ferido os dois vai ser bom e

19525
12:58:37,840 --> 12:58:40,080
nós vamos limpar e correr o galo e

19526
12:58:40,080 --> 12:58:42,880
você vê e é alfabético i deve colocar um

19527
12:58:42,880 --> 12:58:45,276
Espaço aqui encorajo você a mudar

19528
12:58:45,276 --> 12:58:47,360
esses personagens para cima e ver o que você obtém

19529
12:58:47,360 --> 12:58:49,436
aqui e veja como você pode usar isso que é

19530
12:58:49,436 --> 12:58:52,320
em testes que é a melhor maneira de aprender

19531
12:58:52,320 --> 12:58:54,240
OK antes de continuar Eu faço para incentivar

19532
12:58:54,240 --> 12:58:56,720
você para tentar executar esses métodos através de

19533
12:58:56,720 --> 12:58:58,956
Compiladores diferentes, por exemplo, aqui nós

19534
12:58:58,956 --> 12:59:01,916
também tem um compilador msvc a partir de

19535
12:59:01,916 --> 12:59:04,240
configuração de microsoft para que possamos usar isso e

19536
12:59:04,240 --> 12:59:06,800
Tente construir essa coisa aqui, mas antes

19537
12:59:06,800 --> 12:59:09,916
Fazemos isso, vamos trazer a nossa caneta aqui

19538
12:59:09,916 --> 12:59:11,400
e remover

19539
12:59:11,400 --> 12:59:14,240
Galo.exe aqui porque

19540
12:59:14,240 --> 12:59:16,956
nós não queremos anular isso, nós vamos

19541
12:59:16,956 --> 12:59:19,756
para selecioná-lo e excluir

19542
12:59:19,756 --> 12:59:22,240
e eu vou remover isso e mover

19543
12:59:22,240 --> 12:59:24,480
que para a lixeira

19544
12:59:24,480 --> 12:59:26,640
E eu vou limpar o que eu tenho

19545
12:59:26,640 --> 12:59:28,560
Aqui no terminal

19546
12:59:28,560 --> 12:59:30,956
E eu vou para lá eu vou para

19547
12:59:30,956 --> 12:59:32,640
Escolher a tarefa de execução

19548
12:59:32,640 --> 12:59:35,596
e eu vou escolher o mundo com msvc

19549
12:59:35,596 --> 12:59:37,040
Aqui

19550
12:59:37,040 --> 12:59:39,200
Eu vou usar que ele vai

19551
12:59:39,200 --> 12:59:41,520
construir o meu thang você vê a saída aqui

19552
12:59:41,520 --> 12:59:44,480
e nós temos galo.exe aqui

19553
12:59:44,480 --> 12:59:46,800
E deve dizer que o mundo é bom

19554
12:59:46,800 --> 12:59:49,680
em um minuto o mundo terminou com sucesso

19555
12:59:49,680 --> 12:59:51,520
A Microsoft vai nos dar muito

19556
12:59:51,520 --> 12:59:54,400
saída aqui, mas nenhum problema a compilação é

19557
12:59:54,400 --> 12:59:55,200
Bom

19558
12:59:55,200 --> 12:59:56,880
Se nós entrarmos

19559
12:59:56,880 --> 12:59:58,880
Podemos realmente verificar

19560
12:59:58,880 --> 13:00:01,200
e ver o que temos

19561
13:00:01,200 --> 13:00:02,640
em nossa pasta aqui você vai ver

19562
13:00:02,640 --> 13:00:05,200
que temos esses arquivos, um deles é

19563
13:00:05,200 --> 13:00:07,436
laoster.exe

19564
13:00:07,436 --> 13:00:10,000
Se nós executá-lo, vamos conseguir o

19565
13:00:10,000 --> 13:00:11,840
saídas que esperamos e você vê que

19566
13:00:11,840 --> 13:00:14,400
É exatamente a mesma coisa que temos

19567
13:00:14,400 --> 13:00:16,400
com o Gcc

19568
13:00:16,400 --> 13:00:17,840
Estou lhe dizendo para tentar usar

19569
13:00:17,840 --> 13:00:19,756
Compiladores diferentes porque alguns

19570
13:00:19,756 --> 13:00:23,116
Os compiladores vão achatar alguns dos

19571
13:00:23,116 --> 13:00:25,756
instalações do cctype

19572
13:00:25,756 --> 13:00:29,276
ou aqueles que começam com c como não seguro

19573
13:00:29,276 --> 13:00:31,200
Porque existem alguns tanques que podem

19574
13:00:31,200 --> 13:00:33,200
realmente te joga fora sobre eles e

19575
13:00:33,200 --> 13:00:34,800
Vamos aprender sobre eles nisso

19576
13:00:34,800 --> 13:00:37,040
Capítulo à medida que avançamos, apenas saiba

19577
13:00:37,040 --> 13:00:38,800
que é uma boa ideia tentar estes

19578
13:00:38,800 --> 13:00:41,276
coisas em diferentes compiladores e ver

19579
13:00:41,276 --> 13:00:43,200
Os erros que você recebe e se faz

19580
13:00:43,200 --> 13:00:45,596
familiarizado com essas coisas

19581
13:00:45,596 --> 13:00:47,200
Por enquanto, vamos seguir em frente e nós

19582
13:00:47,200 --> 13:00:48,880
Eles vão continuar a usar

19583
13:00:48,880 --> 13:00:51,840
gcc porque esse é o meu compilador favorito

19584
13:00:51,840 --> 13:00:53,680
você pode usar o compilador que quiser

19585
13:00:53,680 --> 13:00:55,436
O próximo exemplo vai verificar se

19586
13:00:55,436 --> 13:00:58,000
O personagem está em branco, vamos fechar isso

19587
13:00:58,000 --> 13:00:58,880
uma coisa

19588
13:00:58,880 --> 13:01:00,720
e claro

19589
13:01:00,720 --> 13:01:03,756
e dar-nos algum espaço para respirar

19590
13:01:03,756 --> 13:01:05,276
nós vamos derrubar isso um pouco

19591
13:01:05,276 --> 13:01:06,800
mordeu e vamos verificar se

19592
13:01:06,800 --> 13:01:09,116
O personagem está em branco a facilidade para isso

19593
13:01:09,116 --> 13:01:11,596
É std está em branco

19594
13:01:11,596 --> 13:01:13,360
E se é um personagem em branco, nós somos

19595
13:01:13,360 --> 13:01:15,040
Vou ter algo diferente do que

19596
13:01:15,040 --> 13:01:17,276
zero e podemos usar isso em um teste como

19597
13:01:17,276 --> 13:01:19,436
Isto e se não for um preto, vamos

19598
13:01:19,436 --> 13:01:21,840
para obter algo igual a zero e isso

19599
13:01:21,840 --> 13:01:24,000
Teste aqui vai falhar, então o que isso

19600
13:01:24,000 --> 13:01:25,360
O exemplo aqui vai fazer isso está indo

19601
13:01:25,360 --> 13:01:27,436
para contar quantos caracteres em branco nós

19602
13:01:27,436 --> 13:01:28,880
ter neste

19603
13:01:28,880 --> 13:01:31,200
mensagem aqui e vamos imprimir

19604
13:01:31,200 --> 13:01:33,040
O contador disso no console usando

19605
13:01:33,040 --> 13:01:34,956
Esta linha aqui, então vamos passar por isso

19606
13:01:34,956 --> 13:01:36,400
loop e ver o que ele faz o primeiro

19607
13:01:36,400 --> 13:01:39,436
O que fazemos é inicializar a contagem em branco para

19608
13:01:39,436 --> 13:01:41,756
0 e estamos usando um inteiro e

19609
13:01:41,756 --> 13:01:44,560
Porque isso é uma contagem eu penso em branco

19610
13:01:44,560 --> 13:01:47,200
A contagem é de tipo errado porque pode ser

19611
13:01:47,200 --> 13:01:50,320
negativo para realmente estar seguro em nossa

19612
13:01:50,320 --> 13:01:52,000
programa aqui devemos fazer isso

19613
13:01:52,000 --> 13:01:54,800
não assinado ou mesmo usar tamanho t

19614
13:01:54,800 --> 13:01:58,080
Isso é melhor, então vamos usar o tamanho

19615
13:01:58,080 --> 13:01:59,040
t

19616
13:01:59,040 --> 13:02:01,916
porque este é um tamanho e tamanho t é

19617
13:02:01,916 --> 13:02:04,956
bom tipo para manter o controle de tamanhos em seu

19618
13:02:04,956 --> 13:02:07,520
c plus programas, então certifique-se de que você

19619
13:02:07,520 --> 13:02:09,360
Tamanho t aqui

19620
13:02:09,360 --> 13:02:11,436
e o que vamos fazer

19621
13:02:11,436 --> 13:02:13,520
é ir no loop em cada iteração

19622
13:02:13,520 --> 13:02:15,756
Vamos verificar se cada personagem

19623
13:02:15,756 --> 13:02:17,680
em cada iteração é um branco se for

19624
13:02:17,680 --> 13:02:19,756
Vamos cair aqui e dizer isso

19625
13:02:19,756 --> 13:02:22,956
encontramos um caractere em branco neste índice

19626
13:02:22,956 --> 13:02:24,880
em nossa matriz aqui

19627
13:02:24,880 --> 13:02:26,800
e nós vamos incrementar o nosso branco

19628
13:02:26,800 --> 13:02:28,956
conta e no momento em que este loop é

19629
13:02:28,956 --> 13:02:30,720
Já que vamos ter o branco

19630
13:02:30,720 --> 13:02:32,800
conta armazenada nesta conta em branco

19631
13:02:32,800 --> 13:02:34,640
variável e vamos imprimir isso

19632
13:02:34,640 --> 13:02:36,400
fora é esta simples

19633
13:02:36,400 --> 13:02:39,840
Agora podemos construir com gcc vamos fazer isso

19634
13:02:39,840 --> 13:02:42,400
nós estamos indo para o mundo com o nosso gcc

19635
13:02:42,400 --> 13:02:43,840
Compilador

19636
13:02:43,840 --> 13:02:45,916
E o mundo vai ser bom

19637
13:02:45,916 --> 13:02:47,200
claro

19638
13:02:47,200 --> 13:02:48,800
e correr o galo

19639
13:02:48,800 --> 13:02:50,880
e você vai ver isso

19640
13:02:50,880 --> 13:02:52,800
Vai dizer que encontramos um branco

19641
13:02:52,800 --> 13:02:54,956
caractere no índice 5

19642
13:02:54,956 --> 13:02:59,596
12 20 24 31 35 39 e 42

19643
13:02:59,596 --> 13:03:01,840
e no total encontramos nove em branco

19644
13:03:01,840 --> 13:03:04,400
Personagens temos que muitos vamos

19645
13:03:04,400 --> 13:03:08,240
conte assim um caractere em branco

19646
13:03:08,240 --> 13:03:11,040
Temos dois aqui que temos três

19647
13:03:11,040 --> 13:03:12,000
Quatro

19648
13:03:12,000 --> 13:03:13,596
Nós temos cinco

19649
13:03:13,596 --> 13:03:14,640
Aqui

19650
13:03:14,640 --> 13:03:16,320
Nós temos seis

19651
13:03:16,320 --> 13:03:17,200
sete

19652
13:03:17,200 --> 13:03:18,956
Oito e nove se você contar você está indo

19653
13:03:18,956 --> 13:03:21,040
para descobrir que nós os temos e o primeiro

19654
13:03:21,040 --> 13:03:25,040
um está no índice cinco, então o índice zero é h

19655
13:03:25,040 --> 13:03:27,596
um dois três, quatro o primeiro é em

19656
13:03:27,596 --> 13:03:30,400
índice cinco e isso está fazendo exatamente

19657
13:03:30,400 --> 13:03:33,040
o que queremos podemos descer e verificar se

19658
13:03:33,040 --> 13:03:36,320
um personagem é maiúsculo ou minúsculo nós

19659
13:03:36,320 --> 13:03:39,436
pode fazer isso através de um exemplo como este

19660
13:03:39,436 --> 13:03:41,756
e a instalação vai ser std

19661
13:03:41,756 --> 13:03:44,880
inferior e std é superior, temos uma mensagem

19662
13:03:44,880 --> 13:03:46,160
Aqui

19663
13:03:46,160 --> 13:03:48,080
nós vamos dar a volta usando um intervalo

19664
13:03:48,080 --> 13:03:50,000
Baseado para loop e vamos verificar

19665
13:03:50,000 --> 13:03:52,720
se cada caractere for inferior ou

19666
13:03:52,720 --> 13:03:53,916
maiúsculas

19667
13:03:53,916 --> 13:03:55,916
E se o teste for bom, vamos

19668
13:03:55,916 --> 13:03:57,596
saltar no loop e nós vamos

19669
13:03:57,596 --> 13:04:00,080
incremente menor contagem que são

19670
13:04:00,080 --> 13:04:03,116
Algumas variáveis para acompanhar quantos

19671
13:04:03,116 --> 13:04:05,040
caracteres maiúsculos e minúsculos nós

19672
13:04:05,040 --> 13:04:07,436
ter aqui e novamente estas variáveis

19673
13:04:07,436 --> 13:04:09,436
Eles vão armazenar contagens, então é

19674
13:04:09,436 --> 13:04:10,560
O melhor

19675
13:04:10,560 --> 13:04:13,840
para usar um tamanho t ou algum inteiro não assinado

19676
13:04:13,840 --> 13:04:16,080
tipo mas agora vamos usar o tamanho t

19677
13:04:16,080 --> 13:04:18,480
Porque é bom, então vamos

19678
13:04:18,480 --> 13:04:20,320
manter isso armazenado aqui e nós estamos indo

19679
13:04:20,320 --> 13:04:22,480
para construir isso e ver o que temos

19680
13:04:22,480 --> 13:04:26,000
Antes de correr, queremos limpar

19681
13:04:26,000 --> 13:04:29,680
e vamos construir com gcc

19682
13:04:29,680 --> 13:04:31,840
O parafuso vai ser bom, estamos indo

19683
13:04:31,840 --> 13:04:34,080
para limpar e correr galo

19684
13:04:34,080 --> 13:04:36,800
E você vê que o fio original é

19685
13:04:36,800 --> 13:04:38,720
Este cara aqui o que vamos fazer

19686
13:04:38,720 --> 13:04:40,400
Vamos imprimir qualquer personagem

19687
13:04:40,400 --> 13:04:42,640
Estamos em que eu vou colocar um espaço em

19688
13:04:42,640 --> 13:04:45,360
diante disso e vamos ver

19689
13:04:45,360 --> 13:04:48,400
incrementa esta é a saída por que nós

19690
13:04:48,400 --> 13:04:50,640
Tenho este método aqui porque nós somos

19691
13:04:50,640 --> 13:04:52,400
impressão para fora

19692
13:04:52,400 --> 13:04:55,116
cada personagem e nós não estamos imprimindo

19693
13:04:55,116 --> 13:04:57,596
Os maiúsculas que estamos imprimindo

19694
13:04:57,596 --> 13:05:00,400
minúsculas, é por isso que você vê

19695
13:05:00,400 --> 13:05:02,400
Esse cara aqui é realmente interessante

19696
13:05:02,400 --> 13:05:04,640
Você pode manter isso se você quiser que eu esteja

19697
13:05:04,640 --> 13:05:06,800
Vou manter isso no importante

19698
13:05:06,800 --> 13:05:09,436
A mensagem é que encontramos minúsculo

19699
13:05:09,436 --> 13:05:11,756
personagens e caracteres maiúsculos e

19700
13:05:11,756 --> 13:05:14,240
temos cinco caracteres maiúsculos se nós

19701
13:05:14,240 --> 13:05:16,080
Vamos entrar e contar que vamos encontrar isso

19702
13:05:16,080 --> 13:05:18,240
Nós não temos aqui um

19703
13:05:18,240 --> 13:05:22,160
Dois e três e quatro e cinco

19704
13:05:22,160 --> 13:05:24,320
caracteres maiúsculos e se você contar

19705
13:05:24,320 --> 13:05:26,720
os caracteres minúsculos um por um eu sou

19706
13:05:26,720 --> 13:05:29,360
certo de que você vai ter um 47 como

19707
13:05:29,360 --> 13:05:30,800
nós fizemos aqui nós vamos comentar isso

19708
13:05:30,800 --> 13:05:33,360
porque este foi apenas um exemplo

19709
13:05:33,360 --> 13:05:35,596
Eu estou deixando isso aqui para que você

19710
13:05:35,596 --> 13:05:37,756
pode usar isso como uma referência se você quiser

19711
13:05:37,756 --> 13:05:40,240
Também podemos verificar se um personagem é um

19712
13:05:40,240 --> 13:05:41,916
dígito

19713
13:05:41,916 --> 13:05:44,956
e nós vamos usar std é dígito para

19714
13:05:44,956 --> 13:05:46,720
Verifique se o tipo de retorno está indo para

19715
13:05:46,720 --> 13:05:48,560
ser diferente de zero

19716
13:05:48,560 --> 13:05:51,116
Se o teste for bem-sucedido se falhar, estamos

19717
13:05:51,116 --> 13:05:52,880
Vou obter um zero e podemos usar isso

19718
13:05:52,880 --> 13:05:55,916
assim, então temos uma mensagem aqui

19719
13:05:55,916 --> 13:05:58,800
armazenado no array de caracteres chamado

19720
13:05:58,800 --> 13:06:00,000
Declaração

19721
13:06:00,000 --> 13:06:02,160
e nós vamos fazer loop em torno da verificação

19722
13:06:02,160 --> 13:06:04,800
Se cada personagem em que estamos é realmente

19723
13:06:04,800 --> 13:06:06,720
Um dígito ou não se é um dígito que somos

19724
13:06:06,720 --> 13:06:08,320
Vou dizer que encontrei um dígito que eu vou

19725
13:06:08,320 --> 13:06:10,160
Diga o dígito que encontramos e nós somos

19726
13:06:10,160 --> 13:06:12,400
vai aumentar a contagem de dígitos e

19727
13:06:12,400 --> 13:06:14,320
Vamos armazenar essa informação em

19728
13:06:14,320 --> 13:06:17,276
esta variável de contagem de dígitos aqui não

19729
13:06:17,276 --> 13:06:19,200
Quero fazer um fim para que vamos

19730
13:06:19,200 --> 13:06:21,436
torná-lo um tamanho t

19731
13:06:21,436 --> 13:06:23,040
e nós vamos construir e executar isso

19732
13:06:23,040 --> 13:06:24,080
O programa

19733
13:06:24,080 --> 13:06:26,956
e ver quantos dígitos encontramos você

19734
13:06:26,956 --> 13:06:28,800
Eu sei que é esse número aqui eu não

19735
13:06:28,800 --> 13:06:30,160
Vou dizer isso

19736
13:06:30,160 --> 13:06:32,400
Vamos deixar o nosso programa figurar

19737
13:06:32,400 --> 13:06:34,840
Isso fora tão galo e nós vamos

19738
13:06:34,840 --> 13:06:38,560
Encontre dois e um, então encontramos três

19739
13:06:38,560 --> 13:06:40,880
dígitos e é exatamente o que esperamos

19740
13:06:40,880 --> 13:06:41,916
Aqui

19741
13:06:41,916 --> 13:06:43,840
nós vamos comentar isso e mostrar

19742
13:06:43,840 --> 13:06:46,320
outro exemplo e no último

19743
13:06:46,320 --> 13:06:48,000
Por exemplo, vamos mostrar a você

19744
13:06:48,000 --> 13:06:49,756
que você pode mudar o caso de um

19745
13:06:49,756 --> 13:06:52,320
personagem se é minúsculo torná-lo

19746
13:06:52,320 --> 13:06:54,400
Mais maiúsculo se for maiúsculo, faça-o

19747
13:06:54,400 --> 13:06:56,480
menor e você pode fazer coisas como

19748
13:06:56,480 --> 13:06:59,520
que temos uma mensagem aqui armazenada em

19749
13:06:59,520 --> 13:07:02,720
nossa matriz de caracteres chamada original str

19750
13:07:02,720 --> 13:07:04,640
nós configuramos outro array que está indo

19751
13:07:04,640 --> 13:07:08,160
para armazenar nossa mensagem que é transformada

19752
13:07:08,160 --> 13:07:10,000
e nós vamos dar a volta girar

19753
13:07:10,000 --> 13:07:12,800
Tudo o que encontramos em maiúsculas

19754
13:07:12,800 --> 13:07:14,880
A maneira como fazemos isso, vamos dizer

19755
13:07:14,880 --> 13:07:17,116
std para o topo

19756
13:07:17,116 --> 13:07:19,116
E nós vamos passar no personagem

19757
13:07:19,116 --> 13:07:21,200
que queremos nos voltar para maiúsculas se nós

19758
13:07:21,200 --> 13:07:23,520
Fazer isso nós vamos ter um maiúsculo

19759
13:07:23,520 --> 13:07:26,000
personagem fora disso e nós vamos

19760
13:07:26,000 --> 13:07:28,800
Armazene isso em nosso destino

19761
13:07:28,800 --> 13:07:31,200
array neste índice aqui é este

19762
13:07:31,200 --> 13:07:33,040
Simples depois disso vamos imprimir

19763
13:07:33,040 --> 13:07:35,520
O fio original e o maiúsculo

19764
13:07:35,520 --> 13:07:37,680
string devemos obter isso impresso para fora

19765
13:07:37,680 --> 13:07:39,520
Porque é armazenado

19766
13:07:39,520 --> 13:07:42,160
em cadeia de destino aqui

19767
13:07:42,160 --> 13:07:43,840
E nós vamos fazer o contrário e

19768
13:07:43,840 --> 13:07:46,560
transformar isso de volta em minúsculas

19769
13:07:46,560 --> 13:07:47,840
nós vamos pegar o original

19770
13:07:47,840 --> 13:07:50,560
força loop sobre ele e em cada um

19771
13:07:50,560 --> 13:07:52,480
iteração, vamos conseguir o que quer que seja

19772
13:07:52,480 --> 13:07:53,436


19773
13:07:53,436 --> 13:07:56,160
e virar isso para maiúscula para minúsculo

19774
13:07:56,160 --> 13:07:57,436
Eu deveria dizer

19775
13:07:57,436 --> 13:07:59,756
E o resultado disso vai ser

19776
13:07:59,756 --> 13:08:02,880
armazenado de volta em nossa cadeia de destino assim

19777
13:08:02,880 --> 13:08:04,640
Vamos sobrescrever o que quer que sejamos

19778
13:08:04,640 --> 13:08:07,436
ter em nosso destino string aqui e

19779
13:08:07,436 --> 13:08:08,956
Depois disso, vamos ramificar o

19780
13:08:08,956 --> 13:08:11,040
string minúsculo e devemos conseguir isso

19781
13:08:11,040 --> 13:08:12,720
impresso é assim que é o exemplo

19782
13:08:12,720 --> 13:08:14,880
funciona e se você tem algum problema

19783
13:08:14,880 --> 13:08:17,360
Entendendo isso, estou sempre por perto

19784
13:08:17,360 --> 13:08:20,160
Por favor, pergunte que vou fazer o melhor que posso

19785
13:08:20,160 --> 13:08:22,800
para ajudá-lo por enquanto nós vamos

19786
13:08:22,800 --> 13:08:24,240
Construa isso

19787
13:08:24,240 --> 13:08:26,800
com gcc o construtor vai ser bom

19788
13:08:26,800 --> 13:08:28,320
nós vamos limpar e nós vamos

19789
13:08:28,320 --> 13:08:31,116
correr booster e vamos ver isso

19790
13:08:31,116 --> 13:08:33,276
A mensagem é aqui que está virada

19791
13:08:33,276 --> 13:08:35,520
maiúsculas é virada na caixa inferior e

19792
13:08:35,520 --> 13:08:38,080
É assim que você pode fazer essas coisas aqui

19793
13:08:38,080 --> 13:08:41,200
Então nós olhamos para alguns destes

19794
13:08:41,200 --> 13:08:43,520
instalações de cctime eu realmente não

19795
13:08:43,520 --> 13:08:45,756
Quero olhar para todos eles porque isso

19796
13:08:45,756 --> 13:08:48,800
seria realmente chato eu espero que você tenha

19797
13:08:48,800 --> 13:08:50,956
uma ideia de como eles funcionam e se você

19798
13:08:50,956 --> 13:08:52,560
Quero olhar para todos eles tudo o que você tem

19799
13:08:52,560 --> 13:08:55,200
O fazer é chegar à documentação aqui

19800
13:08:55,200 --> 13:08:56,800
Escolha um

19801
13:08:56,800 --> 13:08:59,360
abra e veja a documentação

19802
13:08:59,360 --> 13:09:01,360
Na maioria dos casos, eles vão ter

19803
13:09:01,360 --> 13:09:04,000
exemplos aqui em que você pode olhar

19804
13:09:04,000 --> 13:09:05,360
e jogar com

19805
13:09:05,360 --> 13:09:06,880
Por enquanto, vamos parar por aqui

19806
13:09:06,880 --> 13:09:08,640
Esta palestra é realmente tudo o que estabelecemos

19807
13:09:08,640 --> 13:09:11,276
para fazer para brincar com muitos destes

19808
13:09:11,276 --> 13:09:14,080
instalações da biblioteca cctype em

19809
13:09:14,080 --> 13:09:15,680
A próxima palestra vamos ver

19810
13:09:15,680 --> 13:09:18,400
Como podemos manipular cordas c e por

19811
13:09:18,400 --> 13:09:20,720
que queremos dizer coletá-los ou

19812
13:09:20,720 --> 13:09:23,116
colocando-os juntos copiando-os para fora

19813
13:09:23,116 --> 13:09:25,840
e fazendo todos os tipos de coisas loucas

19814
13:09:25,840 --> 13:09:28,160
Vá em frente e termine aqui e me encontre

19815
13:09:28,160 --> 13:09:29,040
lá

19816
13:09:29,040 --> 13:09:30,560
Nesta palestra vamos olhar

19817
13:09:30,560 --> 13:09:33,116
as instalações do c plus plus

19818
13:09:33,116 --> 13:09:36,080
biblioteca padrão para jogar com strings c

19819
13:09:36,080 --> 13:09:38,160
Todos estes vão sair para dentro

19820
13:09:38,160 --> 13:09:40,560
a biblioteca de string c você pode ir e

19821
13:09:40,560 --> 13:09:42,956
confira em cpp referência e estamos

19822
13:09:42,956 --> 13:09:44,400
Vou começar e olhar para alguns

19823
13:09:44,400 --> 13:09:47,116
Exemplos de algumas das coisas que podemos fazer

19824
13:09:47,116 --> 13:09:49,596
com esta biblioteca eu quero dizer c string

19825
13:09:49,596 --> 13:09:51,436
A primeira coisa que vamos olhar é

19826
13:09:51,436 --> 13:09:53,756
Exemplo de como podemos verificar o comprimento

19827
13:09:53,756 --> 13:09:56,560
de uma força aqui temos um personagem

19828
13:09:56,560 --> 13:09:58,720
array chamado mensagem um é um

19829
13:09:58,720 --> 13:10:01,040
matriz de caracteres e você vê que nós fizemos

19830
13:10:01,040 --> 13:10:04,800
Const nós também temos outro array que

19831
13:10:04,800 --> 13:10:07,360
é apontado para o ponteiro você sabe que

19832
13:10:07,360 --> 13:10:09,200
Se fizermos coisas como esta matriz é

19833
13:10:09,200 --> 13:10:11,520
indo para decair em um ponteiro e lá

19834
13:10:11,520 --> 13:10:13,360
São algumas coisas que podemos fazer com isso para

19835
13:10:13,360 --> 13:10:16,480
exemplo, não podemos usá-lo com std tamanho

19836
13:10:16,480 --> 13:10:19,276
e não podemos usar um intervalo baseado em loop

19837
13:10:19,276 --> 13:10:21,916
para percorrer esta mensagem para agradecer

19838
13:10:21,916 --> 13:10:22,720
Você

19839
13:10:22,720 --> 13:10:23,520


19840
13:10:23,520 --> 13:10:26,480
sdr, então, vai nos ajudar a verificar o

19841
13:10:26,480 --> 13:10:28,956
comprimento desta coisa aqui para que possamos usar

19842
13:10:28,956 --> 13:10:33,436
por exemplo, se fizermos hdd sdr lam

19843
13:10:33,436 --> 13:10:34,800
mensagem um que vamos receber o

19844
13:10:34,800 --> 13:10:36,720
O número de personagens

19845
13:10:36,720 --> 13:10:38,000
dentro deste

19846
13:10:38,000 --> 13:10:40,400
string aqui isso não vai contar

19847
13:10:40,400 --> 13:10:42,560
o caráter nulo embora assim o null

19848
13:10:42,560 --> 13:10:44,880
personagem que é implicitamente adicionado por

19849
13:10:44,880 --> 13:10:46,880
O compilador não vai ser contado

19850
13:10:46,880 --> 13:10:48,080
Aqui você vai ver isso em um

19851
13:10:48,080 --> 13:10:50,480
minuto quando atingimos o código do estúdio visual para

19852
13:10:50,480 --> 13:10:52,956
brincar com isso, obrigado, mas esta facilidade

19853
13:10:52,956 --> 13:10:55,840
pode funcionar independentemente de você estar

19854
13:10:55,840 --> 13:10:58,320
usando um array de linha como este ou até mesmo para

19855
13:10:58,320 --> 13:11:00,800
apontadores como este e é muito legal

19856
13:11:00,800 --> 13:11:02,720
para que possamos usá-lo assim, estamos indo

19857
13:11:02,720 --> 13:11:05,116
para obtê-lo impresso, por favor, note que

19858
13:11:05,116 --> 13:11:08,320
nós também podemos usar o tamanho do operador para

19859
13:11:08,320 --> 13:11:10,400
obter a mesma coisa para que ele vai

19860
13:11:10,400 --> 13:11:13,436
trabalhar quase da mesma maneira, mas o tamanho de

19861
13:11:13,436 --> 13:11:15,360
O operador vai incluir o null

19862
13:11:15,360 --> 13:11:17,840
personagem que você precisa estar ciente disso

19863
13:11:17,840 --> 13:11:20,640
A coisa boa sobre str lan aqui é

19864
13:11:20,640 --> 13:11:23,040
que ainda funciona por uma década de matrizes

19865
13:11:23,040 --> 13:11:25,596
então, se o usarmos na mensagem 2, vamos

19866
13:11:25,596 --> 13:11:26,480
para chegar

19867
13:11:26,480 --> 13:11:28,400
a saída correta que vamos obter

19868
13:11:28,400 --> 13:11:30,480
o número de personagens aqui em que

19869
13:11:30,480 --> 13:11:31,680
É muito legal

19870
13:11:31,680 --> 13:11:34,400
e também podemos tentar imprimir o

19871
13:11:34,400 --> 13:11:35,680
Tamanho de

19872
13:11:35,680 --> 13:11:37,520
mensagem dois, mas aqui vamos conseguir

19873
13:11:37,520 --> 13:11:39,916
o tamanho de um ponteiro impresso bem

19874
13:11:39,916 --> 13:11:43,360
É assim que hdr lan funciona, ele permite que você

19875
13:11:43,360 --> 13:11:45,756
Avaliar o comprimento de uma vertente aqui é

19876
13:11:45,756 --> 13:11:49,360
outro exemplo e é str cmp ou

19877
13:11:49,360 --> 13:11:51,596
string compare é usado para comparar

19878
13:11:51,596 --> 13:11:53,276
strings sobre com o que você vai fazer

19879
13:11:53,276 --> 13:11:56,160
Esta facilidade é dar-lhe dois fios c

19880
13:11:56,160 --> 13:11:58,480
fios que devemos ser exatos

19881
13:11:58,480 --> 13:12:02,240
e um é esse cara aqui l h ace ou esquerda

19882
13:12:02,240 --> 13:12:04,240
corda de mão eu acho que é isso

19883
13:12:04,240 --> 13:12:06,640
significa e nós vamos dar uma

19884
13:12:06,640 --> 13:12:08,800
fio da mão direita e pelo caminho estes

19885
13:12:08,800 --> 13:12:11,276
As assinaturas são copiadas diretamente do

19886
13:12:11,276 --> 13:12:13,436
documentação para que possamos olhar para

19887
13:12:13,436 --> 13:12:15,840
Isso em um slide para torná-lo realmente fácil

19888
13:12:15,840 --> 13:12:17,916
Seguir isto vai devolver um

19889
13:12:17,916 --> 13:12:20,880
Valor negativo se o primeiro homem acontecer

19890
13:12:20,880 --> 13:12:22,640
para vir antes

19891
13:12:22,640 --> 13:12:26,000
O segundo cara em ordem lexicográfica

19892
13:12:26,000 --> 13:12:28,160
É algo como uma vem na frente

19893
13:12:28,160 --> 13:12:30,720
de b c vem na frente de d ou algo assim

19894
13:12:30,720 --> 13:12:33,200
Assim, se os dois fios são iguais

19895
13:12:33,200 --> 13:12:34,956
Vai voltar

19896
13:12:34,956 --> 13:12:37,040
zero e vai voltar um positivo

19897
13:12:37,040 --> 13:12:38,000
valor

19898
13:12:38,000 --> 13:12:40,400
Se o primeiro cara aparecer depois do

19899
13:12:40,400 --> 13:12:41,840
Segundo cara

19900
13:12:41,840 --> 13:12:43,680
Tudo bem e nós vamos tentar isso nós

19901
13:12:43,680 --> 13:12:46,240
têm duas cordas alabama e la bama

19902
13:12:46,240 --> 13:12:48,560
aqui e eles são armazenados em caráter

19903
13:12:48,560 --> 13:12:50,880
arrays que são apontados por estes dois

19904
13:12:50,880 --> 13:12:52,956
ponteiros string dados um e string dados

19905
13:12:52,956 --> 13:12:55,200
Dois e nós podemos fazer algo assim

19906
13:12:55,200 --> 13:12:56,880
Abaixo aqui, então vamos imprimir

19907
13:12:56,880 --> 13:12:58,080
alguma coisa para fora

19908
13:12:58,080 --> 13:13:00,240
e nós vamos dizer std string

19909
13:13:00,240 --> 13:13:02,080
Comparar e vamos passar no

19910
13:13:02,080 --> 13:13:04,320
primeira corda e a segunda string para

19911
13:13:04,320 --> 13:13:06,320
Agora eu quero que você faça uma pausa um pouco e

19912
13:13:06,320 --> 13:13:07,756
Tente adivinhar o que vamos conseguir

19913
13:13:07,756 --> 13:13:09,200
Impressãoi para fora aqui

19914
13:13:09,200 --> 13:13:11,276
A primeira corda é alabama a segunda

19915
13:13:11,276 --> 13:13:14,240
Um é blá blá, então o primeiro vem

19916
13:13:14,240 --> 13:13:16,160
Na frente do segundo

19917
13:13:16,160 --> 13:13:18,080
e vemos que vamos conseguir um

19918
13:13:18,080 --> 13:13:21,116
valor negativo se o primeiro cara entrar

19919
13:13:21,116 --> 13:13:23,756
diante do segundo cara, então alabama vem

19920
13:13:23,756 --> 13:13:25,916
em frente ao blabama

19921
13:13:25,916 --> 13:13:27,840
e nós esperamos conseguir algo

19922
13:13:27,840 --> 13:13:30,160
Negativo a partir desta coisa que estamos fazendo

19923
13:13:30,160 --> 13:13:31,520
Aqui

19924
13:13:31,520 --> 13:13:33,360
e novamente se tentarmos mudá-los para cima

19925
13:13:33,360 --> 13:13:35,276
Um pouco você vê que alabama ainda

19926
13:13:35,276 --> 13:13:38,240
vem antes de uma la bomba

19927
13:13:38,240 --> 13:13:39,916
Então vamos obter um valor negativo

19928
13:13:39,916 --> 13:13:41,596
apontou e podemos mudar isso

19929
13:13:41,596 --> 13:13:43,520
coisas para ver o que conseguimos é

19930
13:13:43,520 --> 13:13:46,000
muito simples se você sabe como usar

19931
13:13:46,000 --> 13:13:48,000
também podemos usar outra versão de

19932
13:13:48,000 --> 13:13:50,000
string compare qual vai nos deixar

19933
13:13:50,000 --> 13:13:52,240
especificar o número de caracteres que nós

19934
13:13:52,240 --> 13:13:54,160
Quer comparar

19935
13:13:54,160 --> 13:13:57,116
podemos especificar que queremos comparar n

19936
13:13:57,116 --> 13:13:58,956
Personagens neste caso são três

19937
13:13:58,956 --> 13:14:01,436
Personagens e vai comparar a

19938
13:14:01,436 --> 13:14:04,320
seção das strings que você especificar

19939
13:14:04,320 --> 13:14:07,040
como um primeiro e segundo parâmetro aqui,

19940
13:14:07,040 --> 13:14:09,116
por exemplo, se mudarmos string que i

19941
13:14:09,116 --> 13:14:12,320
quer ser um i a e string data dois

19942
13:14:12,320 --> 13:14:16,000
para b a a a a n a a e estamos comparando

19943
13:14:16,000 --> 13:14:17,680
Três personagens aqui, então estamos

19944
13:14:17,680 --> 13:14:20,560
comparando aaa para aaa que vamos ver

19945
13:14:20,560 --> 13:14:22,240
que eles são iguais e nós vamos

19946
13:14:22,240 --> 13:14:24,640
obter um 0 impresso aqui você está indo para

19947
13:14:24,640 --> 13:14:26,720
Veja que este é exatamente o caso quando

19948
13:14:26,720 --> 13:14:28,800
Nós começamos a brincar conosco no estúdio visual

19949
13:14:28,800 --> 13:14:30,320
Código em um minuto

19950
13:14:30,320 --> 13:14:32,800
Temos uma facilidade que podemos usar para

19951
13:14:32,800 --> 13:14:34,720
procure em uma string e procure por um

19952
13:14:34,720 --> 13:14:37,840
Caracter da facilidade para isso é sdr

19953
13:14:37,840 --> 13:14:40,956
chr e ele vai encontrar o primeiro

19954
13:14:40,956 --> 13:14:43,520
ocorrência de um caractere em uma cadeia de caracteres

19955
13:14:43,520 --> 13:14:45,596
e a documentação para isso é correta

19956
13:14:45,596 --> 13:14:46,480
Aqui

19957
13:14:46,480 --> 13:14:49,040
Observe que este exemplo é

19958
13:14:49,040 --> 13:14:50,560
Na verdade, copiado

19959
13:14:50,560 --> 13:14:52,880
diretamente da documentação

19960
13:14:52,880 --> 13:14:55,360
Tudo bem, então temos uma mensagem aqui

19961
13:14:55,360 --> 13:14:57,276
é uma matriz de caracteres e é

19962
13:14:57,276 --> 13:15:00,160
apontado por um ponteiro de carro de const chamado

19963
13:15:00,160 --> 13:15:02,640
hdr e nós temos um personagem alvo que

19964
13:15:02,640 --> 13:15:04,240
Estamos procurando

19965
13:15:04,240 --> 13:15:06,640
e o resultado será armazenado em

19966
13:15:06,640 --> 13:15:09,916
O array de caracteres de resultado aqui e nós

19967
13:15:09,916 --> 13:15:12,160
têm uma variável chamada iterações que

19968
13:15:12,160 --> 13:15:14,080
Vai acompanhar quantos

19969
13:15:14,080 --> 13:15:16,720
As iterações que fizemos para encontrar o nosso alvo

19970
13:15:16,720 --> 13:15:19,276
Aqui do jeito que esse cara trabalha, está indo

19971
13:15:19,276 --> 13:15:22,720
para retornar um ponteiro para o que você encontra

19972
13:15:22,720 --> 13:15:24,880
se for encontrado, por exemplo, aqui, se nós

19973
13:15:24,880 --> 13:15:28,080
encontrar esta primeira t esta função aqui ou

19974
13:15:28,080 --> 13:15:29,680
Esta instalação vai devolver um

19975
13:15:29,680 --> 13:15:32,240
ponteiro para este primeiro t aqui

19976
13:15:32,240 --> 13:15:34,480
Se não encontrar o que queremos é

19977
13:15:34,480 --> 13:15:36,400
vai retornar um ponteiro nulo que é

19978
13:15:36,400 --> 13:15:38,480
Como funciona e você pode ver isso no

19979
13:15:38,480 --> 13:15:40,720
documentação aqui vamos levar

19980
13:15:40,720 --> 13:15:42,956
vantagem de como funciona nisso enquanto

19981
13:15:42,956 --> 13:15:44,956
loop aqui e a maneira como você usa isso

19982
13:15:44,956 --> 13:15:46,880
facilidade que você lhe dá a força de você

19983
13:15:46,880 --> 13:15:49,040
Quero procurar e você dá

19984
13:15:49,040 --> 13:15:51,680
personagem que você está procurando, então se

19985
13:15:51,680 --> 13:15:53,680
Veja como funciona no tempo

19986
13:15:53,680 --> 13:15:55,596
loop aqui nós vamos chamar de

19987
13:15:55,596 --> 13:15:56,400
A função

19988
13:15:56,400 --> 13:15:58,720
e vamos armazenar o resultado em

19989
13:15:58,720 --> 13:16:01,596
nosso ponteiro de personagem aqui e se formos

19990
13:16:01,596 --> 13:16:03,916
Dentro, vamos acertar o primeiro

19991
13:16:03,916 --> 13:16:06,240
personagem aqui na primeira iteração, então

19992
13:16:06,240 --> 13:16:08,480
nós vamos encontrar isso t aqui e quando

19993
13:16:08,480 --> 13:16:10,320
nós achamos que o resultado disso está indo

19994
13:16:10,320 --> 13:16:12,880
para ser armazenado de volta em resultado aqui

19995
13:16:12,880 --> 13:16:15,116
Espero que isso faça sentido, então vamos

19996
13:16:15,116 --> 13:16:17,436
para encontrá-lo, vamos imprimi-lo e

19997
13:16:17,436 --> 13:16:19,436
vamos aumentar o resultado para fazer

19998
13:16:19,436 --> 13:16:21,596
aponta para o próximo personagem que é

19999
13:16:21,596 --> 13:16:24,880
ponteiro aritmética em ação aqui

20000
13:16:24,880 --> 13:16:26,560
E depois que fazemos isso, vamos

20001
13:16:26,560 --> 13:16:28,400
incrementar as iterações para que possamos

20002
13:16:28,400 --> 13:16:30,720
Já temos uma iteração e nós somos

20003
13:16:30,720 --> 13:16:33,116
indo pular no loop novamente, então o

20004
13:16:33,116 --> 13:16:34,880
string em que procuramos será

20005
13:16:34,880 --> 13:16:37,276
A partir de r aqui

20006
13:16:37,276 --> 13:16:39,436
então nós vamos tentar e encontrar

20007
13:16:39,436 --> 13:16:42,240
uma tn maiúscula e vai encontrar

20008
13:16:42,240 --> 13:16:45,360
Este maiúsculo t aqui, então ele vai

20009
13:16:45,360 --> 13:16:48,320
apontar para ele e o ponteiro para este t

20010
13:16:48,320 --> 13:16:50,240
vai ser armazenado neste resultado

20011
13:16:50,240 --> 13:16:52,560
Aqui está tudo bem e nós vamos pular para dentro

20012
13:16:52,560 --> 13:16:54,560
nosso corpo aqui vamos dizer que nós

20013
13:16:54,560 --> 13:16:57,276
Encontremos isso, vamos imprimi-lo

20014
13:16:57,276 --> 13:16:59,360
e nós vamos aumentar os resultados se

20015
13:16:59,360 --> 13:17:01,756
incremento reservado agora que a pesquisa é

20016
13:17:01,756 --> 13:17:04,720
Vou apontar para o h aqui

20017
13:17:04,720 --> 13:17:06,480
Tudo bem e nós vamos para

20018
13:17:06,480 --> 13:17:08,800
Diga quantas iterações fizemos para encontrar

20019
13:17:08,800 --> 13:17:11,276
Nossa coisa teremos impresso para fora

20020
13:17:11,276 --> 13:17:13,276
que nós encontramos e nós vamos

20021
13:17:13,276 --> 13:17:15,040
saltar para a próxima iteração que é

20022
13:17:15,040 --> 13:17:17,200
Vou procurar por t

20023
13:17:17,200 --> 13:17:19,116
no lembrete da corda aqui é

20024
13:17:19,116 --> 13:17:20,640
não vai encontrá-lo, é claro que é

20025
13:17:20,640 --> 13:17:22,956
não vai retornar nenhum ponteiro e teste

20026
13:17:22,956 --> 13:17:24,880
Aqui vai falhar e nós vamos

20027
13:17:24,880 --> 13:17:27,040
cair aqui e dizer quantos

20028
13:17:27,040 --> 13:17:29,436
iterações que encontramos que eu percebo isso

20029
13:17:29,436 --> 13:17:31,840
O exemplo pode ser realmente confuso eu sou

20030
13:17:31,840 --> 13:17:34,080
Vou tentar explicar de novo quando

20031
13:17:34,080 --> 13:17:36,720
atingimos o código do estúdio visual por enquanto observamos

20032
13:17:36,720 --> 13:17:39,520
que esta facilidade pode ajudá-lo a encontrar

20033
13:17:39,520 --> 13:17:41,360
caracteres em uma string que é o

20034
13:17:41,360 --> 13:17:43,200
Mensagem aqui também há outro

20035
13:17:43,200 --> 13:17:45,680
Função que ajuda você a encontrar o último

20036
13:17:45,680 --> 13:17:48,560
ocorrência de um caractere em uma cadeia de caracteres

20037
13:17:48,560 --> 13:17:50,240
Por exemplo, aqui temos um personagem

20038
13:17:50,240 --> 13:17:51,200
entrada

20039
13:17:51,200 --> 13:17:54,560
é um caminho para um arquivo em algum limite

20040
13:17:54,560 --> 13:17:56,640
sistema ou sistema mac

20041
13:17:56,640 --> 13:17:59,840
e nós temos um ponteiro de caracteres de saída

20042
13:17:59,840 --> 13:18:01,756
que vai armazenar o ponteiro para

20043
13:18:01,756 --> 13:18:04,560
O personagem que achamos bem se

20044
13:18:04,560 --> 13:18:06,080
Encontre o personagem que vamos armazenar

20045
13:18:06,080 --> 13:18:08,240
no ponteiro para esse personagem se nós

20046
13:18:08,240 --> 13:18:10,240
Não acho que vamos voltar não

20047
13:18:10,240 --> 13:18:12,320
Pontoro eu acho que é assim que esta coisa

20048
13:18:12,320 --> 13:18:13,276
Trabalhas

20049
13:18:13,276 --> 13:18:15,520
Então o que realmente queremos aqui

20050
13:18:15,520 --> 13:18:18,640
é procurar o nome do arquivo neste

20051
13:18:18,640 --> 13:18:20,956
caminho aqui e isso é realmente interessante

20052
13:18:20,956 --> 13:18:23,436
Então nós vamos procurar o

20053
13:18:23,436 --> 13:18:26,080
backslash o último e esta string

20054
13:18:26,080 --> 13:18:28,560
Aqui e vai encontrar esse cara

20055
13:18:28,560 --> 13:18:30,640
Porque essa é a última ocorrência

20056
13:18:30,640 --> 13:18:32,320
da barra traseira

20057
13:18:32,320 --> 13:18:34,880
em nossa string de entrada aqui uma vez que encontramos

20058
13:18:34,880 --> 13:18:37,276
nós vamos ter um ponteiro para esse cara

20059
13:18:37,276 --> 13:18:39,840
armazenado no ponteiro de caracteres de saída

20060
13:18:39,840 --> 13:18:41,756
Aqui e nós vamos imprimi-lo

20061
13:18:41,756 --> 13:18:43,116
O que vamos fazer, vamos

20062
13:18:43,116 --> 13:18:45,436
usar aritmética do ponteiro para mover isso

20063
13:18:45,436 --> 13:18:47,276
ponteiro para o próximo cara, porque isso é

20064
13:18:47,276 --> 13:18:49,360
O que realmente queremos imprimir

20065
13:18:49,360 --> 13:18:51,360
A partir da borda aqui e isso é

20066
13:18:51,360 --> 13:18:52,800
O que vamos conseguir quando imprimirmos

20067
13:18:52,800 --> 13:18:53,916
Isto para fora

20068
13:18:53,916 --> 13:18:56,080
Agora que temos olhado para tudo isso

20069
13:18:56,080 --> 13:18:58,320
Exemplos eu acho que é hora de ir para

20070
13:18:58,320 --> 13:19:00,480
código de estúdio visual e realmente jogou

20071
13:19:00,480 --> 13:19:02,956
E assim por diante, aqui estamos em nosso

20072
13:19:02,956 --> 13:19:05,680
pasta de trabalho o projeto atual é c

20073
13:19:05,680 --> 13:19:07,916
Manipulação de strings é o que nós somos

20074
13:19:07,916 --> 13:19:10,000
indo para trabalhar, vamos copiar o nosso

20075
13:19:10,000 --> 13:19:12,080
arquivos de modelo e vamos colocar

20076
13:19:12,080 --> 13:19:14,480
Isso no lugar

20077
13:19:14,480 --> 13:19:16,400
e nós vamos abrir isso em visual

20078
13:19:16,400 --> 13:19:19,116
Código de estúdio muito rápido, vamos incluir c

20079
13:19:19,116 --> 13:19:20,720
string porque é isso que estamos indo

20080
13:19:20,720 --> 13:19:22,800
para usar muitas das coisas que somos

20081
13:19:22,800 --> 13:19:24,640
Vou jogar com esta palestra

20082
13:19:24,640 --> 13:19:26,800
estão documentados neste pedaço de

20083
13:19:26,800 --> 13:19:29,040
documentação aqui para que você possa vir aqui

20084
13:19:29,040 --> 13:19:31,360
e obter mais detalhes do que poderíamos até

20085
13:19:31,360 --> 13:19:33,596
cobertura em um curso como este, vamos trazer

20086
13:19:33,596 --> 13:19:35,200
Isso um pouco e nós vamos

20087
13:19:35,200 --> 13:19:37,520
ir em nossa principal função e colocar no

20088
13:19:37,520 --> 13:19:40,320
primeira parte do código que podemos jogar com o

20089
13:19:40,320 --> 13:19:43,116
str land facility vai encontrar o

20090
13:19:43,116 --> 13:19:45,520
comprimento da força e vai

20091
13:19:45,520 --> 13:19:48,080
trabalho independentemente de você estar usando

20092
13:19:48,080 --> 13:19:50,880
uma matriz de linha como esta ou mesmo se você é

20093
13:19:50,880 --> 13:19:52,800
usando o ponteiro de caracteres para apontar para

20094
13:19:52,800 --> 13:19:55,116
sua matriz e isso é muito legal, então

20095
13:19:55,116 --> 13:19:57,436
Aqui nós temos a mensagem strlen um nós somos

20096
13:19:57,436 --> 13:19:58,640
vou imprimir isso, nós vamos

20097
13:19:58,640 --> 13:20:00,320
imprimir quantos personagens temos em

20098
13:20:00,320 --> 13:20:01,680
Este tipo aqui

20099
13:20:01,680 --> 13:20:03,916
Também vamos usar o tamanho de

20100
13:20:03,916 --> 13:20:06,160
Operador para tentar comparar essas coisas

20101
13:20:06,160 --> 13:20:08,560
Mas, por favor, saiba que o personagem nulo

20102
13:20:08,560 --> 13:20:10,240
será incluído se você usar

20103
13:20:10,240 --> 13:20:13,116
Tamanhoof aqui em uma matriz de linha

20104
13:20:13,116 --> 13:20:16,320
Isso é muito importante para saber

20105
13:20:16,320 --> 13:20:19,360
mas uma coisa interessante sobre hdr lan

20106
13:20:19,360 --> 13:20:21,596
é que também vai funcionar se você

20107
13:20:21,596 --> 13:20:23,680
estão armazenando sua matriz

20108
13:20:23,680 --> 13:20:25,680
e algo que é apontado por

20109
13:20:25,680 --> 13:20:28,880
ponteiro tão mesmo decaído ponteiros

20110
13:20:28,880 --> 13:20:30,640
Vai ser utilizável aqui e isto é

20111
13:20:30,640 --> 13:20:33,436
Muito legal para que também possamos tentar e imprimir

20112
13:20:33,436 --> 13:20:35,360
o tamanho da mensagem 2 que é apontado

20113
13:20:35,360 --> 13:20:37,840
Por um ponteiro de linha e nós vamos

20114
13:20:37,840 --> 13:20:39,520
Veja o que temos, mas sabemos que estamos

20115
13:20:39,520 --> 13:20:41,200
obter o tamanho de um ponteiro

20116
13:20:41,200 --> 13:20:43,680
Porque isso é o que realmente é mensagem

20117
13:20:43,680 --> 13:20:46,000
Dois aqui é apenas um ponteiro bom, vamos

20118
13:20:46,000 --> 13:20:48,160
Feche isto à esquerda

20119
13:20:48,160 --> 13:20:50,000
e nós vamos trazer a nossa

20120
13:20:50,000 --> 13:20:51,520
O terminal

20121
13:20:51,520 --> 13:20:54,160
e eu tento construir isso com gcc nós somos

20122
13:20:54,160 --> 13:20:55,916
vamos fazer isso para que vamos usar

20123
13:20:55,916 --> 13:20:57,596
gcc para construir isso

20124
13:20:57,596 --> 13:20:59,520
O mundo vai passar

20125
13:20:59,520 --> 13:21:01,596
e nós vamos limpar e correr galo

20126
13:21:01,596 --> 13:21:02,560
Mais uma vez

20127
13:21:02,560 --> 13:21:04,160
E isso vai nos dar o que nós

20128
13:21:04,160 --> 13:21:07,756
want sqr lan mensagem 1 é 16

20129
13:21:07,756 --> 13:21:10,720
tamanho da mensagem 1 é 17 porque sizeof

20130
13:21:10,720 --> 13:21:12,320
Também vai contar

20131
13:21:12,320 --> 13:21:16,320
o personagem null htrlen message2 você

20132
13:21:16,320 --> 13:21:18,400
Veja que funciona mesmo se

20133
13:21:18,400 --> 13:21:21,040
temos uma matriz deteriorada

20134
13:21:21,040 --> 13:21:23,916
que é apontado por um ponteiro e isso

20135
13:21:23,916 --> 13:21:26,160
é realmente útil se você precisar

20136
13:21:26,160 --> 13:21:28,640
o tamanho de um array como este você pode

20137
13:21:28,640 --> 13:21:30,800
Use hdr então e você vai conseguir o

20138
13:21:30,800 --> 13:21:33,916
tamanho dos dados, mas saiba que

20139
13:21:33,916 --> 13:21:36,160
nula terminar o caráter não é

20140
13:21:36,160 --> 13:21:39,680
contado se você usar hdr ln aqui e tamanho

20141
13:21:39,680 --> 13:21:42,160
da mensagem 2 vai ser 8 porque

20142
13:21:42,160 --> 13:21:44,400
que é o tamanho de um ponteiro sobre o nosso

20143
13:21:44,400 --> 13:21:47,276
sistema aqui, então saiba que esse cara é

20144
13:21:47,276 --> 13:21:48,640
apenas um ponteiro

20145
13:21:48,640 --> 13:21:51,200
Ok, essa é a mensagem aqui

20146
13:21:51,200 --> 13:21:52,880
nós vamos comentar isso para fora

20147
13:21:52,880 --> 13:21:55,080
A próxima coisa que vamos olhar é

20148
13:21:55,080 --> 13:21:57,756
strcmp que pode ser usado para comparar

20149
13:21:57,756 --> 13:21:59,040
As forças de força

20150
13:21:59,040 --> 13:22:01,840
então funciona exatamente como nós dizemos que é

20151
13:22:01,840 --> 13:22:04,000
Vou voltar algo negativo se

20152
13:22:04,000 --> 13:22:06,720
A primeira corda acontece para entrar

20153
13:22:06,720 --> 13:22:08,956
frente da segunda corda em

20154
13:22:08,956 --> 13:22:10,480
- Alexicographical

20155
13:22:10,480 --> 13:22:13,480
ordem

20156
13:22:25,360 --> 13:22:26,956
por exemplo, aqui temos algumas variáveis

20157
13:22:26,956 --> 13:22:29,596
nós temos alabama e blabama existem

20158
13:22:29,596 --> 13:22:31,680
As forças apontadas por

20159
13:22:31,680 --> 13:22:32,956
ponteiros

20160
13:22:32,956 --> 13:22:34,640
então eles são cordas c

20161
13:22:34,640 --> 13:22:37,436
e nós temos um par de outras cordas

20162
13:22:37,436 --> 13:22:40,240
armazenado em matrizes de linha como este e por

20163
13:22:40,240 --> 13:22:42,080
Fazendo isso eu quero provar que isso

20164
13:22:42,080 --> 13:22:44,480
A facilidade vai funcionar independentemente de

20165
13:22:44,480 --> 13:22:46,880
como sua matriz ou sua string c é

20166
13:22:46,880 --> 13:22:50,160
armazenados para que possamos usar isso aqui

20167
13:22:50,160 --> 13:22:51,840
para o nosso

20168
13:22:51,840 --> 13:22:54,480
c string ponteiro 2 por ponteiros

20169
13:22:54,480 --> 13:22:56,240
Vamos tentar comparar o que for

20170
13:22:56,240 --> 13:22:58,320
está em uma string data um

20171
13:22:58,320 --> 13:23:01,200
com dados de cadeia de caracteres dois dados de duas cadeias um tem

20172
13:23:01,200 --> 13:23:04,320
alabama string data dois tem blá blá assim

20173
13:23:04,320 --> 13:23:06,400
Se compararmos esses caras que esperamos

20174
13:23:06,400 --> 13:23:09,436
obter um valor negativo fora desta coisa

20175
13:23:09,436 --> 13:23:10,720
Aqui

20176
13:23:10,720 --> 13:23:12,480
strcmp

20177
13:23:12,480 --> 13:23:16,160
Porque alabama vem na frente de

20178
13:23:16,160 --> 13:23:19,520
blabama em nosso alfabeto, então a está na frente

20179
13:23:19,520 --> 13:23:21,596
de b então nós vamos ter um negativo

20180
13:23:21,596 --> 13:23:23,916
valor a partir disso e esperamos obter

20181
13:23:23,916 --> 13:23:25,680
A mesma coisa no segundo exemplo

20182
13:23:25,680 --> 13:23:27,840
Aqui, o que vai usar o que nós

20183
13:23:27,840 --> 13:23:30,400
loja em nossa matriz de linha

20184
13:23:30,400 --> 13:23:32,640
para que você entenda isso e

20185
13:23:32,640 --> 13:23:34,560
vamos tentar construir isso para ver

20186
13:23:34,560 --> 13:23:38,240
que passa através do nosso compilador gcc

20187
13:23:38,240 --> 13:23:39,916
O zumbido é bom

20188
13:23:39,916 --> 13:23:42,000
Então nós vamos limpar

20189
13:23:42,000 --> 13:23:44,080
e correr galo e você vai ver

20190
13:23:44,080 --> 13:23:46,000
que nós temos um negativo

20191
13:23:46,000 --> 13:23:47,756
Eu quero que você jogue com este agradecimento e

20192
13:23:47,756 --> 13:23:50,720
Tente mudar, por exemplo, o 8 com c

20193
13:23:50,720 --> 13:23:52,640
e ver o que você recebe

20194
13:23:52,640 --> 13:23:54,560
Tudo bem, vamos tentar construir, mas

20195
13:23:54,560 --> 13:23:56,880
Antes de tentarmos esperar ver o que

20196
13:23:56,880 --> 13:23:59,596
você tem c vem depois de blá blá

20197
13:23:59,596 --> 13:24:01,360
Então,

20198
13:24:01,360 --> 13:24:03,916
Se olharmos para esta descrição aqui nós

20199
13:24:03,916 --> 13:24:06,480
deve obter um valor positivo, porque

20200
13:24:06,480 --> 13:24:08,800
O primeiro cara vem depois

20201
13:24:08,800 --> 13:24:11,596
O segundo cara em ordem lexicográfica

20202
13:24:11,596 --> 13:24:13,840
Então devemos obter um valor positivo

20203
13:24:13,840 --> 13:24:17,040
pela primeira coisa que imprimimos aqui

20204
13:24:17,040 --> 13:24:19,040
OK, vamos soldar e ver se isso é o

20205
13:24:19,040 --> 13:24:21,520
Caso vamos construir com sucesso

20206
13:24:21,520 --> 13:24:24,080
nós vamos limpar e correr o galo e

20207
13:24:24,080 --> 13:24:26,400
Você vê que o primeiro cara imprime um

20208
13:24:26,400 --> 13:24:27,520
porque

20209
13:24:27,520 --> 13:24:30,560
cla gamma vem antes de blá blá

20210
13:24:30,560 --> 13:24:32,480
E o segundo vai

20211
13:24:32,480 --> 13:24:35,276
Ainda ser um negativo porque ainda

20212
13:24:35,276 --> 13:24:36,080


20213
13:24:36,080 --> 13:24:38,080
O que tínhamos antes lá, tudo bem

20214
13:24:38,080 --> 13:24:40,240
É assim que você trabalha com isso, obrigado

20215
13:24:40,240 --> 13:24:42,800
Vamos voltar isso para o Alabama

20216
13:24:42,800 --> 13:24:45,360
para que não estejamos confusos

20217
13:24:45,360 --> 13:24:47,116
E nós vamos continuar

20218
13:24:47,116 --> 13:24:50,160
trabalhando nisso e na próxima peça de

20219
13:24:50,160 --> 13:24:51,916
Código que vamos tentar modificar

20220
13:24:51,916 --> 13:24:54,000
o que é armazenado em string data 1 e

20221
13:24:54,000 --> 13:24:56,956
string data 2 e imprimir as comparações

20222
13:24:56,956 --> 13:24:58,000
para fora.

20223
13:24:58,000 --> 13:25:00,640
Por exemplo, temos alabama e álbum

20224
13:25:00,640 --> 13:25:02,800
A propósito, somos capazes de modificar

20225
13:25:02,800 --> 13:25:04,160
que

20226
13:25:04,160 --> 13:25:07,360
porque é um ponteiro para uma força

20227
13:25:07,360 --> 13:25:09,200
e note que este não é o

20228
13:25:09,200 --> 13:25:11,360
conspirador para que possamos realmente mudar

20229
13:25:11,360 --> 13:25:13,200
onde esse cara está apontando e isso é

20230
13:25:13,200 --> 13:25:15,436
O que estamos fazendo aqui, mas não podemos fazer

20231
13:25:15,436 --> 13:25:17,916
que com dados de string 3 e dados de string

20232
13:25:17,916 --> 13:25:20,880
4 porque estes são arrays e lembre-se

20233
13:25:20,880 --> 13:25:23,360
você não pode mudar onde um array points

20234
13:25:23,360 --> 13:25:25,916
então isso vai compilar bem, mas se

20235
13:25:25,916 --> 13:25:28,240
Nós tentamos fazer a mesma coisa com corda

20236
13:25:28,240 --> 13:25:30,720
dados 3 e string dados quatro

20237
13:25:30,720 --> 13:25:31,916
Vamos fazer isso que você vai ter um

20238
13:25:31,916 --> 13:25:33,436
Erro do compilador

20239
13:25:33,436 --> 13:25:35,360
Vamos colocar esse cara aqui e

20240
13:25:35,360 --> 13:25:37,360
Diga três

20241
13:25:37,360 --> 13:25:39,116
e quatro

20242
13:25:39,116 --> 13:25:41,200
e devemos ver o código do estúdio visual

20243
13:25:41,200 --> 13:25:43,436
reclamando aqui porque isso não é

20244
13:25:43,436 --> 13:25:45,360
permitido que você não tenha permissão para fazer um

20245
13:25:45,360 --> 13:25:46,320
Array

20246
13:25:46,320 --> 13:25:48,560
apontar para outro local e este é

20247
13:25:48,560 --> 13:25:50,000
apenas mais um

20248
13:25:50,000 --> 13:25:52,640
matriz de caracteres ou matriz de caracteres de custo

20249
13:25:52,640 --> 13:25:55,436
na memória que queremos que esses ponteiros

20250
13:25:55,436 --> 13:25:57,200
apontar para ou esta matriz para apontar para e

20251
13:25:57,200 --> 13:25:59,040
Isso não é possível, então vamos

20252
13:25:59,040 --> 13:26:00,880
obter um erro de compilador se fizermos isso

20253
13:26:00,880 --> 13:26:03,116
É algo que eu queria que você soubesse que é

20254
13:26:03,116 --> 13:26:05,680
por que eu corri este exemplo aqui, então se nós

20255
13:26:05,680 --> 13:26:07,756
Executar isso, vamos ver o primeiro

20256
13:26:07,756 --> 13:26:10,560
Linha de produção aqui

20257
13:26:10,560 --> 13:26:14,640
ou acho que devo comentar isso

20258
13:26:14,640 --> 13:26:16,720
ou não vamos comentá-lo agora se nós

20259
13:26:16,720 --> 13:26:18,320
executar este programa, vamos conseguir o

20260
13:26:18,320 --> 13:26:21,360
saída para obama e alabama impresso para fora

20261
13:26:21,360 --> 13:26:24,640
e alabama vem depois de alabama, então nós

20262
13:26:24,640 --> 13:26:27,116
esperar obter um negativo, porque o

20263
13:26:27,116 --> 13:26:28,956
O primeiro cara aqui vem na frente do

20264
13:26:28,956 --> 13:26:30,400
Segundo cara, então nós vamos ter um

20265
13:26:30,400 --> 13:26:31,680
negativo um

20266
13:26:31,680 --> 13:26:32,956
- A partir de mais

20267
13:26:32,956 --> 13:26:34,240
O que é

20268
13:26:34,240 --> 13:26:36,640
O que estamos fazendo aqui vamos tentar entrar

20269
13:26:36,640 --> 13:26:39,200
Mundo com o Gcc

20270
13:26:39,200 --> 13:26:41,200
O construtor vai ser bom, então nós somos

20271
13:26:41,200 --> 13:26:43,596
indo para limpar e correr o galo e nós estamos

20272
13:26:43,596 --> 13:26:45,276
Vamos ver que temos um negativo

20273
13:26:45,276 --> 13:26:49,276
Aqui alabama vem na frente de um laboratório

20274
13:26:49,276 --> 13:26:51,520
então isso é legal para que possamos tentar colocar

20275
13:26:51,520 --> 13:26:53,436
Muitos outros exemplos para você brincar

20276
13:26:53,436 --> 13:26:55,040
Eu vou fazer isso porque eu não

20277
13:26:55,040 --> 13:26:56,880
Queremos digitar tudo isso graças e nós somos

20278
13:26:56,880 --> 13:26:58,400
Vou imprimir os resultados para

20279
13:26:58,400 --> 13:27:00,720
O exemplo colocamos na índia e na franqueza

20280
13:27:00,720 --> 13:27:02,800
Coloque em kigali e kigali e vamos

20281
13:27:02,800 --> 13:27:04,956
para imprimir as coisas aqui, então vamos

20282
13:27:04,956 --> 13:27:08,160
construir isso para que não percamos tempo

20283
13:27:08,160 --> 13:27:10,000
nós vamos limpar e nós vamos

20284
13:27:10,000 --> 13:27:11,436
correr o galo

20285
13:27:11,436 --> 13:27:13,276
e nós vamos ver que nós temos isso

20286
13:27:13,276 --> 13:27:15,680
As coisas aqui alakama vem depois de alabama

20287
13:27:15,680 --> 13:27:17,520
para que tenhamos um

20288
13:27:17,520 --> 13:27:20,720
A índia vem depois que a frança nós temos um

20289
13:27:20,720 --> 13:27:23,200
shigari vem junto com kigali e

20290
13:27:23,200 --> 13:27:24,880
nós temos um zero que você pode tentar e colocar

20291
13:27:24,880 --> 13:27:27,276
O que você quiser estes são apenas alguns

20292
13:27:27,276 --> 13:27:30,080
exemplos para você brincar com e agora

20293
13:27:30,080 --> 13:27:31,840
Espero que você realmente entenda como isso

20294
13:27:31,840 --> 13:27:34,400
função funciona ou esta facilidade funciona assim

20295
13:27:34,400 --> 13:27:37,040
nós vamos comentar isso, seja lá o que for

20296
13:27:37,040 --> 13:27:38,320
nós fizemos aqui

20297
13:27:38,320 --> 13:27:40,400
Então vamos comentar tudo isso

20298
13:27:40,400 --> 13:27:42,640
para que não tenhamos saída de ruído em

20299
13:27:42,640 --> 13:27:44,956
O que quisermos fazer a seguir e o que nós

20300
13:27:44,956 --> 13:27:47,116
Quero olhar para o próximo é esta função

20301
13:27:47,116 --> 13:27:49,116
Aqui, o que vai comparar

20302
13:27:49,116 --> 13:27:51,596
strings da mesma maneira, mas nós estamos indo

20303
13:27:51,596 --> 13:27:54,480
para dizer para comparar quantas

20304
13:27:54,480 --> 13:27:56,080
personagens na corda e você vê

20305
13:27:56,080 --> 13:27:58,080
que minha string aqui foi comentado

20306
13:27:58,080 --> 13:28:01,276
up eu posso levá-lo rapidamente e trazê-lo

20307
13:28:01,276 --> 13:28:03,520
Aqui vamos fazer isso não consigo encontrar

20308
13:28:03,520 --> 13:28:04,640
que

20309
13:28:04,640 --> 13:28:08,400
Vamos encontrar isso e copiá-lo para baixo

20310
13:28:08,400 --> 13:28:10,400
e nós vamos encontrá-los aqui, então eu estou

20311
13:28:10,400 --> 13:28:12,080
Vou encontrar isto.

20312
13:28:12,080 --> 13:28:13,916
e trazer isso para cá para que eu possa

20313
13:28:13,916 --> 13:28:16,320
Compare essas coisas, então vamos descer

20314
13:28:16,320 --> 13:28:19,116
aqui e imprimir e colocar em nosso

20315
13:28:19,116 --> 13:28:20,956
declarações para esses pontos fortes e você

20316
13:28:20,956 --> 13:28:23,520
Veja que o código visual do estúdio está feliz agora

20317
13:28:23,520 --> 13:28:25,756
Então o que vamos fazer é comparar a

20318
13:28:25,756 --> 13:28:28,956
conjunto de caracteres nessas strings aqui

20319
13:28:28,956 --> 13:28:31,200
Tudo bem, então vamos comparar qualquer

20320
13:28:31,200 --> 13:28:32,880
Personagens em nossos pontos fortes, então nós somos

20321
13:28:32,880 --> 13:28:36,480
indo comparar alá com blá aqui e

20322
13:28:36,480 --> 13:28:38,320
Allah vai vir na frente do preto

20323
13:28:38,320 --> 13:28:39,756
Vamos ter um negativo

20324
13:28:39,756 --> 13:28:42,240
impresso aqui, mas se mudarmos o

20325
13:28:42,240 --> 13:28:46,080
forças para aaa e aaa aqui e

20326
13:28:46,080 --> 13:28:48,640
Compare os três primeiros personagens que somos

20327
13:28:48,640 --> 13:28:50,560
Vou obter um zero impresso porque

20328
13:28:50,560 --> 13:28:53,276
Os três primeiros personagens são iguais e

20329
13:28:53,276 --> 13:28:55,116
Mais uma vez a coisa especial sobre isso

20330
13:28:55,116 --> 13:28:56,956
A função é que permite que você

20331
13:28:56,956 --> 13:28:58,160
Especificar a

20332
13:28:58,160 --> 13:29:00,720
Um número de personagens que você deseja comparar

20333
13:29:00,720 --> 13:29:03,040
nestas duas cordas para que você possa dizer

20334
13:29:03,040 --> 13:29:04,880
Quer comparar três fios que você pode

20335
13:29:04,880 --> 13:29:06,720
Eu quero comparar quatro strings ou

20336
13:29:06,720 --> 13:29:07,756
Cinco

20337
13:29:07,756 --> 13:29:09,680
apenas certifique-se de que você não passar por cima

20338
13:29:09,680 --> 13:29:12,000
o tamanho da corda e se você fizer

20339
13:29:12,000 --> 13:29:13,596
que não vai fazer sentido que

20340
13:29:13,596 --> 13:29:15,840
Você está tentando fazer aqui se descermos

20341
13:29:15,840 --> 13:29:17,520
Aqui vamos mudar n para 5 e

20342
13:29:17,520 --> 13:29:19,520
nós vamos comparar tudo isso

20343
13:29:19,520 --> 13:29:21,360
Coisas aqui e nós vamos ficar

20344
13:29:21,360 --> 13:29:22,320
que

20345
13:29:22,320 --> 13:29:24,640
O primeiro vem na frente do

20346
13:29:24,640 --> 13:29:28,560
segundo, porque eu venho na frente de n

20347
13:29:28,560 --> 13:29:32,000
em nosso alfabeto se mudarmos os dados para

20348
13:29:32,000 --> 13:29:33,680
o aqui e n

20349
13:29:33,680 --> 13:29:35,916
o vai vir depois n e nós estamos

20350
13:29:35,916 --> 13:29:38,480
Vou obter um número positivo impresso

20351
13:29:38,480 --> 13:29:40,956
Aqui vamos tentar correr isto

20352
13:29:40,956 --> 13:29:45,116
então vamos executar a tarefa para construir com jcc

20353
13:29:45,116 --> 13:29:47,200
A bala vai ser boa e nós estamos

20354
13:29:47,200 --> 13:29:49,840
indo para limpar e correr o galo

20355
13:29:49,840 --> 13:29:51,680
e nós vamos ver esse alabama

20356
13:29:51,680 --> 13:29:55,276
vem na frente do blabama porque nós somos

20357
13:29:55,276 --> 13:29:58,480
Comparando os três primeiros caracteres

20358
13:29:58,480 --> 13:30:01,276
se temos aiaa aqui e comparamos

20359
13:30:01,276 --> 13:30:02,720
Os três personagens que você vai ver

20360
13:30:02,720 --> 13:30:04,880
que eles são iguais, nós obtemos um zero

20361
13:30:04,880 --> 13:30:06,560
Se nós mudarmos o I

20362
13:30:06,560 --> 13:30:09,040
e n aqui vamos ter um negativo

20363
13:30:09,040 --> 13:30:11,916
um porque eu vem na frente de n

20364
13:30:11,916 --> 13:30:14,720
se usarmos o aqui e n, vamos

20365
13:30:14,720 --> 13:30:17,596
obter um um porque o vem depois de n isso

20366
13:30:17,596 --> 13:30:19,916
É realmente simples de entender agora que

20367
13:30:19,916 --> 13:30:22,160
Sabemos como usar a primeira versão de

20368
13:30:22,160 --> 13:30:24,640
string compare esta versão é apenas

20369
13:30:24,640 --> 13:30:27,436
vamos nos permitir especificar quantos

20370
13:30:27,436 --> 13:30:29,360
Personagens na corda que queremos

20371
13:30:29,360 --> 13:30:31,756
comparado, então vamos comentar isso

20372
13:30:31,756 --> 13:30:34,720
fora e nós vamos descer e fazer

20373
13:30:34,720 --> 13:30:37,840
Outro exemplo que nos permite pesquisar

20374
13:30:37,840 --> 13:30:40,240
por um personagem em uma cadeia de caracteres

20375
13:30:40,240 --> 13:30:43,680
e o método que usamos para fazer isso é std

20376
13:30:43,680 --> 13:30:45,040
str

20377
13:30:45,040 --> 13:30:46,560
chr (em hr)

20378
13:30:46,560 --> 13:30:48,480
então esse cara vai encontrar o que

20379
13:30:48,480 --> 13:30:50,956
alvo que você quer encontrar e se ele encontrar

20380
13:30:50,956 --> 13:30:52,880
que vai te devolver um ponteiro

20381
13:30:52,880 --> 13:30:55,596
para o alvo dot se ele não encontrá-lo

20382
13:30:55,596 --> 13:30:58,080
Vai devolver você sem ponteiro assim

20383
13:30:58,080 --> 13:31:00,560
nós configuramos uma matriz aqui e nós armazenamos

20384
13:31:00,560 --> 13:31:03,756
que em um local que é apontado por

20385
13:31:03,756 --> 13:31:06,480
o ponteiro para o personagem aqui e nós dizemos

20386
13:31:06,480 --> 13:31:08,320
Seja qual for o alvo que estamos procurando

20387
13:31:08,320 --> 13:31:11,360
neste caso queremos encontrar isso t aqui

20388
13:31:11,360 --> 13:31:13,596
Vamos criar um outro personagem

20389
13:31:13,596 --> 13:31:16,080
array que vai armazenar nossos resultados

20390
13:31:16,080 --> 13:31:17,756
O resultado será realmente um

20391
13:31:17,756 --> 13:31:19,520
ponteiro que vai apontar para

20392
13:31:19,520 --> 13:31:22,240
Algo válido se encontrarmos o alvo

20393
13:31:22,240 --> 13:31:24,080
e não vai ser nenhum equador se nós

20394
13:31:24,080 --> 13:31:26,160
Não encontramos o alvo e nós estabelecemos

20395
13:31:26,160 --> 13:31:28,000
Outra variável que vai armazenar

20396
13:31:28,000 --> 13:31:30,160
Quantas iterações fizemos que deveríamos

20397
13:31:30,160 --> 13:31:32,480
realmente fazer disso um inteiro não assinado ou

20398
13:31:32,480 --> 13:31:35,116
Tamanho t então vamos fazer isso aqui e nós somos

20399
13:31:35,116 --> 13:31:37,200
indo para loop aqui, então a primeira vez

20400
13:31:37,200 --> 13:31:38,800
Vamos abrir aqui, vamos chamar isso

20401
13:31:38,800 --> 13:31:40,956
Cara, vamos dizer que eu quero encontrar um

20402
13:31:40,956 --> 13:31:41,916
t

20403
13:31:41,916 --> 13:31:43,680
e resultado aqui e o resultado está indo

20404
13:31:43,680 --> 13:31:45,520
para estar apontando para esta linha aqui porque

20405
13:31:45,520 --> 13:31:47,916
nós fizemos a tarefa aqui, então está indo

20406
13:31:47,916 --> 13:31:49,840
para ir e tentar encontrar o t que está indo

20407
13:31:49,840 --> 13:31:52,880
para encontrar o cara aqui no primeiro índice

20408
13:31:52,880 --> 13:31:55,680
E o teste aqui vai ter sucesso

20409
13:31:55,680 --> 13:31:57,680
Quando for bem sucedido, não vai ser

20410
13:31:57,680 --> 13:31:59,520
igual a nenhum ponteiro vai ser

20411
13:31:59,520 --> 13:32:01,596
apontando para um ponteiro válido

20412
13:32:01,596 --> 13:32:04,880
e vai ter sucesso e devolver o

20413
13:32:04,880 --> 13:32:07,756
ponteiro a ser armazenado no resort após

20414
13:32:07,756 --> 13:32:09,436
Este guia retorna o ponteiro está indo

20415
13:32:09,436 --> 13:32:11,520
para ser armazenado no resultado aqui e

20416
13:32:11,520 --> 13:32:13,040
que vai ser um ponteiro para isso

20417
13:32:13,040 --> 13:32:15,040
equipe e nós vamos pular no corpo

20418
13:32:15,040 --> 13:32:16,880
Aqui eu realmente quero que você entenda como

20419
13:32:16,880 --> 13:32:18,640
Esta coisa vai funcionar

20420
13:32:18,640 --> 13:32:20,080
Uma vez que chegamos ao corpo, vamos

20421
13:32:20,080 --> 13:32:22,240
Diga uh-huh, encontramos nosso alvo que é

20422
13:32:22,240 --> 13:32:24,880
Vou ser o nosso t imprimir e é

20423
13:32:24,880 --> 13:32:26,956
Vou começar neste local

20424
13:32:26,956 --> 13:32:29,116
Tudo bem e nós vamos imprimir a partir

20425
13:32:29,116 --> 13:32:32,080
do t aqui porque isso é o nosso

20426
13:32:32,080 --> 13:32:34,880
O resultado aqui está apontando para depois que fazemos

20427
13:32:34,880 --> 13:32:36,720
que vamos incrementar o resultado

20428
13:32:36,720 --> 13:32:39,200
para fazê-lo apontar para o próximo personagem

20429
13:32:39,200 --> 13:32:41,360
Se fizermos isso com a aritmética do ponteiro

20430
13:32:41,360 --> 13:32:43,436
Agora vamos apontar para o

20431
13:32:43,436 --> 13:32:44,400
dentro aqui

20432
13:32:44,400 --> 13:32:46,720
Espero que isso faça sentido e vamos

20433
13:32:46,720 --> 13:32:48,480
para incrementar nossas iterações para que possamos

20434
13:32:48,480 --> 13:32:51,200
Vamos dizer que fizemos uma iteração

20435
13:32:51,200 --> 13:32:52,640
e nós vamos tentar executá-lo

20436
13:32:52,640 --> 13:32:55,116
Mais uma vez e pelo tempo que entrarmos aqui

20437
13:32:55,116 --> 13:32:58,320
nós vamos ter essa corda aqui dentro

20438
13:32:58,320 --> 13:33:00,956
que estamos procurando por um t

20439
13:33:00,956 --> 13:33:03,436
e vai ser encontrado começando em

20440
13:33:03,436 --> 13:33:06,320
Este segundo t aqui aqui

20441
13:33:06,320 --> 13:33:08,480
E vai encontrá-lo

20442
13:33:08,480 --> 13:33:11,756
ele vai armazenar o ponteiro para ele para

20443
13:33:11,756 --> 13:33:14,560
resort aqui ou devo dizer a busca

20444
13:33:14,560 --> 13:33:16,160
vai ser bem sucedido, então vamos

20445
13:33:16,160 --> 13:33:18,720
para encontrar o ponteiro para este t

20446
13:33:18,720 --> 13:33:21,436
e devolvê-lo a partir desta função aqui

20447
13:33:21,436 --> 13:33:23,276
e o ponteiro será armazenado em

20448
13:33:23,276 --> 13:33:24,640
o nosso resultado

20449
13:33:24,640 --> 13:33:26,800
ponteiro aqui vamos pular no

20450
13:33:26,800 --> 13:33:29,200
corpo e nós vamos imprimir que encontramos

20451
13:33:29,200 --> 13:33:31,040
o alvo a partir disso, não estamos

20452
13:33:31,040 --> 13:33:33,680
indo imprimir isso e stdc fora é

20453
13:33:33,680 --> 13:33:35,756
ir imprimir até que se encontre com um velho

20454
13:33:35,756 --> 13:33:37,360
personagem, então vamos imprimir isso

20455
13:33:37,360 --> 13:33:39,276
A coisa através do fim e nós vamos

20456
13:33:39,276 --> 13:33:42,080
Coloque um slash n que vai nos mover

20457
13:33:42,080 --> 13:33:43,680
para a próxima linha depois que nós fazemos isso nós somos

20458
13:33:43,680 --> 13:33:45,916
indo para incrementar o resultado

20459
13:33:45,916 --> 13:33:48,640
E uh o resultado agora vai apontar para

20460
13:33:48,640 --> 13:33:50,400
o h aqui

20461
13:33:50,400 --> 13:33:52,480
e nós vamos aumentar as iterações

20462
13:33:52,480 --> 13:33:54,480
Agora vamos ter feito dois

20463
13:33:54,480 --> 13:33:57,040
iterações até agora e nós vamos correr

20464
13:33:57,040 --> 13:33:59,200
o loop novamente desta vez o loop é

20465
13:33:59,200 --> 13:34:01,520
Vou falhar porque a partir daqui

20466
13:34:01,520 --> 13:34:03,200
nós não temos um t

20467
13:34:03,200 --> 13:34:04,720
e que esta função vai para

20468
13:34:04,720 --> 13:34:07,756
não retorno nenhum ponteiro e este teste aqui é

20469
13:34:07,756 --> 13:34:09,840
Vou falhar bem, vamos

20470
13:34:09,840 --> 13:34:12,240
Não retorno nenhum ponteiro nenhum ponteiro não é

20471
13:34:12,240 --> 13:34:14,240
Vai ser diferente de nenhum ponto, então

20472
13:34:14,240 --> 13:34:16,320
Isso vai falhar e nós vamos

20473
13:34:16,320 --> 13:34:18,080
cair aqui e dizer quantos

20474
13:34:18,080 --> 13:34:20,000
iterações que vamos encontrar assim em

20475
13:34:20,000 --> 13:34:22,240
total vamos fazer duas iterações

20476
13:34:22,240 --> 13:34:24,560
e vamos encontrar dois t's e

20477
13:34:24,560 --> 13:34:26,080
Vamos imprimir o que encontrarmos

20478
13:34:26,080 --> 13:34:28,080
aqui, certifique-se de que você realmente entende

20479
13:34:28,080 --> 13:34:28,880
Isto é

20480
13:34:28,880 --> 13:34:31,520
e eu coloco neste exemplo de propósito

20481
13:34:31,520 --> 13:34:34,400
porque é um pouco complicado, mas

20482
13:34:34,400 --> 13:34:36,880
Vai realmente trazer o seu jogo para cima

20483
13:34:36,880 --> 13:34:39,520
em como você usa essas funções a partir do

20484
13:34:39,520 --> 13:34:41,680
c plus biblioteca padrão e você

20485
13:34:41,680 --> 13:34:43,916
realmente precisa saber disso se você tiver alguma

20486
13:34:43,916 --> 13:34:45,436
O problema com isso

20487
13:34:45,436 --> 13:34:47,520
ter certeza de me perguntar eu vou fazer o melhor eu

20488
13:34:47,520 --> 13:34:49,116
pode te ajudar para que possamos

20489
13:34:49,116 --> 13:34:51,116
construir isso e executar isso nós vamos

20490
13:34:51,116 --> 13:34:53,916
construir com gcc como sempre e nós somos

20491
13:34:53,916 --> 13:34:56,160
indo para limpar e correr galo e

20492
13:34:56,160 --> 13:34:57,680
Você vai ver que estamos olhando

20493
13:34:57,680 --> 13:34:58,720
para t

20494
13:34:58,720 --> 13:35:01,116
nós vamos dizer que encontramos t começando

20495
13:35:01,116 --> 13:35:04,320
no t aqui, então vamos dizer tentar

20496
13:35:04,320 --> 13:35:06,480
Tudo bem, vamos imprimir tudo

20497
13:35:06,480 --> 13:35:08,480
mensagem para fora e a segunda iteração é

20498
13:35:08,480 --> 13:35:10,080
indo para encontrar t

20499
13:35:10,080 --> 13:35:12,560
começando neste local aqui e estamos

20500
13:35:12,560 --> 13:35:14,880
Vou fazer duas iterações no total

20501
13:35:14,880 --> 13:35:16,400
nós vamos comentar isso e

20502
13:35:16,400 --> 13:35:18,640
Mais uma vez se você não entender isso

20503
13:35:18,640 --> 13:35:20,800
Por favor, passe por isso novamente e se você

20504
13:35:20,800 --> 13:35:23,200
Ainda não entendo ter certeza de me perguntar

20505
13:35:23,200 --> 13:35:25,040
Eu vou fazer o melhor que posso para ajudar

20506
13:35:25,040 --> 13:35:28,720
Você sai e alguns de vocês podem estar perguntando

20507
13:35:28,720 --> 13:35:30,956
Por que passamos pelos problemas para

20508
13:35:30,956 --> 13:35:34,080
Armazenar esse cara em um resultado

20509
13:35:34,080 --> 13:35:36,560
Por que não usamos htr

20510
13:35:36,560 --> 13:35:38,560
em primeiro lugar aqui

20511
13:35:38,560 --> 13:35:40,880
e a explicação que eu posso chegar com

20512
13:35:40,880 --> 13:35:43,680
É que você realmente não quer modificar

20513
13:35:43,680 --> 13:35:45,360
Este cara aqui porque alguém está indo

20514
13:35:45,360 --> 13:35:47,200
para olhar para essa coisa e dizer

20515
13:35:47,200 --> 13:35:50,240
Esta é a mensagem que tenho em sdr aqui

20516
13:35:50,240 --> 13:35:52,320
mas se você tentar modificar isso no

20517
13:35:52,320 --> 13:35:53,916
loop que vai ser confuso porque

20518
13:35:53,916 --> 13:35:55,520
Você vai incrementá-lo e

20519
13:35:55,520 --> 13:35:57,436
fazendo todos os tipos de coisas loucas nele, então

20520
13:35:57,436 --> 13:36:00,080
Você realmente não quer modificar isso assim

20521
13:36:00,080 --> 13:36:02,956
uma maneira melhor de fazer isso é marcar

20522
13:36:02,956 --> 13:36:05,436
isso como um const pointer e nós sabemos como

20523
13:36:05,436 --> 13:36:08,000
para fazer isso para que possamos dizer custo aqui e

20524
13:36:08,000 --> 13:36:10,560
se você mesmo tentar incrementar htr

20525
13:36:10,560 --> 13:36:12,720
Em algum lugar que você vai conseguir um compilador

20526
13:36:12,720 --> 13:36:13,680
Erro de erro

20527
13:36:13,680 --> 13:36:16,080
então, vamos ter certeza de que vemos isso para

20528
13:36:16,080 --> 13:36:19,200
exemplo, tentamos fazer plus plus. sdr

20529
13:36:19,200 --> 13:36:20,560
vamos ter um erro de compilador

20530
13:36:20,560 --> 13:36:22,956
porque este é um const pointer agora

20531
13:36:22,956 --> 13:36:25,200
E isso é muito mais seguro

20532
13:36:25,200 --> 13:36:26,400
Está tudo bem

20533
13:36:26,400 --> 13:36:28,080
nós vamos comentar isso e mostrar

20534
13:36:28,080 --> 13:36:31,200
Você algo que pode jogar fora muitos

20535
13:36:31,200 --> 13:36:32,880
de vocês, então nós vamos comentar

20536
13:36:32,880 --> 13:36:35,756
Isso e eu vou trazer isso

20537
13:36:35,756 --> 13:36:38,000
Ok, vamos para cá

20538
13:36:38,000 --> 13:36:39,840
e nós vamos fazer basicamente o

20539
13:36:39,840 --> 13:36:41,116
A mesma coisa

20540
13:36:41,116 --> 13:36:43,200
Mas nós vamos tentar

20541
13:36:43,200 --> 13:36:46,720
e use str em primeiro lugar aqui

20542
13:36:46,720 --> 13:36:48,240
Tudo bem é assim que vamos fazer isso

20543
13:36:48,240 --> 13:36:50,240
nós vamos ter nossa corda, nós somos

20544
13:36:50,240 --> 13:36:51,680
Vou ter o nosso alvo para onde vamos

20545
13:36:51,680 --> 13:36:53,596
ter o nosso resultado aqui que é igual a

20546
13:36:53,596 --> 13:36:56,320
ponteiro nulo e temos nossas iterações

20547
13:36:56,320 --> 13:36:58,160
que é um inteiro, vamos fazer disso um

20548
13:36:58,160 --> 13:37:00,240
tamanho t e o que vamos fazer em

20549
13:37:00,240 --> 13:37:03,916
aqui vamos usar htr para procurar

20550
13:37:03,916 --> 13:37:06,240
Tudo bem e nós vamos basicamente fazer o

20551
13:37:06,240 --> 13:37:08,320
Os mesmos cheques que vamos saltar aqui

20552
13:37:08,320 --> 13:37:10,800
e dizer que encontramos o alvo começando em

20553
13:37:10,800 --> 13:37:13,756
resultado e vamos incrementar hdr

20554
13:37:13,756 --> 13:37:16,800
aqui porque não é um limitador agora

20555
13:37:16,800 --> 13:37:18,800
Tente passar por essa coisa aqui e

20556
13:37:18,800 --> 13:37:21,596
Veja quantas vezes você vai fazer loop

20557
13:37:21,596 --> 13:37:24,956
Ok passe por isso e quando você terminar

20558
13:37:24,956 --> 13:37:26,956
nós vamos tentar correr isso nós somos

20559
13:37:26,956 --> 13:37:28,880
indo para construir com gcc a construção é

20560
13:37:28,880 --> 13:37:31,840
Vou ser bom, vamos limpar

20561
13:37:31,840 --> 13:37:34,720
e correr galo e você vê que isso

20562
13:37:34,720 --> 13:37:37,200
Cara vai olhar 25 vezes

20563
13:37:37,200 --> 13:37:39,596
E isso é loucura por que isso está acontecendo

20564
13:37:39,596 --> 13:37:41,436
Por que isso está acontecendo

20565
13:37:41,436 --> 13:37:44,640
O que realmente estamos fazendo aqui não estamos

20566
13:37:44,640 --> 13:37:48,240
Atribuindo o resultado nessa tendência que

20567
13:37:48,240 --> 13:37:49,916
Estamos procurando em

20568
13:37:49,916 --> 13:37:51,596
OK, vamos tentar passar por isso a

20569
13:37:51,596 --> 13:37:53,756
Algumas vezes, então a primeira vez que estamos

20570
13:37:53,756 --> 13:37:56,240
Vou fazer a nossa busca ok, então estamos

20571
13:37:56,240 --> 13:37:58,480
indo para a pesquisa em sdr

20572
13:37:58,480 --> 13:38:01,276
E se encontrarmos nosso alvo, vamos

20573
13:38:01,276 --> 13:38:03,916
Retorne o ponteiro para o alvo

20574
13:38:03,916 --> 13:38:05,116
Se não a encontrarmos, vamos

20575
13:38:05,116 --> 13:38:07,040
retornar um ponteiro nulo na primeira vez

20576
13:38:07,040 --> 13:38:09,200
nós vamos encontrar isso t aqui bem e

20577
13:38:09,200 --> 13:38:10,640
Vamos devolver um ponteiro para isso

20578
13:38:10,640 --> 13:38:13,040
e armazene isso em resultados

20579
13:38:13,040 --> 13:38:15,436
Tudo bem, então depois de fazermos isso, vamos

20580
13:38:15,436 --> 13:38:17,360
queda em nosso corpo aqui

20581
13:38:17,360 --> 13:38:19,040
E nós vamos dizer que encontramos t

20582
13:38:19,040 --> 13:38:21,276
Começando neste local aqui que é

20583
13:38:21,276 --> 13:38:23,116
indo para o trabalho e nós vamos

20584
13:38:23,116 --> 13:38:27,040
implementar str OK note que nós não somos

20585
13:38:27,040 --> 13:38:29,200
incrementando o resultado aqui

20586
13:38:29,200 --> 13:38:31,916
Se incrementarmos sdr, isso vai apontar

20587
13:38:31,916 --> 13:38:34,480
para o próximo personagem que está aqui

20588
13:38:34,480 --> 13:38:35,596
Está tudo bem

20589
13:38:35,596 --> 13:38:36,880
e nós vamos incrementar o nosso

20590
13:38:36,880 --> 13:38:38,320
iterações e vamos começar em

20591
13:38:38,320 --> 13:38:39,436
loop novamente

20592
13:38:39,436 --> 13:38:41,436
nós vamos procurar aqui

20593
13:38:41,436 --> 13:38:43,116
e nós vamos procurar a partir de

20594
13:38:43,116 --> 13:38:44,800
Esta localização aqui

20595
13:38:44,800 --> 13:38:46,560
e nós vamos encontrar o t começando

20596
13:38:46,560 --> 13:38:48,480
Neste local vamos encontrar

20597
13:38:48,480 --> 13:38:50,640
Isto t aqui e nós vamos

20598
13:38:50,640 --> 13:38:53,200
devolver isso e armazenar isso reservado

20599
13:38:53,200 --> 13:38:55,360
Mas o problema é que somos

20600
13:38:55,360 --> 13:38:58,160
incrementa aqui, mas o problema aqui

20601
13:38:58,160 --> 13:39:00,560
É que estamos incrementando um por um

20602
13:39:00,560 --> 13:39:03,680
nós não estamos pulando para isso t aqui e nós

20603
13:39:03,680 --> 13:39:06,000
Tinha uma maneira de saltar para este t

20604
13:39:06,000 --> 13:39:09,200
atribuindo o resultado no mesmo

20605
13:39:09,200 --> 13:39:11,040
variável que estamos procurando em OK

20606
13:39:11,040 --> 13:39:13,680
Então isso vai fazer um loop 25 vezes e

20607
13:39:13,680 --> 13:39:16,400
Não é realmente bom e alguns de vocês podem

20608
13:39:16,400 --> 13:39:18,320
Tente montar algo assim e isso

20609
13:39:18,320 --> 13:39:20,720
Realmente não vai ser boa tentar ir

20610
13:39:20,720 --> 13:39:22,000
através disso e você vai ver o

20611
13:39:22,000 --> 13:39:25,520
razão pela qual ele está enrolando 25 vezes bem eu

20612
13:39:25,520 --> 13:39:27,276
Queria que você visse isso, não faça

20613
13:39:27,276 --> 13:39:28,956
Algo assim e nós vamos

20614
13:39:28,956 --> 13:39:30,480
Comente esta é a próxima coisa que nós somos

20615
13:39:30,480 --> 13:39:32,880
Vou ver como podemos encontrar o último

20616
13:39:32,880 --> 13:39:35,040
ocorrência do caráter e isso é

20617
13:39:35,040 --> 13:39:37,040
Um exemplo muito legal eu gosto que é

20618
13:39:37,040 --> 13:39:39,756
Vou fazer algo muito prático, nós

20619
13:39:39,756 --> 13:39:41,680
Vamos tomar um caminho que está indo

20620
13:39:41,680 --> 13:39:43,756
ser um array basicamente armazenado neste

20621
13:39:43,756 --> 13:39:46,240
matriz de entrada e nós vamos sair

20622
13:39:46,240 --> 13:39:47,756
Todas as coisas que não precisamos e nós somos

20623
13:39:47,756 --> 13:39:50,400
vai caçar o nome do arquivo

20624
13:39:50,400 --> 13:39:53,040
de um caminho completo e isso pode ser útil

20625
13:39:53,040 --> 13:39:55,520
em qualquer aplicação que você esteja fazendo

20626
13:39:55,520 --> 13:39:57,436
Vamos caçar o último

20627
13:39:57,436 --> 13:40:00,160
ocorrência de um personagem de backslash

20628
13:40:00,160 --> 13:40:03,116
usando a str ou

20629
13:40:03,116 --> 13:40:06,080
Instalação chr no esquadrão ziploc

20630
13:40:06,080 --> 13:40:08,080
biblioteca padrão e você pode encontrar o

20631
13:40:08,080 --> 13:40:09,916
Documentação sobre este cara aqui não estou

20632
13:40:09,916 --> 13:40:11,436
indo para lá você realmente deveria

20633
13:40:11,436 --> 13:40:13,756
Pratique para ir lá e ler o que estes

20634
13:40:13,756 --> 13:40:16,160
Coisas que fazem, é por isso que eu estou vivendo no

20635
13:40:16,160 --> 13:40:18,000
lente para a documentação que você deve ir

20636
13:40:18,000 --> 13:40:20,000
lá e ler e se você tem um problema

20637
13:40:20,000 --> 13:40:22,320
Você pode me perguntar eu vou fazer o melhor que posso

20638
13:40:22,320 --> 13:40:24,000
para te ajudar

20639
13:40:24,000 --> 13:40:26,160
Então, esta linha aqui vai caçar

20640
13:40:26,160 --> 13:40:27,276
O último

20641
13:40:27,276 --> 13:40:29,276
backslash vai encontrar esse cara

20642
13:40:29,276 --> 13:40:31,116
Aqui e vamos guardar um ponteiro

20643
13:40:31,116 --> 13:40:33,680
para isso em nosso ponteiro de caracteres de saída

20644
13:40:33,680 --> 13:40:35,756
Aqui depois que fizermos isso, vamos dizer

20645
13:40:35,756 --> 13:40:38,400
se encontramos algo útil se isso for

20646
13:40:38,400 --> 13:40:40,560
Não não há ponteiro, vamos imprimir isso

20647
13:40:40,560 --> 13:40:42,880
fora, mas não queremos imprimir a partir de

20648
13:40:42,880 --> 13:40:44,880
da barragem que vamos usar

20649
13:40:44,880 --> 13:40:47,040
ponteiro aritmético e passar para o próximo

20650
13:40:47,040 --> 13:40:49,200
personagem que vai ser este h

20651
13:40:49,200 --> 13:40:51,360
Aqui, então se imprimirmos isso, vamos

20652
13:40:51,360 --> 13:40:54,080
para ter olá cpp impresso para fora porque

20653
13:40:54,080 --> 13:40:56,800
sddc out vai imprimir até

20654
13:40:56,800 --> 13:40:57,680
Os encontros

20655
13:40:57,680 --> 13:41:00,320
O último agora personagem e isso está indo

20656
13:41:00,320 --> 13:41:03,040
para estar atrás do último p aqui, porque este

20657
13:41:03,040 --> 13:41:05,680
é uma corda c vamos rolar aqui ok estamos

20658
13:41:05,680 --> 13:41:07,276
Vou construir isso a construção está indo

20659
13:41:07,276 --> 13:41:09,756
para sermos bons, vamos limpar

20660
13:41:09,756 --> 13:41:11,436
e correr galo e você vai ver

20661
13:41:11,436 --> 13:41:13,756
que temos olá cpp

20662
13:41:13,756 --> 13:41:15,916
impresso aqui ok, isso é realmente tudo

20663
13:41:15,916 --> 13:41:17,596
nos prossamos fazer nesta palestra i

20664
13:41:17,596 --> 13:41:19,596
Pedir desculpas que acabou por ser

20665
13:41:19,596 --> 13:41:22,000
longos essas coisas podem demorar muito para

20666
13:41:22,000 --> 13:41:24,160
Explique e eu realmente queria que vocês

20667
13:41:24,160 --> 13:41:27,520
Tenho tantas explicações quanto eu poderia

20668
13:41:27,520 --> 13:41:28,720
Venha com

20669
13:41:28,720 --> 13:41:30,240
Vamos parar aqui neste

20670
13:41:30,240 --> 13:41:31,916
dar uma palestra no próximo que vamos ver

20671
13:41:31,916 --> 13:41:34,880
Como podemos copiar e criar

20672
13:41:34,880 --> 13:41:38,080
c strings usando as instalações de c

20673
13:41:38,080 --> 13:41:41,040
string aqui vá em frente e termine aqui

20674
13:41:41,040 --> 13:41:42,560
e me encontrar lá

20675
13:41:42,560 --> 13:41:44,720
Nesta palestra vamos olhar

20676
13:41:44,720 --> 13:41:47,436
mais algumas instalações da corda c

20677
13:41:47,436 --> 13:41:50,240
Biblioteca e eles vão nos permitir

20678
13:41:50,240 --> 13:41:53,116
para conspirar e copiar strings sobre o

20679
13:41:53,116 --> 13:41:54,956
Documentação para o que vamos ser

20680
13:41:54,956 --> 13:41:57,116
Falar sobre pode ser encontrado aqui se você

20681
13:41:57,116 --> 13:41:58,880
Ir lá você vai cair sobre isso

20682
13:41:58,880 --> 13:42:00,640
Link aqui e você está indo para

20683
13:42:00,640 --> 13:42:03,436
encontrar que c string estava originalmente no

20684
13:42:03,436 --> 13:42:07,040
c biblioteca padrão como ponto de cadeia h, mas

20685
13:42:07,040 --> 13:42:10,160
em c plus plus podemos usá-lo assim

20686
13:42:10,160 --> 13:42:11,756
Temos algumas funções que podemos

20687
13:42:11,756 --> 13:42:14,720
copiar coisas que podemos criar nós podemos obter

20688
13:42:14,720 --> 13:42:17,040
o comprimento da corda que vimos isso, mas

20689
13:42:17,040 --> 13:42:18,956
Agora vamos olhar para as coisas que

20690
13:42:18,956 --> 13:42:21,756
nos permite copiar e concatenar coisas

20691
13:42:21,756 --> 13:42:22,640
porque

20692
13:42:22,640 --> 13:42:24,720
Isso é algo que você pode querer fazer

20693
13:42:24,720 --> 13:42:26,240
Este é o primeiro exemplo para o qual vamos

20694
13:42:26,240 --> 13:42:27,560
O olhar é

20695
13:42:27,560 --> 13:42:30,560
stdstr gato que vai permitir que você

20696
13:42:30,560 --> 13:42:32,400
para unir os pontos fortes

20697
13:42:32,400 --> 13:42:34,160
novamente você pode navegar até o

20698
13:42:34,160 --> 13:42:36,080
documentação aqui e ver mais sobre

20699
13:42:36,080 --> 13:42:38,480
Esta instalação aqui e você está indo para

20700
13:42:38,480 --> 13:42:40,640
Veja tudo sobre isso por enquanto nós somos apenas

20701
13:42:40,640 --> 13:42:42,000
Vou jogar com ele nós vamos definir

20702
13:42:42,000 --> 13:42:44,560
até dois arrays um será chamado

20703
13:42:44,560 --> 13:42:45,520
Dest

20704
13:42:45,520 --> 13:42:47,840
vai conter olá o outro é

20705
13:42:47,840 --> 13:42:49,276
Vai ser fonte aqui e está indo

20706
13:42:49,276 --> 13:42:51,596
para conter mundos note que estes são

20707
13:42:51,596 --> 13:42:54,480
matrizes estáticas de linha que são armazenadas no

20708
13:42:54,480 --> 13:42:55,436
snap

20709
13:42:55,436 --> 13:42:57,756
E foi assim que os estabelecemos aqui

20710
13:42:57,756 --> 13:42:59,916
Tudo bem para que possamos reunir forças

20711
13:42:59,916 --> 13:43:02,160
usando a sintaxe como esta, estamos indo

20712
13:43:02,160 --> 13:43:04,956
para dizer hdd hdr cache nós vamos dizer

20713
13:43:04,956 --> 13:43:07,116
A cadeia de destino e nós vamos

20714
13:43:07,116 --> 13:43:09,276
para dizer a string de origem que queremos copiar

20715
13:43:09,276 --> 13:43:11,360
de OK, então depois de fazermos isso o

20716
13:43:11,360 --> 13:43:13,680
O destino vai conter

20717
13:43:13,680 --> 13:43:16,956
Estes dois cordões uniram-se e

20718
13:43:16,956 --> 13:43:19,596
antes de fazer isso, você tem que ter certeza

20719
13:43:19,596 --> 13:43:22,000
que sua força de destino é grande

20720
13:43:22,000 --> 13:43:24,560
o suficiente e isso é um problema porque você

20721
13:43:24,560 --> 13:43:26,480
Tenho que realmente acompanhar o seu

20722
13:43:26,480 --> 13:43:29,116
força de destino e é fácil

20723
13:43:29,116 --> 13:43:31,680
colocar em muitos outros personagens que podem

20724
13:43:31,680 --> 13:43:34,160
realmente se encaixar no ranking de destinos

20725
13:43:34,160 --> 13:43:36,000
É por isso que muitos destes

20726
13:43:36,000 --> 13:43:38,480
As funções aqui são consideradas inseguras por

20727
13:43:38,480 --> 13:43:40,560
Muitos compiladores eu não acho que você pode

20728
13:43:40,560 --> 13:43:42,560
compilar isso no estúdio visual que está indo

20729
13:43:42,560 --> 13:43:45,040
para impedi-lo de fazer isso por causa de

20730
13:43:45,040 --> 13:43:46,160
Isto é

20731
13:43:46,160 --> 13:43:47,116
caminho a seguir

20732
13:43:47,116 --> 13:43:48,880
Você tem que manter o controle das coisas

20733
13:43:48,880 --> 13:43:51,276
você mesmo, mas eu estou apenas mostrando você tão

20734
13:43:51,276 --> 13:43:53,680
que você sabe como evitar isso

20735
13:43:53,680 --> 13:43:55,436
problemas se você estiver em um

20736
13:43:55,436 --> 13:43:57,596
Compilador que não protege você de

20737
13:43:57,596 --> 13:43:59,596
Isso então nós vamos anexar adeus

20738
13:43:59,596 --> 13:44:02,480
mundo para o que quer que esteja na poeira e em baixo

20739
13:44:02,480 --> 13:44:04,240
Aqui, se imprimirmos isso, vamos

20740
13:44:04,240 --> 13:44:06,720
ter hello world goodbye mundo impresso

20741
13:44:06,720 --> 13:44:08,480
Vamos jogar com isso em um

20742
13:44:08,480 --> 13:44:10,240
Código visual do estúdio em um minuto não

20743
13:44:10,240 --> 13:44:13,116
Preocupa-se se isso não faz sentido

20744
13:44:13,116 --> 13:44:15,116
Mas aqui está outro exemplo de como

20745
13:44:15,116 --> 13:44:18,640
pode unir forças através de strcat

20746
13:44:18,640 --> 13:44:20,956
Temos dois pontos fortes e nós os estabelecemos

20747
13:44:20,956 --> 13:44:22,956
com personagens simples como este você

20748
13:44:22,956 --> 13:44:25,756
pode fazer isso e colocar em seu próprio agora

20749
13:44:25,756 --> 13:44:28,000
Terminar o caráter este é um c legal

20750
13:44:28,000 --> 13:44:30,320
mais plus poderia e note que este

20751
13:44:30,320 --> 13:44:32,560
array é uma matriz dinâmica que vai

20752
13:44:32,560 --> 13:44:34,560
Deixe no quadril por causa dessa nova

20753
13:44:34,560 --> 13:44:37,200
Operador aqui também temos uma fonte

20754
13:44:37,200 --> 13:44:39,116
array que também vai sair em

20755
13:44:39,116 --> 13:44:42,000
O quadril é de 30 caracteres, então

20756
13:44:42,000 --> 13:44:44,400
É realmente longo e nós vamos tentar

20757
13:44:44,400 --> 13:44:46,640
e colocar posição aqui, mas antes

20758
13:44:46,640 --> 13:44:48,080
Fazemos isso, vamos verificar os seus

20759
13:44:48,080 --> 13:44:50,080
comprimento vamos imprimi-los para fora e

20760
13:44:50,080 --> 13:44:52,240
Vamos conspirar a sintaxe

20761
13:44:52,240 --> 13:44:55,040
É o mesmo que você vai dizer hdr gato

20762
13:44:55,040 --> 13:44:57,436
Você vai especificar seu destino

20763
13:44:57,436 --> 13:44:58,800
e sua fonte você vai ser

20764
13:44:58,800 --> 13:45:01,436
copiando coisas de e você está indo para

20765
13:45:01,436 --> 13:45:03,840
armazenar o resultado no destino aqui

20766
13:45:03,840 --> 13:45:05,360
O que isso vai fazer, vai fazer

20767
13:45:05,360 --> 13:45:08,160
Pegue o que estiver na fonte e copie-o

20768
13:45:08,160 --> 13:45:09,840
Então vai copiar a coisa toda

20769
13:45:09,840 --> 13:45:11,916
aqui da fonte e vai

20770
13:45:11,916 --> 13:45:13,680
Anexar isso a tudo o que temos em

20771
13:45:13,680 --> 13:45:17,276
Destino a partir do último null

20772
13:45:17,276 --> 13:45:19,116
personagem aqui, então vai

20773
13:45:19,116 --> 13:45:21,520
sobrescrever a partir deste personagem nulo e

20774
13:45:21,520 --> 13:45:23,916
Vai basicamente copiar tudo

20775
13:45:23,916 --> 13:45:26,400
e o destino aqui e se imprimirmos

20776
13:45:26,400 --> 13:45:28,080
O que temos no destino aqui

20777
13:45:28,080 --> 13:45:30,240
nós vamos ter um senhor dos bombeiros

20778
13:45:30,240 --> 13:45:32,160
a fênix tipo de impresso para fora e

20779
13:45:32,160 --> 13:45:33,520
Você vai ver que isso está acontecendo

20780
13:45:33,520 --> 13:45:36,080
para ser o caso quando atingimos o estúdio visual

20781
13:45:36,080 --> 13:45:37,840
código em um minuto você também pode usar um

20782
13:45:37,840 --> 13:45:40,720
versão do gato sdr que é

20783
13:45:40,720 --> 13:45:42,800
permitindo que você especifique

20784
13:45:42,800 --> 13:45:45,756
Quantos personagens você quer

20785
13:45:45,756 --> 13:45:48,240
concatenate a partir da cadeia de origem em

20786
13:45:48,240 --> 13:45:50,000
Este caso temos destino que é

20787
13:45:50,000 --> 13:45:51,840
Olá e nós temos uma fonte que está lá

20788
13:45:51,840 --> 13:45:53,596
É um pássaro

20789
13:45:53,596 --> 13:45:55,040
Na minha janela

20790
13:45:55,040 --> 13:45:58,320
E aqui você vê que fazemos hdr e

20791
13:45:58,320 --> 13:46:00,400
Gato salvamos o destino que salvamos

20792
13:46:00,400 --> 13:46:03,040
Fonte e nós dizemos quantos personagens nós

20793
13:46:03,040 --> 13:46:06,320
Queremos copiado da fonte aqui e nós

20794
13:46:06,320 --> 13:46:08,480
Diga seis personagens, então vamos

20795
13:46:08,480 --> 13:46:10,080
conte a partir da fonte que vamos dizer

20796
13:46:10,080 --> 13:46:12,560
um dois três quatro e cinco seis, estamos indo

20797
13:46:12,560 --> 13:46:14,880
para agarrar esta corda deles com isso

20798
13:46:14,880 --> 13:46:17,116
espaço aqui e vamos anexar

20799
13:46:17,116 --> 13:46:18,956
Isso para a fonte e é isso que nós somos

20800
13:46:18,956 --> 13:46:21,520
Vou entrar aqui, vamos dizer

20801
13:46:21,520 --> 13:46:24,080
Olá espaço e lá e é isso que

20802
13:46:24,080 --> 13:46:26,240
nós vamos ter impresso aqui se

20803
13:46:26,240 --> 13:46:29,276
nós imprimimos poeira nós também podemos copiar coisas e

20804
13:46:29,276 --> 13:46:32,240
a função cpy str aqui vai fazer

20805
13:46:32,240 --> 13:46:34,160
e aqui temos um exemplo que é

20806
13:46:34,160 --> 13:46:37,680
Vou tentar dirigir esta casa para você

20807
13:46:37,680 --> 13:46:39,520
temos uma força de fonte que é c

20808
13:46:39,520 --> 13:46:41,756
Plus plus é uma programação multiúso

20809
13:46:41,756 --> 13:46:44,000
Idioma OK convidado três aqui está indo

20810
13:46:44,000 --> 13:46:46,080
ser o mesmo comprimento que a fonte que nós

20811
13:46:46,080 --> 13:46:48,720
Certifica-se disso aqui porque estamos

20812
13:46:48,720 --> 13:46:50,880
Vou pegar o comprimento da fonte

20813
13:46:50,880 --> 13:46:53,436
Força, por favor, lembre-se que o Sdrlam é

20814
13:46:53,436 --> 13:46:54,880
Não vai contar

20815
13:46:54,880 --> 13:46:57,436
O personagem nu, é por isso que somos

20816
13:46:57,436 --> 13:46:59,680
Adicionando um aqui para explicar o

20817
13:46:59,680 --> 13:47:01,916
substantivo terminando personagem aqui ok

20818
13:47:01,916 --> 13:47:03,680
Depois disso, vamos pular aqui

20819
13:47:03,680 --> 13:47:07,916
e dizer htr cpy dest 3 e fonte 3 nós

20820
13:47:07,916 --> 13:47:10,320
Será basicamente copiar de

20821
13:47:10,320 --> 13:47:12,400
fonte e pastagem

20822
13:47:12,400 --> 13:47:14,160
no destino aqui é o que somos

20823
13:47:14,160 --> 13:47:16,480
Fazendo se imprimirmos o destino, estamos

20824
13:47:16,480 --> 13:47:17,916
Vou ver que agora vai

20825
13:47:17,916 --> 13:47:20,800
conter tudo o que tínhamos na fonte e

20826
13:47:20,800 --> 13:47:22,720
É assim que você pode usar esses métodos

20827
13:47:22,720 --> 13:47:25,040
Aqui também temos uma versão

20828
13:47:25,040 --> 13:47:27,276
Na qual podemos especificar quantos

20829
13:47:27,276 --> 13:47:29,116
Personagens que queremos copiados do

20830
13:47:29,116 --> 13:47:31,520
Fonte aqui temos uma string de origem

20831
13:47:31,520 --> 13:47:33,756
que é olá, temos um destino

20832
13:47:33,756 --> 13:47:36,480
string que é zest 4 e nós estamos indo

20833
13:47:36,480 --> 13:47:38,320
para copiar coisas que vamos copiar de

20834
13:47:38,320 --> 13:47:40,480
a fonte que vamos colar no

20835
13:47:40,480 --> 13:47:42,560
Destino e vamos apenas para

20836
13:47:42,560 --> 13:47:45,520
Copie cinco caracteres o que isso está acontecendo

20837
13:47:45,520 --> 13:47:48,080
Fazer é copiar tudo da fonte

20838
13:47:48,080 --> 13:47:51,276
e colar no nosso destino e é

20839
13:47:51,276 --> 13:47:54,160
indo para substituir o que temos em

20840
13:47:54,160 --> 13:47:57,040
os índices iniciais no destino aqui

20841
13:47:57,040 --> 13:47:59,840
Então nós vamos ter um b c d e aqui

20842
13:47:59,840 --> 13:48:02,956
substituído por hello e se imprimirmos isso

20843
13:48:02,956 --> 13:48:05,680
Aqui vamos ter olá f impresso

20844
13:48:05,680 --> 13:48:08,080
É assim que essas coisas funcionam e se

20845
13:48:08,080 --> 13:48:10,320
Você se pergunta como eu sei como essas coisas

20846
13:48:10,320 --> 13:48:12,640
trabalho Eu só venho e leio o

20847
13:48:12,640 --> 13:48:15,360
documentação aqui, por exemplo, htr e

20848
13:48:15,360 --> 13:48:17,680
cpy aqui, se clicarmos nele, estamos indo

20849
13:48:17,680 --> 13:48:19,520
para obter a documentação que está indo

20850
13:48:19,520 --> 13:48:22,240
para dizer cópias na maioria dos personagens contam

20851
13:48:22,240 --> 13:48:23,916
da corda do byte

20852
13:48:23,916 --> 13:48:26,480
fonte incluindo o encerramento nulo

20853
13:48:26,480 --> 13:48:28,800
caractere para o array de caracteres apontado

20854
13:48:28,800 --> 13:48:30,880
para by desk é isso que nós temos

20855
13:48:30,880 --> 13:48:33,040
O destino que temos a fonte e

20856
13:48:33,040 --> 13:48:34,720
Temos quantos personagens queremos

20857
13:48:34,720 --> 13:48:36,720
copiou e eles dizem algumas coisas que você

20858
13:48:36,720 --> 13:48:38,800
Preciso ter cuidado com esse cara aqui

20859
13:48:38,800 --> 13:48:41,596
Uma coisa que você costuma se importar é

20860
13:48:41,596 --> 13:48:43,436
O valor de retorno você vê que o retorno

20861
13:48:43,436 --> 13:48:45,596
O valor será o destino

20862
13:48:45,596 --> 13:48:47,756
força assim se você quer este ponteiro você

20863
13:48:47,756 --> 13:48:50,080
pode usá-lo e você pode ir para baixo e olhar

20864
13:48:50,080 --> 13:48:52,800
em alguns exemplos aqui e jogar com

20865
13:48:52,800 --> 13:48:55,276
eles para realmente conduzir o ponto para casa ok

20866
13:48:55,276 --> 13:48:57,276
Agora que você tem uma ideia de como

20867
13:48:57,276 --> 13:48:59,436
Esses caras trabalham que vamos cabeçar

20868
13:48:59,436 --> 13:49:02,000
sobre o código do estúdio visual e jogar com

20869
13:49:02,000 --> 13:49:02,880
eles

20870
13:49:02,880 --> 13:49:05,276
Ok, tudo bem aqui estamos em nosso

20871
13:49:05,276 --> 13:49:08,320
pasta de trabalho o projeto atual é c

20872
13:49:08,320 --> 13:49:10,560
string concatenação e cópia que é

20873
13:49:10,560 --> 13:49:12,400
O que estamos fazendo aqui vamos

20874
13:49:12,400 --> 13:49:15,360
Copie nossos arquivos de modelo e uh saltar para

20875
13:49:15,360 --> 13:49:18,160
nosso projeto atual e colocá-los em

20876
13:49:18,160 --> 13:49:20,800
lugar que vamos abrir isso em visual

20877
13:49:20,800 --> 13:49:22,880
Código de estúdio muito rápido que vamos

20878
13:49:22,880 --> 13:49:24,640
incluir c string porque é isso que

20879
13:49:24,640 --> 13:49:26,400
Vamos usar aqui que estamos

20880
13:49:26,400 --> 13:49:28,400
Vou trazer isso um pouco e

20881
13:49:28,400 --> 13:49:30,560
Vamos dar o nosso primeiro exemplo

20882
13:49:30,560 --> 13:49:32,800
Aqui temos dois pontos fortes

20883
13:49:32,800 --> 13:49:35,200
Destino e fonte e você vê que

20884
13:49:35,200 --> 13:49:37,520
nós tentamos e nos certificamos de que eles são

20885
13:49:37,520 --> 13:49:39,916
grande o suficiente para conter quanto muitos

20886
13:49:39,916 --> 13:49:42,080
Personagens que queremos colocar

20887
13:49:42,080 --> 13:49:44,640
e são matrizes de linhas armazenadas no

20888
13:49:44,640 --> 13:49:47,756
empilhar porque eles estão configurados assim

20889
13:49:47,756 --> 13:49:49,200
e novamente você pode verificar o

20890
13:49:49,200 --> 13:49:51,200
documentação aqui, se você quiser saber

20891
13:49:51,200 --> 13:49:53,360
Como funciona essa função e estamos indo

20892
13:49:53,360 --> 13:49:57,756
para chamar strcat aqui para conspirar

20893
13:49:57,756 --> 13:50:00,560
fonte para o nosso destino aqui, então se nós

20894
13:50:00,560 --> 13:50:02,756
Fazei isto, vamos ter o mundo aqui

20895
13:50:02,756 --> 13:50:05,756
Concatenado ao que temos em Olá

20896
13:50:05,756 --> 13:50:07,916
Aqui e nós vamos ter olá mundo

20897
13:50:07,916 --> 13:50:10,480
no lugar, por exemplo, se tentarmos imprimir

20898
13:50:10,480 --> 13:50:13,756
Isso fora eu vou tentar e fazer aquilo

20899
13:50:13,756 --> 13:50:16,160
Depois de fazermos a primeira concatenação aqui

20900
13:50:16,160 --> 13:50:18,320
Vamos fazer isso que vai ser melhor

20901
13:50:18,320 --> 13:50:20,880
para mostrar como essas coisas funcionam bem

20902
13:50:20,880 --> 13:50:23,116
Depois da primeira função aqui corre, estamos

20903
13:50:23,116 --> 13:50:26,400
ter uma fonte concatenada para

20904
13:50:26,400 --> 13:50:28,640
destino aqui o que vamos fazer

20905
13:50:28,640 --> 13:50:30,880
ter é o mundo dolá armazenado em

20906
13:50:30,880 --> 13:50:32,560
Destino aqui o segundo

20907
13:50:32,560 --> 13:50:34,720
A concatenação aqui vai anexar

20908
13:50:34,720 --> 13:50:37,360
adeus mundo para o que temos em

20909
13:50:37,360 --> 13:50:39,436
destino aqui o que vamos fazer

20910
13:50:39,436 --> 13:50:42,560
ter impresso para baixo é se imprimirmos isso de

20911
13:50:42,560 --> 13:50:44,956
Curso é hello mundo e adeus mundo

20912
13:50:44,956 --> 13:50:46,400
Tudo bem, vamos ter isso escrito

20913
13:50:46,400 --> 13:50:49,040
Vamos tentar correr isso e realmente

20914
13:50:49,040 --> 13:50:51,520
Certifique-se de que esse é o caso e então

20915
13:50:51,520 --> 13:50:53,520
nós vamos ver como essa função pode

20916
13:50:53,520 --> 13:50:56,160
ser inseguro para alguns compiladores que estamos indo

20917
13:50:56,160 --> 13:50:58,240
para construir isso com gcc você vê que é

20918
13:50:58,240 --> 13:51:00,240
indo para ir através

20919
13:51:00,240 --> 13:51:01,840
E se nós executarmos isso, vamos ter

20920
13:51:01,840 --> 13:51:04,320
Olá mundo Olá mundo Olá mundo adeus mundo

20921
13:51:04,320 --> 13:51:06,880
Imprimindo isso é o que esperamos e

20922
13:51:06,880 --> 13:51:07,756
Mais uma vez

20923
13:51:07,756 --> 13:51:10,240
esta função aqui sdr gato vai

20924
13:51:10,240 --> 13:51:12,480
ter o que você tem na fonte e isso

20925
13:51:12,480 --> 13:51:14,640
vai anexar isso a qualquer coisa que você

20926
13:51:14,640 --> 13:51:17,200
ter no destino e para que isso funcione

20927
13:51:17,200 --> 13:51:19,360
Você tem que ter certeza de que o destino

20928
13:51:19,360 --> 13:51:22,640
é modificável, por exemplo, se foi um

20929
13:51:22,640 --> 13:51:25,276
variedade de custo núcleo vamos fazer isso e

20930
13:51:25,276 --> 13:51:27,040
mostrar o erro do compilador que devemos

20931
13:51:27,040 --> 13:51:29,680
obter um erro de compilador porque agora

20932
13:51:29,680 --> 13:51:32,320
Destino não é modificável é um

20933
13:51:32,320 --> 13:51:34,956
variedade de personagens de custo e não podemos

20934
13:51:34,956 --> 13:51:37,596
modifique-o para ter certeza

20935
13:51:37,596 --> 13:51:40,560
a matriz de destino é modificável e

20936
13:51:40,560 --> 13:51:42,720
Neste caso, tudo bem, por favor, note que

20937
13:51:42,720 --> 13:51:44,480
Algumas dessas funções podem ser tratadas

20938
13:51:44,480 --> 13:51:47,680
como inseguro por alguns compiladores, mas eu tentei

20939
13:51:47,680 --> 13:51:50,720
isso em ambos em gcc e no compilador

20940
13:51:50,720 --> 13:51:52,956
de microsoft e eles funcionam muito bem

20941
13:51:52,956 --> 13:51:54,956
para que você possa experimentá-los aqui para provar

20942
13:51:54,956 --> 13:51:57,360
que vamos tentar construir com o

20943
13:51:57,360 --> 13:51:59,916
Compilador de Microsoft que temos

20944
13:51:59,916 --> 13:52:01,276
A criação aqui

20945
13:52:01,276 --> 13:52:02,956
Vamos executar a tarefa de construir

20946
13:52:02,956 --> 13:52:05,596
Com o msvc aqui

20947
13:52:05,596 --> 13:52:06,880
Você vai ver que o mundo

20948
13:52:06,880 --> 13:52:08,880
Vai ser bom o mundo acabado

20949
13:52:08,880 --> 13:52:11,040
Com sucesso e se vamos e nós somos

20950
13:52:11,040 --> 13:52:12,560
indo para limpar

20951
13:52:12,560 --> 13:52:14,160
e correr galo você vai ver que

20952
13:52:14,160 --> 13:52:16,400
Vai fazer exatamente a mesma coisa

20953
13:52:16,400 --> 13:52:18,160
mas alguns compiladores podem lhe dar

20954
13:52:18,160 --> 13:52:20,080
avisos ou erros se você tentar fazer

20955
13:52:20,080 --> 13:52:22,480
Algo assim e a razão é

20956
13:52:22,480 --> 13:52:24,160
você realmente tem que ter cuidado com o uso

20957
13:52:24,160 --> 13:52:26,720
essas funções porque, por exemplo

20958
13:52:26,720 --> 13:52:29,276
Destination array não é grande o suficiente

20959
13:52:29,276 --> 13:52:32,000
Você pode fazer algumas coisas loucas correndo

20960
13:52:32,000 --> 13:52:33,840
sobre o equilíbrio de sua matriz e ele

20961
13:52:33,840 --> 13:52:36,480
Pode ser muito ruim, por exemplo, se tentarmos

20962
13:52:36,480 --> 13:52:38,480
e fazer matriz de destino aqui para

20963
13:52:38,480 --> 13:52:41,040
Exemplo de um tamanho de três é possível

20964
13:52:41,040 --> 13:52:43,680
para fazer isso e você vê que nós temos um

20965
13:52:43,680 --> 13:52:46,800
aviso do código do estúdio visual e se

20966
13:52:46,800 --> 13:52:49,436
Nós tentamos construir isso com gcc vamos tentar

20967
13:52:49,436 --> 13:52:51,520
e remover o lixo que temos de

20968
13:52:51,520 --> 13:52:54,000
Estúdio visual primeiro agora que este é

20969
13:52:54,000 --> 13:52:58,080
limpo, podemos uh tentar construir com gcc

20970
13:52:58,080 --> 13:53:00,000
Vamos fazer isso nosso compilador que estamos indo

20971
13:53:00,000 --> 13:53:02,560
para escolher gcc e você vai ver

20972
13:53:02,560 --> 13:53:03,840
que vai lhe dar um erro

20973
13:53:03,840 --> 13:53:05,756
Vai realmente nos proteger de

20974
13:53:05,756 --> 13:53:08,160
Fazendo algo assim, mas em alguns

20975
13:53:08,160 --> 13:53:10,160
casos em que alguns compiladores não vão

20976
13:53:10,160 --> 13:53:12,400
impedir você de fazer isso, mas qualquer

20977
13:53:12,400 --> 13:53:15,276
Compilador que realmente se respeita

20978
13:53:15,276 --> 13:53:17,680
vai ter essas verificações de segurança

20979
13:53:17,680 --> 13:53:19,360
dentro e vai te proteger de

20980
13:53:19,360 --> 13:53:21,360
Fazendo algo louco assim tudo bem

20981
13:53:21,360 --> 13:53:23,680
É assim que você pode fazer a concatenação

20982
13:53:23,680 --> 13:53:27,840
usando hdr gato como fizemos aqui vamos tentar

20983
13:53:27,840 --> 13:53:29,436
e soldar e ver que agora estamos

20984
13:53:29,436 --> 13:53:31,276
construindo bem porque eu não gosto destes

20985
13:53:31,276 --> 13:53:33,756
linhas vermelhas aqui o mundo é bom e nós

20986
13:53:33,756 --> 13:53:36,000
Estamos todos bem agora eu vou comentar

20987
13:53:36,000 --> 13:53:37,276
Isto para fora

20988
13:53:37,276 --> 13:53:38,800
E nós vamos ver outro exemplo

20989
13:53:38,800 --> 13:53:41,436
de como podemos criar coisas que somos

20990
13:53:41,436 --> 13:53:43,276
Indo para baixo aqui vamos trazer isso

20991
13:53:43,276 --> 13:53:45,596
Para baixo e esconder isso

20992
13:53:45,596 --> 13:53:47,840
e nós vamos colocar em nosso simples

20993
13:53:47,840 --> 13:53:49,916
Um exemplo exatamente a mesma coisa em que vimos

20994
13:53:49,916 --> 13:53:52,240
Os slides temos dois

20995
13:53:52,240 --> 13:53:55,116
arrays de caracteres eles são matrizes dinâmicas

20996
13:53:55,116 --> 13:53:57,756
mas nós os inicializamos com personagens

20997
13:53:57,756 --> 13:54:00,000
assim e nos certificamos de colocar em nosso

20998
13:54:00,000 --> 13:54:00,880
O null

20999
13:54:00,880 --> 13:54:03,200
terminator nós temos a nossa força de fonte

21000
13:54:03,200 --> 13:54:05,276
que vai dizer o

21001
13:54:05,276 --> 13:54:07,436
femix king e vai ter um

21002
13:54:07,436 --> 13:54:08,956
Terminator aqui

21003
13:54:08,956 --> 13:54:10,320
E o que vamos fazer, vamos

21004
13:54:10,320 --> 13:54:13,276
tomar soros e concatenar isso para

21005
13:54:13,276 --> 13:54:15,520
nosso destino, então o que realmente está acontecendo

21006
13:54:15,520 --> 13:54:17,680
para acontecer, vamos substituir o

21007
13:54:17,680 --> 13:54:19,680
null terminator aqui e nós vamos

21008
13:54:19,680 --> 13:54:22,640
começar a colar nas coisas da fonte aqui

21009
13:54:22,640 --> 13:54:24,956
Então, depois da concatenação, é feito o que

21010
13:54:24,956 --> 13:54:27,360
Estamos fazendo aqui que estamos concatenando

21011
13:54:27,360 --> 13:54:29,596
fonte um para testar um

21012
13:54:29,596 --> 13:54:32,400
nós vamos ter o Senhor do Fogo

21013
13:54:32,400 --> 13:54:35,360
phoenix kang armazenado em nosso destino

21014
13:54:35,360 --> 13:54:36,480
string aqui

21015
13:54:36,480 --> 13:54:39,756
e perceber que nos certificamos de que

21016
13:54:39,756 --> 13:54:42,320
grande o suficiente para conter nossos personagens

21017
13:54:42,320 --> 13:54:44,240
Aqui e se imprimirmos, vamos

21018
13:54:44,240 --> 13:54:46,880
para ter a coisa impressa para fora, podemos tentar

21019
13:54:46,880 --> 13:54:49,596
e solda com gcc que vai ir

21020
13:54:49,596 --> 13:54:51,756
através de vamos trazer isso para cima a lâmpada é

21021
13:54:51,756 --> 13:54:52,640
Bom

21022
13:54:52,640 --> 13:54:54,800
Se você descer aqui a construção é boa

21023
13:54:54,800 --> 13:54:57,596
nós vamos limpar e correr o galo

21024
13:54:57,596 --> 13:54:59,276
Tudo bem esta é a saída aqui que você vê

21025
13:54:59,276 --> 13:55:01,840
O destino é de oito caracteres

21026
13:55:01,840 --> 13:55:05,276
longo se contarmos um dois três quatro cinco

21027
13:55:05,276 --> 13:55:08,080
Seis sete oito lembram sdrl lan

21028
13:55:08,080 --> 13:55:10,320
não conta o personagem nulo, então isso

21029
13:55:10,320 --> 13:55:12,400
É o que esperamos que oito personagens o

21030
13:55:12,400 --> 13:55:14,560
A fonte terá 17 caracteres se

21031
13:55:14,560 --> 13:55:16,000
Você conta tudo isso que é o que você é

21032
13:55:16,000 --> 13:55:17,200
indo para chegar

21033
13:55:17,200 --> 13:55:19,840
E se nós os conspiramos agora, isso

21034
13:55:19,840 --> 13:55:21,596
A doação vai ser

21035
13:55:21,596 --> 13:55:24,000
25 caracteres de comprimento

21036
13:55:24,000 --> 13:55:26,956
nos olhos da terra de hdr e você vê que

21037
13:55:26,956 --> 13:55:28,880
nós imprimimos o destino e é

21038
13:55:28,880 --> 13:55:31,596
exatamente o que esperamos Senhor do Fogo

21039
13:55:31,596 --> 13:55:34,000
Fênix gang OK, vamos comentar

21040
13:55:34,000 --> 13:55:35,596
Isso eu só queria que você visse um

21041
13:55:35,596 --> 13:55:37,596
Exemplo disso e a única coisa que eu

21042
13:55:37,596 --> 13:55:40,400
realmente quero enfatizar neste exemplo

21043
13:55:40,400 --> 13:55:42,800
É que strcat vai começar

21044
13:55:42,800 --> 13:55:45,916
substituindo tudo o que está no início da poeira

21045
13:55:45,916 --> 13:55:49,756
no último personagem nulo, então isso

21046
13:55:49,756 --> 13:55:52,240
O cara vai ser substituído pelo

21047
13:55:52,240 --> 13:55:54,160
Comma aqui e nós vamos começar e

21048
13:55:54,160 --> 13:55:55,840
Colocar coisas e isso é o que somos

21049
13:55:55,840 --> 13:55:58,080
Vou ver aqui vamos comentar isso

21050
13:55:58,080 --> 13:56:00,160
Porque nós queremos seguir em frente e mostrar a você

21051
13:56:00,160 --> 13:56:02,240
alguns outros exemplos da próxima coisa

21052
13:56:02,240 --> 13:56:04,640
Vamos olhar para uma nova versão

21053
13:56:04,640 --> 13:56:08,400
de gato str que permite especificar

21054
13:56:08,400 --> 13:56:09,916
Quantos personagens você deseja

21055
13:56:09,916 --> 13:56:11,436
concatenados

21056
13:56:11,436 --> 13:56:13,756
da fonte, por exemplo, aqui temos dois

21057
13:56:13,756 --> 13:56:16,640
pontos fortes destino e fonte e

21058
13:56:16,640 --> 13:56:19,756
Aqui estamos basicamente dizendo que eu quero

21059
13:56:19,756 --> 13:56:22,880
concatenate seis caracteres da fonte

21060
13:56:22,880 --> 13:56:24,640
e colocá-los no final do

21061
13:56:24,640 --> 13:56:26,800
destino aqui e o que vai

21062
13:56:26,800 --> 13:56:30,800
Ele vai pegar um dois três quatro

21063
13:56:30,800 --> 13:56:33,040
Cinco seis vai pegar tudo isso

21064
13:56:33,040 --> 13:56:35,040
coisa e vai anexar isso a

21065
13:56:35,040 --> 13:56:37,200
Olá e nós vamos ter olá

21066
13:56:37,200 --> 13:56:40,160
lá armazenado no destino e

21067
13:56:40,160 --> 13:56:42,480
O retorno de valor será um ponteiro para

21068
13:56:42,480 --> 13:56:44,956
Destino 2. e como eu sei

21069
13:56:44,956 --> 13:56:47,360
Retorne valor bem, eu sei que do

21070
13:56:47,360 --> 13:56:50,080
documentação se você entrar no seu favorito

21071
13:56:50,080 --> 13:56:51,880
motor de busca e fazer

21072
13:56:51,880 --> 13:56:54,956
stdstr e gato e você vai ver um

21073
13:56:54,956 --> 13:56:57,116
link aqui se você clicar nele a partir de cpp

21074
13:56:57,116 --> 13:56:58,640
referência que vai te dar

21075
13:56:58,640 --> 13:57:00,160
Tudo que você precisa saber sobre isso

21076
13:57:00,160 --> 13:57:02,640
Função aqui vai anexar

21077
13:57:02,640 --> 13:57:05,916
fonte para destino e contagem

21078
13:57:05,916 --> 13:57:07,756
Os personagens serão copiados, então o

21079
13:57:07,756 --> 13:57:09,520
O terceiro parâmetro aqui vai ser como

21080
13:57:09,520 --> 13:57:11,916
Muitos personagens que você quer copiar e

21081
13:57:11,916 --> 13:57:14,560
Cotado em nosso destino

21082
13:57:14,560 --> 13:57:16,640
e o valor de retorno será dest

21083
13:57:16,640 --> 13:57:18,320
Tudo bem se tentarmos isso, vamos

21084
13:57:18,320 --> 13:57:20,480
veja olá lá impresso para fora nós vamos

21085
13:57:20,480 --> 13:57:22,160
para imprimi-lo diretamente e nós vamos

21086
13:57:22,160 --> 13:57:24,240
para imprimir isso fora

21087
13:57:24,240 --> 13:57:26,956
usando o ponteiro de destino que é

21088
13:57:26,956 --> 13:57:29,040
Vou voltar desse cara aqui

21089
13:57:29,040 --> 13:57:30,956
então, se tentarmos construir isso, estamos indo

21090
13:57:30,956 --> 13:57:33,436
para construir com gcc a bala vai

21091
13:57:33,436 --> 13:57:35,756
sermos bons, vamos limpar e correr

21092
13:57:35,756 --> 13:57:37,040
Galo e você vai ver que nós

21093
13:57:37,040 --> 13:57:39,436
Tenho olá lá duas vezes aqui e isso é

21094
13:57:39,436 --> 13:57:41,436
Exceto o que esperamos

21095
13:57:41,436 --> 13:57:43,436
Nós vamos comentar isso e nós

21096
13:57:43,436 --> 13:57:48,000
estão indo para baixo e olhar para sdr cpi

21097
13:57:48,000 --> 13:57:51,040
Eu devo dizer sdr cpy que vai

21098
13:57:51,040 --> 13:57:53,596
copiar coisas da fonte e colar

21099
13:57:53,596 --> 13:57:57,040
aqueles no destino e uma coisa

21100
13:57:57,040 --> 13:57:59,200
Você deve saber que a cópia é

21101
13:57:59,200 --> 13:58:01,276
Vai acontecer a partir do início

21102
13:58:01,276 --> 13:58:03,596
da matriz de destino aqui que temos

21103
13:58:03,596 --> 13:58:06,000
Dois arrays um é chamado fonte três

21104
13:58:06,000 --> 13:58:08,560
O outro é chamado destino três

21105
13:58:08,560 --> 13:58:11,116
O destino 3 é configurado no heap

21106
13:58:11,116 --> 13:58:12,880
usando o novo operador para que seja um

21107
13:58:12,880 --> 13:58:15,276
matriz dinâmica e você vê que nós fazemos

21108
13:58:15,276 --> 13:58:17,520
É o mesmo tamanho que

21109
13:58:17,520 --> 13:58:18,640
Fonte

21110
13:58:18,640 --> 13:58:21,276
Estamos usando sdr lan para descobrir como

21111
13:58:21,276 --> 13:58:23,436
Muitos personagens que temos aqui

21112
13:58:23,436 --> 13:58:26,160
e lembre-se que sdr terra não

21113
13:58:26,160 --> 13:58:28,240
conta para o personagem nulo, então nós somos

21114
13:58:28,240 --> 13:58:30,720
adicionando um para explicar o null

21115
13:58:30,720 --> 13:58:32,640
Personagem que é o que estamos fazendo aqui

21116
13:58:32,640 --> 13:58:34,560
e depois disso vamos fazer std

21117
13:58:34,560 --> 13:58:38,160
str cpy e o que isso vai fazer é

21118
13:58:38,160 --> 13:58:41,276
copiar coisas da fonte para o destino

21119
13:58:41,276 --> 13:58:42,956
personagem por personagem, então nós somos

21120
13:58:42,956 --> 13:58:46,160
basicamente vai ter esse cara colado

21121
13:58:46,160 --> 13:58:48,640
no destino aqui e se imprimirmos

21122
13:58:48,640 --> 13:58:50,000
Coisas fora nós vamos ver isso

21123
13:58:50,000 --> 13:58:52,720
O destino contém a mesma coisa que

21124
13:58:52,720 --> 13:58:55,596
fonte aqui se construímos isso com gcc

21125
13:58:55,596 --> 13:58:57,200
Vamos fazer isso que a construção vai ser

21126
13:58:57,200 --> 13:58:58,800
Bom que podemos limpar

21127
13:58:58,800 --> 13:59:00,880
e correr galo e você vai ver

21128
13:59:00,880 --> 13:59:03,200
que o destino tem exatamente o

21129
13:59:03,200 --> 13:59:05,276
A mesma coisa que tínhamos na fonte e se

21130
13:59:05,276 --> 13:59:08,160
você precisa copiar coisas de arrays sdr

21131
13:59:08,160 --> 13:59:11,200
cpui vai ser muito útil

21132
13:59:11,200 --> 13:59:13,040
vamos comentar isso porque

21133
13:59:13,040 --> 13:59:15,116
Ainda temos algumas coisas que queremos

21134
13:59:15,116 --> 13:59:15,916
Veja

21135
13:59:15,916 --> 13:59:18,880
então vamos comentar isso, estamos indo

21136
13:59:18,880 --> 13:59:20,956
para descer e ver que também podemos usar

21137
13:59:20,956 --> 13:59:23,596
Uma outra versão que nos permite

21138
13:59:23,596 --> 13:59:25,916
Especifique quantos personagens queremos

21139
13:59:25,916 --> 13:59:28,240
copiado da fonte ok neste

21140
13:59:28,240 --> 13:59:31,680
Um exemplo aqui estamos usando std str e

21141
13:59:31,680 --> 13:59:34,560
cpy e isso n aqui significa que podemos

21142
13:59:34,560 --> 13:59:38,080
especificar a contagem de caracteres que fazemos

21143
13:59:38,080 --> 13:59:39,116
Seja o que for

21144
13:59:39,116 --> 13:59:41,360
A função atual está fazendo aqui ok

21145
13:59:41,360 --> 13:59:43,916
Então estamos especificando que eu quero cinco

21146
13:59:43,916 --> 13:59:46,800
Personagens copiados da fonte e eu quero

21147
13:59:46,800 --> 13:59:49,276
aqueles colados no destino aqui

21148
13:59:49,276 --> 13:59:51,436
Isso é o que estamos dizendo aqui e

21149
13:59:51,436 --> 13:59:53,276
Fonte vai conter o hello

21150
13:59:53,276 --> 13:59:54,800
O destino vai conter o

21151
13:59:54,800 --> 13:59:57,276
O mundo e a cópia vão acontecer

21152
13:59:57,276 --> 14:00:00,240
Começando no primeiro índice aqui, então

21153
14:00:00,240 --> 14:00:02,080
nós vamos ter olá override

21154
14:00:02,080 --> 14:00:05,436
o que temos em um b c d e porque

21155
14:00:05,436 --> 14:00:07,916
que são cinco personagens aqui e a poeira

21156
14:00:07,916 --> 14:00:10,640
vai conter olá f se imprimirmos

21157
14:00:10,640 --> 14:00:12,956
vamos construir isso e ver se

21158
14:00:12,956 --> 14:00:14,480
É isso que vamos conseguir, estamos

21159
14:00:14,480 --> 14:00:16,400
indo para construir com gcc a construção é

21160
14:00:16,400 --> 14:00:17,840
indo para ir através

21161
14:00:17,840 --> 14:00:20,080
nós vamos limpar e correr galo

21162
14:00:20,080 --> 14:00:22,000
E você vê que isso é exatamente o que nós

21163
14:00:22,000 --> 14:00:23,116
Tenho aqui

21164
14:00:23,116 --> 14:00:25,360
Tudo bem é assim que esses métodos funcionam

21165
14:00:25,360 --> 14:00:27,040
Existem muitas outras funções que você pode

21166
14:00:27,040 --> 14:00:27,916
Uso

21167
14:00:27,916 --> 14:00:30,400
da biblioteca c string e novamente se

21168
14:00:30,400 --> 14:00:32,080
Você quer ver

21169
14:00:32,080 --> 14:00:34,480
Uma lista de todos eles que você pode passar

21170
14:00:34,480 --> 14:00:36,320
O seu

21171
14:00:36,320 --> 14:00:38,880
Motor de busca favorito e busca por c

21172
14:00:38,880 --> 14:00:40,080
string string

21173
14:00:40,080 --> 14:00:43,040
e nós podemos especificar a referência do cpp aqui

21174
14:00:43,040 --> 14:00:45,436
Vamos tentar fazer isso bem, podemos encontrar um

21175
14:00:45,436 --> 14:00:47,840
link para isso podemos clicar sobre isso e

21176
14:00:47,840 --> 14:00:49,680
vai se abrir e nos mostrar muitos

21177
14:00:49,680 --> 14:00:52,000
mais funções que podemos usar e se você

21178
14:00:52,000 --> 14:00:53,840
Você precisa saber sobre uma função especial

21179
14:00:53,840 --> 14:00:55,916
você pode clicar nele e ver o que ele faz

21180
14:00:55,916 --> 14:00:57,520
E se você descer, você vai encontrar

21181
14:00:57,520 --> 14:00:59,840
Um exemplo de como você pode usá-lo

21182
14:00:59,840 --> 14:01:01,436
Por enquanto, vamos parar por aqui

21183
14:01:01,436 --> 14:01:03,040
Esta palestra e isso está realmente indo

21184
14:01:03,040 --> 14:01:05,360
para ser a última palestra que vemos em c

21185
14:01:05,360 --> 14:01:07,116
strings no próximo que vamos

21186
14:01:07,116 --> 14:01:10,160
começar e olhar para a força std que é

21187
14:01:10,160 --> 14:01:12,640
um tipo composto que faz trabalhar com

21188
14:01:12,640 --> 14:01:13,680
As forças de força

21189
14:01:13,680 --> 14:01:16,320
Muito fácil em c plus plus

21190
14:01:16,320 --> 14:01:18,720
Vá em frente e termine aqui e me encontre

21191
14:01:18,720 --> 14:01:20,560
lá nesta palestra vamos

21192
14:01:20,560 --> 14:01:23,360
começar e aprender sobre a força hdd que

21193
14:01:23,360 --> 14:01:25,436
É um tipo que vai torná-lo super

21194
14:01:25,436 --> 14:01:28,240
fácil de trabalhar com dados de string que temos

21195
14:01:28,240 --> 14:01:30,080
Vi muitas maneiras com as quais podemos trabalhar

21196
14:01:30,080 --> 14:01:32,640
arrays de caracteres até agora podemos usar linha

21197
14:01:32,640 --> 14:01:35,200
Raios podemos apontar para eles com ponteiros

21198
14:01:35,200 --> 14:01:37,596
Podemos até mesmo alocar arrays no quadril

21199
14:01:37,596 --> 14:01:40,640
mas todos esses arrays de personagens tinham alguns

21200
14:01:40,640 --> 14:01:43,756
problemas que são realmente uma dor no

21201
14:01:43,756 --> 14:01:46,400
pescoço para lidar diariamente

21202
14:01:46,400 --> 14:01:48,480
Um desses problemas foi que você teve

21203
14:01:48,480 --> 14:01:50,320
para manter o tamanho sob controle que você precisa

21204
14:01:50,320 --> 14:01:51,756
Saiba quantos

21205
14:01:51,756 --> 14:01:54,640
elementos que você tem na matriz de caracteres

21206
14:01:54,640 --> 14:01:57,680
e isso estava definindo os limites que

21207
14:01:57,680 --> 14:02:00,320
você pode trabalhar se você passar por cima de limites

21208
14:02:00,320 --> 14:02:02,720
Eles viram que isso pode causar falhas de

21209
14:02:02,720 --> 14:02:04,956
Seu programa e você não quer isso

21210
14:02:04,956 --> 14:02:07,276
Outro problema foi que tínhamos 3d para

21211
14:02:07,276 --> 14:02:09,436
Lembre-se de manter o controle do null

21212
14:02:09,436 --> 14:02:11,916
personagem se não o tivermos no lugar

21213
14:02:11,916 --> 14:02:13,680
nós vamos ter problemas quando

21214
14:02:13,680 --> 14:02:16,080
string é impressa para fora e é realmente

21215
14:02:16,080 --> 14:02:18,400
irritante para sempre ter que pensar em

21216
14:02:18,400 --> 14:02:21,040
Estes pequenos detalhes quando tudo que você realmente

21217
14:02:21,040 --> 14:02:24,400
O desejo é armazenar um fio para que c mais mais

21218
14:02:24,400 --> 14:02:27,520
oferece um tipo de alto nível que podemos usar

21219
14:02:27,520 --> 14:02:29,756
e vai esconder todos esses pequenos

21220
14:02:29,756 --> 14:02:32,800
detalhes subterrâneos e tudo o que temos para

21221
14:02:32,800 --> 14:02:35,276
fazer é colocar em nossa string e usá-lo e

21222
14:02:35,276 --> 14:02:37,276
Podemos estar no nosso caminho alegre e fazer

21223
14:02:37,276 --> 14:02:39,436
O que quisermos fazer com dados de string

21224
14:02:39,436 --> 14:02:41,520
em nosso c plus mais aplicação assim que é

21225
14:02:41,520 --> 14:02:42,640
O que vamos fazer, vamos

21226
14:02:42,640 --> 14:02:44,956
ter um tipo que vai envolver no topo

21227
14:02:44,956 --> 14:02:47,680
dos cálculos de matriz feios que temos

21228
14:02:47,680 --> 14:02:50,400
Tenho feito em arrays de personagens que somos

21229
14:02:50,400 --> 14:02:52,640
vou chamar essa corda std e nós somos

21230
14:02:52,640 --> 14:02:54,956
Será capaz de fazer muitos dos

21231
14:02:54,956 --> 14:02:57,756
coisas que estávamos fazendo com cordas c, mas

21232
14:02:57,756 --> 14:02:59,916
de uma forma muito melhor nós podemos concatenar

21233
14:02:59,916 --> 14:03:01,916
nós podemos procurar podemos copiar nós podemos fazer tudo

21234
14:03:01,916 --> 14:03:04,000
Tipos de coisas loucas realmente, mas é

21235
14:03:04,000 --> 14:03:06,240
Vai ser de uma maneira que você não tem

21236
14:03:06,240 --> 14:03:08,080
Preocupe-se com esses pequenos detalhes

21237
14:03:08,080 --> 14:03:10,480
sobre os limites de matriz o caractere nulo

21238
14:03:10,480 --> 14:03:12,956
Você vai usá-lo para o que você

21239
14:03:12,956 --> 14:03:16,000
querer que está armazenando caractere ou texto

21240
14:03:16,000 --> 14:03:17,596
Os dados estão bem, então é para isso que vamos

21241
14:03:17,596 --> 14:03:19,276
Estamos fazendo nas próximas palestras que estamos

21242
14:03:19,276 --> 14:03:21,276
Vou aprender sobre a corda std

21243
14:03:21,276 --> 14:03:22,956
e como você pode usá-lo em seu c plus

21244
14:03:22,956 --> 14:03:25,040
além de aplicações e vai fazer

21245
14:03:25,040 --> 14:03:27,596
Sua vida muito mais fácil somos

21246
14:03:27,596 --> 14:03:29,436
Vou parar aqui nesta palestra:

21247
14:03:29,436 --> 14:03:30,880
A seguir, vamos ver como você pode

21248
14:03:30,880 --> 14:03:34,160
declarar inicialize e use força de std

21249
14:03:34,160 --> 14:03:36,320
em seu c plus mais aplicação vá em frente

21250
14:03:36,320 --> 14:03:39,276
e terminar aqui e encontrar-me lá e

21251
14:03:39,276 --> 14:03:40,640
Esta palestra vamos ver como você

21252
14:03:40,640 --> 14:03:43,436
pode declarar e usar a força de hdd em seu

21253
14:03:43,436 --> 14:03:45,520
c plus mais aplicações

21254
14:03:45,520 --> 14:03:47,436
std força é um tipo que vai

21255
14:03:47,436 --> 14:03:49,520
envolva em cima de arrays e nos dê um

21256
14:03:49,520 --> 14:03:51,360
interface muito agradável

21257
14:03:51,360 --> 14:03:53,116
que podemos usar para

21258
14:03:53,116 --> 14:03:55,840
armazenar dados de string sem ter que lidar

21259
14:03:55,840 --> 14:03:58,080
com os pequenos detalhes feios como

21260
14:03:58,080 --> 14:04:00,480
mantendo o controle da matriz ligada lembrando

21261
14:04:00,480 --> 14:04:02,480
para manter sob controle o caráter nulo e

21262
14:04:02,480 --> 14:04:04,720
coisas como essa para usar a força std você

21263
14:04:04,720 --> 14:04:07,040
terá de incluir a biblioteca de strings

21264
14:04:07,040 --> 14:04:09,040
E depois de fazer isso, você pode declarar

21265
14:04:09,040 --> 14:04:11,916
e use suas cordas assim aqui

21266
14:04:11,916 --> 14:04:14,480
temos uma série de exemplos apenas para obter

21267
14:04:14,480 --> 14:04:16,640
Você começou isso, você declara seu

21268
14:04:16,640 --> 14:04:18,320
forças como você declara qualquer

21269
14:04:18,320 --> 14:04:20,400
outra vez que você especificar o tipo no

21270
14:04:20,400 --> 14:04:22,400
esquerda o tipo vai ser std

21271
14:04:22,400 --> 14:04:24,720
força pela maneira que você terá que

21272
14:04:24,720 --> 14:04:26,956
Lembre-se de usar coluna std como

21273
14:04:26,956 --> 14:04:28,800
Isso e teremos uma chance de

21274
14:04:28,800 --> 14:04:32,080
Explique por que em alguns capítulos à frente, mas

21275
14:04:32,080 --> 14:04:34,320
por enquanto nós só vamos pensar em std

21276
14:04:34,320 --> 14:04:37,116
força como tipo, por isso declaramos a

21277
14:04:37,116 --> 14:04:39,680
Tipo de string nós chamamos de nome completo e nós

21278
14:04:39,680 --> 14:04:41,840
pode deixá-lo como este não inicializado e

21279
14:04:41,840 --> 14:04:43,916
Vai ser um fio vazio que pudermos

21280
14:04:43,916 --> 14:04:46,320
também colocar em nossa string e inicializar

21281
14:04:46,320 --> 14:04:48,720
que com uma string literal e é

21282
14:04:48,720 --> 14:04:51,200
Vou trabalhar outra maneira de fazer isso

21283
14:04:51,200 --> 14:04:53,360
está inicializando uma string com outra

21284
14:04:53,360 --> 14:04:55,360
string que estamos fazendo aqui em baixo você

21285
14:04:55,360 --> 14:04:57,200
também pode configurar outra string e

21286
14:04:57,200 --> 14:04:59,680
inicializá-lo com parte de outro

21287
14:04:59,680 --> 14:05:02,000
string literal assim por exemplo mensagem

21288
14:05:02,000 --> 14:05:04,160
Aqui vai ser olá e é só

21289
14:05:04,160 --> 14:05:06,480
Vou pegar cinco personagens disso

21290
14:05:06,480 --> 14:05:08,000
string literal isso é algo que você

21291
14:05:08,000 --> 14:05:09,436
Talvez queira fazer

21292
14:05:09,436 --> 14:05:10,956
Se faz sentido para o que

21293
14:05:10,956 --> 14:05:12,956
Aplicação que você está fazendo aqui nós podemos

21294
14:05:12,956 --> 14:05:15,436
inicialize também a nossa força com

21295
14:05:15,436 --> 14:05:18,160
múltiplas cópias de um caractere e

21296
14:05:18,160 --> 14:05:20,640
Esta é a sintaxe para fazê-lo você diz

21297
14:05:20,640 --> 14:05:22,240
o nome da sua variável que você diz

21298
14:05:22,240 --> 14:05:23,840
No entanto, muitas vezes você quer o

21299
14:05:23,840 --> 14:05:25,916
Caráter repetido e você diz qual

21300
14:05:25,916 --> 14:05:28,560
Personagem é assim que podemos

21301
14:05:28,560 --> 14:05:31,596
inicialize também uma string com parte de

21302
14:05:31,596 --> 14:05:34,160
Outra string existente, por exemplo

21303
14:05:34,160 --> 14:05:36,720
Aqui nós temos dito olá e é

21304
14:05:36,720 --> 14:05:39,200
inicializado com parte do que temos em

21305
14:05:39,200 --> 14:05:41,520
cumprimentar aqui, então vamos começar

21306
14:05:41,520 --> 14:05:44,000
índice 6 que vai ser

21307
14:05:44,000 --> 14:05:48,640
0 1 2 3 4 5 6 no w aqui e nós estamos

21308
14:05:48,640 --> 14:05:51,200
Vai pegar cinco personagens, então um dois

21309
14:05:51,200 --> 14:05:53,116
Três quatro cinco e isso é o que somos

21310
14:05:53,116 --> 14:05:54,956
Vou usar para inicializar este ditado

21311
14:05:54,956 --> 14:05:56,956
Olá aqui e se nós imprimirmos, nós somos

21312
14:05:56,956 --> 14:05:59,436
Vou ver que isso vai ser

21313
14:05:59,436 --> 14:06:01,520
exatamente o caso, então espero que você possa

21314
14:06:01,520 --> 14:06:03,436
Veja que é mais fácil você não precisa

21315
14:06:03,436 --> 14:06:05,040
Use ponteiros que você não precisa usar

21316
14:06:05,040 --> 14:06:08,000
arrays e a melhor parte é força std

21317
14:06:08,000 --> 14:06:10,560
pode crescer automaticamente se você acontecer com

21318
14:06:10,560 --> 14:06:12,880
Armazenar em mais personagens do que você

21319
14:06:12,880 --> 14:06:15,276
inicializou-o com em primeiro lugar

21320
14:06:15,276 --> 14:06:16,956
E isso é muito legal, então agora estamos

21321
14:06:16,956 --> 14:06:19,040
indo para a cabeça para o código de estúdio visual

21322
14:06:19,040 --> 14:06:20,956
e jogar conosco para que você possa ver por

21323
14:06:20,956 --> 14:06:23,756
você está bem aqui estamos em nosso trabalho

21324
14:06:23,756 --> 14:06:26,320
pasta que o projeto atual está declarando

21325
14:06:26,320 --> 14:06:28,560
e usando a força de std que é o que nós

21326
14:06:28,560 --> 14:06:30,400
Estamos fazendo aqui nós vamos pegar o nosso

21327
14:06:30,400 --> 14:06:32,320
arquivos de modelo muito rápido e nós somos

21328
14:06:32,320 --> 14:06:34,240
indo para ir e armazenar nos arquivos e

21329
14:06:34,240 --> 14:06:36,480
nós vamos abrir a pasta e nós estamos

21330
14:06:36,480 --> 14:06:38,880
Incluindo a biblioteca de força

21331
14:06:38,880 --> 14:06:41,596
Vamos fazer o que está bem, é assim que fazemos

21332
14:06:41,596 --> 14:06:44,400
E agora que o incluímos em nosso

21333
14:06:44,400 --> 14:06:47,200
projeto que podemos começar a declarar e usar

21334
14:06:47,200 --> 14:06:48,720
std string

21335
14:06:48,720 --> 14:06:51,276
tipos em nosso programa c plus plus que somos

21336
14:06:51,276 --> 14:06:53,040
indo para baixo e colocar no código para

21337
14:06:53,040 --> 14:06:55,116
jogar com isso um pouco para que você possa

21338
14:06:55,116 --> 14:06:57,520
Declarar uma string vazia como esta e

21339
14:06:57,520 --> 14:06:59,680
Não vai ter nada dentro

21340
14:06:59,680 --> 14:07:02,000
você pode declarar uma string e colocar em um

21341
14:07:02,000 --> 14:07:04,800
string literal como estamos fazendo aqui

21342
14:07:04,800 --> 14:07:07,596
e string std sabe como lidar com isso

21343
14:07:07,596 --> 14:07:09,520
então ele vai armazená-lo dentro usando um

21344
14:07:09,520 --> 14:07:12,080
matriz de caracteres, mas não precisamos

21345
14:07:12,080 --> 14:07:14,080
realmente se preocupa com essa matriz de caracteres

21346
14:07:14,080 --> 14:07:16,640
Vai funcionar, vamos usar

21347
14:07:16,640 --> 14:07:20,800
std string aqui nós podemos configurar uma string

21348
14:07:20,800 --> 14:07:23,436
usando outra string em nosso inicializador

21349
14:07:23,436 --> 14:07:26,160
assim também podemos usar

21350
14:07:26,160 --> 14:07:28,080
parte de um literal para inicializar o

21351
14:07:28,080 --> 14:07:29,756
string assim, por exemplo

21352
14:07:29,756 --> 14:07:31,520
Esta string literal aqui nós vamos

21353
14:07:31,520 --> 14:07:33,520
Pegue parte disso e nós vamos pegar

21354
14:07:33,520 --> 14:07:35,520
Cinco personagens e usá-los para

21355
14:07:35,520 --> 14:07:38,480
inicialize nossa mensagem std string aqui

21356
14:07:38,480 --> 14:07:40,800
e isso é muito legal também podemos usar

21357
14:07:40,800 --> 14:07:42,560
vários caracteres para inicializar a

21358
14:07:42,560 --> 14:07:44,560
string assim dizemos como muitos

21359
14:07:44,560 --> 14:07:46,480
Cópias que queremos deste personagem neste

21360
14:07:46,480 --> 14:07:48,160
string aqui e vai ser

21361
14:07:48,160 --> 14:07:50,400
Exatamente o que queremos, então vai ser

21362
14:07:50,400 --> 14:07:51,680
4 e's

21363
14:07:51,680 --> 14:07:54,240
Nesta estranha cadeia de mensagens

21364
14:07:54,240 --> 14:07:56,320
e nós podemos inicializar a string com

21365
14:07:56,320 --> 14:07:58,480
parte de outra string e isso é

21366
14:07:58,480 --> 14:08:01,040
muito legal e pode vir a mão em

21367
14:08:01,040 --> 14:08:03,520
Muitas aplicações, por exemplo, aqui

21368
14:08:03,520 --> 14:08:06,320
Dizer olá vai conter

21369
14:08:06,320 --> 14:08:08,880
Mundo aqui e estamos dizendo que isso

21370
14:08:08,880 --> 14:08:10,800
É o que queremos dizendo que queremos

21371
14:08:10,800 --> 14:08:13,680
começar no índice seis nesta string aqui

21372
14:08:13,680 --> 14:08:17,200
Então, se formos zero um dois três, quatro cinco

21373
14:08:17,200 --> 14:08:20,400
Seis este vai ser o nosso personagem em

21374
14:08:20,400 --> 14:08:22,720
índice seis e deste índice estamos

21375
14:08:22,720 --> 14:08:24,320
Vou pegar cinco personagens, então estamos

21376
14:08:24,320 --> 14:08:27,116
vai contar um dois três quatro cinco

21377
14:08:27,116 --> 14:08:29,360
E isso vai ser o que está armazenado em

21378
14:08:29,360 --> 14:08:31,520
Esta string aqui e se você não fizer

21379
14:08:31,520 --> 14:08:33,360
Acredite que podemos imprimir todas essas coisas

21380
14:08:33,360 --> 14:08:35,040
fora e eles vão ser exatamente

21381
14:08:35,040 --> 14:08:37,360
O que esperamos e com isso você pode até

21382
14:08:37,360 --> 14:08:39,596
ver que podemos imprimir std força

21383
14:08:39,596 --> 14:08:41,840
usando sddc para fora

21384
14:08:41,840 --> 14:08:44,080
Muito convenientemente como este e este é

21385
14:08:44,080 --> 14:08:46,240
muito legal bem para que possamos tentar e soldar

21386
14:08:46,240 --> 14:08:49,200
Isso com gcc a construção vai ir

21387
14:08:49,200 --> 14:08:50,560
Então nós vamos trazer uma

21388
14:08:50,560 --> 14:08:52,720
terminal para que possamos executar isso e

21389
14:08:52,720 --> 14:08:55,840
nós vamos limpar e vamos ver o que

21390
14:08:55,840 --> 14:08:57,276
Vemos quando nós

21391
14:08:57,276 --> 14:09:00,080
correr galo aqui, então vamos imprimir

21392
14:09:00,080 --> 14:09:02,560
O nome completo do nome completo está vazio

21393
14:09:02,560 --> 14:09:04,400
Tudo bem para que não vamos ver nada

21394
14:09:04,400 --> 14:09:06,240
Porque está vazio, vamos ver

21395
14:09:06,240 --> 14:09:08,800
Planeta planeta é essa coisa em que temos

21396
14:09:08,800 --> 14:09:11,680
aqui planeta onde o céu é azul

21397
14:09:11,680 --> 14:09:14,480
Isto é o que esperamos que possamos dizer

21398
14:09:14,480 --> 14:09:17,200
preferiu o planeta e colocar no texto para

21399
14:09:17,200 --> 14:09:19,200
O planeta aqui, então vamos conseguir

21400
14:09:19,200 --> 14:09:20,800
A mesma coisa aqui

21401
14:09:20,800 --> 14:09:23,200
e se tivermos uma mensagem e dizer olá

21402
14:09:23,200 --> 14:09:24,956
lá e agarrar o

21403
14:09:24,956 --> 14:09:27,436
primeiros caracteres nesta string literal

21404
14:09:27,436 --> 14:09:29,276
A mensagem vai dizer olá, que é

21405
14:09:29,276 --> 14:09:31,680
O que estamos dizendo aqui vamos descer

21406
14:09:31,680 --> 14:09:33,200
e veja para onde a mensagem está indo

21407
14:09:33,200 --> 14:09:35,520
ser para a facilidade, que é o que temos

21408
14:09:35,520 --> 14:09:39,040
Aqui e podemos inicializar dizendo olá

21409
14:09:39,040 --> 14:09:41,520
parte do que temos na saudação

21410
14:09:41,520 --> 14:09:44,560
e temos como alvo esta palavra string

21411
14:09:44,560 --> 14:09:46,720
Aqui e é o que vemos aqui e isso

21412
14:09:46,720 --> 14:09:49,200
é muito legal a coisa boa sobre hdd

21413
14:09:49,200 --> 14:09:51,520
string, no entanto, é que você pode

21414
14:09:51,520 --> 14:09:53,596
Armazenar em mais personagens do que nós

21415
14:09:53,596 --> 14:09:57,200
inicialize esse cara com isso, por exemplo

21416
14:09:57,200 --> 14:09:59,520
Aqui temos esta mensagem aqui, mas nós

21417
14:09:59,520 --> 14:10:00,640
Pode dizer que

21418
14:10:00,640 --> 14:10:02,800
Planeta vamos para cá e diga isso

21419
14:10:02,800 --> 14:10:05,116
nós vamos mudar std string em execução

21420
14:10:05,116 --> 14:10:07,360
para que possamos dizer planeta e

21421
14:10:07,360 --> 14:10:08,880
nós vamos atribuir algo a isso

21422
14:10:08,880 --> 14:10:10,720
nós vamos colocar o que estava dentro

21423
14:10:10,720 --> 14:10:12,800
lá primeiro e vamos colar

21424
14:10:12,800 --> 14:10:14,880
que em várias vezes vamos fazer três

21425
14:10:14,880 --> 14:10:16,956
Tempos eu acho que isso vai ser o suficiente

21426
14:10:16,956 --> 14:10:19,596
ou podemos até trazer isso de volta para que

21427
14:10:19,596 --> 14:10:21,840
Nós vemos a coisa toda aqui não

21428
14:10:21,840 --> 14:10:24,160
Realmente importa tudo o que queremos é para isso

21429
14:10:24,160 --> 14:10:27,276
coisa para ser maior do que era inicialmente

21430
14:10:27,276 --> 14:10:28,560
Declarado

21431
14:10:28,560 --> 14:10:31,040
em um planeta aqui, então nós vamos

21432
14:10:31,040 --> 14:10:33,040
remover essas citações porque elas são

21433
14:10:33,040 --> 14:10:35,520
fazendo as coisas feias para nós e agora é

21434
14:10:35,520 --> 14:10:37,436
Vai ser uma força válida, vamos esperar

21435
14:10:37,436 --> 14:10:40,880
para código de estúdio visual para perceber que

21436
14:10:40,880 --> 14:10:42,800
E vai remover estes squiggly

21437
14:10:42,800 --> 14:10:45,200
linhas agora somos uma boa string std é

21438
14:10:45,200 --> 14:10:47,756
automaticamente indo cuidar do

21439
14:10:47,756 --> 14:10:48,720
lógica

21440
14:10:48,720 --> 14:10:51,360
para fazer esta corda crescer, nós não temos

21441
14:10:51,360 --> 14:10:53,436
para se preocupar com isso e se imprimirmos

21442
14:10:53,436 --> 14:10:55,116
Planeta agora vamos ver o mesmo

21443
14:10:55,116 --> 14:10:57,596
detalhes e cuidado de OK este é

21444
14:10:57,596 --> 14:11:00,320
muito legal e torna super fácil

21445
14:11:00,320 --> 14:11:01,756
para trabalhar com

21446
14:11:01,756 --> 14:11:04,560
texto e string dados como você vê aqui

21447
14:11:04,560 --> 14:11:07,200
então vamos construir novamente para que nossas mudanças

21448
14:11:07,200 --> 14:11:08,320
São

21449
14:11:08,320 --> 14:11:10,640
refletido em nossa produção, vamos

21450
14:11:10,640 --> 14:11:13,200
claro e correr o galo e nós vamos

21451
14:11:13,200 --> 14:11:15,840
Veja que o planeta agora é realmente grande bem

21452
14:11:15,840 --> 14:11:17,116
nós podemos mudar

21453
14:11:17,116 --> 14:11:19,200
Esta coisa do tamanho desta coisa em

21454
14:11:19,200 --> 14:11:21,360
O tempo de execução e isso é algo que nós

21455
14:11:21,360 --> 14:11:23,520
Não poderia fazer com arrays, então, por exemplo

21456
14:11:23,520 --> 14:11:25,840
Se descermos aqui e usarmos uma matriz de linhas

21457
14:11:25,840 --> 14:11:28,560
Para fazer algo como este código é

21458
14:11:28,560 --> 14:11:30,640
indo para correr, mas tentar pensar sobre o que

21459
14:11:30,640 --> 14:11:32,480
Está realmente acontecendo aqui temos um

21460
14:11:32,480 --> 14:11:35,360
array que contém este texto aqui

21461
14:11:35,360 --> 14:11:38,160
e é apontado por este cartão de custo

21462
14:11:38,160 --> 14:11:40,560
pontodor que temos se tentarmos fazer um

21463
14:11:40,560 --> 14:11:42,800
tarefa como esta, isso é realmente

21464
14:11:42,800 --> 14:11:46,080
Vai ser para fazer isso apontar para outro

21465
14:11:46,080 --> 14:11:49,040
matriz de caracteres na memória e esta peça

21466
14:11:49,040 --> 14:11:50,880
da memória aqui vai ser basicamente

21467
14:11:50,880 --> 14:11:54,560
desperdiçados porque achamos que temos o nosso

21468
14:11:54,560 --> 14:11:57,360
A força do planeta aqui

21469
14:11:57,360 --> 14:11:59,916
este não é o caso com força std

21470
14:11:59,916 --> 14:12:01,840
porque std força quando fazemos

21471
14:12:01,840 --> 14:12:04,240
Algo como esta memória inicial

21472
14:12:04,240 --> 14:12:06,560
que foi atribuído à loja

21473
14:12:06,560 --> 14:12:08,720
O planeta aqui vai ser devolvido

21474
14:12:08,720 --> 14:12:11,596
O sistema de ópera e uma nova memória é

21475
14:12:11,596 --> 14:12:13,756
será alocado para conter isso

21476
14:12:13,756 --> 14:12:16,320
coisas novas, então o desperdício que estamos fazendo aqui

21477
14:12:16,320 --> 14:12:19,360
apenas deixando isso na memória e não

21478
14:12:19,360 --> 14:12:21,756
usá-lo não está sendo feito aqui, então se nós

21479
14:12:21,756 --> 14:12:23,360
Tente imprimir, vamos conseguir o mesmo

21480
14:12:23,360 --> 14:12:26,240
mas dentro e como nossa memória é

21481
14:12:26,240 --> 14:12:29,840
managed hdd string é melhor que a

21482
14:12:29,840 --> 14:12:32,160
memória que foi usada para inicializar isso

21483
14:12:32,160 --> 14:12:34,880
O cara não é desperdiçado

21484
14:12:34,880 --> 14:12:37,040
Aqui com a matriz o que realmente estamos fazendo

21485
14:12:37,040 --> 14:12:39,200
é apenas fazer este ponto de ponteiro do planeta

21486
14:12:39,200 --> 14:12:42,080
para outra corda e deixar isso para ser

21487
14:12:42,080 --> 14:12:43,756
desperdiçados na memória isso é o que somos

21488
14:12:43,756 --> 14:12:46,080
fazer aqui e podemos evitar isso com

21489
14:12:46,080 --> 14:12:47,756
força do std

21490
14:12:47,756 --> 14:12:49,276
Nesta palestra vamos aprender

21491
14:12:49,276 --> 14:12:52,400
sobre a regra de uma definição e esta

21492
14:12:52,400 --> 14:12:55,520
É uma regra que diz que as definições não podem

21493
14:12:55,520 --> 14:12:58,800
aparecer mais de uma vez em todo o seu c

21494
14:12:58,800 --> 14:13:01,840
mais programa mais ou em alguns casos

21495
14:13:01,840 --> 14:13:04,240
A definição pode aparecer mais de uma vez

21496
14:13:04,240 --> 14:13:06,560
uma unidade de tradução que vamos olhar

21497
14:13:06,560 --> 14:13:08,720
na regra de uma definição na

21498
14:13:08,720 --> 14:13:10,956
contexto das variáveis independentes

21499
14:13:10,956 --> 14:13:13,916
funções classes funções membros funções e

21500
14:13:13,916 --> 14:13:17,116
membros estáticos em nossas aulas na maioria dos

21501
14:13:17,116 --> 14:13:19,596
Casos que uma definição não pode realmente aparecer

21502
14:13:19,596 --> 14:13:22,240
mais de uma vez em todo o seu c-plus

21503
14:13:22,240 --> 14:13:24,956
além do programa, mas temos exceções para

21504
14:13:24,956 --> 14:13:27,680
Esta regra e a exceção é para

21505
14:13:27,680 --> 14:13:30,320
classes que uma definição para uma classe pode

21506
14:13:30,320 --> 14:13:34,000
aparecer em várias unidades de tradução e

21507
14:13:34,000 --> 14:13:35,360
A razão é

21508
14:13:35,360 --> 14:13:37,360
Precisamos criar objetos desses

21509
14:13:37,360 --> 14:13:39,916
classes para que cada unidade de tradução realmente

21510
14:13:39,916 --> 14:13:42,240
É preciso ver a definição para o

21511
14:13:42,240 --> 14:13:45,116
classe e vamos tentar fazer

21512
14:13:45,116 --> 14:13:47,840
Este super claro com exemplos uma vez que nós

21513
14:13:47,840 --> 14:13:50,400
hit código de estúdio visual bem, então é

21514
14:13:50,400 --> 14:13:52,640
Tempo para ir ao código do estúdio visual

21515
14:13:52,640 --> 14:13:55,276
e lançar mais alguma luz sobre o

21516
14:13:55,276 --> 14:13:57,840
Regra de definição aqui estamos em nosso

21517
14:13:57,840 --> 14:13:59,840
pasta de trabalho o projeto atual é

21518
14:13:59,840 --> 14:14:01,916
uma regra de definição que vamos pegar

21519
14:14:01,916 --> 14:14:04,880
nossos arquivos de modelo como sempre fazemos

21520
14:14:04,880 --> 14:14:06,640
nós vamos colocá-los no lugar e

21521
14:14:06,640 --> 14:14:08,480
nós vamos abrir este pequeno rapaz dentro

21522
14:14:08,480 --> 14:14:10,400
Código de estúdio visual vamos fazer isso eu

21523
14:14:10,400 --> 14:14:12,000
Vou arrastar e cair e nós vamos

21524
14:14:12,000 --> 14:14:13,756
para ter nosso arquivo principal cpp aqui estamos

21525
14:14:13,756 --> 14:14:15,596
indo para limpá-lo, é o que nós

21526
14:14:15,596 --> 14:14:17,520
Sempre faça

21527
14:14:17,520 --> 14:14:20,240
E agora queremos explorar o

21528
14:14:20,240 --> 14:14:22,080
Regra de definição no contexto de

21529
14:14:22,080 --> 14:14:24,640
variáveis por isso temos uma independente

21530
14:14:24,640 --> 14:14:27,040
variável aqui

21531
14:14:27,040 --> 14:14:28,800
e isso vai ser a mesma variável

21532
14:14:28,800 --> 14:14:30,720
Tivemos na última palestra que vamos

21533
14:14:30,720 --> 14:14:33,116
para inicializar isso e isso é realmente

21534
14:14:33,116 --> 14:14:36,080
Bom podemos usá-lo podemos ir em main e

21535
14:14:36,080 --> 14:14:38,000
usá-lo como quisermos, podemos imprimir o

21536
14:14:38,000 --> 14:14:39,116
caminho a seguir

21537
14:14:39,116 --> 14:14:41,360
e se não executarmos este programa é

21538
14:14:41,360 --> 14:14:43,916
indo para o trabalho, mas a única definição

21539
14:14:43,916 --> 14:14:46,956
A regra diz que não podemos ter mais de um

21540
14:14:46,956 --> 14:14:50,160
Definição para qualquer coisa e para isso

21541
14:14:50,160 --> 14:14:52,080
variável aqui temos visto que este é

21542
14:14:52,080 --> 14:14:54,320
Ambas as declarações

21543
14:14:54,320 --> 14:14:57,040
e uma definição para que não possamos ter mais

21544
14:14:57,040 --> 14:14:59,596
uma definição para o nome do peso

21545
14:14:59,596 --> 14:15:02,160
Aqui, por exemplo, se tentarmos agarrá-lo

21546
14:15:02,160 --> 14:15:04,480
e copiar e colar aqui para que nós sejamos

21547
14:15:04,480 --> 14:15:06,240
Vou tentar construir este programa

21548
14:15:06,240 --> 14:15:08,560
nós vamos usar gcc

21549
14:15:08,560 --> 14:15:09,756
nós vamos ver que nós temos um

21550
14:15:09,756 --> 14:15:12,116
O problema e o problema vão dizer

21551
14:15:12,116 --> 14:15:13,756
redefinição

21552
14:15:13,756 --> 14:15:16,320
de peso duplo e não vai

21553
14:15:16,320 --> 14:15:18,400
ajudar, mesmo se você tomar isso e colocar isso

21554
14:15:18,400 --> 14:15:20,640
em outro arquivo, então vamos criar outro

21555
14:15:20,640 --> 14:15:22,320
arquivo para realmente mostrar a você que estamos indo

21556
14:15:22,320 --> 14:15:26,160
para chamá-lo algum outro arquivo que cpp e

21557
14:15:26,160 --> 14:15:29,200
Vamos pegar nossa redefinição

21558
14:15:29,200 --> 14:15:31,436
e mover isso lá

21559
14:15:31,436 --> 14:15:33,756
E você vai ver isso se tentarmos

21560
14:15:33,756 --> 14:15:35,756
e construir este programa

21561
14:15:35,756 --> 14:15:37,040
nós vamos ter o mesmo problema

21562
14:15:37,040 --> 14:15:39,200
nós vamos ter redefinição, então

21563
14:15:39,200 --> 14:15:40,880
nós vamos ver

21564
14:15:40,880 --> 14:15:42,640
Qual é o problema aqui o compilador

21565
14:15:42,640 --> 14:15:44,640
O erro é um pouco diferente, mas

21566
14:15:44,640 --> 14:15:47,596
vai dizer múltiplas definições de

21567
14:15:47,596 --> 14:15:48,400
o peso

21568
14:15:48,400 --> 14:15:50,640
e vai dizer que um está definido em

21569
14:15:50,640 --> 14:15:53,916
o arquivo cpp principal, então este é um linker

21570
14:15:53,916 --> 14:15:56,400
O erro foi capturado pelo laker

21571
14:15:56,400 --> 14:15:58,880
porque a redefinição está aparecendo

21572
14:15:58,880 --> 14:16:01,520
em vários arquivos para que o linker fosse

21573
14:16:01,520 --> 14:16:03,756
vinculando este programa e ele precisava

21574
14:16:03,756 --> 14:16:06,000
ver uma definição para o peso e tinha

21575
14:16:06,000 --> 14:16:09,040
visto uma definição no arquivo principal do cpp

21576
14:16:09,040 --> 14:16:10,956
E viu outra definição e

21577
14:16:10,956 --> 14:16:13,276
algum outro arquivo e isso é um problema

21578
14:16:13,276 --> 14:16:15,040
o linker não sabe qual deles

21579
14:16:15,040 --> 14:16:17,276
escolha para que ele vai lançar um erro

21580
14:16:17,276 --> 14:16:19,200
e você não pode realmente ter múltiplos

21581
14:16:19,200 --> 14:16:21,596
Definições para uma variável em seu c

21582
14:16:21,596 --> 14:16:23,840
mais mais programa e este é o único

21583
14:16:23,840 --> 14:16:26,560
A regra de definição e o contexto de

21584
14:16:26,560 --> 14:16:28,560
Variáveis independentes como o peso

21585
14:16:28,560 --> 14:16:31,436
Aqui, mas isso é o mesmo no contexto

21586
14:16:31,436 --> 14:16:34,320
das funções se descermos e colocarmos

21587
14:16:34,320 --> 14:16:36,640
nossa função de adicionar aqui nós vamos dizer

21588
14:16:36,640 --> 14:16:37,596
o dobro

21589
14:16:37,596 --> 14:16:38,400
a

21590
14:16:38,400 --> 14:16:40,956
e duplo b aqui e nós vamos colocar

21591
14:16:40,956 --> 14:16:43,756
A definição abaixo do arquivo cpp principal

21592
14:16:43,756 --> 14:16:45,276
Vamos pegar isso

21593
14:16:45,276 --> 14:16:48,160
Podemos copiar isso e colocar isso no

21594
14:16:48,160 --> 14:16:49,916
código aqui eu vou remover isso

21595
14:16:49,916 --> 14:16:51,436
cozinhos, não queremos que seja

21596
14:16:51,436 --> 14:16:53,436
vamos colocar em nosso corpo e nós vamos

21597
14:16:53,436 --> 14:16:56,160
para voltar um mais b aqui bem, então isso é

21598
14:16:56,160 --> 14:16:58,720
nossa função é trabalhar que podemos tomar

21599
14:16:58,720 --> 14:17:00,956
fora o que tivemos aqui porque tem

21600
14:17:00,956 --> 14:17:03,276
Serviu ao seu propósito, você pode dizer o dobro

21601
14:17:03,276 --> 14:17:05,756
resultado e vamos somar 10 e

21602
14:17:05,756 --> 14:17:08,240
20 como fizemos na última palestra

21603
14:17:08,240 --> 14:17:10,956
Não há problema e podemos tentar imprimir

21604
14:17:10,956 --> 14:17:12,720
Os nossos resultados aqui

21605
14:17:12,720 --> 14:17:14,560
Se construirmos e executarmos este programa é

21606
14:17:14,560 --> 14:17:16,640
Vai trabalhar sem problemas porque

21607
14:17:16,640 --> 14:17:19,756
Temos apenas uma definição para adicionar

21608
14:17:19,756 --> 14:17:20,720
A função

21609
14:17:20,720 --> 14:17:23,520
Qual é o problema aqui que temos peso

21610
14:17:23,520 --> 14:17:25,756
Definidos várias vezes vamos

21611
14:17:25,756 --> 14:17:27,520
Comentar uma definição para

21612
14:17:27,520 --> 14:17:28,956
o peso

21613
14:17:28,956 --> 14:17:31,360
E nós vamos construir de novo

21614
14:17:31,360 --> 14:17:33,116
Agora a construção é boa e nós podemos correr

21615
14:17:33,116 --> 14:17:35,360
Este programa nós podemos

21616
14:17:35,360 --> 14:17:37,520
Matar o nosso terminal aqui e trazer

21617
14:17:37,520 --> 14:17:39,520
outro e correr galo você está indo

21618
14:17:39,520 --> 14:17:42,400
ver que o resultado é 30 e a

21619
14:17:42,400 --> 14:17:45,200
O programa está funcionando muito bem, mas se nós

21620
14:17:45,200 --> 14:17:47,360
configurar outra definição para adicionar mesmo

21621
14:17:47,360 --> 14:17:50,800
Se colocarmos isso no mesmo arquivo

21622
14:17:50,800 --> 14:17:52,800
Vamos ter um problema porque nós

21623
14:17:52,800 --> 14:17:55,596
estão violando a regra de uma definição

21624
14:17:55,596 --> 14:17:57,116
Vamos correr de novo

21625
14:17:57,116 --> 14:17:58,480
Você vai ver o problema aqui

21626
14:17:58,480 --> 14:18:00,320
Vamos ver a redefinição

21627
14:18:00,320 --> 14:18:02,720
Redefinição da função Adicionar é

21628
14:18:02,720 --> 14:18:04,560
Não é permitido que o seu programa não vá

21629
14:18:04,560 --> 14:18:07,200
compilar vemos o erro do compilador aqui

21630
14:18:07,200 --> 14:18:08,956
Mesmo se você colocar a definição em

21631
14:18:08,956 --> 14:18:11,200
Outro arquivo que não vai ajudar

21632
14:18:11,200 --> 14:18:13,360
nós vamos pegar isso e colocar isso dentro

21633
14:18:13,360 --> 14:18:15,756
Nosso outro arquivo

21634
14:18:15,756 --> 14:18:19,436
e tentar compilar o programa

21635
14:18:20,400 --> 14:18:22,320
Vamos ter um erro de linker e ele

21636
14:18:22,320 --> 14:18:24,320
Vamos dizer uma definição múltipla de

21637
14:18:24,320 --> 14:18:27,116
A função add e isso não é permitido

21638
14:18:27,116 --> 14:18:29,436
Este é um erro de linker neste tempo se

21639
14:18:29,436 --> 14:18:31,680
comentamos uma definição, vamos fazer

21640
14:18:31,680 --> 14:18:33,596
que vamos comentar um

21641
14:18:33,596 --> 14:18:35,680
na função principal, isso vai

21642
14:18:35,680 --> 14:18:38,800
O trabalho e queremos violar aquele

21643
14:18:38,800 --> 14:18:41,360
Regra de definição, então isso é bom

21644
14:18:41,360 --> 14:18:43,436
O mundo é bom, podemos limpar

21645
14:18:43,436 --> 14:18:45,360
e correr galo nós vamos ver o nosso

21646
14:18:45,360 --> 14:18:48,000
Resulta aqui, então a regra de uma definição

21647
14:18:48,000 --> 14:18:50,560
Diz que você não pode ter várias definições

21648
14:18:50,560 --> 14:18:51,360
para a

21649
14:18:51,360 --> 14:18:54,240
Variáveis ou mesmo funções autônomas

21650
14:18:54,240 --> 14:18:55,840
e reserve que se você fizer isso você é

21651
14:18:55,840 --> 14:18:58,080
Vou obter um erro do compilador, vamos olhar

21652
14:18:58,080 --> 14:19:00,400
Neste contexto das aulas, somos

21653
14:19:00,400 --> 14:19:01,840
Vou fazer uma aula, vamos dizer

21654
14:19:01,840 --> 14:19:04,080
Sedir e nós vamos chamar isso

21655
14:19:04,080 --> 14:19:06,640
Ponto como sempre fazemos

21656
14:19:06,640 --> 14:19:08,880
principalmente nós vamos chamar este ponto

21657
14:19:08,880 --> 14:19:10,480
e nós vamos colocar alguns membros

21658
14:19:10,480 --> 14:19:13,200
As variáveis um vai ser mx o

21659
14:19:13,200 --> 14:19:15,436
Outro vai ser m y

21660
14:19:15,436 --> 14:19:17,520
e esta será a nossa definição

21661
14:19:17,520 --> 14:19:18,320
Aqui

21662
14:19:18,320 --> 14:19:20,480
Mas o que você vai ver

21663
14:19:20,480 --> 14:19:23,116
é que é possível ter múltiplos

21664
14:19:23,116 --> 14:19:26,080
definições para classes, por exemplo, se

21665
14:19:26,080 --> 14:19:28,480
nós pegamos isso e

21666
14:19:28,480 --> 14:19:30,800
ter uma cópia disso em outro arquivo

21667
14:19:30,800 --> 14:19:32,320
nós vamos fazer isso, vamos

21668
14:19:32,320 --> 14:19:34,880
Declarar esta estrutura aqui

21669
14:19:34,880 --> 14:19:36,840
E nós vamos tentar construir isso

21670
14:19:36,840 --> 14:19:39,276
programa que você vai ver que é

21671
14:19:39,276 --> 14:19:41,200
trabalhando, temos várias definições de

21672
14:19:41,200 --> 14:19:44,080
Esses caras podemos ir em geral, por exemplo

21673
14:19:44,080 --> 14:19:46,080
e dizer ponto

21674
14:19:46,080 --> 14:19:47,200
p1

21675
14:19:47,200 --> 14:19:49,116
e nós podemos subir a solda e ver que o

21676
14:19:49,116 --> 14:19:51,360
O programa vai funcionar bem, então se você

21677
14:19:51,360 --> 14:19:54,320
Entro aqui, por exemplo, e tente imprimir

21678
14:19:54,320 --> 14:19:56,160
Rio de sdd cl

21679
14:19:56,160 --> 14:19:58,560
p1 e a impressão x que vamos fazer

21680
14:19:58,560 --> 14:20:01,116
que nós vamos dizer p1 mx nós somos

21681
14:20:01,116 --> 14:20:03,040
será capaz de usar isso porque

21682
14:20:03,040 --> 14:20:05,360
Esta é uma estrutura das variáveis membros

21683
14:20:05,360 --> 14:20:08,000
Somos públicos por padrão, podemos fazer isso

21684
14:20:08,000 --> 14:20:09,520
E nós podemos dizer

21685
14:20:09,520 --> 14:20:11,916
p1 y em

21686
14:20:11,916 --> 14:20:13,116
É

21687
14:20:13,116 --> 14:20:16,800
p1y meus vamos fazer isso e podemos dizer

21688
14:20:16,800 --> 14:20:20,400
stdndl qual é o problema aqui que precisamos

21689
14:20:20,400 --> 14:20:23,840
para colocar nosso operador de fluxo de saída

21690
14:20:23,840 --> 14:20:25,596
Eu acho que agora o compilador vai ser

21691
14:20:25,596 --> 14:20:26,560
Feliz

21692
14:20:26,560 --> 14:20:27,916
E, portanto, o mundo

21693
14:20:27,916 --> 14:20:30,400
nós vamos usar gcc

21694
14:20:30,400 --> 14:20:31,916
nós vamos ver isso se nós corrermos o

21695
14:20:31,916 --> 14:20:34,000
programa, vamos ver nossas coisas

21696
14:20:34,000 --> 14:20:36,160
aqui e temos alguns valores de lixo dentro

21697
14:20:36,160 --> 14:20:38,400
Porque essas coisas não são inicializadas

21698
14:20:38,400 --> 14:20:40,800
mas se inicializarmos a zero usando

21699
14:20:40,800 --> 14:20:43,116
A inicialização estáada aqui

21700
14:20:43,116 --> 14:20:45,276
nós vamos construir de novo

21701
14:20:45,276 --> 14:20:47,840
e devemos ver zero dentro, então vamos

21702
14:20:47,840 --> 14:20:51,360
clear e run galo agora temos 0 em x

21703
14:20:51,360 --> 14:20:53,680
e y para o nosso objeto aqui este é

21704
14:20:53,680 --> 14:20:55,596
trabalhando bem e nós temos múltiplos

21705
14:20:55,596 --> 14:20:58,640
definições para a nossa classe, mas o

21706
14:20:58,640 --> 14:21:01,200
Definições não podem aparecer em um único

21707
14:21:01,200 --> 14:21:03,916
unidade de tradução, por exemplo, se nós tomamos

21708
14:21:03,916 --> 14:21:06,000
Esta definição aqui

21709
14:21:06,000 --> 14:21:08,480
e trouxe isso de volta para o principal e colocou

21710
14:21:08,480 --> 14:21:10,160
que logo abaixo

21711
14:21:10,160 --> 14:21:13,200
nossa estrutura aqui se tentarmos soldar o

21712
14:21:13,200 --> 14:21:15,040
O compilador vai reclamar porque

21713
14:21:15,040 --> 14:21:17,756
Agora temos várias definições para o

21714
14:21:17,756 --> 14:21:20,880
A mesma classe na mesma unidade de tradução

21715
14:21:20,880 --> 14:21:22,320
para as aulas

21716
14:21:22,320 --> 14:21:24,800
Podemos ter várias definições, mas a

21717
14:21:24,800 --> 14:21:27,756
As definições têm que aparecer em diferentes

21718
14:21:27,756 --> 14:21:29,680
Unidades de tradução e isso é o que eu quero

21719
14:21:29,680 --> 14:21:31,436
você para ver aqui, então nós temos um

21720
14:21:31,436 --> 14:21:34,240
Redefinição de nossa estrutura de ponto e ela

21721
14:21:34,240 --> 14:21:36,320
Não é bom que vai violar o

21722
14:21:36,320 --> 14:21:38,640
Uma regra de definição ok agora que você

21723
14:21:38,640 --> 14:21:40,800
Já vimos isso, também queremos ver isso

21724
14:21:40,800 --> 14:21:43,040
No contexto de uma classe

21725
14:21:43,040 --> 14:21:45,116
que também tem algum membro estático

21726
14:21:45,116 --> 14:21:47,040
variáveis que vamos tirar isso

21727
14:21:47,040 --> 14:21:49,200
Porque já vimos isso e

21728
14:21:49,200 --> 14:21:51,840
vamos trazer nossa classe de pessoa

21729
14:21:51,840 --> 14:21:54,080
Como usamos na última palestra que somos

21730
14:21:54,080 --> 14:21:56,240
indo para adicionar um novo arquivo de cabeçalho é

21731
14:21:56,240 --> 14:21:59,040
Vai ser chamado de pessoa

21732
14:21:59,040 --> 14:22:00,320
Dot h

21733
14:22:00,320 --> 14:22:02,880
E nós vamos pular para dentro

21734
14:22:02,880 --> 14:22:06,240
O que fizemos nós é esta pasta, vamos

21735
14:22:06,240 --> 14:22:09,360
remover isso não queríamos uma pasta

21736
14:22:09,360 --> 14:22:11,436
Vamos apagar esta pasta que nós

21737
14:22:11,436 --> 14:22:13,360
Não o queira

21738
14:22:13,360 --> 14:22:15,520
e nós vamos apenas adicionar um arquivo

21739
14:22:15,520 --> 14:22:18,880
chamada pessoa.h

21740
14:22:18,880 --> 14:22:20,560
Isso é tudo arquivo aqui e nós vamos

21741
14:22:20,560 --> 14:22:22,640
colocar no conteúdo que o conteúdo está indo

21742
14:22:22,640 --> 14:22:24,480
para ser nossa classe pessoal, vamos fechar

21743
14:22:24,480 --> 14:22:26,720
para que você possa ver mais disso

21744
14:22:26,720 --> 14:22:29,596
classe aqui bem, então temos nossa pessoa

21745
14:22:29,596 --> 14:22:32,080
classe aqui temos o nosso cartão incluem nós

21746
14:22:32,080 --> 14:22:34,720
ter nossa definição de classe de pessoa que temos

21747
14:22:34,720 --> 14:22:36,480
um construtor e nós temos uma impressora

21748
14:22:36,480 --> 14:22:37,916
função do telefone temos nosso membro

21749
14:22:37,916 --> 14:22:40,080
variáveis e abaixo aqui você vê

21750
14:22:40,080 --> 14:22:42,320
que temos uma variável estática que é

21751
14:22:42,320 --> 14:22:44,480
conta de pessoa que precisamos colocar no

21752
14:22:44,480 --> 14:22:47,040
definição para esses caras, então vamos embora

21753
14:22:47,040 --> 14:22:49,520
para baixo e fazer isso nós vamos colocar

21754
14:22:49,520 --> 14:22:51,520
A definição para a pessoa

21755
14:22:51,520 --> 14:22:53,520
construtor, vamos no topo

21756
14:22:53,520 --> 14:22:56,560
aqui e incluir nosso arquivo de cabeçalho de pessoa

21757
14:22:56,560 --> 14:22:58,240
e nós vamos colocar no lugar nosso

21758
14:22:58,240 --> 14:23:00,160
construtor, podemos descer e fazer isso

21759
14:23:00,160 --> 14:23:03,040
Podemos dizer pessoa e dizer pessoa

21760
14:23:03,040 --> 14:23:04,956
que vai ser o nosso construtor nós somos

21761
14:23:04,956 --> 14:23:07,436
indo voltar para a classe e agarrar

21762
14:23:07,436 --> 14:23:09,596
Os parâmetros porque eu não quero

21763
14:23:09,596 --> 14:23:11,680
digite todos esses comprimentos

21764
14:23:11,680 --> 14:23:13,680
então vamos fazer isso, vamos colocá-los

21765
14:23:13,680 --> 14:23:14,800
Os de que a si a si a do que sobre a, a , a , a , aja, a , a, a, a

21766
14:23:14,800 --> 14:23:17,436
vamos colocar em nosso inicializador

21767
14:23:17,436 --> 14:23:19,840
list Eu acho que nós também devemos excluir um

21768
14:23:19,840 --> 14:23:22,160
Parenthesis aqui vamos descer

21769
14:23:22,160 --> 14:23:24,400
e colocar em nossa lista de inicializadores que estamos

21770
14:23:24,400 --> 14:23:26,240
Vou dizer nome completo para nós vamos

21771
14:23:26,240 --> 14:23:28,720
inicialize isso com o nome param

21772
14:23:28,720 --> 14:23:32,240
e nós também vamos colocar em nossa idade

21773
14:23:32,240 --> 14:23:34,000
e nós vamos inicializar isso com

21774
14:23:34,000 --> 14:23:36,080
borda param o parâmetro que temos de

21775
14:23:36,080 --> 14:23:39,040
A função e isso vai ser tudo

21776
14:23:39,040 --> 14:23:41,916
dentro do corpo vamos implementar

21777
14:23:41,916 --> 14:23:43,680
a variável estática que vamos dizer

21778
14:23:43,680 --> 14:23:46,160
incrementar a contagem de pessoas bem agora selecione

21779
14:23:46,160 --> 14:23:48,800
Aqui e isso vai ser bom

21780
14:23:48,800 --> 14:23:51,360
Também precisamos inicializar nossa estática

21781
14:23:51,360 --> 14:23:52,956
variáveis, então vamos dizer finais

21782
14:23:52,956 --> 14:23:56,160
conta de pessoa pessoa, vamos fazer pessoa

21783
14:23:56,160 --> 14:23:58,160
conta e vamos inicializar

21784
14:23:58,160 --> 14:24:00,240
Isso para talvez oito como nós fizemos no

21785
14:24:00,240 --> 14:24:03,436
última palestra e isso deve ser tudo o que

21786
14:24:03,436 --> 14:24:05,916
Precisamos aqui, então se construirmos e executarmos isso

21787
14:24:05,916 --> 14:24:08,480
Programa eu acho que vai correr

21788
14:24:08,480 --> 14:24:10,800
Vamos selecionar a função principal aqui

21789
14:24:10,800 --> 14:24:12,640
e que problema temos aqui vamos

21790
14:24:12,640 --> 14:24:14,400
construir e ver que vamos deixar o

21791
14:24:14,400 --> 14:24:16,800
O compilador descobre isso

21792
14:24:16,800 --> 14:24:18,240
nós vamos ver que o mundo é

21793
14:24:18,240 --> 14:24:20,640
bom e nós podemos criar objetos de pessoa

21794
14:24:20,640 --> 14:24:22,480
e realmente usá-los em nosso programa, então

21795
14:24:22,480 --> 14:24:24,640
Vamos descer aqui e apagar o que

21796
14:24:24,640 --> 14:24:27,276
Tivemos que vamos incluir a pessoa

21797
14:24:27,276 --> 14:24:28,800
e nós vamos descer aqui e

21798
14:24:28,800 --> 14:24:30,240
criar um objeto de pessoa para quem vamos

21799
14:24:30,240 --> 14:24:32,160
Diga pessoa

21800
14:24:32,160 --> 14:24:34,560
A p1 e vamos especificar o nome

21801
14:24:34,560 --> 14:24:37,040
para ser jon neve por que não

21802
14:24:37,040 --> 14:24:39,360
e nós vamos dizer que eles são

21803
14:24:39,360 --> 14:24:41,116
35 Por que não

21804
14:24:41,116 --> 14:24:42,956
e podemos pregar informações sobre isso

21805
14:24:42,956 --> 14:24:45,756
pessoa podemos dizer princípio de pessoa e

21806
14:24:45,756 --> 14:24:48,000
Se tentarmos construir este programa, vamos

21807
14:24:48,000 --> 14:24:50,000
Use o gcc para fazer isso

21808
14:24:50,000 --> 14:24:52,160
O mundo vai ser bom como você vê

21809
14:24:52,160 --> 14:24:54,480
Aqui em baixo podemos limpar

21810
14:24:54,480 --> 14:24:56,320
e correr galo nós vamos ver jon

21811
14:24:56,320 --> 14:24:58,080
Neve que ele é

21812
14:24:58,080 --> 14:25:00,560
35 anos de idade, então isso está funcionando apenas

21813
14:25:00,560 --> 14:25:02,956
Está bem, mas não podemos ter

21814
14:25:02,956 --> 14:25:06,400
definições múltiplas para a mesma classe

21815
14:25:06,400 --> 14:25:09,200
na mesma unidade de tradução aqui para

21816
14:25:09,200 --> 14:25:11,040
Exemplo se viermos na função principal

21817
14:25:11,040 --> 14:25:13,680
Eu notamos que estamos incluindo uma pessoa, então isso

21818
14:25:13,680 --> 14:25:15,840
está trazendo a definição para

21819
14:25:15,840 --> 14:25:19,200
pessoa que temos em nossa pessoa.h aqui se

21820
14:25:19,200 --> 14:25:21,276
Também tentamos declarar outra classe

21821
14:25:21,276 --> 14:25:22,800
chamada pessoa

21822
14:25:22,800 --> 14:25:25,916
mesmo se não colocarmos nada no

21823
14:25:25,916 --> 14:25:28,400
O compilador vai reclamar porque nós

21824
14:25:28,400 --> 14:25:31,040
Duas definições para o mesmo nome

21825
14:25:31,040 --> 14:25:34,720
que é a pessoa aqui se tentarmos construir

21826
14:25:34,720 --> 14:25:36,320
Acho que vamos conseguir um compilador

21827
14:25:36,320 --> 14:25:38,480
Erro ao dizer que temos uma definição

21828
14:25:38,480 --> 14:25:41,040
Você vê que temos uma redefinição de pessoa

21829
14:25:41,040 --> 14:25:42,880
então isso não é permitido que não possamos realmente

21830
14:25:42,880 --> 14:25:45,360
Faz isso, mas observe que essa pessoa

21831
14:25:45,360 --> 14:25:48,720
A classe está incluída em ambos em algum outro

21832
14:25:48,720 --> 14:25:50,800
arquivo que é uma tradução separada

21833
14:25:50,800 --> 14:25:54,160
Unidade e principal temos que incluímos aqui

21834
14:25:54,160 --> 14:25:56,320
É realmente em uma separação

21835
14:25:56,320 --> 14:25:58,956
Unidade de tradução que temos a definição

21836
14:25:58,956 --> 14:26:01,116
para a classe em tradução separada

21837
14:26:01,116 --> 14:26:03,520
Unidades e isso não é um problema, mas se

21838
14:26:03,520 --> 14:26:05,680
Você tenta colocar a mesma definição

21839
14:26:05,680 --> 14:26:09,040
Várias vezes em uma única tradução

21840
14:26:09,040 --> 14:26:10,956
unidade que você vai ter um problema e

21841
14:26:10,956 --> 14:26:13,360
Você precisa estar ciente disso o que eu quero

21842
14:26:13,360 --> 14:26:16,080
Você ver aqui é que você não pode

21843
14:26:16,080 --> 14:26:18,560
Também tem várias definições

21844
14:26:18,560 --> 14:26:22,400
para suas variáveis estáticas e o membro

21845
14:26:22,400 --> 14:26:25,596
funções de sua classe, por exemplo, se

21846
14:26:25,596 --> 14:26:28,160
Agarramos o que temos aqui

21847
14:26:28,160 --> 14:26:30,560
e também colocar isso em nossa função principal

21848
14:26:30,560 --> 14:26:32,880
Podemos fazer isso por que não vamos

21849
14:26:32,880 --> 14:26:35,116
Venha em nossa principal função aqui e nós estamos

21850
14:26:35,116 --> 14:26:37,596
Vou colocar as mesmas definições aqui

21851
14:26:37,596 --> 14:26:39,040
Agora vamos ter um problema

21852
14:26:39,040 --> 14:26:40,956
Porque o linker vai ver dois

21853
14:26:40,956 --> 14:26:43,680
definições para a variável estática e

21854
14:26:43,680 --> 14:26:45,680
o construtor para uma pessoa aqui e

21855
14:26:45,680 --> 14:26:47,276
Isso vai ser um problema que você não pode

21856
14:26:47,276 --> 14:26:49,840
Realmente fazer isso se construirmos, vamos

21857
14:26:49,840 --> 14:26:50,956
para ver

21858
14:26:50,956 --> 14:26:53,040
um problema que vamos ver

21859
14:26:53,040 --> 14:26:55,436
O problema é

21860
14:26:55,436 --> 14:26:57,200
Temos várias definições para o

21861
14:26:57,200 --> 14:26:59,756
construtor e nós temos vários

21862
14:26:59,756 --> 14:27:02,480
definições para conta de pessoa e isso

21863
14:27:02,480 --> 14:27:04,560
Não é permitido que você não possa realmente fazer isso

21864
14:27:04,560 --> 14:27:07,200
Você pode remover o de alguns

21865
14:27:07,200 --> 14:27:09,840
outro file.cpp, por exemplo, se comentarmos

21866
14:27:09,840 --> 14:27:11,116
Isto para fora

21867
14:27:11,116 --> 14:27:13,916
Vamos fazer isso, podemos chegar ao topo aqui

21868
14:27:13,916 --> 14:27:16,160
e comentar isso e tentar construir

21869
14:27:16,160 --> 14:27:18,400
O programa agora o programa está indo para

21870
14:27:18,400 --> 14:27:20,720
trabalho porque temos uma definição para

21871
14:27:20,720 --> 14:27:22,800
Esses caras que você vê o mundo é bom nós

21872
14:27:22,800 --> 14:27:25,360
pode até executar o programa para mostrar

21873
14:27:25,360 --> 14:27:28,000
que funciona ou podemos remover o

21874
14:27:28,000 --> 14:27:31,116
no arquivo cpp principal e podemos sair

21875
14:27:31,116 --> 14:27:33,680
Isso vivo então vamos voltar para o cpp

21876
14:27:33,680 --> 14:27:36,560
arquivar o arquivo cpp principal eu devo dizer e

21877
14:27:36,560 --> 14:27:38,640
remover isso e se trabalharmos, vamos

21878
14:27:38,640 --> 14:27:40,800
para ver que isso vai funcionar e

21879
14:27:40,800 --> 14:27:42,480
Que nós somos

21880
14:27:42,480 --> 14:27:45,276
compatível com o que o c plus plus

21881
14:27:45,276 --> 14:27:49,040
O padrão espera que façamos em nosso c plus

21882
14:27:49,040 --> 14:27:50,720
além de programas se estivermos por perto, estamos

21883
14:27:50,720 --> 14:27:52,480
Vou ver que isso vai funcionar

21884
14:27:52,480 --> 14:27:54,400
E isso é muito legal, isso é realmente

21885
14:27:54,400 --> 14:27:56,956
Tudo que eu queria que você visse nesta palestra

21886
14:27:56,956 --> 14:27:59,276
A regra de uma definição que diz que

21887
14:27:59,276 --> 14:28:02,880
Você não pode ter várias definições para

21888
14:28:02,880 --> 14:28:06,080
o mesmo nome em todo o c plus plus

21889
14:28:06,080 --> 14:28:09,360
programa, mas para aulas podemos violar

21890
14:28:09,360 --> 14:28:12,240
Esta regra é um pouco e faz o mesmo

21891
14:28:12,240 --> 14:28:14,800
A definição aparece em múltiplos

21892
14:28:14,800 --> 14:28:17,276
Unidades de tradução que vamos parar

21893
14:28:17,276 --> 14:28:19,276
aqui nesta palestra na próxima

21894
14:28:19,276 --> 14:28:22,000
Vamos aprender sobre a ligação

21895
14:28:22,000 --> 14:28:24,320
Vá em frente e termine aqui e me faça

21896
14:28:24,320 --> 14:28:25,360
lá

21897
14:28:25,360 --> 14:28:26,800
Nesta palestra vamos aprender

21898
14:28:26,800 --> 14:28:29,520
A função é uma função reutilizável

21899
14:28:29,520 --> 14:28:31,756
pedaço de código que você pode usar vários

21900
14:28:31,756 --> 14:28:35,436
tempos para fazer coisas diferentes que pode levar

21901
14:28:35,436 --> 14:28:38,400
entrada e uma vez que tem entrada que pode fazer

21902
14:28:38,400 --> 14:28:40,880
algum processamento e quando processamento

21903
14:28:40,880 --> 14:28:43,756
é feito a função pode opcionalmente dar

21904
14:28:43,756 --> 14:28:46,080
um resultado que você pode pensar em uma função

21905
14:28:46,080 --> 14:28:48,480
como uma máquina que pode levar a entrada e

21906
14:28:48,480 --> 14:28:50,956
dar-lhe alguma saída quando você dá entrada

21907
14:28:50,956 --> 14:28:52,480
para a máquina a máquina vai

21908
14:28:52,480 --> 14:28:54,800
fazer algum processamento e então está indo

21909
14:28:54,800 --> 14:28:57,520
para dar a você a saída e a saída é

21910
14:28:57,520 --> 14:28:59,680
Vai depender da entrada que

21911
14:28:59,680 --> 14:29:01,596
você deu para a máquina este é realmente

21912
14:29:01,596 --> 14:29:04,240
Como funciona uma função em c plus plus e

21913
14:29:04,240 --> 14:29:06,400
uma vez que você tem a máquina configurada você pode

21914
14:29:06,400 --> 14:29:09,116
realmente reutilizá-lo, mas muitas vezes você

21915
14:29:09,116 --> 14:29:11,276
Queremos, veja como uma função parece

21916
14:29:11,276 --> 14:29:13,680
em c plus mais a sintaxe é isso que você

21917
14:29:13,680 --> 14:29:16,240
primeiro especificar o tipo de retorno que pode

21918
14:29:16,240 --> 14:29:18,880
ser e duplo ou qualquer coisa depois disso

21919
14:29:18,880 --> 14:29:20,720
você vai especificar a função

21920
14:29:20,720 --> 14:29:21,680
O nome

21921
14:29:21,680 --> 14:29:23,520
E depois disso você vai ter um

21922
14:29:23,520 --> 14:29:25,756
par de parênteses dentro deste

21923
14:29:25,756 --> 14:29:27,276
Parêntese você vai ter seu

21924
14:29:27,276 --> 14:29:29,520
parâmetros que serão uma vírgula

21925
14:29:29,520 --> 14:29:32,320
Lista separada das coisas que você passa para o

21926
14:29:32,320 --> 14:29:35,436
função e depois de todos esses parâmetros

21927
14:29:35,436 --> 14:29:37,756
Você vai ter um par de encaracolados

21928
14:29:37,756 --> 14:29:40,640
aparelhos e dentro desses aparelhos encaracolados

21929
14:29:40,640 --> 14:29:42,320
nós vamos ter o corpo do

21930
14:29:42,320 --> 14:29:44,320
Função que vamos fazer o nosso

21931
14:29:44,320 --> 14:29:46,640
processamento no corpo e quando

21932
14:29:46,640 --> 14:29:49,680
O processamento é feito, podemos obter o resultado

21933
14:29:49,680 --> 14:29:52,480
da função através deste retorno

21934
14:29:52,480 --> 14:29:55,040
mecanismo aqui, então se quisermos chegar

21935
14:29:55,040 --> 14:29:57,200
Algo fora da função que temos que

21936
14:29:57,200 --> 14:29:59,520
Retorne essa coisa e vai ser

21937
14:29:59,520 --> 14:30:03,116
visível para quem usou esta função

21938
14:30:03,116 --> 14:30:05,436
Aqui está um exemplo simples de uma função

21939
14:30:05,436 --> 14:30:08,480
sem entrada e saída a sintaxe é

21940
14:30:08,480 --> 14:30:10,720
Vai ser esse vazio significa que isso

21941
14:30:10,720 --> 14:30:12,800
A função não vai devolver nada

21942
14:30:12,800 --> 14:30:15,276
e você percebe que o nosso par de

21943
14:30:15,276 --> 14:30:18,480
Os parênteses estão vazios porque não temos

21944
14:30:18,480 --> 14:30:21,276
entrada nesta função temos nosso curly

21945
14:30:21,276 --> 14:30:24,000
aparelhos e dentro destes aparelhos encaracolados é

21946
14:30:24,000 --> 14:30:25,840
Vai ser o corpo dessa função

21947
14:30:25,840 --> 14:30:28,160
vai fazer algum processamento e

21948
14:30:28,160 --> 14:30:30,720
Quando o processamento é feito, nós retornamos fora de

21949
14:30:30,720 --> 14:30:33,116
Esta função agora lembre-se que eu disse

21950
14:30:33,116 --> 14:30:34,956
que esta função não retorna

21951
14:30:34,956 --> 14:30:39,116
qualquer coisa porque é de tipo vazio aqui

21952
14:30:39,116 --> 14:30:41,116
Mas nós podemos voltar e eu vou mostrar

21953
14:30:41,116 --> 14:30:43,680
Você é a sintaxe exata de como você pode fazer

21954
14:30:43,680 --> 14:30:46,080
que tudo bem para que possamos ter muitas funções

21955
14:30:46,080 --> 14:30:48,400
em c plus plus, mas cada função tem que

21956
14:30:48,400 --> 14:30:50,560
ser único senão você vai ter

21957
14:30:50,560 --> 14:30:53,040
problemas em seu c plus programas a

21958
14:30:53,040 --> 14:30:55,756
A função será única baseada em

21959
14:30:55,756 --> 14:30:58,080
sua assinatura e a assinatura é

21960
14:30:58,080 --> 14:31:00,000
Realmente um nome de função

21961
14:31:00,000 --> 14:31:02,640
mais os parâmetros da função se formos

21962
14:31:02,640 --> 14:31:05,200
Voltando ao nosso exemplo aqui e tente

21963
14:31:05,200 --> 14:31:06,956
Descobrir a assinatura disso

21964
14:31:06,956 --> 14:31:10,000
função será o nome da função

21965
14:31:10,000 --> 14:31:12,560
e mais os parâmetros e você vê que

21966
14:31:12,560 --> 14:31:15,276
Não temos parâmetros aqui, então isso

21967
14:31:15,276 --> 14:31:18,400
Assinatura vai identificar de forma única

21968
14:31:18,400 --> 14:31:21,520
esta função em nosso programa c plus plus

21969
14:31:21,520 --> 14:31:23,436
Se estabelecermos outra função que tenha

21970
14:31:23,436 --> 14:31:25,680
este mesmo nome da função e não leva

21971
14:31:25,680 --> 14:31:27,436
qualquer parâmetro que vamos ter

21972
14:31:27,436 --> 14:31:30,160
problemas, mesmo que tenhamos uma

21973
14:31:30,160 --> 14:31:33,200
valor de retorno diferente para a função

21974
14:31:33,200 --> 14:31:35,360
e não se preocupe se isso não está fazendo

21975
14:31:35,360 --> 14:31:38,160
Sensação, mas veremos muitos exemplos

21976
14:31:38,160 --> 14:31:40,320
E tenho certeza quando terminamos

21977
14:31:40,320 --> 14:31:42,560
Com esta palestra você será um mestre

21978
14:31:42,560 --> 14:31:45,040
Usando funções ok agora que temos

21979
14:31:45,040 --> 14:31:47,436
Veja como podemos declarar ou definir um

21980
14:31:47,436 --> 14:31:49,520
função em c plus mais vamos ver como nós

21981
14:31:49,520 --> 14:31:51,200
pode usar a função

21982
14:31:51,200 --> 14:31:53,200
e quando você chama uma função na maioria das coisas

21983
14:31:53,200 --> 14:31:55,520
Casos que você vai querer tirar algo

21984
14:31:55,520 --> 14:31:58,480
dessa função, então suponha aqui resultar

21985
14:31:58,480 --> 14:32:00,640
var é uma variável que vai pegar

21986
14:32:00,640 --> 14:32:02,320
O resultado da função

21987
14:32:02,320 --> 14:32:03,680
e nós vamos chamar a função

21988
14:32:03,680 --> 14:32:05,680
com a sintaxe assim nós vamos

21989
14:32:05,680 --> 14:32:08,160
Diga o nome da função que vamos colocar

21990
14:32:08,160 --> 14:32:11,200
nosso par de parênteses aqui e nós estamos

21991
14:32:11,200 --> 14:32:13,680
passar nos argumentos ou nos

21992
14:32:13,680 --> 14:32:16,560
valores dos nossos parâmetros este é o

21993
14:32:16,560 --> 14:32:18,800
Sintaxe que vai chamar a função

21994
14:32:18,800 --> 14:32:20,480
e o resultado da função está indo

21995
14:32:20,480 --> 14:32:24,160
ser atribuído a este resultado var

21996
14:32:24,160 --> 14:32:26,800
Variável de horas aqui é como você pode

21997
14:32:26,800 --> 14:32:28,956
chamar uma função que não leva qualquer

21998
14:32:28,956 --> 14:32:31,040
parâmetro que a lista de parâmetros é

21999
14:32:31,040 --> 14:32:33,360
Basicamente vai ficar vazio e agora

22000
14:32:33,360 --> 14:32:35,436
Vamos ver alguns exemplos de

22001
14:32:35,436 --> 14:32:38,240
Como você pode realmente declarar funções em

22002
14:32:38,240 --> 14:32:40,480
seu c plus programa, por exemplo

22003
14:32:40,480 --> 14:32:43,200
Aqui temos uma função chamada em barra

22004
14:32:43,200 --> 14:32:45,360
Não devolve nada, então não podemos

22005
14:32:45,360 --> 14:32:47,596
captar o resultado desta função e

22006
14:32:47,596 --> 14:32:50,160
vai ter uma entrada na forma

22007
14:32:50,160 --> 14:32:53,116
de um inteiro, então o parâmetro é chamado

22008
14:32:53,116 --> 14:32:56,080
h aqui é um inteiro e dentro do

22009
14:32:56,080 --> 14:32:58,720
função vamos testar se

22010
14:32:58,720 --> 14:33:02,080
Alguém tem idade suficiente para entrar em um bar, então

22011
14:33:02,080 --> 14:33:04,320
Fazemos um teste para ver se a idade é

22012
14:33:04,320 --> 14:33:06,640
Maior que 18 se é que vamos

22013
14:33:06,640 --> 14:33:10,560
Diga-lhes, por favor, prossiga f que o h não é

22014
14:33:10,560 --> 14:33:12,480
Mais de 18 nós vamos dizer-lhes

22015
14:33:12,480 --> 14:33:15,040
Você não pode entrar, este é um exemplo de

22016
14:33:15,040 --> 14:33:16,956
função que você pode configurar em seu c plus

22017
14:33:16,956 --> 14:33:19,276
O plus programas aqui é outra função

22018
14:33:19,276 --> 14:33:21,040
que vai calcular o máximo

22019
14:33:21,040 --> 14:33:23,596
Entre dois números, ele vai dar

22020
14:33:23,596 --> 14:33:26,240
um resultado para que o valor de retorno seja um

22021
14:33:26,240 --> 14:33:29,200
inteiro aqui o nome da função é max

22022
14:33:29,200 --> 14:33:31,200
e nós vamos colocar em nossa lista de

22023
14:33:31,200 --> 14:33:33,840
Parâmetros e novamente estes são os

22024
14:33:33,840 --> 14:33:36,720
parâmetros quando você está definindo o seu

22025
14:33:36,720 --> 14:33:37,756
A função

22026
14:33:37,756 --> 14:33:40,320
esta lista separada de coisas que nós

22027
14:33:40,320 --> 14:33:42,956
Os parênteses são chamados

22028
14:33:42,956 --> 14:33:45,040
parâmetros e quando você chama a

22029
14:33:45,040 --> 14:33:47,840
função dos valores que você passa no

22030
14:33:47,840 --> 14:33:50,320
Os locais desses parâmetros são chamados

22031
14:33:50,320 --> 14:33:53,040
argumentos para que estes sejam alguns termos que

22032
14:33:53,040 --> 14:33:55,276
Eu posso realmente te jogar fora e eu só quero

22033
14:33:55,276 --> 14:33:58,000
Você é super claro sobre essas coisas

22034
14:33:58,000 --> 14:33:59,596
Uma vez que temos a assinatura do

22035
14:33:59,596 --> 14:34:01,840
função configurada, pulamos no corpo e

22036
14:34:01,840 --> 14:34:03,680
Fazemos o que quisermos que esta função seja

22037
14:34:03,680 --> 14:34:06,240
Fazê-lo, vamos dizer se um é maior

22038
14:34:06,240 --> 14:34:08,640
do que b então deve ser o máximo que somos

22039
14:34:08,640 --> 14:34:11,680
vou enviar isso de volta para quem

22040
14:34:11,680 --> 14:34:14,000
chamado essa função ou em outras palavras

22041
14:34:14,000 --> 14:34:15,840
nós vamos devolver um

22042
14:34:15,840 --> 14:34:18,880
e se a não é maior que b então b

22043
14:34:18,880 --> 14:34:20,796
Deve ser o máximo e nós vamos

22044
14:34:20,796 --> 14:34:22,796
Retorne isso é o que estamos dizendo aqui

22045
14:34:22,796 --> 14:34:24,880
Aqui está outro exemplo de uma função

22046
14:34:24,880 --> 14:34:27,680
que não tem nenhuma saída e não

22047
14:34:27,680 --> 14:34:30,320
tomar qualquer entrada que não retorna

22048
14:34:30,320 --> 14:34:33,360
qualquer coisa porque o tipo de retorno é vazio

22049
14:34:33,360 --> 14:34:35,680
e não requer nenhuma contribuição porque

22050
14:34:35,680 --> 14:34:38,720
a lista de parâmetros aqui está vazia e o

22051
14:34:38,720 --> 14:34:40,640
corpo da função que vamos apenas

22052
14:34:40,640 --> 14:34:43,360
cumprimente alguém e diga-lhes olá lá

22053
14:34:43,360 --> 14:34:44,956
E nós vamos voltar para fora do

22054
14:34:44,956 --> 14:34:48,000
aviso de função que para evitar a função

22055
14:34:48,000 --> 14:34:50,956
Podemos omitir a declaração de retorno

22056
14:34:50,956 --> 14:34:53,520
aqui ou podemos simplesmente colocá-lo assim

22057
14:34:53,520 --> 14:34:55,916
Diga retorno e o ponto e vírgula e

22058
14:34:55,916 --> 14:34:58,080
Seja qual for o c plus plus compilador que você é

22059
14:34:58,080 --> 14:35:01,040
usar vai aceitar isso como aceitável c

22060
14:35:01,040 --> 14:35:02,480
plus plus sintaxe

22061
14:35:02,480 --> 14:35:04,640
Aqui está outro exemplo de uma função

22062
14:35:04,640 --> 14:35:07,756
que retorna alguma coisa, mas não leva

22063
14:35:07,756 --> 14:35:10,000
qualquer entrada o valor de retorno vai

22064
14:35:10,000 --> 14:35:12,956
ser um inteiro, mas não precisamos passar

22065
14:35:12,956 --> 14:35:14,880
algo para esta função quando chamamos

22066
14:35:14,880 --> 14:35:17,276
Isso só vai nos dar produção nós

22067
14:35:17,276 --> 14:35:20,240
pode chamá-lo e obter o nosso número da sorte e

22068
14:35:20,240 --> 14:35:22,880
Use que, no entanto, queremos em nosso c plus

22069
14:35:22,880 --> 14:35:25,436
além da aplicação, acho que vimos um

22070
14:35:25,436 --> 14:35:27,680
muitos exemplos de como podemos configurar

22071
14:35:27,680 --> 14:35:30,320
funções agora, vamos ver como podemos chamar

22072
14:35:30,320 --> 14:35:32,796
Estas funções aqui é um simples c plus

22073
14:35:32,796 --> 14:35:34,796
além do programa na função principal

22074
14:35:34,796 --> 14:35:37,276
basta configurar algumas variáveis um valor b

22075
14:35:37,276 --> 14:35:40,400
valorizar a e b aqui e nós usamos isso

22076
14:35:40,400 --> 14:35:42,956
variáveis para chamar funções lembram que

22077
14:35:42,956 --> 14:35:45,360
configurar uma função inter bar

22078
14:35:45,360 --> 14:35:47,436
A função parecia assim e foi

22079
14:35:47,436 --> 14:35:50,400
Testar para ver se a idade de alguém era

22080
14:35:50,400 --> 14:35:52,796
Maior que 18. se a idade for maior

22081
14:35:52,796 --> 14:35:55,756
mais de 18 eles vão entrar no bar

22082
14:35:55,756 --> 14:35:58,320
se a borda não for maior que 18 nós

22083
14:35:58,320 --> 14:36:01,116
Não vai deixá-los terminar a função takes

22084
14:36:01,116 --> 14:36:03,680
entrada, mas não retorna nada assim

22085
14:36:03,680 --> 14:36:05,680
Podemos chamar essa função como fazemos

22086
14:36:05,680 --> 14:36:07,840
aqui e dizer em bar

22087
14:36:07,840 --> 14:36:09,756
e você percebe que não estamos pegando

22088
14:36:09,756 --> 14:36:11,520
algo fora desta função nós somos

22089
14:36:11,520 --> 14:36:13,596
Só vou chamá-lo e nós vamos

22090
14:36:13,596 --> 14:36:16,880
dar-lhe a entrada que é 22 aqui e a

22091
14:36:16,880 --> 14:36:18,640
A função vai fazer sua coisa, então

22092
14:36:18,640 --> 14:36:21,916
vai nos deixar entrar porque a nossa idade

22093
14:36:21,916 --> 14:36:24,880
é maior que 18. aqui em baixo você vê que nós

22094
14:36:24,880 --> 14:36:28,400
estão chamando a função máxima aqui que estamos

22095
14:36:28,400 --> 14:36:31,680
dando a ele duas entradas um valor e b valor

22096
14:36:31,680 --> 14:36:34,000
e vai devolver alguma coisa e

22097
14:36:34,000 --> 14:36:36,080
O valor de retorno desta função é

22098
14:36:36,080 --> 14:36:38,720
vai ser usado para inicializar isso

22099
14:36:38,720 --> 14:36:41,680
variável número máximo aqui é

22100
14:36:41,680 --> 14:36:44,240
O que estamos fazendo se descermos, vemos

22101
14:36:44,240 --> 14:36:46,160
que podemos chamar a função máxima

22102
14:36:46,160 --> 14:36:49,436
diretamente e usar seu valor de retorno em um

22103
14:36:49,436 --> 14:36:52,160
sddc fora declaração aqui e isso é

22104
14:36:52,160 --> 14:36:54,480
vai imprimir o máximo entre um

22105
14:36:54,480 --> 14:36:55,360
e b

22106
14:36:55,360 --> 14:36:57,040
E aqui você vê que temos o

22107
14:36:57,040 --> 14:36:59,276
A função diga olá que vai

22108
14:36:59,276 --> 14:37:01,436
Basta cumprimentar alguém e não voltar

22109
14:37:01,436 --> 14:37:03,840
Tudo aqui é outro exemplo de como

22110
14:37:03,840 --> 14:37:05,596
Você pode chamar o número da sorte que você diz

22111
14:37:05,596 --> 14:37:07,360
sorte número que você passa um par de

22112
14:37:07,360 --> 14:37:08,480
os parênteses

22113
14:37:08,480 --> 14:37:10,160
E isso vai devolver a sorte

22114
14:37:10,160 --> 14:37:13,840
número e imprimi-lo para fora neste htdc para fora

22115
14:37:13,840 --> 14:37:16,880
Declaração aqui em baixo nós estabelecemos alguns

22116
14:37:16,880 --> 14:37:19,840
variáveis a e b e vamos

22117
14:37:19,840 --> 14:37:22,320
usá-los para chamar as funções máximas

22118
14:37:22,320 --> 14:37:25,116
você vê que chamamos max a b ou podemos até

22119
14:37:25,116 --> 14:37:28,560
Passar em números literais como nós somos

22120
14:37:28,560 --> 14:37:30,640
fazendo aqui em baixo

22121
14:37:30,640 --> 14:37:32,400
Uma coisa que eu quero que você tenha cuidado

22122
14:37:32,400 --> 14:37:34,480
é conversões implícitas que podem

22123
14:37:34,480 --> 14:37:36,080
Acontece quando você está te chamando

22124
14:37:36,080 --> 14:37:37,276
Funções

22125
14:37:37,276 --> 14:37:39,756
Suponha que temos uma função mínima como

22126
14:37:39,756 --> 14:37:42,080
Vemos aqui o que vai levar

22127
14:37:42,080 --> 14:37:45,596
em parâmetros inteiros, mas aqui estamos

22128
14:37:45,596 --> 14:37:48,320
Chamando a função com f e g

22129
14:37:48,320 --> 14:37:51,436
que é de tipo duplo como

22130
14:37:51,436 --> 14:37:54,080
vemos no topo aqui, então o que vai fazer

22131
14:37:54,080 --> 14:37:55,840
Acontece é que o compilador vai

22132
14:37:55,840 --> 14:37:58,240
perceber que o que você está passando é

22133
14:37:58,240 --> 14:38:00,640
não realmente o que a função toma, mas

22134
14:38:00,640 --> 14:38:03,360
o compilador sabe que ele pode inserir um

22135
14:38:03,360 --> 14:38:06,880
Transformação do duplo para o inteiro

22136
14:38:06,880 --> 14:38:09,040
E isso vai fazer isso sem o seu

22137
14:38:09,040 --> 14:38:11,756
envolvimento, então seja realmente cuidadoso com

22138
14:38:11,756 --> 14:38:14,240
conversões implícitas e certifique-se de que

22139
14:38:14,240 --> 14:38:16,956
estão trabalhando para sua vantagem, caso contrário

22140
14:38:16,956 --> 14:38:18,640
você vai ter muito difícil de

22141
14:38:18,640 --> 14:38:21,200
depurar problemas em seu c plus mais

22142
14:38:21,200 --> 14:38:22,560
Os programas

22143
14:38:22,560 --> 14:38:24,400
Uma outra coisa que eu quero que você esteja ciente

22144
14:38:24,400 --> 14:38:26,640
DÉ isso se tivermos uma função configurada

22145
14:38:26,640 --> 14:38:29,360
Como esta função vai ser

22146
14:38:29,360 --> 14:38:33,200
tomar os parâmetros como cópias se você

22147
14:38:33,200 --> 14:38:35,756
tem duas variáveis, por exemplo, c e d

22148
14:38:35,756 --> 14:38:37,276
e você chama essa função com aqueles

22149
14:38:37,276 --> 14:38:39,436
Duas variáveis que você não vai ser

22150
14:38:39,436 --> 14:38:41,680
manipular essas duas variáveis o que

22151
14:38:41,680 --> 14:38:44,160
Você estará trabalhando com dentro do corpo

22152
14:38:44,160 --> 14:38:46,956
Desta função serão cópias

22153
14:38:46,956 --> 14:38:48,720
dos parâmetros em que você passou

22154
14:38:48,720 --> 14:38:51,040
E aqui, se por exemplo você acontecer com

22155
14:38:51,040 --> 14:38:53,200
incrementar qualquer um dos parâmetros para

22156
14:38:53,200 --> 14:38:55,680
O exemplo aqui incrementamos a e nós

22157
14:38:55,680 --> 14:38:56,956
incremento b

22158
14:38:56,956 --> 14:38:59,200
as mudanças que fazemos aqui dentro do corpo

22159
14:38:59,200 --> 14:39:01,116
da função vai ser

22160
14:39:01,116 --> 14:39:03,436
afetando as cópias que temos dentro do

22161
14:39:03,436 --> 14:39:05,756
função aqui e essas cópias estão indo

22162
14:39:05,756 --> 14:39:08,796
para morrer no momento em que chegamos ao fim disso

22163
14:39:08,796 --> 14:39:10,400
Função aqui é algo que eu quero

22164
14:39:10,400 --> 14:39:12,560
você está ciente e vamos jogar com

22165
14:39:12,560 --> 14:39:15,200
mais detalhes quando atingimos o visual

22166
14:39:15,200 --> 14:39:17,680
Código de estúdio em um minuto aqui é simples

22167
14:39:17,680 --> 14:39:19,276
Exemplo de como você pode chamar isso

22168
14:39:19,276 --> 14:39:22,640
função temos duas variáveis h e i

22169
14:39:22,640 --> 14:39:25,520
e nós vamos imprimi-los depois

22170
14:39:25,520 --> 14:39:27,200
que vamos chamar a função

22171
14:39:27,200 --> 14:39:30,400
vamos armazenar o resultado de volta

22172
14:39:30,400 --> 14:39:33,040
Resultados mult mas o importante é

22173
14:39:33,040 --> 14:39:35,200
que chamamos a função aqui com h

22174
14:39:35,200 --> 14:39:36,240
E eu

22175
14:39:36,240 --> 14:39:38,160
Lembrem que no corpo da função

22176
14:39:38,160 --> 14:39:41,680
estão incrementando h e i como argumentos

22177
14:39:41,680 --> 14:39:44,720
mas as mudanças que fazemos dentro do corpo

22178
14:39:44,720 --> 14:39:46,880
A função não vai ser

22179
14:39:46,880 --> 14:39:50,080
visível quando a função retorna se nós

22180
14:39:50,080 --> 14:39:52,400
imprimir h e eu aqui nós só estamos indo para

22181
14:39:52,400 --> 14:39:55,276
Veja a mesma coisa que vimos antes de ligar

22182
14:39:55,276 --> 14:39:56,400
a função

22183
14:39:56,400 --> 14:39:58,400
Percebo que isso é muita informação

22184
14:39:58,400 --> 14:40:00,796
para aceitar agora que vamos cabeçar

22185
14:40:00,796 --> 14:40:03,040
para código de estúdio visual e realmente jogar

22186
14:40:03,040 --> 14:40:05,200
Connos passo a passo

22187
14:40:05,200 --> 14:40:07,840
Tudo bem aqui estamos em nosso trabalho

22188
14:40:07,840 --> 14:40:10,480
diretório do capítulo sobre funções

22189
14:40:10,480 --> 14:40:12,880
A palestra atual é em primeira mão

22190
14:40:12,880 --> 14:40:15,360
funções que vamos pegar o nosso

22191
14:40:15,360 --> 14:40:18,000
arquivos de modelo como sempre fazemos

22192
14:40:18,000 --> 14:40:19,756
indo para colocar isso em

22193
14:40:19,756 --> 14:40:21,680
e nós vamos abrir isso em

22194
14:40:21,680 --> 14:40:25,520
O código do estúdio vamos abrir a pasta

22195
14:40:25,520 --> 14:40:27,596
e nós vamos entrar no correto

22196
14:40:27,596 --> 14:40:28,720
O capítulo

22197
14:40:28,720 --> 14:40:31,276
e escolher em primeira mão em funções aqui

22198
14:40:31,276 --> 14:40:33,756
Isto é o que queremos abrir e nós somos

22199
14:40:33,756 --> 14:40:36,720
indo para abrir o nosso arquivo cpp principal e

22200
14:40:36,720 --> 14:40:39,200
Limpar um pouco

22201
14:40:39,200 --> 14:40:41,040
A primeira coisa que queremos fazer é

22202
14:40:41,040 --> 14:40:42,796
configurar uma função que leva um único

22203
14:40:42,796 --> 14:40:45,680
parâmetro e não devolve nada

22204
14:40:45,680 --> 14:40:48,080
resultado para que a função seja

22205
14:40:48,080 --> 14:40:50,480
interbore, vimos que a função

22206
14:40:50,480 --> 14:40:52,480
Não vai devolver nada, então é

22207
14:40:52,480 --> 14:40:54,560
vai ser anulado seu tipo de retorno é

22208
14:40:54,560 --> 14:40:56,320
Será anulado o nome do

22209
14:40:56,320 --> 14:40:59,116
A função vai ser interbar e

22210
14:40:59,116 --> 14:41:00,796
O que queremos passar aqui é um

22211
14:41:00,796 --> 14:41:02,796
variável para representar a idade de

22212
14:41:02,796 --> 14:41:05,360
Alguém e nós sabemos que a idade pode

22213
14:41:05,360 --> 14:41:08,240
Realmente não ser negativo, então é

22214
14:41:08,240 --> 14:41:11,680
Aconselhado a pelo menos usar um não assinado

22215
14:41:11,680 --> 14:41:13,596
tipo inteiro, então vamos usar

22216
14:41:13,596 --> 14:41:16,320
fim não assinado e o nome do parâmetro é

22217
14:41:16,320 --> 14:41:18,320
Vai ser chamado de idade

22218
14:41:18,320 --> 14:41:20,560
uma vez que temos nossa lista de parâmetros, estamos

22219
14:41:20,560 --> 14:41:22,880
indo para colocar no corpo da função e

22220
14:41:22,880 --> 14:41:24,720
Lembre-se da função que o corpo vai

22221
14:41:24,720 --> 14:41:26,796
Deixe dentro desses dois

22222
14:41:26,796 --> 14:41:28,880
curly braces

22223
14:41:28,880 --> 14:41:31,116
agora esta é uma função válida c plus plus

22224
14:41:31,116 --> 14:41:33,116
Não vai devolver nada, é

22225
14:41:33,116 --> 14:41:34,796
Vou tomar um único parâmetro cujo

22226
14:41:34,796 --> 14:41:37,680
tipo não é assinado e seu nome é

22227
14:41:37,680 --> 14:41:40,240
interbar nós podemos obter dentro da função

22228
14:41:40,240 --> 14:41:42,160
E realmente fazer o que quisermos

22229
14:41:42,160 --> 14:41:44,956
Para fazer isso quando entrarmos, vamos

22230
14:41:44,956 --> 14:41:47,520
testar e ver se a idade é maior do que

22231
14:41:47,520 --> 14:41:50,480
18 fazer algo se a idade não é

22232
14:41:50,480 --> 14:41:52,000
Maior que 18 nós vamos fazer

22233
14:41:52,000 --> 14:41:53,520
Algo mais vamos fazer que estamos indo

22234
14:41:53,520 --> 14:41:54,720
para dizer se

22235
14:41:54,720 --> 14:41:57,680
A idade é maior que 18 estamos indo para

22236
14:41:57,680 --> 14:41:59,840
Diga a eles a idade e diga que

22237
14:41:59,840 --> 14:42:03,360
Eles podem realmente ir nisso é lógico

22238
14:42:03,360 --> 14:42:05,596
e nós vamos dizer mais e no

22239
14:42:05,596 --> 14:42:08,320
corpo deste outro bloco

22240
14:42:08,320 --> 14:42:10,240
nós vamos dizer outra coisa

22241
14:42:10,240 --> 14:42:12,400
nós vamos dizer-lhes que lamentam que você está

22242
14:42:12,400 --> 14:42:14,320
Muito jovem para isso e nós vamos

22243
14:42:14,320 --> 14:42:16,880
sair deste bloco aqui e isso é

22244
14:42:16,880 --> 14:42:19,360
Realmente a nossa função novamente vamos tentar

22245
14:42:19,360 --> 14:42:21,680
analisar a sintaxe aqui que temos

22246
14:42:21,680 --> 14:42:24,720
Tipo de retorno que é necessário em c mais

22247
14:42:24,720 --> 14:42:26,640
Além disso, se você não colocá-lo em você está indo

22248
14:42:26,640 --> 14:42:29,200
para obter um erro do compilador porque você

22249
14:42:29,200 --> 14:42:31,116
Não pode ter uma função sem um retorno

22250
14:42:31,116 --> 14:42:33,436
Digite c plus plus note que nós

22251
14:42:33,436 --> 14:42:35,276
ter nossas linhas aqui visual

22252
14:42:35,276 --> 14:42:37,520
Código de estúdio não é feliz, então estamos indo

22253
14:42:37,520 --> 14:42:40,000
para dizer o tipo de retorno que estamos indo

22254
14:42:40,000 --> 14:42:42,880
para salvar o nome da função depois disso

22255
14:42:42,880 --> 14:42:44,560
e após o nome da função estamos indo

22256
14:42:44,560 --> 14:42:47,360
para passar os parâmetros que podemos ter qualquer

22257
14:42:47,360 --> 14:42:49,916
número de parâmetros ou entradas para o

22258
14:42:49,916 --> 14:42:52,400
função, mas neste caso temos apenas

22259
14:42:52,400 --> 14:42:54,160
um porque é suficiente para o nosso

22260
14:42:54,160 --> 14:42:56,796
Depois disso, temos o corpo e

22261
14:42:56,796 --> 14:42:58,796
Dentro do corpo, fazemos o que quer que seja

22262
14:42:58,796 --> 14:43:01,360
Quero fazer nesta função aqui, porque

22263
14:43:01,360 --> 14:43:03,840
Esta função retorna o vazio que não

22264
14:43:03,840 --> 14:43:06,560
realmente precisa retornar explicitamente de

22265
14:43:06,560 --> 14:43:08,796
Esta função aqui, mas esta é uma

22266
14:43:08,796 --> 14:43:11,520
exceção apenas para funções que retornam

22267
14:43:11,520 --> 14:43:14,000
anular para outros tipos de retorno que você vai

22268
14:43:14,000 --> 14:43:16,640
tem que colocar na declaração de retorno, mas

22269
14:43:16,640 --> 14:43:18,720
mesmo para funções vazias que você pode colocar

22270
14:43:18,720 --> 14:43:20,880
declaração de retorno se você quiser e você pode

22271
14:43:20,880 --> 14:43:24,080
Faz isso dizer retorno

22272
14:43:24,080 --> 14:43:25,520
E você vai colocar um ponto e e-vírgula

22273
14:43:25,520 --> 14:43:28,080
depois disso, isso também é válido c plus

22274
14:43:28,080 --> 14:43:30,956
mais sintaxe ok agora nós declaramos

22275
14:43:30,956 --> 14:43:33,116
A função é um c plus mais válido

22276
14:43:33,116 --> 14:43:35,276
Funções, vamos tentar chamá-lo, nós somos

22277
14:43:35,276 --> 14:43:37,116
indo para baixo no main porque isso é

22278
14:43:37,116 --> 14:43:38,560
onde queremos chamar a nossa

22279
14:43:38,560 --> 14:43:41,680
funções por enquanto e nós vamos

22280
14:43:41,680 --> 14:43:44,080
Diga interbar, vamos chamar de

22281
14:43:44,080 --> 14:43:46,000
função e você usa o nome da função

22282
14:43:46,000 --> 14:43:48,320
para chamá-lo e você vai colocar em um

22283
14:43:48,320 --> 14:43:51,596
Pares de parênteses e passar um argumento

22284
14:43:51,596 --> 14:43:54,000
para a função novamente o que você passa para

22285
14:43:54,000 --> 14:43:55,436
A função quando você a chama é

22286
14:43:55,436 --> 14:43:57,596
Um argumento, mas o que você passa

22287
14:43:57,596 --> 14:43:58,956
através da função quando você está

22288
14:43:58,956 --> 14:44:01,520
Definindo como fizemos aqui que é um

22289
14:44:01,520 --> 14:44:02,640
O parâmetro

22290
14:44:02,640 --> 14:44:04,720
Ok, então função parâmetros quando

22291
14:44:04,720 --> 14:44:07,116
Declarar funções e quando você é

22292
14:44:07,116 --> 14:44:09,116
Chamando a função do que você passa são

22293
14:44:09,116 --> 14:44:10,480
A função

22294
14:44:10,480 --> 14:44:12,880
argumentos e agora precisamos passar

22295
14:44:12,880 --> 14:44:15,596
alguma idade para esta função e digamos

22296
14:44:15,596 --> 14:44:18,160
22 E se fizermos isso, isso vai ser

22297
14:44:18,160 --> 14:44:21,520
um programa c plus mais válido

22298
14:44:21,520 --> 14:44:23,436
notar que nós temos esta linha squiggly

22299
14:44:23,436 --> 14:44:26,720
É porque nos esquecemos de um ponto e vírgula aqui

22300
14:44:26,720 --> 14:44:27,680
porque

22301
14:44:27,680 --> 14:44:30,880
c plus mais requer ter um ponto e vírgula

22302
14:44:30,880 --> 14:44:33,840
após cada declaração e agora temos um

22303
14:44:33,840 --> 14:44:37,116
válido c plus programa que está declarando a

22304
14:44:37,116 --> 14:44:39,436
função e chamando uma função para baixo

22305
14:44:39,436 --> 14:44:42,320
Aqui no geral podemos tentar construí-lo

22306
14:44:42,320 --> 14:44:44,880
Vamos usar o gcc para fazer isso que o mundo é

22307
14:44:44,880 --> 14:44:46,720
Vai ser bom você vê o mundo acabado

22308
14:44:46,720 --> 14:44:49,116
Podemos trazer uma

22309
14:44:49,116 --> 14:44:51,116
terminal e realmente tentar executar isso

22310
14:44:51,116 --> 14:44:53,200
Função aqui, vamos limpar e correr

22311
14:44:53,200 --> 14:44:55,360
Galo porque o nosso programa vai

22312
14:44:55,360 --> 14:44:57,360
ser chamado de galo como temos sido

22313
14:44:57,360 --> 14:44:59,840
fazer o tempo todo e na saída é

22314
14:44:59,840 --> 14:45:02,560
Vai ser você 22

22315
14:45:02,560 --> 14:45:05,360
Por favor, observe que temos isso

22316
14:45:05,360 --> 14:45:08,240
função definida uma vez, mas podemos chamá-lo

22317
14:45:08,240 --> 14:45:10,320
várias vezes, por exemplo, se você for

22318
14:45:10,320 --> 14:45:12,560
Aqui em baixo e dizer em bar

22319
14:45:12,560 --> 14:45:15,436
e nós damos 15 como a idade

22320
14:45:15,436 --> 14:45:18,000
e tentamos construir novamente vamos construir

22321
14:45:18,000 --> 14:45:19,596
com o Gcc

22322
14:45:19,596 --> 14:45:21,520
O construtor vai ser bom, nós podemos

22323
14:45:21,520 --> 14:45:24,240
claro e correr galo agora vai

22324
14:45:24,240 --> 14:45:27,200
Diga que você tem 15 anos, por favor, continue por que

22325
14:45:27,200 --> 14:45:28,480
que

22326
14:45:28,480 --> 14:45:30,796
o que estamos realmente fazendo aqui se a idade

22327
14:45:30,796 --> 14:45:32,880
é maior que 10 nós dizemos 10 aqui nós

22328
14:45:32,880 --> 14:45:36,080
deveria dizer 18. desculpe por isso nós somos

22329
14:45:36,080 --> 14:45:38,880
indo para soldar novamente

22330
14:45:38,880 --> 14:45:42,160
e agora deve se comportar de acordo, então

22331
14:45:42,160 --> 14:45:43,916
Vamos dizer galo aqui

22332
14:45:43,916 --> 14:45:46,796
Você tem 22, por favor, continue você também

22333
14:45:46,796 --> 14:45:49,116
jovens por isso sem ofensa, porque o

22334
14:45:49,116 --> 14:45:52,160
A idade é 15 aqui você pode continuar chamando isso

22335
14:45:52,160 --> 14:45:53,916
Função e você vai ver as coisas

22336
14:45:53,916 --> 14:45:55,680
Imprimir você pode até chamar isso

22337
14:45:55,680 --> 14:45:57,520
Função no loop eu não posso realmente

22338
14:45:57,520 --> 14:45:59,596
resistir, então vamos fazer isso nós vamos

22339
14:45:59,596 --> 14:46:03,040
Diga para o tamanho t

22340
14:46:03,040 --> 14:46:06,560
e dizer começar de 0 por exemplo ou 1

22341
14:46:06,560 --> 14:46:07,680
Por que não

22342
14:46:07,680 --> 14:46:10,320
e nós vamos dizer enquanto eu sou menos

22343
14:46:10,320 --> 14:46:11,200
Mais do que

22344
14:46:11,200 --> 14:46:12,840
10 ou 10

22345
14:46:12,840 --> 14:46:15,596
20. vamos incrementar uh você

22346
14:46:15,596 --> 14:46:18,000
já sei como usar loops para que nós

22347
14:46:18,000 --> 14:46:20,320
Vou usar isso como um exemplo

22348
14:46:20,320 --> 14:46:21,680
E nós podemos

22349
14:46:21,680 --> 14:46:23,916
Comente todos esses caras na frente

22350
14:46:23,916 --> 14:46:25,756
porque nós não queremos que eles imprimam

22351
14:46:25,756 --> 14:46:27,436
Coisas por agora

22352
14:46:27,436 --> 14:46:29,520
e o que vamos fazer é chamar o

22353
14:46:29,520 --> 14:46:31,916
Funcionar com qualquer iteração que sejamos

22354
14:46:31,916 --> 14:46:32,880
A este.

22355
14:46:32,880 --> 14:46:35,360
notar que temos um tamanho t aqui e

22356
14:46:35,360 --> 14:46:37,840
A função vai ser tomada

22357
14:46:37,840 --> 14:46:40,080
um inteiro não assinado, então vamos

22358
14:46:40,080 --> 14:46:43,840
ter conversões implícitas do tamanho t

22359
14:46:43,840 --> 14:46:47,680
para terminar ou se realmente queremos que isso não

22360
14:46:47,680 --> 14:46:50,720
causar qualquer problema que possamos mudar o

22361
14:46:50,720 --> 14:46:53,200
tipo do nosso parâmetro para ser tamanho t este

22362
14:46:53,200 --> 14:46:56,400
também é válido c plus código plus, digamos

22363
14:46:56,400 --> 14:46:58,880
Tamanho t corretamente

22364
14:46:58,880 --> 14:47:01,200
E se formos aqui

22365
14:47:01,200 --> 14:47:02,880
nós vamos dizer

22366
14:47:02,880 --> 14:47:04,320
entrar na barra

22367
14:47:04,320 --> 14:47:06,640
E nós vamos passar um eu

22368
14:47:06,640 --> 14:47:08,080
Veja o que vai acontecer, isso é

22369
14:47:08,080 --> 14:47:09,200
indo para o loop

22370
14:47:09,200 --> 14:47:12,000
de 1 todo o caminho até 19 e está indo

22371
14:47:12,000 --> 14:47:14,320
para chamar essa função com

22372
14:47:14,320 --> 14:47:16,880
Seja qual for a iteração que possamos estar, então

22373
14:47:16,880 --> 14:47:19,276
vai olhar de 1 todo o caminho para

22374
14:47:19,276 --> 14:47:21,680
18 e vai

22375
14:47:21,680 --> 14:47:23,916
Diga-nos que somos jovens demais para isso, mas

22376
14:47:23,916 --> 14:47:26,000
por 19 vai nos deixar entrar porque

22377
14:47:26,000 --> 14:47:29,596
Nós teremos idade suficiente para entrar em um bar

22378
14:47:29,596 --> 14:47:31,276
Vamos tentar isso eu acho que vai ser

22379
14:47:31,276 --> 14:47:34,560
Diversão nós vamos soldar com gcc

22380
14:47:34,560 --> 14:47:36,320
E nós vamos limpar

22381
14:47:36,320 --> 14:47:38,956
e correr galo ah desculpe você também é

22382
14:47:38,956 --> 14:47:40,720
jovem para isso você muito jovem com a gente e

22383
14:47:40,720 --> 14:47:42,880
que uma vez que batemos 19 vai dizer

22384
14:47:42,880 --> 14:47:45,116
Somos jovens o suficiente para entrar em um bar

22385
14:47:45,116 --> 14:47:47,200
e nós vamos e temos como

22386
14:47:47,200 --> 14:47:50,080
Muito divertido como queremos, então isso é realmente

22387
14:47:50,080 --> 14:47:53,040
Como você pode declarar uma função lembre-se

22388
14:47:53,040 --> 14:47:56,000
uma função é identificada exclusivamente por sua

22389
14:47:56,000 --> 14:47:58,640
Assinatura e a assinatura são realmente

22390
14:47:58,640 --> 14:48:00,720
O nome da função e a

22391
14:48:00,720 --> 14:48:02,880
Parâmetros que você tem aqui ok

22392
14:48:02,880 --> 14:48:04,240
uma vez que você tem a função declarada

22393
14:48:04,240 --> 14:48:05,596
Você vai fazer o que quiser

22394
14:48:05,596 --> 14:48:07,840
O corpo que você vai opcionalmente

22395
14:48:07,840 --> 14:48:10,160
Retorne algo da função e

22396
14:48:10,160 --> 14:48:13,360
uma vez que a função é declarada ou configurada

22397
14:48:13,360 --> 14:48:15,276
você pode ir no main e chamá-lo e fazer

22398
14:48:15,276 --> 14:48:17,840
O que quer que você queira com isso, tudo bem agora

22399
14:48:17,840 --> 14:48:20,400
Acho que estamos maduros o suficiente para experimentar

22400
14:48:20,400 --> 14:48:22,640
algumas outras funções vamos para baixo e

22401
14:48:22,640 --> 14:48:24,160
colocar em outra função que está indo

22402
14:48:24,160 --> 14:48:26,400
para calcular o máximo de dois números

22403
14:48:26,400 --> 14:48:28,000
A assinatura desta função está indo

22404
14:48:28,000 --> 14:48:30,000
ser o seu nome aqui e os parâmetros

22405
14:48:30,000 --> 14:48:32,560
notar que estamos tomando dois parâmetros

22406
14:48:32,560 --> 14:48:34,400
porque queremos estar calculando o

22407
14:48:34,400 --> 14:48:37,116
máximo entre dois números e este

22408
14:48:37,116 --> 14:48:38,880
A função vai devolver algo que nós

22409
14:48:38,880 --> 14:48:40,796
Quer tirar o máximo do

22410
14:48:40,796 --> 14:48:43,200
funcionar e usá-lo para fazer outra coisa

22411
14:48:43,200 --> 14:48:44,560
Quando nós o chamamos de

22412
14:48:44,560 --> 14:48:46,320
Esta é a declaração do

22413
14:48:46,320 --> 14:48:48,240
Função uma vez que atingimos o corpo do

22414
14:48:48,240 --> 14:48:49,840
A função vamos calcular o

22415
14:48:49,840 --> 14:48:52,240
máximo vamos dizer se um é

22416
14:48:52,240 --> 14:48:54,560
maior do que b então um deve ser o nosso

22417
14:48:54,560 --> 14:48:56,956
máximo para que vamos devolver isso

22418
14:48:56,956 --> 14:48:59,840
e se a não é maior que b então b

22419
14:48:59,840 --> 14:49:01,520
Deve ser o máximo para o qual vamos

22420
14:49:01,520 --> 14:49:04,160
devolver b como o nosso máximo aqui é

22421
14:49:04,160 --> 14:49:06,240
O que a função está fazendo podemos entrar

22422
14:49:06,240 --> 14:49:08,560
main e chamá-lo vamos para baixo e

22423
14:49:08,560 --> 14:49:10,560
Comente isso porque não queremos

22424
14:49:10,560 --> 14:49:13,360
saída de ruído desses caras, então chamando

22425
14:49:13,360 --> 14:49:15,756
Interbore é o que estávamos fazendo agora

22426
14:49:15,756 --> 14:49:17,916
Estamos chamando o máximo, então vamos embora

22427
14:49:17,916 --> 14:49:20,560
para baixo e configurar uma variável chamá-lo

22428
14:49:20,560 --> 14:49:23,116
Resultar por que não e nós vamos

22429
14:49:23,116 --> 14:49:26,560
calcular o máximo entre 10 e 20

22430
14:49:26,560 --> 14:49:28,956
Por que não está bem, então vamos ver o que temos

22431
14:49:28,956 --> 14:49:30,480
e vamos imprimir o máximo

22432
14:49:30,480 --> 14:49:32,560
Desta vez vamos dizer

22433
14:49:32,560 --> 14:49:36,480
max como resort bom agora se construirmos isso

22434
14:49:36,480 --> 14:49:38,400
programar e executá-lo para adivinhar o que

22435
14:49:38,400 --> 14:49:39,916
nós vamos conseguir que vamos ligar

22436
14:49:39,916 --> 14:49:41,596
A função máxima

22437
14:49:41,596 --> 14:49:44,640
O que passamos aqui são argumentos

22438
14:49:44,640 --> 14:49:47,360
novamente não estamos passando parâmetros aqui

22439
14:49:47,360 --> 14:49:50,400
Vamos passar em 10 e 20 como nosso

22440
14:49:50,400 --> 14:49:52,956
argumentos e quando chamamos a função

22441
14:49:52,956 --> 14:49:55,040
O controle vai saltar para o corpo de

22442
14:49:55,040 --> 14:49:56,796
A função e nós vamos cair

22443
14:49:56,796 --> 14:49:58,956
Aqui dentro dos argumentos que vamos

22444
14:49:58,956 --> 14:50:01,200
pass in só vai ser copiado em

22445
14:50:01,200 --> 14:50:03,756
A função e nós vamos tê-los

22446
14:50:03,756 --> 14:50:05,680
através desses nomes a e b então nós somos

22447
14:50:05,680 --> 14:50:07,436
vai testar e ver se o primeiro

22448
14:50:07,436 --> 14:50:09,916
O parâmetro é maior que o segundo em

22449
14:50:09,916 --> 14:50:11,916
Este caso o primeiro parâmetro não é

22450
14:50:11,916 --> 14:50:13,840
maior do que o segundo, porque o

22451
14:50:13,840 --> 14:50:16,000
O primeiro é 10, o segundo é um 20.

22452
14:50:16,000 --> 14:50:18,640
vamos descer e ver isso e o teste

22453
14:50:18,640 --> 14:50:20,480
Aqui vai falhar e nós vamos

22454
14:50:20,480 --> 14:50:23,596
executar o que está no outro bloco aqui

22455
14:50:23,596 --> 14:50:25,840
e nós vamos voltar b como nosso

22456
14:50:25,840 --> 14:50:28,000
máximo quando retornamos b

22457
14:50:28,000 --> 14:50:30,400
b será basicamente o resultado de

22458
14:50:30,400 --> 14:50:32,080
Esta expressão aqui

22459
14:50:32,080 --> 14:50:34,240
e esse resultado será atribuído

22460
14:50:34,240 --> 14:50:36,000
para nossa variável de pesquisa e estamos indo

22461
14:50:36,000 --> 14:50:38,480
para imprimi-lo com este esddc para fora

22462
14:50:38,480 --> 14:50:40,880
declaração aqui, então vamos tentar construir

22463
14:50:40,880 --> 14:50:43,436
Isso vamos construir com gcc novamente

22464
14:50:43,436 --> 14:50:45,116
O mundo vai ser bom nós somos

22465
14:50:45,116 --> 14:50:47,520
indo para limpar e correr galo que você vê

22466
14:50:47,520 --> 14:50:50,240
que o máximo é 20. se tentarmos mudar

22467
14:50:50,240 --> 14:50:51,840
Isso, por exemplo, faça o primeiro

22468
14:50:51,840 --> 14:50:55,680
parâmetro 100 e ambos novamente

22469
14:50:55,680 --> 14:50:58,320
Vamos ver o máximo que temos

22470
14:50:58,320 --> 14:51:00,240
indo para limpar e correr galo, nós somos

22471
14:51:00,240 --> 14:51:02,956
vai dizer que o máximo é 100 e

22472
14:51:02,956 --> 14:51:04,956
novamente você pode chamar esta função no entanto

22473
14:51:04,956 --> 14:51:07,200
Muitas vezes você quer, por exemplo, podemos

22474
14:51:07,200 --> 14:51:10,320
chamá-lo novamente e dizer que resultado é igual a

22475
14:51:10,320 --> 14:51:13,116
máximo usando duas variáveis que temos

22476
14:51:13,116 --> 14:51:15,040
Vamos dizer x e y

22477
14:51:15,040 --> 14:51:17,116
e ir para cima e declarar estes dois

22478
14:51:17,116 --> 14:51:19,276
variáveis por que não vamos dizer e

22479
14:51:19,276 --> 14:51:22,956
x e nós vamos colocar nele 22

22480
14:51:22,956 --> 14:51:26,080
e nós vamos dizer fim y e colocar em

22481
14:51:26,080 --> 14:51:27,916
a 44 neste momento

22482
14:51:27,916 --> 14:51:30,240
E agora, se imprimirmos o resultado, estamos

22483
14:51:30,240 --> 14:51:32,560
vai ter 44, porque esse é o

22484
14:51:32,560 --> 14:51:35,840
máximo que foi atribuído de volta ao nosso

22485
14:51:35,840 --> 14:51:38,480
variável de pesquisa aqui vamos soldar novamente

22486
14:51:38,480 --> 14:51:40,160
Vamos executar a tarefa de construir

22487
14:51:40,160 --> 14:51:42,720
com o Gcc

22488
14:51:42,720 --> 14:51:45,116
você pode limpar e correr o galo que você vê

22489
14:51:45,116 --> 14:51:47,916
O máximo é 44 e é assim que você pode

22490
14:51:47,916 --> 14:51:50,640
declarar e usar uma função máxima como

22491
14:51:50,640 --> 14:51:51,436
Isto é

22492
14:51:51,436 --> 14:51:52,956
nós vamos comentar isso porque

22493
14:51:52,956 --> 14:51:55,520
Temos mais algumas funções que queremos

22494
14:51:55,520 --> 14:51:58,000
Experimente vamos lá em cima e colocar em

22495
14:51:58,000 --> 14:52:00,320
Outra função e novamente notar que

22496
14:52:00,320 --> 14:52:02,796
Estamos declarando funções

22497
14:52:02,796 --> 14:52:05,276
antes da principal função aqui, este é um

22498
14:52:05,276 --> 14:52:07,680
exigência de um compilador c plus plus

22499
14:52:07,680 --> 14:52:10,720
porque antes de usar a função

22500
14:52:10,720 --> 14:52:13,360
A função deve ser declarada em algum lugar assim

22501
14:52:13,360 --> 14:52:16,080
Precisamos ir antes da função principal

22502
14:52:16,080 --> 14:52:18,560
e declarar nossas funções aqui o

22503
14:52:18,560 --> 14:52:20,320
A função que vamos fazer agora é dizer

22504
14:52:20,320 --> 14:52:22,320
Olá aqui não vai demorar

22505
14:52:22,320 --> 14:52:24,480
input e não vai nos dar nenhum

22506
14:52:24,480 --> 14:52:27,040
saída, só vai dizer olá e

22507
14:52:27,040 --> 14:52:29,756
morrermos, podemos descer e chamá-lo assim

22508
14:52:29,756 --> 14:52:32,160
vai ser super fácil chamar Olá

22509
14:52:32,160 --> 14:52:35,040
e nós vamos chamá-lo dizer olá ver

22510
14:52:35,040 --> 14:52:37,520
que mesmo o código do estúdio visual sabe sobre

22511
14:52:37,520 --> 14:52:39,840
Esta função podemos chamá-lo assim

22512
14:52:39,840 --> 14:52:41,596
vai ser ativado, então nós somos

22513
14:52:41,596 --> 14:52:43,040
Vai atingir o corpo da função

22514
14:52:43,040 --> 14:52:45,116
nós vamos dizer olá lá e

22515
14:52:45,116 --> 14:52:47,680
A função vai voltar ou morrer

22516
14:52:47,680 --> 14:52:49,520
Saiba que você pode omitir isso

22517
14:52:49,520 --> 14:52:51,680
declaração de retorno para funções que

22518
14:52:51,680 --> 14:52:54,080
voltar vazio, então se comentarmos esse cara

22519
14:52:54,080 --> 14:52:55,680
A função vai funcionar

22520
14:52:55,680 --> 14:52:57,840
igualmente bem você pode usar isso, no entanto

22521
14:52:57,840 --> 14:53:00,160
Você quer agora que vamos construir

22522
14:53:00,160 --> 14:53:03,840
com gcc e ver esta função correr

22523
14:53:03,840 --> 14:53:05,436
A construção é boa, vamos correr

22524
14:53:05,436 --> 14:53:08,320
Galo e está dizendo olá lá

22525
14:53:08,320 --> 14:53:10,796
Vamos descer e olhar para outro

22526
14:53:10,796 --> 14:53:12,080
O exemplo aqui

22527
14:53:12,080 --> 14:53:14,640
A próxima função vai ter sorte

22528
14:53:14,640 --> 14:53:17,116
número que não vai levar nenhuma entrada

22529
14:53:17,116 --> 14:53:19,276
mas vai nos dar uma saída em

22530
14:53:19,276 --> 14:53:22,080
a forma de um inteiro para que possamos chamá-lo

22531
14:53:22,080 --> 14:53:24,400
Vamos descer e comentar dizendo

22532
14:53:24,400 --> 14:53:27,116
Olá aqui e dizer que queremos ligar

22533
14:53:27,116 --> 14:53:28,400
Número da sorte

22534
14:53:28,400 --> 14:53:30,480
e nós podemos descer e configurar uma variável

22535
14:53:30,480 --> 14:53:32,400
Vamos fazer isso, vamos dizer ao int

22536
14:53:32,400 --> 14:53:33,680
O resultado

22537
14:53:33,680 --> 14:53:34,880
E nós

22538
14:53:34,880 --> 14:53:37,276
vai preparar a inicialização desse cara

22539
14:53:37,276 --> 14:53:39,596
então será inicializado para zero

22540
14:53:39,596 --> 14:53:42,796
e nós vamos dizer resultado

22541
14:53:42,796 --> 14:53:45,360
iguala o número da sorte e nós vamos

22542
14:53:45,360 --> 14:53:48,160
tomar o resultado retornado pela nossa sorte

22543
14:53:48,160 --> 14:53:50,880
função de número e atribuir isso ao

22544
14:53:50,880 --> 14:53:52,720
resultado variável e podemos imprimi-lo

22545
14:53:52,720 --> 14:53:56,000
se quisermos para que possamos dizer

22546
14:53:56,000 --> 14:53:59,116
Diga resultado

22547
14:53:59,116 --> 14:54:01,916
e nós vamos colocar isso aqui dizendo

22548
14:54:01,916 --> 14:54:04,480
O resultado

22549
14:54:05,360 --> 14:54:08,000
e se construímos e executamos este programa

22550
14:54:08,000 --> 14:54:10,320
nós vamos tirar esse cara impresso

22551
14:54:10,320 --> 14:54:12,796
Devemos ver um 99, porque é isso que

22552
14:54:12,796 --> 14:54:15,520
Estamos retornando de nossa função aqui

22553
14:54:15,520 --> 14:54:18,400
O resort é 99 como você vê no

22554
14:54:18,400 --> 14:54:20,720
saída aqui, então isso é realmente como você

22555
14:54:20,720 --> 14:54:22,480
pode declarar

22556
14:54:22,480 --> 14:54:24,560
suas funções uma função tem uma função única

22557
14:54:24,560 --> 14:54:26,796
assinatura, por exemplo, em bar aqui

22558
14:54:26,796 --> 14:54:28,956
Tem esse nome em particular

22559
14:54:28,956 --> 14:54:31,596
E esses parâmetros aqui

22560
14:54:31,596 --> 14:54:34,560
se você desce as esteiras tem seu próprio nome e

22561
14:54:34,560 --> 14:54:37,596
os parâmetros que ele recebe se você

22562
14:54:37,596 --> 14:54:40,080
ir para baixo dizer olá e o número da sorte são

22563
14:54:40,080 --> 14:54:42,796
diferente em seus próprios caminhos, se você tentar

22564
14:54:42,796 --> 14:54:44,956
e estabelecer uma outra função que tenha o

22565
14:54:44,956 --> 14:54:48,160
a mesma assinatura que max aqui o seu compilador

22566
14:54:48,160 --> 14:54:49,916
Vai passar fora, vamos tentar fazer

22567
14:54:49,916 --> 14:54:51,116
que vamos montar outro

22568
14:54:51,116 --> 14:54:52,796
Função vai ter um vazio

22569
14:54:52,796 --> 14:54:54,720
Tipo de retorno, vamos chamá-lo max

22570
14:54:54,720 --> 14:54:56,640
Porque queremos igualar esta assinatura

22571
14:54:56,640 --> 14:54:57,520
Aqui

22572
14:54:57,520 --> 14:54:58,956
E nós vamos dar dois

22573
14:54:58,956 --> 14:55:02,720
parâmetros em a e ele b

22574
14:55:02,720 --> 14:55:04,320
e nós podemos fazer o que quisermos nisso

22575
14:55:04,320 --> 14:55:06,080
aviso de função que temos um

22576
14:55:06,080 --> 14:55:09,360
linha se abrirmos nossa aba de problemas aqui

22577
14:55:09,360 --> 14:55:11,276
Você vai ver esse estúdio visual

22578
14:55:11,276 --> 14:55:13,200
O código tem alguns problemas com isso

22579
14:55:13,200 --> 14:55:16,320
porque estamos preparando uma função

22580
14:55:16,320 --> 14:55:19,116
com a mesma assinatura duas vezes, tente

22581
14:55:19,116 --> 14:55:21,200
e diferentes fazem disso uma rede e ver

22582
14:55:21,200 --> 14:55:23,436
O que temos agora, não parece que

22583
14:55:23,436 --> 14:55:25,680
Tenho um problema, mas se conseguirmos correr isso

22584
14:55:25,680 --> 14:55:28,720
Programa, vamos ter problemas

22585
14:55:28,720 --> 14:55:30,880
Vamos descer e realmente ativar o

22586
14:55:30,880 --> 14:55:33,040
código para chamar a função máxima para realmente

22587
14:55:33,040 --> 14:55:34,400
mostrar-lhe isso

22588
14:55:34,400 --> 14:55:36,480
Porque você precisa saber para que vamos

22589
14:55:36,480 --> 14:55:38,796
para comentar o número da sorte chamando e

22590
14:55:38,796 --> 14:55:41,040
nós queremos chamar max que nós vamos

22591
14:55:41,040 --> 14:55:43,520
ativar o código para chamar max

22592
14:55:43,520 --> 14:55:46,640
e nós vamos construir isso com gcc

22593
14:55:46,640 --> 14:55:48,240
notar o que vamos ver uh-huh nós

22594
14:55:48,240 --> 14:55:50,240
Temos problemas aqui que temos um compilador

22595
14:55:50,240 --> 14:55:53,436
erro dizendo re definição de int max

22596
14:55:53,436 --> 14:55:54,796
e formi

22597
14:55:54,796 --> 14:55:55,680
E a

22598
14:55:55,680 --> 14:55:58,720
alguém poderia pensar o que se eu nomear o meu

22599
14:55:58,720 --> 14:56:01,040
Parâmetros de forma diferente, por exemplo

22600
14:56:01,040 --> 14:56:02,796
Eu chamo esse cara

22601
14:56:02,796 --> 14:56:04,080
c - Em

22602
14:56:04,080 --> 14:56:06,400
E esse outro cara d

22603
14:56:06,400 --> 14:56:07,756
Vamos fazer isso

22604
14:56:07,756 --> 14:56:09,840
Usar nomes diferentes como este não é

22605
14:56:09,840 --> 14:56:11,756
vai resolver seus problemas porque se

22606
14:56:11,756 --> 14:56:14,240
nós tentamos e uh ousado novamente nós vamos

22607
14:56:14,240 --> 14:56:16,640
obter o mesmo erro do compilador este não é

22608
14:56:16,640 --> 14:56:18,560
vamos mudar sua coisa que não temos

22609
14:56:18,560 --> 14:56:20,880
ferramentas suficientes para realmente entender isso

22610
14:56:20,880 --> 14:56:23,520
problema, mas saiba que você não pode ter dois

22611
14:56:23,520 --> 14:56:24,720
Funções

22612
14:56:24,720 --> 14:56:27,276
Com a mesma assinatura em um

22613
14:56:27,276 --> 14:56:29,436
single c plus plus programa e nós somos

22614
14:56:29,436 --> 14:56:31,680
Vou aprender mais sobre isso depois, mas

22615
14:56:31,680 --> 14:56:34,400
Note que a assinatura de uma função

22616
14:56:34,400 --> 14:56:37,040
deve ser único em todo o seu

22617
14:56:37,040 --> 14:56:40,160
Todo o programa c-plus se você se lembrar

22618
14:56:40,160 --> 14:56:41,756
Esta regra simples que você não vai

22619
14:56:41,756 --> 14:56:44,560
ter muitos problemas, então vamos tentar e soldar

22620
14:56:44,560 --> 14:56:46,796
Mais uma vez para ter certeza de que não temos mais

22621
14:56:46,796 --> 14:56:48,480
Os problemas aqui dentro

22622
14:56:48,480 --> 14:56:50,796
o parafuso é bom e nós podemos correr o

22623
14:56:50,796 --> 14:56:53,276
programa para ver o máximo impresso

22624
14:56:53,276 --> 14:56:56,640
Então vamos fazer isso claro

22625
14:56:56,840 --> 14:57:00,796
Galo e max é 44 é exatamente o que

22626
14:57:00,796 --> 14:57:02,160
Esperamos que

22627
14:57:02,160 --> 14:57:04,080
A última coisa que quero fazer nisso

22628
14:57:04,080 --> 14:57:06,480
A palestra é torná-la super clara em sua

22629
14:57:06,480 --> 14:57:09,360
mente que o que passamos para funções

22630
14:57:09,360 --> 14:57:11,680
tem vindo a estabelecer-se até agora

22631
14:57:11,680 --> 14:57:15,596
são cópias, então vamos no topo e configurar

22632
14:57:15,596 --> 14:57:17,840
uma função simples que a função está indo

22633
14:57:17,840 --> 14:57:20,560
para incrementar e multiplicá-lo retorna a

22634
14:57:20,560 --> 14:57:22,956
O nome da função é duplo

22635
14:57:22,956 --> 14:57:25,200
incremente e multiplique e está indo

22636
14:57:25,200 --> 14:57:27,680
para tomar dois parâmetros e um duplo a

22637
14:57:27,680 --> 14:57:29,040
e um duplo b

22638
14:57:29,040 --> 14:57:30,956
Uma vez que atingimos o corpo da função

22639
14:57:30,956 --> 14:57:34,240
Vamos incrementar a e b

22640
14:57:34,240 --> 14:57:36,160
Os argumentos que foram passados para

22641
14:57:36,160 --> 14:57:38,000
Função e nós vamos multiplicar

22642
14:57:38,000 --> 14:57:39,756
Eles e nós vamos armazenar o resultado

22643
14:57:39,756 --> 14:57:42,720
de uma variável reservada:

22644
14:57:42,720 --> 14:57:44,240
A variável de resultado é o que vamos

22645
14:57:44,240 --> 14:57:46,560
Voltar para a função e quem quer que

22646
14:57:46,560 --> 14:57:48,320
chamado esta função vai usar

22647
14:57:48,320 --> 14:57:50,880
para fazer o que quiserem, nós

22648
14:57:50,880 --> 14:57:53,276
Quero ver que as mudanças

22649
14:57:53,276 --> 14:57:55,916
nós fazemos dentro da função não estão indo

22650
14:57:55,916 --> 14:57:59,360
ser visível para os argumentos que nós

22651
14:57:59,360 --> 14:58:01,680
passar para esta função aqui para realmente

22652
14:58:01,680 --> 14:58:04,240
Faça isso super claro, vamos entrar

22653
14:58:04,240 --> 14:58:06,160
principal e configurar algumas variáveis que somos

22654
14:58:06,160 --> 14:58:08,880
ter um duplo h e o duplo

22655
14:58:08,880 --> 14:58:11,116
Os valores serão três e

22656
14:58:11,116 --> 14:58:13,436
4 vamos imprimi-los e

22657
14:58:13,436 --> 14:58:15,276
Nós vamos chamar o nosso incremento

22658
14:58:15,276 --> 14:58:17,840
multiplicar o aviso de função que passamos h

22659
14:58:17,840 --> 14:58:18,956
E o i

22660
14:58:18,956 --> 14:58:21,116
para a função e o resultado do

22661
14:58:21,116 --> 14:58:24,320
A função vai ser armazenada em uh

22662
14:58:24,320 --> 14:58:27,200
anc mult resort variável aqui, mas a

22663
14:58:27,200 --> 14:58:29,116
O valor de retorno não é realmente importante

22664
14:58:29,116 --> 14:58:30,720
O que queremos ver

22665
14:58:30,720 --> 14:58:34,000
é se as mudanças que fazemos aos argumentos

22666
14:58:34,000 --> 14:58:36,080
Será visível no exterior

22667
14:58:36,080 --> 14:58:38,880
da função aqui, então lembre-se que temos

22668
14:58:38,880 --> 14:58:40,720
h e aqui vamos passá-los para o

22669
14:58:40,720 --> 14:58:42,956
Uma vez que atingimos o interior do

22670
14:58:42,956 --> 14:58:44,160
A função

22671
14:58:44,160 --> 14:58:46,796
Vamos incrementar a e b

22672
14:58:46,796 --> 14:58:48,320
e vamos voltar do

22673
14:58:48,320 --> 14:58:50,796
Função assim vamos ver

22674
14:58:50,796 --> 14:58:55,276
se foi um 3 e b que era um 4

22675
14:58:55,276 --> 14:58:57,840
foram incrementados para 4 e 5. que é

22676
14:58:57,840 --> 14:58:59,756
o que queremos ver, então vamos

22677
14:58:59,756 --> 14:59:02,796
ferva isso e execute isso, então vamos usar gcc

22678
14:59:02,796 --> 14:59:05,596
Para fazer isso, o volume vai ser bom

22679
14:59:05,596 --> 14:59:07,276
nós vamos limpar

22680
14:59:07,276 --> 14:59:09,116
e correr o galo

22681
14:59:09,116 --> 14:59:11,200
e perceber o que temos aqui vamos

22682
14:59:11,200 --> 14:59:14,160
para baixo e olhar para as variáveis novamente

22683
14:59:14,160 --> 14:59:18,480
nós configuramos h para conter um 3, então antes de

22684
14:59:18,480 --> 14:59:20,000
incremento h

22685
14:59:20,000 --> 14:59:22,320
E eu sou quatro

22686
14:59:22,320 --> 14:59:23,916
Tudo bem, então é isso que vamos imprimir

22687
14:59:23,916 --> 14:59:26,080
Aqui uma vez que batemos no interior do

22688
14:59:26,080 --> 14:59:27,040
A função

22689
14:59:27,040 --> 14:59:29,200
Nós vamos dizer o que temos dentro

22690
14:59:29,200 --> 14:59:31,200
a função antes de fazer a operação

22691
14:59:31,200 --> 14:59:33,916
antes do incremento novamente a e b são

22692
14:59:33,916 --> 14:59:36,640
quatro, então essas são cópias que temos dentro

22693
14:59:36,640 --> 14:59:37,916
nós vamos

22694
14:59:37,916 --> 14:59:40,160
fazer o incremento e depois que temos o

22695
14:59:40,160 --> 14:59:43,276
incrementa a e b serão quatro

22696
14:59:43,276 --> 14:59:45,200
Mas uma vez batemos no exterior do

22697
14:59:45,200 --> 14:59:47,040
A função

22698
14:59:47,040 --> 14:59:48,560
e uma impressão

22699
14:59:48,560 --> 14:59:50,320
com esse cara aqui, vamos ver

22700
14:59:50,320 --> 14:59:52,560
que h e i

22701
14:59:52,560 --> 14:59:55,040
Ainda são três e quatro, então

22702
14:59:55,040 --> 14:59:58,080
Nós realmente não afetamos h e eu quando nós

22703
14:59:58,080 --> 15:00:01,116
fez este incremento aqui o que afetamos

22704
15:00:01,116 --> 15:00:04,560
são cópias que foram passadas para a e b

22705
15:00:04,560 --> 15:00:05,360
Aqui

22706
15:00:05,360 --> 15:00:07,200
E isso é algo que você precisa saber

22707
15:00:07,200 --> 15:00:08,720
Porque algumas pessoas vão pensar que

22708
15:00:08,720 --> 15:00:10,560
Porque eu passo

22709
15:00:10,560 --> 15:00:14,796
h e eu na minha lista de argumentos aqui eu posso

22710
15:00:14,796 --> 15:00:16,880
manipular h e eu o que você é

22711
15:00:16,880 --> 15:00:19,596
manipular são cópias que foram feitas

22712
15:00:19,596 --> 15:00:22,640
pelo compilador para passar os argumentos para

22713
15:00:22,640 --> 15:00:24,560
A função aqui é algo que você

22714
15:00:24,560 --> 15:00:26,480
Precisamos ter em mente e vamos aprender

22715
15:00:26,480 --> 15:00:28,640
Mais sobre isso, mas eu queria que você

22716
15:00:28,640 --> 15:00:31,200
Aprenda isso em primeira mão e isso é realmente

22717
15:00:31,200 --> 15:00:33,200
Tudo o que nos prossamos fazer nesta palestra eu

22718
15:00:33,200 --> 15:00:35,276
Espero que você tenha uma melhor compreensão de

22719
15:00:35,276 --> 15:00:37,436
O que é uma função e o que você pode fazer

22720
15:00:37,436 --> 15:00:39,436
com ele em c plus plus vamos

22721
15:00:39,436 --> 15:00:41,360
parar aqui nesta palestra no próximo

22722
15:00:41,360 --> 15:00:43,040
Um que vamos aprender um pouco mais

22723
15:00:43,040 --> 15:00:45,916
sobre declarações de função e função

22724
15:00:45,916 --> 15:00:47,360
Definições

22725
15:00:47,360 --> 15:00:49,680
Vá em frente e termine aqui e me encontre

22726
15:00:49,680 --> 15:00:51,680
lá nesta palestra vamos

22727
15:00:51,680 --> 15:00:54,000
Saiba mais sobre declarações de função e

22728
15:00:54,000 --> 15:00:57,040
A função define a motivação para

22729
15:00:57,040 --> 15:00:58,720
O tópico que vamos falar

22730
15:00:58,720 --> 15:01:01,680
Sobre aqui é que às vezes você realmente

22731
15:01:01,680 --> 15:01:05,116
Quer separar um cabeçalho de função de

22732
15:01:05,116 --> 15:01:07,116
A sua implementação porque você não

22733
15:01:07,116 --> 15:01:10,080
Quero expor todos os detalhes sobre como

22734
15:01:10,080 --> 15:01:12,080
Você faz coisas, vamos olhar para o simples

22735
15:01:12,080 --> 15:01:14,560
Exemplo na última palestra que declaramos

22736
15:01:14,560 --> 15:01:16,480
uma função máxima que estava computando o

22737
15:01:16,480 --> 15:01:18,956
máximo entre dois números da saída

22738
15:01:18,956 --> 15:01:20,560
Era um inteiro, então é isso que nós

22739
15:01:20,560 --> 15:01:22,720
O nome da função foi

22740
15:01:22,720 --> 15:01:25,596
max e tivemos dois parâmetros em um e

22741
15:01:25,596 --> 15:01:27,756
E b mas o que fizemos no último

22742
15:01:27,756 --> 15:01:31,040
A palestra foi cortar toda a função

22743
15:01:31,040 --> 15:01:32,080
o corpo

22744
15:01:32,080 --> 15:01:34,400
na frente do principal, mas às vezes as pessoas

22745
15:01:34,400 --> 15:01:36,480
Não quero realmente ver os detalhes de

22746
15:01:36,480 --> 15:01:39,200
Como você faz coisas que eles só querem saber

22747
15:01:39,200 --> 15:01:41,276
Um resumo do que sua função faz

22748
15:01:41,276 --> 15:01:43,200
O que podemos tirar da função e

22749
15:01:43,200 --> 15:01:45,756
O que precisamos dar à função para

22750
15:01:45,756 --> 15:01:48,000
para fazer o seu trabalho e é isso que nós somos

22751
15:01:48,000 --> 15:01:49,916
indo ver nesta palestra se você olhar

22752
15:01:49,916 --> 15:01:52,560
Aqui nós temos a função header em

22753
15:01:52,560 --> 15:01:54,240
dianteira da função principal e da

22754
15:01:54,240 --> 15:01:56,796
function header é feito de seu retorno

22755
15:01:56,796 --> 15:01:59,116
digite o nome da função e

22756
15:01:59,116 --> 15:02:01,520
lista dos parâmetros e depois disso

22757
15:02:01,520 --> 15:02:03,520
nós vamos colocar um ponto e vírgula que é

22758
15:02:03,520 --> 15:02:06,956
chamado de cabeçalho de função ou um protótipo

22759
15:02:06,956 --> 15:02:09,116
Quando fazemos isso, o compilador é

22760
15:02:09,116 --> 15:02:10,880
Vou ser feliz e vai funcionar

22761
15:02:10,880 --> 15:02:13,596
Com a gente para compilar nosso programa, mas quando

22762
15:02:13,596 --> 15:02:16,400
Nós podemos vincular nosso programa para realmente colocar

22763
15:02:16,400 --> 15:02:18,956
em conjunto e fazer um binário o

22764
15:02:18,956 --> 15:02:20,640
A definição da função vai

22765
15:02:20,640 --> 15:02:23,116
ser necessário e se você cuidar do main

22766
15:02:23,116 --> 15:02:25,360
Aqui o que temos é uma função

22767
15:02:25,360 --> 15:02:27,596
Definição se você olhar de perto você vê

22768
15:02:27,596 --> 15:02:30,000
Que é exatamente a mesma coisa que tivemos

22769
15:02:30,000 --> 15:02:32,880
Na última palestra temos nosso cabeçalho

22770
15:02:32,880 --> 15:02:34,880
informação que não temos ponto e vírgula

22771
15:02:34,880 --> 15:02:37,916
após nossa lista de parâmetros, mas temos um

22772
15:02:37,916 --> 15:02:41,360
par de aparelhos encaracolados e dentro destes

22773
15:02:41,360 --> 15:02:44,400
Aparelhos encaracolados temos o nosso corpo

22774
15:02:44,400 --> 15:02:45,436
A função

22775
15:02:45,436 --> 15:02:46,480
E agora

22776
15:02:46,480 --> 15:02:48,320
É realmente fácil olhar para isso

22777
15:02:48,320 --> 15:02:50,480
programa porque não temos que olhar para

22778
15:02:50,480 --> 15:02:52,560
Todos esses detalhes sobre como isso

22779
15:02:52,560 --> 15:02:54,956
Função funciona que nós podemos obter

22780
15:02:54,956 --> 15:02:57,360
informações em primeira mão sobre como podemos usar

22781
15:02:57,360 --> 15:02:59,840
Esta função e que é o que mais

22782
15:02:59,840 --> 15:03:01,680
As pessoas vão estar interessadas em

22783
15:03:01,680 --> 15:03:03,680
sobre sua função, eles querem realmente

22784
15:03:03,680 --> 15:03:06,160
Quero entrar e ver como você faz coisas

22785
15:03:06,160 --> 15:03:08,320
eles vão querer usar sua função para

22786
15:03:08,320 --> 15:03:10,320
obter a saída e usá-lo para fazer o que

22787
15:03:10,320 --> 15:03:12,720
É que eles querem fazer se você olhar aqui

22788
15:03:12,720 --> 15:03:15,116
no corpo da função principal que temos

22789
15:03:15,116 --> 15:03:17,276
duas variáveis a e b e nós as usamos para

22790
15:03:17,276 --> 15:03:19,436
chamar a função máxima que nós podemos também

22791
15:03:19,436 --> 15:03:21,916
configurar uma função mínima que funciona em

22792
15:03:21,916 --> 15:03:24,560
A maneira semelhante e chamamos outro

22793
15:03:24,560 --> 15:03:26,480
Função chamada incremento que está indo

22794
15:03:26,480 --> 15:03:28,796
incrementar e multiplicar qualquer coisa

22795
15:03:28,796 --> 15:03:31,040
argumentos que passamos para esta função assim

22796
15:03:31,040 --> 15:03:33,520
A ideia principal aqui é que podemos dividir

22797
15:03:33,520 --> 15:03:36,400
nossa função em duas partes um está indo

22798
15:03:36,400 --> 15:03:37,840
ser o cabeçalho da função que é

22799
15:03:37,840 --> 15:03:39,040
Realmente vai ser a função

22800
15:03:39,040 --> 15:03:41,756
A declaração e o outro vai ser

22801
15:03:41,756 --> 15:03:44,400
O corpo da função com todos os detalhes

22802
15:03:44,400 --> 15:03:46,160
sobre como a função funciona e isso é

22803
15:03:46,160 --> 15:03:48,640
vai ser a nossa definição de função e

22804
15:03:48,640 --> 15:03:50,560
Uma vez que temos essas duas coisas no lugar

22805
15:03:50,560 --> 15:03:52,400
Podemos chamar a função em nossa principal

22806
15:03:52,400 --> 15:03:54,320
Funcionar e fazer o que quisermos

22807
15:03:54,320 --> 15:03:56,640
que tudo bem agora deve ser super claro

22808
15:03:56,640 --> 15:03:59,040
Podemos separar nossa função em dois

22809
15:03:59,040 --> 15:04:01,680
declaração e definição das peças e

22810
15:04:01,680 --> 15:04:03,756
às vezes a parte da declaração também é

22811
15:04:03,756 --> 15:04:05,916
chamado de protótipo que é um protótipo de

22812
15:04:05,916 --> 15:04:08,160
uma função e é composta de

22813
15:04:08,160 --> 15:04:09,520
Tipo de retorno

22814
15:04:09,520 --> 15:04:11,756
juntamente com o nome da função juntos

22815
15:04:11,756 --> 15:04:13,520
com os parâmetros e depois disso

22816
15:04:13,520 --> 15:04:15,596
você vai adicionar um ponto-e-vírgula para fazer

22817
15:04:15,596 --> 15:04:18,956
ele válido c mais sintaxe e outra coisa

22818
15:04:18,956 --> 15:04:21,200
Você deve saber que o protótipo

22819
15:04:21,200 --> 15:04:24,000
precisa vir antes onde quer que esteja

22820
15:04:24,000 --> 15:04:25,756
Liguei se você está tentando chamar um

22821
15:04:25,756 --> 15:04:29,276
função antes de seu protótipo ser visto em

22822
15:04:29,276 --> 15:04:31,680
Seu c plus mais programa que você está indo para

22823
15:04:31,680 --> 15:04:33,756
obter um erro de compilador e agora você pode

22824
15:04:33,756 --> 15:04:37,276
estar perguntando, mas por que nossos programas fizeram em

22825
15:04:37,276 --> 15:04:39,840
O último trabalho de palestra que não dividimos

22826
15:04:39,840 --> 15:04:42,400
as coisas e nosso programa estava funcionando

22827
15:04:42,400 --> 15:04:43,276
multa fina

22828
15:04:43,276 --> 15:04:44,080
Bem

22829
15:04:44,080 --> 15:04:46,640
se você colocar uma definição de função em

22830
15:04:46,640 --> 15:04:49,116
dianteira da função principal que funciona

22831
15:04:49,116 --> 15:04:51,436
A definição também vai dobrar como a

22832
15:04:51,436 --> 15:04:54,160
declaração de função que é por isso que o código

22833
15:04:54,160 --> 15:04:56,796
Na última palestra funcionou bem agora que

22834
15:04:56,796 --> 15:04:58,880
Você tem uma ideia sobre o que é uma função

22835
15:04:58,880 --> 15:05:01,040
declaração e definição de função

22836
15:05:01,040 --> 15:05:03,520
é vamos para o código do estúdio visual

22837
15:05:03,520 --> 15:05:06,560
e brincar conosco ok aqui estamos em nosso

22838
15:05:06,560 --> 15:05:08,796
pasta de trabalho o projeto atual é

22839
15:05:08,796 --> 15:05:11,680
declarações de função e definições que nós

22840
15:05:11,680 --> 15:05:14,000
eles vão pegar nossos arquivos de modelos

22841
15:05:14,000 --> 15:05:16,160
Como sempre fazemos

22842
15:05:16,160 --> 15:05:18,480
nós vamos colocá-los no lugar

22843
15:05:18,480 --> 15:05:20,796
e nós vamos abrir esse cara em

22844
15:05:20,796 --> 15:05:24,000
Código de estúdio visual vamos fazer isso

22845
15:05:24,000 --> 15:05:25,756
nós abrimos isso

22846
15:05:25,756 --> 15:05:28,560
e nós vamos abrir nosso principal cpp

22847
15:05:28,560 --> 15:05:31,840
arquivo limpa um pouco e vamos

22848
15:05:31,840 --> 15:05:33,680
Feche este painel para que tenhamos alguns

22849
15:05:33,680 --> 15:05:35,360
Espaço Respirar a primeira coisa que somos

22850
15:05:35,360 --> 15:05:37,596
indo fazer é configurar uma função máxima

22851
15:05:37,596 --> 15:05:39,116
Você já sabe como fazer isso

22852
15:05:39,116 --> 15:05:41,360
indo para especificar o tipo de retorno

22853
15:05:41,360 --> 15:05:43,200
Vamos especificar a função

22854
15:05:43,200 --> 15:05:44,956
Nome e os parâmetros para os quais vamos

22855
15:05:44,956 --> 15:05:47,756
tomar nele a e em b e nós estamos indo

22856
15:05:47,756 --> 15:05:50,000
para entrar e fazer o que precisarmos

22857
15:05:50,000 --> 15:05:52,000
calcular o máximo entre estes dois

22858
15:05:52,000 --> 15:05:54,560
Caras nós vamos dizer se um é maior

22859
15:05:54,560 --> 15:05:55,596
do que b

22860
15:05:55,596 --> 15:05:56,480
Em seguida,

22861
15:05:56,480 --> 15:05:59,040
a deve ser o máximo, então vamos

22862
15:05:59,040 --> 15:06:00,480
Retorne isso

22863
15:06:00,480 --> 15:06:03,436
Mais como vamos voltar

22864
15:06:03,436 --> 15:06:04,796
b

22865
15:06:04,796 --> 15:06:06,720
Tudo bem, esta é a função e é

22866
15:06:06,720 --> 15:06:09,116
Realmente simples podemos ir para baixo no principal e

22867
15:06:09,116 --> 15:06:11,756
Use-o assim digamos formiga

22868
15:06:11,756 --> 15:06:14,880
x e eu colocar em um cinco, por exemplo

22869
15:06:14,880 --> 15:06:16,480
E vamos dizer que

22870
15:06:16,480 --> 15:06:20,480
y e colocar em dois ou três colocados

22871
15:06:20,480 --> 15:06:21,680
O que você quiser

22872
15:06:21,680 --> 15:06:24,240
e então nós vamos configurar o

22873
15:06:24,240 --> 15:06:25,840
variável de pesquisa

22874
15:06:25,840 --> 15:06:27,756
que vai pegar o máximo de i

22875
15:06:27,756 --> 15:06:29,756
Acho que podemos fazer isso e o que somos

22876
15:06:29,756 --> 15:06:32,080
indo para atribuir a isso é tudo o que é

22877
15:06:32,080 --> 15:06:34,400
retornado de nossa chamada de função, então nós somos

22878
15:06:34,400 --> 15:06:36,480
Vou chamar essa função com x e y

22879
15:06:36,480 --> 15:06:37,840
Vamos calcular o

22880
15:06:37,840 --> 15:06:39,360
O máximo entre

22881
15:06:39,360 --> 15:06:42,000
5 e 2 aqui o máximo será

22882
15:06:42,000 --> 15:06:44,320
armazenado nesta variável de resultado e

22883
15:06:44,320 --> 15:06:45,916
vamos imprimi-lo para que vamos

22884
15:06:45,916 --> 15:06:47,680
Diga std

22885
15:06:47,680 --> 15:06:50,880
ver fora e eu vou dizer max

22886
15:06:50,880 --> 15:06:54,720
Como resultado, isso vai fazer

22887
15:06:54,720 --> 15:06:57,116
OK, vamos tentar construir isso e fazer

22888
15:06:57,116 --> 15:06:59,276
Certamente que realmente funciona

22889
15:06:59,276 --> 15:07:01,520
Isso não é novidade até agora

22890
15:07:01,520 --> 15:07:03,596
Tudo o que fizemos no último

22891
15:07:03,596 --> 15:07:05,596
A palestra

22892
15:07:05,596 --> 15:07:08,000
Agora o mundo é bom, podemos limpar e

22893
15:07:08,000 --> 15:07:09,680
correr galo, vamos pegar o

22894
15:07:09,680 --> 15:07:12,080
máximo como um cinco aqui e se tentarmos

22895
15:07:12,080 --> 15:07:15,116
Mudar essas coisas, por exemplo, fazer y 12

22896
15:07:15,116 --> 15:07:16,796
E o mundo novamente

22897
15:07:16,796 --> 15:07:19,276
nós vamos usar gcc

22898
15:07:19,276 --> 15:07:21,520
e nós vamos limpar esses agradecimentos

22899
15:07:21,520 --> 15:07:24,240
e correr galo, devemos obter max equals

22900
15:07:24,240 --> 15:07:25,276
12.

22901
15:07:25,276 --> 15:07:28,880
tudo isso é tudo bem e dandy, mas às vezes

22902
15:07:28,880 --> 15:07:31,756
nós realmente não queremos ter os detalhes

22903
15:07:31,756 --> 15:07:35,116
sobre como nossa função funciona mostrada em

22904
15:07:35,116 --> 15:07:37,596
diante da função principal aqui e nós

22905
15:07:37,596 --> 15:07:40,480
pode dividir nossa função em duas partes

22906
15:07:40,480 --> 15:07:43,040
Declaração e uma definição de

22907
15:07:43,040 --> 15:07:44,720
A declaração será realmente a

22908
15:07:44,720 --> 15:07:47,040
cabeçalho parte da função e isso é

22909
15:07:47,040 --> 15:07:49,040
Vai ser o valor de retorno do nome de

22910
15:07:49,040 --> 15:07:51,680
A função e a lista de parâmetros, mas

22911
15:07:51,680 --> 15:07:54,240
para torná-lo uma declaração válida que temos

22912
15:07:54,240 --> 15:07:56,956
para colocar um ponto-vírgula depois disso, então este é

22913
15:07:56,956 --> 15:07:58,320
a nossa função

22914
15:07:58,320 --> 15:07:59,756
Declaração de

22915
15:07:59,756 --> 15:08:04,320
às vezes também é chamado de protótipo

22916
15:08:04,480 --> 15:08:06,320
e, por favor, certifique-se de que você entende o

22917
15:08:06,320 --> 15:08:09,040
A diferença entre um protótipo e um

22918
15:08:09,040 --> 15:08:11,276
assinatura na última palestra que vimos

22919
15:08:11,276 --> 15:08:14,320
que a assinatura foi feita apenas da

22920
15:08:14,320 --> 15:08:16,400
Nome da função e do parâmetro

22921
15:08:16,400 --> 15:08:20,000
lista, mas o valor de retorno não fazia parte

22922
15:08:20,000 --> 15:08:21,916
da assinatura da função, mas da

22923
15:08:21,916 --> 15:08:24,560
O protótipo inclui todos esses caras, então

22924
15:08:24,560 --> 15:08:27,756
A assinatura não inclui

22925
15:08:27,756 --> 15:08:30,160
Tipo de retorno

22926
15:08:30,160 --> 15:08:32,880
Tudo bem agora que temos nossa função

22927
15:08:32,880 --> 15:08:36,880
configuração de declaração que precisamos colocar

22928
15:08:36,880 --> 15:08:38,956
uma definição de função porque se você tentar

22929
15:08:38,956 --> 15:08:42,080
para compilar este programa e vinculá-lo

22930
15:08:42,080 --> 15:08:44,480
Você vai ter problemas, vamos tentar

22931
15:08:44,480 --> 15:08:45,840
e fazer isso antes de colocar no

22932
15:08:45,840 --> 15:08:47,040
A definição

22933
15:08:47,040 --> 15:08:49,840
nós podemos soldar com gcc nós estamos aprendendo assim

22934
15:08:49,840 --> 15:08:50,956
nós não o fazemos.

22935
15:08:50,956 --> 15:08:52,880
Tenho que temer quebrar as coisas um pouco

22936
15:08:52,880 --> 15:08:53,840
Um pouco

22937
15:08:53,840 --> 15:08:58,400
Vamos limpar e tentar construir com gcc

22938
15:08:58,400 --> 15:09:00,640
e você vai ver ah, nós temos um

22939
15:09:00,640 --> 15:09:03,116
problema aqui e que tipo de problema nós

22940
15:09:03,116 --> 15:09:05,756
ter o compilador c plus plus que está indo

22941
15:09:05,756 --> 15:09:08,720
para compilar este programa, mas quando atingimos

22942
15:09:08,720 --> 15:09:10,320
o estágio do link

22943
15:09:10,320 --> 15:09:12,240
Eu percebo que eu realmente não falei sobre

22944
15:09:12,240 --> 15:09:14,640
Isso em mais detalhes, mas faremos em

22945
15:09:14,640 --> 15:09:17,596
Esta palestra, mas o principal problema aqui

22946
15:09:17,596 --> 15:09:20,000
É que não temos a definição de

22947
15:09:20,000 --> 15:09:22,720
Esta função no lugar e o compilador

22948
15:09:22,720 --> 15:09:24,480
vai procurá-lo e não encontrar

22949
15:09:24,480 --> 15:09:26,720
Isso e você vê que está dizendo

22950
15:09:26,720 --> 15:09:29,276
Referência indefinida ao max

22951
15:09:29,276 --> 15:09:31,916
Tudo bem para que tenha visto a declaração de

22952
15:09:31,916 --> 15:09:33,116
a função

22953
15:09:33,116 --> 15:09:35,596
Mas não sabe como funciona

22954
15:09:35,596 --> 15:09:37,360
faz o seu trabalho porque nós não temos um

22955
15:09:37,360 --> 15:09:39,916
função do corpo aqui para realmente fazer

22956
15:09:39,916 --> 15:09:42,796
Este código funciona exatamente como queremos

22957
15:09:42,796 --> 15:09:45,040
precisa colocar em uma definição e a

22958
15:09:45,040 --> 15:09:47,276
A definição pode aparecer em qualquer lugar em seu lugar

22959
15:09:47,276 --> 15:09:49,436
c plus programa neste caso, estamos

22960
15:09:49,436 --> 15:09:50,796
Vou colocar isso

22961
15:09:50,796 --> 15:09:52,956
Depois da função principal e da

22962
15:09:52,956 --> 15:09:55,040
A definição é realmente

22963
15:09:55,040 --> 15:09:57,756
o que temos usado até onde

22964
15:09:57,756 --> 15:10:00,080
Definição de função na última palestra

22965
15:10:00,080 --> 15:10:02,640
Mas note que ele tem o corpo

22966
15:10:02,640 --> 15:10:05,680
Informações e agora quando é o compilador

22967
15:10:05,680 --> 15:10:08,400
Tenta compilar este programa que ele irá

22968
15:10:08,400 --> 15:10:11,200
Saiba como é a função máxima

22969
15:10:11,200 --> 15:10:13,436
calcular o seu máximo porque temos

22970
15:10:13,436 --> 15:10:15,436
todas essas informações aqui, então vamos

22971
15:10:15,436 --> 15:10:17,680
Diga que esta é a nossa definição de função

22972
15:10:17,680 --> 15:10:21,200
e aparece após o principal neste caso e

22973
15:10:21,200 --> 15:10:23,916
Podemos tentar construir isso e ver se o

22974
15:10:23,916 --> 15:10:25,756
O trabalho é bom agora que você vê que o mundo é

22975
15:10:25,756 --> 15:10:26,560
Bom

22976
15:10:26,560 --> 15:10:29,116
E se tentarmos executá-lo, vamos

22977
15:10:29,116 --> 15:10:32,160
obter o nosso máximo exatamente como fizemos quando

22978
15:10:32,160 --> 15:10:33,360
que tínhamos

22979
15:10:33,360 --> 15:10:35,840
A declaração e a definição

22980
15:10:35,840 --> 15:10:38,160
Apertado antes do principal aqui, mas

22981
15:10:38,160 --> 15:10:39,916
Espero que agora você possa ver que

22982
15:10:39,916 --> 15:10:42,480
O programa é muito mais limpo, porque quando você

22983
15:10:42,480 --> 15:10:44,640
Olhe para isso você sabe que nós temos um

22984
15:10:44,640 --> 15:10:46,640
Função chamada max que vai levar

22985
15:10:46,640 --> 15:10:48,720
Dois parâmetros vai voltar

22986
15:10:48,720 --> 15:10:51,200
Algo e é chamado de tapetes, então

22987
15:10:51,200 --> 15:10:53,200
Deve estar calculando o máximo destes

22988
15:10:53,200 --> 15:10:56,240
Dois caras, mas nós realmente não nos importamos como

22989
15:10:56,240 --> 15:10:58,080
Esta função faz o seu trabalho como

22990
15:10:58,080 --> 15:11:00,240
calcula o máximo aqui e isso é

22991
15:11:00,240 --> 15:11:02,720
A mensagem principal aqui podemos dividir um

22992
15:11:02,720 --> 15:11:05,840
função em duas partes uma declaração e

22993
15:11:05,840 --> 15:11:08,400
Uma definição é bom apenas para brincar ao redor

22994
15:11:08,400 --> 15:11:11,040
também pode configurar uma função mínima

22995
15:11:11,040 --> 15:11:13,360
Antes de fazermos isso, vamos configurar

22996
15:11:13,360 --> 15:11:15,680
Definição aqui em baixo nós vamos apenas para

22997
15:11:15,680 --> 15:11:18,320
copiar o máximo e adaptá-lo

22998
15:11:18,320 --> 15:11:20,640
nós vamos colocar uma cópia desse cara

22999
15:11:20,640 --> 15:11:23,916
Aqui vamos chamar isso de homens

23000
15:11:23,916 --> 15:11:25,596
vai levar dois parâmetros que é

23001
15:11:25,596 --> 15:11:27,916
Vou voltar um fim, mas o que nós testamos

23002
15:11:27,916 --> 15:11:31,276
pois é se a é menos que b se um é menos

23003
15:11:31,276 --> 15:11:33,756
do que b então a é um mínimo

23004
15:11:33,756 --> 15:11:36,796
se a não é menor que b então b deve ser

23005
15:11:36,796 --> 15:11:38,796
nosso mínimo e podemos colocar o

23006
15:11:38,796 --> 15:11:40,880
declaração desta função no topo aqui

23007
15:11:40,880 --> 15:11:43,520
Então vamos lá e dizer homens

23008
15:11:43,520 --> 15:11:47,040
e dizer fim a e o fim b

23009
15:11:47,040 --> 15:11:48,880
e agora podemos mudar a chamada aqui para

23010
15:11:48,880 --> 15:11:50,880
Diga mau e vai calcular o

23011
15:11:50,880 --> 15:11:53,276
No mínimo por que não vamos fazer isso nós

23012
15:11:53,276 --> 15:11:55,200
vamos dizer min aqui e nós vamos

23013
15:11:55,200 --> 15:11:57,596
agarrar tudo o que é o mínimo entre x

23014
15:11:57,596 --> 15:11:59,116
E e e é isso que estamos indo

23015
15:11:59,116 --> 15:12:01,840
para ter nesta variável de resultado aqui

23016
15:12:01,840 --> 15:12:04,080
Vamos fazer isso, vamos tentar usar

23017
15:12:04,080 --> 15:12:05,596
Isto é

23018
15:12:05,596 --> 15:12:07,360
A construção é boa

23019
15:12:07,360 --> 15:12:09,520
Então nós vamos limpar e correr o galo

23020
15:12:09,520 --> 15:12:11,756
Agora o mínimo é cinco que estamos chamando

23021
15:12:11,756 --> 15:12:13,596
a nossa função mínima

23022
15:12:13,596 --> 15:12:15,680
Na última palestra também estabelecemos uma

23023
15:12:15,680 --> 15:12:17,916
Função para incrementar e multiplicar

23024
15:12:17,916 --> 15:12:19,756
Tente fazer a mesma coisa

23025
15:12:19,756 --> 15:12:22,560
mas dividindo isso em uma declaração e

23026
15:12:22,560 --> 15:12:24,320
A definição apenas para praticar um pouco

23027
15:12:24,320 --> 15:12:26,956
Mais vamos chamar isso e

23028
15:12:26,956 --> 15:12:30,400
malte e vai levar um e b entrar

23029
15:12:30,400 --> 15:12:32,796
E dentro e não vamos colocar

23030
15:12:32,796 --> 15:12:34,796
O corpo no topo aqui vamos colocar

23031
15:12:34,796 --> 15:12:37,520
o corpo para baixo com as outras definições

23032
15:12:37,520 --> 15:12:39,436
que temos para todos esses outros

23033
15:12:39,436 --> 15:12:42,080
funções para max e significa aqui, então nós somos

23034
15:12:42,080 --> 15:12:43,596
indo para colocar em nosso corpo é realmente

23035
15:12:43,596 --> 15:12:45,680
Simples para que vamos colocar um corpo

23036
15:12:45,680 --> 15:12:48,080
dentro deste cintas encaracolados

23037
15:12:48,080 --> 15:12:50,560
E nós vamos voltar

23038
15:12:50,560 --> 15:12:51,840
Plus a

23039
15:12:51,840 --> 15:12:53,840
nós vamos incrementar a

23040
15:12:53,840 --> 15:12:56,560
e nós vamos multiplicar isso com um

23041
15:12:56,560 --> 15:12:58,240
incremento de b

23042
15:12:58,240 --> 15:13:00,000
e nós vamos voltar que eu acho

23043
15:13:00,000 --> 15:13:01,916
isso vai ser válido c plus plus

23044
15:13:01,916 --> 15:13:04,160
sintaxe e se tentarmos chamar isso

23045
15:13:04,160 --> 15:13:06,560
função em main vamos fazer isso dizer em

23046
15:13:06,560 --> 15:13:09,360
mult e vamos passar um x e y

23047
15:13:09,360 --> 15:13:11,596
O programa vai funcionar bem

23048
15:13:11,596 --> 15:13:14,560
Vamos pegar o resultado e armazenar

23049
15:13:14,560 --> 15:13:15,360
que

23050
15:13:15,360 --> 15:13:18,640
em nossa variável vamos fazer isso

23051
15:13:18,640 --> 15:13:21,040
e nós podemos imprimir o resultado

23052
15:13:21,040 --> 15:13:23,680
e vamos dizer resultado aqui

23053
15:13:23,680 --> 15:13:25,840
Vai fazer

23054
15:13:25,840 --> 15:13:28,240
e se construímos e executamos este programa

23055
15:13:28,240 --> 15:13:30,080
nós vamos ver a saída aqui vamos

23056
15:13:30,080 --> 15:13:33,200
Veja o que nós temos

23057
15:13:33,200 --> 15:13:36,080
Os resultados serão 78, porque se

23058
15:13:36,080 --> 15:13:38,956
incrementamos um 5 que se torna um 6.

23059
15:13:38,956 --> 15:13:42,080
Se incrementarmos y nós vamos ter 13

23060
15:13:42,080 --> 15:13:46,160
13 vezes 6 deve ser 78, vamos ter certeza

23061
15:13:46,160 --> 15:13:48,720
nós vamos trazer a calculadora

23062
15:13:48,720 --> 15:13:51,116
Vamos fazer isso para que você saiba que eu sou

23063
15:13:51,116 --> 15:13:54,000
não fazer essas coisas crescerem 78.

23064
15:13:54,000 --> 15:13:56,720
O programa está realmente funcionando como deveria

23065
15:13:56,720 --> 15:13:58,640
Esta é a principal mensagem aqui que podemos

23066
15:13:58,640 --> 15:14:00,796
Dividindo funções em um

23067
15:14:00,796 --> 15:14:02,320
Declaração de

23068
15:14:02,320 --> 15:14:04,640
e uma definição e isso vai

23069
15:14:04,640 --> 15:14:07,116
tornar nossos programas muito mais fáceis de trabalhar

23070
15:14:07,116 --> 15:14:08,796
com e ler

23071
15:14:08,796 --> 15:14:10,720
Uma coisa que você deve saber é que o

23072
15:14:10,720 --> 15:14:13,276
Nomes das variáveis não são realmente

23073
15:14:13,276 --> 15:14:15,756
importante em declarações de função como

23074
15:14:15,756 --> 15:14:16,560
Isto é

23075
15:14:16,560 --> 15:14:18,880
Por exemplo, podemos tirar o a e

23076
15:14:18,880 --> 15:14:19,916
b aqui

23077
15:14:19,916 --> 15:14:22,240
ou podemos tirar toda a variável

23078
15:14:22,240 --> 15:14:25,436
nomes em nossas declarações de função

23079
15:14:25,436 --> 15:14:27,276
- Faz isso.

23080
15:14:27,276 --> 15:14:29,360
e você pode pensar que este programa

23081
15:14:29,360 --> 15:14:32,320
Vou compilar bem eu odeio quebrá-lo

23082
15:14:32,320 --> 15:14:34,720
para você, mas ele vai compilar assim

23083
15:14:34,720 --> 15:14:37,200
Vamos soldar com gcc

23084
15:14:37,200 --> 15:14:38,560
você vai ver que ambos estão

23085
15:14:38,560 --> 15:14:41,916
Bom, então a função header ou

23086
15:14:41,916 --> 15:14:44,560
A declaração realmente não se importa com

23087
15:14:44,560 --> 15:14:46,080
os nomes das variáveis

23088
15:14:46,080 --> 15:14:48,240
nas definições que nos preocupamos com estas

23089
15:14:48,240 --> 15:14:50,240
nomes de variáveis porque vamos

23090
15:14:50,240 --> 15:14:52,880
estar usando-os nos corpos, mas se você

23091
15:14:52,880 --> 15:14:55,040
Quer que você possa deixá-los de fora em seu

23092
15:14:55,040 --> 15:14:58,720
declarações de função, mas eu gosto de manter

23093
15:14:58,720 --> 15:15:00,880
eles no lugar porque eu gosto do meu

23094
15:15:00,880 --> 15:15:03,360
funções a serem auto-documentadas se

23095
15:15:03,360 --> 15:15:05,360
Alguém olha para isso que eles vão saber

23096
15:15:05,360 --> 15:15:07,756
o nome da variável aqui, mas se você realmente

23097
15:15:07,756 --> 15:15:09,596
Você pode deixar os nomes das variáveis

23098
15:15:09,596 --> 15:15:12,320
fora e vai funcionar muito bem

23099
15:15:12,320 --> 15:15:13,840
Isso é sempre o suficiente para fazer em

23100
15:15:13,840 --> 15:15:15,200
Esta palestra espero que você a tenha encontrado

23101
15:15:15,200 --> 15:15:17,436
interessante, vamos parar por aqui

23102
15:15:17,436 --> 15:15:19,276
Esta palestra no próximo somos

23103
15:15:19,276 --> 15:15:20,956
Vamos ver como podemos dividir o nosso

23104
15:15:20,956 --> 15:15:24,000
programas em vários arquivos agora que nós

23105
15:15:24,000 --> 15:15:26,160
Saiba como dividir em declaração e

23106
15:15:26,160 --> 15:15:27,436
A definição

23107
15:15:27,436 --> 15:15:29,756
Vá em frente e termine aqui e me encontre

23108
15:15:29,756 --> 15:15:31,436
lá

23109
15:15:31,436 --> 15:15:33,680
Nesta palestra vamos revisitar

23110
15:15:33,680 --> 15:15:36,080
nossa compilação c plus plus

23111
15:15:36,080 --> 15:15:38,720
modelo ao longo do caminho, também vamos

23112
15:15:38,720 --> 15:15:40,880
Veja como podemos trabalhar com funções

23113
15:15:40,880 --> 15:15:43,040
através de vários arquivos

23114
15:15:43,040 --> 15:15:45,436
se você se lembrar do nosso modelo de compilação

23115
15:15:45,436 --> 15:15:47,520
Ele parecia algo assim que você viu

23116
15:15:47,520 --> 15:15:50,796
Este deslizar muitas vezes até agora o que é

23117
15:15:50,796 --> 15:15:53,040
Descreve o que acontece quando

23118
15:15:53,040 --> 15:15:55,520
compile nosso programa no momento em que executamos

23119
15:15:55,520 --> 15:15:58,400
O comando da compilação nosso c plus

23120
15:15:58,400 --> 15:16:01,040
programa que vive no arquivo cpp principal

23121
15:16:01,040 --> 15:16:03,360
Agora vai ser passado através do

23122
15:16:03,360 --> 15:16:05,276
compilador que o compilador vai

23123
15:16:05,276 --> 15:16:07,200
Processá-lo e ele vai subir

23124
15:16:07,200 --> 15:16:10,000
com um executável binário que é principalmente

23125
15:16:10,000 --> 15:16:12,320
chamado galo neste curso e quando

23126
15:16:12,320 --> 15:16:15,276
executamos este arquivo de galo ou binário

23127
15:16:15,276 --> 15:16:17,520
file, vamos obter o programa para

23128
15:16:17,520 --> 15:16:20,080
executar o programa vai ser executado

23129
15:16:20,080 --> 15:16:22,240
instrução por instrução quando é

23130
15:16:22,240 --> 15:16:24,956
carregado pelo sistema operacional e nós

23131
15:16:24,956 --> 15:16:26,796
em sua maioria, vai ver a saída de

23132
15:16:26,796 --> 15:16:29,040
aquele programa no terminal neste

23133
15:16:29,040 --> 15:16:31,596
Este é o modelo de compilação que nós

23134
15:16:31,596 --> 15:16:35,116
Saiba, mas agora o que queremos fazer é zoom

23135
15:16:35,116 --> 15:16:38,320
em esta compilação parte aqui e ver

23136
15:16:38,320 --> 15:16:40,956
O que realmente acontece sob o capô

23137
15:16:40,956 --> 15:16:43,276
Vamos supor que temos um

23138
15:16:43,276 --> 15:16:46,240
Programa que é feito de muita fonte

23139
15:16:46,240 --> 15:16:48,560
Arquivos como temos aqui na esquerda

23140
15:16:48,560 --> 15:16:51,360
Suponha que temos duas três ou cinco fontes

23141
15:16:51,360 --> 15:16:54,160
Arquivos diferentes do que temos até agora, que

23142
15:16:54,160 --> 15:16:57,040
é um arquivo o arquivo principal cpp quando você

23143
15:16:57,040 --> 15:16:58,796
compile um programa que você vai

23144
15:16:58,796 --> 15:17:00,840
passar por uma etapa chamada

23145
15:17:00,840 --> 15:17:03,360
pré-processamento e o que isso vai fazer

23146
15:17:03,360 --> 15:17:04,160
- É assim.

23147
15:17:04,160 --> 15:17:07,040
vai procurar a sua inclusão

23148
15:17:07,040 --> 15:17:08,160
Declaração

23149
15:17:08,160 --> 15:17:10,400
e vai levar qualquer arquivo

23150
15:17:10,400 --> 15:17:12,880
Você está incluindo e ele vai

23151
15:17:12,880 --> 15:17:15,436
colar isso no lugar, por exemplo, aqui

23152
15:17:15,436 --> 15:17:18,160
você vê que temos um io stream include

23153
15:17:18,160 --> 15:17:19,360
Declaração

23154
15:17:19,360 --> 15:17:23,436
quando o estágio de pré-processamento é executado

23155
15:17:23,436 --> 15:17:25,756
Isso inclui declaração será

23156
15:17:25,756 --> 15:17:28,880
substituído por tudo o que temos nesta

23157
15:17:28,880 --> 15:17:32,160
io stream file aqui, então isso está indo para

23158
15:17:32,160 --> 15:17:34,240
ser eliminado e vamos colocar

23159
15:17:34,240 --> 15:17:38,240
o conteúdo que temos no io stream em

23160
15:17:38,240 --> 15:17:40,320
Este exato lugar onde temos o

23161
15:17:40,320 --> 15:17:42,956
include declaração, espero que isso seja claro

23162
15:17:42,956 --> 15:17:45,040
assim, quando passamos pelo pré-processamento

23163
15:17:45,040 --> 15:17:46,796
nós vamos ter

23164
15:17:46,796 --> 15:17:49,520
uma versão dos nossos arquivos de origem

23165
15:17:49,520 --> 15:17:52,720
com as peças incluídas colocadas em nosso

23166
15:17:52,720 --> 15:17:54,640
arquivos de origem que basicamente vamos embora

23167
15:17:54,640 --> 15:17:56,720
copiar tudo nesse arquivo que nós

23168
15:17:56,720 --> 15:17:59,840
incluir e nós vamos colar dentro

23169
15:17:59,840 --> 15:18:02,796
nossos novos arquivos aqui que vamos

23170
15:18:02,796 --> 15:18:05,916
estar se referindo como unidades de tradução por

23171
15:18:05,916 --> 15:18:08,560
agora estas são unidades de tradução em um c

23172
15:18:08,560 --> 15:18:11,276
Plus plus programa

23173
15:18:11,276 --> 15:18:13,436
uma vez que você tem esta unidade de tradução, em seguida,

23174
15:18:13,436 --> 15:18:14,956
Você vai compilá-los

23175
15:18:14,956 --> 15:18:16,880
indo para passar pelo compilador o

23176
15:18:16,880 --> 15:18:19,116
O compilador vai gerar o que nós

23177
15:18:19,116 --> 15:18:22,640
chamar um arquivo objeto e este é um binário

23178
15:18:22,640 --> 15:18:25,596
Representação do conteúdo que você tem

23179
15:18:25,596 --> 15:18:28,080
em sua unidade de tradução para cada

23180
15:18:28,080 --> 15:18:30,400
A unidade de tradução vai gerar

23181
15:18:30,400 --> 15:18:33,520
um arquivo objeto e, por exemplo, se você

23182
15:18:33,520 --> 15:18:36,480
tinha 20 unidades de tradução no seu programa

23183
15:18:36,480 --> 15:18:39,040
você vai ter 20 arquivos de objetos

23184
15:18:39,040 --> 15:18:41,200
uma vez que temos arquivos de objetos que eles estão indo

23185
15:18:41,200 --> 15:18:43,200
ser processado pelo que chamamos de

23186
15:18:43,200 --> 15:18:44,320
Linker

23187
15:18:44,320 --> 15:18:46,320
e o linker vai costurá-los

23188
15:18:46,320 --> 15:18:49,756
juntos e ter um único arquivo binário

23189
15:18:49,756 --> 15:18:52,160
de todos esses arquivos de objeto, então estamos

23190
15:18:52,160 --> 15:18:53,916
Vou ter algo assim e

23191
15:18:53,916 --> 15:18:56,320
Isso será basicamente o nosso binário

23192
15:18:56,320 --> 15:18:59,360
que podemos executar em nosso alvo operando

23193
15:18:59,360 --> 15:19:01,596
sistema, então agora você vê que

23194
15:19:01,596 --> 15:19:03,680
O modelo de compilação expandiu-se para

23195
15:19:03,680 --> 15:19:05,756
Contém três fases que temos

23196
15:19:05,756 --> 15:19:09,040
pré-processamento de compilação e vinculação

23197
15:19:09,040 --> 15:19:11,360
Agora você pode estar se perguntando por que estou mostrando

23198
15:19:11,360 --> 15:19:14,080
Você agora bem, vai importar

23199
15:19:14,080 --> 15:19:15,436
porque nós vamos dividir para um

23200
15:19:15,436 --> 15:19:18,560
programa em vários arquivos alguns dos

23201
15:19:18,560 --> 15:19:20,720
esses arquivos vão importar sobre o

23202
15:19:20,720 --> 15:19:23,200
fase de compilação e alguns desses

23203
15:19:23,200 --> 15:19:25,276
Arquivos vão importar sobre a ligação

23204
15:19:25,276 --> 15:19:28,080
palco para que realmente precisemos deixar claro

23205
15:19:28,080 --> 15:19:30,160
A distinção entre a compilação e

23206
15:19:30,160 --> 15:19:32,640
Ligar aqui ok isso deve ser mais

23207
15:19:32,640 --> 15:19:35,916
modelo de compilação completo para ir por

23208
15:19:35,916 --> 15:19:37,756
Agora agora que sabemos sobre isso

23209
15:19:37,756 --> 15:19:40,000
modelo de compilação, podemos ver como

23210
15:19:40,000 --> 15:19:42,240
pode dividir nosso programa em vários

23211
15:19:42,240 --> 15:19:44,400
Arquivos supõem que temos três funções

23212
15:19:44,400 --> 15:19:46,400
um que podemos usar para obter o máximo de dois

23213
15:19:46,400 --> 15:19:49,436
números chamados max uma função chamada homens

23214
15:19:49,436 --> 15:19:51,436
Podemos usar para obter o mínimo entre

23215
15:19:51,436 --> 15:19:53,916
dois números e uma função que podemos usar para

23216
15:19:53,916 --> 15:19:56,480
incrementa e multiplique como vimos

23217
15:19:56,480 --> 15:19:57,916
Na última palestra agora os dois

23218
15:19:57,916 --> 15:19:59,680
funções matemática e homens estão indo para

23219
15:19:59,680 --> 15:20:02,640
viver em seu próprio arquivo e esse arquivo é

23220
15:20:02,640 --> 15:20:04,480
vai ser dividido em dois arquivos que estamos

23221
15:20:04,480 --> 15:20:06,956
ter um arquivo de cabeçalho e um cpp

23222
15:20:06,956 --> 15:20:08,880
arquivo que vai conter o

23223
15:20:08,880 --> 15:20:10,956
implementação no cabeçalho do que somos

23224
15:20:10,956 --> 15:20:13,436
Vai ter é apenas um protótipo e nós

23225
15:20:13,436 --> 15:20:15,520
Vamos configurar o nosso código de certa forma

23226
15:20:15,520 --> 15:20:18,240
que nossa função mult da âncora aqui é

23227
15:20:18,240 --> 15:20:20,640
indo para viver em arquivo de zona que estamos indo

23228
15:20:20,640 --> 15:20:22,560
para dividir isso em dois arquivos, então nós somos

23229
15:20:22,560 --> 15:20:24,160
vai ter um arquivo de cabeçalho chamado

23230
15:20:24,160 --> 15:20:25,680
operações.h

23231
15:20:25,680 --> 15:20:26,640
e nós vamos ter um

23232
15:20:26,640 --> 15:20:28,160
Arquivo de implementação chamado

23233
15:20:28,160 --> 15:20:30,080
operações.cpp

23234
15:20:30,080 --> 15:20:31,276
que vai conter o

23235
15:20:31,276 --> 15:20:33,436
implementação desta função aqui

23236
15:20:33,436 --> 15:20:35,520
quando atingimos o arquivo principal o que somos

23237
15:20:35,520 --> 15:20:37,276
Vou fazer nada de especial que somos

23238
15:20:37,276 --> 15:20:40,000
só vamos incluir os cabeçalhos e nós

23239
15:20:40,000 --> 15:20:42,000
Vamos usar essas funções como nós

23240
15:20:42,000 --> 15:20:44,240
têm usado o tempo todo se você

23241
15:20:44,240 --> 15:20:45,756
Olhe na primeira linha aqui que estamos

23242
15:20:45,756 --> 15:20:48,080
chamando max na segunda linha que somos

23243
15:20:48,080 --> 15:20:50,796
Chamando homens e na terceira linha aqui

23244
15:20:50,796 --> 15:20:53,840
Estamos chamando incur mult para fazer o que

23245
15:20:53,840 --> 15:20:56,400
Tudo bem quando você começa a dividir

23246
15:20:56,400 --> 15:20:58,400
suas funções entre as definições

23247
15:20:58,400 --> 15:21:01,436
E as declarações lembram uma

23248
15:21:01,436 --> 15:21:04,240
regra de definição e isso diz que você

23249
15:21:04,240 --> 15:21:07,200
Não pode ter uma função definida

23250
15:21:07,200 --> 15:21:10,000
Várias vezes em todo o seu c+

23251
15:21:10,000 --> 15:21:12,080
aplicação de classe se você fizer isso

23252
15:21:12,080 --> 15:21:14,240
O estágio lincoln vai encontrar esses dois

23253
15:21:14,240 --> 15:21:16,560
funções e vai

23254
15:21:16,560 --> 15:21:18,796
Não sei qual você realmente quer

23255
15:21:18,796 --> 15:21:20,880
Use e você vai ter um linker

23256
15:21:20,880 --> 15:21:22,240
Erro, vamos ver isso quando nós

23257
15:21:22,240 --> 15:21:24,560
hit código de estúdio visual em um minuto

23258
15:21:24,560 --> 15:21:26,480
Outra coisa é que você sabe que você

23259
15:21:26,480 --> 15:21:29,040
A definição pode realmente deixar em qualquer lugar

23260
15:21:29,040 --> 15:21:30,160
o seu código

23261
15:21:30,160 --> 15:21:32,720
o linker é inteligente o suficiente para analisar o seu

23262
15:21:32,720 --> 15:21:35,200
Projeto inteiro procurando

23263
15:21:35,200 --> 15:21:37,596
A definição para qualquer função

23264
15:21:37,596 --> 15:21:40,400
é encontrado em seu código fonte e é

23265
15:21:40,400 --> 15:21:42,720
Vou continuar procurando até que termine

23266
15:21:42,720 --> 15:21:45,520
olhando em todas as unidades de tradução e

23267
15:21:45,520 --> 15:21:47,756
quando não encontra a definição é

23268
15:21:47,756 --> 15:21:49,840
vai dar-lhe um erro de link que é

23269
15:21:49,840 --> 15:21:51,756
Provavelmente vai dizer indefinido

23270
15:21:51,756 --> 15:21:53,596
Referência a algo e nós vamos

23271
15:21:53,596 --> 15:21:55,840
para ver um exemplo disso em um minuto

23272
15:21:55,840 --> 15:21:57,680
Tudo bem agora que você sabe sobre isso

23273
15:21:57,680 --> 15:21:59,916
Modelo de compilação atualizado e você tem

23274
15:21:59,916 --> 15:22:03,200
Uma ideia de que podemos dividir nossas funções

23275
15:22:03,200 --> 15:22:05,360
em vários arquivos que vamos

23276
15:22:05,360 --> 15:22:07,200
cabeça para código de estúdio visual e jogar

23277
15:22:07,200 --> 15:22:08,160
Conosco

23278
15:22:08,160 --> 15:22:11,436
Tudo bem aqui estamos em nossa pasta de trabalho

23279
15:22:11,436 --> 15:22:14,240
O projeto atual é vários arquivos

23280
15:22:14,240 --> 15:22:16,400
Aqui nós vamos pegar nosso template

23281
15:22:16,400 --> 15:22:18,880
Arquivos, vamos copiar isso

23282
15:22:18,880 --> 15:22:22,240
e colocar isso no projeto de interesse

23283
15:22:22,240 --> 15:22:23,840
e nós vamos abrir isso em visual

23284
15:22:23,840 --> 15:22:25,916
Código do estúdio, vamos fazer isso

23285
15:22:25,916 --> 15:22:28,160
abrir a pasta que eu vou escolher o

23286
15:22:28,160 --> 15:22:30,000
Projeto e abra-o

23287
15:22:30,000 --> 15:22:32,796
e nós vamos abrir o cpp principal

23288
15:22:32,796 --> 15:22:34,320
arquivo aqui

23289
15:22:34,320 --> 15:22:36,956
E limpar um pouco nós somos

23290
15:22:36,956 --> 15:22:39,116
vai configurar uma função máxima e

23291
15:22:39,116 --> 15:22:41,276
Lembre que a função tem que aparecer

23292
15:22:41,276 --> 15:22:44,080
antes de ser usado em algum lugar

23293
15:22:44,080 --> 15:22:47,116
E uh nós vamos dividir isso em um

23294
15:22:47,116 --> 15:22:49,680
definição e uma declaração eu acho que nós

23295
15:22:49,680 --> 15:22:51,916
já sei como fazer isso, então vamos fazer

23296
15:22:51,916 --> 15:22:53,276
que nós vamos

23297
15:22:53,276 --> 15:22:55,520
Coloque uma definição aqui em baixo e nós estamos

23298
15:22:55,520 --> 15:22:58,240
Vamos mudar o que temos no topo aqui

23299
15:22:58,240 --> 15:23:01,276
em uma declaração, digamos que seja

23300
15:23:01,276 --> 15:23:03,840
super claro e o que temos aqui em baixo

23301
15:23:03,840 --> 15:23:05,916
É uma definição e podemos chamar isso de

23302
15:23:05,916 --> 15:23:07,520
Função que vamos configurar o

23303
15:23:07,520 --> 15:23:09,916
variável que vai armazenar o nosso máximo

23304
15:23:09,916 --> 15:23:11,276
Por exemplo,

23305
15:23:11,276 --> 15:23:13,680
e nós vamos atribuir tudo o que nós

23306
15:23:13,680 --> 15:23:15,360
obter a partir da função

23307
15:23:15,360 --> 15:23:17,680
máximo aqui, então queremos encontrar o

23308
15:23:17,680 --> 15:23:22,080
No máximo entre 34 e 56, por exemplo

23309
15:23:22,080 --> 15:23:23,840
e nós vamos imprimir isso eu estou

23310
15:23:23,840 --> 15:23:26,880
Vamos dizer que max é o máximo

23311
15:23:26,880 --> 15:23:29,436
e se ferver e executar este programa

23312
15:23:29,436 --> 15:23:31,596
Vamos usar o gcc para fazer isso.

23313
15:23:31,596 --> 15:23:34,320
Erro de compilador aqui o que é que precisamos

23314
15:23:34,320 --> 15:23:36,560
um ponto e vírgula não uma coluna aqui

23315
15:23:36,560 --> 15:23:38,480
Eu acho que a linha do squiggly está indo agora

23316
15:23:38,480 --> 15:23:41,360
para ir embora e nossas coisas são chamadas de

23317
15:23:41,360 --> 15:23:43,200
Da mesma forma que o compilador não vai

23318
15:23:43,200 --> 15:23:45,436
como se fosse trazer um terminal, então

23319
15:23:45,436 --> 15:23:48,480
que vemos nossa expressão de tabulação de problemas

23320
15:23:48,480 --> 15:23:50,640
parênteses anteriores ou paralelos

23321
15:23:50,640 --> 15:23:51,680


23322
15:23:51,680 --> 15:23:54,240
Ah o problema aqui é que estes

23323
15:23:54,240 --> 15:23:57,116
dois caras max e max são chamados

23324
15:23:57,116 --> 15:23:59,200
O mesmo e isso vai confundir

23325
15:23:59,200 --> 15:24:01,276
O compilador um pouco, então o que somos

23326
15:24:01,276 --> 15:24:04,320
indo fazer é chamar este máximo

23327
15:24:04,320 --> 15:24:06,480
Não há grande coisa aqui

23328
15:24:06,480 --> 15:24:09,436
e nós vamos fazer o máximo aqui

23329
15:24:09,436 --> 15:24:11,916
e o compilador vai ser feliz

23330
15:24:11,916 --> 15:24:14,840
Agora podemos compilar e eu construí isso

23331
15:24:14,840 --> 15:24:18,080
O mundo do programa é bom e se nós o executamos

23332
15:24:18,080 --> 15:24:21,436
Devemos tirar o máximo de impressão

23333
15:24:21,436 --> 15:24:24,640
Vamos ver que o máximo é 56

23334
15:24:24,640 --> 15:24:29,436
e se mudarmos 34 aqui para ser 134

23335
15:24:29,436 --> 15:24:31,596
e ambos novamente devemos agarrar isso como

23336
15:24:31,596 --> 15:24:34,160
o máximo vamos ver se esse é o caso

23337
15:24:34,160 --> 15:24:35,116
Aqui

23338
15:24:35,116 --> 15:24:38,796
executar o programa o máximo é 134.

23339
15:24:38,796 --> 15:24:41,840
Então isso está funcionando exatamente como queremos

23340
15:24:41,840 --> 15:24:44,560
A próxima coisa que queremos fazer é dividir

23341
15:24:44,560 --> 15:24:47,040
esta função em vários arquivos assim

23342
15:24:47,040 --> 15:24:48,560
nós vamos configurar dois diferentes

23343
15:24:48,560 --> 15:24:51,116
Arquivos serão um arquivo de cabeçalho

23344
15:24:51,116 --> 15:24:53,436
o outro vai ser um arquivo cpp e

23345
15:24:53,436 --> 15:24:55,680
você tem que seguir esta estrutura em c

23346
15:24:55,680 --> 15:24:57,520
Além disso, vamos para a esquerda

23347
15:24:57,520 --> 15:25:00,240
aqui e adicionar um novo arquivo no estúdio visual

23348
15:25:00,240 --> 15:25:02,720
código que você pode clicar neste pequeno ícone

23349
15:25:02,720 --> 15:25:05,520
que diz novo arquivo para criar um novo arquivo

23350
15:25:05,520 --> 15:25:06,720
Uma vez que você faz isso, você vai ser

23351
15:25:06,720 --> 15:25:08,796
dada esta pequena janela em que podemos

23352
15:25:08,796 --> 15:25:10,956
digite o nome do arquivo que vamos fazer

23353
15:25:10,956 --> 15:25:14,560
chamar este compare

23354
15:25:14,560 --> 15:25:17,520
dot h será o nosso arquivo de cabeçalho

23355
15:25:17,520 --> 15:25:19,040
e nós vamos adicionar outro que

23356
15:25:19,040 --> 15:25:22,400
vai dizer comparar esse cpp ok

23357
15:25:22,400 --> 15:25:24,480
Nossos dois arquivos vão ser comparados

23358
15:25:24,480 --> 15:25:27,276
que h e comparar esse cpp

23359
15:25:27,276 --> 15:25:29,596
E eles vão conter

23360
15:25:29,596 --> 15:25:32,080
nossas funções para comparar as coisas, então nós somos

23361
15:25:32,080 --> 15:25:34,560
ter em uma função chamada max

23362
15:25:34,560 --> 15:25:37,040
e outra função chamou os homens para

23363
15:25:37,040 --> 15:25:39,436
computar o mínimo vamos lá e

23364
15:25:39,436 --> 15:25:41,596
Na verdade, faça isso, vamos nos mover

23365
15:25:41,596 --> 15:25:44,796
declaração no arquivo de cabeçalho

23366
15:25:44,796 --> 15:25:46,640
Então suas declarações vão ser

23367
15:25:46,640 --> 15:25:48,880
deixando arquivos de cabeçalho e vamos

23368
15:25:48,880 --> 15:25:51,916
para agarrar nossa definição e mover isso

23369
15:25:51,916 --> 15:25:54,360
em outro arquivo chamado

23370
15:25:54,360 --> 15:25:57,276
compare.cpp para que eu só vou cortá-lo

23371
15:25:57,276 --> 15:26:01,360
fora e colar isso e compare cpp aqui

23372
15:26:01,360 --> 15:26:02,956
Uma vez que fazemos isso, vamos voltar

23373
15:26:02,956 --> 15:26:04,000
em main

23374
15:26:04,000 --> 15:26:06,480
e ver que temos um problema agora

23375
15:26:06,480 --> 15:26:08,956
A função principal não sabe o que isto

23376
15:26:08,956 --> 15:26:10,796
A função máxima é porque não é

23377
15:26:10,796 --> 15:26:12,880
declarado mais e se estamos tentando

23378
15:26:12,880 --> 15:26:14,480
compilar nosso programa, somos basicamente

23379
15:26:14,480 --> 15:26:16,796
Vou ter o mesmo erro que vemos aqui

23380
15:26:16,796 --> 15:26:19,596
e identificador de código de estúdio visual max é

23381
15:26:19,596 --> 15:26:22,000
indefinida porque não sabe o que

23382
15:26:22,000 --> 15:26:24,480
Esta função é se ignorarmos isso e

23383
15:26:24,480 --> 15:26:26,560
Tente soldar, vamos fazer isso nós

23384
15:26:26,560 --> 15:26:29,116
aprendendo tão grande coisa aqui que estamos indo

23385
15:26:29,116 --> 15:26:30,956
para obter um mesmo

23386
15:26:30,956 --> 15:26:34,240
Erro muito mais estranho, mas a mensagem é

23387
15:26:34,240 --> 15:26:36,320
Vai ser a mesma matemática não

23388
15:26:36,320 --> 15:26:39,116
declarado no escopo para que o compilador

23389
15:26:39,116 --> 15:26:41,116
Não sabe o que fazer com qualquer coisa que nós

23390
15:26:41,116 --> 15:26:43,680
digitado aqui, mas há uma maneira em c plus

23391
15:26:43,680 --> 15:26:45,756
Além disso, podemos resolver este problema por

23392
15:26:45,756 --> 15:26:49,116
incluindo o cabeçalho que contém o nosso

23393
15:26:49,116 --> 15:26:51,520
declaração para a função que somos

23394
15:26:51,520 --> 15:26:53,756
usando aqui podemos voltar no main e fazer

23395
15:26:53,756 --> 15:26:55,916
Isso e vamos dizer incluir e

23396
15:26:55,916 --> 15:26:59,200
nós vamos dizer comparar

23397
15:26:59,200 --> 15:27:00,720
que h

23398
15:27:00,720 --> 15:27:02,720
que vai trazer o nosso cabeçalho e

23399
15:27:02,720 --> 15:27:04,080
Se você esperar um minuto que você vai ver

23400
15:27:04,080 --> 15:27:05,680
que a linha de squiggly vai ir

23401
15:27:05,680 --> 15:27:09,756
fora assim o que aconteceu o pré-processador

23402
15:27:09,756 --> 15:27:12,796
vai entrar e copiar o que quer que seja

23403
15:27:12,796 --> 15:27:15,520
ter dentro compare.h é basicamente

23404
15:27:15,520 --> 15:27:18,320
ir e comparar essa cópia de idade

23405
15:27:18,320 --> 15:27:21,200
Tudo o que temos aqui e voltar

23406
15:27:21,200 --> 15:27:24,080
Principal e colar tudo isso no lugar

23407
15:27:24,080 --> 15:27:27,116
onde temos a diretiva incluem aqui

23408
15:27:27,116 --> 15:27:30,240
isso é chamado de diretiva incluem ou

23409
15:27:30,240 --> 15:27:33,360
uma diretiva de pré-processador incluir esta

23410
15:27:33,360 --> 15:27:35,436
É o que o pré-processador vai fazer

23411
15:27:35,436 --> 15:27:37,916
Aqui e agora se tentarmos construir isso

23412
15:27:37,916 --> 15:27:40,000
Programa vamos tentar fazer isso que devemos

23413
15:27:40,000 --> 15:27:43,276
estar bem o mundo acabado com sucesso e

23414
15:27:43,276 --> 15:27:45,596
Podemos executar nosso programa para ver o

23415
15:27:45,596 --> 15:27:48,160
máximo impresso para fora, vamos rodar galo

23416
15:27:48,160 --> 15:27:51,520
máximo é 134 agora tudo está funcionando

23417
15:27:51,520 --> 15:27:53,596
Vamos adicionar outra função aqui porque

23418
15:27:53,596 --> 15:27:55,360
Ter uma função é realmente

23419
15:27:55,360 --> 15:27:57,276
chato, então nós vamos colocar em um main

23420
15:27:57,276 --> 15:27:59,916
função vai digitar em um e

23421
15:27:59,916 --> 15:28:01,040
em b

23422
15:28:01,040 --> 15:28:03,200
e nós vamos entrar no arquivo cpp

23423
15:28:03,200 --> 15:28:05,680
e colocar em outra definição para o

23424
15:28:05,680 --> 15:28:07,520
Função mínima aqui nós vamos

23425
15:28:07,520 --> 15:28:10,160
Chamar este homem

23426
15:28:10,160 --> 15:28:13,116
Vamos fazer isso

23427
15:28:13,520 --> 15:28:15,756
Vamos chamar isso de homem e nós vamos

23428
15:28:15,756 --> 15:28:18,400
teste para um é menos do que b isso está indo

23429
15:28:18,400 --> 15:28:21,276
para nos dar um mínimo e agora, se formos

23430
15:28:21,276 --> 15:28:24,400
back in main cpp que seremos capazes de usar

23431
15:28:24,400 --> 15:28:26,400
nossa função mínima porque é

23432
15:28:26,400 --> 15:28:30,320
proteína também por este pré-processador

23433
15:28:30,320 --> 15:28:33,200
Diretiva que temos aqui para que possamos ir para baixo

23434
15:28:33,200 --> 15:28:35,680
e dizer o mínimo final e nós vamos

23435
15:28:35,680 --> 15:28:36,796
Diga o homem

23436
15:28:36,796 --> 15:28:38,360
E vamos pegar

23437
15:28:38,360 --> 15:28:40,000
146

23438
15:28:40,000 --> 15:28:42,956
E 23 por que não e vamos imprimir

23439
15:28:42,956 --> 15:28:44,880
o mínimo aqui e nós vamos

23440
15:28:44,880 --> 15:28:47,520
Construa isso com gcc

23441
15:28:47,520 --> 15:28:49,680
A bala vai ser boa se corrermos

23442
15:28:49,680 --> 15:28:52,160
Isso devemos ver o máximo e

23443
15:28:52,160 --> 15:28:54,560
o mínimo dessas chamadas que fazemos

23444
15:28:54,560 --> 15:28:55,840
Aqui

23445
15:28:55,840 --> 15:28:57,840
Ok agora você deve ter uma ideia

23446
15:28:57,840 --> 15:29:01,276
sobre como dividir suas funções

23447
15:29:01,276 --> 15:29:03,840
vários arquivos você também deve saber que

23448
15:29:03,840 --> 15:29:07,116
você terá que incluir qualquer cabeçalho

23449
15:29:07,116 --> 15:29:09,520
Contém as declarações para o

23450
15:29:09,520 --> 15:29:11,916
funções que você deseja usar outro

23451
15:29:11,916 --> 15:29:14,400
O que eu quero que você veja é que o

23452
15:29:14,400 --> 15:29:16,956
Definições para suas funções não

23453
15:29:16,956 --> 15:29:20,640
tem que viver em um arquivo que é chamado de

23454
15:29:20,640 --> 15:29:23,596
O mesmo que o arquivo de cabeçalho, por exemplo, aqui

23455
15:29:23,596 --> 15:29:25,596
nosso arquivo de cabeçalho é chamado de comparar e

23456
15:29:25,596 --> 15:29:27,116
A comparação tpp contém o nosso

23457
15:29:27,116 --> 15:29:29,840
definições mas as definições não

23458
15:29:29,840 --> 15:29:32,400
Você tem que viver aqui eles podem realmente viver

23459
15:29:32,400 --> 15:29:35,276
em qualquer unidade de tradução que você tenha em

23460
15:29:35,276 --> 15:29:37,596
seu c plus mais programa

23461
15:29:37,596 --> 15:29:39,916
e nosso c plus programas

23462
15:29:39,916 --> 15:29:42,796
A unidade de tradução é equivalente principalmente a

23463
15:29:42,796 --> 15:29:45,840
um arquivo cpp então vamos configurar outro arquivo

23464
15:29:45,840 --> 15:29:47,436
e mostrar que nós podemos mover isso

23465
15:29:47,436 --> 15:29:49,360
A definição lá e o programa é

23466
15:29:49,360 --> 15:29:51,200
Vou continuar trabalhando, vamos adicionar

23467
15:29:51,200 --> 15:29:53,916
outro arquivo cpp e chamá-lo algum

23468
15:29:53,916 --> 15:29:55,680
outro arquivo

23469
15:29:55,680 --> 15:29:58,320
que cpp tem que ser um arquivo cpp porque

23470
15:29:58,320 --> 15:29:59,360
Vai conter o

23471
15:29:59,360 --> 15:30:02,000
implementações e vamos tomar o

23472
15:30:02,000 --> 15:30:03,840
Implementações, por exemplo, vamos tomar

23473
15:30:03,840 --> 15:30:06,320
todos os colocam em outro arquivo por que

23474
15:30:06,320 --> 15:30:07,200
Não é

23475
15:30:07,200 --> 15:30:09,596
nós vamos pegar todos esses caras aqui

23476
15:30:09,596 --> 15:30:12,080
Vamos pegá-los e colocá-los dentro

23477
15:30:12,080 --> 15:30:14,160
Um outro arquivo

23478
15:30:14,160 --> 15:30:16,400
E eu vou construir isso e ver aquilo

23479
15:30:16,400 --> 15:30:18,640
Funciona que deve

23480
15:30:18,640 --> 15:30:21,116
porque o linker é inteligente o suficiente para ir

23481
15:30:21,116 --> 15:30:23,276
Encontre essas definições

23482
15:30:23,276 --> 15:30:25,840
e quaisquer unidades de tradução que nós

23483
15:30:25,840 --> 15:30:28,956
ter configurado em nosso projeto aqui e você

23484
15:30:28,956 --> 15:30:31,436
ver o mundo é bom podemos carregar isso

23485
15:30:31,436 --> 15:30:33,200
Podemos correr isso, devo dizer e estamos

23486
15:30:33,200 --> 15:30:35,360
vamos ter a nossa produção aqui nós podemos

23487
15:30:35,360 --> 15:30:38,720
Até pegar um desses caras deixá-lo sair

23488
15:30:38,720 --> 15:30:40,680
em nosso

23489
15:30:40,680 --> 15:30:42,956
arquivo compare.cpp por exemplo, vamos tomar

23490
15:30:42,956 --> 15:30:45,040
A função mínima aqui

23491
15:30:45,040 --> 15:30:46,840
e nós vamos trazer isso

23492
15:30:46,840 --> 15:30:49,916
De volta e vamos trabalhar perceber que

23493
15:30:49,916 --> 15:30:50,796
E agora

23494
15:30:50,796 --> 15:30:54,000
nossa função máxima é viver em alguns

23495
15:30:54,000 --> 15:30:56,720
outro arquivo e que é a função mínima

23496
15:30:56,720 --> 15:30:59,200
A definição é deixar e comparar que

23497
15:30:59,200 --> 15:31:02,080
cpp mas se nós vamos isso vai funcionar

23498
15:31:02,080 --> 15:31:04,400
Mais uma vez o linker é

23499
15:31:04,400 --> 15:31:07,040
Vou analisar todas as unidades de tradução

23500
15:31:07,040 --> 15:31:08,796
Procurando para o que quer que seja

23501
15:31:08,796 --> 15:31:11,680
A definição precisa encontrar e nisso

23502
15:31:11,680 --> 15:31:14,000
Caso que ele estará procurando o máximo

23503
15:31:14,000 --> 15:31:17,116
Aqui e vai descobrir que em alguns

23504
15:31:17,116 --> 15:31:19,916
outro arquivo e para o

23505
15:31:19,916 --> 15:31:21,756
Função mínima aqui vai ser

23506
15:31:21,756 --> 15:31:24,000
olhar e comparar e vai

23507
15:31:24,000 --> 15:31:26,000
encontrá-lo e o mundo vai ser

23508
15:31:26,000 --> 15:31:28,480
bom e podemos executar o programa novamente

23509
15:31:28,480 --> 15:31:31,520
e ver a nossa saída aqui

23510
15:31:31,520 --> 15:31:34,240
Uma coisa que eu realmente preciso apontar é

23511
15:31:34,240 --> 15:31:37,116
Se a definição não estiver disponível

23512
15:31:37,116 --> 15:31:39,596
Vamos dizer que a função mínima aqui é

23513
15:31:39,596 --> 15:31:42,160
Não lá podemos comentar para esconder

23514
15:31:42,160 --> 15:31:44,560
para o compilador ou escondê-lo a partir do

23515
15:31:44,560 --> 15:31:45,916
Compilador

23516
15:31:45,916 --> 15:31:48,160
E se tentarmos votar agora

23517
15:31:48,160 --> 15:31:50,796
obteremos um erro de linker, vamos tentar

23518
15:31:50,796 --> 15:31:53,040
construção com gcc

23519
15:31:53,040 --> 15:31:55,916
uh-huh mundo terminou com erro é o

23520
15:31:55,916 --> 15:31:58,240
Processo de terminal terminado com execução

23521
15:31:58,240 --> 15:32:02,000
código -1 mas a mensagem principal aqui é

23522
15:32:02,000 --> 15:32:05,040
que temos uma referência indefinida a

23523
15:32:05,040 --> 15:32:08,000
min e e assim quando compilamos o

23524
15:32:08,000 --> 15:32:10,320
O compilador vai ficar feliz com o

23525
15:32:10,320 --> 15:32:13,796
declarações que encontrou em nosso

23526
15:32:13,796 --> 15:32:16,640
arquivo compare.h se formos lá, vemos

23527
15:32:16,640 --> 15:32:19,520
que temos uma declaração para max e

23528
15:32:19,520 --> 15:32:21,840
a declaração para o homem o compilador é

23529
15:32:21,840 --> 15:32:23,436
Vai ser feliz que vai compilar

23530
15:32:23,436 --> 15:32:26,000
nosso código e quando o compilador compilar

23531
15:32:26,000 --> 15:32:28,720
vai gerar arquivos de objetos e

23532
15:32:28,720 --> 15:32:31,040
ele vai entregar o trabalho para o linker

23533
15:32:31,040 --> 15:32:33,596
para costurar todos esses pequenos arquivos de objeto

23534
15:32:33,596 --> 15:32:36,560
para ter um único arquivo binário

23535
15:32:36,560 --> 15:32:38,640
uma vez que o linker tenta fazer isso é

23536
15:32:38,640 --> 15:32:40,560
Vou olhar para o principal porque isso é

23537
15:32:40,560 --> 15:32:42,796
de onde ele está indo para começar a partir de

23538
15:32:42,796 --> 15:32:44,640
e vai ver uh-huh principal é

23539
15:32:44,640 --> 15:32:47,116
Chamando mínimo aqui onde é o

23540
15:32:47,116 --> 15:32:49,200
definição para a função mínima que é

23541
15:32:49,200 --> 15:32:51,276
indo para analisar cada tradução

23542
15:32:51,276 --> 15:32:54,000
unidade no projeto que vai chegar

23543
15:32:54,000 --> 15:32:55,840
aqui e compare aquele cpp não está indo

23544
15:32:55,840 --> 15:32:57,200
para encontrá-lo ele vai olhar para dentro

23545
15:32:57,200 --> 15:32:59,520
main.cpp não vai descobrir que é

23546
15:32:59,520 --> 15:33:01,200
indo para olhar em algum outro arquivo é

23547
15:33:01,200 --> 15:33:03,520
Não encontrar a definição e a

23548
15:33:03,520 --> 15:33:05,116
Linker vai dizer

23549
15:33:05,116 --> 15:33:07,040
Eu não encontrei minha definição para o

23550
15:33:07,040 --> 15:33:09,436
função mínima para que eu vou jogar um

23551
15:33:09,436 --> 15:33:11,916
Erro de linker e você o desenvolvedor

23552
15:33:11,916 --> 15:33:14,560
você vai resolver esse problema e

23553
15:33:14,560 --> 15:33:16,240
você vai ver esse erro aqui e

23554
15:33:16,240 --> 15:33:20,000
novamente este é um erro de linker gcc não

23555
15:33:20,000 --> 15:33:21,040
dar-lhe

23556
15:33:21,040 --> 15:33:23,596
coisas mais visíveis para mostrar que isso

23557
15:33:23,596 --> 15:33:25,680
é um erro de linker, mas o que você deve

23558
15:33:25,680 --> 15:33:30,000
O olhar é ld retornado 1 aqui porque

23559
15:33:30,000 --> 15:33:33,916
ld é o linker que gcc usa para que este

23560
15:33:33,916 --> 15:33:35,360
é um erro do linker

23561
15:33:35,360 --> 15:33:37,276
Acho que devo mostrar como um linker

23562
15:33:37,276 --> 15:33:39,840
O erro parece se você estiver usando um microsoft

23563
15:33:39,840 --> 15:33:42,400
Compilador, então vamos construir novamente

23564
15:33:42,400 --> 15:33:46,080
mas agora vamos construir com o msvc

23565
15:33:46,080 --> 15:33:47,840
Se você não tem estúdio visual que é

23566
15:33:47,840 --> 15:33:50,560
não é um problema que você pode continuar usando gcc, mas

23567
15:33:50,560 --> 15:33:52,956
Eu só quero que você veja o quão diferente

23568
15:33:52,956 --> 15:33:56,240
Compiladores manipulam essas setas que eu tenho a

23569
15:33:56,240 --> 15:33:57,840
luxo para fazer isso porque eu sou

23570
15:33:57,840 --> 15:33:59,520
Desenvolvendo este curso em uma janela

23571
15:33:59,520 --> 15:34:02,560
máquina e eu tenho um compilador microsoft

23572
15:34:02,560 --> 15:34:04,956
dissimcio que podemos usar diretamente de

23573
15:34:04,956 --> 15:34:07,360
código de estúdio visual aqui, então eu vou

23574
15:34:07,360 --> 15:34:09,116
Escolha este compilador

23575
15:34:09,116 --> 15:34:10,560
E você vai ver que está indo

23576
15:34:10,560 --> 15:34:12,880
para começar a soldar está construindo

23577
15:34:12,880 --> 15:34:15,680
e vai falhar e jogar um link

23578
15:34:15,680 --> 15:34:18,880
seta também para que você veja aqui algum outro

23579
15:34:18,880 --> 15:34:22,080
Arquivo de objeto OK

23580
15:34:22,080 --> 15:34:22,880
Quando

23581
15:34:22,880 --> 15:34:25,360
este arquivo de objeto estava sendo tomado e

23582
15:34:25,360 --> 15:34:27,756
costurado junto com outro objeto

23583
15:34:27,756 --> 15:34:30,640
arquivos para montar um binário que não fez

23584
15:34:30,640 --> 15:34:32,880
Encontre a definição para o mínimo

23585
15:34:32,880 --> 15:34:34,480
função e vai jogar um

23586
15:34:34,480 --> 15:34:36,880
erro de linker e em estúdio visual você é

23587
15:34:36,880 --> 15:34:39,680
ter um problema como este l e

23588
15:34:39,680 --> 15:34:40,880
k (em inglês)

23589
15:34:40,880 --> 15:34:42,720
e vai dar qualquer versão

23590
15:34:42,720 --> 15:34:44,880
do compilador que você está usando, mas para baixo

23591
15:34:44,880 --> 15:34:47,436
Aqui você vê o símbolo externo não resolvido

23592
15:34:47,436 --> 15:34:51,116
É assim que o estúdio visual diz e

23593
15:34:51,116 --> 15:34:53,040
Basicamente vai ser

23594
15:34:53,040 --> 15:34:55,360
uma referência indefinida a algo que

23595
15:34:55,360 --> 15:34:57,916
é apenas o caminho do compilador do estúdio visual

23596
15:34:57,916 --> 15:35:00,240
para dizer isso e novamente vai dizer

23597
15:35:00,240 --> 15:35:02,160
Este é um erro de linker aqui

23598
15:35:02,160 --> 15:35:04,320
É basicamente o mesmo erro que vimos

23599
15:35:04,320 --> 15:35:06,720
quando estávamos usando gcc em um vídeo de minuto

23600
15:35:06,720 --> 15:35:09,040
studio the compiler do microsoft é

23601
15:35:09,040 --> 15:35:11,276
Também vou colocar um monte de lixo em nosso

23602
15:35:11,276 --> 15:35:13,200
pasta aqui, então vamos remover todos estes

23603
15:35:13,200 --> 15:35:17,200
Coisas que eu vou selecionar todos eles

23604
15:35:17,200 --> 15:35:20,160
e eu odeio apagar aqui

23605
15:35:20,160 --> 15:35:22,160
E eles vão para a minha reciclagem

23606
15:35:22,160 --> 15:35:24,720
bin e temos outro aqui

23607
15:35:24,720 --> 15:35:28,080
deve remover vamos removê-lo

23608
15:35:28,080 --> 15:35:30,596
E agora devemos voltar em algum outro

23609
15:35:30,596 --> 15:35:33,520
file.cpp ou compare.cpp que é onde nós

23610
15:35:33,520 --> 15:35:35,840
ter uma função mínima que podemos ativar

23611
15:35:35,840 --> 15:35:38,400
Isso e se nós dois somos agora o mundo

23612
15:35:38,400 --> 15:35:40,240
Deve ser bom porque o linker é

23613
15:35:40,240 --> 15:35:42,720
Vou encontrar esta definição aqui

23614
15:35:42,720 --> 15:35:45,520
OK, vamos construir com gcc porque isso é

23615
15:35:45,520 --> 15:35:47,840
O meu compilador favorito

23616
15:35:47,840 --> 15:35:49,916
Agora você vê que o mundo é bom

23617
15:35:49,916 --> 15:35:52,400
pode limpar e executar galo e nosso

23618
15:35:52,400 --> 15:35:54,956
O programa vai funcionar como deveria

23619
15:35:54,956 --> 15:35:57,520
É assim que você pode dividir seu

23620
15:35:57,520 --> 15:36:00,400
funções em vários arquivos

23621
15:36:00,400 --> 15:36:01,916
Os cabeçalhos vão conter o

23622
15:36:01,916 --> 15:36:04,480
declarações de que os arquivos cpp estão indo para

23623
15:36:04,480 --> 15:36:07,040
Contém as definições das suas definições

23624
15:36:07,040 --> 15:36:08,796
pode realmente deixar em qualquer lugar que vai

23625
15:36:08,796 --> 15:36:11,916
ser uma questão do que funciona melhor para

23626
15:36:11,916 --> 15:36:14,720
seu projeto, mas para organização

23627
15:36:14,720 --> 15:36:17,360
propósitos que seus arquivos cpp serão

23628
15:36:17,360 --> 15:36:18,956
Basicamente assim você vai ter

23629
15:36:18,956 --> 15:36:21,756
algumas declarações no cabeçalho como

23630
15:36:21,756 --> 15:36:23,276
Comparar.h

23631
15:36:23,276 --> 15:36:26,240
e em um arquivo cpp correspondente você é

23632
15:36:26,240 --> 15:36:28,640
ter e as definições para

23633
15:36:28,640 --> 15:36:30,480
Todas as declarações que você tem no

23634
15:36:30,480 --> 15:36:32,720
cabeçalho, mas você não tem que fazer isso

23635
15:36:32,720 --> 15:36:34,480
Se faz sentido para o seu

23636
15:36:34,480 --> 15:36:36,640
definição para aparecer em outro lugar

23637
15:36:36,640 --> 15:36:38,640
Por favor, vá em frente e faça isso mais c plus

23638
15:36:38,640 --> 15:36:40,640
vai aceitar que isso é realmente

23639
15:36:40,640 --> 15:36:43,200
Tudo o que nos parecemos fazer nesta palestra, mas

23640
15:36:43,200 --> 15:36:45,520
Antes de ir, eu vou te dar um

23641
15:36:45,520 --> 15:36:47,756
chance de configurar outra função

23642
15:36:47,756 --> 15:36:51,200
Supondo que temos uma função chamada

23643
15:36:51,200 --> 15:36:54,400
âncora malte e nós vamos ter o

23644
15:36:54,400 --> 15:36:56,320
Função configurada aqui nós vamos

23645
15:36:56,320 --> 15:36:58,000
retorno

23646
15:36:58,000 --> 15:36:59,840
a plus plus

23647
15:36:59,840 --> 15:37:01,520
Já sabemos como fazer essas coisas

23648
15:37:01,520 --> 15:37:03,276
nós usamos este exemplo um par de

23649
15:37:03,276 --> 15:37:07,596
tempos agora mais mais mais b

23650
15:37:07,596 --> 15:37:09,756
E é isso que vamos voltar

23651
15:37:09,756 --> 15:37:12,796
Agora seu trabalho é dividir essa função

23652
15:37:12,796 --> 15:37:14,080
em

23653
15:37:14,080 --> 15:37:16,796
uma declaração e uma definição e colocar

23654
15:37:16,796 --> 15:37:19,040
aqueles em dois arquivos separados um está indo

23655
15:37:19,040 --> 15:37:21,756
para ser chamado de operações.h e o outro

23656
15:37:21,756 --> 15:37:23,320
Vai ser chamado

23657
15:37:23,320 --> 15:37:26,720
operations.cpp pausar o vídeo ir em frente

23658
15:37:26,720 --> 15:37:28,560
configurar seu projeto assim e chamar

23659
15:37:28,560 --> 15:37:31,520
que funcionam no cpp principal e ver se você

23660
15:37:31,520 --> 15:37:33,840
pode puxar isso juntos bem poste o

23661
15:37:33,840 --> 15:37:35,916
O vídeo faz isso e uma vez que você terminar, venha

23662
15:37:35,916 --> 15:37:37,916
de volta e ver como eu faço isso

23663
15:37:37,916 --> 15:37:39,916
vamos configurar um novo arquivo chamado

23664
15:37:39,916 --> 15:37:42,720
As operações aqui

23665
15:37:42,720 --> 15:37:45,680
vai ser um arquivo de cabeçalho dot h e

23666
15:37:45,680 --> 15:37:47,360
vamos adicionar outro arquivo chamado

23667
15:37:47,360 --> 15:37:50,320
operações.cpp

23668
15:37:50,320 --> 15:37:52,956
que vai ser o nosso arquivo cpp que é

23669
15:37:52,956 --> 15:37:56,240
Vou conter nossas definições que somos

23670
15:37:56,240 --> 15:37:58,480
indo para voltar no main e pegar o

23671
15:37:58,480 --> 15:38:01,116
Toda a função aqui não queremos isso

23672
15:38:01,116 --> 15:38:03,756
Principal para que vamos entrar

23673
15:38:03,756 --> 15:38:05,916
O cabeçalho aqui

23674
15:38:05,916 --> 15:38:08,480
nós devemos ir no cabeçalho de operações

23675
15:38:08,480 --> 15:38:10,400
É onde queremos isso

23676
15:38:10,400 --> 15:38:12,720
e nós vamos colocar em nossa definição

23677
15:38:12,720 --> 15:38:13,756
e nós vamos colocar em nosso

23678
15:38:13,756 --> 15:38:15,756
Declaração que a declaração não tem

23679
15:38:15,756 --> 15:38:17,680
um corpo, então nós vamos colocar um

23680
15:38:17,680 --> 15:38:19,596
ponto e-vírgula no final, você já está

23681
15:38:19,596 --> 15:38:21,916
Saiba isso nós vamos entrar no cpp

23682
15:38:21,916 --> 15:38:24,160
arquivar e colocar em nossa definição

23683
15:38:24,160 --> 15:38:26,560
isso vai funcionar e ser capaz de

23684
15:38:26,560 --> 15:38:28,160
Use esta função

23685
15:38:28,160 --> 15:38:30,640
Precisamos incluir o

23686
15:38:30,640 --> 15:38:33,360
cabeçalho correspondente aqui, por que isso é

23687
15:38:33,360 --> 15:38:34,796
arquivo chamado

23688
15:38:34,796 --> 15:38:37,200
uh é chamado ccp

23689
15:38:37,200 --> 15:38:40,160
É cpp nós vamos renomeá-lo

23690
15:38:40,160 --> 15:38:44,640
e nós vamos mudar isso para cpp

23691
15:38:44,640 --> 15:38:47,200
Agora devemos estar bem, devemos ter o nosso

23692
15:38:47,200 --> 15:38:48,640
Obrigado colorido

23693
15:38:48,640 --> 15:38:51,596
corretamente e uh para usar esta função nós

23694
15:38:51,596 --> 15:38:53,756
terá de incluir a correspondente

23695
15:38:53,756 --> 15:38:56,320
cabeçalho que é operações.h

23696
15:38:56,320 --> 15:38:58,480
Vamos fazer isso, vamos para o principal

23697
15:38:58,480 --> 15:39:02,000
e ir para baixo e incluir

23698
15:39:03,276 --> 15:39:06,080
as operações

23699
15:39:06,400 --> 15:39:09,200
dot h este vai funcionar

23700
15:39:09,200 --> 15:39:11,840
e observe que a forma como incluímos o nosso

23701
15:39:11,840 --> 15:39:14,400
Os cabeçalhos próprios são diferentes da maneira como nós

23702
15:39:14,400 --> 15:39:15,436
Incluir

23703
15:39:15,436 --> 15:39:18,480
as bibliotecas ou cabeçalhos que vêm com

23704
15:39:18,480 --> 15:39:20,956
a biblioteca padrão c plus este é

23705
15:39:20,956 --> 15:39:22,720
uma conversão que é usada por muitos

23706
15:39:22,720 --> 15:39:25,040
Compiladores é assim que teremos que fazer

23707
15:39:25,040 --> 15:39:27,596
Coisas, por favor, lembre-se disso se você é

23708
15:39:27,596 --> 15:39:29,840
incluindo o seu próprio cabeçalho, por favor, coloque

23709
15:39:29,840 --> 15:39:30,720
que

23710
15:39:30,720 --> 15:39:33,680
nas citações como fazemos aqui, se você é

23711
15:39:33,680 --> 15:39:36,160
incluindo um cabeçalho de biblioteca padrão

23712
15:39:36,160 --> 15:39:38,956
Por favor, use suportes de ângulo como este agora

23713
15:39:38,956 --> 15:39:40,400
Que temos isso

23714
15:39:40,400 --> 15:39:42,400
incluído, podemos ir aqui e dizer

23715
15:39:42,400 --> 15:39:43,756
O resultado

23716
15:39:43,756 --> 15:39:45,436
Vamos configurar duas variáveis x

23717
15:39:45,436 --> 15:39:46,400
E e y

23718
15:39:46,400 --> 15:39:49,916
Por que não vamos ter um 4 aqui

23719
15:39:49,916 --> 15:39:53,040
e nós vamos ter um y que é um

23720
15:39:53,040 --> 15:39:55,520
Cinco vamos fazer isso e nós vamos

23721
15:39:55,520 --> 15:39:57,756
ter um inteiro para armazenar nossos resultados

23722
15:39:57,756 --> 15:40:00,640
vai dizer montagem de âncora e é

23723
15:40:00,640 --> 15:40:04,000
Vou fazer as operações em x

23724
15:40:04,000 --> 15:40:06,160
e vamos fazer isso e nós vamos

23725
15:40:06,160 --> 15:40:08,880
Imprima os resultados aqui, então vamos

23726
15:40:08,880 --> 15:40:11,756
Diga resultado

23727
15:40:12,320 --> 15:40:14,720
E vai ser o que tivermos em

23728
15:40:14,720 --> 15:40:17,756
que a variável

23729
15:40:18,080 --> 15:40:19,916
Tudo bem se construirmos este programa é

23730
15:40:19,916 --> 15:40:22,480
indo para o trabalho, vamos usar gcc para

23731
15:40:22,480 --> 15:40:25,360
mundo o mundo é bom se nós corremos nós

23732
15:40:25,360 --> 15:40:27,200
Deverá

23733
15:40:27,200 --> 15:40:30,160
ver a nossa produção aqui indo para executar galo

23734
15:40:30,160 --> 15:40:32,956
O resultado é 24 porque

23735
15:40:32,956 --> 15:40:34,956
Tudo bem se incrementarmos x vamos

23736
15:40:34,956 --> 15:40:36,640
obter um 5

23737
15:40:36,640 --> 15:40:38,640
E se incrementarmos um 5, vamos

23738
15:40:38,640 --> 15:40:40,320
conseguir um 6.

23739
15:40:40,320 --> 15:40:42,560
Se multiplicarmos esses caras, devemos obter

23740
15:40:42,560 --> 15:40:45,436
a 30 e isso não é o que temos aqui, então

23741
15:40:45,436 --> 15:40:47,756
O que está acontecendo, vamos olhar para o nosso

23742
15:40:47,756 --> 15:40:49,276
Definição aqui

23743
15:40:49,276 --> 15:40:52,240
nós dissemos um plus plus

23744
15:40:52,240 --> 15:40:54,320
nós deveríamos dizer mais mais mais mais

23745
15:40:54,320 --> 15:40:57,520
porque queremos incrementar imediatamente

23746
15:40:57,520 --> 15:40:59,276
OK, vamos construir novamente

23747
15:40:59,276 --> 15:41:00,880
nós vamos para

23748
15:41:00,880 --> 15:41:02,560
Bem com sucesso

23749
15:41:02,560 --> 15:41:04,320
e nós vamos limpar e correr

23750
15:41:04,320 --> 15:41:06,956
Galo agora temos o resultado de que

23751
15:41:06,956 --> 15:41:09,276
Espere, vamos voltar para o principal e olhar para

23752
15:41:09,276 --> 15:41:11,360
Nosso programa é o que estamos usando

23753
15:41:11,360 --> 15:41:14,480
Aqui e este é o resultado que esperamos

23754
15:41:14,480 --> 15:41:16,320
Isso é realmente tudo o que nos prossamos fazer em

23755
15:41:16,320 --> 15:41:18,720
Esta palestra mostrando como você pode

23756
15:41:18,720 --> 15:41:21,360
configurar o seu projeto para dividir

23757
15:41:21,360 --> 15:41:24,160
funções em vários arquivos este é

23758
15:41:24,160 --> 15:41:26,240
Realmente bom se você quer organizar o seu

23759
15:41:26,240 --> 15:41:28,640
Projeto, por exemplo, alguém que vem

23760
15:41:28,640 --> 15:41:30,796
para o cabeçalho aqui não vai ser

23761
15:41:30,796 --> 15:41:32,560
incomodado olhando para todos os

23762
15:41:32,560 --> 15:41:34,720
Definições e os detalhes de como

23763
15:41:34,720 --> 15:41:38,240
calcular este máximo e mínimo e nós

23764
15:41:38,240 --> 15:41:40,880
ter a flexibilidade agora para mover o nosso

23765
15:41:40,880 --> 15:41:43,436
cabeçalhos em algum outro arquivo porque nós

23766
15:41:43,436 --> 15:41:45,840
realmente quero manter a função principal ou

23767
15:41:45,840 --> 15:41:48,796
O arquivo principal aqui realmente limpo não

23768
15:41:48,796 --> 15:41:50,956
Quer que todas essas definições apareçam

23769
15:41:50,956 --> 15:41:53,200
Porque é possível para o seu

23770
15:41:53,200 --> 15:41:55,916
Projeto para conter centenas ou até mesmo

23771
15:41:55,916 --> 15:41:58,160
milhares de definições se você fizer tudo

23772
15:41:58,160 --> 15:42:00,796
As declarações aparecem em geral

23773
15:42:00,796 --> 15:42:03,436
arquivo cpp aqui que vai ser realmente

23774
15:42:03,436 --> 15:42:06,400
É difícil seguir e trabalhar com agora que temos

23775
15:42:06,400 --> 15:42:09,040
A flexibilidade para dividir esses caras

23776
15:42:09,040 --> 15:42:11,520
em vários arquivos e podemos até

23777
15:42:11,520 --> 15:42:14,320
Use muitos cabeçalhos se é isso que é

23778
15:42:14,320 --> 15:42:16,560
Vou trabalhar para o nosso projeto que é

23779
15:42:16,560 --> 15:42:18,000
Realmente tudo o que nos posicionamos para fazer nisso

23780
15:42:18,000 --> 15:42:20,080
Uma palestra espero que você tenha achado interessante

23781
15:42:20,080 --> 15:42:22,320
Vamos parar aqui nesta em

23782
15:42:22,320 --> 15:42:23,840
O próximo vamos ver como nós

23783
15:42:23,840 --> 15:42:26,840
pode passar parâmetros para funções por

23784
15:42:26,840 --> 15:42:29,840
O valor vá em frente e termine aqui e

23785
15:42:29,840 --> 15:42:31,116
Me encontre lá

23786
15:42:31,116 --> 15:42:32,720
Nesta palestra vamos ver o que

23787
15:42:32,720 --> 15:42:35,436
significa passar parâmetros para um

23788
15:42:35,436 --> 15:42:37,916
função por valor e nós vamos

23789
15:42:37,916 --> 15:42:40,080
Veja um exemplo disso aqui que temos

23790
15:42:40,080 --> 15:42:42,160
Uma função simples chamada dizer idade é

23791
15:42:42,160 --> 15:42:43,840
tomar um parâmetro que é um

23792
15:42:43,840 --> 15:42:46,560
inteiro chamado idade e no corpo de

23793
15:42:46,560 --> 15:42:49,680
a função que estamos imprimindo a idade

23794
15:42:49,680 --> 15:42:52,080
depois de incrementar, suponha que isso seja

23795
15:42:52,080 --> 15:42:53,520
Algo útil

23796
15:42:53,520 --> 15:42:56,080
para o seu programa a função é dividida

23797
15:42:56,080 --> 15:42:58,560
em declaração e definição que temos

23798
15:42:58,560 --> 15:43:01,756
uma declaração no topo aqui e nós temos

23799
15:43:01,756 --> 15:43:04,880
nossa definição abaixo da função principal

23800
15:43:04,880 --> 15:43:06,796
na função principal, tentaremos

23801
15:43:06,796 --> 15:43:08,796
usar esta função que vamos chamá-lo

23802
15:43:08,796 --> 15:43:11,360
Aqui em baixo e vamos passar um

23803
15:43:11,360 --> 15:43:14,080
variável local que é chamada de idade como

23804
15:43:14,080 --> 15:43:17,276
nossa idade quando fazemos isso, esperamos que isso

23805
15:43:17,276 --> 15:43:19,916
para imprimir você tem 24 anos porque

23806
15:43:19,916 --> 15:43:21,840
Vamos aumentar a idade e

23807
15:43:21,840 --> 15:43:23,756
nós vamos dizer olá você tem 24 anos

23808
15:43:23,756 --> 15:43:25,680
anos de idade, é isso que este programa é

23809
15:43:25,680 --> 15:43:28,880
indo fazer, mas nós queremos manter o controle

23810
15:43:28,880 --> 15:43:31,916
de como a variável externa aqui é

23811
15:43:31,916 --> 15:43:34,560
Vamos mudar e a idade que temos

23812
15:43:34,560 --> 15:43:37,200
passou como um parâmetro aqui porque isso

23813
15:43:37,200 --> 15:43:39,916
edge que passamos como um parâmetro não está indo

23814
15:43:39,916 --> 15:43:42,796
ser o mesmo que a idade que temos no topo

23815
15:43:42,796 --> 15:43:45,116
Aqui o que passamos aqui como um parâmetro é

23816
15:43:45,116 --> 15:43:47,680
Será uma cópia do real

23817
15:43:47,680 --> 15:43:50,080
variável que passamos aqui e isso

23818
15:43:50,080 --> 15:43:52,640
O mecanismo é chamado de passar um parâmetro

23819
15:43:52,640 --> 15:43:55,116
pelo valor e o que você realmente passa é

23820
15:43:55,116 --> 15:43:57,756
Vou copiar e no que você trabalha

23821
15:43:57,756 --> 15:43:59,916
dentro do corpo da função não é

23822
15:43:59,916 --> 15:44:02,000
Será a coisa original você

23823
15:44:02,000 --> 15:44:04,560
Passado como um argumento para a função assim

23824
15:44:04,560 --> 15:44:06,560
Vamos tentar provar isso aqui

23825
15:44:06,560 --> 15:44:08,320
Vamos imprimir a idade antes de nós

23826
15:44:08,320 --> 15:44:10,160
chamar a função que vamos imprimir

23827
15:44:10,160 --> 15:44:12,640
A idade depois de chamar a função e

23828
15:44:12,640 --> 15:44:14,720
O que nós imprimimos aqui vai ser o

23829
15:44:14,720 --> 15:44:17,436
fora da variável porque aqui estamos em

23830
15:44:17,436 --> 15:44:18,560
o âmbito de aplicação

23831
15:44:18,560 --> 15:44:20,400
da principal função

23832
15:44:20,400 --> 15:44:23,200
dentro da função de borda de dizer o que nós somos

23833
15:44:23,200 --> 15:44:26,240
será modificador é uma cópia do armário

23834
15:44:26,240 --> 15:44:28,720
Então esperamos que a borda aqui permaneça a

23835
15:44:28,720 --> 15:44:32,000
mesmo antes e depois da chamada de função

23836
15:44:32,000 --> 15:44:33,756
então a maneira como isso vai funcionar quando

23837
15:44:33,756 --> 15:44:36,560
O controle tem essa função aqui é como

23838
15:44:36,560 --> 15:44:38,320
nós vamos ter uma situação como nós

23839
15:44:38,320 --> 15:44:40,956
Tenho aqui à esquerda, vamos definir

23840
15:44:40,956 --> 15:44:43,680
cópias locais na função que são

23841
15:44:43,680 --> 15:44:46,560
Vou conter o que foi passado como

23842
15:44:46,560 --> 15:44:49,276
um argumento para esta função e esta

23843
15:44:49,276 --> 15:44:51,680
A borda aqui foi passada como uma discussão para um

23844
15:44:51,680 --> 15:44:53,756
função para que nós vamos ter um local

23845
15:44:53,756 --> 15:44:56,080
cópia deste h e vamos armazenar

23846
15:44:56,080 --> 15:44:57,756
Isso e é o que vamos ser

23847
15:44:57,756 --> 15:45:00,640
manipular em nosso programa quando

23848
15:45:00,640 --> 15:45:03,040
A função sai do escopo do local

23849
15:45:03,040 --> 15:45:05,360
A cópia vai morrer e o exterior

23850
15:45:05,360 --> 15:45:07,040
A variável que temos aqui está basicamente indo

23851
15:45:07,040 --> 15:45:09,596
para não ser afetado vamos cabeça para

23852
15:45:09,596 --> 15:45:11,916
código de estúdio visual e mostrar-lhe isso em

23853
15:45:11,916 --> 15:45:13,116
Ação

23854
15:45:13,116 --> 15:45:15,916
Tudo bem aqui estamos em nossa pasta de trabalho

23855
15:45:15,916 --> 15:45:18,160
O projeto atual é passado pelo valor

23856
15:45:18,160 --> 15:45:20,640
nós vamos pegar nossos arquivos de modelo

23857
15:45:20,640 --> 15:45:22,880
E nós vamos colocá-los no lugar

23858
15:45:22,880 --> 15:45:25,596
O projeto correto e nós vamos

23859
15:45:25,596 --> 15:45:28,080
abrir isso no código do estúdio visual, vamos

23860
15:45:28,080 --> 15:45:30,000
Fazê isso, vamos abrir a pasta

23861
15:45:30,000 --> 15:45:33,040
que contém o projeto passar por valor

23862
15:45:33,040 --> 15:45:36,400
Vamos fazer isso, vamos abri-lo

23863
15:45:36,400 --> 15:45:39,520
e eu vou entrar no arquivo e

23864
15:45:39,520 --> 15:45:42,080
Limpe-o um pouco e nós estamos

23865
15:45:42,080 --> 15:45:44,080
Vou configurar uma função que vai

23866
15:45:44,080 --> 15:45:46,000
Não devolver nada

23867
15:45:46,000 --> 15:45:49,040
E vai dizer idade

23868
15:45:49,040 --> 15:45:50,720
E vai levar um inteiro que

23869
15:45:50,720 --> 15:45:52,880
Vai ser a nossa idade

23870
15:45:52,880 --> 15:45:55,040
E por dentro nós vamos incrementar o nosso

23871
15:45:55,040 --> 15:45:57,200
h Eu acho que isto é o que vimos no

23872
15:45:57,200 --> 15:45:59,596
slides e nós vamos dizer no entanto

23873
15:45:59,596 --> 15:46:01,596
Muitos anos você é velho que nós vamos

23874
15:46:01,596 --> 15:46:02,880
Diga olá

23875
15:46:02,880 --> 15:46:04,480
Você é

23876
15:46:04,480 --> 15:46:07,596
idade avançada e podemos configurar uma variável e

23877
15:46:07,596 --> 15:46:09,360
A principal função que vamos chamar

23878
15:46:09,360 --> 15:46:10,560
h

23879
15:46:10,560 --> 15:46:14,240
e vai conter 23 como nossa idade

23880
15:46:14,240 --> 15:46:15,916
nós vamos dizer idade e nós vamos

23881
15:46:15,916 --> 15:46:19,040
para passar em nossa era aqui nós podemos fazer isso

23882
15:46:19,040 --> 15:46:20,720
Se estamos tentando executar este programa

23883
15:46:20,720 --> 15:46:22,796
Vamos tentar fazer isso, vamos

23884
15:46:22,796 --> 15:46:25,916
construir com gcc e vamos trazer

23885
15:46:25,916 --> 15:46:28,080
em um terminal que podemos usar para executar isso

23886
15:46:28,080 --> 15:46:30,080
O programa facilmente a partir de

23887
15:46:30,080 --> 15:46:32,000
Código de estúdio visual aqui vamos rodar

23888
15:46:32,000 --> 15:46:33,596
booster, vamos dizer olá que você é

23889
15:46:33,596 --> 15:46:36,080
24 anos e isso é o que esperamos

23890
15:46:36,080 --> 15:46:38,320
porque quando essa função é chamada

23891
15:46:38,320 --> 15:46:39,840
Vamos aumentar a idade então

23892
15:46:39,840 --> 15:46:42,480
nós vamos dizer a idade, mas nós queremos

23893
15:46:42,480 --> 15:46:43,520
para ver

23894
15:46:43,520 --> 15:46:46,796
o que acontece com a orelha de borda externa

23895
15:46:46,796 --> 15:46:49,200
se modificarmos a borda interna que nós

23896
15:46:49,200 --> 15:46:51,276
ter sobre esta função aqui que foi

23897
15:46:51,276 --> 15:46:53,680
Passado como um argumento e novamente o que você

23898
15:46:53,680 --> 15:46:55,436
passar quando você está declarando seu

23899
15:46:55,436 --> 15:46:57,596
A função é o parâmetro e o que você

23900
15:46:57,596 --> 15:46:59,520
passar quando você está chamando a função

23901
15:46:59,520 --> 15:47:01,916
é chamado de argumento em c plus mais

23902
15:47:01,916 --> 15:47:04,000
Por favor, lembre-se disso o que passamos

23903
15:47:04,000 --> 15:47:06,480
como argumento é a nossa variável anti-idade

23904
15:47:06,480 --> 15:47:09,680
que é local para a função principal

23905
15:47:09,680 --> 15:47:11,200
e vamos ver o que acontece com

23906
15:47:11,200 --> 15:47:14,320
Vamos imprimir a idade

23907
15:47:14,320 --> 15:47:17,360
e dizer idade antes da chamada

23908
15:47:17,360 --> 15:47:19,276
Acho que isso é bastante descritivo e

23909
15:47:19,276 --> 15:47:21,040
nós vamos imprimir isso e nós somos

23910
15:47:21,040 --> 15:47:23,596
indo para ir depois que a função é chamada

23911
15:47:23,596 --> 15:47:25,680
nós vamos dizer a mesma coisa, mas

23912
15:47:25,680 --> 15:47:28,000
nós vamos dizer depois da chamada

23913
15:47:28,000 --> 15:47:28,796
E a

23914
15:47:28,796 --> 15:47:30,796
por depois que queremos dizer depois de chamarmos o

23915
15:47:30,796 --> 15:47:32,796
A função diga h aqui eu acho que isso é

23916
15:47:32,796 --> 15:47:34,720
Descritivo o suficiente e nós vamos

23917
15:47:34,720 --> 15:47:37,520
Veja se incrementa o local

23918
15:47:37,520 --> 15:47:40,080
variável para a função aqui afeta

23919
15:47:40,080 --> 15:47:42,160
a variável que temos e o escopo

23920
15:47:42,160 --> 15:47:45,040
da função principal ok, então vamos ver

23921
15:47:45,040 --> 15:47:47,756
que vamos construir com gcc como

23922
15:47:47,756 --> 15:47:50,240
Sempre

23923
15:47:50,240 --> 15:47:52,720
E a riqueza é boa, então vamos limpar

23924
15:47:52,720 --> 15:47:54,880
e correr galo você vai ver que

23925
15:47:54,880 --> 15:47:57,840
antes da chamada, temos 23 e depois do

23926
15:47:57,840 --> 15:48:00,560
call we have 23 nós não mudamos o

23927
15:48:00,560 --> 15:48:02,000
segunda chamada

23928
15:48:02,000 --> 15:48:04,240
Este é um erro clássico de pasta de texto

23929
15:48:04,240 --> 15:48:06,240
nós vamos mudar isso

23930
15:48:06,240 --> 15:48:08,720
para que o nosso programa seja realmente descritivo

23931
15:48:08,720 --> 15:48:10,080
O suficiente

23932
15:48:10,080 --> 15:48:12,320
Ok, o mundo é bom, podemos limpar e

23933
15:48:12,320 --> 15:48:15,116
correr galo e agora temos antes de chamar

23934
15:48:15,116 --> 15:48:18,880
23 após a idade de chamada é 23, não foi

23935
15:48:18,880 --> 15:48:22,000
Mudou pelo que temos aqui e

23936
15:48:22,000 --> 15:48:24,240
Podemos até ir mais longe e olhar para o

23937
15:48:24,240 --> 15:48:26,560
Endereços de memória desses caras

23938
15:48:26,560 --> 15:48:29,596
Aqui podemos tentar imprimir o endereço de

23939
15:48:29,596 --> 15:48:31,916
A variável idade, vamos fazer isso

23940
15:48:31,916 --> 15:48:34,160
nós vamos dizer

23941
15:48:34,160 --> 15:48:36,400
Endereço da idade

23942
15:48:36,400 --> 15:48:39,040
E colocar isso aqui nós vamos dizer

23943
15:48:39,040 --> 15:48:41,040
Endereço da idade

23944
15:48:41,040 --> 15:48:43,200
Não há grande coisa aqui, podemos fechar o painel

23945
15:48:43,200 --> 15:48:46,480
à esquerda aqui porque está tomando

23946
15:48:46,480 --> 15:48:48,796
Espaço valioso e vamos para

23947
15:48:48,796 --> 15:48:50,956
A segunda declaração e colocar no

23948
15:48:50,956 --> 15:48:53,040
Endereço da idade

23949
15:48:53,040 --> 15:48:54,720
e nós vamos imprimir que podemos

23950
15:48:54,720 --> 15:48:56,480
fazer isso agora nós sabemos

23951
15:48:56,480 --> 15:48:59,040
O endereço do operador

23952
15:48:59,040 --> 15:49:00,796
Ok, podemos fazer isso

23953
15:49:00,796 --> 15:49:03,200
E quando atingimos o corpo da nossa função

23954
15:49:03,200 --> 15:49:04,956
Aqui também podemos imprimir o endereço de

23955
15:49:04,956 --> 15:49:06,080
A idade

23956
15:49:06,080 --> 15:49:07,756
sem grande negócio

23957
15:49:07,756 --> 15:49:09,756
Assim podemos dizer

23958
15:49:09,756 --> 15:49:12,640
endereço da idade, vamos fazer isso aqui e

23959
15:49:12,640 --> 15:49:15,436
Vamos imprimir o endereço do

23960
15:49:15,436 --> 15:49:17,840
variável de borda local aqui que foi

23961
15:49:17,840 --> 15:49:20,880
passado como um parâmetro aqui ok agora

23962
15:49:20,880 --> 15:49:23,520
pode construir o nosso programa e assistir aqueles

23963
15:49:23,520 --> 15:49:27,520
endereços que vamos construir com gcc

23964
15:49:27,520 --> 15:49:29,680
O mundo é bom, podemos limpar

23965
15:49:29,680 --> 15:49:31,276
e correr um galo

23966
15:49:31,276 --> 15:49:33,840
Agora você vê que a variável externa é

23967
15:49:33,840 --> 15:49:36,480
Vai sair em um endereço que termina

23968
15:49:36,480 --> 15:49:38,000
em dec

23969
15:49:38,000 --> 15:49:39,840
e a variável local vai sair

23970
15:49:39,840 --> 15:49:43,276
em um endereço que termina em dc0, então isso

23971
15:49:43,276 --> 15:49:46,080
é uma localização de memória completamente nova que

23972
15:49:46,080 --> 15:49:48,400
Estamos usando e vai apenas

23973
15:49:48,400 --> 15:49:51,916
Contém uma cópia do que passamos como um

23974
15:49:51,916 --> 15:49:54,000
parâmetro aqui eo compilador está indo

23975
15:49:54,000 --> 15:49:56,240
Para cuidar da criação desta cópia

23976
15:49:56,240 --> 15:49:58,956
variável e tê-lo disponível para uso

23977
15:49:58,956 --> 15:50:00,560
na função local aqui não temos

23978
15:50:00,560 --> 15:50:02,796
para nos preocuparmos com isso, mas temos que ser

23979
15:50:02,796 --> 15:50:06,080
conscientes do que estamos trabalhando e

23980
15:50:06,080 --> 15:50:08,956
A mesma função de idade aqui é uma cópia

23981
15:50:08,956 --> 15:50:11,200
Não é o valor original que é

23982
15:50:11,200 --> 15:50:12,640
Realmente tudo o que nos posicionamos para fazer nisso

23983
15:50:12,640 --> 15:50:15,520
palestrando fazendo você ciente da chamada por

23984
15:50:15,520 --> 15:50:18,560
mecanismo de valor e a mensagem principal é

23985
15:50:18,560 --> 15:50:21,200
O que você está trabalhando no corpo

23986
15:50:21,200 --> 15:50:23,436
de sua função quando é chamado

23987
15:50:23,436 --> 15:50:25,916
Vai ser uma cópia do que você tem

23988
15:50:25,916 --> 15:50:29,116
Passado como um argumento quando sua função

23989
15:50:29,116 --> 15:50:30,796
Foi chamado aqui

23990
15:50:30,796 --> 15:50:32,320
Nesta palestra vamos ver como

23991
15:50:32,320 --> 15:50:35,116
nós podemos passar parâmetros para funções por

23992
15:50:35,116 --> 15:50:37,360
O ponteiro isso vai nos permitir

23993
15:50:37,360 --> 15:50:39,276
Evite as cópias que nós fomos

23994
15:50:39,276 --> 15:50:41,596
experimentando quando estávamos passando

23995
15:50:41,596 --> 15:50:45,116
parâmetros por valor como vimos em

23996
15:50:45,116 --> 15:50:47,756
As últimas palestras aqui são simples

23997
15:50:47,756 --> 15:50:50,240
exemplo mostrando a sintaxe que podemos usar para

23998
15:50:50,240 --> 15:50:52,400
passar parâmetros por ponteiro

23999
15:50:52,400 --> 15:50:54,720
Em cima aqui temos a nossa função

24000
15:50:54,720 --> 15:50:57,436
Declaração e aqui em baixo temos o nosso

24001
15:50:57,436 --> 15:50:59,840
definição de função e você vê que

24002
15:50:59,840 --> 15:51:02,080
A sintaxe é a mesma que estamos passando

24003
15:51:02,080 --> 15:51:04,640
ponteiro e por ponteiro e

24004
15:51:04,640 --> 15:51:07,200
Definição aqui e outra coisa você

24005
15:51:07,200 --> 15:51:09,200
Deve ter cuidado é isso quando você

24006
15:51:09,200 --> 15:51:12,000
chamar uma função que passa pelo ponteiro

24007
15:51:12,000 --> 15:51:14,640
você tem que dar-lhe um endereço e

24008
15:51:14,640 --> 15:51:16,560
Isso é o que estamos fazendo aqui, então estamos

24009
15:51:16,560 --> 15:51:20,160
passando o endereço da nossa variável etária

24010
15:51:20,160 --> 15:51:22,400
que vai ser passado pelo ponteiro

24011
15:51:22,400 --> 15:51:24,720
Quando passamos pelo ponteiro, queremos ser

24012
15:51:24,720 --> 15:51:28,640
Modificar uma cópia dentro do corpo do nosso

24013
15:51:28,640 --> 15:51:31,360
Função se você olhar aqui estamos

24014
15:51:31,360 --> 15:51:34,320
incrementando a variável de borda, mas nós

24015
15:51:34,320 --> 15:51:36,956
estão fazendo isso através da referência

24016
15:51:36,956 --> 15:51:39,040
quando passamos por um ponteiro aqui o

24017
15:51:39,040 --> 15:51:41,276
O ponteiro vai conter o endereço

24018
15:51:41,276 --> 15:51:42,880
de um tipo deste tipo

24019
15:51:42,880 --> 15:51:45,596
No corpo da função

24020
15:51:45,596 --> 15:51:48,080
ponteiro, teremos este ponteiro de borda

24021
15:51:48,080 --> 15:51:51,436
Vai apontar para o original

24022
15:51:51,436 --> 15:51:54,320
variável aqui está tudo bem, então este ponteiro de borda

24023
15:51:54,320 --> 15:51:56,320
Vai apontar para o original

24024
15:51:56,320 --> 15:51:57,596
variável de borda

24025
15:51:57,596 --> 15:52:00,160
quando o desreferencemos e modificamos o

24026
15:52:00,160 --> 15:52:02,160
variável que vamos afetar o

24027
15:52:02,160 --> 15:52:03,840
A variável original eu realmente espero que isso

24028
15:52:03,840 --> 15:52:05,916
Faz sentido e isto é realmente o que

24029
15:52:05,916 --> 15:52:08,400
passar pelo ponteiro é tudo sobre você

24030
15:52:08,400 --> 15:52:10,240
Declarar suas funções passando

24031
15:52:10,240 --> 15:52:12,560
ponteiros como este e na definição

24032
15:52:12,560 --> 15:52:14,796
você faz o mesmo e quando você chama o

24033
15:52:14,796 --> 15:52:17,436
função que você precisa passar em um endereço

24034
15:52:17,436 --> 15:52:19,756
da variável porque é isso que nós

24035
15:52:19,756 --> 15:52:21,840
armazene em um ponteiro aqui e isso é

24036
15:52:21,840 --> 15:52:23,916
indo para o trabalho se tentarmos executar isso

24037
15:52:23,916 --> 15:52:26,720
Um exemplo aqui vamos imprimir 23

24038
15:52:26,720 --> 15:52:29,436
Porque esse é o valor original que somos

24039
15:52:29,436 --> 15:52:31,360
Vamos chamar a idade de dizer que estamos indo

24040
15:52:31,360 --> 15:52:33,436
para incrementar e isso vai mudar

24041
15:52:33,436 --> 15:52:35,520
O valor original se imprimirmos aqui

24042
15:52:35,520 --> 15:52:38,956
nós vamos ter 24 e quando isso

24043
15:52:38,956 --> 15:52:41,276
A função termina que vamos acertar

24044
15:52:41,276 --> 15:52:43,040
Esta declaração aqui e nós vamos

24045
15:52:43,040 --> 15:52:46,240
impressão 24 é isso que vamos ver

24046
15:52:46,240 --> 15:52:48,400
quando começarmos a executar este programa aqui e

24047
15:52:48,400 --> 15:52:50,000
Isso é realmente tudo o que há sobre

24048
15:52:50,000 --> 15:52:52,560
passando pelo ponteiro, vamos cabeçar

24049
15:52:52,560 --> 15:52:54,956
sobre o código do estúdio visual e jogar com

24050
15:52:54,956 --> 15:52:58,480
nós um pouco mais bem aqui estamos em nosso

24051
15:52:58,480 --> 15:53:00,796
pasta de trabalho o projeto atual é

24052
15:53:00,796 --> 15:53:03,200
Passado pelo ponteiro que vamos pegar

24053
15:53:03,200 --> 15:53:05,520
nossos arquivos de modelo aqui

24054
15:53:05,520 --> 15:53:07,276
e nós vamos colocá-los no

24055
15:53:07,276 --> 15:53:11,116
Projeto atual que é passado por ponteiro

24056
15:53:11,116 --> 15:53:12,880
Vamos abrir isso em visual

24057
15:53:12,880 --> 15:53:14,880
Código de estúdio muito rápido que vamos

24058
15:53:14,880 --> 15:53:18,080
escolher aquele passe pelo ponteiro nós abrimos isso

24059
15:53:18,080 --> 15:53:20,796
e nosso arquivo principal cpp deve aparecer

24060
15:53:20,796 --> 15:53:21,596
Aqui

24061
15:53:21,596 --> 15:53:25,276
nós vamos limpá-lo um pouco

24062
15:53:25,276 --> 15:53:27,520
Na verdade, vamos pegar o código

24063
15:53:27,520 --> 15:53:29,756
da última palestra e coloque isso em

24064
15:53:29,756 --> 15:53:32,480
Aqui e isso vai ser o nosso começo

24065
15:53:32,480 --> 15:53:34,796
ponto vamos fechar o painel esquerdo aqui, então

24066
15:53:34,796 --> 15:53:37,116
que temos algum espaço para respirar o

24067
15:53:37,116 --> 15:53:39,840
A função aqui diz que h vai passar

24068
15:53:39,840 --> 15:53:42,320
ponteiro, então devemos tirar esse custo

24069
15:53:42,320 --> 15:53:43,436
Aqui

24070
15:53:43,436 --> 15:53:46,080
E uh ter um ponteiro aqui como nós tivemos

24071
15:53:46,080 --> 15:53:48,796
nos slides vamos fazer o mesmo

24072
15:53:48,796 --> 15:53:50,160
em nosso

24073
15:53:50,160 --> 15:53:52,400
Definição aqui, se cairmos, estamos

24074
15:53:52,400 --> 15:53:54,080
Vou fazer isso, vamos passar

24075
15:53:54,080 --> 15:53:56,400
ponteiro e nós vamos descomer

24076
15:53:56,400 --> 15:53:59,360
A linha que aumenta a nossa idade aqui

24077
15:53:59,360 --> 15:54:01,200
Tudo bem depois de fazermos que você vê que nós

24078
15:54:01,200 --> 15:54:03,520
ter uma linha de squiggly nesta linha que

24079
15:54:03,520 --> 15:54:06,880
Chama a função de dizer idade do que precisamos

24080
15:54:06,880 --> 15:54:09,756
fazer isso é passar o endereço do

24081
15:54:09,756 --> 15:54:12,320
uma variável de borda aqui como vimos no

24082
15:54:12,320 --> 15:54:14,480
slide então esta é a sintaxe que temos que

24083
15:54:14,480 --> 15:54:15,520
Seguir

24084
15:54:15,520 --> 15:54:17,520
Uma vez que fazemos isso, este programa vai

24085
15:54:17,520 --> 15:54:19,916
ser válido e se nós executarmos aqui estamos

24086
15:54:19,916 --> 15:54:22,400
Vou imprimir 23 porque esse é o

24087
15:54:22,400 --> 15:54:24,400
valor que temos aqui nós vamos

24088
15:54:24,400 --> 15:54:26,720
chamar a função de idade dizer que estamos indo

24089
15:54:26,720 --> 15:54:29,596
para aumentar a idade e aqui nos esquecemos de

24090
15:54:29,596 --> 15:54:32,720
fazer nosso dereferenciamento, então o que precisamos

24091
15:54:32,720 --> 15:54:35,680
fazer aqui é desreferenciar a idade e

24092
15:54:35,680 --> 15:54:38,160
incremente isso vai incrementar

24093
15:54:38,160 --> 15:54:40,240
A variável original aqui e nós somos

24094
15:54:40,240 --> 15:54:42,640
vai acessar isso através do

24095
15:54:42,640 --> 15:54:45,520
o operador de referência do nosso ponteiro

24096
15:54:45,520 --> 15:54:48,000
Aqui se atingimos esta linha e a

24097
15:54:48,000 --> 15:54:50,640
Função aqui vamos imprimir 24

24098
15:54:50,640 --> 15:54:52,796
Porque o valor tem sido

24099
15:54:52,796 --> 15:54:56,400
incrementado através desta declaração aqui

24100
15:54:56,400 --> 15:54:58,400
e depois da chamada de função, vamos

24101
15:54:58,400 --> 15:55:02,000
para acertar esta declaração aqui na linha 10

24102
15:55:02,000 --> 15:55:04,320
e vai imprimir 24. isto é

24103
15:55:04,320 --> 15:55:05,680
O que nós esperamos

24104
15:55:05,680 --> 15:55:07,360
Tenha um momento para ter certeza de que você realmente

24105
15:55:07,360 --> 15:55:09,360
Entenda isso as coisas que você precisa

24106
15:55:09,360 --> 15:55:12,400
ter cuidado com a sintaxe que usamos para

24107
15:55:12,400 --> 15:55:15,200
Declarar a função aqui dizemos que nós

24108
15:55:15,200 --> 15:55:17,276
estão passando por ponteiro por causa disso

24109
15:55:17,276 --> 15:55:19,840
pequena estrela aqui e nós temos o mesmo

24110
15:55:19,840 --> 15:55:21,916
Uma coisa quando atingimos a definição de

24111
15:55:21,916 --> 15:55:24,240
função temos essa pequena estrela, então nós

24112
15:55:24,240 --> 15:55:26,320
estão passando pelo ponteiro outra coisa que você

24113
15:55:26,320 --> 15:55:28,796
Deve lembrar-se é passar o endereço

24114
15:55:28,796 --> 15:55:31,276
de uma variável quando você chama a função

24115
15:55:31,276 --> 15:55:33,916
como fazemos aqui e por favor lembre-se de

24116
15:55:33,916 --> 15:55:36,720
Utilize o operador de referência sempre que

24117
15:55:36,720 --> 15:55:39,840
você quer modificar qualquer variável

24118
15:55:39,840 --> 15:55:42,080
saindo no endereço que você passou

24119
15:55:42,080 --> 15:55:44,080
aqui é por isso que somos o

24120
15:55:44,080 --> 15:55:46,480
referência aqui através da estrela

24121
15:55:46,480 --> 15:55:48,956
Operador como estamos fazendo aqui, isso é

24122
15:55:48,956 --> 15:55:51,116
Realmente tudo o que você precisa para ter cuidado

24123
15:55:51,116 --> 15:55:53,116
Então vamos tentar correr isso

24124
15:55:53,116 --> 15:55:54,720
programa, vamos fazer isso, vamos

24125
15:55:54,720 --> 15:55:57,916
construção com gcc

24126
15:55:58,240 --> 15:56:00,000
A caldeira vai passar por nós

24127
15:56:00,000 --> 15:56:02,720
Necessidade de trazer um terminal

24128
15:56:02,720 --> 15:56:05,200
para que possamos executar este programa e

24129
15:56:05,200 --> 15:56:09,916
Esperamos ver um 23 24 e 24

24130
15:56:09,916 --> 15:56:11,436
aqui imprima para fora

24131
15:56:11,436 --> 15:56:13,520
Então vamos correr o galo

24132
15:56:13,520 --> 15:56:17,040
Tudo bem aqui é a nossa saída antes de chamar

24133
15:56:17,040 --> 15:56:19,680
A função de idade diz que a idade é de 23 anos.

24134
15:56:19,680 --> 15:56:23,200
O endereço é necessário quando atingimos a função

24135
15:56:23,200 --> 15:56:25,680
Estamos dizendo olá, você é

24136
15:56:25,680 --> 15:56:29,116
uh anos de idade, então aqui devemos ter o

24137
15:56:29,116 --> 15:56:32,080
Referência para acessar algo dentro do

24138
15:56:32,080 --> 15:56:34,640
variável aqui, então devemos dizer que você é

24139
15:56:34,640 --> 15:56:37,276
Idade avançada, precisamos desreferenciar esse cara

24140
15:56:37,276 --> 15:56:39,200
Porque agora é um ponteiro que eu esqueci

24141
15:56:39,200 --> 15:56:41,840
que eu realmente sinto muito, mas nós estamos

24142
15:56:41,840 --> 15:56:43,200
Aprendizado assim

24143
15:56:43,200 --> 15:56:45,200
Esta é uma boa oportunidade de aprendizado para você

24144
15:56:45,200 --> 15:56:47,276
Não cometer o mesmo erro que eu sou

24145
15:56:47,276 --> 15:56:50,160
fazendo aqui então vamos tentar construir novamente

24146
15:56:50,160 --> 15:56:52,796
Devemos ver a saída correta que somos

24147
15:56:52,796 --> 15:56:54,400
indo para limpar

24148
15:56:54,400 --> 15:56:57,840
e correr galo agora vemos que antes

24149
15:56:57,840 --> 15:56:58,880
a chamada

24150
15:56:58,880 --> 15:57:01,756
idades 23 quando chamamos a função h

24151
15:57:01,756 --> 15:57:04,796
torna-se 24 porque nós apenas incrementamos

24152
15:57:04,796 --> 15:57:07,596
através do nosso operador de referência e após

24153
15:57:07,596 --> 15:57:09,200
a função chamar a borda vai

24154
15:57:09,200 --> 15:57:10,480
ser 24

24155
15:57:10,480 --> 15:57:12,956
porque nós modificamos o original

24156
15:57:12,956 --> 15:57:15,276
variável aqui através do nosso

24157
15:57:15,276 --> 15:57:18,000
Referindo o ponteiro aqui este é

24158
15:57:18,000 --> 15:57:20,160
Realmente tudo o que há sobre passar por

24159
15:57:20,160 --> 15:57:22,320
O ponteiro é a sintaxe que você precisa

24160
15:57:22,320 --> 15:57:24,480
passar um ponteiro na declaração que você

24161
15:57:24,480 --> 15:57:26,560
Você tem que passar um ponteiro na função

24162
15:57:26,560 --> 15:57:28,400
definição e quando você chama a

24163
15:57:28,400 --> 15:57:31,436
função você tem que usar o endereço de

24164
15:57:31,436 --> 15:57:33,360
a variável e passar isso como um

24165
15:57:33,360 --> 15:57:35,520
argumento para a função e quando

24166
15:57:35,520 --> 15:57:37,840
você precisa usar o parâmetro passado

24167
15:57:37,840 --> 15:57:39,276
Você vai passar pelo

24168
15:57:39,276 --> 15:57:42,480
Operador de referência como fizemos aqui

24169
15:57:42,480 --> 15:57:45,756
e aqui no corpo da nossa função

24170
15:57:45,756 --> 15:57:46,720
Aqui

24171
15:57:46,720 --> 15:57:48,240
Nesta palestra vamos ver como

24172
15:57:48,240 --> 15:57:51,436
nós podemos passar os parâmetros para uma função por

24173
15:57:51,436 --> 15:57:52,560
Referência

24174
15:57:52,560 --> 15:57:54,560
e esta é outra técnica que podemos usar

24175
15:57:54,560 --> 15:57:57,276
para evitar passar pelo valor que está indo

24176
15:57:57,276 --> 15:57:59,680
para criar uma cópia e a sintaxe é

24177
15:57:59,680 --> 15:58:01,916
muito simples se você olhar para o

24178
15:58:01,916 --> 15:58:03,916
Declaração aqui você vai ver

24179
15:58:03,916 --> 15:58:07,116
que dizemos e fazemos referência e novamente se

24180
15:58:07,116 --> 15:58:09,276
nós atingimos a definição que vamos dizer

24181
15:58:09,276 --> 15:58:11,520
em referência como você vê aqui

24182
15:58:11,520 --> 15:58:13,520
quando chamamos a função que não temos

24183
15:58:13,520 --> 15:58:16,160
para passar o endereço do operador apenas

24184
15:58:16,160 --> 15:58:17,680
passou a variável porque isso é

24185
15:58:17,680 --> 15:58:20,160
vai ser tratado como uma referência por

24186
15:58:20,160 --> 15:58:22,720
O compilador e no corpo do

24187
15:58:22,720 --> 15:58:25,040
Função que não temos que passar

24188
15:58:25,040 --> 15:58:27,680
feio a referência como fizemos com

24189
15:58:27,680 --> 15:58:30,080
ponteiros e espero que você possa ver isso

24190
15:58:30,080 --> 15:58:33,116
se você quiser evitar cópias que passam

24191
15:58:33,116 --> 15:58:35,360
As referências são muito mais limpas que você não

24192
15:58:35,360 --> 15:58:37,840
tem que usar o endereço do operador quando

24193
15:58:37,840 --> 15:58:40,560
Você chama a função como fazemos aqui

24194
15:58:40,560 --> 15:58:42,640
E você não precisa passar pelo

24195
15:58:42,640 --> 15:58:45,436
referência e para acessar e modificar sua

24196
15:58:45,436 --> 15:58:48,160
variáveis e a modificação que fazemos

24197
15:58:48,160 --> 15:58:51,040
Aqui, incrementando a idade, será

24198
15:58:51,040 --> 15:58:54,080
visto do lado de fora porque estamos indo

24199
15:58:54,080 --> 15:58:56,320
através de uma referência e a referência é

24200
15:58:56,320 --> 15:58:59,276
uma verdadeira aliança com a variável que

24201
15:58:59,276 --> 15:59:01,520
A referência é referenciar, por

24202
15:59:01,520 --> 15:59:03,680
incrementando a borda aqui e o corpo

24203
15:59:03,680 --> 15:59:05,680
da função que a mudança vai

24204
15:59:05,680 --> 15:59:08,956
ser visto após a chamada de função antes

24205
15:59:08,956 --> 15:59:11,520
A função aqui vamos ter 23

24206
15:59:11,520 --> 15:59:12,956
no corpo da função que estamos indo

24207
15:59:12,956 --> 15:59:15,360
para obter 24, porque nós apenas incrementamos

24208
15:59:15,360 --> 15:59:17,916
a função e após a chamada da função

24209
15:59:17,916 --> 15:59:20,720
Vamos ter um 24, porque o

24210
15:59:20,720 --> 15:59:23,596
A mudança foi propagada para a original

24211
15:59:23,596 --> 15:59:26,240
A variável e a razão é porque nós

24212
15:59:26,240 --> 15:59:28,560
estão passando por uma referência aqui

24213
15:59:28,560 --> 15:59:30,720
Vamos ao código do estúdio visual e

24214
15:59:30,720 --> 15:59:33,200
realmente jogar com a gente um pouco mais bem

24215
15:59:33,200 --> 15:59:35,276
Aqui estamos no código visual do estúdio o

24216
15:59:35,276 --> 15:59:37,916
O projeto atual é passado por referência

24217
15:59:37,916 --> 15:59:41,200
1710 aqui, então vamos pegar o nosso

24218
15:59:41,200 --> 15:59:44,320
template files e colocá-los no lugar

24219
15:59:44,320 --> 15:59:45,840
1710

24220
15:59:45,840 --> 15:59:48,240
Vamos fazer isso e vamos abrir

24221
15:59:48,240 --> 15:59:50,400
Isso em código de estúdio visual muito rápido

24222
15:59:50,400 --> 15:59:52,956
Vamos fazer isso que o arquivo cpp principal está indo

24223
15:59:52,956 --> 15:59:55,520
para aparecer aqui novamente, vamos

24224
15:59:55,520 --> 15:59:57,680
Pegue o código da última palestra e

24225
15:59:57,680 --> 16:00:00,320
Use isso como ponto de partida e nós somos

24226
16:00:00,320 --> 16:00:02,720
vamos modificar a assinatura de

24227
16:00:02,720 --> 16:00:05,040
nossa função aqui, então o que queremos fazer

24228
16:00:05,040 --> 16:00:07,276
É passar por referência que vamos

24229
16:00:07,276 --> 16:00:09,596
Diga em referência aqui você já

24230
16:00:09,596 --> 16:00:12,640
Conhecer referências de um capítulo anterior

24231
16:00:12,640 --> 16:00:14,796
e nós vamos acertar a definição

24232
16:00:14,796 --> 16:00:17,680
aqui e fazer a mesma coisa, então vamos dizer

24233
16:00:17,680 --> 16:00:19,756
e referência

24234
16:00:19,756 --> 16:00:21,116
A idade

24235
16:00:21,116 --> 16:00:23,040
E quando chamamos a função, não

24236
16:00:23,040 --> 16:00:25,436
necessidade de passar o endereço do operador

24237
16:00:25,436 --> 16:00:27,360
Porque esta é uma referência que podemos usar

24238
16:00:27,360 --> 16:00:29,756
imediatamente, o compilador vai

24239
16:00:29,756 --> 16:00:31,916
Saiba que isso vai ser um

24240
16:00:31,916 --> 16:00:33,916
referência à variável original que

24241
16:00:33,916 --> 16:00:35,276
Passamos por aqui

24242
16:00:35,276 --> 16:00:37,520
e no corpo da função, vamos

24243
16:00:37,520 --> 16:00:39,520
tirar esta última linha aqui que não temos

24244
16:00:39,520 --> 16:00:42,400
Precisa dele e no corpo quando queremos

24245
16:00:42,400 --> 16:00:43,596
modificar

24246
16:00:43,596 --> 16:00:46,000
A referência que podemos fazer isso imediatamente

24247
16:00:46,000 --> 16:00:48,080
sem a referência para que possamos apenas

24248
16:00:48,080 --> 16:00:51,596
Diga mais mais h aqui e as mudanças são

24249
16:00:51,596 --> 16:00:53,596
Será propagado para o original

24250
16:00:53,596 --> 16:00:56,080
variável aqui porque estamos indo

24251
16:00:56,080 --> 16:00:58,400
através de uma referência vamos descer e

24252
16:00:58,400 --> 16:01:00,400
modificar isso porque esta é uma referência

24253
16:01:00,400 --> 16:01:02,480
nós podemos usá-lo imediatamente

24254
16:01:02,480 --> 16:01:05,840
e nós podemos fechar este painel esquerdo aqui assim

24255
16:01:05,840 --> 16:01:08,956
que temos mais espaço para respirar

24256
16:01:08,956 --> 16:01:11,116
e você vê que o código do estúdio visual é

24257
16:01:11,116 --> 16:01:14,080
Não nos dando mais nenhuma linha squiggly

24258
16:01:14,080 --> 16:01:17,200
assim, isso deve ser válido c plus mais código

24259
16:01:17,200 --> 16:01:19,840
novamente notar as sintaxes que estamos usando

24260
16:01:19,840 --> 16:01:23,520
Aqui estamos passando uma referência em nossa

24261
16:01:23,520 --> 16:01:26,320
declaração de que estamos passando uma referência

24262
16:01:26,320 --> 16:01:28,796
em nossa definição de função aqui quando

24263
16:01:28,796 --> 16:01:30,720
chamar a função que não precisamos fazer

24264
16:01:30,720 --> 16:01:33,200
qualquer endereço do operador que passamos

24265
16:01:33,200 --> 16:01:34,956
A variável como é

24266
16:01:34,956 --> 16:01:36,880
e no corpo da função não

24267
16:01:36,880 --> 16:01:39,040
você tem que fazer qualquer dereferenciamento que podemos

24268
16:01:39,040 --> 16:01:40,720
incremento imediatamente

24269
16:01:40,720 --> 16:01:43,200
ou modificar a variável como quisermos

24270
16:01:43,200 --> 16:01:45,360
As mudanças serão propagadas

24271
16:01:45,360 --> 16:01:47,916
para a variável original porque nós somos

24272
16:01:47,916 --> 16:01:49,200
passando uma referência para que o

24273
16:01:49,200 --> 16:01:51,360
A incrementação aqui também vai

24274
16:01:51,360 --> 16:01:54,160
afetar a variável original que foi

24275
16:01:54,160 --> 16:01:56,480
declarada na função principal aqui vamos

24276
16:01:56,480 --> 16:01:59,436
tirar isso e aqui, se precisarmos

24277
16:01:59,436 --> 16:02:01,116
para usar nossa variável, vamos apenas

24278
16:02:01,116 --> 16:02:03,040
use-o imediatamente, não precisamos de nenhum

24279
16:02:03,040 --> 16:02:06,000
fazendo referência e se imprimirmos o endereço

24280
16:02:06,000 --> 16:02:08,400
Da idade aqui vamos ver o mesmo

24281
16:02:08,400 --> 16:02:10,400
endereço que vemos no exterior porque

24282
16:02:10,400 --> 16:02:12,720
Este é um verdadeiro apelido que vai ser

24283
16:02:12,720 --> 16:02:15,040
referenciando a mesma variável que nós

24284
16:02:15,040 --> 16:02:17,520
Tenho no main aqui ok agora que você tem

24285
16:02:17,520 --> 16:02:19,916
Uma ideia melhor sobre isso, vamos

24286
16:02:19,916 --> 16:02:22,000
Tente construir isso, vamos usar

24287
16:02:22,000 --> 16:02:24,880
gcc como sempre você pode ver que a construção

24288
16:02:24,880 --> 16:02:25,916
É bom

24289
16:02:25,916 --> 16:02:28,880
se trouxermos um terminal para tentar correr

24290
16:02:28,880 --> 16:02:30,720
este programa

24291
16:02:30,720 --> 16:02:33,116
nós podemos limpar e correr galo

24292
16:02:33,116 --> 16:02:35,276
nós vamos ver isso antes de ligar

24293
16:02:35,276 --> 16:02:38,320
A função h é 23 mas o endereço

24294
16:02:38,320 --> 16:02:40,240
Fim em dec

24295
16:02:40,240 --> 16:02:42,956
Quando atingimos a função a borda é 24

24296
16:02:42,956 --> 16:02:46,160
Porque nós apenas incrementamos isso aqui

24297
16:02:46,160 --> 16:02:48,240
mas note que o endereço do

24298
16:02:48,240 --> 16:02:51,116
variável é a mesma que no exterior

24299
16:02:51,116 --> 16:02:53,756
assim, estamos modificando a mesma variável

24300
16:02:53,756 --> 16:02:56,640
e quando a função é feita a borda

24301
16:02:56,640 --> 16:02:59,520
Ainda serão 24, porque nós apenas

24302
16:02:59,520 --> 16:03:02,480
modificou a variável original através de um

24303
16:03:02,480 --> 16:03:04,796
referência aqui ok este é o efeito

24304
16:03:04,796 --> 16:03:07,360
de passagem por referência você pode usar um

24305
16:03:07,360 --> 16:03:10,000
reivindicação de sintaxe para modificar o original

24306
16:03:10,000 --> 16:03:12,880
variável em suas funções e isso é

24307
16:03:12,880 --> 16:03:15,840
Vou evitar cópias como vimos

24308
16:03:15,840 --> 16:03:18,400
quando estávamos passando parâmetros por valor

24309
16:03:18,400 --> 16:03:21,200
Algumas palestras de volta eu gostaria de

24310
16:03:21,200 --> 16:03:23,596
Congratula-se com você neste novo capítulo onde nós

24311
16:03:23,596 --> 16:03:26,796
Você se concentrará em como obter dados

24312
16:03:26,796 --> 16:03:29,116
das funções novamente o modelo do

24313
16:03:29,116 --> 16:03:31,756
A função é realmente o que você vê aqui

24314
16:03:31,756 --> 16:03:34,400
é como uma máquina e você pode dar entrada

24315
16:03:34,400 --> 16:03:36,956
para essa máquina e você espera obter

24316
16:03:36,956 --> 16:03:39,276
Algo fora daquela máquina isso

24317
16:03:39,276 --> 16:03:41,680
O capítulo vai focar nesta parte

24318
16:03:41,680 --> 16:03:42,400
Aqui

24319
16:03:42,400 --> 16:03:43,916
E nós vamos ver o diferente

24320
16:03:43,916 --> 16:03:46,240
Instalações oferecidas pelo c plus plus

24321
16:03:46,240 --> 16:03:49,116
Linguagem de programação para obter saída de

24322
16:03:49,116 --> 16:03:51,276
funções e vamos começar em

24323
16:03:51,276 --> 16:03:53,680
A próxima palestra e ver como podemos usar

24324
16:03:53,680 --> 16:03:56,640
Os parâmetros de entrada e saída vão em frente e

24325
16:03:56,640 --> 16:03:59,276
Termine aqui e me encontre lá neste

24326
16:03:59,276 --> 16:04:00,796
palestra, vamos ver como podemos

24327
16:04:00,796 --> 16:04:03,840
usar parâmetros de função para obter dados para fora

24328
16:04:03,840 --> 16:04:05,276
da função

24329
16:04:05,276 --> 16:04:07,360
Aqui está um exemplo simples e nós temos

24330
16:04:07,360 --> 16:04:10,796
três funções aqui temos max str

24331
16:04:10,796 --> 16:04:13,680
max e max double e max e você percebe

24332
16:04:13,680 --> 16:04:16,000
que temos três parâmetros para cada

24333
16:04:16,000 --> 16:04:17,840
Essas funções as duas primeiras

24334
16:04:17,840 --> 16:04:19,916
Os parâmetros serão inseridos eles

24335
16:04:19,916 --> 16:04:22,560
vai obter dados e função

24336
16:04:22,560 --> 16:04:24,880
E o terceiro vai ser o

24337
16:04:24,880 --> 16:04:27,756
parâmetro de saída e vai ficar

24338
16:04:27,756 --> 16:04:29,756
Dados fora da função

24339
16:04:29,756 --> 16:04:33,040
vamos focar no max hdr aqui e realmente

24340
16:04:33,040 --> 16:04:35,756
conduzir o ponto para casa a ideia chave aqui

24341
16:04:35,756 --> 16:04:38,560
Isso é para o terceiro parâmetro

24342
16:04:38,560 --> 16:04:42,080
estamos usando uma referência modificável e

24343
16:04:42,080 --> 16:04:44,640
se usarmos uma referência as alterações que fazemos

24344
16:04:44,640 --> 16:04:46,880
Dentro da função também vai ser

24345
16:04:46,880 --> 16:04:50,880
visível no exterior e nós explicitamente

24346
16:04:50,880 --> 16:04:53,520
deixou de fora o const que temos no

24347
16:04:53,520 --> 16:04:55,596
Outros parâmetros porque queremos ser

24348
16:04:55,596 --> 16:04:57,360
capaz de modificar

24349
16:04:57,360 --> 16:05:00,400
A variável de saída aqui dentro do

24350
16:05:00,400 --> 16:05:02,480
Função se marcamos o terceiro

24351
16:05:02,480 --> 16:05:04,720
parâmetro como const nós teríamos um

24352
16:05:04,720 --> 16:05:06,560
Erro do compilador se estivermos tentando fazer

24353
16:05:06,560 --> 16:05:09,040
Algo assim e atribua algo

24354
16:05:09,040 --> 16:05:11,596
para o parâmetro de saída aqui, então o principal

24355
16:05:11,596 --> 16:05:13,520
A finalidade desta função é calcular

24356
16:05:13,520 --> 16:05:16,000
o máximo entre essas duas cordas

24357
16:05:16,000 --> 16:05:18,640
vai dizer se a entrada 1 é maior

24358
16:05:18,640 --> 16:05:20,480
do que entrada 2

24359
16:05:20,480 --> 16:05:23,520
então a entrada 1 será o nosso máximo

24360
16:05:23,520 --> 16:05:26,240
e nós vamos armazenar isso em nosso

24361
16:05:26,240 --> 16:05:29,360
parâmetro de saída aqui se entrada 1 não é

24362
16:05:29,360 --> 16:05:32,400
maior do que a entrada 2, em seguida, entrada 2 é o nosso

24363
16:05:32,400 --> 16:05:34,796
máximo vamos armazenar isso em nosso

24364
16:05:34,796 --> 16:05:38,320
saída e quem tiver acesso à entrada 2

24365
16:05:38,320 --> 16:05:40,480
Fora a função vai ver o

24366
16:05:40,480 --> 16:05:42,640
Mudanças que estamos fazendo no corpo

24367
16:05:42,640 --> 16:05:44,400
da função que esta é realmente a

24368
16:05:44,400 --> 16:05:46,240
técnica que nós podemos usar

24369
16:05:46,240 --> 16:05:46,956
A sua forma de

24370
16:05:46,956 --> 16:05:49,276
enviar a saída da função e fazer

24371
16:05:49,276 --> 16:05:50,640
É visível

24372
16:05:50,640 --> 16:05:53,200
quando a função retornar e novamente

24373
16:05:53,200 --> 16:05:55,276
A ideia chave é que nós configuramos o

24374
16:05:55,276 --> 16:05:57,916
Funcionar de uma forma que as mudanças que fazemos

24375
16:05:57,916 --> 16:05:59,680
Dentro da função vai ser

24376
16:05:59,680 --> 16:06:02,000
visível no exterior e somos capazes

24377
16:06:02,000 --> 16:06:04,796
para fazer isso porque a saída aqui é

24378
16:06:04,796 --> 16:06:07,276
referência esta é realmente a chave que temos

24379
16:06:07,276 --> 16:06:09,840
usou referências aqui, mas podemos configurar

24380
16:06:09,840 --> 16:06:12,240
a mesma coisa usando ponteiros porque nós

24381
16:06:12,240 --> 16:06:14,956
Temos visto que com ponteiros também podemos

24382
16:06:14,956 --> 16:06:17,436
fazer nossas mudanças dentro da função

24383
16:06:17,436 --> 16:06:19,916
visível para o exterior os outros dois

24384
16:06:19,916 --> 16:06:22,400
Exemplos aqui são realmente extensões de

24385
16:06:22,400 --> 16:06:24,320
A mesma coisa que temos duas entradas

24386
16:06:24,320 --> 16:06:27,276
variáveis entrada 1 e entrada 2

24387
16:06:27,276 --> 16:06:28,400
E a

24388
16:06:28,400 --> 16:06:30,640
A saída vai armazenar a saída a partir de

24389
16:06:30,640 --> 16:06:33,200
a função que você percebe que a saída é um

24390
16:06:33,200 --> 16:06:35,360
referência e por causa disso

24391
16:06:35,360 --> 16:06:37,520
As mudanças que fazemos aqui vão ser

24392
16:06:37,520 --> 16:06:40,640
visível quando esta função voltou

24393
16:06:40,640 --> 16:06:43,200
e fazemos exatamente a mesma coisa no máximo

24394
16:06:43,200 --> 16:06:44,400
Dupla aqui

24395
16:06:44,400 --> 16:06:46,560
Mas você vê que está usando um ponteiro

24396
16:06:46,560 --> 16:06:48,880
Tudo bem, eu realmente queria que você visse isso, então

24397
16:06:48,880 --> 16:06:50,796
Por dentro, vamos tentar descobrir

24398
16:06:50,796 --> 16:06:54,080
quem é o máximo e se entrada 1 é o

24399
16:06:54,080 --> 16:06:56,560
máximo vamos escrever isso em nosso

24400
16:06:56,560 --> 16:06:58,956
variável de saída aqui e você percebe que

24401
16:06:58,956 --> 16:07:01,200
Somos a referência aqui porque isso

24402
16:07:01,200 --> 16:07:04,720
cara é um ponteiro e se entrada 2 é o nosso

24403
16:07:04,720 --> 16:07:07,360
máximo vamos escrever isso em nosso

24404
16:07:07,360 --> 16:07:09,436
variável de saída aqui uma coisa eu não

24405
16:07:09,436 --> 16:07:12,240
Acho que expliquei aqui é que temos um

24406
16:07:12,240 --> 16:07:15,680
custo std string referência aqui para maxed

24407
16:07:15,680 --> 16:07:19,040
hdr e a razão é que a entrada

24408
16:07:19,040 --> 16:07:21,200
As variáveis não são realmente destinadas a ser

24409
16:07:21,200 --> 16:07:23,436
Mudou, é por isso que os comercializamos como

24410
16:07:23,436 --> 16:07:26,080
custo e se você quiser modificá-los em

24411
16:07:26,080 --> 16:07:28,400
alguma maneira você pode tirar o const e

24412
16:07:28,400 --> 16:07:30,240
vai funcionar ok, isso é realmente

24413
16:07:30,240 --> 16:07:32,640
A grande ideia com a qual estamos jogando neste

24414
16:07:32,640 --> 16:07:35,360
palestra usando parâmetros de função como a

24415
16:07:35,360 --> 16:07:38,480
maneira de produzir dados da função e

24416
16:07:38,480 --> 16:07:40,720
Aqui estão algumas ideias que você deve manter

24417
16:07:40,720 --> 16:07:43,200
Os parâmetros da saída da mente devem ser passados

24418
16:07:43,200 --> 16:07:45,360
de tal forma que você possa modificar o

24419
16:07:45,360 --> 16:07:48,000
argumentos de dentro das funções

24420
16:07:48,000 --> 16:07:50,000
E vimos que temos duas maneiras

24421
16:07:50,000 --> 16:07:51,436
para fazer isso, poderíamos usar

24422
16:07:51,436 --> 16:07:54,080
referências ou até mesmo usar ponteiros, mas

24423
16:07:54,080 --> 16:07:56,796
As referências são o que você deve preferir

24424
16:07:56,796 --> 16:07:59,360
parâmetros modernos c plus plus de entrada

24425
16:07:59,360 --> 16:08:01,840
Não devem ser modificados para que

24426
16:08:01,840 --> 16:08:04,560
basta obter dados na função e isso é

24427
16:08:04,560 --> 16:08:06,480
Porque na maioria dos casos você vai ver

24428
16:08:06,480 --> 16:08:08,956
que eles estão marcados const ok agora que

24429
16:08:08,956 --> 16:08:11,116
Vimos todas essas ideias eu acho que

24430
16:08:11,116 --> 16:08:13,116
É hora de irmos para o estúdio visual

24431
16:08:13,116 --> 16:08:15,200
código e realmente jogou com eles bem

24432
16:08:15,200 --> 16:08:17,840
Aqui estamos em nossa pasta de trabalho o

24433
16:08:17,840 --> 16:08:20,160
O projeto atual é entrada e saída

24434
16:08:20,160 --> 16:08:22,400
Parâmetros, vamos pegar o nosso

24435
16:08:22,400 --> 16:08:24,880
arquivos de modelo como sempre fazemos

24436
16:08:24,880 --> 16:08:27,276
vamos colocá-los no lugar e nós estamos

24437
16:08:27,276 --> 16:08:29,276
Vou abrir esse cara no estúdio visual

24438
16:08:29,276 --> 16:08:31,200
Código, vamos apenas arrastá-lo e

24439
16:08:31,200 --> 16:08:33,840
drop em cima de código de estúdio visual aqui

24440
16:08:33,840 --> 16:08:35,840
e vai abrir, temos o nosso

24441
16:08:35,840 --> 16:08:37,916
principal função aqui nós podemos fechar o painel

24442
16:08:37,916 --> 16:08:40,880
aqui e limpar o arquivo um pouco

24443
16:08:40,880 --> 16:08:42,560
Vamos remover o que não precisamos

24444
16:08:42,560 --> 16:08:45,596
aqui e nós vamos ter um bare main

24445
16:08:45,596 --> 16:08:47,520
Função com que podemos jogar aqui o primeiro

24446
16:08:47,520 --> 16:08:49,840
O que vamos fazer é colocar em nosso

24447
16:08:49,840 --> 16:08:52,720
max str função é nada especial

24448
16:08:52,720 --> 16:08:55,756
temos apenas dois parâmetros de entrada e

24449
16:08:55,756 --> 16:08:58,480
um parâmetro de saída da saída

24450
16:08:58,480 --> 16:09:00,480
O parâmetro vai ser o que usamos

24451
16:09:00,480 --> 16:09:03,116
obter saída fora da função e

24452
16:09:03,116 --> 16:09:04,796
Por dentro, vamos apenas calcular o

24453
16:09:04,796 --> 16:09:07,200
máximo se a entrada 1 é o máximo que somos

24454
16:09:07,200 --> 16:09:09,200
Vou escrever isso em nossa produção

24455
16:09:09,200 --> 16:09:11,916
parâmetro se a entrada 2 é nossa

24456
16:09:11,916 --> 16:09:14,160
máximo vamos escrever isso em nosso

24457
16:09:14,160 --> 16:09:16,880
parâmetro de saída porque nossa saída

24458
16:09:16,880 --> 16:09:19,360
parâmetro é uma referência as mudanças que nós

24459
16:09:19,360 --> 16:09:21,360
fazer dentro a função vai ser

24460
16:09:21,360 --> 16:09:24,240
visível no exterior porque vamos

24461
16:09:24,240 --> 16:09:27,116
estar trabalhando na variável original

24462
16:09:27,116 --> 16:09:29,596
através da referência que é realmente um

24463
16:09:29,596 --> 16:09:32,080
verdadeiros alias aqui ok agora que temos

24464
16:09:32,080 --> 16:09:33,756
A função configurada assim nós podemos

24465
16:09:33,756 --> 16:09:36,560
cabeça na função principal e experimentá-lo

24466
16:09:36,560 --> 16:09:38,640
Vamos criar três variáveis de

24467
16:09:38,640 --> 16:09:40,640
tipo std strand eu acho que devemos

24468
16:09:40,640 --> 16:09:43,040
incluir a biblioteca de strings aqui vamos fazer

24469
16:09:43,040 --> 16:09:45,276
Isso e nós vamos ter uma saída

24470
16:09:45,276 --> 16:09:48,240
string que vai ser a nossa saída

24471
16:09:48,240 --> 16:09:51,360
variável e nós temos duas cadeias de entrada

24472
16:09:51,360 --> 16:09:53,916
um é inicializado com alabama o

24473
16:09:53,916 --> 16:09:56,796
outro é inicializado com vista do sino e

24474
16:09:56,796 --> 16:10:00,240
nós vamos chamar a nossa função max sdr

24475
16:10:00,240 --> 16:10:02,080
Aqui você percebe que não vai

24476
16:10:02,080 --> 16:10:04,560
usar o mecanismo de retorno que somos

24477
16:10:04,560 --> 16:10:06,880
Vou pegar a saída de

24478
16:10:06,880 --> 16:10:10,000
esta função usando um parâmetro de saída

24479
16:10:10,000 --> 16:10:13,276
que vai ser o nosso out hdr

24480
16:10:13,276 --> 16:10:15,276
variável aqui OK uma vez que a função é

24481
16:10:15,276 --> 16:10:17,040
Fizemos que teremos o máximo

24482
16:10:17,040 --> 16:10:21,040
armazenados na nossa variável out sdr aqui e

24483
16:10:21,040 --> 16:10:22,880
Podemos imprimi-lo agora que temos

24484
16:10:22,880 --> 16:10:25,276
Esta configuração podemos realmente tentar construir

24485
16:10:25,276 --> 16:10:27,360
Isto vamos usar o gcc vamos fazer

24486
16:10:27,360 --> 16:10:29,680
que a construção é boa, podemos trazer um

24487
16:10:29,680 --> 16:10:32,640
terminal e clear e run galo agora

24488
16:10:32,640 --> 16:10:34,400
Você vê que o máximo vai ser

24489
16:10:34,400 --> 16:10:38,000
bell view vamos tentar mudar isso para

24490
16:10:38,000 --> 16:10:39,840
Casablanca por que não e nós vamos

24491
16:10:39,840 --> 16:10:41,596
Veja que o máximo agora vai ser

24492
16:10:41,596 --> 16:10:44,240
casablanca e nossa função vai

24493
16:10:44,240 --> 16:10:47,276
ser inteligente o suficiente para armazenar o máximo em

24494
16:10:47,276 --> 16:10:50,080
Esta variável de saída aqui vamos construir

24495
16:10:50,080 --> 16:10:51,916
Mais uma vez o mundo vai ser bom

24496
16:10:51,916 --> 16:10:54,160
indo para limpar e correr galo agora o

24497
16:10:54,160 --> 16:10:56,560
O máximo é casablanca espero que você

24498
16:10:56,560 --> 16:10:59,276
Entenda que somos capazes de fazer o

24499
16:10:59,276 --> 16:11:02,160
Mudanças na função processada

24500
16:11:02,160 --> 16:11:06,000
porque o nosso parâmetro de saída aqui é

24501
16:11:06,000 --> 16:11:08,400
Passado por referência, isso é um verdadeiro

24502
16:11:08,400 --> 16:11:10,720
referência e qualquer mudança que fazemos para o

24503
16:11:10,720 --> 16:11:13,200
parâmetro de saída aqui vai ser

24504
16:11:13,200 --> 16:11:16,160
visível em qualquer variável que você passou

24505
16:11:16,160 --> 16:11:19,200
como argumento para este terceiro argumento

24506
16:11:19,200 --> 16:11:21,436
Aqui é isso que está fazendo este trabalho

24507
16:11:21,436 --> 16:11:23,040
Agora que isso está funcionando, vamos

24508
16:11:23,040 --> 16:11:24,480
Comente isso para fora

24509
16:11:24,480 --> 16:11:25,360
E a

24510
16:11:25,360 --> 16:11:28,320
colocar em outro exemplo para você jogar

24511
16:11:28,320 --> 16:11:29,756
com a próxima função que vamos

24512
16:11:29,756 --> 16:11:32,160
jogar com vai ser máximo e como você

24513
16:11:32,160 --> 16:11:35,520
Veja aqui e é muito parecido com o nosso

24514
16:11:35,520 --> 16:11:39,116
max hdr, mas você percebe que nossas entradas

24515
16:11:39,116 --> 16:11:42,000
Não somos mais referências porque nós

24516
16:11:42,000 --> 16:11:44,720
não se importa realmente de copiar fundamental

24517
16:11:44,720 --> 16:11:47,116
tipos em c plus plus eles são pequenos em

24518
16:11:47,116 --> 16:11:49,756
A memória, então copiá-los é realmente barato

24519
16:11:49,756 --> 16:11:52,160
Podemos passá-los por valor e isso é

24520
16:11:52,160 --> 16:11:54,956
Não vai ser tão desperdiçado em nosso

24521
16:11:54,956 --> 16:11:57,360
programa, mas o primeiro parâmetro deve ser

24522
16:11:57,360 --> 16:11:59,840
Passado por referência porque queremos

24523
16:11:59,840 --> 16:12:02,796
use-o como um parâmetro de saída e nós somos

24524
16:12:02,796 --> 16:12:04,956
indo para usá-lo para obter a saída a partir do

24525
16:12:04,956 --> 16:12:06,796
função e a maneira como vamos fazer

24526
16:12:06,796 --> 16:12:08,400
que vamos escrever o que

24527
16:12:08,400 --> 16:12:11,040
variável é o máximo em nossa saída

24528
16:12:11,040 --> 16:12:13,276
parâmetro e as mudanças vão

24529
16:12:13,276 --> 16:12:15,360
ser visível no exterior agora estamos

24530
16:12:15,360 --> 16:12:17,756
indo para cabeça em nossa principal função

24531
16:12:17,756 --> 16:12:19,756
configurar algumas variáveis e brincar com a gente

24532
16:12:19,756 --> 16:12:22,400
então nós vamos dizer e sair e isso

24533
16:12:22,400 --> 16:12:25,040
será a nossa variável de saída e

24534
16:12:25,040 --> 16:12:27,680
nós vamos dizer uma entrada, vamos dizer

24535
16:12:27,680 --> 16:12:29,436
em um e vamos inicializar

24536
16:12:29,436 --> 16:12:32,320
com um 45 por que não e nós vamos

24537
16:12:32,320 --> 16:12:34,480
para dizer ent em dois e nós vamos

24538
16:12:34,480 --> 16:12:37,276
inicialize isso com 23 por que não agora aquilo

24539
16:12:37,276 --> 16:12:39,360
nós temos isso, vamos dizer max e

24540
16:12:39,360 --> 16:12:41,116
e nós vamos colocar em nossa opinião

24541
16:12:41,116 --> 16:12:44,000
nós vamos dizer n1 e n2, então nós somos

24542
16:12:44,000 --> 16:12:46,956
vamos dizer e como nossa produção

24543
16:12:46,956 --> 16:12:49,116
variável agora que temos isso, podemos

24544
16:12:49,116 --> 16:12:51,200
realmente imprimir qualquer número que seja

24545
16:12:51,200 --> 16:12:53,596
o máximo através de uma instrução de saída

24546
16:12:53,596 --> 16:12:55,360
Como isso realmente simples, vamos

24547
16:12:55,360 --> 16:12:58,000
Diga max e e nós vamos dizer

24548
16:12:58,000 --> 16:13:00,240
Para terminar, é onde vai ser

24549
16:13:00,240 --> 16:13:02,320
armazenado e nós somos capazes de fazer isso

24550
16:13:02,320 --> 16:13:05,116
Porque novamente é o terceiro parâmetro aqui

24551
16:13:05,116 --> 16:13:08,160
é passado por referência e qualquer mudança que

24552
16:13:08,160 --> 16:13:10,560
fazer e a função aqui vai

24553
16:13:10,560 --> 16:13:13,756
empilhar mesmo quando a função aqui tem

24554
16:13:13,756 --> 16:13:16,000
Voltou e nós vamos ter isso

24555
16:13:16,000 --> 16:13:18,720
armazenado em nosso terceiro parâmetro aqui e

24556
16:13:18,720 --> 16:13:20,480
Esta é uma técnica realmente comum

24557
16:13:20,480 --> 16:13:23,596
Principalmente em código que tem que interagir

24558
16:13:23,596 --> 16:13:27,276
com código c lá fora de c plus

24559
16:13:27,276 --> 16:13:29,360
e você realmente precisa estar ciente disso

24560
16:13:29,360 --> 16:13:31,436
Agora, se executarmos este programa, vamos

24561
16:13:31,436 --> 16:13:33,916
para ver o nosso máximo impresso e é

24562
16:13:33,916 --> 16:13:36,480
vai ser armazenado em nossa variável fora

24563
16:13:36,480 --> 16:13:38,480
Vamos fazer isso que vamos usar

24564
16:13:38,480 --> 16:13:40,796
gcc para o mundo o mundo é bom você pode

24565
16:13:40,796 --> 16:13:42,956
limpar e correr galo e você está indo

24566
16:13:42,956 --> 16:13:45,596
ver que o máximo é 45 se nós

24567
16:13:45,596 --> 16:13:49,040
mudar e armazenar nosso máximo em

24568
16:13:49,040 --> 16:13:51,840
aqui e, por exemplo, vamos fazer disso um

24569
16:13:51,840 --> 16:13:54,640
Endereço de 723

24570
16:13:54,640 --> 16:13:57,116
Vamos construí-lo para tomar as mudanças

24571
16:13:57,116 --> 16:13:59,240
em consideração em nosso

24572
16:13:59,240 --> 16:14:01,840
Galo.xe binário vamos limpar

24573
16:14:01,840 --> 16:14:03,680
e correr galo e você vai ver

24574
16:14:03,680 --> 16:14:06,000
que é o máximo aqui que somos capazes

24575
16:14:06,000 --> 16:14:08,400
para agarrar tudo o que é o máximo de

24576
16:14:08,400 --> 16:14:11,276
estes dois parâmetros de entrada e armazenamento

24577
16:14:11,276 --> 16:14:13,916
que em nosso parâmetro de saída aqui

24578
16:14:13,916 --> 16:14:17,360
Porque estamos passando esse terceiro cara como

24579
16:14:17,360 --> 16:14:19,916
Uma referência que é realmente importante

24580
16:14:19,916 --> 16:14:21,916
Temos visto que podemos usar referências para

24581
16:14:21,916 --> 16:14:24,956
fazer alterações que fazemos na função stick

24582
16:14:24,956 --> 16:14:28,240
e ser visível em variáveis externas, mas

24583
16:14:28,240 --> 16:14:30,160
nós também podemos usar ponteiros e eu estou indo

24584
16:14:30,160 --> 16:14:32,240
para mostrar um exemplo de como podemos fazer

24585
16:14:32,240 --> 16:14:33,840
Que primeiro vamos comentar isso

24586
16:14:33,840 --> 16:14:36,400
Porque não queremos saída de ruído

24587
16:14:36,400 --> 16:14:38,956
em nosso programa e vamos continuar

24588
16:14:38,956 --> 16:14:41,840
topo e configurar uma função máxima dupla

24589
16:14:41,840 --> 16:14:45,680
que vai pegar a nossa saída usando

24590
16:14:45,680 --> 16:14:48,000
apontando o nome da função é max

24591
16:14:48,000 --> 16:14:50,400
O dobro não vai voltar nada

24592
16:14:50,400 --> 16:14:52,400
e vai levar duas entradas

24593
16:14:52,400 --> 16:14:55,916
parâmetros entrada 1 e entrada 2 e é

24594
16:14:55,916 --> 16:14:58,320
vamos nos dizer que qualquer um desses dois é

24595
16:14:58,320 --> 16:15:00,720
O máximo será o máximo

24596
16:15:00,720 --> 16:15:03,596
armazenado em nosso parâmetro de saída, mas nós

24597
16:15:03,596 --> 16:15:05,840
estão usando ponteiros para fazer essas mudanças

24598
16:15:05,840 --> 16:15:08,400
dentro do corpo da vara da função

24599
16:15:08,400 --> 16:15:10,720
e ser visível no exterior do

24600
16:15:10,720 --> 16:15:12,240
Função para que vamos para o

24601
16:15:12,240 --> 16:15:14,080
referência aqui porque o terceiro cara

24602
16:15:14,080 --> 16:15:15,916
Aqui está um ponteiro e nós vamos

24603
16:15:15,916 --> 16:15:18,240
armazenar o que for o máximo e

24604
16:15:18,240 --> 16:15:20,560
quando a função retorna o máximo é

24605
16:15:20,560 --> 16:15:22,880
será visível no exterior, então

24606
16:15:22,880 --> 16:15:24,880
vamos descer e experimentar isso nós estamos

24607
16:15:24,880 --> 16:15:26,956
Vou dizer o dobro do dobro e nós somos

24608
16:15:26,956 --> 16:15:28,080
Indo para dentro de nós.

24609
16:15:28,080 --> 16:15:30,400
configurar a nossa opinião aqui, vamos dizer

24610
16:15:30,400 --> 16:15:32,400
em um duplo e vamos fazer

24611
16:15:32,400 --> 16:15:33,240
Isto é

24612
16:15:33,240 --> 16:15:36,240
45.8 por que não e nós vamos fazer um

24613
16:15:36,240 --> 16:15:39,596
segundo parâmetro de entrada e int devemos

24614
16:15:39,596 --> 16:15:43,040
Diga n não ter fim, desculpe por isso em duplo

24615
16:15:43,040 --> 16:15:45,200
para entrada duplo, então vamos dizer

24616
16:15:45,200 --> 16:15:47,360
duplo 2 e vamos inicializar

24617
16:15:47,360 --> 16:15:50,000
Isso é com 6.9

24618
16:15:50,000 --> 16:15:51,840
Por exemplo, podemos realmente colocar

24619
16:15:51,840 --> 16:15:54,000
qualquer coisa agora que temos isso, podemos

24620
16:15:54,000 --> 16:15:56,320
chamar a nossa função máxima dupla, vamos fazer

24621
16:15:56,320 --> 16:15:58,080
que vai dizer max double nós vamos

24622
16:15:58,080 --> 16:16:01,680
dizer em um duplo e em dois duplos

24623
16:16:01,680 --> 16:16:03,596
Vamos fazer isso e nós vamos ter

24624
16:16:03,596 --> 16:16:07,276
fora duplo como nosso parâmetro de saída e

24625
16:16:07,276 --> 16:16:09,040
Porque é um ponteiro que precisamos

24626
16:16:09,040 --> 16:16:12,000
passar este cara como um endereço, então nós somos

24627
16:16:12,000 --> 16:16:14,640
Vou dizer um endereço de como dobrar

24628
16:16:14,640 --> 16:16:16,560
Aqui é assim que vamos ser capazes

24629
16:16:16,560 --> 16:16:19,040
para manipular isso dentro da função

24630
16:16:19,040 --> 16:16:21,520
Aqui uma vez que fazemos isso, vamos

24631
16:16:21,520 --> 16:16:24,880
ter o nosso máximo armazenado e fora o dobro

24632
16:16:24,880 --> 16:16:26,720
e podemos imprimir isso para que vamos

24633
16:16:26,720 --> 16:16:29,680
para dizer stdcl max double e nós estamos indo

24634
16:16:29,680 --> 16:16:32,000
para dizer mac e nós vamos dizer para fora

24635
16:16:32,000 --> 16:16:36,320
double std e el e se soldamos por quê

24636
16:16:36,320 --> 16:16:38,240
Temos uma linha cativante aqui, não temos

24637
16:16:38,240 --> 16:16:40,956
ter um ponto e ponto e ponto e vírgula no final do nosso

24638
16:16:40,956 --> 16:16:42,560
Função chamada aqui, então vamos

24639
16:16:42,560 --> 16:16:45,276
construir com gcc como sempre você vai

24640
16:16:45,276 --> 16:16:47,360
Veja que o mundo é bom, podemos limpar

24641
16:16:47,360 --> 16:16:51,436
e run galo max é 45.8

24642
16:16:51,436 --> 16:16:54,320
se mudarmos e armazenarmos o nosso máximo e

24643
16:16:54,320 --> 16:16:57,116
No dobro para aqui podemos mudar esse cara

24644
16:16:57,116 --> 16:16:58,796
em 76.9

24645
16:16:58,796 --> 16:17:01,116
nós vamos construir e ver que estamos

24646
16:17:01,116 --> 16:17:04,080
realmente agarrando o máximo independentemente

24647
16:17:04,080 --> 16:17:06,240
da variável em que é armazenada se

24648
16:17:06,240 --> 16:17:08,080
nós corremos o galo nós vamos ter o nosso

24649
16:17:08,080 --> 16:17:11,116
máximo e isso funciona exatamente como

24650
16:17:11,116 --> 16:17:12,956
Queremos que isso seja tudo o que nos estabelecemos

24651
16:17:12,956 --> 16:17:14,560
fazer nesta palestra mostrando como você

24652
16:17:14,560 --> 16:17:18,240
pode usar referências para usar parâmetros como

24653
16:17:18,240 --> 16:17:21,520
canais de saída para dados para sair

24654
16:17:21,520 --> 16:17:24,880
da função e ser usado em variáveis

24655
16:17:24,880 --> 16:17:27,436
que estão fora da função aqui i

24656
16:17:27,436 --> 16:17:29,436
realmente espero que isso faça sentido e isso é

24657
16:17:29,436 --> 16:17:31,276
uma técnica que você precisa conhecer

24658
16:17:31,276 --> 16:17:32,880
Vamos ver outras técnicas para

24659
16:17:32,880 --> 16:17:35,680
fazer a mesma coisa e uh começando no

24660
16:17:35,680 --> 16:17:37,200
A próxima palestra vamos ver como nós

24661
16:17:37,200 --> 16:17:39,840
pode retornar de funções por enquanto eu espero

24662
16:17:39,840 --> 16:17:42,320
Você achou esta palestra interessante

24663
16:17:42,320 --> 16:17:44,160
Vou parar aqui neste em

24664
16:17:44,160 --> 16:17:45,436
O próximo vamos ver como nós

24665
16:17:45,436 --> 16:17:48,796
pode usar o mecanismo de devolução para obter dados

24666
16:17:48,796 --> 16:17:51,680
Fora da nossa função vá em frente e termine

24667
16:17:51,680 --> 16:17:54,240
Aqui em cima e me faz lá

24668
16:17:54,240 --> 16:17:55,680
Nesta palestra vamos ver como

24669
16:17:55,680 --> 16:17:58,560
podemos obter dados fora de uma função

24670
16:17:58,560 --> 16:18:01,756
através do mecanismo de retorno e este é

24671
16:18:01,756 --> 16:18:04,400
Será uma alternativa à forma como nós

24672
16:18:04,400 --> 16:18:06,400
Tenho feito coisas no último

24673
16:18:06,400 --> 16:18:08,640
palestra onde usamos a função

24674
16:18:08,640 --> 16:18:12,080
parâmetros como canais para obter dados

24675
16:18:12,080 --> 16:18:14,000
fora da função

24676
16:18:14,000 --> 16:18:16,240
Vejamos o exemplo simples de como

24677
16:18:16,240 --> 16:18:17,756
Isto é feito aqui temos uma simples

24678
16:18:17,756 --> 16:18:19,596
Função chamada soma da função é

24679
16:18:19,596 --> 16:18:21,596
Vai voltar ao fim

24680
16:18:21,596 --> 16:18:24,000
e vai resumir dois parâmetros

24681
16:18:24,000 --> 16:18:27,116
que passamos para em nta e terminamos b

24682
16:18:27,116 --> 16:18:28,720
Se entrarmos na função, estamos

24683
16:18:28,720 --> 16:18:30,240
Vou fazer algo realmente simples

24684
16:18:30,240 --> 16:18:31,680
Vamos configurar uma nova variável

24685
16:18:31,680 --> 16:18:33,360
que é local para a função que somos

24686
16:18:33,360 --> 16:18:35,040
Vou chamar que reservado está indo

24687
16:18:35,040 --> 16:18:37,040
ser o mesmo tipo que nossa entrada

24688
16:18:37,040 --> 16:18:39,276
parâmetros e vamos somar um

24689
16:18:39,276 --> 16:18:41,756
e b e armazenar os resultados de volta em nosso

24690
16:18:41,756 --> 16:18:43,680
variável de resultado aqui

24691
16:18:43,680 --> 16:18:45,756
Uma vez que temos isso, vamos voltar

24692
16:18:45,756 --> 16:18:49,436
para que esta variável seja visível por

24693
16:18:49,436 --> 16:18:52,080
Quem chamou essa função aqui

24694
16:18:52,080 --> 16:18:53,840
O que você deve saber é que isso

24695
16:18:53,840 --> 16:18:57,596
variável é local para esta função aqui

24696
16:18:57,596 --> 16:19:00,480
E será destruído no momento em que

24697
16:19:00,480 --> 16:19:02,880
acertar o fim da função aqui e

24698
16:19:02,880 --> 16:19:04,640
A função termina

24699
16:19:04,640 --> 16:19:06,640
então, se formos no topo aqui, vamos

24700
16:19:06,640 --> 16:19:08,560
Tente ver um exemplo de como podemos

24701
16:19:08,560 --> 16:19:11,116
Chamar esta função temos duas variáveis

24702
16:19:11,116 --> 16:19:14,400
a e b e temos um novo resultado

24703
16:19:14,400 --> 16:19:16,796
variável configurada na função principal

24704
16:19:16,796 --> 16:19:19,200
Por favor, note que esta variável é muito

24705
16:19:19,200 --> 16:19:21,436
diferente da variável que temos e

24706
16:19:21,436 --> 16:19:22,400
O que é

24707
16:19:22,400 --> 16:19:24,880
Soma funciona aqui porque eles vivem em

24708
16:19:24,880 --> 16:19:27,360
Diferentes escopos estão bem, estamos chamando nossos

24709
16:19:27,360 --> 16:19:30,160
sum função aqui e estamos passando

24710
16:19:30,160 --> 16:19:33,520
dois argumentos em forma de a e b

24711
16:19:33,520 --> 16:19:35,596
Aqui a função vai computar

24712
16:19:35,596 --> 16:19:37,916
nossa soma e vai devolvê-lo e

24713
16:19:37,916 --> 16:19:40,320
nós vamos armazenar isso de volta em nosso

24714
16:19:40,320 --> 16:19:42,880
variável local para a função principal aqui

24715
16:19:42,880 --> 16:19:45,436
A variável de resultado aqui novamente é local

24716
16:19:45,436 --> 16:19:47,756
para esta função principal ok uma vez que chamamos

24717
16:19:47,756 --> 16:19:49,276
Esta função nós vamos ter o nosso

24718
16:19:49,276 --> 16:19:52,080
resultados armazenados aqui e se imprimirmos

24719
16:19:52,080 --> 16:19:53,756
Como fazemos aqui, vamos vê-lo

24720
16:19:53,756 --> 16:19:55,916
impresso no console neste caso

24721
16:19:55,916 --> 16:19:59,520
vai imprimir 50 porque 34 adicionando

24722
16:19:59,520 --> 16:20:02,480
16 que vai ser 50. mas uma coisa

24723
16:20:02,480 --> 16:20:04,480
Eu quero que você saiba que isso está indo

24724
16:20:04,480 --> 16:20:06,956
para retornar por valor e o que queremos dizer com

24725
16:20:06,956 --> 16:20:08,956
Isto é que vamos copiar

24726
16:20:08,956 --> 16:20:12,160
O que quer que voltemos aqui e armazene uma cópia

24727
16:20:12,160 --> 16:20:15,116
disso nesta variável de resultado que nós

24728
16:20:15,116 --> 16:20:17,276
Temos na função principal e nós somos

24729
16:20:17,276 --> 16:20:18,956
vou provar isso

24730
16:20:18,956 --> 16:20:21,916
notar a declaração stdc out que temos

24731
16:20:21,916 --> 16:20:25,520
Aqui, isso vai imprimir o endereço

24732
16:20:25,520 --> 16:20:27,520
desta variável local e uma vez

24733
16:20:27,520 --> 16:20:29,756
A função termina que vamos tentar

24734
16:20:29,756 --> 16:20:32,080
e imprimir o endereço deste resort

24735
16:20:32,080 --> 16:20:34,640
variável no âmbito local do principal

24736
16:20:34,640 --> 16:20:36,640
Função e vamos ver dois

24737
16:20:36,640 --> 16:20:38,880
diferentes endereços e espero que isso

24738
16:20:38,880 --> 16:20:41,436
Vai provar que estamos voltando

24739
16:20:41,436 --> 16:20:43,756
uma cópia não é a variável original

24740
16:20:43,756 --> 16:20:46,320
que temos na função de soma aqui

24741
16:20:46,320 --> 16:20:48,560
que estamos voltando bem espero

24742
16:20:48,560 --> 16:20:50,640
Isso impulsiona o ponto para casa que podemos

24743
16:20:50,640 --> 16:20:53,276
Use o mecanismo de devolução para obter dados

24744
16:20:53,276 --> 16:20:55,200
Fora da função e nós vamos

24745
16:20:55,200 --> 16:20:58,720
Pegue o resultado em nossa variável de resultado

24746
16:20:58,720 --> 16:21:00,720
Aqui e nós vamos usá-lo no entanto

24747
16:21:00,720 --> 16:21:02,720
Queríamos a função principal

24748
16:21:02,720 --> 16:21:06,000
Mas as coisas nem sempre funcionam assim

24749
16:21:06,000 --> 16:21:08,000
às vezes o compilador vai

24750
16:21:08,000 --> 16:21:10,080
Otimizações de inserção

24751
16:21:10,080 --> 16:21:12,560
e não realmente retornado pelo valor, mas

24752
16:21:12,560 --> 16:21:15,520
retornar por valor é o padrão, mas se

24753
16:21:15,520 --> 16:21:18,000
o compilador percebe que pode fazer

24754
16:21:18,000 --> 16:21:20,480
Coisas melhor que vai otimizar

24755
16:21:20,480 --> 16:21:23,360
seus retornos por valor para retornar

24756
16:21:23,360 --> 16:21:25,520
referência e você não vai fazer um

24757
16:21:25,520 --> 16:21:28,480
copiar, mas você vai de alguma forma reutilizar

24758
16:21:28,480 --> 16:21:30,796
a variável local na função principal

24759
16:21:30,796 --> 16:21:33,040
Vejamos um exemplo simples para realmente

24760
16:21:33,040 --> 16:21:35,360
conduzir esta casa temos uma função aqui

24761
16:21:35,360 --> 16:21:37,436
que vai adicionar força é

24762
16:21:37,436 --> 16:21:39,436
indo basicamente concatenate-los

24763
16:21:39,436 --> 16:21:41,756
usando o operador plus aqui e você

24764
16:21:41,756 --> 16:21:43,596
perceber que dentro da função aqui

24765
16:21:43,596 --> 16:21:45,040
Vamos configurar uma variável local

24766
16:21:45,040 --> 16:21:47,916
que vai armazenar nossos concatenados

24767
16:21:47,916 --> 16:21:49,360
string aqui

24768
16:21:49,360 --> 16:21:51,680
e vamos imprimir o endereço de

24769
16:21:51,680 --> 16:21:53,596
A corda local depois disso estamos indo

24770
16:21:53,596 --> 16:21:55,680
Retorne a força para que ela seja

24771
16:21:55,680 --> 16:21:58,640
utilizáveis por quem chama essa função

24772
16:21:58,640 --> 16:22:00,720
Vamos para o principal e ver como podemos usar

24773
16:22:00,720 --> 16:22:03,360
Esta função aqui estamos preparando um

24774
16:22:03,360 --> 16:22:05,916
variável chamada resultado de sdr que é

24775
16:22:05,916 --> 16:22:08,720
vamos armazenar nossa força de resultados

24776
16:22:08,720 --> 16:22:10,640
Estamos dizendo adicionar cordas aqui estamos

24777
16:22:10,640 --> 16:22:13,040
Chamando nossa função e estamos passando

24778
16:22:13,040 --> 16:22:16,080
em duas cordas olá e mundo e nós

24779
16:22:16,080 --> 16:22:18,400
Quero conspirar esses caras, isso é

24780
16:22:18,400 --> 16:22:20,480
vamos nos dar o nosso resultado e se nós

24781
16:22:20,480 --> 16:22:21,916
imprimi-lo, vamos receber olá

24782
16:22:21,916 --> 16:22:24,480
mundo impresso, mas é a mensagem principal

24783
16:22:24,480 --> 16:22:28,000
Aqui é que o endereço do exterior

24784
16:22:28,000 --> 16:22:30,720
string aqui vai ser o mesmo que

24785
16:22:30,720 --> 16:22:33,680
o endereço que temos no interior aqui

24786
16:22:33,680 --> 16:22:35,360
E isso vai significar que

24787
16:22:35,360 --> 16:22:37,436
O compilador tem realmente

24788
16:22:37,436 --> 16:22:39,116
Fiz um pouco de magia

24789
16:22:39,116 --> 16:22:42,400
para retornar a variável local porque

24790
16:22:42,400 --> 16:22:44,880
Tem visto que nós realmente poderíamos estar desperdiçando

24791
16:22:44,880 --> 16:22:47,436
Este cara aqui dentro da função quando

24792
16:22:47,436 --> 16:22:49,756
a função retorna este resultado de string

24793
16:22:49,756 --> 16:22:52,320
Aqui vai morrer, mas o

24794
16:22:52,320 --> 16:22:54,880
O compilador sabe que podemos reutilizar que

24795
16:22:54,880 --> 16:22:57,436
e evitar o trabalho de copiar isso

24796
16:22:57,436 --> 16:23:00,160
string que pode ser realmente grande

24797
16:23:00,160 --> 16:23:02,160
Suponha que essa corda tenha mil

24798
16:23:02,160 --> 16:23:04,640
personagens dentro e copiar isso

24799
16:23:04,640 --> 16:23:07,276
ser um desperdício para que o compilador não esteja indo

24800
16:23:07,276 --> 16:23:10,000
para retornar por valor que é o padrão

24801
16:23:10,000 --> 16:23:12,400
vai fazer algum tipo de retorno

24802
16:23:12,400 --> 16:23:14,956
Referência, mas não é realmente um retorno

24803
16:23:14,956 --> 16:23:16,796
por referência, porque este é um local

24804
16:23:16,796 --> 16:23:18,640
variável que não podemos realmente ter um

24805
16:23:18,640 --> 16:23:20,320
referência a uma variável local a

24806
16:23:20,320 --> 16:23:22,240
Função que seria realmente ruim

24807
16:23:22,240 --> 16:23:24,560
porque podemos ser capazes de modificá-lo

24808
16:23:24,560 --> 16:23:27,040
quando a variável está realmente morta após

24809
16:23:27,040 --> 16:23:29,360
A função retornou, então é um

24810
16:23:29,360 --> 16:23:31,756
mágica que o compilador está fazendo para salvar

24811
16:23:31,756 --> 16:23:34,320
você de cópias desnecessárias, mas você

24812
16:23:34,320 --> 16:23:36,400
deve estar ciente disso e não fazer

24813
16:23:36,400 --> 16:23:39,520
Seu código depende de retornar por valor

24814
16:23:39,520 --> 16:23:41,360
Tudo bem agora que sabemos isso, estamos indo

24815
16:23:41,360 --> 16:23:43,276
para ir até o código do estúdio visual e

24816
16:23:43,276 --> 16:23:46,560
realmente brincar conosco aqui estamos em nosso

24817
16:23:46,560 --> 16:23:48,796
pasta de trabalho o projeto atual é

24818
16:23:48,796 --> 16:23:51,596
retornando de funções por valor que somos

24819
16:23:51,596 --> 16:23:54,000
Vou pegar nossos arquivos de modelo bonitos

24820
16:23:54,000 --> 16:23:56,160
rápido vamos copiá-los vamos fazer

24821
16:23:56,160 --> 16:23:58,400
Isso e nós vamos colocá-los no

24822
16:23:58,400 --> 16:24:00,956
Palestra ou projeto atual

24823
16:24:00,956 --> 16:24:03,360
E nós vamos abrir esse cara em

24824
16:24:03,360 --> 16:24:05,596
Código de estúdio visual muito rápido, vamos fazer

24825
16:24:05,596 --> 16:24:06,560
que

24826
16:24:06,560 --> 16:24:09,436
agora temos nosso arquivo principal cpp aqui

24827
16:24:09,436 --> 16:24:11,916
pode limpar um pouco

24828
16:24:11,916 --> 16:24:14,000
e fechar o painel esquerdo aqui porque nós

24829
16:24:14,000 --> 16:24:15,520
Não preciso dele a primeira coisa que somos

24830
16:24:15,520 --> 16:24:17,436
Vou fazer é colocar em nossa função

24831
16:24:17,436 --> 16:24:19,520
que vai calcular a soma de dois

24832
16:24:19,520 --> 16:24:22,796
inteiros e retorno como a soma destes

24833
16:24:22,796 --> 16:24:24,956
Dois caras dentro da função que estamos indo

24834
16:24:24,956 --> 16:24:27,200
para configurar uma variável de resultado que é

24835
16:24:27,200 --> 16:24:29,116
Vou guardar a quantia e nós vamos

24836
16:24:29,116 --> 16:24:31,040
para devolvê-lo e vai ser

24837
16:24:31,040 --> 16:24:33,276
visível para quem chamou isso

24838
16:24:33,276 --> 16:24:35,276
Função aqui novamente eu vou

24839
16:24:35,276 --> 16:24:37,436
Enfatize que isso vai voltar

24840
16:24:37,436 --> 16:24:40,320
pelo valor, então o que retornamos é realmente

24841
16:24:40,320 --> 16:24:43,596
Vai ser uma cópia desta variável aqui

24842
16:24:43,596 --> 16:24:45,276
e nós vamos provar isso por

24843
16:24:45,276 --> 16:24:47,756
Imprimir o endereço desta variável

24844
16:24:47,756 --> 16:24:50,640
dentro e fora da função aqui, então

24845
16:24:50,640 --> 16:24:52,320
Vamos configurar duas variáveis em

24846
16:24:52,320 --> 16:24:54,560
O principal vamos dizer e x vamos ligar

24847
16:24:54,560 --> 16:24:57,520
nossos parâmetros de entrada x e y estamos indo

24848
16:24:57,520 --> 16:25:00,240
para colocar em um cinco e o segundo cara é

24849
16:25:00,240 --> 16:25:02,560
Vai ser um y e vai armazenar

24850
16:25:02,560 --> 16:25:05,116
um n9 por que não depois disso vamos

24851
16:25:05,116 --> 16:25:07,040
configurar uma variável que vai fazer

24852
16:25:07,040 --> 16:25:09,916
armazenar os resultados, vamos chamar este resultado

24853
16:25:09,916 --> 16:25:12,400
Por que não e nós vamos dizer algum x

24854
16:25:12,400 --> 16:25:14,796
e sim, estamos passando esses caras

24855
16:25:14,796 --> 16:25:17,276
valor porque nós realmente não nos importamos

24856
16:25:17,276 --> 16:25:20,160
copiar e é um tipo fundamental

24857
16:25:20,160 --> 16:25:22,880
É realmente pequeno na memória, então é

24858
16:25:22,880 --> 16:25:25,520
Vai ser muito barato para copiar não é

24859
16:25:25,520 --> 16:25:28,080
Vou prejudicar o desempenho do nosso

24860
16:25:28,080 --> 16:25:31,436
Aplicação, mas o que queremos fazer agora

24861
16:25:31,436 --> 16:25:33,276
É para imprimir

24862
16:25:33,276 --> 16:25:37,040
o endereço da variável reservada em

24863
16:25:37,040 --> 16:25:39,520
A principal função aqui e veja que

24864
16:25:39,520 --> 16:25:41,756
É o mesmo que o

24865
16:25:41,756 --> 16:25:44,320
endereço da variável que temos dentro

24866
16:25:44,320 --> 16:25:46,000
Aqui outra coisa você deve tomar cuidado

24867
16:25:46,000 --> 16:25:48,400
porque é que somos capazes de obter dados

24868
16:25:48,400 --> 16:25:50,880
fora da função aqui a soma era a

24869
16:25:50,880 --> 16:25:53,840
variável local, mas somos capazes de obtê-lo

24870
16:25:53,840 --> 16:25:56,560
fora da função através do retorno

24871
16:25:56,560 --> 16:25:59,200
mecanismo aqui ok antes de ir em frente

24872
16:25:59,200 --> 16:26:01,680
e executar este programa vamos consertar

24873
16:26:01,680 --> 16:26:04,240
A declaração aqui esquecemos de mudar

24874
16:26:04,240 --> 16:26:07,116
Isso dizer para fora significa que é

24875
16:26:07,116 --> 16:26:09,276
fora da função aqui esse é o

24876
16:26:09,276 --> 16:26:12,320
significando que vamos construir com gcc

24877
16:26:12,320 --> 16:26:14,640
O mundo é bom que podemos limpar e correr

24878
16:26:14,640 --> 16:26:16,560
Galo agora vamos ver isso

24879
16:26:16,560 --> 16:26:19,840
dentro da função o endereço do

24880
16:26:19,840 --> 16:26:22,000
variável de resultado aqui

24881
16:26:22,000 --> 16:26:24,240
Fim em dac

24882
16:26:24,240 --> 16:26:27,116
e fora da função quando atingimos

24883
16:26:27,116 --> 16:26:29,040
O fim da função aqui estamos indo

24884
16:26:29,040 --> 16:26:32,400
para ver que o endereço termina em 4 assim

24885
16:26:32,400 --> 16:26:35,520
Isso prova que a variável local

24886
16:26:35,520 --> 16:26:38,000
dentro da função e do lado de fora

24887
16:26:38,000 --> 16:26:40,640
variável aqui na função principal

24888
16:26:40,640 --> 16:26:42,880
Deixando dois endereços de memória diferentes

24889
16:26:42,880 --> 16:26:44,956
Existem duas variáveis diferentes e

24890
16:26:44,956 --> 16:26:47,596
O mecanismo de retorno aqui está apenas indo

24891
16:26:47,596 --> 16:26:50,320
Copiar o que temos no local

24892
16:26:50,320 --> 16:26:52,640
variável e disponibilizá-lo no

24893
16:26:52,640 --> 16:26:56,000
Lá fora, para que possamos atribuí-lo a

24894
16:26:56,000 --> 16:26:58,080
a variável reservada em nosso principal

24895
16:26:58,080 --> 16:27:00,240
A função aqui é assim que o retorno

24896
16:27:00,240 --> 16:27:02,796
O mecanismo está funcionando e vai

24897
16:27:02,796 --> 16:27:05,520
estar retornando por valor por padrão é

24898
16:27:05,520 --> 16:27:07,360
Vou fazer cópias, este é o

24899
16:27:07,360 --> 16:27:09,840
Mensagem aqui agora que nós sabemos disso eu

24900
16:27:09,840 --> 16:27:11,360
Quero mostrar que existem

24901
16:27:11,360 --> 16:27:13,756
Exceções a essa regra

24902
16:27:13,756 --> 16:27:15,756
Se você retornar por valor assim

24903
16:27:15,756 --> 16:27:18,560
Não estará sempre usando separado

24904
16:27:18,560 --> 16:27:21,436
endereços de memória para o interior e o

24905
16:27:21,436 --> 16:27:23,200
Saímos aqui e vamos provar

24906
16:27:23,200 --> 16:27:25,200
que com uma função que vai

24907
16:27:25,200 --> 16:27:26,956
adicionar duas cordas

24908
16:27:26,956 --> 16:27:29,276
Vamos comentar o que temos porque

24909
16:27:29,276 --> 16:27:31,680
Nós não queremos que isso nos confunda

24910
16:27:31,680 --> 16:27:34,000
nós vamos trazer isso para dentro do nosso

24911
16:27:34,000 --> 16:27:36,240
bloqueio comentário aqui e nós vamos

24912
16:27:36,240 --> 16:27:38,880
ir abaixo da nossa função de soma aqui e definir

24913
16:27:38,880 --> 16:27:40,880
em cima de uma nova função que vai ser

24914
16:27:40,880 --> 16:27:43,840
chamado adicionar fios que vai voltar

24915
16:27:43,840 --> 16:27:46,720
uma string por valor bem é por valor

24916
16:27:46,720 --> 16:27:49,040
porque este tipo de retorno aqui não é

24917
16:27:49,040 --> 16:27:51,200
qualificado com qualquer coisa como um ponteiro

24918
16:27:51,200 --> 16:27:53,360
ou uma referência assim por padrão ele está indo

24919
16:27:53,360 --> 16:27:56,160
ser pelo valor e dentro você vê que somos

24920
16:27:56,160 --> 16:27:58,400
fazendo exatamente a mesma coisa que fizemos no

24921
16:27:58,400 --> 16:28:01,040
função de soma aqui estamos adicionando dois

24922
16:28:01,040 --> 16:28:03,360
fios que estamos armazenando os resultados em um

24923
16:28:03,360 --> 16:28:06,240
variável local e estamos devolvendo isso

24924
16:28:06,240 --> 16:28:08,240
Mas se executarmos este programa você está indo

24925
16:28:08,240 --> 16:28:11,680
para ver que o endereço no interior é

24926
16:28:11,680 --> 16:28:14,080
Vai ser o mesmo que o endereço em

24927
16:28:14,080 --> 16:28:16,880
O exterior, então vamos montar algo

24928
16:28:16,880 --> 16:28:18,560
que podemos brincar aqui estamos indo

24929
16:28:18,560 --> 16:28:20,480
para ir para baixo na função principal e definir

24930
16:28:20,480 --> 16:28:22,320
para cima de algumas variáveis que vamos dizer

24931
16:28:22,320 --> 16:28:24,840
hdd strand nós vamos dizer

24932
16:28:24,840 --> 16:28:28,080
nstr1 e nós vamos guardar em hello

24933
16:28:28,080 --> 16:28:30,720
Vamos fazer isso e nós vamos dizer std

24934
16:28:30,720 --> 16:28:31,756
A força

24935
16:28:31,756 --> 16:28:33,756
e str2

24936
16:28:33,756 --> 16:28:36,320
e nós vamos armazenar e ao mundo por

24937
16:28:36,320 --> 16:28:38,480
Agora você sabe o que eu estou tentando fazer aqui

24938
16:28:38,480 --> 16:28:40,796
Eu estou tentando dizer olá mundo bem uma vez

24939
16:28:40,796 --> 16:28:42,796
nós temos isso, nós vamos montar um

24940
16:28:42,796 --> 16:28:45,756
resort strike, então vamos dizer std

24941
16:28:45,756 --> 16:28:48,956
força e eu digo resultado str e nós somos

24942
16:28:48,956 --> 16:28:51,436
vamos dizer adicionar sdr e nós vamos

24943
16:28:51,436 --> 16:28:52,840
somar-se

24944
16:28:52,840 --> 16:28:57,520
nstr1 e na str2 é assim que fazemos isso

24945
16:28:57,520 --> 16:28:59,200
E depois de fazermos isso, vamos

24946
16:28:59,200 --> 16:29:02,080
imprimir o endereço da variável

24947
16:29:02,080 --> 16:29:04,400
Aqui, então vamos fazer isso e vai

24948
16:29:04,400 --> 16:29:08,880
ser o endereço do resultado hdr, digamos

24949
16:29:08,880 --> 16:29:11,840
Aqui e também precisamos imprimir o

24950
16:29:11,840 --> 16:29:14,720
resultado real desta operação aqui também

24951
16:29:14,720 --> 16:29:17,520
Vamos fazer isso nós vamos dizer sddc

24952
16:29:17,520 --> 16:29:20,640
out result sdr vamos imprimir o

24953
16:29:20,640 --> 16:29:21,596
real

24954
16:29:21,596 --> 16:29:24,160
força eu não acho que nós fizemos isso

24955
16:29:24,160 --> 16:29:25,200
nosso

24956
16:29:25,200 --> 16:29:28,240
função de soma aqui, mas podemos ir rapidamente

24957
16:29:28,240 --> 16:29:30,720
lá e provar isso para você, então vamos

24958
16:29:30,720 --> 16:29:33,116
Comente este desculpe por isso é

24959
16:29:33,116 --> 16:29:35,200
Vou ser confuso, mas eu não quero

24960
16:29:35,200 --> 16:29:36,880
para deixar você com

24961
16:29:36,880 --> 16:29:38,720
Agradecimentos inexplicáveis

24962
16:29:38,720 --> 16:29:40,796
então nós vamos ver isso se imprimirmos

24963
16:29:40,796 --> 16:29:42,320
Isso vamos conseguir a soma

24964
16:29:42,320 --> 16:29:45,520
que são 14 impressos para fora, vamos fazer isso

24965
16:29:45,520 --> 16:29:47,040
É muito rápido que vamos descer e

24966
16:29:47,040 --> 16:29:50,480
Diga sddcl e diga resultado e nós estamos indo

24967
16:29:50,480 --> 16:29:52,720
para dizer o resultado e vamos construir

24968
16:29:52,720 --> 16:29:55,840
é muito rápido com o gcc e se nós

24969
16:29:55,840 --> 16:29:58,000
limpar e correr o galo que vamos

24970
16:29:58,000 --> 16:30:00,480
Veja o resultado que é 14 aqui e você

24971
16:30:00,480 --> 16:30:02,240
pode mudar esses caras para realmente jogar

24972
16:30:02,240 --> 16:30:04,796
conosco, por exemplo, se fizermos este 15

24973
16:30:04,796 --> 16:30:07,436
e colocar em um 9 nós vamos ter um 24

24974
16:30:07,436 --> 16:30:09,520
Impresso para fora, vamos construir novamente

24975
16:30:09,520 --> 16:30:11,360
Só para nos divertirmos com isso e nós somos

24976
16:30:11,360 --> 16:30:13,596
indo para limpar e correr galo, nós somos

24977
16:30:13,596 --> 16:30:15,840
Vou ter um 24 aqui agora que podemos

24978
16:30:15,840 --> 16:30:18,320
Comentar isso de volta eu estou feliz que eu tenho

24979
16:30:18,320 --> 16:30:20,956
Mostrou-lhe isso e podemos descompreeir o nosso

24980
16:30:20,956 --> 16:30:24,480
string código aqui e uh construir e executá-lo

24981
16:30:24,480 --> 16:30:27,116
Então nós vamos construir com gcc o

24982
16:30:27,116 --> 16:30:29,436
construir é bom que podemos limpar e correr

24983
16:30:29,436 --> 16:30:32,560
Galo e novamente o que queremos ver

24984
16:30:32,560 --> 16:30:34,480
é que o compilador vai

24985
16:30:34,480 --> 16:30:36,720
Otimize isso para fora, não vai

24986
16:30:36,720 --> 16:30:39,916
retorno por valor como tínhamos era a soma

24987
16:30:39,916 --> 16:30:42,480
função onde tínhamos o endereço no

24988
16:30:42,480 --> 16:30:44,880
dentro diferente do endereço no

24989
16:30:44,880 --> 16:30:48,240
Fora você vê aqui que dentro de ah nós

24990
16:30:48,240 --> 16:30:50,560
Esqueci-me novamente de mudar esse cara para sair

24991
16:30:50,560 --> 16:30:52,880
uh desculpe por isso vamos fazer

24992
16:30:52,880 --> 16:30:54,880
Este cara para fora e nós vamos construir

24993
16:30:54,880 --> 16:30:56,956
Mais uma vez e nós vamos limpar

24994
16:30:56,956 --> 16:30:59,680
claro e correr galo agora vamos

24995
16:30:59,680 --> 16:31:03,840
Veja que dentro do endereço termina em d30

24996
16:31:03,840 --> 16:31:07,916
e fora do endereço termina em d30

24997
16:31:07,916 --> 16:31:10,160
pode ser muito confuso porque dissemos

24998
16:31:10,160 --> 16:31:12,636
Queremos retornar pelo valor por não

24999
16:31:12,636 --> 16:31:15,200
decorando nosso tipo de retorno com um

25000
16:31:15,200 --> 16:31:17,520
ponteiro ou uma referência ou algo como

25001
16:31:17,520 --> 16:31:19,436
que vai voltar por

25002
16:31:19,436 --> 16:31:21,840
valor e se você retornar por valor você é

25003
16:31:21,840 --> 16:31:23,916
vamos fazer cópias e se fizemos o

25004
16:31:23,916 --> 16:31:27,040
copia o endereço no interior e no

25005
16:31:27,040 --> 16:31:29,040
O endereço no exterior deve ser

25006
16:31:29,040 --> 16:31:31,200
Diferente, mas eles são os mesmos

25007
16:31:31,200 --> 16:31:32,956
A razão é que o compilador vai

25008
16:31:32,956 --> 16:31:35,200
observe que você está tentando copiar

25009
16:31:35,200 --> 16:31:36,400
fios

25010
16:31:36,400 --> 16:31:38,560
e vai ver que a variável

25011
16:31:38,560 --> 16:31:40,400
Aqui que está dentro da função é

25012
16:31:40,400 --> 16:31:42,720
Vai ser desperdiçado quando a função

25013
16:31:42,720 --> 16:31:43,756
Devoluções

25014
16:31:43,756 --> 16:31:45,680
por padrão, isso deve ser realmente

25015
16:31:45,680 --> 16:31:48,796
destruído e você deve copiar

25016
16:31:48,796 --> 16:31:50,720
porque você está retornando por valor, mas

25017
16:31:50,720 --> 16:31:52,480
o compilador vai inserir um

25018
16:31:52,480 --> 16:31:55,360
otimização para fazer alguma magia e fazer

25019
16:31:55,360 --> 16:31:57,360
Parece que você está voltando

25020
16:31:57,360 --> 16:31:59,520
referência e realmente não vai

25021
16:31:59,520 --> 16:32:01,916
fazer uma cópia para que ele reutilize o

25022
16:32:01,916 --> 16:32:04,480
endereço no interior e espero que isso

25023
16:32:04,480 --> 16:32:06,160
vai provar isso para você o

25024
16:32:06,160 --> 16:32:08,636
Mensagem aqui é que você não deve confiar

25025
16:32:08,636 --> 16:32:10,480
em suas funções

25026
16:32:10,480 --> 16:32:12,720
retornando pelo valor porque se o

25027
16:32:12,720 --> 16:32:15,040
O compilador vê que ele pode fazer uma melhor

25028
16:32:15,040 --> 16:32:17,756
trabalho do que você vai otimizar

25029
16:32:17,756 --> 16:32:20,000
seu retorno por valor para retornar

25030
16:32:20,000 --> 16:32:22,720
Referência e você não vai ser

25031
16:32:22,720 --> 16:32:25,276
fazer cópias para não fazer o seu código

25032
16:32:25,276 --> 16:32:28,636
depende de retornar por valor e fazer

25033
16:32:28,636 --> 16:32:31,240
cópias e você deve estar ciente destes

25034
16:32:31,240 --> 16:32:34,320
otimizações que o compilador pode fazer

25035
16:32:34,320 --> 16:32:37,276
pelas suas costas eu gostaria de receber

25036
16:32:37,276 --> 16:32:39,916
Você neste novo capítulo onde estaremos

25037
16:32:39,916 --> 16:32:42,320
aprendendo sobre sobrecarga de funções

25038
16:32:42,320 --> 16:32:44,636
A sobrecarga da função é um mecanismo que nós

25039
16:32:44,636 --> 16:32:46,636
ter em c plus plus

25040
16:32:46,636 --> 16:32:49,200
ter várias cópias do mesmo

25041
16:32:49,200 --> 16:32:52,636
função mas tomando parâmetros diferentes

25042
16:32:52,636 --> 16:32:54,160
por exemplo, aqui você vê que nós temos

25043
16:32:54,160 --> 16:32:56,000
Funções diferentes, mas tudo isso

25044
16:32:56,000 --> 16:32:58,720
As funções têm o mesmo nome de função

25045
16:32:58,720 --> 16:33:01,596
e estes são ditos para ser diferente

25046
16:33:01,596 --> 16:33:04,400
sobrecargas da mesma função que existem

25047
16:33:04,400 --> 16:33:06,560
Algumas regras que você precisa estar ciente

25048
16:33:06,560 --> 16:33:08,636
para ser capaz de configurar o seu macacão

25049
16:33:08,636 --> 16:33:10,480
corretamente e levá-los a trabalhar e

25050
16:33:10,480 --> 16:33:11,840
Isso é o que vamos aprender

25051
16:33:11,840 --> 16:33:14,720
em detalhes neste capítulo, mas agora

25052
16:33:14,720 --> 16:33:16,956
Eu só quero que você veja a flexibilidade

25053
16:33:16,956 --> 16:33:19,276
você pode obter com sobrecarga de função

25054
16:33:19,276 --> 16:33:21,200
Por exemplo, aqui se tivermos alguns

25055
16:33:21,200 --> 16:33:24,400
variáveis em nosso programa podemos chamar de

25056
16:33:24,400 --> 16:33:27,040
max function e o compilador está indo

25057
16:33:27,040 --> 16:33:29,680
para selecionar a sobrecarga mais apropriada

25058
16:33:29,680 --> 16:33:32,080
então, por exemplo, se chamarmos a nossa

25059
16:33:32,080 --> 16:33:35,040
função com argumentos inteiros

25060
16:33:35,040 --> 16:33:37,040
O compilador vai escolher este

25061
16:33:37,040 --> 16:33:39,840
sobrecarga aqui se chamarmos uma função com

25062
16:33:39,840 --> 16:33:42,560
std string arguments que o compilador é

25063
16:33:42,560 --> 16:33:45,520
Vou escolher esta sobrecarga aqui e

25064
16:33:45,520 --> 16:33:47,276
Não precisamos realmente de nos preocupar

25065
16:33:47,276 --> 16:33:48,796
a nós mesmos

25066
16:33:48,796 --> 16:33:50,720
certificando-nos de que temos o correto

25067
16:33:50,720 --> 16:33:52,480
argumentos que o compilador vai

25068
16:33:52,480 --> 16:33:54,636
escolha a sobrecarga de função correta para

25069
16:33:54,636 --> 16:33:56,796
Nós e vai chamá-lo e é

25070
16:33:56,796 --> 16:33:58,796
Vai ser muito flexível para chamar estes

25071
16:33:58,796 --> 16:34:01,436
funções do nosso c plus código este

25072
16:34:01,436 --> 16:34:04,160
é como a sobrecarga da função pode ser realmente

25073
16:34:04,160 --> 16:34:06,636
úteis, vamos parar por aqui neste

25074
16:34:06,636 --> 16:34:08,320
palestra no próximo, vamos

25075
16:34:08,320 --> 16:34:10,560
Saiba como você pode configurar a função

25076
16:34:10,560 --> 16:34:13,520
sobrecargas baseadas em diferentes funções

25077
16:34:13,520 --> 16:34:14,796
Os parâmetros

25078
16:34:14,796 --> 16:34:17,200
Vá em frente e termine aqui e me encontre

25079
16:34:17,200 --> 16:34:19,360
lá nesta palestra vamos ver

25080
16:34:19,360 --> 16:34:22,480
como podemos sobrecarregar as funções baseadas em

25081
16:34:22,480 --> 16:34:24,956
Os parâmetros que passamos para o

25082
16:34:24,956 --> 16:34:27,436
função quando o declaramos ou

25083
16:34:27,436 --> 16:34:29,840
Definindo e aqui é um exemplo simples

25084
16:34:29,840 --> 16:34:32,080
para conduzir o ponto para casa aqui temos um

25085
16:34:32,080 --> 16:34:34,320
Função chamada max

25086
16:34:34,320 --> 16:34:36,320
E este é o nome

25087
16:34:36,320 --> 16:34:38,880
está tomando dois parâmetros que são de

25088
16:34:38,880 --> 16:34:40,636
Digite e aqui

25089
16:34:40,636 --> 16:34:43,756
e sobrecarregando esta função nós vamos

25090
16:34:43,756 --> 16:34:46,320
Use o mesmo nome que este

25091
16:34:46,320 --> 16:34:48,956
Funcionar aqui para que as diferenças realmente

25092
16:34:48,956 --> 16:34:51,360
estará nos parâmetros que passamos

25093
16:34:51,360 --> 16:34:54,320
para a função porque do tipo de retorno

25094
16:34:54,320 --> 16:34:55,276
Não é

25095
16:34:55,276 --> 16:34:58,480
envolvidos na definição da assinatura de

25096
16:34:58,480 --> 16:35:00,480
A função se tentarmos configurar

25097
16:35:00,480 --> 16:35:02,720
Outra função chamada max aqui que

25098
16:35:02,720 --> 16:35:04,560
Leva o exato

25099
16:35:04,560 --> 16:35:07,840
os mesmos parâmetros que o nosso máximo no topo aqui

25100
16:35:07,840 --> 16:35:09,520
A diferença só vai estar em

25101
16:35:09,520 --> 16:35:11,680
O tipo de retorno que o compilador não é

25102
16:35:11,680 --> 16:35:13,596
vamos nos permitir fazer isso porque o

25103
16:35:13,596 --> 16:35:17,116
O tipo de retorno não é realmente significativo

25104
16:35:17,116 --> 16:35:19,756
em fazer duas funções diferentes

25105
16:35:19,756 --> 16:35:21,360
A única maneira de criar uma

25106
16:35:21,360 --> 16:35:24,400
função que é legal em c plus plus

25107
16:35:24,400 --> 16:35:27,276
É mudar algo sobre o

25108
16:35:27,276 --> 16:35:29,680
parâmetros que temos aqui podemos

25109
16:35:29,680 --> 16:35:31,436
Mudar os tipos como você vê aqui para

25110
16:35:31,436 --> 16:35:33,916
Exemplo, alteramos os tipos para b duplo

25111
16:35:33,916 --> 16:35:36,000
Se os tipos são diferentes, podemos até

25112
16:35:36,000 --> 16:35:38,160
Alterar a ordem dos parâmetros que você

25113
16:35:38,160 --> 16:35:40,080
só tem que certificar-se do parâmetro

25114
16:35:40,080 --> 16:35:43,520
A lista é diferente de uma forma ou de outra

25115
16:35:43,520 --> 16:35:45,040
É assim que você vai conseguir isso

25116
16:35:45,040 --> 16:35:48,080
Função para correr com os mesmos nomes aqui

25117
16:35:48,080 --> 16:35:49,916
e se conseguirmos configurar múltiplos

25118
16:35:49,916 --> 16:35:52,320
funções com o mesmo nome em c plus

25119
16:35:52,320 --> 16:35:54,560
Além disso, essas funções serão

25120
16:35:54,560 --> 16:35:56,956
chamado sobrecargas um do outro ok se

25121
16:35:56,956 --> 16:35:59,040
nós vamos aqui, temos outra sobrecarga

25122
16:35:59,040 --> 16:36:01,680
para a função máxima esta sobrecarga é

25123
16:36:01,680 --> 16:36:03,756
Vou tomar dois parâmetros e

25124
16:36:03,756 --> 16:36:05,680
Os parâmetros serão do tipo

25125
16:36:05,680 --> 16:36:08,240
string view eles são diferentes do que

25126
16:36:08,240 --> 16:36:10,636
Temos no topo aqui que é formi, então isso

25127
16:36:10,636 --> 16:36:13,916
é uma sobrecarga legal para este máximo

25128
16:36:13,916 --> 16:36:16,320
função aqui e podemos usá-lo ok

25129
16:36:16,320 --> 16:36:18,480
realmente ter algumas maneiras de fazer o nosso

25130
16:36:18,480 --> 16:36:21,276
sobrecargas de função até agora podemos mudar

25131
16:36:21,276 --> 16:36:23,916
A ordem do parâmetro podemos mudar

25132
16:36:23,916 --> 16:36:26,080
O número dos parâmetros ou mesmo nós

25133
16:36:26,080 --> 16:36:28,560
pode alterar os tipos de parâmetros

25134
16:36:28,560 --> 16:36:31,680
novamente as sobrecargas de função são um mecanismo

25135
16:36:31,680 --> 16:36:34,160
temos em c plus plus para configurar

25136
16:36:34,160 --> 16:36:36,880
múltiplas funções com o mesmo nome para

25137
16:36:36,880 --> 16:36:39,520
tornar nosso código mais fácil de trabalhar bem

25138
16:36:39,520 --> 16:36:41,200
Agora que você sabe que vamos olhar para um

25139
16:36:41,200 --> 16:36:43,756
Um exemplo simples de como podemos chamar o nosso

25140
16:36:43,756 --> 16:36:45,840
sobrecargas que temos algumas variáveis

25141
16:36:45,840 --> 16:36:48,080
Declaramos aqui que temos variáveis de formigos

25142
16:36:48,080 --> 16:36:50,636
têm variáveis duplas e temos std

25143
16:36:50,636 --> 16:36:52,560
variáveis de exibição de string

25144
16:36:52,560 --> 16:36:54,796
E se você for aqui, estamos chamando

25145
16:36:54,796 --> 16:36:57,756
nossa função máxima passando em inteiros assim

25146
16:36:57,756 --> 16:37:00,080
a sobrecarga que leva inteiros para

25147
16:37:00,080 --> 16:37:02,000
Esta função máxima será chamada

25148
16:37:02,000 --> 16:37:05,116
Aqui em baixo estamos passando em inteiro

25149
16:37:05,116 --> 16:37:07,116
literals, então isso vai chamar de

25150
16:37:07,116 --> 16:37:10,000
int overload aqui estamos chamando

25151
16:37:10,000 --> 16:37:12,480
a função com parâmetros duplos ou

25152
16:37:12,480 --> 16:37:15,040
argumentos para que isso chame a nossa

25153
16:37:15,040 --> 16:37:17,276
sobrecarga dupla para a função de correspondência

25154
16:37:17,276 --> 16:37:20,320
Aqui e aqui estamos passando em nosso

25155
16:37:20,320 --> 16:37:22,880
parâmetros de visualização de string e isso está indo

25156
16:37:22,880 --> 16:37:25,840
para chamar a sobrecarga que leva string

25157
16:37:25,840 --> 16:37:28,480
ver os parâmetros e o último cara aqui é

25158
16:37:28,480 --> 16:37:29,916
Vou levar

25159
16:37:29,916 --> 16:37:33,040
dois string literals string literals pode

25160
16:37:33,040 --> 16:37:37,200
converta implicitamente para std string view assim

25161
16:37:37,200 --> 16:37:40,796
nossa sobrecarga de visão de string std para o máximo

25162
16:37:40,796 --> 16:37:43,360
A função aqui vai ser chamada

25163
16:37:43,360 --> 16:37:44,636
Agora que sabemos isso, vamos

25164
16:37:44,636 --> 16:37:46,880
cabeça para código de estúdio visual e jogar

25165
16:37:46,880 --> 16:37:49,116
com isso um pouco mais bem aqui estamos

25166
16:37:49,116 --> 16:37:51,680
em nossa pasta de trabalho a atual

25167
16:37:51,680 --> 16:37:54,720
O projeto está sobrecarregando com diferentes

25168
16:37:54,720 --> 16:37:57,756
Parâmetros aqui nós vamos pegar o nosso

25169
16:37:57,756 --> 16:38:00,240
arquivos de modelo como sempre fazemos

25170
16:38:00,240 --> 16:38:02,240
Vou colocá-los no lugar

25171
16:38:02,240 --> 16:38:04,160
e nós vamos abrir esse cara em

25172
16:38:04,160 --> 16:38:06,320
código visual do estúdio arrastando e

25173
16:38:06,320 --> 16:38:08,720
cair em cima do código de estúdio visual

25174
16:38:08,720 --> 16:38:10,880
Aqui isso vai abrir nosso projeto

25175
16:38:10,880 --> 16:38:12,720
Aqui vamos clicar em nosso principal

25176
16:38:12,720 --> 16:38:15,680
arquivo cpp e abri-lo que vamos

25177
16:38:15,680 --> 16:38:18,000
Limpe-o um pouco e feche o

25178
16:38:18,000 --> 16:38:20,636
Pane esquerdo aqui nós vamos no topo

25179
16:38:20,636 --> 16:38:23,520
aqui e colocar em nossa primeira função máxima

25180
16:38:23,520 --> 16:38:26,240
Aqui o tipo de retorno é e neste caso

25181
16:38:26,240 --> 16:38:28,636
vai tomar dois parâmetros e

25182
16:38:28,636 --> 16:38:30,796
Vai devolver qualquer número

25183
16:38:30,796 --> 16:38:33,200
é o máximo e estamos tomando

25184
16:38:33,200 --> 16:38:35,756
parâmetros em valor e retornando por

25185
16:38:35,756 --> 16:38:38,160
valor aqui nada de especial podemos entrar

25186
16:38:38,160 --> 16:38:39,840
Principal e chame essa função e você

25187
16:38:39,840 --> 16:38:41,360
já sei como fazer isso, eu não

25188
16:38:41,360 --> 16:38:43,276
Acho que eu realmente preciso fazer isso

25189
16:38:43,276 --> 16:38:46,240
Mas agora o que realmente estamos interessados

25190
16:38:46,240 --> 16:38:49,040
é ser capaz de configurar diferentes

25191
16:38:49,040 --> 16:38:51,680
funções com o mesmo nome de função

25192
16:38:51,680 --> 16:38:54,240
Como temos aqui, porque se por exemplo

25193
16:38:54,240 --> 16:38:56,720
Você pega essa função e coloca isso para baixo

25194
16:38:56,720 --> 16:38:58,796
Abaixo vamos fazer uma cópia dele

25195
16:38:58,796 --> 16:39:01,520
e só alterar o tipo de retorno se nós

25196
16:39:01,520 --> 16:39:03,596
Tente compilar este programa, você vê que

25197
16:39:03,596 --> 16:39:06,560
Até mesmo o código de estúdio visual está infeliz agora

25198
16:39:06,560 --> 16:39:08,880
Se trouxermos um terminal, ele vai

25199
16:39:08,880 --> 16:39:11,596
Diga-nos não pode sobrecarregar a função

25200
16:39:11,596 --> 16:39:14,956
Distinguindo apenas o tipo de retorno

25201
16:39:14,956 --> 16:39:17,520
Então, novamente, a mensagem é super clara aqui

25202
16:39:17,520 --> 16:39:20,320
O tipo de retorno não é suficiente para fazer

25203
16:39:20,320 --> 16:39:22,560
duas funções diferentes porque o

25204
16:39:22,560 --> 16:39:26,560
O tipo de retorno não está envolvido em fazer o

25205
16:39:26,560 --> 16:39:28,880
Assinatura única o que faz o

25206
16:39:28,880 --> 16:39:30,880
A assinatura única é a função

25207
16:39:30,880 --> 16:39:33,756
nome ou os parâmetros para os quais você passa

25208
16:39:33,756 --> 16:39:36,080
a função aqui, então vamos fazer

25209
16:39:36,080 --> 16:39:38,480
Este tipo de retorno de volta um duplo e nós somos

25210
16:39:38,480 --> 16:39:40,160
Vou descobrir uma maneira de fazer isso

25211
16:39:40,160 --> 16:39:42,720
Duas funções diferentes, mas têm a

25212
16:39:42,720 --> 16:39:44,400
O mesmo nome aqui porque às vezes você

25213
16:39:44,400 --> 16:39:45,680
Realmente quero isso

25214
16:39:45,680 --> 16:39:47,680
Um jeito que temos que fazer isso é mudar

25215
16:39:47,680 --> 16:39:49,756
Tipos dos parâmetros que passamos

25216
16:39:49,756 --> 16:39:51,520
Aqui, então vamos fazê-los

25217
16:39:51,520 --> 16:39:53,040
duplo e nós vamos fazê-los

25218
16:39:53,040 --> 16:39:55,116
duplo aqui e isso vai ser

25219
16:39:55,116 --> 16:39:58,000
válido c plus plus poderia estes dois

25220
16:39:58,000 --> 16:40:00,400
As funções são diferentes, mesmo que

25221
16:40:00,400 --> 16:40:02,636
Tenho o mesmo nome aqui são dois

25222
16:40:02,636 --> 16:40:04,560
diferentes funções porque levam

25223
16:40:04,560 --> 16:40:06,880
Parâmetros diferentes, portanto, se você tentar

25224
16:40:06,880 --> 16:40:08,956
chamar esta função com

25225
16:40:08,956 --> 16:40:11,596
inteiros este vai ser chamado

25226
16:40:11,596 --> 16:40:14,080
que leva inteiros n se você chamá-lo

25227
16:40:14,080 --> 16:40:16,240
com argumentos duplos, esse cara aqui é

25228
16:40:16,240 --> 16:40:17,916
vai ser chamado vamos tentar provar

25229
16:40:17,916 --> 16:40:20,400
Isso vamos para dentro e dizer

25230
16:40:20,400 --> 16:40:24,080
stdc para fora e sobrecarga chamado eu acho

25231
16:40:24,080 --> 16:40:26,000
Isso é suficiente e nós vamos entrar

25232
16:40:26,000 --> 16:40:28,636
a dupla função aqui e dizer sddc

25233
16:40:28,636 --> 16:40:31,116
fora dupla sobrecarga cool

25234
16:40:31,116 --> 16:40:33,200
Ok, uma vez que temos isso, também temos que

25235
16:40:33,200 --> 16:40:35,840
Alterar o tipo de retorno aqui para dobrar

25236
16:40:35,840 --> 16:40:37,276
Porque vai fazer as coisas um

25237
16:40:37,276 --> 16:40:39,840
Um pouco consistente aqui, mas agora nós

25238
16:40:39,840 --> 16:40:43,040
Quero ir na nossa principal função aqui

25239
16:40:43,040 --> 16:40:44,880
e configurar algumas variáveis que estamos indo

25240
16:40:44,880 --> 16:40:46,796
para dizer e x e nós vamos fazer

25241
16:40:46,796 --> 16:40:48,880
este um quatro e nós vamos dizer em

25242
16:40:48,880 --> 16:40:51,200
y e nós vamos fazer disso um nove

25243
16:40:51,200 --> 16:40:52,320
Por que não

25244
16:40:52,320 --> 16:40:54,400
Nós vamos configurar também o dobro

25245
16:40:54,400 --> 16:40:57,520
variáveis, digamos, o dobro

25246
16:40:57,520 --> 16:40:59,436
E dizer cinco

25247
16:40:59,436 --> 16:41:02,560
o ponto quatro para torná-lo uma variável dupla

25248
16:41:02,560 --> 16:41:04,636
E nós vamos dizer o dobro

25249
16:41:04,636 --> 16:41:08,480
b e colocar em 7.4

25250
16:41:08,480 --> 16:41:09,680
Por que não

25251
16:41:09,680 --> 16:41:11,596
Agora vamos chamar o máximo, vamos

25252
16:41:11,596 --> 16:41:15,200
para dizer auto resultado e dizer max e

25253
16:41:15,200 --> 16:41:17,680
passando x e y

25254
16:41:17,680 --> 16:41:19,436
O que você acha que vamos voltar

25255
16:41:19,436 --> 16:41:22,320
Aqui, o que realmente estamos interessados

25256
16:41:22,320 --> 16:41:24,636
é o tipo de retorno do resultado

25257
16:41:24,636 --> 16:41:26,796
variável aqui e o compilador está indo

25258
16:41:26,796 --> 16:41:29,360
para deduzir tudo o que é devolvido por este

25259
16:41:29,360 --> 16:41:31,916
Função se chamamos a função com x

25260
16:41:31,916 --> 16:41:34,480
e y x e y são inteiros para que

25261
16:41:34,480 --> 16:41:36,080
O compilador vai procurar por um

25262
16:41:36,080 --> 16:41:38,240
função que leva inteiros e é

25263
16:41:38,240 --> 16:41:39,840
Vou encontrar esse cara aqui e isso é

25264
16:41:39,840 --> 16:41:41,756
O que vai ser chamado

25265
16:41:41,756 --> 16:41:44,400
Vamos soldar e executar este programa que somos

25266
16:41:44,400 --> 16:41:46,636
não está interessado em olhar para a saída

25267
16:41:46,636 --> 16:41:49,916
Aqui nós só vamos ver este std

25268
16:41:49,916 --> 16:41:52,480
A declaração aqui imprime o que for

25269
16:41:52,480 --> 16:41:55,040
A função foi chamada bem, esperamos o

25270
16:41:55,040 --> 16:41:56,636
acabar um para ser chamado assim nós vamos

25271
16:41:56,636 --> 16:41:59,360
ver sobrecarga de formção chamada no terminal

25272
16:41:59,360 --> 16:42:02,400
aqui quando executamos este programa, então vamos

25273
16:42:02,400 --> 16:42:04,400
para que vamos construir com gcc

25274
16:42:04,400 --> 16:42:07,276
Como sempre fazemos, o mundo é tão bom

25275
16:42:07,276 --> 16:42:09,840
nós podemos limpar e correr galo

25276
16:42:09,840 --> 16:42:12,320
nós vamos ver a sobrecarga chamada

25277
16:42:12,320 --> 16:42:14,796
Tudo bem, então isso prova que

25278
16:42:14,796 --> 16:42:16,720
Podemos configurar duas funções com a

25279
16:42:16,720 --> 16:42:19,200
O mesmo nome e torná-los diferentes apenas

25280
16:42:19,200 --> 16:42:22,320
nos parâmetros que eles tomam e

25281
16:42:22,320 --> 16:42:24,796
As diferenças podem estar nos tipos

25282
16:42:24,796 --> 16:42:27,200
do parâmetro como estamos fazendo aqui

25283
16:42:27,200 --> 16:42:29,680
Eles também podem estar na ordem do

25284
16:42:29,680 --> 16:42:31,916
Parâmetros e vamos ver um

25285
16:42:31,916 --> 16:42:34,160
Um exemplo disso em um minuto, mas antes

25286
16:42:34,160 --> 16:42:36,560
Também precisamos tentar isso com

25287
16:42:36,560 --> 16:42:38,880
a e b e mostrar que o duplo

25288
16:42:38,880 --> 16:42:41,116
vai ser chamado porque nós somos

25289
16:42:41,116 --> 16:42:43,756
passando em argumentos duplos aqui, então

25290
16:42:43,756 --> 16:42:45,756
Vamos construir de novo a bala é boa nós

25291
16:42:45,756 --> 16:42:48,796
pode limpar e correr galo isso está indo

25292
16:42:48,796 --> 16:42:51,916
para chamar nossa dupla sobrecarga esperançosamente

25293
16:42:51,916 --> 16:42:54,400
Isso realmente impulsiona o ponto para casa

25294
16:42:54,400 --> 16:42:56,720
que podemos configurar várias sobrecargas

25295
16:42:56,720 --> 16:42:59,276
para o mesmo nome da função e novamente o

25296
16:42:59,276 --> 16:43:00,720
As diferenças vão estar no

25297
16:43:00,720 --> 16:43:03,040
Parâmetros que passamos aqui temos

25298
16:43:03,040 --> 16:43:06,000
Foi capaz de passar diferentes tipos para

25299
16:43:06,000 --> 16:43:08,480
os parâmetros e este foi um veículo c

25300
16:43:08,480 --> 16:43:10,956
mais mais código, mas também podemos configurar

25301
16:43:10,956 --> 16:43:14,000
Outra sobrecarga apenas mudando o

25302
16:43:14,000 --> 16:43:17,040
Tipos e a ordem dos parâmetros

25303
16:43:17,040 --> 16:43:18,636
Vamos fazer isso, vamos fazer o

25304
16:43:18,636 --> 16:43:21,360
primeiro parâmetro aqui e uma vez que fazemos

25305
16:43:21,360 --> 16:43:23,596
que isso é diferente de qualquer um dos

25306
16:43:23,596 --> 16:43:26,480
sobrecargas que tivemos, então esta é uma

25307
16:43:26,480 --> 16:43:29,200
sobrecarga para esta função máxima aqui este

25308
16:43:29,200 --> 16:43:31,436
Vai trabalhar, podemos até mudar o

25309
16:43:31,436 --> 16:43:33,680
ordem desses dois caras e também é

25310
16:43:33,680 --> 16:43:34,880
Vou ser

25311
16:43:34,880 --> 16:43:37,276
uma sobrecarga válida, vamos colocar em outro

25312
16:43:37,276 --> 16:43:39,200
A variante desse cara

25313
16:43:39,200 --> 16:43:40,956
E nós vamos mudar o primeiro

25314
16:43:40,956 --> 16:43:43,040
parâmetro para dobrar e o segundo

25315
16:43:43,040 --> 16:43:46,240
para terminar e agora temos quatro sobrecargas

25316
16:43:46,240 --> 16:43:48,636
para a função máxima e novamente a

25317
16:43:48,636 --> 16:43:51,116
Mensagem aqui é que você só tem que

25318
16:43:51,116 --> 16:43:54,080
Certifique-se de que os parâmetros são diferentes

25319
16:43:54,080 --> 16:43:56,636
de alguma forma e sua sobrecarga está indo

25320
16:43:56,636 --> 16:43:59,040
para ser válido e novamente eu não estou dizendo

25321
16:43:59,040 --> 16:44:00,720
você para configurar funções como esta

25322
16:44:00,720 --> 16:44:02,400
porque neste caso isso é realmente

25323
16:44:02,400 --> 16:44:05,116
inútil, mas estou tentando expor isso

25324
16:44:05,116 --> 16:44:07,520
facilidade para você para que você possa usá-lo

25325
16:44:07,520 --> 16:44:10,560
para sua vantagem se faz sentido para

25326
16:44:10,560 --> 16:44:12,480
Qualquer aplicação que você está projetando

25327
16:44:12,480 --> 16:44:15,360
Aqui, então vamos descer e colocar

25328
16:44:15,360 --> 16:44:18,320
saída significativa eu acho que podemos entrar

25329
16:44:18,320 --> 16:44:20,080
aqui e dizer os parâmetros que somos

25330
16:44:20,080 --> 16:44:22,956
passando aqui para que possamos dizer e dobrar

25331
16:44:22,956 --> 16:44:25,200
sobrecarga chamada e se formos aqui

25332
16:44:25,200 --> 16:44:28,000
Você pode tirar isso e dizer o dobro e

25333
16:44:28,000 --> 16:44:30,636
sobrecarga chamada e para obter qualquer um destes

25334
16:44:30,636 --> 16:44:32,720
para serem chamados, temos que passar o

25335
16:44:32,720 --> 16:44:35,200
parâmetros ou dos argumentos nesta

25336
16:44:35,200 --> 16:44:36,160
ordem

25337
16:44:36,160 --> 16:44:39,840
assim, se passarmos em uma extremidade que é x x é

25338
16:44:39,840 --> 16:44:42,480
nele e nós passamos em um duplo que é um

25339
16:44:42,480 --> 16:44:44,720
b aqui isso vai chamar a nossa

25340
16:44:44,720 --> 16:44:47,520
sobrecarga que leva o primeiro argumento

25341
16:44:47,520 --> 16:44:50,000
ser um inteiro e um segundo argumento

25342
16:44:50,000 --> 16:44:51,276
Para ser o dobro

25343
16:44:51,276 --> 16:44:53,276
vamos provar que vamos

25344
16:44:53,276 --> 16:44:55,756
construir com o gcc o parafuso é bom

25345
16:44:55,756 --> 16:44:57,840
Podemos limpar e podemos correr galo e

25346
16:44:57,840 --> 16:45:00,720
vemos formiam dupla chamada porque x é um

25347
16:45:00,720 --> 16:45:01,520
O fim

25348
16:45:01,520 --> 16:45:04,720
e b é um duplo se virarmos esses caras

25349
16:45:04,720 --> 16:45:07,596
Vamos dizer b e x então nós vamos

25350
16:45:07,596 --> 16:45:09,916
ter a sobrecarga que leva o primeiro

25351
16:45:09,916 --> 16:45:12,796
argumento do tipo duplo e do segundo

25352
16:45:12,796 --> 16:45:15,116
argumento do tipo a ser chamado e

25353
16:45:15,116 --> 16:45:17,116
É esse cara aqui e nós vamos

25354
16:45:17,116 --> 16:45:19,840
Veja esta mensagem impressa no

25355
16:45:19,840 --> 16:45:22,480
terminal aqui vamos construir com gcc para

25356
16:45:22,480 --> 16:45:24,240
Realmente provar isso, então nós vamos fazer

25357
16:45:24,240 --> 16:45:25,040
que

25358
16:45:25,040 --> 16:45:27,436
A bala é boa, podemos limpar e correr

25359
16:45:27,436 --> 16:45:28,400
Galo

25360
16:45:28,400 --> 16:45:30,720
e a sobrecarga de extremidade dupla chamada

25361
16:45:30,720 --> 16:45:32,480
Espero que você possa realmente ver que você

25362
16:45:32,480 --> 16:45:35,596
pode configurar todos os tipos de sobrecargas loucas

25363
16:45:35,596 --> 16:45:38,000
Para suas funções a próxima coisa que eu quero

25364
16:45:38,000 --> 16:45:39,680
Você vê é que nós podemos até mudar

25365
16:45:39,680 --> 16:45:42,240
O número de parâmetros, por exemplo

25366
16:45:42,240 --> 16:45:44,636
Aqui podemos montar outro cara aqui e

25367
16:45:44,636 --> 16:45:47,276
Eu chamo de max que vai ser exatamente

25368
16:45:47,276 --> 16:45:49,840
Como aquele no topo aqui para o primeiro

25369
16:45:49,840 --> 16:45:52,796
dois parâmetros mas vamos adicionar um terceiro

25370
16:45:52,796 --> 16:45:56,240
parâmetro talvez torná-lo um fim e dizer c

25371
16:45:56,240 --> 16:45:57,840
E isso vai ser

25372
16:45:57,840 --> 16:46:00,400
uma sobrecarga válida para a função máxima

25373
16:46:00,400 --> 16:46:02,560
Então vamos dizer o dobro e

25374
16:46:02,560 --> 16:46:04,000
Porque é preciso

25375
16:46:04,000 --> 16:46:06,720
três parâmetros eu não vou entrar no

25376
16:46:06,720 --> 16:46:08,796
detalhes de como podemos calcular o

25377
16:46:08,796 --> 16:46:11,360
máximo entre esses três caras o que eu

25378
16:46:11,360 --> 16:46:13,436
realmente estou interessado em mostrar a você

25379
16:46:13,436 --> 16:46:15,756
que você pode configurar sobrecargas aqui, então

25380
16:46:15,756 --> 16:46:17,436
para este caso, vamos apenas

25381
16:46:17,436 --> 16:46:20,480
retorno, vamos apenas dizer que isso vai

25382
16:46:20,480 --> 16:46:23,596
trabalho, mas esta é uma sobrecarga válida para

25383
16:46:23,596 --> 16:46:25,200
A função de correspondência e vai

25384
16:46:25,200 --> 16:46:27,840
compile assim vamos desenhar e fazer isso

25385
16:46:27,840 --> 16:46:30,160
passar e uma rede dupla e a

25386
16:46:30,160 --> 16:46:32,636
Net então vamos passar em b que é

25387
16:46:32,636 --> 16:46:34,880
um duplo e x e y

25388
16:46:34,880 --> 16:46:36,400
Vamos ver o que é chamado aqui, podemos

25389
16:46:36,400 --> 16:46:39,360
compilar com gcc a fronteira é bom

25390
16:46:39,360 --> 16:46:41,520
pode limpar e agradar

25391
16:46:41,520 --> 16:46:43,276
Tente chegar ao que vai ser

25392
16:46:43,276 --> 16:46:44,880
Impresso aqui o que vai ser

25393
16:46:44,880 --> 16:46:47,116
impresso ok agora que você adivinhou

25394
16:46:47,116 --> 16:46:48,636
nós vamos correr e nós vamos

25395
16:46:48,636 --> 16:46:50,880
Veja o duplo e formi, porque isso está indo

25396
16:46:50,880 --> 16:46:53,596
para chamar essa sobrecarga novamente, você pode

25397
16:46:53,596 --> 16:46:56,320
sobrecarga com base nas diferenças no

25398
16:46:56,320 --> 16:46:58,796
Tipos dos parâmetros que você passa

25399
16:46:58,796 --> 16:47:00,480
Você pode alterar a ordem do

25400
16:47:00,480 --> 16:47:03,276
parâmetros como se estivessemos fazendo aqui duplo

25401
16:47:03,276 --> 16:47:06,480
fim e fim duplo ou você pode até mesmo

25402
16:47:06,480 --> 16:47:08,636
Alterar o número de parâmetros

25403
16:47:08,636 --> 16:47:11,276
usando essas técnicas, você pode garantir que

25404
16:47:11,276 --> 16:47:13,756
que suas sobrecargas são diferentes em

25405
16:47:13,756 --> 16:47:14,880
De alguma forma

25406
16:47:14,880 --> 16:47:16,956
Antes de fechar esta palestra eu vou

25407
16:47:16,956 --> 16:47:18,720
mostrar que você também pode usar outro

25408
16:47:18,720 --> 16:47:20,400
sobrecarga que leva

25409
16:47:20,400 --> 16:47:22,720
Parâmetros de visão de string vamos para baixo

25410
16:47:22,720 --> 16:47:24,956
aqui e colocar isso em

25411
16:47:24,956 --> 16:47:26,880
novamente o nome da função é max

25412
16:47:26,880 --> 16:47:29,276
O tipo de retorno não é realmente significativo

25413
16:47:29,276 --> 16:47:31,040
em garantir que duas funções sejam

25414
16:47:31,040 --> 16:47:33,276
diferente, mas observe os parâmetros que nós

25415
16:47:33,276 --> 16:47:36,240
passar aqui os tipos são string view

25416
16:47:36,240 --> 16:47:38,560
E nós temos a e b aqui e nós estamos

25417
16:47:38,560 --> 16:47:40,880
vamos calcular o máximo, então se formos

25418
16:47:40,880 --> 16:47:44,636
Aqui em baixo e dizer max e passar n olá

25419
16:47:44,636 --> 16:47:46,880
e mundo o compilador vai tentar

25420
16:47:46,880 --> 16:47:49,756
e procure uma função que leve dois

25421
16:47:49,756 --> 16:47:51,680
parâmetros de matriz de caracteres não é

25422
16:47:51,680 --> 16:47:53,360
vamos encontrá-lo porque nós não temos

25423
16:47:53,360 --> 16:47:55,840
aquele cara aqui, mas vai ver

25424
16:47:55,840 --> 16:47:57,840
Qual a função

25425
16:47:57,840 --> 16:48:01,040
tomar algo que eu posso vir com

25426
16:48:01,040 --> 16:48:03,116
através de conversões implícitas e

25427
16:48:03,116 --> 16:48:04,720
O compilador vai ver que ele pode

25428
16:48:04,720 --> 16:48:06,480
Realmente converter a partir de

25429
16:48:06,480 --> 16:48:09,916
uma string literal para um tipo de exibição de cadeia

25430
16:48:09,916 --> 16:48:12,160
e vai inserir um

25431
16:48:12,160 --> 16:48:13,840
A conversão a partir de

25432
16:48:13,840 --> 16:48:16,636
string literal para string view e isso

25433
16:48:16,636 --> 16:48:18,880
A função aqui vai ser chamada assim

25434
16:48:18,880 --> 16:48:21,200
vamos colocar em uma saída

25435
16:48:21,200 --> 16:48:23,436
Declaração aqui vamos dizer

25436
16:48:23,436 --> 16:48:27,840
string view string view view overload chamado

25437
16:48:27,840 --> 16:48:30,480
e se tentarmos executar este programa vamos

25438
16:48:30,480 --> 16:48:32,880
construir com gcc certifique-se de que a construção

25439
16:48:32,880 --> 16:48:33,916
É bom

25440
16:48:33,916 --> 16:48:36,480
O mundo é bom para que possamos limpar e

25441
16:48:36,480 --> 16:48:38,956
run galo isto vai mostrar string

25442
16:48:38,956 --> 16:48:41,680
view string view sobrecarga chamada nós somos

25443
16:48:41,680 --> 16:48:44,160
capaz de chamar esse cara aqui e novamente de

25444
16:48:44,160 --> 16:48:46,480
A mensagem é que realmente temos muito

25445
16:48:46,480 --> 16:48:49,040
flexibilidade na forma como podemos configurar

25446
16:48:49,040 --> 16:48:52,400
sobrecargas para uma função em c plus plus

25447
16:48:52,400 --> 16:48:55,436
e por favor use esta facilidade em sua

25448
16:48:55,436 --> 16:48:57,916
vantagem se isso melhorar as coisas

25449
16:48:57,916 --> 16:48:59,596
para qualquer aplicação que você é

25450
16:48:59,596 --> 16:49:02,240
Designing eu gostaria de recebê-lo em

25451
16:49:02,240 --> 16:49:04,160
Este novo capítulo onde vamos ser

25452
16:49:04,160 --> 16:49:06,796
aprender sobre lambda funções lambda

25453
16:49:06,796 --> 16:49:09,596
As funções são um mecanismo que temos em c

25454
16:49:09,596 --> 16:49:12,796
mais mais para configurar funções anônimas

25455
16:49:12,796 --> 16:49:15,040
uma vez que temos uma função anônima configurada

25456
16:49:15,040 --> 16:49:17,116
Podemos fazer todos os tipos de coisas loucas com

25457
16:49:17,116 --> 16:49:19,916
Por exemplo, podemos dar nomes

25458
16:49:19,916 --> 16:49:22,636
e codificá-los várias vezes ou nós podemos

25459
16:49:22,636 --> 16:49:25,040
até mesmo chamá-los diretamente sem sequer

25460
16:49:25,040 --> 16:49:27,360
dando-lhes um nome eu percebo que isso pode ser

25461
16:49:27,360 --> 16:49:29,520
Realmente enigmático, então vamos cabeçar

25462
16:49:29,520 --> 16:49:31,840
para a próxima palestra e ver como nós

25463
16:49:31,840 --> 16:49:35,596
pode declarar e usar nossas funções lambda

25464
16:49:35,596 --> 16:49:37,520
Vá em frente e termine aqui

25465
16:49:37,520 --> 16:49:39,520
e encontrar-me lá nesta palestra nós somos

25466
16:49:39,520 --> 16:49:42,000
Vamos ver como podemos declarar e usar

25467
16:49:42,000 --> 16:49:44,880
nossa função lambda e novamente lambda

25468
16:49:44,880 --> 16:49:47,680
As funções são um mecanismo que temos em c

25469
16:49:47,680 --> 16:49:51,040
mais mais para configurar funções anônimas

25470
16:49:51,040 --> 16:49:53,360
e uma função anônima é uma função

25471
16:49:53,360 --> 16:49:55,520
Sem um nome, vamos ver como nós

25472
16:49:55,520 --> 16:49:57,680
pode configurar uma função anônima

25473
16:49:57,680 --> 16:49:59,916
opcionalmente dar-lhe um nome e chamá-lo ou

25474
16:49:59,916 --> 16:50:02,000
Podemos até chamá-lo diretamente sem

25475
16:50:02,000 --> 16:50:04,320
dando isso um nome, vamos ver como podemos

25476
16:50:04,320 --> 16:50:06,636
fazer isso antes de falar sobre qualquer coisa

25477
16:50:06,636 --> 16:50:08,400
sobre as funções lambda que vamos

25478
16:50:08,400 --> 16:50:09,840
Primeiro para ver

25479
16:50:09,840 --> 16:50:12,880
a assinatura da função lambda e ali

25480
16:50:12,880 --> 16:50:15,116
é uma sintaxe especial que você tem que seguir

25481
16:50:15,116 --> 16:50:16,880
se você quiser configurar uma função lambda

25482
16:50:16,880 --> 16:50:18,796
em c plus mais a primeira coisa que você tem

25483
16:50:18,796 --> 16:50:21,200
colocar no lugar é suporte de ângulo como

25484
16:50:21,200 --> 16:50:24,160
Isto e isso vai ser a sua captura

25485
16:50:24,160 --> 16:50:26,480
Lista que não vamos mais falar

25486
16:50:26,480 --> 16:50:27,916
sobre isso nós vamos ter uma chance

25487
16:50:27,916 --> 16:50:30,560
para falar sobre isso em detalhes após o seu

25488
16:50:30,560 --> 16:50:32,480
lista de captura que vai sair em

25489
16:50:32,480 --> 16:50:35,040
Este par de suportes de ângulo que você está indo

25490
16:50:35,040 --> 16:50:37,596
para ter os parâmetros para seu lambda

25491
16:50:37,596 --> 16:50:39,916
funções e é aí que você pode passar

25492
16:50:39,916 --> 16:50:41,840
argumentos se você quiser chamar seu

25493
16:50:41,840 --> 16:50:43,916
função lambda depois que você está indo

25494
16:50:43,916 --> 16:50:46,956
para ter um tipo de retorno para o seu lambda

25495
16:50:46,956 --> 16:50:49,436
Função, mas você não tem que colocar isso

25496
16:50:49,436 --> 16:50:52,240
em explicitamente você pode viver isso e

25497
16:50:52,240 --> 16:50:53,916
o compilador vai deduzir seu

25498
16:50:53,916 --> 16:50:56,400
Tipo de retorno por si só

25499
16:50:56,400 --> 16:50:58,480
Depois de todas essas coisas você tem que colocar

25500
16:50:58,480 --> 16:51:01,916
em um par de chaves encaracoladas e dentro

25501
16:51:01,916 --> 16:51:03,916
Esses aparelhos encaracolados que vamos ter

25502
16:51:03,916 --> 16:51:06,400
nosso corpo de função e podemos fazer o que

25503
16:51:06,400 --> 16:51:09,040
Queremos que a nossa função lambda faça em

25504
16:51:09,040 --> 16:51:11,116
Este corpo de função aqui depois disso você

25505
16:51:11,116 --> 16:51:12,880
terá que lembrar de colocar o seu

25506
16:51:12,880 --> 16:51:15,680
ponto e-vírgula para fazer quaisquer declarações

25507
16:51:15,680 --> 16:51:17,040
Contêm

25508
16:51:17,040 --> 16:51:19,276
ao longo da função de ser válido e

25509
16:51:19,276 --> 16:51:21,360
Esta é a sintaxe que você tem que seguir

25510
16:51:21,360 --> 16:51:23,840
Aqui temos um exemplo simples, então temos

25511
16:51:23,840 --> 16:51:26,320
nossa função lambda nós queremos dizer olá

25512
16:51:26,320 --> 16:51:28,796
Para o console isso é o que temos em

25513
16:51:28,796 --> 16:51:30,796
O corpo da função lambda, mas

25514
16:51:30,796 --> 16:51:32,956
note que temos a nossa lista de captura

25515
16:51:32,956 --> 16:51:34,880
que vai ser

25516
16:51:34,880 --> 16:51:37,756
delimitadas por esses suportes de ângulo, nós

25517
16:51:37,756 --> 16:51:40,000
ter nossa lista de parâmetros que está indo

25518
16:51:40,000 --> 16:51:42,080
estar vazio neste momento, porque isso

25519
16:51:42,080 --> 16:51:43,756
lambda função não leva nenhum

25520
16:51:43,756 --> 16:51:46,560
parâmetro e nós temos o nosso corpo que é

25521
16:51:46,560 --> 16:51:48,400
indo para sair dentro

25522
16:51:48,400 --> 16:51:51,520
estes dois aparelhos encaracolados e depois disso

25523
16:51:51,520 --> 16:51:54,636
ter nosso ponto e ponto e vírgula para tornar este

25524
16:51:54,636 --> 16:51:57,520
c plus mais declaração se tentarmos e colocar

25525
16:51:57,520 --> 16:51:59,680
esta coisa em nosso c plus mais fonte

25526
16:51:59,680 --> 16:52:00,400
o código

25527
16:52:00,400 --> 16:52:02,400
Isso vai ser um lambda válido

25528
16:52:02,400 --> 16:52:04,880
função, mas não é realmente útil por

25529
16:52:04,880 --> 16:52:07,436
Agora porque não podemos chamá-lo de uma maneira que nós

25530
16:52:07,436 --> 16:52:09,596
ter que chamá-lo é dar-lhe um nome e

25531
16:52:09,596 --> 16:52:12,400
Podemos dar um nome atribuindo o nosso

25532
16:52:12,400 --> 16:52:15,276
função lambda para uma variável como nós

25533
16:52:15,276 --> 16:52:17,520
Veja aqui uma vez que temos o nosso Lambda

25534
16:52:17,520 --> 16:52:20,320
Função declarada assim toda essa

25535
16:52:20,320 --> 16:52:22,720
A coisa vai ser a nossa função lambda

25536
16:52:22,720 --> 16:52:25,520
tipo que podemos tomar isso e atribuir isso a

25537
16:52:25,520 --> 16:52:28,000
uma variável que vai deduzir o

25538
16:52:28,000 --> 16:52:28,880
Tipo de tipo

25539
16:52:28,880 --> 16:52:31,200
usando a dedução do tipo automático aqui é

25540
16:52:31,200 --> 16:52:32,720
O que estamos fazendo

25541
16:52:32,720 --> 16:52:35,276
Uma vez que esta coisa tem um nome, então nós podemos

25542
16:52:35,276 --> 16:52:38,560
Chamá-lo com a sintaxe que temos aqui e

25543
16:52:38,560 --> 16:52:40,720
Se executarmos este código agora ele vai

25544
16:52:40,720 --> 16:52:43,276
print hello mundo para o console i

25545
16:52:43,276 --> 16:52:45,360
Percebe que essa sintaxe pode ser realmente

25546
16:52:45,360 --> 16:52:48,880
enigmática, mas se você tentar se lembrar disso

25547
16:52:48,880 --> 16:52:50,480
Você vai encontrar aquele lambda

25548
16:52:50,480 --> 16:52:53,040
As funções são muito legais e depois em

25549
16:52:53,040 --> 16:52:54,796
O curso vamos ver que eles realmente

25550
16:52:54,796 --> 16:52:57,520
tornar muitas coisas mais fáceis em c plus

25551
16:52:57,520 --> 16:53:00,160
Além disso, tente lembrar a sintaxe aqui

25552
16:53:00,160 --> 16:53:02,160
e tudo vai fluir de

25553
16:53:02,160 --> 16:53:04,796
Aqui novamente a sintaxe é ter a

25554
16:53:04,796 --> 16:53:06,796
lista de captura que será

25555
16:53:06,796 --> 16:53:08,880
A primeira coisa a segunda coisa vai

25556
16:53:08,880 --> 16:53:11,200
Os parâmetros a terceira coisa é

25557
16:53:11,200 --> 16:53:13,040
Vai ser o tipo de retorno que é

25558
16:53:13,040 --> 16:53:14,720
opcional, você pode deixar isso de fora e

25559
16:53:14,720 --> 16:53:16,880
O compilador vai deduzir isso e

25560
16:53:16,880 --> 16:53:18,240
Depois disso você vai ter o seu

25561
16:53:18,240 --> 16:53:21,756
par de chaves encaracoladas e o corpo do nosso

25562
16:53:21,756 --> 16:53:24,240
A função lambda vai sair dentro

25563
16:53:24,240 --> 16:53:26,720
Estes aparelhos encaracolados esta é a sintaxe

25564
16:53:26,720 --> 16:53:28,560
Você precisa se lembrar bem que vimos

25565
16:53:28,560 --> 16:53:30,956
que podemos dar um nome ao nosso lambda

25566
16:53:30,956 --> 16:53:33,436
função e chamá-lo, mas é também

25567
16:53:33,436 --> 16:53:36,000
Possível chamar a função lambda

25568
16:53:36,000 --> 16:53:39,200
diretamente sem dar um nome e nós

25569
16:53:39,200 --> 16:53:42,240
fazer isso anexando um par de encaracolados

25570
16:53:42,240 --> 16:53:45,276
chaves para a definição da função lambda

25571
16:53:45,276 --> 16:53:47,200
Aqui, então temos uma função lambda

25572
16:53:47,200 --> 16:53:49,200
ter nossas chaves encaracoladas e nós temos o nosso

25573
16:53:49,200 --> 16:53:52,320
lista de parâmetros temos nosso corpo aqui e

25574
16:53:52,320 --> 16:53:55,520
após o fechamento curly brace we's

25575
16:53:55,520 --> 16:53:57,756
adicionar um par de parênteses a

25576
16:53:57,756 --> 16:54:00,080
chamar esta função lambda e porque

25577
16:54:00,080 --> 16:54:02,480
esta função lambda não leva nenhum parâmetro

25578
16:54:02,480 --> 16:54:04,480
nós não vamos colocar nenhum argumento

25579
16:54:04,480 --> 16:54:06,796
dentro de nossos parênteses aqui e isso é

25580
16:54:06,796 --> 16:54:09,276
Vou chamar a nossa função lambda não

25581
16:54:09,276 --> 16:54:11,116
Preocupe-se se você achar isso confuso, estamos

25582
16:54:11,116 --> 16:54:12,880
indo para a cabeça para o código de estúdio visual

25583
16:54:12,880 --> 16:54:14,720
Em um minuto e tudo isso vai

25584
16:54:14,720 --> 16:54:17,200
fazer sentido ok até agora não temos realmente

25585
16:54:17,200 --> 16:54:19,916
visto que podemos passar parâmetros para o nosso

25586
16:54:19,916 --> 16:54:22,320
função lambda aqui é um exemplo simples

25587
16:54:22,320 --> 16:54:24,880
que leva parâmetros este é um lambda

25588
16:54:24,880 --> 16:54:27,116
função porque segue a sintaxe

25589
16:54:27,116 --> 16:54:29,276
para funções lambda que temos

25590
16:54:29,276 --> 16:54:31,756
nossa lista de captura temos nosso parâmetro

25591
16:54:31,756 --> 16:54:34,560
list nós temos nossos cintas encaracolados e o

25592
16:54:34,560 --> 16:54:36,720
O corpo vai viver dentro desses caras

25593
16:54:36,720 --> 16:54:38,956
e estamos chamando essa função lambda

25594
16:54:38,956 --> 16:54:41,756
diretamente com este parâmetro listar o

25595
16:54:41,756 --> 16:54:43,200
função lambda vai levar dois

25596
16:54:43,200 --> 16:54:45,756
parâmetros de tipo duplo que vamos

25597
16:54:45,756 --> 16:54:48,400
imprimir a soma destes dois números

25598
16:54:48,400 --> 16:54:50,080
E que vamos chamar isso

25599
16:54:50,080 --> 16:54:52,080
função lambda notar diretamente que nós

25600
16:54:52,080 --> 16:54:55,040
estão passando em nossos argumentos

25601
16:54:55,040 --> 16:54:56,000
Como

25602
16:54:56,000 --> 16:54:57,596
o dobro

25603
16:54:57,596 --> 16:55:00,160
Literais estão bem, é assim que você pode configurar

25604
16:55:00,160 --> 16:55:02,796
uma função lambda que leva parâmetros

25605
16:55:02,796 --> 16:55:04,796
e chamá-lo diretamente de outra coisa nós

25606
16:55:04,796 --> 16:55:07,436
pode fazer é fazer a função lambda

25607
16:55:07,436 --> 16:55:09,436
Retorne algo e isso é realmente

25608
16:55:09,436 --> 16:55:11,116
Simples vamos montar o lambda

25609
16:55:11,116 --> 16:55:12,880
funcionar assim, então vai demorar

25610
16:55:12,880 --> 16:55:15,200
dois parâmetros a e b

25611
16:55:15,200 --> 16:55:17,596
e aqui você vê que estamos retornando a

25612
16:55:17,596 --> 16:55:20,000
mais b e nós podemos fazer isso o lambda

25613
16:55:20,000 --> 16:55:21,840
A função agora vai voltar

25614
16:55:21,840 --> 16:55:24,636
Algo e toda essa coisa que temos

25615
16:55:24,636 --> 16:55:28,080
Aqui vai ser uma expressão lambda

25616
16:55:28,080 --> 16:55:29,596
A função lambda vai ser

25617
16:55:29,596 --> 16:55:31,916
Chamou-se que vai devolver alguma coisa

25618
16:55:31,916 --> 16:55:34,240
O que a função lambda retorna é

25619
16:55:34,240 --> 16:55:36,480
vai ser atribuído a este resultado

25620
16:55:36,480 --> 16:55:38,636
variável aqui e se nós a imprimirmos nós somos

25621
16:55:38,636 --> 16:55:40,796
Vou obter a soma de tudo o que passar

25622
16:55:40,796 --> 16:55:42,956
Aqui impresso no console e

25623
16:55:42,956 --> 16:55:45,116
você vai vê-lo impresso para fora

25624
16:55:45,116 --> 16:55:47,680
O terminal também é possível colocar

25625
16:55:47,680 --> 16:55:50,240
sua função lambda diretamente em um

25626
16:55:50,240 --> 16:55:52,880
declaração de saída eu percebo que isso pode ser

25627
16:55:52,880 --> 16:55:56,000
Realmente confuso, mas por favor, olhe para isso

25628
16:55:56,000 --> 16:55:59,200
A função lambda inteira é a mesma aqui

25629
16:55:59,200 --> 16:56:02,160
como um único valor, porque este é um

25630
16:56:02,160 --> 16:56:04,240
função lambda que vai voltar

25631
16:56:04,240 --> 16:56:06,720
Algo e aquilo que é devolvido por isso

25632
16:56:06,720 --> 16:56:09,040
A função lambda vai ser impressa

25633
16:56:09,040 --> 16:56:11,436
Como o nosso resultado aqui

25634
16:56:11,436 --> 16:56:14,160
novamente eu percebo que isso pode ser confuso para

25635
16:56:14,160 --> 16:56:16,400
Muitos de vocês vamos cabeçar

25636
16:56:16,400 --> 16:56:18,240
Mais para código de estúdio visual em um minuto

25637
16:56:18,240 --> 16:56:19,840
e nós vamos ver isso e você está

25638
16:56:19,840 --> 16:56:21,680
Vou realmente entender ok o último

25639
16:56:21,680 --> 16:56:23,276
O que vamos olhar é que nós

25640
16:56:23,276 --> 16:56:26,636
pode especificar um tipo de retorno para o nosso lambda

25641
16:56:26,636 --> 16:56:29,436
A função e a sintaxe para fazer isso é

25642
16:56:29,436 --> 16:56:30,956
fazer um traço

25643
16:56:30,956 --> 16:56:34,160
um símbolo maior do que o símbolo e colocar o seu tipo

25644
16:56:34,160 --> 16:56:36,956
depois disso e quando você fizer isso agora

25645
16:56:36,956 --> 16:56:39,200
A função lambda vai ser forçada a

25646
16:56:39,200 --> 16:56:42,796
devolver o tipo duplo mesmo se você passar

25647
16:56:42,796 --> 16:56:45,360
para parâmetros que não são duplos

25648
16:56:45,360 --> 16:56:47,436
tipo, vamos adicioná-los e

25649
16:56:47,436 --> 16:56:49,680
O tipo de retorno será implicitamente

25650
16:56:49,680 --> 16:56:51,680
convertido em duplo e é isso que

25651
16:56:51,680 --> 16:56:53,360
Vamos voltar e podemos imprimir

25652
16:56:53,360 --> 16:56:55,596
Isso no console e nós vamos

25653
16:56:55,596 --> 16:56:57,840
Veja um exemplo disso em um minuto em que

25654
16:56:57,840 --> 16:57:00,560
nós atingimos o código do estúdio visual na verdade

25655
16:57:00,560 --> 16:57:02,560
é realmente tudo que eu tinha para compartilhar com você

25656
16:57:02,560 --> 16:57:04,956
Os slides eu percebi muitos destes

25657
16:57:04,956 --> 16:57:07,520
As coisas podem ser confusas que vamos

25658
16:57:07,520 --> 16:57:09,840
cabeça para código de estúdio visual e jogar

25659
16:57:09,840 --> 16:57:12,160
com essas coisas passo a passo e eu sou

25660
16:57:12,160 --> 16:57:14,000
Com certeza você vai entender aqui nós

25661
16:57:14,000 --> 16:57:17,116
estão em nosso diretório de trabalho o atual

25662
16:57:17,116 --> 16:57:19,680
O projeto está declarando e usando lambda

25663
16:57:19,680 --> 16:57:21,680
funções que vamos pegar o nosso

25664
16:57:21,680 --> 16:57:24,160
template files e colocá-los no lugar

25665
16:57:24,160 --> 16:57:26,240
Vamos fazer isso e nós vamos pegar

25666
16:57:26,240 --> 16:57:29,116
nossa pasta aqui e arrastar e soltá-lo em

25667
16:57:29,116 --> 16:57:30,880
código visual do estúdio e isso vai

25668
16:57:30,880 --> 16:57:33,040
Abri-lo é aberto aqui que temos o nosso

25669
16:57:33,040 --> 16:57:36,000
arquivo cpp principal aberto, podemos fechar o

25670
16:57:36,000 --> 16:57:38,320
Pane esquerdo aqui porque nós não queremos

25671
16:57:38,320 --> 16:57:40,480
mais e podemos limpar nossa função

25672
16:57:40,480 --> 16:57:42,320
Aqui e a primeira coisa que vamos

25673
16:57:42,320 --> 16:57:45,276
fazer é colocar na sintaxe para um lambda

25674
16:57:45,276 --> 16:57:48,240
Funcionar aqui e usá-lo como uma referência

25675
16:57:48,240 --> 16:57:50,160
quando aprendemos sobre isso eu acho que isso é

25676
16:57:50,160 --> 16:57:52,320
Vou fazer as coisas um pouco mais fácil

25677
16:57:52,320 --> 16:57:54,080
A primeira coisa que queremos fazer é

25678
16:57:54,080 --> 16:57:56,560
Declarar uma função lambda e a primeira

25679
16:57:56,560 --> 16:57:58,400
O que precisamos colocar é uma captura

25680
16:57:58,400 --> 16:58:00,796
listar uma lista de capturas vai estar em

25681
16:58:00,796 --> 16:58:03,200
globo neste suporte de ângulo, então este é

25682
16:58:03,200 --> 16:58:05,680
nossa lista de captura vazia e depois disso

25683
16:58:05,680 --> 16:58:07,756
vamos colocar uma lista de parâmetros

25684
16:58:07,756 --> 16:58:10,000
que vai deixar dentro disto

25685
16:58:10,000 --> 16:58:12,240
Parêntese aqui depois disso estamos indo

25686
16:58:12,240 --> 16:58:13,520
para colocar em

25687
16:58:13,520 --> 16:58:15,756
um tipo de retorno opcional para agora

25688
16:58:15,756 --> 16:58:17,520
Vou ignorar isso e depois disso

25689
16:58:17,520 --> 16:58:20,000
nós vamos colocar em nosso par de encaracolados

25690
16:58:20,000 --> 16:58:22,956
chaves e dentro deste par de encaracolados

25691
16:58:22,956 --> 16:58:26,320
Os aparelhos são onde o corpo de nosso Lambda

25692
16:58:26,320 --> 16:58:28,480
A função vai sair tão dentro

25693
16:58:28,480 --> 16:58:30,240
Aqui podemos fazer o que quisermos no

25694
16:58:30,240 --> 16:58:32,240
corpo desta função lambda, por exemplo

25695
16:58:32,240 --> 16:58:35,040
Podemos dizer olá mundo que é

25696
16:58:35,040 --> 16:58:37,276
A coisa lógica a fazer neste ponto, então

25697
16:58:37,276 --> 16:58:39,436
nós vamos dizer olá mundo aqui e

25698
16:58:39,436 --> 16:58:41,276
nós vamos colocar em nossa nova linha

25699
16:58:41,276 --> 16:58:44,320
personagem com endl OK agora temos um

25700
16:58:44,320 --> 16:58:47,116
função lambda declarada, mas temos que

25701
16:58:47,116 --> 16:58:50,160
colocar em um ponto-e-vírgula de fechamento porque isso

25702
16:58:50,160 --> 16:58:52,796
é um c plus declaração OK agora nós

25703
16:58:52,796 --> 16:58:55,436
ter a nossa função lambda declarada e

25704
16:58:55,436 --> 16:58:58,000
isso é válido c plus mais código se formos

25705
16:58:58,000 --> 16:58:59,596
Tentando compilar este programa você é

25706
16:58:59,596 --> 16:59:01,520
Vou ver que vai compilar

25707
16:59:01,520 --> 16:59:04,240
mundo de cabo fino acabado com sucesso

25708
16:59:04,240 --> 16:59:06,400
E se tentarmos executá-lo, não vai

25709
16:59:06,400 --> 16:59:09,596
para fazer uma coisa porque estamos declarando

25710
16:59:09,596 --> 16:59:11,840
A função lambda aqui mas nós não somos

25711
16:59:11,840 --> 16:59:14,400
chamando-o para levá-lo a fazer as coisas

25712
16:59:14,400 --> 16:59:16,400
então vamos trazer um terminal e mostrar

25713
16:59:16,400 --> 16:59:18,720
você que se executarmos este programa é

25714
16:59:18,720 --> 16:59:21,200
Não vou fazer nada, então vamos fazer

25715
16:59:21,200 --> 16:59:23,276
clear e run galo que você está indo para

25716
16:59:23,276 --> 16:59:24,636
Veja que não vai imprimir

25717
16:59:24,636 --> 16:59:27,116
Qualquer coisa e nós podemos até mesmo ir para baixo aqui

25718
16:59:27,116 --> 16:59:30,880
e colocar em uma declaração de encerramento stdc out

25719
16:59:30,880 --> 16:59:33,116
dizendo isso para mim que estamos batendo

25720
16:59:33,116 --> 16:59:35,116
O fim da função aqui sem

25721
16:59:35,116 --> 16:59:38,000
fazendo qualquer coisa assim se votarmos novamente o

25722
16:59:38,000 --> 16:59:40,240
O voto vai ser bom, podemos limpar

25723
16:59:40,240 --> 16:59:42,480
e nós vamos correr o galo que você vê

25724
16:59:42,480 --> 16:59:44,560
Estamos imprimindo, estamos batendo o

25725
16:59:44,560 --> 16:59:46,880
fim da função aqui e não somos

25726
16:59:46,880 --> 16:59:49,916
ver o próprio mundo, então essa função aqui

25727
16:59:49,916 --> 16:59:52,880
ou esta função lambda aqui para ser exato

25728
16:59:52,880 --> 16:59:55,360
Não é ser chamado de uma maneira que temos que

25729
16:59:55,360 --> 16:59:57,436
Chamá-lo é dar-lhe um nome

25730
16:59:57,436 --> 16:59:59,436
e vimos isso para dar um nome

25731
16:59:59,436 --> 17:00:02,480
Temos que atribuir o Lambda inteiro

25732
17:00:02,480 --> 17:00:04,636
coisa de função que temos aqui para a

25733
17:00:04,636 --> 17:00:06,480
variável e vamos usar o auto

25734
17:00:06,480 --> 17:00:08,240
tipo de dedução aqui, então vamos

25735
17:00:08,240 --> 17:00:10,956
Diga auto func e vamos atribuir

25736
17:00:10,956 --> 17:00:14,320
nossa função lambda aqui para isso

25737
17:00:14,320 --> 17:00:16,080
variável e isso vai ser

25738
17:00:16,080 --> 17:00:18,880
basicamente um punho que temos em nosso

25739
17:00:18,880 --> 17:00:21,520
programa aqui para a função lambda e

25740
17:00:21,520 --> 17:00:24,000
Podemos usar essa alça para fazer as coisas com

25741
17:00:24,000 --> 17:00:26,320
A função lambda mas agora eu quero

25742
17:00:26,320 --> 17:00:28,160
você vê isso mesmo se nós corremos o

25743
17:00:28,160 --> 17:00:31,040
Programa agora não vai fazer

25744
17:00:31,040 --> 17:00:33,276
qualquer coisa porque ainda não estamos chamando

25745
17:00:33,276 --> 17:00:35,596
A função lambda aqui vamos mostrar-lhe

25746
17:00:35,596 --> 17:00:37,520
que estamos indo para o mundo novamente e

25747
17:00:37,520 --> 17:00:39,360
O mundo vai ser bom, não há problema nós

25748
17:00:39,360 --> 17:00:42,240
pode limpar e correr galo ainda não

25749
17:00:42,240 --> 17:00:44,000
Olá mundo porque não estamos chamando

25750
17:00:44,000 --> 17:00:46,636
nossa função lambda para chamar o nosso lambda

25751
17:00:46,636 --> 17:00:49,436
função temos que usar nosso punho aqui

25752
17:00:49,436 --> 17:00:53,200
que é esta variável e usar regular

25753
17:00:53,200 --> 17:00:55,916
Função chamada sintaxe para que possamos ir para baixo

25754
17:00:55,916 --> 17:00:58,560
aqui e dizer func e podemos colocar em nosso

25755
17:00:58,560 --> 17:01:00,956
Parêntese, não estamos colocando nenhum

25756
17:01:00,956 --> 17:01:02,956
parâmetro porque este lambda aqui

25757
17:01:02,956 --> 17:01:06,160
não toma parâmetros e agora se

25758
17:01:06,160 --> 17:01:08,240
nós executamos este programa, vai dizer

25759
17:01:08,240 --> 17:01:10,480
Olá mundo porque esta linha aqui é

25760
17:01:10,480 --> 17:01:13,520
Vou chamar essa função lambda, vamos

25761
17:01:13,520 --> 17:01:15,436
Aparar e ver isso

25762
17:01:15,436 --> 17:01:17,840
nós vamos usar o gcc para construir

25763
17:01:17,840 --> 17:01:21,276
então agora, se limparmos e corrermos o galo, estamos

25764
17:01:21,276 --> 17:01:23,276
indo ver olá mundo que podemos chamar

25765
17:01:23,276 --> 17:01:25,276
esta função várias vezes porque nós

25766
17:01:25,276 --> 17:01:27,436
ter uma alça para ele o punho está indo

25767
17:01:27,436 --> 17:01:29,200
Para ser válido

25768
17:01:29,200 --> 17:01:30,880
em todo o âmbito do tema

25769
17:01:30,880 --> 17:01:32,956
Função aqui, então nós vamos descer

25770
17:01:32,956 --> 17:01:35,520
e chame isso de novo e se construirmos nós estamos

25771
17:01:35,520 --> 17:01:38,000
indo para construir com gcc o mundo é

25772
17:01:38,000 --> 17:01:40,956
Bom podemos limpar e correr galo, estamos

25773
17:01:40,956 --> 17:01:43,360
Vou dizer olá mundo duas vezes porque

25774
17:01:43,360 --> 17:01:46,636
Estamos chamando nossa função lambda duas vezes

25775
17:01:46,636 --> 17:01:48,636
Esta é uma maneira que temos que chamar a nossa

25776
17:01:48,636 --> 17:01:50,320
função lambda aqui

25777
17:01:50,320 --> 17:01:52,400
Vamos comentar isso

25778
17:01:52,400 --> 17:01:54,080
Porque nós vamos ver alguns outros

25779
17:01:54,080 --> 17:01:56,560
coisas e no topo aqui o que éramos

25780
17:01:56,560 --> 17:01:58,956
fazer é declarar em torno da função

25781
17:01:58,956 --> 17:02:01,200
e chamá-lo através de um agora que estamos indo

25782
17:02:01,200 --> 17:02:03,840
para descer configurar uma função lambda e

25783
17:02:03,840 --> 17:02:06,080
chame-o diretamente sem dar uma

25784
17:02:06,080 --> 17:02:08,400
nome porque isso também é uma possibilidade

25785
17:02:08,400 --> 17:02:10,560
em c plus plus para isso nós vamos

25786
17:02:10,560 --> 17:02:12,560
agarrar a nossa função lambda aqui e nós estamos

25787
17:02:12,560 --> 17:02:14,560
Vou copiá-lo e vamos dizer

25788
17:02:14,560 --> 17:02:16,880
Declarar uma função lambda e chamá-lo

25789
17:02:16,880 --> 17:02:18,880
direto e a sintaxe para fazer isso é

25790
17:02:18,880 --> 17:02:20,240
Realmente simples

25791
17:02:20,240 --> 17:02:22,240
você configura sua função lambda como nós

25792
17:02:22,240 --> 17:02:24,400
Tenho visto antes de ver que este é o nosso

25793
17:02:24,400 --> 17:02:26,720
declaração de função lambda aqui, mas

25794
17:02:26,720 --> 17:02:28,636
você vai para o fechamento encaracolado

25795
17:02:28,636 --> 17:02:31,040
brace e adicionar um par

25796
17:02:31,040 --> 17:02:33,840
de parênteses isto vai declarar

25797
17:02:33,840 --> 17:02:36,880
a função lambda e chamá-lo diretamente

25798
17:02:36,880 --> 17:02:39,116
notar que não temos um manuseamento para

25799
17:02:39,116 --> 17:02:41,596
essa função lambda, então se você fizer coisas

25800
17:02:41,596 --> 17:02:44,160
Como isso você terá apenas uma chance

25801
17:02:44,160 --> 17:02:46,000
para chamar a função lambda para que nós sejamos

25802
17:02:46,000 --> 17:02:48,400
vou dizer olá do mundo uma vez porque nós

25803
17:02:48,400 --> 17:02:50,796
estão declarando a função lambda e

25804
17:02:50,796 --> 17:02:53,596
chamando-o diretamente aqui e depois disso

25805
17:02:53,596 --> 17:02:55,276
nós vamos dizer feito porque nós estamos

25806
17:02:55,276 --> 17:02:57,680
Vai chegar ao fim do principal

25807
17:02:57,680 --> 17:02:59,040
A função aqui

25808
17:02:59,040 --> 17:03:00,796
Vamos construir o programa e mostrar a você

25809
17:03:00,796 --> 17:03:03,040
que vamos construir com gcc como

25810
17:03:03,040 --> 17:03:05,596
Fazemos sempre que vamos limpar

25811
17:03:05,596 --> 17:03:07,596
e correr o galo isto vai dizer

25812
17:03:07,596 --> 17:03:09,756
Olá mundo e nós vamos acabar

25813
17:03:09,756 --> 17:03:12,080
aqui porque estamos chamando este lambda

25814
17:03:12,080 --> 17:03:15,520
A função mais uma vez note que agora nós

25815
17:03:15,520 --> 17:03:17,276
Não tem um cabo para este lambda

25816
17:03:17,276 --> 17:03:19,916
função, então nós realmente temos uma chance de

25817
17:03:19,916 --> 17:03:22,480
chamar isso e você vai fazer isso se você

25818
17:03:22,480 --> 17:03:25,040
Só quero configurar alguma função que

25819
17:03:25,040 --> 17:03:27,436
Você quer ligar diretamente e você não

25820
17:03:27,436 --> 17:03:29,840
se preocupa em chamá-lo nunca mais em seu

25821
17:03:29,840 --> 17:03:32,080
c plus mais aplicação e estamos indo

25822
17:03:32,080 --> 17:03:34,720
para ver que temos muitos tipos de

25823
17:03:34,720 --> 17:03:37,200
problemas em que queremos fazer esses tipos

25824
17:03:37,200 --> 17:03:38,240
das coisas

25825
17:03:38,240 --> 17:03:39,840
Tudo bem agora que você viu isso

25826
17:03:39,840 --> 17:03:42,080
A próxima coisa que eu quero mostrar a você é como

25827
17:03:42,080 --> 17:03:44,160
configurar uma função lambda que leva

25828
17:03:44,160 --> 17:03:46,560
Parâmetros e vamos comentar

25829
17:03:46,560 --> 17:03:48,636
fora o que temos em cima aqui porque nós

25830
17:03:48,636 --> 17:03:51,916
não quero saída de ruído em nosso terminal

25831
17:03:51,916 --> 17:03:53,596
E nós vamos pegar esse Lambda

25832
17:03:53,596 --> 17:03:56,160
Funciona e adaptá-lo

25833
17:03:56,160 --> 17:03:58,160
Então vamos copiá-lo, vamos descer

25834
17:03:58,160 --> 17:04:00,720
aqui e colocá-lo e nós queremos passar

25835
17:04:00,720 --> 17:04:02,796
dois parâmetros agora vamos passar em duplo

25836
17:04:02,796 --> 17:04:04,480
parâmetros que vamos passar em duplo

25837
17:04:04,480 --> 17:04:07,360
a e duplo d você pode fazer isso

25838
17:04:07,360 --> 17:04:10,560
e dentro da função lambda nós podemos

25839
17:04:10,560 --> 17:04:13,596
imprimir a soma dessas duas variáveis, então

25840
17:04:13,596 --> 17:04:16,240
nós vamos dizer um plus b, por exemplo

25841
17:04:16,240 --> 17:04:18,240
e nós vamos imprimir o que quer que seja

25842
17:04:18,240 --> 17:04:21,520
o resultado de um mais b vamos fazer isso e

25843
17:04:21,520 --> 17:04:22,880
Depois que fazemos isso, você vai ver

25844
17:04:22,880 --> 17:04:26,000
que obtemos um erro de compilador porque agora

25845
17:04:26,000 --> 17:04:29,596
nossa função lambda está tomando parâmetros

25846
17:04:29,596 --> 17:04:32,240
Mas estamos chamando isso com um vazio

25847
17:04:32,240 --> 17:04:34,080
Lista de parâmetros

25848
17:04:34,080 --> 17:04:36,560
Então, precisamos dar algo a somar

25849
17:04:36,560 --> 17:04:40,720
para dar 10.0, por exemplo, e um

25850
17:04:40,720 --> 17:04:43,360
5.0 e ver o que temos e depois disso

25851
17:04:43,360 --> 17:04:45,596
Precisamos colocar em nosso ponto e vírgula porque

25852
17:04:45,596 --> 17:04:48,636
Esta é uma declaração z plus plus e qualquer

25853
17:04:48,636 --> 17:04:51,436
c plus mais declaração precisa terminar com

25854
17:04:51,436 --> 17:04:54,160
a semicolon agora tenta pensar sobre o que

25855
17:04:54,160 --> 17:04:56,796
Estamos fazendo aqui estamos montando um

25856
17:04:56,796 --> 17:04:59,040
função lambda bem, vai acabar

25857
17:04:59,040 --> 17:05:00,720
Neste encerramento

25858
17:05:00,720 --> 17:05:03,276
curly brace e esta função lambda é

25859
17:05:03,276 --> 17:05:05,436
Vou tomar dois parâmetros de duplo

25860
17:05:05,436 --> 17:05:06,320
Tipo de tipo

25861
17:05:06,320 --> 17:05:08,320
E dentro da função lambda nós somos

25862
17:05:08,320 --> 17:05:10,320
Vou imprimir tudo o que é a soma

25863
17:05:10,320 --> 17:05:12,880
destes dois parâmetros que somos

25864
17:05:12,880 --> 17:05:14,320
A tomar aqui

25865
17:05:14,320 --> 17:05:16,080
Depois disso estamos chamando o nosso lambda

25866
17:05:16,080 --> 17:05:20,720
função com duas variáveis 10.0 e 5.0

25867
17:05:20,720 --> 17:05:24,000
ou devo dizer dois duplos literals

25868
17:05:24,000 --> 17:05:25,680
Isso é o que estamos chamando de lambda

25869
17:05:25,680 --> 17:05:28,560
Funcionar com e agora se o programa

25870
17:05:28,560 --> 17:05:30,796
corre a função lambda vai ser

25871
17:05:30,796 --> 17:05:32,636
Liguei uma vez e nós vamos imprimir

25872
17:05:32,636 --> 17:05:35,276
Seja qual for a soma destes dois números

25873
17:05:35,276 --> 17:05:37,916
E isso vai ser 15. vamos construir

25874
17:05:37,916 --> 17:05:40,480
Então vamos construir com gcc

25875
17:05:40,480 --> 17:05:42,796
O mundo é bom que podemos limpar e correr

25876
17:05:42,796 --> 17:05:45,360
Galo vamos ver um plus b é

25877
17:05:45,360 --> 17:05:47,520
15. estamos chamando uma função lambda

25878
17:05:47,520 --> 17:05:50,080
Aqui se colocarmos um 50 aqui, por exemplo

25879
17:05:50,080 --> 17:05:52,080
Vamos tirar 60 impressões digitais

25880
17:05:52,080 --> 17:05:54,320
Porque isso vai ser a nossa soma ok

25881
17:05:54,320 --> 17:05:56,480
Vamos fervê-lo novamente e ver essa impressão

25882
17:05:56,480 --> 17:05:58,560
para baixo se nós executarmos galo nós estamos indo para

25883
17:05:58,560 --> 17:06:01,680
Veja 60 porque essa é a soma de 10 e

25884
17:06:01,680 --> 17:06:02,880
50 aqui

25885
17:06:02,880 --> 17:06:05,360
Outra coisa que podemos fazer é realmente

25886
17:06:05,360 --> 17:06:07,360
Não chamar a função lambda diretamente

25887
17:06:07,360 --> 17:06:09,360
aqui nós podemos realmente comentar isso I

25888
17:06:09,360 --> 17:06:11,116
Não quero tirar isso porque você

25889
17:06:11,116 --> 17:06:13,756
pode querer usar isso como uma referência, então

25890
17:06:13,756 --> 17:06:15,756
nós vamos comentar isso e definir

25891
17:06:15,756 --> 17:06:17,276
Para um outro exemplo

25892
17:06:17,276 --> 17:06:19,276
que vai dar ao nosso lambda

25893
17:06:19,276 --> 17:06:21,916
função e então teremos um punho

25894
17:06:21,916 --> 17:06:23,680
para a função lambda e podemos chamar

25895
17:06:23,680 --> 17:06:25,360
ele várias vezes

25896
17:06:25,360 --> 17:06:28,240
então vamos fazer a chamada que estamos fazendo

25897
17:06:28,240 --> 17:06:30,000
Aqui e vamos atribuir o nosso

25898
17:06:30,000 --> 17:06:32,560
função lambda para uma variável que somos

25899
17:06:32,560 --> 17:06:34,956
vamos dizer auto func um que podemos chamar

25900
17:06:34,956 --> 17:06:38,080
Este func não tem problema e agora

25901
17:06:38,080 --> 17:06:39,756
Podemos chamar essa função lambda

25902
17:06:39,756 --> 17:06:42,480
Várias vezes, por exemplo, podemos dizer

25903
17:06:42,480 --> 17:06:46,320
funk um e passe em 10 e 20 OK e

25904
17:06:46,320 --> 17:06:50,080
Podemos dizer funk um e passar em cinco

25905
17:06:50,080 --> 17:06:52,480
E sete por que não

25906
17:06:52,480 --> 17:06:54,400
Se executarmos este programa, ele vai

25907
17:06:54,400 --> 17:06:56,796
imprimir a soma de 10 e 20 e é

25908
17:06:56,796 --> 17:06:59,360
Vou imprimir a soma de cinco e sete

25909
17:06:59,360 --> 17:07:01,116
e vai estar chamando isso

25910
17:07:01,116 --> 17:07:03,680
função lambda várias vezes espero

25911
17:07:03,680 --> 17:07:05,840
você pode ver que se você quer uma chance de

25912
17:07:05,840 --> 17:07:08,560
chamar a sua função lambda várias vezes

25913
17:07:08,560 --> 17:07:10,796
você vai precisar dar-lhe uma alça como

25914
17:07:10,796 --> 17:07:12,880
Estamos fazendo aqui e então você pode usar

25915
17:07:12,880 --> 17:07:14,160
essa alça

25916
17:07:14,160 --> 17:07:16,400
várias vezes e chamar o seu lambda

25917
17:07:16,400 --> 17:07:18,880
Função, no entanto, muitas vezes você quer, então

25918
17:07:18,880 --> 17:07:21,360
Vamos construir este programa e ver o que nós

25919
17:07:21,360 --> 17:07:23,596
entrar no console

25920
17:07:23,596 --> 17:07:26,320
Eu vou limpar e correr o galo

25921
17:07:26,320 --> 17:07:28,956
Agora nós vamos ver um plus b é 30

25922
17:07:28,956 --> 17:07:31,520
como resultado desta chamada aqui e nós somos

25923
17:07:31,520 --> 17:07:34,160
Vou ver um plus b é 12

25924
17:07:34,160 --> 17:07:36,956
como resultado desta chamada aqui aviso

25925
17:07:36,956 --> 17:07:40,400
que estamos passando por um inteiro literais

25926
17:07:40,400 --> 17:07:42,480
assim, o compilador vai inserir um

25927
17:07:42,480 --> 17:07:45,520
Conversão implícita de e para o dobro

25928
17:07:45,520 --> 17:07:47,520
Porque a nossa função lambda aqui é

25929
17:07:47,520 --> 17:07:49,756
tomando o tipo duplo que você realmente precisa ser

25930
17:07:49,756 --> 17:07:52,720
Conscientes dessas conversões implícitas e

25931
17:07:52,720 --> 17:07:54,560
Certifique-se de que eles estão trabalhando para o seu

25932
17:07:54,560 --> 17:07:56,796
vantagem se eles estão trabalhando contra

25933
17:07:56,796 --> 17:07:58,480
Você está tentando encontrar uma maneira de fazer seu

25934
17:07:58,480 --> 17:08:01,840
O código funciona exatamente como você quer porque

25935
17:08:01,840 --> 17:08:03,680
Estamos aprendendo sobre tudo isso legal

25936
17:08:03,680 --> 17:08:06,080
truques em c plus plus você vai ser

25937
17:08:06,080 --> 17:08:08,240
usá-los em sua vantagem ok

25938
17:08:08,240 --> 17:08:10,080
Espero que agora você saiba como definir

25939
17:08:10,080 --> 17:08:11,916
uma função lambda que leva

25940
17:08:11,916 --> 17:08:14,080
Parâmetros vamos descer e

25941
17:08:14,080 --> 17:08:16,636
Comentar isso porque agora queremos

25942
17:08:16,636 --> 17:08:19,116
Veja como podemos devolver algo de um

25943
17:08:19,116 --> 17:08:20,880
função lambda e nós vamos ser

25944
17:08:20,880 --> 17:08:22,796
usando a mesma função lambda aqui, então

25945
17:08:22,796 --> 17:08:24,400
Vamos agarrá-lo e vamos dizer

25946
17:08:24,400 --> 17:08:26,636
função lambda que retorna algo

25947
17:08:26,636 --> 17:08:28,956
E nós vamos montar o nosso Lambda

25948
17:08:28,956 --> 17:08:31,360
A função aqui vamos colocar isso no lugar

25949
17:08:31,360 --> 17:08:32,560
corretamente

25950
17:08:32,560 --> 17:08:35,756
e em vez de imprimir a soma de um

25951
17:08:35,756 --> 17:08:36,720
e b

25952
17:08:36,720 --> 17:08:39,116
Podemos voltar para que possamos ir em nosso

25953
17:08:39,116 --> 17:08:41,680
função lambda e dizer retorno

25954
17:08:41,680 --> 17:08:44,560
um plus b OK agora que temos isso nós

25955
17:08:44,560 --> 17:08:47,116
pode chamá-lo diretamente dizendo:

25956
17:08:47,116 --> 17:08:51,276
Por exemplo 10 e 20, mas agora, se tentarmos

25957
17:08:51,276 --> 17:08:54,160
e executar este código que não vai fazer

25958
17:08:54,160 --> 17:08:56,796
Qualquer coisa tente adivinhar o porquê

25959
17:08:56,796 --> 17:08:59,200
esta função lambda não está imprimindo para

25960
17:08:59,200 --> 17:09:01,276
O conceito diretamente é apenas

25961
17:09:01,276 --> 17:09:04,000
devolver qualquer que seja a soma de 10 e

25962
17:09:04,000 --> 17:09:04,956
20 anos.

25963
17:09:04,956 --> 17:09:07,200
E se devolvê-lo, não estamos fazendo

25964
17:09:07,200 --> 17:09:09,276
qualquer coisa com tudo que é devolvido de

25965
17:09:09,276 --> 17:09:11,276
Esta função lambda para que não vamos

25966
17:09:11,276 --> 17:09:12,880
para imprimir qualquer coisa e nós estamos apenas indo

25967
17:09:12,880 --> 17:09:14,480
para imprimir feito aqui

25968
17:09:14,480 --> 17:09:16,880
Vamos ferver e fazer você ver isso porque

25969
17:09:16,880 --> 17:09:18,480
Você realmente precisa estar ciente disso

25970
17:09:18,480 --> 17:09:19,680
pequenas coisas

25971
17:09:19,680 --> 17:09:21,840
para que a construção seja boa, podemos limpar e

25972
17:09:21,840 --> 17:09:24,160
corre galo vamos ver o nosso

25973
17:09:24,160 --> 17:09:26,720
A função lambda está devolvendo algo

25974
17:09:26,720 --> 17:09:28,956
Mas não estamos fazendo nada com o

25975
17:09:28,956 --> 17:09:30,400
Valor de retorno

25976
17:09:30,400 --> 17:09:32,636
Se quisermos imprimir o valor de retorno,

25977
17:09:32,636 --> 17:09:35,040
Precisamos pegá-lo de alguma forma e nós podemos colocar

25978
17:09:35,040 --> 17:09:36,880
que em uma variável, por exemplo, podemos

25979
17:09:36,880 --> 17:09:39,840
Diga automaticamente resultado e atribua o retorno

25980
17:09:39,840 --> 17:09:42,636
valor da nossa função lambda para isso

25981
17:09:42,636 --> 17:09:44,956
variável agora temos uma chance de imprimir

25982
17:09:44,956 --> 17:09:47,840
Isso, por exemplo, fazendo sddc out

25983
17:09:47,840 --> 17:09:49,916
Resultar e nós vamos

25984
17:09:49,916 --> 17:09:53,040
imprimir isso e salvar resultado agora se nós

25985
17:09:53,040 --> 17:09:54,880
construir este programa que vai imprimir

25986
17:09:54,880 --> 17:09:57,360
Seja qual for a soma de 10 e 20.

25987
17:09:57,360 --> 17:09:58,956
Faça isso e mostre que isso é

25988
17:09:58,956 --> 17:10:00,796
Na verdade, o caso

25989
17:10:00,796 --> 17:10:04,636
para que o mundo seja bom para que possamos limpar e correr

25990
17:10:04,636 --> 17:10:08,720
O resultado do galo é 30. se passarmos em 10

25991
17:10:08,720 --> 17:10:11,520
E 50, por exemplo, vamos conseguir

25992
17:10:11,520 --> 17:10:14,240
A mesma coisa vamos passar em 60 aqui

25993
17:10:14,240 --> 17:10:16,400
Então nós vamos construir com gcc o

25994
17:10:16,400 --> 17:10:18,636
Construir é bom, podemos limpar muito rápido

25995
17:10:18,636 --> 17:10:21,596
e correr galo agora a soma é 70 e

25996
17:10:21,596 --> 17:10:23,840
É assim que você pode devolver coisas de

25997
17:10:23,840 --> 17:10:26,320
sua função lambda e uma vez que você retorna

25998
17:10:26,320 --> 17:10:28,956
Coisas que você tem que ter certeza que você cortou seu

25999
17:10:28,956 --> 17:10:31,520
resultados e imprimi-los outra coisa

26000
17:10:31,520 --> 17:10:33,756
Você pode fazer é imprimir o resultado

26001
17:10:33,756 --> 17:10:36,000
diretamente depois de chamar seu lambda

26002
17:10:36,000 --> 17:10:38,636
funcionar, por exemplo, podemos pegar isso

26003
17:10:38,636 --> 17:10:41,276
toda a função lambda aqui e

26004
17:10:41,276 --> 17:10:44,080
colocar isso em uma declaração sddc out, então

26005
17:10:44,080 --> 17:10:46,320
nós vamos colocar um segundo aqui

26006
17:10:46,320 --> 17:10:48,880
e dizer resultado ou podemos até mesmo comentar

26007
17:10:48,880 --> 17:10:51,520
Isso não queremos ficar confusos

26008
17:10:51,520 --> 17:10:53,360
Quando olhamos para a terminologia que somos

26009
17:10:53,360 --> 17:10:56,240
Vou comentar o primeiro sddc out

26010
17:10:56,240 --> 17:10:59,320
Declaração aqui e vamos dizer

26011
17:10:59,320 --> 17:11:02,796
stdendl aqui e colocar em um espaço reservado

26012
17:11:02,796 --> 17:11:05,116
para a nossa função lambda e nós vamos

26013
17:11:05,116 --> 17:11:06,560
para colá-lo em

26014
17:11:06,560 --> 17:11:08,636
Se fizermos algo assim novamente

26015
17:11:08,636 --> 17:11:11,040
Toda a coisa da função lambda vai

26016
17:11:11,040 --> 17:11:13,116
Retorne a soma e é isso que nós somos

26017
17:11:13,116 --> 17:11:15,840
indo imprimir eu percebo que esta sintaxe é

26018
17:11:15,840 --> 17:11:18,560
Realmente enigmático, mas vai funcionar

26019
17:11:18,560 --> 17:11:21,276
Vamos tentar construir o nosso programa aqui o

26020
17:11:21,276 --> 17:11:23,680
O mundo é bom para que possamos limpar e correr

26021
17:11:23,680 --> 17:11:25,680
Galo, vamos ver esse resultado

26022
17:11:25,680 --> 17:11:29,040
é 70 e isso vem do nosso chamado

26023
17:11:29,040 --> 17:11:32,956
Aqui, que está aninhado dentro do nosso htdc para fora

26024
17:11:32,956 --> 17:11:35,520
Declaração que você pode fazer isso se quiser

26025
17:11:35,520 --> 17:11:37,520
Outra coisa que você pode fazer como vimos

26026
17:11:37,520 --> 17:11:40,160
antes é dar a sua função lambda um

26027
17:11:40,160 --> 17:11:42,796
nomeie e chame-o repetidamente para

26028
17:11:42,796 --> 17:11:44,796
Um exemplo, podemos tentar comentar o que

26029
17:11:44,796 --> 17:11:47,040
Temos aqui e montou outro lambda

26030
17:11:47,040 --> 17:11:48,796
A função porque nós

26031
17:11:48,796 --> 17:11:50,880
Não quero confundir você novamente, então nós somos

26032
17:11:50,880 --> 17:11:53,756
indo para agarrar a nossa função lambda aqui

26033
17:11:53,756 --> 17:11:55,360
nós vamos copiá-lo porque não

26034
17:11:55,360 --> 17:11:57,840
Quero digitar isso mil vezes

26035
17:11:57,840 --> 17:11:59,840
e nós não queremos chamar isso lambda

26036
17:11:59,840 --> 17:12:01,916
funcionar diretamente, em vez disso, queremos

26037
17:12:01,916 --> 17:12:03,596
Dá-lhe um nome e vamos dizer

26038
17:12:03,596 --> 17:12:07,200
aro funk 2 e vamos atribuir o nosso

26039
17:12:07,200 --> 17:12:10,400
função lambda tipo para func um

26040
17:12:10,400 --> 17:12:12,880
Agora que temos isso, podemos dizer auto

26041
17:12:12,880 --> 17:12:14,956
O resultado 1, por exemplo

26042
17:12:14,956 --> 17:12:17,276
e podemos dizer func e podemos passar em

26043
17:12:17,276 --> 17:12:19,756
O que quisermos, vamos colocar em 23 e um

26044
17:12:19,756 --> 17:12:20,720
sete

26045
17:12:20,720 --> 17:12:23,680
E isso vai somar 23 e sete

26046
17:12:23,680 --> 17:12:25,276
nós vamos pegar o resultado e nós somos

26047
17:12:25,276 --> 17:12:27,756
vai atribuir isso ao resultado

26048
17:12:27,756 --> 17:12:29,916
Se descermos e dissermos automaticamente, por exemplo

26049
17:12:29,916 --> 17:12:33,276
resultado dois e dizer, por exemplo, funk um

26050
17:12:33,276 --> 17:12:34,636
E dizer

26051
17:12:34,636 --> 17:12:37,596
9 e 45

26052
17:12:37,596 --> 17:12:40,080
Por que não e descer e imprimir estes

26053
17:12:40,080 --> 17:12:41,916
variáveis de resultado que vamos ver o

26054
17:12:41,916 --> 17:12:44,320
somas impressas e novamente a mensagem

26055
17:12:44,320 --> 17:12:47,116
é que nós podemos usar este punho para chamar

26056
17:12:47,116 --> 17:12:49,200
nossa função lambda várias vezes assim

26057
17:12:49,200 --> 17:12:51,040
Vamos descer e imprimir isso, nós somos

26058
17:12:51,040 --> 17:12:52,240
Vou dizer que

26059
17:12:52,240 --> 17:12:54,636
Resultar um e vamos dizer resultado

26060
17:12:54,636 --> 17:12:56,636
Um aqui nós vamos descer e dizer

26061
17:12:56,636 --> 17:12:58,956
resultado dois e vamos imprimir isso

26062
17:12:58,956 --> 17:13:00,796
fora e podemos até chamar isso lambda

26063
17:13:00,796 --> 17:13:03,680
funcionar diretamente e colocar isso em esddc

26064
17:13:03,680 --> 17:13:05,840
Aqui vamos dizer que estamos indo

26065
17:13:05,840 --> 17:13:08,636
dizer resultado para 3, por exemplo ou direto

26066
17:13:08,636 --> 17:13:11,200
chamar Eu acho que isso é bastante descritivo

26067
17:13:11,200 --> 17:13:13,360
Vamos dizer func

26068
17:13:13,360 --> 17:13:15,680
um nome da nossa função lambda ou

26069
17:13:15,680 --> 17:13:18,080
a alça para a função lambda e nós

26070
17:13:18,080 --> 17:13:20,956
pode colocar em um cinco e um dois, por exemplo

26071
17:13:20,956 --> 17:13:22,560
e nós vamos ver essa impressão

26072
17:13:22,560 --> 17:13:25,520
O resultado se construirmos nosso programa, vamos

26073
17:13:25,520 --> 17:13:29,040
fazer isso com gcc o parafuso vai ser

26074
17:13:29,040 --> 17:13:32,000
Bom podemos limpar e correr galo, estamos

26075
17:13:32,000 --> 17:13:35,436
ter resultado 1 é 30, que é 23

26076
17:13:35,436 --> 17:13:38,560
e 7 assim a soma é 30. o segundo

26077
17:13:38,560 --> 17:13:42,080
Devo dizer 54 porque essa é a soma e

26078
17:13:42,080 --> 17:13:44,240
O terceiro deve dizer 7 porque

26079
17:13:44,240 --> 17:13:47,436
que é a soma de 5 e 2 e é o que

26080
17:13:47,436 --> 17:13:49,276
Nós temos aqui e depois disso estamos indo

26081
17:13:49,276 --> 17:13:51,680
para ver que o nosso programa é feito isso é

26082
17:13:51,680 --> 17:13:54,160
Como você pode configurar uma função lambda

26083
17:13:54,160 --> 17:13:56,636
que retorna algo e nós vimos

26084
17:13:56,636 --> 17:13:58,796
Muitas maneiras de trabalhar conosco, vamos

26085
17:13:58,796 --> 17:14:01,040
Comente isso porque há um

26086
17:14:01,040 --> 17:14:03,596
Mais coisa eu quero que você veja e isso é

26087
17:14:03,596 --> 17:14:06,240
ao longo da função cujo tipo de retorno é

26088
17:14:06,240 --> 17:14:08,956
especificado explicitamente ok, estamos indo

26089
17:14:08,956 --> 17:14:11,040
reutilizar a mesma função lambda nós

26090
17:14:11,040 --> 17:14:12,796
Temos usado o tempo todo e nós estamos

26091
17:14:12,796 --> 17:14:14,320
Vou copiar isso

26092
17:14:14,320 --> 17:14:16,796
e nós vamos descer e colocá-lo

26093
17:14:16,796 --> 17:14:19,840
Aqui e agora queremos especificar o

26094
17:14:19,840 --> 17:14:22,320
Tipo de retorno como um duplo da maneira que fazemos

26095
17:14:22,320 --> 17:14:25,040
que vamos atrás da nossa lista de parâmetros e

26096
17:14:25,040 --> 17:14:27,680
colocamos em um símbolo de traço e colocamos em um

26097
17:14:27,680 --> 17:14:29,596
Maior do que o símbolo e então vamos

26098
17:14:29,596 --> 17:14:32,320
para especificar o tipo de retorno de nossa lambda

26099
17:14:32,320 --> 17:14:34,880
Função, digamos que queremos o nosso

26100
17:14:34,880 --> 17:14:37,596
Tipo de retorno para ser formista é assim que dizemos

26101
17:14:37,596 --> 17:14:39,916
Agora nossa função aqui vai

26102
17:14:39,916 --> 17:14:42,956
Retorno, independentemente dos tipos que

26103
17:14:42,956 --> 17:14:45,436
colocamos o que o compilador está indo

26104
17:14:45,436 --> 17:14:47,200
para fazer quando chamamos isso de função lambda

26105
17:14:47,200 --> 17:14:48,956
ele vai tomar os parâmetros que é

26106
17:14:48,956 --> 17:14:50,480
Vou adicioná-los, por exemplo, agora

26107
17:14:50,480 --> 17:14:52,880
eles são o dobro, então ele vai adicionar um

26108
17:14:52,880 --> 17:14:54,956
e b como o dobro vai produzir um

26109
17:14:54,956 --> 17:14:57,040
dupla variável, então ele vai

26110
17:14:57,040 --> 17:15:00,320
Converta isso para terminar e devolva você

26111
17:15:00,320 --> 17:15:03,276
perceba que agora nós forçamos a nossa

26112
17:15:03,276 --> 17:15:06,320
função lambda para realmente retornar um

26113
17:15:06,320 --> 17:15:07,520
específicos

26114
17:15:07,520 --> 17:15:08,720
O tipo aqui

26115
17:15:08,720 --> 17:15:11,520
antes que o tipo de retorno fosse deduzido de

26116
17:15:11,520 --> 17:15:14,160
A operação que fizemos aqui e

26117
17:15:14,160 --> 17:15:16,720
antes de voltarmos o dobro porque

26118
17:15:16,720 --> 17:15:18,796
Isso é o que o compilador estava deduzindo

26119
17:15:18,796 --> 17:15:21,116
para a e b aqui para realmente conduzir o

26120
17:15:21,116 --> 17:15:24,000
ponto de casa vamos atribuir este lambda

26121
17:15:24,000 --> 17:15:27,756
função para func um ou func três vamos

26122
17:15:27,756 --> 17:15:30,240
Faz isso vamos dizer func três

26123
17:15:30,240 --> 17:15:32,000
e esta é uma função lambda que é

26124
17:15:32,000 --> 17:15:35,520
indo retornar explicitamente e nós somos

26125
17:15:35,520 --> 17:15:36,956
Vou montar outro que é

26126
17:15:36,956 --> 17:15:38,956
indo para deduzir o tipo de retorno que nós somos

26127
17:15:38,956 --> 17:15:40,720
Não vai especificar

26128
17:15:40,720 --> 17:15:42,956
o tipo de retorno explicitamente para que possamos

26129
17:15:42,956 --> 17:15:45,596
Vou tirar o nosso tipo de retorno aqui

26130
17:15:45,596 --> 17:15:46,880
Vamos fazer isso

26131
17:15:46,880 --> 17:15:49,200
e nós vamos descer e dizer automóvel

26132
17:15:49,200 --> 17:15:53,116
resultado 3 e vamos dizer funk 3

26133
17:15:53,116 --> 17:15:56,240
e somar duas variáveis duplas, vamos

26134
17:15:56,240 --> 17:15:58,480
configurar essas variáveis explicitamente assim

26135
17:15:58,480 --> 17:16:00,480
que você realmente vê o que está acontecendo, então

26136
17:16:00,480 --> 17:16:03,116
nós vamos dizer isso e colocar em

26137
17:16:03,116 --> 17:16:05,276
a 6.9

26138
17:16:05,276 --> 17:16:08,080
Por que não e vamos fazer deste cara um duplo

26139
17:16:08,080 --> 17:16:10,160
Porque é essa a nossa função aqui

26140
17:16:10,160 --> 17:16:12,240
espera e nós vamos fazer outro

26141
17:16:12,240 --> 17:16:14,956
um do duplo b e nós vamos colocar

26142
17:16:14,956 --> 17:16:17,840
em um 3.5

26143
17:16:17,840 --> 17:16:20,560
Por exemplo, e vamos usar isso

26144
17:16:20,560 --> 17:16:22,480
variáveis como argumentos aqui estamos indo

26145
17:16:22,480 --> 17:16:24,560
para dizer a e b e nós vamos dizer

26146
17:16:24,560 --> 17:16:26,480
Resultado do automóvel

26147
17:16:26,480 --> 17:16:27,276
para a

26148
17:16:27,276 --> 17:16:30,636
Isso deve ser funk 4 desculpe por isso

26149
17:16:30,636 --> 17:16:32,880
e eu vou dizer resultado 4 e isso

26150
17:16:32,880 --> 17:16:36,080
Devo dizer que resultado estou fazendo muitos erros de digitação

26151
17:16:36,080 --> 17:16:38,240
Vamos atribuir o nosso Lambda

26152
17:16:38,240 --> 17:16:41,040
Funcionar o resultado do nosso lambda

26153
17:16:41,040 --> 17:16:44,480
Função devo dizer para resultar aqui

26154
17:16:44,480 --> 17:16:46,160
E nós vamos passar para dentro

26155
17:16:46,160 --> 17:16:47,596
a e b

26156
17:16:47,596 --> 17:16:50,956
Agora queremos ver os tipos de resultado 3

26157
17:16:50,956 --> 17:16:53,840
e resultado 4 aqui vamos descer

26158
17:16:53,840 --> 17:16:55,520
e imprimi-los vamos dizer

26159
17:16:55,520 --> 17:16:59,200
sddc fora tamanho deste é uma maneira que temos

26160
17:16:59,200 --> 17:17:00,400
para chegar

26161
17:17:00,400 --> 17:17:03,040
Tipos de nossas variáveis

26162
17:17:03,040 --> 17:17:05,040
Vamos passar no resultado três

26163
17:17:05,040 --> 17:17:07,596
Vamos dizer o tamanho do resultado três

26164
17:17:07,596 --> 17:17:09,916
e nós vamos descer e dizer tamanho

26165
17:17:09,916 --> 17:17:13,200
de resultado para OK temos o nosso código em

26166
17:17:13,200 --> 17:17:15,436
lugar e o que queremos ver

26167
17:17:15,436 --> 17:17:18,796
é o tipo que é deduzido pelo func

26168
17:17:18,796 --> 17:17:22,720
3 função lambda aqui estamos explicitamente

26169
17:17:22,720 --> 17:17:25,040
transformando o tipo de retorno em fim

26170
17:17:25,040 --> 17:17:26,956
Os parâmetros que passamos serão

26171
17:17:26,956 --> 17:17:29,116
O dobro é o que temos aqui estamos

26172
17:17:29,116 --> 17:17:31,436
vai somar a e b e o resultado

26173
17:17:31,436 --> 17:17:33,596
Isso também será o dobro, mas

26174
17:17:33,596 --> 17:17:35,596
o compilador vai notar que nós

26175
17:17:35,596 --> 17:17:39,116
estão retornando e explicitamente aqui e

26176
17:17:39,116 --> 17:17:41,756
vai tomar este duplo resultado e

26177
17:17:41,756 --> 17:17:44,636
transformar isso para acabar e nós vamos

26178
17:17:44,636 --> 17:17:45,436
get get

26179
17:17:45,436 --> 17:17:47,040
e nós vamos obter o resultado de

26180
17:17:47,040 --> 17:17:49,756
que foi atribuído ao func 3 aqui para o

26181
17:17:49,756 --> 17:17:52,160
segunda função lambda aqui estamos indo

26182
17:17:52,160 --> 17:17:54,636
para deduzir automaticamente o tipo de retorno

26183
17:17:54,636 --> 17:17:57,276
Então o que voltamos aqui vai ser

26184
17:17:57,276 --> 17:17:59,680
um tipo duplo e devemos ver um tamanho

26185
17:17:59,680 --> 17:18:02,480
para pesquisa 3 aqui impresso para fora, então

26186
17:18:02,480 --> 17:18:06,000
Devemos ver um 4 no meu sistema e para

26187
17:18:06,000 --> 17:18:08,400
A segunda declaração aqui devemos ver

26188
17:18:08,400 --> 17:18:10,796
Um tamanho de duplo impresso este é um

26189
17:18:10,796 --> 17:18:13,436
maneira que temos que tentar provar isso assim

26190
17:18:13,436 --> 17:18:15,520
Vamos construir este programa e ver o que nós

26191
17:18:15,520 --> 17:18:17,756
O mundo é bom que podemos limpar

26192
17:18:17,756 --> 17:18:20,080
e correr o galo e nós vamos ver

26193
17:18:20,080 --> 17:18:23,200
Que isso é exatamente o que esperamos aqui

26194
17:18:23,200 --> 17:18:25,840
se quisermos podemos até imprimir o resultado 3

26195
17:18:25,840 --> 17:18:28,480
e resultar 4 e ver o que nós temos

26196
17:18:28,480 --> 17:18:31,360
Vamos fazer isso que estamos aprendendo, então vamos

26197
17:18:31,360 --> 17:18:32,956
Experimentar com isso um pouco nós somos

26198
17:18:32,956 --> 17:18:36,000
vamos dizer resultado 3 e devemos ir

26199
17:18:36,000 --> 17:18:39,520
voltar e dizer resultado três se eu posso digitar

26200
17:18:39,520 --> 17:18:42,000
e e dl aqui e nós vamos descer

26201
17:18:42,000 --> 17:18:45,680
e dizer resultado do sddc para ok se nós

26202
17:18:45,680 --> 17:18:47,200
construir e executar isso

26203
17:18:47,200 --> 17:18:49,520
Vamos ver os resultados impressos

26204
17:18:49,520 --> 17:18:52,080
para baixo ambos é bom que podemos limpar e

26205
17:18:52,080 --> 17:18:53,520
correr o galo

26206
17:18:53,520 --> 17:18:57,040
Agora temos resultado é 10 para a

26207
17:18:57,040 --> 17:18:59,596
A primeira coisa aqui para o

26208
17:18:59,596 --> 17:19:02,240
Primeira função lambda e para o segundo

26209
17:19:02,240 --> 17:19:05,916
Um resultado é 10,4 você pode ver que para

26210
17:19:05,916 --> 17:19:08,956
O primeiro o resultado foi transformado

26211
17:19:08,956 --> 17:19:11,276
do duplo para e para o segundo

26212
17:19:11,276 --> 17:19:13,436
Um que deduzimos o dobro, então ainda temos

26213
17:19:13,436 --> 17:19:16,160
nosso ponto decimal aqui espero que isso

26214
17:19:16,160 --> 17:19:18,160
faz sentido e isso é realmente tudo que nós

26215
17:19:18,160 --> 17:19:20,880
definido para fazer nesta palestra mostrando

26216
17:19:20,880 --> 17:19:22,720
maneiras diferentes de configurar suas

26217
17:19:22,720 --> 17:19:25,040
funções lambda que vimos a sintaxe de

26218
17:19:25,040 --> 17:19:27,276
configurando uma função lambda, vimos que

26219
17:19:27,276 --> 17:19:29,276
você pode declarar uma função lambda e

26220
17:19:29,276 --> 17:19:32,000
chamá-lo através de um nome como func aqui nós

26221
17:19:32,000 --> 17:19:34,160
desceu e para que você possa declarar um

26222
17:19:34,160 --> 17:19:36,160
função lambda e chamá-lo diretamente

26223
17:19:36,160 --> 17:19:38,160
através da sintaxe que você vê aqui nós vimos

26224
17:19:38,160 --> 17:19:40,480
Como podemos especificar parâmetros para

26225
17:19:40,480 --> 17:19:42,956
nossa função lambda esta é a sintaxe

26226
17:19:42,956 --> 17:19:44,400
E uma vez que você faz isso você tem que

26227
17:19:44,400 --> 17:19:46,240
Lembre-se de chamar suas funções de lambda

26228
17:19:46,240 --> 17:19:48,956
com parâmetros como vemos aqui podemos

26229
17:19:48,956 --> 17:19:52,160
até usar uma alça dada ao nosso lambda

26230
17:19:52,160 --> 17:19:54,720
função e chamar a função lambda

26231
17:19:54,720 --> 17:19:57,200
Várias vezes depois disso vimos que

26232
17:19:57,200 --> 17:19:59,040
Poderia devolver algo de um lambda

26233
17:19:59,040 --> 17:20:01,276
Funcionar e tivemos muitas chances de jogar

26234
17:20:01,276 --> 17:20:02,240
Conosco

26235
17:20:02,240 --> 17:20:03,436
E nós

26236
17:20:03,436 --> 17:20:06,080
Acabado olhando como poderíamos especificar

26237
17:20:06,080 --> 17:20:09,116
O tipo de retorno explicitamente e

26238
17:20:09,116 --> 17:20:12,160
Sintaxe para fazer isso é o que você vê aqui

26239
17:20:12,160 --> 17:20:13,756
Vamos parar aqui neste

26240
17:20:13,756 --> 17:20:15,596
dar uma palestra no próximo que vamos ver

26241
17:20:15,596 --> 17:20:18,720
Como podemos usar nossas listas de captura aqui

26242
17:20:18,720 --> 17:20:21,756
e fazê-los fazer coisas úteis

26243
17:20:21,756 --> 17:20:23,596
Vá em frente e termine aqui

26244
17:20:23,596 --> 17:20:25,436
e me encontrar lá

26245
17:20:25,436 --> 17:20:26,956
Nesta palestra vamos ver como

26246
17:20:26,956 --> 17:20:30,080
Podemos usar listas de captura em nosso lambda

26247
17:20:30,080 --> 17:20:32,880
funções e fazer algumas coisas úteis que nós

26248
17:20:32,880 --> 17:20:35,680
Tenho visto que a sintaxe do nosso lambda

26249
17:20:35,680 --> 17:20:38,240
funções incluem estes suportes de ângulo

26250
17:20:38,240 --> 17:20:40,720
Aqui, mas nós realmente não os usamos para

26251
17:20:40,720 --> 17:20:43,276
fazer qualquer coisa pelo que fizemos no

26252
17:20:43,276 --> 17:20:45,840
Na última palestra, eles estavam vazios todos os

26253
17:20:45,840 --> 17:20:48,160
tempo nesta palestra que vamos usar

26254
17:20:48,160 --> 17:20:50,400
Aqui estão um exemplo simples de como nós

26255
17:20:50,400 --> 17:20:52,636
pode usar nossa lista de cápsulas

26256
17:20:52,636 --> 17:20:55,116
temos duas variáveis a e b

26257
17:20:55,116 --> 17:20:57,116
de tipo duplo e contêm estes

26258
17:20:57,116 --> 17:21:00,240
valores 10 e 20. mas às vezes queremos

26259
17:21:00,240 --> 17:21:02,796
para usar graças fora do escopo do

26260
17:21:02,796 --> 17:21:04,320
função lambda

26261
17:21:04,320 --> 17:21:06,636
dentro da função lambda aqui e se

26262
17:21:06,636 --> 17:21:08,636
você configura sua função lambda com um

26263
17:21:08,636 --> 17:21:10,636
Lista de captura vazia suponha que você não

26264
17:21:10,636 --> 17:21:12,636
Tenho esses dois caras em

26265
17:21:12,636 --> 17:21:14,796
e você tenta usar um e b como este

26266
17:21:14,796 --> 17:21:16,636
você vai ter um erro de compilador

26267
17:21:16,636 --> 17:21:17,840
porque

26268
17:21:17,840 --> 17:21:20,956
o corpo da função lambda não

26269
17:21:20,956 --> 17:21:24,796
ter acesso ao contexto externo aqui

26270
17:21:24,796 --> 17:21:27,276
Só pode usar as coisas dentro do lambda

26271
17:21:27,276 --> 17:21:29,840
funções ou eventos que você passa para o

26272
17:21:29,840 --> 17:21:32,160
Lambda função aqui, mas não pode

26273
17:21:32,160 --> 17:21:34,956
acessar diretamente as coisas fora do

26274
17:21:34,956 --> 17:21:37,596
funções lambda e podemos ter acesso

26275
17:21:37,596 --> 17:21:40,160
graças que são declaradas e definidas

26276
17:21:40,160 --> 17:21:42,636
fora da função lambda através do nosso

26277
17:21:42,636 --> 17:21:44,880
lista de captura se você olhar aqui estamos

26278
17:21:44,880 --> 17:21:47,756
dizendo a e b e esta é a sintaxe que nós

26279
17:21:47,756 --> 17:21:49,520
Você tem que capturar

26280
17:21:49,520 --> 17:21:52,796
estas duas variáveis a e b e têm

26281
17:21:52,796 --> 17:21:55,436
acesso a eles dentro do nosso lambda

26282
17:21:55,436 --> 17:21:57,596
função aqui e é isso que captura

26283
17:21:57,596 --> 17:22:00,160
As listas são realmente para dar acesso

26284
17:22:00,160 --> 17:22:03,436
às coisas que são declaradas fora do

26285
17:22:03,436 --> 17:22:05,436
escopo da função lambda porque se

26286
17:22:05,436 --> 17:22:08,000
Você realmente pensa sobre isso este lambda

26287
17:22:08,000 --> 17:22:11,040
A coisa da função que temos aqui é realmente um

26288
17:22:11,040 --> 17:22:12,240
Tipo de tipo

26289
17:22:12,240 --> 17:22:14,400
Então é a sua própria coisa

26290
17:22:14,400 --> 17:22:16,956
que tem esses comportamentos bem, então então

26291
17:22:16,956 --> 17:22:19,360
que podemos chamá-lo e fazer as coisas, mas

26292
17:22:19,360 --> 17:22:21,840
Realmente não tem acesso direto ao

26293
17:22:21,840 --> 17:22:23,116
O lado de fora

26294
17:22:23,116 --> 17:22:25,276
onde foi declarado e você tem que

26295
17:22:25,276 --> 17:22:27,436
dar acesso através da captura

26296
17:22:27,436 --> 17:22:29,520
Um mecanismo aqui está bem agora que você sabe

26297
17:22:29,520 --> 17:22:31,116
Isso nós vamos ver maneiras diferentes

26298
17:22:31,116 --> 17:22:33,596
nós podemos usar o mecanismo de captura um

26299
17:22:33,596 --> 17:22:36,160
O que podemos fazer é capturar por valor e

26300
17:22:36,160 --> 17:22:38,080
Se capturarmos por valor o que estamos indo

26301
17:22:38,080 --> 17:22:40,720
para ter dentro da função lambda é

26302
17:22:40,720 --> 17:22:42,636
Vou ser uma cópia, suponha que temos um

26303
17:22:42,636 --> 17:22:44,956
variável aqui que é c o valor é

26304
17:22:44,956 --> 17:22:47,520
Vou ter 42 como você vê aqui estamos

26305
17:22:47,520 --> 17:22:49,276
Vou montar uma função lambda e

26306
17:22:49,276 --> 17:22:51,756
capturar nossa variável c

26307
17:22:51,756 --> 17:22:54,480
por valor nesta função lambda aqui

26308
17:22:54,480 --> 17:22:56,480
e o que vamos fazer fora do

26309
17:22:56,480 --> 17:22:58,160
função lambda notar o lambda

26310
17:22:58,160 --> 17:23:00,400
A função tem um punho para que possamos chamá-lo

26311
17:23:00,400 --> 17:23:02,400
vamos fazer loop cinco vezes

26312
17:23:02,400 --> 17:23:04,480
e em cada iteração vamos

26313
17:23:04,480 --> 17:23:07,116
chamar a nossa função lambda e imprimir o

26314
17:23:07,116 --> 17:23:08,480
O valor interior aqui

26315
17:23:08,480 --> 17:23:10,400
Mas depois disso vamos incrementar

26316
17:23:10,400 --> 17:23:12,636
nossa variável c e isso vai

26317
17:23:12,636 --> 17:23:14,240
incrementa o

26318
17:23:14,240 --> 17:23:16,796
Variável exterior aqui e o que queremos

26319
17:23:16,796 --> 17:23:19,040
Veja é que as mudanças que estamos fazendo

26320
17:23:19,040 --> 17:23:21,756
O exterior aqui é pego pelo

26321
17:23:21,756 --> 17:23:23,840
valor interior que temos em nosso lambda

26322
17:23:23,840 --> 17:23:26,400
função aqui e à frente para quebrá-lo para

26323
17:23:26,400 --> 17:23:28,636
Você não vai ser o caso

26324
17:23:28,636 --> 17:23:30,720
Porque o que temos dentro do lambda

26325
17:23:30,720 --> 17:23:33,436
A função é uma cópia do exterior

26326
17:23:33,436 --> 17:23:35,200
variável aqui, então o que vamos

26327
17:23:35,200 --> 17:23:38,000
tem é para o valor exterior sair de

26328
17:23:38,000 --> 17:23:40,400
42 até 47 nós vamos embora

26329
17:23:40,400 --> 17:23:42,956
Cinco vezes incrementando esse garotinho

26330
17:23:42,956 --> 17:23:45,360
Mas a coisa no interior não está indo

26331
17:23:45,360 --> 17:23:47,596
para mudar, porque é uma cópia do

26332
17:23:47,596 --> 17:23:50,160
A incrementação aqui está afetando a

26333
17:23:50,160 --> 17:23:52,796
fora da variável aqui, mas não é

26334
17:23:52,796 --> 17:23:55,116
afetando a cópia que temos dentro do nosso

26335
17:23:55,116 --> 17:23:57,680
função lambda assim para todos esses loops

26336
17:23:57,680 --> 17:24:00,240
Aqui vamos ver 42 imprimindo para baixo

26337
17:24:00,240 --> 17:24:02,000
E nós vamos ver isso em um minuto

26338
17:24:02,000 --> 17:24:04,160
quando atingimos o código do estúdio visual, vamos dizer

26339
17:24:04,160 --> 17:24:06,080
42 corretamente

26340
17:24:06,080 --> 17:24:08,480
Desculpe a minha digitação aqui, então agora você

26341
17:24:08,480 --> 17:24:10,636
Saiba que podemos capturar por um valor e

26342
17:24:10,636 --> 17:24:12,796
Você sabe o que isso realmente significa outro

26343
17:24:12,796 --> 17:24:15,596
O que podemos fazer é capturar por referência

26344
17:24:15,596 --> 17:24:18,160
e a sintaxe a fazer é adicionar um

26345
17:24:18,160 --> 17:24:20,956
ampersand símbolo na frente do

26346
17:24:20,956 --> 17:24:22,956
variável que capturamos aqui e se nós

26347
17:24:22,956 --> 17:24:25,520
fazer isso e executar o ponto e-vírgula que corremos em

26348
17:24:25,520 --> 17:24:27,916
A última palestra que vamos ver agora

26349
17:24:27,916 --> 17:24:30,636
que as mudanças que fazemos no exterior

26350
17:24:30,636 --> 17:24:32,720
serão pegos pelo interior

26351
17:24:32,720 --> 17:24:35,596
lado da nossa função lambda porque nós

26352
17:24:35,596 --> 17:24:38,320
são capturando por referência o que temos

26353
17:24:38,320 --> 17:24:41,116
dentro da nossa função lambda aqui é um

26354
17:24:41,116 --> 17:24:43,756
verdadeira referência ao exterior

26355
17:24:43,756 --> 17:24:45,360
variável aqui e nós vamos ver

26356
17:24:45,360 --> 17:24:48,320
que agora o exterior e o interior são

26357
17:24:48,320 --> 17:24:50,400
vai aumentar em conjunto e

26358
17:24:50,400 --> 17:24:53,520
Vamos ter 43 42 44 e coisas

26359
17:24:53,520 --> 17:24:55,840
Como aquele impresso no console

26360
17:24:55,840 --> 17:24:57,756
Tudo bem isso é realmente tudo que eu tenho que compartilhar

26361
17:24:57,756 --> 17:24:59,916
com você nesta palestra mostrando-lhe como

26362
17:24:59,916 --> 17:25:02,480
você pode usar suas listas de captura e que

26363
17:25:02,480 --> 17:25:04,796
você pode capturar por valor ou por

26364
17:25:04,796 --> 17:25:06,880
referência que vamos nos dirigir para

26365
17:25:06,880 --> 17:25:08,636
código de estúdio visual e jogar com este

26366
17:25:08,636 --> 17:25:11,200
Um pouco mais bem aqui estamos em nosso

26367
17:25:11,200 --> 17:25:13,436
pasta de trabalho o projeto atual é

26368
17:25:13,436 --> 17:25:16,160
captura listas que vamos pegar o nosso

26369
17:25:16,160 --> 17:25:18,080
arquivos de modelo muito rápido e nós somos

26370
17:25:18,080 --> 17:25:19,756
vamos colocá-los no lugar que estamos indo

26371
17:25:19,756 --> 17:25:20,636
A sua forma de

26372
17:25:20,636 --> 17:25:23,116
Coloque-os no projeto atual e

26373
17:25:23,116 --> 17:25:25,200
nós vamos abrir esse cara no visual

26374
17:25:25,200 --> 17:25:27,596
código de estúdio arrastando e soltando

26375
17:25:27,596 --> 17:25:29,840
lugar aqui e nós vamos abrir o nosso

26376
17:25:29,840 --> 17:25:33,360
arquivo cpp principal limpar um pouco

26377
17:25:33,360 --> 17:25:35,520
e fechar o painel esquerdo aqui o que nós

26378
17:25:35,520 --> 17:25:38,160
Quero fazer aqui é uh aprender um pouco

26379
17:25:38,160 --> 17:25:40,240
mais sobre listas de captura e vamos

26380
17:25:40,240 --> 17:25:42,880
para colocar um pedaço de código para jogar com

26381
17:25:42,880 --> 17:25:46,400
Só que temos duas variáveis a e 10

26382
17:25:46,400 --> 17:25:49,436
aqui e nós temos a nossa função lambda

26383
17:25:49,436 --> 17:25:51,436
configuração e vamos tirar a nossa captura

26384
17:25:51,436 --> 17:25:53,436
lista para que você possa ver o compilador

26385
17:25:53,436 --> 17:25:54,720
O erro que vemos

26386
17:25:54,720 --> 17:25:57,680
Se tentarmos usá-los como está aqui, então nós

26387
17:25:57,680 --> 17:25:59,596
Temos nossas duas variáveis e temos uma

26388
17:25:59,596 --> 17:26:02,636
função lambda configurada aqui e dentro

26389
17:26:02,636 --> 17:26:05,200
A função lambda percebe que nós somos

26390
17:26:05,200 --> 17:26:08,080
Tentando acessar as variáveis que têm

26391
17:26:08,080 --> 17:26:10,240
Foi declarado no exterior do

26392
17:26:10,240 --> 17:26:12,636
função lambda aqui e por padrão se

26393
17:26:12,636 --> 17:26:14,240
nós tentamos fazer isso, nós vamos ter um

26394
17:26:14,240 --> 17:26:16,240
Erro do compilador porque estes dois

26395
17:26:16,240 --> 17:26:19,200
As variáveis não existem no âmbito de

26396
17:26:19,200 --> 17:26:21,200
A função lambda aqui vamos trazer à tona

26397
17:26:21,200 --> 17:26:23,840
um terminal e ver que estúdio visual

26398
17:26:23,840 --> 17:26:25,756
O código está dizendo sobre isso

26399
17:26:25,756 --> 17:26:27,680
e vai dizer um fechamento

26400
17:26:27,680 --> 17:26:30,160
A variável local da função não pode ser

26401
17:26:30,160 --> 17:26:31,916
referenciado em

26402
17:26:31,916 --> 17:26:35,040
corpo lambda a menos que esteja na captura

26403
17:26:35,040 --> 17:26:36,796
Liste e você vê que isso é realmente

26404
17:26:36,796 --> 17:26:39,360
Ok descritivo enviamos este erro

26405
17:26:39,360 --> 17:26:41,200
Mas nós queremos ver o que o compilador

26406
17:26:41,200 --> 17:26:43,520
Diz sobre isso nós vamos passar isso

26407
17:26:43,520 --> 17:26:46,720
através de gcc e devemos obter um similar

26408
17:26:46,720 --> 17:26:49,360
Erro vai dizer a não

26409
17:26:49,360 --> 17:26:52,000
Capturado e vai descer aqui

26410
17:26:52,000 --> 17:26:55,116
e dizer b não é capturado aqui e isso

26411
17:26:55,116 --> 17:26:57,360
É o erro que estamos tentando usar

26412
17:26:57,360 --> 17:27:00,560
variáveis externas em nossa função lambda

26413
17:27:00,560 --> 17:27:02,720
Mas para realmente fazer isso, precisamos capturar

26414
17:27:02,720 --> 17:27:03,840
a e b

26415
17:27:03,840 --> 17:27:06,160
e a sintaxe para capturar nossas variáveis

26416
17:27:06,160 --> 17:27:09,360
é colocá-los dentro de nossos suportes de ângulo

26417
17:27:09,360 --> 17:27:12,480
Aqui com uma vírgula separada da lista

26418
17:27:12,480 --> 17:27:14,636
das variáveis que queremos capturar

26419
17:27:14,636 --> 17:27:16,956
Então vamos dizer uma vírgula b porque

26420
17:27:16,956 --> 17:27:19,200
Isso é o que queremos capturar aqui e

26421
17:27:19,200 --> 17:27:20,956
O momento em que fazemos isso

26422
17:27:20,956 --> 17:27:22,880
Código de estúdio visual deve ser feliz que é

26423
17:27:22,880 --> 17:27:24,720
Não feliz eu acho que precisamos compilar

26424
17:27:24,720 --> 17:27:27,916
para que seja feliz, então vamos fazer isso

26425
17:27:27,916 --> 17:27:29,276
E você vê agora

26426
17:27:29,276 --> 17:27:32,240
Nossas variáveis estão sendo capturadas e nós

26427
17:27:32,240 --> 17:27:35,116
estamos somando e estamos imprimindo

26428
17:27:35,116 --> 17:27:38,400
o resultado de adicioná-los aqui por

26429
17:27:38,400 --> 17:27:41,200
Chamando a função através de uma alça

26430
17:27:41,200 --> 17:27:43,200
ter configurado aqui espero que isso seja

26431
17:27:43,200 --> 17:27:45,436
Realmente fazendo sentido, vamos construir o

26432
17:27:45,436 --> 17:27:46,880
programa novamente

26433
17:27:46,880 --> 17:27:49,276
então vamos usar o gcc

26434
17:27:49,276 --> 17:27:50,720
Você vai ver que o mundo é

26435
17:27:50,720 --> 17:27:53,520
Bom podemos limpar e correr galo we

26436
17:27:53,520 --> 17:27:57,916
deve ver um plus b é 30, mas os valores

26437
17:27:57,916 --> 17:28:01,040
estão ficando dentro da função lambda

26438
17:28:01,040 --> 17:28:03,200
através da nossa lista de captura eles não são

26439
17:28:03,200 --> 17:28:06,080
passando pela lista de parâmetros aqui

26440
17:28:06,080 --> 17:28:08,080
Isso é realmente algo que você precisa ser

26441
17:28:08,080 --> 17:28:09,276
Conscientes de

26442
17:28:09,276 --> 17:28:12,636
Agora que você sabe como funcionam as listas de captura

26443
17:28:12,636 --> 17:28:15,200
Vamos ver que você pode capturar por

26444
17:28:15,200 --> 17:28:17,436
valor ou por referência e nós vamos

26445
17:28:17,436 --> 17:28:20,000
Veja o que isso significa exatamente que estou indo

26446
17:28:20,000 --> 17:28:22,160
para descer aqui e colocar um pedaço de

26447
17:28:22,160 --> 17:28:24,880
código para jogar com captura por valor

26448
17:28:24,880 --> 17:28:27,276
Ok, vamos fazer isso que temos uma variável

26449
17:28:27,276 --> 17:28:30,080
chamado c, o valor é 42

26450
17:28:30,080 --> 17:28:32,320
e nós estabelecemos uma função lambda que é

26451
17:28:32,320 --> 17:28:34,080
indo para capturar c

26452
17:28:34,080 --> 17:28:36,480
com esta sintaxe aqui e este é o

26453
17:28:36,480 --> 17:28:38,480
sintaxe padrão que vimos

26454
17:28:38,480 --> 17:28:40,880
Como fizemos no topo aqui, então estamos indo

26455
17:28:40,880 --> 17:28:43,200
para capturar assim e se fizermos

26456
17:28:43,200 --> 17:28:44,720
Isso nós vamos capturar por

26457
17:28:44,720 --> 17:28:46,720
Valorize o significado disso é que o que

26458
17:28:46,720 --> 17:28:49,276
Temos dentro de nossa função lambda é

26459
17:28:49,276 --> 17:28:51,596
Não será o valor original aqui

26460
17:28:51,596 --> 17:28:54,080
Vai ser uma cópia do que temos

26461
17:28:54,080 --> 17:28:55,116
lá

26462
17:28:55,116 --> 17:28:57,840
O que podemos fazer aqui é usar essa coisa em

26463
17:28:57,840 --> 17:29:00,320
um loop e realmente provar isso

26464
17:29:00,320 --> 17:29:02,796
Então vamos fazer loop cinco vezes a partir de

26465
17:29:02,796 --> 17:29:05,200
zero todo o caminho para quatro, porque isso é

26466
17:29:05,200 --> 17:29:08,000
Indo para ir até que eu não seja mais menos

26467
17:29:08,000 --> 17:29:09,276
do que 5

26468
17:29:09,276 --> 17:29:11,040
E dentro vamos imprimir o

26469
17:29:11,040 --> 17:29:13,116
Valor exterior que vai ser

26470
17:29:13,116 --> 17:29:15,040
O c aqui depois disso vamos

26471
17:29:15,040 --> 17:29:17,116
chamar a nossa função lambda que está indo

26472
17:29:17,116 --> 17:29:18,956
para prever o valor interno no lambda

26473
17:29:18,956 --> 17:29:21,200
Funciona e vamos ver que o

26474
17:29:21,200 --> 17:29:23,916
incrementação que fazemos no exterior

26475
17:29:23,916 --> 17:29:26,000
que vai afetar o valor exterior

26476
17:29:26,000 --> 17:29:28,480
Aqui vai ser visível dentro do

26477
17:29:28,480 --> 17:29:30,720
função lambda aqui e isso não é

26478
17:29:30,720 --> 17:29:32,480
Será o caso da mudança que fazemos

26479
17:29:32,480 --> 17:29:34,956
Aqui não vai ser pego pelo

26480
17:29:34,956 --> 17:29:36,956
Lambda funciona aqui porque o que nós

26481
17:29:36,956 --> 17:29:39,276
O interior é uma cópia, então o que somos

26482
17:29:39,276 --> 17:29:41,596
Ir ver é para o valor exterior para

26483
17:29:41,596 --> 17:29:46,000
ir de 42 43 43 45 e vai para

26484
17:29:46,000 --> 17:29:48,320
Vamos até chegarmos ao fim deste loop

26485
17:29:48,320 --> 17:29:51,116
Aqui, mas o valor interno não está indo

26486
17:29:51,116 --> 17:29:53,520
para mudar porque a mudança que fazemos em

26487
17:29:53,520 --> 17:29:56,400
Aqui não vai afetar a cópia

26488
17:29:56,400 --> 17:29:59,276
que temos em nossa função lambda aqui

26489
17:29:59,276 --> 17:30:01,436
espero que isso faça sentido e novamente se

26490
17:30:01,436 --> 17:30:03,520
Você tem um problema, por favor, certifique-se de que

26491
17:30:03,520 --> 17:30:04,400
Pergunte

26492
17:30:04,400 --> 17:30:05,756
Por meio do

26493
17:30:05,756 --> 17:30:07,916
plataforma do curso e eu vou fazer o melhor i

26494
17:30:07,916 --> 17:30:10,080
pode te ajudar por enquanto estamos indo

26495
17:30:10,080 --> 17:30:12,400
para construir e executar este programa que você vê

26496
17:30:12,400 --> 17:30:15,520
O mundo é bom, então vamos limpar e correr

26497
17:30:15,520 --> 17:30:17,756
Galo que vai ver o valor exterior

26498
17:30:17,756 --> 17:30:21,596
é 43 valor exterior é 43 o valor exterior é

26499
17:30:21,596 --> 17:30:25,520
44 valor externo é 45 o valor externo é

26500
17:30:25,520 --> 17:30:28,880
Mudar, mas o valor interior é ficar

26501
17:30:28,880 --> 17:30:30,560
em 42

26502
17:30:30,560 --> 17:30:32,000
Como você vê aqui

26503
17:30:32,000 --> 17:30:34,240
Espero que isso prove que a exterior

26504
17:30:34,240 --> 17:30:36,880
O valor e o valor interior são dois

26505
17:30:36,880 --> 17:30:39,200
coisas diferentes, mas podemos até mesmo ir

26506
17:30:39,200 --> 17:30:41,680
mais e imprimir os endereços do

26507
17:30:41,680 --> 17:30:43,680
Valor exterior e o valor interno, vamos fazer

26508
17:30:43,680 --> 17:30:44,400
que

26509
17:30:44,400 --> 17:30:47,040
Vamos acrescentar isso à nossa declaração

26510
17:30:47,040 --> 17:30:50,636
aqui e dizer o endereço desse cara

26511
17:30:50,636 --> 17:30:53,040
então nós vamos dizer endereço do exterior

26512
17:30:53,040 --> 17:30:55,916
valor ou dizer endereço de valor interno

26513
17:30:55,916 --> 17:30:57,680
Você pode dizer assim

26514
17:30:57,680 --> 17:31:00,560
para ser realmente descritivo em nosso terminal

26515
17:31:00,560 --> 17:31:02,480
Aqui, então vamos dizer o endereço

26516
17:31:02,480 --> 17:31:03,520
de c

26517
17:31:03,520 --> 17:31:05,596
e no valor exterior vamos

26518
17:31:05,596 --> 17:31:08,160
Adicione outra informação e diga

26519
17:31:08,160 --> 17:31:10,956
endereço do valor exterior e nós vamos

26520
17:31:10,956 --> 17:31:13,360
para dizer o endereço de c

26521
17:31:13,360 --> 17:31:15,276
E isso vai pegar o exterior

26522
17:31:15,276 --> 17:31:17,680
valor que temos aqui e isso é

26523
17:31:17,680 --> 17:31:20,636
vamos usar o valor interior que temos em

26524
17:31:20,636 --> 17:31:22,720
nossa função lambda aqui

26525
17:31:22,720 --> 17:31:24,956
Vamos tentar trabalhar e espero que estes

26526
17:31:24,956 --> 17:31:27,520
Dois abordam o interior e o exterior

26527
17:31:27,520 --> 17:31:29,756
Os endereços serão diferentes

26528
17:31:29,756 --> 17:31:31,756
Isso é o que queremos ver aqui e

26529
17:31:31,756 --> 17:31:34,720
realmente provando que o que temos dentro

26530
17:31:34,720 --> 17:31:37,200
A função lambda é uma cópia através

26531
17:31:37,200 --> 17:31:40,080
O mecanismo de captura, então vamos executar o

26532
17:31:40,080 --> 17:31:42,560
programa o mundo era bom, então o exterior

26533
17:31:42,560 --> 17:31:45,360
valor O endereço é o e4 o interior

26534
17:31:45,360 --> 17:31:48,636
valor que o endereço é de0 que estamos provando

26535
17:31:48,636 --> 17:31:50,720
O que temos dentro do nosso Lambda

26536
17:31:50,720 --> 17:31:54,000
A função é realmente uma cópia, então é assim que

26537
17:31:54,000 --> 17:31:56,796
você pode capturar por valor e isso é

26538
17:31:56,796 --> 17:31:58,956
Vou fazer uma cópia, mas às vezes você

26539
17:31:58,956 --> 17:32:00,956
realmente querer capturar por referência e

26540
17:32:00,956 --> 17:32:02,720
nós vamos ver como você pode fazer isso

26541
17:32:02,720 --> 17:32:05,116
Então vamos comentar o código

26542
17:32:05,116 --> 17:32:07,040
para capturar por valor aqui nós vamos

26543
17:32:07,040 --> 17:32:09,756
Pegue o código e reutilizá-lo porque

26544
17:32:09,756 --> 17:32:11,916
que vai ser muito parecido com o que

26545
17:32:11,916 --> 17:32:14,080
tínhamos antes de dizermos a captura

26546
17:32:14,080 --> 17:32:16,320
por referência, vamos colocar em nosso

26547
17:32:16,320 --> 17:32:18,636
código e vamos mudá-lo um minúsculo

26548
17:32:18,636 --> 17:32:21,200
bit, o que vamos fazer é adicionar um

26549
17:32:21,200 --> 17:32:22,956
ampersand símbolo

26550
17:32:22,956 --> 17:32:25,756
na frente da nossa variável aqui que nós

26551
17:32:25,756 --> 17:32:27,916
Estamos capturando e nós vamos dizer

26552
17:32:27,916 --> 17:32:29,116
ampersand (em-chave)

26553
17:32:29,116 --> 17:32:31,596
No momento em que fazemos isso o que temos

26554
17:32:31,596 --> 17:32:34,240
Dentro da função lambda não é mais

26555
17:32:34,240 --> 17:32:37,040
uma cópia será uma verdadeira referência

26556
17:32:37,040 --> 17:32:40,240
para o valor exterior aqui e agora o

26557
17:32:40,240 --> 17:32:43,360
As mudanças que fazemos em nosso valor exterior são

26558
17:32:43,360 --> 17:32:45,360
Vai ser visível dentro do lambda

26559
17:32:45,360 --> 17:32:47,116
Função aqui e você vai ver

26560
17:32:47,116 --> 17:32:49,596
Os endereços são os mesmos

26561
17:32:49,596 --> 17:32:51,840
Vamos construir e realmente ver isso nós somos

26562
17:32:51,840 --> 17:32:54,720
usar o gcc para construir nosso programa

26563
17:32:54,720 --> 17:32:57,200
O mundo é bom que podemos limpar agora e

26564
17:32:57,200 --> 17:32:59,596
correr galo e nós vamos ver isso

26565
17:32:59,596 --> 17:33:02,720
o valor exterior, vamos ter certeza de que temos

26566
17:33:02,720 --> 17:33:05,436
alguns espaços depois desses caras e vamos

26567
17:33:05,436 --> 17:33:08,080
subir e fazer isso e ambos novamente, porque

26568
17:33:08,080 --> 17:33:10,080
As coisas estão realmente apertadas juntas e eu

26569
17:33:10,080 --> 17:33:11,436
Não gosto disto.

26570
17:33:11,436 --> 17:33:13,520
para que o impulso seja bom, podemos limpar e

26571
17:33:13,520 --> 17:33:14,880
correr o galo

26572
17:33:14,880 --> 17:33:16,720
Vamos ver o valor exterior

26573
17:33:16,720 --> 17:33:18,560
E o valor interno está mudando

26574
17:33:18,560 --> 17:33:21,436
juntos e os endereços são agora o

26575
17:33:21,436 --> 17:33:22,400
O mesmo

26576
17:33:22,400 --> 17:33:25,276
porque capturamos por referência

26577
17:33:25,276 --> 17:33:27,840
O valor interno e o valor exterior são

26578
17:33:27,840 --> 17:33:30,320
referenciando a mesma variável que temos

26579
17:33:30,320 --> 17:33:32,796
Por fora, isso é realmente tudo o que estabelecemos

26580
17:33:32,796 --> 17:33:34,560
para fazer nesta palestra eu espero que você

26581
17:33:34,560 --> 17:33:37,116
Achei interessante que a ideia principal era

26582
17:33:37,116 --> 17:33:39,596
O mecanismo de captura que temos com o nosso

26583
17:33:39,596 --> 17:33:42,080
funções lambda para capturar graças

26584
17:33:42,080 --> 17:33:45,200
Fora do contexto das funções lambda

26585
17:33:45,200 --> 17:33:47,756
podemos capturar especificando uma vírgula

26586
17:33:47,756 --> 17:33:50,000
separado da lista das variáveis

26587
17:33:50,000 --> 17:33:52,240
que queremos capturar e temos a

26588
17:33:52,240 --> 17:33:54,880
opção para capturar por valor

26589
17:33:54,880 --> 17:33:55,916
usando

26590
17:33:55,916 --> 17:33:57,916
a variável diretamente na captura

26591
17:33:57,916 --> 17:34:01,200
lista como fazemos aqui ou através da preparação de

26592
17:34:01,200 --> 17:34:03,756
ampersand símbolo aqui e capturar por

26593
17:34:03,756 --> 17:34:05,916
Referência e você vai ter que

26594
17:34:05,916 --> 17:34:07,916
Escolher qual a maneira que você quiser capturar

26595
17:34:07,916 --> 17:34:10,480
suas variáveis agora que você conhece

26596
17:34:10,480 --> 17:34:12,320
Todas essas opções aqui

26597
17:34:12,320 --> 17:34:13,916
Vamos parar aqui neste

26598
17:34:13,916 --> 17:34:15,680
palestra no próximo, vamos

26599
17:34:15,680 --> 17:34:18,320
Veja como podemos capturar tudo de

26600
17:34:18,320 --> 17:34:20,480
O contexto externo para o lambda

26601
17:34:20,480 --> 17:34:21,596
A função

26602
17:34:21,596 --> 17:34:23,520
Vá em frente e termine aqui

26603
17:34:23,520 --> 17:34:25,756
e encontrar-me lá na última palestra

26604
17:34:25,756 --> 17:34:28,320
Vi que poderíamos capturar coisas lá fora

26605
17:34:28,320 --> 17:34:31,040
o contexto da função lambda agora

26606
17:34:31,040 --> 17:34:32,720
Queremos ver que podemos capturar

26607
17:34:32,720 --> 17:34:36,320
Tudo vivendo fora do contexto de

26608
17:34:36,320 --> 17:34:38,480
A função lambda da sintaxe a fazer

26609
17:34:38,480 --> 17:34:41,276
Isso é ridiculamente simples se você quiser

26610
17:34:41,276 --> 17:34:44,560
para capturar tudo por valor você apenas

26611
17:34:44,560 --> 17:34:46,720
Coloque um sinal igual em seu lambda

26612
17:34:46,720 --> 17:34:48,880
lista de captura de função e se você fizer

26613
17:34:48,880 --> 17:34:50,880
Algo assim agora você vai

26614
17:34:50,880 --> 17:34:53,360
ter acesso a tudo fora do

26615
17:34:53,360 --> 17:34:55,436
Alcance da função lambda, por exemplo

26616
17:34:55,436 --> 17:34:57,680
podemos acessar a variável c aqui a partir de

26617
17:34:57,680 --> 17:35:00,400
A função lambda mas se tivermos alguma

26618
17:35:00,400 --> 17:35:02,956
Mais variáveis declaradas fora do

26619
17:35:02,956 --> 17:35:05,040
âmbito da função lambda, vamos

26620
17:35:05,040 --> 17:35:08,320
ter acesso a eles dentro do nosso Lambda

26621
17:35:08,320 --> 17:35:11,596
Função aqui novamente, isso é ativado por

26622
17:35:11,596 --> 17:35:14,320
a sintaxe que usamos aqui, colocando

26623
17:35:14,320 --> 17:35:17,040
um sinal de igual dentro de uma função lambda

26624
17:35:17,040 --> 17:35:19,360
note que se você usar o sinal de igual

26625
17:35:19,360 --> 17:35:21,276
Como nós fazemos aqui nós vamos ser

26626
17:35:21,276 --> 17:35:23,916
capturando por valor o que temos dentro

26627
17:35:23,916 --> 17:35:25,596
A função lambda vai ser um

26628
17:35:25,596 --> 17:35:28,400
copiar se você não quiser capturar todos por

26629
17:35:28,400 --> 17:35:31,840
valor que você pode capturar todos por referência

26630
17:35:31,840 --> 17:35:34,400
e novamente a sintaxe é realmente simples

26631
17:35:34,400 --> 17:35:37,040
Tudo que você tem a fazer é colocar um ampersand

26632
17:35:37,040 --> 17:35:39,840
símbolo dentro de sua lista de captura

26633
17:35:39,840 --> 17:35:41,436
momento em que você faz isso, você vai ter

26634
17:35:41,436 --> 17:35:44,636
acesso a tudo fora do contexto

26635
17:35:44,636 --> 17:35:47,040
de sua função lambda, mas isso está indo

26636
17:35:47,040 --> 17:35:49,680
ser por referência o que você tem dentro

26637
17:35:49,680 --> 17:35:51,756
A função lambda será verdadeira

26638
17:35:51,756 --> 17:35:55,276
referências às variáveis externas e

26639
17:35:55,276 --> 17:35:58,796
Você pode fazer coisas muito desagradáveis com eles

26640
17:35:58,796 --> 17:36:00,636
Porque as mudanças que você faz dentro do

26641
17:36:00,636 --> 17:36:02,720
A função lambda será visível

26642
17:36:02,720 --> 17:36:05,520
fora da função lambda e qualquer

26643
17:36:05,520 --> 17:36:07,436
A mudança que você faz do lado de fora também é

26644
17:36:07,436 --> 17:36:09,840
Vai ser visível dentro do lambda

26645
17:36:09,840 --> 17:36:12,080
função para que, se você fizer isso, certifique-se

26646
17:36:12,080 --> 17:36:14,240
Isto é o que você quer e você pode usar

26647
17:36:14,240 --> 17:36:16,720
Isso para sua vantagem ok agora que você

26648
17:36:16,720 --> 17:36:18,320
Eu sei que vamos nos dirigir para

26649
17:36:18,320 --> 17:36:20,080
código de estúdio visual e jogar com a gente um

26650
17:36:20,080 --> 17:36:22,796
Um pouco mais bem aqui estamos em nosso

26651
17:36:22,796 --> 17:36:25,040
pasta de trabalho o projeto atual é

26652
17:36:25,040 --> 17:36:28,080
Capture todas as listas para onde vamos

26653
17:36:28,080 --> 17:36:31,360
pegar nossos arquivos de modelo muito rápido e

26654
17:36:31,360 --> 17:36:33,436
nós vamos colocá-los no lugar e

26655
17:36:33,436 --> 17:36:35,436
nós vamos abrir este pequeno rapaz dentro

26656
17:36:35,436 --> 17:36:37,840
Código de estúdio visual, vamos fazer isso

26657
17:36:37,840 --> 17:36:40,160
Vou ter nossa pasta aberta, podemos

26658
17:36:40,160 --> 17:36:43,840
abrir o nosso arquivo cpp principal, limpe-o como

26659
17:36:43,840 --> 17:36:46,160
Fazemos sempre e vamos fechar

26660
17:36:46,160 --> 17:36:48,000
o painel esquerdo aqui a primeira coisa que nós

26661
17:36:48,000 --> 17:36:50,320
Quer fazer é capturar tudo

26662
17:36:50,320 --> 17:36:51,916
valor e vamos colocar o código

26663
17:36:51,916 --> 17:36:54,400
para fazer isso que deve ser muito fácil

26664
17:36:54,400 --> 17:36:56,956
Entenda de vez em quando a sintaxe

26665
17:36:56,956 --> 17:36:59,840
para capturar tudo pelo valor é por

26666
17:36:59,840 --> 17:37:02,720
colocando um sinal igual dentro do seu

26667
17:37:02,720 --> 17:37:05,040
lista de capturas que você tem que colocar isso dentro

26668
17:37:05,040 --> 17:37:07,116
Estes brackets de ângulo e que vai

26669
17:37:07,116 --> 17:37:09,436
Capture tudo pelo valor agora se

26670
17:37:09,436 --> 17:37:11,200
executamos o programa que vamos ver

26671
17:37:11,200 --> 17:37:14,320
que c foi capturado pelo valor se nós

26672
17:37:14,320 --> 17:37:15,916
Olhe ao redor, vamos ver que

26673
17:37:15,916 --> 17:37:17,840
O valor exterior vai para

26674
17:37:17,840 --> 17:37:20,400
mudança, mas o valor interno vai

26675
17:37:20,400 --> 17:37:22,880
permanecer o mesmo, é o mesmo comportamento

26676
17:37:22,880 --> 17:37:24,796
Já vimos antes capturando por

26677
17:37:24,796 --> 17:37:26,796
valor, então vamos construir de novo, estamos indo

26678
17:37:26,796 --> 17:37:29,436
para construir com gcc o mundo é bom

26679
17:37:29,436 --> 17:37:31,916
pode limpar e uh trazer um terminal assim

26680
17:37:31,916 --> 17:37:34,160
que podemos limpar corretamente, então vamos fazer

26681
17:37:34,160 --> 17:37:37,116
clear e run galo agora vemos que

26682
17:37:37,116 --> 17:37:39,436
O valor exterior está mudando, mas o

26683
17:37:39,436 --> 17:37:42,796
O valor interno não está mudando e novamente

26684
17:37:42,796 --> 17:37:46,160
esta é a captura clássica por valor se

26685
17:37:46,160 --> 17:37:48,796
você quer capturar tudo por referência

26686
17:37:48,796 --> 17:37:50,796
você vai usar o símbolo ampersand

26687
17:37:50,796 --> 17:37:52,160
Aqui e vamos fazer isso, vamos

26688
17:37:52,160 --> 17:37:55,040
comente isso e nós vamos levar

26689
17:37:55,040 --> 17:37:57,360
Isto para fora e uh

26690
17:37:57,360 --> 17:38:00,000
usar o código aqui que podemos fazer que somos

26691
17:38:00,000 --> 17:38:02,560
indo para baixo e colocar em um código e

26692
17:38:02,560 --> 17:38:05,360
Digamos que estamos capturando por referência

26693
17:38:05,360 --> 17:38:08,480
devemos dizer capturar tudo por referência

26694
17:38:08,480 --> 17:38:11,200
E tudo o que temos que fazer para fazer isso funcionar

26695
17:38:11,200 --> 17:38:14,000
por referência é colocar nossa ampersand

26696
17:38:14,000 --> 17:38:17,520
símbolo dentro deste suporte de ângulo aqui

26697
17:38:17,520 --> 17:38:19,200
E isso vai capturar tudo

26698
17:38:19,200 --> 17:38:21,360
por referência se corrermos agora vamos

26699
17:38:21,360 --> 17:38:23,040
para ver que as mudanças que fazemos a partir do

26700
17:38:23,040 --> 17:38:25,596
O exterior será visível a partir do

26701
17:38:25,596 --> 17:38:26,956
Por dentro aqui

26702
17:38:26,956 --> 17:38:29,756
Vamos soldar com gcc e ver que este é

26703
17:38:29,756 --> 17:38:32,400
Na verdade, o caso o parafuso é bom como

26704
17:38:32,400 --> 17:38:35,116
você vê aqui nós podemos limpar e correr o

26705
17:38:35,116 --> 17:38:36,796
Galo vamos ver que

26706
17:38:36,796 --> 17:38:40,400
O valor exterior é 42 o valor exterior é

26707
17:38:40,400 --> 17:38:42,880
A mudança e o valor interior está mudando

26708
17:38:42,880 --> 17:38:46,480
como você vê em nossa produção aqui e isso

26709
17:38:46,480 --> 17:38:48,480
é realmente como você pode capturar

26710
17:38:48,480 --> 17:38:51,116
por referência apenas para brincar com isso

26711
17:38:51,116 --> 17:38:52,560
Vamos configurar outra variável

26712
17:38:52,560 --> 17:38:55,756
chamar isso d e nós vamos dizê-lo

26713
17:38:55,756 --> 17:38:58,240
contém um 5 e nós podemos tentar imprimir

26714
17:38:58,240 --> 17:39:00,480
que dentro do nosso valor interior aqui e isso

26715
17:39:00,480 --> 17:39:02,000
Vai trabalhar você vai ver

26716
17:39:02,000 --> 17:39:04,000
que foi capturado, podemos dizer

26717
17:39:04,000 --> 17:39:07,040
Oddc out value interior vamos dizer que

26718
17:39:07,040 --> 17:39:09,360
é a variável d que estamos tentando

26719
17:39:09,360 --> 17:39:12,080
acesso aqui e vamos dizer d e

26720
17:39:12,080 --> 17:39:14,480
vai ser visível dentro do nosso

26721
17:39:14,480 --> 17:39:16,636
função lambda aqui porque era

26722
17:39:16,636 --> 17:39:19,520
capturado por referência aqui vamos construir

26723
17:39:19,520 --> 17:39:22,480
Mais uma vez vamos usar gcc para fazer isso

26724
17:39:22,480 --> 17:39:24,956
o parafuso é bom nós podemos limpar e se nós

26725
17:39:24,956 --> 17:39:27,840
impulsionador de corrida, devemos ver d impresso para fora

26726
17:39:27,840 --> 17:39:29,520
Várias vezes d

26727
17:39:29,520 --> 17:39:30,240
D

26728
17:39:30,240 --> 17:39:30,880
D

26729
17:39:30,880 --> 17:39:34,160
d e somos capazes de acessá-lo através de

26730
17:39:34,160 --> 17:39:36,400
O mecanismo de captura e nós somos

26731
17:39:36,400 --> 17:39:39,200
Capturando tudo no contexto

26732
17:39:39,200 --> 17:39:41,520
referência aqui é realmente tudo que nós estabelecemos

26733
17:39:41,520 --> 17:39:43,276
para fazer nesta palestra eu espero que você

26734
17:39:43,276 --> 17:39:45,756
Achei interessante eu odeio dizer isso

26735
17:39:45,756 --> 17:39:48,560
Mas esta é a última palestra

26736
17:39:48,560 --> 17:39:50,956
Neste capítulo sobre funções lambda nós

26737
17:39:50,956 --> 17:39:53,200
Ainda tem muito para aprender sobre lambda

26738
17:39:53,200 --> 17:39:55,680
Funções, mas infelizmente não

26739
17:39:55,680 --> 17:39:57,756
realmente ter ferramentas suficientes para entender

26740
17:39:57,756 --> 17:39:59,840
Isso agora, mas por agora vamos parar

26741
17:39:59,840 --> 17:40:01,436
Aqui e aprender um pouco mais de coisas

26742
17:40:01,436 --> 17:40:03,436
sobre c plus plus, então nós vamos

26743
17:40:03,436 --> 17:40:05,916
Volte e veja algumas coisas loucas que você

26744
17:40:05,916 --> 17:40:08,880
pode realmente fazer com lambda funções i

26745
17:40:08,880 --> 17:40:10,720
Gostaria de recebê-lo neste novo

26746
17:40:10,720 --> 17:40:12,560
capítulo onde vamos aprender

26747
17:40:12,560 --> 17:40:14,956
sobre função de modelos de função

26748
17:40:14,956 --> 17:40:18,000
templates são um mecanismo que temos em c

26749
17:40:18,000 --> 17:40:21,596
mais para configurar o blueprint para funções

26750
17:40:21,596 --> 17:40:24,720
e ter um ponto de controle para configurar

26751
17:40:24,720 --> 17:40:26,560
a função mas o compilador está indo

26752
17:40:26,560 --> 17:40:28,720
para gerar a função real que

26753
17:40:28,720 --> 17:40:31,276
é chamado quando vê a função

26754
17:40:31,276 --> 17:40:33,116
Chamar para que isso vai resolver o

26755
17:40:33,116 --> 17:40:35,276
Problema que tivemos antes com função

26756
17:40:35,276 --> 17:40:37,276
sobrecargas se você olhar para o código aqui

26757
17:40:37,276 --> 17:40:39,596
Temos várias sobrecargas para o

26758
17:40:39,596 --> 17:40:42,400
função máxima, mas o que realmente somos

26759
17:40:42,400 --> 17:40:45,436
fazer no corpo dessas funções

26760
17:40:45,436 --> 17:40:48,636
É o mesmo e suponha que você tenha

26761
17:40:48,636 --> 17:40:51,840
12 ou 13 ou 20 sobrecargas do mesmo

26762
17:40:51,840 --> 17:40:53,840
Função que você vai ser basicamente

26763
17:40:53,840 --> 17:40:56,320
Repetindo a mesma lógica nos corpos

26764
17:40:56,320 --> 17:40:58,080
desta função e deste código

26765
17:40:58,080 --> 17:41:00,956
repetição é má função templates são

26766
17:41:00,956 --> 17:41:02,720
Um esforço para

26767
17:41:02,720 --> 17:41:05,040
resolver problemas como este da maneira que eles

26768
17:41:05,040 --> 17:41:06,956
trabalho que você criou um modelo para o seu

26769
17:41:06,956 --> 17:41:09,520
função e esta é a sintaxe a fazer

26770
17:41:09,520 --> 17:41:12,080
Algo assim que você diz modelo

26771
17:41:12,080 --> 17:41:14,480
nome do tipo não aqui não se preocupe com isso

26772
17:41:14,480 --> 17:41:16,000
sintaxe, vamos ter uma chance de

26773
17:41:16,000 --> 17:41:19,200
passar por isso em detalhes, mas se você fizer isso

26774
17:41:19,200 --> 17:41:21,436
Coisas como essa, isso vai ser um

26775
17:41:21,436 --> 17:41:24,400
blueprint para sua função máxima e

26776
17:41:24,400 --> 17:41:26,320
O compilador vai usar isso

26777
17:41:26,320 --> 17:41:30,000
blueprint para gerar uma função real

26778
17:41:30,000 --> 17:41:31,756
quando você chama essa função e isso é

26779
17:41:31,756 --> 17:41:34,000
Vou fazer as coisas super fáceis eu

26780
17:41:34,000 --> 17:41:36,160
Percebi que parte disso é realmente enigmático

26781
17:41:36,160 --> 17:41:39,116
então vamos para a próxima palestra

26782
17:41:39,116 --> 17:41:41,596
e deixe você configurar o seu primeiro

26783
17:41:41,596 --> 17:41:44,080
modelo de função vá em frente e termine

26784
17:41:44,080 --> 17:41:46,636
Aqui e encontre-me lá nesta palestra

26785
17:41:46,636 --> 17:41:49,040
Vamos montar o nosso primeiro

26786
17:41:49,040 --> 17:41:51,436
modelo de função e novamente função

26787
17:41:51,436 --> 17:41:54,240
templates são um mecanismo que temos em c

26788
17:41:54,240 --> 17:41:57,200
mais plus para evitar a repetição de código para

26789
17:41:57,200 --> 17:42:00,000
Exemplo se você estiver configurando a função

26790
17:42:00,000 --> 17:42:02,880
sobrecargas se você olhar aqui nós temos o nosso

26791
17:42:02,880 --> 17:42:05,520
max função e nós temos múltiplos

26792
17:42:05,520 --> 17:42:07,680
sobrecargas para esta função que podemos chamar

26793
17:42:07,680 --> 17:42:10,880
ele com e dupla e string view aqui

26794
17:42:10,880 --> 17:42:12,956
Mas se você olhar para dentro você vê que nós

26795
17:42:12,956 --> 17:42:15,680
Realmente estão repetindo a mesma lógica

26796
17:42:15,680 --> 17:42:18,240
e é até possível ter dezenas de

26797
17:42:18,240 --> 17:42:21,596
de sobrecargas se você quiser suportar toneladas

26798
17:42:21,596 --> 17:42:23,680
Tipos para sua função

26799
17:42:23,680 --> 17:42:27,040
E esta repetição de código é realmente ruim

26800
17:42:27,040 --> 17:42:29,276
Os modelos de função são um mecanismo que

26801
17:42:29,276 --> 17:42:32,000
ter no lugar para evitar coisas como esta

26802
17:42:32,000 --> 17:42:33,520
e o que você faz

26803
17:42:33,520 --> 17:42:36,160
você configura um blueprint de função usando

26804
17:42:36,160 --> 17:42:38,560
A sintaxe que você vê aqui e seu

26805
17:42:38,560 --> 17:42:40,160
O modelo de função vai ser

26806
17:42:40,160 --> 17:42:41,596
prefixado

26807
17:42:41,596 --> 17:42:44,240
com este tipo de modelo de dentes e

26808
17:42:44,240 --> 17:42:46,796
Aqui o nome do tipo t vai estar neste

26809
17:42:46,796 --> 17:42:48,560
suportes de ângulo

26810
17:42:48,560 --> 17:42:50,000
e então você vai colocar o

26811
17:42:50,000 --> 17:42:53,040
blueprint para sua função t é a

26812
17:42:53,040 --> 17:42:55,436
espaço reservado para os tipos que você usa

26813
17:42:55,436 --> 17:42:58,560
em sua função você vê que t está em

26814
17:42:58,560 --> 17:43:01,436
O tipo de retorno aqui está no

26815
17:43:01,436 --> 17:43:03,756
parâmetros que passamos para a função

26816
17:43:03,756 --> 17:43:05,360
E porque é o mesmo personagem

26817
17:43:05,360 --> 17:43:07,436
Aqui todas essas coisas têm que ser do

26818
17:43:07,436 --> 17:43:09,276
mesmo tipo do tipo de retorno o primeiro

26819
17:43:09,276 --> 17:43:11,680
parâmetro o segundo parâmetro que eles têm

26820
17:43:11,680 --> 17:43:14,400
para ser do mesmo tipo, tudo bem, então uma vez

26821
17:43:14,400 --> 17:43:16,320
ter o seu modelo de função configurado como

26822
17:43:16,320 --> 17:43:17,916
Isso você vai implementá-lo como

26823
17:43:17,916 --> 17:43:20,480
Vemos lá embaixo aqui não é nada

26824
17:43:20,480 --> 17:43:23,200
complicado, acabamos de configurar o protótipo

26825
17:43:23,200 --> 17:43:25,116
para a função no topo

26826
17:43:25,116 --> 17:43:27,680
E dentro, colocamos nossa implementação você

26827
17:43:27,680 --> 17:43:30,240
Veja aqui nós separamos isso em

26828
17:43:30,240 --> 17:43:32,320
declaração e função da função

26829
17:43:32,320 --> 17:43:34,796
definição, mas dentro você vê que é

26830
17:43:34,796 --> 17:43:37,520
A mesma lógica que tínhamos para calcular o nosso

26831
17:43:37,520 --> 17:43:39,916
máximo entre estes dois parâmetros

26832
17:43:39,916 --> 17:43:42,720
que passamos para esta função

26833
17:43:42,720 --> 17:43:45,596
como isso funciona quando o compilador

26834
17:43:45,596 --> 17:43:48,956
você chama isso de função máxima para

26835
17:43:48,956 --> 17:43:51,916
Um exemplo como estamos fazendo aqui está indo

26836
17:43:51,916 --> 17:43:54,240
para olhar para os tipos que você passa

26837
17:43:54,240 --> 17:43:56,796
e neste caso a e b

26838
17:43:56,796 --> 17:43:59,436
são do tipo de formila, então ele vai

26839
17:43:59,436 --> 17:44:03,520
substituir o t aqui e é

26840
17:44:03,520 --> 17:44:05,840
vai gerar uma função inicial

26841
17:44:05,840 --> 17:44:06,880
o código

26842
17:44:06,880 --> 17:44:08,880
E isso realmente traz um grande ponto

26843
17:44:08,880 --> 17:44:10,720
sobre modelos de função muitas pessoas

26844
17:44:10,720 --> 17:44:13,520
Pense que os modelos de função são reais

26845
17:44:13,520 --> 17:44:16,160
c plus código que eles não são

26846
17:44:16,160 --> 17:44:18,796
apenas um blueprint do qual o compilador

26847
17:44:18,796 --> 17:44:21,840
vai gerar a função real

26848
17:44:21,840 --> 17:44:23,596
que é chamado pelo compilador para

26849
17:44:23,596 --> 17:44:26,560
Um exemplo quando você emite uma chamada como essa

26850
17:44:26,560 --> 17:44:27,436
Mais uma vez

26851
17:44:27,436 --> 17:44:29,520
Modelos de função não são reais c plus

26852
17:44:29,520 --> 17:44:32,720
além do código, eles são apenas um projeto que

26853
17:44:32,720 --> 17:44:35,040
o compilador usa para gerar seu

26854
17:44:35,040 --> 17:44:36,080
A função

26855
17:44:36,080 --> 17:44:38,400
baseado nos argumentos que você passa para o

26856
17:44:38,400 --> 17:44:40,720
Função quando você chama isso quando nós

26857
17:44:40,720 --> 17:44:43,276
emitir o chamado como fazemos aqui um int

26858
17:44:43,276 --> 17:44:45,596
A versão da nossa função máxima está indo

26859
17:44:45,596 --> 17:44:47,680
para ser criado para que o compilador seja

26860
17:44:47,680 --> 17:44:50,560
basicamente indo para entrar e substituir n

26861
17:44:50,560 --> 17:44:52,796
e para t aqui o tipo de retorno está indo

26862
17:44:52,796 --> 17:44:54,636
Para ser ent o primeiro parâmetro vai

26863
17:44:54,636 --> 17:44:56,400
estar no fim, o segundo parâmetro vai

26864
17:44:56,400 --> 17:44:57,680
estar vazio, ele vai entrar

26865
17:44:57,680 --> 17:44:59,436
Definição vai fazer isso e

26866
17:44:59,436 --> 17:45:01,436
nós vamos ter uma função

26867
17:45:01,436 --> 17:45:04,240
se emitirmos uma chamada com c e d como

26868
17:45:04,240 --> 17:45:06,636
Faz aqui na segunda linha, então

26869
17:45:06,636 --> 17:45:09,200
O compilador vai ver que c e d

26870
17:45:09,200 --> 17:45:11,436
são de tipo duplo, então ele vai

26871
17:45:11,436 --> 17:45:13,360
gerar outra função a partir disso

26872
17:45:13,360 --> 17:45:14,956
plano aqui e vai

26873
17:45:14,956 --> 17:45:17,276
substituir em dupla, então vamos

26874
17:45:17,276 --> 17:45:19,596
ter outra dupla função se formos

26875
17:45:19,596 --> 17:45:21,040
A terceira linha aqui vamos fazer

26876
17:45:21,040 --> 17:45:22,636
O mesmo vamos chamá-lo com

26877
17:45:22,636 --> 17:45:24,956
forças e vai gerar um

26878
17:45:24,956 --> 17:45:27,680
versão em cadeia da função máxima

26879
17:45:27,680 --> 17:45:30,560
Aqui, o que alcançamos com função

26880
17:45:30,560 --> 17:45:33,040
Os modelos são para evitar

26881
17:45:33,040 --> 17:45:35,360
várias sobrecargas para a mesma função

26882
17:45:35,360 --> 17:45:37,520
e nós temos um ponto de controle em nosso

26883
17:45:37,520 --> 17:45:40,560
código, mas o compilador ainda está indo para

26884
17:45:40,560 --> 17:45:43,276
gerar essas sobrecargas de função, mas uma

26885
17:45:43,276 --> 17:45:45,276
Uma coisa sobre isso é que se uma função

26886
17:45:45,276 --> 17:45:47,436
Não é usado, por exemplo, se você nunca

26887
17:45:47,436 --> 17:45:50,480
chamar uma função máxima com string

26888
17:45:50,480 --> 17:45:52,240
então a versão string nunca vai

26889
17:45:52,240 --> 17:45:54,636
para ser criado o compilador está indo para

26890
17:45:54,636 --> 17:45:57,276
gerar as sobrecargas que você apenas

26891
17:45:57,276 --> 17:45:59,436
chamar em seu programa c plus plus e

26892
17:45:59,436 --> 17:46:01,596
isso é realmente todos os modelos de função

26893
17:46:01,596 --> 17:46:04,160
são tudo sobre eles lhe dão um mecanismo

26894
17:46:04,160 --> 17:46:06,320
para configurar um modelo para sua função

26895
17:46:06,320 --> 17:46:07,840
e então o compilador vai

26896
17:46:07,840 --> 17:46:11,116
gerar funções reais baseadas no que

26897
17:46:11,116 --> 17:46:13,360
você chamar seu c plus mais código OK

26898
17:46:13,360 --> 17:46:14,796
Nós salvamos isso, mas eu quero

26899
17:46:14,796 --> 17:46:16,796
Enfatize isso novamente

26900
17:46:16,796 --> 17:46:19,596
Os modelos de função são apenas blueprints

26901
17:46:19,596 --> 17:46:22,796
eles não são reais c plus plus poderia e

26902
17:46:22,796 --> 17:46:24,480
quando atingimos código de estúdio visual em um

26903
17:46:24,480 --> 17:46:26,400
minuto vamos ver uma ferramenta

26904
17:46:26,400 --> 17:46:29,520
que nos permite ver como é que o compilador

26905
17:46:29,520 --> 17:46:32,480
instancia seus modelos de função

26906
17:46:32,480 --> 17:46:35,116
baseado nos argumentos que você chama de

26907
17:46:35,116 --> 17:46:37,916
Funcionar com mas tenha isso em mente

26908
17:46:37,916 --> 17:46:40,160
Modelos de função não são reais c plus

26909
17:46:40,160 --> 17:46:43,276
mais código das funções rio c plus plus

26910
17:46:43,276 --> 17:46:45,520
ser gerado pelo compilador

26911
17:46:45,520 --> 17:46:47,916
quando você chama sua função e outra

26912
17:46:47,916 --> 17:46:50,636
O que eu queria apontar é que

26913
17:46:50,636 --> 17:46:53,680
uma vez que uma instância de modelo de função é

26914
17:46:53,680 --> 17:46:55,680
gerados, por exemplo, a interversão

26915
17:46:55,680 --> 17:46:59,276
de nosso modelo de função máximo, então se

26916
17:46:59,276 --> 17:47:01,200
é necessário novamente o compilador não é

26917
17:47:01,200 --> 17:47:03,276
vai gerar isso novamente, está indo

26918
17:47:03,276 --> 17:47:05,680
para ver se já existe um gerador

26919
17:47:05,680 --> 17:47:07,756
e vai reutilizar isso ok

26920
17:47:07,756 --> 17:47:09,436
é realmente tudo que eu tenho que compartilhar sobre

26921
17:47:09,436 --> 17:47:11,916
modelos de função neste momento

26922
17:47:11,916 --> 17:47:14,000
capítulo por enquanto vamos nos dirigir

26923
17:47:14,000 --> 17:47:15,916
para código de estúdio visual e jogar com isso

26924
17:47:15,916 --> 17:47:18,796
um pouco mais bem aqui estamos em nosso

26925
17:47:18,796 --> 17:47:21,360
diretório de trabalho do projeto atual é

26926
17:47:21,360 --> 17:47:23,116
experimentando modelos de função que nós somos

26927
17:47:23,116 --> 17:47:25,916
vamos pegar nosso projeto de modelo e

26928
17:47:25,916 --> 17:47:27,756
Uma coisa que eu devo apontar aqui é

26929
17:47:27,756 --> 17:47:30,320
que o nosso projeto de template já foi

26930
17:47:30,320 --> 17:47:34,080
Atualizado para ter o arquivo launch.json

26931
17:47:34,080 --> 17:47:36,000
que nos permitirá depurar o nosso

26932
17:47:36,000 --> 17:47:38,636
programas para que você use um modelo

26933
17:47:38,636 --> 17:47:41,520
que inclui o arquivo launch.json aqui

26934
17:47:41,520 --> 17:47:43,276
que vai nos permitir depurar seu

26935
17:47:43,276 --> 17:47:45,276
programas e nós vamos fazer isso em um

26936
17:47:45,276 --> 17:47:47,360
minuto em que temos dado o exemplo

26937
17:47:47,360 --> 17:47:49,840
Então nós vamos pegar o nosso modelo

26938
17:47:49,840 --> 17:47:52,880
arquiva e colocá-los no lugar e nós estamos

26939
17:47:52,880 --> 17:47:54,956
Vou abrir esse garrinho em visual

26940
17:47:54,956 --> 17:47:57,520
código de estúdio arrastando e soltando

26941
17:47:57,520 --> 17:48:00,320
No topo, isso vai fazer o nosso trabalho

26942
17:48:00,320 --> 17:48:02,320
então nós vamos abrir o cpp principal

26943
17:48:02,320 --> 17:48:04,400
arquivo e eu acho que devemos fechar o

26944
17:48:04,400 --> 17:48:06,560
Pane esquerdo aqui nós não precisamos mais disso

26945
17:48:06,560 --> 17:48:07,916
e nós vamos limpar isso

26946
17:48:07,916 --> 17:48:10,240
Um pouquinho, então uma coisa que eu quero fazer é

26947
17:48:10,240 --> 17:48:12,400
Para primeiro fazer as coisas da maneira ruim, então nós somos

26948
17:48:12,400 --> 17:48:14,400
Vou configurar uma função máxima

26949
17:48:14,400 --> 17:48:16,560
Vamos chamar isso de máximo

26950
17:48:16,560 --> 17:48:18,956
e vai tomar parâmetros finais

26951
17:48:18,956 --> 17:48:21,596
E vamos devolver o máximo

26952
17:48:21,596 --> 17:48:23,436
Entre a e b e a maneira como fazemos isso

26953
17:48:23,436 --> 17:48:26,320
Dizemos um maior que b nós vamos

26954
17:48:26,320 --> 17:48:28,160
usar nosso operador ternário aqui estamos

26955
17:48:28,160 --> 17:48:29,680
Vou colocar um ponto de interrogação que vamos

26956
17:48:29,680 --> 17:48:32,480
para retornar a ou b e isso vai ser

26957
17:48:32,480 --> 17:48:34,796
nossa função, mas suponha que precisamos de outro

26958
17:48:34,796 --> 17:48:38,000
A função que funciona em duplas se colocarmos

26959
17:48:38,000 --> 17:48:40,240
argumentos duplos aqui o compilador é

26960
17:48:40,240 --> 17:48:42,636
indo para inserir conversões implícitas

26961
17:48:42,636 --> 17:48:45,436
do duplo para o fim, isso pode parecer funcionar

26962
17:48:45,436 --> 17:48:48,880
Mas suponha que você use um tipo de parâmetro

26963
17:48:48,880 --> 17:48:50,720
que não é conversível para acabar

26964
17:48:50,720 --> 17:48:52,796
Um exemplo, você usa uma string ou algo assim

26965
17:48:52,796 --> 17:48:54,840
Vamos colocar em std string

26966
17:48:54,840 --> 17:48:57,680
Aqui apenas por exemplo, então vamos

26967
17:48:57,680 --> 17:49:01,200
para dizer força máxima de std

26968
17:49:01,200 --> 17:49:04,400
a e std força b

26969
17:49:04,400 --> 17:49:06,080
e devemos fazer esses const

26970
17:49:06,080 --> 17:49:08,560
Referências porque não estamos interessados

26971
17:49:08,560 --> 17:49:11,360
em modificar essas strings aqui

26972
17:49:11,360 --> 17:49:13,436
Vamos terminar o nome aqui

26973
17:49:13,436 --> 17:49:16,160
e nós vamos dizer const std string

26974
17:49:16,160 --> 17:49:18,320
referência a isso é muito melhor é

26975
17:49:18,320 --> 17:49:20,560
evitar cópias desnecessárias de

26976
17:49:20,560 --> 17:49:23,436
strings e nós vamos dizer const ht

26977
17:49:23,436 --> 17:49:25,116
referência de string

26978
17:49:25,116 --> 17:49:27,840
Estar aqui dentro, não vamos

26979
17:49:27,840 --> 17:49:29,680
fazer algo diferente nós estamos apenas indo

26980
17:49:29,680 --> 17:49:32,400
para usar a mesma lógica ok, vamos fazer isso

26981
17:49:32,400 --> 17:49:35,200
Suponha que você tenha outra função

26982
17:49:35,200 --> 17:49:38,560
que leva o que devo dizer por muito tempo

26983
17:49:38,560 --> 17:49:41,436
fim, se precisarmos que precisamos copiar isso

26984
17:49:41,436 --> 17:49:44,796
função e colocar isso em bom andamento precisamos

26985
17:49:44,796 --> 17:49:46,480
fazer isso e nós vamos mudar isso

26986
17:49:46,480 --> 17:49:48,796
para longo final longo e vamos fazer

26987
17:49:48,796 --> 17:49:50,240
O mesmo aqui

26988
17:49:50,240 --> 17:49:53,360
longo longo e nosso parâmetro e nós somos

26989
17:49:53,360 --> 17:49:55,916
Vou dizer o mesmo aqui e você vê

26990
17:49:55,916 --> 17:49:58,160
Estamos criando muitas funções

26991
17:49:58,160 --> 17:50:00,720
basicamente a mesma coisa dentro e

26992
17:50:00,720 --> 17:50:03,840
que é um monte de cópias de código

26993
17:50:03,840 --> 17:50:06,636
Suponha que temos essa função talvez 20

26994
17:50:06,636 --> 17:50:09,916
tempos é possível ou pior ainda o

26995
17:50:09,916 --> 17:50:12,320
A lógica nesta função é realmente longa

26996
17:50:12,320 --> 17:50:15,116
talvez 20 ou 30 linhas e teremos que

26997
17:50:15,116 --> 17:50:17,680
Repita esta coisa em aku, então

26998
17:50:17,680 --> 17:50:19,596
designers da linguagem c plus plus

26999
17:50:19,596 --> 17:50:22,320
Eu vi este problema e eles disseram por que não

27000
17:50:22,320 --> 17:50:25,360
estabelecemos um ponto de controle

27001
17:50:25,360 --> 17:50:27,756
onde podemos configurar nossa lógica para fazer o

27002
17:50:27,756 --> 17:50:31,360
máximo e deixamos o compilador gerar

27003
17:50:31,360 --> 17:50:32,720
real

27004
17:50:32,720 --> 17:50:35,916
funções baseadas nos argumentos que chamamos de

27005
17:50:35,916 --> 17:50:39,436
nossas funções com e eles vieram com

27006
17:50:39,436 --> 17:50:41,040
modelos de função e é isso que somos

27007
17:50:41,040 --> 17:50:42,400
Vou ver, então vamos tirar

27008
17:50:42,400 --> 17:50:44,160
todas as outras funções e nós vamos

27009
17:50:44,160 --> 17:50:47,680
transformar esse máximo e função em um

27010
17:50:47,680 --> 17:50:50,160
modelo de função a sintaxe para fazer isso

27011
17:50:50,160 --> 17:50:52,160
É ridiculamente fácil

27012
17:50:52,160 --> 17:50:54,000
Então nós vamos dizer que este é

27013
17:50:54,000 --> 17:50:56,000
O que você diz, você coloca um suporte de ângulo

27014
17:50:56,000 --> 17:50:58,720
e você diz nome de tipo e você especifica

27015
17:50:58,720 --> 17:51:01,436
o espaço reservado para o tipo neste

27016
17:51:01,436 --> 17:51:03,360
Suportes angulares aqui esta é a sintaxe

27017
17:51:03,360 --> 17:51:04,720
Você tem que usar

27018
17:51:04,720 --> 17:51:07,200
então você tem que especificar sua função

27019
17:51:07,200 --> 17:51:10,400
em termos deste espaço reservado é

27020
17:51:10,400 --> 17:51:12,880
Vou tomar o lugar do tipo assim

27021
17:51:12,880 --> 17:51:15,116
por exemplo, aqui queremos voltar e

27022
17:51:15,116 --> 17:51:17,116
nós vamos mudar isso para t e

27023
17:51:17,116 --> 17:51:19,436
Os parâmetros serão tomados por

27024
17:51:19,436 --> 17:51:21,916
valor t e t

27025
17:51:21,916 --> 17:51:23,436
Vamos fazer isso

27026
17:51:23,436 --> 17:51:26,320
e agora temos um c plus legal

27027
17:51:26,320 --> 17:51:28,560
modelo de função que vai levar

27028
17:51:28,560 --> 17:51:30,720
Este modelo aqui e usá-lo para

27029
17:51:30,720 --> 17:51:34,240
gerar funções reais c plus plus assim

27030
17:51:34,240 --> 17:51:36,160
Por exemplo, se formos em geral

27031
17:51:36,160 --> 17:51:39,596
Funcionar aqui e dizer ent result

27032
17:51:39,596 --> 17:51:42,956
igual ao máximo máximo que devemos dizer e dizer

27033
17:51:42,956 --> 17:51:45,200
x e y, por exemplo, vamos criar estes

27034
17:51:45,200 --> 17:51:47,680
variáveis no topo aqui, então nós vamos

27035
17:51:47,680 --> 17:51:49,916
Diga ent x e vamos colocar em um

27036
17:51:49,916 --> 17:51:52,320
Cinco e vamos criar um y e

27037
17:51:52,320 --> 17:51:55,436
colocar em um sete por que não agora esta função

27038
17:51:55,436 --> 17:51:57,360
vai armazenar o resultado e imprimir

27039
17:51:57,360 --> 17:51:58,636
Isso para fora

27040
17:51:58,636 --> 17:52:00,796
Vamos fazer isso para que possamos ver isso

27041
17:52:00,796 --> 17:52:02,480
Isso realmente funciona, então nós vamos

27042
17:52:02,480 --> 17:52:05,596
Diga resultado e diga resultados que isso está indo

27043
17:52:05,596 --> 17:52:08,240
para fazer e se construirmos e executarmos isso

27044
17:52:08,240 --> 17:52:10,400
programa, vamos usar gcc você está

27045
17:52:10,400 --> 17:52:11,916
Vou ver que o mundo vai

27046
17:52:11,916 --> 17:52:13,040
ser bom

27047
17:52:13,040 --> 17:52:15,520
E uh o mundo terminou com sucesso

27048
17:52:15,520 --> 17:52:18,796
pode executar este programa como sempre fazemos

27049
17:52:18,796 --> 17:52:20,956
Vamos trazer um terminal e limpar um

27050
17:52:20,956 --> 17:52:23,276
Um pouco e correr o galo você está indo

27051
17:52:23,276 --> 17:52:24,636
para ver que vamos ver isso

27052
17:52:24,636 --> 17:52:27,200
O resultado agora é 7, porque esse é o

27053
17:52:27,200 --> 17:52:29,840
máximo você vê que está funcionando aqui, então

27054
17:52:29,840 --> 17:52:33,116
Como esse mecanismo está funcionando aqui o

27055
17:52:33,116 --> 17:52:34,880
O compilador está basicamente olhando para o

27056
17:52:34,880 --> 17:52:37,360
função principal aqui e está percebendo

27057
17:52:37,360 --> 17:52:39,756
a chamada e vai olhar em volta

27058
17:52:39,756 --> 17:52:43,040
e veja se ele pode encontrar uma declaração para

27059
17:52:43,040 --> 17:52:44,796
A função máxima aqui não está indo

27060
17:52:44,796 --> 17:52:47,360
para encontrá-lo porque não há nenhum, então

27061
17:52:47,360 --> 17:52:49,116
Vai olhar para a função

27062
17:52:49,116 --> 17:52:51,276
modelos que tem aqui e está indo

27063
17:52:51,276 --> 17:52:54,080
para ver que ele pode fazer uma substituição e

27064
17:52:54,080 --> 17:52:56,400
Substituindo os tipos que estamos passando

27065
17:52:56,400 --> 17:52:58,560
Aqui, então vai fazer isso que é

27066
17:52:58,560 --> 17:53:00,636
Vou pegar este modelo e é

27067
17:53:00,636 --> 17:53:02,320
Indo para substituir

27068
17:53:02,320 --> 17:53:05,276
t por fim e então ele vai

27069
17:53:05,276 --> 17:53:08,240
gerar uma função que basicamente parece

27070
17:53:08,240 --> 17:53:10,320
Como o que temos aqui, vamos

27071
17:53:10,320 --> 17:53:13,116
Copie isso e vamos colocar isso em

27072
17:53:13,116 --> 17:53:14,720
o compilador vai tomar o primeiro

27073
17:53:14,720 --> 17:53:16,400
t aqui vai transformar isso em um

27074
17:53:16,400 --> 17:53:18,320
Net vai levar o segundo

27075
17:53:18,320 --> 17:53:20,240
Aqui vai transformar isso em um fim

27076
17:53:20,240 --> 17:53:23,040
Vai levar o terceiro aqui

27077
17:53:23,040 --> 17:53:25,596
e transformar isso em um e nós vamos

27078
17:53:25,596 --> 17:53:28,080
ter uma definição de função para o

27079
17:53:28,080 --> 17:53:30,160
chamar aqui isso é o que o compilador é

27080
17:53:30,160 --> 17:53:31,360
Vou fazer isso

27081
17:53:31,360 --> 17:53:33,916
Uma coisa que alguns de vocês podem estar pensando

27082
17:53:33,916 --> 17:53:36,720
Existe uma maneira de realmente provar isso e

27083
17:53:36,720 --> 17:53:38,956
Alguém foi bom o suficiente para projetar um

27084
17:53:38,956 --> 17:53:39,916
Ferramenta

27085
17:53:39,916 --> 17:53:41,436
para nos deixar ver

27086
17:53:41,436 --> 17:53:44,320
esta função ou instâncias de modelo

27087
17:53:44,320 --> 17:53:46,720
gerado pelo compilador e eu acontece

27088
17:53:46,720 --> 17:53:49,200
para ter isso aberto é um web-based

27089
17:53:49,200 --> 17:53:51,596
ferramenta para que você possa usar isso no seu navegador

27090
17:53:51,596 --> 17:53:53,720
Basta ir para dentro

27091
17:53:53,720 --> 17:53:55,276
Cppinsights.io jogo:

27092
17:53:55,276 --> 17:53:57,360
e então vamos pegar o código que nós

27093
17:53:57,360 --> 17:54:01,200
tinha em nosso arquivo principal cpp que estamos indo para

27094
17:54:01,200 --> 17:54:04,160
Copie tudo e nós vamos voltar

27095
17:54:04,160 --> 17:54:07,360
para o nosso navegador e remover o que eu tinha

27096
17:54:07,360 --> 17:54:09,040
Aqui porque eu não quero isso

27097
17:54:09,040 --> 17:54:11,040
mais e eu vou colocar na minha

27098
17:54:11,040 --> 17:54:13,200
modelo de função se quisermos podemos mesmo

27099
17:54:13,200 --> 17:54:16,320
tomar esta declaração sddc para fora porque nós

27100
17:54:16,320 --> 17:54:18,320
Não quero todo o lixo que vem com

27101
17:54:18,320 --> 17:54:21,756
que estamos apenas interessados em olhar

27102
17:54:21,756 --> 17:54:24,240
nas instâncias do modelo

27103
17:54:24,240 --> 17:54:26,560
gerado pelo compilador agora que nós

27104
17:54:26,560 --> 17:54:29,200
Tenho o código aqui que vamos ver

27105
17:54:29,200 --> 17:54:31,436
O que o compilador gera por causa de

27106
17:54:31,436 --> 17:54:33,596
A chamada que temos aqui eu acho que eu poderia

27107
17:54:33,596 --> 17:54:35,436
aumentar o tamanho da fonte aqui, então

27108
17:54:35,436 --> 17:54:36,720
que vocês

27109
17:54:36,720 --> 17:54:38,796
Eu posso ver isso eu acho que isso é um pouco

27110
17:54:38,796 --> 17:54:39,680
O melhor

27111
17:54:39,680 --> 17:54:42,320
Então, se você apertar este botão de reprodução aqui

27112
17:54:42,320 --> 17:54:44,840
Vamos clicar nele, ele vai fazer o seu

27113
17:54:44,840 --> 17:54:47,360
Processamento e, em seguida, o código gerado

27114
17:54:47,360 --> 17:54:48,956
pelo compilador vai aparecer para

27115
17:54:48,956 --> 17:54:51,360
Aqui você vê que detectou

27116
17:54:51,360 --> 17:54:52,636
que nós temos

27117
17:54:52,636 --> 17:54:55,200
chamado de modelo de função na linha 13

27118
17:54:55,200 --> 17:54:58,240
Aqui você vê que esta linha é destacada

27119
17:54:58,240 --> 17:54:59,680
E então, se você for para a direita, nós somos

27120
17:54:59,680 --> 17:55:02,320
ver as funções geradas por

27121
17:55:02,320 --> 17:55:04,560
O compilador, então se você for aqui você vê

27122
17:55:04,560 --> 17:55:06,636
que temos uma interversão

27123
17:55:06,636 --> 17:55:09,520
do nosso modelo de função e outro

27124
17:55:09,520 --> 17:55:12,240
O que eu deveria provar aqui é que

27125
17:55:12,240 --> 17:55:14,720
instâncias de modelo que não são necessárias

27126
17:55:14,720 --> 17:55:16,400
Não serão gerados pelo

27127
17:55:16,400 --> 17:55:18,320
Compilador outra maneira de dizer isso

27128
17:55:18,320 --> 17:55:21,436
O compilador só vai gerar o

27129
17:55:21,436 --> 17:55:24,480
template instances que precisa e novamente

27130
17:55:24,480 --> 17:55:27,200
instância de modelo é o que você tem aqui

27131
17:55:27,200 --> 17:55:29,840
A função a função real que é

27132
17:55:29,840 --> 17:55:32,560
callable pelo compilador gerado a partir de

27133
17:55:32,560 --> 17:55:34,880
seu projeto, então se, por exemplo,

27134
17:55:34,880 --> 17:55:37,520
Mude o tipo de nosso

27135
17:55:37,520 --> 17:55:39,916
Parâmetros para dobrar, vamos fazer isso bem

27136
17:55:39,916 --> 17:55:42,636
Então nós mudamos nossos tipos para o dobro, nós somos

27137
17:55:42,636 --> 17:55:44,880
Vou apertar o botão play novamente

27138
17:55:44,880 --> 17:55:46,636
você vai ver que agora está indo

27139
17:55:46,636 --> 17:55:48,880
para gerar uma dupla função aqui você

27140
17:55:48,880 --> 17:55:51,276
Veja aqui se mudarmos isso para

27141
17:55:51,276 --> 17:55:52,956
Um exemplo para

27142
17:55:52,956 --> 17:55:55,840
O que podemos usar vamos usar longo fim longo

27143
17:55:55,840 --> 17:55:58,560
Como fizemos em nossa palestra que podemos fazer

27144
17:55:58,560 --> 17:56:02,320
que podemos dizer por muito tempo e se nós

27145
17:56:02,320 --> 17:56:04,560
apertar o botão play que é o que está indo

27146
17:56:04,560 --> 17:56:07,436
para ser gerado pelo compilador assim

27147
17:56:07,436 --> 17:56:10,160
Espero que isso prove que o compilador

27148
17:56:10,160 --> 17:56:13,596
só vai gerar as instâncias

27149
17:56:13,596 --> 17:56:16,400
que são necessárias para as chamadas que você faz em

27150
17:56:16,400 --> 17:56:18,880
seu c plus mais programa e isso é

27151
17:56:18,880 --> 17:56:21,116
modelos realmente de função são tudo sobre

27152
17:56:21,116 --> 17:56:22,956
Tudo bem agora que você sabe disso vamos configurar

27153
17:56:22,956 --> 17:56:25,040
Mais alguns exemplos para ver que

27154
17:56:25,040 --> 17:56:26,480
Realmente funciona

27155
17:56:26,480 --> 17:56:28,796
então vamos mudar os tipos desses caras

27156
17:56:28,796 --> 17:56:29,680
A sua forma de

27157
17:56:29,680 --> 17:56:32,160
Dupla vamos fazer isso e nós vamos

27158
17:56:32,160 --> 17:56:33,916
brincar com isso um pouco mais no visual

27159
17:56:33,916 --> 17:56:37,200
código de estúdio e vamos usar o dobro

27160
17:56:37,200 --> 17:56:41,956
litros 5,5 e 7 ou 7

27161
17:56:41,956 --> 17:56:46,320
78.7 aqui vamos fazer isso 78,7 e nós somos

27162
17:56:46,320 --> 17:56:48,720
Vou construir isso e uma coisa eu

27163
17:56:48,720 --> 17:56:50,636
Deve ressaltar que modelo

27164
17:56:50,636 --> 17:56:52,880
As instâncias são geradas quando

27165
17:56:52,880 --> 17:56:55,200
O compilador está fazendo seu trabalho e, em seguida, eles

27166
17:56:55,200 --> 17:56:56,880
Eles vão ser colocados

27167
17:56:56,880 --> 17:56:59,520
na representação binária do seu

27168
17:56:59,520 --> 17:57:02,240
código fonte para que o mundo seja bom como você

27169
17:57:02,240 --> 17:57:05,116
Veja aqui podemos limpar e correr um galo

27170
17:57:05,116 --> 17:57:08,320
Vamos ver que o resultado é 78

27171
17:57:08,320 --> 17:57:11,200
e é transformado para acabar porque nós

27172
17:57:11,200 --> 17:57:13,596
estão atribuindo fim aqui para realmente chegar

27173
17:57:13,596 --> 17:57:15,436
para os resultados corretos aqui devemos

27174
17:57:15,436 --> 17:57:18,080
usar auto tipo de dedução se fizermos isso

27175
17:57:18,080 --> 17:57:20,000
o compilador vai deduzir o tipo

27176
17:57:20,000 --> 17:57:22,480
de resultado aqui com base no tipo de retorno

27177
17:57:22,480 --> 17:57:24,956
desta função ou da função

27178
17:57:24,956 --> 17:57:27,360
Template instance i devo dizer

27179
17:57:27,360 --> 17:57:29,116
Agora vamos mudar isso para o automóvel

27180
17:57:29,116 --> 17:57:31,360
para fazer auto tipo de dedução

27181
17:57:31,360 --> 17:57:33,200
E se nós dois novamente ver um

27182
17:57:33,200 --> 17:57:36,320
duplo impresso corretamente os dois são

27183
17:57:36,320 --> 17:57:38,720
Bom podemos limpar e correr o galo

27184
17:57:38,720 --> 17:57:41,276
Agora temos o valor correto impresso

27185
17:57:41,276 --> 17:57:44,796
fora do nosso modelo de função aqui

27186
17:57:44,796 --> 17:57:47,116
Vamos mudar isso para a string std que podemos

27187
17:57:47,116 --> 17:57:49,436
fazer isso, então vamos incluir

27188
17:57:49,436 --> 17:57:50,240
a

27189
17:57:50,240 --> 17:57:52,080
a biblioteca de strings

27190
17:57:52,080 --> 17:57:53,840
E nós vamos mudar esses dois caras

27191
17:57:53,840 --> 17:57:57,436
para std string por que não std string x é

27192
17:57:57,436 --> 17:58:01,436
vai ser um string electro vamos usar

27193
17:58:01,436 --> 17:58:04,720
Olá, por exemplo, e uh para

27194
17:58:04,720 --> 17:58:07,520
y nós vamos dizer força e

27195
17:58:07,520 --> 17:58:10,080
nós vamos colocar em um mundo aqui bem

27196
17:58:10,080 --> 17:58:12,080
Isso vai fazer e você percebe que

27197
17:58:12,080 --> 17:58:14,400
Nem sequer temos um erro de compilador

27198
17:58:14,400 --> 17:58:16,560
Código de estúdio visual não está reclamando

27199
17:58:16,560 --> 17:58:18,400
O compilador vai olhar para o

27200
17:58:18,400 --> 17:58:21,116
tipos que chamamos de nossa função com então

27201
17:58:21,116 --> 17:58:23,596
vai gerar é uma string do sdd

27202
17:58:23,596 --> 17:58:26,000
versão desta função e o que é

27203
17:58:26,000 --> 17:58:28,880
indo fazer, vai substituir em t

27204
17:58:28,880 --> 17:58:31,916
e substitua isso por std strand nós podemos

27205
17:58:31,916 --> 17:58:35,596
Na verdade, coloque essa coisa inteiramente em

27206
17:58:35,596 --> 17:58:37,596
cpp dentro, então vamos copiar este código

27207
17:58:37,596 --> 17:58:39,520
antes de executá-lo para que você possa realmente

27208
17:58:39,520 --> 17:58:41,436
Veja o que está acontecendo aqui estamos indo

27209
17:58:41,436 --> 17:58:43,116
para tirar o que tínhamos antes de nós

27210
17:58:43,116 --> 17:58:45,200
vamos colocar o nosso código e então nós somos

27211
17:58:45,200 --> 17:58:46,880
Vou apertar o botão play aqui é

27212
17:58:46,880 --> 17:58:48,880
vamos gerar o polegar que esperamos

27213
17:58:48,880 --> 17:58:51,200
para fazer a sua coisa e se você olhar aqui

27214
17:58:51,200 --> 17:58:54,080
Você vê que ele gerou

27215
17:58:54,080 --> 17:58:56,520
std força este é realmente um compilador

27216
17:58:56,520 --> 17:59:00,000
representação de std string nós não fazemos

27217
17:59:00,000 --> 17:59:02,080
ter ferramentas suficientes para realmente entender

27218
17:59:02,080 --> 17:59:04,880
Isso, mas espero que você possa ver que

27219
17:59:04,880 --> 17:59:06,956
foi substituído t

27220
17:59:06,956 --> 17:59:09,436
com algum outro tipo que ainda não sabemos

27221
17:59:09,436 --> 17:59:12,560
std carro de corda básico que tem algumas coisas

27222
17:59:12,560 --> 17:59:14,956
Dentro disso, nós realmente não sabemos ainda nós

27223
17:59:14,956 --> 17:59:17,360
Você precisa aprender mais algumas coisas

27224
17:59:17,360 --> 17:59:19,840
A tal enquanto progredimos no curso

27225
17:59:19,840 --> 17:59:21,200
Mas por enquanto

27226
17:59:21,200 --> 17:59:23,276
Quero provar a você que o compilador

27227
17:59:23,276 --> 17:59:25,840
está fazendo a substituição que você vê que t foi

27228
17:59:25,840 --> 17:59:28,720
substituído por esta coisa aqui std básico

27229
17:59:28,720 --> 17:59:30,880
força e nós temos suportes de ângulo e

27230
17:59:30,880 --> 17:59:34,080
Esta coisa toda é realmente hdd força

27231
17:59:34,080 --> 17:59:36,240
nos olhos do compilador ok

27232
17:59:36,240 --> 17:59:37,916
que nós sabemos disso vamos voltar para

27233
17:59:37,916 --> 17:59:40,400
código de estúdio visual e executar isso nós somos

27234
17:59:40,400 --> 17:59:43,596
vamos construir com gcc como sempre fazemos

27235
17:59:43,596 --> 17:59:45,756
O mundo é bom que podemos limpar e correr

27236
17:59:45,756 --> 17:59:46,880
Galo

27237
17:59:46,880 --> 17:59:49,040
Vou ver que o máximo é o mundo

27238
17:59:49,040 --> 17:59:51,116
E isso vai usar o

27239
17:59:51,116 --> 17:59:53,040
Maior do que o operador

27240
17:59:53,040 --> 17:59:55,116
E isso vai comparar dois

27241
17:59:55,116 --> 17:59:57,276
forças baseadas nisso e sabemos que

27242
17:59:57,276 --> 18:00:00,160
w aqui vem depois de h

27243
18:00:00,160 --> 18:00:03,116
na ordem lexicográfica, de modo que o

27244
18:00:03,116 --> 18:00:04,880
Comparação que é feita aqui é

27245
18:00:04,880 --> 18:00:06,400
- Alexicographical

27246
18:00:06,400 --> 18:00:08,880
para essa força aqui ou devo dizer

27247
18:00:08,880 --> 18:00:11,276
está comparando as coisas em alfabética

27248
18:00:11,276 --> 18:00:14,480
ordem em abcde e coisas assim bem

27249
18:00:14,480 --> 18:00:17,116
Agora espero que você tenha uma grande ideia sobre

27250
18:00:17,116 --> 18:00:18,636
modelos de função que são apenas

27251
18:00:18,636 --> 18:00:20,956
blueprints que você usa

27252
18:00:20,956 --> 18:00:23,916
para gerar funções reais e isso é

27253
18:00:23,916 --> 18:00:26,000
permitir que você evite vários

27254
18:00:26,000 --> 18:00:28,000
sobrecargas de função como vimos

27255
18:00:28,000 --> 18:00:28,956
Antes de

27256
18:00:28,956 --> 18:00:30,956
Uma coisa que eu quero que você veja

27257
18:00:30,956 --> 18:00:33,200
é que você tem que ter certeza de que o

27258
18:00:33,200 --> 18:00:36,160
A lógica que você faz dentro de sua função é

27259
18:00:36,160 --> 18:00:38,636
suportado pelos tipos para os quais você passa

27260
18:00:38,636 --> 18:00:40,636
A função e eu vou te mostrar

27261
18:00:40,636 --> 18:00:42,080
O que quero dizer aqui vamos montar

27262
18:00:42,080 --> 18:00:43,756
Outro modelo de função que vamos

27263
18:00:43,756 --> 18:00:46,000
Diga tipo de modelo chamado que vamos

27264
18:00:46,000 --> 18:00:48,240
configurar outro pedem e nós vamos

27265
18:00:48,240 --> 18:00:50,560
para usar aqui você pode usar

27266
18:00:50,560 --> 18:00:52,720
Mas muitas vezes você quer e

27267
18:00:52,720 --> 18:00:54,160
Então vamos configurar a função

27268
18:00:54,160 --> 18:00:57,680
que vai fazer uma multiplicação assim

27269
18:00:57,680 --> 18:00:59,360
nós vamos dizer que vai ser

27270
18:00:59,360 --> 18:01:01,116
o valor de retorno e nós vamos dizer

27271
18:01:01,116 --> 18:01:03,116
multiplicar e vamos multiplicar dois

27272
18:01:03,116 --> 18:01:05,680
parâmetros que vamos dizer t a e t

27273
18:01:05,680 --> 18:01:08,080
b OK e nós vamos colocar no

27274
18:01:08,080 --> 18:01:11,040
lógica e nós vamos apenas retornar um

27275
18:01:11,040 --> 18:01:12,880
multiplicado por b este é o nosso

27276
18:01:12,880 --> 18:01:16,160
operador de multiplicação em c plus plus

27277
18:01:16,160 --> 18:01:18,480
e nós podemos usar esta função assim para

27278
18:01:18,480 --> 18:01:21,116
O exemplo podemos dizer que podemos comentar isso

27279
18:01:21,116 --> 18:01:23,116
fora e podemos configurar duas variáveis

27280
18:01:23,116 --> 18:01:25,680
nós vamos dizer e x e nós vamos

27281
18:01:25,680 --> 18:01:27,436
para colocar o que tínhamos antes

27282
18:01:27,436 --> 18:01:28,796
Colocado em cinco

27283
18:01:28,796 --> 18:01:31,680
E o fim de y vamos dizer 7 i

27284
18:01:31,680 --> 18:01:33,360
Acho que é isso que usamos antes de você

27285
18:01:33,360 --> 18:01:35,360
pode realmente colocar o que quiser e

27286
18:01:35,360 --> 18:01:37,200
Agora vamos chamar a multiplicação

27287
18:01:37,200 --> 18:01:39,200
modelo de função para o que isso está acontecendo

27288
18:01:39,200 --> 18:01:41,756
fazer isso é gerar um modelo de função

27289
18:01:41,756 --> 18:01:44,160
instância que vai ser do tipo

27290
18:01:44,160 --> 18:01:46,796
e vai fazer um substituto em

27291
18:01:46,796 --> 18:01:49,116
aqui e substitua t por form e depois

27292
18:01:49,116 --> 18:01:51,040
Vamos multiplicar duas extremidades

27293
18:01:51,040 --> 18:01:52,560
Os parâmetros que são passados para isso

27294
18:01:52,560 --> 18:01:55,116
Função e vamos voltar a acabar

27295
18:01:55,116 --> 18:01:57,360
E se fizermos isso, vamos ter 35

27296
18:01:57,360 --> 18:01:59,276
impressos, vamos provar que estamos indo

27297
18:01:59,276 --> 18:02:02,080
para usar gcc para aparafusar o parafuso é bom nós

27298
18:02:02,080 --> 18:02:05,756
pode limpar e correr galo, temos um 35 se

27299
18:02:05,756 --> 18:02:07,680
nós mudamos isso para dobrar ele vai

27300
18:02:07,680 --> 18:02:10,320
trabalhar então vamos mudar isso para dobrar e

27301
18:02:10,320 --> 18:02:13,880
Talvez colocar em cinco pontos um e

27302
18:02:13,880 --> 18:02:16,796
7.0 por que não e então vamos ver

27303
18:02:16,796 --> 18:02:18,796
O que temos, vamos construir com

27304
18:02:18,796 --> 18:02:21,680
gcc a construção é boa nós podemos limpar correr

27305
18:02:21,680 --> 18:02:23,000
Galo que temos

27306
18:02:23,000 --> 18:02:26,000
35.7 é isso que esperamos

27307
18:02:26,000 --> 18:02:29,276
Mas observe o que acontece se tentarmos

27308
18:02:29,276 --> 18:02:33,436
para usar os tipos de string std OK i want

27309
18:02:33,436 --> 18:02:35,840
você para ver isso para que vamos permitir

27310
18:02:35,840 --> 18:02:38,956
nossas variáveis de força std aqui

27311
18:02:38,956 --> 18:02:41,200
E se tentarmos fugir, vamos chegar

27312
18:02:41,200 --> 18:02:43,520
um erro de compilador, mas eu quero que você tente

27313
18:02:43,520 --> 18:02:45,520
e adivinhe por que temos isso

27314
18:02:45,520 --> 18:02:48,400
compilador se olharmos para o que é gcc

27315
18:02:48,400 --> 18:02:49,680
dizendo aqui

27316
18:02:49,680 --> 18:02:52,956
está dizendo uma instanciação de nossa

27317
18:02:52,956 --> 18:02:56,160
modelo de função necessário a partir daqui e

27318
18:02:56,160 --> 18:02:58,560
sem correspondência para o operador

27319
18:02:58,560 --> 18:03:01,040
multiplicação aqui e este é o

27320
18:03:01,040 --> 18:03:02,240
Problema

27321
18:03:02,240 --> 18:03:04,400
O compilador vai fazer o que ele

27322
18:03:04,400 --> 18:03:06,480
Sabe fazer isso vai fazer a

27323
18:03:06,480 --> 18:03:09,360
substituição em nosso modelo de função e

27324
18:03:09,360 --> 18:03:11,436
Vai substituir t

27325
18:03:11,436 --> 18:03:13,840
por força de std porque esse é o tipo

27326
18:03:13,840 --> 18:03:16,400
Estamos usando como argumento aqui o

27327
18:03:16,400 --> 18:03:19,360
O problema é que não podemos realmente multiplicar dois

27328
18:03:19,360 --> 18:03:21,596
fios se você tentar multiplicar dois

27329
18:03:21,596 --> 18:03:23,756
fios como nós fazemos aqui, não está indo

27330
18:03:23,756 --> 18:03:26,480
para fazer sentido o que você espera obter

27331
18:03:26,480 --> 18:03:28,636
Se você multiplicar duas cordas, não

27332
18:03:28,636 --> 18:03:30,400
fazer sentido o compilador não sabe

27333
18:03:30,400 --> 18:03:32,320
O que fazer com esta operação é

27334
18:03:32,320 --> 18:03:34,320
vai dar-lhe um erro de compilador bem

27335
18:03:34,320 --> 18:03:36,880
para realmente dirigir isso para casa, vamos voltar

27336
18:03:36,880 --> 18:03:39,276
para cpp insights

27337
18:03:39,276 --> 18:03:41,756
e colocar o código aqui e ver o que é

27338
18:03:41,756 --> 18:03:43,840
gerado pelo compilador

27339
18:03:43,840 --> 18:03:45,756
você deve usar essas ferramentas para sua

27340
18:03:45,756 --> 18:03:48,000
vantagem porque eles realmente ajudam em

27341
18:03:48,000 --> 18:03:50,480
Entendendo o que está acontecendo, então vamos

27342
18:03:50,480 --> 18:03:52,400
apertar o botão play aqui eu apenas coloquei

27343
18:03:52,400 --> 18:03:54,240
Meu código e vai dizer

27344
18:03:54,240 --> 18:03:57,040
A compilação falhou porque temos a

27345
18:03:57,040 --> 18:04:00,240
Mesmo erro cpp insights precisa compilar

27346
18:04:00,240 --> 18:04:01,916
O código corretamente

27347
18:04:01,916 --> 18:04:05,116
para lhe dar as instanciações do modelo

27348
18:04:05,116 --> 18:04:07,436
Mas aqui você vê que é basicamente

27349
18:04:07,436 --> 18:04:10,240
nos dando o mesmo erro, vamos tentar

27350
18:04:10,240 --> 18:04:12,956
ver a coisa toda aqui e ver se nós

27351
18:04:12,956 --> 18:04:15,680
Veja o erro real e não podemos realmente

27352
18:04:15,680 --> 18:04:17,520
rolar ao redor com isso eu estou tendo

27353
18:04:17,520 --> 18:04:20,000
dificuldade rolando por aqui eu posso usar

27354
18:04:20,000 --> 18:04:22,956
Estes botões eu acho que está bem, então vamos ver

27355
18:04:22,956 --> 18:04:25,596
Se vemos o erro real e não somos

27356
18:04:25,596 --> 18:04:28,080
vendo isso aqui automaticamente multiplicar

27357
18:04:28,080 --> 18:04:30,160
o erro gerado para que possamos obter um

27358
18:04:30,160 --> 18:04:32,320
erro se tentarmos instanciar o nosso

27359
18:04:32,320 --> 18:04:34,880
modelo com os tipos que somos

27360
18:04:34,880 --> 18:04:37,436
passando aqui que são hdd força

27361
18:04:37,436 --> 18:04:40,480
cpp insights não é realmente útil aqui

27362
18:04:40,480 --> 18:04:42,636
Mas espero que você entenda o problema

27363
18:04:42,636 --> 18:04:45,116
O problema é se o compilador tenta

27364
18:04:45,116 --> 18:04:49,040
gerar uma instância de modelo usando std

27365
18:04:49,040 --> 18:04:51,756
strand multiplicando dois fios não é

27366
18:04:51,756 --> 18:04:53,520
vai fazer sentido para que o compilador seja

27367
18:04:53,520 --> 18:04:55,596
dar-lhe um erro de compilador

27368
18:04:55,596 --> 18:04:57,916
porque isso não é suportado, então o

27369
18:04:57,916 --> 18:05:00,160
Mensagem aqui é que você deve fazer

27370
18:05:00,160 --> 18:05:02,320
Certifique-se de que as instâncias de modelo

27371
18:05:02,320 --> 18:05:04,796
gerado pelo suporte dos compiladores

27372
18:05:04,796 --> 18:05:08,000
Quais sejam as operações que você está fazendo no

27373
18:05:08,000 --> 18:05:10,160
corpo do seu modelo de função este é

27374
18:05:10,160 --> 18:05:11,840
A mensagem aqui

27375
18:05:11,840 --> 18:05:13,360
Outra coisa que eu quero que você veja antes

27376
18:05:13,360 --> 18:05:15,596
nós fechamos isso, eu vou tirar

27377
18:05:15,596 --> 18:05:16,400
Isto é

27378
18:05:16,400 --> 18:05:18,400
linha problemática aqui e nós vamos

27379
18:05:18,400 --> 18:05:21,200
voltar à nossa função máxima o que eu

27380
18:05:21,200 --> 18:05:23,276
Você quer ver que se você passar

27381
18:05:23,276 --> 18:05:25,360
diferentes tipos para esta função

27382
18:05:25,360 --> 18:05:27,680
modelo que você vai ter um compilador

27383
18:05:27,680 --> 18:05:30,000
Erro e o que quero dizer com isso, vamos

27384
18:05:30,000 --> 18:05:32,560
tirar a nossa força std porque é

27385
18:05:32,560 --> 18:05:35,680
Não é mais útil para nossos propósitos aqui

27386
18:05:35,680 --> 18:05:38,796
e nós vamos usar dupla e 8

27387
18:05:38,796 --> 18:05:42,240
Parâmetros vamos usar formi aqui

27388
18:05:42,240 --> 18:05:43,520
E nós

27389
18:05:43,520 --> 18:05:46,080
fazer disso um intelectual

27390
18:05:46,080 --> 18:05:48,480
e então chamamos nossa função máxima

27391
18:05:48,480 --> 18:05:50,320
Você vê que nós temos uma linha squiggly

27392
18:05:50,320 --> 18:05:52,796
porque o modelo de função é forçado

27393
18:05:52,796 --> 18:05:56,000
para usar o mesmo tipo para o tipo de retorno

27394
18:05:56,000 --> 18:05:57,596
O primeiro parâmetro e o segundo

27395
18:05:57,596 --> 18:06:00,160
parâmetro aqui porque o espaço reservado

27396
18:06:00,160 --> 18:06:02,796
é o mesmo, então o compilador é suposto

27397
18:06:02,796 --> 18:06:04,956
Usar a mesma coisa para o primeiro

27398
18:06:04,956 --> 18:06:07,520
argumentar aqui o segundo argumento e

27399
18:06:07,520 --> 18:06:09,520
o tipo de retorno que olhemos a partir disso

27400
18:06:09,520 --> 18:06:11,680
função máxima aqui, mas o problema é

27401
18:06:11,680 --> 18:06:13,520
Estamos passando nos parâmetros de

27402
18:06:13,520 --> 18:06:15,596
diferentes tipos e isso vai

27403
18:06:15,596 --> 18:06:17,360
nos dar um erro de compilador porque o

27404
18:06:17,360 --> 18:06:20,400
O compilador quer saber o que fazer com

27405
18:06:20,400 --> 18:06:23,520
os tipos que você passa como argumentos

27406
18:06:23,520 --> 18:06:26,636
e se olharmos para a guia dos nossos problemas aqui

27407
18:06:26,636 --> 18:06:29,116
Código visual do estúdio deve nos dar uma

27408
18:06:29,116 --> 18:06:31,840
Erro nenhum fósforo para o operador uh este é

27409
18:06:31,840 --> 18:06:33,840
o erro que tivemos antes de podermos tentar e

27410
18:06:33,840 --> 18:06:35,276
construir novamente nós vamos ter um

27411
18:06:35,276 --> 18:06:38,320
erro do compilador novamente, mas desta vez é

27412
18:06:38,320 --> 18:06:39,756
Vai ser diferente, vai dizer

27413
18:06:39,756 --> 18:06:43,276
nenhuma instância de modelo de função máxima

27414
18:06:43,276 --> 18:06:45,596
corresponde à lista de argumentos de que somos

27415
18:06:45,596 --> 18:06:48,080
usando aqui que é duplo e fim

27416
18:06:48,080 --> 18:06:48,956
Então,

27417
18:06:48,956 --> 18:06:51,360
Isso é um problema, mas vamos ver caminhos

27418
18:06:51,360 --> 18:06:52,956
em torno disso à medida que progredimos no

27419
18:06:52,956 --> 18:06:55,596
Capítulo, mas o que você deve saber

27420
18:06:55,596 --> 18:06:57,840
é que se configurarmos um modelo de função

27421
18:06:57,840 --> 18:07:00,320
Assim, isso vai impor para

27422
18:07:00,320 --> 18:07:03,040
todos os tipos onde vamos colocar em t

27423
18:07:03,040 --> 18:07:05,596
ser o mesmo se não for o mesmo

27424
18:07:05,596 --> 18:07:07,596
o compilador não saberá como fazer

27425
18:07:07,596 --> 18:07:09,520
substituição e vai dar-lhe

27426
18:07:09,520 --> 18:07:11,596
um erro de compilador ok na última coisa que eu

27427
18:07:11,596 --> 18:07:14,160
Você quer que você veja é que nós podemos usar o

27428
18:07:14,160 --> 18:07:17,436
depurador para depurar modelos de função assim

27429
18:07:17,436 --> 18:07:19,596
Vamos voltar isso de volta ao fim porque nós

27430
18:07:19,596 --> 18:07:21,436
Queria que isso compilasse

27431
18:07:21,436 --> 18:07:24,560
Então vamos tirar o ponto decimal aqui

27432
18:07:24,560 --> 18:07:27,596
para que tenhamos os próprios intelectuais e

27433
18:07:27,596 --> 18:07:30,080
se compilarmos novamente isso deve compilar

27434
18:07:30,080 --> 18:07:32,636
Ok, o mundo é bom agora o que realmente

27435
18:07:32,636 --> 18:07:36,160
acontece se você tentar depurar um programa

27436
18:07:36,160 --> 18:07:36,956
em

27437
18:07:36,956 --> 18:07:38,480
modelos de função

27438
18:07:38,480 --> 18:07:40,720
Você vai trabalhar no

27439
18:07:40,720 --> 18:07:43,360
instâncias de modelo porque lembre-se do

27440
18:07:43,360 --> 18:07:46,160
Os modelos de função vão gerar

27441
18:07:46,160 --> 18:07:48,480
instâncias de modelo de função com real

27442
18:07:48,480 --> 18:07:50,880
tipos, por exemplo, nossa instância de modelo

27443
18:07:50,880 --> 18:07:53,116
Aqui vai ter formigas porque nós

27444
18:07:53,116 --> 18:07:56,956
estão passando a formiga como argumento aqui, então como

27445
18:07:56,956 --> 18:07:59,116
Será que vamos depurar isso, vamos

27446
18:07:59,116 --> 18:08:02,080
Tente isso, vamos fazer uma pausa

27447
18:08:02,080 --> 18:08:03,360
Ponto aqui

27448
18:08:03,360 --> 18:08:06,240
na chamada para a nossa função máxima

27449
18:08:06,240 --> 18:08:08,080
E nós vamos começar a depurar nós somos

27450
18:08:08,080 --> 18:08:10,000
indo para o nosso

27451
18:08:10,000 --> 18:08:11,840
executar tab aqui

27452
18:08:11,840 --> 18:08:13,520
e nós vamos usar a depuração

27453
18:08:13,520 --> 18:08:16,240
ferramentas que vêm com gcc que temos visto

27454
18:08:16,240 --> 18:08:18,796
Como fazer isso no último capítulo e

27455
18:08:18,796 --> 18:08:20,560
nós vamos começar a depurar vamos

27456
18:08:20,560 --> 18:08:23,596
minimizar este cara aqui para que tenhamos

27457
18:08:23,596 --> 18:08:25,276
algum espaço para respirar

27458
18:08:25,276 --> 18:08:28,160
e nós vamos executar o nosso depurador

27459
18:08:28,160 --> 18:08:30,880
Vamos maximizar isso um pouco

27460
18:08:30,880 --> 18:08:33,520
E empurre isso um pouco para a esquerda

27461
18:08:33,520 --> 18:08:35,200
e nós vamos começar a depurar e

27462
18:08:35,200 --> 18:08:37,520
Veja o que realmente acontece aqui, então nós batemos

27463
18:08:37,520 --> 18:08:39,276
O botão verde aqui nós vamos

27464
18:08:39,276 --> 18:08:41,840
começar a depurar o nosso código está construindo agora

27465
18:08:41,840 --> 18:08:43,276
A construção é feita

27466
18:08:43,276 --> 18:08:45,680
O binário foi passado para o

27467
18:08:45,680 --> 18:08:48,240
debugger e agora nós batemos nossa pausa

27468
18:08:48,240 --> 18:08:50,796
Ponto aqui, então vamos minimizar isso a

27469
18:08:50,796 --> 18:08:53,116
Um pouquinho para que tenhamos uma maneira mais fácil

27470
18:08:53,116 --> 18:08:55,680
para ver isso, atingimos ou quebramos pontos

27471
18:08:55,680 --> 18:08:57,360
Você vê que os locais são o que temos em

27472
18:08:57,360 --> 18:08:59,596
A principal função que é

27473
18:08:59,596 --> 18:09:01,916
o topo da pilha de chamadas aqui

27474
18:09:01,916 --> 18:09:03,596
Tudo bem agora queremos saltar para o

27475
18:09:03,596 --> 18:09:05,680
função máxima e ver os tipos que

27476
18:09:05,680 --> 18:09:07,276
Nós temos dentro

27477
18:09:07,276 --> 18:09:09,596
Então, o que queremos fazer aqui é cabeça

27478
18:09:09,596 --> 18:09:12,636
Entre na função e você percebe que é

27479
18:09:12,636 --> 18:09:14,796
indo para saltar em nosso modelo de função

27480
18:09:14,796 --> 18:09:17,756
Aqui, mas os locais aqui não estão dando

27481
18:09:17,756 --> 18:09:20,160
nós os tipos e isso é porque isso é

27482
18:09:20,160 --> 18:09:22,240
um modelo de função que não vai

27483
18:09:22,240 --> 18:09:24,320
dar a você os tipos

27484
18:09:24,320 --> 18:09:27,200
porque não é fácil conseguir isso aqui

27485
18:09:27,200 --> 18:09:30,160
mas se olharmos para a pilha de chamadas que você vê

27486
18:09:30,160 --> 18:09:32,400
que temos informações sobre os tipos

27487
18:09:32,400 --> 18:09:34,160
da função que está sendo chamada

27488
18:09:34,160 --> 18:09:36,560
estão chamando isso de um e ele b

27489
18:09:36,560 --> 18:09:38,480
E vai voltar e você vê

27490
18:09:38,480 --> 18:09:40,636
que nos braquetes de ângulo aqui e

27491
18:09:40,636 --> 18:09:42,480
Mais uma vez, esta é possivelmente outra maneira de

27492
18:09:42,480 --> 18:09:45,436
Veja quais instâncias de template foram

27493
18:09:45,436 --> 18:09:47,596
gerado pelo compilador porque vemos

27494
18:09:47,596 --> 18:09:49,520
A função chamada aqui é levada em

27495
18:09:49,520 --> 18:09:52,320
Parâmetros e vai voltar a acabar

27496
18:09:52,320 --> 18:09:54,880
Vamos matar o nosso depurador, porque isto é

27497
18:09:54,880 --> 18:09:57,116
Realmente tudo o que queremos ver e mudar o

27498
18:09:57,116 --> 18:09:59,200
tipos para dobrar aqui e nós vamos

27499
18:09:59,200 --> 18:10:01,596
Veja que a função para o topo do

27500
18:10:01,596 --> 18:10:03,520
A chamada vai ser

27501
18:10:03,520 --> 18:10:06,240
tomando os parâmetros duplos, então vamos mudar

27502
18:10:06,240 --> 18:10:09,436
isso de volta a cinco pontos algo 5.5

27503
18:10:09,436 --> 18:10:13,360
Talvez 7 e 0,9 por que não e nós vamos

27504
18:10:13,360 --> 18:10:15,276
para imprimir os nossos resultados aqui

27505
18:10:15,276 --> 18:10:17,756
Mas uh o que realmente estamos interessados

27506
18:10:17,756 --> 18:10:21,436
está vendo a instância do modelo de função

27507
18:10:21,436 --> 18:10:23,360
gerado pelo compilador por causa de

27508
18:10:23,360 --> 18:10:25,200
Este chamado aqui e nós podemos fazer isso

27509
18:10:25,200 --> 18:10:27,116
através do depurador isso é um pouco

27510
18:10:27,116 --> 18:10:29,040
bit convolutivo porque você tem que definir

27511
18:10:29,040 --> 18:10:31,276
para pontos de ruptura e o que quer que seja, mas é

27512
18:10:31,276 --> 18:10:33,276
útil se você não quiser usar as coisas

27513
18:10:33,276 --> 18:10:36,320
como insights cpp como já vimos antes

27514
18:10:36,320 --> 18:10:38,320
e novamente isso também é útil porque

27515
18:10:38,320 --> 18:10:40,400
você precisará depurar seu código se ele

27516
18:10:40,400 --> 18:10:42,480
está usando modelos de função

27517
18:10:42,480 --> 18:10:45,276
Isso para realmente provar o nosso ponto aqui

27518
18:10:45,276 --> 18:10:47,276
O mundo vai passar pelo

27519
18:10:47,276 --> 18:10:49,360
O executável binário vai ser passado

27520
18:10:49,360 --> 18:10:50,240
em

27521
18:10:50,240 --> 18:10:52,080
o depurador e nós vamos bater o nosso

27522
18:10:52,080 --> 18:10:55,040
breakpoint aqui novamente você vê nossos locais

27523
18:10:55,040 --> 18:10:57,680
não estamos nos dando os tipos aqui, mas nós

27524
18:10:57,680 --> 18:10:59,200
Não pode usar

27525
18:10:59,200 --> 18:11:01,116
A chamada de função para realmente ver

27526
18:11:01,116 --> 18:11:03,436
que atingimos o ponto de interrupção aqui em

27527
18:11:03,436 --> 18:11:06,400
linha 15 para que possamos entrar na chamada

27528
18:11:06,400 --> 18:11:09,360
E se atingirmos o corpo do máximo

27529
18:11:09,360 --> 18:11:12,880
função aqui e olhar para a pilha de chamadas

27530
18:11:12,880 --> 18:11:15,520
Vamos ver que os parâmetros

27531
18:11:15,520 --> 18:11:18,880
Temos em nossa função chamada de

27532
18:11:18,880 --> 18:11:21,116
duplo tipo e novamente isso espero

27533
18:11:21,116 --> 18:11:22,720
Prova para nós

27534
18:11:22,720 --> 18:11:25,680
que o compilador realmente gerou

27535
18:11:25,680 --> 18:11:26,956
um duplo

27536
18:11:26,956 --> 18:11:29,756
Função template instance OK desde que nós

27537
18:11:29,756 --> 18:11:31,680
são depuração, podemos realmente tentar e

27538
18:11:31,680 --> 18:11:35,116
Siga este programa vamos acertar em seguida, então

27539
18:11:35,116 --> 18:11:37,200
que podemos atingir o final desta função

27540
18:11:37,200 --> 18:11:38,400
Podemos

27541
18:11:38,400 --> 18:11:40,956
terminá-lo e acertar a função principal por

27542
18:11:40,956 --> 18:11:43,200
O momento em que atingimos a principal função

27543
18:11:43,200 --> 18:11:46,000
Os resultados serão 7.9, que é o que

27544
18:11:46,000 --> 18:11:47,520
Temos aqui e é o que estamos indo

27545
18:11:47,520 --> 18:11:49,756
para imprimir, podemos apenas ultrapassar isso

27546
18:11:49,756 --> 18:11:51,520
porque nós não queremos entrar no

27547
18:11:51,520 --> 18:11:54,400
lógicas de sddc out tão passo sobre nós somos

27548
18:11:54,400 --> 18:11:56,240
vamos imprimir o nosso resultado e nosso

27549
18:11:56,240 --> 18:11:58,400
A sessão de depuração vai basicamente

27550
18:11:58,400 --> 18:12:01,040
Fim porque nós atingimos o fim do

27551
18:12:01,040 --> 18:12:03,520
principal função vamos tentar usar o

27552
18:12:03,520 --> 18:12:06,160
compilador da microsoft para ver o

27553
18:12:06,160 --> 18:12:08,480
informação que nos dá porque estes

27554
18:12:08,480 --> 18:12:10,480
As coisas podem ser diferentes dependendo do

27555
18:12:10,480 --> 18:12:12,796
compilador e as ferramentas de depuração que

27556
18:12:12,796 --> 18:12:15,040
Você está usando, temos o luxo de ter

27557
18:12:15,040 --> 18:12:17,836
Estes dois estão aqui, então tudo o que temos para

27558
18:12:17,836 --> 18:12:19,756
fazer é mudar a ferramenta que queremos usar

27559
18:12:19,756 --> 18:12:22,244
Aqui e isso vai usar o

27560
18:12:22,244 --> 18:12:24,720
um da Microsoft se você não estiver ligado

27561
18:12:24,720 --> 18:12:27,436
Janelas ou você não quer usar o

27562
18:12:27,436 --> 18:12:30,244
compilador do microsoft e seu

27563
18:12:30,244 --> 18:12:33,116
ferramentas de depuração que você pode usar apenas gcc e

27564
18:12:33,116 --> 18:12:35,360
suas ferramentas de depuração aqui eu só quero você

27565
18:12:35,360 --> 18:12:37,116
Ver maneiras diferentes de fazer o mesmo

27566
18:12:37,116 --> 18:12:39,436
coisas e esses compiladores e depuradores

27567
18:12:39,436 --> 18:12:42,080
pode dar-nos informações diferentes que somos

27568
18:12:42,080 --> 18:12:44,000
Vou tentar depurar com isso assim

27569
18:12:44,000 --> 18:12:46,000
nós vamos apertar o botão verde aqui

27570
18:12:46,000 --> 18:12:47,600
Perceba que isso vai ser usado

27571
18:12:47,600 --> 18:12:50,640
O compilador do microsoft se olharmos

27572
18:12:50,640 --> 18:12:53,116
na produção mundial aqui você vê que nós

27573
18:12:53,116 --> 18:12:55,600
estão chamando cl.exe

27574
18:12:55,600 --> 18:12:57,756
É o que estamos usando para construir nossa

27575
18:12:57,756 --> 18:13:00,080
Binário o binário vai passar

27576
18:13:00,080 --> 18:13:02,156
para o depurador e então nós vamos

27577
18:13:02,156 --> 18:13:05,516
Acerte o ponto de interrupção aqui como sabemos

27578
18:13:05,516 --> 18:13:07,600
e então nós vamos ter a nossa produção

27579
18:13:07,600 --> 18:13:10,000
Estes são os nossos locais

27580
18:13:10,000 --> 18:13:12,476
você vê na função principal que não vemos

27581
18:13:12,476 --> 18:13:15,280
ver os tipos de nossos habitantes locais, por que isso é

27582
18:13:15,280 --> 18:13:17,600
Eu não sei o porquê, mas nós vemos os valores

27583
18:13:17,600 --> 18:13:19,920
Aqui na função principal

27584
18:13:19,920 --> 18:13:23,040
e se nós apertamos o passo no botão para

27585
18:13:23,040 --> 18:13:25,756
saltar em nossa função máxima a é

27586
18:13:25,756 --> 18:13:27,516
ter esse valor b vai

27587
18:13:27,516 --> 18:13:30,476
Tenho esse valor e olhamos para o

27588
18:13:30,476 --> 18:13:32,244
template instance podemos ver o mesmo

27589
18:13:32,244 --> 18:13:34,796
informações mas estamos usando um

27590
18:13:34,796 --> 18:13:37,196
Compilador este é realmente como você pode

27591
18:13:37,196 --> 18:13:40,080
depurar o código que usa a função

27592
18:13:40,080 --> 18:13:42,556
templates e isso vai nos dar uma

27593
18:13:42,556 --> 18:13:46,000
espreita para a instância de modelo real

27594
18:13:46,000 --> 18:13:49,196
que foi gerado pelo nosso compilador este

27595
18:13:49,196 --> 18:13:51,360
É realmente tudo que eu tive que compartilhar disso

27596
18:13:51,360 --> 18:13:53,436
palestra e antes que eu deixe você ir, vamos

27597
18:13:53,436 --> 18:13:55,516
Resuma um pouco de função

27598
18:13:55,516 --> 18:13:57,360
templates são blueprints que vimos

27599
18:13:57,360 --> 18:13:59,280
que o compilador vai usar esses

27600
18:13:59,280 --> 18:14:01,600
para gerar um modelo de função real

27601
18:14:01,600 --> 18:14:04,400
instâncias definições de função reais e

27602
18:14:04,400 --> 18:14:05,116
- uh

27603
18:14:05,116 --> 18:14:07,196
As declarações serão criadas

27604
18:14:07,196 --> 18:14:08,876
Quando você chama a função com

27605
18:14:08,876 --> 18:14:11,516
argumentos se os parâmetros do modelo são

27606
18:14:11,516 --> 18:14:14,556
do mesmo tipo talvez t e t, então

27607
18:14:14,556 --> 18:14:16,476
argumentos que você chama de função com

27608
18:14:16,476 --> 18:14:18,400
Também deve coincidir caso contrário você terá um

27609
18:14:18,400 --> 18:14:20,556
Erro do compilador temos visto isso bem

27610
18:14:20,556 --> 18:14:22,876
Aqui temos um ponto que ainda não temos

27611
18:14:22,876 --> 18:14:25,116
instâncias de modelo cobertas nem sempre

27612
18:14:25,116 --> 18:14:27,360
Faça o que você quer um bom exemplo é quando

27613
18:14:27,360 --> 18:14:29,196
você chama nossa função máxima com

27614
18:14:29,196 --> 18:14:31,436
dicas, então vamos voltar e realmente dizer

27615
18:14:31,436 --> 18:14:32,244
Isto é

27616
18:14:32,244 --> 18:14:34,796
Porque eu quero que isso cubra tanto quanto

27617
18:14:34,796 --> 18:14:37,360
Possível sobre modelos de função

27618
18:14:37,360 --> 18:14:39,600
Então vamos voltar ao nosso código e nós somos

27619
18:14:39,600 --> 18:14:41,436
Vou modificar as coisas um pouco bem

27620
18:14:41,436 --> 18:14:42,960
Então o que vamos fazer aqui é tomar

27621
18:14:42,960 --> 18:14:44,400
fora o que temos aqui, vamos

27622
18:14:44,400 --> 18:14:47,280
configurado em variáveis x e y

27623
18:14:47,280 --> 18:14:49,280
x vai ser 5 como vimos

27624
18:14:49,280 --> 18:14:51,280
Antes e

27625
18:14:51,280 --> 18:14:54,320
y vai ser sete, vamos usar isso

27626
18:14:54,320 --> 18:14:55,516
E então vamos montar dois

27627
18:14:55,516 --> 18:14:57,116
variáveis de ponteiro que vamos dizer

27628
18:14:57,116 --> 18:14:58,400
endpointer

27629
18:14:58,400 --> 18:15:00,556
Px e nós vamos inicializar isso

27630
18:15:00,556 --> 18:15:02,640
com o endereço de x nada

27631
18:15:02,640 --> 18:15:04,640
sofisticado até agora e nós vamos

27632
18:15:04,640 --> 18:15:06,796
Diga fim p y e nós vamos

27633
18:15:06,796 --> 18:15:09,516
inicializar isso com o endereço de y

27634
18:15:09,516 --> 18:15:11,756
Pode fazer isso, o problema virá

27635
18:15:11,756 --> 18:15:14,156
quando tentamos chamar nossa função aqui

27636
18:15:14,156 --> 18:15:15,436
Com o

27637
18:15:15,436 --> 18:15:18,476
ponteiros, vamos usar px e py para chamar

27638
18:15:18,476 --> 18:15:21,280
Esta função e py e o que isto é

27639
18:15:21,280 --> 18:15:24,244
O fazer é gerar um template

27640
18:15:24,244 --> 18:15:26,476
instância que leva o ponteiro final, isso é

27641
18:15:26,476 --> 18:15:28,080
O que sabe fazer o compilador

27642
18:15:28,080 --> 18:15:30,000
Vou levar os tipos que passamos

27643
18:15:30,000 --> 18:15:32,796
Aqui, que por acaso é o ponteiro final e

27644
18:15:32,796 --> 18:15:34,720
Vamos mudar o tipo de retorno para

27645
18:15:34,720 --> 18:15:36,080
fim de ponteiro, vamos mudar o

27646
18:15:36,080 --> 18:15:37,920
primeiro parâmetro para final apontar o

27647
18:15:37,920 --> 18:15:39,836
segundo parâmetro ao ponteiro final e

27648
18:15:39,836 --> 18:15:41,920
Vamos calcular o máximo

27649
18:15:41,920 --> 18:15:43,680
Se calcularmos o máximo aqui, estamos

27650
18:15:43,680 --> 18:15:46,156
Vou comparar ponteiros bem

27651
18:15:46,156 --> 18:15:48,876
notar isso e se tentarmos fazer isso

27652
18:15:48,876 --> 18:15:51,756
pode não conseguir o que queremos, porque o que

27653
18:15:51,756 --> 18:15:55,280
Obtemos agora depende do endereço usado

27654
18:15:55,280 --> 18:15:57,360
para armazenar esses caras na memória, espero

27655
18:15:57,360 --> 18:16:00,156
você pode ver isso e vamos tentar depurar

27656
18:16:00,156 --> 18:16:02,476
Este programa para que você possa realmente ver

27657
18:16:02,476 --> 18:16:06,876
Isso vamos usar as ferramentas de g

27658
18:16:06,876 --> 18:16:09,040
plus plus ou gcc

27659
18:16:09,040 --> 18:16:10,476
e nós vamos tentar depurá-lo

27660
18:16:10,476 --> 18:16:13,280
Vamos fazer isso que vai passar

27661
18:16:13,280 --> 18:16:15,116
O depurador e o que vamos

27662
18:16:15,116 --> 18:16:18,000
Tenho é o nosso terminal aqui eu acho que isso

27663
18:16:18,000 --> 18:16:20,556
Não é mais necessário, então vamos colocar isso

27664
18:16:20,556 --> 18:16:23,196
para a direita aqui e minimizar um pouco

27665
18:16:23,196 --> 18:16:27,196
bit e agora você percebe que px contém

27666
18:16:27,196 --> 18:16:30,244
Um endereço e py contém um endereço

27667
18:16:30,244 --> 18:16:32,244
Espero que você possa ver isso no corpo

27668
18:16:32,244 --> 18:16:34,000
da nossa instância de modelo que vamos

27669
18:16:34,000 --> 18:16:36,720
comparar esses endereços porque

27670
18:16:36,720 --> 18:16:38,796
Estamos comparando o que passamos pelo valor

27671
18:16:38,796 --> 18:16:40,796
Aqui e o que passamos são estes dois

27672
18:16:40,796 --> 18:16:43,920
Endereços, o que for o máximo em

27673
18:16:43,920 --> 18:16:46,080
Esses caras e eu acho que isso vai

27674
18:16:46,080 --> 18:16:49,600
ser dd4 aqui é o máximo, então

27675
18:16:49,600 --> 18:16:52,244
O que está contido em px vai

27676
18:16:52,244 --> 18:16:55,280
ser considerado o máximo vamos matar

27677
18:16:55,280 --> 18:16:56,640
porque nós vimos isso

27678
18:16:56,640 --> 18:16:59,436
informações para que possamos ter um valor em px

27679
18:16:59,436 --> 18:17:01,756
E isso acontece para estar em um maior

27680
18:17:01,756 --> 18:17:03,600
Endereço que vai ser considerado o

27681
18:17:03,600 --> 18:17:05,680
máximo vamos ver o que imprimimos se nós

27682
18:17:05,680 --> 18:17:07,360
executar este programa que vamos construir

27683
18:17:07,360 --> 18:17:10,876
com gcc vamos fazer que o mundo é bom

27684
18:17:10,876 --> 18:17:12,476
nós podemos limpar

27685
18:17:12,476 --> 18:17:15,516
e executar galo agora você vê que o resultado é

27686
18:17:15,516 --> 18:17:17,920
algum endereço porque estamos retornando a

27687
18:17:17,920 --> 18:17:20,000
ponteiro e impressão disso, mas nós podemos

27688
18:17:20,000 --> 18:17:22,400
facilmente desreferência disso e chegar ao

27689
18:17:22,400 --> 18:17:25,280
valor dentro deste ponteiro vamos construir

27690
18:17:25,280 --> 18:17:28,244
novamente podemos limpar e correr galo isso

27691
18:17:28,244 --> 18:17:30,796
vai nos dar resultado é 5 e

27692
18:17:30,796 --> 18:17:32,244
Espero que você possa ver que isso é

27693
18:17:32,244 --> 18:17:35,600
Realmente ruim e não correto estamos tentando

27694
18:17:35,600 --> 18:17:38,400
para calcular o máximo entre x e y

27695
18:17:38,400 --> 18:17:41,600
e estamos vendo que o máximo é

27696
18:17:41,600 --> 18:17:44,556
5 então como pode cinco bater o máximo

27697
18:17:44,556 --> 18:17:46,960
Entre cinco e sete, o problema é

27698
18:17:46,960 --> 18:17:49,360
Nós não estamos comparando os valores aqui que nós

27699
18:17:49,360 --> 18:17:52,556
estão comparando os endereços armazenados em

27700
18:17:52,556 --> 18:17:54,244
esses ponteiros, porque é isso que nós

27701
18:17:54,244 --> 18:17:55,680
estão passando aqui espero que você possa

27702
18:17:55,680 --> 18:17:57,836
realmente ver isso e podemos provar isso

27703
18:17:57,836 --> 18:18:00,796
novamente através do nosso depurador nós podemos correr

27704
18:18:00,796 --> 18:18:03,280
Isso através do depurador vamos

27705
18:18:03,280 --> 18:18:05,600
acertar o ponto de interrupção vamos minimizar isso

27706
18:18:05,600 --> 18:18:07,680
para que possamos ver nossa janela do terminal

27707
18:18:07,680 --> 18:18:09,680
Aqui e nós vamos mover isso ao redor

27708
18:18:09,680 --> 18:18:11,836
um pouco e agora nós batemos o nosso

27709
18:18:11,836 --> 18:18:14,720
ponto de ruptura se batermos ao lado para saltar para dentro

27710
18:18:14,720 --> 18:18:16,796
A função você vê que o que somos

27711
18:18:16,796 --> 18:18:20,000
realmente comparar são a e b aqui e um

27712
18:18:20,000 --> 18:18:22,720
contém um endereço muito maior, por isso é

27713
18:18:22,720 --> 18:18:25,116
O ponteiro que vai ser devolvido

27714
18:18:25,116 --> 18:18:27,516
E se dereferênciamos que vamos

27715
18:18:27,516 --> 18:18:29,680
ser dereferenciando o ponteiro que

27716
18:18:29,680 --> 18:18:32,640
contém este valor x e a mensagem

27717
18:18:32,640 --> 18:18:35,436
Aqui é que você deve ter cuidado

27718
18:18:35,436 --> 18:18:37,196
que seus modelos de função são realmente

27719
18:18:37,196 --> 18:18:39,280
O que fazer o que você quer alguém pode

27720
18:18:39,280 --> 18:18:41,600
fazer isso se eles não forem cuidadosos apenas

27721
18:18:41,600 --> 18:18:43,680
passar no ponteiro e esperar para obter o

27722
18:18:43,680 --> 18:18:46,156
máximo, mas o compilador está apenas indo

27723
18:18:46,156 --> 18:18:49,040
para comparar endereços de ponteiro e você está

27724
18:18:49,040 --> 18:18:50,960
Vou conseguir algo que você provavelmente

27725
18:18:50,960 --> 18:18:53,360
Não espere ok, isso é o que significa

27726
18:18:53,360 --> 18:18:55,756
por instâncias de modelo nem sempre farão

27727
18:18:55,756 --> 18:18:57,600
O que você quer um bom exemplo é quando você

27728
18:18:57,600 --> 18:18:59,836
chamar uma função máxima com ponteiros

27729
18:18:59,836 --> 18:19:01,756
Você vai ter um valor errado

27730
18:19:01,756 --> 18:19:04,000
possivelmente existem ferramentas como cpp

27731
18:19:04,000 --> 18:19:05,920
insights que podem mostrar o modelo em

27732
18:19:05,920 --> 18:19:07,756
Instrumentos espaciais, temos visto que

27733
18:19:07,756 --> 18:19:10,320
e novamente os argumentos passaram para um

27734
18:19:10,320 --> 18:19:12,156
modelo de função deve suportar o

27735
18:19:12,156 --> 18:19:14,796
operações que você está fazendo em seu

27736
18:19:14,796 --> 18:19:16,556
modelo de função que vimos um

27737
18:19:16,556 --> 18:19:18,244
Um exemplo disso, criando um

27738
18:19:18,244 --> 18:19:20,400
modelo de função de multiplicação e nós

27739
18:19:20,400 --> 18:19:22,720
vimos que tínhamos um erro de compilador se nós

27740
18:19:22,720 --> 18:19:25,436
tentar passar os argumentos de força std

27741
18:19:25,436 --> 18:19:27,756
porque não podemos multiplicar duas cordas

27742
18:19:27,756 --> 18:19:30,000
Isso é realmente tudo que eu tinha para compartilhar

27743
18:19:30,000 --> 18:19:32,400
Esta palestra eu peço desculpas que acabou

27744
18:19:32,400 --> 18:19:35,040
para ser longo, mas eu realmente tive que colocar

27745
18:19:35,040 --> 18:19:37,360
isso em uma palestra para que eu possa realmente

27746
18:19:37,360 --> 18:19:39,680
mostrar-lhe lados diferentes do mesmo

27747
18:19:39,680 --> 18:19:42,080
Coisas que vamos parar por aqui neste

27748
18:19:42,080 --> 18:19:43,756
palestra e a próxima que vamos

27749
18:19:43,756 --> 18:19:46,960
Saiba mais sobre a dedução do tipo template e

27750
18:19:46,960 --> 18:19:49,116
Argumentos explícitos

27751
18:19:49,116 --> 18:19:50,960
Vá em frente e termine aqui

27752
18:19:50,960 --> 18:19:52,640
e me encontrar lá

27753
18:19:52,640 --> 18:19:53,920
Nesta palestra vamos aprender

27754
18:19:53,920 --> 18:19:56,640
sobre a dedução do tipo modelo e

27755
18:19:56,640 --> 18:19:59,680
argumentos explícitos o que queremos dizer com

27756
18:19:59,680 --> 18:20:02,960
modelo de dedução é o mecanismo

27757
18:20:02,960 --> 18:20:04,960
O compilador usa

27758
18:20:04,960 --> 18:20:08,080
para deduzir o tipo que ele usaria para

27759
18:20:08,080 --> 18:20:10,476
configurar a nossa instância de modelo a partir do

27760
18:20:10,476 --> 18:20:12,796
argumentos que passamos para a nossa função

27761
18:20:12,796 --> 18:20:14,244
Chamar aqui

27762
18:20:14,244 --> 18:20:15,756
Por exemplo, o compilador vai

27763
18:20:15,756 --> 18:20:18,080
Olhe para a e b aqui em um chamado para o

27764
18:20:18,080 --> 18:20:20,244
função máxima e vai

27765
18:20:20,244 --> 18:20:22,400
notar que eles são de tipo e

27766
18:20:22,400 --> 18:20:24,720
então vai dizer ok que você está

27767
18:20:24,720 --> 18:20:27,280
chamando sua função com ele tipos e

27768
18:20:27,280 --> 18:20:30,156
Vejo que seus modelos de função levam

27769
18:20:30,156 --> 18:20:33,436
três substitutores aqui, então eu vou

27770
18:20:33,436 --> 18:20:36,080
Substitua esses caras e e é

27771
18:20:36,080 --> 18:20:38,080
Vou adivinhar isso a partir da chamada que

27772
18:20:38,080 --> 18:20:40,640
Você faz aqui não há outro mecanismo

27773
18:20:40,640 --> 18:20:42,796
para ajudar o compilador a sair deste é realmente

27774
18:20:42,796 --> 18:20:45,516
qual dedução de tipo de modelo é sobre

27775
18:20:45,516 --> 18:20:47,360
E para o primeiro exemplo aqui estamos

27776
18:20:47,360 --> 18:20:50,000
passando um parâmetro final assim

27777
18:20:50,000 --> 18:20:52,080
nt vai ser deduzido para o segundo

27778
18:20:52,080 --> 18:20:55,196
função call que estamos passando em duplo

27779
18:20:55,196 --> 18:20:57,436
parâmetro para um modelo de função dupla

27780
18:20:57,436 --> 18:20:59,680
A instância será gerada para

27781
18:20:59,680 --> 18:21:02,400
A terceira chamada aqui estamos usando std

27782
18:21:02,400 --> 18:21:04,156
parâmetros da string

27783
18:21:04,156 --> 18:21:07,280
Vamos deduzir um modelo

27784
18:21:07,280 --> 18:21:10,080
instância que usa a string hdd aqui

27785
18:21:10,080 --> 18:21:12,476
é o que queremos dizer com tipo de modelo

27786
18:21:12,476 --> 18:21:14,556
Dedução, mas nós vimos que

27787
18:21:14,556 --> 18:21:17,280
modelo automático de dedução pode

27788
18:21:17,280 --> 18:21:19,756
Realmente tem problemas, especialmente se você

27789
18:21:19,756 --> 18:21:22,556
passar parâmetros de diferentes tipos para

27790
18:21:22,556 --> 18:21:24,720
exemplo, se chamarmos uma função máxima

27791
18:21:24,720 --> 18:21:26,320
Aqui com a

27792
18:21:26,320 --> 18:21:29,196
a e c que acabam e

27793
18:21:29,196 --> 18:21:31,040
duplo tipo, então nós vamos ter um

27794
18:21:31,040 --> 18:21:33,436
problema porque este modelo de função

27795
18:21:33,436 --> 18:21:34,796
Não pode lidar com

27796
18:21:34,796 --> 18:21:37,516
parâmetros com diferentes tipos porque

27797
18:21:37,516 --> 18:21:40,080
o substituto é o mesmo que o compilador é

27798
18:21:40,080 --> 18:21:42,876
indo para fazer cumprir todo o modelo

27799
18:21:42,876 --> 18:21:45,360
Os argumentos são do mesmo tipo e

27800
18:21:45,360 --> 18:21:47,116
Os argumentos de template serão o que

27801
18:21:47,116 --> 18:21:49,516
você passa aqui, então a e b deve ser o

27802
18:21:49,516 --> 18:21:51,836
Mesmo se não for o mesmo

27803
18:21:51,836 --> 18:21:53,836
Por exemplo, formista e dupla você está indo

27804
18:21:53,836 --> 18:21:55,516
para obter um erro do compilador

27805
18:21:55,516 --> 18:21:57,436
Agora vamos ver que podemos usar

27806
18:21:57,436 --> 18:22:00,720
argumentos de modelo explícito e novamente i

27807
18:22:00,720 --> 18:22:02,556
Quero deixar bem claro o

27808
18:22:02,556 --> 18:22:05,360
Diferença entre um parâmetro template

27809
18:22:05,360 --> 18:22:07,756
e no argumento do modelo um modelo

27810
18:22:07,756 --> 18:22:09,756
parâmetro é o que você tem em seu

27811
18:22:09,756 --> 18:22:12,156
declaração de função ou uma definição assim

27812
18:22:12,156 --> 18:22:15,040
O que temos em nossa configuração de função aqui

27813
18:22:15,040 --> 18:22:16,476
São modelo

27814
18:22:16,476 --> 18:22:20,000
os parâmetros ta aqui e tb são template

27815
18:22:20,000 --> 18:22:22,796
Parâmetros, mas o que temos quando chamamos

27816
18:22:22,796 --> 18:22:25,360
um modelo de função vai ser

27817
18:22:25,360 --> 18:22:28,476
argumentos de modelo, por exemplo c e d

27818
18:22:28,476 --> 18:22:29,360
Aqui

27819
18:22:29,360 --> 18:22:31,600
são argumentos de modelo e nós vamos

27820
18:22:31,600 --> 18:22:34,080
usar essa terminologia neste

27821
18:22:34,080 --> 18:22:36,720
capítulo e muitos outros capítulos por vir

27822
18:22:36,720 --> 18:22:38,556
Neste curso, certifique-se de que isso é super

27823
18:22:38,556 --> 18:22:40,720
claro para que o que vamos olhar é

27824
18:22:40,720 --> 18:22:44,796
usando argumentos de modelo explícitos e

27825
18:22:44,796 --> 18:22:46,400
O que isto significa

27826
18:22:46,400 --> 18:22:48,640
É um mecanismo através do qual você pode

27827
18:22:48,640 --> 18:22:51,756
forçar o compilador a usar algum tipo para

27828
18:22:51,756 --> 18:22:53,920
gerar sua instância de modelo e

27829
18:22:53,920 --> 18:22:56,000
Sintaxe para fazer isso é realmente simples, é

27830
18:22:56,000 --> 18:22:58,640
O que temos aqui dizemos o máximo e nós

27831
18:22:58,640 --> 18:23:00,400
Coloque o tipo que queremos

27832
18:23:00,400 --> 18:23:03,116
usar para gerar nossa instância de modelo

27833
18:23:03,116 --> 18:23:05,040
em braquetes de ângulo como vemos aqui, então

27834
18:23:05,040 --> 18:23:07,116
Isso vai usar o dobro, então isso é

27835
18:23:07,116 --> 18:23:10,000
vamos explicitamente dizer ao compilador que nós

27836
18:23:10,000 --> 18:23:12,400
Quer a versão dupla chamada e é

27837
18:23:12,400 --> 18:23:14,400
vai gerar isso e é isso que

27838
18:23:14,400 --> 18:23:16,556
Será chamado por esta chamada nós

27839
18:23:16,556 --> 18:23:18,960
ter aqui um bom benefício com este

27840
18:23:18,960 --> 18:23:21,436
que agora isso vai apoiar

27841
18:23:21,436 --> 18:23:24,080
argumentos de modelos de diferentes tipos assim

27842
18:23:24,080 --> 18:23:25,756
Se fizermos o chamado assim de

27843
18:23:25,756 --> 18:23:27,756
O compilador vai ver que uh-huh nós

27844
18:23:27,756 --> 18:23:30,156
estão chamando com intenção tipos duplos

27845
18:23:30,156 --> 18:23:33,680
Porque a é ant e c é duplo

27846
18:23:33,680 --> 18:23:36,156
Mas vai ver que você quer

27847
18:23:36,156 --> 18:23:36,876
O que é

27848
18:23:36,876 --> 18:23:39,920
instância de modelo duplo gerado agora

27849
18:23:39,920 --> 18:23:42,400
O compilador terá a possibilidade

27850
18:23:42,400 --> 18:23:45,040
para fazer conversões implícitas de outros

27851
18:23:45,040 --> 18:23:47,756
tipos para dobrar e se isso implícito

27852
18:23:47,756 --> 18:23:50,000
A conversão falha, então vamos conseguir

27853
18:23:50,000 --> 18:23:52,156
um erro de compilador, portanto, se você procurar aqui

27854
18:23:52,156 --> 18:23:53,116
O exemplo

27855
18:23:53,116 --> 18:23:54,876
Este é o exemplo para que nós somos

27856
18:23:54,876 --> 18:23:59,360
passando em um e e e a é ant e e é

27857
18:23:59,360 --> 18:24:02,000
uma força std não podemos fazer um implícito

27858
18:24:02,000 --> 18:24:03,600
A conversão a partir de

27859
18:24:03,600 --> 18:24:06,156
força para dobrar, então isso está indo

27860
18:24:06,156 --> 18:24:08,156
para nos dar um erro de compilador e isso é

27861
18:24:08,156 --> 18:24:11,516
realmente todos os modelos de dedução e

27862
18:24:11,516 --> 18:24:14,080
argumentos explícitos são sobre podemos usar

27863
18:24:14,080 --> 18:24:15,836
essas coisas para realmente fazer o nosso código

27864
18:24:15,836 --> 18:24:18,640
Mais fácil agora que você entendeu isso

27865
18:24:18,640 --> 18:24:20,156
nós vamos ir para o visual

27866
18:24:20,156 --> 18:24:21,680
código de estúdio e jogar com isso um pouco

27867
18:24:21,680 --> 18:24:24,156
Mais aqui estamos em nosso trabalho

27868
18:24:24,156 --> 18:24:26,244
diretório do projeto atual é

27869
18:24:26,244 --> 18:24:29,116
deduções de tipo de modelo e explícito

27870
18:24:29,116 --> 18:24:31,360
argumentos que vamos agarrar o nosso

27871
18:24:31,360 --> 18:24:33,836
modelo de arquivos muito rápido e colocá-los

27872
18:24:33,836 --> 18:24:36,080
no lugar e depois disso vamos

27873
18:24:36,080 --> 18:24:38,156
abrir isso em código de estúdio visual, vamos

27874
18:24:38,156 --> 18:24:40,556
arrastar e soltar em cima do estúdio visual

27875
18:24:40,556 --> 18:24:42,720
código aqui vai abrir o nosso

27876
18:24:42,720 --> 18:24:46,400
pasta e podemos abrir o nosso arquivo principal cpp

27877
18:24:46,400 --> 18:24:47,436
E a

27878
18:24:47,436 --> 18:24:49,836
configurar o nosso modelo de função vamos limpar

27879
18:24:49,836 --> 18:24:51,680
Isso um pouco e nós vamos

27880
18:24:51,680 --> 18:24:54,476
configurar o nosso modelo de função

27881
18:24:54,476 --> 18:24:56,400
Isso é apenas para praticar, então estamos

27882
18:24:56,400 --> 18:24:58,640
vamos dizer modelo e nós vamos

27883
18:24:58,640 --> 18:25:01,196
Diga nome do tipo e vamos dizer t

27884
18:25:01,196 --> 18:25:02,960
E se você quiser, você pode colocar isso em um

27885
18:25:02,960 --> 18:25:05,756
uma linha, mas eu prefiro colocar isso

27886
18:25:05,756 --> 18:25:08,320
linhas separadas, mas vamos mostrar que

27887
18:25:08,320 --> 18:25:10,476
então nós vamos dizer t aqui e nós estamos

27888
18:25:10,476 --> 18:25:12,320
vamos dizer o máximo e nós vamos

27889
18:25:12,320 --> 18:25:14,400
Diga os parâmetros que eles vão ser

27890
18:25:14,400 --> 18:25:17,756
do tipo t e podemos passá-los por valor

27891
18:25:17,756 --> 18:25:19,360
Só por agora e depois disso estamos indo

27892
18:25:19,360 --> 18:25:21,836
para entrar no corpo da nossa função

27893
18:25:21,836 --> 18:25:23,600
modelo e então podemos retornar

27894
18:25:23,600 --> 18:25:26,720
Qualquer parâmetro que seja o máximo que somos

27895
18:25:26,720 --> 18:25:28,796
vamos dizer um maior que b aqui estamos

27896
18:25:28,796 --> 18:25:31,516
usar nosso operador ternário e se

27897
18:25:31,516 --> 18:25:34,000
a é maior nós vamos voltar um se

27898
18:25:34,000 --> 18:25:36,320
b é maior, vamos voltar b e

27899
18:25:36,320 --> 18:25:38,320
Esta é a nossa função aqui, tudo bem agora que

27900
18:25:38,320 --> 18:25:40,400
esta função é configurando um

27901
18:25:40,400 --> 18:25:42,720
Poucas variáveis para realmente jogar com isso

27902
18:25:42,720 --> 18:25:44,960
Vamos incluir a corda

27903
18:25:44,960 --> 18:25:46,876
biblioteca porque vamos usar

27904
18:25:46,876 --> 18:25:49,116
um pouco e nós vamos embora

27905
18:25:49,116 --> 18:25:52,476
para baixo na função principal e colocar em nosso

27906
18:25:52,476 --> 18:25:56,476
poucas variáveis que temos por meio de f aqui

27907
18:25:56,476 --> 18:26:00,156
e b são final c e d são do tipo duplo

27908
18:26:00,156 --> 18:26:04,156
e e f são do tipo std strand a

27909
18:26:04,156 --> 18:26:06,244
A primeira coisa que podemos fazer podemos dizer auto

27910
18:26:06,244 --> 18:26:09,196
max e nós podemos atribuir o que é

27911
18:26:09,196 --> 18:26:11,920
máximo entre a e b e uma vez que fazemos

27912
18:26:11,920 --> 18:26:13,756
Isso nós vamos ter o máximo

27913
18:26:13,756 --> 18:26:16,796
armazenado no máximo aqui, mas o que eu quero você

27914
18:26:16,796 --> 18:26:19,680
ver o que o compilador faz quando

27915
18:26:19,680 --> 18:26:22,640
vê o código como este que o compilador tem

27916
18:26:22,640 --> 18:26:25,116
Não há outra ajuda externa

27917
18:26:25,116 --> 18:26:28,320
para conhecer a instância do modelo de função

27918
18:26:28,320 --> 18:26:30,476
Deve realmente gerar que vai

27919
18:26:30,476 --> 18:26:33,040
Veja os tipos que temos aqui a e b

27920
18:26:33,040 --> 18:26:34,876
Vai ver que eles são do tipo

27921
18:26:34,876 --> 18:26:38,000
e vai ver que ele pode usar

27922
18:26:38,000 --> 18:26:40,156
O modelo de função que temos aqui e

27923
18:26:40,156 --> 18:26:41,920
vai usar isso e gerar um

27924
18:26:41,920 --> 18:26:43,280
instância de modelo que vai fazer

27925
18:26:43,280 --> 18:26:45,600
tomar e ele vai chamá-lo para

27926
18:26:45,600 --> 18:26:48,080
obter o nosso máximo aqui novamente podemos provar

27927
18:26:48,080 --> 18:26:50,080
Isso através do depurador vamos

27928
18:26:50,080 --> 18:26:51,836
configurar um ponto de ruptura que vamos ir para

27929
18:26:51,836 --> 18:26:55,280
nossa guia de corrida aqui e vamos correr

27930
18:26:55,280 --> 18:26:57,360
Isso através do nosso depurador

27931
18:26:57,360 --> 18:26:59,436
nós vamos construir nossa coisa e quando

27932
18:26:59,436 --> 18:27:01,920
nós atingimos a função principal que você vai

27933
18:27:01,920 --> 18:27:05,040
Veja que a é 10 b é 23, que é o que

27934
18:27:05,040 --> 18:27:08,400
Temos aqui cd temos os nossos valores n e

27935
18:27:08,400 --> 18:27:11,196
string std porque é um tipo composto

27936
18:27:11,196 --> 18:27:13,920
ou um tipo personalizado, podemos expandir sobre isso

27937
18:27:13,920 --> 18:27:15,516
e realmente ver mais informações sobre

27938
18:27:15,516 --> 18:27:17,680
Mas não temos ferramentas suficientes para

27939
18:27:17,680 --> 18:27:19,836
realmente entender isso agora, então nós somos

27940
18:27:19,836 --> 18:27:22,796
indo apenas para usar isso como um invólucro

27941
18:27:22,796 --> 18:27:25,280
em nossas informações de fluxo aqui agora

27942
18:27:25,280 --> 18:27:27,360
Quer chamar a função máxima e

27943
18:27:27,360 --> 18:27:30,244
Veja o que foi gerado pelo compilador

27944
18:27:30,244 --> 18:27:32,080
e nós podemos entrar nesta função

27945
18:27:32,080 --> 18:27:34,000
porque atingimos o ponto de ruptura por

27946
18:27:34,000 --> 18:27:34,796
E agora

27947
18:27:34,796 --> 18:27:37,280
Então, se entrarmos em frente, vamos

27948
18:27:37,280 --> 18:27:39,280
entre nessa função e nós vamos

27949
18:27:39,280 --> 18:27:41,756
ver que é uma função int

27950
18:27:41,756 --> 18:27:44,244
A instância que foi gerada é

27951
18:27:44,244 --> 18:27:46,400
o suficiente para os nossos propósitos

27952
18:27:46,400 --> 18:27:49,360
se mudarmos nosso chamado aqui para usar c e

27953
18:27:49,360 --> 18:27:51,116
d Vamos gerar um duplo

27954
18:27:51,116 --> 18:27:53,360
exemplo, então vamos fazer isso, vamos

27955
18:27:53,360 --> 18:27:55,360
gerar uma instância dupla e se nós

27956
18:27:55,360 --> 18:27:56,960
Impressear isso, vamos ver isso

27957
18:27:56,960 --> 18:27:59,196
impresso fora, mas podemos usar o depurador

27958
18:27:59,196 --> 18:28:01,116
para realmente provar isso não que nós sabemos

27959
18:28:01,116 --> 18:28:03,196
Como usá-lo não temos que olhar

27960
18:28:03,196 --> 18:28:05,516
através da janela de saída do terminal, mas

27961
18:28:05,516 --> 18:28:07,280
Você pode fazer isso se quiser, você pode definir

27962
18:28:07,280 --> 18:28:09,680
up sddc out e imprima o máximo aqui você está

27963
18:28:09,680 --> 18:28:12,244
indo vê-lo impresso, então vamos correr

27964
18:28:12,244 --> 18:28:13,920
Nosso depurador nós vamos ver o

27965
18:28:13,920 --> 18:28:16,400
template instance que foi gerada

27966
18:28:16,400 --> 18:28:18,400
através do divisor nós vamos bater

27967
18:28:18,400 --> 18:28:21,280
o ponto de interrupção na linha 17 aqui

27968
18:28:21,280 --> 18:28:23,516
Se entrarmos, vamos ver o

27969
18:28:23,516 --> 18:28:25,836
variáveis locais para nossa função aqui a

27970
18:28:25,836 --> 18:28:26,796
e b

27971
18:28:26,796 --> 18:28:29,116
E nós vamos ter o máximo

27972
18:28:29,116 --> 18:28:31,516
Função para o topo da pilha de chamadas

27973
18:28:31,516 --> 18:28:33,360
e você vai ver que é um

27974
18:28:33,360 --> 18:28:35,836
instância dupla para nossa função

27975
18:28:35,836 --> 18:28:37,360
modelo aqui

27976
18:28:37,360 --> 18:28:39,920
Tudo bem é isso que queremos dizer com

27977
18:28:39,920 --> 18:28:43,196
modelo de dedução de que é o

27978
18:28:43,196 --> 18:28:45,196
mecanismo padrão

27979
18:28:45,196 --> 18:28:48,156
que o compilador usa para saber

27980
18:28:48,156 --> 18:28:50,796
que template instance para gerar a partir

27981
18:28:50,796 --> 18:28:53,196
suas chamadas de função, mas como vimos

27982
18:28:53,196 --> 18:28:55,040
Na última palestra pode ser

27983
18:28:55,040 --> 18:28:56,476
problemático

27984
18:28:56,476 --> 18:28:59,600
Uma maneira que isso pode ser ruim é se você passar

27985
18:28:59,600 --> 18:29:02,080
diferentes tipos para a função máxima

27986
18:29:02,080 --> 18:29:05,360
Aqui vamos passar em a e c, por exemplo

27987
18:29:05,360 --> 18:29:07,680
ou a e d isso vai funcionar igualmente

27988
18:29:07,680 --> 18:29:09,516
Bem, você vê que nós temos um compilador

27989
18:29:09,516 --> 18:29:12,476
Erro porque o compilador agora diz

27990
18:29:12,476 --> 18:29:15,680
que estamos chamando com diferentes tipos

27991
18:29:15,680 --> 18:29:18,080
mas os parâmetros do modelo aqui são

27992
18:29:18,080 --> 18:29:20,080
realmente do mesmo tipo que deveriam ser

27993
18:29:20,080 --> 18:29:22,320
do mesmo tipo porque t vai

27994
18:29:22,320 --> 18:29:24,960
ser substituído por um único tempo para que o

27995
18:29:24,960 --> 18:29:26,876
chamar que fazemos aqui vai falhar e se

27996
18:29:26,876 --> 18:29:28,960
nós executamos isso através do compilador novamente

27997
18:29:28,960 --> 18:29:31,280
Vamos fazer isso vamos usar gcc

27998
18:29:31,280 --> 18:29:32,876
vamos ter um erro de compilador e

27999
18:29:32,876 --> 18:29:34,720
vai dizer deduzir conflitos

28000
18:29:34,720 --> 18:29:36,796
tipos para o parâmetro t

28001
18:29:36,796 --> 18:29:39,436
e então dobrar para que ele não possa realmente saber

28002
18:29:39,436 --> 18:29:41,360
qual você quer que você queira ent ou

28003
18:29:41,360 --> 18:29:43,756
dobrar o compilador não sabe e ele

28004
18:29:43,756 --> 18:29:46,640
vai nos dar um erro de compilador, mas

28005
18:29:46,640 --> 18:29:48,400
Agora vamos ver um mecanismo

28006
18:29:48,400 --> 18:29:50,720
pode usar para fazer este trabalho e isso é

28007
18:29:50,720 --> 18:29:53,836
serão argumentos de modelo explícitos

28008
18:29:53,836 --> 18:29:56,720
O que podemos fazer para fazer isso podemos ir

28009
18:29:56,720 --> 18:29:59,116
para baixo e colocar em nosso chamado que vamos

28010
18:29:59,116 --> 18:30:02,244
Diga auto e diga resultado ou max que podemos

28011
18:30:02,244 --> 18:30:03,836
Chamem isto como queremos, vamos

28012
18:30:03,836 --> 18:30:05,436
Diga o nome da função e nós somos

28013
18:30:05,436 --> 18:30:07,196
indo para especificar

28014
18:30:07,196 --> 18:30:10,080
O tipo de modelo que queremos gerar

28015
18:30:10,080 --> 18:30:12,476
para o nosso modelo de função aqui, então se nós

28016
18:30:12,476 --> 18:30:14,876
fazer algo assim com o dobro

28017
18:30:14,876 --> 18:30:17,360
dentro de suportes de ângulo aqui estamos indo

28018
18:30:17,360 --> 18:30:19,600
para ser basicamente dizendo o compilador

28019
18:30:19,600 --> 18:30:22,556
Gere um modelo duplo

28020
18:30:22,556 --> 18:30:25,516
por exemplo, para esta chamada que estamos fazendo aqui

28021
18:30:25,516 --> 18:30:28,000
Então, se passarmos em c e d por exemplo

28022
18:30:28,000 --> 18:30:29,600
Isso vai nos dar o que queremos

28023
18:30:29,600 --> 18:30:31,836
e nós podemos imprimir isso se nós

28024
18:30:31,836 --> 18:30:34,320
Quero, então vamos dizer max OK, isso está indo

28025
18:30:34,320 --> 18:30:37,836
para trabalhar se construirmos vamos construir com gcc

28026
18:30:37,836 --> 18:30:39,280
Vamos usar isso

28027
18:30:39,280 --> 18:30:41,436
A construção vai ser boa porque nós

28028
18:30:41,436 --> 18:30:43,600
estão passando qualquer duplo

28029
18:30:43,600 --> 18:30:46,000
argumentos e se nós executarmos isso, devemos

28030
18:30:46,000 --> 18:30:48,640
ver o nosso máximo vamos trazer um

28031
18:30:48,640 --> 18:30:51,360
janela terminal e um código de estúdio visual

28032
18:30:51,360 --> 18:30:53,680
para que possamos usar isso para ver

28033
18:30:53,680 --> 18:30:55,680
Coisas correndo, vamos limpar e

28034
18:30:55,680 --> 18:30:57,920
correr galo você vê que temos o nosso

28035
18:30:57,920 --> 18:31:02,244
máximo aqui, mas usando modelo explícito

28036
18:31:02,244 --> 18:31:04,556
argumentos como estamos fazendo aqui é

28037
18:31:04,556 --> 18:31:07,280
permitir que passemos diferentes

28038
18:31:07,280 --> 18:31:10,080
tipos para nossos argumentos de modelo e para

28039
18:31:10,080 --> 18:31:12,080
Exemplo agora podemos mudar o primeiro

28040
18:31:12,080 --> 18:31:14,476
argumento aqui para ba que vai ser

28041
18:31:14,476 --> 18:31:16,400
um fim e nós vamos deixar o

28042
18:31:16,400 --> 18:31:19,756
segundo um para bd que é de tipo duplo

28043
18:31:19,756 --> 18:31:21,920
Agora o compilador vai ver que

28044
18:31:21,920 --> 18:31:24,080
Vamos gerar um template

28045
18:31:24,080 --> 18:31:26,960
instância do tipo duplo e vai

28046
18:31:26,960 --> 18:31:28,960
Saber que ele pode fazer implícito

28047
18:31:28,960 --> 18:31:31,756
conversões para os argumentos que passamos

28048
18:31:31,756 --> 18:31:34,556
Aqui, então isso vai funcionar se passarmos

28049
18:31:34,556 --> 18:31:36,640
Um argumento que é implicitamente

28050
18:31:36,640 --> 18:31:39,600
conversível para o tipo que passamos no

28051
18:31:39,600 --> 18:31:42,720
suportes de ângulo aqui e vamos depurar isso

28052
18:31:42,720 --> 18:31:44,960
Mais uma vez para mostrar que nós vamos

28053
18:31:44,960 --> 18:31:47,516
gerar uma instância de modelo duplo que

28054
18:31:47,516 --> 18:31:49,196
vai ser chamado e nos dar o

28055
18:31:49,196 --> 18:31:52,400
máximo que imprimimos aqui para que possamos rodar

28056
18:31:52,400 --> 18:31:55,196
nosso depurador batendo a corrida verde

28057
18:31:55,196 --> 18:31:57,680
botão aqui vamos minimizar isso para que

28058
18:31:57,680 --> 18:31:59,196
Nós podemos ver

28059
18:31:59,196 --> 18:32:02,000
nossa janela do terminal e está aqui em baixo

28060
18:32:02,000 --> 18:32:04,400
Vamos agarrá-lo e colocá-lo à esquerda, então

28061
18:32:04,400 --> 18:32:07,040
que nós podemos realmente ver as coisas impressas

28062
18:32:07,040 --> 18:32:08,796
fora como nós depuramos

28063
18:32:08,796 --> 18:32:11,516
Nós atingimos o ponto de interrupção aqui e nós

28064
18:32:11,516 --> 18:32:13,360
ter nossas variáveis locais que você pode olhar

28065
18:32:13,360 --> 18:32:15,116
Isso se você quiser é basicamente o que nós

28066
18:32:15,116 --> 18:32:17,280
ter na função principal aqui, mas o que

28067
18:32:17,280 --> 18:32:19,920
Queremos entrar nesse máximo

28068
18:32:19,920 --> 18:32:20,876
A função

28069
18:32:20,876 --> 18:32:22,640
E nós vamos ver

28070
18:32:22,640 --> 18:32:25,280
A instância do modelo que foi gerada

28071
18:32:25,280 --> 18:32:27,756
Você vê que é de um tipo duplo aqui

28072
18:32:27,756 --> 18:32:30,156
OK espero que agora você pode ver isso mesmo

28073
18:32:30,156 --> 18:32:34,000
Se passamos valores diferentes para a nossa

28074
18:32:34,000 --> 18:32:36,000
argumentos de modelo eu devo dizer

28075
18:32:36,000 --> 18:32:38,960
diferentes tipos porque a é do tipo e

28076
18:32:38,960 --> 18:32:42,080
e d é do tipo duplo, mas nós não somos

28077
18:32:42,080 --> 18:32:44,556
obtendo um erro de compilador, o compilador é

28078
18:32:44,556 --> 18:32:47,436
indo para inserir conversões implícitas

28079
18:32:47,436 --> 18:32:50,796
de quaisquer argumentos que passemos aqui para

28080
18:32:50,796 --> 18:32:53,600
O argumento de modelo explícito de que

28081
18:32:53,600 --> 18:32:56,400
Especificado aqui novamente o explícito

28082
18:32:56,400 --> 18:32:58,556
argumento de modelo como estamos fazendo aqui

28083
18:32:58,556 --> 18:33:01,196
usando a sintaxe com suportes angulares e

28084
18:33:01,196 --> 18:33:03,516
Colocar o nosso tipo vai dizer o

28085
18:33:03,516 --> 18:33:06,400
Compilador por favor use este tipo e

28086
18:33:06,400 --> 18:33:09,116
substituir isso por t em nossa função

28087
18:33:09,116 --> 18:33:11,680
modelo aqui e gerar um template

28088
18:33:11,680 --> 18:33:14,156
A instância podemos chamar para atender isso

28089
18:33:14,156 --> 18:33:16,400
chamar aqui e nós vamos fazer implícito

28090
18:33:16,400 --> 18:33:18,640
As conversões basicamente a partir de

28091
18:33:18,640 --> 18:33:20,556
E dobrar porque isso é o que nós

28092
18:33:20,556 --> 18:33:22,876
Quer então d vai ser de duplo

28093
18:33:22,876 --> 18:33:24,876
Digite que não vamos fazer nenhum implícito

28094
18:33:24,876 --> 18:33:26,556
Conversão, então vamos chamar isso

28095
18:33:26,556 --> 18:33:28,476
Função, vamos devolver um duplo

28096
18:33:28,476 --> 18:33:30,476
Porque esse é o nosso modelo

28097
18:33:30,476 --> 18:33:32,320
A instância e vamos imprimir isso

28098
18:33:32,320 --> 18:33:34,156
Aqui isso é o que está acontecendo e

28099
18:33:34,156 --> 18:33:36,720
Podemos provar que uma dupla instância foi

28100
18:33:36,720 --> 18:33:39,436
gerado através da nossa chap stack aqui nós

28101
18:33:39,436 --> 18:33:42,640
ver a função máxima está tomando

28102
18:33:42,640 --> 18:33:44,476
Parâmetros duplos e vai

28103
18:33:44,476 --> 18:33:48,400
retorno duplo como nosso explícito

28104
18:33:48,400 --> 18:33:50,244
argumento de modelo aqui este é o

28105
18:33:50,244 --> 18:33:54,156
sintaxe que o Gcc usa está usando, mas nós

28106
18:33:54,156 --> 18:33:56,556
Saiba agora que é um modelo duplo

28107
18:33:56,556 --> 18:33:59,360
Por exemplo, uma chamada de função aqui ok

28108
18:33:59,360 --> 18:34:02,000
Se você não está feliz com o que somos

28109
18:34:02,000 --> 18:34:04,796
Ver com o depurador você também pode

28110
18:34:04,796 --> 18:34:07,516
Use insights cpp para realmente provar isso

28111
18:34:07,516 --> 18:34:09,280
Vamos abrir isso, vamos dizer

28112
18:34:09,280 --> 18:34:11,600
Cpp insights

28113
18:34:11,600 --> 18:34:13,836
Vamos fazer isso e nós vamos tê-lo

28114
18:34:13,836 --> 18:34:16,000
Aberto aqui ok, vamos

28115
18:34:16,000 --> 18:34:17,836
Apague o que tivermos aqui e estamos

28116
18:34:17,836 --> 18:34:20,476
Vou colocar outro pedaço de código que nós

28117
18:34:20,476 --> 18:34:23,436
ter a nossa função máxima, devo dizer

28118
18:34:23,436 --> 18:34:25,600
modelo de função ou modelo de função

28119
18:34:25,600 --> 18:34:27,436
E nós temos álcool aqui e é

28120
18:34:27,436 --> 18:34:30,876
passando diferentes tipos a e d lembre-se

28121
18:34:30,876 --> 18:34:32,720
A última vez que fizemos algo assim

28122
18:34:32,720 --> 18:34:35,600
passando em diferentes tipos para o

28123
18:34:35,600 --> 18:34:38,476
argumento de modelo este cara falhou

28124
18:34:38,476 --> 18:34:40,796
Não poderia realmente gerar uma função

28125
18:34:40,796 --> 18:34:43,116
instância de modelo porque modelo

28126
18:34:43,116 --> 18:34:45,920
parâmetros que temos no topo aqui especificar

28127
18:34:45,920 --> 18:34:48,080
que esses caras deveriam ser do mesmo

28128
18:34:48,080 --> 18:34:50,476
Digite, mas agora somos capazes de usar

28129
18:34:50,476 --> 18:34:53,516
diferentes tipos como argumentos, porque nós

28130
18:34:53,516 --> 18:34:56,320
ter um argumento explícito especificado

28131
18:34:56,320 --> 18:34:58,476
Vamos executar isso e ver o modelo

28132
18:34:58,476 --> 18:35:00,960
instância que é gerada e você pode

28133
18:35:00,960 --> 18:35:02,960
Veja que é de tipo duplo

28134
18:35:02,960 --> 18:35:06,244
basicamente substituiu todas as instâncias de t

28135
18:35:06,244 --> 18:35:08,960
aqui com o dobro e esta função é

28136
18:35:08,960 --> 18:35:11,280
vai ser chamado para atender a chamada

28137
18:35:11,280 --> 18:35:13,280
Estamos fazendo aqui ok, isso é realmente

28138
18:35:13,280 --> 18:35:15,280
Tudo o que nos prossamos fazer nesta palestra eu

28139
18:35:15,280 --> 18:35:17,196
Espero que você tenha achado interessante o principal

28140
18:35:17,196 --> 18:35:19,600
mensagem era modelo de tipo dedução a

28141
18:35:19,600 --> 18:35:22,796
mecanismo padrão c plus plus usos para

28142
18:35:22,796 --> 18:35:24,960
Saiba quais instâncias de modelo

28143
18:35:24,960 --> 18:35:27,680
gerar a partir de suas chamadas de função, mas se

28144
18:35:27,680 --> 18:35:30,156
Os padrões não estão funcionando para você

28145
18:35:30,156 --> 18:35:33,280
pode usar argumentos de modelo explícitos para

28146
18:35:33,280 --> 18:35:36,400
especificar a instância de modelo desejada

28147
18:35:36,400 --> 18:35:39,040
para gerá-lo, vamos parar por aqui

28148
18:35:39,040 --> 18:35:40,720
Nesta palestra no próximo somos

28149
18:35:40,720 --> 18:35:42,796
Vou ver como podemos passar template

28150
18:35:42,796 --> 18:35:45,196
Os parâmetros por referência

28151
18:35:45,196 --> 18:35:47,516
Vá em frente e termine aqui e me encontre

28152
18:35:47,516 --> 18:35:49,116
lá nesta palestra vamos

28153
18:35:49,116 --> 18:35:51,436
mostrar que você pode passar seu modelo

28154
18:35:51,436 --> 18:35:54,320
digitar parâmetros por referência e nós somos

28155
18:35:54,320 --> 18:35:56,244
Vou olhar para um exemplo simples para

28156
18:35:56,244 --> 18:35:58,320
Realmente conduz este para casa o que temos visto

28157
18:35:58,320 --> 18:36:00,320
Até agora é que podemos fazer coisas como

28158
18:36:00,320 --> 18:36:03,116
isto e especificar o nosso t like isto e

28159
18:36:03,116 --> 18:36:05,280
Isso vai gerar um template

28160
18:36:05,280 --> 18:36:08,476
instância que passa nossos argumentos por

28161
18:36:08,476 --> 18:36:11,116
valor, por exemplo, se passarmos no dobro

28162
18:36:11,116 --> 18:36:13,756
e o dobro b aqui para o nosso máximo estamos

28163
18:36:13,756 --> 18:36:16,244
vai gerar uma instância de modelo

28164
18:36:16,244 --> 18:36:18,556
que leva dupla como parâmetros e

28165
18:36:18,556 --> 18:36:20,796
retorna um duplo aqui e isso está acontecendo

28166
18:36:20,796 --> 18:36:23,116
estar fazendo as coisas por valor, tudo bem, isso é

28167
18:36:23,116 --> 18:36:25,516
O que eu quero que você se concentre agora

28168
18:36:25,516 --> 18:36:27,516
é que isso vai fazer as coisas

28169
18:36:27,516 --> 18:36:30,476
valor para que, se formos em nossa função aqui

28170
18:36:30,476 --> 18:36:32,400
e calcular o máximo que você está indo para

28171
18:36:32,400 --> 18:36:34,720
Veja que os endereços que temos no

28172
18:36:34,720 --> 18:36:37,196
Fora vai ser diferente de

28173
18:36:37,196 --> 18:36:39,920
os endereços que temos no interior aqui

28174
18:36:39,920 --> 18:36:42,640
Se tentarmos imprimi-los, mas você pode

28175
18:36:42,640 --> 18:36:44,960
também passar seus parâmetros de modelo por

28176
18:36:44,960 --> 18:36:47,436
referência e a sintaxe para fazer isso é

28177
18:36:47,436 --> 18:36:50,000
ridiculamente fácil você apenas usa isso como

28178
18:36:50,000 --> 18:36:52,400
você usaria qualquer referência que dissermos elenco

28179
18:36:52,400 --> 18:36:54,640
t referência aqui e isso vai

28180
18:36:54,640 --> 18:36:58,000
apenas substitua em qualquer tipo que você

28181
18:36:58,000 --> 18:37:00,000
passar quando você chamar a função aqui para

28182
18:37:00,000 --> 18:37:02,556
O exemplo aqui estamos passando em duplo

28183
18:37:02,556 --> 18:37:05,516
argumentos para que isso deduza de uma

28184
18:37:05,516 --> 18:37:08,320
instância de modelo duplo que basicamente

28185
18:37:08,320 --> 18:37:11,280
diz custo duplo referência custo máximo custo

28186
18:37:11,280 --> 18:37:13,196
dupla referência a e custo duplo

28187
18:37:13,196 --> 18:37:15,436
referência b e este vai ser o

28188
18:37:15,436 --> 18:37:17,516
A função que é chamada assim isso está indo

28189
18:37:17,516 --> 18:37:20,320
para realmente fazer as coisas por referência e

28190
18:37:20,320 --> 18:37:22,640
valores que temos dentro de uma função

28191
18:37:22,640 --> 18:37:25,680
corpo de modelo aqui vai ser verdade

28192
18:37:25,680 --> 18:37:27,920
referências aos valores que temos sobre

28193
18:37:27,920 --> 18:37:29,680
Fora, se acontecer de fazer qualquer

28194
18:37:29,680 --> 18:37:31,600
modificação no corpo do

28195
18:37:31,600 --> 18:37:33,680
função da modificação vai ser

28196
18:37:33,680 --> 18:37:35,920
visível por fora o que estamos indo

28197
18:37:35,920 --> 18:37:38,000
Estar fazendo nesta palestra é apenas

28198
18:37:38,000 --> 18:37:40,080
Imprimindo os endereços aqui e nós estamos

28199
18:37:40,080 --> 18:37:42,080
Vou ver que eles são os mesmos aqui

28200
18:37:42,080 --> 18:37:45,436
no exterior e dentro do corpo de

28201
18:37:45,436 --> 18:37:48,000
nosso modelo de função aqui ok isso é

28202
18:37:48,000 --> 18:37:50,320
com o que queremos realmente brincar neste

28203
18:37:50,320 --> 18:37:52,720
palestra, mas antes de nos dirigirmos para

28204
18:37:52,720 --> 18:37:54,960
código de estúdio visual que eu quero te mostrar

28205
18:37:54,960 --> 18:37:57,196
que você pode confundir seu compilador se

28206
18:37:57,196 --> 18:37:59,836
Você não tem cuidado se você configurar estes

28207
18:37:59,836 --> 18:38:02,400
dois modelos de função que você vê aqui

28208
18:38:02,400 --> 18:38:04,556
Eles vão ser sobrecargas e nós

28209
18:38:04,556 --> 18:38:06,320
pode usar sobrecargas de função com

28210
18:38:06,320 --> 18:38:08,244
templates, mas por enquanto estamos apenas indo

28211
18:38:08,244 --> 18:38:10,476
para focar nos parâmetros que somos

28212
18:38:10,476 --> 18:38:12,960
passando aqui o primeiro é levado

28213
18:38:12,960 --> 18:38:15,116
Obrigado pelo volume

28214
18:38:15,116 --> 18:38:17,360
e o segundo é agradecer por

28215
18:38:17,360 --> 18:38:19,360
Referência como vemos aqui

28216
18:38:19,360 --> 18:38:21,600
E se emitirmos uma chamada como esta, nós somos

28217
18:38:21,600 --> 18:38:24,000
Vou ter o mesmo problema que temos

28218
18:38:24,000 --> 18:38:26,556
visto com sobrecargas de função antes disso

28219
18:38:26,556 --> 18:38:28,320
não vai saber se você é

28220
18:38:28,320 --> 18:38:30,640
Chamada por valor ou por referência e

28221
18:38:30,640 --> 18:38:32,800
Isso vai causar um erro de compilador

28222
18:38:32,800 --> 18:38:34,720
Eu realmente quero que você esteja ciente disso

28223
18:38:34,720 --> 18:38:36,160
Tudo bem agora que você sabe disso, estamos indo

28224
18:38:36,160 --> 18:38:38,160
para ir até o código do estúdio visual e

28225
18:38:38,160 --> 18:38:40,160
realmente brincar com a gente um pouco mais bem

28226
18:38:40,160 --> 18:38:42,800
Aqui estamos em nossa pasta de trabalho o

28227
18:38:42,800 --> 18:38:45,512
O projeto atual é parâmetros de modelo

28228
18:38:45,512 --> 18:38:47,680
por referência nós vamos pegar o nosso

28229
18:38:47,680 --> 18:38:50,800
modelo de arquivos e colocá-los no lugar assim

28230
18:38:50,800 --> 18:38:52,872
Vamos fazer isso e vamos abrir

28231
18:38:52,872 --> 18:38:55,512
Este garotinho em código de estúdio visual por

28232
18:38:55,512 --> 18:38:58,080
arrastando e soltando aqui a pasta é

28233
18:38:58,080 --> 18:39:00,160
indo para abrir-se, vamos abri-lo

28234
18:39:00,160 --> 18:39:02,080
e nós vamos fechar o painel esquerdo

28235
18:39:02,080 --> 18:39:05,920
aqui e limpar nosso arquivo principal aqui e

28236
18:39:05,920 --> 18:39:08,000
Vamos colocar em nossa função

28237
18:39:08,000 --> 18:39:10,320
modelo de uma coisa que eu quero que você veja em

28238
18:39:10,320 --> 18:39:12,400
Esta palestra é que é possível

28239
18:39:12,400 --> 18:39:14,480
Separe essas coisas em função

28240
18:39:14,480 --> 18:39:16,800
declaração e definição de função

28241
18:39:16,800 --> 18:39:18,800
Vamos apenas tentar fazer isso aqui para que

28242
18:39:18,800 --> 18:39:20,872
você pode realmente ver isso e então você está

28243
18:39:20,872 --> 18:39:22,552
ter que escolher o que você gosta de

28244
18:39:22,552 --> 18:39:24,640
Pouco mais, então vamos pegar uma função

28245
18:39:24,640 --> 18:39:27,040
cabeçalho aqui e use isso como um protótipo

28246
18:39:27,040 --> 18:39:29,280
vamos colocar isso na frente do

28247
18:39:29,280 --> 18:39:31,440
função principal e isso vai ser o nosso

28248
18:39:31,440 --> 18:39:34,552
declaração e se descermos após o

28249
18:39:34,552 --> 18:39:37,192
A principal função aqui o que temos é o nosso

28250
18:39:37,192 --> 18:39:39,440
definição que poderia funcionar e isso é

28251
18:39:39,440 --> 18:39:41,832
vai gerar instâncias de modelo para

28252
18:39:41,832 --> 18:39:44,080
as chamadas que fazemos na função principal

28253
18:39:44,080 --> 18:39:45,920
Aqui bem agora que temos isso, podemos

28254
18:39:45,920 --> 18:39:47,920
cabeça na função principal e realmente

28255
18:39:47,920 --> 18:39:50,320
jogar com o modelo de função aqui

28256
18:39:50,320 --> 18:39:51,760
nós vamos configurar dois duplos

28257
18:39:51,760 --> 18:39:53,600
parâmetros e vamos chamar o

28258
18:39:53,600 --> 18:39:56,400
Função, por exemplo, dizemos resultado de addon

28259
18:39:56,400 --> 18:39:58,640
e nós vamos chamar o máximo

28260
18:39:58,640 --> 18:40:00,320
Função e vamos passar em um

28261
18:40:00,320 --> 18:40:02,552
e b isto vai fazer

28262
18:40:02,552 --> 18:40:05,040
modelo padrão de dedução e ele

28263
18:40:05,040 --> 18:40:08,160
vai gerar uma dupla função

28264
18:40:08,160 --> 18:40:10,320
template instance aqui, mas o que nós

28265
18:40:10,320 --> 18:40:12,080
Real realmente querer provar é que isso é

28266
18:40:12,080 --> 18:40:14,480
passar as coisas por valor e uma

28267
18:40:14,480 --> 18:40:16,720
A maneira que temos que provar isso é para superar

28268
18:40:16,720 --> 18:40:20,160
os endereços tanto no exterior quanto no

28269
18:40:20,160 --> 18:40:22,320
O interior da função aqui você vê

28270
18:40:22,320 --> 18:40:24,240
Já estamos fazendo isso em nosso

28271
18:40:24,240 --> 18:40:26,240
corpo do modelo de função que vamos

28272
18:40:26,240 --> 18:40:28,640
imprimir o endereço de um para que possamos realmente

28273
18:40:28,640 --> 18:40:32,080
Peguei isto e usamos este stdc out

28274
18:40:32,080 --> 18:40:33,280
Declaração

28275
18:40:33,280 --> 18:40:36,080
e nós vamos mudá-lo para dizer para fora

28276
18:40:36,080 --> 18:40:37,512
Aqui e nós vamos imprimir o

28277
18:40:37,512 --> 18:40:40,160
endereço de um vamos pegar isso novamente e

28278
18:40:40,160 --> 18:40:42,800
usar isso após a chamada da função e

28279
18:40:42,800 --> 18:40:44,720
O que esperamos ver

28280
18:40:44,720 --> 18:40:47,832
é algum endereço no exterior, então para

28281
18:40:47,832 --> 18:40:50,160
Um exemplo, podemos ter algo como zero

28282
18:40:50,160 --> 18:40:54,640
x e um um abc que é algum

28283
18:40:54,640 --> 18:40:57,040
hexorar número aqui e isso é o mesmo

28284
18:40:57,040 --> 18:40:59,192
O que vamos ter do lado de fora

28285
18:40:59,192 --> 18:41:01,120
porque temos o valor que temos antes do

28286
18:41:01,120 --> 18:41:04,000
chamada de função e o valor que temos

28287
18:41:04,000 --> 18:41:05,832
Depois que a chamada da função vai ser

28288
18:41:05,832 --> 18:41:08,552
Deixando no mesmo endereço, mas o que nós

28289
18:41:08,552 --> 18:41:11,192
ter dentro da função que o corpo está indo

28290
18:41:11,192 --> 18:41:13,440
para ser uma cópia para que ele vai viver em

28291
18:41:13,440 --> 18:41:15,680
algum outro endereço, por exemplo, digamos

28292
18:41:15,680 --> 18:41:16,960
d a

28293
18:41:16,960 --> 18:41:19,120
E o ponto principal aqui é que o que

28294
18:41:19,120 --> 18:41:20,872
Temos do lado de fora que vai ser

28295
18:41:20,872 --> 18:41:22,552
diferente do que temos no leste

28296
18:41:22,552 --> 18:41:24,552
lado e espero que isso vá

28297
18:41:24,552 --> 18:41:27,192
provar que estamos passando pelo valor, então

28298
18:41:27,192 --> 18:41:30,080
Vamos imprimir o nosso máximo aqui e ver

28299
18:41:30,080 --> 18:41:32,160
os endereços impressos para fora, vamos

28300
18:41:32,160 --> 18:41:35,360
construir com gcc e vamos construir

28301
18:41:35,360 --> 18:41:38,400
Podemos trazer um terminal

28302
18:41:38,400 --> 18:41:40,240
para brincar com a gente um pouco mais nós podemos

28303
18:41:40,240 --> 18:41:42,480
clear e run galo que vamos ver

28304
18:41:42,480 --> 18:41:45,040
que o endereço no exterior termina em

28305
18:41:45,040 --> 18:41:48,720
dd8 e a morada no exterior termina

28306
18:41:48,720 --> 18:41:51,512
com dd8 após a chamada de função, mas

28307
18:41:51,512 --> 18:41:53,760
Dentro você vê que temos um diferente

28308
18:41:53,760 --> 18:41:56,160
endereço e isso vai nos dizer

28309
18:41:56,160 --> 18:41:58,800
que estamos passando pelo valor e pelo que nós

28310
18:41:58,800 --> 18:42:01,360
ter dentro do corpo da função é

28311
18:42:01,360 --> 18:42:04,400
basicamente uma cópia novamente eu não espero

28312
18:42:04,400 --> 18:42:06,720
você vê os mesmos discursos que eu aqui

28313
18:42:06,720 --> 18:42:08,552
porque o seu sistema operacional está indo

28314
18:42:08,552 --> 18:42:10,872
para configurar os endereços como quiser

28315
18:42:10,872 --> 18:42:13,040
O ponto principal aqui é que o

28316
18:42:13,040 --> 18:42:15,280
Os endereços que você vê no exterior são

28317
18:42:15,280 --> 18:42:17,192
Vai ser diferente dos endereços

28318
18:42:17,192 --> 18:42:19,600
você vê por dentro aqui e isso

28319
18:42:19,600 --> 18:42:22,160
prova que estamos passando por valor, mas

28320
18:42:22,160 --> 18:42:24,640
E se você realmente não quiser passar

28321
18:42:24,640 --> 18:42:27,120
valor e faça o seu modelo de função

28322
18:42:27,120 --> 18:42:29,600
trabalho por referência bem podemos fazer que

28323
18:42:29,600 --> 18:42:31,512
pode mudar nossa função aqui para fazer

28324
18:42:31,512 --> 18:42:33,600
coisas por referência e tudo o que temos que

28325
18:42:33,600 --> 18:42:34,400
- É assim.

28326
18:42:34,400 --> 18:42:37,512
é usar t referência como este ok e

28327
18:42:37,512 --> 18:42:39,920
Quando começamos a usar referências, realmente

28328
18:42:39,920 --> 18:42:42,552
Precisamos ter cuidado e garantir que as pessoas

28329
18:42:42,552 --> 18:42:45,440
Não modifique as coisas sem o nosso

28330
18:42:45,440 --> 18:42:48,080
O conhecimento e uma boa prática é marcar

28331
18:42:48,080 --> 18:42:50,640
suas coisas como referências de custo, então nós somos

28332
18:42:50,640 --> 18:42:52,640
vamos fazer isso e nós vamos fazer

28333
18:42:52,640 --> 18:42:55,192
o mesmo em nossa definição de função, então

28334
18:42:55,192 --> 18:42:57,360
nós vamos mudar isso para custar t

28335
18:42:57,360 --> 18:43:00,080
referência, vamos fazer isso e vamos dizer

28336
18:43:00,080 --> 18:43:02,720
custo t referência para o primeiro parâmetro

28337
18:43:02,720 --> 18:43:05,192
aqui e dizer o mesmo para o segundo

28338
18:43:05,192 --> 18:43:07,920
parâmetro aqui e isso deve ser nós

28339
18:43:07,920 --> 18:43:10,320
Não deve ser capaz de usar esta referência

28340
18:43:10,320 --> 18:43:12,552
para modificar os dados dentro do corpo de

28341
18:43:12,552 --> 18:43:14,552
A função e a nossa função é

28342
18:43:14,552 --> 18:43:16,872
pouco mais seguro, mas o que é o compilador

28343
18:43:16,872 --> 18:43:18,640
Ir fazer é realmente o que tem sido

28344
18:43:18,640 --> 18:43:20,480
Fazendo o tempo todo, vai olhar para

28345
18:43:20,480 --> 18:43:22,160
Os argumentos que passamos para o

28346
18:43:22,160 --> 18:43:23,600
chamada da função aqui vai ver

28347
18:43:23,600 --> 18:43:26,080
que é o dobro e vai fazer

28348
18:43:26,080 --> 18:43:28,872
modelo padrão de dedução para que seja

28349
18:43:28,872 --> 18:43:31,760
vai gerar um modelo duplo

28350
18:43:31,760 --> 18:43:34,000
Por exemplo, para o modelo de função aqui

28351
18:43:34,000 --> 18:43:36,640
e vai substituir em dupla e

28352
18:43:36,640 --> 18:43:38,080
nós vamos ter const duplo

28353
18:43:38,080 --> 18:43:40,480
referência máxima custo de referência dupla referência

28354
18:43:40,480 --> 18:43:42,872
uma referência dupla constante b

28355
18:43:42,872 --> 18:43:46,160
e podemos provar isso entrando em cpp

28356
18:43:46,160 --> 18:43:48,480
Percepção eu acho que podemos fazer isso para que nós somos

28357
18:43:48,480 --> 18:43:51,040
aqui em cpp insights que podemos tirar

28358
18:43:51,040 --> 18:43:52,960
O que quer que tivéssemos, vamos colocar

28359
18:43:52,960 --> 18:43:55,512
Novo código aqui e nós podemos

28360
18:43:55,512 --> 18:43:57,360
Apertar o botão de correr

28361
18:43:57,360 --> 18:44:00,400
para gerar nossas instâncias e aqui nós

28362
18:44:00,400 --> 18:44:03,120
ter nossa instância de modelo aqui

28363
18:44:03,120 --> 18:44:05,680
gerado você vê que ele vai

28364
18:44:05,680 --> 18:44:08,872
gerar uma versão dupla do nosso

28365
18:44:08,872 --> 18:44:10,720
modelo de função aqui e é isso que

28366
18:44:10,720 --> 18:44:13,280
nós temos tão const dupla referência

28367
18:44:13,280 --> 18:44:16,240
máximo e vai colocar em um

28368
18:44:16,240 --> 18:44:18,400
duplo argumento explícito aqui, mas isso

28369
18:44:18,400 --> 18:44:20,640
é negócio do compilador o que nós

28370
18:44:20,640 --> 18:44:23,440
realmente se preocupa é que ele gerou um

28371
18:44:23,440 --> 18:44:25,440
instância de modelo duplo para o nosso

28372
18:44:25,440 --> 18:44:27,600
modelo de função aqui agora se executarmos

28373
18:44:27,600 --> 18:44:29,040
Isso vai passar

28374
18:44:29,040 --> 18:44:31,512
parâmetros por referência e pelo que temos

28375
18:44:31,512 --> 18:44:33,512
no interior deve ter o mesmo

28376
18:44:33,512 --> 18:44:36,160
abordar como o que temos no exterior

28377
18:44:36,160 --> 18:44:37,512
Aqui assim

28378
18:44:37,512 --> 18:44:39,760
para realmente dirigir isso para casa, devemos

28379
18:44:39,760 --> 18:44:40,960
Mudança

28380
18:44:40,960 --> 18:44:44,080
nosso endereço para abc para cumprir com o que

28381
18:44:44,080 --> 18:44:46,240
Temos lá fora aqui que podemos tentar

28382
18:44:46,240 --> 18:44:48,240
e construir o nosso programa que vamos usar

28383
18:44:48,240 --> 18:44:50,400
o gcc para fazer que a construção vai

28384
18:44:50,400 --> 18:44:52,480
sermos bons, vamos limpar e se nós

28385
18:44:52,480 --> 18:44:54,640
executar galo que devemos ver os endereços

28386
18:44:54,640 --> 18:44:59,440
sendo o mesmo fora d e 0 em d e 0 e

28387
18:44:59,440 --> 18:45:02,480
fora d e 0 e você vê agora que estamos passando

28388
18:45:02,480 --> 18:45:04,552
nossos parâmetros por referência e se você

28389
18:45:04,552 --> 18:45:07,040
Quer configurar um modelo de função que

28390
18:45:07,040 --> 18:45:10,400
passa os parâmetros do modelo por referência

28391
18:45:10,400 --> 18:45:12,240
É assim que você pode fazer isso

28392
18:45:12,240 --> 18:45:14,480
e acho que também podemos tentar depurar

28393
18:45:14,480 --> 18:45:16,552
Isso e ver se podemos ver mais

28394
18:45:16,552 --> 18:45:18,960
Informações sobre como isso funciona

28395
18:45:18,960 --> 18:45:21,760
indo para bater a nossa guia de corrida aqui e nós estamos

28396
18:45:21,760 --> 18:45:24,160
indo para apertar o botão verde para começar

28397
18:45:24,160 --> 18:45:26,000
depuração deste programa que vamos ser

28398
18:45:26,000 --> 18:45:29,600
usando as ferramentas de depuração do gcc

28399
18:45:29,600 --> 18:45:32,320
e vemos nossas variáveis locais aqui

28400
18:45:32,320 --> 18:45:35,360
Atingimos o ponto de interrupção e nós temos o

28401
18:45:35,360 --> 18:45:37,120
função principal para o topo da chamada

28402
18:45:37,120 --> 18:45:40,320
empilhar isso é o que temos aqui e se

28403
18:45:40,320 --> 18:45:42,480
Tentamos entrar no máximo

28404
18:45:42,480 --> 18:45:44,240
Função, vamos ver que

28405
18:45:44,240 --> 18:45:47,192
instância de modelo agora está usando const

28406
18:45:47,192 --> 18:45:49,832
duas referências e esta é a

28407
18:45:49,832 --> 18:45:52,720
template instance que foi gerado i

28408
18:45:52,720 --> 18:45:55,600
Acho que isso é tudo o que podemos realmente ver aqui

28409
18:45:55,600 --> 18:45:58,552
e vamos parar isso e mostrar-lhe um

28410
18:45:58,552 --> 18:46:00,080
A última coisa

28411
18:46:00,080 --> 18:46:01,832
O que eu vou te mostrar é que você

28412
18:46:01,832 --> 18:46:03,832
Não posso realmente ter

28413
18:46:03,832 --> 18:46:07,120
O modelo de função que passa

28414
18:46:07,120 --> 18:46:09,040
valor e o outro passando

28415
18:46:09,040 --> 18:46:10,800
Referência se você fizer isso, você vai

28416
18:46:10,800 --> 18:46:12,720
ter problemas quando você emite a chamada

28417
18:46:12,720 --> 18:46:14,240
assim porque o compilador está indo

28418
18:46:14,240 --> 18:46:16,720
ser confundido, vamos mudar o segundo

28419
18:46:16,720 --> 18:46:19,120
um aqui para passar pelo valor, então vamos

28420
18:46:19,120 --> 18:46:21,192
para remover a referência de custo aqui i

28421
18:46:21,192 --> 18:46:22,960
Acho que vai fazer vamos fazer isso

28422
18:46:22,960 --> 18:46:25,280
muito rápido vamos remover o custo e

28423
18:46:25,280 --> 18:46:28,240
a referência nós removemos o custo e o

28424
18:46:28,240 --> 18:46:31,120
referência aqui e nós usamos esse cara como

28425
18:46:31,120 --> 18:46:33,920
nosso protótipo de função na frente do

28426
18:46:33,920 --> 18:46:36,800
principal função aqui e como podemos dizer

28427
18:46:36,800 --> 18:46:39,360
que vamos para cima aqui e

28428
18:46:39,360 --> 18:46:41,120
Diga que tudo bem, vamos colocar o nosso

28429
18:46:41,120 --> 18:46:43,680
ponto e-vírgula e isso vai ser nosso

28430
18:46:43,680 --> 18:46:45,832
Declaração, mas no momento em que fazemos isso

28431
18:46:45,832 --> 18:46:47,680
você vê que o nosso compilador vai ser

28432
18:46:47,680 --> 18:46:49,760
Confundido porque temos dois possíveis

28433
18:46:49,760 --> 18:46:52,400
candidatos para a chamada aqui que pode

28434
18:46:52,400 --> 18:46:55,192
seja por valor ou por referência e

28435
18:46:55,192 --> 18:46:56,960
Se tentarmos construir este programa, nós somos

28436
18:46:56,960 --> 18:46:59,280
vai ter um erro de compilador e é

28437
18:46:59,280 --> 18:47:01,040
basicamente vai dizer o que é

28438
18:47:01,040 --> 18:47:03,360
errado aqui, então vai dizer chamada

28439
18:47:03,360 --> 18:47:05,760
sobrecarga máxima dupla ambígua

28440
18:47:05,760 --> 18:47:08,720
porque temos dois candidatos novamente um

28441
18:47:08,720 --> 18:47:11,512
por referência um por valor e esta chamada

28442
18:47:11,512 --> 18:47:14,240
pode ser surgido por ambos os

28443
18:47:14,240 --> 18:47:16,480
candidatos aqui para que o compilador esteja indo

28444
18:47:16,480 --> 18:47:18,640
para nos dar um erro de compilador e nós temos

28445
18:47:18,640 --> 18:47:21,440
Não há escolha a não ser usar qualquer um desses dois

28446
18:47:21,440 --> 18:47:23,680
Mas não podemos tê-los todos

28447
18:47:23,680 --> 18:47:26,000
em nosso código e, por exemplo, se tomarmos

28448
18:47:26,000 --> 18:47:28,552
fora aquele por valor aqui e saindo

28449
18:47:28,552 --> 18:47:31,040
Aquele por referência, então vamos comentar

28450
18:47:31,040 --> 18:47:32,640
Isso fora novamente se estivermos fervidos, estamos

28451
18:47:32,640 --> 18:47:34,800
indo para fugir você ver o mundo é bom

28452
18:47:34,800 --> 18:47:36,400
e vamos imprimir nossos dados

28453
18:47:36,400 --> 18:47:38,552
no entanto, temos em nosso código que vemos

28454
18:47:38,552 --> 18:47:40,872
Os endereços são os mesmos e outro

28455
18:47:40,872 --> 18:47:43,040
coisa eu não acho que eu realmente provei

28456
18:47:43,040 --> 18:47:45,600
Você é que estamos passando por const

28457
18:47:45,600 --> 18:47:48,640
referência aqui para que a instância de modelo

28458
18:47:48,640 --> 18:47:50,400
que vai ser gerado está indo

28459
18:47:50,400 --> 18:47:52,480
estar passando por const dupla referência

28460
18:47:52,480 --> 18:47:54,400
Porque estamos passando em dupla

28461
18:47:54,400 --> 18:47:57,512
parâmetros, mas por causa deste custo em

28462
18:47:57,512 --> 18:48:00,000
diante de nossos argumentos aqui queremos

28463
18:48:00,000 --> 18:48:03,120
ser capaz de modificar os dados referenciados por

28464
18:48:03,120 --> 18:48:05,440
Este nome aqui se formos para dentro

28465
18:48:05,440 --> 18:48:08,080
exemplo e dizer mais mais uma tentativa

28466
18:48:08,080 --> 18:48:10,640
modificar uma de qualquer forma através deste

28467
18:48:10,640 --> 18:48:12,160
referência que vamos ter um compilador

28468
18:48:12,160 --> 18:48:13,920
Erro, vamos trabalhar novamente e nós vamos

28469
18:48:13,920 --> 18:48:17,192
para ver isso e uh o mundo terminou com

28470
18:48:17,192 --> 18:48:18,240
um erro

28471
18:48:18,240 --> 18:48:20,160
E isso está dizendo

28472
18:48:20,160 --> 18:48:22,800
incremento de leitura apenas referência a

28473
18:48:22,800 --> 18:48:24,640
porque estamos passando por const

28474
18:48:24,640 --> 18:48:26,552
referência aqui, então você deve realmente

28475
18:48:26,552 --> 18:48:29,120
Lembre-se disso mesmo se estamos fazendo o

28476
18:48:29,120 --> 18:48:31,440
Coisas no contexto da função

28477
18:48:31,440 --> 18:48:32,480
templates

28478
18:48:32,480 --> 18:48:34,080
Isso é realmente tudo o que nos prossamos fazer em

28479
18:48:34,080 --> 18:48:35,760
Esta palestra mostrando que você pode

28480
18:48:35,760 --> 18:48:38,160
configurar modelos de função que tomam

28481
18:48:38,160 --> 18:48:41,040
parâmetros por referência e contraste

28482
18:48:41,040 --> 18:48:43,512
Isso com passar pelo valor e ver

28483
18:48:43,512 --> 18:48:45,832
As diferenças entre essas duas coisas

28484
18:48:45,832 --> 18:48:47,760
Vamos parar aqui nesta palestra

28485
18:48:47,760 --> 18:48:49,280
E o próximo vamos aprender

28486
18:48:49,280 --> 18:48:52,320
sobre a espacialização do modelo

28487
18:48:52,320 --> 18:48:54,552
Vá em frente e termine aqui e me encontre

28488
18:48:54,552 --> 18:48:55,512
lá

28489
18:48:55,512 --> 18:48:56,800
Nesta palestra vamos aprender

28490
18:48:56,800 --> 18:48:59,680
sobre a especialização de modelos e isso

28491
18:48:59,680 --> 18:49:02,160
é uma característica que temos em c plus plus

28492
18:49:02,160 --> 18:49:05,600
ignorar o mecanismo padrão de como

28493
18:49:05,600 --> 18:49:08,240
os modelos de função funcionam em c plus plus

28494
18:49:08,240 --> 18:49:10,872
Ok, vamos deixar-me super claro aqui

28495
18:49:10,872 --> 18:49:12,872
nós temos um modelo de função simples nós

28496
18:49:12,872 --> 18:49:15,192
Já viu mil vezes agora é

28497
18:49:15,192 --> 18:49:17,280
a função máxima e vai

28498
18:49:17,280 --> 18:49:20,240
calcular o máximo entre a e b aqui

28499
18:49:20,240 --> 18:49:22,400
e vai voltar que é um

28500
18:49:22,400 --> 18:49:24,720
modelo de função então se passarmos em um e

28501
18:49:24,720 --> 18:49:26,552
b que são do tipo e nós vamos

28502
18:49:26,552 --> 18:49:29,280
gerar uma instância líquida do modelo

28503
18:49:29,280 --> 18:49:32,720
Aqui se passarmos em c e d de duplo

28504
18:49:32,720 --> 18:49:34,800
Tempo que vamos gerar um duplo

28505
18:49:34,800 --> 18:49:37,600
instância do modelo de função aqui

28506
18:49:37,600 --> 18:49:40,552
se passarmos em parâmetros de string hdd

28507
18:49:40,552 --> 18:49:43,360
vamos gerar uma string std

28508
18:49:43,360 --> 18:49:45,600
instância deste modelo aqui e isso

28509
18:49:45,600 --> 18:49:47,680
Será basicamente comparar o

28510
18:49:47,680 --> 18:49:49,680
Parâmetros que passamos, então somos basicamente

28511
18:49:49,680 --> 18:49:52,320
vai dizer se um é maior do que b então

28512
18:49:52,320 --> 18:49:55,512
devolver um se a não é maior que b então

28513
18:49:55,512 --> 18:49:58,080
retorno b OK que vai funcionar se

28514
18:49:58,080 --> 18:50:00,320
O que estamos fazendo é o que temos aqui

28515
18:50:00,320 --> 18:50:02,400
Mas no momento em que passamos algo como

28516
18:50:02,400 --> 18:50:06,000
o que temos aqui fechados ponteiros de carro

28517
18:50:06,000 --> 18:50:08,000
Então nós vamos ter um problema

28518
18:50:08,000 --> 18:50:10,080
Porque nós vamos estar chamando a nossa

28519
18:50:10,080 --> 18:50:13,280
modelo de função com ponteiro de carro de custo

28520
18:50:13,280 --> 18:50:14,800
Os parâmetros

28521
18:50:14,800 --> 18:50:15,680
O que é

28522
18:50:15,680 --> 18:50:18,720
O mecanismo padrão vai deduzir

28523
18:50:18,720 --> 18:50:21,360
Uma instância de modelo que funciona com custos

28524
18:50:21,360 --> 18:50:24,400
argumentos de ponteiro de carro aqui e o que

28525
18:50:24,400 --> 18:50:26,000
Vamos comparar agora

28526
18:50:26,000 --> 18:50:28,960
Vou ser ponteiros para a corda

28527
18:50:28,960 --> 18:50:32,000
em vez dos dados da string em si e

28528
18:50:32,000 --> 18:50:33,512
Espero que você possa ver que isso está indo

28529
18:50:33,512 --> 18:50:36,240
para ser uma especialização de modelo de problema

28530
18:50:36,240 --> 18:50:38,640
É um mecanismo que temos que dizer ao

28531
18:50:38,640 --> 18:50:41,600
compilador para uma função de modelo

28532
18:50:41,600 --> 18:50:44,160
se eu passar por você este tipo, por favor não faça

28533
18:50:44,160 --> 18:50:47,360
A coisa padrão que você faz de substituir em

28534
18:50:47,360 --> 18:50:48,240
O que é

28535
18:50:48,240 --> 18:50:50,960
tipo de argumento para o parâmetro template

28536
18:50:50,960 --> 18:50:53,440
Use a implementação que eu sou

28537
18:50:53,440 --> 18:50:55,360
vamos dar-lhe e você diz isso para

28538
18:50:55,360 --> 18:50:57,600
o compilador usando a sintaxe que temos

28539
18:50:57,600 --> 18:51:00,552
Aqui você coloca uma palavra-chave modelo aqui

28540
18:51:00,552 --> 18:51:03,600
colocar um par vazio de suportes de ângulo e

28541
18:51:03,600 --> 18:51:06,320
então você especifica sua função do caminho

28542
18:51:06,320 --> 18:51:08,240
Você quer que você veja que vai voltar

28543
18:51:08,240 --> 18:51:10,400
um ponteiro de cartão de const o nome da função

28544
18:51:10,400 --> 18:51:12,640
é o máximo que deve ser o mesmo que

28545
18:51:12,640 --> 18:51:14,400
O modelo de função aqui

28546
18:51:14,400 --> 18:51:16,640
Vai ser especializado para const

28547
18:51:16,640 --> 18:51:19,512
ponteiro de carro, então especificamos um explícito

28548
18:51:19,512 --> 18:51:21,832
argumento de modelo aqui e depois passamos

28549
18:51:21,832 --> 18:51:24,552
nossos parâmetros que também são de custo

28550
18:51:24,552 --> 18:51:27,120
ponto de carta e quando fazemos isso, então nós

28551
18:51:27,120 --> 18:51:29,360
pode cabecear no corpo da função e

28552
18:51:29,360 --> 18:51:31,440
fazer a comparação, no entanto, queremos ok

28553
18:51:31,440 --> 18:51:33,512
Como fazer essa comparação aqui

28554
18:51:33,512 --> 18:51:36,160
Aqui está uma simples implementação da

28555
18:51:36,160 --> 18:51:38,552
modelo de função que acabamos de ver no

28556
18:51:38,552 --> 18:51:40,720
slide anterior você vê que realmente é

28557
18:51:40,720 --> 18:51:42,320
A mesma coisa que temos o template

28558
18:51:42,320 --> 18:51:44,800
palavra-chave, temos nossos suportes de ângulo e

28559
18:51:44,800 --> 18:51:47,760
nós temos o cabeçalho da função aqui é

28560
18:51:47,760 --> 18:51:50,080
indo para retornar custo preço ponteiro de carro é

28561
18:51:50,080 --> 18:51:52,320
vai ser chamado de máximo e um

28562
18:51:52,320 --> 18:51:55,040
O argumento de modelo explícito é especificado

28563
18:51:55,040 --> 18:51:57,440
dentro desses suportes de ângulo e então nós

28564
18:51:57,440 --> 18:52:00,480
ter nossos parâmetros o que é realmente

28565
18:52:00,480 --> 18:52:02,480
importante sobre essa função é que

28566
18:52:02,480 --> 18:52:04,240
Não vai fazer a comparação

28567
18:52:04,240 --> 18:52:06,160
Temos feito o tempo todo que vai

28568
18:52:06,160 --> 18:52:08,080
usar uma função embutida

28569
18:52:08,080 --> 18:52:10,320
e é uma biblioteca padrão c plus

28570
18:52:10,320 --> 18:52:12,800
que é especializada para comparar c

28571
18:52:12,800 --> 18:52:15,600
strings bem se viermos em cpp referência

28572
18:52:15,600 --> 18:52:17,800
Aqui e olhar para uma função chamada

28573
18:52:17,800 --> 18:52:21,120
htrcmp nós vimos isso antes eu acho

28574
18:52:21,120 --> 18:52:23,040
vai comparar dois null

28575
18:52:23,040 --> 18:52:24,400
terminado byte strings

28576
18:52:24,400 --> 18:52:26,240
lexografia e você vê que isso é

28577
18:52:26,240 --> 18:52:28,872
Realmente o que queremos, temos dois const

28578
18:52:28,872 --> 18:52:30,800
Car pointers one vai ser o

28579
18:52:30,800 --> 18:52:32,320
Primeiro parâmetro o outro vai ser

28580
18:52:32,320 --> 18:52:34,000
O segundo parâmetro que vamos

28581
18:52:34,000 --> 18:52:36,400
Compare-os e olhe para o retorno

28582
18:52:36,400 --> 18:52:38,160
valor que olhemos desta função que somos

28583
18:52:38,160 --> 18:52:40,640
obter um valor de retorno negativo se

28584
18:52:40,640 --> 18:52:43,192
O primeiro parâmetro vem antes do

28585
18:52:43,192 --> 18:52:45,920
segundo parâmetro em lexicográfico

28586
18:52:45,920 --> 18:52:48,080
ordem, vamos ter um zero se eles

28587
18:52:48,080 --> 18:52:49,360
São iguais

28588
18:52:49,360 --> 18:52:51,600
e nós vamos ter um valor positivo

28589
18:52:51,600 --> 18:52:54,400
se o primeiro parâmetro vem depois do

28590
18:52:54,400 --> 18:52:57,120
segundo parâmetro em lexicográfico

28591
18:52:57,120 --> 18:52:58,480
ordem para que nós vamos usar isso

28592
18:52:58,480 --> 18:53:00,640
Informações aqui e compare

28593
18:53:00,640 --> 18:53:03,512
nossos dois c strings aqui e voltar

28594
18:53:03,512 --> 18:53:06,000
algo no código do estúdio visual, então

28595
18:53:06,000 --> 18:53:07,600
Esta é a função aqui que vai

28596
18:53:07,600 --> 18:53:10,800
usar a lógica de hdr cmp

28597
18:53:10,800 --> 18:53:12,800
e observe o que voltamos, vamos

28598
18:53:12,800 --> 18:53:15,192
Voltar qualquer que seja a força

28599
18:53:15,192 --> 18:53:17,120
Compara o maior com o outro, então

28600
18:53:17,120 --> 18:53:19,512
nós vamos fazer strcmp nós vamos

28601
18:53:19,512 --> 18:53:22,080
Passar em nossos dois argumentos aqui e nós estamos

28602
18:53:22,080 --> 18:53:23,512
Vou dizer

28603
18:53:23,512 --> 18:53:26,080
Se isso retornar algo maior que 0

28604
18:53:26,080 --> 18:53:28,552
Retorne um porque nesse caso

28605
18:53:28,552 --> 18:53:31,080
a é maior que b

28606
18:53:31,080 --> 18:53:33,192
lexicograficamente esta é a comparação

28607
18:53:33,192 --> 18:53:35,040
Queremos fazer aqui e de outra forma você é

28608
18:53:35,040 --> 18:53:36,640
indo voltar b e isso vai

28609
18:53:36,640 --> 18:53:38,872
compare nossas strings e não compare

28610
18:53:38,872 --> 18:53:41,120
apontam diretamente qual é o que somos

28611
18:53:41,120 --> 18:53:43,040
Tentando evitar aqui e você vê isso

28612
18:53:43,040 --> 18:53:45,120
A especialização é realmente

28613
18:53:45,120 --> 18:53:48,480
Ajudar aqui agora se tivermos este n

28614
18:53:48,480 --> 18:53:51,280
e o compilador vê uma chamada como esta

28615
18:53:51,280 --> 18:53:53,120
Não vai comparar ponteiros, é

28616
18:53:53,120 --> 18:53:55,680
usar a especialização do modelo

28617
18:53:55,680 --> 18:53:58,080
porque o compilador sabe que este é

28618
18:53:58,080 --> 18:53:59,280
Um melhor

28619
18:53:59,280 --> 18:54:02,000
aptos para a chamada que estamos fazendo aqui

28620
18:54:02,000 --> 18:54:04,320
porque estamos passando o cartão de custo

28621
18:54:04,320 --> 18:54:06,480
apontam isso é como template

28622
18:54:06,480 --> 18:54:08,872
A especialização funciona e pode realmente

28623
18:54:08,872 --> 18:54:11,832
Venha a calar a mão se você está fazendo as coisas

28624
18:54:11,832 --> 18:54:14,160
que trabalham com ponteiros que vamos

28625
18:54:14,160 --> 18:54:16,240
cabeça para código de estúdio visual e jogar

28626
18:54:16,240 --> 18:54:18,160
com isso um pouco mais bem aqui estamos

28627
18:54:18,160 --> 18:54:20,320
em nossa pasta de trabalho a atual

28628
18:54:20,320 --> 18:54:22,400
Projeto é especialização template que somos

28629
18:54:22,400 --> 18:54:25,192
Vou pegar nossos arquivos de modelo

28630
18:54:25,192 --> 18:54:27,512
nós vamos colocá-los no lugar e

28631
18:54:27,512 --> 18:54:29,440
vamos abrir isso em visual

28632
18:54:29,440 --> 18:54:32,240
código de estúdio arrastando e soltando

28633
18:54:32,240 --> 18:54:34,480
topo de código de estúdio visual aqui este é

28634
18:54:34,480 --> 18:54:36,080
Vou abrir nosso projeto e nós somos

28635
18:54:36,080 --> 18:54:38,160
Vou limpar um pouco e

28636
18:54:38,160 --> 18:54:39,920
Vamos fechar o painel esquerdo aqui

28637
18:54:39,920 --> 18:54:41,832
Não precisamos mais da primeira coisa

28638
18:54:41,832 --> 18:54:43,600
nós vamos fazer é colocar em nosso

28639
18:54:43,600 --> 18:54:46,000
modelo de função a mesma coisa que temos

28640
18:54:46,000 --> 18:54:48,480
Tenho feito por um tempo de zilhão agora

28641
18:54:48,480 --> 18:54:50,800
A função máxima vai voltar

28642
18:54:50,800 --> 18:54:53,680
Qualquer que seja maior entre a e b e

28643
18:54:53,680 --> 18:54:55,760
Está fazendo isso por valor depois disso

28644
18:54:55,760 --> 18:54:57,440
Nós vamos ir para cima no principal

28645
18:54:57,440 --> 18:54:59,600
função e configurar um pedaço de código para

28646
18:54:59,600 --> 18:55:01,440
Realmente brincar com a gente nós vamos definir

28647
18:55:01,440 --> 18:55:03,360
para cima algumas variáveis e nós vamos

28648
18:55:03,360 --> 18:55:06,960
chamar nossas funções para que vamos dizer

28649
18:55:06,960 --> 18:55:09,040
máximo a e b isso vai voltar

28650
18:55:09,040 --> 18:55:11,192
o máximo entre a e b do compilador

28651
18:55:11,192 --> 18:55:14,000
vai deduzir que é o modelo

28652
18:55:14,000 --> 18:55:16,160
A instância deve ser do tipo de formista, então é

28653
18:55:16,160 --> 18:55:18,240
vai gerar isso e chamá-lo de

28654
18:55:18,240 --> 18:55:20,000
vamos nos dar o valor de retorno aqui

28655
18:55:20,000 --> 18:55:22,000
Podemos imprimi-lo e vê-lo e nós somos

28656
18:55:22,000 --> 18:55:23,920
Vou basicamente fazer o mesmo

28657
18:55:23,920 --> 18:55:26,640
para o tipo duplo e os tipos de string

28658
18:55:26,640 --> 18:55:27,920
Aqui e você vai ver que isso

28659
18:55:27,920 --> 18:55:30,080
Vai trabalhar muito bem, então vamos

28660
18:55:30,080 --> 18:55:32,640
construir isso, vamos usar gcc para fazer

28661
18:55:32,640 --> 18:55:35,920
que o parafuso é bom nós podemos limpar e eu

28662
18:55:35,920 --> 18:55:38,480
trazer um terminal para executar este

28663
18:55:38,480 --> 18:55:40,320
e realmente ver a saída aqui nós podemos

28664
18:55:40,320 --> 18:55:43,680
clear e run galo que você vê final máxima é

28665
18:55:43,680 --> 18:55:46,080
23 porque é isso que temos aqui no máximo

28666
18:55:46,080 --> 18:55:48,080
duplo 34

28667
18:55:48,080 --> 18:55:50,720
E é isso que temos aqui e nós

28668
18:55:50,720 --> 18:55:53,600
chamado máximo duplo para ser do tipo int nós

28669
18:55:53,600 --> 18:55:55,920
deve usar a dedução do tipo automático aqui para

28670
18:55:55,920 --> 18:55:57,760
Evite esses erros

28671
18:55:57,760 --> 18:55:59,920
porque o compilador pode fazer isso melhor

28672
18:55:59,920 --> 18:56:00,960
do que nós

28673
18:56:00,960 --> 18:56:02,800
Isso é o que vamos fazer e nós somos

28674
18:56:02,800 --> 18:56:05,280
indo para deduzir max sdr aqui e nós estamos

28675
18:56:05,280 --> 18:56:08,480
indo para construir novamente, vamos soldar com gcc

28676
18:56:08,480 --> 18:56:10,960
porque esse é o meu compilador favorito eu sou

28677
18:56:10,960 --> 18:56:13,512
indo para limpar e correr o galo agora nós

28678
18:56:13,512 --> 18:56:16,000
temos a saída correta que temos 23 que é

28679
18:56:16,000 --> 18:56:18,320
O máximo entre a e b

28680
18:56:18,320 --> 18:56:21,920
Nós temos 34.7 que foi deduzido para ser de

28681
18:56:21,920 --> 18:56:24,160
digite duplo aqui e então temos o

28682
18:56:24,160 --> 18:56:26,640
força máxima que passa a ser

28683
18:56:26,640 --> 18:56:28,552
Mundo aqui novamente

28684
18:56:28,552 --> 18:56:30,800
ao comparar os pontos fortes, o padrão é

28685
18:56:30,800 --> 18:56:32,440
indo para compará-los

28686
18:56:32,440 --> 18:56:35,120
lexografia e o que isso significa

28687
18:56:35,120 --> 18:56:38,240
Aquele que vem depois do outro em

28688
18:56:38,240 --> 18:56:40,000
A ordem alfabética vai ser

28689
18:56:40,000 --> 18:56:42,800
maior por esse mundo lógico é maior

28690
18:56:42,800 --> 18:56:45,280
do que olá e é o que estamos vendo

28691
18:56:45,280 --> 18:56:47,120
impresso aqui está bem, isso está funcionando

28692
18:56:47,120 --> 18:56:50,160
Tudo bem, mas e se usarmos o cartão de custo

28693
18:56:50,160 --> 18:56:52,480
apontadores e tentar chamar o nosso máximo

28694
18:56:52,480 --> 18:56:55,120
modelo de função e com isso quero dizer

28695
18:56:55,120 --> 18:56:57,040
Fazendo algo assim, temos dois

28696
18:56:57,040 --> 18:56:58,160
As variáveis

28697
18:56:58,160 --> 18:57:01,600
g e h que são do tipo cartão de custo

28698
18:57:01,600 --> 18:57:04,000
apontadores para que eles sejam c strings que são

28699
18:57:04,000 --> 18:57:06,080
Vou agora ser encerrado porque nós

28700
18:57:06,080 --> 18:57:08,552
estão inicializando-os com uma corda

28701
18:57:08,552 --> 18:57:10,960
elétron e estamos comparando-os aqui

28702
18:57:10,960 --> 18:57:13,600
Estamos dizendo máximo g e h e estamos

28703
18:57:13,600 --> 18:57:15,760
indo para imprimir o que é o máximo

28704
18:57:15,760 --> 18:57:18,160
Depois que retornamos isso da função

28705
18:57:18,160 --> 18:57:19,920
quando o compilador vê a chamada como

28706
18:57:19,920 --> 18:57:21,512
Isso vai fazer o que sabe

28707
18:57:21,512 --> 18:57:23,680
Ele vai substituir um

28708
18:57:23,680 --> 18:57:26,640
scar pointer em nosso modelo de função

28709
18:57:26,640 --> 18:57:28,400
Aqui, então ele vai devolver o cartão de custo

28710
18:57:28,400 --> 18:57:30,080
pointer ele vai passar o

28711
18:57:30,080 --> 18:57:32,320
parâmetros como ponteiros da guarda costeira e

28712
18:57:32,320 --> 18:57:33,600
nós vamos comparar isso

28713
18:57:33,600 --> 18:57:36,080
apontadores aqui e vamos voltar

28714
18:57:36,080 --> 18:57:39,120
Qualquer que seja o ponteiro maior novamente aqui

28715
18:57:39,120 --> 18:57:41,120
Você deve estar percebendo o problema que nós somos

28716
18:57:41,120 --> 18:57:43,192
indo para retornar qualquer ponteiro

28717
18:57:43,192 --> 18:57:45,360
Maior e nós não vamos ser

28718
18:57:45,360 --> 18:57:47,832
Retorne os dados reais da string que somos

28719
18:57:47,832 --> 18:57:50,400
Vou devolver apenas o endereço

28720
18:57:50,400 --> 18:57:52,800
E isso pode estar realmente errado, porque se

28721
18:57:52,800 --> 18:57:55,512
Os endereços acontecem para ser estragados

28722
18:57:55,512 --> 18:57:57,832
nós vamos ter a saída errada, então

28723
18:57:57,832 --> 18:58:00,720
Vamos tentar provar isso novamente para isso

28724
18:58:00,720 --> 18:58:02,872
Vou comentar o que tivemos

28725
18:58:02,872 --> 18:58:05,040
No topo, porque isso poderia bagunçar as coisas

28726
18:58:05,040 --> 18:58:06,400
para cima um pouco

28727
18:58:06,400 --> 18:58:08,640
Então eu vou comentar tudo isso agora e

28728
18:58:08,640 --> 18:58:10,640
Eu vou depurar isso

28729
18:58:10,640 --> 18:58:13,120
Então vamos olhar para esta linha aqui

28730
18:58:13,120 --> 18:58:15,360
E eu acho que devemos dizer

28731
18:58:15,360 --> 18:58:18,800
resultado do ponteiro do carro e eu digo iguais

28732
18:58:18,800 --> 18:58:22,160
max c mom g e h e i imprimi o

28733
18:58:22,160 --> 18:58:24,160
resultado aqui vai fazer isso

28734
18:58:24,160 --> 18:58:26,080
Mais fácil entrar nesta função

28735
18:58:26,080 --> 18:58:29,440
sem o barulho de stdc aqui, então

28736
18:58:29,440 --> 18:58:31,440
Vamos montar o nosso ponto de ruptura

28737
18:58:31,440 --> 18:58:33,760
Aqui nós vamos bater o nosso

28738
18:58:33,760 --> 18:58:36,000
executar a aba e nós vamos depurar isso

28739
18:58:36,000 --> 18:58:37,512
programa e nós vamos acertar isso

28740
18:58:37,512 --> 18:58:40,400
ponto de quebra aqui, vamos ver os tipos que

28741
18:58:40,400 --> 18:58:43,360
nós temos dentro da nossa chamada de função

28742
18:58:43,360 --> 18:58:45,512
Então agora que estamos aqui nós vamos

28743
18:58:45,512 --> 18:58:48,720
Veja que nossos locais são g e h e eles

28744
18:58:48,720 --> 18:58:51,832
conter nossa força se formos para dentro

28745
18:58:51,832 --> 18:58:54,240
nós vamos ver que g é realmente um

28746
18:58:54,240 --> 18:58:56,400
ponteiro para o primeiro elemento em nosso

28747
18:58:56,400 --> 18:58:59,280
string aqui e contém

28748
18:58:59,280 --> 18:59:00,720
w aqui

28749
18:59:00,720 --> 18:59:03,280
que é o que temos aqui

28750
18:59:03,280 --> 18:59:05,832
e h vai ser um ponteiro para um

28751
18:59:05,832 --> 18:59:08,000
Isso é o que temos aqui bem

28752
18:59:08,000 --> 18:59:10,480
e resultado vai conter algum lixo

28753
18:59:10,480 --> 18:59:13,040
dados porque ainda não estão inicializados

28754
18:59:13,040 --> 18:59:15,600
Mas nós podemos entrar nesta função

28755
18:59:15,600 --> 18:59:18,552
e ver as coisas acontecendo uma vez é um

28756
18:59:18,552 --> 18:59:21,040
endereço e b é um endereço que você vê que

28757
18:59:21,040 --> 18:59:23,192
O depurador é realmente inteligente é

28758
18:59:23,192 --> 18:59:25,360
percebendo que este é um ponteiro para um

28759
18:59:25,360 --> 18:59:27,512
força e isso vai nos mostrar o

28760
18:59:27,512 --> 18:59:29,832
string aqui, mas o que comparamos são

28761
18:59:29,832 --> 18:59:33,360
esses dois endereços e você vê que b

28762
18:59:33,360 --> 18:59:36,240
vive em um endereço maior que deixa em

28763
18:59:36,240 --> 18:59:40,160
endereço que termina em 55 e uma vida em

28764
18:59:40,160 --> 18:59:43,440
O endereço que termina em 50. então se

28765
18:59:43,440 --> 18:59:45,920
Realmente executar esta função que estamos indo

28766
18:59:45,920 --> 18:59:48,720
para retornar o ponteiro para b mas você vê

28767
18:59:48,720 --> 18:59:51,120
que b não é realmente a corda maior

28768
18:59:51,120 --> 18:59:52,640
E isso é realmente algo ruim você

28769
18:59:52,640 --> 18:59:54,640
deve estar ciente disso é isso que

28770
18:59:54,640 --> 18:59:56,720
O compilador está fazendo por padrão e é

28771
18:59:56,720 --> 18:59:59,440
vamos nos dar um resultado que não é

28772
18:59:59,440 --> 19:00:02,240
Correto vamos fechar isso e ver um caminho

28773
19:00:02,240 --> 19:00:05,120
nós podemos resolver este problema e nós podemos usar

28774
19:00:05,120 --> 19:00:07,680
especialização para isso o que nós

28775
19:00:07,680 --> 19:00:10,320
A necessidade é uma maneira de comparar c

28776
19:00:10,320 --> 19:00:12,552
strings e não comparar ponteiros como nós

28777
19:00:12,552 --> 19:00:14,080
Estamos fazendo aqui nós vamos fazer isso

28778
19:00:14,080 --> 19:00:16,720
Usando uma especialização de modelo

28779
19:00:16,720 --> 19:00:18,800
e a sintaxe para isso funcionar, você diz

28780
19:00:18,800 --> 19:00:21,440
modelo e você especificar um par vazio

28781
19:00:21,440 --> 19:00:24,320
de suportes de ângulo e então você especificar

28782
19:00:24,320 --> 19:00:26,400
Seja qual for a função que você quiser usar

28783
19:00:26,400 --> 19:00:28,160
Vamos descer aqui e especificar

28784
19:00:28,160 --> 19:00:30,080
que queremos devolver o cartão de custo

28785
19:00:30,080 --> 19:00:31,040
O ponteiro

28786
19:00:31,040 --> 19:00:32,400
A função vai ser chamada

28787
19:00:32,400 --> 19:00:34,872
máximo vamos especificar um

28788
19:00:34,872 --> 19:00:38,080
argumento de modelo explícito que é de

28789
19:00:38,080 --> 19:00:40,400
const car pointer porque queremos isso

28790
19:00:40,400 --> 19:00:42,872
instância de modelo para trabalhar para cicatriz

28791
19:00:42,872 --> 19:00:43,832
ponteiros

28792
19:00:43,832 --> 19:00:45,832
então, uma vez que tenhamos esse fim, vamos

28793
19:00:45,832 --> 19:00:47,680
Especifique nossos parâmetros para os quais vamos

28794
19:00:47,680 --> 19:00:50,640
Diga cos ponteiro de carro e carro de custo

28795
19:00:50,640 --> 19:00:53,040
pointer b e nós vamos entrar

28796
19:00:53,040 --> 19:00:55,760
o corpo do nosso modelo de função aqui

28797
19:00:55,760 --> 19:00:58,160
Agora temos nossos dois parâmetros e

28798
19:00:58,160 --> 19:01:00,480
indo para compará-los como se fossem

28799
19:01:00,480 --> 19:01:02,800
forças da cor dos const e nós vimos

28800
19:01:02,800 --> 19:01:04,720
que temos uma instalação embutida a partir de

28801
19:01:04,720 --> 19:01:07,360
a biblioteca padrão c plus é

28802
19:01:07,360 --> 19:01:10,640
esta função htr cmp nós podemos usá-lo para

28803
19:01:10,640 --> 19:01:12,640
Compare dois pontos fortes e vamos

28804
19:01:12,640 --> 19:01:14,800
Use a lógica que temos aqui, então se

28805
19:01:14,800 --> 19:01:17,192
o primeiro parâmetro é menor que o

28806
19:01:17,192 --> 19:01:19,360
segundo parâmetro estou falando em um

28807
19:01:19,360 --> 19:01:21,192
Ordem
 lexicográfica que vamos

28808
19:01:21,192 --> 19:01:23,040
Retorne algo negativo se for

28809
19:01:23,040 --> 19:01:24,872
igual dexicografia, nós vamos

28810
19:01:24,872 --> 19:01:27,512
retorno zero e se o

28811
19:01:27,512 --> 19:01:30,240
O primeiro parâmetro é maior que o

28812
19:01:30,240 --> 19:01:33,120
segundo parâmetro lexicograficamente, somos

28813
19:01:33,120 --> 19:01:36,000
Vou retornar um valor positivo, então

28814
19:01:36,000 --> 19:01:38,872
Vamos transformar essa lógica em um

28815
19:01:38,872 --> 19:01:41,120
Operador ternário, vamos dizer

28816
19:01:41,120 --> 19:01:46,320
retorno sdd str cmp nós podemos dizer isso e

28817
19:01:46,320 --> 19:01:47,600
Se você tem acesso a esta função

28818
19:01:47,600 --> 19:01:50,160
nós vamos precisar incluir c string

28819
19:01:50,160 --> 19:01:52,320
Vamos fazer isso, vamos incluir o

28820
19:01:52,320 --> 19:01:55,440
c string library e agora podemos dizer isso

28821
19:01:55,440 --> 19:01:58,160
e nós vamos passar em a e b e

28822
19:01:58,160 --> 19:02:00,400
nós vamos perguntar a nós mesmos é isso

28823
19:02:00,400 --> 19:02:02,480
Maior que zero é bom se for maior

28824
19:02:02,480 --> 19:02:05,440
do que zero então se o primeiro parâmetro é

28825
19:02:05,440 --> 19:02:07,360
maior que o segundo parâmetro, vamos

28826
19:02:07,360 --> 19:02:09,832
Veja graficamente, então vamos voltar

28827
19:02:09,832 --> 19:02:10,720
a

28828
19:02:10,720 --> 19:02:12,080
Se não for o caso, vamos

28829
19:02:12,080 --> 19:02:14,320
retorno b este é o nosso operador ternário

28830
19:02:14,320 --> 19:02:16,960
Aqui e vai funcionar agora que nós

28831
19:02:16,960 --> 19:02:19,360
ter este n o compilador vai

28832
19:02:19,360 --> 19:02:22,640
Saiba que temos uma especialização de templates

28833
19:02:22,640 --> 19:02:25,040
para um const car pointer se chamarmos o

28834
19:02:25,040 --> 19:02:27,040
Função como fizemos aqui chamando o

28835
19:02:27,040 --> 19:02:29,512
função máxima do compilador não é

28836
19:02:29,512 --> 19:02:31,760
vamos usar este modelo de função

28837
19:02:31,760 --> 19:02:34,240
Tenho no topo aqui vai ver que

28838
19:02:34,240 --> 19:02:37,832
Esta especialização é melhor

28839
19:02:37,832 --> 19:02:40,240
para o tipo de ponteiro de cartão de custo que nós

28840
19:02:40,240 --> 19:02:42,872
estão passando aqui e agora se tentarmos

28841
19:02:42,872 --> 19:02:45,120
construir e executar o programa que o barco é

28842
19:02:45,120 --> 19:02:47,512
Vou ser bom se limparmos e corrermos

28843
19:02:47,512 --> 19:02:49,440
Galo vamos ver que agora o

28844
19:02:49,440 --> 19:02:51,280
O máximo é selvagem

28845
19:02:51,280 --> 19:02:54,320
Vamos ver o que vemos se não temos

28846
19:02:54,320 --> 19:02:56,320
Esta especialização e nós vamos

28847
19:02:56,320 --> 19:02:58,240
Comente isso porque eu não acho que eu

28848
19:02:58,240 --> 19:03:00,160
Realmente te mostrou que vamos construir

28849
19:03:00,160 --> 19:03:02,552
uma e outra vez se fizermos isso

28850
19:03:02,552 --> 19:03:04,320
Este modelo de função vai ser

28851
19:03:04,320 --> 19:03:06,160
usado e você sabe que vai

28852
19:03:06,160 --> 19:03:08,872
deduzir uma função que compara ponteiros

28853
19:03:08,872 --> 19:03:10,872
diretamente e isso vai ser realmente

28854
19:03:10,872 --> 19:03:13,600
mal podemos construir isso com gcc e

28855
19:03:13,600 --> 19:03:16,400
realmente veja o que nós orramos como saída nós podemos

28856
19:03:16,400 --> 19:03:18,720
claro e correr galo agora você vê que

28857
19:03:18,720 --> 19:03:21,440
Dizemos que o animal é o máximo

28858
19:03:21,440 --> 19:03:23,600
Entre esses dois caras, mas isso não é

28859
19:03:23,600 --> 19:03:27,680
O verdadeiro animal é menos do que selvagem em

28860
19:03:27,680 --> 19:03:30,640
ordem lexicográfica precisamos de um caminho para

28861
19:03:30,640 --> 19:03:32,080
Realmente comparar

28862
19:03:32,080 --> 19:03:35,120
c strings corretamente e nosso template

28863
19:03:35,120 --> 19:03:36,640
Especialização

28864
19:03:36,640 --> 19:03:40,240
está realmente fazendo isso usando o htd crmp

28865
19:03:40,240 --> 19:03:43,040
função e está funcionando muito bem

28866
19:03:43,040 --> 19:03:44,872
Este é realmente todo modelo

28867
19:03:44,872 --> 19:03:47,040
A especialização é tudo sobre você ir

28868
19:03:47,040 --> 19:03:49,360
para fazer isso se a função padrão

28869
19:03:49,360 --> 19:03:51,440
O modelo que você tem não está realmente funcionando

28870
19:03:51,440 --> 19:03:53,920
de acordo com suas necessidades para o tipo

28871
19:03:53,920 --> 19:03:56,320
que você quer usar para isso e usar

28872
19:03:56,320 --> 19:03:58,000
Isso para sua vantagem, porque é

28873
19:03:58,000 --> 19:04:00,160
disponível para você e agora você sabe como

28874
19:04:00,160 --> 19:04:02,320
Use isso a sintaxe é realmente simples você

28875
19:04:02,320 --> 19:04:04,640
Diga modelo e você diz suportes de ângulo

28876
19:04:04,640 --> 19:04:07,192
e então você especificar o que quer que

28877
19:04:07,192 --> 19:04:09,600
implementação que você deseja para o seu

28878
19:04:09,600 --> 19:04:12,000
tipo específico, por exemplo, aqui nosso

28879
19:04:12,000 --> 19:04:14,000
Tipo específico para o qual queremos

28880
19:04:14,000 --> 19:04:16,872
especificar este modelo de função é custo

28881
19:04:16,872 --> 19:04:17,760
Cartão de cartão

28882
19:04:17,760 --> 19:04:20,552
Você especifica isso como um explícito

28883
19:04:20,552 --> 19:04:22,400
modelo de argumento e então você especificar

28884
19:04:22,400 --> 19:04:25,040
seu retorno valoriza seus parâmetros e

28885
19:04:25,040 --> 19:04:27,360
você faz qualquer lógica que você precisa fazer

28886
19:04:27,360 --> 19:04:29,760
Faça coisas certas no corpo disso

28887
19:04:29,760 --> 19:04:32,320
especialização aqui eu gostaria

28888
19:04:32,320 --> 19:04:34,552
Gostaria de recebê-lo neste novo capítulo

28889
19:04:34,552 --> 19:04:36,240
Onde vamos aprender sobre

28890
19:04:36,240 --> 19:04:40,000
Conceitos conceitos são um mecanismo que podemos

28891
19:04:40,000 --> 19:04:42,320
usar para configurar restrições ou

28892
19:04:42,320 --> 19:04:45,040
restrições aos parâmetros do modelo

28893
19:04:45,040 --> 19:04:47,512
em nossos modelos de função, por exemplo,

28894
19:04:47,512 --> 19:04:49,440
pode usar essa técnica para dizer que

28895
19:04:49,440 --> 19:04:51,680
Quer que nossa função seja chamada apenas com

28896
19:04:51,680 --> 19:04:53,680
inteiros e se você chamá-lo com

28897
19:04:53,680 --> 19:04:55,920
Algo que não é um inteiro é

28898
19:04:55,920 --> 19:04:58,080
vou dar-lhe um compilador uma coisa que eu

28899
19:04:58,080 --> 19:05:00,552
Deve enfatizar é que os conceitos são

28900
19:05:00,552 --> 19:05:03,280
Uma das quatro grandes características em c plus

28901
19:05:03,280 --> 19:05:05,120
mais 20. então vamos aprender

28902
19:05:05,120 --> 19:05:07,280
Neste capítulo, temos apenas

28903
19:05:07,280 --> 19:05:09,440
disse que nós os usamos para colocar

28904
19:05:09,440 --> 19:05:12,552
restrições em nossos parâmetros de modelo

28905
19:05:12,552 --> 19:05:14,400
Mas vimos que poderíamos fazer alguma coisa

28906
19:05:14,400 --> 19:05:16,872
assim no último capítulo em que

28907
19:05:16,872 --> 19:05:19,120
poderia usar tipos de negociações e estática

28908
19:05:19,120 --> 19:05:21,680
preocupações, por exemplo, se você olhar para o

28909
19:05:21,680 --> 19:05:22,960
Função aqui vai imprimir a

28910
19:05:22,960 --> 19:05:25,360
número mas temos uma exigência para

28911
19:05:25,360 --> 19:05:28,160
Este número é um tipo integral

28912
19:05:28,160 --> 19:05:30,240
através da afirmação estática de que temos

28913
19:05:30,240 --> 19:05:32,480
Aqui vamos ver que podemos fazer

28914
19:05:32,480 --> 19:05:35,440
Algo realmente semelhante com conceitos

28915
19:05:35,440 --> 19:05:37,760
Mas vai ser muito mais limpo e

28916
19:05:37,760 --> 19:05:40,832
que a lógica para fazer cumprir a nossa

28917
19:05:40,832 --> 19:05:43,040
As restrições não estarão no

28918
19:05:43,040 --> 19:05:45,192
função do corpo, vai ser um pouco

28919
19:05:45,192 --> 19:05:47,360
Na declaração de função no

28920
19:05:47,360 --> 19:05:49,440
restrições que colocamos no modelo

28921
19:05:49,440 --> 19:05:50,872
parâmetro aqui vamos ver

28922
19:05:50,872 --> 19:05:53,760
sintaxes específicas de como você pode fazer isso

28923
19:05:53,760 --> 19:05:56,080
A partir da próxima palestra, há

28924
19:05:56,080 --> 19:05:59,040
dois lados para conceitos em c plus plus

28925
19:05:59,040 --> 19:06:01,280
Existem conceitos internos padrão

28926
19:06:01,280 --> 19:06:03,120
que vem com o c plus mais

28927
19:06:03,120 --> 19:06:05,760
Linguagem de programação, mas se para alguns

28928
19:06:05,760 --> 19:06:08,400
Razão que estes não são suficientes para você

28929
19:06:08,400 --> 19:06:10,320
pode construir o seu próprio e nós vamos

28930
19:06:10,320 --> 19:06:12,320
Veja como podemos fazer isso mais tarde nisso

28931
19:06:12,320 --> 19:06:15,040
O capítulo aqui são alguns exemplos de

28932
19:06:15,040 --> 19:06:17,280
conceitos que você pode usar em seu c plus plus

28933
19:06:17,280 --> 19:06:19,600
programa que você pode usar a integral

28934
19:06:19,600 --> 19:06:21,920
conceitos para reforçar seus parâmetros

28935
19:06:21,920 --> 19:06:24,320
ser integral que você pode usar a flutuação

28936
19:06:24,320 --> 19:06:26,400
Conceito de ponto para impor que

28937
19:06:26,400 --> 19:06:29,040
parâmetros de modelo ser de ponto flutuante

28938
19:06:29,040 --> 19:06:31,120
digite que você pode fazer todos os tipos de loucos

28939
19:06:31,120 --> 19:06:33,920
As coisas que são bons conceitos são muito legais e

28940
19:06:33,920 --> 19:06:35,440
eles vão fazer sua função

28941
19:06:35,440 --> 19:06:38,240
modelos muito mais seguros para trabalhar, somos

28942
19:06:38,240 --> 19:06:40,320
Vou parar aqui nesta palestra e

28943
19:06:40,320 --> 19:06:42,872
mostrar como você pode usar conceitos

28944
19:06:42,872 --> 19:06:45,040
Começando na próxima palestra, vá em frente

28945
19:06:45,040 --> 19:06:47,760
e terminar aqui e encontrar-me lá dentro

28946
19:06:47,760 --> 19:06:49,600
Esta palestra vamos aprender sobre

28947
19:06:49,600 --> 19:06:53,280
Conceitos novamente conceitos são um mecanismo

28948
19:06:53,280 --> 19:06:56,400
nós temos no lugar em c mais 20 para colocar

28949
19:06:56,400 --> 19:06:59,832
restrições em nossos modelos de função

28950
19:06:59,832 --> 19:07:01,760
Por exemplo, podemos usar conceitos para

28951
19:07:01,760 --> 19:07:03,120
Especificar a

28952
19:07:03,120 --> 19:07:05,600
que queremos o nosso modelo de função para

28953
19:07:05,600 --> 19:07:08,552
ser chamado apenas com inteiros ou duplos

28954
19:07:08,552 --> 19:07:10,640
ou cordas ou qualquer coisa

28955
19:07:10,640 --> 19:07:13,680
E quando alguém viola o nosso conceito

28956
19:07:13,680 --> 19:07:15,512
eles vão ter um erro de compilador em

28957
19:07:15,512 --> 19:07:17,512
Esta palestra vou te mostrar como

28958
19:07:17,512 --> 19:07:19,360
Você pode configurar seu conceito e

28959
19:07:19,360 --> 19:07:21,832
diferentes sintaxes que você pode usar e como

28960
19:07:21,832 --> 19:07:23,600
nós podemos compreendê-los

28961
19:07:23,600 --> 19:07:25,920
mas antes que façamos isso, por favor, note que

28962
19:07:25,920 --> 19:07:28,480
Há dois lados para os conceitos lá

28963
19:07:28,480 --> 19:07:31,360
são conceitos que são padrão e construídos

28964
19:07:31,360 --> 19:07:34,320
na biblioteca padrão c plus plus

28965
19:07:34,320 --> 19:07:36,400
e aqueles estão prontos para uso e estes são

28966
19:07:36,400 --> 19:07:37,920
O que vamos usar nisso

28967
19:07:37,920 --> 19:07:40,720
palestra, mas saiba que você também pode construir

28968
19:07:40,720 --> 19:07:43,360
seus próprios conceitos e usá-los para fazer

28969
19:07:43,360 --> 19:07:45,760
O que quer que você queira fazer aqui são

28970
19:07:45,760 --> 19:07:48,320
poucos exemplos de conceitos internos que podemos

28971
19:07:48,320 --> 19:07:50,320
uso do c plus padrão

28972
19:07:50,320 --> 19:07:53,192
Biblioteca temos, por exemplo, um conceito que

28973
19:07:53,192 --> 19:07:55,040
pode usar para fazer cumprir

28974
19:07:55,040 --> 19:07:57,680
que as pessoas chamam nossas funções apenas com

28975
19:07:57,680 --> 19:08:00,640
tipos integrais se eles violarem isso

28976
19:08:00,640 --> 19:08:02,552
eles vão ter um erro de compilador nós

28977
19:08:02,552 --> 19:08:04,800
também pode aplicar para o nosso modelo

28978
19:08:04,800 --> 19:08:07,040
parâmetros para ser o ponto flutuante que podemos

28979
19:08:07,040 --> 19:08:09,192
fazer todos os tipos de coisas loucas bem agora

28980
19:08:09,192 --> 19:08:11,280
que você sabe disso, vamos ver como podemos

28981
19:08:11,280 --> 19:08:13,760
configurar um conceito sobre nossa função

28982
19:08:13,760 --> 19:08:16,240
templates e esta é a primeira sintaxe

28983
19:08:16,240 --> 19:08:18,240
nós vamos olhar para tudo o que você realmente

28984
19:08:18,240 --> 19:08:21,120
Você tem que fazer é colocar em seu modelo

28985
19:08:21,120 --> 19:08:23,192
Declaração como temos feito tudo

28986
19:08:23,192 --> 19:08:26,160
Você também tem que adicionar o

28987
19:08:26,160 --> 19:08:29,680
requer uma palavra-chave aqui após as necessidades

28988
19:08:29,680 --> 19:08:31,512
palavra-chave que você vai especificar o seu

28989
19:08:31,512 --> 19:08:34,800
conceito e especificar o seu modelo

28990
19:08:34,800 --> 19:08:37,512
parâmetro em suportes de ângulo aqui

28991
19:08:37,512 --> 19:08:39,920
Quando você tem essa coisa na frente de

28992
19:08:39,920 --> 19:08:42,240
seu modelo de função como temos aqui

28993
19:08:42,240 --> 19:08:44,552
O modelo de função só pode funcionar

28994
19:08:44,552 --> 19:08:47,680
certo se o conceito aqui é

28995
19:08:47,680 --> 19:08:50,400
satisfeito e este conceito neste caso

28996
19:08:50,400 --> 19:08:53,280
Vai ficar satisfeito se alguém

28997
19:08:53,280 --> 19:08:56,080
Tenta chamar esse modelo de função

28998
19:08:56,080 --> 19:08:59,120
somente com tipos integrais se eles violarem

28999
19:08:59,120 --> 19:09:00,872
que mais uma vez eles vão ter um

29000
19:09:00,872 --> 19:09:03,192
Erro do compilador bem uma vez que temos isso

29001
19:09:03,192 --> 19:09:05,680
conceito configurado para que possamos olhar para a peça

29002
19:09:05,680 --> 19:09:08,800
de código que tenta usá-lo e tentar

29003
19:09:08,800 --> 19:09:11,120
Adivinha que o que vai acontecer aqui é um

29004
19:09:11,120 --> 19:09:12,800
pedaço de código que iria configurar no

29005
19:09:12,800 --> 19:09:15,192
função principal e tentar chamar uma função

29006
19:09:15,192 --> 19:09:17,920
modelo, temos duas variáveis de carro

29007
19:09:17,920 --> 19:09:20,480
Tipo sabemos que o carro é um integral

29008
19:09:20,480 --> 19:09:23,680
digite, portanto, se emitirmos uma chamada como essa

29009
19:09:23,680 --> 19:09:25,832
Esta chamada vai funcionar o template

29010
19:09:25,832 --> 19:09:28,160
A instância será gerada e

29011
19:09:28,160 --> 19:09:29,920
vai ser chamado e nos dar o

29012
19:09:29,920 --> 19:09:32,080
resultados que podemos imprimir aqui este é

29013
19:09:32,080 --> 19:09:35,040
à direita no segundo pedaço de código aqui

29014
19:09:35,040 --> 19:09:38,160
temos duas variáveis de tipo e

29015
19:09:38,160 --> 19:09:40,000
nós vamos chamá-los de que vamos

29016
19:09:40,000 --> 19:09:42,640
chamar o nosso modelo de função com e

29017
19:09:42,640 --> 19:09:45,512
e isso também é um tipo integral de entrada é

29018
19:09:45,512 --> 19:09:47,280
um tipo integral, então isso vai

29019
19:09:47,280 --> 19:09:50,000
gerar nossa instância de modelo de função

29020
19:09:50,000 --> 19:09:51,600
e nós vamos chamá-lo e pegar o

29021
19:09:51,600 --> 19:09:54,240
resultados que imprimimos aqui e se tentarmos

29022
19:09:54,240 --> 19:09:56,800
para chamar o nosso modelo de função com

29023
19:09:56,800 --> 19:09:58,400
Tipos duplos

29024
19:09:58,400 --> 19:10:00,640
O conceito não será satisfeito

29025
19:10:00,640 --> 19:10:02,400
e nós vamos ter algum tipo de

29026
19:10:02,400 --> 19:10:04,960
erro e nossa instância de modelo de função

29027
19:10:04,960 --> 19:10:06,872
Não vai ser gerado este é

29028
19:10:06,872 --> 19:10:09,832
realmente como você pode usar conceitos para forçar

29029
19:10:09,832 --> 19:10:13,120
algumas regras sobre os usuários de sua função

29030
19:10:13,120 --> 19:10:15,440
templates se eu posso dizer assim que nós

29031
19:10:15,440 --> 19:10:17,512
Conseguiram fazer algo assim

29032
19:10:17,512 --> 19:10:19,512
usando traços digitados e a estática

29033
19:10:19,512 --> 19:10:22,240
Afirma no último capítulo, mas conceitos

29034
19:10:22,240 --> 19:10:24,872
São muito mais limpos e que eles são gentis

29035
19:10:24,872 --> 19:10:27,040
de embutido na assinatura do seu

29036
19:10:27,040 --> 19:10:28,800
função que você não tem que ir no

29037
19:10:28,800 --> 19:10:30,872
corpo da sua função e configurar estática

29038
19:10:30,872 --> 19:10:33,440
Afirma que a função já é

29039
19:10:33,440 --> 19:10:36,720
apoiar conceitos quando você declara e

29040
19:10:36,720 --> 19:10:38,800
Defina-o e isso é muito legal ok

29041
19:10:38,800 --> 19:10:40,960
Esta é a nossa primeira sintaxe que podemos usar para

29042
19:10:40,960 --> 19:10:43,192
configurar conceitos

29043
19:10:43,192 --> 19:10:45,360
para nossos modelos de função usando o

29044
19:10:45,360 --> 19:10:47,680
requer close após o nosso modelo

29045
19:10:47,680 --> 19:10:50,480
declaração e seguindo isso com

29046
19:10:50,480 --> 19:10:53,192
Seja qual for o conceito que queremos impor

29047
19:10:53,192 --> 19:10:55,360
nosso modelo de função aqui, por favor note

29048
19:10:55,360 --> 19:10:57,512
que você também pode usar características de tipo

29049
19:10:57,512 --> 19:10:58,720
diretamente

29050
19:10:58,720 --> 19:11:00,720
na cláusula exigida aqui e isso é

29051
19:11:00,720 --> 19:11:03,680
Vou trabalhar e isso realmente diz que

29052
19:11:03,680 --> 19:11:05,680
Tudo que você realmente tem que colocar depois do

29053
19:11:05,680 --> 19:11:07,280
Requer perto

29054
19:11:07,280 --> 19:11:09,920
É uma expressão que pode ser avaliada

29055
19:11:09,920 --> 19:11:13,680
em tempo de compilação, mas também resulta em um

29056
19:11:13,680 --> 19:11:16,640
valor booleano uma vez que você satisfaz esses poucos

29057
19:11:16,640 --> 19:11:19,360
requisitos que você pode realmente configurar seu

29058
19:11:19,360 --> 19:11:21,512
Conceito como quiser, você só tem

29059
19:11:21,512 --> 19:11:24,640
para ter cuidado para que a expiração possa ser

29060
19:11:24,640 --> 19:11:27,680
avaliado em tempo de compilação e que

29061
19:11:27,680 --> 19:11:30,552
avalia um valor booleano e quando

29062
19:11:30,552 --> 19:11:32,720
a expressão avalia a verdadeira

29063
19:11:32,720 --> 19:11:35,600
O conceito vai ter sucesso se

29064
19:11:35,600 --> 19:11:37,832
expressão avalia para falso que você é

29065
19:11:37,832 --> 19:11:39,600
vai ter um erro de compilador porque

29066
19:11:39,600 --> 19:11:42,080
O conceito não está satisfeito é assim

29067
19:11:42,080 --> 19:11:44,160
Essas coisas funcionam agora que temos visto

29068
19:11:44,160 --> 19:11:46,800
A primeira sintaxe eu acho que é um grande momento

29069
19:11:46,800 --> 19:11:48,872
olhamos para a segunda maneira que você pode definir

29070
19:11:48,872 --> 19:11:51,760
conceitos para cima e que vai estar dentro

29071
19:11:51,760 --> 19:11:53,920
sua declaração de modelo que você está indo

29072
19:11:53,920 --> 19:11:55,832
para dizer modelo colocar em seu ângulo

29073
19:11:55,832 --> 19:11:58,400
colchetes e dentro em vez de dizer

29074
19:11:58,400 --> 19:12:00,640
nome do tipo t como estamos fazendo tudo

29075
19:12:00,640 --> 19:12:03,512
Basta especificar seu conceito

29076
19:12:03,512 --> 19:12:06,872
diretamente e salvar o parâmetro template

29077
19:12:06,872 --> 19:12:09,760
assim, uma vez que você faz esse conceito

29078
19:12:09,760 --> 19:12:12,080
vai ser aplicado sobre esta função

29079
19:12:12,080 --> 19:12:14,160
modelo aqui é apenas mais um

29080
19:12:14,160 --> 19:12:16,160
sintaxe para realmente fazer a mesma coisa que nós

29081
19:12:16,160 --> 19:12:18,720
também temos uma terceira sintaxe que podemos usar se

29082
19:12:18,720 --> 19:12:21,512
usamos o auto para configurar nossa função

29083
19:12:21,512 --> 19:12:23,920
templates e a maneira como isso funciona é para

29084
19:12:23,920 --> 19:12:26,872
Basta adicionar seu conceito na frente do

29085
19:12:26,872 --> 19:12:30,000
auto palavra-chave e uma vez que você faz isso

29086
19:12:30,000 --> 19:12:31,920
O compilador vai impor para o

29087
19:12:31,920 --> 19:12:33,920
Primeiro parâmetro e o segundo parâmetro

29088
19:12:33,920 --> 19:12:35,280
Para esta função

29089
19:12:35,280 --> 19:12:38,960
satisfazer os conceitos integrais se

29090
19:12:38,960 --> 19:12:41,280
você tem que usar o auto para configurar a função

29091
19:12:41,280 --> 19:12:43,360
templates é assim que você pode usar

29092
19:12:43,360 --> 19:12:45,600
Conceitos para restringir

29093
19:12:45,600 --> 19:12:47,832
maneiras pelas quais as pessoas usam sua função

29094
19:12:47,832 --> 19:12:50,000
Ainda temos outra maneira de usar

29095
19:12:50,000 --> 19:12:52,872
conceitos em c plus plus e é assim que

29096
19:12:52,872 --> 19:12:54,720
Você faz isso, você especifica seu modelo

29097
19:12:54,720 --> 19:12:56,872
Declaração como temos feito tudo

29098
19:12:56,872 --> 19:12:59,760
Especificar seu modelo de função

29099
19:12:59,760 --> 19:13:02,872
mas depois da lista de parâmetros como vemos

29100
19:13:02,872 --> 19:13:05,120
Aqui você vai colocar suas necessidades

29101
19:13:05,120 --> 19:13:07,600
perto e você pode colocar isso neste lugar

29102
19:13:07,600 --> 19:13:10,160
aqui e vai funcionar, eu percebo

29103
19:13:10,160 --> 19:13:12,552
Estas são muitas sintaxes para processar para

29104
19:13:12,552 --> 19:13:14,552
Primeira vez, mas algumas delas

29105
19:13:14,552 --> 19:13:16,480
As sintaxes vão funcionar melhor em

29106
19:13:16,480 --> 19:13:19,440
Algumas situações e elas estão lá apenas

29107
19:13:19,440 --> 19:13:21,760
para torná-lo flexível para você usar

29108
19:13:21,760 --> 19:13:24,240
conceitos em seu c plus código OK

29109
19:13:24,240 --> 19:13:26,240
Agora que vimos maneiras diferentes

29110
19:13:26,240 --> 19:13:28,400
pode configurar conceitos para a nossa função

29111
19:13:28,400 --> 19:13:30,552
templates eu acho que neste grande momento nós

29112
19:13:30,552 --> 19:13:32,872
dirige-se para o código do estúdio visual e

29113
19:13:32,872 --> 19:13:35,680
experimentá-los bem aqui estamos em nosso

29114
19:13:35,680 --> 19:13:37,832
pasta de trabalho o capítulo atual é

29115
19:13:37,832 --> 19:13:40,080
conceitos que a palestra atual está usando

29116
19:13:40,080 --> 19:13:42,640
Conceitos que vamos pegar nosso

29117
19:13:42,640 --> 19:13:45,280
arquivos de modelo que vamos colocá-los

29118
19:13:45,280 --> 19:13:46,480
no lugar

29119
19:13:46,480 --> 19:13:48,800
e nós vamos abrir essa coisa em

29120
19:13:48,800 --> 19:13:50,800
código visual do estúdio arrastando e

29121
19:13:50,800 --> 19:13:53,280
cair em cima do código de estúdio visual

29122
19:13:53,280 --> 19:13:55,832
Aqui fazemos que isso vai abrir

29123
19:13:55,832 --> 19:13:57,832
nossa pasta vamos abrir o nosso

29124
19:13:57,832 --> 19:14:01,440
arquivo principal cpp e fechar a barra lateral aqui

29125
19:14:01,440 --> 19:14:02,960
E nós vamos limpar as coisas e

29126
19:14:02,960 --> 19:14:04,552
Um pouquinho e nós vamos montar um

29127
19:14:04,552 --> 19:14:06,320
modelo de função que vai adicionar

29128
19:14:06,320 --> 19:14:08,000
Dois números que já sabemos como fazer

29129
19:14:08,000 --> 19:14:10,080
Então vamos dizer tipo de modelo

29130
19:14:10,080 --> 19:14:12,400
Nome e vai ter um modelo

29131
19:14:12,400 --> 19:14:14,872
parâmetro de t, então vamos definir

29132
19:14:14,872 --> 19:14:17,040
A função como estamos fazendo

29133
19:14:17,040 --> 19:14:19,192
O tempo todo nós vamos dizer acrescentar que estamos

29134
19:14:19,192 --> 19:14:22,080
indo dizer t a e t b e isso é

29135
19:14:22,080 --> 19:14:25,040
voltar a soma de a e b uma vez

29136
19:14:25,040 --> 19:14:27,680
Você tem a função em que podemos entrar

29137
19:14:27,680 --> 19:14:30,080
A função principal e configurar o código que

29138
19:14:30,080 --> 19:14:32,400
chamaria essa função e se tentarmos

29139
19:14:32,400 --> 19:14:34,552
para compilar este programa, ele vai

29140
19:14:34,552 --> 19:14:37,760
trabalho agora porque não estamos colocando nenhum

29141
19:14:37,760 --> 19:14:40,240
restrições sobre este modelo de função

29142
19:14:40,240 --> 19:14:43,040
Aqui vamos tentar construir com gcc como nós

29143
19:14:43,040 --> 19:14:45,192
Tenho feito o tempo todo, você vê que é

29144
19:14:45,192 --> 19:14:47,832
indo para soldar ok, você vê que o mundo é

29145
19:14:47,832 --> 19:14:50,160
Bom mundo terminou com sucesso e se

29146
19:14:50,160 --> 19:14:52,240
Queremos que possamos executar esta aplicação e

29147
19:14:52,240 --> 19:14:54,640
vai imprimir o resultado a

29148
19:14:54,640 --> 19:14:57,760
resultado b vamos tirar isso porque nós

29149
19:14:57,760 --> 19:14:59,680
Ainda não fiz isso, mas não está indo

29150
19:14:59,680 --> 19:15:02,000
para imprimir o resultado c mas se quisermos nós podemos

29151
19:15:02,000 --> 19:15:03,920
realmente imprimi-lo vai funcionar assim

29152
19:15:03,920 --> 19:15:04,960
- Vamos lá.

29153
19:15:04,960 --> 19:15:07,120
Coloque isso dentro e nós vamos dizer

29154
19:15:07,120 --> 19:15:11,120
resultado c e impressão de resultado c aqui e

29155
19:15:11,120 --> 19:15:13,440
mundo novamente vamos ao mundo agora para tomar isso

29156
19:15:13,440 --> 19:15:14,800
em conta

29157
19:15:14,800 --> 19:15:16,800
O mundo é bom, podemos trazer um terminal

29158
19:15:16,800 --> 19:15:19,600
para experimentar isso e podemos limpar e correr

29159
19:15:19,600 --> 19:15:22,400
Galo agora você vê o resultado a é 30

29160
19:15:22,400 --> 19:15:24,872
Porque essa é a soma de a e b aqui

29161
19:15:24,872 --> 19:15:27,680
O resultado b deve ser 16, que é o que nós

29162
19:15:27,680 --> 19:15:31,360
O resultado c é 13, que é o que nós

29163
19:15:31,360 --> 19:15:34,000
Deve obter adicionando estes dois duplos

29164
19:15:34,000 --> 19:15:35,280
As variáveis

29165
19:15:35,280 --> 19:15:38,480
Agora queríamos restringir essa função

29166
19:15:38,480 --> 19:15:41,920
só funciona se alguém passar integral

29167
19:15:41,920 --> 19:15:44,240
tipos e quando colocamos essa restrição em

29168
19:15:44,240 --> 19:15:46,552
lugar que vai funcionar se nós somarmos

29169
19:15:46,552 --> 19:15:49,760
duas variáveis de caráter porque são

29170
19:15:49,760 --> 19:15:52,160
tipos integrais, vai funcionar se nós

29171
19:15:52,160 --> 19:15:54,320
adicionar duas variáveis de inteiro por causa

29172
19:15:54,320 --> 19:15:57,040
são tipos integrais, mas uma vez que batemos

29173
19:15:57,040 --> 19:15:58,552
Este tipo aqui

29174
19:15:58,552 --> 19:16:00,552
Com a dupla variáveis que devemos obter

29175
19:16:00,552 --> 19:16:03,760
um erro do compilador porque a restrição

29176
19:16:03,760 --> 19:16:05,920
Não está satisfeito, vamos fazer isso

29177
19:16:05,920 --> 19:16:08,160
Vou comentar a coisa dupla primeiro

29178
19:16:08,160 --> 19:16:11,040
porque queremos realmente isolá-lo e

29179
19:16:11,040 --> 19:16:13,120
vê-lo e ver o erro do compilador que

29180
19:16:13,120 --> 19:16:14,720
nós temos e nós vamos adicionar um

29181
19:16:14,720 --> 19:16:17,440
restrição ao nosso modelo de função

29182
19:16:17,440 --> 19:16:20,080
Usando conceitos bem se você quiser usar

29183
19:16:20,080 --> 19:16:22,480
conceitos em c mais mais 20 do primeiro

29184
19:16:22,480 --> 19:16:24,480
O que você precisa fazer é incluir o

29185
19:16:24,480 --> 19:16:27,440
Biblioteca que nos dá acesso a conceitos

29186
19:16:27,440 --> 19:16:28,960
e nós vamos fazer isso dizendo

29187
19:16:28,960 --> 19:16:31,512
Isso é fácil agora que

29188
19:16:31,512 --> 19:16:33,440
nós temos esse fim, vamos usar o

29189
19:16:33,440 --> 19:16:36,080
primeira sintaxe que vimos nos slides e

29190
19:16:36,080 --> 19:16:38,400
Vamos adicionar as necessidades próximas

29191
19:16:38,400 --> 19:16:40,552
após a declaração do modelo

29192
19:16:40,552 --> 19:16:43,512
e nós vamos dizer stt integral e

29193
19:16:43,512 --> 19:16:45,040
nós vamos dizer o modelo

29194
19:16:45,040 --> 19:16:46,640
parâmetro aqui eu acho que este é o

29195
19:16:46,640 --> 19:16:49,600
sintaxe OK, observe o que acontece se fizermos

29196
19:16:49,600 --> 19:16:52,400
Isso no código que estamos chamando de

29197
19:16:52,400 --> 19:16:54,640
função com tipos de carro

29198
19:16:54,640 --> 19:16:55,512
E a

29199
19:16:55,512 --> 19:16:57,192
Tipos inteiros, então isso vai

29200
19:16:57,192 --> 19:17:00,400
compilar bem porque o conceito aqui

29201
19:17:00,400 --> 19:17:03,192
está satisfeito que este conceito vai

29202
19:17:03,192 --> 19:17:05,680
impor para os parâmetros do modelo que nós

29203
19:17:05,680 --> 19:17:08,720
chamar um modelo de função com estar

29204
19:17:08,720 --> 19:17:12,080
tipos integrais, vamos construir e ver se nós

29205
19:17:12,080 --> 19:17:14,960
começar a compilar com sucesso você vê ambos

29206
19:17:14,960 --> 19:17:16,872
Acabar bem que tudo vai chegar

29207
19:17:16,872 --> 19:17:19,040
trabalhar e se executarmos nosso programa, devemos

29208
19:17:19,040 --> 19:17:21,280
ver resultados a e resultado a ser impresso

29209
19:17:21,280 --> 19:17:23,680
Vamos executar o programa que vemos

29210
19:17:23,680 --> 19:17:25,920
Resultado aqui agora vamos comentar

29211
19:17:25,920 --> 19:17:29,760
fora os outros e deixar no duplo

29212
19:17:29,760 --> 19:17:32,000
exemplo e nós vamos descomente

29213
19:17:32,000 --> 19:17:33,832
Isso e eu quero que você veja o problema

29214
19:17:33,832 --> 19:17:36,400
nós temos quando tentamos usar

29215
19:17:36,400 --> 19:17:38,160
nosso modelo de função com duplo

29216
19:17:38,160 --> 19:17:40,480
variáveis aqui você vê estúdio visual

29217
19:17:40,480 --> 19:17:42,400
O código já está reclamando que está dizendo

29218
19:17:42,400 --> 19:17:44,800
Há algo errado se olharmos

29219
19:17:44,800 --> 19:17:47,280
A guia de problemas vai dizer não

29220
19:17:47,280 --> 19:17:48,960
Exemplo de modelo de função add

29221
19:17:48,960 --> 19:17:50,960
corresponde à lista de argumentos, mas isso é

29222
19:17:50,960 --> 19:17:53,440
Não é suficientemente descritivo, mas sim de

29223
19:17:53,440 --> 19:17:56,640
O problema é que nosso conceito não está satisfeito

29224
19:17:56,640 --> 19:17:59,360
Chamando nosso modelo de função com

29225
19:17:59,360 --> 19:18:03,120
tipos duplos porque dissemos claramente

29226
19:18:03,120 --> 19:18:05,600
que queremos que a função seja apenas

29227
19:18:05,600 --> 19:18:08,552
chamados com tipos integrais, vamos construir

29228
19:18:08,552 --> 19:18:10,480
nosso programa vamos passar por isso

29229
19:18:10,480 --> 19:18:12,080
através do gcc

29230
19:18:12,080 --> 19:18:14,240
e vamos ter um erro de compilador

29231
19:18:14,240 --> 19:18:16,800
que diz que algum conceito foi

29232
19:18:16,800 --> 19:18:18,320
Não satisfeito

29233
19:18:18,320 --> 19:18:21,512
e vemos que vemos na função principal

29234
19:18:21,512 --> 19:18:25,440
uso de função t adicionar com duplo com

29235
19:18:25,440 --> 19:18:28,480
Restrições insatisfações e isso é

29236
19:18:28,480 --> 19:18:30,720
muito claro quando vemos um erro como

29237
19:18:30,720 --> 19:18:32,640
Vamos isto e olharemos para o

29238
19:18:32,640 --> 19:18:35,192
restrições que a função tem e

29239
19:18:35,192 --> 19:18:37,360
nós vamos ver se nós satisfazemos isso

29240
19:18:37,360 --> 19:18:39,600
Restrições chamando

29241
19:18:39,600 --> 19:18:41,192
como fizemos na função principal aqui

29242
19:18:41,192 --> 19:18:42,960
E saberemos que a função

29243
19:18:42,960 --> 19:18:45,600
não suporta tipos não integrais e

29244
19:18:45,600 --> 19:18:48,080
vamos resolver este problema, isso é realmente

29245
19:18:48,080 --> 19:18:50,552
Como os conceitos podem ajudar

29246
19:18:50,552 --> 19:18:53,440
em escrever modelos de função mais seguros agora

29247
19:18:53,440 --> 19:18:55,680
que vimos a primeira sintaxe i

29248
19:18:55,680 --> 19:18:57,832
Acho que é um grande momento em que olhamos para o

29249
19:18:57,832 --> 19:19:00,480
Outras sintaxes, então vamos fazer isso

29250
19:19:00,480 --> 19:19:01,920
Copie o código aqui porque vamos

29251
19:19:01,920 --> 19:19:04,872
estar reutilizando isso algumas vezes e

29252
19:19:04,872 --> 19:19:07,120
adaptá-lo em vez de digitar tudo

29253
19:19:07,120 --> 19:19:10,240
A coisa que a segunda sintaxe envolve ficar

29254
19:19:10,240 --> 19:19:12,960
Livre das necessidades próximas todas juntas

29255
19:19:12,960 --> 19:19:16,480
E apenas usando o conceito em vez de

29256
19:19:16,480 --> 19:19:19,192
Digite nome aqui, então eu vou dizer std

29257
19:19:19,192 --> 19:19:21,600
Integral e isso vai ser o suficiente

29258
19:19:21,600 --> 19:19:23,920
Isto vai dizer ao compilador para

29259
19:19:23,920 --> 19:19:27,040
impor este conceito para esta função

29260
19:19:27,040 --> 19:19:27,832
chamada

29261
19:19:27,832 --> 19:19:31,192
para todos os parâmetros do modelo que vão

29262
19:19:31,192 --> 19:19:33,920
no lugar de t aqui espero que isso faça

29263
19:19:33,920 --> 19:19:36,400
Sentir agora se voltarmos, vemos que nós

29264
19:19:36,400 --> 19:19:38,720
Ainda temos nossas linhas piggly aqui se nós

29265
19:19:38,720 --> 19:19:41,040
Tente compilar vamos ter o mesmo

29266
19:19:41,040 --> 19:19:43,360
Erro do compilador bem e você vê que temos

29267
19:19:43,360 --> 19:19:46,320
a mesma função de erro do compilador add t

29268
19:19:46,320 --> 19:19:49,192
chamado com restrições insatisfeitas i

29269
19:19:49,192 --> 19:19:50,800
Acho que se você cair, nós vamos ver

29270
19:19:50,800 --> 19:19:53,600
ainda mais coisas disso está indo

29271
19:19:53,600 --> 19:19:57,832
para dizer exigir a satisfação de std

29272
19:19:57,832 --> 19:20:00,640
integral com t mas agora estamos tentando

29273
19:20:00,640 --> 19:20:03,192
chamar isso com o dobro, então isso é realmente

29274
19:20:03,192 --> 19:20:06,240
vai levar a um erro do compilador, então

29275
19:20:06,240 --> 19:20:08,160
Esta é a segunda sintaxe e é

29276
19:20:08,160 --> 19:20:10,400
Vou fazer a mesma coisa agora que nós

29277
19:20:10,400 --> 19:20:13,192
Já vimos isso, também temos uma terceira via

29278
19:20:13,192 --> 19:20:15,600
nós podemos fazer isso e isso é através do

29279
19:20:15,600 --> 19:20:18,720
auto mecanismo, vamos configurar uma função

29280
19:20:18,720 --> 19:20:21,280
usando auto para que vamos dizer auto

29281
19:20:21,280 --> 19:20:24,320
adicionar auto a e auto b temos visto que

29282
19:20:24,320 --> 19:20:26,320
Podemos fazer isso no último capítulo e

29283
19:20:26,320 --> 19:20:28,720
nós vamos retornar a e b a plus b i

29284
19:20:28,720 --> 19:20:31,120
Devo dizer se fizermos isso você vê que

29285
19:20:31,120 --> 19:20:33,360
a linha do squiggly vai embora e nós podemos

29286
19:20:33,360 --> 19:20:35,920
adicionar essas coisas e imprimir o resultado

29287
19:20:35,920 --> 19:20:37,832
O tipo de retorno será deduzido

29288
19:20:37,832 --> 19:20:40,240
pelo compilador automaticamente, mas saiba

29289
19:20:40,240 --> 19:20:41,832
que isso vai gerar um

29290
19:20:41,832 --> 19:20:44,240
modelo de função nos bastidores

29291
19:20:44,240 --> 19:20:46,320
é apenas uma sintaxe mais agradável que temos que usar

29292
19:20:46,320 --> 19:20:48,960
Auto para configurar funções que funcionem para

29293
19:20:48,960 --> 19:20:52,000
vários tipos, vamos construir e ver

29294
19:20:52,000 --> 19:20:55,040
Como gcc lida com isso o mundo é bom

29295
19:20:55,040 --> 19:20:57,832
porque não temos restrições aqui e

29296
19:20:57,832 --> 19:21:00,160
Se executarmos nosso programa, vai funcionar

29297
19:21:00,160 --> 19:21:03,120
vai nos dar 13 como a soma de

29298
19:21:03,120 --> 19:21:07,440
11.1 e 1.9 mas também podemos colocar

29299
19:21:07,440 --> 19:21:09,512
restrições nesta função aqui e

29300
19:21:09,512 --> 19:21:12,640
você faz isso especificando seu conceito

29301
19:21:12,640 --> 19:21:15,360
na frente da palavra-chave automática aqui para

29302
19:21:15,360 --> 19:21:18,640
exemplo, podemos dizer std integral e std

29303
19:21:18,640 --> 19:21:21,040
dobra integral o segundo parâmetro aqui

29304
19:21:21,040 --> 19:21:23,760
Vamos dizer isso e uma vez que fazemos isso se nós

29305
19:21:23,760 --> 19:21:26,720
descemos, devemos ver a nossa linha squiggly

29306
19:21:26,720 --> 19:21:28,552
na chamada da função aqui, porque

29307
19:21:28,552 --> 19:21:31,360
Agora a maneira como estamos chamando essa função

29308
19:21:31,360 --> 19:21:34,160
não é válido a função diz claramente

29309
19:21:34,160 --> 19:21:37,512
que ele quer ser chamado apenas com

29310
19:21:37,512 --> 19:21:41,440
argumentos que satisfazem esse conceito aqui

29311
19:21:41,440 --> 19:21:43,680
Se estamos tentando construir novamente com gcc

29312
19:21:43,680 --> 19:21:45,280
Vamos pegar o semicompilador

29313
19:21:45,280 --> 19:21:47,600
Erro, vamos fazer isso e vai

29314
19:21:47,600 --> 19:21:50,120
Diga função de uso com

29315
19:21:50,120 --> 19:21:52,872
Restrições insatisfeitas o mesmo erro

29316
19:21:52,872 --> 19:21:55,832
E se descermos, devemos ver que

29317
19:21:55,832 --> 19:21:58,720
requer a integral

29318
19:21:58,720 --> 19:22:01,760
conceito para ser satisfeito aqui, então isso é

29319
19:22:01,760 --> 19:22:03,832
A terceira sintaxe que você pode usar se você

29320
19:22:03,832 --> 19:22:06,480
Acontece que está usando a sintaxe automática para

29321
19:22:06,480 --> 19:22:08,640
seus modelos de função vamos comentar

29322
19:22:08,640 --> 19:22:10,640
Isso porque ainda temos outro

29323
19:22:10,640 --> 19:22:12,872
Sintaxe que precisamos aprender sobre isso é

29324
19:22:12,872 --> 19:22:15,360
Será a nossa sintaxe três e nós somos

29325
19:22:15,360 --> 19:22:17,680
Vou comentar isso e o último

29326
19:22:17,680 --> 19:22:19,440
Uma delas envolve

29327
19:22:19,440 --> 19:22:22,160
apenas deixando em nosso modelo de função

29328
19:22:22,160 --> 19:22:23,832
Vamos copiar isso porque eu não quero

29329
19:22:23,832 --> 19:22:26,080
Digite isso novamente, vamos descer

29330
19:22:26,080 --> 19:22:28,160
e dizer sintaxe e colocar em nosso

29331
19:22:28,160 --> 19:22:30,240
modelo de função que vamos levar

29332
19:22:30,240 --> 19:22:32,960
Isso requer perto, vamos cortar

29333
19:22:32,960 --> 19:22:36,240
fora e nós vamos colocá-lo depois

29334
19:22:36,240 --> 19:22:38,552
a lista de parâmetros da função

29335
19:22:38,552 --> 19:22:40,480
assim e isso vai ser válido

29336
19:22:40,480 --> 19:22:41,192
c - Em

29337
19:22:41,192 --> 19:22:44,160
sintaxe para impor um conceito em sua

29338
19:22:44,160 --> 19:22:46,800
modelo de função se formos para baixo você ver

29339
19:22:46,800 --> 19:22:49,360
nós temos essa linha wiggly e eu deveria

29340
19:22:49,360 --> 19:22:51,440
Prova que isso funciona com outros

29341
19:22:51,440 --> 19:22:54,000
tipos integrais aqui vamos apenas comentar

29342
19:22:54,000 --> 19:22:56,552
fora a linha dupla aqui e descomenta

29343
19:22:56,552 --> 19:22:59,920
o outro que tínhamos para o carro e formia se nós

29344
19:22:59,920 --> 19:23:01,920
Tente construir este programa agora que é

29345
19:23:01,920 --> 19:23:03,680
vai trabalhar bem porque o

29346
19:23:03,680 --> 19:23:06,640
As restrições estão satisfeitas, mas o momento

29347
19:23:06,640 --> 19:23:09,832
descomentamos as chamadas com tipos duplos

29348
19:23:09,832 --> 19:23:12,080
nós vamos ter uma linha esquiggly que

29349
19:23:12,080 --> 19:23:14,552
É um bom aviso de que temos um problema

29350
19:23:14,552 --> 19:23:17,440
mas se ignorarmos as linhas irritantes

29351
19:23:17,440 --> 19:23:19,920
e ajustar a construção com gcc que vamos

29352
19:23:19,920 --> 19:23:22,720
obter o mesmo erro do compilador e é

29353
19:23:22,720 --> 19:23:25,512
Vamos dizer isso para chamar nossa função

29354
19:23:25,512 --> 19:23:27,760
Precisamos satisfazer

29355
19:23:27,760 --> 19:23:31,192
O conceito integral para os argumentos

29356
19:23:31,192 --> 19:23:33,280
que passamos aqui e o duplo

29357
19:23:33,280 --> 19:23:35,512
Os argumentos que estamos passando aqui são

29358
19:23:35,512 --> 19:23:37,760
violando nosso conceito para que tenhamos um

29359
19:23:37,760 --> 19:23:40,080
Erro do compilador é realmente como você

29360
19:23:40,080 --> 19:23:43,192
pode usar conceitos em c plus mais eu tentei

29361
19:23:43,192 --> 19:23:45,680
e surgiu com exemplos simples para mostrar

29362
19:23:45,680 --> 19:23:47,832
sintaxes diferentes que você pode usar

29363
19:23:47,832 --> 19:23:49,360
Os conceitos com

29364
19:23:49,360 --> 19:23:52,000
E isso é realmente tentar obter

29365
19:23:52,000 --> 19:23:54,960
você mesmo familiarizado com essas sintaxes

29366
19:23:54,960 --> 19:23:57,192
E não vai ser muito difícil

29367
19:23:57,192 --> 19:23:59,120
usar conceitos em seu c plus plus

29368
19:23:59,120 --> 19:24:01,920
Programas ok isso é realmente tudo que eu tinha

29369
19:24:01,920 --> 19:24:04,552
para compartilhar em termos de sintaxes que você

29370
19:24:04,552 --> 19:24:07,760
pode usar com c mais mais 20 conceitos se

29371
19:24:07,760 --> 19:24:09,512
Você vai para a documentação que você está indo

29372
19:24:09,512 --> 19:24:12,000
ter mais informações sobre isso, mas

29373
19:24:12,000 --> 19:24:14,240
Vamos fazer mais algumas palestras para

29374
19:24:14,240 --> 19:24:16,720
realmente dirigir este dancehall por enquanto você

29375
19:24:16,720 --> 19:24:19,680
pode vir para cpp referência aqui e ver

29376
19:24:19,680 --> 19:24:22,552
mais conceitos que você pode usar que temos a

29377
19:24:22,552 --> 19:24:25,280
muito disso e podemos realmente usar isso

29378
19:24:25,280 --> 19:24:27,600
para ajustar nossos modelos de função no entanto

29379
19:24:27,600 --> 19:24:29,760
Queremos ok, por exemplo, você vê o nosso

29380
19:24:29,760 --> 19:24:31,760
Conceitos integrais que você vê flutuando

29381
19:24:31,760 --> 19:24:34,872
Conceitos pontuais e há ainda mais

29382
19:24:34,872 --> 19:24:37,040
que são utilizáveis com

29383
19:24:37,040 --> 19:24:39,280
aulas, mas não aprendemos sobre

29384
19:24:39,280 --> 19:24:41,440
classes ainda e vamos fazer isso a partir

29385
19:24:41,440 --> 19:24:43,832
no próximo capítulo, mas agora eu só quero

29386
19:24:43,832 --> 19:24:47,120
Você está familiarizado com conceitos que

29387
19:24:47,120 --> 19:24:49,680
foram introduzidos em c mais mais 20. e

29388
19:24:49,680 --> 19:24:51,600
Aqui está mais uma peça de documentação

29389
19:24:51,600 --> 19:24:53,832
Você pode olhar apenas para complementar o que

29390
19:24:53,832 --> 19:24:56,552
Estamos falando deste capítulo, mas

29391
19:24:56,552 --> 19:24:58,800
Eu não recomendo ler isso apenas

29392
19:24:58,800 --> 19:25:00,552
No entanto, porque ele só vai confundir

29393
19:25:00,552 --> 19:25:02,872
Você tem muitas coisas que ainda

29394
19:25:02,872 --> 19:25:04,640
Precisamos aprender para realmente ser capaz de

29395
19:25:04,640 --> 19:25:06,640
Entenda isso, então tente passar

29396
19:25:06,640 --> 19:25:08,800
Este capítulo e eu vou tentar e

29397
19:25:08,800 --> 19:25:11,192
quebrar isso de maneiras que você pode

29398
19:25:11,192 --> 19:25:13,512
Entenda que a principal mensagem é que

29399
19:25:13,512 --> 19:25:16,240
Há mais conceitos aqui que você pode tentar

29400
19:25:16,240 --> 19:25:18,872
em seu c plus mais código se faz

29401
19:25:18,872 --> 19:25:20,800
Sentir para o problema que você está tentando

29402
19:25:20,800 --> 19:25:23,040
resolver com c plus plus que vamos

29403
19:25:23,040 --> 19:25:24,960
parar aqui nesta palestra no próximo

29404
19:25:24,960 --> 19:25:26,800
Um que vamos mostrar como você pode

29405
19:25:26,800 --> 19:25:29,760
configurar seus próprios conceitos em c plus plus

29406
19:25:29,760 --> 19:25:32,000
Vá em frente e termine aqui e me encontre

29407
19:25:32,000 --> 19:25:33,832
lá nesta palestra vamos ver

29408
19:25:33,832 --> 19:25:36,720
Como você pode construir seus próprios conceitos e

29409
19:25:36,720 --> 19:25:38,640
Isso vai nos trazer para o

29410
19:25:38,640 --> 19:25:41,440
segunda parte dos conceitos que podemos usar em c

29411
19:25:41,440 --> 19:25:44,080
mais mais na última palestra que usamos

29412
19:25:44,080 --> 19:25:46,480
os conceitos da biblioteca padrão

29413
19:25:46,480 --> 19:25:48,480
que estão embutidos no c plus mais

29414
19:25:48,480 --> 19:25:51,120
Linguagem de programação começando em c plus

29415
19:25:51,120 --> 19:25:53,440
mais 20. Neste vamos ser

29416
19:25:53,440 --> 19:25:56,720
Construindo nossos próprios conceitos e sem

29417
19:25:56,720 --> 19:25:59,120
Esperar mais, vamos ver como você pode fazer

29418
19:25:59,120 --> 19:26:01,360
Isso e esta é a sintaxe que você pode usar

29419
19:26:01,360 --> 19:26:03,680
para fazer isso e é realmente simples o

29420
19:26:03,680 --> 19:26:05,832
Como você faz isso, você diz um modelo

29421
19:26:05,832 --> 19:26:08,320
declaração especificando o modelo

29422
19:26:08,320 --> 19:26:11,192
parâmetro que você quer restringir e, em seguida,

29423
19:26:11,192 --> 19:26:13,280
Você diz conceito que você diz a palavra-chave

29424
19:26:13,280 --> 19:26:16,320
Conceito você dá ao seu conceito um nome

29425
19:26:16,320 --> 19:26:19,280
colocar o sinal igual depois disso e, em seguida,

29426
19:26:19,280 --> 19:26:22,000
você vai especificar os requisitos

29427
19:26:22,000 --> 19:26:24,720
para o seu conceito, por exemplo, aqui nós

29428
19:26:24,720 --> 19:26:28,960
estão usando uma característica de tipo para especificar que

29429
19:26:28,960 --> 19:26:31,360
Este tipo de traço vai determinar

29430
19:26:31,360 --> 19:26:34,080
O que funciona para este conceito aqui e

29431
19:26:34,080 --> 19:26:36,872
O que isso vai fazer é fazer

29432
19:26:36,872 --> 19:26:39,680
para o nosso parâmetro de modelo ser apenas

29433
19:26:39,680 --> 19:26:41,832
integral se não for integral, somos

29434
19:26:41,832 --> 19:26:43,832
obter um erro de compilador e um

29435
19:26:43,832 --> 19:26:46,240
O que eu devo dizer é que a std

29436
19:26:46,240 --> 19:26:49,192
Conceito integral é exatamente construído como

29437
19:26:49,192 --> 19:26:51,512
isso na biblioteca padrão c plus

29438
19:26:51,512 --> 19:26:53,600
Isso é muito legal, então se você quiser

29439
19:26:53,600 --> 19:26:55,600
configurar seu próprio conceito e você quer

29440
19:26:55,600 --> 19:26:58,000
fazer isso usando traços digitados que você pode fazer

29441
19:26:58,000 --> 19:26:59,512
que assim e vai

29442
19:26:59,512 --> 19:27:03,040
aplicação para seus parâmetros de modelo para

29443
19:27:03,040 --> 19:27:06,480
satisfazer essa taxa de digitada ou ser exato

29444
19:27:06,480 --> 19:27:09,360
Este conceito vai ser satisfeito

29445
19:27:09,360 --> 19:27:12,400
quando o traço de tipo é avaliado como verdadeiro se

29446
19:27:12,400 --> 19:27:14,640
a taxa de digitada avalia false em

29447
19:27:14,640 --> 19:27:17,120
Tempo de compilação o conceito não vai

29448
19:27:17,120 --> 19:27:19,280
estar satisfeito que é outra maneira de olhar

29449
19:27:19,280 --> 19:27:21,760
Aqui em baixo temos outra sintaxe

29450
19:27:21,760 --> 19:27:24,320
nós podemos usar se nós temos múltiplos

29451
19:27:24,320 --> 19:27:26,800
declarações em nosso conceito tudo o que você tem

29452
19:27:26,800 --> 19:27:30,160
fazer é especificar a palavra-chave conceito que você

29453
19:27:30,160 --> 19:27:32,552
dar um nome que você vai para o sinal de igual

29454
19:27:32,552 --> 19:27:35,440
e então você adicionar um requer perto

29455
19:27:35,440 --> 19:27:37,512
Requer que o fechamento especifique o

29456
19:27:37,512 --> 19:27:39,512
parâmetros de modelo para os quais você deseja

29457
19:27:39,512 --> 19:27:42,240
para reforçar o seu conceito e então você é

29458
19:27:42,240 --> 19:27:45,440
indo para colocar um par de aparelhos encaracolados e

29459
19:27:45,440 --> 19:27:48,000
por dentro que você vai especificar o

29460
19:27:48,000 --> 19:27:51,192
sintaxe que você quer que seu conceito satisfaça

29461
19:27:51,192 --> 19:27:53,040
E, por exemplo, aqui queremos

29462
19:27:53,040 --> 19:27:55,680
para os dois parâmetros a serem

29463
19:27:55,680 --> 19:27:58,552
apoiando o operador de multiplicação

29464
19:27:58,552 --> 19:28:00,872
se este operador de multiplicação não for

29465
19:28:00,872 --> 19:28:03,040
suportado para os parâmetros do modelo

29466
19:28:03,040 --> 19:28:05,192
que nós passamos o conceito vai

29467
19:28:05,192 --> 19:28:09,120
falhar e novamente devo enfatizar que

29468
19:28:09,120 --> 19:28:11,600
Isso não verifica o valor de um

29469
19:28:11,600 --> 19:28:13,760
multiplicado por b só vai

29470
19:28:13,760 --> 19:28:16,160
aplicação da sintaxe a ser suportada

29471
19:28:16,160 --> 19:28:18,552
por exemplo, se você chamar uma função

29472
19:28:18,552 --> 19:28:21,680
modelo com este conceito e você tenta

29473
19:28:21,680 --> 19:28:24,080
para passar em inteiros, vai funcionar

29474
19:28:24,080 --> 19:28:26,400
porque você pode multiplicar inteiros, mas se

29475
19:28:26,400 --> 19:28:29,440
Você passa duas cordas, isso vai

29476
19:28:29,440 --> 19:28:31,360
falhar porque realmente não faz

29477
19:28:31,360 --> 19:28:33,760
sentido para multiplicar cordas ok isso é

29478
19:28:33,760 --> 19:28:36,080
A sintaxe agora só temos um

29479
19:28:36,080 --> 19:28:38,480
declaração para impor dentro, mas se você

29480
19:28:38,480 --> 19:28:41,120
Você pode até mesmo colocar mais declarações se

29481
19:28:41,120 --> 19:28:42,960
Você vai aqui, temos outro exemplo

29482
19:28:42,960 --> 19:28:45,680
chamado incrementável, isso vai

29483
19:28:45,680 --> 19:28:48,000
exigir que o parâmetro template seja

29484
19:28:48,000 --> 19:28:50,640
incrementável especificamos a chave do conceito

29485
19:28:50,640 --> 19:28:53,512
mundo nós dizemos o nome conceitual que colocamos

29486
19:28:53,512 --> 19:28:56,320
nosso sinal de igual e então dizemos que requer

29487
19:28:56,320 --> 19:28:58,640
colocamos o parâmetro modelo e colocamos em

29488
19:28:58,640 --> 19:29:01,192
nossos requisitos para qualquer modelo

29489
19:29:01,192 --> 19:29:04,720
parâmetro que está usando este conceito

29490
19:29:04,720 --> 19:29:07,120
A sintaxe aqui deve fazer sentido para que você deve

29491
19:29:07,120 --> 19:29:09,280
ser capaz de tomar o valor que você recebe

29492
19:29:09,280 --> 19:29:11,680
daqui e por exemplo, dizer eu mais

29493
19:29:11,680 --> 19:29:13,600
igual a um, isso será válido

29494
19:29:13,600 --> 19:29:16,320
sintaxe que você vai dizer mais mais mais um

29495
19:29:16,320 --> 19:29:18,240
e mais b tudo isso vai

29496
19:29:18,240 --> 19:29:21,440
ser válido c plus plus sintaxes para

29497
19:29:21,440 --> 19:29:23,600
parâmetro de modelo que você tenta chamar

29498
19:29:23,600 --> 19:29:26,000
Este modelo de função com e se este

29499
19:29:26,000 --> 19:29:27,832
Não funciona, você vai conseguir um

29500
19:29:27,832 --> 19:29:30,160
Erro do compilador porque seu modelo

29501
19:29:30,160 --> 19:29:32,720
O argumento não está realmente satisfazendo isso

29502
19:29:32,720 --> 19:29:34,960
Conceito, então é assim que você pode

29503
19:29:34,960 --> 19:29:37,832
configurar seus próprios conceitos em c plus plus

29504
19:29:37,832 --> 19:29:40,000
uma vez que você tem seus próprios conceitos configurados

29505
19:29:40,000 --> 19:29:42,320
você pode usá-los como estamos usando

29506
19:29:42,320 --> 19:29:44,720
o outro conceito do ziploc plus

29507
19:29:44,720 --> 19:29:47,280
biblioteca padrão, por exemplo, podemos usar

29508
19:29:47,280 --> 19:29:50,552
sintaxe uma para colocar uma necessidade de pistas e

29509
19:29:50,552 --> 19:29:53,760
Digamos que queremos satisfazer os nossos

29510
19:29:53,760 --> 19:29:56,552
conceito com esta sintaxe em particular você

29511
19:29:56,552 --> 19:29:59,192
terá que colocar nesses suportes de ângulo

29512
19:29:59,192 --> 19:30:01,680
e coloque seu parâmetro de modelo dentro

29513
19:30:01,680 --> 19:30:03,832
Esta é a sintaxe que você tem que usar

29514
19:30:03,832 --> 19:30:06,800
também pode usar a sintaxe 2 e especificar o meu

29515
19:30:06,800 --> 19:30:09,600
integral diretamente nestes suportes de ângulo

29516
19:30:09,600 --> 19:30:11,680
em sua declaração de modelo e isso é

29517
19:30:11,680 --> 19:30:14,000
Também vamos trabalhar, podemos até usar isso

29518
19:30:14,000 --> 19:30:16,400
com a sintaxe automática para nossa função

29519
19:30:16,400 --> 19:30:18,552
modelos que vai funcionar bem agora

29520
19:30:18,552 --> 19:30:20,480
que você enviou isso eu acho que é

29521
19:30:20,480 --> 19:30:22,552
tempo em que nos dirigimos para o estúdio visual

29522
19:30:22,552 --> 19:30:24,800
código e jogar com a gente um pouco mais bem

29523
19:30:24,800 --> 19:30:27,360
Aqui estamos em nossa pasta de trabalho o

29524
19:30:27,360 --> 19:30:29,512
O projeto atual está construindo o seu próprio

29525
19:30:29,512 --> 19:30:31,760
Conceitos que vamos pegar nosso

29526
19:30:31,760 --> 19:30:34,000
arquivos de modelo como sempre fazemos e

29527
19:30:34,000 --> 19:30:35,920
nós vamos colocá-los no lugar e

29528
19:30:35,920 --> 19:30:38,480
Vamos abrir essa coisa em visual

29529
19:30:38,480 --> 19:30:41,360
Código de estúdio vamos fazer isso que temos o nosso

29530
19:30:41,360 --> 19:30:44,240
projeto aberto aqui ou pasta, devo dizer

29531
19:30:44,240 --> 19:30:45,760
nós vamos limpar isso um pouco

29532
19:30:45,760 --> 19:30:47,832
mordeu e vamos incluir o nosso

29533
19:30:47,832 --> 19:30:50,720
Biblioteca de conceitos e queríamos configurar

29534
19:30:50,720 --> 19:30:52,960
nosso próprio conceito, a primeira sintaxe que somos

29535
19:30:52,960 --> 19:30:56,480
indo ver é usando tipos de negociações e

29536
19:30:56,480 --> 19:30:59,280
nós vamos dizer template tipo nome t

29537
19:30:59,280 --> 19:31:01,440
e nós vamos dizer esse conceito nós

29538
19:31:01,440 --> 19:31:04,400
Quer este parâmetro de template para satisfazer

29539
19:31:04,400 --> 19:31:06,080
nós vamos dizer conceito e nós somos

29540
19:31:06,080 --> 19:31:08,720
Vou dizer a minha integral que está indo

29541
19:31:08,720 --> 19:31:10,552
Para ser o nome do nosso conceito, somos

29542
19:31:10,552 --> 19:31:12,720
Vou colocar um sinal ecológico e então nós somos

29543
19:31:12,720 --> 19:31:14,000
Vou dizer

29544
19:31:14,000 --> 19:31:18,552
std integral v e especificar que queremos

29545
19:31:18,552 --> 19:31:21,680
este tipo de característica estar satisfeito para isso

29546
19:31:21,680 --> 19:31:23,920
Conceito aqui e depois disso precisamos

29547
19:31:23,920 --> 19:31:26,400
colocar em nosso ponto e vírgula e eu acho que precisamos

29548
19:31:26,400 --> 19:31:29,512
para incluir a biblioteca de traços de tipo

29549
19:31:29,512 --> 19:31:32,000
porque estamos usando que devemos dizer

29550
19:31:32,000 --> 19:31:35,440
std é integral, então sinto muito por isso e

29551
19:31:35,440 --> 19:31:37,440
isso vai funcionar agora, tudo bem agora que

29552
19:31:37,440 --> 19:31:40,480
temos o conceito configurado, podemos usá-lo

29553
19:31:40,480 --> 19:31:43,120
Como se estivesse usando outro conceito

29554
19:31:43,120 --> 19:31:45,192
Por exemplo, podemos configurar uma função

29555
19:31:45,192 --> 19:31:47,440
que vai somar dois números e

29556
19:31:47,440 --> 19:31:50,480
vai usar esse conceito aqui

29557
19:31:50,480 --> 19:31:52,872
temos várias sintaxes que podemos usar assim

29558
19:31:52,872 --> 19:31:54,640
vamos descer e experimentar isso nós estamos

29559
19:31:54,640 --> 19:31:56,960
vamos dizer modelo e dizer nome do tipo

29560
19:31:56,960 --> 19:31:59,360
t e nós vamos exigir isso

29561
19:31:59,360 --> 19:32:02,080
conceito para ser satisfeito para a nossa função

29562
19:32:02,080 --> 19:32:04,480
modelo que vimos que poderíamos usar o

29563
19:32:04,480 --> 19:32:07,832
Requer perto aqui e dizer a minha integral

29564
19:32:07,832 --> 19:32:10,160
e dizer o parâmetro template que queremos

29565
19:32:10,160 --> 19:32:12,552
para fazer cumprir isso e depois disso estamos

29566
19:32:12,552 --> 19:32:14,320
indo apenas colocar em nossa função

29567
19:32:14,320 --> 19:32:16,160
modelo, vamos dizer, adicione o que nós

29568
19:32:16,160 --> 19:32:18,080
têm feito o tempo todo no último

29569
19:32:18,080 --> 19:32:20,640
palestra vamos dizer t a

29570
19:32:20,640 --> 19:32:23,760
e t b e nós vamos devolver um plus

29571
19:32:23,760 --> 19:32:26,480
b agora esta função vai apoiar

29572
19:32:26,480 --> 19:32:28,872
Nosso conceito vamos descer e configurar dois

29573
19:32:28,872 --> 19:32:31,440
variáveis vamos dizer e x

29574
19:32:31,440 --> 19:32:33,920
e vamos dizer 6, por exemplo, e

29575
19:32:33,920 --> 19:32:36,480
em y e eu vou fazer isso um 7

29576
19:32:36,480 --> 19:32:39,120
Por que não e nós vamos dizer adicionar

29577
19:32:39,120 --> 19:32:41,440
x e y uma vez que fazemos isso você vê que nós

29578
19:32:41,440 --> 19:32:43,832
Não tem problema porque o conceito é

29579
19:32:43,832 --> 19:32:46,320
satisfeito com os argumentos de que somos

29580
19:32:46,320 --> 19:32:49,832
passando aqui o conceito é satisfeito

29581
19:32:49,832 --> 19:32:52,480
porque o tipo traço aqui vai

29582
19:32:52,480 --> 19:32:54,960
retorno verdadeiro para este tipo aqui porque

29583
19:32:54,960 --> 19:32:57,120
é um tipo integral quando o tipo

29584
19:32:57,120 --> 19:32:59,280
Tração retorna verdade, então o conceito é

29585
19:32:59,280 --> 19:33:01,760
vai ficar satisfeito se o tipo traço

29586
19:33:01,760 --> 19:33:04,160
Retorna false o conceito vai

29587
19:33:04,160 --> 19:33:06,960
falhar vamos tentar e aparafusar e realmente dirigir

29588
19:33:06,960 --> 19:33:08,960
Esta casa você vê que o mundo é bom

29589
19:33:08,960 --> 19:33:11,440
nossa função está funcionando assim que a função

29590
19:33:11,440 --> 19:33:13,440
modelo e significa este código aqui

29591
19:33:13,440 --> 19:33:15,600
vai ser gerado com sucesso

29592
19:33:15,600 --> 19:33:17,832
e nós vamos chamá-lo quando o

29593
19:33:17,832 --> 19:33:19,192
O programa é executado

29594
19:33:19,192 --> 19:33:21,832
Agora vamos mudar o tipo desses caras

29595
19:33:21,832 --> 19:33:24,720
dobrar e tentar violar o nosso conceito

29596
19:33:24,720 --> 19:33:26,960
e fazê-lo falhar uma vez que fazemos isso você vê

29597
19:33:26,960 --> 19:33:29,440
a chamada aqui tem uma linha...

29598
19:33:29,440 --> 19:33:31,360
O código do estúdio visual não vai dizer

29599
19:33:31,360 --> 19:33:34,000
que é um problema de conceito que é um

29600
19:33:34,000 --> 19:33:36,960
vergonha, mas ainda podemos passar por isso

29601
19:33:36,960 --> 19:33:39,192
o compilador e o compilador estão indo

29602
19:33:39,192 --> 19:33:41,280
para nos dizer o que está errado, então está indo

29603
19:33:41,280 --> 19:33:44,640
para dizer o uso da função adicionar

29604
19:33:44,640 --> 19:33:47,440
Restrições insatisfeitas e se formos

29605
19:33:47,440 --> 19:33:49,360
Vamos ver o exato

29606
19:33:49,360 --> 19:33:52,320
Restrições que violamos e vamos

29607
19:33:52,320 --> 19:33:55,040
dizer necessário para a satisfação de

29608
19:33:55,040 --> 19:33:57,832
minha integral com t estamos chamando isso

29609
19:33:57,832 --> 19:33:59,920
com duplo e duplo vai para

29610
19:33:59,920 --> 19:34:03,280
Avalie isso para falso espero que você possa

29611
19:34:03,280 --> 19:34:05,040
Veja que você pode realmente configurar o seu próprio

29612
19:34:05,040 --> 19:34:08,000
conceitos usando a sintaxe aqui e nós

29613
19:34:08,000 --> 19:34:09,680
pode usar nosso conceito com todo o

29614
19:34:09,680 --> 19:34:11,440
sintaxes que vimos no último

29615
19:34:11,440 --> 19:34:13,600
palestra, por exemplo, podemos tirar

29616
19:34:13,600 --> 19:34:16,480
o que requer todos juntos aqui e

29617
19:34:16,480 --> 19:34:18,800
Diga minha integral no

29618
19:34:18,800 --> 19:34:20,800
declaração de modelo aqui, então vamos

29619
19:34:20,800 --> 19:34:23,192
para dizer minha integral e se fizermos isso

29620
19:34:23,192 --> 19:34:25,832
vamos falhar novamente porque o

29621
19:34:25,832 --> 19:34:28,240
O conceito não será satisfeito

29622
19:34:28,240 --> 19:34:30,400
nós vamos ter o mesmo problema que nós

29623
19:34:30,400 --> 19:34:33,280
pode alterar a sintaxe para usar o carro

29624
19:34:33,280 --> 19:34:35,832
sintaxe, mas antes de fazermos isso, vamos

29625
19:34:35,832 --> 19:34:39,280
mudar isso de volta para o nome do tipo t e, em seguida,

29626
19:34:39,280 --> 19:34:42,160
colocar nossas necessidades perto após o

29627
19:34:42,160 --> 19:34:44,640
lista de parâmetros do nosso modelo de função

29628
19:34:44,640 --> 19:34:46,552
nós vamos dizer que requer

29629
19:34:46,552 --> 19:34:48,960
e nós vamos dizer a minha integral e

29630
19:34:48,960 --> 19:34:51,760
especificar o parâmetro template e este

29631
19:34:51,760 --> 19:34:54,000
é um modelo de função válido com um

29632
19:34:54,000 --> 19:34:56,400
conceito aplicado ao app e se nós dois

29633
19:34:56,400 --> 19:34:57,600
Mais uma vez vamos ter o mesmo

29634
19:34:57,600 --> 19:35:00,552
erro do compilador para que você veja o mesmo erro

29635
19:35:00,552 --> 19:35:03,440
e podemos usar a sintaxe automática, vamos fazer

29636
19:35:03,440 --> 19:35:05,600
que nós vamos tirar o

29637
19:35:05,600 --> 19:35:08,000
declaração de modelo aqui vamos

29638
19:35:08,000 --> 19:35:10,552
tirar as necessidades necessárias aqui e

29639
19:35:10,552 --> 19:35:14,552
nós vamos mudar nosso t para automóvel e

29640
19:35:14,552 --> 19:35:16,000
A maneira como fazemos isso, vamos dizer

29641
19:35:16,000 --> 19:35:19,280
std no std nós estamos usando o nosso próprio

29642
19:35:19,280 --> 19:35:21,280
Conceito, então vamos dizer o meu

29643
19:35:21,280 --> 19:35:24,160
automóvel integral isso vai funcionar e

29644
19:35:24,160 --> 19:35:26,800
nós vamos dizer o meu automóvel integral e

29645
19:35:26,800 --> 19:35:29,280
meu automóvel integral aqui no momento em que fazemos

29646
19:35:29,280 --> 19:35:31,832
Isso você vê que temos linhas piggly

29647
19:35:31,832 --> 19:35:34,872
Porque o nosso conceito é violado, mas

29648
19:35:34,872 --> 19:35:36,480
Se estamos tentando construir novamente, estamos

29649
19:35:36,480 --> 19:35:38,800
usar o gcc para fazer que a construção é

29650
19:35:38,800 --> 19:35:40,960
Vou falhar, você vê o mesmo

29651
19:35:40,960 --> 19:35:43,760
O conceito é violado e nós somos capazes de

29652
19:35:43,760 --> 19:35:46,872
Use nosso conceito ao longo dos quatro

29653
19:35:46,872 --> 19:35:49,120
sintasxas que vimos na última palestra

29654
19:35:49,120 --> 19:35:50,800
E isso é muito legal agora que temos

29655
19:35:50,800 --> 19:35:53,192
Isso vamos comentar isso e

29656
19:35:53,192 --> 19:35:55,192
nós vamos ver que podemos configurar

29657
19:35:55,192 --> 19:35:58,800
conceitos que têm requisitos de abrangências

29658
19:35:58,800 --> 19:36:01,440
várias declarações ou várias linhas

29659
19:36:01,440 --> 19:36:03,512
Ok, vamos descer e fazer isso supor

29660
19:36:03,512 --> 19:36:05,920
Queremos estabelecer um conceito que

29661
19:36:05,920 --> 19:36:07,832
indo para a aplicação para os modelos

29662
19:36:07,832 --> 19:36:10,640
parâmetros a serem multipliáveis

29663
19:36:10,640 --> 19:36:13,280
com o operador de multiplicação que temos

29664
19:36:13,280 --> 19:36:15,680
Aqui podemos usar essa sintaxe aqui que estamos

29665
19:36:15,680 --> 19:36:17,440
Vou colocar em nossa declaração de modelo

29666
19:36:17,440 --> 19:36:19,280
nós vamos dizer conceito que estamos indo

29667
19:36:19,280 --> 19:36:20,960
para dizer o nome conceitual que vamos

29668
19:36:20,960 --> 19:36:22,872
colocar em um sinal igual e então nós somos

29669
19:36:22,872 --> 19:36:25,680
indo para colocar em um requerer perto

29670
19:36:25,680 --> 19:36:28,400
com nossos parâmetros de modelo e

29671
19:36:28,400 --> 19:36:30,400
Depois disso, vamos colocar um par de

29672
19:36:30,400 --> 19:36:33,120
curly chaves e dentro dos curlies

29673
19:36:33,120 --> 19:36:35,680
Vamos colocar os requisitos para

29674
19:36:35,680 --> 19:36:38,552
Neste caso, precisamos do

29675
19:36:38,552 --> 19:36:41,192
parâmetro de modelo aqui para apoiar o

29676
19:36:41,192 --> 19:36:43,600
operador de multiplicação entre dois

29677
19:36:43,600 --> 19:36:45,832
estes tipos se a multiplicação

29678
19:36:45,832 --> 19:36:48,000
O operador não é suportado que vamos

29679
19:36:48,000 --> 19:36:49,760
ter um problema e que este é o

29680
19:36:49,760 --> 19:36:52,240
conceito que vai fazer valer isso

29681
19:36:52,240 --> 19:36:54,080
Uma coisa que você deve saber é que isso

29682
19:36:54,080 --> 19:36:56,080
É só ir verificar

29683
19:36:56,080 --> 19:37:00,080
que multiplicando a e b é sintaxe válida

29684
19:37:00,080 --> 19:37:02,640
Não vai verificar o valor de um

29685
19:37:02,640 --> 19:37:04,640
multiplicado por b e você deve realmente

29686
19:37:04,640 --> 19:37:07,120
Entenda isto agora que temos este n

29687
19:37:07,120 --> 19:37:09,040
podemos configurar uma função para usar estes

29688
19:37:09,040 --> 19:37:12,160
Dois caras por que não usar a função que nós

29689
19:37:12,160 --> 19:37:14,320
Já vimos antes para adicionar dois números

29690
19:37:14,320 --> 19:37:16,320
Vamos fazer isso e nós vamos colocar

29691
19:37:16,320 --> 19:37:18,400
nossas necessidades são próximas e nós vamos

29692
19:37:18,400 --> 19:37:22,640
Exigir agora para apoiar o multipliable

29693
19:37:22,640 --> 19:37:24,720
conceito e vamos especificar o nosso

29694
19:37:24,720 --> 19:37:27,760
parâmetro template nós temos o conceito n

29695
19:37:27,760 --> 19:37:30,080
para que possamos usar isso para fazer o que quer que seja

29696
19:37:30,080 --> 19:37:32,240
Quero agora vamos dizer t

29697
19:37:32,240 --> 19:37:35,512
adicionar e vamos dizer t a e t b

29698
19:37:35,512 --> 19:37:38,240
e nós vamos devolver um mais b isso

29699
19:37:38,240 --> 19:37:40,240
É a mesma função que temos usado

29700
19:37:40,240 --> 19:37:42,872
O tempo todo OK agora temos o nosso conceito

29701
19:37:42,872 --> 19:37:45,120
no lugar e nós temos um modelo de função

29702
19:37:45,120 --> 19:37:47,440
que vai usar esse conceito

29703
19:37:47,440 --> 19:37:51,440
Vamos ver se podemos adicionar x e y e

29704
19:37:51,440 --> 19:37:53,192
Veja o que temos, vamos para o mundo

29705
19:37:53,192 --> 19:37:55,120
com gcc vamos ver que

29706
19:37:55,120 --> 19:37:57,192
O mundo vai ser bom porque

29707
19:37:57,192 --> 19:38:01,040
O conceito aqui está satisfeito que estamos passando

29708
19:38:01,040 --> 19:38:03,920
tipos duplos para nosso modelo de função

29709
19:38:03,920 --> 19:38:06,400
e é legal multiplicar dois duplos

29710
19:38:06,400 --> 19:38:08,400
variáveis se multiplicarmos duas duplas

29711
19:38:08,400 --> 19:38:10,240
nós vamos ter um valor e isso é

29712
19:38:10,240 --> 19:38:12,800
vai ser válido c plus mais sintaxe, mas

29713
19:38:12,800 --> 19:38:15,040
Vamos ver o que acontece se tentarmos

29714
19:38:15,040 --> 19:38:17,600
mudar nossos argumentos para força hdd

29715
19:38:17,600 --> 19:38:20,000
Vamos fazer isso para que vamos dizer x é

29716
19:38:20,000 --> 19:38:22,640
Olá e nós vamos dizer o porquê

29717
19:38:22,640 --> 19:38:25,440
mundo por que não vamos descer e colocar em um

29718
19:38:25,440 --> 19:38:27,832
Segônio e o momento em que fazemos isso você

29719
19:38:27,832 --> 19:38:30,800
Veja que temos um problema e visual

29720
19:38:30,800 --> 19:38:34,240
O código do estúdio ainda não é bom nisso

29721
19:38:34,240 --> 19:38:36,400
Mas se formos para dentro

29722
19:38:36,400 --> 19:38:38,800
e correr isso através de gcc nós vamos

29723
19:38:38,800 --> 19:38:42,160
que nosso conceito é violado, vamos

29724
19:38:42,160 --> 19:38:44,240
Veja o erro do compilador aqui é

29725
19:38:44,240 --> 19:38:47,280
Vamos dizer restrições não satisfeitas

29726
19:38:47,280 --> 19:38:49,512
E vai nos dizer que nós somos

29727
19:38:49,512 --> 19:38:52,320
chamando a função add com os valores

29728
19:38:52,320 --> 19:38:54,800
que não pode ser multiplicado, ele vai

29729
19:38:54,800 --> 19:38:56,872
Digamos que a expressão necessária aqui é

29730
19:38:56,872 --> 19:38:59,512
Inválido e é assim que você pode configurar um

29731
19:38:59,512 --> 19:39:01,680
conceito como este e você pode realmente usar

29732
19:39:01,680 --> 19:39:02,800
Isso para

29733
19:39:02,800 --> 19:39:05,440
Coloque restrições como você quer em seu

29734
19:39:05,440 --> 19:39:08,240
modelos de função, mas aqui temos apenas

29735
19:39:08,240 --> 19:39:11,040
usou uma declaração dentro do nosso conceito

29736
19:39:11,040 --> 19:39:13,920
Aqui nós podemos até colocar mais para dirigir

29737
19:39:13,920 --> 19:39:15,512
Esta casa nós vamos montar outro

29738
19:39:15,512 --> 19:39:17,832
Conceito vamos descer e colocar isso dentro

29739
19:39:17,832 --> 19:39:20,000
lugar onde o conceito vai ser chamado

29740
19:39:20,000 --> 19:39:22,320
incremental, vai usar o

29741
19:39:22,320 --> 19:39:24,640
A mesma sintaxe que vimos aqui, mas estamos indo

29742
19:39:24,640 --> 19:39:26,640
estar colocando uma exigência sobre o

29743
19:39:26,640 --> 19:39:29,192
parâmetro de modelo aqui para suporte

29744
19:39:29,192 --> 19:39:32,080
incrementação e queremos para cada

29745
19:39:32,080 --> 19:39:34,800
tipo que vai no lugar de t aqui

29746
19:39:34,800 --> 19:39:37,512
Deve ser capaz de dizer um plus igual a um

29747
19:39:37,512 --> 19:39:40,400
isso deve ser válido c plus mais sintaxe

29748
19:39:40,400 --> 19:39:42,552
deve ser capaz de dizer mais mais mais um este

29749
19:39:42,552 --> 19:39:45,120
deve ser válido c plus mais sintaxe e nós

29750
19:39:45,120 --> 19:39:47,600
Deve ser capaz de dizer um plus plus this

29751
19:39:47,600 --> 19:39:50,720
deve ser válido c plus sintaxe

29752
19:39:50,720 --> 19:39:53,040
Agora que temos isso, podemos mudar o nosso

29753
19:39:53,040 --> 19:39:56,000
adicionar função para usar este conceito por que não

29754
19:39:56,000 --> 19:39:58,720
nós vamos dizer incrementável e agora

29755
19:39:58,720 --> 19:40:01,600
Esta função será necessária para

29756
19:40:01,600 --> 19:40:04,400
usar coisas que podemos incrementar e

29757
19:40:04,400 --> 19:40:06,800
Você vê que já está falhando porque nós

29758
19:40:06,800 --> 19:40:08,720
Não pode realmente incrementar as forças do que

29759
19:40:08,720 --> 19:40:10,872
Isso significa que vamos construir e

29760
19:40:10,872 --> 19:40:13,040
mostrar o erro do compilador ok que você vê

29761
19:40:13,040 --> 19:40:16,000
incremental não é satisfeito e que

29762
19:40:16,000 --> 19:40:18,640
As expressões requeridas não são válidas

29763
19:40:18,640 --> 19:40:21,832
você ver plus plus a não é válido um plus

29764
19:40:21,832 --> 19:40:25,280
plus não é válido e um mais é igual a um

29765
19:40:25,280 --> 19:40:28,080
Também não deve ser válido, mas não somos

29766
19:40:28,080 --> 19:40:30,240
vendo isso aqui, mas espero que você veja

29767
19:40:30,240 --> 19:40:33,680
A mensagem aqui que nosso conceito é

29768
19:40:33,680 --> 19:40:36,400
falhando aqui se comentamos o nosso

29769
19:40:36,400 --> 19:40:39,120
Os pontos fortes aqui e descomente dobram tudo

29770
19:40:39,120 --> 19:40:40,872
Estas operações que temos aqui são

29771
19:40:40,872 --> 19:40:43,440
suportado para o tipo duplo

29772
19:40:43,440 --> 19:40:46,552
por isso não devemos falhar aqui se tentarmos

29773
19:40:46,552 --> 19:40:49,120
compilar isso porque o conceito é

29774
19:40:49,120 --> 19:40:50,872
Vou ficar satisfeito

29775
19:40:50,872 --> 19:40:53,440
Vamos usar o gcc

29776
19:40:53,440 --> 19:40:55,440
compilador para construir você ver a compilação é

29777
19:40:55,440 --> 19:40:56,480
Bom agora

29778
19:40:56,480 --> 19:40:58,720
e nós podemos limpar e nós podemos trazer uma

29779
19:40:58,720 --> 19:41:01,760
terminal para realmente ver isso que

29780
19:41:01,760 --> 19:41:04,800
binário foi gerado vamos fazer o ir

29781
19:41:04,800 --> 19:41:06,480
Vamos ver o nosso galo

29782
19:41:06,480 --> 19:41:08,960
executável aqui e se descermos, vamos

29783
19:41:08,960 --> 19:41:10,872
Digamos que vamos ver que se nós

29784
19:41:10,872 --> 19:41:13,280
construir novamente para trazer isso em

29785
19:41:13,280 --> 19:41:15,832
considerar clear run galo the

29786
19:41:15,832 --> 19:41:18,000
O programa foi gerado e é realmente

29787
19:41:18,000 --> 19:41:21,600
correndo porque o conceito aqui

29788
19:41:21,600 --> 19:41:23,280
Está satisfeito

29789
19:41:23,280 --> 19:41:27,600
com nossa chamada usando argumentos duplos

29790
19:41:27,600 --> 19:41:30,240
Aqui está tudo bem, então isso é realmente tudo que eu ponha

29791
19:41:30,240 --> 19:41:32,160
para compartilhar com vocês nisso

29792
19:41:32,160 --> 19:41:34,640
palestra espero que você conheça as sintaxes que você

29793
19:41:34,640 --> 19:41:37,120
pode usar para criar seus próprios conceitos

29794
19:41:37,120 --> 19:41:39,280
pode usar características de tipo como nós temos

29795
19:41:39,280 --> 19:41:41,760
visto aqui e a sintaxe é colocar o

29796
19:41:41,760 --> 19:41:45,600
conceito de palavra-chave colocado no seu nome de conceito

29797
19:41:45,600 --> 19:41:47,920
Coloque um ecosign e, em seguida, especifique o seu

29798
19:41:47,920 --> 19:41:50,160
traço de tipo aqui que vai funcionar se

29799
19:41:50,160 --> 19:41:51,680
Você precisa de algo um pouco mais

29800
19:41:51,680 --> 19:41:53,760
complicado, então você vai usar

29801
19:41:53,760 --> 19:41:55,920
Esta sintaxe aqui e coloque o

29802
19:41:55,920 --> 19:41:59,120
requisitos para o seu conceito nestes

29803
19:41:59,120 --> 19:42:01,920
chaves encaracoladas você pode colocar um

29804
19:42:01,920 --> 19:42:04,400
declaração como fizemos aqui ou você pode

29805
19:42:04,400 --> 19:42:07,280
Coloque quantas declarações você quiser

29806
19:42:07,280 --> 19:42:08,800
Lembre-se de acabar com eles

29807
19:42:08,800 --> 19:42:10,800
vírgulas e outra coisa que você

29808
19:42:10,800 --> 19:42:13,512
Não deve realmente tomar de ânimo leve é que

29809
19:42:13,512 --> 19:42:16,320
Isso só vai verificar se há sintaxe

29810
19:42:16,320 --> 19:42:18,080
Não vai verificar o valor

29811
19:42:18,080 --> 19:42:21,280
Você vai depois de adicionar um a um aqui para

29812
19:42:21,280 --> 19:42:23,120
Por exemplo, não vai verificar a

29813
19:42:23,120 --> 19:42:25,360
valor que você obtém depois de multiplicar b é

29814
19:42:25,360 --> 19:42:28,552
só vai ver que uma multiplicação b

29815
19:42:28,552 --> 19:42:32,640
é uma sintaxe válida para os tipos que

29816
19:42:32,640 --> 19:42:35,440
parâmetro de modelo está usando aqui estamos

29817
19:42:35,440 --> 19:42:37,832
Vou parar aqui nesta palestra:

29818
19:42:37,832 --> 19:42:40,160
Um, vamos ampliar um pouco mais

29819
19:42:40,160 --> 19:42:43,040
no necessário fechar aqui vá em frente e

29820
19:42:43,040 --> 19:42:44,320
Acabar aqui

29821
19:42:44,320 --> 19:42:46,480
e encontrar-me lá nesta palestra nós somos

29822
19:42:46,480 --> 19:42:49,120
Vou aprender sobre mais algumas coisas que nós

29823
19:42:49,120 --> 19:42:52,080
fazer com nossas necessidades próximas, mas

29824
19:42:52,080 --> 19:42:54,800
Antes de fazermos isso, vamos olhar para o

29825
19:42:54,800 --> 19:42:57,760
tipos de requisitos que nós podemos colocar em nosso

29826
19:42:57,760 --> 19:43:00,640
Requer fechar o primeiro é simples

29827
19:43:00,640 --> 19:43:02,800
Exigência que é o que temos visto

29828
19:43:02,800 --> 19:43:04,960
Até agora também podemos fazer um aninhado

29829
19:43:04,960 --> 19:43:06,480
Exigência e nós vamos aprender

29830
19:43:06,480 --> 19:43:08,720
sobre isso em um minuto e nós podemos fazer um

29831
19:43:08,720 --> 19:43:10,960
exigência de composto que está indo para

29832
19:43:10,960 --> 19:43:13,512
permitir-nos especificar mais coisas sobre

29833
19:43:13,512 --> 19:43:16,480
o que precisamos para o nosso conceito lá

29834
19:43:16,480 --> 19:43:19,192
também são requisitos de tipo, mas estes são

29835
19:43:19,192 --> 19:43:21,120
Realmente avançado para o escopo disso

29836
19:43:21,120 --> 19:43:22,640
curso para que não vamos falar sobre

29837
19:43:22,640 --> 19:43:24,480
Neste curso, o que vamos

29838
19:43:24,480 --> 19:43:27,760
Olhe para estes três primeiros aqui, então

29839
19:43:27,760 --> 19:43:30,240
Vejamos uma exigência simples:

29840
19:43:30,240 --> 19:43:32,080
É o que já vimos aqui

29841
19:43:32,080 --> 19:43:35,192
ter nossa declaração de modelo que temos a

29842
19:43:35,192 --> 19:43:38,080
conceito declarado que o nome do conceito é

29843
19:43:38,080 --> 19:43:40,320
Tipo minúsculo que vamos colocar em nosso

29844
19:43:40,320 --> 19:43:42,640
Requer perto que vamos colocar em nosso

29845
19:43:42,640 --> 19:43:45,192
lista de parâmetros e vamos colocar em

29846
19:43:45,192 --> 19:43:48,000
nossos aparelhos encaracolados dentro das necessidades

29847
19:43:48,000 --> 19:43:50,800
perto temos uma declaração aqui que é

29848
19:43:50,800 --> 19:43:54,240
impor esse tamanho de t é menor

29849
19:43:54,240 --> 19:43:55,832
do que 4.

29850
19:43:55,832 --> 19:43:58,080
E o que isso realmente significa que vai

29851
19:43:58,080 --> 19:44:01,280
verificar se o tamanho da sintaxe aqui é

29852
19:44:01,280 --> 19:44:04,000
Correto e isso pode realmente jogar as pessoas

29853
19:44:04,000 --> 19:44:06,480
Eu já disse isso na última palestra

29854
19:44:06,480 --> 19:44:09,120
Mas eu tomei este pequeno exemplo para

29855
19:44:09,120 --> 19:44:11,600
realmente dirigir isso para casa e mostrar que

29856
19:44:11,600 --> 19:44:14,480
Se você não tem cuidado, seus conceitos são

29857
19:44:14,480 --> 19:44:16,800
Vou estar realmente errado isso está acontecendo

29858
19:44:16,800 --> 19:44:19,280
para verificar a sintaxe assim por exemplo

29859
19:44:19,280 --> 19:44:22,240
se chamarmos um modelo de função com isso

29860
19:44:22,240 --> 19:44:25,192
conceito com um tipo de carro

29861
19:44:25,192 --> 19:44:27,192
O conceito vai ficar satisfeito

29862
19:44:27,192 --> 19:44:30,080
mesmo que o tamanho do carro seja menor que

29863
19:44:30,080 --> 19:44:32,552
4 Obviamente, mas isso não vai ser

29864
19:44:32,552 --> 19:44:34,800
O trabalho deste conceito aqui este

29865
19:44:34,800 --> 19:44:37,680
O conceito não vai ser aplicado para o

29866
19:44:37,680 --> 19:44:40,160
expressão aqui para avaliar a verdade é

29867
19:44:40,160 --> 19:44:42,480
só vai verificar a sintaxe e se

29868
19:44:42,480 --> 19:44:45,920
Você passa algo menor que uma rede em

29869
19:44:45,920 --> 19:44:48,640
um modelo de função com este conceito

29870
19:44:48,640 --> 19:44:50,872
isso vai ser válido c plus plus

29871
19:44:50,872 --> 19:44:53,192
sintaxe para que o conceito funcione

29872
19:44:53,192 --> 19:44:55,920
Agora você deve estar se perguntando como posso

29873
19:44:55,920 --> 19:44:58,720
Aplicá-lo ao valor desta expressão

29874
19:44:58,720 --> 19:45:00,160
para ser verdade

29875
19:45:00,160 --> 19:45:03,680
Usando o conceito bem para que você vai

29876
19:45:03,680 --> 19:45:06,720
tem que usar requisitos aninhados e

29877
19:45:06,720 --> 19:45:08,800
A exigência aninhada vai ter

29878
19:45:08,800 --> 19:45:11,832
outra requer palavra-chave inserida em

29879
19:45:11,832 --> 19:45:14,552
diante dele agora, se você usar a sintaxe

29880
19:45:14,552 --> 19:45:16,720
Assim agora, isso vai verificar

29881
19:45:16,720 --> 19:45:19,600
esse tamanho de t é realmente inferior a 4.

29882
19:45:19,600 --> 19:45:22,080
se não for menos de 4 isso vai

29883
19:45:22,080 --> 19:45:24,480
devolver o falso aqui e o conceito é

29884
19:45:24,480 --> 19:45:26,320
indo para falhar e é assim que você pode

29885
19:45:26,320 --> 19:45:29,360
usar requisitos aninhados para fazer cumprir

29886
19:45:29,360 --> 19:45:31,920
Algumas expressões para ser verdade em seu

29887
19:45:31,920 --> 19:45:33,832
requer um novo tipo de

29888
19:45:33,832 --> 19:45:35,680
Exigência que você pode configurar para o seu

29889
19:45:35,680 --> 19:45:38,872
O conceito é a exigência composta e

29890
19:45:38,872 --> 19:45:41,760
Isso permitirá que você verifique se

29891
19:45:41,760 --> 19:45:43,760
Algo não joga uma exceção você

29892
19:45:43,760 --> 19:45:46,552
pode fazer isso usando a palavra-chave sem aceitar

29893
19:45:46,552 --> 19:45:48,160
Mas não vamos usar isso agora

29894
19:45:48,160 --> 19:45:50,960
porque isso não está no escopo do que nós

29895
19:45:50,960 --> 19:45:53,360
pode fazer neste ponto do curso, mas

29896
19:45:53,360 --> 19:45:56,000
Você também pode verificar o tipo de devolução de um

29897
19:45:56,000 --> 19:45:59,600
expressão e divórcio que satisfaz

29898
19:45:59,600 --> 19:46:02,480
algum traço de tipo, por exemplo, aqui nós

29899
19:46:02,480 --> 19:46:05,760
estamos dizendo para o nosso conceito e se nós

29900
19:46:05,760 --> 19:46:08,640
passar em dois parâmetros a sintaxe para

29901
19:46:08,640 --> 19:46:11,680
adicionar a e b deve estar correto e

29902
19:46:11,680 --> 19:46:14,640
apoiado para esses tipos, mas o resultado

29903
19:46:14,640 --> 19:46:18,080
de a e b também deve ser conversível em

29904
19:46:18,080 --> 19:46:20,160
form e você pode fazer algo assim

29905
19:46:20,160 --> 19:46:21,680
E isso vai funcionar que você pode

29906
19:46:21,680 --> 19:46:23,920
aplicar esses tipos de coisas usando

29907
19:46:23,920 --> 19:46:26,480
requisitos compostos estão bem agora que você

29908
19:46:26,480 --> 19:46:28,720
Conheça esses tipos de requisitos

29909
19:46:28,720 --> 19:46:31,680
você pode colocar em suas necessidades perto, vamos

29910
19:46:31,680 --> 19:46:34,080
cabeça para código de estúdio visual e jogar

29911
19:46:34,080 --> 19:46:36,000
conosco um pouco mais bem aqui estamos

29912
19:46:36,000 --> 19:46:38,480
em nossa pasta de trabalho a atual

29913
19:46:38,480 --> 19:46:41,440
O projeto está ampliando necessidades de fechamento

29914
19:46:41,440 --> 19:46:43,920
nós vamos pegar nossos arquivos de modelo

29915
19:46:43,920 --> 19:46:46,080
e nós vamos colocá-los no lugar e

29916
19:46:46,080 --> 19:46:47,920
Vamos abrir isso em visual

29917
19:46:47,920 --> 19:46:50,240
código de estúdio muito rápido, arrastando e

29918
19:46:50,240 --> 19:46:52,400
deixando aqui isso vai se abrir

29919
19:46:52,400 --> 19:46:54,240
nossa pasta vamos fazer o habitual

29920
19:46:54,240 --> 19:46:56,240
nós vamos fechar o painel aqui nós estamos

29921
19:46:56,240 --> 19:46:59,120
Vou limpar as coisas um pouco

29922
19:46:59,120 --> 19:47:01,512
e vamos incluir nossos conceitos

29923
19:47:01,512 --> 19:47:03,920
Biblioteca, vamos fazer isso, vamos

29924
19:47:03,920 --> 19:47:05,680
configurar um conceito simples que vamos

29925
19:47:05,680 --> 19:47:07,512
Diga modelo e vamos dizer o que

29926
19:47:07,512 --> 19:47:10,080
O conceito é que o conceito vai

29927
19:47:10,080 --> 19:47:12,480
ser chamado o tipo minúsculo e nós vamos

29928
19:47:12,480 --> 19:47:13,600
para dizer

29929
19:47:13,600 --> 19:47:16,800
O que faz deste conceito um pequeno tempo

29930
19:47:16,800 --> 19:47:19,360
Nós vamos colocar em nossas necessidades perto

29931
19:47:19,360 --> 19:47:21,192
e vamos colocar no template

29932
19:47:21,192 --> 19:47:23,680
parâmetro chame-o por que não e nós somos

29933
19:47:23,680 --> 19:47:25,920
indo colocar em nosso ponto e vírgula de fechamento

29934
19:47:25,920 --> 19:47:28,480
Aqui agora o que vai fazer isso

29935
19:47:28,480 --> 19:47:31,280
O conceito de um tipo minúsculo é que o tamanho do

29936
19:47:31,280 --> 19:47:33,192
a visualização do parâmetro template vai

29937
19:47:33,192 --> 19:47:35,360
ser menos de quatro, vamos supor que estamos

29938
19:47:35,360 --> 19:47:37,440
fazendo a função e nós queríamos usar

29939
19:47:37,440 --> 19:47:38,240
para a

29940
19:47:38,240 --> 19:47:41,360
tipos integrais que são menores do que

29941
19:47:41,360 --> 19:47:43,600
Quatro bytes na memória suponha que você quer

29942
19:47:43,600 --> 19:47:45,680
fazer isso e é útil

29943
19:47:45,680 --> 19:47:47,600
no problema que você está tentando

29944
19:47:47,600 --> 19:47:49,680
resolver em c plus plus a maneira que podemos

29945
19:47:49,680 --> 19:47:52,480
fazer isso, podemos dizer que o tamanho de t é

29946
19:47:52,480 --> 19:47:55,360
Devia ser menos de quatro, digamos

29947
19:47:55,360 --> 19:47:57,832
tamanho de corretamente não digite pode digitar I

29948
19:47:57,832 --> 19:47:59,120
No momento em que fazemos isso, você está indo

29949
19:47:59,120 --> 19:48:01,192
Veja que isso é válido c plus plus

29950
19:48:01,192 --> 19:48:03,360
sintaxe para que não tenhamos nenhum

29951
19:48:03,360 --> 19:48:06,000
linhas muito bem, mas o que você deve saber

29952
19:48:06,000 --> 19:48:08,552
é que este é um requisito simples em

29953
19:48:08,552 --> 19:48:11,040
c plus conceitos e o que isto é

29954
19:48:11,040 --> 19:48:12,400
Vou fazer isso

29955
19:48:12,400 --> 19:48:15,600
só vai impor a sintaxe de

29956
19:48:15,600 --> 19:48:17,832
O que fazemos aqui o que colocamos aqui deve ser

29957
19:48:17,832 --> 19:48:20,552
sintaxe c plus plus somente

29958
19:48:20,552 --> 19:48:22,720
impõe a sintaxe, isso é o que você deve

29959
19:48:22,720 --> 19:48:24,872
Realmente lembrem-se bem agora que temos

29960
19:48:24,872 --> 19:48:27,600
Este fim vamos experimentá-lo e mostrar-lhe

29961
19:48:27,600 --> 19:48:30,000
alguns problemas que você pode realmente encontrar

29962
19:48:30,000 --> 19:48:31,600
Vamos criar dois personagens

29963
19:48:31,600 --> 19:48:33,440
variáveis que vamos chamar de primeira

29964
19:48:33,440 --> 19:48:35,280
um x nós vamos inicializar isso

29965
19:48:35,280 --> 19:48:39,120
57 por que não 67 e nós vamos

29966
19:48:39,120 --> 19:48:41,440
colocar na outra variável que está indo

29967
19:48:41,440 --> 19:48:44,960
para ser y e vai ter um 56 n

29968
19:48:44,960 --> 19:48:47,040
você pode colocar no que quiser apenas

29969
19:48:47,040 --> 19:48:49,120
Certifique-se de que você está dentro do alcance

29970
19:48:49,120 --> 19:48:51,832
do tipo de cartão que está entre 0 e 0

29971
19:48:51,832 --> 19:48:54,400
255 se você se lembrar bem agora que nós

29972
19:48:54,400 --> 19:48:56,960
Tenho isso n Eu percebo que não temos um

29973
19:48:56,960 --> 19:48:59,920
A função podemos tentar isso em vamos configurar

29974
19:48:59,920 --> 19:49:01,680
Outra função muito rápida nós somos

29975
19:49:01,680 --> 19:49:03,920
vamos dizer minúsculo tipo automático que podemos fazer

29976
19:49:03,920 --> 19:49:06,400
que você já conhece essa sintaxe e

29977
19:49:06,400 --> 19:49:09,440
nós vamos dizer adicionar tipo minúsculo auto a

29978
19:49:09,440 --> 19:49:12,552
e um tipo minúsculo p nós podemos fazer isso

29979
19:49:12,552 --> 19:49:15,192
e nós vamos devolver um plus b agora

29980
19:49:15,192 --> 19:49:18,080
que temos isso, digamos, a e b para baixo

29981
19:49:18,080 --> 19:49:19,600
aqui e chamar esta função que estamos indo

29982
19:49:19,600 --> 19:49:22,000
para dizer x e y e nós vamos tentar

29983
19:49:22,000 --> 19:49:24,160
e compilar este programa e ele está indo

29984
19:49:24,160 --> 19:49:26,872
para compilar bem porque do tipo que somos

29985
19:49:26,872 --> 19:49:29,192
usando para chamar a função que é o carro

29986
19:49:29,192 --> 19:49:31,440
seu tamanho será inferior a quatro

29987
19:49:31,440 --> 19:49:33,120
Tudo bem, então isso vai funcionar e é

29988
19:49:33,120 --> 19:49:34,400
indo para a compilação

29989
19:49:34,400 --> 19:49:36,720
Vamos construir com gcc que você vai ver

29990
19:49:36,720 --> 19:49:40,160
que a construção é boa, vamos tentar e uh

29991
19:49:40,160 --> 19:49:42,720
mudar o tipo aqui para terminar ou até mesmo

29992
19:49:42,720 --> 19:49:45,360
O dobro você sabe que o duplo é 8 bytes em

29993
19:49:45,360 --> 19:49:47,680
Memória, então esperamos que isso provavelmente

29994
19:49:47,680 --> 19:49:49,920
dar-nos algo errado tipo duplo é

29995
19:49:49,920 --> 19:49:52,320
8 bytes na memória, então esperamos o

29996
19:49:52,320 --> 19:49:54,240
Tamanho de t aqui

29997
19:49:54,240 --> 19:49:57,192
ser falso porque o tamanho de t é

29998
19:49:57,192 --> 19:49:59,760
Vai ser oito e oito não é menos

29999
19:49:59,760 --> 19:50:02,240
do que quatro isso vai ser falso, então

30000
19:50:02,240 --> 19:50:04,872
Alguns podem esperar que este conceito aqui

30001
19:50:04,872 --> 19:50:05,760
falhar

30002
19:50:05,760 --> 19:50:08,552
Mas vamos tentar e realmente provar que você está errado

30003
19:50:08,552 --> 19:50:11,192
nós vamos construir com gcc e você

30004
19:50:11,192 --> 19:50:13,360
Veja que está construindo com sucesso o que isso

30005
19:50:13,360 --> 19:50:16,800
É realmente fazer isso com simples

30006
19:50:16,800 --> 19:50:19,192
requisitos como temos aqui c plus

30007
19:50:19,192 --> 19:50:21,360
plus só vai aplicar para isso

30008
19:50:21,360 --> 19:50:24,640
para ser válido c plus mais sintaxe e tamanho

30009
19:50:24,640 --> 19:50:26,720
de t é menos de quatro

30010
19:50:26,720 --> 19:50:29,360
vai ser válido c plus sintaxe

30011
19:50:29,360 --> 19:50:32,080
Mesmo que esta expressão aqui avalie

30012
19:50:32,080 --> 19:50:34,480
à falsa isso não vai impor

30013
19:50:34,480 --> 19:50:36,960
para o valor desta expressão ser

30014
19:50:36,960 --> 19:50:38,960
falso você não pode fazer isso com simples

30015
19:50:38,960 --> 19:50:41,360
Requisitos que você vai fazer é verificar

30016
19:50:41,360 --> 19:50:44,480
que isso é sintaxe válida agora o que fazemos

30017
19:50:44,480 --> 19:50:46,720
fazer se realmente quisermos fazer isso

30018
19:50:46,720 --> 19:50:48,552
O tamanho de t deve ser

30019
19:50:48,552 --> 19:50:50,872
Menos de quatro se você quiser que você

30020
19:50:50,872 --> 19:50:53,832
deve usar requisitos aninhados e

30021
19:50:53,832 --> 19:50:55,600
Sintaxe para fazer isso é realmente simples nós

30022
19:50:55,600 --> 19:50:58,080
Pode ir aqui e colocar isso dentro, estamos

30023
19:50:58,080 --> 19:51:00,000
vamos dizer que precisamos que vamos adicionar

30024
19:51:00,000 --> 19:51:02,800
uma palavra-chave requer uma palavra-chave na frente disso, então

30025
19:51:02,800 --> 19:51:04,960
nós vamos colocar nossa expressão aqui

30026
19:51:04,960 --> 19:51:06,800
Vamos copiá-lo e colocá-lo em eu não quero

30027
19:51:06,800 --> 19:51:09,600
para digitar isso novamente no momento em que fazemos isso

30028
19:51:09,600 --> 19:51:12,320
agora a compilação vai falhar se nós

30029
19:51:12,320 --> 19:51:15,760
passar um tipo cujo tamanho não é menor do que

30030
19:51:15,760 --> 19:51:16,552
Quatro

30031
19:51:16,552 --> 19:51:18,552
e vamos tentar construir de novo você é

30032
19:51:18,552 --> 19:51:20,080
Vou ver que o mundo vai

30033
19:51:20,080 --> 19:51:22,000
falhar agora e nós vamos ter um

30034
19:51:22,000 --> 19:51:24,552
O conceito falhou e você vê o mundo

30035
19:51:24,552 --> 19:51:27,360
Terminou com erros, temos restrições

30036
19:51:27,360 --> 19:51:29,680
Não satisfeito e se formos aqui

30037
19:51:29,680 --> 19:51:31,512
nós vamos ver necessário para o

30038
19:51:31,512 --> 19:51:34,240
satisfação de pequeno tipo de automóvel e nós

30039
19:51:34,240 --> 19:51:37,512
Passado em um tipo duplo cujo tamanho é 8

30040
19:51:37,512 --> 19:51:40,320
bytes na memória e é menos de quatro

30041
19:51:40,320 --> 19:51:43,120
bytes você vê a exigência aqui é

30042
19:51:43,120 --> 19:51:46,640
não satisfeitos que possamos fazer isso usando

30043
19:51:46,640 --> 19:51:49,192
requisitos aninhados ok se formos para baixo

30044
19:51:49,192 --> 19:51:51,680
Por exemplo, e mudar isso para o carro

30045
19:51:51,680 --> 19:51:54,000
as pessoas chamam isso de char, mas eu chamo isso

30046
19:51:54,000 --> 19:51:56,720
carro que é meu hábito se mudarmos isso para

30047
19:51:56,720 --> 19:51:57,680
Carro de carro

30048
19:51:57,680 --> 19:51:59,120
e tentar fugir novamente você vai

30049
19:51:59,120 --> 19:52:01,680
ver que ele vai soldar bem

30050
19:52:01,680 --> 19:52:04,552
Porque agora o que está errado aqui vamos ver

30051
19:52:04,552 --> 19:52:07,360
O que erramos huh estamos recebendo um

30052
19:52:07,360 --> 19:52:10,240
Erro do compilador aqui qual é o problema

30053
19:52:10,240 --> 19:52:11,760
Vai dizer que

30054
19:52:11,760 --> 19:52:14,720
Vamos subir e tentar analisar isso a

30055
19:52:14,720 --> 19:52:17,040
Um pouco é dizer deduzir o retorno

30056
19:52:17,040 --> 19:52:19,512
O tipo não satisfaz o espaço reservado

30057
19:52:19,512 --> 19:52:21,192
Restrições

30058
19:52:21,192 --> 19:52:23,760
e nós estamos exigindo o tipo de retorno

30059
19:52:23,760 --> 19:52:25,760
desse cara para ser minúsculo tempo uh-huh i

30060
19:52:25,760 --> 19:52:28,000
Acho que sei qual é o problema

30061
19:52:28,000 --> 19:52:30,872
O problema são as operações aritméticas

30062
19:52:30,872 --> 19:52:32,720
Como a adição que estamos fazendo aqui são

30063
19:52:32,720 --> 19:52:35,120
Não suportado por tipos que

30064
19:52:35,120 --> 19:52:37,920
menor que a formista e é a menor

30065
19:52:37,920 --> 19:52:40,000
tipo que nós podemos usar com aritmética

30066
19:52:40,000 --> 19:52:42,160
operações para o que o compilador está indo

30067
19:52:42,160 --> 19:52:44,160
O fazer é fazer implícito

30068
19:52:44,160 --> 19:52:47,512
conversões de carro em ponta e dentro

30069
19:52:47,512 --> 19:52:49,440
Aqui o que teremos será

30070
19:52:49,440 --> 19:52:52,320
et o resultado disso vai ser

30071
19:52:52,320 --> 19:52:54,480
form e o tipo de retorno vai ser

30072
19:52:54,480 --> 19:52:56,960
deduzido para estar em mas ant

30073
19:52:56,960 --> 19:52:59,440
vai violar a exigência que nós

30074
19:52:59,440 --> 19:53:01,920
Tenho aqui o que diz que o tamanho

30075
19:53:01,920 --> 19:53:04,160
de tipo minúsculo aqui deve ser menor do que

30076
19:53:04,160 --> 19:53:06,800
Quatro e o retorno da formi não é menor

30077
19:53:06,800 --> 19:53:09,680
mais de quatro para que possamos tentar corrigir isso por

30078
19:53:09,680 --> 19:53:12,080
colocando um sinal de igualdade aqui e eu acho

30079
19:53:12,080 --> 19:53:14,480
vai funcionar, vamos fazer isso e

30080
19:53:14,480 --> 19:53:16,480
mundo novamente este é um bom aprendizado

30081
19:53:16,480 --> 19:53:18,320
experiência e agora você vê que o

30082
19:53:18,320 --> 19:53:20,160
A construção vai funcionar porque agora o

30083
19:53:20,160 --> 19:53:22,480
O tipo de retorno vai satisfazer o nosso

30084
19:53:22,480 --> 19:53:25,192
Requisitos, então vamos provar que somos

30085
19:53:25,192 --> 19:53:27,440
tirar uma rede disso, na verdade, estamos

30086
19:53:27,440 --> 19:53:29,512
vamos fazer nosso próprio resultado e nós somos

30087
19:53:29,512 --> 19:53:31,920
Vou dizer igual e pegar o resultado

30088
19:53:31,920 --> 19:53:33,920
desse cara, nós realmente deveríamos provar isso

30089
19:53:33,920 --> 19:53:36,160
Obrigado e depois disso vamos

30090
19:53:36,160 --> 19:53:38,800
imprimir os resultados que podemos fazer isso e nós

30091
19:53:38,800 --> 19:53:41,440
pode até mesmo ir mais longe e imprimir o tamanho

30092
19:53:41,440 --> 19:53:43,832
do resultado aqui, então vamos dizer

30093
19:53:43,832 --> 19:53:46,160
Tamanho do resultado ok agora que temos

30094
19:53:46,160 --> 19:53:49,440
Este fim podemos soldar com gcc e o

30095
19:53:49,440 --> 19:53:52,480
O mundo é bom, não se importe com isso

30096
19:53:52,480 --> 19:53:55,040
linha é provavelmente código de estúdio visual

30097
19:53:55,040 --> 19:53:56,720
mexendo conosco, você vê que o mundo

30098
19:53:56,720 --> 19:54:00,640
É bom agora podemos trazer um terminal

30099
19:54:00,640 --> 19:54:03,192
e correr isso e ver o tamanho do

30100
19:54:03,192 --> 19:54:05,360
Tipo de retorno e realmente provar

30101
19:54:05,360 --> 19:54:07,832
que o compilador transformou isso em um

30102
19:54:07,832 --> 19:54:10,960
final mesmo se nós chamamos a nossa função com

30103
19:54:10,960 --> 19:54:13,512
Argumentos de carro, isso é interessante, então

30104
19:54:13,512 --> 19:54:15,760
claro e correr galo agora vamos

30105
19:54:15,760 --> 19:54:18,480
Veja os resultados serão 123 e a

30106
19:54:18,480 --> 19:54:21,040
O tamanho do resultado é para, mesmo se

30107
19:54:21,040 --> 19:54:24,160
Passado em tipos de carros como nossos argumentos

30108
19:54:24,160 --> 19:54:26,240
Tudo bem, então espero que isso prove que você

30109
19:54:26,240 --> 19:54:29,040
pode configurar requisitos aninhados para

30110
19:54:29,040 --> 19:54:31,600
impor a expressão aqui para ser

30111
19:54:31,600 --> 19:54:33,680
Verificar outro tipo de exigência que você

30112
19:54:33,680 --> 19:54:36,400
pode fazer é uma exigência composta

30113
19:54:36,400 --> 19:54:38,400
Coloque isso e nós vamos colocar em um

30114
19:54:38,400 --> 19:54:40,480
exemplo simples para levar isso para casa i

30115
19:54:40,480 --> 19:54:42,640
Acho que devo tomar essa função e

30116
19:54:42,640 --> 19:54:46,000
Coloque isso abaixo de nossos conceitos, então a

30117
19:54:46,000 --> 19:54:48,320
A exigência composta parece assim você

30118
19:54:48,320 --> 19:54:51,192
Coloque sua expressão em acrílicos como

30119
19:54:51,192 --> 19:54:53,360
Isso e então você pode até mesmo colocar

30120
19:54:53,360 --> 19:54:56,000
Requisitos sobre os valores do

30121
19:54:56,000 --> 19:54:58,000
expressão, por exemplo, podemos fazer cumprir

30122
19:54:58,000 --> 19:55:00,720
que o valor de um mais b aqui deve

30123
19:55:00,720 --> 19:55:03,280
ser conversível e se não for

30124
19:55:03,280 --> 19:55:05,920
conversível para acabar com o conceito aqui é

30125
19:55:05,920 --> 19:55:08,000
Vou falhar isso é um composto

30126
19:55:08,000 --> 19:55:10,800
exigência que você pode até mesmo colocar não, exceto

30127
19:55:10,800 --> 19:55:13,192
palavras-chave aqui, mas não vamos

30128
19:55:13,192 --> 19:55:15,600
Vai tão longe porque não temos realmente

30129
19:55:15,600 --> 19:55:18,000
Aprendi sobre exceções, então por enquanto eu sou

30130
19:55:18,000 --> 19:55:19,920
Vou testar isso, eu só queria você

30131
19:55:19,920 --> 19:55:22,000
para estar ciente de que você pode fazer isso agora

30132
19:55:22,000 --> 19:55:24,320
que temos esse conceito n, vamos jogar

30133
19:55:24,320 --> 19:55:26,640
com ele e ver como podemos fazê-lo quebrar

30134
19:55:26,640 --> 19:55:29,120
Obrigado, vamos mudar nosso conceito

30135
19:55:29,120 --> 19:55:31,600
para comestível, digamos, comestível aqui e

30136
19:55:31,600 --> 19:55:33,440
nós vamos dizer comestível e nós somos

30137
19:55:33,440 --> 19:55:34,480
Indo para dentro de nós.

30138
19:55:34,480 --> 19:55:36,640
colocar em nossos tipos de carro aqui e é

30139
19:55:36,640 --> 19:55:39,120
indo para matar o trabalho porque

30140
19:55:39,120 --> 19:55:42,160
podemos adicionar duas variáveis de carro e isso é

30141
19:55:42,160 --> 19:55:44,800
indo para o trabalho porque nós podemos adicionar dois carros

30142
19:55:44,800 --> 19:55:47,280
variáveis e esta é uma sintaxe válida o que

30143
19:55:47,280 --> 19:55:48,960
nós vamos sair disso está indo

30144
19:55:48,960 --> 19:55:50,960
ser uma formista porque lembre-se do

30145
19:55:50,960 --> 19:55:52,960
O compilador vai inserir implícito

30146
19:55:52,960 --> 19:55:55,760
conversões de cartão para fim porque

30147
19:55:55,760 --> 19:55:58,960
Não pode realmente adicionar dois tipos de cartão e é

30148
19:55:58,960 --> 19:56:01,920
A menor coisa que você pode fazer aritmética

30149
19:56:01,920 --> 19:56:04,640
operações para que o resultado seja

30150
19:56:04,640 --> 19:56:06,240
Vai ser um fim para que uma lente seja

30151
19:56:06,240 --> 19:56:07,832
conversível em uma borda, isso vai

30152
19:56:07,832 --> 19:56:10,160
O trabalho vamos construir e mostrar que isso

30153
19:56:10,160 --> 19:56:12,552
Vai trabalhar, vamos soldar

30154
19:56:12,552 --> 19:56:15,360
Isso com o gcc você vê construir é bom

30155
19:56:15,360 --> 19:56:17,192
Podemos tentar correr e ver o que nós

30156
19:56:17,192 --> 19:56:20,000
Veja depois de chamar a função que temos

30157
19:56:20,000 --> 19:56:23,040
O resultado é 123 e isso vai ser

30158
19:56:23,040 --> 19:56:25,280
o tamanho de quatro porque nós temos uma rede

30159
19:56:25,280 --> 19:56:27,360
A partir disso, vamos tentar mudar isso para

30160
19:56:27,360 --> 19:56:29,600
dobro e ver o que temos tão duplo

30161
19:56:29,600 --> 19:56:32,160
vamos dizer o dobro aqui e se nós gostaríamos

30162
19:56:32,160 --> 19:56:34,720
Espero que isso funcione porque somar

30163
19:56:34,720 --> 19:56:36,552
Duas duplas vão te dar um

30164
19:56:36,552 --> 19:56:37,512
o dobro

30165
19:56:37,512 --> 19:56:39,512
e vamos devolver um duplo de

30166
19:56:39,512 --> 19:56:40,872
Esta função

30167
19:56:40,872 --> 19:56:43,920
E uh um duplo é conversível em uma rede

30168
19:56:43,920 --> 19:56:45,440
Então vamos devolver um duplo de

30169
19:56:45,440 --> 19:56:48,320
Este tipo e isto devia dizer oito agora

30170
19:56:48,320 --> 19:56:49,832
Porque é isso que estamos retornando

30171
19:56:49,832 --> 19:56:51,760
da função aqui vamos construir com

30172
19:56:51,760 --> 19:56:54,000
gcc você vê que ambos são bons nós podemos

30173
19:56:54,000 --> 19:56:56,720
claro e correr galo isto vai

30174
19:56:56,720 --> 19:57:00,000
Diga que o tamanho do resultado é oito, porque agora

30175
19:57:00,000 --> 19:57:01,920
O que estamos retornando vai ser um

30176
19:57:01,920 --> 19:57:04,080
duplo a partir desta função aqui e

30177
19:57:04,080 --> 19:57:07,280
duplo satisfaz o nosso conceito somar

30178
19:57:07,280 --> 19:57:10,160
dois duplos é a sintaxe válida e o que nós

30179
19:57:10,160 --> 19:57:12,160
sair disso vai ser um duplo

30180
19:57:12,160 --> 19:57:14,480
e um duplo é conversível em uma rede

30181
19:57:14,480 --> 19:57:16,720
isso vai funcionar, vamos tentar e

30182
19:57:16,720 --> 19:57:19,280
Mude nossos parâmetros aqui para força

30183
19:57:19,280 --> 19:57:21,440
nós vamos comentar o nosso x e y

30184
19:57:21,440 --> 19:57:23,512
variáveis aqui e vamos configurar

30185
19:57:23,512 --> 19:57:26,872
duas cordas indo para dizer std string x

30186
19:57:26,872 --> 19:57:28,720
e nós vamos dizer olá e você

30187
19:57:28,720 --> 19:57:30,552
Saiba o que vamos dizer e por quê

30188
19:57:30,552 --> 19:57:33,280
nós vamos dizer std força y

30189
19:57:33,280 --> 19:57:35,920
e nós vamos dizer o mundo por que não e

30190
19:57:35,920 --> 19:57:37,760
No momento em que fazemos isso, você vê que nós

30191
19:57:37,760 --> 19:57:40,552
Há um problema por que temos um problema

30192
19:57:40,552 --> 19:57:44,000
porque agora é uma exigência para o

30193
19:57:44,000 --> 19:57:46,400
resultado de a e b para ser conversível em

30194
19:57:46,400 --> 19:57:48,640
final Lembre-se que você pode somar dois

30195
19:57:48,640 --> 19:57:51,832
fios, por exemplo, você pode dizer auto s

30196
19:57:51,832 --> 19:57:55,040
e dizer x plus y isso vai funcionar

30197
19:57:55,040 --> 19:57:57,040
porque você pode adicionar duas cordas e

30198
19:57:57,040 --> 19:57:58,872
Isso vai concatenar, então

30199
19:57:58,872 --> 19:58:02,000
Esta é uma sintaxe válida, por que estamos falhando

30200
19:58:02,000 --> 19:58:04,552
porque temos uma exigência para

30201
19:58:04,552 --> 19:58:07,192
para ser conversível em um fim e

30202
19:58:07,192 --> 19:58:09,760
A força não é realmente conversível para um

30203
19:58:09,760 --> 19:58:12,400
fim, então isso vai falhar vamos construir

30204
19:58:12,400 --> 19:58:14,640
Este programa e mostrar que este é

30205
19:58:14,640 --> 19:58:16,872
Na verdade, o caso que vamos ver

30206
19:58:16,872 --> 19:58:20,240
O mundo terminou com flechas e vamos ver

30207
19:58:20,240 --> 19:58:22,720
O erro que temos bem, então restrições

30208
19:58:22,720 --> 19:58:25,280
Não satisfeito, vai dizer necessário

30209
19:58:25,280 --> 19:58:28,320
a satisfação de audível com o automóvel

30210
19:58:28,320 --> 19:58:30,720
aqui em exigência e vai

30211
19:58:30,720 --> 19:58:31,512
Dizê

30212
19:58:31,512 --> 19:58:34,240
um plus b não satisfaz o tipo

30213
19:58:34,240 --> 19:58:36,640
exigência porque o que nós temos depois

30214
19:58:36,640 --> 19:58:39,920
adicionar a e b não é conversível para um

30215
19:58:39,920 --> 19:58:42,000
acabar e você vê isso aqui

30216
19:58:42,000 --> 19:58:44,640
um plus b convertível para um fim este é

30217
19:58:44,640 --> 19:58:47,040
indo falhar bem, então vamos tentar e

30218
19:58:47,040 --> 19:58:50,080
remover este requisito para converter em

30219
19:58:50,080 --> 19:58:52,720
acabar e ver que isso realmente funciona

30220
19:58:52,720 --> 19:58:54,552
nós vamos remover isso eu vou

30221
19:58:54,552 --> 19:58:56,160
Corte isso para fora

30222
19:58:56,160 --> 19:58:58,480
e tentar construir novamente eu vou usar

30223
19:58:58,480 --> 19:59:00,960
gcc para construir e agora você vê que isso

30224
19:59:00,960 --> 19:59:03,360
é soldagem porque já não

30225
19:59:03,360 --> 19:59:06,080
ter a exigência do valor de retorno

30226
19:59:06,080 --> 19:59:08,400
desta expressão ou resultado eu devo

30227
19:59:08,400 --> 19:59:11,120
Digam o resultado desta função

30228
19:59:11,120 --> 19:59:13,360
Agora não precisa ser conversível para um

30229
19:59:13,360 --> 19:59:15,040
OK, vamos colocar isso de volta porque eu quero

30230
19:59:15,040 --> 19:59:17,360
você vê isso mais tarde como uma referência e

30231
19:59:17,360 --> 19:59:19,440
Agora você sabe como usar composto

30232
19:59:19,440 --> 19:59:22,552
Requisitos para realmente colocar restrições

30233
19:59:22,552 --> 19:59:25,280
em seus modelos de função, isso é

30234
19:59:25,280 --> 19:59:27,360
Realmente tudo o que nos posicionamos para fazer nisso

30235
19:59:27,360 --> 19:59:29,760
Uma palestra espero que você tenha achado interessante

30236
19:59:29,760 --> 19:59:32,640
Acho que devo comentar esses caras

30237
19:59:32,640 --> 19:59:35,120
Porque eu não gosto de deixar você com

30238
19:59:35,120 --> 19:59:37,920
código que tem erros de compilador, vamos virar

30239
19:59:37,920 --> 19:59:39,832
de volta ao dobro para que isso funcione

30240
19:59:39,832 --> 19:59:41,920
nós vamos soldar novamente o mundo

30241
19:59:41,920 --> 19:59:44,240
É bom e vamos parar por aqui

30242
19:59:44,240 --> 19:59:45,920
Esta palestra no próximo vamos

30243
19:59:45,920 --> 19:59:48,480
para ver como podemos combinar conceitos e

30244
19:59:48,480 --> 19:59:50,552
fazer algumas coisas loucas

30245
19:59:50,552 --> 19:59:52,872
Vá em frente e termine aqui e me encontre

30246
19:59:52,872 --> 19:59:54,960
lá nesta palestra vamos ver

30247
19:59:54,960 --> 19:59:57,680
como podemos combinar conceitos usando

30248
19:59:57,680 --> 20:00:00,160
operadores lógicos que podemos combinar

30249
20:00:00,160 --> 20:00:03,280
conceitos usando o operador e o

30250
20:00:03,280 --> 20:00:06,552
r operador como você vê aqui vamos olhar

30251
20:00:06,552 --> 20:00:09,600
Um exemplo simples aqui temos um conceito

30252
20:00:09,600 --> 20:00:12,080
é o tipo de tempo que já vimos antes e

30253
20:00:12,080 --> 20:00:14,720
Vai verificar se o tamanho do

30254
20:00:14,720 --> 20:00:17,120
parâmetro de modelo que passamos é menor que

30255
20:00:17,120 --> 20:00:19,280
Quatro vai impor a sintaxe

30256
20:00:19,280 --> 20:00:21,600
com uma exigência simples, mas também é

30257
20:00:21,600 --> 20:00:23,680
indo para impor o valor deste

30258
20:00:23,680 --> 20:00:25,680
expressão para ser verdade se o valor é

30259
20:00:25,680 --> 20:00:28,160
Não é verdade que o conceito vai falhar

30260
20:00:28,160 --> 20:00:30,552
e estamos usando um requisito aninhado

30261
20:00:30,552 --> 20:00:33,192
para isso é o nosso conceito aqui

30262
20:00:33,192 --> 20:00:35,600
Vamos tentar configurar uma função e ver

30263
20:00:35,600 --> 20:00:38,480
Como podemos combinar esse conceito com

30264
20:00:38,480 --> 20:00:41,440
Outros conceitos aqui temos uma função

30265
20:00:41,440 --> 20:00:43,440
vai devolver um t o nome de

30266
20:00:43,440 --> 20:00:45,760
A função é func que está tomando em nosso

30267
20:00:45,760 --> 20:00:48,160
parâmetro e aqui temos o corpo de

30268
20:00:48,160 --> 20:00:50,160
a função dentro destes dois encaracolados

30269
20:00:50,160 --> 20:00:52,960
As chaves, mas o que temos aqui é um

30270
20:00:52,960 --> 20:00:55,832
Conceito que queremos aplicar a este

30271
20:00:55,832 --> 20:00:58,320
A função aqui e a primeira linha aqui é

30272
20:00:58,320 --> 20:01:00,320
vamos mostrar que podemos combinar o

30273
20:01:00,320 --> 20:01:01,440
O conceito

30274
20:01:01,440 --> 20:01:03,760
Como fazemos aqui para que tudo isso seja

30275
20:01:03,760 --> 20:01:06,872
Será uma combinação lógica de

30276
20:01:06,872 --> 20:01:09,040
Para que possamos exigir que o

30277
20:01:09,040 --> 20:01:11,440
parâmetro de modelo seja um integral

30278
20:01:11,440 --> 20:01:14,800
tipo ou um tipo de ponto flutuante usando o

30279
20:01:14,800 --> 20:01:17,600
ou operador aqui outra coisa que podemos fazer

30280
20:01:17,600 --> 20:01:20,160
é usar o operador como você vê para baixo

30281
20:01:20,160 --> 20:01:22,400
Aqui na segunda linha e nós vamos

30282
20:01:22,400 --> 20:01:24,080
Para exigir que

30283
20:01:24,080 --> 20:01:24,960
O que é

30284
20:01:24,960 --> 20:01:28,320
parâmetro de modelo é integral e

30285
20:01:28,320 --> 20:01:30,720
um tipo minúsculo e o compilador vai

30286
20:01:30,720 --> 20:01:33,120
impor essas coisas como estamos prestes a

30287
20:01:33,120 --> 20:01:35,120
ver em um minuto quando atingimos o visual

30288
20:01:35,120 --> 20:01:37,832
código de estúdio que você pode até mesmo especificar seu

30289
20:01:37,832 --> 20:01:40,640
conceitos em vigor, por exemplo, o terceiro

30290
20:01:40,640 --> 20:01:43,280
A linha aqui vai dizer que precisamos para

30291
20:01:43,280 --> 20:01:46,160
O conceito para ser integral, então deve

30292
20:01:46,160 --> 20:01:48,160
ser um tipo integral e nós vamos

30293
20:01:48,160 --> 20:01:51,760
Especifique nosso conceito de tipo minúsculo no lugar

30294
20:01:51,760 --> 20:01:54,640
Você vê que estamos fazendo isso aqui em

30295
20:01:54,640 --> 20:01:56,720
A declaração de função e isso é

30296
20:01:56,720 --> 20:01:58,480
indo para trabalhar este é um c plus válido

30297
20:01:58,480 --> 20:02:01,192
mais sintaxe, mas eu não recomendo isso

30298
20:02:01,192 --> 20:02:02,640
Porque isso vai fazer seu

30299
20:02:02,640 --> 20:02:05,600
declarações de função realmente feias, então agora

30300
20:02:05,600 --> 20:02:07,040
que você sabe disso nós vamos cabeçar

30301
20:02:07,040 --> 20:02:08,960
sobre o código do estúdio visual e jogar com

30302
20:02:08,960 --> 20:02:11,040
Este um pouco mais é apenas usando o

30303
20:02:11,040 --> 20:02:14,240
ou e operador para combinar conceitos

30304
20:02:14,240 --> 20:02:16,800
Tudo bem aqui estamos em nossa pasta de trabalho

30305
20:02:16,800 --> 20:02:18,960
O projeto atual está combinando

30306
20:02:18,960 --> 20:02:21,192
Conceitos que vamos pegar nosso

30307
20:02:21,192 --> 20:02:23,600
modelo de arquivos muito rápido e colocá-los

30308
20:02:23,600 --> 20:02:25,760
no lugar e nós vamos abrir isso em

30309
20:02:25,760 --> 20:02:28,240
código de estúdio visual como sempre fazemos

30310
20:02:28,240 --> 20:02:30,320
arrastar e cair aqui temos o nosso

30311
20:02:30,320 --> 20:02:32,800
file, vamos abrir isso e

30312
20:02:32,800 --> 20:02:34,960
Feche o painel esquerdo aqui eu não gosto

30313
20:02:34,960 --> 20:02:37,440
e vamos incluir nossos conceitos

30314
20:02:37,440 --> 20:02:40,080
biblioteca, vamos fazer isso e

30315
20:02:40,080 --> 20:02:41,680
A primeira coisa que vamos fazer é

30316
20:02:41,680 --> 20:02:44,640
colocar em nosso pequeno tipo conceito aqui, então

30317
20:02:44,640 --> 20:02:47,120
é um tipo minúsculo que vai exigir isso

30318
20:02:47,120 --> 20:02:49,360
a sintaxe para o tamanho de t menos do que

30319
20:02:49,360 --> 20:02:51,192
4b suportado isso é simples

30320
20:02:51,192 --> 20:02:53,120
exigência novamente e nós vamos

30321
20:02:53,120 --> 20:02:56,240
exigir que essa expressão seja verdadeira e

30322
20:02:56,240 --> 20:02:57,760
nós estamos fazendo isso

30323
20:02:57,760 --> 20:03:00,160
usando um requisito aninhado, tudo bem agora que

30324
20:03:00,160 --> 20:03:02,640
temos esse conceito, podemos combinar isso

30325
20:03:02,640 --> 20:03:05,600
em outros conceitos, vamos usar o mesmo

30326
20:03:05,600 --> 20:03:07,600
função que temos usado o tempo todo

30327
20:03:07,600 --> 20:03:09,680
vamos dizer nome do tipo template

30328
20:03:09,680 --> 20:03:12,320
equipe e nós vamos colocar em nosso

30329
20:03:12,320 --> 20:03:14,080
requer cláusula, então vamos dizer

30330
20:03:14,080 --> 20:03:17,440
requer que possamos usar std intergroup e

30331
20:03:17,440 --> 20:03:18,640
Diga t

30332
20:03:18,640 --> 20:03:22,320
e dizer ou deve ser htd flutuando

30333
20:03:22,320 --> 20:03:24,800
No momento, acho que temos esse fim, este é um

30334
20:03:24,800 --> 20:03:28,000
conceito que temos que é construído no

30335
20:03:28,000 --> 20:03:30,160
c plus biblioteca padrão que podemos usar

30336
20:03:30,160 --> 20:03:32,400
Agora que temos isso, podemos então

30337
20:03:32,400 --> 20:03:35,280
Digamos que a assinatura de uma função t x é

30338
20:03:35,280 --> 20:03:38,240
indo para adicionar t a e t b e é

30339
20:03:38,240 --> 20:03:40,720
vai devolver a soma de a e b agora

30340
20:03:40,720 --> 20:03:42,480
Você só pode chamar essa função com

30341
20:03:42,480 --> 20:03:45,040
ou inteiros ou pontos flutuantes se

30342
20:03:45,040 --> 20:03:47,680
Você tenta desviar disso o conceito

30343
20:03:47,680 --> 20:03:49,440
vai falhar e nós vamos conseguir

30344
20:03:49,440 --> 20:03:51,832
um erro do compilador vamos descer e tentar

30345
20:03:51,832 --> 20:03:54,080
Isso vamos dizer e x e

30346
20:03:54,080 --> 20:03:57,192
colocar em um 6 por exemplo e em y e

30347
20:03:57,192 --> 20:03:59,440
colocar em um 4 e nós vamos adicionar isso

30348
20:03:59,440 --> 20:04:02,160
Vamos dizer adicionar x e y e se

30349
20:04:02,160 --> 20:04:04,480
Fazemos isso que vai funcionar porque

30350
20:04:04,480 --> 20:04:06,552
Este é um inteiro, então o conceito aqui

30351
20:04:06,552 --> 20:04:09,760
Vai ter sucesso, vamos soldar com gcc

30352
20:04:09,760 --> 20:04:11,192
e mostrar que a construção é boa

30353
20:04:11,192 --> 20:04:13,512
O mundo é bom, então não há problema que possamos

30354
20:04:13,512 --> 20:04:15,040
Mude isso para dobrar ele vai

30355
20:04:15,040 --> 20:04:17,920
trabalho porque o dobro é um ponto flutuante

30356
20:04:17,920 --> 20:04:20,800
Vamos dizer o dobro corretamente e se soprarmos

30357
20:04:20,800 --> 20:04:22,400
Novamente a bala vai embora

30358
20:04:22,400 --> 20:04:25,120
mas se tentarmos usar para

30359
20:04:25,120 --> 20:04:27,832
exemplo uma força, digamos std

30360
20:04:27,832 --> 20:04:30,640
corda de força que é uma força e

30361
20:04:30,640 --> 20:04:32,800
nós vamos mudar isso para o dobro

30362
20:04:32,800 --> 20:04:35,832
citações que podemos fazer isso e dizer std

30363
20:04:35,832 --> 20:04:39,192
força e eu coloco isso em citações novamente

30364
20:04:39,192 --> 20:04:42,240
double quotes OK se fizermos isso você ver

30365
20:04:42,240 --> 20:04:44,872
nós temos uma linha esquiggly e se nós andamos

30366
20:04:44,872 --> 20:04:48,000
Vamos ter violado o nosso conceito

30367
20:04:48,000 --> 20:04:50,800
Porque os parâmetros que passamos

30368
20:04:50,800 --> 20:04:53,192
Não satisfaça esse conceito, não é nem

30369
20:04:53,192 --> 20:04:55,832
um tipo integral ou um ponto flutuante

30370
20:04:55,832 --> 20:04:58,240
Digite e se formos aqui, vamos

30371
20:04:58,240 --> 20:05:01,120
Veja que violamos um conceito

30372
20:05:01,120 --> 20:05:03,832
restrição não satisfeita e está indo

30373
20:05:03,832 --> 20:05:06,080
para dizer o conceito que não foi

30374
20:05:06,080 --> 20:05:09,040
Satisfeito aqui, o que está bem

30375
20:05:09,040 --> 20:05:11,120
você pode combinar dois conceitos usando a

30376
20:05:11,120 --> 20:05:13,440
ou operador, mas nós também podemos usar o e

30377
20:05:13,440 --> 20:05:14,480
o operador

30378
20:05:14,480 --> 20:05:16,480
Vamos descer e tentar colocar um

30379
20:05:16,480 --> 20:05:18,872
Um exemplo simples que vai fazer isso

30380
20:05:18,872 --> 20:05:21,040
Agora o que vamos exigir

30381
20:05:21,040 --> 20:05:23,440
As pessoas que usam essa função são para

30382
20:05:23,440 --> 20:05:24,720
Satisfazer-se

30383
20:05:24,720 --> 20:05:27,832
tanto tipo minúsculo e integral, então nós somos

30384
20:05:27,832 --> 20:05:30,800
indo dizer que requer std integral i

30385
20:05:30,800 --> 20:05:32,552
Acho que temos isso n e nós vamos

30386
20:05:32,552 --> 20:05:33,832
Diga e

30387
20:05:33,832 --> 20:05:35,440
Tempo minúsculo e nós vamos dizer o nosso

30388
20:05:35,440 --> 20:05:38,080
parâmetro de modelo aqui no momento em que fazemos

30389
20:05:38,080 --> 20:05:40,872
Isso e vamos voltar isso para ser

30390
20:05:40,872 --> 20:05:44,000
digamos, ant x e colocar em um sete

30391
20:05:44,000 --> 20:05:46,960
o que tínhamos antes e em y e vamos

30392
20:05:46,960 --> 20:05:49,920
Diga quatro ou cinco não importa

30393
20:05:49,920 --> 20:05:51,360
Se fizermos isso

30394
20:05:51,360 --> 20:05:54,872
Vamos ver a nossa coisa novamente tão minúsculo tipo

30395
20:05:54,872 --> 20:05:57,440
requer que o tamanho seja menor ou

30396
20:05:57,440 --> 20:05:58,400
Igual a partir de

30397
20:05:58,400 --> 20:06:00,720
para quatro, então ant vai funcionar isso é

30398
20:06:00,720 --> 20:06:02,400
Vou construir porque o conceito é

30399
20:06:02,400 --> 20:06:04,960
Vou ficar satisfeito que são ambos

30400
20:06:04,960 --> 20:06:07,120
Tipo integral e minúsculo

30401
20:06:07,120 --> 20:06:10,000
Vamos trabalhar e ver esta corrida você vê o

30402
20:06:10,000 --> 20:06:13,120
O mundo é bom, nosso conceito está satisfeito

30403
20:06:13,120 --> 20:06:16,320
Mas no momento em que tentamos usar algo

30404
20:06:16,320 --> 20:06:18,640
Isso é maior que quatro

30405
20:06:18,640 --> 20:06:20,640
Nós vamos ter um problema

30406
20:06:20,640 --> 20:06:23,360
Vamos usar um duplo, por exemplo, somos

30407
20:06:23,360 --> 20:06:26,240
vai mudar isso para o dobro e o mundo

30408
20:06:26,240 --> 20:06:29,040
Esperamos que a compilação falhe porque

30409
20:06:29,040 --> 20:06:32,400
o tipo que é duplo não satisfaz

30410
20:06:32,400 --> 20:06:34,552
o conceito de tipo minúsculo e nós vamos

30411
20:06:34,552 --> 20:06:36,960
Veja isso aqui bem, então vamos ver

30412
20:06:36,960 --> 20:06:39,360
solda terminou com flechas e nós somos

30413
20:06:39,360 --> 20:06:41,760
ter um longo erro aqui, mas

30414
20:06:41,760 --> 20:06:44,480
A carne disto é que temos um

30415
20:06:44,480 --> 20:06:47,360
restrição que não está satisfeita

30416
20:06:47,360 --> 20:06:48,960
E é

30417
20:06:48,960 --> 20:06:51,680
para que seja necessário para a satisfação

30418
20:06:51,680 --> 20:06:55,120
de std integral tão duplo não está indo

30419
20:06:55,120 --> 20:06:57,600
para satisfazer isso eu acho que o duplo foi um

30420
20:06:57,600 --> 20:06:59,360
Um péssimo exemplo porque não é

30421
20:06:59,360 --> 20:07:01,680
Integrante tão integral vai falhar

30422
20:07:01,680 --> 20:07:04,000
E se passarmos em longa ant OK que

30423
20:07:04,000 --> 20:07:05,040
É realmente

30424
20:07:05,040 --> 20:07:07,040
um tipo integral, mas não vai

30425
20:07:07,040 --> 20:07:10,320
satisfazer o tipo minúsculo, então vamos dizer longo fim

30426
20:07:10,320 --> 20:07:12,640
E nós vamos construir agora que estamos

30427
20:07:12,640 --> 20:07:15,600
vai violar, vamos usar formiga longa

30428
20:07:15,600 --> 20:07:18,320
Porque eu acho que o fim longo não é grande

30429
20:07:18,320 --> 20:07:20,552
o suficiente para que vamos construir agora que estamos

30430
20:07:20,552 --> 20:07:23,280
vai falhar porque o tipo minúsculo não é

30431
20:07:23,280 --> 20:07:25,600
Satisfeito que você vê necessário para um

30432
20:07:25,600 --> 20:07:27,920
insatisfação do tipo minúsculo e é

30433
20:07:27,920 --> 20:07:31,040
vai dizer que o tamanho de t é inferior a 4 é

30434
20:07:31,040 --> 20:07:34,400
Não satisfeito porque adivinhe o que

30435
20:07:34,400 --> 20:07:37,832
tamanho da formi pulmonar pulmonar é maior que 4.

30436
20:07:37,832 --> 20:07:40,160
Você pode tentar provar isso tirando

30437
20:07:40,160 --> 20:07:44,160
Este tipo aqui e a dizer stdc out tamanho

30438
20:07:44,160 --> 20:07:47,440
de um longo final que vamos ver

30439
20:07:47,440 --> 20:07:49,280
Esta impressão para fora

30440
20:07:49,280 --> 20:07:50,872
E se estivermos fervidos agora, não vamos

30441
20:07:50,872 --> 20:07:52,552
para violar os nossos conceitos porque nós somos

30442
20:07:52,552 --> 20:07:54,552
Não chamando a função

30443
20:07:54,552 --> 20:07:56,480
A palavra vai ser boa o que nós

30444
20:07:56,480 --> 20:07:58,872
Quer fazer é executar o programa e ver

30445
20:07:58,872 --> 20:08:01,512
tamanho da formi pulmonar pulmonar que podemos fazer isso

30446
20:08:01,512 --> 20:08:05,360
galo oito do tamanho da formi pulmonar pulmonar

30447
20:08:05,360 --> 20:08:08,240
é oito e vai violar o nosso

30448
20:08:08,240 --> 20:08:11,512
Pequeno tipo conceito ok você pode fazer as coisas

30449
20:08:11,512 --> 20:08:13,680
assim e combinar os conceitos, mas

30450
20:08:13,680 --> 20:08:16,640
Podemos até mesmo colocar nossos conceitos no lugar

30451
20:08:16,640 --> 20:08:19,280
Pode fazer algo louco e, por exemplo

30452
20:08:19,280 --> 20:08:21,680
Digamos, vamos copiar isso e nós vamos

30453
20:08:21,680 --> 20:08:24,640
descer e dizer requer integral, mas

30454
20:08:24,640 --> 20:08:27,040
vamos colocar o tipo oportuno no lugar

30455
20:08:27,040 --> 20:08:28,480
Por exemplo, vamos pegar o

30456
20:08:28,480 --> 20:08:31,040
Requer fechar aqui e copiá-lo

30457
20:08:31,040 --> 20:08:33,760
e colocar isso no lugar de tipo minúsculo aqui

30458
20:08:33,760 --> 20:08:35,512
nós vamos fazer isso

30459
20:08:35,512 --> 20:08:36,800
e você vai ver que isso é

30460
20:08:36,800 --> 20:08:39,192
será válido c plus mais sintaxe se

30461
20:08:39,192 --> 20:08:41,280
nós tiramos o ponto e ponto e-a-lo

30462
20:08:41,280 --> 20:08:43,832
Não deveria estar lá, mas olhe para isso isso

30463
20:08:43,832 --> 20:08:45,440
É realmente feio isso vai fazer

30464
20:08:45,440 --> 20:08:48,160
suas funções são muito difíceis de ler, mas

30465
20:08:48,160 --> 20:08:50,480
Vai funcionar exatamente da mesma maneira

30466
20:08:50,480 --> 20:08:52,552
Isso aconteceu se chamarmos essa função, nós somos

30467
20:08:52,552 --> 20:08:55,280
Vou violar o tipo minúsculo, vamos fazer isso

30468
20:08:55,280 --> 20:08:57,512
vamos construir com gcc, temos um

30469
20:08:57,512 --> 20:09:00,080
Erro, vamos trazer isso para que possamos

30470
20:09:00,080 --> 20:09:02,872
Veja o que é requisito aninhado errado

30471
20:09:02,872 --> 20:09:05,680
tamanho de t não está satisfeito que este é um

30472
20:09:05,680 --> 20:09:08,480
sintaxe que você pode usar, mas eu realmente não

30473
20:09:08,480 --> 20:09:10,160
Recomendo isso porque isso vai

30474
20:09:10,160 --> 20:09:12,480
fazer o código difícil de ler e isso é

30475
20:09:12,480 --> 20:09:14,720
Realmente tudo o que nos posicionamos para fazer nisso

30476
20:09:14,720 --> 20:09:16,800
palestra sobre como podemos combinar

30477
20:09:16,800 --> 20:09:20,000
nossos conceitos usando o operador e

30478
20:09:20,000 --> 20:09:22,960
ou operador e você pode realmente usar

30479
20:09:22,960 --> 20:09:26,000
em todas as sintaxes para conceitos

30480
20:09:26,000 --> 20:09:28,640
Eu vi, mas eu só usei isso nisso

30481
20:09:28,640 --> 20:09:30,960
palestra porque é mais simples de mostrar

30482
20:09:30,960 --> 20:09:32,640
Vamos parar aqui neste

30483
20:09:32,640 --> 20:09:34,480
ensinar o próximo que vamos olhar

30484
20:09:34,480 --> 20:09:37,512
em conceitos e auto ir em frente e terminar

30485
20:09:37,512 --> 20:09:39,920
Aqui e me encontre lá nisso

30486
20:09:39,920 --> 20:09:41,512
palestra que vamos ampliar

30487
20:09:41,512 --> 20:09:44,160
conceitos e o mundo chave automático que temos

30488
20:09:44,160 --> 20:09:46,000
Já visto que podemos fazer alguma coisa

30489
20:09:46,000 --> 20:09:48,640
como este use as palavras-chave auto com o nosso

30490
20:09:48,640 --> 20:09:51,192
funções e deixar o compilador gerar

30491
20:09:51,192 --> 20:09:53,360
um modelo de função nos bastidores

30492
20:09:53,360 --> 20:09:55,280
E isso funcionou muito bem, poderíamos usar

30493
20:09:55,280 --> 20:09:58,320
Esta sintaxe para colocar restrições em nossa

30494
20:09:58,320 --> 20:10:00,480
Outras palavras-chave e vimos que

30495
20:10:00,480 --> 20:10:03,280
O compilador poderia realmente impor isso e

30496
20:10:03,280 --> 20:10:05,760
lançar um erro de compilador se o nosso conceito

30497
20:10:05,760 --> 20:10:08,640
Aqui está violado o que eu não mostrei

30498
20:10:08,640 --> 20:10:11,280
você é que você pode até mesmo fazer cumprir

30499
20:10:11,280 --> 20:10:13,920
conceitos sobre variáveis que você declara

30500
20:10:13,920 --> 20:10:15,920
Você pode fazer algo assim configurar um

30501
20:10:15,920 --> 20:10:18,000
variável dizer auto x e chamar o

30502
20:10:18,000 --> 20:10:21,120
variável x e aplicar para a variável

30503
20:10:21,120 --> 20:10:23,680
Para ser um tipo integral eu não

30504
20:10:23,680 --> 20:10:26,552
Você tem muito uso para isso porque

30505
20:10:26,552 --> 20:10:29,040
uma vez que você chamar a função e atribuir um

30506
20:10:29,040 --> 20:10:31,832
valor para uma variável você já tem um

30507
20:10:31,832 --> 20:10:34,080
ideia do que vai sair do

30508
20:10:34,080 --> 20:10:36,480
função mas se você tiver um caso de uso para

30509
20:10:36,480 --> 20:10:38,720
Algo assim, por favor, vá em frente e

30510
20:10:38,720 --> 20:10:40,552
Use isso, ele vai impor o seu

30511
20:10:40,552 --> 20:10:43,360
conceitos que você pode até usar conceitos como

30512
20:10:43,360 --> 20:10:45,760
Isso configura uma variável e atribui a

30513
20:10:45,760 --> 20:10:48,400
literal para o nome da variável usando o

30514
20:10:48,400 --> 20:10:51,512
auto palavra-chave aqui, mas eu pessoalmente acho

30515
20:10:51,512 --> 20:10:54,320
Isso é inútil porque você está colocando

30516
20:10:54,320 --> 20:10:55,832
o valor de si mesmo

30517
20:10:55,832 --> 20:10:58,872
Por que você quer colocar uma proteção se

30518
20:10:58,872 --> 20:11:00,320
Você sabe que você está colocando em um

30519
20:11:00,320 --> 20:11:02,240
duplo literal, então a variável deve

30520
20:11:02,240 --> 20:11:05,040
ser um tipo duplo eu acho isso um pouco

30521
20:11:05,040 --> 20:11:07,440
bit inútil mas é suportado em c

30522
20:11:07,440 --> 20:11:09,360
mais mais se você tiver um caso de uso para

30523
20:11:09,360 --> 20:11:11,832
Isso, por favor, vá em frente e use isso agora

30524
20:11:11,832 --> 20:11:13,360
que você sabe disso nós vamos cabeçar

30525
20:11:13,360 --> 20:11:15,600
sobre o código do estúdio visual e jogar com

30526
20:11:15,600 --> 20:11:18,240
nós um pouco mais bem aqui estamos em nosso

30527
20:11:18,240 --> 20:11:20,320
pasta de trabalho o projeto atual é

30528
20:11:20,320 --> 20:11:22,872
conceitos e auto que vamos pegar

30529
20:11:22,872 --> 20:11:24,960
nossos arquivos de modelo e vamos

30530
20:11:24,960 --> 20:11:27,120
Coloque-os no lugar e nós vamos

30531
20:11:27,120 --> 20:11:29,440
abrir isso no código do estúdio visual, vamos

30532
20:11:29,440 --> 20:11:31,360
fazer isso muito rápido que vamos ter

30533
20:11:31,360 --> 20:11:33,280
nossa pasta aberta, vamos abrir o

30534
20:11:33,280 --> 20:11:36,400
arquivo cpp principal fechar o painel esquerdo e

30535
20:11:36,400 --> 20:11:38,552
Limpe as coisas um pouco e nós estamos

30536
20:11:38,552 --> 20:11:41,360
incluir nossa biblioteca de conceitos

30537
20:11:41,360 --> 20:11:43,512
e nós vamos colocar em nossa função

30538
20:11:43,512 --> 20:11:45,192
que vai usar o carro

30539
20:11:45,192 --> 20:11:46,720
palavras-chave para

30540
20:11:46,720 --> 20:11:49,600
realmente fazer a sintaxe agradável e legal, mas

30541
20:11:49,600 --> 20:11:51,760
Vamos restringir o nosso automóvel

30542
20:11:51,760 --> 20:11:54,960
parâmetros aqui para usar tipos integrais se

30543
20:11:54,960 --> 20:11:56,640
Chamamos essa função com algo

30544
20:11:56,640 --> 20:11:59,040
que não é um inteiro ou qualquer gatilho

30545
20:11:59,040 --> 20:12:00,640
Tipo realmente nós vamos ter um

30546
20:12:00,640 --> 20:12:02,872
Erro do compilador, por isso, se formos aqui para

30547
20:12:02,872 --> 20:12:05,720
Exemplo e diga adicionar e dizer

30548
20:12:05,720 --> 20:12:09,360
10,9 e 0,1 vamos conseguir um

30549
20:12:09,360 --> 20:12:14,160
Erro do compilador porque 10.9 e 0.1 são

30550
20:12:14,160 --> 20:12:16,640
duplo literal e só apoiamos

30551
20:12:16,640 --> 20:12:19,120
tipos integrais nesta função, então

30552
20:12:19,120 --> 20:12:21,192
Vamos trabalhar e mostrar o erro, mas

30553
20:12:21,192 --> 20:12:23,040
Você deve saber disso agora porque nós

30554
20:12:23,040 --> 20:12:25,440
Fiz isto como um tempo de gazilhão

30555
20:12:25,440 --> 20:12:27,280
O conceito integral vai ser

30556
20:12:27,280 --> 20:12:29,760
violado e vai dizer necessário

30557
20:12:29,760 --> 20:12:32,800
para a satisfação da integral, para que o

30558
20:12:32,800 --> 20:12:34,720
O conceito está falhando aqui que vamos

30559
20:12:34,720 --> 20:12:36,640
obter um erro de compilador, mas se mudarmos

30560
20:12:36,640 --> 20:12:39,600
Isso, por exemplo, para 10 e 5

30561
20:12:39,600 --> 20:12:41,600
O que você quiser, é um inteiro

30562
20:12:41,600 --> 20:12:42,872
Isso vai funcionar que nós vamos

30563
20:12:42,872 --> 20:12:44,800
construção com gcc

30564
20:12:44,800 --> 20:12:46,720
Você vê que a riqueza é boa para que você possa

30565
20:12:46,720 --> 20:12:49,760
usar auto com conceitos como este que temos

30566
20:12:49,760 --> 20:12:51,832
Eu já viu essa sintaxe um par de

30567
20:12:51,832 --> 20:12:53,760
momentos neste capítulo o que não temos

30568
20:12:53,760 --> 20:12:55,920
visto é que, por exemplo, você pode configurar

30569
20:12:55,920 --> 20:12:59,040
uma variável no principal e chamar isso x y

30570
20:12:59,040 --> 20:13:02,240
nada e dizer que esta variável deve

30571
20:13:02,240 --> 20:13:05,192
satisfazer o conceito e especificar o

30572
20:13:05,192 --> 20:13:06,960
conceito que você quer, por exemplo, digamos

30573
20:13:06,960 --> 20:13:09,280
std integral e se você fizer alguma coisa

30574
20:13:09,280 --> 20:13:11,192
Assim vamos ver do que temos

30575
20:13:11,192 --> 20:13:12,800
que nós estamos indo para o mundo você vê o

30576
20:13:12,800 --> 20:13:14,872
O trabalho é bom porque se nós somarmos estes

30577
20:13:14,872 --> 20:13:17,360
Eu vamos gerar um inteiro

30578
20:13:17,360 --> 20:13:19,512
por exemplo, para esta função e nós somos

30579
20:13:19,512 --> 20:13:22,080
vai deduzir o tipo de retorno como form

30580
20:13:22,080 --> 20:13:23,832
Então o tipo de retorno vai ser

30581
20:13:23,832 --> 20:13:26,480
Integral e vai ser atribuível

30582
20:13:26,480 --> 20:13:29,760
em nossa variável aqui, mas se mudarmos para

30583
20:13:29,760 --> 20:13:31,680
Ponto flutuante eu acho que nós temos isso

30584
20:13:31,680 --> 20:13:34,240
conceito no lugar sim, nós fazemos, mas é

30585
20:13:34,240 --> 20:13:36,400
vamos falhar porque do que olhemos

30586
20:13:36,400 --> 20:13:38,640
Esta função vai ser um inteiro

30587
20:13:38,640 --> 20:13:41,192
e não podemos atribuir isso porque isso

30588
20:13:41,192 --> 20:13:43,120
O conceito aqui está dizendo

30589
20:13:43,120 --> 20:13:46,080
O que você tenta atribuir a esta variável

30590
20:13:46,080 --> 20:13:48,240
Aqui deve haver um ponto flutuante este

30591
20:13:48,240 --> 20:13:50,000
O significado aqui e se fizermos isso, somos

30592
20:13:50,000 --> 20:13:52,240
Vou chegar ao erro provavelmente, então nós

30593
20:13:52,240 --> 20:13:54,800
Tenho a flecha e vai dizer

30594
20:13:54,800 --> 20:13:57,440
restrição não satisfeita e está indo

30595
20:13:57,440 --> 20:13:59,192
para dizer o

30596
20:13:59,192 --> 20:14:01,680
Restrição que não satisfazemos o que é

30597
20:14:01,680 --> 20:14:03,760
seu ponto flutuante aqui é assim que você

30598
20:14:03,760 --> 20:14:06,320
pode colocar restrições em suas variáveis

30599
20:14:06,320 --> 20:14:08,800
Mesmo quando você os declara assim

30600
20:14:08,800 --> 20:14:11,512
Outra coisa que podemos tentar aqui é

30601
20:14:11,512 --> 20:14:12,800
Atribuir

30602
20:14:12,800 --> 20:14:15,360
um literal para esta variável aqui vamos

30603
20:14:15,360 --> 20:14:18,720
colocar em um 3.9 e ver se isso realmente

30604
20:14:18,720 --> 20:14:20,552
boils e compila

30605
20:14:20,552 --> 20:14:22,872
Vamos construir com gcc

30606
20:14:22,872 --> 20:14:24,872
Você vê que a construção é boa e

30607
20:14:24,872 --> 20:14:27,832
A exigência é para o que atribuímos a

30608
20:14:27,832 --> 20:14:30,480
Esta variável aqui deve ser um duplo

30609
20:14:30,480 --> 20:14:33,360
e um 3.9 já é um duplo, então não

30610
20:14:33,360 --> 20:14:36,400
problema, mas se tentarmos fazer isso

30611
20:14:36,400 --> 20:14:38,080
Sete, por exemplo,

30612
20:14:38,080 --> 20:14:40,640
Isso vai falhar, então vamos construir

30613
20:14:40,640 --> 20:14:42,640
Mais uma vez você vê que o conceito vai

30614
20:14:42,640 --> 20:14:45,280
falhar e é assim que você pode usar estes

30615
20:14:45,280 --> 20:14:48,552
coisas para restringir suas variáveis i

30616
20:14:48,552 --> 20:14:50,720
pessoalmente encontrar isso um pouco

30617
20:14:50,720 --> 20:14:53,120
inútil, pelo menos neste caso aqui

30618
20:14:53,120 --> 20:14:56,552
Porque eu sei que eu tenho um inteiro

30619
20:14:56,552 --> 20:14:57,680
Literal

30620
20:14:57,680 --> 20:15:00,000
e estou atribuindo isso a uma variável

30621
20:15:00,000 --> 20:15:02,480
Porque preciso da ajuda de conceitos para

30622
20:15:02,480 --> 20:15:03,440
A sério que

30623
20:15:03,440 --> 20:15:05,920
constrange minha variável aqui, mas no

30624
20:15:05,920 --> 20:15:07,832
Caso em que você está chamando uma função

30625
20:15:07,832 --> 20:15:11,680
Por exemplo, usando um 5 e um 8

30626
20:15:11,680 --> 20:15:14,080
Isso pode ser útil porque não é

30627
20:15:14,080 --> 20:15:16,800
Fácil de acompanhar o tipo de retorno

30628
20:15:16,800 --> 20:15:18,720
Você obtém de uma função porque o

30629
20:15:18,720 --> 20:15:21,440
A função pode ter uma expressão de retorno

30630
20:15:21,440 --> 20:15:24,400
que tem várias variáveis diferentes

30631
20:15:24,400 --> 20:15:26,552
e não é fácil manter o controle do que

30632
20:15:26,552 --> 20:15:28,872
Você volta de uma função e você pode

30633
20:15:28,872 --> 20:15:31,920
usar uma restrição como esta para ter certeza

30634
20:15:31,920 --> 20:15:33,832
O que você obtém da função é o que

30635
20:15:33,832 --> 20:15:35,920
Você quer e se não é o que você quer

30636
20:15:35,920 --> 20:15:37,832
você vai lançar um erro de compilador

30637
20:15:37,832 --> 20:15:40,000
Porque o conceito que você usa vai

30638
20:15:40,000 --> 20:15:42,160
Falha eu gostaria de recebê-lo neste

30639
20:15:42,160 --> 20:15:43,832
Novo capítulo onde vamos estar

30640
20:15:43,832 --> 20:15:46,872
Aprender sobre aulas é a

30641
20:15:46,872 --> 20:15:49,440
mecanismo que temos em c plus plus para

30642
20:15:49,440 --> 20:15:52,480
construir nossos próprios tipos e usá-los como nós

30643
20:15:52,480 --> 20:15:54,800
têm usado outros tipos de boletins

30644
20:15:54,800 --> 20:15:57,120
Como e para dobrar ou o que quer que seja e nós somos

30645
20:15:57,120 --> 20:15:59,120
será capaz de fazer isso através da configuração

30646
20:15:59,120 --> 20:16:03,280
aumentar os planos dos nossos tipos de classes e

30647
20:16:03,280 --> 20:16:05,600
nós vamos usar esses projetos

30648
20:16:05,600 --> 20:16:08,480
para construir objetos reais que podemos usar

30649
20:16:08,480 --> 20:16:10,640
em nosso programa c plus plus para

30650
20:16:10,640 --> 20:16:12,960
Um exemplo, podemos ter uma classe como

30651
20:16:12,960 --> 20:16:16,160
blueprint e podemos criar classe real

30652
20:16:16,160 --> 20:16:19,600
objetos em nosso programa c plus plus como nós

30653
20:16:19,600 --> 20:16:21,760
Precisamos deles e nós vamos aprender

30654
20:16:21,760 --> 20:16:24,320
tudo sobre isso nos próximos capítulos

30655
20:16:24,320 --> 20:16:25,920
Vamos nos dirigir no próximo

30656
20:16:25,920 --> 20:16:28,320
dar palestra e deixar você configurar o seu próprio

30657
20:16:28,320 --> 20:16:31,040
Primeiro c plus mais classe vá em frente e

30658
20:16:31,040 --> 20:16:33,760
Termine aqui e me encontre lá neste

30659
20:16:33,760 --> 20:16:35,920
palestra que você vai construir seu

30660
20:16:35,920 --> 20:16:39,192
primeiras classes c plus plus são a

30661
20:16:39,192 --> 20:16:42,080
mecanismo que temos em c plus plus para ser

30662
20:16:42,080 --> 20:16:45,040
capaz de construir nossos próprios tipos se você

30663
20:16:45,040 --> 20:16:47,280
Lembremmo até agora neste curso que temos

30664
20:16:47,280 --> 20:16:50,000
use tipos básicos como formi e

30665
20:16:50,000 --> 20:16:50,960
o dobro

30666
20:16:50,960 --> 20:16:53,360
e nós estávamos usando-os assim nós dissemos

30667
20:16:53,360 --> 20:16:55,600
o tipo da variável que damos

30668
20:16:55,600 --> 20:16:57,360
nome da variável e, em seguida, nós

30669
20:16:57,360 --> 20:16:59,760
inicializar essa variável e podemos usar

30670
20:16:59,760 --> 20:17:03,280
Isso ao longo do nosso programa, agora estamos

30671
20:17:03,280 --> 20:17:05,920
Em um ponto em que precisamos começar

30672
20:17:05,920 --> 20:17:08,800
projetar nossos próprios tipos supor que queremos

30673
20:17:08,800 --> 20:17:12,720
para construir nosso próprio tipo que modela a

30674
20:17:12,720 --> 20:17:15,192
Uma pessoa, por exemplo, suponha que uma pessoa é

30675
20:17:15,192 --> 20:17:17,440
Definido pelo nome

30676
20:17:17,440 --> 20:17:20,800
A idade e a morada e queremos

30677
20:17:20,800 --> 20:17:23,760
Modelar pessoas em nosso programa

30678
20:17:23,760 --> 20:17:27,120
e usá-los como jogadores, por exemplo e

30679
20:17:27,120 --> 20:17:29,680
Quando temos as propriedades de uma pessoa

30680
20:17:29,680 --> 20:17:31,680
Podemos fazer todos os tipos de coisas loucas com

30681
20:17:31,680 --> 20:17:33,440
Eles podemos fazê-los saltar para cima

30682
20:17:33,440 --> 20:17:35,920
Se estamos projetando um jogo, nós

30683
20:17:35,920 --> 20:17:38,480
pode fazê-los correr, podemos fazê-los voar

30684
20:17:38,480 --> 20:17:40,800
Podemos fazer todos os tipos de coisas loucas em

30685
20:17:40,800 --> 20:17:42,240
Esta palestra vamos usar um

30686
20:17:42,240 --> 20:17:44,720
cilindro como exemplo e vamos

30687
20:17:44,720 --> 20:17:48,000
para modelar um cilindro em nosso c plus

30688
20:17:48,000 --> 20:17:51,120
programa um cilindro é definido por dois

30689
20:17:51,120 --> 20:17:54,000
Coisas que tem um raio de base que é

30690
20:17:54,000 --> 20:17:56,872
modelado por este... você vê aqui e ele

30691
20:17:56,872 --> 20:17:58,240
Tem uma altura

30692
20:17:58,240 --> 20:18:00,720
Quando temos essas informações sobre

30693
20:18:00,720 --> 20:18:03,512
nosso cilindro nós podemos realmente fazer todos os tipos

30694
20:18:03,512 --> 20:18:05,280
de coisas loucas, por exemplo, podemos

30695
20:18:05,280 --> 20:18:08,552
calcular sua área na área de base e

30696
20:18:08,552 --> 20:18:10,872
Fórmula para fazer isso é pi

30697
20:18:10,872 --> 20:18:13,680
ao quadrado este é uma fórmula que você obtém de

30698
20:18:13,680 --> 20:18:16,400
sua educação matemática básica

30699
20:18:16,400 --> 20:18:18,160
você pode calcular o volume do

30700
20:18:18,160 --> 20:18:21,512
O cilindro e a fórmula para fazer isso é

30701
20:18:21,512 --> 20:18:24,160
área multiplicada pela altura e nós podemos

30702
20:18:24,160 --> 20:18:26,640
realmente fazer todos os tipos de coisas loucas com

30703
20:18:26,640 --> 20:18:30,000
o cilindro se tivermos essa informação

30704
20:18:30,000 --> 20:18:32,160
Vamos usar essa informação

30705
20:18:32,160 --> 20:18:35,680
e modelar um cilindro que podemos usar em nosso c

30706
20:18:35,680 --> 20:18:38,160
mais mais programa e nós vamos ser

30707
20:18:38,160 --> 20:18:41,040
usando aulas para fazer a sintaxe para

30708
20:18:41,040 --> 20:18:43,192
configurar a sua classe em c plus mais é

30709
20:18:43,192 --> 20:18:45,440
muito simples você diz que classe é este

30710
20:18:45,440 --> 20:18:48,552
palavra-chave que você tem que colocar aqui você diz

30711
20:18:48,552 --> 20:18:50,960
o nome da sua classe, neste caso,

30712
20:18:50,960 --> 20:18:53,680
é cilíria como você vê aqui e então nós

30713
20:18:53,680 --> 20:18:57,120
Coloque um par de chaves encaracoladas no lugar

30714
20:18:57,120 --> 20:18:59,760
começar no topo e o fim está para baixo

30715
20:18:59,760 --> 20:19:02,240
aqui e depois da sua definição de classe

30716
20:19:02,240 --> 20:19:04,320
Você vai colocar um ponto e vírgula dentro

30717
20:19:04,320 --> 20:19:07,120
A classe que realmente temos duas partes

30718
20:19:07,120 --> 20:19:09,440
ter variáveis de membro que estão indo para

30719
20:19:09,440 --> 20:19:11,600
modelar as propriedades que sua classe é

30720
20:19:11,600 --> 20:19:14,240
Teremos, neste caso, dois

30721
20:19:14,240 --> 20:19:16,872
Propriedades que realmente definem um cilindro

30722
20:19:16,872 --> 20:19:19,120
nós temos o melhor raio e nós temos o

30723
20:19:19,120 --> 20:19:21,760
altura, decidimos modelar estes

30724
20:19:21,760 --> 20:19:24,960
coisas como tipos duplos dentro da nossa classe

30725
20:19:24,960 --> 20:19:27,600
E isso vai fazer a primeira parte

30726
20:19:27,600 --> 20:19:30,720
de nossa classe, o membro variáveis o

30727
20:19:30,720 --> 20:19:33,280
A segunda parte será feita de

30728
20:19:33,280 --> 20:19:37,360
comportamentos ou funções que fazem as coisas

30729
20:19:37,360 --> 20:19:40,640
a classe usando as propriedades e uma

30730
20:19:40,640 --> 20:19:43,440
A função que temos é a função do volume

30731
20:19:43,440 --> 20:19:45,440
que nos ajudará a calcular o

30732
20:19:45,440 --> 20:19:48,720
volume do nosso cilindro aqui se você olhar

30733
20:19:48,720 --> 20:19:51,832
em sua sintaxe é realmente uma função que nós

30734
20:19:51,832 --> 20:19:54,000
Temos um tipo de retorno que temos o nome de

30735
20:19:54,000 --> 20:19:56,320
a função que temos a lista de parâmetros

30736
20:19:56,320 --> 20:19:58,320
que está vazio agora e nós temos o nosso

30737
20:19:58,320 --> 20:20:01,680
chaves encaradas que delimitam o corpo de

30738
20:20:01,680 --> 20:20:03,832
nossa função dentro da função que somos

30739
20:20:03,832 --> 20:20:05,440
Não vamos fazer nada de especial, estamos apenas

30740
20:20:05,440 --> 20:20:08,240
Vou devolver o volume do nosso

30741
20:20:08,240 --> 20:20:10,320
funcionar aqui e se você se lembrar do

30742
20:20:10,320 --> 20:20:13,040
O volume é a área de base

30743
20:20:13,040 --> 20:20:16,400
multiplicado pela altura e esta coisa

30744
20:20:16,400 --> 20:20:19,120
Aqui vai modelar a área de base que você

30745
20:20:19,120 --> 20:20:20,800
Veja que é pi

30746
20:20:20,800 --> 20:20:24,240
multiplicado pelo quadrado do raio

30747
20:20:24,240 --> 20:20:25,832
e então vamos multiplicar isso por

30748
20:20:25,832 --> 20:20:27,680
a altura e vamos devolver o

30749
20:20:27,680 --> 20:20:30,552
volume para uso por quem está chamando

30750
20:20:30,552 --> 20:20:32,000
Esta função

30751
20:20:32,000 --> 20:20:34,160
Uma coisa que realmente não falamos

30752
20:20:34,160 --> 20:20:36,720
É essa coisa pública que você vê aqui

30753
20:20:36,720 --> 20:20:40,080
O que isso diz é que os membros

30754
20:20:40,080 --> 20:20:42,160
que temos nesta classe vamos

30755
20:20:42,160 --> 20:20:44,960
ser acessível a partir do exterior do

30756
20:20:44,960 --> 20:20:47,512
classe por enquanto não podemos realmente entender

30757
20:20:47,512 --> 20:20:49,832
isso, mas quando atingimos o código do estúdio visual

30758
20:20:49,832 --> 20:20:52,160
Eu vou te mostrar o que exatamente isso

30759
20:20:52,160 --> 20:20:53,192
Os meios

30760
20:20:53,192 --> 20:20:55,680
Agora que temos a classe declarada

30761
20:20:55,680 --> 20:20:58,000
pode realmente usá-lo como usamos qualquer outro

30762
20:20:58,000 --> 20:21:00,552
tipos em c plus plus, por exemplo, podemos

30763
20:21:00,552 --> 20:21:03,120
cabeça em nossa principal função

30764
20:21:03,120 --> 20:21:05,280
e configurar uma variável chamada cilindro

30765
20:21:05,280 --> 20:21:07,512
Um como você vê aqui é que o tipo vai

30766
20:21:07,512 --> 20:21:10,080
ser cilindro e notar que este é

30767
20:21:10,080 --> 20:21:12,960
Realmente um tipo que nós mesmos construímos

30768
20:21:12,960 --> 20:21:15,120
e nós podemos realmente usá-lo como usamos

30769
20:21:15,120 --> 20:21:17,760
Outras variáveis, por exemplo, podemos chamar

30770
20:21:17,760 --> 20:21:20,552
funciona usando a sintaxe aqui e

30771
20:21:20,552 --> 20:21:22,720
imprimir o volume que isso vai imprimir

30772
20:21:22,720 --> 20:21:25,280
o volume usando a função de volume

30773
20:21:25,280 --> 20:21:27,832
que nós apenas configuramos em um minuto se formos

30774
20:21:27,832 --> 20:21:30,872
Podemos modificar as coisas sobre o nosso

30775
20:21:30,872 --> 20:21:33,512
cilindro, por exemplo, podemos usar o dot

30776
20:21:33,512 --> 20:21:36,320
notação aqui para alterar o raio base

30777
20:21:36,320 --> 20:21:38,480
e mudar a altura e se tentarmos

30778
20:21:38,480 --> 20:21:41,192
imprimir o volume novamente esta informação

30779
20:21:41,192 --> 20:21:43,512
vai ser pego e ser usado por

30780
20:21:43,512 --> 20:21:46,080
A função de volume para calcular o

30781
20:21:46,080 --> 20:21:48,480
volume do nosso cilindro aqui é

30782
20:21:48,480 --> 20:21:50,400
muito legal se você quiser você também pode definir

30783
20:21:50,400 --> 20:21:52,320
subir outro cilindro como fazemos aqui e

30784
20:21:52,320 --> 20:21:54,240
Vamos imprimir o volume e nós

30785
20:21:54,240 --> 20:21:56,872
Pode realmente fazer todos os tipos de coisas loucas

30786
20:21:56,872 --> 20:21:59,192
com nossos tipos como este, tudo bem, isso é

30787
20:21:59,192 --> 20:22:01,760
nossa classe e podemos realmente usá-la para fazer

30788
20:22:01,760 --> 20:22:04,800
muito antes de irmos para o visual

30789
20:22:04,800 --> 20:22:07,280
código de estúdio e jogar com a gente eu quero

30790
20:22:07,280 --> 20:22:09,920
Trai à vossa atenção que os membros de

30791
20:22:09,920 --> 20:22:11,280
uma classe

30792
20:22:11,280 --> 20:22:14,240
são privados por padrão e o que eu quero dizer

30793
20:22:14,240 --> 20:22:16,800
Por isso é isso, por exemplo, se não o fizermos

30794
20:22:16,800 --> 20:22:19,832
Coloque essas palavras-chave públicas aqui que queremos

30795
20:22:19,832 --> 20:22:21,192
para poder

30796
20:22:21,192 --> 20:22:24,080
para usar a função de volume, por exemplo

30797
20:22:24,080 --> 20:22:27,280
Como temos usado em nosso principal

30798
20:22:27,280 --> 20:22:30,000
Função como você vê aqui

30799
20:22:30,000 --> 20:22:32,480
Se o membro é privado, não será

30800
20:22:32,480 --> 20:22:35,280
utilizável fora da classe é isso que nós

30801
20:22:35,280 --> 20:22:37,512
Aqui estamos tentando usar isso

30802
20:22:37,512 --> 20:22:39,832
Membro na função principal

30803
20:22:39,832 --> 20:22:42,400
fora da definição da classe não será

30804
20:22:42,400 --> 20:22:45,360
acessível se é privado e nós fazemos

30805
20:22:45,360 --> 20:22:48,400
publicando ao colocar a palavra-chave pública

30806
20:22:48,400 --> 20:22:50,480
e a coluna como fazemos aqui

30807
20:22:50,480 --> 20:22:52,720
tudo depois dessa palavra-chave pública é

30808
20:22:52,720 --> 20:22:55,120
Vai ser público até que mudemos isso

30809
20:22:55,120 --> 20:22:57,512
para privado em algum lugar em nosso programa se

30810
20:22:57,512 --> 20:23:00,400
Precisamos disso agora que você tem uma ideia

30811
20:23:00,400 --> 20:23:02,800
Como você pode declarar e usar o seu

30812
20:23:02,800 --> 20:23:05,600
classe em c plus plus vamos cabeça para

30813
20:23:05,600 --> 20:23:07,440
código de estúdio visual e jogar com a gente um

30814
20:23:07,440 --> 20:23:10,240
Um pouco mais bem aqui estamos em nosso

30815
20:23:10,240 --> 20:23:12,720
pasta de trabalho o projeto atual é

30816
20:23:12,720 --> 20:23:14,872
sua primeira aula que você vai construir

30817
20:23:14,872 --> 20:23:17,360
sua primeira classe em c plus plus

30818
20:23:17,360 --> 20:23:19,760
nós vamos pegar nossos arquivos de modelo

30819
20:23:19,760 --> 20:23:22,080
nós vamos copiá-los e colocá-los dentro

30820
20:23:22,080 --> 20:23:24,400
lugar e então vamos abrir isso

30821
20:23:24,400 --> 20:23:26,720
um garrinho no código do estúdio visual por

30822
20:23:26,720 --> 20:23:29,120
arrastando e soltando aqui isso está indo

30823
20:23:29,120 --> 20:23:31,040
para abrir nossa pasta, vamos fechar

30824
20:23:31,040 --> 20:23:33,440
o painel esquerdo aqui e limpar as coisas um

30825
20:23:33,440 --> 20:23:35,760
Um pouco a primeira coisa que queremos fazer

30826
20:23:35,760 --> 20:23:38,872
É declarar nossa classe

30827
20:23:38,872 --> 20:23:40,640
Mas antes de fazermos isso, vamos

30828
20:23:40,640 --> 20:23:43,040
Preciso da variável pi porque lembre-se

30829
20:23:43,040 --> 20:23:45,120
nós vamos modelar pi

30830
20:23:45,120 --> 20:23:48,000
para uso na computação da área e

30831
20:23:48,000 --> 20:23:51,192
volume do nosso cilindro que queremos

30832
20:23:51,192 --> 20:23:53,280
modelo como fizemos nos slides, então o

30833
20:23:53,280 --> 20:23:54,960
Como nós vamos fazer isso eu vou

30834
20:23:54,960 --> 20:23:57,192
Declarar uma variável const e eu vou

30835
20:23:57,192 --> 20:23:58,720
para chamá-lo de pi

30836
20:23:58,720 --> 20:24:01,120
e vou inicializar isso com

30837
20:24:01,120 --> 20:24:04,480
pi para obter pi eu vou enganar um pouco

30838
20:24:04,480 --> 20:24:07,280
bit eu vou na minha calculadora e

30839
20:24:07,280 --> 20:24:10,240
Vamos ver se eu posso chegar aqui e eu

30840
20:24:10,240 --> 20:24:12,480
Clique sobre isso e eu vou pegar pi

30841
20:24:12,480 --> 20:24:15,040
aqui e copiá-lo, esta é a maneira mais fácil

30842
20:24:15,040 --> 20:24:17,832
Eu posso encontrar para que eu vá colocá-lo

30843
20:24:17,832 --> 20:24:19,680
Aqui e isso vai ser nosso

30844
20:24:19,680 --> 20:24:21,760
variável agora que nós temos isso nós somos

30845
20:24:21,760 --> 20:24:24,320
Vou montar a nossa classe e isso para

30846
20:24:24,320 --> 20:24:27,512
Defina uma classe que você diz classe que você tem que

30847
20:24:27,512 --> 20:24:29,760
colocar esta palavra-chave e, em seguida, estamos indo

30848
20:24:29,760 --> 20:24:31,600
dizer o nome da classe o nome de

30849
20:24:31,600 --> 20:24:34,160
a classe vai ser cilindro e

30850
20:24:34,160 --> 20:24:36,160
Depois que fizermos isso, vamos colocar um

30851
20:24:36,160 --> 20:24:38,960
Um par de chaves encaracoladas e nós vamos

30852
20:24:38,960 --> 20:24:41,440
acabar com um semi-cólon que você tem que

30853
20:24:41,440 --> 20:24:43,680
Lembre-se disso se você não colocá-lo aqui

30854
20:24:43,680 --> 20:24:45,920
o ziploc plus compilador vai

30855
20:24:45,920 --> 20:24:47,120
Queixar-se de

30856
20:24:47,120 --> 20:24:49,832
Agora que temos o projeto de classe

30857
20:24:49,832 --> 20:24:51,920
Aqui vamos colocar em nosso membro

30858
20:24:51,920 --> 20:24:53,680
variável e estes serão os

30859
20:24:53,680 --> 20:24:56,320
variáveis que usamos para modelar a base

30860
20:24:56,320 --> 20:24:58,960
raio e a altura do nosso cilindro

30861
20:24:58,960 --> 20:25:01,040
vamos colocar uma variável dupla

30862
20:25:01,040 --> 20:25:03,120
e vamos chamar esse raio de base

30863
20:25:03,120 --> 20:25:05,512
e nós vamos preparar a inicialização disso

30864
20:25:05,512 --> 20:25:07,760
Para zero nós podemos fazer isso e nós estamos indo

30865
20:25:07,760 --> 20:25:10,240
para montar outro e chamá-lo de altura

30866
20:25:10,240 --> 20:25:12,480
e nós também vamos inicializar isso

30867
20:25:12,480 --> 20:25:14,400
para zero ok agora que temos isso nós somos

30868
20:25:14,400 --> 20:25:17,512
vamos colocar funções ou métodos em nosso

30869
20:25:17,512 --> 20:25:20,000
classe e nós fazemos isso apenas colocando o

30870
20:25:20,000 --> 20:25:22,400
definição de função em nossa classe, então

30871
20:25:22,400 --> 20:25:24,872
A função vai devolver o dobro

30872
20:25:24,872 --> 20:25:26,640
Porque vai devolver o

30873
20:25:26,640 --> 20:25:27,832
o volume

30874
20:25:27,832 --> 20:25:30,800
do nosso cilindro, então ele vai voltar

30875
20:25:30,800 --> 20:25:32,400
O nome vai ser duplo

30876
20:25:32,400 --> 20:25:34,960
volume e vai ser computação

30877
20:25:34,960 --> 20:25:37,360
O volume e retorno que lembram

30878
20:25:37,360 --> 20:25:40,080
A fórmula para calcular o volume

30879
20:25:40,080 --> 20:25:42,960
vai ser pi nós temos uma variável pi

30880
20:25:42,960 --> 20:25:45,440
em cima e vamos multiplicar por

30881
20:25:45,440 --> 20:25:48,160
este raio duas vezes porque a base

30882
20:25:48,160 --> 20:25:50,800
O raio tem que ser quadrado, vamos fazer isso

30883
20:25:50,800 --> 20:25:53,040
e multiplicar pelo raio de base novamente e

30884
20:25:53,040 --> 20:25:55,040
Então vamos multiplicar por altura

30885
20:25:55,040 --> 20:25:58,320
e note que estes são os caras declarados

30886
20:25:58,320 --> 20:26:00,552
no corpo da classe se eu posso dizer

30887
20:26:00,552 --> 20:26:02,872
Esta é a definição da classe

30888
20:26:02,872 --> 20:26:05,280
Somos capazes de usar esses caras porque nós

30889
20:26:05,280 --> 20:26:08,160
Estão dentro desta classe aqui, tudo bem agora que

30890
20:26:08,160 --> 20:26:10,480
nós temos isso a nossa classe é realmente definida

30891
20:26:10,480 --> 20:26:13,360
mas não podemos realmente usá-lo ainda

30892
20:26:13,360 --> 20:26:15,512
O que quero dizer com isso vamos entrar no

30893
20:26:15,512 --> 20:26:17,600
função principal e vamos configurar

30894
20:26:17,600 --> 20:26:20,240
uma variável do cilindro do tipo que podemos fazer

30895
20:26:20,240 --> 20:26:23,680
Isso e vamos chamar este cilindro um se

30896
20:26:23,680 --> 20:26:26,400
nós fazemos isso e tentamos compilar isso

30897
20:26:26,400 --> 20:26:28,320
Vai trabalhar bem, vamos fazer isso

30898
20:26:28,320 --> 20:26:29,440
nós vamos

30899
20:26:29,440 --> 20:26:31,512
Mundo com o Gcc

30900
20:26:31,512 --> 20:26:33,440
O mundo terminou com sucesso este é

30901
20:26:33,440 --> 20:26:36,000
soldagem mas nós temos uma função chamada

30902
20:26:36,000 --> 20:26:38,800
volume aqui e podemos tentar chamá-lo

30903
20:26:38,800 --> 20:26:42,000
usando a notação de pontos que vimos em

30904
20:26:42,000 --> 20:26:44,080
Os slides vamos tentar imprimir o

30905
20:26:44,080 --> 20:26:46,800
volume do nosso cilindro aqui e ver o que

30906
20:26:46,800 --> 20:26:48,872
nós temos, então nós vamos dizer volume nós

30907
20:26:48,872 --> 20:26:50,720
pode salvar isso e vamos dizer

30908
20:26:50,720 --> 20:26:53,600
cilindro um e fazer o volume ok

30909
20:26:53,600 --> 20:26:55,600
Veja se podemos chamar essa função aqui

30910
20:26:55,600 --> 20:26:57,440
E no momento em que fazemos que você vê que

30911
20:26:57,440 --> 20:27:00,552
temos uma linha muito lenta aqui tão visual

30912
20:27:00,552 --> 20:27:02,800
O código do estúdio detectou que algo

30913
20:27:02,800 --> 20:27:05,512
está errado, vamos bater a guia de problemas aqui

30914
20:27:05,512 --> 20:27:08,000
e ver o que temos, vai dizer

30915
20:27:08,000 --> 20:27:12,552
esperava um identificador on-line o que isso

30916
20:27:12,552 --> 20:27:14,720
Não está fazendo sentido

30917
20:27:14,720 --> 20:27:17,680
uh colocamos três colunas aqui vamos

30918
20:27:17,680 --> 20:27:19,440
Corrige isso um pouco

30919
20:27:19,440 --> 20:27:23,192
e o erro vai mudar para ser

30920
20:27:23,192 --> 20:27:26,320
de repente o volume declarado na linha 6

30921
20:27:26,320 --> 20:27:29,192
é inacessível a partir deste local aqui

30922
20:27:29,192 --> 20:27:31,832
Isto é o que diz o erro e é

30923
20:27:31,832 --> 20:27:33,192
Não é sensato

30924
20:27:33,192 --> 20:27:36,800
Porque os membros da classe são privados

30925
20:27:36,800 --> 20:27:40,000
por padrão, eles querem estar acessíveis

30926
20:27:40,000 --> 20:27:42,080
do lado de fora da classe como nós

30927
20:27:42,080 --> 20:27:44,160
estão fazendo na função principal aqui

30928
20:27:44,160 --> 20:27:46,960
Percebe que somos capazes de acessá-los

30929
20:27:46,960 --> 20:27:48,640
do interior da classe que você vê

30930
20:27:48,640 --> 20:27:51,600
O raio da base é declarado aqui em baixo e nós

30931
20:27:51,600 --> 20:27:53,760
são capazes de usar na função porque

30932
20:27:53,760 --> 20:27:56,240
O volume da função aqui está dentro do

30933
20:27:56,240 --> 20:27:59,680
classe para que os membros sejam acessíveis mesmo

30934
20:27:59,680 --> 20:28:02,160
se eles são privados, mas membros privados

30935
20:28:02,160 --> 20:28:04,552
Não pode ser acessível a partir do exterior de

30936
20:28:04,552 --> 20:28:06,872
A classe como estamos fazendo no principal

30937
20:28:06,872 --> 20:28:08,552
Função aqui é por isso que temos isso

30938
20:28:08,552 --> 20:28:10,800
problema, vamos ver o que o compilador diz

30939
20:28:10,800 --> 20:28:13,192
nós vamos passar por isso através de gcc e

30940
20:28:13,192 --> 20:28:14,960
vamos ter um erro de compilador que

30941
20:28:14,960 --> 20:28:18,320
e o compilador é realmente

30942
20:28:18,320 --> 20:28:20,640
específico sobre isso vai dizer

30943
20:28:20,640 --> 20:28:23,192
Volume duplo do cilindro o volume

30944
20:28:23,192 --> 20:28:26,080
A função da classe do cilindro é

30945
20:28:26,080 --> 20:28:28,872
privado dentro deste contexto e que

30946
20:28:28,872 --> 20:28:31,920
contexto a linha 19 quando estamos tentando

30947
20:28:31,920 --> 20:28:34,640
para usá-lo na função principal, então se você

30948
20:28:34,640 --> 20:28:37,280
realmente quero agradecer dentro da classe para

30949
20:28:37,280 --> 20:28:40,320
ser acessível a partir do exterior que você precisa

30950
20:28:40,320 --> 20:28:43,120
para torná-los públicos e mudá-los de

30951
20:28:43,120 --> 20:28:45,920
privado como fazemos que é realmente

30952
20:28:45,920 --> 20:28:47,920
simples você usa a sintaxe que vimos no

30953
20:28:47,920 --> 20:28:50,000
slides nós vamos dizer público e colocar

30954
20:28:50,000 --> 20:28:53,040
uma coluna aqui e quando você faz isso é

30955
20:28:53,040 --> 20:28:55,512
Aconselhado para alinhar suas coisas um pouco

30956
20:28:55,512 --> 20:28:58,400
bit corretamente quando fazemos isso

30957
20:28:58,400 --> 20:29:01,440
tudo depois dessa palavra-chave pública é

30958
20:29:01,440 --> 20:29:04,160
Vai ser público nesta classe e

30959
20:29:04,160 --> 20:29:07,440
será acessível a partir do exterior

30960
20:29:07,440 --> 20:29:09,360
Vamos tentar construir agora, mas antes de nós

30961
20:29:09,360 --> 20:29:11,512
construir vamos te mostrar que o squiggly

30962
20:29:11,512 --> 20:29:14,480
A linha deve ter ido ao código do estúdio visual

30963
20:29:14,480 --> 20:29:17,280
Ainda está confuso, vamos tentar vault

30964
20:29:17,280 --> 20:29:19,512
Vamos passar isso através do gcc agora você vê

30965
20:29:19,512 --> 20:29:21,832
que o mundo é bom agora se você

30966
20:29:21,832 --> 20:29:23,680
Tente imprimir o volume aqui que estamos

30967
20:29:23,680 --> 20:29:26,160
vai ter zero porque a base

30968
20:29:26,160 --> 20:29:29,192
o raio é preparado inicializado para zero o

30969
20:29:29,192 --> 20:29:31,680
a altura é zero e se multiplicarmos como

30970
20:29:31,680 --> 20:29:33,120
Isso nós vamos ter um zero e

30971
20:29:33,120 --> 20:29:35,760
Retorne isso, vamos tentar correr isso

30972
20:29:35,760 --> 20:29:37,832
programa porque nós apenas o construímos

30973
20:29:37,832 --> 20:29:40,160
Podemos trazer um terminal

30974
20:29:40,160 --> 20:29:43,280
para fazer isso e vamos limpar e correr

30975
20:29:43,280 --> 20:29:45,832
Galo e podemos ver que o volume

30976
20:29:45,832 --> 20:29:48,640
é zero e é o que esperamos bem

30977
20:29:48,640 --> 20:29:50,960
Agora nossa classe está funcionando, mas há

30978
20:29:50,960 --> 20:29:54,000
Realmente algo ruim sobre isso e

30979
20:29:54,000 --> 20:29:57,120
porque a palavra-chave pública é

30980
20:29:57,120 --> 20:29:59,360
Vou tornar tudo público nisso

30981
20:29:59,360 --> 20:30:01,512
classe das variáveis membros também são

30982
20:30:01,512 --> 20:30:04,080
Vou ser público para que possamos descer

30983
20:30:04,080 --> 20:30:06,080
aqui e imprimir o raio da base e o

30984
20:30:06,080 --> 20:30:08,000
a altura, por exemplo, vamos fazer isso e

30985
20:30:08,000 --> 20:30:10,240
mostrar a você que este é o caso, então estamos

30986
20:30:10,240 --> 20:30:12,800
Vou dizer cilindro um e dizer base

30987
20:30:12,800 --> 20:30:15,760
raio isso vai imprimir e nós estamos

30988
20:30:15,760 --> 20:30:18,400
Vou dizer olá, vamos imprimir

30989
20:30:18,400 --> 20:30:21,040
isso se tentarmos imprimir esses caras

30990
20:30:21,040 --> 20:30:23,832
Vamos construir e passar por isso através do gcc

30991
20:30:23,832 --> 20:30:26,400
você vê o parafuso é bom e se nós limpamos

30992
20:30:26,400 --> 20:30:28,480
e correr o galo, vamos ver isso

30993
20:30:28,480 --> 20:30:31,680
Este raio e altura são ou acessíveis

30994
20:30:31,680 --> 20:30:33,600
para mostrar que isso também pode ser

30995
20:30:33,600 --> 20:30:36,000
diferente de zero, vamos mudar o

30996
20:30:36,000 --> 20:30:38,640
raio de base para um e a altura para um

30997
20:30:38,640 --> 20:30:42,320
para torná-lo um cilindro de unidade, vamos tentar

30998
20:30:42,320 --> 20:30:44,480
solda, vamos mudar esses caras para

30999
20:30:44,480 --> 20:30:46,920
Um e o volume vai ser

31000
20:30:46,920 --> 20:30:49,832
3.14 ou algo vamos correr galo

31001
20:30:49,832 --> 20:30:52,160
Vamos ver o nosso volume aqui e

31002
20:30:52,160 --> 20:30:54,480
nós temos o raio base e a altura

31003
20:30:54,480 --> 20:30:57,360
Mas isso é realmente um design ruim, porque

31004
20:30:57,360 --> 20:30:59,120
as variáveis do membro

31005
20:30:59,120 --> 20:31:01,192
Na maioria dos casos, você vai querer

31006
20:31:01,192 --> 20:31:04,160
mantê-los privados do exterior

31007
20:31:04,160 --> 20:31:07,040
porque os usuários da sua classe realmente não

31008
20:31:07,040 --> 20:31:09,120
preocupam-se com as variáveis dos membros

31009
20:31:09,120 --> 20:31:11,040
Só quero fazer coisas com sua classe

31010
20:31:11,040 --> 20:31:12,872
Por exemplo, chamar a função de volume

31011
20:31:12,872 --> 20:31:15,512
Aqui, então o que costumamos fazer em

31012
20:31:15,512 --> 20:31:18,720
A prática é sinalizar nossas variáveis de membro

31013
20:31:18,720 --> 20:31:21,280
como privado e podemos fazer isso usando a

31014
20:31:21,280 --> 20:31:24,080
palavra-chave privada como fazemos aqui e no

31015
20:31:24,080 --> 20:31:27,192
momento em que fazemos tudo isso depois disso

31016
20:31:27,192 --> 20:31:29,512
A palavra-chave privada será privada

31017
20:31:29,512 --> 20:31:31,920
para a classe que só vai ser

31018
20:31:31,920 --> 20:31:34,400
acessível a partir do interior da classe

31019
20:31:34,400 --> 20:31:36,552
mas se tentarmos acessar isso a partir do

31020
20:31:36,552 --> 20:31:38,320
Fora, nós vamos ter o mesmo

31021
20:31:38,320 --> 20:31:41,280
Erro do compilador que vimos antes, quando

31022
20:31:41,280 --> 20:31:44,320
tentou acessar coisas privadas a partir do

31023
20:31:44,320 --> 20:31:46,320
classe na função principal aqui visual

31024
20:31:46,320 --> 20:31:48,000
O código do estúdio vai nos dar uma

31025
20:31:48,000 --> 20:31:49,920
O problema diz que esses membros

31026
20:31:49,920 --> 20:31:52,640
As variáveis não são acessíveis a partir disso

31027
20:31:52,640 --> 20:31:54,960
contexto aqui e se passarmos por isso

31028
20:31:54,960 --> 20:31:57,512
gcc vamos ter um compilador claro

31029
20:31:57,512 --> 20:32:00,160
Erro dizendo que a altura

31030
20:32:00,160 --> 20:32:01,600
E o

31031
20:32:01,600 --> 20:32:04,720
O raio da base agora é privado na classe

31032
20:32:04,720 --> 20:32:07,120
E não podemos acessá-los a partir do

31033
20:32:07,120 --> 20:32:09,280
Fora isso é realmente o que eu queria você

31034
20:32:09,280 --> 20:32:12,080
para ver e este é um bom design ok agora

31035
20:32:12,080 --> 20:32:14,640
que temos nossa classe declarada e que

31036
20:32:14,640 --> 20:32:16,960
nós podemos usá-lo na função principal i

31037
20:32:16,960 --> 20:32:19,440
Quer que você veja que é possível

31038
20:32:19,440 --> 20:32:22,160
alterar essas variáveis de membro, mas fazer

31039
20:32:22,160 --> 20:32:24,720
que precisaremos virar isso de volta para

31040
20:32:24,720 --> 20:32:26,400
público e vamos ver um melhor

31041
20:32:26,400 --> 20:32:29,120
maneira de fazer isso mais tarde, mas por agora vamos

31042
20:32:29,120 --> 20:32:30,872
torná-los públicos e mostrar a você que nós

31043
20:32:30,872 --> 20:32:33,512
pode mudar as coisas ao redor e fazer o nosso

31044
20:32:33,512 --> 20:32:35,760
Cilindros um pouco mais interessantes, então

31045
20:32:35,760 --> 20:32:37,760
Agora que eles são públicos, podemos entrar

31046
20:32:37,760 --> 20:32:40,160
A principal função e fazer coisas loucas

31047
20:32:40,160 --> 20:32:42,240
Alterar os dados, por exemplo, nós podemos

31048
20:32:42,240 --> 20:32:44,240
Mudar nossas variáveis de membro para ser

31049
20:32:44,240 --> 20:32:46,400
Algo mais vamos descer e dizer

31050
20:32:46,400 --> 20:32:49,832
cilindro um e dizer raio de base que podemos

31051
20:32:49,832 --> 20:32:53,040
Use a notação de ponto e coloque um sinal ecológico

31052
20:32:53,040 --> 20:32:55,280
e dar outro valor à nossa base

31053
20:32:55,280 --> 20:32:58,800
raio vamos fazer 10, por exemplo, e

31054
20:32:58,800 --> 20:33:01,120
mudar a altura para ser outra coisa

31055
20:33:01,120 --> 20:33:03,192
nós podemos mudar isso e nós vamos

31056
20:33:03,192 --> 20:33:06,480
colocar em um 3, por exemplo, por que não agora se nós

31057
20:33:06,480 --> 20:33:08,480
imprimir o volume novamente, vamos

31058
20:33:08,480 --> 20:33:10,640
obter outro valor, vamos copiar isso e

31059
20:33:10,640 --> 20:33:12,400
Coloque isso lá embaixo

31060
20:33:12,400 --> 20:33:15,832
nossas mudanças aqui e se construirmos a

31061
20:33:15,832 --> 20:33:18,400
programa que deve definir o mundo

31062
20:33:18,400 --> 20:33:19,440
É bom

31063
20:33:19,440 --> 20:33:22,400
para que possamos entrar e limpar e se nós

31064
20:33:22,400 --> 20:33:24,240
correr galo que vamos conseguir

31065
20:33:24,240 --> 20:33:25,872
O volume a ser

31066
20:33:25,872 --> 20:33:29,600
3.14 primeiro aqui a primeira linha aqui e

31067
20:33:29,600 --> 20:33:31,280
A segunda linha vai nos dar

31068
20:33:31,280 --> 20:33:33,680
outro volume e se multiplicarmos estes

31069
20:33:33,680 --> 20:33:35,920
rapazes com o pi

31070
20:33:35,920 --> 20:33:38,320
e se usarmos a nossa fórmula para calcular o

31071
20:33:38,320 --> 20:33:39,920
volume, vamos basicamente obter o

31072
20:33:39,920 --> 20:33:42,480
A mesma coisa vamos tentar provar isso com

31073
20:33:42,480 --> 20:33:45,120
nossa calculadora temos por perto, então nós

31074
20:33:45,120 --> 20:33:48,240
Temos pi aqui vamos multiplicar

31075
20:33:48,240 --> 20:33:49,440
Isso com

31076
20:33:49,440 --> 20:33:51,440
100 que é

31077
20:33:51,440 --> 20:33:54,240
o raio quadrado que vamos colocar

31078
20:33:54,240 --> 20:33:56,640
100 aqui e nós vamos multiplicar

31079
20:33:56,640 --> 20:33:58,960
Isso com 3 que é a nossa altura, vamos

31080
20:33:58,960 --> 20:34:01,720
Coloque isso dentro e nós temos

31081
20:34:01,720 --> 20:34:04,320
942.47, que é o que temos aqui

31082
20:34:04,320 --> 20:34:06,400
aproximadamente a mesma coisa, então você vê isso

31083
20:34:06,400 --> 20:34:08,320
nossa função é realmente computar o nosso

31084
20:34:08,320 --> 20:34:10,800
volume que podemos cair e mudar

31085
20:34:10,800 --> 20:34:12,800
a altura a outra coisa, por exemplo

31086
20:34:12,800 --> 20:34:15,760
Vamos mudar a altura para

31087
20:34:15,760 --> 20:34:17,680
Vamos fazer um oito e eu imprimi o

31088
20:34:17,680 --> 20:34:19,760
volume novamente você pode continuar jogando com

31089
20:34:19,760 --> 20:34:22,400
Nós e realmente deixar claro

31090
20:34:22,400 --> 20:34:24,720
que nossa função de volume é computação

31091
20:34:24,720 --> 20:34:27,512
nosso volume usando os dados que temos

31092
20:34:27,512 --> 20:34:29,280
nas variáveis do membro, este é o

31093
20:34:29,280 --> 20:34:32,080
Mensagem aqui vamos construir novamente o mundo

31094
20:34:32,080 --> 20:34:34,240
Devemos ser bons, vamos limpar e

31095
20:34:34,240 --> 20:34:36,872
correr galo agora vemos outro

31096
20:34:36,872 --> 20:34:39,760
número para o nosso volume e isso é realmente

31097
20:34:39,760 --> 20:34:42,000
Como você pode declarar uma classe novamente você

31098
20:34:42,000 --> 20:34:43,920
Use a sintaxe que você vê aqui class você

31099
20:34:43,920 --> 20:34:46,720
Diga o nome da classe que você coloca um par de

31100
20:34:46,720 --> 20:34:49,120
Aparelhos encaracolados e você coloca seu ponto e vírgula

31101
20:34:49,120 --> 20:34:50,640
Não se esqueça disso

31102
20:34:50,640 --> 20:34:53,192
Os membros da sua classe são privados por

31103
20:34:53,192 --> 20:34:55,760
padrão, mas você pode torná-los públicos se

31104
20:34:55,760 --> 20:34:58,320
Você quer usar a palavra-chave pública como nós

31105
20:34:58,320 --> 20:35:00,240
Eu aqui dentro de sua classe você está indo

31106
20:35:00,240 --> 20:35:02,080
Para ter duas partes que você vai ter

31107
20:35:02,080 --> 20:35:03,920
As variáveis de membro que vão

31108
20:35:03,920 --> 20:35:06,800
sejam propriedades que definem o que você

31109
20:35:06,800 --> 20:35:09,360
A classe é e nós vamos ter

31110
20:35:09,360 --> 20:35:12,240
funções ou métodos, digamos, e

31111
20:35:12,240 --> 20:35:14,800
Estes serão comportamentos

31112
20:35:14,800 --> 20:35:17,280
de sua classe que você vai passar

31113
20:35:17,280 --> 20:35:19,832
essas funções para fazer suas aulas

31114
20:35:19,832 --> 20:35:21,920
Coisas e uma vez que você tem a classe

31115
20:35:21,920 --> 20:35:24,160
definição no lugar que você pode usá-lo para

31116
20:35:24,160 --> 20:35:25,120
Criar

31117
20:35:25,120 --> 20:35:27,600
variáveis como fazemos na função principal

31118
20:35:27,600 --> 20:35:30,320
aqui e as variáveis que criamos a partir de

31119
20:35:30,320 --> 20:35:33,040
nossa classe é geralmente chamada de objetos em

31120
20:35:33,040 --> 20:35:35,760
c plus mais terminologia OK the class

31121
20:35:35,760 --> 20:35:39,040
é realmente um modelo e nós criamos

31122
20:35:39,040 --> 20:35:42,480
objetos usando esse blueprint e objetos

31123
20:35:42,480 --> 20:35:45,360
teremos dados de tempo de execução que nós

31124
20:35:45,360 --> 20:35:47,440
armazenar em nossa classe ok, por exemplo

31125
20:35:47,440 --> 20:35:49,920
Se atingimos este ponto aqui a base

31126
20:35:49,920 --> 20:35:52,000
O raio vai ser 10 e a altura

31127
20:35:52,000 --> 20:35:54,000
vai ser oito e isso vai

31128
20:35:54,000 --> 20:35:57,512
ser informação em tempo de execução para a nossa classe

31129
20:35:57,512 --> 20:36:00,160
objeto armazenado nesta variável que nós

31130
20:36:00,160 --> 20:36:03,280
call cylinder one aqui este é realmente

31131
20:36:03,280 --> 20:36:05,680
O que eu queria que você visse ok, vamos tentar

31132
20:36:05,680 --> 20:36:08,080
e recapitular o que sabemos sobre as aulas, então

31133
20:36:08,080 --> 20:36:10,872
longe uma classe pode ter variáveis de membro

31134
20:36:10,872 --> 20:36:13,600
Mas até agora usamos variáveis de membros

31135
20:36:13,600 --> 20:36:16,080
como variáveis de pilha se voltarmos para

31136
20:36:16,080 --> 20:36:18,720
O exemplo você vê que dizemos raio de base

31137
20:36:18,720 --> 20:36:21,040
Aqui você percebe que não é um ponteiro ou um

31138
20:36:21,040 --> 20:36:23,192
Referência ou qualquer coisa que é uma pilha

31139
20:36:23,192 --> 20:36:26,000
variável dentro da nossa classe para membro

31140
20:36:26,000 --> 20:36:29,440
As variáveis só podem ser variáveis de pilha

31141
20:36:29,440 --> 20:36:32,320
Como nós temos aqui, mas eles também podem ser

31142
20:36:32,320 --> 20:36:34,640
Senhores, mas eles nunca podem ser

31143
20:36:34,640 --> 20:36:37,832
As referências e a razão são uma referência

31144
20:36:37,832 --> 20:36:41,040
Nunca pode ser deixado unnitorializado e em

31145
20:36:41,040 --> 20:36:42,960
As classes quando declaramos membro

31146
20:36:42,960 --> 20:36:45,600
variáveis a capacidade de deixá-los

31147
20:36:45,600 --> 20:36:48,480
O uninializado é muito importante e nós

31148
20:36:48,480 --> 20:36:50,872
Não posso realmente fazer isso com referências i

31149
20:36:50,872 --> 20:36:53,512
Não pode realmente entrar nos detalhes disso

31150
20:36:53,512 --> 20:36:56,240
como veremos isso à medida que avançamos em

31151
20:36:56,240 --> 20:36:58,480
O capítulo mas saiba que o membro

31152
20:36:58,480 --> 20:37:00,320
As variáveis podem ser empilhadas

31153
20:37:00,320 --> 20:37:03,040
variáveis ou ponteiros, mas eles nunca podem

31154
20:37:03,040 --> 20:37:05,760
ser referências em z mais OK que é o que

31155
20:37:05,760 --> 20:37:08,000
Acabámos de dizer aqui que os membros não podem ser

31156
20:37:08,000 --> 20:37:11,280
classes de referências podem ter funções ou

31157
20:37:11,280 --> 20:37:13,832
métodos que lhes permitem fazer coisas que vimos

31158
20:37:13,832 --> 20:37:16,400
Um exemplo disso com o nosso volume

31159
20:37:16,400 --> 20:37:19,192
Os métodos de classe de função têm acesso a

31160
20:37:19,192 --> 20:37:21,760
as variáveis do membro, independentemente de

31161
20:37:21,760 --> 20:37:24,000
se eles são públicos ou privados nós

31162
20:37:24,000 --> 20:37:26,720
tem visto que a função de volume vai

31163
20:37:26,720 --> 20:37:30,000
ter acesso às nossas variáveis de membro

31164
20:37:30,000 --> 20:37:32,400
independentemente de ser público ou

31165
20:37:32,400 --> 20:37:35,360
privado e por último, mas não menos privado

31166
20:37:35,360 --> 20:37:38,552
Os membros das aulas não estão acessíveis

31167
20:37:38,552 --> 20:37:40,872
do exterior como vimos no principal

31168
20:37:40,872 --> 20:37:43,120
Função que você não pode acessá-los a partir do

31169
20:37:43,120 --> 20:37:45,760
função principal você só pode fazer isso a partir de

31170
20:37:45,760 --> 20:37:47,760
A própria definição de classe é

31171
20:37:47,760 --> 20:37:49,600
Realmente tudo que eu tinha para compartilhar isso

31172
20:37:49,600 --> 20:37:52,000
Uma palestra espero que você tenha achado interessante

31173
20:37:52,000 --> 20:37:54,320
Vamos parar aqui nesta em

31174
20:37:54,320 --> 20:37:56,080
O próximo vamos ver como

31175
20:37:56,080 --> 20:37:58,960
Objetos de classe são construídos

31176
20:37:58,960 --> 20:38:01,440
dos construtores vão em frente e terminam

31177
20:38:01,440 --> 20:38:04,160
Aqui e encontre-me lá nesta palestra

31178
20:38:04,160 --> 20:38:06,800
Vamos aprender sobre construtores

31179
20:38:06,800 --> 20:38:10,080
e construtores são classe especial

31180
20:38:10,080 --> 20:38:12,240
Os métodos ou funções

31181
20:38:12,240 --> 20:38:15,120
que são chamados pelo compilador para

31182
20:38:15,120 --> 20:38:18,080
Construa seus objetos de classe e eles

31183
20:38:18,080 --> 20:38:20,720
são especiais porque não têm retorno

31184
20:38:20,720 --> 20:38:23,120
tipo um construtor nunca pode ter um

31185
20:38:23,120 --> 20:38:26,080
Tipo de retorno como você vê aqui que eles têm

31186
20:38:26,080 --> 20:38:28,400
O mesmo nome da classe, então para

31187
20:38:28,400 --> 20:38:31,040
O exemplo da nossa aula no último

31188
20:38:31,040 --> 20:38:33,600
A palestra que foi chamada silenciosa de

31189
20:38:33,600 --> 20:38:35,440
Os construtores também terão a

31190
20:38:35,440 --> 20:38:37,360
O mesmo nome da classe para a qual eles estão indo

31191
20:38:37,360 --> 20:38:41,040
ser chamado também construtores caluniadores podem

31192
20:38:41,040 --> 20:38:43,600
tem parâmetros, mas se faz sentido

31193
20:38:43,600 --> 20:38:46,080
Por tudo o que você está tentando fazer

31194
20:38:46,080 --> 20:38:48,480
Você também pode deixar os parâmetros de fora

31195
20:38:48,480 --> 20:38:51,512
e os construtores geralmente são usados para

31196
20:38:51,512 --> 20:38:54,552
inicializar as variáveis do membro e colocar

31197
20:38:54,552 --> 20:38:57,120
eles em um estado onde você os quer em

31198
20:38:57,120 --> 20:38:59,280
seu c plus mais aplicação

31199
20:38:59,280 --> 20:39:01,440
Veja como você pode declarar

31200
20:39:01,440 --> 20:39:03,680
construtores para suas aulas

31201
20:39:03,680 --> 20:39:06,720
Aqui está a nossa classe de cilindros que você vê

31202
20:39:06,720 --> 20:39:08,552
ter nossas variáveis de membro que tivemos

31203
20:39:08,552 --> 20:39:11,360
Somos privados agora e nós temos

31204
20:39:11,360 --> 20:39:13,512
uma seção pública que vai ter

31205
20:39:13,512 --> 20:39:15,760
nossas funções ou comportamentos como você vê

31206
20:39:15,760 --> 20:39:17,832
Aqui as variáveis do membro são o que nós

31207
20:39:17,832 --> 20:39:20,720
Viu na última palestra, mas se

31208
20:39:20,720 --> 20:39:24,080
Você olha aqui temos algumas coisas novas

31209
20:39:24,080 --> 20:39:24,872
Aqui

31210
20:39:24,872 --> 20:39:27,280
Temos duas coisas que parecem

31211
20:39:27,280 --> 20:39:29,440
funções, mas não têm retorno

31212
20:39:29,440 --> 20:39:30,960
valores que é algo que você deveria

31213
20:39:30,960 --> 20:39:32,000
a notificação

31214
20:39:32,000 --> 20:39:34,480
Eles têm uma lista de parâmetros como você vê

31215
20:39:34,480 --> 20:39:37,512
aqui e temos um par de chaves encaracoladas

31216
20:39:37,512 --> 20:39:39,680
porque estas são realmente funções e

31217
20:39:39,680 --> 20:39:41,920
Estas são funções especiais que são

31218
20:39:41,920 --> 20:39:44,640
vai ser chamado pelo compilador para

31219
20:39:44,640 --> 20:39:47,760
inicialize seus objetos de classe se você

31220
20:39:47,760 --> 20:39:50,552
Olhe aqui neste exemplo, nós somos

31221
20:39:50,552 --> 20:39:52,080
Usando o

31222
20:39:52,080 --> 20:39:54,320
construtor sem parâmetros para

31223
20:39:54,320 --> 20:39:57,120
inicialize nossas variáveis de membro para 2 e

31224
20:39:57,120 --> 20:39:59,680
Temos outro construtor como você vê

31225
20:39:59,680 --> 20:40:01,192
Aqui em baixo, o que vai levar

31226
20:40:01,192 --> 20:40:03,920
parâmetros diretamente e vai

31227
20:40:03,920 --> 20:40:06,320
tomar o parâmetro de raio e a altura

31228
20:40:06,320 --> 20:40:09,360
parâmetro que os parâmetros são duplos

31229
20:40:09,360 --> 20:40:11,512
tipo porque é isso que esperamos em

31230
20:40:11,512 --> 20:40:14,000
nossa classe e estamos passando por eles

31231
20:40:14,000 --> 20:40:16,480
valor aqui porque eles são fundamentais

31232
20:40:16,480 --> 20:40:18,872
tipos e nós realmente não nos importamos em copiar

31233
20:40:18,872 --> 20:40:20,960
Eles, mas por favor, tenham em mente que eles

31234
20:40:20,960 --> 20:40:23,832
serão passados pelo valor e o que

31235
20:40:23,832 --> 20:40:26,800
Você tem dentro do seu corpo construtor

31236
20:40:26,800 --> 20:40:30,160
serão cópias do original

31237
20:40:30,160 --> 20:40:32,240
argumentos que foram passados para o seu

31238
20:40:32,240 --> 20:40:34,320
construtor e isso é realmente como você

31239
20:40:34,320 --> 20:40:37,120
Declarar construtores para o seu c plus

31240
20:40:37,120 --> 20:40:39,120
Construtores de classe plus podem

31241
20:40:39,120 --> 20:40:41,440
ter parâmetros como temos novamente em

31242
20:40:41,440 --> 20:40:44,320
Este exemplo aqui ou eles podem não ter

31243
20:40:44,320 --> 20:40:46,640
Parâmetros e isso vai ser um

31244
20:40:46,640 --> 20:40:48,480
Construtor padrão que vamos ver

31245
20:40:48,480 --> 20:40:50,872
que isso vai ser chamado quando você

31246
20:40:50,872 --> 20:40:52,320
Tente criar

31247
20:40:52,320 --> 20:40:55,680
variáveis deste tipo de cilindro sem

31248
20:40:55,680 --> 20:40:58,240
passando o parêntese como nós fazemos quando

31249
20:40:58,240 --> 20:40:59,920
Chamamos a este segundo construtor aqui

31250
20:40:59,920 --> 20:41:01,512
nós vamos ver isso em um minuto bem

31251
20:41:01,512 --> 20:41:03,600
Isso é tudo que eu acho que eu tenho que compartilhar

31252
20:41:03,600 --> 20:41:05,440
Os slides sobre como você declara

31253
20:41:05,440 --> 20:41:08,000
construtores vamos nos dirigir ao visual

31254
20:41:08,000 --> 20:41:09,680
código de estúdio e jogar com isso um pouco

31255
20:41:09,680 --> 20:41:12,320
Mais bem aqui estamos em nosso trabalho

31256
20:41:12,320 --> 20:41:14,320
pasta do projeto atual é

31257
20:41:14,320 --> 20:41:17,680
construtores que vamos colocar em nosso

31258
20:41:17,680 --> 20:41:20,000
arquivos de modelo muito rápido, vamos fazer

31259
20:41:20,000 --> 20:41:22,000
Isso e nós vamos abrir isso em

31260
20:41:22,000 --> 20:41:24,320
código visual do estúdio arrastando e

31261
20:41:24,320 --> 20:41:26,240
caindo em cima aqui

31262
20:41:26,240 --> 20:41:28,552
isso vai abrir nossa pasta, vamos

31263
20:41:28,552 --> 20:41:31,760
abrir o nosso arquivo cpp principal

31264
20:41:31,760 --> 20:41:33,280
e nós vamos tirar o que nós

31265
20:41:33,280 --> 20:41:35,832
Não precisa da função principal e em

31266
20:41:35,832 --> 20:41:39,040
no topo aqui e eu vou reutilizar o código

31267
20:41:39,040 --> 20:41:40,960
da última palestra porque não

31268
20:41:40,960 --> 20:41:43,600
Quero digitar isso novamente, então vamos colocar

31269
20:41:43,600 --> 20:41:45,512
nossa definição de classe que temos

31270
20:41:45,512 --> 20:41:48,320
variável pi que vai ser usado para

31271
20:41:48,320 --> 20:41:51,360
calcular o volume na classe aqui e

31272
20:41:51,360 --> 20:41:53,680
temos variáveis de membro ok agora que

31273
20:41:53,680 --> 20:41:56,080
Estamos aqui vamos mudar o membro

31274
20:41:56,080 --> 20:41:58,720
variáveis para ser privado porque fazer

31275
20:41:58,720 --> 20:42:01,280
Eles públicos vão realmente ser maus

31276
20:42:01,280 --> 20:42:03,680
desenhei que vai expô-los no

31277
20:42:03,680 --> 20:42:05,760
função principal e as pessoas podem mexer com

31278
20:42:05,760 --> 20:42:08,800
eles e realmente mudar a lógica de como

31279
20:42:08,800 --> 20:42:12,480
nossa classe funciona sem o nosso conceito

31280
20:42:12,480 --> 20:42:14,872
É aconselhado a fazer suas variáveis de membro

31281
20:42:14,872 --> 20:42:17,120
privado a menos que você realmente tenha um

31282
20:42:17,120 --> 20:42:20,080
Razões convincentes para torná-los públicos

31283
20:42:20,080 --> 20:42:22,872
Tudo bem agora que temos nossa classe aqui

31284
20:42:22,872 --> 20:42:24,960
Vamos criar construtores para isso

31285
20:42:24,960 --> 20:42:26,552
nós vamos descer aqui no

31286
20:42:26,552 --> 20:42:29,040
âmbito público e dizer construtores e

31287
20:42:29,040 --> 20:42:30,872
Vamos montar o primeiro

31288
20:42:30,872 --> 20:42:33,040
construtor que não vai levar

31289
20:42:33,040 --> 20:42:35,360
qualquer parâmetro, então vamos dizer o

31290
20:42:35,360 --> 20:42:37,512
O nome da classe lembra um construtor

31291
20:42:37,512 --> 20:42:40,320
não tem um tipo de retorno e tem que

31292
20:42:40,320 --> 20:42:43,360
ter o mesmo nome que a classe, então nós

31293
20:42:43,360 --> 20:42:45,192
Precisamos cumprir com isso e nós vamos

31294
20:42:45,192 --> 20:42:48,720
para colocar nosso par de chaves encaracoladas e

31295
20:42:48,720 --> 20:42:50,240
Por dentro, vamos inicializar o nosso

31296
20:42:50,240 --> 20:42:53,192
No entanto, as variáveis queremos, então o que

31297
20:42:53,192 --> 20:42:54,480
nós vamos fazer aqui nós vamos

31298
20:42:54,480 --> 20:42:57,440
definir o raio de base para algo vamos

31299
20:42:57,440 --> 20:43:00,480
torná-lo um 2 como vimos nos slides não

31300
20:43:00,480 --> 20:43:02,400
problema com isso e vamos definir

31301
20:43:02,400 --> 20:43:04,640
a altura a outra coisa e nós somos

31302
20:43:04,640 --> 20:43:07,192
para definir a altura para 2 também nós

31303
20:43:07,192 --> 20:43:10,160
Você pode fazer isso para que você possa usar o que quiser

31304
20:43:10,160 --> 20:43:13,192
E agora temos o nosso construtor e ele

31305
20:43:13,192 --> 20:43:16,000
está inicializando nossos agradecimentos, agora que

31306
20:43:16,000 --> 20:43:18,400
Temos o construtor no lugar

31307
20:43:18,400 --> 20:43:20,800
Como é realmente chamado pelo compilador

31308
20:43:20,800 --> 20:43:23,832
e note que nosso construtor está em

31309
20:43:23,832 --> 20:43:26,480
âmbito público da classe

31310
20:43:26,480 --> 20:43:28,960
Se não é público, você quer ser capaz

31311
20:43:28,960 --> 20:43:31,600
para acessá-lo do exterior e do

31312
20:43:31,600 --> 20:43:34,320
O compilador não conseguirá construir seus objetos

31313
20:43:34,320 --> 20:43:36,080
E nós vamos ver isso em um minuto

31314
20:43:36,080 --> 20:43:38,000
Mas antes de fazermos isso, vamos tentar

31315
20:43:38,000 --> 20:43:40,400
criar um objeto de cilindro agora, então nós somos

31316
20:43:40,400 --> 20:43:42,800
Vou dizer cilindro e dizer cilindro

31317
20:43:42,800 --> 20:43:45,360
Um como fizemos na última palestra

31318
20:43:45,360 --> 20:43:48,720
e quando fazemos isso notar o que vemos

31319
20:43:48,720 --> 20:43:52,640
se imprimirmos o volume do nosso cilindro

31320
20:43:52,640 --> 20:43:55,280
objeto aqui este é um objeto porque

31321
20:43:55,280 --> 20:43:58,240
Estamos criando isso a partir do nosso plano

31322
20:43:58,240 --> 20:44:00,240
que é a definição de classe aqui você

31323
20:44:00,240 --> 20:44:02,160
Eu realmente precisa saber que esta é uma classe

31324
20:44:02,160 --> 20:44:04,720
Objeto, vamos dizer isso e nós vamos

31325
20:44:04,720 --> 20:44:06,720
imprimir seu volume nós vamos dizer

31326
20:44:06,720 --> 20:44:08,800
cilindro um e nós vamos chamar a nossa

31327
20:44:08,800 --> 20:44:11,192
método de volume, devemos dizer e se nós

31328
20:44:11,192 --> 20:44:12,640
construir você vai ver que isso é

31329
20:44:12,640 --> 20:44:14,160
Indo para o trabalho, mas

31330
20:44:14,160 --> 20:44:16,160
O volume não virá

31331
20:44:16,160 --> 20:44:19,440
dos valores iniciais que temos aqui,

31332
20:44:19,440 --> 20:44:22,640
terá mudado esses caras para 2

31333
20:44:22,640 --> 20:44:25,120
do nosso construtor aqui porque o

31334
20:44:25,120 --> 20:44:26,960
O compilador vai olhar para esta linha

31335
20:44:26,960 --> 20:44:29,832
aqui e ver que estamos tentando construir

31336
20:44:29,832 --> 20:44:32,320
Um objeto silencioso que vai olhar

31337
20:44:32,320 --> 20:44:34,240
a definição da classe e vai

31338
20:44:34,240 --> 20:44:36,960
Digamos que eu tenho algum construtor

31339
20:44:36,960 --> 20:44:39,192
que eu posso usar para construir um objeto a partir de

31340
20:44:39,192 --> 20:44:41,360
a sintaxe que vejo aqui e vai

31341
20:44:41,360 --> 20:44:43,832
Veja que tem um construtor que

31342
20:44:43,832 --> 20:44:45,680
não tem nenhum parâmetro e é

31343
20:44:45,680 --> 20:44:48,872
vamos usá-lo para construir o nosso objeto e

31344
20:44:48,872 --> 20:44:50,960
ele vai usar esta informação

31345
20:44:50,960 --> 20:44:53,680
para construir nosso objeto do cilindro para que a base

31346
20:44:53,680 --> 20:44:55,512
O raio vai ser dois a altura é

31347
20:44:55,512 --> 20:44:57,360
serão dois e vai usar

31348
20:44:57,360 --> 20:44:59,832
para calcular o volume

31349
20:44:59,832 --> 20:45:01,680
que nós imprimimos aqui você realmente precisa

31350
20:45:01,680 --> 20:45:04,160
Entenda isso vamos votar

31351
20:45:04,160 --> 20:45:05,440
E ver

31352
20:45:05,440 --> 20:45:08,872
se gcc aceita isso, você vê que ambos são

31353
20:45:08,872 --> 20:45:11,680
Bom agora podemos trazer um terminal e

31354
20:45:11,680 --> 20:45:13,760
clear e run galo que você está indo para

31355
20:45:13,760 --> 20:45:16,400
Veja que temos 25 algo que é um

31356
20:45:16,400 --> 20:45:19,680
resultado da utilização desta informação que temos

31357
20:45:19,680 --> 20:45:22,480
Aqui se tomarmos pi multiplicado por isso

31358
20:45:22,480 --> 20:45:24,960
Raio de base multiplicar-se por este raio de base

31359
20:45:24,960 --> 20:45:27,280
novamente e multiplicar por altura que estamos indo

31360
20:45:27,280 --> 20:45:29,280
para obter isso aqui você pode experimentar isso

31361
20:45:29,280 --> 20:45:31,680
Vai ser o que você vê aqui e

31362
20:45:31,680 --> 20:45:34,720
Isso prova que o compilador

31363
20:45:34,720 --> 20:45:37,600
está usando nosso construtor aqui, mas nós podemos

31364
20:45:37,600 --> 20:45:39,512
Também use um depurador

31365
20:45:39,512 --> 20:45:42,800
Vamos configurar um ponto de ruptura aqui

31366
20:45:42,800 --> 20:45:44,800
e nós vamos correr isso através do nosso

31367
20:45:44,800 --> 20:45:47,760
depurador podemos voltar para a guia de execução

31368
20:45:47,760 --> 20:45:48,480
Aqui

31369
20:45:48,480 --> 20:45:50,400
Como já fizemos antes

31370
20:45:50,400 --> 20:45:52,800
e nós vamos tentar usar o

31371
20:45:52,800 --> 20:45:55,192
ferramentas de depuração que vêm

31372
20:45:55,192 --> 20:45:57,680
com o compilador gcc que é o que podemos

31373
20:45:57,680 --> 20:46:00,080
usar se você estiver no Windows você também pode

31374
20:46:00,080 --> 20:46:01,120
Use o

31375
20:46:01,120 --> 20:46:03,440
ferramentas que vêm com o compilador de

31376
20:46:03,440 --> 20:46:05,600
Microsoft, mas não vamos usar

31377
20:46:05,600 --> 20:46:08,240
que agora gcc vai ficar bem, estamos

31378
20:46:08,240 --> 20:46:10,080
Vou começar a depuração e nós

31379
20:46:10,080 --> 20:46:12,872
deve atingir o nosso ponto de interrupção quando a construção

31380
20:46:12,872 --> 20:46:15,440
Está feito, vamos esperar um minuto bem, temos

31381
20:46:15,440 --> 20:46:17,192
Atingir o nosso ponto de ruptura

31382
20:46:17,192 --> 20:46:20,160
Podemos minimizar isso um pouco e eu

31383
20:46:20,160 --> 20:46:22,480
mostrar o terminal para a direita aqui i

31384
20:46:22,480 --> 20:46:24,720
Acho que podemos fazer isso, vamos fazer isso, vamos

31385
20:46:24,720 --> 20:46:27,192
Coloque isso um pouco para a direita aqui

31386
20:46:27,192 --> 20:46:29,280
e minimizar um pouco bem, temos

31387
20:46:29,280 --> 20:46:32,640
nosso thunk no lugar, nós batemos nossa pausa

31388
20:46:32,640 --> 20:46:34,480
O ponto de ver que estes são os locais

31389
20:46:34,480 --> 20:46:36,800
As variáveis que temos aqui temos a

31390
20:46:36,800 --> 20:46:40,080
Objeto de cilindro que não é inicializado

31391
20:46:40,080 --> 20:46:42,240
Mas porque você vê o que temos dentro

31392
20:46:42,240 --> 20:46:45,440
é realmente lixo de dados que não colocamos

31393
20:46:45,440 --> 20:46:48,480
qualquer coisa ainda, mas agora que estamos nisso

31394
20:46:48,480 --> 20:46:51,120
Ponto de quebra aqui que podemos acertar em frente

31395
20:46:51,120 --> 20:46:54,640
e entrar no código que constrói

31396
20:46:54,640 --> 20:46:57,360
nosso objeto de cilindro porque neste

31397
20:46:57,360 --> 20:47:01,120
point liner 25 aqui não correu ainda assim

31398
20:47:01,120 --> 20:47:02,872
nós vamos entrar e você está

31399
20:47:02,872 --> 20:47:05,360
Vou ver que nós batemos no construtor

31400
20:47:05,360 --> 20:47:08,552
para o nosso objeto do cilindro

31401
20:47:08,552 --> 20:47:09,360
E a

31402
20:47:09,360 --> 20:47:11,760
Isso novamente prova que nosso construtor

31403
20:47:11,760 --> 20:47:14,240
está sendo usado para construir o nosso cilindro

31404
20:47:14,240 --> 20:47:15,360
objetos

31405
20:47:15,360 --> 20:47:17,120
Agora podemos passar para a próxima linha que somos

31406
20:47:17,120 --> 20:47:19,440
vai configurar o raio da base e se

31407
20:47:19,440 --> 20:47:22,240
batemos em seguida aqui que isso vai definir

31408
20:47:22,240 --> 20:47:24,480
nosso raio base para 2

31409
20:47:24,480 --> 20:47:26,640
E você vê que a altura está em um

31410
20:47:26,640 --> 20:47:29,280
porque ainda não o estamos, mas se

31411
20:47:29,280 --> 20:47:31,280
nós executamos esta linha que você vai ver

31412
20:47:31,280 --> 20:47:33,040
essa altura também vai mudar para

31413
20:47:33,040 --> 20:47:33,920
Dois dos dois

31414
20:47:33,920 --> 20:47:36,080
E agora, se acertamos em seguida, vamos

31415
20:47:36,080 --> 20:47:38,872
sair do nosso construtor e do nosso

31416
20:47:38,872 --> 20:47:40,872
O objeto do cilindro já estará

31417
20:47:40,872 --> 20:47:43,512
construídos se olharmos novamente aqui, estamos

31418
20:47:43,512 --> 20:47:46,160
ver que o raio é de 2 altura é

31419
20:47:46,160 --> 20:47:49,040
2 e nós podemos imprimir o volume e se nós

31420
20:47:49,040 --> 20:47:50,720
hit passo sobre nós vamos ver o nosso

31421
20:47:50,720 --> 20:47:53,280
volume impresso aqui espero que de novo

31422
20:47:53,280 --> 20:47:56,400
Isso prova que nosso construtor aqui é

31423
20:47:56,400 --> 20:47:58,320
sendo usado para construir

31424
20:47:58,320 --> 20:48:01,440
objetos e está fazendo isso porque

31425
20:48:01,440 --> 20:48:04,400
é a sintaxe aqui que não passamos

31426
20:48:04,400 --> 20:48:07,440
parâmetro ao nosso objeto do cilindro como nós

31427
20:48:07,440 --> 20:48:10,160
criado para que isso deva chamar a

31428
20:48:10,160 --> 20:48:12,800
construtor padrão que não leva

31429
20:48:12,800 --> 20:48:15,192
Qualquer parâmetro esta é a mensagem aqui

31430
20:48:15,192 --> 20:48:17,760
Vamos fechar nossa sessão de depuração e

31431
20:48:17,760 --> 20:48:20,800
maximizar nossa instância de código de estúdio visual

31432
20:48:20,800 --> 20:48:22,160
Porque nós vamos montar outro

31433
20:48:22,160 --> 20:48:23,832
construtor que vai levar

31434
20:48:23,832 --> 20:48:26,240
Parâmetros agora e você já viu o

31435
20:48:26,240 --> 20:48:28,552
sintaxe para fazer isso nos slides que é

31436
20:48:28,552 --> 20:48:30,640
Nada complicado vamos dizer

31437
20:48:30,640 --> 20:48:32,240
o nome do construtor que é

31438
20:48:32,240 --> 20:48:33,920
Será o nome da classe e

31439
20:48:33,920 --> 20:48:35,600
nós vamos dizer o dobro

31440
20:48:35,600 --> 20:48:38,872
e dizer rad param param parara e nós somos

31441
20:48:38,872 --> 20:48:40,160
Vou dizer

31442
20:48:40,160 --> 20:48:42,640
altura param param para o nosso

31443
20:48:42,640 --> 20:48:44,552
altura e vamos fazer isto

31444
20:48:44,552 --> 20:48:46,080
duplo e depois disso vamos

31445
20:48:46,080 --> 20:48:49,192
cabeça no corpo do nosso construtor e

31446
20:48:49,192 --> 20:48:51,832
Vamos inicializar nossos guias para

31447
20:48:51,832 --> 20:48:54,240
Os parâmetros que passarão para o

31448
20:48:54,240 --> 20:48:55,920
função aqui e isso é realmente

31449
20:48:55,920 --> 20:48:58,080
poderoso depois que temos este construtor

31450
20:48:58,080 --> 20:49:00,552
Fim que seremos capazes de passar

31451
20:49:00,552 --> 20:49:02,800
parâmetros que serão usados para

31452
20:49:02,800 --> 20:49:05,512
construir nosso objeto de cilindro para que possamos

31453
20:49:05,512 --> 20:49:08,080
Diga raio de base e passe em

31454
20:49:08,080 --> 20:49:11,192
param vermelho e podemos dizer altura e dizer

31455
20:49:11,192 --> 20:49:13,512
altura param aqui e estes vão

31456
20:49:13,512 --> 20:49:16,160
ser usado para construir o nosso objeto agora

31457
20:49:16,160 --> 20:49:18,720
pode ir sobre a função principal e

31458
20:49:18,720 --> 20:49:20,872
Mudar a forma como construímos nosso cilindro

31459
20:49:20,872 --> 20:49:23,832
objeto se quisermos usar o bronzeado como

31460
20:49:23,832 --> 20:49:25,440
o raio e a

31461
20:49:25,440 --> 20:49:27,680
Cinco ou quatro como o

31462
20:49:27,680 --> 20:49:29,832
altura podemos fazer isso passando

31463
20:49:29,832 --> 20:49:33,512
argumentos para o nosso construtor aqui

31464
20:49:33,512 --> 20:49:35,440
Vamos correr isso através do depurador

31465
20:49:35,440 --> 20:49:37,920
novamente e ver que a nossa informação aqui

31466
20:49:37,920 --> 20:49:39,512
está sendo usado

31467
20:49:39,512 --> 20:49:42,080
Agora este construtor aqui vai ser

31468
20:49:42,080 --> 20:49:44,552
escolhida pelo compilador porque é

31469
20:49:44,552 --> 20:49:47,040
mais adequado para a chamada que somos

31470
20:49:47,040 --> 20:49:50,000
fazendo aqui vamos executar a nossa depuração

31471
20:49:50,000 --> 20:49:53,120
sessão o programa vai ser parafuso

31472
20:49:53,120 --> 20:49:55,600
e vamos tentar maximizar

31473
20:49:55,600 --> 20:49:58,480
Isso um pouco e trazer a nossa

31474
20:49:58,480 --> 20:50:00,800
Saída terminal ok, atingimos o

31475
20:50:00,800 --> 20:50:03,360
Ponto de quebra aqui nós podemos entrar em nosso

31476
20:50:03,360 --> 20:50:05,760
construtor e observe o construtor

31477
20:50:05,760 --> 20:50:08,000
que o compilador escolhe o nosso

31478
20:50:08,000 --> 20:50:10,400
O construtor que leva parâmetros é

31479
20:50:10,400 --> 20:50:13,440
escolhido aqui e podemos fazer coisas dentro

31480
20:50:13,440 --> 20:50:16,160
Vamos acertar em seguida, vamos inicializar

31481
20:50:16,160 --> 20:50:18,960
o raio da base para 10 e nós vamos

31482
20:50:18,960 --> 20:50:21,360
inicialize a altura a

31483
20:50:21,360 --> 20:50:23,760
Quatro Ok, podemos ver isso para a esquerda

31484
20:50:23,760 --> 20:50:26,320
Aqui se atingirmos a próxima altura está indo

31485
20:50:26,320 --> 20:50:28,000
ser mudado para quatro e nosso

31486
20:50:28,000 --> 20:50:29,680
O construtor vai acabar, nós somos

31487
20:50:29,680 --> 20:50:31,192
indo para a cabeça sobre

31488
20:50:31,192 --> 20:50:33,440
na função principal novamente e se nós

31489
20:50:33,440 --> 20:50:35,512
passo agora vamos imprimir um novo

31490
20:50:35,512 --> 20:50:38,160
volume baseado na informação

31491
20:50:38,160 --> 20:50:41,040
Costumávamos construir nosso objeto aqui

31492
20:50:41,040 --> 20:50:43,760
Isso é realmente o que os construtores fazem

31493
20:50:43,760 --> 20:50:46,640
são usados pelo compilador para construir seu

31494
20:50:46,640 --> 20:50:49,192
objetos e vimos a sintaxe que podemos usar

31495
20:50:49,192 --> 20:50:52,000
para criar construtores para o nosso próprio

31496
20:50:52,000 --> 20:50:54,640
aulas bem agora você deve estar dizendo se

31497
20:50:54,640 --> 20:50:57,680
Precisamos de construtores para construir o nosso

31498
20:50:57,680 --> 20:50:58,960
objetos

31499
20:50:58,960 --> 20:51:01,192
Por que foi o código na última palestra

31500
20:51:01,192 --> 20:51:02,400
Trabalhando

31501
20:51:02,400 --> 20:51:04,320
Na última palestra, fizemos algo

31502
20:51:04,320 --> 20:51:06,960
assim nós dissemos cilindro um cilindro

31503
20:51:06,960 --> 20:51:10,080
cilindro um e isso foi soldagem e

31504
20:51:10,080 --> 20:51:12,800
compilando bem e vamos tentar tomar

31505
20:51:12,800 --> 20:51:15,040
para fora nossos construtores podemos fazer isso

31506
20:51:15,040 --> 20:51:17,760
Vamos comentá-los e se você olhar

31507
20:51:17,760 --> 20:51:19,120
Você vai ver que o código é

31508
20:51:19,120 --> 20:51:21,440
vou compilar bem mesmo se não

31509
20:51:21,440 --> 20:51:24,320
Tenho algum construtor aqui, vamos

31510
20:51:24,320 --> 20:51:27,040
construir com gcc para mostrar que o código

31511
20:51:27,040 --> 20:51:30,080
vai compilar ambos é bom, então como

31512
20:51:30,080 --> 20:51:32,240
é isso funcionando como é isso

31513
20:51:32,240 --> 20:51:35,120
Construindo nossos objetos mesmo se

31514
20:51:35,120 --> 20:51:37,600
Não tenha nenhum construtor aqui bem

31515
20:51:37,600 --> 20:51:40,160
A razão é que o compilador vai

31516
20:51:40,160 --> 20:51:42,872
criar seu próprio construtor e o que ele

31517
20:51:42,872 --> 20:51:44,800
Vai montar um construtor

31518
20:51:44,800 --> 20:51:47,360
que é realmente vazio e não tem

31519
20:51:47,360 --> 20:51:49,680
Qualquer coisa dentro, basicamente vai

31520
20:51:49,680 --> 20:51:52,480
ser como se colocássemos em um construtor vazio

31521
20:51:52,480 --> 20:51:54,800
Vamos copiar isso e realmente mostrar a você

31522
20:51:54,800 --> 20:51:57,760
Isso nós podemos fazer isso e nós vamos

31523
20:51:57,760 --> 20:52:00,400
fazer este construtor vazio e não fazer

31524
20:52:00,400 --> 20:52:02,552
Qualquer coisa no corpo este é o

31525
20:52:02,552 --> 20:52:04,720
construtor que seu compilador está indo

31526
20:52:04,720 --> 20:52:07,920
para gerar e se nós somos os dois agora e eu

31527
20:52:07,920 --> 20:52:09,440
Tente tentar

31528
20:52:09,440 --> 20:52:11,512
configurar um ponto de ruptura aqui você está indo

31529
20:52:11,512 --> 20:52:13,920
para ver que nosso construtor vazio é

31530
20:52:13,920 --> 20:52:16,480
Vai ser escolhido vamos depurar e mostrar

31531
20:52:16,480 --> 20:52:18,160
Você está tudo bem, você vê que estamos indo

31532
20:52:18,160 --> 20:52:20,400
para acertar o ponto de interrupção aqui e se nós

31533
20:52:20,400 --> 20:52:22,400
passo para o compilador vai

31534
20:52:22,400 --> 20:52:24,400
Escolha esse cara e não vai fazer

31535
20:52:24,400 --> 20:52:27,192
Qualquer coisa, então basicamente vai tomar

31536
20:52:27,192 --> 20:52:29,280
nossas variáveis de membro como

31537
20:52:29,280 --> 20:52:31,280
eles são e vai usar o

31538
20:52:31,280 --> 20:52:33,680
Informações para imprimir o volume aqui

31539
20:52:33,680 --> 20:52:34,400
pode

31540
20:52:34,400 --> 20:52:35,920
hit próximo novamente

31541
20:52:35,920 --> 20:52:39,120
e sair do nosso construtor

31542
20:52:39,120 --> 20:52:41,192
E se nós

31543
20:52:41,192 --> 20:52:44,640
passo acima devemos imprimir o nosso volume

31544
20:52:44,640 --> 20:52:47,360
que vai ser 3,14 porque o

31545
20:52:47,360 --> 20:52:48,480
Compilador

31546
20:52:48,480 --> 20:52:50,872
Só use o

31547
20:52:50,872 --> 20:52:53,120
valores iniciais que temos em nosso membro

31548
20:52:53,120 --> 20:52:55,920
variáveis aqui, mais uma vez a mensagem é

31549
20:52:55,920 --> 20:52:58,640
se você não tem nenhum construtor em

31550
20:52:58,640 --> 20:53:01,192
sua classe que o compilador vai

31551
20:53:01,192 --> 20:53:03,600
Gerar um construtor vazio para você

31552
20:53:03,600 --> 20:53:05,512
E o construtor vazio vai

31553
20:53:05,512 --> 20:53:08,000
Não tome parâmetros e não vai

31554
20:53:08,000 --> 20:53:09,832
ter qualquer coisa no corpo que vai

31555
20:53:09,832 --> 20:53:13,040
ser um construtor vazio e é chamado de

31556
20:53:13,040 --> 20:53:15,832
um construtor padrão gerado pelo

31557
20:53:15,832 --> 20:53:18,240
compilador este é realmente tudo o que eu tinha que

31558
20:53:18,240 --> 20:53:19,920
compartilhar nesta palestra eu espero que você tenha encontrado

31559
20:53:19,920 --> 20:53:22,160
É interessante agora que você deve ter

31560
20:53:22,160 --> 20:53:24,240
conhecimento suficiente para construir o seu próprio

31561
20:53:24,240 --> 20:53:26,872
construtores para suas aulas que somos

31562
20:53:26,872 --> 20:53:29,040
Vou parar aqui nesta palestra:

31563
20:53:29,040 --> 20:53:30,800
Em seguida, vamos aprender sobre

31564
20:53:30,800 --> 20:53:32,800
construtores padrão

31565
20:53:32,800 --> 20:53:34,640
Vá em frente e termine aqui

31566
20:53:34,640 --> 20:53:36,480
e encontrar-me lá nesta palestra nós somos

31567
20:53:36,480 --> 20:53:38,080
Vou aprender sobre o padrão

31568
20:53:38,080 --> 20:53:40,800
construtores e isso é uma sintaxe você

31569
20:53:40,800 --> 20:53:43,512
pode usar para deixar o compilador

31570
20:53:43,512 --> 20:53:46,320
gerar um construtor padrão para você

31571
20:53:46,320 --> 20:53:48,640
Tudo que você precisa fazer é fazer coisas como

31572
20:53:48,640 --> 20:53:51,120
Isso você vai dizer o nome do

31573
20:53:51,120 --> 20:53:52,800
construtor que vai ser o

31574
20:53:52,800 --> 20:53:54,400
O mesmo nome da classe para a qual você está indo

31575
20:53:54,400 --> 20:53:56,872
colocar em uma lista de parâmetros vazios e, em seguida,

31576
20:53:56,872 --> 20:53:59,832
você vai dizer iguais ao padrão

31577
20:53:59,832 --> 20:54:01,920
se você fizer isso, o compilador vai fazer

31578
20:54:01,920 --> 20:54:05,040
gerar um construtor vazio padrão para

31579
20:54:05,040 --> 20:54:05,832
Você

31580
20:54:05,832 --> 20:54:07,920
Na última palestra vimos que

31581
20:54:07,920 --> 20:54:10,080
pode criar nossos próprios construtores

31582
20:54:10,080 --> 20:54:13,040
basicamente assim o que eu não disse

31583
20:54:13,040 --> 20:54:15,760
Você é que no momento em que você configura seu

31584
20:54:15,760 --> 20:54:19,192
proprietário construtor o compilador está indo para

31585
20:54:19,192 --> 20:54:22,080
não gerar a construtora padrão e

31586
20:54:22,080 --> 20:54:24,480
se você quiser manter a capacidade de

31587
20:54:24,480 --> 20:54:27,360
Construir objetos sem passar

31588
20:54:27,360 --> 20:54:29,832
parâmetros que você vai ter que colocar

31589
20:54:29,832 --> 20:54:32,080
em seu próprio construtor padrão e você

31590
20:54:32,080 --> 20:54:35,360
pode usar esta sintaxe aqui para fazer isso

31591
20:54:35,360 --> 20:54:37,600
vamos para o código do estúdio visual

31592
20:54:37,600 --> 20:54:39,680
e falar sobre isso um pouco mais bem

31593
20:54:39,680 --> 20:54:42,400
Aqui estamos em nossa pasta de trabalho o

31594
20:54:42,400 --> 20:54:44,400
O projeto atual é padrão

31595
20:54:44,400 --> 20:54:46,960
construtores, vamos pegar o nosso

31596
20:54:46,960 --> 20:54:49,040
arquivos de modelo e vamos colocar

31597
20:54:49,040 --> 20:54:51,440
eles no lugar e nós vamos abrir

31598
20:54:51,440 --> 20:54:53,680
isso em código de estúdio visual arrastando

31599
20:54:53,680 --> 20:54:55,512
e caindo aqui e nós vamos

31600
20:54:55,512 --> 20:54:58,400
abrir nosso arquivo principal do cpp, vamos retirar

31601
20:54:58,400 --> 20:55:00,800
O que não precisamos, vamos limpar

31602
20:55:00,800 --> 20:55:03,040
A principal função aqui e estamos indo

31603
20:55:03,040 --> 20:55:05,600
para trazer a definição de classe que tivemos

31604
20:55:05,600 --> 20:55:07,512
Na última palestra

31605
20:55:07,512 --> 20:55:10,160
Se você se lembra que tivemos dois construtores

31606
20:55:10,160 --> 20:55:12,800
e um construtor que não tome

31607
20:55:12,800 --> 20:55:16,320
qualquer parâmetro e outro construtor

31608
20:55:16,320 --> 20:55:18,552
que estava inicializando nosso membro

31609
20:55:18,552 --> 20:55:21,040
variáveis com parâmetros que passamos

31610
20:55:21,040 --> 20:55:24,000
nesta lista de parâmetros aqui, mas neste

31611
20:55:24,000 --> 20:55:27,440
palestra, vamos tirar este construtor

31612
20:55:27,440 --> 20:55:30,080
que não leva nenhum parâmetro

31613
20:55:30,080 --> 20:55:32,720
e mostrar isso quando você configurar seu

31614
20:55:32,720 --> 20:55:35,280
próprio construtor o compilador não é

31615
20:55:35,280 --> 20:55:37,600
vai gerar um construtor padrão

31616
20:55:37,600 --> 20:55:39,440
Para você e nós vamos perder o

31617
20:55:39,440 --> 20:55:42,552
capacidade de construir objetos sem

31618
20:55:42,552 --> 20:55:45,120
passando os parâmetros da sintaxe que nós

31619
20:55:45,120 --> 20:55:46,720
Basicamente, veja aqui nós vamos dizer

31620
20:55:46,720 --> 20:55:49,512
cilindro e dizer cilindro um vamos usar

31621
20:55:49,512 --> 20:55:52,320
um c minúsculo e se fizermos isso você vê

31622
20:55:52,320 --> 20:55:54,160
que temos uma linha...

31623
20:55:54,160 --> 20:55:56,400
O compilador não vai gerar um

31624
20:55:56,400 --> 20:56:00,400
construtor de tomada de não parâmetro vazio

31625
20:56:00,400 --> 20:56:02,000
porque vê que temos um

31626
20:56:02,000 --> 20:56:04,320
construtor aqui é assim que c plus mais

31627
20:56:04,320 --> 20:56:07,192
Os compiladores funcionam se eles vêem que você tem

31628
20:56:07,192 --> 20:56:09,360
qualquer construtor em sua classe que eles são

31629
20:56:09,360 --> 20:56:11,440
não vai gerar um vazio padrão

31630
20:56:11,440 --> 20:56:13,360
construtor e se tentarmos construir, estamos

31631
20:56:13,360 --> 20:56:15,280
Vou ter uma flecha que diz

31632
20:56:15,280 --> 20:56:17,280
Algo como

31633
20:56:17,280 --> 20:56:19,280
Não temos um construtor que possa

31634
20:56:19,280 --> 20:56:21,440
Basicamente, construir um objeto a partir do

31635
20:56:21,440 --> 20:56:23,920
linha aqui vai dizer não combinando

31636
20:56:23,920 --> 20:56:26,480
chamada da função para cilindro do cilindro você

31637
20:56:26,480 --> 20:56:28,240
Veja aqui que está tentando chamar um

31638
20:56:28,240 --> 20:56:30,872
construtor que não leva nenhum

31639
20:56:30,872 --> 20:56:32,640
parâmetro mas não temos tal

31640
20:56:32,640 --> 20:56:35,600
construtor em nosso código que poderíamos ir

31641
20:56:35,600 --> 20:56:37,832
e colocar nesse construtor

31642
20:56:37,832 --> 20:56:40,872
e, por exemplo, dizer cilindro e colocar um

31643
20:56:40,872 --> 20:56:43,280
Lista de parâmetros vazia e colocar um vazio

31644
20:56:43,280 --> 20:56:46,000
corpo agora esta linha aqui vai funcionar

31645
20:56:46,000 --> 20:56:47,920
Porque temos um padrão vazio

31646
20:56:47,920 --> 20:56:50,960
construtor e se soldar você vê que

31647
20:56:50,960 --> 20:56:53,192
A construção vai ser bom ok nós

31648
20:56:53,192 --> 20:56:56,552
estão construindo bem, mas tendo que digitar tudo

31649
20:56:56,552 --> 20:56:59,680
Isto se o que você realmente quer é um vazio

31650
20:56:59,680 --> 20:57:01,040
construtor

31651
20:57:01,040 --> 20:57:03,920
é demasiado tipo dentro e em c plus plus

31652
20:57:03,920 --> 20:57:06,240
temos uma sintaxe que podemos usar para deixar o

31653
20:57:06,240 --> 20:57:08,640
O compilador gera esse tipo de

31654
20:57:08,640 --> 20:57:10,720
construtor para nós e a maneira como fazemos

31655
20:57:10,720 --> 20:57:13,760
que é dizer cilindro e nós dizemos o nome

31656
20:57:13,760 --> 20:57:15,760
do construtor que dizemos iguais e nós

31657
20:57:15,760 --> 20:57:18,480
Diga padrão se salvarmos este compilador

31658
20:57:18,480 --> 20:57:20,320
vai gerar este construtor

31659
20:57:20,320 --> 20:57:22,400
para nós e a linha aqui vai

31660
20:57:22,400 --> 20:57:25,440
trabalhar assim vamos trazer isso e construir

31661
20:57:25,440 --> 20:57:28,320
Mais uma vez vamos construir com gcc

31662
20:57:28,320 --> 20:57:29,760
Você vai ver que a construção é

31663
20:57:29,760 --> 20:57:32,872
bom e nós podemos trazer o terminal

31664
20:57:32,872 --> 20:57:35,440
e claro e correr galo nós não somos

31665
20:57:35,440 --> 20:57:37,280
Vou ver qualquer coisa porque não somos

31666
20:57:37,280 --> 20:57:40,720
imprimir o volume do nosso cilindro aqui

31667
20:57:40,720 --> 20:57:42,320
Mas podemos fazer isso, vamos chamar isso

31668
20:57:42,320 --> 20:57:44,720
um cilindro para ser consistente com o que

31669
20:57:44,720 --> 20:57:46,800
Fizemos nas últimas palestras e

31670
20:57:46,800 --> 20:57:49,040
nós vamos dizer hddc para fora e imprimir

31671
20:57:49,040 --> 20:57:51,120
O volume deste cilindro estamos indo

31672
20:57:51,120 --> 20:57:54,320
para dizer volume e chamar o nosso método de volume

31673
20:57:54,320 --> 20:57:56,800
E agora que temos isso, podemos soldar

31674
20:57:56,800 --> 20:57:58,960
vamos usar o gcc para fazer isso

31675
20:57:58,960 --> 20:58:01,760
construir é bom que podemos ir para baixo e claro

31676
20:58:01,760 --> 20:58:03,512
e correr o galo, vamos ver isso

31677
20:58:03,512 --> 20:58:06,000
vemos nosso volume aqui e isso é

31678
20:58:06,000 --> 20:58:08,000
realmente tudo que eu queria compartilhar com você em

31679
20:58:08,000 --> 20:58:10,400
Esta palestra que você pode usar isso

31680
20:58:10,400 --> 20:58:13,280
sintaxe padrão aqui para configurar um vazio

31681
20:58:13,280 --> 20:58:16,400
construtor padrão para suas classes e

31682
20:58:16,400 --> 20:58:18,800
Uma coisa que eu não te mostrei

31683
20:58:18,800 --> 20:58:22,080
É que seus construtores têm que ser

31684
20:58:22,080 --> 20:58:25,280
público para poder ser chamado assim

31685
20:58:25,280 --> 20:58:27,600
e para mostrar que vamos subir e

31686
20:58:27,600 --> 20:58:29,832
realmente mudar isso para privado e show

31687
20:58:29,832 --> 20:58:31,600
Você o que acontece no momento em que fazemos isso

31688
20:58:31,600 --> 20:58:33,512
nós vamos ter uma linha de riscas em

31689
20:58:33,512 --> 20:58:36,320
A principal função aqui e se tentarmos

31690
20:58:36,320 --> 20:58:39,040
construir, mas antes de construir vamos mostrar-lhe

31691
20:58:39,040 --> 20:58:41,192
O que o código do estúdio visual está dizendo que é

31692
20:58:41,192 --> 20:58:44,080
indo dizer cilindro do cilindro declarado

31693
20:58:44,080 --> 20:58:46,160
É inacessível para que você veja o

31694
20:58:46,160 --> 20:58:49,120
construtor que é declarado dentro de

31695
20:58:49,120 --> 20:58:51,120
uma classe como privada

31696
20:58:51,120 --> 20:58:54,000
acessível de fora quando nós

31697
20:58:54,000 --> 20:58:56,720
Tente chamá-lo para construir nosso cilindro

31698
20:58:56,720 --> 20:59:00,640
objetos assim para os construtores serem utilizáveis

31699
20:59:00,640 --> 20:59:02,720
no exterior aqui e ambos

31700
20:59:02,720 --> 20:59:05,360
objetos que eles têm que ser públicos, vamos

31701
20:59:05,360 --> 20:59:08,400
construir e ver o que gcc diz sobre isso

31702
20:59:08,400 --> 20:59:09,832
Nós basicamente vamos ter o mesmo

31703
20:59:09,832 --> 20:59:12,480
erro O construtor é privado dentro

31704
20:59:12,480 --> 20:59:14,960
Este contexto, então não podemos realmente chamá-lo

31705
20:59:14,960 --> 20:59:16,872
Então, se queremos que nosso código seja construído, precisamos

31706
20:59:16,872 --> 20:59:19,512
para tornar os nossos construtores públicos e isso

31707
20:59:19,512 --> 20:59:20,640
É alguma coisa

31708
20:59:20,640 --> 20:59:22,872
Você precisa saber que vamos construir novamente e

31709
20:59:22,872 --> 20:59:25,280
Veja que o frio está construindo a

31710
20:59:25,280 --> 20:59:27,440
O mundo é bom e isso é realmente tudo

31711
20:59:27,440 --> 20:59:29,280
Tive que compartilhar esta palestra que somos

31712
20:59:29,280 --> 20:59:31,360
Vou parar aqui neste no

31713
20:59:31,360 --> 20:59:32,960
A seguir, vamos ver como podemos

31714
20:59:32,960 --> 20:59:36,640
usar setters e getters para modificar as coisas

31715
20:59:36,640 --> 20:59:39,040
sobre nossos objetos de classe

31716
20:59:39,040 --> 20:59:41,440
Vá em frente e termine aqui e me encontre

31717
20:59:41,440 --> 20:59:42,240
lá

31718
20:59:42,240 --> 20:59:43,680
Nesta palestra vamos aprender

31719
20:59:43,680 --> 20:59:46,480
sobre setters e gatores e estes são

31720
20:59:46,480 --> 20:59:49,512
métodos em nossa classe que podemos usar para

31721
20:59:49,512 --> 20:59:52,552
ler variáveis de membro ou modificar dados em

31722
20:59:52,552 --> 20:59:55,120
nossas variáveis de membro, vamos olhar para um

31723
20:59:55,120 --> 20:59:58,080
Um exemplo simples e pelo caminho eu sinto muito

31724
20:59:58,080 --> 21:00:00,960
para minha má pronúncia de cilindro

31725
21:00:00,960 --> 21:00:03,600
Aqui eu disse que era cilindro e

31726
21:00:03,600 --> 21:00:05,832
Depois de algum pensamento cuidadoso eu verifiquei

31727
21:00:05,832 --> 21:00:08,640
online para a pronúncia sobre isso e

31728
21:00:08,640 --> 21:00:11,120
Eu descobri que era cilindro desculpe por

31729
21:00:11,120 --> 21:00:13,920
Isso se estiver incomodando você, peço desculpas

31730
21:00:13,920 --> 21:00:16,160
para a pronúncia ruim e eu estou indo

31731
21:00:16,160 --> 21:00:18,552
para fazer isso direito a partir de agora, tudo bem

31732
21:00:18,552 --> 21:00:21,600
Aqui temos nossa classe de cilindros que temos

31733
21:00:21,600 --> 21:00:23,920
algumas variáveis de membro e nós temos a

31734
21:00:23,920 --> 21:00:26,800
raio de base, temos a altura e agora

31735
21:00:26,800 --> 21:00:28,872
Queremos passar por algum público

31736
21:00:28,872 --> 21:00:31,280
funções para fazer operações sobre estes

31737
21:00:31,280 --> 21:00:33,192
variáveis de membros porque agora que

31738
21:00:33,192 --> 21:00:35,760
Somos privados, não podemos realmente modificá-los

31739
21:00:35,760 --> 21:00:38,480
ou manipulá-los de fora e

31740
21:00:38,480 --> 21:00:40,960
nós realmente precisamos fazer coisas com eles, então

31741
21:00:40,960 --> 21:00:43,120
Se quisermos ler as coisas deles

31742
21:00:43,120 --> 21:00:45,360
usará as funções getter

31743
21:00:45,360 --> 21:00:47,360
E se você olhar aqui, isso é simples

31744
21:00:47,360 --> 21:00:50,240
função a única coisa especial sobre isso

31745
21:00:50,240 --> 21:00:52,960
é que ele sai dentro da classe

31746
21:00:52,960 --> 21:00:55,040
tem um valor de retorno que tem uma função

31747
21:00:55,040 --> 21:00:56,872
nome tem uma lista de parâmetros e, em seguida,

31748
21:00:56,872 --> 21:00:59,440
O corpo nós só vamos devolver o

31749
21:00:59,440 --> 21:01:01,512
variável de interesse porque

31750
21:01:01,512 --> 21:01:04,240
É um getter que usamos isso para obter coisas

31751
21:01:04,240 --> 21:01:06,552
da classe este é o significado aqui

31752
21:01:06,552 --> 21:01:08,400
Aqui temos outra função getter

31753
21:01:08,400 --> 21:01:10,400
que vai devolver a altura e

31754
21:01:10,400 --> 21:01:13,440
notar que essas funções vivem no

31755
21:01:13,440 --> 21:01:16,872
abrangência pública da nossa classe, esta é a chave

31756
21:01:16,872 --> 21:01:19,040
Porque nós queremos ser capazes de passar

31757
21:01:19,040 --> 21:01:22,480
para modificar e fazer as coisas com o nosso

31758
21:01:22,480 --> 21:01:25,040
variáveis do membro, mas elas serão usadas

31759
21:01:25,040 --> 21:01:27,920
do exterior, então eles devem ser públicos

31760
21:01:27,920 --> 21:01:29,832
Caso contrário, eles querem ser acessíveis

31761
21:01:29,832 --> 21:01:33,120
do exterior também temos um par de

31762
21:01:33,120 --> 21:01:35,192
funções de configuração que eles vão ser

31763
21:01:35,192 --> 21:01:38,320
modificar nossas variáveis de membro assim definido

31764
21:01:38,320 --> 21:01:40,720
O raio da base vai levar um parâmetro

31765
21:01:40,720 --> 21:01:42,872
que ele vai usar para definir uma base

31766
21:01:42,872 --> 21:01:44,960
a altura do conjunto de raio vai fazer o

31767
21:01:44,960 --> 21:01:46,640
O mesmo vai levar um parâmetro e

31768
21:01:46,640 --> 21:01:49,600
vai usar isso para atribuir um valor

31769
21:01:49,600 --> 21:01:52,240
para a nossa variável membro de altura aqui e

31770
21:01:52,240 --> 21:01:55,040
porque essas funções são membros de

31771
21:01:55,040 --> 21:01:56,160
A classe

31772
21:01:56,160 --> 21:01:59,832
eles têm acesso às nossas variáveis de membro

31773
21:01:59,832 --> 21:02:02,552
independentemente de serem públicos ou

31774
21:02:02,552 --> 21:02:04,872
privado, então isso vai funcionar, nós somos

31775
21:02:04,872 --> 21:02:06,400
indo passar por eles a partir do

31776
21:02:06,400 --> 21:02:08,400
Lá fora e eles vão fazer o

31777
21:02:08,400 --> 21:02:11,440
os laticínios funcionam para nós e fazem as coisas usando

31778
21:02:11,440 --> 21:02:14,160
nossas variáveis de membro às quais não

31779
21:02:14,160 --> 21:02:15,760
ter acesso a

31780
21:02:15,760 --> 21:02:17,600
de fora este é o significado

31781
21:02:17,600 --> 21:02:20,080
Aqui agora que você tem uma ideia sobre

31782
21:02:20,080 --> 21:02:22,080
Isso nós vamos ir para o visual

31783
21:02:22,080 --> 21:02:23,760
código de estúdio e jogar com a gente um pouco

31784
21:02:23,760 --> 21:02:26,720
Mais bem aqui estamos em nosso trabalho

31785
21:02:26,720 --> 21:02:28,960
pasta do projeto atual é setters

31786
21:02:28,960 --> 21:02:30,800
e getters nós vamos pegar o nosso

31787
21:02:30,800 --> 21:02:33,120
modelo de arquivos muito rápido e colocá-los

31788
21:02:33,120 --> 21:02:34,320
no lugar

31789
21:02:34,320 --> 21:02:36,960
setters e getters é vamos pegar o

31790
21:02:36,960 --> 21:02:38,872
pasta e nós vamos abrir isso em

31791
21:02:38,872 --> 21:02:40,800
código de vídeo estúdio arrastando e

31792
21:02:40,800 --> 21:02:42,872
Deixando aqui isso vai abrir o nosso

31793
21:02:42,872 --> 21:02:45,760
pasta vamos abrir nosso cpp principal

31794
21:02:45,760 --> 21:02:47,680
arquivo e nós vamos limpá-lo um

31795
21:02:47,680 --> 21:02:49,832
Um pouquinho nós vamos pegar o

31796
21:02:49,832 --> 21:02:53,040
classe de cilindro da nossa palestra anterior

31797
21:02:53,040 --> 21:02:55,680
e use isso como ponto de partida aqui

31798
21:02:55,680 --> 21:02:57,920
E se você olhar, temos um par de

31799
21:02:57,920 --> 21:03:00,552
construtores aqui temos o volume

31800
21:03:00,552 --> 21:03:02,160
Função que nos dará a

31801
21:03:02,160 --> 21:03:04,960
volume do nosso cilindro aqui e nós temos

31802
21:03:04,960 --> 21:03:07,360
nossas variáveis de membro agora o que queremos

31803
21:03:07,360 --> 21:03:10,240
O fazer é poder fazer coisas com isso

31804
21:03:10,240 --> 21:03:13,120
variáveis de membro do exterior no

31805
21:03:13,120 --> 21:03:15,192
principal função aqui e vamos embora

31806
21:03:15,192 --> 21:03:17,512
através de métodos de setter e getter que

31807
21:03:17,512 --> 21:03:20,480
Deve ser público, então vamos fazer isso para que sejamos

31808
21:03:20,480 --> 21:03:22,872
indo para configurar o nosso getter primeiro assim

31809
21:03:22,872 --> 21:03:25,280
nós vamos dizer o dobro da base

31810
21:03:25,280 --> 21:03:27,280
raio de que vai devolver o dobro é

31811
21:03:27,280 --> 21:03:29,760
não vai levar nada e e entrar

31812
21:03:29,760 --> 21:03:32,160
O corpo nós só vamos devolver a nossa

31813
21:03:32,160 --> 21:03:34,400
Raio vamos voltar assim, então estamos

31814
21:03:34,400 --> 21:03:36,320
Vou montar outro getter que é

31815
21:03:36,320 --> 21:03:38,480
vamos nos dar a altura e não é

31816
21:03:38,480 --> 21:03:40,552
Vou pegar qualquer coisa e vai

31817
21:03:40,552 --> 21:03:43,512
basta retornar nossa variável membro de altura

31818
21:03:43,512 --> 21:03:46,160
Agora estes são os nossos getters eles estão indo

31819
21:03:46,160 --> 21:03:49,040
para obter coisas da classe

31820
21:03:49,040 --> 21:03:50,960
Objeto, vamos montar outro

31821
21:03:50,960 --> 21:03:52,720
funções que serão nossas

31822
21:03:52,720 --> 21:03:54,960
setters eles não vão voltar

31823
21:03:54,960 --> 21:03:57,120
Qualquer coisa e nós vamos dizer set base

31824
21:03:57,120 --> 21:03:59,120
raio e vai levar um duplo

31825
21:03:59,120 --> 21:04:01,360
parâmetro e vamos usar isso

31826
21:04:01,360 --> 21:04:03,280
para definir o nosso raio de base para que vamos

31827
21:04:03,280 --> 21:04:05,440
Diga raio de base e vamos dizer

31828
21:04:05,440 --> 21:04:07,360
igual a um parâmetro vermelho aqui e nós estamos

31829
21:04:07,360 --> 21:04:09,832
Vou fazer o mesmo para a nossa altura, então

31830
21:04:09,832 --> 21:04:11,680
Não vai devolver nada

31831
21:04:11,680 --> 21:04:13,512
Funcionar aqui e vamos dizer set

31832
21:04:13,512 --> 21:04:15,280
altura e vamos levar o nosso

31833
21:04:15,280 --> 21:04:17,832
parâmetro n então eu vou dizer duplo

31834
21:04:17,832 --> 21:04:20,240
altura param e vamos usar isso

31835
21:04:20,240 --> 21:04:21,040
A sua forma de

31836
21:04:21,040 --> 21:04:22,080
Atribuir

31837
21:04:22,080 --> 21:04:24,640
coisas para a nossa variável de membro que estamos indo

31838
21:04:24,640 --> 21:04:27,280
para dizer oi e nós vamos dizer altura

31839
21:04:27,280 --> 21:04:30,240
Param ok, então esta é a nossa coisa aqui agora

31840
21:04:30,240 --> 21:04:33,192
Temos duas funções para obter coisas de

31841
21:04:33,192 --> 21:04:35,760
nossa classe e temos duas funções para

31842
21:04:35,760 --> 21:04:38,640
definir dados para nossas variáveis de membro aqui

31843
21:04:38,640 --> 21:04:41,040
e novamente lembre-se que não podemos ter

31844
21:04:41,040 --> 21:04:44,240
acesso direto a essas variáveis de membro

31845
21:04:44,240 --> 21:04:46,160
no exterior da classe e se nós

31846
21:04:46,160 --> 21:04:48,000
Quero fazer isso, nós vamos ser capazes

31847
21:04:48,000 --> 21:04:50,552
para fazer isso através do nosso setter e getter

31848
21:04:50,552 --> 21:04:52,872
funções agora para essas funções

31849
21:04:52,872 --> 21:04:54,552
setters e getters para ser acessível

31850
21:04:54,552 --> 21:04:57,280
Do lado de fora, eles precisavam sair

31851
21:04:57,280 --> 21:04:59,760
A seção pública da nossa classe você vê

31852
21:04:59,760 --> 21:05:01,680
Esta palavra-chave pública aqui vai

31853
21:05:01,680 --> 21:05:05,192
Aplicar a qualquer coisa depois disso até que nós

31854
21:05:05,192 --> 21:05:07,920
mude isso para o software privado, de modo que o

31855
21:05:07,920 --> 21:05:10,080
O escopo público está basicamente saindo do

31856
21:05:10,080 --> 21:05:11,832
Os construtores aqui

31857
21:05:11,832 --> 21:05:14,720
todo o caminho para a nossa função de altura definida

31858
21:05:14,720 --> 21:05:17,192
e uma vez colocamos esta palavra-chave privada

31859
21:05:17,192 --> 21:05:19,280
Aqui tudo depois disso vai

31860
21:05:19,280 --> 21:05:21,832
ser privado é assim que essas coisas funcionam

31861
21:05:21,832 --> 21:05:23,832
então vamos tentar usar isso no geral, somos

31862
21:05:23,832 --> 21:05:25,920
Vou montar um objeto de cilindro

31863
21:05:25,920 --> 21:05:28,640
cilindro um e vamos colocar para

31864
21:05:28,640 --> 21:05:31,360
exemplo dois e três por que não e agora se

31865
21:05:31,360 --> 21:05:33,440
Queremos ter acesso à base

31866
21:05:33,440 --> 21:05:36,552
Raio lembra se tentamos acessar

31867
21:05:36,552 --> 21:05:39,440
que diretamente vamos dizer que se tentarmos

31868
21:05:39,440 --> 21:05:41,760
fazer algo como o cilindro um e

31869
21:05:41,760 --> 21:05:44,080
Diga raio de base que você vai ver isso

31870
21:05:44,080 --> 21:05:45,680
nós vamos ter uma linha esquiggly

31871
21:05:45,680 --> 21:05:47,192
significa que há algo errado

31872
21:05:47,192 --> 21:05:48,872
com o nosso chamado aqui vamos trazer um

31873
21:05:48,872 --> 21:05:49,920
O terminal

31874
21:05:49,920 --> 21:05:51,760
e ver o que o código do estúdio visual pensa

31875
21:05:51,760 --> 21:05:53,440
sobre este raio da base de membros

31876
21:05:53,440 --> 21:05:55,440
Declarou isso inacessível aqui se

31877
21:05:55,440 --> 21:05:57,440
Tente soldar nós provavelmente vamos ter um

31878
21:05:57,440 --> 21:05:59,600
Erro do compilador que diz essa base

31879
21:05:59,600 --> 21:06:02,320
O raio é privado neste âmbito e

31880
21:06:02,320 --> 21:06:04,480
Isso é o que temos aqui declaram

31881
21:06:04,480 --> 21:06:07,040
privado aqui para que não possamos acessar isso

31882
21:06:07,040 --> 21:06:09,440
da função principal aqui, mas agora que

31883
21:06:09,440 --> 21:06:12,080
nós temos nossas funções de getter que podemos ir

31884
21:06:12,080 --> 21:06:14,552
por meio deles e ter acesso a

31885
21:06:14,552 --> 21:06:16,872
variáveis de membros privados e observe que

31886
21:06:16,872 --> 21:06:19,760
porque estamos retornando por valor aqui

31887
21:06:19,760 --> 21:06:21,680
O que o retorno vai ser uma cópia de você

31888
21:06:21,680 --> 21:06:24,400
realmente precisa manter um olho para saber se

31889
21:06:24,400 --> 21:06:26,400
O que você está manipulando é o

31890
21:06:26,400 --> 21:06:29,600
coisas originais ou uma cópia, então aqui estamos

31891
21:06:29,600 --> 21:06:31,512
Vou voltar por valor e nós estamos

31892
21:06:31,512 --> 21:06:33,920
Vou devolver uma cópia, mas isso ainda é

31893
21:06:33,920 --> 21:06:36,800
útil em alguns casos para que aqui possamos usar

31894
21:06:36,800 --> 21:06:39,120
Alocador vamos tirar isso aqui e

31895
21:06:39,120 --> 21:06:42,240
Diga que obtenha o raio de base, é um método ou um

31896
21:06:42,240 --> 21:06:45,280
função para que precisamos colocar nossa função

31897
21:06:45,280 --> 21:06:47,832
chamar aqui e agora se tentarmos construir

31898
21:06:47,832 --> 21:06:50,000
Vamos passar por isso através do gcc e ver o que

31899
21:06:50,000 --> 21:06:52,960
nos fazem ver que a construção é boa que podemos

31900
21:06:52,960 --> 21:06:55,512
executar este programa vamos limpar e executar

31901
21:06:55,512 --> 21:06:57,040
galo você vai ver que

31902
21:06:57,040 --> 21:06:59,512
O raio base é dois agora que temos

31903
21:06:59,512 --> 21:07:01,920
Neste sentido, podemos realmente modificar as coisas

31904
21:07:01,920 --> 21:07:05,440
sobre o nosso cilindro aqui vamos colocar em 10

31905
21:07:05,440 --> 21:07:07,832
e 10 apenas para poder seguir isso

31906
21:07:07,832 --> 21:07:09,832
facilmente e vamos imprimir o

31907
21:07:09,832 --> 21:07:12,640
volume, digamos, volume e vamos

31908
21:07:12,640 --> 21:07:14,960
para dizer volume aqui, não vamos

31909
21:07:14,960 --> 21:07:16,720
Use o getter aqui eu vou dizer

31910
21:07:16,720 --> 21:07:19,040
volume isto vai imprimir o nosso volume

31911
21:07:19,040 --> 21:07:21,360
Mas vamos modificar o nosso membro

31912
21:07:21,360 --> 21:07:24,320
As variáveis lembram que este é um objeto de

31913
21:07:24,320 --> 21:07:26,080
nossa classe de cilindros

31914
21:07:26,080 --> 21:07:28,800
Então nós vamos dizer cilindro 1 conjunto

31915
21:07:28,800 --> 21:07:31,040
raio de base que podemos fazer isso e nós podemos

31916
21:07:31,040 --> 21:07:33,680
Mude isso para 100, por exemplo, e nós

31917
21:07:33,680 --> 21:07:36,872
pode mudar a altura que podemos

31918
21:07:36,872 --> 21:07:39,360
use essa função de membro porque temos

31919
21:07:39,360 --> 21:07:41,832
Isso agora e nós vamos definir isso para 10

31920
21:07:41,832 --> 21:07:44,320
Por que não agora se imprimirmos o volume

31921
21:07:44,320 --> 21:07:46,160
Você vai ver que o volume tem

31922
21:07:46,160 --> 21:07:49,440
Mudou porque estamos passando pelo nosso

31923
21:07:49,440 --> 21:07:50,480
público

31924
21:07:50,480 --> 21:07:52,720
setter e getters métodos para o

31925
21:07:52,720 --> 21:07:54,640
O cilindro agora vai usar isso

31926
21:07:54,640 --> 21:07:56,960
dados e para o primeiro caso aqui o

31927
21:07:56,960 --> 21:07:59,040
O cilindro vai usar os dados

31928
21:07:59,040 --> 21:08:01,440
nós usamos em nosso construtor aqui vamos

31929
21:08:01,440 --> 21:08:03,760
ambos e executar este aplicativo a compilação

31930
21:08:03,760 --> 21:08:06,480
É bom que podemos limpar e correr galo agora

31931
21:08:06,480 --> 21:08:07,832
Pela primeira vez vamos ver

31932
21:08:07,832 --> 21:08:10,400
que o nosso volume é este número e para

31933
21:08:10,400 --> 21:08:13,040
A segunda vez que o nosso volume vai para

31934
21:08:13,040 --> 21:08:16,160
ser multiplicado por 10 porque nós mudamos

31935
21:08:16,160 --> 21:08:19,360
o raio de base para 100 e se você colocar

31936
21:08:19,360 --> 21:08:21,280
Esses números em você vão ver

31937
21:08:21,280 --> 21:08:23,360
que eles fazem sentido que somos capazes de

31938
21:08:23,360 --> 21:08:26,320
modificar nossas variáveis de membro através do nosso

31939
21:08:26,320 --> 21:08:28,640
setter e getter funções e novamente

31940
21:08:28,640 --> 21:08:30,960
para esta setter e getter funções para

31941
21:08:30,960 --> 21:08:33,440
trabalho que eles têm que estar no âmbito público

31942
21:08:33,440 --> 21:08:35,360
de sua classe, porque se você fazê-los

31943
21:08:35,360 --> 21:08:36,872
Privados, eles não vão ser

31944
21:08:36,872 --> 21:08:38,960
acessível a partir do exterior e você está

31945
21:08:38,960 --> 21:08:40,720
obter um erro do compilador, vamos tentar

31946
21:08:40,720 --> 21:08:43,040
e fazer isso estamos aprendendo para que não sejamos

31947
21:08:43,040 --> 21:08:45,192
Medo de quebrar as coisas um pouco assim

31948
21:08:45,192 --> 21:08:47,440
Vamos torná-los privados, podemos fazer isso

31949
21:08:47,440 --> 21:08:50,080
e trazer isso um pouco para a esquerda

31950
21:08:50,080 --> 21:08:51,832
e no momento fazemos isso que devemos

31951
21:08:51,832 --> 21:08:54,400
tem algumas linhas squiggly em nosso principal

31952
21:08:54,400 --> 21:08:57,120
Funciona e esperamos isso porque

31953
21:08:57,120 --> 21:08:59,512
Eles são privados agora, então não temos

31954
21:08:59,512 --> 21:09:01,512
Negócios acessando a partir do principal

31955
21:09:01,512 --> 21:09:04,160
Funcional como esta que eles devem ser

31956
21:09:04,160 --> 21:09:06,320
usado a partir do interior da classe se

31957
21:09:06,320 --> 21:09:08,400
Eles são privados assim e se você

31958
21:09:08,400 --> 21:09:10,872
Tente usá-los do lado de fora, você está

31959
21:09:10,872 --> 21:09:13,192
Vou obter um erro do compilador, vamos passar

31960
21:09:13,192 --> 21:09:15,040
Isso através do gcc para realmente ver o

31961
21:09:15,040 --> 21:09:17,360
erro do compilador e nós vamos receber

31962
21:09:17,360 --> 21:09:20,080
A altura definida é privada a partir do contexto

31963
21:09:20,080 --> 21:09:22,720
da função principal e se subirmos

31964
21:09:22,720 --> 21:09:24,480
Acho que vamos ver a mesma coisa

31965
21:09:24,480 --> 21:09:28,080
para um raio de base definido e isso é aqui

31966
21:09:28,080 --> 21:09:29,920
Isso é realmente tudo o que nos prossamos fazer em

31967
21:09:29,920 --> 21:09:32,080
Esta palestra mostrando como você pode usar

31968
21:09:32,080 --> 21:09:34,320
setters e getters para manipular o seu

31969
21:09:34,320 --> 21:09:36,960
variáveis de membro de fora

31970
21:09:36,960 --> 21:09:39,360
E eu espero que você tenha encontrado isso útil, nós somos

31971
21:09:39,360 --> 21:09:41,120
Vou parar aqui nesta palestra em

31972
21:09:41,120 --> 21:09:42,720
O próximo vamos mostrar como

31973
21:09:42,720 --> 21:09:45,832
você pode dividir sua classe em vários

31974
21:09:45,832 --> 21:09:49,192
Arquivos, mas antes eu deixo você ir, vamos corrigir

31975
21:09:49,192 --> 21:09:50,960
para que não tenhamos um compilador

31976
21:09:50,960 --> 21:09:53,040
erro aqui, então vamos remover isso

31977
21:09:53,040 --> 21:09:55,680
palavra-chave privada que colocamos aqui e

31978
21:09:55,680 --> 21:09:57,600
nós vamos construir novamente para ter certeza

31979
21:09:57,600 --> 21:10:00,160
O mundo é bom vamos usar gcc para isso

31980
21:10:00,160 --> 21:10:03,040
O mundo é bom e eu vou te ver em

31981
21:10:03,040 --> 21:10:05,192
A próxima palestra vá em frente e termine

31982
21:10:05,192 --> 21:10:07,920
Aqui e encontrar-me lá nesta palestra eu

31983
21:10:07,920 --> 21:10:10,080
Vou mostrar como podemos dividir

31984
21:10:10,080 --> 21:10:13,120
nossas informações de classe em vários

31985
21:10:13,120 --> 21:10:16,080
Arquivos até agora o que temos feito é

31986
21:10:16,080 --> 21:10:18,480
realmente cramping tudo no principal

31987
21:10:18,480 --> 21:10:21,920
A função tivemos nossa constante declaração

31988
21:10:21,920 --> 21:10:24,800
nós tivemos a nossa definição da classe do cilindro e

31989
21:10:24,800 --> 21:10:27,040
Tivemos a nossa principal função para usar estes

31990
21:10:27,040 --> 21:10:30,240
coisas todas apertadas no cpp principal

31991
21:10:30,240 --> 21:10:32,240
arquivo agora vamos ver como podemos

31992
21:10:32,240 --> 21:10:34,240
fazer as coisas melhor a primeira coisa que podemos

31993
21:10:34,240 --> 21:10:38,000
fazer é mover a nossa constante em outro arquivo

31994
21:10:38,000 --> 21:10:40,800
porque se você pensar sobre isso os usuários de

31995
21:10:40,800 --> 21:10:43,360
Sua classe na função principal não

31996
21:10:43,360 --> 21:10:46,400
cuidado com este pi constante porque

31997
21:10:46,400 --> 21:10:49,192
realmente é um detalhe de implementação

31998
21:10:49,192 --> 21:10:51,600
que deve deixar em outro lugar ou mesmo

31999
21:10:51,600 --> 21:10:53,600
dentro da classe do cilindro, mas nós somos

32000
21:10:53,600 --> 21:10:55,920
Vou colocar isso em um arquivo separado

32001
21:10:55,920 --> 21:10:57,920
Porque isso vai nos dar espaço para

32002
21:10:57,920 --> 21:11:00,640
colocado como uma constante se precisamos fazer isso

32003
21:11:00,640 --> 21:11:03,360
então se dividirmos coisas assim

32004
21:11:03,360 --> 21:11:05,600
quando queremos usar a variável pi nós

32005
21:11:05,600 --> 21:11:08,320
terá de incluir o ficheiro de constantes

32006
21:11:08,320 --> 21:11:10,400
Porque isso nos dará acesso

32007
21:11:10,400 --> 21:11:12,872
para isso, mas não temos que mantê-lo

32008
21:11:12,872 --> 21:11:15,040
na função principal, então isso é um pouco

32009
21:11:15,040 --> 21:11:17,120
Melhor, mas outra coisa que podemos fazer é

32010
21:11:17,120 --> 21:11:19,832
remover o cilindro em outra separação

32011
21:11:19,832 --> 21:11:22,640
arquivar e fazer algo assim, então agora

32012
21:11:22,640 --> 21:11:25,360
você vê que a nossa declaração de cilindro

32013
21:11:25,360 --> 21:11:27,600
e a definição mudou em um arquivo

32014
21:11:27,600 --> 21:11:29,832
chamado de cilindro.h

32015
21:11:29,832 --> 21:11:32,240
e nós temos o nosso pi constante

32016
21:11:32,240 --> 21:11:33,832
Viver em outro arquivo chamado

32017
21:11:33,832 --> 21:11:35,512
Constantes.h

32018
21:11:35,512 --> 21:11:37,832
e se queremos usar nossa classe de cilindro

32019
21:11:37,832 --> 21:11:40,640
Como nós temos usado isso o tempo todo

32020
21:11:40,640 --> 21:11:43,120
terá de incluir o cabeçalho que

32021
21:11:43,120 --> 21:11:45,280
traz isso e é assim que estamos indo

32022
21:11:45,280 --> 21:11:47,600
para fazê-lo e nós seremos capazes de usá-lo

32023
21:11:47,600 --> 21:11:50,240
na função principal se configurarmos as coisas

32024
21:11:50,240 --> 21:11:52,872
assim, mas podemos ir ainda mais longe

32025
21:11:52,872 --> 21:11:55,512
pode dividir nossa declaração de classe e

32026
21:11:55,512 --> 21:11:58,240
definição em dois arquivos separados o que

32027
21:11:58,240 --> 21:11:59,600
nós vamos ter no cabeçalho é

32028
21:11:59,600 --> 21:12:01,512
Será realmente uma prévia do

32029
21:12:01,512 --> 21:12:02,400
classe de classe

32030
21:12:02,400 --> 21:12:05,192
e no arquivo cpp que será

32031
21:12:05,192 --> 21:12:05,960
Chamada

32032
21:12:05,960 --> 21:12:08,000
cylinder.cpp nós vamos ter o

32033
21:12:08,000 --> 21:12:11,440
detalhes de implementação da nossa classe e

32034
21:12:11,440 --> 21:12:13,192
Mais uma vez isso vai fazer as coisas a

32035
21:12:13,192 --> 21:12:15,680
Pouco mais fácil de gerenciar, porque é

32036
21:12:15,680 --> 21:12:17,600
Realmente não é bom ter tudo

32037
21:12:17,600 --> 21:12:20,720
Apertado em seu arquivo cpp principal

32038
21:12:20,720 --> 21:12:23,512
deve realmente ter detalhes de alto nível

32039
21:12:23,512 --> 21:12:26,400
sobre como funciona sua aplicação e tudo

32040
21:12:26,400 --> 21:12:28,552
Os detalhes de baixo nível devem ser divididos

32041
21:12:28,552 --> 21:12:31,360
em arquivos diferentes, este é um bom design

32042
21:12:31,360 --> 21:12:33,832
Agora que você tem uma ideia sobre isso

32043
21:12:33,832 --> 21:12:36,080
vamos para o código do estúdio visual

32044
21:12:36,080 --> 21:12:37,760
e mostrar como você pode fazer isso ok

32045
21:12:37,760 --> 21:12:40,320
Aqui estamos em nossa pasta de trabalho o

32046
21:12:40,320 --> 21:12:43,120
O projeto atual é classe em vários

32047
21:12:43,120 --> 21:12:46,400
Arquivos que vamos pegar nosso template

32048
21:12:46,400 --> 21:12:48,640
arquiva e colocá-los no lugar e nós estamos

32049
21:12:48,640 --> 21:12:50,640
abrir isso em código de estúdio visual

32050
21:12:50,640 --> 21:12:52,640
para que possamos realmente brincar com a gente isso

32051
21:12:52,640 --> 21:12:55,440
vai abrir a nossa pasta que podemos abrir

32052
21:12:55,440 --> 21:12:58,400
O arquivo principal do cpp que vamos limpar

32053
21:12:58,400 --> 21:13:00,480
Isso um pouco e nós vamos

32054
21:13:00,480 --> 21:13:03,040
Pegue nossa definição de classe e coloque isso

32055
21:13:03,040 --> 21:13:05,440
em cima aqui, então este é o nosso cilindro

32056
21:13:05,440 --> 21:13:07,440
classe que temos os construtores que temos

32057
21:13:07,440 --> 21:13:10,000
Funções da função de volume aqui

32058
21:13:10,000 --> 21:13:12,080
e nós temos nossos setters e getters

32059
21:13:12,080 --> 21:13:14,552
Dentro para baixo temos nossas variáveis de membro

32060
21:13:14,552 --> 21:13:16,720
que é privado para esta classe

32061
21:13:16,720 --> 21:13:19,440
Aqui agora o que queremos fazer é

32062
21:13:19,440 --> 21:13:20,400
Organizar

32063
21:13:20,400 --> 21:13:22,872
Nosso código melhor e a primeira coisa que nós

32064
21:13:22,872 --> 21:13:26,000
A necessidade é mover essa constante de

32065
21:13:26,000 --> 21:13:28,800
o arquivo principal aqui porque é realmente

32066
21:13:28,800 --> 21:13:31,832
Não tão útil neste ponto aqui usuários

32067
21:13:31,832 --> 21:13:33,832
De suas aulas não se importarão com

32068
21:13:33,832 --> 21:13:36,080
O que é porque é um

32069
21:13:36,080 --> 21:13:38,320
detalhe da implementação para o cilindro

32070
21:13:38,320 --> 21:13:40,320
classe porque estamos usando isso para

32071
21:13:40,320 --> 21:13:42,800
calcular o nosso volume para que esta constante

32072
21:13:42,800 --> 21:13:45,192
Realmente não tem negócio estar no principal

32073
21:13:45,192 --> 21:13:46,960
arquivo vamos mover isso em um

32074
21:13:46,960 --> 21:13:48,552
arquivo separado que vamos configurar um

32075
21:13:48,552 --> 21:13:50,240
Novo arquivo vamos chegar à esquerda

32076
21:13:50,240 --> 21:13:52,960
aqui clique no ícone de mais aqui que

32077
21:13:52,960 --> 21:13:55,040
Diz novo arquivo que vamos dizer

32078
21:13:55,040 --> 21:13:57,720
Constantes e nós vamos chamar isso

32079
21:13:57,720 --> 21:13:59,832
constants.h porque vai ser um

32080
21:13:59,832 --> 21:14:02,800
arquivo de cabeçalho e podemos simplesmente vir de

32081
21:14:02,800 --> 21:14:03,832
O que é

32082
21:14:03,832 --> 21:14:06,320
arquivo cpp principal vamos copiar este

32083
21:14:06,320 --> 21:14:08,240
nós vamos cortar isso na verdade e

32084
21:14:08,240 --> 21:14:11,120
nós vamos colocar isso em nossa separação

32085
21:14:11,120 --> 21:14:13,832
arquivo que é constants.h

32086
21:14:13,832 --> 21:14:15,760
Depois de fazermos isso, vamos entrar

32087
21:14:15,760 --> 21:14:18,160
nosso arquivo principal cpp e nós vamos

32088
21:14:18,160 --> 21:14:20,800
incluir esse arquivo de cabeçalho, então vamos fazer

32089
21:14:20,800 --> 21:14:24,160
que vamos incluir constantes.h

32090
21:14:24,160 --> 21:14:25,600
E no momento em que fazemos isso você está indo

32091
21:14:25,600 --> 21:14:28,080
para ver agora o código do estúdio visual sabe

32092
21:14:28,080 --> 21:14:30,720
onde essa constante é, mas nós não temos

32093
21:14:30,720 --> 21:14:32,800
para lidar com isso diretamente aqui outro

32094
21:14:32,800 --> 21:14:34,720
O benefício de fazer coisas como este é

32095
21:14:34,720 --> 21:14:37,280
que podemos ir neste arquivo de cabeçalho e

32096
21:14:37,280 --> 21:14:40,400
Declarar milhares de outras constantes e

32097
21:14:40,400 --> 21:14:42,400
Podemos ter acesso a eles em geral

32098
21:14:42,400 --> 21:14:46,240
função apenas usando esta única linha

32099
21:14:46,240 --> 21:14:48,720
que inclui o nosso arquivo aqui, então este é

32100
21:14:48,720 --> 21:14:51,040
bom design se nós construímos nossa aplicação

32101
21:14:51,040 --> 21:14:52,480
você vai ver que vai

32102
21:14:52,480 --> 21:14:54,800
trabalho, vamos tentar montar um cilindro

32103
21:14:54,800 --> 21:14:57,680
Objeto vamos dizer cilindro 1 e

32104
21:14:57,680 --> 21:15:00,720
vamos colocar 10 e 10 n como nosso

32105
21:15:00,720 --> 21:15:02,552
parâmetros e vamos imprimir o

32106
21:15:02,552 --> 21:15:04,800
volume deste pequeno rapaz, então isto é

32107
21:15:04,800 --> 21:15:07,192
Fácil de fazer agora vamos dizer volume

32108
21:15:07,192 --> 21:15:08,800
E nós vamos imprimir isso

32109
21:15:08,800 --> 21:15:10,800
um cilindro e vamos chamar o

32110
21:15:10,800 --> 21:15:13,120
método de volume e isso vai imprimir

32111
21:15:13,120 --> 21:15:15,680
Nosso polegar e de novo eu vou ser

32112
21:15:15,680 --> 21:15:19,440
Usando os termos funções e métodos

32113
21:15:19,440 --> 21:15:21,440
intercambiavelmente neste curso e o que

32114
21:15:21,440 --> 21:15:23,760
Quero dizer, no contexto da classe

32115
21:15:23,760 --> 21:15:25,600
que serão as funções dos membros

32116
21:15:25,600 --> 21:15:27,680
da classe, então não se confunda com

32117
21:15:27,680 --> 21:15:30,160
isso aqui se construirmos e executarmos isso

32118
21:15:30,160 --> 21:15:32,960
Aplicação deve estar funcionando corretamente

32119
21:15:32,960 --> 21:15:35,680
Porque temos tudo o que precisamos para

32120
21:15:35,680 --> 21:15:37,040
Isso para trabalhar

32121
21:15:37,040 --> 21:15:39,192
Vamos ver se o mundo era bom

32122
21:15:39,192 --> 21:15:41,280
A construção foi boa, podemos trazer uma

32123
21:15:41,280 --> 21:15:43,512
terminal e realmente executar isso vamos

32124
21:15:43,512 --> 21:15:45,832
claro e correr galo isto vai

32125
21:15:45,832 --> 21:15:47,832
imprimir o nosso volume para que o código esteja funcionando

32126
21:15:47,832 --> 21:15:49,920
A segunda coisa que queremos fazer é

32127
21:15:49,920 --> 21:15:52,480
para mover esta classe todos juntos em

32128
21:15:52,480 --> 21:15:54,552
Outro arquivo porque nós realmente não

32129
21:15:54,552 --> 21:15:56,800
Quero vê-lo

32130
21:15:56,800 --> 21:15:59,120
aqui na função principal o que realmente

32131
21:15:59,120 --> 21:16:01,760
Quero é usar coisas e não nos importamos

32132
21:16:01,760 --> 21:16:04,400
sobre como essas coisas são estabelecidas no

32133
21:16:04,400 --> 21:16:07,440
mesma lógica que usamos quando usamos std

32134
21:16:07,440 --> 21:16:09,600
força nós realmente não nos importamos com como

32135
21:16:09,600 --> 21:16:12,400
A força hdd é montada todos nós

32136
21:16:12,400 --> 21:16:14,640
Realmente queria incluir a classe

32137
21:16:14,640 --> 21:16:18,080
que o traz e o usa em nosso código

32138
21:16:18,080 --> 21:16:20,160
nós vamos estar montando o mesmo

32139
21:16:20,160 --> 21:16:22,800
comportamento para a nossa classe de cilindro aqui e

32140
21:16:22,800 --> 21:16:24,720
vai ser dado em seu próprio

32141
21:16:24,720 --> 21:16:27,280
arquivo separado, então vamos configurar outro

32142
21:16:27,280 --> 21:16:28,872
arquivo de cabeçalho vamos chamar isso

32143
21:16:28,872 --> 21:16:31,512
cilindro dot h e nós vamos agarrar

32144
21:16:31,512 --> 21:16:33,920
nossa definição de classe todos juntos, então

32145
21:16:33,920 --> 21:16:36,720
nós vamos do fundo aqui

32146
21:16:36,720 --> 21:16:39,280
e selecione tudo o que inclui o nosso

32147
21:16:39,280 --> 21:16:41,360
classe, vamos cortar isso, estamos

32148
21:16:41,360 --> 21:16:43,832
indo para ir em nosso cabeçalho de cilindro e

32149
21:16:43,832 --> 21:16:46,000
nós vamos colar isso lá e

32150
21:16:46,000 --> 21:16:47,680
Vamos voltar ao nosso principal

32151
21:16:47,680 --> 21:16:50,160
arquivo e incluir nossa classe de cilindro assim

32152
21:16:50,160 --> 21:16:52,640
Vamos fazer isso, vamos incluir e

32153
21:16:52,640 --> 21:16:54,872
nós vamos dizer cilindro.h

32154
21:16:54,872 --> 21:16:56,960
E isso vai fazer as coisas funcionarem

32155
21:16:56,960 --> 21:16:59,440
Lembre-se que o pré-processador vai

32156
21:16:59,440 --> 21:17:01,760
colocar essas coisas no pré-processador é

32157
21:17:01,760 --> 21:17:04,000
basicamente indo em constantes é

32158
21:17:04,000 --> 21:17:06,320
Vou levar tudo o que está dentro e

32159
21:17:06,320 --> 21:17:08,872
então vai colar isso aqui e

32160
21:17:08,872 --> 21:17:11,280
Vai levar tudo para dentro do nosso

32161
21:17:11,280 --> 21:17:13,192
classe de cilindro e vai colar

32162
21:17:13,192 --> 21:17:15,760
Isso aqui, então basicamente vai ser

32163
21:17:15,760 --> 21:17:18,160
como se estejamos declarando essas coisas em

32164
21:17:18,160 --> 21:17:20,400
A função principal, mas o nosso código está indo

32165
21:17:20,400 --> 21:17:23,040
Estar melhor organizado agora se tentarmos

32166
21:17:23,040 --> 21:17:25,360
Construa este programa que vai para o mundo

32167
21:17:25,360 --> 21:17:27,920
exatamente como ele fez porque temos tudo

32168
21:17:27,920 --> 21:17:30,400
A informação para o seu mundo vamos

32169
21:17:30,400 --> 21:17:32,720
O mundo da construção acabou com sucesso

32170
21:17:32,720 --> 21:17:35,120
O mundo é bom e nós podemos executar isso

32171
21:17:35,120 --> 21:17:36,960
programa e vai fazer o que era

32172
21:17:36,960 --> 21:17:39,192
Fazendo o tempo todo nós podemos limpar e correr

32173
21:17:39,192 --> 21:17:41,680
O galo não se preocupa com o estúdio visual

32174
21:17:41,680 --> 21:17:43,512
Código aqui não sei qual é o problema

32175
21:17:43,512 --> 21:17:45,920
É com isso que é apenas ter ah é

32176
21:17:45,920 --> 21:17:48,320
tendo um problema com o pi

32177
21:17:48,320 --> 21:17:50,320
constante aqui porque não está incluído

32178
21:17:50,320 --> 21:17:53,512
Aqui, então o que podemos fazer é dizer que incluem

32179
21:17:53,512 --> 21:17:56,720
e incluir o nosso cabeçalho constante e se

32180
21:17:56,720 --> 21:17:58,640
Fazemos isso o problema aqui vai

32181
21:17:58,640 --> 21:18:01,360
ir embora, mas nós vamos ter um

32182
21:18:01,360 --> 21:18:03,360
problema se estamos tentando executar isso

32183
21:18:03,360 --> 21:18:05,600
Programa agora porque tente pensar em

32184
21:18:05,600 --> 21:18:08,080
na função principal que estamos incluindo

32185
21:18:08,080 --> 21:18:09,920
O cabeçalho das constantes

32186
21:18:09,920 --> 21:18:11,680
E no

32187
21:18:11,680 --> 21:18:14,552
cabeçalho do cilindro que também estamos incluindo

32188
21:18:14,552 --> 21:18:17,440
Este garotinho aqui, então se o processador

32189
21:18:17,440 --> 21:18:19,680
Vem que vai incluir

32190
21:18:19,680 --> 21:18:21,920
Isso e vai ter esse pouco

32191
21:18:21,920 --> 21:18:24,400
Cara dentro da nossa principal função e

32192
21:18:24,400 --> 21:18:26,400
O cilindro também vai incluir isso

32193
21:18:26,400 --> 21:18:29,040
porque está incluindo este cabeçalho assim

32194
21:18:29,040 --> 21:18:31,440
Quando o pré-processador é feito, nós somos

32195
21:18:31,440 --> 21:18:34,000
ter nossa constante aqui declarada

32196
21:18:34,000 --> 21:18:36,240
duas vezes e se tentarmos construir isso

32197
21:18:36,240 --> 21:18:38,320
programa que você pode esperar coisas ruins para

32198
21:18:38,320 --> 21:18:40,720
Acontecer porque não é realmente bom

32199
21:18:40,720 --> 21:18:43,512
ter a mesma coisa definida mais do que

32200
21:18:43,512 --> 21:18:47,040
Uma vez em todo o seu programa e vamos

32201
21:18:47,040 --> 21:18:48,720
Tente construir e mostrar isso

32202
21:18:48,720 --> 21:18:50,240
Espero que consigamos um compilador

32203
21:18:50,240 --> 21:18:51,040
Erro de erro

32204
21:18:51,040 --> 21:18:53,040
E vai explodir na nossa cara

32205
21:18:53,040 --> 21:18:55,440
vai dizer herói redefinição de

32206
21:18:55,440 --> 21:18:58,640
const double pi então o que está acontecendo aqui

32207
21:18:58,640 --> 21:19:01,760
Estamos incluindo essa coisa duas vezes uma

32208
21:19:01,760 --> 21:19:04,320
Aqui e na segunda vez está chegando

32209
21:19:04,320 --> 21:19:06,640
diretamente da classe do cilindro

32210
21:19:06,640 --> 21:19:09,280
porque nós estamos incluindo isso neste

32211
21:19:09,280 --> 21:19:11,920
localização aqui e qual é o pré-processador

32212
21:19:11,920 --> 21:19:14,000
É basicamente ir fazer isso vai

32213
21:19:14,000 --> 21:19:16,552
copiar o arquivo inteiro aqui e ele está indo

32214
21:19:16,552 --> 21:19:19,832
para colar isso no lugar do cilindro.h

32215
21:19:19,832 --> 21:19:22,080
Aqui e este cabeçalho constante é

32216
21:19:22,080 --> 21:19:24,320
basicamente será incluído duas vezes, então

32217
21:19:24,320 --> 21:19:26,160
vai ser redefinido aqui que é

32218
21:19:26,160 --> 21:19:28,800
O problema que temos uma maneira que temos que

32219
21:19:28,800 --> 21:19:32,160
resolver isso em c plus plus é usando

32220
21:19:32,160 --> 21:19:34,800
incluir acordes e a maneira como fazemos isso

32221
21:19:34,800 --> 21:19:37,680
Venha em nosso cabeçalho constante e nós dizemos

32222
21:19:37,680 --> 21:19:39,440
bata de libra se

32223
21:19:39,440 --> 21:19:40,552
e def

32224
21:19:40,552 --> 21:19:42,240
Esta é uma maneira de dizer

32225
21:19:42,240 --> 21:19:45,040
Se algo ainda não está definido e

32226
21:19:45,040 --> 21:19:48,000
Vamos dizer cilindro sublinhado h e

32227
21:19:48,000 --> 21:19:49,920
nós vamos dizer definir

32228
21:19:49,920 --> 21:19:52,480
cilindro ressaltar h e nós vamos

32229
21:19:52,480 --> 21:19:56,160
descer até o fim e dizer e f isso

32230
21:19:56,160 --> 21:19:57,600
É uma maneira que temos que dizer o

32231
21:19:57,600 --> 21:20:00,960
pré-processador para fazer apenas algo ou

32232
21:20:00,960 --> 21:20:03,600
incluir o código que temos dentro destes

32233
21:20:03,600 --> 21:20:07,832
coisas se a condição no topo aqui é

32234
21:20:07,832 --> 21:20:10,720
satisfeito, por exemplo, o código dentro

32235
21:20:10,720 --> 21:20:14,080
Aqui vai ser colocado em nosso c plus

32236
21:20:14,080 --> 21:20:15,440
arquivo de origem

32237
21:20:15,440 --> 21:20:18,960
se o nome do cilindro aqui não estiver definido

32238
21:20:18,960 --> 21:20:21,360
nos olhos do pré-processador, então é

32239
21:20:21,360 --> 21:20:24,400
indo para dizer se cilindro sublinhado h é

32240
21:20:24,400 --> 21:20:26,872
Não definido, vou definir isso

32241
21:20:26,872 --> 21:20:29,360
e eu vou colocar este código aqui, mas

32242
21:20:29,360 --> 21:20:31,120
Se já estiver definido, vai

32243
21:20:31,120 --> 21:20:32,872
pule todas essas coisas e não está indo

32244
21:20:32,872 --> 21:20:34,872
para incluir isso ok, então este é o

32245
21:20:34,872 --> 21:20:37,120
lógica aqui e eu notei que isso é realmente

32246
21:20:37,120 --> 21:20:39,120
Não um arquivo de cilindro, então vamos

32247
21:20:39,120 --> 21:20:41,120
Mudar isso para constantes

32248
21:20:41,120 --> 21:20:44,000
ressaltar h vamos dizer isso e vamos fazer

32249
21:20:44,000 --> 21:20:46,000
O mesmo aqui e isso vai fazer

32250
21:20:46,000 --> 21:20:48,640
nossa coisa e nós vamos entrar no nosso

32251
21:20:48,640 --> 21:20:51,120
cabeçalho do cilindro e fazer a mesma coisa

32252
21:20:51,120 --> 21:20:54,080
e colocar em nossa casa de guarda é

32253
21:20:54,080 --> 21:20:56,800
Basicamente um guarda que vai proteger

32254
21:20:56,800 --> 21:20:58,552
Contra alguma coisa

32255
21:20:58,552 --> 21:21:01,440
ser incluído mais de uma vez

32256
21:21:01,440 --> 21:21:03,832
então vamos fazer isso em nosso cabeçalho de cilindro

32257
21:21:03,832 --> 21:21:06,240
então nós vamos envolver isso dentro do nosso

32258
21:21:06,240 --> 21:21:08,872
incluir guardas, vamos dizer se n

32259
21:21:08,872 --> 21:21:10,872
def you see visual studio code é realmente

32260
21:21:10,872 --> 21:21:12,552
ajudando aqui e nós vamos colocar

32261
21:21:12,552 --> 21:21:14,552
no nome que vamos usar para isso

32262
21:21:14,552 --> 21:21:16,872
Esta é uma classe de cilindros, então eu acho que

32263
21:21:16,872 --> 21:21:19,192
Faz sentido chamar este cilindro

32264
21:21:19,192 --> 21:21:21,512
ressaltar h e nós vamos fazer o

32265
21:21:21,512 --> 21:21:24,800
A mesma coisa define cilindro e

32266
21:21:24,800 --> 21:21:27,360
nós vamos terminar f no final do

32267
21:21:27,360 --> 21:21:29,440
arquivo aqui para que vamos dizer fim f

32268
21:21:29,440 --> 21:21:31,280
e novamente esta é a sintaxe do

32269
21:21:31,280 --> 21:21:33,680
pré-processador eu não quero ficar muito

32270
21:21:33,680 --> 21:21:35,440
muito sobre isso porque vamos aprender

32271
21:21:35,440 --> 21:21:37,920
Mais adiante no curso, mas

32272
21:21:37,920 --> 21:21:41,040
Agora pode usar isso para proteger contra

32273
21:21:41,040 --> 21:21:44,232
Algo sendo incluído mais de uma vez

32274
21:21:44,232 --> 21:21:46,080
e se estamos tentando construir o programa

32275
21:21:46,080 --> 21:21:48,080
Agora espero que vá para o mundo vamos

32276
21:21:48,080 --> 21:21:50,480
use o gcc e agora você vê que o

32277
21:21:50,480 --> 21:21:53,920
O mundo é bom mesmo se estivermos incluindo

32278
21:21:53,920 --> 21:21:56,552
o cabeçalho constante várias vezes em

32279
21:21:56,552 --> 21:21:59,680
o arquivo principal aqui nós podemos até mesmo ir para baixo

32280
21:21:59,680 --> 21:22:02,000
e fazer isso mil vezes assim

32281
21:22:02,000 --> 21:22:03,600
Vamos fazer isso e você vai ver

32282
21:22:03,600 --> 21:22:05,920
que se tentarmos compilar isso vai

32283
21:22:05,920 --> 21:22:09,440
boil define porque agora temos um guarda

32284
21:22:09,440 --> 21:22:11,360
proteger contra a inclusão desta coisa

32285
21:22:11,360 --> 21:22:13,360
mais de uma vez, o pré-processador é

32286
21:22:13,360 --> 21:22:15,832
basicamente vai entrar aqui e dizer

32287
21:22:15,832 --> 21:22:16,800
Se for

32288
21:22:16,800 --> 21:22:19,440
O nome da constante não está definido

32289
21:22:19,440 --> 21:22:21,920
Vou definir esse nome

32290
21:22:21,920 --> 21:22:24,160
e vou colocar o código aqui em

32291
21:22:24,160 --> 21:22:26,400
O arquivo fonte que me inclui

32292
21:22:26,400 --> 21:22:29,040
Se isso já estiver definido,

32293
21:22:29,040 --> 21:22:30,960
A condição aqui vai falhar não é

32294
21:22:30,960 --> 21:22:33,920
indo fazer mais do que neste arquivo

32295
21:22:33,920 --> 21:22:35,680
O pré-processador está basicamente indo para

32296
21:22:35,680 --> 21:22:38,000
desistir deste arquivo aqui é o que eu

32297
21:22:38,000 --> 21:22:40,720
Quer que você saiba que agora devemos ser

32298
21:22:40,720 --> 21:22:43,280
capaz de dividir nosso código em múltiplos

32299
21:22:43,280 --> 21:22:45,760
Arquivos e agora que eu penso sobre isso nós

32300
21:22:45,760 --> 21:22:47,120
Não precisa realmente incluir o

32301
21:22:47,120 --> 21:22:49,120
Constants header aqui porque está indo

32302
21:22:49,120 --> 21:22:51,440
para ser ampliado pela classe de cilindros

32303
21:22:51,440 --> 21:22:53,680
Mas foi uma boa oportunidade para ensinar

32304
21:22:53,680 --> 21:22:56,160
você sobre os protetores incluem aqui agora

32305
21:22:56,160 --> 21:22:57,680
que você percebe que vamos remover

32306
21:22:57,680 --> 21:22:59,280
Isso e nós vamos construir e mostrar

32307
21:22:59,280 --> 21:23:01,920
você que isso vai funcionar de qualquer maneira, então

32308
21:23:01,920 --> 21:23:04,640
solda é bom que podemos executar nosso programa

32309
21:23:04,640 --> 21:23:06,960
claro e correr galo isto vai

32310
21:23:06,960 --> 21:23:08,552
trabalhar a última coisa que quero te mostrar

32311
21:23:08,552 --> 21:23:11,760
é que podemos ir ainda mais longe e dividir

32312
21:23:11,760 --> 21:23:14,800
nossa classe em dois arquivos separados

32313
21:23:14,800 --> 21:23:16,872
Porque as pessoas que vêm ao cabeçalho

32314
21:23:16,872 --> 21:23:19,920
O arquivo geralmente está interessado em seu

32315
21:23:19,920 --> 21:23:23,192
Definição de classe que eles realmente não são

32316
21:23:23,192 --> 21:23:25,280
interessado na sua implementação

32317
21:23:25,280 --> 21:23:27,512
Detalhes, por exemplo, querem ver

32318
21:23:27,512 --> 21:23:30,232
que você tem uma função de volume e eles

32319
21:23:30,232 --> 21:23:32,160
Quer saber que eles podem chamar isso

32320
21:23:32,160 --> 21:23:34,400
Função, mas eles realmente não querem

32321
21:23:34,400 --> 21:23:36,640
Saiba como você calcula seu volume e nós

32322
21:23:36,640 --> 21:23:38,640
pode realmente tornar os eventos simples para eles

32323
21:23:38,640 --> 21:23:41,512
e ocultar os detalhes da implementação em um

32324
21:23:41,512 --> 21:23:44,160
arquivo cpp separado então vamos fazer isso que estamos

32325
21:23:44,160 --> 21:23:46,232
vamos configurar um novo arquivo cpp que estamos

32326
21:23:46,232 --> 21:23:48,960
vou chamar este cilindro que é cpp

32327
21:23:48,960 --> 21:23:50,480
E nós vamos para

32328
21:23:50,480 --> 21:23:53,192
mover as implementações

32329
21:23:53,192 --> 21:23:55,280
das nossas funções

32330
21:23:55,280 --> 21:23:58,800
no arquivo cpp e eu estou fazendo isso apenas

32331
21:23:58,800 --> 21:24:01,192
para mostrar que é possível em

32332
21:24:01,192 --> 21:24:02,872
prática que você vai ter que decidir

32333
21:24:02,872 --> 21:24:04,552
para si mesmo o que você quer manter

32334
21:24:04,552 --> 21:24:06,640
O arquivo de cabeçalho e o que você quer

32335
21:24:06,640 --> 21:24:09,920
manter no arquivo cpp para o cilindro

32336
21:24:09,920 --> 21:24:11,512
O construtor padrão aqui vai

32337
21:24:11,512 --> 21:24:14,320
Mantenha este caminho, mas nós podemos mover o outro

32338
21:24:14,320 --> 21:24:16,960
construtor aqui no arquivo cpp e

32339
21:24:16,960 --> 21:24:18,800
Como fazemos isso, vamos simplesmente pegar

32340
21:24:18,800 --> 21:24:20,800
Isso e eu vou mudar essa linha

32341
21:24:20,800 --> 21:24:23,120
por linha para que você possa ver isso

32342
21:24:23,120 --> 21:24:25,120
e no arquivo cpp a primeira coisa que nós

32343
21:24:25,120 --> 21:24:27,600
Quer fazer é incluir o cilindro

32344
21:24:27,600 --> 21:24:30,000
cabeçalho porque implementações aqui

32345
21:24:30,000 --> 21:24:32,640
Vai usar isso

32346
21:24:32,640 --> 21:24:33,760
e nós vamos colocar em nosso

32347
21:24:33,760 --> 21:24:36,720
construtor e modificá-lo para ser apto para

32348
21:24:36,720 --> 21:24:39,760
Vivendo em um arquivo cpp, então vamos vir aqui

32349
21:24:39,760 --> 21:24:42,480
e faça isso da maneira que dizemos isso que

32350
21:24:42,480 --> 21:24:44,400
Esta é realmente uma implementação de

32351
21:24:44,400 --> 21:24:47,192
A função que temos em nosso cabeçalho aqui é

32352
21:24:47,192 --> 21:24:49,040
para colocar o nome da classe na frente, estamos

32353
21:24:49,040 --> 21:24:50,960
Vou dizer cilindro e colocar dois

32354
21:24:50,960 --> 21:24:53,192
colunas no momento em que fazemos que

32355
21:24:53,192 --> 21:24:55,120
O compilador vai saber que este é

32356
21:24:55,120 --> 21:24:58,000
uma implementação de uma função que temos

32357
21:24:58,000 --> 21:24:59,680
em nosso arquivo de cabeçalho e este é o

32358
21:24:59,680 --> 21:25:02,640
Função aqui e agora podemos tirar

32359
21:25:02,640 --> 21:25:05,192
o corpo aqui e viver isso como um

32360
21:25:05,192 --> 21:25:07,512
protótipo para a função que é nossa

32361
21:25:07,512 --> 21:25:09,760
visão do construtor, podemos fazer isso

32362
21:25:09,760 --> 21:25:12,232
Tudo bem se fizermos isso no mundo, o código é

32363
21:25:12,232 --> 21:25:13,920
indo para o mundo vai construir

32364
21:25:13,920 --> 21:25:16,960
nossos objetos vamos voltar no cpb principal

32365
21:25:16,960 --> 21:25:18,232
E certifique-se de que esse é o

32366
21:25:18,232 --> 21:25:20,960
Construtor que estamos usando é que podemos

32367
21:25:20,960 --> 21:25:24,160
soldar e certificar-se de que o que acabamos de fazer

32368
21:25:24,160 --> 21:25:26,320
Não quebre nada que estamos construindo

32369
21:25:26,320 --> 21:25:28,872
e nós podemos esclarecer as coisas um pouco

32370
21:25:28,872 --> 21:25:31,280
e correr galo este vai dar-nos

32371
21:25:31,280 --> 21:25:34,480
nosso volume e começamos a dividir

32372
21:25:34,480 --> 21:25:35,920
As coisas para cima

32373
21:25:35,920 --> 21:25:38,000
em nossa classe aqui algumas coisas estão indo

32374
21:25:38,000 --> 21:25:40,080
para sair no arquivo de cabeçalho algum outro

32375
21:25:40,080 --> 21:25:41,280
As coisas vão sair no

32376
21:25:41,280 --> 21:25:43,760
arquivo de implementação para que tenhamos movido o nosso

32377
21:25:43,760 --> 21:25:45,512
Construtor aqui vamos mover o volume

32378
21:25:45,512 --> 21:25:47,512
função podemos agarrá-lo e eu me movo

32379
21:25:47,512 --> 21:25:49,680
coisas linha por linha eu acho que este é o

32380
21:25:49,680 --> 21:25:51,512
A melhor maneira de aprender

32381
21:25:51,512 --> 21:25:53,920
e eu acho que nós podemos mover essas coisas a

32382
21:25:53,920 --> 21:25:56,640
Um pouco para a esquerda vamos fazer isso e

32383
21:25:56,640 --> 21:25:58,400
nós vamos dizer que isso é um

32384
21:25:58,400 --> 21:26:01,040
Implementação de funções para alguns

32385
21:26:01,040 --> 21:26:03,120
Função declarada na classe

32386
21:26:03,120 --> 21:26:05,600
Aqui vamos dizer cilindro e

32387
21:26:05,600 --> 21:26:07,680
Vamos colocar duas colunas que isto é

32388
21:26:07,680 --> 21:26:09,360
Vou dizer ao compilador que este é um

32389
21:26:09,360 --> 21:26:12,400
implementação da função que temos

32390
21:26:12,400 --> 21:26:15,600
em nossa classe e o tipo de retorno tem que

32391
21:26:15,600 --> 21:26:18,720
viver em frente a esta resolução de âmbito

32392
21:26:18,720 --> 21:26:21,280
Operador bem o que temos aqui cilindro

32393
21:26:21,280 --> 21:26:23,760
coluna de coluna é chamada de escopo

32394
21:26:23,760 --> 21:26:26,080
Operador de resolução e é basicamente

32395
21:26:26,080 --> 21:26:29,192
dizendo ao compilador que nossa função

32396
21:26:29,192 --> 21:26:32,400
chamadas folhas de volume no âmbito do

32397
21:26:32,400 --> 21:26:34,800
classe de cilindro é isso que é a sintaxe

32398
21:26:34,800 --> 21:26:37,120
Aqui está dizendo e essa coisinha

32399
21:26:37,120 --> 21:26:39,192
Aqui é chamado de resolução de escopo

32400
21:26:39,192 --> 21:26:40,400
o operador

32401
21:26:40,400 --> 21:26:42,720
Tudo bem para que tenhamos movido nosso volume

32402
21:26:42,720 --> 21:26:45,360
Função que podemos agora tirar o corpo

32403
21:26:45,360 --> 21:26:48,000
da classe e manter o protótipo

32404
21:26:48,000 --> 21:26:50,232
Aqui podemos descer e realmente praticar

32405
21:26:50,232 --> 21:26:52,232
nos setters e jacarés, então vamos fazer

32406
21:26:52,232 --> 21:26:54,232
que vamos pegar todos eles

32407
21:26:54,232 --> 21:26:56,640
juntos porque agora você tem a essência

32408
21:26:56,640 --> 21:26:59,360
sobre como isso funciona, podemos copiá-los

32409
21:26:59,360 --> 21:27:02,400
e movê-los para o arquivo cpp e

32410
21:27:02,400 --> 21:27:04,232
vamos consertar o código por

32411
21:27:04,232 --> 21:27:07,120
linha aqui, então vamos ter certeza de que eles são

32412
21:27:07,120 --> 21:27:11,040
alinhados corretamente, temos dois a fazer

32413
21:27:11,040 --> 21:27:13,280
Vamos fazer isso e eu realmente tenho que mostrar

32414
21:27:13,280 --> 21:27:15,280
Esta vida porque algumas pessoas são

32415
21:27:15,280 --> 21:27:18,160
Vou ter problemas em relação a como eu

32416
21:27:18,160 --> 21:27:20,640
Fiz isso, então eu quero que você veja isso ao vivo

32417
21:27:20,640 --> 21:27:23,192
Como eu faço isso eu não vou editar isso

32418
21:27:23,192 --> 21:27:25,440
fora, então nós vamos colocar o nosso escopo

32419
21:27:25,440 --> 21:27:28,000
operador de resolução após nosso retorno

32420
21:27:28,000 --> 21:27:30,000
Digite aqui eu vou dizer cilindro

32421
21:27:30,000 --> 21:27:32,640
cilindro não pode digitar posso fazer bem que temos

32422
21:27:32,640 --> 21:27:35,680
Isso e podemos realmente copiar isso e

32423
21:27:35,680 --> 21:27:37,760
colar isso no lugar onde quer que esteja

32424
21:27:37,760 --> 21:27:40,320
Eu preciso para que eu vou colar que aqui eu

32425
21:27:40,320 --> 21:27:42,480
Vou colar isso aqui e eu estou

32426
21:27:42,480 --> 21:27:44,960
Vou colar que aqui agora temos

32427
21:27:44,960 --> 21:27:47,440
moveu com sucesso todas as funções em

32428
21:27:47,440 --> 21:27:49,720
O ficheiro de execução

32429
21:27:49,720 --> 21:27:52,800
cylinder.cpp e nós podemos voltar em nosso

32430
21:27:52,800 --> 21:27:54,960
cabecear e remover os corpos porque nós

32431
21:27:54,960 --> 21:27:57,360
Não preciso deles aqui se nós os mantivermos

32432
21:27:57,360 --> 21:27:59,040
Aqui vamos ter duas definições

32433
21:27:59,040 --> 21:28:00,960
para essas funções e nós vamos

32434
21:28:00,960 --> 21:28:03,680
ter erros de compilador, vamos tirar isso

32435
21:28:03,680 --> 21:28:05,440
nós vamos tirar o corpo para fora nós

32436
21:28:05,440 --> 21:28:07,360
Vou tirar o corpo e nós estamos

32437
21:28:07,360 --> 21:28:09,360
Vou tirar o corpo, vamos fazer isso

32438
21:28:09,360 --> 21:28:11,920
para um raio base do portão aqui

32439
21:28:11,920 --> 21:28:14,320
E agora, se construirmos o nosso programa

32440
21:28:14,320 --> 21:28:17,120
Devia trabalhar, vamos trabalhar com gcc

32441
21:28:17,120 --> 21:28:19,040
Veja que o mundo é bom e se tentarmos

32442
21:28:19,040 --> 21:28:21,360
executar o programa que deve nos dar o que

32443
21:28:21,360 --> 21:28:23,680
foi dado antes que este é o volume

32444
21:28:23,680 --> 21:28:24,480
Aqui

32445
21:28:24,480 --> 21:28:26,720
Uma coisa que eu quero que você veja é que você

32446
21:28:26,720 --> 21:28:29,760
Não quero manter duas definições para

32447
21:28:29,760 --> 21:28:32,320
suas funções, por exemplo, podemos

32448
21:28:32,320 --> 21:28:34,720
Pegue o corpo aqui e traga isso de volta

32449
21:28:34,720 --> 21:28:36,400
no arquivo de cabeçalho eu quero que você veja

32450
21:28:36,400 --> 21:28:38,400
O que vai acontecer se você fizer isso eu

32451
21:28:38,400 --> 21:28:41,192
Vou colar isso aqui e eu estou

32452
21:28:41,192 --> 21:28:43,192
Vou mover as coisas um pouco para o

32453
21:28:43,192 --> 21:28:46,000
certo para alinhar as coisas corretamente aqui, então

32454
21:28:46,000 --> 21:28:48,320
Se fizermos isso, o compilador vai fazer

32455
21:28:48,320 --> 21:28:51,192
Veja que estamos chamando esse construtor

32456
21:28:51,192 --> 21:28:53,040
e o compilador vai ter não

32457
21:28:53,040 --> 21:28:55,360
problema conosco, mas uma vez que nós batemos o

32458
21:28:55,360 --> 21:28:57,832
encenação do linker que o linker vai encontrar

32459
21:28:57,832 --> 21:28:59,760
que temos duas definições para o

32460
21:28:59,760 --> 21:29:02,000
construtor aqui temos um no

32461
21:29:02,000 --> 21:29:04,320
cabeçalho e nós temos um no

32462
21:29:04,320 --> 21:29:07,040
Arquivo de implementação e isso está indo para

32463
21:29:07,040 --> 21:29:09,600
aumentar um erro do compilador dizendo que temos

32464
21:29:09,600 --> 21:29:12,400
duas definições para o construtor aqui

32465
21:29:12,400 --> 21:29:14,960
e o linker quer saber qual deles

32466
21:29:14,960 --> 21:29:17,040
Use para que ele lhe dê um erro

32467
21:29:17,040 --> 21:29:18,800
Vamos construir e realmente mostrar isso

32468
21:29:18,800 --> 21:29:21,192
Porque isso pode ser difícil de depurar se você

32469
21:29:21,192 --> 21:29:22,872
Não sei o que está acontecendo bem você

32470
21:29:22,872 --> 21:29:25,920
Vejamos o mundo terminado com erros

32471
21:29:25,920 --> 21:29:28,720
e o problema é cilindro do cilindro

32472
21:29:28,720 --> 21:29:31,280
duplo duplo é redefinido que não queremos

32473
21:29:31,280 --> 21:29:33,680
ter duas definições para a soma

32474
21:29:33,680 --> 21:29:36,232
função assim, uma vez que você move as coisas de

32475
21:29:36,232 --> 21:29:39,040
cabeçalho para arquivo de implementação, certifique-se

32476
21:29:39,040 --> 21:29:41,600
Você não tem mais definições

32477
21:29:41,600 --> 21:29:43,760
no cabeçalho ou você vai ter

32478
21:29:43,760 --> 21:29:46,552
Realmente difícil de depurar problemas

32479
21:29:46,552 --> 21:29:49,440
E agora acho que temos o nosso programa

32480
21:29:49,440 --> 21:29:52,720
organizado bastante bem para o que sabemos

32481
21:29:52,720 --> 21:29:55,600
até agora sobre c plus mais

32482
21:29:55,600 --> 21:29:58,720
constantes que vivem em outro arquivo de cabeçalho

32483
21:29:58,720 --> 21:30:00,872
e aprendemos sobre incluir cartões

32484
21:30:00,872 --> 21:30:03,280
O que podemos usar para nos proteger contra a nossa

32485
21:30:03,280 --> 21:30:05,600
coisas sendo incluídas mais de uma vez por

32486
21:30:05,600 --> 21:30:08,232
o pré-processador temos nosso cilindro

32487
21:30:08,232 --> 21:30:10,480
classe vivendo em seu próprio arquivo e novamente

32488
21:30:10,480 --> 21:30:12,552
Temos um protetor aqui e você

32489
21:30:12,552 --> 21:30:14,640
pode ver que esta classe agora é realmente

32490
21:30:14,640 --> 21:30:16,872
Fácil de olhar, podemos olhar para o

32491
21:30:16,872 --> 21:30:18,872
Informações sobre as funções dos membros

32492
21:30:18,872 --> 21:30:21,120
Temos, por exemplo, um padrão

32493
21:30:21,120 --> 21:30:23,192
construtor, temos um construtor que

32494
21:30:23,192 --> 21:30:25,600
leva dois parâmetros, mas não vemos

32495
21:30:25,600 --> 21:30:28,400
os detalhes sobre como essas coisas fazem

32496
21:30:28,400 --> 21:30:30,720
seus trabalhos, por exemplo, não vemos o

32497
21:30:30,720 --> 21:30:33,440
detalhes sobre como o volume é computado

32498
21:30:33,440 --> 21:30:36,552
Esses detalhes estão escondidos no arquivo cpp

32499
21:30:36,552 --> 21:30:38,400
E se você quiser vê-los, você precisa

32500
21:30:38,400 --> 21:30:40,872
ir para este arquivo de implementação aqui este

32501
21:30:40,872 --> 21:30:43,600
é um bom design e eu incentivo para

32502
21:30:43,600 --> 21:30:46,160
Divida seus programas c plus plus em

32503
21:30:46,160 --> 21:30:48,000
vários arquivos como este está acontecendo

32504
21:30:48,000 --> 21:30:50,160
para tornar sua vida mais fácil nesta palestra

32505
21:30:50,160 --> 21:30:52,400
Vamos ver como podemos gerir o nosso

32506
21:30:52,400 --> 21:30:55,512
objetos de classe através de ponteiros e em

32507
21:30:55,512 --> 21:30:58,320
Na maioria dos casos, precisamos gerenciar nossa classe

32508
21:30:58,320 --> 21:31:01,192
objeto através de ponteiros se estamos usando

32509
21:31:01,192 --> 21:31:04,160
alguma forma de alocação de memória dinâmica

32510
21:31:04,160 --> 21:31:06,400
Aqui está um exemplo simples que temos

32511
21:31:06,400 --> 21:31:08,960
classe de cilindro incluída e aqui em baixo

32512
21:31:08,960 --> 21:31:11,120
Você vê que podemos criar cilindro

32513
21:31:11,120 --> 21:31:13,360
objetos na pilha se usarmos o

32514
21:31:13,360 --> 21:31:15,920
sintaxe como fazemos aqui os objetos são

32515
21:31:15,920 --> 21:31:18,080
vai ser criado na pilha e nós

32516
21:31:18,080 --> 21:31:20,080
Temos visto que podemos acessar o

32517
21:31:20,080 --> 21:31:22,720
comportamentos ou dados dentro da nossa classe

32518
21:31:22,720 --> 21:31:25,512
objeto usando a notação de dados como nós

32519
21:31:25,512 --> 21:31:27,360
Faz aqui, por exemplo, aqui estamos chamando

32520
21:31:27,360 --> 21:31:30,400
nossa função de volume, mas às vezes

32521
21:31:30,400 --> 21:31:32,480
Queremos gerir os nossos objetos através de

32522
21:31:32,480 --> 21:31:35,040
dicas, por exemplo, se você olhar para o

32523
21:31:35,040 --> 21:31:37,440
sintaxe que temos aqui, estamos dizendo

32524
21:31:37,440 --> 21:31:40,400
cilindro e usando o asterisco aqui

32525
21:31:40,400 --> 21:31:42,320
Isto vai dizer que isto vai acontecer

32526
21:31:42,320 --> 21:31:45,280
ser um ponteiro para um tipo de cilindro

32527
21:31:45,280 --> 21:31:47,360
e eu vou dar-lhe um nome c2 e

32528
21:31:47,360 --> 21:31:51,192
Podemos alocar nosso objeto no heap

32529
21:31:51,192 --> 21:31:53,680
usando o novo operador, isso vai

32530
21:31:53,680 --> 21:31:56,720
alocar espaço dinâmico a partir do heap

32531
21:31:56,720 --> 21:31:58,720
E esse espaço de memória vai ser

32532
21:31:58,720 --> 21:32:02,800
usado para armazenar nosso objeto de cilindro agora

32533
21:32:02,800 --> 21:32:04,960
O interessante vai acontecer

32534
21:32:04,960 --> 21:32:08,080
quando você tenta acessar comportamentos a partir de

32535
21:32:08,080 --> 21:32:10,872
seu objeto de cilindro aqui, por exemplo, se

32536
21:32:10,872 --> 21:32:13,360
olhamos para esta linha aqui que estamos tentando

32537
21:32:13,360 --> 21:32:16,400
para imprimir o volume deste cilindro e

32538
21:32:16,400 --> 21:32:18,232
Você percebe que temos que passar

32539
21:32:18,232 --> 21:32:20,800
feias dereferenciando aqui, temos que

32540
21:32:20,800 --> 21:32:24,320
desreferenciar o objeto e, em seguida, chamar o nosso

32541
21:32:24,320 --> 21:32:27,440
método através do operador do ponto aqui, mas

32542
21:32:27,440 --> 21:32:29,360
O que eu quero que você veja é que nós podemos

32543
21:32:29,360 --> 21:32:31,600
Evite isso feio a referência que nós

32544
21:32:31,600 --> 21:32:34,320
estão fazendo aqui e usando o ponteiro

32545
21:32:34,320 --> 21:32:37,440
acesso à notação deste traço maior do que

32546
21:32:37,440 --> 21:32:40,080
O símbolo que você vê aqui vai nos permitir

32547
21:32:40,080 --> 21:32:42,800
para acessar as coisas diretamente usando o

32548
21:32:42,800 --> 21:32:45,680
ponteiro para um objeto que é dinamicamente

32549
21:32:45,680 --> 21:32:48,400
alocado no quadril ok depois que estamos

32550
21:32:48,400 --> 21:32:51,280
feito usando nosso objeto de cilindro lembre-se

32551
21:32:51,280 --> 21:32:53,680
É a memória que foi dinamicamente

32552
21:32:53,680 --> 21:32:55,832
alocado do quadril que temos que

32553
21:32:55,832 --> 21:32:57,680
Liberte a memória para que possa ser

32554
21:32:57,680 --> 21:33:00,320
usado pelo sistema operacional e nós

32555
21:33:00,320 --> 21:33:02,552
liberar a memória usando o delete

32556
21:33:02,552 --> 21:33:05,680
Operador como fazemos aqui ok a ideia i

32557
21:33:05,680 --> 21:33:07,600
Queria introduzir aqui é que nós podemos

32558
21:33:07,600 --> 21:33:10,552
Use jogadores para gerenciar nosso cilindro

32559
21:33:10,552 --> 21:33:12,960
objetos e esta é uma maneira que podemos fazer

32560
21:33:12,960 --> 21:33:16,000
esta e uma vez que estamos usando um ponteiro como

32561
21:33:16,000 --> 21:33:19,040
uma alça para o nosso objeto do cilindro nós podemos

32562
21:33:19,040 --> 21:33:22,552
usar o operador de acesso do ponteiro aqui para

32563
21:33:22,552 --> 21:33:25,600
acesso a coisas de nossos objetos de classe

32564
21:33:25,600 --> 21:33:27,760
facilmente e outra coisa que você deve saber

32565
21:33:27,760 --> 21:33:29,440
É que nós podemos realmente criar um

32566
21:33:29,440 --> 21:33:32,232
cilindro objeto e armazene no endereço

32567
21:33:32,232 --> 21:33:34,552
de objetos que temos na pilha e

32568
21:33:34,552 --> 21:33:36,160
nós vamos ver isso em um minuto quando

32569
21:33:36,160 --> 21:33:38,800
Atingimos o código do estúdio visual agora que você

32570
21:33:38,800 --> 21:33:41,832
Tenho uma ideia sobre isso, vamos cabeçar

32571
21:33:41,832 --> 21:33:43,512
para código de estúdio visual e jogar com isso

32572
21:33:43,512 --> 21:33:46,232
um pouco mais bem aqui estamos em nosso

32573
21:33:46,232 --> 21:33:48,800
pasta de trabalho o projeto atual é

32574
21:33:48,800 --> 21:33:51,440
Gerenciar objetos de classe através de ponteiros

32575
21:33:51,440 --> 21:33:54,160
Podemos ver o nome inteiro aqui e agora

32576
21:33:54,160 --> 21:33:56,080
Não vamos pegar nosso modelo

32577
21:33:56,080 --> 21:33:58,800
Projeto porque queremos começar a partir de

32578
21:33:58,800 --> 21:34:02,000
O projeto que tivemos nesta palestra sobre

32579
21:34:02,000 --> 21:34:04,320
classe em vários arquivos para que nós sejamos

32580
21:34:04,320 --> 21:34:06,640
indo para entrar nesse projeto e agarrar

32581
21:34:06,640 --> 21:34:08,400
Tudo de lá

32582
21:34:08,400 --> 21:34:10,552
Exceto para o executável, porque nós

32583
21:34:10,552 --> 21:34:12,480
Obviamente, não quero isso

32584
21:34:12,480 --> 21:34:14,400
e nós vamos entrar em nossa corrente

32585
21:34:14,400 --> 21:34:17,192
projeto e colar no código e isso

32586
21:34:17,192 --> 21:34:18,640
Vai nos dar um bom começo

32587
21:34:18,640 --> 21:34:21,512
Ponto para que possamos pegar isso e abrir

32588
21:34:21,512 --> 21:34:23,760
Este projeto em código de estúdio visual é

32589
21:34:23,760 --> 21:34:25,280
Vou abrir a pasta e nós vamos

32590
21:34:25,280 --> 21:34:27,360
para ter tudo o que queremos começar

32591
21:34:27,360 --> 21:34:29,512
Fazendo o que queremos fazer nesta palestra

32592
21:34:29,512 --> 21:34:32,640
Então agora devemos ter acesso aos nossos

32593
21:34:32,640 --> 21:34:35,512
classe de cilindro e se você olhar aqui nós

32594
21:34:35,512 --> 21:34:38,160
ter um objeto do tipo de cilindro já

32595
21:34:38,160 --> 21:34:41,760
criado por esta linha no liner número seis

32596
21:34:41,760 --> 21:34:43,600
Aqui e vimos que podemos usar

32597
21:34:43,600 --> 21:34:46,640
a sintaxe como o volume do cilindro aqui

32598
21:34:46,640 --> 21:34:49,760
usando o operador de chamada de ponto para acessar

32599
21:34:49,760 --> 21:34:53,120
coisas do nosso objeto de classe e isso é

32600
21:34:53,120 --> 21:34:54,960
Vou trabalhar, mas queremos ver que nós

32601
21:34:54,960 --> 21:34:57,120
pode usar ponteiros para gerenciar nosso objeto

32602
21:34:57,120 --> 21:34:59,192
Aqui e a primeira coisa que eu quero que você

32603
21:34:59,192 --> 21:35:01,680
Veja é que nós podemos gerenciar um objeto de pilha

32604
21:35:01,680 --> 21:35:04,320
através de ponteiros e para realmente mostrar isso

32605
21:35:04,320 --> 21:35:06,232
Vamos montar um

32606
21:35:06,232 --> 21:35:07,832
Outra variável será um

32607
21:35:07,832 --> 21:35:10,640
ponteiro de cilindro e vai ser p

32608
21:35:10,640 --> 21:35:12,720
cilindro um, vai ser um ponteiro

32609
21:35:12,720 --> 21:35:15,280
para cilindro um aqui é o que eu quero dizer

32610
21:35:15,280 --> 21:35:18,080
e podemos dar um endereço de

32611
21:35:18,080 --> 21:35:20,640
cilindro um como um valor para que possamos fazer

32612
21:35:20,640 --> 21:35:22,960
Isso, por exemplo, e colocar no endereço

32613
21:35:22,960 --> 21:35:25,832
do operador e isso vai funcionar

32614
21:35:25,832 --> 21:35:27,832
Agora podemos passar pelo nosso ponteiro aqui

32615
21:35:27,832 --> 21:35:30,552
e fazer coisas com este objeto de cilindro

32616
21:35:30,552 --> 21:35:32,872
Mas a sintaxe vai ser bonita

32617
21:35:32,872 --> 21:35:35,440
Feio assim, por exemplo, vamos tentar imprimir

32618
21:35:35,440 --> 21:35:37,512
o volume do nosso cilindro

32619
21:35:37,512 --> 21:35:40,552
nós vamos dizer htdcl e dizer volume

32620
21:35:40,552 --> 21:35:42,800
Podemos salvar isso e nós vamos ter que

32621
21:35:42,800 --> 21:35:45,040
passar pelo operador de deferência assim

32622
21:35:45,040 --> 21:35:47,512
se fizermos algo como p cilindro um

32623
21:35:47,512 --> 21:35:50,232
e tentar usar o operador dot

32624
21:35:50,232 --> 21:35:53,120
você vai ver que nós temos o

32625
21:35:53,120 --> 21:35:56,080
função de volume, mas se tentarmos chamá-lo

32626
21:35:56,080 --> 21:35:59,120
Vamos fazer isso, vamos ter certeza de que estamos

32627
21:35:59,120 --> 21:36:01,600
usando o operador do ponto aqui se tentarmos

32628
21:36:01,600 --> 21:36:03,832
compilar este programa não vai

32629
21:36:03,832 --> 21:36:05,512
Compilar porque

32630
21:36:05,512 --> 21:36:08,160
Estamos tentando chamar coisas de um

32631
21:36:08,160 --> 21:36:11,120
ponteiro e lembre-se de que um ponteiro é apenas

32632
21:36:11,120 --> 21:36:13,360
Vai armazenar um endereço que não

32633
21:36:13,360 --> 21:36:16,000
realmente informações sobre o tipo

32634
21:36:16,000 --> 21:36:18,480
que está apontando para se tentarmos

32635
21:36:18,480 --> 21:36:20,000
compilar este programa que vamos ter

32636
21:36:20,000 --> 21:36:22,720
um erro do compilador, então vamos usar o gcc para fazer

32637
21:36:22,720 --> 21:36:23,680
que

32638
21:36:23,680 --> 21:36:25,600
e nós vamos pedir

32639
21:36:25,600 --> 21:36:28,960
volume do membro no credor de pc 1. lembre-se p

32640
21:36:28,960 --> 21:36:31,512
cilindro 1 é apenas um ponteiro, não é um

32641
21:36:31,512 --> 21:36:33,680
objeto para que não possamos realmente chamar o

32642
21:36:33,680 --> 21:36:35,680
Função de volume para f

32643
21:36:35,680 --> 21:36:38,232
se quisermos usar o operador de chamada dot

32644
21:36:38,232 --> 21:36:40,080
Aqui temos que fazer referência e

32645
21:36:40,080 --> 21:36:42,320
Na verdade, chegar ao real

32646
21:36:42,320 --> 21:36:45,120
Objeto que o ponteiro está apontando para

32647
21:36:45,120 --> 21:36:47,600
e nós fazemos isso usando o operador estrela

32648
21:36:47,600 --> 21:36:49,280
Você já sabe como desreferenciar a

32649
21:36:49,280 --> 21:36:51,192
ponteiro para que possamos desreferenciar o nosso

32650
21:36:51,192 --> 21:36:53,360
ponteiro e, em seguida, chamar o volume

32651
21:36:53,360 --> 21:36:55,680
Função sobre o que o ponteiro está apontando

32652
21:36:55,680 --> 21:36:57,360
e isso vai funcionar, está indo

32653
21:36:57,360 --> 21:37:00,160
para imprimir o volume vamos construir agora agora

32654
21:37:00,160 --> 21:37:02,160
que estamos diferindo corretamente e

32655
21:37:02,160 --> 21:37:04,160
Você vê que isso vai funcionar e

32656
21:37:04,160 --> 21:37:07,120
Se tentarmos imprimir isto vamos trazer um

32657
21:37:07,120 --> 21:37:09,440
terminal para que possamos executar este programa

32658
21:37:09,440 --> 21:37:11,360
Vamos correr o galo que você vai ver

32659
21:37:11,360 --> 21:37:14,000
que temos nosso volume aqui para

32660
21:37:14,000 --> 21:37:17,280
Realmente chegar ao que é apontado

32661
21:37:17,280 --> 21:37:19,360
você precisa usar o operador de referência

32662
21:37:19,360 --> 21:37:21,192
e, em seguida, chamar qualquer método que você quiser

32663
21:37:21,192 --> 21:37:23,832
para chamar seu objeto, mas nós podemos fazer

32664
21:37:23,832 --> 21:37:26,160
Coisas ainda mais fáceis há uma sintaxe que nós

32665
21:37:26,160 --> 21:37:28,960
pode usar para usar o ponteiro diretamente aqui

32666
21:37:28,960 --> 21:37:30,960
Porque passando por tudo isso

32667
21:37:30,960 --> 21:37:33,280
dereferenciar a feiura não é realmente

32668
21:37:33,280 --> 21:37:35,280
legal, então nós vamos pegar isso e

32669
21:37:35,280 --> 21:37:37,832
mostrar que podemos usar o traço

32670
21:37:37,832 --> 21:37:40,480
maior do que o operador que é como eu

32671
21:37:40,480 --> 21:37:41,680
Chamou-lhe isso

32672
21:37:41,680 --> 21:37:44,160
e se usarmos isso, não precisamos para o

32673
21:37:44,160 --> 21:37:45,440
Referência

32674
21:37:45,440 --> 21:37:48,480
Tudo o que precisamos fazer é usar o traço

32675
21:37:48,480 --> 21:37:50,960
maior do que o símbolo aqui e está indo

32676
21:37:50,960 --> 21:37:51,680
A sua forma de

32677
21:37:51,680 --> 21:37:54,720
Dizer diretamente ao compilador não codificar

32678
21:37:54,720 --> 21:37:57,192
As coisas no ponteiro fazem diretamente o

32679
21:37:57,192 --> 21:37:59,440
fazer referência ao ponteiro internamente e

32680
21:37:59,440 --> 21:38:01,512
em seguida, chamar a função de volume em

32681
21:38:01,512 --> 21:38:04,232
O que você receber depois de referenciar, então

32682
21:38:04,232 --> 21:38:07,280
Isso basicamente vai empurrar o

32683
21:38:07,280 --> 21:38:09,600
Referindo a feiúra aqui atrás do

32684
21:38:09,600 --> 21:38:12,552
cortinas do compilador e podemos usar

32685
21:38:12,552 --> 21:38:15,120
uma boa sintaxe como esta e eu acho que isso

32686
21:38:15,120 --> 21:38:17,440
É muito melhor do que estávamos fazendo

32687
21:38:17,440 --> 21:38:19,832
Então, se tentarmos fugir agora estamos

32688
21:38:19,832 --> 21:38:21,680
vamos construir e imprimir o nosso volume

32689
21:38:21,680 --> 21:38:23,280
Você vai ver que o parafuso é bom você

32690
21:38:23,280 --> 21:38:26,080
pode limpar e executar galo que você vê que vemos

32691
21:38:26,080 --> 21:38:28,400
nosso volume aqui, então isso é o que eu quero

32692
21:38:28,400 --> 21:38:31,920
Você vê que é possível gerenciar o seu

32693
21:38:31,920 --> 21:38:35,192
objetos de cilindro através de ponteiros e

32694
21:38:35,192 --> 21:38:37,040
Esta é uma maneira de fazer isso por

32695
21:38:37,040 --> 21:38:39,760
Gerenciando um objeto de pilha através de ponteiros

32696
21:38:39,760 --> 21:38:41,832
E isso é o que estamos fazendo aqui se

32697
21:38:41,832 --> 21:38:44,160
Você quer chamar coisas em sua classe

32698
21:38:44,160 --> 21:38:47,192
Objeto que você pode fazer as coisas feias

32699
21:38:47,192 --> 21:38:50,000
Fazemos aqui ou você pode usar o bom

32700
21:38:50,000 --> 21:38:52,640
operador de acesso de ponteiro e está indo

32701
21:38:52,640 --> 21:38:54,552
para ser legal ok agora que temos visto

32702
21:38:54,552 --> 21:38:57,120
este vamos ver outro caso de uso em que

32703
21:38:57,120 --> 21:38:59,440
Vamos criar um cilindro

32704
21:38:59,440 --> 21:39:01,680
objeto na pilha através do novo

32705
21:39:01,680 --> 21:39:03,832
operador OK nós podemos descer e salvar

32706
21:39:03,832 --> 21:39:06,160
que vamos dizer ponteiro de cilindro

32707
21:39:06,160 --> 21:39:07,680
Vai ser p

32708
21:39:07,680 --> 21:39:10,720
c credor 2. podemos chamá-lo assim e

32709
21:39:10,720 --> 21:39:12,720
então vamos dizer novo cilindro e

32710
21:39:12,720 --> 21:39:15,040
você vai ver que podemos chamar a

32711
21:39:15,040 --> 21:39:16,400
construtor

32712
21:39:16,400 --> 21:39:19,040
temos dois tipos de construtores que podemos

32713
21:39:19,040 --> 21:39:21,920
Vamos chamar nosso construtor

32714
21:39:21,920 --> 21:39:24,160
que leva dois parâmetros e nós podemos

32715
21:39:24,160 --> 21:39:26,720
Passe em 100 e 100

32716
21:39:26,720 --> 21:39:29,760
100 por que não oh vamos colocar os dois depois

32717
21:39:29,760 --> 21:39:31,832
Aqui nós podemos colocar no que quisermos isso

32718
21:39:31,832 --> 21:39:34,552
vai criar um novo objeto de cilindro

32719
21:39:34,552 --> 21:39:36,480
o espaço para o objeto do cilindro é

32720
21:39:36,480 --> 21:39:38,872
vai ser alocado no quadril, então isso

32721
21:39:38,872 --> 21:39:41,360
é um objeto de quadril e porque estamos usando

32722
21:39:41,360 --> 21:39:43,360
O novo operador aqui

32723
21:39:43,360 --> 21:39:45,280
A outra coisa que você deve ter em mente

32724
21:39:45,280 --> 21:39:47,280
É que você precisará liberar isso

32725
21:39:47,280 --> 21:39:49,760
memória e vamos lá e fazer isso diretamente

32726
21:39:49,760 --> 21:39:52,080
Esta é uma boa prática, porque você vai

32727
21:39:52,080 --> 21:39:54,720
Esqueça liberar sua memória se você

32728
21:39:54,720 --> 21:39:56,800
Não mantenha isso em mente, então estamos

32729
21:39:56,800 --> 21:39:59,280
indo para excluir p cilindro 2 porque

32730
21:39:59,280 --> 21:40:02,480
Isso é o que costumávamos alocar nosso quadril

32731
21:40:02,480 --> 21:40:05,192
memória aqui está bem agora que nós tomamos

32732
21:40:05,192 --> 21:40:07,680
Cuidado da gestão da memória em que podemos entrar

32733
21:40:07,680 --> 21:40:10,480
e use nosso cilindro de p para se opor

32734
21:40:10,480 --> 21:40:12,720
e por exemplo podemos imprimir seu volume

32735
21:40:12,720 --> 21:40:16,872
usando a instrução stdc out aqui, então

32736
21:40:16,872 --> 21:40:18,872
Vamos descer e salvar isso

32737
21:40:18,872 --> 21:40:21,120
Vamos alinhar isso corretamente e nós somos

32738
21:40:21,120 --> 21:40:22,960
Vou dizer volume

32739
21:40:22,960 --> 21:40:25,280
cilindro 2 para realmente fazer este super

32740
21:40:25,280 --> 21:40:27,280
claro e então vamos dizer p

32741
21:40:27,280 --> 21:40:28,720
Cilino 2

32742
21:40:28,720 --> 21:40:30,800
e chamar a função de volume aqui este

32743
21:40:30,800 --> 21:40:33,920
Vai trabalhar vamos desenhar no mundo o

32744
21:40:33,920 --> 21:40:36,640
O mundo é bom que podemos limpar e correr

32745
21:40:36,640 --> 21:40:38,800
Galo isto vai dar-nos o nosso

32746
21:40:38,800 --> 21:40:41,040
volume e se tentarmos usar isso

32747
21:40:41,040 --> 21:40:43,040
informações para criar um cilindro que somos

32748
21:40:43,040 --> 21:40:45,040
Vamos ver que o volume é o que nós

32749
21:40:45,040 --> 21:40:47,760
Veja aqui podemos até mesmo tentar imprimir

32750
21:40:47,760 --> 21:40:49,360
raio de base

32751
21:40:49,360 --> 21:40:52,640
Vamos fazer isso nós vamos dizer sdd cl

32752
21:40:52,640 --> 21:40:54,640
nós vamos dizer p cilindro 2 e

32753
21:40:54,640 --> 21:40:56,960
nós vamos dizer raio de base que podemos

32754
21:40:56,960 --> 21:40:59,040
Atingido o operador do ponto aqui você está indo

32755
21:40:59,040 --> 21:41:01,192
para ver que vamos ter algumas opções

32756
21:41:01,192 --> 21:41:03,680
em um código de estúdio visual aqui, se nós

32757
21:41:03,680 --> 21:41:05,920
duplo clique em obter o raio base aqui

32758
21:41:05,920 --> 21:41:07,680
Você vai ver esse estúdio visual

32759
21:41:07,680 --> 21:41:09,920
O código vai usar o acesso ao ponteiro

32760
21:41:09,920 --> 21:41:12,080
operador aqui e isso é muito legal, então

32761
21:41:12,080 --> 21:41:14,872
nós podemos bater std e sim nós podemos fechar o

32762
21:41:14,872 --> 21:41:17,832
Pane esquerdo aqui porque precisamos de um pouco mais

32763
21:41:17,832 --> 21:41:20,480
espaço para respirar e se tentarmos

32764
21:41:20,480 --> 21:41:23,440
construir e executar este programa e nós temos um

32765
21:41:23,440 --> 21:41:26,320
Erro do compilador aqui e a razão é

32766
21:41:26,320 --> 21:41:29,040
obter o raio de base é uma função

32767
21:41:29,040 --> 21:41:32,640
Se voltarmos em nossa classe de cilindros, nós

32768
21:41:32,640 --> 21:41:34,480
Veja que temos uma função chamada get

32769
21:41:34,480 --> 21:41:37,512
raio de base, então se quisermos chamar isso de

32770
21:41:37,512 --> 21:41:39,760
na função principal que precisamos chamar

32771
21:41:39,760 --> 21:41:42,400
que como uma função, então precisamos colocar um

32772
21:41:42,400 --> 21:41:45,120
par de parênteses aqui e se construirmos

32773
21:41:45,120 --> 21:41:47,280
Devemos construir sem um problema, vamos

32774
21:41:47,280 --> 21:41:48,400
Faz isso de novo

32775
21:41:48,400 --> 21:41:50,480
Você vê que a construção é boa e se corremos

32776
21:41:50,480 --> 21:41:52,320
O programa que vamos ver exatamente

32777
21:41:52,320 --> 21:41:54,960
O que esperamos, vamos rodar um galo que somos

32778
21:41:54,960 --> 21:41:58,320
Vou ver o que esperamos aqui e

32779
21:41:58,320 --> 21:42:01,040
A mensagem aqui foi realmente que você pode

32780
21:42:01,040 --> 21:42:02,720
gerenciar o seu

32781
21:42:02,720 --> 21:42:06,160
objeto de classe através de ponteiros um caso

32782
21:42:06,160 --> 21:42:07,920
É quando você tem um ponteiro que é

32783
21:42:07,920 --> 21:42:10,080
apontando para um objeto de pilha e vimos

32784
21:42:10,080 --> 21:42:12,320
que nós poderíamos fazer isso aqui nós também podemos

32785
21:42:12,320 --> 21:42:15,120
usar notação de ponteiro para alocar

32786
21:42:15,120 --> 21:42:17,512
objetos na pilha e apontar para eles

32787
21:42:17,512 --> 21:42:19,920
com o nosso ponteiro aqui e sempre que

32788
21:42:19,920 --> 21:42:21,600
Estamos usando um ponteiro que temos a opção

32789
21:42:21,600 --> 21:42:24,552
para usar o operador de chamada ponteiro aqui para

32790
21:42:24,552 --> 21:42:26,872
fazer as coisas facilmente eu vou ser

32791
21:42:26,872 --> 21:42:29,360
chamando isso o operador de chamada ponteiro

32792
21:42:29,360 --> 21:42:32,000
para significar isso daqui em diante, se acontecermos

32793
21:42:32,000 --> 21:42:34,080
para precisar disso e você deve saber o que eu

32794
21:42:34,080 --> 21:42:36,720
Quero dizer com que isso é realmente tudo que eu pontei

32795
21:42:36,720 --> 21:42:38,640
para compartilhar esta palestra eu espero que você

32796
21:42:38,640 --> 21:42:40,720
Achei interessante que vamos

32797
21:42:40,720 --> 21:42:42,800
Parar aqui nesta palestra o próximo

32798
21:42:42,800 --> 21:42:44,320
nós vamos aprender sobre isso

32799
21:42:44,320 --> 21:42:45,680
estruturas

32800
21:42:45,680 --> 21:42:48,080
Vá em frente e termine aqui e me encontre

32801
21:42:48,080 --> 21:42:49,832
lá nesta palestra vamos

32802
21:42:49,832 --> 21:42:52,080
Saiba mais sobre essas estruturas

32803
21:42:52,080 --> 21:42:54,872
As estruturas são funções espaciais ou

32804
21:42:54,872 --> 21:42:57,192
métodos em uma classe que são chamados por

32805
21:42:57,192 --> 21:43:00,480
O compilador para destruir o seu objeto e

32806
21:43:00,480 --> 21:43:03,360
Estes serão especialmente úteis

32807
21:43:03,360 --> 21:43:06,080
Se você está, por exemplo, alocando a memória

32808
21:43:06,080 --> 21:43:07,832
em seus construtores

32809
21:43:07,832 --> 21:43:10,232
Vejamos o simples exemplo aqui que

32810
21:43:10,232 --> 21:43:13,192
ter uma classe chamada cão, tem dois

32811
21:43:13,192 --> 21:43:15,440
seções da seção pública e

32812
21:43:15,440 --> 21:43:18,320
seção privada na seção pública

32813
21:43:18,320 --> 21:43:20,080
ter dois construtores um padrão

32814
21:43:20,080 --> 21:43:22,000
construtor que não leva nenhum

32815
21:43:22,000 --> 21:43:24,640
parâmetro e um construtor que leva

32816
21:43:24,640 --> 21:43:26,480
dois parâmetros n

32817
21:43:26,480 --> 21:43:29,040
Os parâmetros serão usados para

32818
21:43:29,040 --> 21:43:31,680
inicialize nossas variáveis de membro e elas

32819
21:43:31,680 --> 21:43:33,360
são passados por um valor aqui para

32820
21:43:33,360 --> 21:43:35,920
A simplicidade e eles serão usados

32821
21:43:35,920 --> 21:43:38,320
para inicializar essas variáveis de membro

32822
21:43:38,320 --> 21:43:41,440
doug nome raça de cão e idade do cão

32823
21:43:41,440 --> 21:43:43,360
A coisa especial sobre esta classe é

32824
21:43:43,360 --> 21:43:46,400
que tem um destruidor e você declara

32825
21:43:46,400 --> 21:43:49,120
O destruidor usando isso

32826
21:43:49,120 --> 21:43:51,832
sintaxe aqui ele coloca um personagem de til em

32827
21:43:51,832 --> 21:43:53,832
na frente você diz o nome da classe e

32828
21:43:53,832 --> 21:43:56,640
Então você coloca um parâmetro vazio listá-lo

32829
21:43:56,640 --> 21:43:59,120
Também é possível declarar um destruidor

32830
21:43:59,120 --> 21:44:01,920
e colocar em todo o seu corpo no cabeçalho

32831
21:44:01,920 --> 21:44:04,400
E esta é a sintaxe para fazer isso

32832
21:44:04,400 --> 21:44:05,920
Dentro do corpo que você vai fazer

32833
21:44:05,920 --> 21:44:08,552
Seja o que for que você precisa para destruir seu

32834
21:44:08,552 --> 21:44:11,360
objeto, por exemplo, se a classe aqui é

32835
21:44:11,360 --> 21:44:12,960
alocando alguma memória no

32836
21:44:12,960 --> 21:44:15,760
construtor do destruidor é o melhor

32837
21:44:15,760 --> 21:44:17,920
lugar para liberar isso e este é um

32838
21:44:17,920 --> 21:44:20,320
O exemplo de como você pode fazer isso aqui é um

32839
21:44:20,320 --> 21:44:23,192
Um exemplo mais direto de como alocamos

32840
21:44:23,192 --> 21:44:26,400
para memória dinâmica no construtor

32841
21:44:26,400 --> 21:44:28,320
e liberar essa memória no

32842
21:44:28,320 --> 21:44:30,640
Destructor temos as nossas três variáveis

32843
21:44:30,640 --> 21:44:33,760
mas nós escolhemos alocar

32844
21:44:33,760 --> 21:44:36,720
nossa variável de borda do cão na pilha usando

32845
21:44:36,720 --> 21:44:39,680
alocação de memória dinâmica e depois de

32846
21:44:39,680 --> 21:44:41,832
alocar dinamicamente um pedaço de memória

32847
21:44:41,832 --> 21:44:44,552
para armazenar nossa variável de idade, vamos

32848
21:44:44,552 --> 21:44:46,400
definir isso para 0 porque estamos em um

32849
21:44:46,400 --> 21:44:49,280
construtor se estivermos usando os três

32850
21:44:49,280 --> 21:44:52,480
construtor de parâmetros aqui que podemos usar

32851
21:44:52,480 --> 21:44:55,760
o parâmetro passado para inicializar a nossa idade

32852
21:44:55,760 --> 21:44:58,160
variável, mas o importante aqui é

32853
21:44:58,160 --> 21:45:00,080
que está sendo

32854
21:45:00,080 --> 21:45:03,192
Memória educada dinamicamente no quadril

32855
21:45:03,192 --> 21:45:07,600
Aqui e quando o nosso objeto morre, precisamos

32856
21:45:07,600 --> 21:45:10,160
Lembre-se de liberar essa memória e a

32857
21:45:10,160 --> 21:45:12,800
Destructor é o melhor lugar para liberar

32858
21:45:12,800 --> 21:45:14,800
essa memória como você vê aqui nós dizemos

32859
21:45:14,800 --> 21:45:17,920
apagar a idade das trevas quando o nosso objeto morre e

32860
21:45:17,920 --> 21:45:20,080
o compilador vai chamar isso

32861
21:45:20,080 --> 21:45:22,400
Função quando está prestes a matar o

32862
21:45:22,400 --> 21:45:23,440
objeto

32863
21:45:23,440 --> 21:45:27,120
Você pode perguntar quando são destruidores

32864
21:45:27,120 --> 21:45:29,192
Realmente chamado, vamos começar

32865
21:45:29,192 --> 21:45:31,920
olhando para casos óbvios aqui para

32866
21:45:31,920 --> 21:45:34,552
exemplo quando um objeto de pilha local vai

32867
21:45:34,552 --> 21:45:36,000
fora do escopo

32868
21:45:36,000 --> 21:45:37,760
O destruidor vai ser chamado

32869
21:45:37,760 --> 21:45:40,000
Porque esse objeto vai ser limpo

32870
21:45:40,000 --> 21:45:42,232
fora da memória, então isso é óbvio

32871
21:45:42,232 --> 21:45:43,192
O caso

32872
21:45:43,192 --> 21:45:45,280
em que o compilador precisará chamar

32873
21:45:45,280 --> 21:45:48,552
um destructor também quando um objeto de quadril é

32874
21:45:48,552 --> 21:45:51,192
liberado da memória usando a exclusão do

32875
21:45:51,192 --> 21:45:53,360
O destructor também será chamado

32876
21:45:53,360 --> 21:45:55,512
mas existem algumas maneiras indiretas em

32877
21:45:55,512 --> 21:45:57,832
que as estruturas também são chamadas para

32878
21:45:57,832 --> 21:45:59,920
exemplo quando um objeto é passado por um

32879
21:45:59,920 --> 21:46:01,760
valor para uma função

32880
21:46:01,760 --> 21:46:04,720
Isso vai chamar o destruidor para

32881
21:46:04,720 --> 21:46:07,600
matar o objeto quando o objeto sair

32882
21:46:07,600 --> 21:46:10,232
de escopo na função porque quando

32883
21:46:10,232 --> 21:46:12,000
O objeto é passado pelo valor que vamos

32884
21:46:12,000 --> 21:46:14,160
ter uma cópia no âmbito local do

32885
21:46:14,160 --> 21:46:17,192
função e quando a função sai

32886
21:46:17,192 --> 21:46:19,120
A cópia local será morta

32887
21:46:19,120 --> 21:46:20,552
e vamos ver um exemplo de

32888
21:46:20,552 --> 21:46:23,120
que outro caso em que você possa ter

32889
21:46:23,120 --> 21:46:25,360
A estrutura chamada é quando um local

32890
21:46:25,360 --> 21:46:27,832
O objeto é retornado de uma função

32891
21:46:27,832 --> 21:46:30,080
Outra cópia será criada para

32892
21:46:30,080 --> 21:46:32,720
ser usado fora da função e

32893
21:46:32,720 --> 21:46:34,960
copiar dentro da função vai ser

32894
21:46:34,960 --> 21:46:37,360
morto, mas isso não é garantido como

32895
21:46:37,360 --> 21:46:40,480
algum compilador pode otimizar seu retorno

32896
21:46:40,480 --> 21:46:43,192
valorizar e usar algum tipo de referência assim

32897
21:46:43,192 --> 21:46:44,640
Você não está garantido para ver isso

32898
21:46:44,640 --> 21:46:47,440
Comportamento, mas é possível vê-lo

32899
21:46:47,440 --> 21:46:49,360
Agora que você tem uma ideia sobre

32900
21:46:49,360 --> 21:46:52,000
Destructors é hora de irmos para

32901
21:46:52,000 --> 21:46:54,160
código de estúdio visual e jogar com a gente um

32902
21:46:54,160 --> 21:46:56,800
Um pouco mais bem aqui estamos em nosso

32903
21:46:56,800 --> 21:46:58,960
pasta de trabalho o projeto atual é

32904
21:46:58,960 --> 21:47:00,960
as estruturas que vamos agarrar o nosso

32905
21:47:00,960 --> 21:47:02,872
arquivos de modelo muito rápido e nós somos

32906
21:47:02,872 --> 21:47:05,192
Vou colocá-los no lugar e depois

32907
21:47:05,192 --> 21:47:07,512
que vamos abrir nossa pasta em

32908
21:47:07,512 --> 21:47:09,512
código visual do estúdio arrastando e

32909
21:47:09,512 --> 21:47:12,320
Deixando aqui isso vai abrir o nosso

32910
21:47:12,320 --> 21:47:15,440
pasta e vamos ver o nosso arquivo cpp principal

32911
21:47:15,440 --> 21:47:18,232
Aqui podemos abri-lo e eu limpo e

32912
21:47:18,232 --> 21:47:20,552
remover o que não precisamos, temos um

32913
21:47:20,552 --> 21:47:22,960
ponto de ruptura desnecessário aqui podemos remover

32914
21:47:22,960 --> 21:47:24,872
Isso e nós vamos limpar o

32915
21:47:24,872 --> 21:47:26,720
principal função a primeira coisa que queremos

32916
21:47:26,720 --> 21:47:29,680
fazer é colocar em nossa classe de cães eu estou indo

32917
21:47:29,680 --> 21:47:32,320
para apenas colocar isso aqui porque eu não

32918
21:47:32,320 --> 21:47:34,080
Quer que você me veja digitar tudo isso

32919
21:47:34,080 --> 21:47:36,160
Isso só vai desperdiçar seu tempo nós

32920
21:47:36,160 --> 21:47:38,320
Temos duas seções na aula de cães

32921
21:47:38,320 --> 21:47:40,800
ter uma seção pública que vai

32922
21:47:40,800 --> 21:47:43,440
agora contêm nossos construtores e nós temos

32923
21:47:43,440 --> 21:47:45,040
Uma seção privada que vai

32924
21:47:45,040 --> 21:47:47,360
Contém três variáveis de membros que temos

32925
21:47:47,360 --> 21:47:49,760
Dois pontos fortes, um para o nome e o

32926
21:47:49,760 --> 21:47:52,080
Outro para a raça do nosso cão e nós

32927
21:47:52,080 --> 21:47:54,320
ter outro que é um ponteiro final

32928
21:47:54,320 --> 21:47:56,232
que vai armazenar a borda do

32929
21:47:56,232 --> 21:47:59,040
cão e você vê que isso é inicializado

32930
21:47:59,040 --> 21:48:00,800
para nenhum ponteiro uma coisa que você deveria

32931
21:48:00,800 --> 21:48:03,512
A notificação é que para o nosso parâmetro tomado

32932
21:48:03,512 --> 21:48:06,232
construtor, estamos passando a corda

32933
21:48:06,232 --> 21:48:09,192
informações aqui usando imagens de string para

32934
21:48:09,192 --> 21:48:12,640
evitar cópias com a imagem de string std

32935
21:48:12,640 --> 21:48:14,320
Digite você já sabe disso porque nós

32936
21:48:14,320 --> 21:48:16,320
Aprendi sobre isso, mas para que isso funcione

32937
21:48:16,320 --> 21:48:18,552
nós precisaremos incluir uma exibição de string assim

32938
21:48:18,552 --> 21:48:20,872
Vamos fazer isso e agora temos nossa classe

32939
21:48:20,872 --> 21:48:23,440
e nós podemos usá-lo como quisermos

32940
21:48:23,440 --> 21:48:26,320
então, mas antes de o fazer, precisamos colocar

32941
21:48:26,320 --> 21:48:29,192
Implementações para essas funções

32942
21:48:29,192 --> 21:48:31,192
A única maneira de fazer isso é fazer isso

32943
21:48:31,192 --> 21:48:33,600
diretamente na função aqui, mas eu quero

32944
21:48:33,600 --> 21:48:35,920
para ver que você também pode fazer isso

32945
21:48:35,920 --> 21:48:38,400
diretamente fora da aula aqui eu não

32946
21:48:38,400 --> 21:48:40,160
Acho que eu mostrei isso, mas é

32947
21:48:40,160 --> 21:48:42,080
Possível fazer isso para que vamos

32948
21:48:42,080 --> 21:48:44,872
Pegue o protótipo do nosso construtor

32949
21:48:44,872 --> 21:48:47,832
e dizer o operador de resolução de escopo

32950
21:48:47,832 --> 21:48:49,920
E nós vamos apenas colar no que nós

32951
21:48:49,920 --> 21:48:52,480
copiaram qual é o protótipo aqui

32952
21:48:52,480 --> 21:48:54,552
e nós vamos entrar em nosso

32953
21:48:54,552 --> 21:48:56,232
corpo e no corpo vamos

32954
21:48:56,232 --> 21:48:59,040
inicialize esses três caras

32955
21:48:59,040 --> 21:49:01,040
então o nome será inicializado

32956
21:49:01,040 --> 21:49:03,680
para nem param e a ponte vai

32957
21:49:03,680 --> 21:49:06,720
ser inicializado para criar o param que podemos

32958
21:49:06,720 --> 21:49:09,440
fazer isso e a idade vai ser

32959
21:49:09,440 --> 21:49:12,552
dinamicamente alocado a partir do quadril você

32960
21:49:12,552 --> 21:49:14,480
Veja que é um ponteiro, então vamos

32961
21:49:14,480 --> 21:49:17,440
dizer que ph é igual a novo e porque nós somos

32962
21:49:17,440 --> 21:49:20,720
indo alocar espaço dinâmico para armazenar

32963
21:49:20,720 --> 21:49:23,440
um fim e vamos colocar os dados em

32964
21:49:23,440 --> 21:49:26,400
usando nosso bom e velho operador de dereferência

32965
21:49:26,400 --> 21:49:28,160
nós vamos dizer ph

32966
21:49:28,160 --> 21:49:31,600
igual a qualquer parâmetro ph que eles passaram

32967
21:49:31,600 --> 21:49:33,360
E eu acho que devemos dizer borda aqui

32968
21:49:33,360 --> 21:49:35,192
Porque não é um ponteiro, então nós somos

32969
21:49:35,192 --> 21:49:37,600
Vou dizer idade eu acho que isso está indo

32970
21:49:37,600 --> 21:49:40,552
para fazer melhor idade param isso é provavelmente

32971
21:49:40,552 --> 21:49:42,080
Vou ser melhor e nós vamos

32972
21:49:42,080 --> 21:49:45,040
Diga idade param bem, então agora temos o nosso

32973
21:49:45,040 --> 21:49:48,160
construtor n e vai alocar

32974
21:49:48,160 --> 21:49:50,552
memória do monte e nós vamos

32975
21:49:50,552 --> 21:49:53,680
colocar dados nesse novo local de memória

32976
21:49:53,680 --> 21:49:56,320
que acaba de ser atribuído ao nosso

32977
21:49:56,320 --> 21:49:58,552
classe aqui, então esta é a nossa classe e nós

32978
21:49:58,552 --> 21:50:00,160
pode ir na função principal e realmente

32979
21:50:00,160 --> 21:50:02,800
Use como quiser, por exemplo,

32980
21:50:02,800 --> 21:50:05,040
pode configurar um objeto de cão para que vamos

32981
21:50:05,040 --> 21:50:07,360
para dizer o meu cão e nós vamos dar-lhe

32982
21:50:07,360 --> 21:50:09,360
Um nome o nome vai ser fofo

32983
21:50:09,360 --> 21:50:12,320
e nós vamos colocar a raça dentro e

32984
21:50:12,320 --> 21:50:14,232
Vai ser apenas um pastor e

32985
21:50:14,232 --> 21:50:16,232
nós vamos colocar na idade que é

32986
21:50:16,232 --> 21:50:18,720
Vai ser, por exemplo, um 2. digamos

32987
21:50:18,720 --> 21:50:20,800
nosso cão tem 2 anos de idade

32988
21:50:20,800 --> 21:50:22,872
isso é válido c plus código é

32989
21:50:22,872 --> 21:50:25,120
Vou criar um objeto do nosso

32990
21:50:25,120 --> 21:50:27,832
classe aqui e nós podemos o mundo para ver que

32991
21:50:27,832 --> 21:50:29,760
Este programa está indo para o mundo sem um

32992
21:50:29,760 --> 21:50:32,480
O problema é bom, mas se corrermos

32993
21:50:32,480 --> 21:50:34,000
O programa que não vamos ver

32994
21:50:34,000 --> 21:50:36,720
Qualquer coisa, mas nós realmente não precisamos ver

32995
21:50:36,720 --> 21:50:38,552
nosso construtor aqui chamado porque nós

32996
21:50:38,552 --> 21:50:40,872
já sabe sobre construtores o que nós

32997
21:50:40,872 --> 21:50:43,192
Quer aprender sobre essas estruturas

32998
21:50:43,192 --> 21:50:45,920
e estes são métodos espaciais que são

32999
21:50:45,920 --> 21:50:48,552
chamado pelo compilador quando seu objeto

33000
21:50:48,552 --> 21:50:51,120
morre, vamos criar um destruidor e ver

33001
21:50:51,120 --> 21:50:54,080
Chamado quando nossos objetos de cão morrem

33002
21:50:54,080 --> 21:50:56,480
Sintaxe para fazer isso é usar o til

33003
21:50:56,480 --> 21:50:58,400
personagem aqui você vai dizer o

33004
21:50:58,400 --> 21:51:00,080
nome da classe que você vai colocar um

33005
21:51:00,080 --> 21:51:02,320
lista de parâmetros vazia e se você quiser

33006
21:51:02,320 --> 21:51:04,720
pode colocar um corpo e fazer o que quiser

33007
21:51:04,720 --> 21:51:07,040
para fazer no corpo do seu destruidor

33008
21:51:07,040 --> 21:51:10,232
Aqui, mas novamente nós vamos mover o

33009
21:51:10,232 --> 21:51:13,120
Toda a definição do destruidor para

33010
21:51:13,120 --> 21:51:15,920
o exterior, então vamos para baixo e salvar

33011
21:51:15,920 --> 21:51:17,600
que vamos dizer o escopo

33012
21:51:17,600 --> 21:51:19,280
operador de resolução, vamos dizer

33013
21:51:19,280 --> 21:51:21,920
cão e nós vamos colocar em nosso corpo

33014
21:51:21,920 --> 21:51:24,720
e a primeira coisa que queremos fazer em nosso

33015
21:51:24,720 --> 21:51:27,920
Destructor é para liberar esta memória

33016
21:51:27,920 --> 21:51:31,280
que foi atribuído dinamicamente para nós se

33017
21:51:31,280 --> 21:51:33,440
Nós não o liberamos quando isso está escuro

33018
21:51:33,440 --> 21:51:35,832
objeto morre, vamos ligar a memória

33019
21:51:35,832 --> 21:51:37,832
E isso é muito ruim, então vamos fazer isso

33020
21:51:37,832 --> 21:51:39,680
diretamente no destruidor podemos dizer

33021
21:51:39,680 --> 21:51:42,872
excluir e dizer ph isso vai

33022
21:51:42,872 --> 21:51:45,440
liberar a memória que foi alocada em

33023
21:51:45,440 --> 21:51:48,080
o construtor aqui e temos acesso

33024
21:51:48,080 --> 21:51:51,120
para esta variável ph porque o

33025
21:51:51,120 --> 21:51:54,320
O destructor faz parte da nossa classe

33026
21:51:54,320 --> 21:51:56,640
qualquer função de membro da sua classe é

33027
21:51:56,640 --> 21:51:58,640
ter acesso a qualquer membro

33028
21:51:58,640 --> 21:52:00,960
variável mesmo se acontecer de ser

33029
21:52:00,960 --> 21:52:02,080
Privado

33030
21:52:02,080 --> 21:52:05,040
Tudo bem, então esquecemos nosso personagem de tilde

33031
21:52:05,040 --> 21:52:07,600
Vamos colocar isso aqui e isso está acontecendo

33032
21:52:07,600 --> 21:52:10,080
para ser válido c mais código plus, mas para

33033
21:52:10,080 --> 21:52:12,480
Realmente ver as coisas acontecendo aqui vamos

33034
21:52:12,480 --> 21:52:14,800
colocar em uma declaração sddc out que estamos indo

33035
21:52:14,800 --> 21:52:17,280
para dizer doug destructor chamado 4 e

33036
21:52:17,280 --> 21:52:19,040
nós vamos dizer o nome do cão

33037
21:52:19,040 --> 21:52:21,040
Vamos dizer nome e vamos dizer

33038
21:52:21,040 --> 21:52:23,192
A mesma coisa no construtor nós somos

33039
21:52:23,192 --> 21:52:26,160
indo dizer hddcl e dizer cão

33040
21:52:26,160 --> 21:52:29,280
Construtor frio para e nós vamos

33041
21:52:29,280 --> 21:52:31,360
Diga o nome do cão que vai usar o nosso membro

33042
21:52:31,360 --> 21:52:33,680
variável e agora temos a nossa coisa em

33043
21:52:33,680 --> 21:52:36,480
lugar que temos o destruidor declarado em

33044
21:52:36,480 --> 21:52:39,120
a definição da classe e esta é a

33045
21:52:39,120 --> 21:52:41,192
sintaxe novamente isso é o que realmente queremos

33046
21:52:41,192 --> 21:52:43,192
para aprender sobre esta palestra que temos

33047
21:52:43,192 --> 21:52:45,440
o caráter tilde que temos a classe

33048
21:52:45,440 --> 21:52:48,480
nome e colocamos uma lista de parâmetros vazia

33049
21:52:48,480 --> 21:52:50,800
Deixe-me dizer-lhe que não é possível

33050
21:52:50,800 --> 21:52:53,760
para passar parâmetros para o seu destruidor se

33051
21:52:53,760 --> 21:52:54,872
Você faz isso que você vai conseguir um

33052
21:52:54,872 --> 21:52:57,360
Erro do compilador, as estruturas irão

33053
21:52:57,360 --> 21:53:00,872
sempre não tem parâmetros em c plus mais

33054
21:53:00,872 --> 21:53:03,512
Aqui temos a definição de nossa

33055
21:53:03,512 --> 21:53:05,760
Destructor e vai liberar

33056
21:53:05,760 --> 21:53:07,760
Seja qual for a memória que tenhamos de forma dinâmica

33057
21:53:07,760 --> 21:53:10,480
atribuídos a partir do construtor aqui se

33058
21:53:10,480 --> 21:53:12,400
Escutamos este programa

33059
21:53:12,400 --> 21:53:14,000
nós vamos ver o nosso construtor

33060
21:53:14,000 --> 21:53:16,552
chamado como resultado dessa linha aqui

33061
21:53:16,552 --> 21:53:19,512
porque estamos construindo um objeto de cão

33062
21:53:19,512 --> 21:53:20,960
E nós vamos ver o destruidor

33063
21:53:20,960 --> 21:53:22,872
chamado quando a função principal é sobre

33064
21:53:22,872 --> 21:53:24,000
Para terminar

33065
21:53:24,000 --> 21:53:26,160
Vamos colocar um stdc fora estado para mencionar

33066
21:53:26,160 --> 21:53:28,320
a principal função aqui e dizer feito apenas

33067
21:53:28,320 --> 21:53:31,040
para provar que atingimos o fim do nosso

33068
21:53:31,040 --> 21:53:32,720
Principal função aqui eu acho que isso é

33069
21:53:32,720 --> 21:53:35,280
útil e vamos construir, então vamos

33070
21:53:35,280 --> 21:53:37,920
para que vamos construir com gcc

33071
21:53:37,920 --> 21:53:39,440
Você vai ver que o mundo é

33072
21:53:39,440 --> 21:53:42,080
Bom para que possamos limpar e executar ou programar

33073
21:53:42,080 --> 21:53:44,872
vamos bater entrar aqui e limpar e correr

33074
21:53:44,872 --> 21:53:46,720
galo você vai ver que

33075
21:53:46,720 --> 21:53:49,192
O construtor foi chamado para

33076
21:53:49,192 --> 21:53:52,000
dizer feito quando a função principal é sobre

33077
21:53:52,000 --> 21:53:54,872
para terminar, mas antes que a função principal term

33078
21:53:54,872 --> 21:53:57,832
Vamos destruir quaisquer dados de pilha

33079
21:53:57,832 --> 21:53:59,920
que temos na função principal e

33080
21:53:59,920 --> 21:54:02,720
nosso objeto de cão está nas estatísticas por isso é

33081
21:54:02,720 --> 21:54:05,040
Vai ser destruído como parte disso

33082
21:54:05,040 --> 21:54:07,600
O processo e o destruidor para o cão é

33083
21:54:07,600 --> 21:54:09,512
Vou ser chamado e nós vamos

33084
21:54:09,512 --> 21:54:11,512
Liberte nossa memória e nós vamos

33085
21:54:11,512 --> 21:54:13,760
Diz que o destruidor de cão foi chamado para

33086
21:54:13,760 --> 21:54:15,120
Seja qual for o nome

33087
21:54:15,120 --> 21:54:18,320
atribuímos ao nosso cão aqui, então isso

33088
21:54:18,320 --> 21:54:21,440
É assim que os destruidores são chamados quando

33089
21:54:21,440 --> 21:54:23,512
Os objetos são mortos

33090
21:54:23,512 --> 21:54:26,960
e nós não colocamos o nome correto

33091
21:54:26,960 --> 21:54:29,832
nós dissemos fof... digamos fofo porque

33092
21:54:29,832 --> 21:54:31,600
Isso é o que eu queria e agora você vê

33093
21:54:31,600 --> 21:54:33,680
que nosso destruidor está realmente sendo

33094
21:54:33,680 --> 21:54:35,920
chamado e liberando a memória, no entanto

33095
21:54:35,920 --> 21:54:38,232
Queremos, mas também podemos ir um pouco mais longe

33096
21:54:38,232 --> 21:54:40,872
e mostrar-lhe outro exemplo de um caso

33097
21:54:40,872 --> 21:54:42,872
onde as estruturas são chamadas e

33098
21:54:42,872 --> 21:54:45,360
nós vamos olhar para uma função que

33099
21:54:45,360 --> 21:54:47,760
configura um objeto local de um cão que somos

33100
21:54:47,760 --> 21:54:49,600
Vou ver o cão construído e

33101
21:54:49,600 --> 21:54:51,920
nós vamos vê-lo destruído quando

33102
21:54:51,920 --> 21:54:54,552
A função está prestes a terminar, vamos fazer isso

33103
21:54:54,552 --> 21:54:56,552
nós vamos dizer descarte algum funk e

33104
21:54:56,552 --> 21:54:58,552
Vai ser apenas uma função para

33105
21:54:58,552 --> 21:55:00,720
jogar com a gente nós vamos

33106
21:55:00,720 --> 21:55:04,160
mover a nossa declaração de cão em algum funk

33107
21:55:04,160 --> 21:55:05,192
Aqui

33108
21:55:05,192 --> 21:55:07,120
E isso é realmente, vamos

33109
21:55:07,120 --> 21:55:08,720
chamar esta função

33110
21:55:08,720 --> 21:55:10,080
E quando nós o chamamos, vamos

33111
21:55:10,080 --> 21:55:12,160
Construa o objeto aqui quando

33112
21:55:12,160 --> 21:55:14,400
A função está prestes a terminar o compilador

33113
21:55:14,400 --> 21:55:15,920
Vai chamar o destruidor porque

33114
21:55:15,920 --> 21:55:18,160
Vai destruir este objeto aqui

33115
21:55:18,160 --> 21:55:19,600
E nós vamos ver o destruidor

33116
21:55:19,600 --> 21:55:22,552
Chamado por esse ponto algum funk

33117
21:55:22,552 --> 21:55:24,480
A função vai ser feita fora do

33118
21:55:24,480 --> 21:55:26,400
no topo da pilha, vamos acertar o

33119
21:55:26,400 --> 21:55:27,920
Principal função aqui e nós vamos

33120
21:55:27,920 --> 21:55:30,800
Diga feito e o programa vai acabar

33121
21:55:30,800 --> 21:55:32,872
Vamos chamar algum nome funky aqui, então estamos

33122
21:55:32,872 --> 21:55:34,720
vamos dizer um pouco de funk e nós vamos

33123
21:55:34,720 --> 21:55:37,440
para o mundo para realmente ver isso acontecendo assim

33124
21:55:37,440 --> 21:55:39,832
Trabalhámos com sucesso que podemos limpar

33125
21:55:39,832 --> 21:55:41,920
limpar corretamente e executar o galo que estamos

33126
21:55:41,920 --> 21:55:44,000
Vou ver o construtor chamado

33127
21:55:44,000 --> 21:55:46,400
fofo a estrutura chamada para fofo

33128
21:55:46,400 --> 21:55:48,720
e você vê feito, nós batemos o principal

33129
21:55:48,720 --> 21:55:51,440
função e realmente terminar a execução

33130
21:55:51,440 --> 21:55:54,000
nosso programa aqui podemos até ver isso

33131
21:55:54,000 --> 21:55:56,080
através do depurador vamos definir

33132
21:55:56,080 --> 21:55:59,192
até três pontos de ruptura um no principal

33133
21:55:59,192 --> 21:56:01,360
Função aqui antes de chamarmos alguns

33134
21:56:01,360 --> 21:56:03,192
função funk que vamos configurar

33135
21:56:03,192 --> 21:56:06,232
outro em nosso destruidor antes de nós

33136
21:56:06,232 --> 21:56:08,320
imprimir a mensagem aqui e nós vamos

33137
21:56:08,320 --> 21:56:11,040
para colocar outro no construtor

33138
21:56:11,040 --> 21:56:13,360
quando estamos prestes a imprimir esta mensagem

33139
21:56:13,360 --> 21:56:16,480
aqui na linha 20. depois que nós configuramos estes

33140
21:56:16,480 --> 21:56:19,280
pontos de quebra, nós meio que matamos o

33141
21:56:19,280 --> 21:56:22,480
terminal aqui e minimizar um pouco

33142
21:56:22,480 --> 21:56:24,800
Vamos matar essas coisas aqui para que nós

33143
21:56:24,800 --> 21:56:27,440
Temos um ah limpo temos um monte de janelas

33144
21:56:27,440 --> 21:56:30,480
Aqui está tudo bem, temos o nosso editor aqui

33145
21:56:30,480 --> 21:56:34,160
e agora se formos para a conta aqui que

33146
21:56:34,160 --> 21:56:37,120
diz começar ou correr, vamos ser capazes

33147
21:56:37,120 --> 21:56:39,440
para clicar no botão verde aqui para começar

33148
21:56:39,440 --> 21:56:42,080
nossa sessão de depuração, vamos

33149
21:56:42,080 --> 21:56:44,320
Tenho um terminal aqui, então vamos trazer isso

33150
21:56:44,320 --> 21:56:46,400
para o lado para que possamos ver as coisas

33151
21:56:46,400 --> 21:56:49,760
impresso bem, vamos fazer assim

33152
21:56:49,760 --> 21:56:52,160
e agora nós atingimos o ponto de ruptura em

33153
21:56:52,160 --> 21:56:54,640
A principal função em que podemos entrar

33154
21:56:54,640 --> 21:56:56,800
A função de func de soma e nós vamos

33155
21:56:56,800 --> 21:56:59,760
fazer isso usando o passo no botão aqui

33156
21:56:59,760 --> 21:57:01,440
Vamos clicar que vamos pular

33157
21:57:01,440 --> 21:57:03,512
em algum funk

33158
21:57:03,512 --> 21:57:06,160
Agora temos a opção de entrar, mas

33159
21:57:06,160 --> 21:57:09,512
Isto vai saltar-nos para a lógica

33160
21:57:09,512 --> 21:57:12,552
Transformando a string literal aqui

33161
21:57:12,552 --> 21:57:15,040
em uma vista de string, porque se você vê

33162
21:57:15,040 --> 21:57:16,960
O construtor vai tomar corda

33163
21:57:16,960 --> 21:57:19,192
Veja os parâmetros, podemos realmente ver isso

33164
21:57:19,192 --> 21:57:20,400
Vamos tentar

33165
21:57:20,400 --> 21:57:22,232
e apertar o passo no botão que você vê

33166
21:57:22,232 --> 21:57:24,872
que estamos na classe de visão de string e

33167
21:57:24,872 --> 21:57:27,512
nós realmente não queremos isso, então vamos dar um passo

33168
21:57:27,512 --> 21:57:30,872
fora e nós vamos passar por cima disso

33169
21:57:30,872 --> 21:57:32,960
para que possamos acertar o próximo ponto de interrupção

33170
21:57:32,960 --> 21:57:35,040
E você vê que o próximo ponto de interrupção está em

33171
21:57:35,040 --> 21:57:38,400
nosso construtor e isso prova que o

33172
21:57:38,400 --> 21:57:39,760
O compilador vai chamar o nosso

33173
21:57:39,760 --> 21:57:42,800
construtor aqui para construir o nosso objeto

33174
21:57:42,800 --> 21:57:45,040
Se passarmos por isso, vamos

33175
21:57:45,040 --> 21:57:47,600
imprimir a mensagem do construtor

33176
21:57:47,600 --> 21:57:50,000
E se continuarmos indo, vamos conseguir

33177
21:57:50,000 --> 21:57:51,120
- A partir de mais

33178
21:57:51,120 --> 21:57:54,000
nosso construtor e você vê onde isso

33179
21:57:54,000 --> 21:57:55,680


33180
21:57:55,680 --> 21:57:58,480
o destructor porque antes de sair

33181
21:57:58,480 --> 21:58:01,512
o algum func função nossos objetos dot

33182
21:58:01,512 --> 21:58:03,600
Vai ser destruído, então vamos

33183
21:58:03,600 --> 21:58:05,832
para liberar nossa memória e nós vamos

33184
21:58:05,832 --> 21:58:08,800
ramificar a mensagem do nosso construtor

33185
21:58:08,800 --> 21:58:12,000
e se nós batemos em seguida e um passo fora de

33186
21:58:12,000 --> 21:58:14,080
Acho que podemos fazer isso porque isso

33187
21:58:14,080 --> 21:58:16,400
É lógica que não queremos que vamos

33188
21:58:16,400 --> 21:58:19,920
Tente passar por cima disso e agora se batermos

33189
21:58:19,920 --> 21:58:22,000
A seguir, vamos voltar em alguns

33190
21:58:22,000 --> 21:58:24,080
funk e algum funk já está indo

33191
21:58:24,080 --> 21:58:26,320
estar acabado e se batermos em seguida, estamos

33192
21:58:26,320 --> 21:58:27,832
vamos voltar para o principal e nós estamos

33193
21:58:27,832 --> 21:58:30,320
vai imprimir feito e o programa é

33194
21:58:30,320 --> 21:58:32,720
basicamente vai ser feito espero que você

33195
21:58:32,720 --> 21:58:34,080
Pode ver que

33196
21:58:34,080 --> 21:58:36,552
o compilador vai chamar o nosso

33197
21:58:36,552 --> 21:58:39,360
Destructor depois de deixar algum funk

33198
21:58:39,360 --> 21:58:41,512
Aqui porque vai estar destruindo

33199
21:58:41,512 --> 21:58:44,320
O objeto local que temos dentro

33200
21:58:44,320 --> 21:58:46,720
algum funk aqui, então este é um caso onde

33201
21:58:46,720 --> 21:58:48,640
O destruidor será chamado por

33202
21:58:48,640 --> 21:58:51,512
O compilador e é se você tiver um

33203
21:58:51,512 --> 21:58:54,720
Objeto local que precisa ser destruído

33204
21:58:54,720 --> 21:58:57,280
quando o escopo da função termina outro

33205
21:58:57,280 --> 21:59:00,232
Caso em que o destruidor pode ser chamado

33206
21:59:00,232 --> 21:59:02,000
É se você passar

33207
21:59:02,000 --> 21:59:02,800
a

33208
21:59:02,800 --> 21:59:04,400
objeto de classe

33209
21:59:04,400 --> 21:59:07,512
parâmetro por valor, então vamos mudar alguns

33210
21:59:07,512 --> 21:59:09,512
Funcionar aqui e fazer tomar algo

33211
21:59:09,512 --> 21:59:11,512
pelo valor, então vamos passar por um cachorro

33212
21:59:11,512 --> 21:59:14,480
Dentro e nós vamos dizer cão param

33213
21:59:14,480 --> 21:59:16,480
Isso vai fazer tudo bem agora que nós

33214
21:59:16,480 --> 21:59:18,960
mudaram algum func aqui nós podemos

33215
21:59:18,960 --> 21:59:21,040
realmente fazer todos os tipos de coisas loucas com

33216
21:59:21,040 --> 21:59:22,960
Por exemplo, podemos montar o nosso cão

33217
21:59:22,960 --> 21:59:26,000
objeto dentro da nossa principal função aqui, então

33218
21:59:26,000 --> 21:59:29,440
Vamos fazer isso nós podemos dizer cão e cão

33219
21:59:29,440 --> 21:59:31,600
Nome variável vai ser cão que podemos

33220
21:59:31,600 --> 21:59:32,872
Dá-lhe isso

33221
21:59:32,872 --> 21:59:35,192
um nome que vai ser fofo é

33222
21:59:35,192 --> 21:59:37,440
ter uma raça de pastor e nós

33223
21:59:37,440 --> 21:59:39,600
pode dar a idade de 2 como temos

33224
21:59:39,600 --> 21:59:42,080
Estou fazendo o tempo todo que podemos chamar a nossa

33225
21:59:42,080 --> 21:59:45,280
função com o objeto do cão aqui, mas ser

33226
21:59:45,280 --> 21:59:47,192
Cuidado sobre o que vai acontecer

33227
21:59:47,192 --> 21:59:49,360
Aqui quando fazemos algo assim

33228
21:59:49,360 --> 21:59:51,680
nós vamos passar pelo valor e

33229
21:59:51,680 --> 21:59:53,600
O compilador vai ver que

33230
21:59:53,600 --> 21:59:56,720
Precisa copiar um objeto de cão

33231
21:59:56,720 --> 21:59:59,680
Agora nós realmente não dissemos a nossa classe

33232
21:59:59,680 --> 22:00:03,120
aqui como copiar objetos de cachorro e nós fazemos

33233
22:00:03,120 --> 22:00:05,360
que através de construtores chamamos cópia

33234
22:00:05,360 --> 22:00:07,680
Construtores que realmente não aprendemos

33235
22:00:07,680 --> 22:00:09,512
sobre ainda, mas o que o compilador está indo

33236
22:00:09,512 --> 22:00:12,160
fazer por padrão é copiar essas coisas

33237
22:00:12,160 --> 22:00:14,720
membro pelo membro, então ele vai configurar

33238
22:00:14,720 --> 22:00:16,872
a doug copy objeto que vai ser

33239
22:00:16,872 --> 22:00:20,000
inicializado com cordas vazias e um

33240
22:00:20,000 --> 22:00:22,232
ponteiro null aqui e então vai

33241
22:00:22,232 --> 22:00:25,120
cópia do nosso objeto de cão

33242
22:00:25,120 --> 22:00:27,192
que temos aqui vai levar o

33243
22:00:27,192 --> 22:00:29,600
nome e cópia que no nome membro

33244
22:00:29,600 --> 22:00:31,920
variável da nossa cópia escura que vai

33245
22:00:31,920 --> 22:00:34,480
tomar a raça e copiar que n na

33246
22:00:34,480 --> 22:00:36,552
Segunda variável de membro aqui e é

33247
22:00:36,552 --> 22:00:38,960
Vou tirar a idade do nosso cão e

33248
22:00:38,960 --> 22:00:41,120
copiar que no problema vai

33249
22:00:41,120 --> 22:00:42,960
chegar a este ponteiro aqui ele vai chegar

33250
22:00:42,960 --> 22:00:45,600
copiar o endereço e não vai

33251
22:00:45,600 --> 22:00:47,920
Copie o que está apontado e isso é

33252
22:00:47,920 --> 22:00:50,080
Vai ser uma receita para um desastre i

33253
22:00:50,080 --> 22:00:51,680
Não quero realmente passar por isso

33254
22:00:51,680 --> 22:00:54,080
Agora, mas se tentarmos correr isso

33255
22:00:54,080 --> 22:00:56,160
Não vai funcionar como nós

33256
22:00:56,160 --> 22:00:58,960
espere, por exemplo, se passarmos fofos

33257
22:00:58,960 --> 22:01:01,192
Aqui vamos ver

33258
22:01:01,192 --> 22:01:03,680
Coisas que não esperamos, então vamos tentar

33259
22:01:03,680 --> 22:01:06,720
para construir, vamos construir com gcc

33260
22:01:06,720 --> 22:01:09,680
e o parafuso é bom, então o que nós esperamos

33261
22:01:09,680 --> 22:01:11,920
É ter o construtor de fofos

33262
22:01:11,920 --> 22:01:14,160
Aqui ligou e vamos copiar o

33263
22:01:14,160 --> 22:01:17,360
objeto de pontos para uso em algum funk aqui e

33264
22:01:17,360 --> 22:01:20,000
para configurar esta cópia não é isso

33265
22:01:20,000 --> 22:01:21,832
construtor aqui que vai ser

33266
22:01:21,832 --> 22:01:22,872
Chamada

33267
22:01:22,872 --> 22:01:24,960
então não é nosso construtor aqui que

33268
22:01:24,960 --> 22:01:26,552
vai ser chamado assim nós não vamos

33269
22:01:26,552 --> 22:01:27,600
para ver

33270
22:01:27,600 --> 22:01:30,320
Isso pedia a cópia que estabelecemos

33271
22:01:30,320 --> 22:01:32,720
Dentro de algum funk outra coisa é

33272
22:01:32,720 --> 22:01:35,512
Porque agora estes dois objetos de cão são

33273
22:01:35,512 --> 22:01:37,832
apontando para a mesma coisa porque

33274
22:01:37,832 --> 22:01:41,440
nós apenas copiamos é o endereço como vemos

33275
22:01:41,440 --> 22:01:44,160
em nossa variável de membro aqui os dois cães

33276
22:01:44,160 --> 22:01:46,000
Os objetos vão apontar para o

33277
22:01:46,000 --> 22:01:48,400
A mesma coisa na memória e quando atingimos o

33278
22:01:48,400 --> 22:01:50,552
Destructor vamos chamar delete

33279
22:01:50,552 --> 22:01:52,640
duas vezes e isso vai ser uma receita

33280
22:01:52,640 --> 22:01:55,040
para desastre nossa aplicação poderia

33281
22:01:55,040 --> 22:01:57,192
Realmente bater você já sabe que

33282
22:01:57,192 --> 22:02:00,000
Excluir um ponteiro duas vezes é realmente ruim

33283
22:02:00,000 --> 22:02:02,080
Não devemos fazer isso e estamos fazendo

33284
22:02:02,080 --> 22:02:04,000
Aqui porque estamos a copiar

33285
22:02:04,000 --> 22:02:06,400
Percebe que isso é um pouco confuso

33286
22:02:06,400 --> 22:02:07,440
O exemplo

33287
22:02:07,440 --> 22:02:09,600
Mas o que eu quero que você saiba é que se

33288
22:02:09,600 --> 22:02:11,920
Você passa um objeto de classe por valor como

33289
22:02:11,920 --> 22:02:12,720
Isto é

33290
22:02:12,720 --> 22:02:15,360
A cópia que você tem dentro está indo para

33291
22:02:15,360 --> 22:02:18,160
causa do destruidor para ser chamado

33292
22:02:18,160 --> 22:02:20,640
quando a função sai porque o texto

33293
22:02:20,640 --> 22:02:22,320
será de escopo dentro do

33294
22:02:22,320 --> 22:02:24,640
função aqui, então vamos tirar isso

33295
22:02:24,640 --> 22:02:26,640
Por exemplo, porque é realmente confuso

33296
22:02:26,640 --> 22:02:28,720
Mas eu espero que você saiba disso e eu estou indo

33297
22:02:28,720 --> 22:02:30,720
Para mostrar que outro caso onde você

33298
22:02:30,720 --> 22:02:32,960
pode ver o destruidor chamado é quando

33299
22:02:32,960 --> 22:02:37,192
Você chama explicitamente o destruidor usando explicitamente

33300
22:02:37,192 --> 22:02:39,680
o operador de exclusão em seu objeto para que nós

33301
22:02:39,680 --> 22:02:41,920
pode configurar algum func novamente, vamos fazer isso

33302
22:02:41,920 --> 22:02:44,080
algum funk e vamos redirecionar

33303
22:02:44,080 --> 22:02:45,680
Isso e dentro vamos montar um

33304
22:02:45,680 --> 22:02:48,960
objeto gole, então vamos pegar isso e reutilizar

33305
22:02:48,960 --> 22:02:51,512
que na nossa função aqui e nós somos

33306
22:02:51,512 --> 22:02:53,832
vou dizer dog pointer, então vamos dizer

33307
22:02:53,832 --> 22:02:56,800
dog pointer nós vamos dizer p cão p

33308
22:02:56,800 --> 22:02:59,512
ressaltar o cão que vai ser igual

33309
22:02:59,512 --> 22:03:02,400
para o cão novo e vamos passar

33310
22:03:02,400 --> 22:03:04,720
O que precisamos para inicializar nosso cão

33311
22:03:04,720 --> 22:03:07,040
O objeto com isso vai criar um

33312
22:03:07,040 --> 22:03:09,040
Objeto escuro no quadril e está indo

33313
22:03:09,040 --> 22:03:11,760
para ser apontado pelo cão p aqui

33314
22:03:11,760 --> 22:03:14,160
Agora eu quero que você veja isso se não

33315
22:03:14,160 --> 22:03:17,120
Libere explicitamente a memória que nós

33316
22:03:17,120 --> 22:03:20,000
alocar através do novo operador que somos

33317
22:03:20,000 --> 22:03:22,320
vamos vazar memória, então criamos um

33318
22:03:22,320 --> 22:03:24,960
Objeto no quadril aqui, mas nós não estamos

33319
22:03:24,960 --> 22:03:27,440
Excluindo isso em algum funk quando alguns

33320
22:03:27,440 --> 22:03:29,280
funk sais, vamos perder isso

33321
22:03:29,280 --> 22:03:31,600
apontar esta variável porque está em

33322
22:03:31,600 --> 22:03:34,160
a pilha em si e não teremos nenhum

33323
22:03:34,160 --> 22:03:36,232
maneira de liberar essa memória, vamos chamar

33324
22:03:36,232 --> 22:03:38,320
algum funk aqui e realmente mostrar-lhe isso

33325
22:03:38,320 --> 22:03:40,000
então vamos chamar um pouco de funk e

33326
22:03:40,000 --> 22:03:42,480
vamos construir vamos usar gcc para

33327
22:03:42,480 --> 22:03:44,872
que a construção é boa, podemos trazer isso

33328
22:03:44,872 --> 22:03:47,280
para cima um pouco e claro e correr

33329
22:03:47,280 --> 22:03:48,960
Galo vamos ver que

33330
22:03:48,960 --> 22:03:51,280
construtor para fofo foi chamado

33331
22:03:51,280 --> 22:03:54,000
Por causa deste novo operador, mas nós

33332
22:03:54,000 --> 22:03:55,680
Não viu o destruidor chamado e

33333
22:03:55,680 --> 22:03:57,192
Isso é realmente ruim

33334
22:03:57,192 --> 22:03:59,440
para que o destructor seja chamado,

33335
22:03:59,440 --> 22:04:02,080
precisa liberar explicitamente a memória em

33336
22:04:02,080 --> 22:04:04,720
Esta função aqui e fazemos isso por

33337
22:04:04,720 --> 22:04:07,512
usando a palavra-chave delete e dizendo o

33338
22:04:07,512 --> 22:04:09,920
pontodor que está apontando para a memória

33339
22:04:09,920 --> 22:04:12,232
que queremos liberar se fizermos isso

33340
22:04:12,232 --> 22:04:14,320
Isso vai causar o

33341
22:04:14,320 --> 22:04:16,960
estrutura da dúvida a ser chamada e se

33342
22:04:16,960 --> 22:04:18,720
nós corremos nós vamos ver o nosso destruidor

33343
22:04:18,720 --> 22:04:20,480
chamados, vamos fazer isso, vamos usar

33344
22:04:20,480 --> 22:04:23,120
gcc o parafuso é bom você pode limpar e

33345
22:04:23,120 --> 22:04:25,120
correr galo agora você vê que o

33346
22:04:25,120 --> 22:04:27,440
O construtor é chamado cheio de fofos e nós

33347
22:04:27,440 --> 22:04:30,640
ter o frio do destructor isso é realmente

33348
22:04:30,640 --> 22:04:32,552
Tudo que eu queria compartilhar com você nisso

33349
22:04:32,552 --> 22:04:35,192
A palestra eu peço desculpas se você encontrou

33350
22:04:35,192 --> 22:04:37,680
confuso, mas se você tiver algum problema, eu

33351
22:04:37,680 --> 22:04:40,552
Estou sempre disponível, por favor, pergunte e eu

33352
22:04:40,552 --> 22:04:42,872
Vou fazer o melhor que posso para te ajudar

33353
22:04:42,872 --> 22:04:45,600
O destruidor é um método especial

33354
22:04:45,600 --> 22:04:47,600
que vai ser chamado quando você

33355
22:04:47,600 --> 22:04:50,080
Objeto morre que vai ser chamado

33356
22:04:50,080 --> 22:04:52,320
quando um objeto é passado por um valor para um

33357
22:04:52,320 --> 22:04:54,480
A função temos visto um exemplo que

33358
22:04:54,480 --> 22:04:56,400
vai ser chamado quando um local

33359
22:04:56,400 --> 22:04:58,480
objeto é retornado de uma função por

33360
22:04:58,480 --> 22:05:00,872
valor, mas isso vai ser compilador

33361
22:05:00,872 --> 22:05:02,872
dependendo porque alguns compiladores são

33362
22:05:02,872 --> 22:05:05,512
indo para otimizar isso e fazê-lo

33363
22:05:05,512 --> 22:05:08,080
Olhe como quando você retornou por referência

33364
22:05:08,080 --> 22:05:10,160
então eu não quero entrar nisso porque

33365
22:05:10,160 --> 22:05:13,360
isso está sujeito à otimização do compilador

33366
22:05:13,360 --> 22:05:15,280
Mas outros casos em que você vai

33367
22:05:15,280 --> 22:05:17,680
ter o seu destructor chamado é quando um

33368
22:05:17,680 --> 22:05:20,720
Objeto de pilha local sai do escopo e

33369
22:05:20,720 --> 22:05:23,512
Quando um objeto de quadril é excluído

33370
22:05:23,512 --> 22:05:25,920
através do mundo chave delete este é

33371
22:05:25,920 --> 22:05:27,680
Realmente tudo que eu tinha para compartilhar isso

33372
22:05:27,680 --> 22:05:30,000
Uma palestra espero que você tenha achado interessante

33373
22:05:30,000 --> 22:05:32,000
Vamos parar por aqui neste

33374
22:05:32,000 --> 22:05:33,680
E o próximo vamos ver o

33375
22:05:33,680 --> 22:05:36,480
ordem em que os construtores e estes

33376
22:05:36,480 --> 22:05:38,640
As estruturas são chamadas e você realmente

33377
22:05:38,640 --> 22:05:40,800
Precisamos estar cientes disso

33378
22:05:40,800 --> 22:05:42,720
Vá em frente e termine aqui

33379
22:05:42,720 --> 22:05:44,720
e me encontrar lá

33380
22:05:44,720 --> 22:05:47,360
e esta palestra eu queria levantar o seu

33381
22:05:47,360 --> 22:05:50,000
consciência sobre a ordem em que

33382
22:05:50,000 --> 22:05:52,480
Os construtores e as estruturas são

33383
22:05:52,480 --> 22:05:54,872
chamado suponhamos que temos nossa classe, que

33384
22:05:54,872 --> 22:05:57,600
é cavado aqui e nós temos o construtor

33385
22:05:57,600 --> 22:05:59,832
que está fazendo sua coisa no corpo

33386
22:05:59,832 --> 22:06:02,320
Aqui e nós temos o destruidor que é

33387
22:06:02,320 --> 22:06:04,400
liberando nossa memória e impressão

33388
22:06:04,400 --> 22:06:07,120
Algo fora, então suponha que criamos

33389
22:06:07,120 --> 22:06:08,800
Alguns dos objetos

33390
22:06:08,800 --> 22:06:10,872
desta classe aqui e eles têm

33391
22:06:10,872 --> 22:06:13,280
Nomes diferentes e eles têm o mesmo

33392
22:06:13,280 --> 22:06:15,512
raça e bordas diferentes como você vê

33393
22:06:15,512 --> 22:06:16,400
Aqui

33394
22:06:16,400 --> 22:06:19,360
e se executarmos este código em

33395
22:06:19,360 --> 22:06:21,680
O que você acha que vai ver impresso a partir de

33396
22:06:21,680 --> 22:06:24,552
os construtores e os destruidores se

33397
22:06:24,552 --> 22:06:26,872
Você me perguntou e eu estava aprendendo sobre c

33398
22:06:26,872 --> 22:06:28,872
mais mais eu diria que o

33399
22:06:28,872 --> 22:06:30,552
Os construtores serão chamados

33400
22:06:30,552 --> 22:06:33,440
pedir o cão um cão dois cão três cão quatro

33401
22:06:33,440 --> 22:06:35,360
eles serão construídos neste

33402
22:06:35,360 --> 22:06:37,760
A ordem e os destruidores seriam

33403
22:06:37,760 --> 22:06:40,400
Chamado na mesma ordem, mas isso não é

33404
22:06:40,400 --> 22:06:42,720
O verdadeiro destruidores vai ser

33405
22:06:42,720 --> 22:06:45,600
chamado na ordem inversa como você vê

33406
22:06:45,600 --> 22:06:47,120
na direita aqui

33407
22:06:47,120 --> 22:06:48,720
Então vamos chamar isso de construtor

33408
22:06:48,720 --> 22:06:52,552
para doug d1 delegate2w3 doge4 que é

33409
22:06:52,552 --> 22:06:55,192
exatamente o que eu esperava, mas você está indo

33410
22:06:55,192 --> 22:06:57,280
para ver que os destruidores vão

33411
22:06:57,280 --> 22:07:00,400
ser chamado em ordem inversa para que o objeto

33412
22:07:00,400 --> 22:07:02,960
que foi construído por último

33413
22:07:02,960 --> 22:07:05,512
Vai ser destruído primeiro como você

33414
22:07:05,512 --> 22:07:07,680
Veja aqui e o objeto que foi

33415
22:07:07,680 --> 22:07:09,600
Construído primeiro vai ser

33416
22:07:09,600 --> 22:07:10,800
destruídos

33417
22:07:10,800 --> 22:07:14,232
por último e o compilador segue esta ordem

33418
22:07:14,232 --> 22:07:16,552
para tornar mais fácil para ele fazer coisas que nós

33419
22:07:16,552 --> 22:07:19,600
Não pode realmente entrar nesses detalhes, mas

33420
22:07:19,600 --> 22:07:21,192
por enquanto nós vamos ir para

33421
22:07:21,192 --> 22:07:23,120
código de estúdio visual e jogar com a gente um

33422
22:07:23,120 --> 22:07:25,680
Um pouco mais bem aqui estamos em nosso

33423
22:07:25,680 --> 22:07:28,160
pasta de trabalho o projeto atual é

33424
22:07:28,160 --> 22:07:30,960
ordem de construtor e destruidor

33425
22:07:30,960 --> 22:07:32,872
Chamadas aqui nós vamos pegar o nosso

33426
22:07:32,872 --> 22:07:35,280
Projeto de modelo muito rápido

33427
22:07:35,280 --> 22:07:37,832
e nós vamos colocá-los no lugar

33428
22:07:37,832 --> 22:07:39,832
Arquivos que quero dizer e vamos abrir

33429
22:07:39,832 --> 22:07:41,920
Isso em código de estúdio visual como temos

33430
22:07:41,920 --> 22:07:44,320
Tenho feito o tempo todo isso vai

33431
22:07:44,320 --> 22:07:47,440
abrir nossa pasta podemos fechar a esquerda

33432
22:07:47,440 --> 22:07:50,872
sidebar aqui e vamos limpar o nosso principal

33433
22:07:50,872 --> 22:07:53,120
Função que vamos trazer no

33434
22:07:53,120 --> 22:07:55,920
classe para cão da última palestra

33435
22:07:55,920 --> 22:07:58,080
É exatamente o que tínhamos lá

33436
22:07:58,080 --> 22:08:00,640
Não há mudança e vamos incluir o

33437
22:08:00,640 --> 22:08:02,720
string review library para isso funcionar

33438
22:08:02,720 --> 22:08:04,960
Então vamos incluir a imagem de string

33439
22:08:04,960 --> 22:08:06,960
Aqui e uma vez que fazemos isso, vamos

33440
22:08:06,960 --> 22:08:09,120
cabeça sobre na função principal e conjunto

33441
22:08:09,120 --> 22:08:10,552
para cima alguns

33442
22:08:10,552 --> 22:08:13,440
objetos da classe do cão aqui, mas antes

33443
22:08:13,440 --> 22:08:15,600
Vamos lá perceber que temos alguns

33444
22:08:15,600 --> 22:08:18,872
htdc out declarações em nosso construtor

33445
22:08:18,872 --> 22:08:21,360
e destructor e queremos ver o

33446
22:08:21,360 --> 22:08:23,680
ordem em que eles são chamados assim nós somos

33447
22:08:23,680 --> 22:08:26,480
Vou criar quatro objetos do nosso cão

33448
22:08:26,480 --> 22:08:28,720
nós vamos dizer cão um e nós somos

33449
22:08:28,720 --> 22:08:32,080
vai dizer o nome a ser ganho e é

33450
22:08:32,080 --> 22:08:34,720
Vai ser um pastor e vai

33451
22:08:34,720 --> 22:08:37,280
ser, por exemplo, 2 anos de idade, por que não

33452
22:08:37,280 --> 22:08:39,512
Devia dizer cão aqui e nós vamos

33453
22:08:39,512 --> 22:08:41,832
Copie estas quatro vezes aqui e nós estamos

33454
22:08:41,832 --> 22:08:44,000
Vou chamar este cão 2

33455
22:08:44,000 --> 22:08:46,400
O outro vai ser cão 3 e isso

33456
22:08:46,400 --> 22:08:48,552
Vai ser o cão 4

33457
22:08:48,552 --> 22:08:50,552
E eu vou dizer a mesma coisa aqui

33458
22:08:50,552 --> 22:08:52,000
cachorrinho dois

33459
22:08:52,000 --> 22:08:54,400
Três e quatro

33460
22:08:54,400 --> 22:08:56,640
Os nomes são o que é realmente importante

33461
22:08:56,640 --> 22:08:58,320
Porque nós vamos vê-los impressos

33462
22:08:58,320 --> 22:09:00,320
Aqui fora, mas se você quiser, você pode mudar

33463
22:09:00,320 --> 22:09:03,280
As idades vamos fazer disso um três, vamos

33464
22:09:03,280 --> 22:09:05,680
fazer este um cinco vamos fazer este um

33465
22:09:05,680 --> 22:09:07,920
Por que não para dougie e agora estamos

33466
22:09:07,920 --> 22:09:10,640
indo para executar o nosso programa se executá-lo

33467
22:09:10,640 --> 22:09:12,080
Nós vamos ver os construtores

33468
22:09:12,080 --> 22:09:14,960
chamado na ordem doggy um cachorrinho 2

33469
22:09:14,960 --> 22:09:18,000
w3 cão e4 e os destruidores estão indo

33470
22:09:18,000 --> 22:09:20,232
para ser chamado na ordem inversa

33471
22:09:20,232 --> 22:09:21,440
dogifur

33472
22:09:21,440 --> 22:09:23,832
todo o caminho para cachorrinho um vamos ferver e

33473
22:09:23,832 --> 22:09:26,160
mostrar que este é realmente o caso

33474
22:09:26,160 --> 22:09:28,640
para que a construção seja boa, podemos trazer um

33475
22:09:28,640 --> 22:09:31,600
terminal e realmente executar isso vamos limpar

33476
22:09:31,600 --> 22:09:34,000
e correr galo você vai ver que

33477
22:09:34,000 --> 22:09:36,400
Construtor de cães pediu um doki um

33478
22:09:36,400 --> 22:09:38,720
todo o caminho para o cão e4 e agora temos

33479
22:09:38,720 --> 22:09:41,760
o destrutor de adaga chamado de doge4

33480
22:09:41,760 --> 22:09:44,640
todo o caminho para doge one e o compilador

33481
22:09:44,640 --> 22:09:47,120
vai fazer cumprir esta ordem para

33482
22:09:47,120 --> 22:09:49,832
Chamando construtores e destruidores

33483
22:09:49,832 --> 22:09:52,480
porque torna mais fácil para ele

33484
22:09:52,480 --> 22:09:55,512
Gerenciar a memória de objetos, por exemplo

33485
22:09:55,512 --> 22:09:58,160
Se o pato existe há muito tempo

33486
22:09:58,160 --> 22:10:00,800
O tempo e tem porque vai ser

33487
22:10:00,800 --> 22:10:03,040
ao redor antes de um cão

33488
22:10:03,040 --> 22:10:04,080
Se você

33489
22:10:04,080 --> 22:10:06,080
excluir o pato um

33490
22:10:06,080 --> 22:10:09,120
Depois do cão quatro aqui pode haver outro

33491
22:10:09,120 --> 22:10:11,760
objetos que dependem do cão, então isso é

33492
22:10:11,760 --> 22:10:15,360
Por que o objeto que foi criado o último

33493
22:10:15,360 --> 22:10:18,320
é excluído primeiro porque as chances para

33494
22:10:18,320 --> 22:10:21,192
Outros objetos para depender desse último

33495
22:10:21,192 --> 22:10:23,680
O objeto é realmente magro e você pode

33496
22:10:23,680 --> 22:10:26,160
excluí-lo sem qualquer problema, mas o

33497
22:10:26,160 --> 22:10:29,280
objeto que foi criado primeiro pode ter

33498
22:10:29,280 --> 22:10:31,192
Outras dependências e você vai

33499
22:10:31,192 --> 22:10:34,720
excluir primeiro o objeto dependente

33500
22:10:34,720 --> 22:10:36,800
antes de excluir esse objeto, eu acho

33501
22:10:36,800 --> 22:10:39,192
Esta é a lógica que o compilador segue

33502
22:10:39,192 --> 22:10:41,512
para realmente fazer cumprir esta ordem aqui e

33503
22:10:41,512 --> 22:10:43,600
Você precisa estar ciente disso e fazer

33504
22:10:43,600 --> 22:10:46,320
certo que em qualquer momento em seu c-plus

33505
22:10:46,320 --> 22:10:49,192
além da aplicação, isso está funcionando para o seu

33506
22:10:49,192 --> 22:10:51,680
vantagem é realmente tudo que eu tinha que

33507
22:10:51,680 --> 22:10:53,440
compartilhar nesta palestra eu espero que você tenha encontrado

33508
22:10:53,440 --> 22:10:55,920
É interessante que vamos parar por aqui

33509
22:10:55,920 --> 22:10:57,680
Neste e no próximo vamos

33510
22:10:57,680 --> 22:11:00,640
para aprender sobre este ponteiro vá em frente

33511
22:11:00,640 --> 22:11:03,440
e terminar aqui e encontrar-me lá

33512
22:11:03,440 --> 22:11:04,872
Nesta palestra vamos aprender

33513
22:11:04,872 --> 22:11:07,920
sobre este ponteiro e este é um

33514
22:11:07,920 --> 22:11:11,040
ponteiro especial que é mantido por c

33515
22:11:11,040 --> 22:11:14,160
Plus plus para realmente ajudá-lo a manipular

33516
22:11:14,160 --> 22:11:17,192
O objeto atual e é a corrente

33517
22:11:17,192 --> 22:11:20,320
Objeto para o qual um determinado método está sendo

33518
22:11:20,320 --> 22:11:23,512
executado aqui é um exemplo simples com

33519
22:11:23,512 --> 22:11:26,160
nossa aula de cães e vamos mostrar

33520
22:11:26,160 --> 22:11:28,552
alguma utilidade para este ponteiro do

33521
22:11:28,552 --> 22:11:30,000
A primeira coisa que vamos olhar é

33522
22:11:30,000 --> 22:11:32,480
A sintaxe, por exemplo, aqui podemos

33523
22:11:32,480 --> 22:11:35,600
Necessidade de imprimir o endereço na memória

33524
22:11:35,600 --> 22:11:38,232
onde o objeto foi criado e fazer isso

33525
22:11:38,232 --> 22:11:40,552
a partir do interior da função e para

33526
22:11:40,552 --> 22:11:42,320
Fazemos que usamos este ponteiro para

33527
22:11:42,320 --> 22:11:44,640
Por exemplo, podemos enviar uma mensagem e nós

33528
22:11:44,640 --> 22:11:46,720
pode fazer isso através de uma declaração como nós

33529
22:11:46,720 --> 22:11:49,360
Temos aqui estamos imprimindo o nome do cão do cão

33530
22:11:49,360 --> 22:11:52,480
Construído em um determinado endereço de memória

33531
22:11:52,480 --> 22:11:55,040
e usamos esta palavra-chave para obter o

33532
22:11:55,040 --> 22:11:58,232
endereço do objeto do personagem para

33533
22:11:58,232 --> 22:12:00,960
que um método ou função específica é

33534
22:12:00,960 --> 22:12:03,360
sendo chamado neste caso, foi o

33535
22:12:03,360 --> 22:12:06,160
construtor do objeto dot aqui

33536
22:12:06,160 --> 22:12:08,160
Também pode fazer o mesmo pelo outro

33537
22:12:08,160 --> 22:12:10,552
construtor e você vê que estamos usando o

33538
22:12:10,552 --> 22:12:13,760
Este ponteiro é um dos usos que você

33539
22:12:13,760 --> 22:12:16,480
ter para este ponteiro novamente o

33540
22:12:16,480 --> 22:12:18,960
O ponteiro é um ponteiro especial que é

33541
22:12:18,960 --> 22:12:21,680
mantido pelo sistema c plus plus e

33542
22:12:21,680 --> 22:12:23,440
vai estar apontando para o

33543
22:12:23,440 --> 22:12:26,640
Objeto atual que está sendo manipulado

33544
22:12:26,640 --> 22:12:29,600
pelo z plus mais tempo de execução e é

33545
22:12:29,600 --> 22:12:31,600
vai ser manipulado através de um

33546
22:12:31,600 --> 22:12:35,120
Função especial do objeto de classe

33547
22:12:35,120 --> 22:12:37,280
que está sendo chamado isso é o significado

33548
22:12:37,280 --> 22:12:40,640
Aqui está um outro caso de uso para o

33549
22:12:40,640 --> 22:12:43,920
Este ponteiro pode ser usado para resolver

33550
22:12:43,920 --> 22:12:47,120
conflitos quando você tem um parâmetro e

33551
22:12:47,120 --> 22:12:49,360
uma variável de membro que é chamada de

33552
22:12:49,360 --> 22:12:51,192
Da mesma forma, por exemplo, aqui estamos chamando

33553
22:12:51,192 --> 22:12:54,232
A função de nome do conjunto tem um parâmetro

33554
22:12:54,232 --> 22:12:56,872
com um nome dou nome e tem um

33555
22:12:56,872 --> 22:12:59,680
variável membro chamada nome do cão, então se

33556
22:12:59,680 --> 22:13:02,160
Você faz uma declaração como temos no topo

33557
22:13:02,160 --> 22:13:04,160
Aqui o compilador vai ser

33558
22:13:04,160 --> 22:13:06,160
confusos, eles vão dizer o nome do cão

33559
22:13:06,160 --> 22:13:09,040
igual a nome do cão e ele não vai realmente saber

33560
22:13:09,040 --> 22:13:11,512
A que nome do cão você está se referindo nós

33561
22:13:11,512 --> 22:13:14,640
pode resolver esse conflito dizendo:

33562
22:13:14,640 --> 22:13:18,400
isto e dizer notação de acesso ao ponteiro

33563
22:13:18,400 --> 22:13:20,640
e dizer nome de cão e esta coisa aqui é

33564
22:13:20,640 --> 22:13:22,640
vai ser a variável membro e

33565
22:13:22,640 --> 22:13:24,320
nós vamos atribuir ao

33566
22:13:24,320 --> 22:13:27,192
variável membro do parâmetro este

33567
22:13:27,192 --> 22:13:29,832
é o significado aqui e podemos usar o

33568
22:13:29,832 --> 22:13:32,720
desperador para resolver tais conflitos

33569
22:13:32,720 --> 22:13:34,960
Outro uso que temos para usar ponteiro é

33570
22:13:34,960 --> 22:13:37,680
Se quisermos configurar chamadas acorrentadas para

33571
22:13:37,680 --> 22:13:39,832
exemplo usando ponteiros e podemos precisar

33572
22:13:39,832 --> 22:13:42,720
para fazer algo assim, então temos um

33573
22:13:42,720 --> 22:13:45,360
dog pointer configurado em cima aqui e nós

33574
22:13:45,360 --> 22:13:48,320
pode fazer algo com o nosso novo objeto para

33575
22:13:48,320 --> 22:13:50,232
Exemplo podemos chamar uma função chamada

33576
22:13:50,232 --> 22:13:53,512
impressão em um objeto de cão depois de imprimir

33577
22:13:53,512 --> 22:13:55,512
A informação que vamos definir alguns

33578
22:13:55,512 --> 22:13:57,760
Informações sobre o documento e você vê que

33579
22:13:57,760 --> 22:14:00,160
estão definindo todas as informações

33580
22:14:00,160 --> 22:14:02,640
através de uma declaração da maneira que alcançamos

33581
22:14:02,640 --> 22:14:05,120
este nosso setters vai ser

33582
22:14:05,120 --> 22:14:08,000
retornando um ponteiro para o atual

33583
22:14:08,000 --> 22:14:10,320
Objeto e nós vamos pegar

33584
22:14:10,320 --> 22:14:13,120
que retornam valor e chamadas

33585
22:14:13,120 --> 22:14:15,120
nele diretamente porque é um ponteiro

33586
22:14:15,120 --> 22:14:17,440
e nós vamos usar o ponteiro

33587
22:14:17,440 --> 22:14:19,680
Acesso notação para que vamos ligar

33588
22:14:19,680 --> 22:14:21,760
definir nome set nome vai retornar a

33589
22:14:21,760 --> 22:14:23,680
ponteiro, vamos usar esse ponteiro

33590
22:14:23,680 --> 22:14:26,320
dizer à raça e definir a raça é

33591
22:14:26,320 --> 22:14:28,000
Vou retornar um ponteiro para o qual vamos

33592
22:14:28,000 --> 22:14:30,720
usar esse ponteiro para definir a idade e

33593
22:14:30,720 --> 22:14:33,600
Depois de toda esta linha toda a

33594
22:14:33,600 --> 22:14:35,440
A informação vai mudar sobre o nosso

33595
22:14:35,440 --> 22:14:37,920
cão e podemos ver que aqui e depois

33596
22:14:37,920 --> 22:14:39,920
Fazemos o que quisermos com o nosso cão

33597
22:14:39,920 --> 22:14:41,760
Objeto, vamos liberá-lo de

33598
22:14:41,760 --> 22:14:43,832
Memória, então isso é outra coisa que você pode

33599
22:14:43,832 --> 22:14:46,872
conseguir usar este ponteiro e este

33600
22:14:46,872 --> 22:14:49,280
é como você pode configurar esses setters

33601
22:14:49,280 --> 22:14:51,680
Não é nada complicado, nós estabelecemos o nome

33602
22:14:51,680 --> 22:14:53,760
vai devolver o ponteiro do ponto e

33603
22:14:53,760 --> 22:14:56,640
nós vamos devolver isso ok e isso

33604
22:14:56,640 --> 22:14:58,960
Vai ser um ponteiro ou a memória

33605
22:14:58,960 --> 22:15:02,232
Endereço do objeto atual do cão

33606
22:15:02,232 --> 22:15:04,800
classe temos a mesma configuração para seti

33607
22:15:04,800 --> 22:15:07,360
raça de cão, devolvemos o ponteiro do cão e

33608
22:15:07,360 --> 22:15:10,160
nós devolvemos esta mesma configuração para set

33609
22:15:10,160 --> 22:15:13,192
doug age, retornamos um ponteiro de cachorro e nós

33610
22:15:13,192 --> 22:15:14,160
retorno

33611
22:15:14,160 --> 22:15:16,640
Isso podemos fazer a mesma coisa usando

33612
22:15:16,640 --> 22:15:19,832
referências, mas nossa configuração será

33613
22:15:19,832 --> 22:15:22,400
Um pouco diferente

33614
22:15:22,400 --> 22:15:25,280
nós temos o nosso cão objeto aqui e nós somos

33615
22:15:25,280 --> 22:15:27,832
Vou fazer a nossa chamada de mudança aqui, então

33616
22:15:27,832 --> 22:15:29,760
nós vamos dizer o nome do set através do

33617
22:15:29,760 --> 22:15:30,960
O ponteiro

33618
22:15:30,960 --> 22:15:33,360
porque temos um ponteiro de pontos aqui, mas

33619
22:15:33,360 --> 22:15:35,360
Depois disso, vamos voltar um

33620
22:15:35,360 --> 22:15:38,480
referência das funções aqui definidas

33621
22:15:38,480 --> 22:15:39,920
O nome vai devolver uma referência

33622
22:15:39,920 --> 22:15:41,680
nós vamos passar por essa referência

33623
22:15:41,680 --> 22:15:43,440
para definir a raça

33624
22:15:43,440 --> 22:15:45,680
série de cães vai devolver um

33625
22:15:45,680 --> 22:15:47,600
referência e nós vamos passar

33626
22:15:47,600 --> 22:15:50,720
essa referência para definir a idade do cão e se

33627
22:15:50,720 --> 22:15:52,800
nós imprimimos a informação agora que estamos indo

33628
22:15:52,800 --> 22:15:55,040
para ver que temos novas informações em

33629
22:15:55,040 --> 22:15:57,832
nosso objeto de cão e depois que terminamos

33630
22:15:57,832 --> 22:16:00,232
com o nosso objeto cão temos que lembrar

33631
22:16:00,232 --> 22:16:03,120
para liberá-lo da memória porque era

33632
22:16:03,120 --> 22:16:06,400
alocado dinamicamente a partir do monte aqui

33633
22:16:06,400 --> 22:16:09,040
É como você pode configurar isso realmente é

33634
22:16:09,040 --> 22:16:11,280
Nada complicado só temos o nosso

33635
22:16:11,280 --> 22:16:13,760
setters e nós vamos devolver um

33636
22:16:13,760 --> 22:16:16,400
referência mas antes de retornar

33637
22:16:16,400 --> 22:16:18,480
O desespero que precisaremos

33638
22:16:18,480 --> 22:16:21,512
dereferência ao displayer e chegar ao

33639
22:16:21,512 --> 22:16:24,232
A coisa real que está sendo apontada para

33640
22:16:24,232 --> 22:16:26,552
É por isso que temos este operador de estrela

33641
22:16:26,552 --> 22:16:28,800
aqui e para os outros setters nós somos

33642
22:16:28,800 --> 22:16:30,080
Vou fazer a mesma coisa que vamos

33643
22:16:30,080 --> 22:16:31,832
para retornar uma referência, vamos

33644
22:16:31,832 --> 22:16:34,872
devolver uma versão dereferenciada disso

33645
22:16:34,872 --> 22:16:36,800
Vamos devolver uma referência de cão

33646
22:16:36,800 --> 22:16:38,552
para a idade do cão definido e nós vamos

33647
22:16:38,552 --> 22:16:41,360
devolver um desreferenciado este ponteiro

33648
22:16:41,360 --> 22:16:42,960
Porque esta é a referência que somos

33649
22:16:42,960 --> 22:16:46,080
Voltando aqui para que isso seja

33650
22:16:46,080 --> 22:16:48,480
O ponteiro é sobre agora que vamos cabeçar

33651
22:16:48,480 --> 22:16:50,480
sobre o código do estúdio visual e jogar com

33652
22:16:50,480 --> 22:16:53,120
nós um pouco mais bem aqui estamos em nosso

33653
22:16:53,120 --> 22:16:55,600
pasta de trabalho o projeto atual é

33654
22:16:55,600 --> 22:16:58,232
o displayer nós vamos pegar o nosso

33655
22:16:58,232 --> 22:17:00,320
arquivos de modelo e vamos colocar

33656
22:17:00,320 --> 22:17:02,480
eles no lugar e então nós vamos

33657
22:17:02,480 --> 22:17:04,720
abra isso em código de estúdio visual por

33658
22:17:04,720 --> 22:17:06,960
arrastando e soltando aqui isso está indo

33659
22:17:06,960 --> 22:17:08,800
para abrir nossa pasta, vamos abrir

33660
22:17:08,800 --> 22:17:10,720
O arquivo cpp principal e nós vamos

33661
22:17:10,720 --> 22:17:13,040
Feche a barra lateral esquerda aqui

33662
22:17:13,040 --> 22:17:15,280
para que tenhamos mais espaço para trabalhar

33663
22:17:15,280 --> 22:17:18,232
com eu vou colocar em uma versão de

33664
22:17:18,232 --> 22:17:20,080
nossa classe de cães

33665
22:17:20,080 --> 22:17:23,280
é bastante limitado agora que só

33666
22:17:23,280 --> 22:17:25,680
tem um destructor e um construtor e um

33667
22:17:25,680 --> 22:17:27,512
construtor e nós temos o nosso membro

33668
22:17:27,512 --> 22:17:29,360
variáveis e nós vamos

33669
22:17:29,360 --> 22:17:31,280
sintonizar isso um pouco para que possamos

33670
22:17:31,280 --> 22:17:33,680
Trabalhar conosco, no entanto, queremos o primeiro

33671
22:17:33,680 --> 22:17:36,872
O que queremos fazer é imprimir o

33672
22:17:36,872 --> 22:17:40,000
endereços de objetos cavados que nós

33673
22:17:40,000 --> 22:17:42,800
Construir e se destruir aqui e nós somos

33674
22:17:42,800 --> 22:17:45,120
Vou fazer isso em nosso construtor assim

33675
22:17:45,120 --> 22:17:48,720
Vamos para a nossa declaração hd dc aqui

33676
22:17:48,720 --> 22:17:51,280
e nós vamos dizer adicionar para significar o

33677
22:17:51,280 --> 22:17:53,360
Endereço de memória onde estava o objeto

33678
22:17:53,360 --> 22:17:55,832
construído e vamos dizer isso

33679
22:17:55,832 --> 22:17:59,120
então, quando fizermos isso, isso vai ser

33680
22:17:59,120 --> 22:18:02,080
O endereço em memória da corrente

33681
22:18:02,080 --> 22:18:05,040
objeto que está sendo construído

33682
22:18:05,040 --> 22:18:07,440
pelo nosso construtor aqui e nós vamos

33683
22:18:07,440 --> 22:18:10,160
para dizer a mesma coisa em nosso destruidor

33684
22:18:10,160 --> 22:18:12,232
nós vamos dizer e nós vamos

33685
22:18:12,232 --> 22:18:14,552
Diga o endereço de memória onde o atual

33686
22:18:14,552 --> 22:18:17,760
O objeto está sendo destruído depois de

33687
22:18:17,760 --> 22:18:19,512
Fazemos isto

33688
22:18:19,512 --> 22:18:22,232
se formos na função principal e para

33689
22:18:22,232 --> 22:18:24,480
O exemplo criou um objeto doug que estamos indo

33690
22:18:24,480 --> 22:18:26,720
para dizer escuro, vamos dizer cão um

33691
22:18:26,720 --> 22:18:27,832
e nós vamos dar isso

33692
22:18:27,832 --> 22:18:30,080
informação que vamos dar de

33693
22:18:30,080 --> 22:18:32,080
nome que vai ser fofo nós somos

33694
22:18:32,080 --> 22:18:33,680
vai dar a raça que é

33695
22:18:33,680 --> 22:18:35,280
Vou ser um pastor e nós vamos

33696
22:18:35,280 --> 22:18:37,360
para dar a idade de dois como temos

33697
22:18:37,360 --> 22:18:39,192
Tenho feito o tempo todo quando fazemos

33698
22:18:39,192 --> 22:18:40,720
Algo assim isto vai

33699
22:18:40,720 --> 22:18:42,320
chamar o construtor porque nós somos

33700
22:18:42,320 --> 22:18:45,360
tentando configurar um objeto e antes

33701
22:18:45,360 --> 22:18:47,360
A principal função termina que vamos

33702
22:18:47,360 --> 22:18:49,360
chamar o destruidor e nós vamos

33703
22:18:49,360 --> 22:18:51,600
Veja as coisas acontecendo aqui, digamos, feito

33704
22:18:51,600 --> 22:18:53,192
para que saibamos que o código é

33705
22:18:53,192 --> 22:18:55,600
Na verdade, correndo eu vou dizer sddc

33706
22:18:55,600 --> 22:18:58,000
Pronto aqui, temos a configuração

33707
22:18:58,000 --> 22:18:58,872
feito

33708
22:18:58,872 --> 22:19:01,512
nós podemos construir e executar o aplicativo

33709
22:19:01,512 --> 22:19:04,080
vamos usar o gcc para construir e

33710
22:19:04,080 --> 22:19:06,480
A construção é boa, podemos trazer um terminal

33711
22:19:06,480 --> 22:19:09,512
para tentar executar o aplicativo e agora

33712
22:19:09,512 --> 22:19:11,600
Se corrermos o galo, vamos ver

33713
22:19:11,600 --> 22:19:14,720
aquele construtor de cães pediu um fofo

33714
22:19:14,720 --> 22:19:17,440
neste local de memória e a atual

33715
22:19:17,440 --> 22:19:20,000
O objeto é este objeto aqui que é

33716
22:19:20,000 --> 22:19:21,920
sendo construídos e nós vamos

33717
22:19:21,920 --> 22:19:23,920
ter acesso à sua memória através do

33718
22:19:23,920 --> 22:19:26,000
Este ponteiro espero que você possa ver como

33719
22:19:26,000 --> 22:19:29,440
Isso é poderoso se não tivermos o

33720
22:19:29,440 --> 22:19:31,680
Este ponteiro é a única maneira de obter o

33721
22:19:31,680 --> 22:19:32,872
Endereço para

33722
22:19:32,872 --> 22:19:35,832
Este objetivo seria pegar o endereço

33723
22:19:35,832 --> 22:19:38,480
da função principal ou de onde quer que

33724
22:19:38,480 --> 22:19:41,280
Estamos montando nosso objeto aqui, mas nós

33725
22:19:41,280 --> 22:19:44,232
ter acesso a este endereço a partir do

33726
22:19:44,232 --> 22:19:46,640
dentro das funções para a classe

33727
22:19:46,640 --> 22:19:48,872
E isso é muito legal para que possamos

33728
22:19:48,872 --> 22:19:51,760
manipular esses endereços se precisarmos

33729
22:19:51,760 --> 22:19:53,360
e nós vamos mostrar-lhe outro uso

33730
22:19:53,360 --> 22:19:55,832
para isso, então suponha que precisamos configurar

33731
22:19:55,832 --> 22:19:59,040
setters para a nossa classe aqui, então precisamos de um

33732
22:19:59,040 --> 22:20:01,360
setter para definir o nome a raça e para

33733
22:20:01,360 --> 22:20:03,600
definir a idade aqui, então vamos configurar o nosso

33734
22:20:03,600 --> 22:20:05,280
setters nós vamos dizer setters e

33735
22:20:05,280 --> 22:20:07,600
nós vamos dizer conjunto vazio

33736
22:20:07,600 --> 22:20:10,960
nome ou vamos ser explícito set nome do cão

33737
22:20:10,960 --> 22:20:12,720
Isso vai ser melhor e nós somos

33738
22:20:12,720 --> 22:20:15,512
indo passar uma visão de string que estamos indo

33739
22:20:15,512 --> 22:20:18,320
para dizer stds amigo de você e nós somos

33740
22:20:18,320 --> 22:20:20,080
vamos dizer o programa de nomes e nós somos

33741
22:20:20,080 --> 22:20:22,720
Vou colocar os corpos em nossa classe

33742
22:20:22,720 --> 22:20:25,192
Aqui, mas eu gostaria de encorajá-lo a ser

33743
22:20:25,192 --> 22:20:28,640
consistente se você está fazendo isso de verdade

33744
22:20:28,640 --> 22:20:31,120
Código que estamos aprendendo aqui e estamos

33745
22:20:31,120 --> 22:20:33,280
tomar alguns atalhos para que possamos fazer

33746
22:20:33,280 --> 22:20:35,512
Coisas simplesmente, mas o que queremos ver

33747
22:20:35,512 --> 22:20:38,160
Agora é o que acontece se tivermos um

33748
22:20:38,160 --> 22:20:40,872
parâmetro chamado como um membro

33749
22:20:40,872 --> 22:20:44,080
variável assim como você define

33750
22:20:44,080 --> 22:20:46,080
este nome para a variável membro chamada

33751
22:20:46,080 --> 22:20:48,400
o nome, então se você tem um caso como este

33752
22:20:48,400 --> 22:20:49,832
Você realmente vai estar em apuros

33753
22:20:49,832 --> 22:20:52,160
porque se você diz nome é igual a nome

33754
22:20:52,160 --> 22:20:53,832
Vamos tentar isto.

33755
22:20:53,832 --> 22:20:55,760
Devemos obter um erro de compilador ou um
linha 
33756
22:20:55,760 --> 22:20:57,680
piggly porque o compilador é

33757
22:20:57,680 --> 22:20:59,440
Não vai saber

33758
22:20:59,440 --> 22:21:01,440
qual nome você está usando aqui é a

33759
22:21:01,440 --> 22:21:03,360
Memorial é o parâmetro que não é

33760
22:21:03,360 --> 22:21:05,760
vai saber e vamos tentar construir e

33761
22:21:05,760 --> 22:21:07,600
Veja o que temos, vamos usar o

33762
22:21:07,600 --> 22:21:09,280
gcc (em cc)

33763
22:21:09,280 --> 22:21:13,120
e surpreendentemente Gcc está tomando isso

33764
22:21:13,120 --> 22:21:15,832
e provavelmente é saber que temos um

33765
22:21:15,832 --> 22:21:17,832
membro variável chamada nome e é

33766
22:21:17,832 --> 22:21:19,680
vai atribuir o parâmetro a isso

33767
22:21:19,680 --> 22:21:22,960
membro variável assim nos bastidores gcc

33768
22:21:22,960 --> 22:21:25,832
Vai mudar isso para isso é

33769
22:21:25,832 --> 22:21:29,280
usar esse nome igual a nome

33770
22:21:29,280 --> 22:21:31,120
Esta é a sintaxe que queremos que seja

33771
22:21:31,120 --> 22:21:34,080
Realmente não confuso, mas o que temos sobre

33772
22:21:34,080 --> 22:21:36,552
O topo aqui vai ser confuso e

33773
22:21:36,552 --> 22:21:38,552
Alguns compiladores nem vão

33774
22:21:38,552 --> 22:21:40,960
tomar isso vamos deixar isso dentro e

33775
22:21:40,960 --> 22:21:43,040
realmente construí-lo com a gente eu quero

33776
22:21:43,040 --> 22:21:45,192
Veja que isso realmente funciona, então nós somos

33777
22:21:45,192 --> 22:21:48,080
vamos soldar com sucesso e se formos

33778
22:21:48,080 --> 22:21:50,872
para baixo no principal e tentar dizer

33779
22:21:50,872 --> 22:21:54,000
cão um set nome de cão vamos dizer pumba

33780
22:21:54,000 --> 22:21:55,832
Vamos ver o que acontece se fizermos

33781
22:21:55,832 --> 22:21:57,680
Algo assim nós vamos tentar

33782
22:21:57,680 --> 22:22:00,160
e construir novamente e gcc vai tomar

33783
22:22:00,160 --> 22:22:02,232
Isso e isso é muito legal, então vamos

33784
22:22:02,232 --> 22:22:03,832
colocar em uma função que vai

33785
22:22:03,832 --> 22:22:06,720
imprimir informações sobre o nosso cão que podemos

33786
22:22:06,720 --> 22:22:08,872
fazer isso aqui em baixo e vai

33787
22:22:08,872 --> 22:22:11,120
Não retorne nada que vai ser chamado

33788
22:22:11,120 --> 22:22:13,512
imprimir informações e ele vai basicamente

33789
22:22:13,512 --> 22:22:15,512
imprimir o nome da raça e a idade

33790
22:22:15,512 --> 22:22:17,600
então vai dizer que o esddc para fora nós somos

33791
22:22:17,600 --> 22:22:19,600
Vou dizer o endereço onde ponto

33792
22:22:19,600 --> 22:22:21,120
Folhas do objeto

33793
22:22:21,120 --> 22:22:23,280
Eu acho que isso é mais significativo nós somos

33794
22:22:23,280 --> 22:22:25,512
vamos dizer isso e então nós vamos

33795
22:22:25,512 --> 22:22:26,400
A sua forma de

33796
22:22:26,400 --> 22:22:28,552
Coloque um parêntese e diga o nome i

33797
22:22:28,552 --> 22:22:32,400
Acho que podemos colocar um suporte de ângulo aqui

33798
22:22:32,400 --> 22:22:34,800
e dizer nome e vamos dizer o

33799
22:22:34,800 --> 22:22:38,800
Cão nome que podemos descer e dizer a idade

33800
22:22:38,800 --> 22:22:41,120
ou a raça e dizer a idade e nós somos

33801
22:22:41,120 --> 22:22:43,440
vai desreferenciar o membro da idade

33802
22:22:43,440 --> 22:22:44,960
variável porque é um ponteiro que somos

33803
22:22:44,960 --> 22:22:47,920
vamos dizer a referência ph aqui e eu

33804
22:22:47,920 --> 22:22:50,160
Acho que vai ser isso agora que podemos

33805
22:22:50,160 --> 22:22:53,440
colocar uma nova linha personagem std e ndm e

33806
22:22:53,440 --> 22:22:56,480
Se nós descermos agora e dizer imprimíveis

33807
22:22:56,480 --> 22:22:58,640
Antes de definir o nome, vamos

33808
22:22:58,640 --> 22:22:59,760
Dizê

33809
22:22:59,760 --> 22:23:01,120
dub1 em Inglês

33810
22:23:01,120 --> 22:23:02,872
Impressão impressa, vamos imprimir o

33811
22:23:02,872 --> 22:23:05,600
informações sobre este cão e depois de

33812
22:23:05,600 --> 22:23:07,680
Coloque o nome do cão que vamos descer

33813
22:23:07,680 --> 22:23:10,160
e também dizer cão um princípio que você pode

33814
22:23:10,160 --> 22:23:12,000
jogar com essas coisas e eu realmente

33815
22:23:12,000 --> 22:23:14,080
Incentive você a fazer isso para que possamos

33816
22:23:14,080 --> 22:23:16,640
construir isso, vamos usar o gcc, então o

33817
22:23:16,640 --> 22:23:19,192
O mundo é bom que podemos limpar e correr

33818
22:23:19,192 --> 22:23:20,872
Galo isto vai dizer o

33819
22:23:20,872 --> 22:23:23,040
O construtor foi chamado para fofo no

33820
22:23:23,040 --> 22:23:24,552
Endereço dado

33821
22:23:24,552 --> 22:23:27,120
nós vamos dizer o cachorro que vamos

33822
22:23:27,120 --> 22:23:28,800
para imprimir a informação e nós vamos

33823
22:23:28,800 --> 22:23:31,920
para dizer que é um objeto de cão neste endereço

33824
22:23:31,920 --> 22:23:34,080
O nome é fofo e nós vamos

33825
22:23:34,080 --> 22:23:35,920
Impressear o cão pela segunda vez que você está

33826
22:23:35,920 --> 22:23:37,920
Vou ver que o nome ainda está

33827
22:23:37,920 --> 22:23:40,320
fofo e temos um problema aqui por que

33828
22:23:40,320 --> 22:23:41,360
que

33829
22:23:41,360 --> 22:23:44,720
por que nosso objeto não está sendo modificado

33830
22:23:44,720 --> 22:23:48,232
Vamos subir e ver o nosso nome de cão definido

33831
22:23:48,232 --> 22:23:50,640
Função aqui, então nós vamos

33832
22:23:50,640 --> 22:23:53,040
Remova isso e vamos usar o

33833
22:23:53,040 --> 22:23:55,360
Este ponteiro e nós vamos

33834
22:23:55,360 --> 22:23:58,232
soldar novamente e vamos limpar agora e correr

33835
22:23:58,232 --> 22:24:00,640
Galo e agora você vê que as mudanças

33836
22:24:00,640 --> 22:24:03,680
Na verdade, estão fazendo sentido, então o que é

33837
22:24:03,680 --> 22:24:06,872
acontecendo com a tarefa aqui o

33838
22:24:06,872 --> 22:24:09,600
O compilador está atribuindo o valor do

33839
22:24:09,600 --> 22:24:11,832
variável para a variável em si e isso

33840
22:24:11,832 --> 22:24:14,080
É realmente não fazer nada e não é

33841
22:24:14,080 --> 22:24:16,400
O que você espera eu fui enganado um pouco

33842
22:24:16,400 --> 22:24:18,400
pouco pelo compilador porque isso foi

33843
22:24:18,400 --> 22:24:20,800
compilando, mas não vai fazer o que

33844
22:24:20,800 --> 22:24:23,512
você quer quando você chamar set doug nome você

33845
22:24:23,512 --> 22:24:26,160
Provavelmente quer tomar este nome e

33846
22:24:26,160 --> 22:24:28,800
atribuir isso ao nome da variável membro

33847
22:24:28,800 --> 22:24:31,120
desta classe, mas não é isso que é

33848
22:24:31,120 --> 22:24:33,360
Vou fazer vamos construir de novo e realmente

33849
22:24:33,360 --> 22:24:34,800
mostrar-lhe isso

33850
22:24:34,800 --> 22:24:37,280
Então é um bom conselho para

33851
22:24:37,280 --> 22:24:39,192
praticar e realmente experimentar as coisas

33852
22:24:39,192 --> 22:24:41,192
Você mesmo vamos correr um galo

33853
22:24:41,192 --> 22:24:43,120
Você vai ver isso depois que nós definirmos

33854
22:24:43,120 --> 22:24:45,832
o nome do cão aqui para pumba e nós tentamos

33855
22:24:45,832 --> 22:24:47,680
para imprimir a informação da informação

33856
22:24:47,680 --> 22:24:49,600
Não vai acabar que o nome não é

33857
22:24:49,600 --> 22:24:51,680
Vai ser pumba para a segunda chamada

33858
22:24:51,680 --> 22:24:54,000
Aqui e o que isso realmente está fazendo é

33859
22:24:54,000 --> 22:24:56,080
Não fazer nada aqui não faz nada e

33860
22:24:56,080 --> 22:24:58,232
Você realmente precisa saber disso se quiser

33861
22:24:58,232 --> 22:24:59,600
para afetar

33862
22:24:59,600 --> 22:25:01,512
sua variável de lembrança que você terá que

33863
22:25:01,512 --> 22:25:03,120
passar por este ponteiro e este é

33864
22:25:03,120 --> 22:25:04,400
Vou contar

33865
22:25:04,400 --> 22:25:07,360
tomar o nome da variável membro de

33866
22:25:07,360 --> 22:25:10,160
O objeto atual e atribuir o valor

33867
22:25:10,160 --> 22:25:12,800
no nome do parâmetro para isso e

33868
22:25:12,800 --> 22:25:15,040
Isso vai definir o seu nome para

33869
22:25:15,040 --> 22:25:17,440
Seja qual for o novo nome que você passou quando

33870
22:25:17,440 --> 22:25:20,160
chamado de função de nome de cão conjunto aqui, então

33871
22:25:20,160 --> 22:25:22,160
Espero que você realmente entenda isso agora

33872
22:25:22,160 --> 22:25:23,920
Se nós dois vamos ver que

33873
22:25:23,920 --> 22:25:26,640
O nome da pumbaa foi aplicado vamos ferver

33874
22:25:26,640 --> 22:25:29,120
Mais uma vez, vamos limpar e correr

33875
22:25:29,120 --> 22:25:31,280
Galo e nós vamos ver agora que

33876
22:25:31,280 --> 22:25:33,760
O nome é pumba e há alguns

33877
22:25:33,760 --> 22:25:35,360
coisa irritante que temos em nosso

33878
22:25:35,360 --> 22:25:37,760
construtores, não temos espaço

33879
22:25:37,760 --> 22:25:40,800
Antes aqui e é realmente irritante

33880
22:25:40,800 --> 22:25:43,040
olhar para aqui, então vamos construir de novo e

33881
22:25:43,040 --> 22:25:45,280
corrigir isso, vamos usar gcc o

33882
22:25:45,280 --> 22:25:47,360
O mundo é bom que podemos limpar e correr

33883
22:25:47,360 --> 22:25:50,552
Galo e agora temos o que queremos, então

33884
22:25:50,552 --> 22:25:52,640
Este é o segundo caso de uso que você pode

33885
22:25:52,640 --> 22:25:55,832
ter para este ponteiro através setters

33886
22:25:55,832 --> 22:25:58,480
Vamos usar o parâmetro que é chamado

33887
22:25:58,480 --> 22:26:01,760
o mesmo que suas variáveis de membro, então

33888
22:26:01,760 --> 22:26:03,192
nós vamos montar todos os outros

33889
22:26:03,192 --> 22:26:05,040
setters nós vamos configurar um setter

33890
22:26:05,040 --> 22:26:07,600
para a raça vamos dizer std

33891
22:26:07,600 --> 22:26:10,480
visão de força e vai ser raça

33892
22:26:10,480 --> 22:26:12,800
Podemos fazer isso porque agora temos ferramentas

33893
22:26:12,800 --> 22:26:14,400
para realmente fazer isso corretamente, estamos indo

33894
22:26:14,400 --> 22:26:17,120
para dizer esta raça e nós vamos dizer

33895
22:26:17,120 --> 22:26:20,000
igual a ler isso vai fazer e nós

33896
22:26:20,000 --> 22:26:22,320
pode definir a idade e vamos dizer

33897
22:26:22,320 --> 22:26:24,232
void set idade

33898
22:26:24,232 --> 22:26:26,080
idade do cão e vamos passar em um

33899
22:26:26,080 --> 22:26:28,720
valor e nós vamos entrar no que

33900
22:26:28,720 --> 22:26:31,040
é chamado de que é chamado ph eu não

33901
22:26:31,040 --> 22:26:32,640
Acho que faz sentido chamar o

33902
22:26:32,640 --> 22:26:35,760
parâmetro ph porque não é um ponteiro

33903
22:26:35,760 --> 22:26:37,760
Então nós vamos entrar e apenas o

33904
22:26:37,760 --> 22:26:39,440
referência de um ponteiro, então vamos

33905
22:26:39,440 --> 22:26:40,960
desreferência que

33906
22:26:40,960 --> 22:26:43,360
e nós vamos dizer isso, então nós somos

33907
22:26:43,360 --> 22:26:46,720
indo para entrar e dizer esse ph

33908
22:26:46,720 --> 22:26:49,512
igual a h eu acho que isso vai funcionar

33909
22:26:49,512 --> 22:26:51,920
e precisamos fazer referência a este ponteiro

33910
22:26:51,920 --> 22:26:53,600
Porque o que temos como membro

33911
22:26:53,600 --> 22:26:55,680
variável é o ponteiro, então precisamos ir

33912
22:26:55,680 --> 22:26:57,920
através da sintaxe feia que você vê aqui e

33913
22:26:57,920 --> 22:26:59,760
Isso vai definir nossa idade para que possamos

33914
22:26:59,760 --> 22:27:01,360
passar por isso e realmente mudar o

33915
22:27:01,360 --> 22:27:03,440
informação para que vamos mudar o

33916
22:27:03,440 --> 22:27:06,800
raça aqui definido cão breed vamos descer

33917
22:27:06,800 --> 22:27:08,960
E escolher isso e vamos dizer

33918
22:27:08,960 --> 22:27:11,440
Wirex Terrier e nós vamos embora

33919
22:27:11,440 --> 22:27:13,440
para baixo e definir a idade que vamos dizer

33920
22:27:13,440 --> 22:27:16,720
culpa 1 set idade do cão e nós vamos

33921
22:27:16,720 --> 22:27:19,680
Por que não para que mudemos o

33922
22:27:19,680 --> 22:27:22,160
informações do nosso cão através do nosso

33923
22:27:22,160 --> 22:27:24,080
setters aqui e vamos imprimir

33924
22:27:24,080 --> 22:27:25,600
Nova informação

33925
22:27:25,600 --> 22:27:27,832
Vamos construir novamente nós vamos usar gcc

33926
22:27:27,832 --> 22:27:30,000
para que a construção seja boa, podemos limpar

33927
22:27:30,000 --> 22:27:32,400
e correr galo este vai dar-nos

33928
22:27:32,400 --> 22:27:34,480
Nova informação para a segunda impressão

33929
22:27:34,480 --> 22:27:37,192
aqui, então o nome vai ser da raça pumba

33930
22:27:37,192 --> 22:27:39,440
vai ser wirefox terrier e idade

33931
22:27:39,440 --> 22:27:41,040
serão quatro e nós temos o

33932
22:27:41,040 --> 22:27:43,920
informações para o nosso objeto de cão aqui ok

33933
22:27:43,920 --> 22:27:46,480
Agora temos isso e queremos ver como

33934
22:27:46,480 --> 22:27:48,960
Podemos configurar chamadas encadeadas

33935
22:27:48,960 --> 22:27:51,512
usando este ponteiro e neste caso

33936
22:27:51,512 --> 22:27:53,832
Vamos usar ponteiros, vamos mudar

33937
22:27:53,832 --> 22:27:56,640
nossos setters para retornar ponteiros de cachorro

33938
22:27:56,640 --> 22:27:58,800
Podemos fazer isso e nós vamos descer

33939
22:27:58,800 --> 22:28:00,400
para dizer à raça do cão que vamos

33940
22:28:00,400 --> 22:28:02,160
devolver o ponteiro do cão

33941
22:28:02,160 --> 22:28:04,872
e nós vamos para definir a idade do cão e

33942
22:28:04,872 --> 22:28:07,360
Vamos devolver um ponteiro de cachorro agora

33943
22:28:07,360 --> 22:28:09,512
Depois que fizermos isso, precisaremos voltar

33944
22:28:09,512 --> 22:28:11,120
Estes ponteiros e nós vamos embora

33945
22:28:11,120 --> 22:28:14,400
dentro e dizer voltar este lembre-se disso

33946
22:28:14,400 --> 22:28:16,480
Contém a memória da corrente

33947
22:28:16,480 --> 22:28:19,192
objeto para que possamos retornar isso e encaixar

33948
22:28:19,192 --> 22:28:21,832
que para um ponteiro retornado para que possamos ir

33949
22:28:21,832 --> 22:28:23,832
em todas as outras funções e

33950
22:28:23,832 --> 22:28:25,440
realmente salvar isso nós vamos dizer

33951
22:28:25,440 --> 22:28:28,160
Retornando assim retornamos o endereço de memória

33952
22:28:28,160 --> 22:28:30,160
do objeto atual

33953
22:28:30,160 --> 22:28:32,552
através dos setters que estamos fazendo

33954
22:28:32,552 --> 22:28:34,720
Aqui vamos devolver isso

33955
22:28:34,720 --> 22:28:38,000
E depois que fazemos isso, podemos mudar o

33956
22:28:38,000 --> 22:28:40,000
Estamos fazendo aqui para b1

33957
22:28:40,000 --> 22:28:42,720
declaração e podemos comentar isso I

33958
22:28:42,720 --> 22:28:44,400
Acho que podemos fazer isso e o que somos

33959
22:28:44,400 --> 22:28:47,360
Vou dizer que é dope um e nós vamos

33960
22:28:47,360 --> 22:28:48,320
para dizer

33961
22:28:48,320 --> 22:28:50,720
definir o nome do cão e vamos passar

33962
22:28:50,720 --> 22:28:53,192
pumba, mas isso vai voltar a

33963
22:28:53,192 --> 22:28:55,760
ponteiro agora set nome do cão está retornando a

33964
22:28:55,760 --> 22:28:58,232
ponteiro para o objeto atual e você

33965
22:28:58,232 --> 22:29:00,400
pode ver que aqui é isso que somos

33966
22:29:00,400 --> 22:29:02,640
Voltando para que possamos passar por isso

33967
22:29:02,640 --> 22:29:05,040
apontar e chamar algumas outras funções

33968
22:29:05,040 --> 22:29:08,000
por exemplo, podemos dizer definir dot raça

33969
22:29:08,000 --> 22:29:10,232
diretamente e o código do estúdio visual é

33970
22:29:10,232 --> 22:29:11,832
Vou descobrir o que somos

33971
22:29:11,832 --> 22:29:14,000
O retorno é um ponteiro e vai

33972
22:29:14,000 --> 22:29:16,960
Mudar a nossa notação de acesso aqui a

33973
22:29:16,960 --> 22:29:19,440
pontoer eixo notação e vamos

33974
22:29:19,440 --> 22:29:22,000
Use isso em uma única instrução assim

33975
22:29:22,000 --> 22:29:24,232
vamos colocar em nossa raça e

33976
22:29:24,232 --> 22:29:26,160
Vamos chamar a função a definir

33977
22:29:26,160 --> 22:29:28,480
A idade que você vê que usa

33978
22:29:28,480 --> 22:29:30,320
ponto de notação de acesso e isso é

33979
22:29:30,320 --> 22:29:32,000
muito legal, então nós vamos colocar em nosso

33980
22:29:32,000 --> 22:29:33,920
Quatro e você vai ver que isso

33981
22:29:33,920 --> 22:29:36,160
Na verdade, funciona e isso é muito legal

33982
22:29:36,160 --> 22:29:38,320
Se você não quer fazer graças em três

33983
22:29:38,320 --> 22:29:41,600
Passos que você pode dar aos seus usuários a opção

33984
22:29:41,600 --> 22:29:44,080
para fazer as coisas em um passo usando retornado

33985
22:29:44,080 --> 22:29:46,160
pontuadores como este e isso é realmente

33986
22:29:46,160 --> 22:29:48,320
legal eu uso isso o tempo todo para o meu

33987
22:29:48,320 --> 22:29:51,440
classes que eu desenho em minhas aplicações

33988
22:29:51,440 --> 22:29:54,160
então, se nós dois vamos ver isso

33989
22:29:54,160 --> 22:29:55,920
O mundo é bom e nós vamos

33990
22:29:55,920 --> 22:29:58,480
clear e run galo que vamos ver

33991
22:29:58,480 --> 22:30:01,512
que a informação é n nome é pumba

33992
22:30:01,512 --> 22:30:04,320
raça é waterfox terrier e a idade é

33993
22:30:04,320 --> 22:30:06,800
e fomos capazes de fazer tudo isso

33994
22:30:06,800 --> 22:30:09,920
mudanças em uma só go para que possamos até mudar

33995
22:30:09,920 --> 22:30:12,872
para usar referências aqui que estamos usando

33996
22:30:12,872 --> 22:30:15,192
dicas, então vamos dizer que estamos usando

33997
22:30:15,192 --> 22:30:17,440
ponteiros, mas também podemos usar referências

33998
22:30:17,440 --> 22:30:20,552
Vamos em cima aqui e dizer que isso

33999
22:30:20,552 --> 22:30:22,720
está usando ponteiros e nós vamos

34000
22:30:22,720 --> 22:30:24,800
comente isso, mas antes de fazer estamos

34001
22:30:24,800 --> 22:30:26,720
Vou copiar tudo isso porque nós somos

34002
22:30:26,720 --> 22:30:28,480
Vou precisar disso

34003
22:30:28,480 --> 22:30:29,920
E nós vamos para

34004
22:30:29,920 --> 22:30:31,600
Comentar tudo isso e nós vamos

34005
22:30:31,600 --> 22:30:34,080
descer e dizer mudanças de chamadas usando

34006
22:30:34,080 --> 22:30:36,080
referências e nós vamos descer

34007
22:30:36,080 --> 22:30:38,232
e colocar em nosso código e nós vamos

34008
22:30:38,232 --> 22:30:41,120
mudar nossos setters para retornar referências

34009
22:30:41,120 --> 22:30:43,512
Em vez de ponteiros, podemos fazer isso

34010
22:30:43,512 --> 22:30:45,600
Vamos mudar a estrela aqui para

34011
22:30:45,600 --> 22:30:48,080
um símbolo de ampersand aqui e isso é

34012
22:30:48,080 --> 22:30:50,232
Vou fazer a magia, então temos um cachorro

34013
22:30:50,232 --> 22:30:52,320
Referência retornada de todas essas

34014
22:30:52,320 --> 22:30:54,480
funciona assim porque não somos mais

34015
22:30:54,480 --> 22:30:56,640
retornando um ponteiro retornando isso

34016
22:30:56,640 --> 22:30:58,552
diretamente vai nos dar um compilador

34017
22:30:58,552 --> 22:31:00,872
erro que precisamos desreferenciar isso

34018
22:31:00,872 --> 22:31:03,360
ponteiro e chegar ao que está apontado

34019
22:31:03,360 --> 22:31:05,760
para agora o compilador saberá que nós

34020
22:31:05,760 --> 22:31:08,160
estão retornando uma referência ao atual

34021
22:31:08,160 --> 22:31:10,480
objeto e esta é a sintaxe que podemos usar

34022
22:31:10,480 --> 22:31:13,360
para fazer isso vamos descer e desreferência

34023
22:31:13,360 --> 22:31:16,232
todos os ponteiros retornados e se formos

34024
22:31:16,232 --> 22:31:17,760
Vamos ver que isto é

34025
22:31:17,760 --> 22:31:20,320
Bom já e podemos descer e definir

34026
22:31:20,320 --> 22:31:23,120
up nossa chamada acorrentada usando referências e

34027
22:31:23,120 --> 22:31:25,192
nós vamos descer e dizer cão um

34028
22:31:25,192 --> 22:31:27,760
Vamos definir o nome do cão e nós somos

34029
22:31:27,760 --> 22:31:29,760
Vou passar em pumba

34030
22:31:29,760 --> 22:31:31,512
O que temos feito o tempo todo agora

34031
22:31:31,512 --> 22:31:33,120
Vamos usar o acesso dot

34032
22:31:33,120 --> 22:31:36,320
notação porque o que estamos voltando

34033
22:31:36,320 --> 22:31:38,872
É uma referência e você vai ver

34034
22:31:38,872 --> 22:31:40,720
esse código visual do estúdio vai escolher

34035
22:31:40,720 --> 22:31:43,832
esta até a raça vai ser wirefox

34036
22:31:43,832 --> 22:31:46,960
e nós vamos dizer definir a idade do cão e

34037
22:31:46,960 --> 22:31:49,440
Vamos passar nos nossos quatro e

34038
22:31:49,440 --> 22:31:51,512
você vai ver que isso é válido c

34039
22:31:51,512 --> 22:31:53,600
mais sintaxe e se imprimirmos o

34040
22:31:53,600 --> 22:31:55,192
informações que vamos ter novos

34041
22:31:55,192 --> 22:31:58,640
informação aplicada ao nosso objeto de cão

34042
22:31:58,640 --> 22:32:00,960
Aqui podemos soldar e ver que este é

34043
22:32:00,960 --> 22:32:02,720
Na verdade, trabalhar você vê que o mundo é

34044
22:32:02,720 --> 22:32:05,440
Bom podemos limpar e correr galo e

34045
22:32:05,440 --> 22:32:07,280
nós vamos ver que a informação tem

34046
22:32:07,280 --> 22:32:10,960
foram aplicados ao nosso objeto de cão para que estes

34047
22:32:10,960 --> 22:32:12,400
São alguns exemplos

34048
22:32:12,400 --> 22:32:14,720
mostrando um pouco da utilidade para o

34049
22:32:14,720 --> 22:32:16,552
Este ponteiro vimos que podemos

34050
22:32:16,552 --> 22:32:18,960
Use este ponteiro para imprimir a memória

34051
22:32:18,960 --> 22:32:21,760
endereço do objeto atual se formos

34052
22:32:21,760 --> 22:32:24,552
para baixo e olhar para o nosso construtor e

34053
22:32:24,552 --> 22:32:26,872
Destructor estamos a imprimir o endereço

34054
22:32:26,872 --> 22:32:29,512
do objeto atual em nossa depuração

34055
22:32:29,512 --> 22:32:31,360
declaração aqui e isso é muito legal

34056
22:32:31,360 --> 22:32:33,440
podemos usar este ponteiro para resolver

34057
22:32:33,440 --> 22:32:35,920
conflitos em nossos setters, por exemplo,

34058
22:32:35,920 --> 22:32:38,232
pode usar um parâmetro que tem o mesmo

34059
22:32:38,232 --> 22:32:40,720
nome como a variável membro e não é

34060
22:32:40,720 --> 22:32:43,192
Vai ser realmente confuso e levar a

34061
22:32:43,192 --> 22:32:45,600
maus resultados, vai mudar o

34062
22:32:45,600 --> 22:32:48,320
variável de membro real e alterá-la para

34063
22:32:48,320 --> 22:32:50,080
O que quer que você passe como parâmetro e

34064
22:32:50,080 --> 22:32:52,320
isso é muito legal, também podemos usar o

34065
22:32:52,320 --> 22:32:55,040
este ponteiro para configurar chamadas de mudança para

34066
22:32:55,040 --> 22:32:56,872
nossa função e vimos que

34067
22:32:56,872 --> 22:32:58,800
pode fazer isso através do retorno

34068
22:32:58,800 --> 22:33:00,872
dicas como estamos fazendo aqui e

34069
22:33:00,872 --> 22:33:03,760
usando este ponteiro como um retorno

34070
22:33:03,760 --> 22:33:06,720
objeto para nossa função aqui ou nós podemos

34071
22:33:06,720 --> 22:33:09,512
usar retornando ponteiros para fazer isso e se

34072
22:33:09,512 --> 22:33:11,440
Fazemos que seremos capazes de

34073
22:33:11,440 --> 22:33:14,320
chamar nossas funções em uma só vez como nós somos

34074
22:33:14,320 --> 22:33:17,280
fazer aqui usando ponteiros ou fazer o mesmo

34075
22:33:17,280 --> 22:33:20,232
A coisa usando referências como estamos fazendo

34076
22:33:20,232 --> 22:33:22,872
Aqui, isso é realmente tudo o que nos demos

34077
22:33:22,872 --> 22:33:24,480
Nesta palestra espero que você a tenha encontrado

34078
22:33:24,480 --> 22:33:26,720
interessante, vamos parar por aqui

34079
22:33:26,720 --> 22:33:28,400
Este o próximo vamos

34080
22:33:28,400 --> 22:33:31,040
Aprenda sobre a struct vá em frente e termine

34081
22:33:31,040 --> 22:33:33,280
Aqui e me encontre lá nisso

34082
22:33:33,280 --> 22:33:35,192
palestra que vamos aprender sobre

34083
22:33:35,192 --> 22:33:37,360
struct palavra-chave e este é outro

34084
22:33:37,360 --> 22:33:40,160
sintaxe que você pode usar para criar classes em

34085
22:33:40,160 --> 22:33:42,640
seu c plus programa que vimos

34086
22:33:42,640 --> 22:33:44,552
que já podemos usar a classe

34087
22:33:44,552 --> 22:33:47,360
palavra-chave para criar nossas classes que eu tenho que

34088
22:33:47,360 --> 22:33:49,280
quebre para você que também podemos usar

34089
22:33:49,280 --> 22:33:51,920
se strute para fazer o mesmo, então a sintaxe aqui

34090
22:33:51,920 --> 22:33:54,232
Vai criar uma classe chamada gato

34091
22:33:54,232 --> 22:33:56,080
e vai ter uma variável de membro

34092
22:33:56,080 --> 22:33:58,320
Chamado string name the difference

34093
22:33:58,320 --> 22:34:01,600
entre a estrutura e a classe é que para

34094
22:34:01,600 --> 22:34:04,720
As classes serão privadas

34095
22:34:04,720 --> 22:34:07,192
por padrão e quando você faz algo

34096
22:34:07,192 --> 22:34:09,680
assim e criar objetos de classe você

34097
22:34:09,680 --> 22:34:11,680
Quer poder acessar o nome aqui

34098
22:34:11,680 --> 22:34:13,680
diretamente, por exemplo, do principal

34099
22:34:13,680 --> 22:34:15,512
Função se você fizer isso, você vai

34100
22:34:15,512 --> 22:34:17,920
obter um erro do compilador porque classe

34101
22:34:17,920 --> 22:34:21,040
Os membros são privados por padrão, mas se

34102
22:34:21,040 --> 22:34:23,600
Você usa membros da estrutura que serão

34103
22:34:23,600 --> 22:34:26,000
público por padrão e você terá

34104
22:34:26,000 --> 22:34:28,872
acesso direto do exterior é

34105
22:34:28,872 --> 22:34:31,120
A única diferença entre classe e

34106
22:34:31,120 --> 22:34:33,280
estrutura de outra forma, você pode usá-los

34107
22:34:33,280 --> 22:34:35,440
de forma intercambiável e eles vão fazer

34108
22:34:35,440 --> 22:34:37,360
As mesmas coisas que temos visto para

34109
22:34:37,360 --> 22:34:39,512
Classes são realmente as mesmas coisas

34110
22:34:39,512 --> 22:34:41,512
A única diferença é que as classes são

34111
22:34:41,512 --> 22:34:43,512
ter variáveis de membros privados

34112
22:34:43,512 --> 22:34:46,640
por padrão e a estrutura terá público

34113
22:34:46,640 --> 22:34:49,512
variáveis de membro por padrão, mas nós podemos

34114
22:34:49,512 --> 22:34:51,832
mudar esses padrões colocando em nosso

34115
22:34:51,832 --> 22:34:54,800
seções públicas e privadas próprias dentro

34116
22:34:54,800 --> 22:34:57,192
nossa classe, por exemplo, aqui você vê

34117
22:34:57,192 --> 22:34:59,440
que mudamos nossa classe de cães para

34118
22:34:59,440 --> 22:35:01,600
ter uma variável de membro público através de

34119
22:35:01,600 --> 22:35:04,160
a palavra-chave pública aqui e podemos fazer

34120
22:35:04,160 --> 22:35:06,160
o mesmo para o gato, por exemplo, podemos colocar

34121
22:35:06,160 --> 22:35:08,232
em uma seção pública e um privado

34122
22:35:08,232 --> 22:35:10,232
seção e vai se comportar como

34123
22:35:10,232 --> 22:35:12,800
classes que temos sido soldando até agora

34124
22:35:12,800 --> 22:35:15,360
Um uso comum que temos para a estrutura é

34125
22:35:15,360 --> 22:35:19,120
quando temos que criar aulas que só

34126
22:35:19,120 --> 22:35:21,760
ter variáveis de membros públicos, por exemplo

34127
22:35:21,760 --> 22:35:24,232
você pode precisar configurar um ponto

34128
22:35:24,232 --> 22:35:26,960
modelo em seu programa c plus plus e

34129
22:35:26,960 --> 22:35:28,720
você pode configurar uma classe como esta que você pode

34130
22:35:28,720 --> 22:35:30,800
Diga ponto de estrutura que você vai colocar

34131
22:35:30,800 --> 22:35:32,720
as variáveis do membro e elas estão indo

34132
22:35:32,720 --> 22:35:34,720
para ser diretamente acessível a partir do

34133
22:35:34,720 --> 22:35:36,720
Fora e isso é algo que você vai

34134
22:35:36,720 --> 22:35:39,600
veja muito lá fora, então isso é realmente

34135
22:35:39,600 --> 22:35:41,680
Tudo sobre a estrutura nós vamos cabeça

34136
22:35:41,680 --> 22:35:43,680
sobre o código do estúdio visual e jogar com

34137
22:35:43,680 --> 22:35:46,480
nós um pouco mais bem aqui estamos em nosso

34138
22:35:46,480 --> 22:35:48,800
pasta de trabalho o projeto atual é

34139
22:35:48,800 --> 22:35:51,360
Estruct vamos pegar nosso template

34140
22:35:51,360 --> 22:35:53,192
Arquivos e nós vamos colocá-los dentro

34141
22:35:53,192 --> 22:35:56,480
place estrutura que é tudo projeto aqui

34142
22:35:56,480 --> 22:35:58,552
e nós vamos abrir isso em visual

34143
22:35:58,552 --> 22:36:00,160
código de estúdio

34144
22:36:00,160 --> 22:36:02,232
Vamos pegar extrair e arrastar e soltar

34145
22:36:02,232 --> 22:36:04,232
topo de código de estúdio visual aqui este é

34146
22:36:04,232 --> 22:36:07,192
vamos abrir nossa pasta, agora podemos abrir

34147
22:36:07,192 --> 22:36:09,920
O arquivo cpp principal e limpar as coisas um

34148
22:36:09,920 --> 22:36:11,680
Um pouco bem, então vamos montar

34149
22:36:11,680 --> 22:36:13,920
Uma classe simples chamada cão que vamos

34150
22:36:13,920 --> 22:36:16,480
Diga cão de classe e dentro vamos

34151
22:36:16,480 --> 22:36:18,800
ter uma variável membro chamada nome que é

34152
22:36:18,800 --> 22:36:21,192
vai ser um std strand, digamos, cão

34153
22:36:21,192 --> 22:36:23,680
nome ou nome m para significar que é um

34154
22:36:23,680 --> 22:36:25,680
uma variável de membro esta é uma sintaxe que você

34155
22:36:25,680 --> 22:36:28,400
vai ver muito em c plus plus lá fora

34156
22:36:28,400 --> 22:36:30,552
então vamos usar isso a partir de agora, estamos

34157
22:36:30,552 --> 22:36:33,280
vamos dizer o nome e nós vamos

34158
22:36:33,280 --> 22:36:36,080
Tenho outra classe vamos colocar o nosso

34159
22:36:36,080 --> 22:36:38,320
ponto e vírgula, vamos usar a estrutura para

34160
22:36:38,320 --> 22:36:40,552
Crie outro e vai ser

34161
22:36:40,552 --> 22:36:43,040
chamado cão, vamos chamar isso de gato e nós

34162
22:36:43,040 --> 22:36:44,960
eles vão entrar e configurar o nosso

34163
22:36:44,960 --> 22:36:46,800
membro variável vamos dizer std

34164
22:36:46,800 --> 22:36:48,960
força m nome e não vai

34165
22:36:48,960 --> 22:36:51,680
ter qualquer coisa m assim como se criarmos objetos

34166
22:36:51,680 --> 22:36:54,640
dessas classes e tentar acessá-las

34167
22:36:54,640 --> 22:36:56,872
nós vamos ver o fundamental

34168
22:36:56,872 --> 22:36:59,040
Diferença entre estrutura e cão

34169
22:36:59,040 --> 22:37:00,720
Vamos criar um cão e nós vamos

34170
22:37:00,720 --> 22:37:03,040
Diga cão um e nós vamos criar um

34171
22:37:03,040 --> 22:37:05,192
gato e nós vamos dizer gato um e

34172
22:37:05,192 --> 22:37:08,872
Se fizermos o cão 1 e tentarmos aceder ao m

34173
22:37:08,872 --> 22:37:10,872
nome membro variável

34174
22:37:10,872 --> 22:37:13,192
Talvez definir para outra coisa, digamos

34175
22:37:13,192 --> 22:37:15,120
fofo que vamos ter um compilador

34176
22:37:15,120 --> 22:37:18,320
Porque os membros de uma classe são

34177
22:37:18,320 --> 22:37:20,480
privado por padrão e não podemos realmente

34178
22:37:20,480 --> 22:37:21,600
Faz isto

34179
22:37:21,600 --> 22:37:23,440
Estamos tentando acessar algo

34180
22:37:23,440 --> 22:37:25,600
que é privado de fora, nós somos

34181
22:37:25,600 --> 22:37:27,440
Vou ter um erro do compilador bem, então nós

34182
22:37:27,440 --> 22:37:29,680
Tenho uma linha aqui, mas se tentarmos

34183
22:37:29,680 --> 22:37:31,920
para fazer o mesmo para um gato que vai

34184
22:37:31,920 --> 22:37:34,320
passar porque o gato é destruido e

34185
22:37:34,320 --> 22:37:37,760
Os membros das structs são públicos por padrão

34186
22:37:37,760 --> 22:37:39,440
Vamos fazer isso e realmente mostrar isso

34187
22:37:39,440 --> 22:37:41,920
nós vamos dizer gato1 e nós vamos

34188
22:37:41,920 --> 22:37:44,160
para dizer m nome e vamos dar

34189
22:37:44,160 --> 22:37:47,440
um nome e vamos dizer johnny eu estou fazendo

34190
22:37:47,440 --> 22:37:49,600
Isso para cima eu não sei se há algum gato

34191
22:37:49,600 --> 22:37:51,760
chamado johnny, mas vamos usar isso

34192
22:37:51,760 --> 22:37:53,280
e você vai ver que nós não

34193
22:37:53,280 --> 22:37:55,600
Tenho alguma linha aquilenta que vamos

34194
22:37:55,600 --> 22:37:58,080
construir e ver se gcc vai tomar

34195
22:37:58,080 --> 22:37:59,920
Isso vai levá-lo o mundo é

34196
22:37:59,920 --> 22:38:02,720
Bom podemos trazer um terminal e correr

34197
22:38:02,720 --> 22:38:04,800
O programa e nós não vamos ver

34198
22:38:04,800 --> 22:38:06,552
Qualquer coisa porque não estamos imprimindo

34199
22:38:06,552 --> 22:38:09,120
qualquer coisa da função principal aqui, mas

34200
22:38:09,120 --> 22:38:11,832
se quisermos podemos imprimir este nome do nosso

34201
22:38:11,832 --> 22:38:15,040
gato, nós vamos dizer sddc para fora e dizer

34202
22:38:15,040 --> 22:38:17,600
gato um nome e se construir estamos indo

34203
22:38:17,600 --> 22:38:20,480
para ver isso para que ambos sejam bons

34204
22:38:20,480 --> 22:38:23,512
É bom que possamos limpar e correr o galo

34205
22:38:23,512 --> 22:38:25,440
e nós temos o johnny impresso e isso

34206
22:38:25,440 --> 22:38:27,192
é o nome de volca e isso é realmente

34207
22:38:27,192 --> 22:38:29,920
a diferença entre classe e strut

34208
22:38:29,920 --> 22:38:32,000
Os membros das aulas vão ser

34209
22:38:32,000 --> 22:38:34,480
privado por padrão os membros da estrutura são

34210
22:38:34,480 --> 22:38:36,872
vai ser público por padrão, mas podemos

34211
22:38:36,872 --> 22:38:38,872
alterar esses padrões, por exemplo, vamos

34212
22:38:38,872 --> 22:38:41,360
tornar tudo o que podemos fazer que não

34213
22:38:41,360 --> 22:38:42,800
Um grande negócio aqui

34214
22:38:42,800 --> 22:38:45,680
e nós podemos mover isso um pouco para o

34215
22:38:45,680 --> 22:38:48,800
para que as coisas estejam alinhadas bem

34216
22:38:48,800 --> 22:38:51,600
e nós podemos fazer o mesmo para estruturar bem

34217
22:38:51,600 --> 22:38:54,800
então vamos alinhar isso agora se fizermos isso nós

34218
22:38:54,800 --> 22:38:56,872
será capaz de ir na função principal

34219
22:38:56,872 --> 22:38:58,800
e dizer o nome do cão e mudar isso e

34220
22:38:58,800 --> 22:39:00,480
nós vamos ser capazes de ver isso se nós

34221
22:39:00,480 --> 22:39:03,832
imprimir isso para fora, então vamos descer e dizer

34222
22:39:03,832 --> 22:39:08,000
stdc para fora e dizer cão1 nome e impressão

34223
22:39:08,000 --> 22:39:09,360
Isso para fora

34224
22:39:09,360 --> 22:39:11,120
E se construirmos agora, vamos ver

34225
22:39:11,120 --> 22:39:13,512
o nome do nosso cão impresso bem

34226
22:39:13,512 --> 22:39:15,440
Bem, isso é bom, podemos trazer isso

34227
22:39:15,440 --> 22:39:18,320
e limpar um pouco e correr galo

34228
22:39:18,320 --> 22:39:20,232
nós vamos ver fofo o nosso nome de cão

34229
22:39:20,232 --> 22:39:22,960
e johnny nosso nome de gato, então este é

34230
22:39:22,960 --> 22:39:25,832
Realmente tudo sobre classes e estruturar eles

34231
22:39:25,832 --> 22:39:27,760
São as mesmas coisas, mas a única

34232
22:39:27,760 --> 22:39:29,512
A diferença é o padrão que vem

34233
22:39:29,512 --> 22:39:31,832
com essas coisas, mas no uso comum

34234
22:39:31,832 --> 22:39:34,800
ter para a estrutura é quando queremos definir

34235
22:39:34,800 --> 22:39:37,832
uma classe que só tem um membro direto

34236
22:39:37,832 --> 22:39:40,320
variáveis e não pretendemos colocar

34237
22:39:40,320 --> 22:39:43,040
métodos nessa classe um bom exemplo

34238
22:39:43,040 --> 22:39:45,280
Isto é o ponto fora da estrutura, então

34239
22:39:45,280 --> 22:39:47,760
Supor que queremos modelar pontos em nosso c

34240
22:39:47,760 --> 22:39:50,080
mais e programa para que possamos fazer algo

34241
22:39:50,080 --> 22:39:52,232
assim e um ponto vai ter

34242
22:39:52,232 --> 22:39:55,040
duas coordenadas x e y nós vamos

34243
22:39:55,040 --> 22:39:57,832
dizer duplo y e a partir deste ponto em diante

34244
22:39:57,832 --> 22:39:59,920
será capaz de criar objetos pontuais e

34245
22:39:59,920 --> 22:40:02,320
imprima-os como quisermos, pois

34246
22:40:02,320 --> 22:40:04,800
Um exemplo, podemos descer e dizer ponto

34247
22:40:04,800 --> 22:40:07,600
Ponto um e a partir deste ponto podemos ir

34248
22:40:07,600 --> 22:40:11,040
e dizer 0,1 e dizer x e atribuir um

34249
22:40:11,040 --> 22:40:13,360
valor para x vamos colocar em um 10 e nós somos

34250
22:40:13,360 --> 22:40:17,040
indo para baixo e dizer ponto 1 y e

34251
22:40:17,040 --> 22:40:18,720
nós vamos dar um valor vamos colocar

34252
22:40:18,720 --> 22:40:19,480
Os de que a si a si a do que sobre a, a , a , a , aja, a , a, a, a

34253
22:40:19,480 --> 22:40:22,232
555.5 Por que não e podemos fazer tudo o que nós

34254
22:40:22,232 --> 22:40:24,232
Queremos com este ponto, por exemplo, podemos

34255
22:40:24,232 --> 22:40:25,760
configurar uma função que vai

34256
22:40:25,760 --> 22:40:28,232
imprimir um ponto que podemos fazer isso, digamos

34257
22:40:28,232 --> 22:40:30,720
Ponto de impressão vazio e vamos passar

34258
22:40:30,720 --> 22:40:33,192
o ponto por valor ou podemos até usar

34259
22:40:33,192 --> 22:40:35,040
Referências porque isso vai ser

34260
22:40:35,040 --> 22:40:37,600
um objeto const ponto referência i think

34261
22:40:37,600 --> 22:40:39,280
Isto vai fazer e nós vamos

34262
22:40:39,280 --> 22:40:41,760
entrar e imprimir a informação

34263
22:40:41,760 --> 22:40:43,040
nós vamos dizer

34264
22:40:43,040 --> 22:40:45,600
hddc out point e nós vamos colocar

34265
22:40:45,600 --> 22:40:48,232
as coordenadas em que vamos dizer x

34266
22:40:48,232 --> 22:40:51,760
vai ser o ponto x e y vai

34267
22:40:51,760 --> 22:40:54,480
ser o ponto e por que não e nós vamos

34268
22:40:54,480 --> 22:40:57,120
colocar em nosso colchete de fechamento e

34269
22:40:57,120 --> 22:40:59,440
nós vamos dizer stdndl

34270
22:40:59,440 --> 22:41:02,080
para colocar um novo personagem de linha após o nosso

34271
22:41:02,080 --> 22:41:04,552
imprimir aqui agora podemos descer e dizer

34272
22:41:04,552 --> 22:41:07,680
imprimir o ponto e passar no ponto um

34273
22:41:07,680 --> 22:41:10,080
E se fizermos isso, vamos construir

34274
22:41:10,080 --> 22:41:11,760
E nós vamos fazer isso através do gcc

34275
22:41:11,760 --> 22:41:14,480
Você vê que os dois estão bem agora se imprimirmos

34276
22:41:14,480 --> 22:41:16,800
Devemos ver as informações sobre o nosso

34277
22:41:16,800 --> 22:41:19,480
Ponto e vemos o ponto x 1 y

34278
22:41:19,480 --> 22:41:21,192
55.5

34279
22:41:21,192 --> 22:41:22,400
E nós vemos

34280
22:41:22,400 --> 22:41:26,640
O ponto x é 10 y é 55.5

34281
22:41:26,640 --> 22:41:28,400
Podemos descer e mudar o

34282
22:41:28,400 --> 22:41:30,160
Informações sobre o nosso ponto, por exemplo

34283
22:41:30,160 --> 22:41:33,440
Podemos copiar isso e descer e mudar

34284
22:41:33,440 --> 22:41:35,720
x para

34285
22:41:35,720 --> 22:41:37,440
4,4

34286
22:41:37,440 --> 22:41:39,872
E y para

34287
22:41:39,872 --> 22:41:42,800
2.7 por que não e se imprimimos o

34288
22:41:42,800 --> 22:41:44,552
informações sobre o nosso ponto em que vamos

34289
22:41:44,552 --> 22:41:46,480
para ver que temos novas informações e

34290
22:41:46,480 --> 22:41:48,480
Vamos imprimir o ponto um e

34291
22:41:48,480 --> 22:41:50,000
Portanto, o mundo vamos ver o

34292
22:41:50,000 --> 22:41:52,320
novas informações para que a construção seja boa

34293
22:41:52,320 --> 22:41:55,120
pode limpar e correr galo agora você vê

34294
22:41:55,120 --> 22:41:57,120
novas informações em nosso ponto, então isso é

34295
22:41:57,120 --> 22:41:59,120
A diferença entre classe e

34296
22:41:59,120 --> 22:42:01,192
Estrute a única diferença vai

34297
22:42:01,192 --> 22:42:03,920
estar nos padrões e a estrutura é principalmente

34298
22:42:03,920 --> 22:42:07,040
útil se você quiser criar aulas

34299
22:42:07,040 --> 22:42:09,920
que só têm variáveis de membros públicos

34300
22:42:09,920 --> 22:42:12,232
E você realmente não quer usar

34301
22:42:12,232 --> 22:42:14,960
funções ou métodos nessa classe e

34302
22:42:14,960 --> 22:42:17,280
Temos um exemplo disso aqui e se

34303
22:42:17,280 --> 22:42:19,360
você tem um caso como esse você vai usar

34304
22:42:19,360 --> 22:42:21,120
Estrute seu código vai ser muito

34305
22:42:21,120 --> 22:42:24,160
É mais fácil ler e entender a partir do

34306
22:42:24,160 --> 22:42:26,480
perspectiva de outros c plus plus

34307
22:42:26,480 --> 22:42:29,040
desenvolvedores, vamos parar por aqui

34308
22:42:29,040 --> 22:42:30,640
Esta palestra e a última que somos

34309
22:42:30,640 --> 22:42:34,000
Vou aprender sobre o tamanho dos objetos

34310
22:42:34,000 --> 22:42:36,400
Vá em frente e termine aqui e me encontre

34311
22:42:36,400 --> 22:42:37,440
lá

34312
22:42:37,440 --> 22:42:38,872
Nesta palestra vamos aprender

34313
22:42:38,872 --> 22:42:42,552
tamanhos de objetos de classe e tentar

34314
22:42:42,552 --> 22:42:43,920
Pense nisso

34315
22:42:43,920 --> 22:42:46,552
O que vamos ver se tentarmos

34316
22:42:46,552 --> 22:42:49,440
imprimir o tamanho da nossa classe aqui chamado

34317
22:42:49,440 --> 22:42:51,920
wrapper dentro temos dois membros

34318
22:42:51,920 --> 22:42:54,640
variáveis que são e tipo

34319
22:42:54,640 --> 22:42:56,480
e nós temos uma variável membro que é

34320
22:42:56,480 --> 22:43:00,000
de std string tipo o que você pensa

34321
22:43:00,000 --> 22:43:01,360
Nós vamos ver

34322
22:43:01,360 --> 22:43:04,000
quando imprimimos o tamanho deste invólucro

34323
22:43:04,000 --> 22:43:05,832
O objeto aqui

34324
22:43:05,832 --> 22:43:08,160
Tente pensar nisso para que c plus

34325
22:43:08,160 --> 22:43:11,120
Além disso, ele só vai explicar

34326
22:43:11,120 --> 22:43:13,760
tamanho das variáveis do seu membro, então

34327
22:43:13,760 --> 22:43:15,760
ele vai adicionar aos tamanhos destes

34328
22:43:15,760 --> 22:43:17,512
Caras na memória para que saibamos que um fim é

34329
22:43:17,512 --> 22:43:19,600
Vou levar quatro bytes na memória, então

34330
22:43:19,600 --> 22:43:21,440
nós vamos ter oito bytes para

34331
22:43:21,440 --> 22:43:23,760
Estas duas formigas e nós vamos ter

34332
22:43:23,760 --> 22:43:26,160
uma quantidade não especificada de memória para

34333
22:43:26,160 --> 22:43:28,480
força porque uma força é

34334
22:43:28,480 --> 22:43:32,000
implementado internamente como classe e

34335
22:43:32,000 --> 22:43:35,440
armazena seus dados como ponteiros de carro de custo

34336
22:43:35,440 --> 22:43:37,512
Temos realmente um ponteiro

34337
22:43:37,512 --> 22:43:41,440
e o tamanho de um objeto não

34338
22:43:41,440 --> 22:43:43,920
graças a que você está se referindo

34339
22:43:43,920 --> 22:43:46,400
Usando ponteiros pode contar com o tamanho

34340
22:43:46,400 --> 22:43:48,800
do próprio ponteiro, mas não está indo

34341
22:43:48,800 --> 22:43:51,512
para contar o que é apontado e no

34342
22:43:51,512 --> 22:43:53,280
caso de string, por exemplo, nós realmente

34343
22:43:53,280 --> 22:43:54,640
Quer saber

34344
22:43:54,640 --> 22:43:57,040
A gama de coisas que estamos apontando

34345
22:43:57,040 --> 22:43:58,872
Para que não tenhamos razão

34346
22:43:58,872 --> 22:44:01,832
informação com hdd string aqui, mas em

34347
22:44:01,832 --> 22:44:04,400
Geral, o tamanho de um objeto está indo

34348
22:44:04,400 --> 22:44:07,360
ser a soma dos tamanhos de seu membro

34349
22:44:07,360 --> 22:44:09,512
variáveis que as funções não vão

34350
22:44:09,512 --> 22:44:11,832
ser contado, então as funções são apenas

34351
22:44:11,832 --> 22:44:14,160
funções auxiliares que vivem em algum lugar

34352
22:44:14,160 --> 22:44:16,080
memória, mas eles não vão ser

34353
22:44:16,080 --> 22:44:19,120
contabilizado no tamanho do seu objeto

34354
22:44:19,120 --> 22:44:21,360
Outra razão pela qual você pode pensar funções

34355
22:44:21,360 --> 22:44:23,832
não são contabilizados no tamanho do

34356
22:44:23,832 --> 22:44:26,232
Objeto é que realmente funções são

34357
22:44:26,232 --> 22:44:29,040
afiliados à própria classe

34358
22:44:29,040 --> 22:44:31,680
As funções não são afiliadas à classe

34359
22:44:31,680 --> 22:44:33,760
Objetos que a classe vai ser o

34360
22:44:33,760 --> 22:44:35,360
Projeto do qual vamos

34361
22:44:35,360 --> 22:44:38,000
gerar milhares de objetos, se quisermos

34362
22:44:38,000 --> 22:44:39,920
Mas as funções ou os métodos são

34363
22:44:39,920 --> 22:44:42,640
Será associado ao projeto

34364
22:44:42,640 --> 22:44:45,120
em si, então realmente não faria sentido

34365
22:44:45,120 --> 22:44:47,680
associar o tamanho dessas funções

34366
22:44:47,680 --> 22:44:51,120
na memória de objetos de classe agora que você

34367
22:44:51,120 --> 22:44:53,440
Tenho essa ideia, vamos ir para o visual

34368
22:44:53,440 --> 22:44:54,960
código de estúdio e jogar com isso um pouco

34369
22:44:54,960 --> 22:44:57,512
Ok, economizamos que o tamanho é

34370
22:44:57,512 --> 22:44:59,512
principalmente vai ser a soma dos tamanhos

34371
22:44:59,512 --> 22:45:01,920
para as variáveis do membro, mas isso não é

34372
22:45:01,920 --> 22:45:04,720
Sempre correto por causa de um fenômeno

34373
22:45:04,720 --> 22:45:05,760
nós chamamos

34374
22:45:05,760 --> 22:45:07,920
alinhamento de limites

34375
22:45:07,920 --> 22:45:10,400
O alinhamento binário é uma coisa mais

34376
22:45:10,400 --> 22:45:13,120
Os compiladores fazem quando têm um membro

34377
22:45:13,120 --> 22:45:16,000
variáveis de diferentes tipos e membros

34378
22:45:16,000 --> 22:45:18,552
variáveis que têm o tamanho de quatro

34379
22:45:18,552 --> 22:45:20,720
bytes na memória serão armazenados

34380
22:45:20,720 --> 22:45:23,600
em locais de memória que são múltiplos

34381
22:45:23,600 --> 22:45:26,480
de quatro e por causa desse fenômeno

34382
22:45:26,480 --> 22:45:29,760
Podemos ter lacunas entre nossa memória se

34383
22:45:29,760 --> 22:45:32,000
Temos, por exemplo, variáveis que

34384
22:45:32,000 --> 22:45:34,640
de dois bytes na memória e quatro bytes em

34385
22:45:34,640 --> 22:45:36,800
memória e nós vamos ter lacunas

34386
22:45:36,800 --> 22:45:39,680
dentro e o tamanho do objeto é

34387
22:45:39,680 --> 22:45:42,232
Será um pouco fora da soma que nós

34388
22:45:42,232 --> 22:45:44,800
pode fazer para os tamanhos do nosso objeto i

34389
22:45:44,800 --> 22:45:46,960
Perceba que isso pode ser confuso que somos

34390
22:45:46,960 --> 22:45:48,960
indo para a cabeça para o código de estúdio visual

34391
22:45:48,960 --> 22:45:50,720
e vamos ver alguns exemplos

34392
22:45:50,720 --> 22:45:53,360
Tudo bem aqui estamos em nossa pasta de trabalho

34393
22:45:53,360 --> 22:45:56,000
O projeto atual é o tamanho da classe

34394
22:45:56,000 --> 22:45:58,720
Objetos que vamos pegar nosso template

34395
22:45:58,720 --> 22:46:01,120
arquivos muito rápidos e nós vamos

34396
22:46:01,120 --> 22:46:03,832
Coloque-os no lugar e nós vamos

34397
22:46:03,832 --> 22:46:06,480
abrir nosso projeto em código de estúdio visual

34398
22:46:06,480 --> 22:46:08,480
arrastando e caindo aqui nós temos

34399
22:46:08,480 --> 22:46:11,360
nosso arquivo principal cpp podemos fechar a esquerda

34400
22:46:11,360 --> 22:46:12,640
barra lateral

34401
22:46:12,640 --> 22:46:15,040
e nós podemos limpar a função principal aqui

34402
22:46:15,040 --> 22:46:16,552
Vamos montar uma classe simples

34403
22:46:16,552 --> 22:46:19,360
Vamos chamar este cão por que não temos sido

34404
22:46:19,360 --> 22:46:22,080
usando dove, então vamos usar isso novamente

34405
22:46:22,080 --> 22:46:24,320
nós vamos colocar o nosso ponto-e-vírgula de fechamento

34406
22:46:24,320 --> 22:46:26,480
vamos colocar uma seção pública e

34407
22:46:26,480 --> 22:46:29,192
Vai conter apenas um construtor

34408
22:46:29,192 --> 22:46:30,960
e nós vamos dizer cachorro e nós somos

34409
22:46:30,960 --> 22:46:32,872
Vou usar o padrão e vamos

34410
22:46:32,872 --> 22:46:35,680
para colocar em uma seção privada e

34411
22:46:35,680 --> 22:46:38,552
Aqui vamos colocar um tamanho t

34412
22:46:38,552 --> 22:46:39,600
E dizer

34413
22:46:39,600 --> 22:46:42,552
Esta é a contagem de pernas do cão, por que não

34414
22:46:42,552 --> 22:46:45,192
Vamos dizer que estamos modelando isso bem, então

34415
22:46:45,192 --> 22:46:48,320
Agora temos nossa classe de cães no lugar

34416
22:46:48,320 --> 22:46:50,552
pode criar objetos desta classe de cães

34417
22:46:50,552 --> 22:46:52,080
nós vamos dizer cachorro

34418
22:46:52,080 --> 22:46:54,552
Cão um e se fizermos isso nós somos

34419
22:46:54,552 --> 22:46:57,760
interessado em saber o tamanho do nosso

34420
22:46:57,760 --> 22:46:59,280
classe de cão aqui

34421
22:46:59,280 --> 22:47:03,120
então vamos dizer stdc fora do tamanho de

34422
22:47:03,120 --> 22:47:06,160
cão e salvar isso e uh dedos cruzados

34423
22:47:06,160 --> 22:47:08,000
Vamos ver o tamanho do nosso cão

34424
22:47:08,000 --> 22:47:10,400
Objeto aqui e tentar adivinhar o que somos

34425
22:47:10,400 --> 22:47:12,640
Vou entrar nos slides que vimos

34426
22:47:12,640 --> 22:47:15,512
que o tamanho vai ser principalmente

34427
22:47:15,512 --> 22:47:17,832
A soma do tamanho do membro

34428
22:47:17,832 --> 22:47:18,960
As variáveis

34429
22:47:18,960 --> 22:47:21,600
e vamos imprimir o tamanho do tamanho t aqui

34430
22:47:21,600 --> 22:47:24,000
porque tamanho d é o nosso único membro

34431
22:47:24,000 --> 22:47:25,832
variável, então eu acho que vai ser

34432
22:47:25,832 --> 22:47:28,480
úteis para ver seu tamanho impresso

34433
22:47:28,480 --> 22:47:30,232
então nós vamos ter algum contexto se

34434
22:47:30,232 --> 22:47:32,320
Fazemos isso, vamos dizer o tamanho de

34435
22:47:32,320 --> 22:47:34,872
tamanho t e nós vamos

34436
22:47:34,872 --> 22:47:36,800
Salve isso e vamos construir isso

34437
22:47:36,800 --> 22:47:38,872
programa, vamos fazer isso, vamos

34438
22:47:38,872 --> 22:47:41,120
passar isso através de gcc você vê os dois

34439
22:47:41,120 --> 22:47:42,232
É bom

34440
22:47:42,232 --> 22:47:44,232
e nós vamos trazer um terminal

34441
22:47:44,232 --> 22:47:47,040
e correr este ver o que acontece bem nós

34442
22:47:47,040 --> 22:47:50,160
ver o tamanho do tamanho t é oito e o tamanho

34443
22:47:50,160 --> 22:47:53,440
Nosso objeto escuro é oito e isso é

34444
22:47:53,440 --> 22:47:56,552
muito legal porque vemos que o tamanho

34445
22:47:56,552 --> 22:47:59,360
do nosso objeto de classe é realmente o tamanho

34446
22:47:59,360 --> 22:48:00,960
do nosso tipo

34447
22:48:00,960 --> 22:48:03,192
variáveis de membro que temos aqui

34448
22:48:03,192 --> 22:48:05,192
Vamos configurar outra variável de membro e

34449
22:48:05,192 --> 22:48:07,192
realmente te mostrar isso, então nós vamos

34450
22:48:07,192 --> 22:48:10,080
Tenho a conta do braço ok, então nós somos apenas

34451
22:48:10,080 --> 22:48:11,920
mexendo conosco para aprender

34452
22:48:11,920 --> 22:48:14,640
Eu não aponio para esta aula aqui para fazer

34453
22:48:14,640 --> 22:48:17,120
algum senso praticamente nós só queremos

34454
22:48:17,120 --> 22:48:20,000
Veja como as variáveis membros afetam o

34455
22:48:20,000 --> 22:48:23,280
tamanho do nosso objeto de classe agora temos dois

34456
22:48:23,280 --> 22:48:25,600
variáveis de membro e vamos tentar

34457
22:48:25,600 --> 22:48:27,760
e mundo que vamos usar gcc para fazer

34458
22:48:27,760 --> 22:48:30,160
Isso e vamos limpar e correr

34459
22:48:30,160 --> 22:48:31,280
Galo

34460
22:48:31,280 --> 22:48:33,600
Agora você vê que o tamanho do doug é 16 e

34461
22:48:33,600 --> 22:48:34,872
Isto é realmente

34462
22:48:34,872 --> 22:48:37,920
O tamanho de um objeto é

34463
22:48:37,920 --> 22:48:40,640
apenas a contabilização dos tamanhos do

34464
22:48:40,640 --> 22:48:42,960
variáveis de membro que não vai contar

34465
22:48:42,960 --> 22:48:45,600
As funções que temos aqui, então se

34466
22:48:45,600 --> 22:48:48,320
Por exemplo, tivemos uma função que diz

34467
22:48:48,320 --> 22:48:50,400
impresso e nós temos outro que

34468
22:48:50,400 --> 22:48:52,800
Diz fazer algo que isso não vai

34469
22:48:52,800 --> 22:48:55,360
mudar o tamanho do nosso objeto porque

34470
22:48:55,360 --> 22:48:58,720
As funções não são contabilizadas no

34471
22:48:58,720 --> 22:49:01,192
tamanho do nosso objeto aqui

34472
22:49:01,192 --> 22:49:04,400
então vamos construir e realmente mostrar isso

34473
22:49:04,400 --> 22:49:06,552
O mundo é bom que podemos limpar e correr

34474
22:49:06,552 --> 22:49:08,640
Galo vemos que temos o mesmo

34475
22:49:08,640 --> 22:49:11,920
Tamanhos do tamanho do cão é 16 do tamanho de

34476
22:49:11,920 --> 22:49:14,872
tamanho t é oito nós podemos até mesmo usar objeto

34477
22:49:14,872 --> 22:49:16,872
Nomes aqui, por exemplo, estamos usando o

34478
22:49:16,872 --> 22:49:19,440
classe em si, mas nós podemos usar o cão um aqui

34479
22:49:19,440 --> 22:49:20,480
E nós vamos ter o mesmo

34480
22:49:20,480 --> 22:49:23,040
A informação vamos lá e nós vamos

34481
22:49:23,040 --> 22:49:25,760
para limpar e correr galo

34482
22:49:25,760 --> 22:49:28,160
E você vê que temos o mesmo tamanho

34483
22:49:28,160 --> 22:49:30,800
então, se mudarmos essa coisa para colocar em um

34484
22:49:30,800 --> 22:49:32,400
pointer, vamos ver alguma coisa

34485
22:49:32,400 --> 22:49:35,832
mais vamos colocar em um ponteiro final

34486
22:49:35,832 --> 22:49:38,480
e vamos dizer ph como temos feito

34487
22:49:38,480 --> 22:49:40,872
O tempo todo e ver o que temos e nós

34488
22:49:40,872 --> 22:49:43,280
Saiba que o tamanho de um ponteiro no meu

34489
22:49:43,280 --> 22:49:45,680
sistema vamos imprimir isso para que nós

34490
22:49:45,680 --> 22:49:48,552
Não tenho dúvidas, por exemplo, dizer tamanho

34491
22:49:48,552 --> 22:49:51,760
O ponteiro final vai ser o tamanho de

34492
22:49:51,760 --> 22:49:54,400
fim de ponto ok vamos construir que estamos indo

34493
22:49:54,400 --> 22:49:55,280
A sua forma de

34494
22:49:55,280 --> 22:49:58,000
passar isso através do gcc e os dois são

34495
22:49:58,000 --> 22:50:00,400
Vou ser bom, podemos limpar e correr

34496
22:50:00,400 --> 22:50:02,480
Galo vamos ver que temos

34497
22:50:02,480 --> 22:50:05,440
24 porque temos duas variáveis de membros

34498
22:50:05,440 --> 22:50:07,360
que serão oito bytes em

34499
22:50:07,360 --> 22:50:10,800
memória do tamanho t são do tipo tamanho t

34500
22:50:10,800 --> 22:50:13,040
e nós temos um ponteiro que vai

34501
22:50:13,040 --> 22:50:15,920
ter um tamanho de h na memória, mas nós não temos

34502
22:50:15,920 --> 22:50:18,552
importa o que este ponteiro está apontando para

34503
22:50:18,552 --> 22:50:20,400
se, por exemplo, este ponteiro está apontando

34504
22:50:20,400 --> 22:50:22,480
Para algo realmente grande

34505
22:50:22,480 --> 22:50:24,160
Não nos importamos que vamos apenas

34506
22:50:24,160 --> 22:50:26,480
conta para o ponteiro final aqui e

34507
22:50:26,480 --> 22:50:29,600
Isso é realmente fenomenal, porque se para

34508
22:50:29,600 --> 22:50:32,232
exemplo, nós tentamos configurar uma string sdd

34509
22:50:32,232 --> 22:50:33,280
objeto

34510
22:50:33,280 --> 22:50:35,832
E agora você deve saber que std

34511
22:50:35,832 --> 22:50:39,192
A própria vertente é implementada como uma classe

34512
22:50:39,192 --> 22:50:41,760
em c plus plus, então é realmente uma classe

34513
22:50:41,760 --> 22:50:44,080
e podemos imprimir seu tamanho para definir

34514
22:50:44,080 --> 22:50:45,680
Um objeto de corda aqui nós vamos

34515
22:50:45,680 --> 22:50:48,552
Diga std amarrado e nós vamos dizer

34516
22:50:48,552 --> 22:50:50,800
nome e vamos inicializar isso

34517
22:50:50,800 --> 22:50:52,800
com olá mundo bem, vamos ver

34518
22:50:52,800 --> 22:50:55,192
Algo realmente estranho aqui, então se nós

34519
22:50:55,192 --> 22:50:57,120
imprimir o tamanho do nome aqui estamos indo

34520
22:50:57,120 --> 22:51:00,232
para dizer o tamanho do nome e nós vamos

34521
22:51:00,232 --> 22:51:02,320
imprimir que vamos ver o que temos nós somos

34522
22:51:02,320 --> 22:51:03,760
indo para correr

34523
22:51:03,760 --> 22:51:05,600
E nós vamos para

34524
22:51:05,600 --> 22:51:08,640
ver que o bloco é bom e pode limpar e

34525
22:51:08,640 --> 22:51:10,400
Assador de corrida, vamos ver esse tamanho

34526
22:51:10,400 --> 22:51:12,872
O nome é 32.

34527
22:51:12,872 --> 22:51:16,400
Vamos mudar o texto dentro da nossa string

34528
22:51:16,400 --> 22:51:18,080
e ver que mudamos de acordo

34529
22:51:18,080 --> 22:51:20,160
Porque isso pode realmente ser confuso

34530
22:51:20,160 --> 22:51:23,920
Vamos dizer que eu sou o rei do universo

34531
22:51:23,920 --> 22:51:26,000
Por que não e nós vamos construir novamente

34532
22:51:26,000 --> 22:51:28,232
Vamos ver o que nós temos cruzado

34533
22:51:28,232 --> 22:51:30,552
Isso vai explodir sua mente que você vê

34534
22:51:30,552 --> 22:51:32,720
nós temos o mesmo tamanho para o nome, mesmo se

34535
22:51:32,720 --> 22:51:35,360
Estamos mudando o texto aqui, então o que

34536
22:51:35,360 --> 22:51:38,000
Está realmente acontecendo a força é

34537
22:51:38,000 --> 22:51:41,440
armazenando nosso texto aqui como cartão de custo

34538
22:51:41,440 --> 22:51:42,400
O ponteiro

34539
22:51:42,400 --> 22:51:45,280
O que temos é um ponteiro dentro e

34540
22:51:45,280 --> 22:51:47,680
O que provavelmente temos por dentro

34541
22:51:47,680 --> 22:51:50,400
é uma variável membro que é um ponteiro

34542
22:51:50,400 --> 22:51:52,800
como temos aqui, então o que seremos

34543
22:51:52,800 --> 22:51:55,600
A contabilidade na classe de força é

34544
22:51:55,600 --> 22:51:57,760
o tamanho do ponteiro, mas não é o

34545
22:51:57,760 --> 22:52:00,232
tamanho do que é apontado para o bom

34546
22:52:00,232 --> 22:52:03,280
O ponteiro do carro pode estar apontando para milhares

34547
22:52:03,280 --> 22:52:06,000
de personagens na memória, mas desde que

34548
22:52:06,000 --> 22:52:08,160
o compilador está preocupado que é apenas

34549
22:52:08,160 --> 22:52:10,232
usar a variável de membro do ponteiro

34550
22:52:10,232 --> 22:52:12,232
e vai explicar isso no

34551
22:52:12,232 --> 22:52:14,080
tamanho do seu objeto espero que você possa

34552
22:52:14,080 --> 22:52:15,512
Entenda o porquê

34553
22:52:15,512 --> 22:52:18,000
o tamanho dos nossos objetos de corda está indo

34554
22:52:18,000 --> 22:52:19,440
para ser o mesmo

34555
22:52:19,440 --> 22:52:22,232
independentemente de quão grande é este fio

34556
22:52:22,232 --> 22:52:24,400
Isso é realmente algo que você precisa

34557
22:52:24,400 --> 22:52:26,320
Entender o contrário, isso vai fazer

34558
22:52:26,320 --> 22:52:28,552
jogá-lo fora como você projetar seu c plus

34559
22:52:28,552 --> 22:52:30,960
além de aplicações e isso é realmente tudo

34560
22:52:30,960 --> 22:52:33,680
Eu tive que compartilhar nesta palestra o tamanho

34561
22:52:33,680 --> 22:52:35,512
do seu objeto vai ser principalmente

34562
22:52:35,512 --> 22:52:37,512
determinado pelo

34563
22:52:37,512 --> 22:52:39,680
membros variáveis que você tem e o tamanho

34564
22:52:39,680 --> 22:52:41,920
Será a soma dos tamanhos de

34565
22:52:41,920 --> 22:52:44,720
suas variáveis de membro eu gostaria de

34566
22:52:44,720 --> 22:52:46,960
recebê-lo neste novo capítulo onde

34567
22:52:46,960 --> 22:52:48,480
Vamos aprender sobre

34568
22:52:48,480 --> 22:52:51,280
Herança e herança é uma característica

34569
22:52:51,280 --> 22:52:54,000
que c plus plus fornece

34570
22:52:54,000 --> 22:52:57,920
para nos permitir construir aulas em termos de

34571
22:52:57,920 --> 22:52:59,440
Outras classes

34572
22:52:59,440 --> 22:53:01,192
O que quero dizer aqui é que podemos

34573
22:53:01,192 --> 22:53:04,080
Construir hierarquias completas de classes

34574
22:53:04,080 --> 22:53:06,872
Isso depende de outras classes, por exemplo

34575
22:53:06,872 --> 22:53:09,760
Se pensarmos em uma pessoa como um tipo que podemos

34576
22:53:09,760 --> 22:53:12,640
ter diferentes tipos de pessoas que podemos

34577
22:53:12,640 --> 22:53:15,192
Um médico é uma pessoa que nós

34578
22:53:15,192 --> 22:53:18,232
Um médico pode ter um médico

34579
22:53:18,232 --> 22:53:20,720
Podemos ter um engenheiro e

34580
22:53:20,720 --> 22:53:23,120
Engenheiro como pessoa que podemos ter realmente

34581
22:53:23,120 --> 22:53:25,920
todos os tipos de pessoas e nós podemos capturar

34582
22:53:25,920 --> 22:53:28,640
esses tipos de relacionamentos em c plus

34583
22:53:28,640 --> 22:53:31,192
além de usar herança, por exemplo, aqui

34584
22:53:31,192 --> 22:53:34,160
Temos uma hierarquia de herança que podemos

34585
22:53:34,160 --> 22:53:36,552
configurar um tipo de pessoa em nosso c plus

34586
22:53:36,552 --> 22:53:38,400
programar e colocar em qualquer membro

34587
22:53:38,400 --> 22:53:42,232
variáveis que precisamos definir uma pessoa para

34588
22:53:42,232 --> 22:53:44,400
Quais sejam os propósitos que estamos construindo nosso c

34589
22:53:44,400 --> 22:53:46,800
plus plus aplicação para uma vez que temos

34590
22:53:46,800 --> 22:53:49,192
Este tipo podemos construir outros tipos que

34591
22:53:49,192 --> 22:53:51,512
Depende dessa pessoa, por exemplo, podemos

34592
22:53:51,512 --> 22:53:54,000
construir um tipo de engenheiro que é realmente

34593
22:53:54,000 --> 22:53:57,040
indo para incorporar o tipo de pessoa dentro

34594
22:53:57,040 --> 22:53:59,192
Então o que vamos fazer é realmente

34595
22:53:59,192 --> 22:54:02,640
configurar uma camada de um tipo de pessoa e

34596
22:54:02,640 --> 22:54:05,120
em nosso tipo de engenheiro que vai

34597
22:54:05,120 --> 22:54:08,080
Depende da pessoa que vamos ferver o romance

34598
22:54:08,080 --> 22:54:10,720
camada em cima disso e realmente reutilizar

34599
22:54:10,720 --> 22:54:13,360
esse tipo de pessoa sem ter que

34600
22:54:13,360 --> 22:54:15,760
Reconstrua isso do zero espero que você

34601
22:54:15,760 --> 22:54:17,512
pode ver que isso vai melhorar

34602
22:54:17,512 --> 22:54:20,000
Reutilização de código também podemos reutilizar isso

34603
22:54:20,000 --> 22:54:22,080
tipo de engenheiro e bem os outros tipos

34604
22:54:22,080 --> 22:54:23,832
Além disso, por exemplo, podemos ter um

34605
22:54:23,832 --> 22:54:26,320
engenheiro civil, podemos ter um elétrico

34606
22:54:26,320 --> 22:54:28,400
Engenheiro, podemos ter todos os tipos de loucos

34607
22:54:28,400 --> 22:54:31,120
Engenheiros modelados em nosso c plus mais

34608
22:54:31,120 --> 22:54:32,160
O programa

34609
22:54:32,160 --> 22:54:33,832
usando a herança e isso está indo

34610
22:54:33,832 --> 22:54:36,552
para ser muito legal, então isso é o que somos

34611
22:54:36,552 --> 22:54:39,040
Vou explorar neste capítulo

34612
22:54:39,040 --> 22:54:41,360
olhando para as instalações que c mais

34613
22:54:41,360 --> 22:54:44,552
Plus fornece para capturar esses tipos de

34614
22:54:44,552 --> 22:54:46,720
relacionamentos em nosso c plus plus

34615
22:54:46,720 --> 22:54:49,680
Os programas, por favor, note que a herança é

34616
22:54:49,680 --> 22:54:51,760
uma característica realmente grande e é um

34617
22:54:51,760 --> 22:54:54,480
característica definidora de objeto orientado

34618
22:54:54,480 --> 22:54:57,440
programação c plus plus object oriented

34619
22:54:57,440 --> 22:55:00,320
A programação é um paradigma ou uma maneira de

34620
22:55:00,320 --> 22:55:03,360
Pensando em programação que usa

34621
22:55:03,360 --> 22:55:05,920
objetos e a definição mais básica

34622
22:55:05,920 --> 22:55:08,232
característica da programação orientada a objetos

34623
22:55:08,232 --> 22:55:10,872
em c plus mais são classes que temos

34624
22:55:10,872 --> 22:55:13,040
Aprendendo sobre o uso de aulas que podemos

34625
22:55:13,040 --> 22:55:15,760
Definir coisas, por exemplo, podemos configurar

34626
22:55:15,760 --> 22:55:17,832
um carro que podemos montar uma casa que podemos definir

34627
22:55:17,832 --> 22:55:20,000
Uma nave espacial que podemos fazer todos os tipos de

34628
22:55:20,000 --> 22:55:22,080
coisas loucas com aulas e ziplocs

34629
22:55:22,080 --> 22:55:24,552
mais herança vai construir sobre

34630
22:55:24,552 --> 22:55:27,360
topo de aulas e permitir-nos construir

34631
22:55:27,360 --> 22:55:30,000
classes que dependem umas das outras e

34632
22:55:30,000 --> 22:55:31,760
Será a herança completa

34633
22:55:31,760 --> 22:55:34,000
hierarquias que vão fazer o nosso

34634
22:55:34,000 --> 22:55:36,160
design muito mais fácil de olhar e

34635
22:55:36,160 --> 22:55:39,040
Compreender e trabalhar com ok, então este é

34636
22:55:39,040 --> 22:55:41,512
o que enfrentamos neste capítulo

34637
22:55:41,512 --> 22:55:43,440
aprender sobre herança e realmente

34638
22:55:43,440 --> 22:55:46,872
expondo você ao máximo possível

34639
22:55:46,872 --> 22:55:49,680
deixar você usar a herança de uma maneira mais fácil

34640
22:55:49,680 --> 22:55:52,080
em seus programas de classe c plus que somos

34641
22:55:52,080 --> 22:55:54,080
Começará na próxima palestra e

34642
22:55:54,080 --> 22:55:56,960
Experimente a herança pela primeira vez

34643
22:55:56,960 --> 22:55:59,120
Vá em frente e termine aqui e me encontre

34644
22:55:59,120 --> 22:56:01,440
lá nesta palestra vamos tentar

34645
22:56:01,440 --> 22:56:04,400
Herança pela primeira vez em

34646
22:56:04,400 --> 22:56:05,680
este curso

34647
22:56:05,680 --> 22:56:07,600
mas antes de fazermos isso, vamos lembrar

34648
22:56:07,600 --> 22:56:11,280
nós mesmos do que a herança realmente é

34649
22:56:11,280 --> 22:56:13,512
Herança é uma característica que temos em c

34650
22:56:13,512 --> 22:56:14,480
plus plus

34651
22:56:14,480 --> 22:56:17,680
para ser capaz de construir novas classes em termos

34652
22:56:17,680 --> 22:56:20,720
das aulas que temos predefinidos

34653
22:56:20,720 --> 22:56:23,040
E as novas classes vão ser

34654
22:56:23,040 --> 22:56:25,360
Roubando características do já

34655
22:56:25,360 --> 22:56:28,400
classes pré-existentes se eu puder dizer

34656
22:56:28,400 --> 22:56:31,120
assim e quanto mais classes construímos

34657
22:56:31,120 --> 22:56:33,512
em termos de outros, vamos acabar

34658
22:56:33,512 --> 22:56:36,232
com o que chamamos de árvore de herança

34659
22:56:36,232 --> 22:56:38,232
que basicamente vai sair do

34660
22:56:38,232 --> 22:56:40,640
de cima para baixo com mais

34661
22:56:40,640 --> 22:56:43,360
classe fundamental no topo e no derivado

34662
22:56:43,360 --> 22:56:45,760
classe no fundo aqui temos um

34663
22:56:45,760 --> 22:56:48,000
Um exemplo simples, por exemplo, podemos ter a

34664
22:56:48,000 --> 22:56:49,512
classe de pessoa

34665
22:56:49,512 --> 22:56:51,600
E esta classe pode ser

34666
22:56:51,600 --> 22:56:54,800
Definir as características básicas de uma pessoa

34667
22:56:54,800 --> 22:56:56,960
mas com base nessa classe pessoal, nós

34668
22:56:56,960 --> 22:57:00,400
pode querer derivar outras classes que

34669
22:57:00,400 --> 22:57:03,512
construir em cima desta classe de pessoa para

34670
22:57:03,512 --> 22:57:05,280
Um exemplo, podemos querer definir um

34671
22:57:05,280 --> 22:57:07,760
engenheiro e um médico e sabemos que

34672
22:57:07,760 --> 22:57:10,400
Um engenheiro também é uma pessoa, então eles são

34673
22:57:10,400 --> 22:57:12,960
vai herdar algumas características do

34674
22:57:12,960 --> 22:57:15,512
pessoa classe o mesmo vale para o

34675
22:57:15,512 --> 22:57:18,232
classe médica que vai herdar

34676
22:57:18,232 --> 22:57:21,040
Algumas características da pessoa, mas todas essas

34677
22:57:21,040 --> 22:57:23,600
classes derivadas também vão adicionar

34678
22:57:23,600 --> 22:57:26,160
suas próprias características para a classe da pessoa

34679
22:57:26,160 --> 22:57:28,640
siplus plus nos permite construir estes

34680
22:57:28,640 --> 22:57:30,720
Tipos de relações

34681
22:57:30,720 --> 22:57:33,832
Aqui está outro exemplo simples que temos a

34682
22:57:33,832 --> 22:57:36,232
classe de veículos para o topo da nossa

34683
22:57:36,232 --> 22:57:39,280
hierarquia de herança e abaixo disso

34684
22:57:39,280 --> 22:57:42,000
classe que podemos derivar uma classe de faixa

34685
22:57:42,000 --> 22:57:44,320
que também é um veículo que podemos ter um

34686
22:57:44,320 --> 22:57:46,400
Minivan podemos ter um caminhão que podemos

34687
22:57:46,400 --> 22:57:49,280
ter uma caminhonete, podemos realmente fazer tudo

34688
22:57:49,280 --> 22:57:52,000
tipos de veículos loucos que estão indo

34689
22:57:52,000 --> 22:57:54,552
para herdar as características básicas do

34690
22:57:54,552 --> 22:57:57,192
classe de veículo e adicionar o seu próprio

34691
22:57:57,192 --> 22:57:58,800
Especialização

34692
22:57:58,800 --> 22:58:00,872
no topo da classe do veículo, então este é

34693
22:58:00,872 --> 22:58:04,320
A ideia básica por trás da herança em c

34694
22:58:04,320 --> 22:58:06,800
mais mais para que os exemplos que vamos

34695
22:58:06,800 --> 22:58:09,040
O fazer nesta palestra

34696
22:58:09,040 --> 22:58:11,192
Aqui está um exemplo simples do que

34697
22:58:11,192 --> 22:58:12,720
nós vamos fazer nesta palestra que estamos

34698
22:58:12,720 --> 22:58:14,552
Vou montar uma classe de pessoa que é

34699
22:58:14,552 --> 22:58:17,040
Vai ser a nossa classe base

34700
22:58:17,040 --> 22:58:18,960
vai definir dois membros

34701
22:58:18,960 --> 22:58:21,440
variáveis que serão de std

34702
22:58:21,440 --> 22:58:23,512
Tipo de string nós vamos ter um último

34703
22:58:23,512 --> 22:58:25,832
Nome para a pessoa e o primeiro nome

34704
22:58:25,832 --> 22:58:27,192
Para a pessoa

34705
22:58:27,192 --> 22:58:30,480
Vamos derivar desta classe

34706
22:58:30,480 --> 22:58:32,872
e criar uma classe de jogador

34707
22:58:32,872 --> 22:58:35,040
A classe do jogador vai herdar

34708
22:58:35,040 --> 22:58:37,192
essas características da classe da pessoa assim

34709
22:58:37,192 --> 22:58:39,680
vai ter um sobrenome e um

34710
22:58:39,680 --> 22:58:42,552
Primeiro nome embutido nele, mas isso é

34711
22:58:42,552 --> 22:58:45,360
Será a nossa base ou nosso começo

34712
22:58:45,360 --> 22:58:48,080
Ponto que vamos adicionar a esta base

34713
22:58:48,080 --> 22:58:50,160
e adicionar outra variável de membro a partir de

34714
22:58:50,160 --> 22:58:52,872
jogador e nós vamos ter a

34715
22:58:52,872 --> 22:58:56,232
classe de jogador que é realmente uma pessoa

34716
22:58:56,232 --> 22:58:58,640
Mas vai adicionar coisas à pessoa

34717
22:58:58,640 --> 22:59:01,600
para personalizar o que podemos fazer com um

34718
22:59:01,600 --> 22:59:02,552
Jogador

34719
22:59:02,552 --> 22:59:05,120
que originalmente não seríamos capazes de

34720
22:59:05,120 --> 22:59:08,160
fazer ou ter com uma classe de pessoa que este é

34721
22:59:08,160 --> 22:59:10,640
A ideia básica está bem agora que sabemos

34722
22:59:10,640 --> 22:59:12,720
Isso nós vamos configurar o nosso pessoal

34723
22:59:12,720 --> 22:59:14,480
classe que vai ser a nossa base

34724
22:59:14,480 --> 22:59:16,960
Classe vai ter os nossos dois membros

34725
22:59:16,960 --> 22:59:19,440
variáveis primeiro o nome e sobrenome

34726
22:59:19,440 --> 22:59:20,640
nós vamos ter um monte de

34727
22:59:20,640 --> 22:59:22,552
construtores e nós vamos ter um

34728
22:59:22,552 --> 22:59:25,192
operador de saída de fluxo para ser capaz de

34729
22:59:25,192 --> 22:59:27,600
imprimir isso no console e ver o nosso

34730
22:59:27,600 --> 22:59:30,400
informação aqui nada de especial, mas agora

34731
22:59:30,400 --> 22:59:33,040
que esta classe é feita que podemos construir

34732
22:59:33,040 --> 22:59:36,080
outras classes no topo desta classe, então

34733
22:59:36,080 --> 22:59:38,232
o que podemos fazer, por exemplo, podemos obter

34734
22:59:38,232 --> 22:59:40,000
uma classe de jogador

34735
22:59:40,000 --> 22:59:41,920
Então a sintaxe é o que você vê aqui nós

34736
22:59:41,920 --> 22:59:45,680
Diga jogador de classe que dizemos coluna coluna

34737
22:59:45,680 --> 22:59:47,832
e então dizemos público

34738
22:59:47,832 --> 22:59:50,160
e especificar a classe que somos

34739
22:59:50,160 --> 22:59:53,192
herdar de assim a classe dos pais para

34740
22:59:53,192 --> 22:59:55,832
Esta classe vai ser pessoa ou em

34741
22:59:55,832 --> 22:59:58,400
Outras palavras, vamos derivar

34742
22:59:58,400 --> 23:00:00,552
da classe da pessoa e nós vamos

34743
23:00:00,552 --> 23:00:03,600
Estou fazendo isso publicamente ok por enquanto eu

34744
23:00:03,600 --> 23:00:05,680
Não quero que você se preocupe muito com

34745
23:00:05,680 --> 23:00:07,600
Esta palavra-chave pública vamos ser

34746
23:00:07,600 --> 23:00:10,400
aprender isso em etapas, saiba que

34747
23:00:10,400 --> 23:00:12,960
Esta é a sintaxe que você usa para derivar

34748
23:00:12,960 --> 23:00:14,640
A partir de uma outra classe

34749
23:00:14,640 --> 23:00:17,120
Agora, no momento em que fazemos isso, o jogador

34750
23:00:17,120 --> 23:00:19,280
A classe vai ter a pessoa

34751
23:00:19,280 --> 23:00:22,640
informação incorporada dentro, mas nós vamos

34752
23:00:22,640 --> 23:00:25,360
também tem a capacidade de personalizar ou

34753
23:00:25,360 --> 23:00:27,280
Adicione outras coisas

34754
23:00:27,280 --> 23:00:29,920
ao nível da classe do jogador este é

34755
23:00:29,920 --> 23:00:31,600
O que fazemos, temos um membro privado

34756
23:00:31,600 --> 23:00:34,800
variável e vai especificar o

34757
23:00:34,800 --> 23:00:36,960
Jogo no lugar do jogador, vamos

34758
23:00:36,960 --> 23:00:39,512
ter o nosso próprio conjunto de construtores que podemos

34759
23:00:39,512 --> 23:00:42,720
realmente construir objetos de jogador, mas eles são

34760
23:00:42,720 --> 23:00:46,720
ter uma pessoa parte dentro disso

34761
23:00:46,720 --> 23:00:49,360
vai armazenar informações sobre isso

34762
23:00:49,360 --> 23:00:51,040
pessoa do jogador

34763
23:00:51,040 --> 23:00:52,960
Você percebe que não temos um membro

34764
23:00:52,960 --> 23:00:54,720
variável aqui para o primeiro nome que nós

34765
23:00:54,720 --> 23:00:56,400
não tem uma variável de membro aqui para

34766
23:00:56,400 --> 23:00:58,640
O sobrenome, mas essa informação é

34767
23:00:58,640 --> 23:01:01,192
Vai ser assado neste jogador

34768
23:01:01,192 --> 23:01:03,760
Objeto e isso é realmente como

34769
23:01:03,760 --> 23:01:07,440
A herança nos ajuda a obter

34770
23:01:07,440 --> 23:01:08,960
das aulas

34771
23:01:08,960 --> 23:01:11,832
e construir sobre eles sem ter

34772
23:01:11,832 --> 23:01:14,160
para refazer o trabalho fundamental para construir

34773
23:01:14,160 --> 23:01:16,720
nossas classes base que podemos apenas construir sobre

34774
23:01:16,720 --> 23:01:19,512
top deles e realmente fazer as coisas mais rápido

34775
23:01:19,512 --> 23:01:22,232
e mais eficientemente bem, então aqui estão a

34776
23:01:22,232 --> 23:01:24,080
Poucas coisas que você precisa saber sobre o

34777
23:01:24,080 --> 23:01:27,120
herança pública que acabamos de fazer e

34778
23:01:27,120 --> 23:01:29,832
Estamos dizendo herança pública porque

34779
23:01:29,832 --> 23:01:32,640
da sintaxe que usamos aqui

34780
23:01:32,640 --> 23:01:35,512
Pessoa pública que está fazendo público

34781
23:01:35,512 --> 23:01:37,680
Herança e vamos ver o que

34782
23:01:37,680 --> 23:01:40,640
Isso nos dá isso com herança pública

34783
23:01:40,640 --> 23:01:43,600
classes derivadas podem acessar e usar

34784
23:01:43,600 --> 23:01:46,720
membros do público da classe base

34785
23:01:46,720 --> 23:01:49,600
mas a classe derivada não pode diretamente

34786
23:01:49,600 --> 23:01:52,000
Acesse membros privados a partir da base

34787
23:01:52,000 --> 23:01:54,800
classe Eu quero que você deixe essa sincronização terminar

34788
23:01:54,800 --> 23:01:58,552
O que isso significa da classe do jogador, nós

34789
23:01:58,552 --> 23:02:01,360
Não pode acessar diretamente o membro privado

34790
23:02:01,360 --> 23:02:04,232
variáveis que tivemos em pessoa, lembrem-se da nossa

34791
23:02:04,232 --> 23:02:07,040
O primeiro nome e sobrenome são privados para

34792
23:02:07,040 --> 23:02:10,640
pessoa e não podemos acessá-los diretamente

34793
23:02:10,640 --> 23:02:13,920
em qualquer classe que esteja fazendo

34794
23:02:13,920 --> 23:02:17,512
A herança pública está bem, então em nosso jogador

34795
23:02:17,512 --> 23:02:19,832
classe se tentarmos acessar o primeiro nome

34796
23:02:19,832 --> 23:02:21,512
e o sobrenome que vamos ter

34797
23:02:21,512 --> 23:02:23,360
Erros de compilador porque não podemos

34798
23:02:23,360 --> 23:02:25,760
Acessá-los diretamente, mas não se preocupar

34799
23:02:25,760 --> 23:02:27,920
Aqui nós ainda podemos passar

34800
23:02:27,920 --> 23:02:31,192
os getters públicos que temos no

34801
23:02:31,192 --> 23:02:32,400
classe de pessoa

34802
23:02:32,400 --> 23:02:34,960
acessar as variáveis de membro privado

34803
23:02:34,960 --> 23:02:37,040
da classe base e é isso que

34804
23:02:37,040 --> 23:02:39,280
nós vamos fazer nesta palestra aqui

34805
23:02:39,280 --> 23:02:41,512
Porque não temos acesso a mais

34806
23:02:41,512 --> 23:02:43,360
ferramentas poderosas que vamos aprender

34807
23:02:43,360 --> 23:02:46,232
sobre nas próximas palestras a mesma

34808
23:02:46,232 --> 23:02:48,960
Também se aplica aos amigos do

34809
23:02:48,960 --> 23:02:50,552
classe derivada

34810
23:02:50,552 --> 23:02:52,800
Eles terão acesso ao privado

34811
23:02:52,800 --> 23:02:55,760
membros da classe derivada, mas eles

34812
23:02:55,760 --> 23:02:57,920
Não tenha acesso a

34813
23:02:57,920 --> 23:03:00,960
os membros privados da classe base se

34814
23:03:00,960 --> 23:03:04,480
Você tenta acessar as partes privadas de um

34815
23:03:04,480 --> 23:03:05,832
classe base

34816
23:03:05,832 --> 23:03:08,640
de um amigo da classe derivada

34817
23:03:08,640 --> 23:03:10,640
você vai ter um monte de compilador

34818
23:03:10,640 --> 23:03:11,680
Os erros

34819
23:03:11,680 --> 23:03:13,280
Tudo bem agora que você sabe disso, estamos indo

34820
23:03:13,280 --> 23:03:15,512
para ir até o código do estúdio visual e

34821
23:03:15,512 --> 23:03:17,280
jogar com isso um pouco mais e realmente

34822
23:03:17,280 --> 23:03:18,872
conduzir isso para casa

34823
23:03:18,872 --> 23:03:21,440
Aqui estamos em nossa pasta de trabalho o

34824
23:03:21,440 --> 23:03:24,080
O projeto atual é a primeira tentativa

34825
23:03:24,080 --> 23:03:26,552
herança, vamos pegar o nosso

34826
23:03:26,552 --> 23:03:28,720
template files e colocá-los no lugar

34827
23:03:28,720 --> 23:03:30,080
Vamos fazer isto.

34828
23:03:30,080 --> 23:03:32,000
e nós vamos abrir isso em

34829
23:03:32,000 --> 23:03:34,080
código de estúdio muito rápido, arrastando e

34830
23:03:34,080 --> 23:03:36,872
Deixando aqui vamos fazer isso corretamente e

34831
23:03:36,872 --> 23:03:38,960
nós vamos ter o nosso arquivo cpp principal nós

34832
23:03:38,960 --> 23:03:41,360
pode limpar isso um pouco e nós somos

34833
23:03:41,360 --> 23:03:43,760
Vamos adicionar nossas aulas de primeira classe

34834
23:03:43,760 --> 23:03:46,400
Vamos acrescentar que a classe da pessoa

34835
23:03:46,400 --> 23:03:48,480
Vamos criar o seu cabeçalho

34836
23:03:48,480 --> 23:03:52,080
file e vamos fazer o arquivo cpp i am

34837
23:03:52,080 --> 23:03:54,552
Vou pegar o código que eu tenho deitado

34838
23:03:54,552 --> 23:03:56,872
Meu drive para o cabeçalho aqui eu estou indo

34839
23:03:56,872 --> 23:03:59,512
para colocar a classe em que estamos incluindo o

34840
23:03:59,512 --> 23:04:01,120
aulas que precisamos que precisamos

34841
23:04:01,120 --> 23:04:03,440
string e fluxo io aqui porque nós somos

34842
23:04:03,440 --> 23:04:05,832
vai sair graças através

34843
23:04:05,832 --> 23:04:08,000
o operador do fluxo de saída

34844
23:04:08,000 --> 23:04:10,000
E aqui em baixo temos nossos dois membros

34845
23:04:10,000 --> 23:04:12,400
variáveis temos o primeiro nome e último

34846
23:04:12,400 --> 23:04:15,360
nome eles são do tipo de string std e nós

34847
23:04:15,360 --> 23:04:17,192
Tenho um monte de construtores aqui e

34848
23:04:17,192 --> 23:04:19,920
construtor padrão e um que leva

34849
23:04:19,920 --> 23:04:22,960
dois parâmetros que estamos tomando por

34850
23:04:22,960 --> 23:04:26,000
copiar aqui isso é ruim que devemos pelo menos

34851
23:04:26,000 --> 23:04:28,232
Passe por referência aqui vamos

34852
23:04:28,232 --> 23:04:29,512
corrija isso

34853
23:04:29,512 --> 23:04:31,440
muito rápido

34854
23:04:31,440 --> 23:04:33,360
e nós vamos fazer o segundo um

34855
23:04:33,360 --> 23:04:36,160
referência também, vamos fazer isso e nós

34856
23:04:36,160 --> 23:04:38,232
ter um destruidor que vai fazer

34857
23:04:38,232 --> 23:04:40,960
Nada porque nós realmente não estamos fazendo

34858
23:04:40,960 --> 23:04:43,760
qualquer alocação de memória dinâmica aqui nós estamos

34859
23:04:43,760 --> 23:04:46,080
indo para a cabeça para o arquivo cpp e

34860
23:04:46,080 --> 23:04:47,760
colocar no código para isso nós vamos

34861
23:04:47,760 --> 23:04:50,160
incluir a pessoa e nós vamos fazer

34862
23:04:50,160 --> 23:04:51,832
Nossos construtores colocam no

34863
23:04:51,832 --> 23:04:54,320
implementações devo dizer e nós somos

34864
23:04:54,320 --> 23:04:56,232
passar nossos parâmetros por

34865
23:04:56,232 --> 23:04:59,280
referência novamente vamos fazer isso e nosso

34866
23:04:59,280 --> 23:05:01,440
O construtor deve ser feito agora que temos um

34867
23:05:01,440 --> 23:05:05,120
classe de pessoa que podemos usar para derivar

34868
23:05:05,120 --> 23:05:08,232
outras classes e usar esta classe como um

34869
23:05:08,232 --> 23:05:11,192
fundação para construir outras classes para

34870
23:05:11,192 --> 23:05:14,480
Visualize isso novamente nossa pessoa de classe é

34871
23:05:14,480 --> 23:05:16,800
Vai ser a classe base para o nosso

34872
23:05:16,800 --> 23:05:18,320
classe de jogadores

34873
23:05:18,320 --> 23:05:20,872
então, se construirmos uma classe de jogadores, está indo

34874
23:05:20,872 --> 23:05:22,080
para ter

34875
23:05:22,080 --> 23:05:25,192
uma pessoa que vai ser

34876
23:05:25,192 --> 23:05:27,120
A base em cima da qual somos

34877
23:05:27,120 --> 23:05:29,680
vamos criar aviso de que no jogador nós

34878
23:05:29,680 --> 23:05:31,760
Não precisa configurar o sobrenome e primeiro

34879
23:05:31,760 --> 23:05:34,080
nome, eles virão do nosso

34880
23:05:34,080 --> 23:05:36,872
Parte pessoal do jogador tudo o que precisamos

34881
23:05:36,872 --> 23:05:39,440
fazer no jogador é configurado o membro do jogo

34882
23:05:39,440 --> 23:05:42,400
variável para torná-lo um jogador completo que

34883
23:05:42,400 --> 23:05:44,960
Pode ter o jogo que eles são

34884
23:05:44,960 --> 23:05:47,360
Jogando esta é a ideia aqui, então

34885
23:05:47,360 --> 23:05:48,960
Agora que sabemos disso, vamos colocar

34886
23:05:48,960 --> 23:05:50,800
em nossa classe de jogadores, vamos

34887
23:05:50,800 --> 23:05:54,000
criar os arquivos para ele vamos fazer player

34888
23:05:54,000 --> 23:05:56,720
Dot h vamos colocar isso dentro e

34889
23:05:56,720 --> 23:05:58,800
nós vamos fazer um jogador

34890
23:05:58,800 --> 23:06:01,512
que cpp vamos colocá-lo e

34891
23:06:01,512 --> 23:06:03,600
nós vamos pular para o cabeçalho

34892
23:06:03,600 --> 23:06:07,120
arquivo e colocar em nosso código a classe é

34893
23:06:07,120 --> 23:06:09,280
Vai ser jogador e vai ser

34894
23:06:09,280 --> 23:06:11,600
Herdar da pessoa esta é a

34895
23:06:11,600 --> 23:06:14,960
sintaxe novamente, dizemos colono, dizemos

34896
23:06:14,960 --> 23:06:17,040
O tipo de herança que queremos fazer em

34897
23:06:17,040 --> 23:06:19,120
Este caso é público e depois dizemos

34898
23:06:19,120 --> 23:06:21,040
A classe que nós vamos ser

34899
23:06:21,040 --> 23:06:24,232
herdar a partir deste ponto no

34900
23:06:24,232 --> 23:06:26,400
Classe de jogador vai ter uma pessoa

34901
23:06:26,400 --> 23:06:28,232
parte disso e vamos provar

34902
23:06:28,232 --> 23:06:30,480
Isto em um minuto em que executamos este código

34903
23:06:30,480 --> 23:06:32,720
Aqui observe que podemos construir um jogador

34904
23:06:32,720 --> 23:06:35,600
objetos apenas passando no jogo

34905
23:06:35,600 --> 23:06:38,000
parâmetro aqui que será usado

34906
23:06:38,000 --> 23:06:40,960
para inicializar nossa variável de membro, vamos

34907
23:06:40,960 --> 23:06:43,120
também torná-lo uma referência porque isso é

34908
23:06:43,120 --> 23:06:44,872
Boas práticas vão evitar

34909
23:06:44,872 --> 23:06:47,832
você pode até usar visualizações de string, mas

34910
23:06:47,832 --> 23:06:50,080
que vai ser a sua escolha

34911
23:06:50,080 --> 23:06:52,552
vamos pular para o arquivo cpp

34912
23:06:52,552 --> 23:06:55,680
e colocar em nossa implementação

34913
23:06:55,680 --> 23:06:58,080
e isso vai completar nossa configuração

34914
23:06:58,080 --> 23:07:00,400
para a classe do jogador que vai

34915
23:07:00,400 --> 23:07:03,680
estar herdando da nossa classe de pessoa aqui

34916
23:07:03,680 --> 23:07:06,800
Podemos realmente ir até o principal

34917
23:07:06,800 --> 23:07:09,920
arquivo cpp e incluir a classe do jogador

34918
23:07:09,920 --> 23:07:11,760
Vamos fazer isso, vamos dizer jogador

34919
23:07:11,760 --> 23:07:14,160
e nós podemos criar objetos do jogador, vamos

34920
23:07:14,160 --> 23:07:16,960
olhar para o código novamente para um jogador que nós

34921
23:07:16,960 --> 23:07:18,720
ter um construtor que vai

34922
23:07:18,720 --> 23:07:21,680
tomar um parâmetro string nós podemos usar isso

34923
23:07:21,680 --> 23:07:24,720
para criar um jogador e especificar o jogo

34924
23:07:24,720 --> 23:07:26,552
Eles vão estar jogando

34925
23:07:26,552 --> 23:07:27,280


34926
23:07:27,280 --> 23:07:30,800
por enquanto não temos ferramentas suficientes para

34927
23:07:30,800 --> 23:07:33,440
colocar nos dados que inicializariam

34928
23:07:33,440 --> 23:07:36,320
As variáveis membros na classe base

34929
23:07:36,320 --> 23:07:38,480
que é a pessoa aqui se voltarmos para

34930
23:07:38,480 --> 23:07:39,920
pessoa nós vamos ver que temos

34931
23:07:39,920 --> 23:07:42,160
O primeiro nome e o sobrenome

34932
23:07:42,160 --> 23:07:44,800
mas na nossa classe de jogadores

34933
23:07:44,800 --> 23:07:46,720
Estas variáveis de membros vão ser

34934
23:07:46,720 --> 23:07:49,760
Herdado porque um jogador está herdando

34935
23:07:49,760 --> 23:07:52,720
de uma pessoa essa é a sintaxe a fazer

34936
23:07:52,720 --> 23:07:55,920
que, mas mesmo que a classe do jogador tenha um

34937
23:07:55,920 --> 23:07:58,872
pessoa parte dentro dele nós não podemos realmente

34938
23:07:58,872 --> 23:08:02,480
Acesse membros privados de pessoa

34939
23:08:02,480 --> 23:08:05,600
de um objeto de jogador que vamos ver

34940
23:08:05,600 --> 23:08:08,400
Algumas maneiras de contornar isso e

34941
23:08:08,400 --> 23:08:11,040
Um deles é seguir os métodos públicos

34942
23:08:11,040 --> 23:08:13,832
da classe da pessoa para acessar

34943
23:08:13,832 --> 23:08:16,000
partes privadas da pessoa classificam isso

34944
23:08:16,000 --> 23:08:17,600
vai nos dar acesso a estes

34945
23:08:17,600 --> 23:08:20,872
variáveis de membro se você cair em nosso

34946
23:08:20,872 --> 23:08:23,280
operador de saída de fluxo que você está indo

34947
23:08:23,280 --> 23:08:26,000
Veja que estamos usando esses getters aqui

34948
23:08:26,000 --> 23:08:28,480
o parâmetro é um jogador que

34949
23:08:28,480 --> 23:08:31,280
Queremos imprimir, mas para ter acesso

34950
23:08:31,280 --> 23:08:33,680
para os nomes que estamos recebendo o primeiro

34951
23:08:33,680 --> 23:08:36,320
nome e o sobrenome através do nosso

34952
23:08:36,320 --> 23:08:39,040
getters aqui antes de realmente explorarmos

34953
23:08:39,040 --> 23:08:41,600
mais isso eu acho que é um bom

34954
23:08:41,600 --> 23:08:44,080
ideia para ir no arquivo principal cpp e

34955
23:08:44,080 --> 23:08:46,480
criar um objeto de jogador, então vamos

34956
23:08:46,480 --> 23:08:48,400
que vamos dizer p1 e nós somos

34957
23:08:48,400 --> 23:08:50,960
Vou especificar que eles jogam

34958
23:08:50,960 --> 23:08:54,232
basquete por que não está bem para que tenhamos nossos

34959
23:08:54,232 --> 23:08:56,080
objeto do jogador

34960
23:08:56,080 --> 23:08:58,000
e nós podemos realmente fazer tudo o que queremos

34961
23:08:58,000 --> 23:09:00,480
por exemplo, podemos imprimir o

34962
23:09:00,480 --> 23:09:03,040
informações sobre este jogador se

34963
23:09:03,040 --> 23:09:05,600
Você se lembra no jogador que temos um fluxo

34964
23:09:05,600 --> 23:09:07,680
operador de saída que vai imprimir

34965
23:09:07,680 --> 23:09:09,600
Todas as informações

34966
23:09:09,600 --> 23:09:12,720
E aqui temos um problema porque isso

34967
23:09:12,720 --> 23:09:16,000
O cara está tomando os dados por referência

34968
23:09:16,000 --> 23:09:18,232
E esta não é uma referência que este é um

34969
23:09:18,232 --> 23:09:20,552
Objeto temporário que estamos passando

34970
23:09:20,552 --> 23:09:21,512
Aqui

34971
23:09:21,512 --> 23:09:24,552
para que pudéssemos voltar e mudar isso para

34972
23:09:24,552 --> 23:09:27,600
tomar um parâmetro de exibição de string

34973
23:09:27,600 --> 23:09:29,600
Vamos voltar e fazer isso, vamos

34974
23:09:29,600 --> 23:09:32,480
incluir uma visão de string aqui no player e

34975
23:09:32,480 --> 23:09:34,232
Vamos mudar o nosso parâmetro para

34976
23:09:34,232 --> 23:09:37,760
ser std string view por valor e nós somos

34977
23:09:37,760 --> 23:09:40,720
indo fazer isso no arquivo cpp vamos

34978
23:09:40,720 --> 23:09:43,360
Faz isso vamos dizer string std

34979
23:09:43,360 --> 23:09:46,720
Vista e isso deve cuidar do nosso

34980
23:09:46,720 --> 23:09:48,400
O problema aqui você vê que o problema

34981
23:09:48,400 --> 23:09:50,720
vai embora agora que nós temos esse cara nós

34982
23:09:50,720 --> 23:09:53,600
pode imprimi-lo, podemos dizer o esddc para fora

34983
23:09:53,600 --> 23:09:56,400
Jogador e eu coloco a informação para fora

34984
23:09:56,400 --> 23:09:58,552
Tudo bem agora que temos isso, não podemos

34985
23:09:58,552 --> 23:10:01,192
Tente construir nosso programa, vamos

34986
23:10:01,192 --> 23:10:02,872
usar o gcc

34987
23:10:02,872 --> 23:10:05,120
nosso compilador favorito e você está indo

34988
23:10:05,120 --> 23:10:07,280
para ver que temos um problema indefinido

34989
23:10:07,280 --> 23:10:10,400
Referência ao jogador destructor, vamos

34990
23:10:10,400 --> 23:10:12,400
De volta ao cabeçalho e veja que temos

34991
23:10:12,400 --> 23:10:15,680
um destructor, mas provavelmente não colocamos

34992
23:10:15,680 --> 23:10:18,960
um destructor no arquivo cpp, então vamos fazer

34993
23:10:18,960 --> 23:10:22,000
Isso ou porque não estamos fazendo nada

34994
23:10:22,000 --> 23:10:24,160
alocação de memória dinâmica que podemos até

34995
23:10:24,160 --> 23:10:27,040
Acabar completamente este destruidor e

34996
23:10:27,040 --> 23:10:28,720
Nós só vamos usar o único

34997
23:10:28,720 --> 23:10:31,040
O compilador gera para nós isso.

34998
23:10:31,040 --> 23:10:32,080
para ser

34999
23:10:32,080 --> 23:10:34,480
Muito mais fácil de manusear em nosso código, então nós

35000
23:10:34,480 --> 23:10:37,512
pode construir novamente com gcc OK o mundo

35001
23:10:37,512 --> 23:10:40,872
É bom que possamos executar este programa

35002
23:10:40,872 --> 23:10:43,120
e vamos ver se temos uma powershell

35003
23:10:43,120 --> 23:10:44,800
Janela que não vamos trazer

35004
23:10:44,800 --> 23:10:47,600
um novo e vamos correr o galo

35005
23:10:47,600 --> 23:10:49,360
Devemos ver informações sobre o nosso

35006
23:10:49,360 --> 23:10:52,640
jogador, então jogador, o jogo é basquete

35007
23:10:52,640 --> 23:10:55,280
Os nomes são uma pessoa misteriosa porque

35008
23:10:55,280 --> 23:10:58,232
Esses são os dados padrão dos quais herdamos

35009
23:10:58,232 --> 23:11:00,552
Uma pessoa se você voltar para a pessoa que você é

35010
23:11:00,552 --> 23:11:02,232
Vou ver isso

35011
23:11:02,232 --> 23:11:05,280
Os dados padrão no primeiro nome são

35012
23:11:05,280 --> 23:11:08,160
misteriosos os dados padrão no sobrenome

35013
23:11:08,160 --> 23:11:11,280
É pessoa e é o que vemos impresso

35014
23:11:11,280 --> 23:11:12,640
Aqui fora

35015
23:11:12,640 --> 23:11:15,192
em nossa janela powershell quando imprimimos

35016
23:11:15,192 --> 23:11:18,720
informações sobre o nosso objeto de jogador

35017
23:11:18,720 --> 23:11:20,400
Outra coisa que eu quero que você veja é que

35018
23:11:20,400 --> 23:11:23,192
Podemos realmente provar

35019
23:11:23,192 --> 23:11:26,640
que qualquer objeto de jogador vai ter

35020
23:11:26,640 --> 23:11:28,552
Uma pessoa parte disso

35021
23:11:28,552 --> 23:11:31,280
apoiado e isso vai estar armazenando

35022
23:11:31,280 --> 23:11:34,160
a informação que é modelada em nosso

35023
23:11:34,160 --> 23:11:36,720
classe de pessoa e podemos usar um depurador

35024
23:11:36,720 --> 23:11:39,832
para fazer isso para que isso funcione eu vou

35025
23:11:39,832 --> 23:11:43,512
para colocar um ponto de ruptura aqui na linha 8

35026
23:11:43,512 --> 23:11:45,680
que está imprimindo as coisas

35027
23:11:45,680 --> 23:11:48,080
Este ponto de ruptura vai ser atingido

35028
23:11:48,080 --> 23:11:50,800
depois que nosso objeto é configurado e nós podemos

35029
23:11:50,800 --> 23:11:53,920
realmente ver os dados dentro deste cara aqui

35030
23:11:53,920 --> 23:11:55,192
Então o que vamos fazer, vamos

35031
23:11:55,192 --> 23:11:57,680
acertar esta run tab

35032
23:11:57,680 --> 23:11:59,920
e nós vamos usar g plus mais

35033
23:11:59,920 --> 23:12:01,680
usar as ferramentas de depuração que

35034
23:12:01,680 --> 23:12:04,160
vem com gcc porque este é nosso

35035
23:12:04,160 --> 23:12:05,512
favorito, vamos bater o verde

35036
23:12:05,512 --> 23:12:06,872
Botão aqui

35037
23:12:06,872 --> 23:12:09,192
Isto vai começar a nossa depuração

35038
23:12:09,192 --> 23:12:12,000
Sessão de um binário será construído

35039
23:12:12,000 --> 23:12:14,000
e vai ser ligado em nosso

35040
23:12:14,000 --> 23:12:16,160
Debugger e nós vamos acertar uma pausa

35041
23:12:16,160 --> 23:12:17,360
Ponto aqui

35042
23:12:17,360 --> 23:12:19,192
Agora, se você olhar para a esquerda aqui você está

35043
23:12:19,192 --> 23:12:22,232
Vou ver um título que diz moradores locais

35044
23:12:22,232 --> 23:12:24,000
nós vamos expandir isso e nós somos

35045
23:12:24,000 --> 23:12:27,040
Vou ver que o objeto p1 realmente

35046
23:12:27,040 --> 23:12:29,920
Tem uma pessoa parte disso e você vê que

35047
23:12:29,920 --> 23:12:32,000
Código de estúdio visual está sendo útil aqui

35048
23:12:32,000 --> 23:12:34,640
está dizendo que esta é a classe base

35049
23:12:34,640 --> 23:12:36,320
E se expandirmos, vamos ver isso

35050
23:12:36,320 --> 23:12:38,320
temos nossas variáveis de membro que temos

35051
23:12:38,320 --> 23:12:41,360
primeiro nome e sobrenome e este é um

35052
23:12:41,360 --> 23:12:43,680
objeto de jogador que estamos olhando

35053
23:12:43,680 --> 23:12:46,640
Não se esqueça disso e em cima do nosso

35054
23:12:46,640 --> 23:12:49,600
pessoa parte que também temos nosso próprio membro

35055
23:12:49,600 --> 23:12:51,920
variável que é o jogo que jogamos

35056
23:12:51,920 --> 23:12:53,760
E é bem aqui espero que isso

35057
23:12:53,760 --> 23:12:55,120
Prossá para você

35058
23:12:55,120 --> 23:12:58,480
que qualquer objeto de classe derivado está indo

35059
23:12:58,480 --> 23:13:02,232
ter uma parte de base incorporada nele e

35060
23:13:02,232 --> 23:13:04,400
que vai ser a base no topo

35061
23:13:04,400 --> 23:13:06,552
de que a classe derivada vai

35062
23:13:06,552 --> 23:13:08,800
estar construindo seu próprio tanque, este é o

35063
23:13:08,800 --> 23:13:11,192
ideia básica aqui ok agora que você tem

35064
23:13:11,192 --> 23:13:13,512
Vimos isto, vamos matar a nossa depuração

35065
23:13:13,512 --> 23:13:14,640
Sessão de sessão

35066
23:13:14,640 --> 23:13:17,600
e nós vamos ver alguns dos

35067
23:13:17,600 --> 23:13:19,680
Coisas que você precisa ter cuidado quando

35068
23:13:19,680 --> 23:13:21,760
Fazendo herança pública como somos

35069
23:13:21,760 --> 23:13:23,680
Fazendo aqui a primeira coisa que eu quero que você

35070
23:13:23,680 --> 23:13:26,320
Veja é que você não tem acesso a

35071
23:13:26,320 --> 23:13:27,920
as peças privadas

35072
23:13:27,920 --> 23:13:30,320
da classe base se você voltar para

35073
23:13:30,320 --> 23:13:31,760
Pessoa aqui

35074
23:13:31,760 --> 23:13:33,760
Vamos matar isso para que você não seja

35075
23:13:33,760 --> 23:13:36,232
confuso se voltarmos para o nosso pessoal

35076
23:13:36,232 --> 23:13:38,232
classe, vamos ver que o nosso primeiro

35077
23:13:38,232 --> 23:13:41,040
Nome e sobrenome são privados

35078
23:13:41,040 --> 23:13:44,400
Eles querem ser acessíveis a qualquer

35079
23:13:44,400 --> 23:13:45,440
classe de classe

35080
23:13:45,440 --> 23:13:48,640
que faz herança pública como nós somos

35081
23:13:48,640 --> 23:13:50,800
Fazendo aqui eles só vão ser

35082
23:13:50,800 --> 23:13:53,280
Privados, eles vão fazer parte do

35083
23:13:53,280 --> 23:13:56,800
classe, mas a classe derivada teria

35084
23:13:56,800 --> 23:13:59,360
acesso a eles essa é a ideia aqui e

35085
23:13:59,360 --> 23:14:02,552
se formos em nosso operador de fluxo de saída

35086
23:14:02,552 --> 23:14:05,440
e comentar o que temos aqui e

35087
23:14:05,440 --> 23:14:08,160
Tente acessar diretamente esses membros

35088
23:14:08,160 --> 23:14:10,480
variáveis vamos fazer isso eu vou

35089
23:14:10,480 --> 23:14:13,440
Copie o código aqui e coloque isso no topo

35090
23:14:13,440 --> 23:14:16,720
e nós não vamos passar pelo

35091
23:14:16,720 --> 23:14:19,920
getter métodos da classe base que nós

35092
23:14:19,920 --> 23:14:22,960
vai tentar acessar o primeiro nome m

35093
23:14:22,960 --> 23:14:25,120
Vamos voltar e olhar para os nomes para

35094
23:14:25,120 --> 23:14:26,960
as variáveis de membro é o primeiro nome

35095
23:14:26,960 --> 23:14:29,192
e sobrenome vamos usar que estamos indo

35096
23:14:29,192 --> 23:14:31,360
para dizer primeiro nome você vê que através

35097
23:14:31,360 --> 23:14:34,320
intellisense mas tentando acessar isso

35098
23:14:34,320 --> 23:14:36,640
Vai dar-nos squiggly linhas você

35099
23:14:36,640 --> 23:14:38,400
Veja que temos isso em nosso

35100
23:14:38,400 --> 23:14:40,872
autocomplete, mas temos linhas

35101
23:14:40,872 --> 23:14:42,800
Não podemos acessá-los se tentarmos

35102
23:14:42,800 --> 23:14:45,680
compilar o nosso programa vamos fazer isso novamente

35103
23:14:45,680 --> 23:14:48,160
Nós vamos usar gcc e nós vamos

35104
23:14:48,160 --> 23:14:50,232
para obter erros de compilador e o compilador

35105
23:14:50,232 --> 23:14:52,872
Os erros basicamente vão dizer

35106
23:14:52,872 --> 23:14:55,120
O primeiro nome é privado dentro disso

35107
23:14:55,120 --> 23:14:58,160
contexto novamente o significado é que

35108
23:14:58,160 --> 23:15:02,000
O primeiro nome é privado para a classe base

35109
23:15:02,000 --> 23:15:04,640
e nós não temos nenhum negócio acessando isso

35110
23:15:04,640 --> 23:15:07,440
em uma classe derivada que é

35111
23:15:07,440 --> 23:15:09,280
A classe do jogador aqui é esta

35112
23:15:09,280 --> 23:15:12,000
Significado para que não possamos realmente acessar isso

35113
23:15:12,000 --> 23:15:14,480
Ok eu percebo que esta é uma função global

35114
23:15:14,480 --> 23:15:16,872
mas mesmo se tentarmos fazer isso a partir de um

35115
23:15:16,872 --> 23:15:19,440
A função de membro vamos fazer isso a partir de

35116
23:15:19,440 --> 23:15:22,080
um construtor vamos tentar dizer

35117
23:15:22,080 --> 23:15:24,720
Primeiro nome OK eu percebo o acesso que nós

35118
23:15:24,720 --> 23:15:27,280
estão tentando fazer a partir do fluxo de saída

35119
23:15:27,280 --> 23:15:29,440
Operador não é um bom exemplo

35120
23:15:29,440 --> 23:15:32,320
porque este não é uma função de membro

35121
23:15:32,320 --> 23:15:35,120
é uma função global independente, então nós

35122
23:15:35,120 --> 23:15:37,280
Pode tentar alterar o primeiro nome e

35123
23:15:37,280 --> 23:15:38,960
sobrenome do construtor para

35124
23:15:38,960 --> 23:15:40,960
exemplo e vamos ver que isso

35125
23:15:40,960 --> 23:15:42,960
também não vai funcionar para que possamos

35126
23:15:42,960 --> 23:15:45,680
tirar isso e nós vamos

35127
23:15:45,680 --> 23:15:48,400
remover nossa vírgula de bloco para que vamos

35128
23:15:48,400 --> 23:15:51,120
Tira o que acabamos de fazer aqui

35129
23:15:51,120 --> 23:15:53,120
e nós vamos descomentar o nosso bem

35130
23:15:53,120 --> 23:15:55,512
código aqui que está usando getter membro

35131
23:15:55,512 --> 23:15:57,680
funções da classe base e nós somos

35132
23:15:57,680 --> 23:15:59,680
Vou tentar e mudar

35133
23:15:59,680 --> 23:16:01,920
O primeiro nome e sobrenome do

35134
23:16:01,920 --> 23:16:05,280
classe base e transformá-los em nosso

35135
23:16:05,280 --> 23:16:07,760
construtor da classe derivada que somos

35136
23:16:07,760 --> 23:16:09,440
Vou tentar mudar, por exemplo, o

35137
23:16:09,440 --> 23:16:12,000
primeiro nome e fazê-lo john e nós somos

35138
23:16:12,000 --> 23:16:14,232
Vou tomar o sobrenome e mudar

35139
23:16:14,232 --> 23:16:15,512
Isso para

35140
23:16:15,512 --> 23:16:18,000
neve vamos fazer isso e vamos voltar e

35141
23:16:18,000 --> 23:16:20,800
Certifique-se de que temos os nomes corretos

35142
23:16:20,800 --> 23:16:22,480
e você vê que nós temos linhas piggly

35143
23:16:22,480 --> 23:16:24,720
nós realmente não podemos fazer isso porque estes

35144
23:16:24,720 --> 23:16:27,360
são membros privados da classe base

35145
23:16:27,360 --> 23:16:30,400
e não podemos acessá-los de um

35146
23:16:30,400 --> 23:16:33,280
classe que eles fazem parte da classe do jogador

35147
23:16:33,280 --> 23:16:35,280
que é uma classe derivada, mas nós não

35148
23:16:35,280 --> 23:16:37,680
ter acesso a eles, não podemos modificá-los

35149
23:16:37,680 --> 23:16:40,080
ou fazer qualquer coisa que não podemos ler a partir deles

35150
23:16:40,080 --> 23:16:41,760
Não podemos escrever a partir deles este é o

35151
23:16:41,760 --> 23:16:43,920
mensagem aqui se tentarmos construir o nosso

35152
23:16:43,920 --> 23:16:46,232
programa vamos usar gcc para fazer

35153
23:16:46,232 --> 23:16:47,192
que

35154
23:16:47,192 --> 23:16:49,512
vamos obter erros de compilador e

35155
23:16:49,512 --> 23:16:53,360
uh vamos ver o erro do compilador que o recebemos

35156
23:16:53,360 --> 23:16:55,680
novamente o erro é o primeiro nome e

35157
23:16:55,680 --> 23:16:58,800
O sobrenome é privado para a classe base

35158
23:16:58,800 --> 23:17:01,440
e não temos nenhum negócio de acesso a eles

35159
23:17:01,440 --> 23:17:03,680
de uma classe derivada como temos aqui

35160
23:17:03,680 --> 23:17:06,160
então, se você precisar de qualquer tipo de acesso a um

35161
23:17:06,160 --> 23:17:07,192
Privado

35162
23:17:07,192 --> 23:17:10,320
membro da classe base que você terá

35163
23:17:10,320 --> 23:17:11,512
para passar por aí

35164
23:17:11,512 --> 23:17:13,512
Algo que é público e um bom

35165
23:17:13,512 --> 23:17:15,832
O exemplo são os métodos getter que são

35166
23:17:15,832 --> 23:17:17,600
Vou permitir que você

35167
23:17:17,600 --> 23:17:20,080
Mude as coisas, por exemplo, se quisermos

35168
23:17:20,080 --> 23:17:22,480
a capacidade de alterar o primeiro nome e

35169
23:17:22,480 --> 23:17:24,232
o sobrenome que podemos configurar um monte de

35170
23:17:24,232 --> 23:17:26,320
Setter métodos vamos fazer isso nós vamos

35171
23:17:26,320 --> 23:17:28,800
para dizer setters e nós vamos dizer

35172
23:17:28,800 --> 23:17:29,832
Vazio de

35173
23:17:29,832 --> 23:17:30,872
conjunto

35174
23:17:30,872 --> 23:17:33,192
primeiro nome e vamos passar um

35175
23:17:33,192 --> 23:17:35,760
std visão de força

35176
23:17:35,760 --> 23:17:37,680
Vamos fazer isso nós vamos dizer corda

35177
23:17:37,680 --> 23:17:41,120
ver aqui fn para o primeiro nome

35178
23:17:41,120 --> 23:17:44,552
Isso vai modificar nossa classe, então nós

35179
23:17:44,552 --> 23:17:46,800
não vai marcar isso como um costume

35180
23:17:46,800 --> 23:17:48,400
Função de membro e nós vamos dizer

35181
23:17:48,400 --> 23:17:49,680
o primeiro nome

35182
23:17:49,680 --> 23:17:51,120
iguais

35183
23:17:51,120 --> 23:17:53,832
fn isso vai fazer

35184
23:17:53,832 --> 23:17:56,872
Vamos montar um setter para o

35185
23:17:56,872 --> 23:17:59,440
sobrenome definido e vamos passar um

35186
23:17:59,440 --> 23:18:01,760
string view aqui e nós vamos dizer

35187
23:18:01,760 --> 23:18:04,232
ln para o sobrenome novamente este não é

35188
23:18:04,232 --> 23:18:06,400
vai ser uma função de membro do elenco, então

35189
23:18:06,400 --> 23:18:09,280
Vamos dizer sobrenome e podemos

35190
23:18:09,280 --> 23:18:13,280
Passe em ln como o nosso novo nome aqui agora que

35191
23:18:13,280 --> 23:18:16,320
nós temos esse fim que podemos tirar

35192
23:18:16,320 --> 23:18:18,960
Essas coisas que temos no construtor

35193
23:18:18,960 --> 23:18:21,600
Eu acho que o trabalho para isso está feito e

35194
23:18:21,600 --> 23:18:23,280
Isso lhe dará um compilador

35195
23:18:23,280 --> 23:18:26,400
erros e podemos ir em nosso cpp principal

35196
23:18:26,400 --> 23:18:28,080
arquivar e alterar os nomes para isso

35197
23:18:28,080 --> 23:18:31,440
pessoa aqui, por exemplo, podemos dizer p1

35198
23:18:31,440 --> 23:18:32,320
conjunto

35199
23:18:32,320 --> 23:18:35,600
Primeiro nome vamos passar John e

35200
23:18:35,600 --> 23:18:37,440
Também podemos definir o sobrenome que somos

35201
23:18:37,440 --> 23:18:40,160
indo para dizer p1 set

35202
23:18:40,160 --> 23:18:43,040
sobrenome e vamos passar pela neve

35203
23:18:43,040 --> 23:18:44,960
E isso vai fazer se construirmos e

35204
23:18:44,960 --> 23:18:46,800
executar este programa vamos ver que

35205
23:18:46,800 --> 23:18:48,720
O mundo vai ser bom isto

35206
23:18:48,720 --> 23:18:50,232
O primeiro passo

35207
23:18:50,232 --> 23:18:52,232
E se corrermos, devemos ver o

35208
23:18:52,232 --> 23:18:54,552
informações impressas para fora que queremos participar

35209
23:18:54,552 --> 23:18:57,512
neve impressa para fora e o jogo deve ser

35210
23:18:57,512 --> 23:18:58,800
basquete

35211
23:18:58,800 --> 23:19:01,440
vamos limpar e correr galo nós estamos indo

35212
23:19:01,440 --> 23:19:04,320
para ver que os dados estão aqui no nome

35213
23:19:04,320 --> 23:19:06,720
Os nomes são jon snow e nós temos o nosso

35214
23:19:06,720 --> 23:19:09,600
Jogo para ser basquete aqui, mas note

35215
23:19:09,600 --> 23:19:12,160
Estes são métodos básicos e nós somos

35216
23:19:12,160 --> 23:19:15,680
chamando-os de um objeto derivado e

35217
23:19:15,680 --> 23:19:18,480
Esta é a prova viva de que o público

35218
23:19:18,480 --> 23:19:20,720
Os membros da classe base estão indo para

35219
23:19:20,720 --> 23:19:23,360
ser herdado e utilizável

35220
23:19:23,360 --> 23:19:26,960
de uma classe derivada que faz o público

35221
23:19:26,960 --> 23:19:29,040
herança como estamos fazendo aqui e

35222
23:19:29,040 --> 23:19:31,280
Esta é realmente a mensagem principal que você pode

35223
23:19:31,280 --> 23:19:33,600
herdar publicamente e ter acesso a

35224
23:19:33,600 --> 23:19:36,320
coisas públicas da classe base e do uso

35225
23:19:36,320 --> 23:19:39,760
eles em sua classe derivada, mas privado

35226
23:19:39,760 --> 23:19:42,080
Os dados ainda serão privados para o

35227
23:19:42,080 --> 23:19:44,640
classe base que você não pode usar isso em um

35228
23:19:44,640 --> 23:19:47,120
classe derivada esta é a mensagem aqui

35229
23:19:47,120 --> 23:19:49,040
E isso é realmente tudo que eu queria que você

35230
23:19:49,040 --> 23:19:52,000
Veja nesta palestra que o grande é

35231
23:19:52,000 --> 23:19:54,160
notar a sintaxe que você usa para fazer

35232
23:19:54,160 --> 23:19:57,440
herança e se você fizer isso o

35233
23:19:57,440 --> 23:19:59,832
A classe de jogadores será derivada de

35234
23:19:59,832 --> 23:20:00,800
Pessoa

35235
23:20:00,800 --> 23:20:03,920
e terá uma parte da pessoa

35236
23:20:03,920 --> 23:20:06,232
Assado dentro e nós podemos construir sobre isso

35237
23:20:06,232 --> 23:20:09,040
fundação e, por exemplo, colocar em nosso

35238
23:20:09,040 --> 23:20:11,440
próprias variáveis de membros e fazer todos os tipos de

35239
23:20:11,440 --> 23:20:12,960
coisas loucas

35240
23:20:12,960 --> 23:20:14,960
Coisas públicas da classe base são

35241
23:20:14,960 --> 23:20:17,680
vai ser herdado e utilizável de um

35242
23:20:17,680 --> 23:20:20,160
A classe derivada acabamos de ver isso por

35243
23:20:20,160 --> 23:20:22,640
montando um grupo de setters que vivem

35244
23:20:22,640 --> 23:20:25,360
no âmbito público da classe base

35245
23:20:25,360 --> 23:20:28,552
E eles eram utilizáveis de fora

35246
23:20:28,552 --> 23:20:31,680
Porque eles serão herdados como públicos

35247
23:20:31,680 --> 23:20:34,400
em uma classe derivada para que possamos realmente chamar

35248
23:20:34,400 --> 23:20:36,480
esses métodos e usá-los a partir do

35249
23:20:36,480 --> 23:20:38,720
Como estamos fazendo aqui, mas

35250
23:20:38,720 --> 23:20:41,120
Dados privados da classe base não são

35251
23:20:41,120 --> 23:20:43,600
vai ser acessível e utilizável a partir de

35252
23:20:43,600 --> 23:20:46,232
classe derivada e vimos isso ao definir

35253
23:20:46,232 --> 23:20:48,320
Este pedaço de código no construtor

35254
23:20:48,320 --> 23:20:50,000
de jogador isto vai dar-nos um

35255
23:20:50,000 --> 23:20:52,480
Erro do compilador dizendo esse primeiro nome

35256
23:20:52,480 --> 23:20:55,280
e o sobrenome são privados para a base

35257
23:20:55,280 --> 23:20:57,760
classe, vamos parar por aqui neste

35258
23:20:57,760 --> 23:20:59,360
palestra no próximo, vamos

35259
23:20:59,360 --> 23:21:01,440
Aprenda sobre outro tipo de acesso

35260
23:21:01,440 --> 23:21:04,552
specifier que temos em c plus plus e

35261
23:21:04,552 --> 23:21:06,640
que é protegido

35262
23:21:06,640 --> 23:21:08,872
então vá em frente e termine aqui e conheça

35263
23:21:08,872 --> 23:21:10,320
eu lá

35264
23:21:10,320 --> 23:21:12,000
Nesta palestra vamos aprender

35265
23:21:12,000 --> 23:21:15,920
sobre o especificador de acesso protegido você

35266
23:21:15,920 --> 23:21:18,720
pode usar em sua classe c plus plus

35267
23:21:18,720 --> 23:21:20,640
e nós vamos estar reutilizando o mesmo

35268
23:21:20,640 --> 23:21:22,232
Um exemplo da última palestra que somos

35269
23:21:22,232 --> 23:21:23,920
ter uma classe de pessoa, que é

35270
23:21:23,920 --> 23:21:26,552
indo agir como nossa classe base e nós somos

35271
23:21:26,552 --> 23:21:28,872
Vou derivar dessa pessoa

35272
23:21:28,872 --> 23:21:32,080
e criar uma nova classe chamada jogador

35273
23:21:32,080 --> 23:21:33,760
A classe do jogador vai ter um

35274
23:21:33,760 --> 23:21:35,920
pessoa parte assada em

35275
23:21:35,920 --> 23:21:38,552
e nós podemos usar isso como uma base para

35276
23:21:38,552 --> 23:21:40,960
construir outros fãs na classe de jogadores para

35277
23:21:40,960 --> 23:21:42,800
Exemplo podemos criar nosso próprio membro

35278
23:21:42,800 --> 23:21:45,120
variáveis e fazer todos os tipos de loucura

35279
23:21:45,120 --> 23:21:47,600
Coisas e esta é a configuração que usamos em

35280
23:21:47,600 --> 23:21:49,832
A última palestra que estabelecemos uma pessoa

35281
23:21:49,832 --> 23:21:52,872
classe e nossos membros eram privados como

35282
23:21:52,872 --> 23:21:55,192
você viu aqui, mas na última palestra nós

35283
23:21:55,192 --> 23:21:56,320
Viu que

35284
23:21:56,320 --> 23:21:58,320
Variáveis de membros privados não estão indo

35285
23:21:58,320 --> 23:22:01,192
para ser acessível e utilizável de

35286
23:22:01,192 --> 23:22:05,192
classes que fazem herança pública e

35287
23:22:05,192 --> 23:22:07,680
às vezes queremos membros da base

35288
23:22:07,680 --> 23:22:10,232
classe para pelo menos ser acessível e

35289
23:22:10,232 --> 23:22:14,320
utilizável de uma classe derivada, mas ainda assim ser

35290
23:22:14,320 --> 23:22:17,280
inacessível do lado de fora e nós podemos

35291
23:22:17,280 --> 23:22:20,160
conseguir isso usando o acesso protegido

35292
23:22:20,160 --> 23:22:22,640
Especificador para que, por exemplo, possamos mudar

35293
23:22:22,640 --> 23:22:24,800
O especificador de acesso do nosso membro

35294
23:22:24,800 --> 23:22:27,760
variáveis do privado ao protegido e

35295
23:22:27,760 --> 23:22:30,320
No momento em que fizermos isso, seremos capazes

35296
23:22:30,320 --> 23:22:32,960
para acessar, por exemplo, leia a partir de e

35297
23:22:32,960 --> 23:22:35,920
Escreva nestas variáveis de membros a partir de

35298
23:22:35,920 --> 23:22:38,552
classes derivadas, por exemplo, vamos

35299
23:22:38,552 --> 23:22:41,440
ser capaz de modificar esses caras de um

35300
23:22:41,440 --> 23:22:44,320
construtor da classe derivada e nós

35301
23:22:44,320 --> 23:22:46,232
Pensava que isso era impossível a partir de

35302
23:22:46,232 --> 23:22:48,960
A última palestra, mas ainda queremos ser

35303
23:22:48,960 --> 23:22:51,440
capaz de usá-los do exterior de

35304
23:22:51,440 --> 23:22:54,080
nossa classe derivada que é pessoa aqui

35305
23:22:54,080 --> 23:22:55,600
Vamos fazer o público

35306
23:22:55,600 --> 23:22:57,920
Herança como da última palestra

35307
23:22:57,920 --> 23:23:00,400
mas agora que o nosso membro variáveis no

35308
23:23:00,400 --> 23:23:03,192
A classe base está protegida, teremos

35309
23:23:03,192 --> 23:23:05,360
A capacidade de fazer o que quisermos

35310
23:23:05,360 --> 23:23:07,832
eles na classe derivada e quando

35311
23:23:07,832 --> 23:23:10,720
Digamos na classe derivada que queremos dizer de

35312
23:23:10,720 --> 23:23:13,280
qualquer método da classe derivada para

35313
23:23:13,280 --> 23:23:15,120
Um exemplo, podemos ir em nosso construtor

35314
23:23:15,120 --> 23:23:18,320
Aqui e depois definir os dados no membro

35315
23:23:18,320 --> 23:23:20,640
variáveis da classe base e isso é

35316
23:23:20,640 --> 23:23:23,192
indo para o trabalho como nós vamos ver

35317
23:23:23,192 --> 23:23:25,040
em um minuto agora que você sabe disso, nós somos

35318
23:23:25,040 --> 23:23:26,960
indo para a cabeça para o código de estúdio visual

35319
23:23:26,960 --> 23:23:29,040
e jogar com isso um pouco mais bem

35320
23:23:29,040 --> 23:23:31,440
novamente nossas variáveis de membro da base

35321
23:23:31,440 --> 23:23:34,080
A classe vai ser protegida

35322
23:23:34,080 --> 23:23:36,552
Tudo bem para que possamos realmente dizer que aqui

35323
23:23:36,552 --> 23:23:38,800
Vamos dizer protegido e no momento

35324
23:23:38,800 --> 23:23:41,440
fazer isso eles vão ser acessíveis

35325
23:23:41,440 --> 23:23:44,080
e utilizável de uma classe derivada assim

35326
23:23:44,080 --> 23:23:46,232
A classe derivada que teremos a primeira

35327
23:23:46,232 --> 23:23:48,160
Nome, por exemplo

35328
23:23:48,160 --> 23:23:50,320
Assim, da classe derivada, teremos

35329
23:23:50,320 --> 23:23:52,960
nossos membros assados, então teremos um

35330
23:23:52,960 --> 23:23:55,440
sobrenome e o primeiro nome e porque

35331
23:23:55,440 --> 23:23:57,832
são protegidos na classe base e

35332
23:23:57,832 --> 23:24:00,552
Estamos fazendo herança pública, nós vamos

35333
23:24:00,552 --> 23:24:02,800
ser capaz, por exemplo, de definir dados em

35334
23:24:02,800 --> 23:24:04,720
Estas variáveis de membro de um

35335
23:24:04,720 --> 23:24:06,480
classe e isso vai ser

35336
23:24:06,480 --> 23:24:08,480
muito legal agora que você sabe disso, nós somos

35337
23:24:08,480 --> 23:24:10,552
indo para a cabeça para o código de estúdio visual

35338
23:24:10,552 --> 23:24:12,400
e brinque conosco um pouco mais bem, então

35339
23:24:12,400 --> 23:24:15,600
Aqui estamos nós em nosso aqui estamos em nosso

35340
23:24:15,600 --> 23:24:17,832
pasta de trabalho o projeto atual é

35341
23:24:17,832 --> 23:24:20,160
Membros protegidos que vamos pegar

35342
23:24:20,160 --> 23:24:22,320
o código da última palestra e reutilização

35343
23:24:22,320 --> 23:24:24,720
porque isso vai ter o nosso

35344
23:24:24,720 --> 23:24:27,680
Hierarquia de herança já configurada nós

35345
23:24:27,680 --> 23:24:30,552
terá nossa classe de pessoa e jogador

35346
23:24:30,552 --> 23:24:33,120
e nós podemos reutilizá-los, teremos o nosso

35347
23:24:33,120 --> 23:24:35,760
classes de pessoas e jogadores e nós vamos

35348
23:24:35,760 --> 23:24:38,960
reutilizá-los sem precisar completamente

35349
23:24:38,960 --> 23:24:40,960
cei

35350
23:24:40,960 --> 23:24:43,832
Salve-nos alguns segundos, então vamos

35351
23:24:43,832 --> 23:24:45,832
Coloque-os aqui

35352
23:24:45,832 --> 23:24:47,832
E nós vamos abrir este pequeno rapaz

35353
23:24:47,832 --> 23:24:49,600
em código de estúdio visual arrastando e

35354
23:24:49,600 --> 23:24:51,512
soltando aqui e nós teremos o nosso

35355
23:24:51,512 --> 23:24:53,760
classe de pessoa que vai ser o

35356
23:24:53,760 --> 23:24:56,320
classe base que vai ter o nosso membro

35357
23:24:56,320 --> 23:24:58,400
Variações que serão privadas

35358
23:24:58,400 --> 23:25:00,640
A partir da última palestra teremos a

35359
23:25:00,640 --> 23:25:02,400
Classe de jogadores que vai ser

35360
23:25:02,400 --> 23:25:05,440
Herdado publicamente do jogador

35361
23:25:05,440 --> 23:25:07,192
teremos uma classe de jogadores que

35362
23:25:07,192 --> 23:25:09,512
vai herdar publicamente de

35363
23:25:09,512 --> 23:25:12,080
pessoa e nós temos o nosso arquivo cpp principal

35364
23:25:12,080 --> 23:25:14,320
que vai configurar um objeto de jogador

35365
23:25:14,320 --> 23:25:16,000
e tentar usá-lo e vamos ver

35366
23:25:16,000 --> 23:25:19,440
Como isso acontece nesta palestra, então o que nós

35367
23:25:19,440 --> 23:25:21,360
Quer fazer é mudar o acesso

35368
23:25:21,360 --> 23:25:24,640
especificador na classe base e fazer

35369
23:25:24,640 --> 23:25:26,960
que protegemos podemos fazer isso, podemos dizer

35370
23:25:26,960 --> 23:25:29,360
Proteja-o e isso vai mudar um

35371
23:25:29,360 --> 23:25:32,080
Poucas coisas sobre esta classe o que é isso

35372
23:25:32,080 --> 23:25:33,192
Vou fazer isso

35373
23:25:33,192 --> 23:25:35,760
Se você fizer herança pública a partir deste

35374
23:25:35,760 --> 23:25:38,480
classe de pessoa que você terá a capacidade

35375
23:25:38,480 --> 23:25:40,640
Para fazer o que quiser com estes

35376
23:25:40,640 --> 23:25:43,680
variáveis de membro de uma classe derivada

35377
23:25:43,680 --> 23:25:45,760
você terá a capacidade de escrever em

35378
23:25:45,760 --> 23:25:47,680
essas variáveis de membro e alterar o

35379
23:25:47,680 --> 23:25:50,080
dados que temos dentro de você também

35380
23:25:50,080 --> 23:25:52,232
ter a capacidade de ler a partir deles e

35381
23:25:52,232 --> 23:25:54,232
Isso é algo que não poderíamos fazer a partir do

35382
23:25:54,232 --> 23:25:56,720
última palestra e isso pode ser útil

35383
23:25:56,720 --> 23:25:58,640
às vezes outra coisa que você deveria saber

35384
23:25:58,640 --> 23:26:01,040
é que esses membros ainda não

35385
23:26:01,040 --> 23:26:03,600
Vai ser acessível de fora

35386
23:26:03,600 --> 23:26:06,720
Assim, do ponto de vista do principal

35387
23:26:06,720 --> 23:26:08,872
função, por exemplo, aqui estão indo

35388
23:26:08,872 --> 23:26:11,600
Comportar-se como se fossem privados porque

35389
23:26:11,600 --> 23:26:13,600
Querem ser acessíveis a partir do

35390
23:26:13,600 --> 23:26:16,872
Fora eles só serão acessíveis e

35391
23:26:16,872 --> 23:26:20,480
Modificável das classes derivadas

35392
23:26:20,480 --> 23:26:23,040
que fazem herança pública, isso é

35393
23:26:23,040 --> 23:26:25,680
É muito importante entender agora que

35394
23:26:25,680 --> 23:26:27,920
nós temos isso nós podemos realmente fazer todos os tipos

35395
23:26:27,920 --> 23:26:30,480
de coisas loucas, por exemplo, podemos entrar

35396
23:26:30,480 --> 23:26:33,280
nosso construtor de jogadores e comentários

35397
23:26:33,280 --> 23:26:35,192
O que não estava funcionando desde o último

35398
23:26:35,192 --> 23:26:38,232
palestra e isso vai funcionar agora, então

35399
23:26:38,232 --> 23:26:40,320
Vamos descomentar isso e nós vamos

35400
23:26:40,320 --> 23:26:42,080
Veja que as linhas malucas vão

35401
23:26:42,080 --> 23:26:45,120
ir embora e se construirmos um objeto de jogador

35402
23:26:45,120 --> 23:26:47,192
usando este construtor, vamos

35403
23:26:47,192 --> 23:26:50,000
ver que nós vamos ter jon neve em

35404
23:26:50,000 --> 23:26:52,480
mesmo se não definirmos usando os setters

35405
23:26:52,480 --> 23:26:54,400
da classe base para que possamos tomar estes

35406
23:26:54,400 --> 23:26:55,360
para fora.

35407
23:26:55,360 --> 23:26:57,360
e se imprimirmos informações sobre isso

35408
23:26:57,360 --> 23:26:59,120
jogador, vamos ver o jogo para ser

35409
23:26:59,120 --> 23:27:01,920
O basquete e os nomes vão ser

35410
23:27:01,920 --> 23:27:05,760
john neve porque estamos montando isso

35411
23:27:05,760 --> 23:27:08,080
no construtor do jogador que não é

35412
23:27:08,080 --> 23:27:10,640
mais que não vai mais ser o

35413
23:27:10,640 --> 23:27:13,832
dados que obtemos do construtor de um

35414
23:27:13,832 --> 23:27:17,192
pessoa objeto que estava aqui

35415
23:27:17,192 --> 23:27:20,480
na classe base, vamos tentar construir e

35416
23:27:20,480 --> 23:27:22,720
execute este programa para que você possa realmente

35417
23:27:22,720 --> 23:27:25,832
Veja isso, acabei de usar o clã aqui, mas é

35418
23:27:25,832 --> 23:27:28,400
Também indo trabalhar não é grande coisa aqui o

35419
23:27:28,400 --> 23:27:31,512
A construção vai ser boa nós podemos limpar

35420
23:27:31,512 --> 23:27:34,000
e trazer uma janela powershell nós podemos

35421
23:27:34,000 --> 23:27:36,080
Use para executar este programa que vamos

35422
23:27:36,080 --> 23:27:37,760
Diga galo e você vai ver isso

35423
23:27:37,760 --> 23:27:40,000
O jogador vai ser

35424
23:27:40,000 --> 23:27:42,320
tendo a informação que o jogo está indo

35425
23:27:42,320 --> 23:27:44,640
para ser basquete, os nomes vão

35426
23:27:44,640 --> 23:27:48,080
ser jon neve e estamos a definir estes dados

35427
23:27:48,080 --> 23:27:50,552
de uma classe derivada e temos a

35428
23:27:50,552 --> 23:27:53,360
capacidade de fazer isso porque esses membros

35429
23:27:53,360 --> 23:27:56,720
estão agora protegidos na classe base, então

35430
23:27:56,720 --> 23:27:59,120
são acessíveis e utilizáveis a partir de

35431
23:27:59,120 --> 23:28:00,640
classe derivada

35432
23:28:00,640 --> 23:28:02,400
Agora que temos essa capacidade que podemos

35433
23:28:02,400 --> 23:28:06,080
realmente mudar a forma como a nossa classe, pelo menos

35434
23:28:06,080 --> 23:28:08,400
classe de obras derivadas para os quais vamos

35435
23:28:08,400 --> 23:28:12,400
alterá-lo para ter mais dois parâmetros

35436
23:28:12,400 --> 23:28:14,400
E nós vamos passar o primeiro nome

35437
23:28:14,400 --> 23:28:17,360
e o último nome e passar esses dados

35438
23:28:17,360 --> 23:28:20,552
de volta para a classe base, definindo o

35439
23:28:20,552 --> 23:28:22,552
dados no corpo do construtor este

35440
23:28:22,552 --> 23:28:24,640
vai funcionar, então vamos adicionar o nosso

35441
23:28:24,640 --> 23:28:26,960
parâmetros, vamos dizer string std

35442
23:28:26,960 --> 23:28:28,080
A visualização

35443
23:28:28,080 --> 23:28:30,160
E isso vai ser

35444
23:28:30,160 --> 23:28:32,800
Primeiro nome param e nós vamos colocar

35445
23:28:32,800 --> 23:28:34,800
em outro que também vai ser

35446
23:28:34,800 --> 23:28:37,360
um parâmetro de exibição de string e está indo

35447
23:28:37,360 --> 23:28:39,920
para ser sobrenome param, podemos dizer que

35448
23:28:39,920 --> 23:28:42,000
e nós vamos pular em nosso

35449
23:28:42,000 --> 23:28:44,552
implementação, vamos pegar o que nós apenas

35450
23:28:44,552 --> 23:28:46,640
E acrescentou porque precisaremos colocar isso

35451
23:28:46,640 --> 23:28:50,760
em nosso arquivo cpp vamos entrar

35452
23:28:50,760 --> 23:28:53,120
Player.cpp e vamos adicionar isso

35453
23:28:53,120 --> 23:28:55,600
dados que vamos colocar isso aqui

35454
23:28:55,600 --> 23:28:58,000
nós podemos fechar a barra lateral esquerda para ter

35455
23:28:58,000 --> 23:29:00,640
Um pouco mais de espaço para respirar e depois estamos

35456
23:29:00,640 --> 23:29:03,280
Vou não fazer

35457
23:29:03,280 --> 23:29:05,360
uma lista inicializadora aqui porque isso é

35458
23:29:05,360 --> 23:29:07,280
Realmente vamos ser inúteis nós somos

35459
23:29:07,280 --> 23:29:10,232
mudar os dados no corpo de qualquer maneira, então o que

35460
23:29:10,232 --> 23:29:11,280
nós podemos fazer

35461
23:29:11,280 --> 23:29:14,400
é dizer jogo param ou um jogo e nós somos

35462
23:29:14,400 --> 23:29:15,680
Vou dizer

35463
23:29:15,680 --> 23:29:18,232
gamipuram eu realmente sinto muito que eu não sou

35464
23:29:18,232 --> 23:29:21,040
seguindo a mesma convenção para o

35465
23:29:21,040 --> 23:29:23,832
Nomeação de minhas variáveis de membro, mas podemos

35466
23:29:23,832 --> 23:29:26,320
mude isso mais tarde, então digamos primeiro

35467
23:29:26,320 --> 23:29:29,120
Nome vamos passar no primeiro nome

35468
23:29:29,120 --> 23:29:31,360
carneiro e para o sobrenome vamos

35469
23:29:31,360 --> 23:29:33,760
Diga o sobrenome param e que vai

35470
23:29:33,760 --> 23:29:36,640
Agora temos a capacidade de ir no

35471
23:29:36,640 --> 23:29:40,552
arquivo cpp principal e criar objetos do player

35472
23:29:40,552 --> 23:29:42,720
e especificar o primeiro nome e o último

35473
23:29:42,720 --> 23:29:45,120
Nome e isso vai ser muito mais

35474
23:29:45,120 --> 23:29:47,192
Flexível, então vamos voltar para o

35475
23:29:47,192 --> 23:29:50,480
construtor e ver a ordem do nosso

35476
23:29:50,480 --> 23:29:53,920
parâmetros do primeiro nome do primeiro nome do jogo assim

35477
23:29:53,920 --> 23:29:56,872
Podemos vir aqui e dizer que o primeiro nome é

35478
23:29:56,872 --> 23:29:58,080
Vou ser

35479
23:29:58,080 --> 23:30:00,232
John e o último nome vai ser

35480
23:30:00,232 --> 23:30:02,400
neve e se construirmos e corrermos, vamos

35481
23:30:02,400 --> 23:30:04,552
para ver as informações impressas aqui

35482
23:30:04,552 --> 23:30:06,480
E agora temos a flexibilidade para ser

35483
23:30:06,480 --> 23:30:08,480
capaz de especificar isso

35484
23:30:08,480 --> 23:30:10,640
em um construtor e isso vai

35485
23:30:10,640 --> 23:30:13,680
fazer o trabalho de construir nossos objetos

35486
23:30:13,680 --> 23:30:16,720
Muito mais fácil e podemos encaminhar esses dados

35487
23:30:16,720 --> 23:30:19,360
de volta para a classe base usando o

35488
23:30:19,360 --> 23:30:22,000
Mecanismo protegido que acabamos de aprender

35489
23:30:22,000 --> 23:30:23,760
sobre esta palestra e isso é realmente

35490
23:30:23,760 --> 23:30:26,080
legal, então vamos construir vamos passar

35491
23:30:26,080 --> 23:30:28,800
isso através do gcc e o mundo está indo

35492
23:30:28,800 --> 23:30:31,512
Para ser bom podemos limpar e correr galo

35493
23:30:31,512 --> 23:30:33,280
Vamos ver que os dados são

35494
23:30:33,280 --> 23:30:35,600
Passando de volta para a classe base este é

35495
23:30:35,600 --> 23:30:36,640
Trabalhando

35496
23:30:36,640 --> 23:30:38,872
muito bem bem, então isso é realmente tudo que eu

35497
23:30:38,872 --> 23:30:41,600
Queria que você visse esta palestra que podemos

35498
23:30:41,600 --> 23:30:44,080
configurar variáveis de membros protegidos e

35499
23:30:44,080 --> 23:30:45,680
serão acessíveis e

35500
23:30:45,680 --> 23:30:49,040
utilizáveis de qualquer classe derivada que

35501
23:30:49,040 --> 23:30:52,000
herança pública, mas eles querem ser

35502
23:30:52,000 --> 23:30:54,640
acessível do lado de fora, então se você

35503
23:30:54,640 --> 23:30:58,232
Tente e, por exemplo, diga p1 e diga

35504
23:30:58,232 --> 23:31:01,120
primeiro nome e tentar mudar isso para

35505
23:31:01,120 --> 23:31:02,872
algo mais, digamos daniel para

35506
23:31:02,872 --> 23:31:04,800
exemplo que você vai ter compilador

35507
23:31:04,800 --> 23:31:07,280
erros porque isso não vai funcionar

35508
23:31:07,280 --> 23:31:09,040
então vamos tentar construir e mostrar-lhe o

35509
23:31:09,040 --> 23:31:11,832
Erro do compilador bem, então os membros protegidos

35510
23:31:11,832 --> 23:31:14,400
Não são acessíveis a partir do exterior

35511
23:31:14,400 --> 23:31:16,552
Eles serão acessíveis a partir de

35512
23:31:16,552 --> 23:31:19,760
classes derivadas ou para ser mais específico

35513
23:31:19,760 --> 23:31:22,640
Eles serão acessíveis a partir de

35514
23:31:22,640 --> 23:31:25,680
os membros da classe derivada e por

35515
23:31:25,680 --> 23:31:27,600
membros i significam funções de membro porque

35516
23:31:27,600 --> 23:31:29,360
É onde você vai acessar e

35517
23:31:29,360 --> 23:31:32,080
modificando as coisas, então vamos voltar para o

35518
23:31:32,080 --> 23:31:35,360
arquivo cpp principal e remover isso

35519
23:31:35,360 --> 23:31:37,600
E isso é realmente tudo que eu queria compartilhar

35520
23:31:37,600 --> 23:31:39,440
com você e espero que você tenha encontrado isso

35521
23:31:39,440 --> 23:31:42,320
palestra interessante, vamos parar

35522
23:31:42,320 --> 23:31:43,760
Aqui neste um

35523
23:31:43,760 --> 23:31:45,600
e no próximo vamos ampliar

35524
23:31:45,600 --> 23:31:48,800
na sintaxe aqui que estamos usando para

35525
23:31:48,800 --> 23:31:51,832
derivam de outras classes que acabamos de fazer

35526
23:31:51,832 --> 23:31:54,080
A herança pública aqui, mas na

35527
23:31:54,080 --> 23:31:55,680
Próximo palestra vamos ver que

35528
23:31:55,680 --> 23:31:59,040
é possível fazer proteção e

35529
23:31:59,040 --> 23:32:01,120
herança privada e nós vamos

35530
23:32:01,120 --> 23:32:03,760
Veja o que isso significa na próxima palestra

35531
23:32:03,760 --> 23:32:06,000
então vá em frente e termine aqui e conheça

35532
23:32:06,000 --> 23:32:07,760
Eu lá nesta palestra vamos

35533
23:32:07,760 --> 23:32:11,280
Saiba mais sobre os especificadores de acesso de classe base

35534
23:32:11,280 --> 23:32:13,512
e no caso de você não saber que fomos

35535
23:32:13,512 --> 23:32:15,920
usando os especificadores de acesso de classe base em

35536
23:32:15,920 --> 23:32:18,720
Este capítulo o tempo todo e para realmente

35537
23:32:18,720 --> 23:32:21,192
Entenda isso, olhemos para o nosso jogador

35538
23:32:21,192 --> 23:32:23,680
classe que está herdando de pessoa

35539
23:32:23,680 --> 23:32:27,120
e estamos fazendo herança pública a

35540
23:32:27,120 --> 23:32:29,760
A palavra-chave pública aqui é uma classe base

35541
23:32:29,760 --> 23:32:32,552
especificador de acesso e vai

35542
23:32:32,552 --> 23:32:33,760
controle

35543
23:32:33,760 --> 23:32:37,512
como são acessíveis os membros da classe base

35544
23:32:37,512 --> 23:32:40,552
de uma classe derivada e temos três

35545
23:32:40,552 --> 23:32:43,120
Opções bem, então se fizermos o público

35546
23:32:43,120 --> 23:32:45,832
herança como vemos aqui em nosso

35547
23:32:45,832 --> 23:32:47,680
classe de jogadores

35548
23:32:47,680 --> 23:32:49,832
Tudo o que é público na base

35549
23:32:49,832 --> 23:32:52,000
A classe também vai ser pública que você vê

35550
23:32:52,000 --> 23:32:54,800
m1 aqui também é público no

35551
23:32:54,800 --> 23:32:55,760
classe de classe

35552
23:32:55,760 --> 23:32:57,680
Tudo o que está protegido vai

35553
23:32:57,680 --> 23:33:00,480
manter protegido e tudo o que é

35554
23:33:00,480 --> 23:33:02,960
Privado na classe base também está indo

35555
23:33:02,960 --> 23:33:06,640
para ficar privado na classe derivada

35556
23:33:06,640 --> 23:33:08,800
Tente tirar um momento para olhar para isso

35557
23:33:08,800 --> 23:33:09,832
Mais uma vez

35558
23:33:09,832 --> 23:33:13,040
os especificadores de acesso do membro que temos em

35559
23:33:13,040 --> 23:33:16,320
A classe base vai ficar intacta

35560
23:33:16,320 --> 23:33:17,512
Se o fizermos

35561
23:33:17,512 --> 23:33:20,400
Herança pública novamente qualquer coisa que

35562
23:33:20,400 --> 23:33:22,720
É público na base vai ser público

35563
23:33:22,720 --> 23:33:25,360
e deriva tudo o que é protegido

35564
23:33:25,360 --> 23:33:27,832
na base será protegida e

35565
23:33:27,832 --> 23:33:30,960
derivada e qualquer coisa que seja privada em

35566
23:33:30,960 --> 23:33:32,640
A base vai ser

35567
23:33:32,640 --> 23:33:36,000
Privado em derivado este é um tipo de

35568
23:33:36,000 --> 23:33:39,120
herança que podemos fazer em c plus plus, mas

35569
23:33:39,120 --> 23:33:42,720
Também podemos fazer herança protegida e

35570
23:33:42,720 --> 23:33:44,872
A sintaxe para fazer isso basta usar o

35571
23:33:44,872 --> 23:33:47,360
Palavra-chave protegida aqui você diz classe

35572
23:33:47,360 --> 23:33:49,760
coluna do jogador e especificar isso

35573
23:33:49,760 --> 23:33:52,872
você quer fazer herança protegida e

35574
23:33:52,872 --> 23:33:55,360
então você especifica a classe base desejada

35575
23:33:55,360 --> 23:33:58,320
Herdar a partir do momento em que você faz isso

35576
23:33:58,320 --> 23:34:00,232
Tudo o que é público na base

35577
23:34:00,232 --> 23:34:02,640
A classe será protegida no

35578
23:34:02,640 --> 23:34:04,160
classe derivada

35579
23:34:04,160 --> 23:34:06,000
Tudo o que está protegido vai

35580
23:34:06,000 --> 23:34:08,960
manter protegido tudo o que é privado

35581
23:34:08,960 --> 23:34:11,512
Vai ser privado

35582
23:34:11,512 --> 23:34:13,760
e de certa forma você pode ver que podemos

35583
23:34:13,760 --> 23:34:17,360
usar esses especificadores de acesso de classe base

35584
23:34:17,360 --> 23:34:18,960
para restringir

35585
23:34:18,960 --> 23:34:21,832
O especificador de acesso em classe derivada

35586
23:34:21,832 --> 23:34:24,800
mas não podemos fazer os especificadores de acesso

35587
23:34:24,800 --> 23:34:26,872
em classes derivadas

35588
23:34:26,872 --> 23:34:28,960
Mais relaxados só podemos fazer coisas

35589
23:34:28,960 --> 23:34:31,600
mais restrito ou mais restrito para

35590
23:34:31,600 --> 23:34:33,832
O exemplo da variável membro m1 foi

35591
23:34:33,832 --> 23:34:36,720
público, mas agora nós fizemos isso se tornar

35592
23:34:36,720 --> 23:34:40,160
Protegido usando a base protegida

35593
23:34:40,160 --> 23:34:42,872
especificador de acesso aqui, então agora você

35594
23:34:42,872 --> 23:34:45,360
Saiba que podemos fazer público e protegido

35595
23:34:45,360 --> 23:34:48,232
herança, mas também é possível

35596
23:34:48,232 --> 23:34:51,280
fazer herança privada e você faz isso

35597
23:34:51,280 --> 23:34:54,232
usando um acesso de classe base privada

35598
23:34:54,232 --> 23:34:56,640
especificador no momento em que você faz isso

35599
23:34:56,640 --> 23:34:58,400
Tudo o que é público na base

35600
23:34:58,400 --> 23:35:00,552
A classe vai tornar-se privada no

35601
23:35:00,552 --> 23:35:03,360
classes derivadas de qualquer coisa que seja protegida

35602
23:35:03,360 --> 23:35:05,120
Na classe base vai se tornar

35603
23:35:05,120 --> 23:35:07,832
privado na classe derivada e

35604
23:35:07,832 --> 23:35:09,360
Tudo o que é privado vai

35605
23:35:09,360 --> 23:35:12,160
permanecer privado na classe derivada e

35606
23:35:12,160 --> 23:35:13,680
Mais uma vez você vê que isso vai

35607
23:35:13,680 --> 23:35:16,720
restringir graças a coisas que eram públicas

35608
23:35:16,720 --> 23:35:18,960
Agora são privados em derivados e não podemos

35609
23:35:18,960 --> 23:35:21,360
Realmente fazer qualquer coisa com eles de qualquer

35610
23:35:21,360 --> 23:35:23,832
outra classe que pode derivar de nossa

35611
23:35:23,832 --> 23:35:26,400
classe de jogador, então esta é a configuração que nós

35612
23:35:26,400 --> 23:35:29,192
Tenho ok para resumir isso através do

35613
23:35:29,192 --> 23:35:31,512


35614
23:35:31,512 --> 23:35:35,600
Controle quão relaxado ou restrito

35615
23:35:35,600 --> 23:35:38,480
é o acesso aos membros da classe base de

35616
23:35:38,480 --> 23:35:40,320
A classe derivada e isso é realmente

35617
23:35:40,320 --> 23:35:42,320
importante para entender se você quiser

35618
23:35:42,320 --> 23:35:44,800
Diga tão relaxado como eles estão na base

35619
23:35:44,800 --> 23:35:47,280
classe que você pode usar a herança pública se

35620
23:35:47,280 --> 23:35:49,192
Você quer restringir um pouco você

35621
23:35:49,192 --> 23:35:50,400
pode usar

35622
23:35:50,400 --> 23:35:52,320
Herança protegida e coisas são

35623
23:35:52,320 --> 23:35:54,480
Será herdado como protegido

35624
23:35:54,480 --> 23:35:57,680
exceto para os dados privados na base

35625
23:35:57,680 --> 23:35:59,920
classe se você quer que as coisas sejam super

35626
23:35:59,920 --> 23:36:02,080
restrito você pode usar o privado

35627
23:36:02,080 --> 23:36:04,160
Herança sobre a qual acabamos de aprender

35628
23:36:04,160 --> 23:36:06,160
e tudo em sua classe derivada é

35629
23:36:06,160 --> 23:36:09,440
vai ser privado e você pode usar isso

35630
23:36:09,440 --> 23:36:11,512
se faz sentido para a aplicação

35631
23:36:11,512 --> 23:36:14,080
você está projetando e você pode usá-los

35632
23:36:14,080 --> 23:36:16,160
tipos de características se eles fazem sentido para

35633
23:36:16,160 --> 23:36:18,552
Qualquer aplicação que você está projetando

35634
23:36:18,552 --> 23:36:20,960
com c plus mais uma coisa que você deveria

35635
23:36:20,960 --> 23:36:23,120
Mas saber é que, independentemente do

35636
23:36:23,120 --> 23:36:26,320
especificador de acesso de classe base que usamos

35637
23:36:26,320 --> 23:36:29,192
Membros privados da classe base podem

35638
23:36:29,192 --> 23:36:32,160
Nunca seja acessível a partir de uma classe derivada

35639
23:36:32,160 --> 23:36:34,400
Tudo o que é privado vai

35640
23:36:34,400 --> 23:36:37,120
Ficar privado e você não tem como

35641
23:36:37,120 --> 23:36:39,360
Relaxe as coisas um pouco que não é

35642
23:36:39,360 --> 23:36:40,960
Vou trabalhar que você realmente deve saber

35643
23:36:40,960 --> 23:36:43,360
Isso agora que você conhece esses tipos de

35644
23:36:43,360 --> 23:36:46,080
Heranças que podemos fazer em ziplus plus

35645
23:36:46,080 --> 23:36:47,680
Vamos para a próxima

35646
23:36:47,680 --> 23:36:49,760
dar uma palestra e brincar com eles um pouco mais

35647
23:36:49,760 --> 23:36:51,760
Nesta palestra vamos brincar com

35648
23:36:51,760 --> 23:36:54,160
os especificadores de acesso de classe base nós

35649
23:36:54,160 --> 23:36:56,160
Aprendi na última palestra em

35650
23:36:56,160 --> 23:36:58,160
Em outras palavras, vamos brincar

35651
23:36:58,160 --> 23:37:01,512
Sucessório público protegido e privado

35652
23:37:01,512 --> 23:37:03,760
em código de estúdio visual, então vamos rever um

35653
23:37:03,760 --> 23:37:05,680
Um pouco do que falamos no

35654
23:37:05,680 --> 23:37:07,680
A última palestra dizemos que podemos ter

35655
23:37:07,680 --> 23:37:10,080
herança pública e a sintaxe a fazer

35656
23:37:10,080 --> 23:37:12,960
Isso é o que você vê aqui e no

35657
23:37:12,960 --> 23:37:15,120
No momento em que você faz isso, o que era público em

35658
23:37:15,120 --> 23:37:17,040
A classe básica será pública em

35659
23:37:17,040 --> 23:37:19,280
A classe derivada que foi protegida é

35660
23:37:19,280 --> 23:37:21,600
Vou ficar protegido o que era privado

35661
23:37:21,600 --> 23:37:24,320
vai tornar-se privado no

35662
23:37:24,320 --> 23:37:26,640
classe derivada em outras palavras, público

35663
23:37:26,640 --> 23:37:28,480
A herança não vai realmente

35664
23:37:28,480 --> 23:37:31,360
Alterar a acessibilidade do membro

35665
23:37:31,360 --> 23:37:33,120
variáveis que temos na classe base

35666
23:37:33,120 --> 23:37:35,832
Vamos herdar os dados como ele

35667
23:37:35,832 --> 23:37:38,552
estava com o mesmo nível de acesso que tínhamos em

35668
23:37:38,552 --> 23:37:40,552
A classe base é uma

35669
23:37:40,552 --> 23:37:43,360
característica da herança pública em c plus

35670
23:37:43,360 --> 23:37:45,680
Além disso, também podemos fazer proteção

35671
23:37:45,680 --> 23:37:49,120
herança e o que isso vai fazer

35672
23:37:49,120 --> 23:37:52,640
é fazer protegido o mais alto acesso

35673
23:37:52,640 --> 23:37:55,920
nível que podemos ter na classe derivada

35674
23:37:55,920 --> 23:37:57,920
Tudo o que era público na base

35675
23:37:57,920 --> 23:37:59,920
A classe vai tornar-se protegida

35676
23:37:59,920 --> 23:38:01,680
Tudo o que foi protegido vai

35677
23:38:01,680 --> 23:38:03,920
Fica protegido porque esse é o

35678
23:38:03,920 --> 23:38:05,920
Nível mais alto que podemos fazer agora

35679
23:38:05,920 --> 23:38:07,760
e qualquer coisa que fosse privada no

35680
23:38:07,760 --> 23:38:10,552
A classe base será privada no

35681
23:38:10,552 --> 23:38:13,280
classe derivada que dizemos privado no

35682
23:38:13,280 --> 23:38:15,280
Sentir que vai ser privado para

35683
23:38:15,280 --> 23:38:17,832
A classe base para que você não possa realmente usar

35684
23:38:17,832 --> 23:38:21,600
m3 da classe do jogador neste caso se

35685
23:38:21,600 --> 23:38:22,800
Você está tentando fazer isso que você vai

35686
23:38:22,800 --> 23:38:25,680
obter um erro de compilador bem, também podemos fazer

35687
23:38:25,680 --> 23:38:28,552
herança privada e a sintaxe a fazer

35688
23:38:28,552 --> 23:38:31,360
Isso é o que você vê aqui e agora

35689
23:38:31,360 --> 23:38:33,440
O privado será o mais alto nível

35690
23:38:33,440 --> 23:38:34,720
nós podemos fazer

35691
23:38:34,720 --> 23:38:37,120
na classe do jogador em termos de

35692
23:38:37,120 --> 23:38:39,600
membros que olhemos da classe base

35693
23:38:39,600 --> 23:38:41,600
Então, qualquer coisa que fosse pública vai

35694
23:38:41,600 --> 23:38:43,600
Torne-se privado qualquer coisa que fosse

35695
23:38:43,600 --> 23:38:45,760
Protegido vai tornar-se privado

35696
23:38:45,760 --> 23:38:48,000
Tudo o que era privado para a base

35697
23:38:48,000 --> 23:38:49,920
A classe vai ficar privada para o

35698
23:38:49,920 --> 23:38:52,640
classe base esta é o que queremos dizer aqui, mas

35699
23:38:52,640 --> 23:38:53,760
E agora

35700
23:38:53,760 --> 23:38:58,552
m1 e m2 tornaram-se públicos para o

35701
23:38:58,552 --> 23:39:01,680
classe de jogador se alguém tentar

35702
23:39:01,680 --> 23:39:04,800
deriva ou herda de um jogador estes

35703
23:39:04,800 --> 23:39:07,120
As coisas não serão acessíveis

35704
23:39:07,120 --> 23:39:10,400
e isso é de alguma forma a classe do jogador

35705
23:39:10,400 --> 23:39:13,040
Sendo egoísta, é dizer que eu vou

35706
23:39:13,040 --> 23:39:15,680
obter tudo que eu posso de meu pai

35707
23:39:15,680 --> 23:39:18,480
classe ou minha classe base, mas eu vou

35708
23:39:18,480 --> 23:39:21,280
fazer tudo o meu ninguém mais pode tomar

35709
23:39:21,280 --> 23:39:23,360
Isso e este é o tipo de configuração que nós

35710
23:39:23,360 --> 23:39:24,400
pode conseguir

35711
23:39:24,400 --> 23:39:27,040
em herança privada, então agora

35712
23:39:27,040 --> 23:39:28,960
que temos isso em mente, vamos

35713
23:39:28,960 --> 23:39:30,960
jogar com a gente no código do estúdio visual que somos

35714
23:39:30,960 --> 23:39:32,800
Vou montar um monte de aulas que somos

35715
23:39:32,800 --> 23:39:34,232
Vou montar uma classe pessoal que somos

35716
23:39:34,232 --> 23:39:36,552
Vamos herdar de nós vamos

35717
23:39:36,552 --> 23:39:38,640
para montar uma aula de enfermagem que está indo

35718
23:39:38,640 --> 23:39:41,360
para fazer herança protegida e nós somos

35719
23:39:41,360 --> 23:39:43,440
vai montar uma classe de engenheiro que

35720
23:39:43,440 --> 23:39:45,920
vai fazer herança privada e

35721
23:39:45,920 --> 23:39:47,760
nós vamos realmente brincar com isso e

35722
23:39:47,760 --> 23:39:50,320
Veja como isso se desenrola em real c plus

35723
23:39:50,320 --> 23:39:52,720
mais código, então vamos fazer isso aqui estamos

35724
23:39:52,720 --> 23:39:54,960
em nossa pasta de trabalho a atual

35725
23:39:54,960 --> 23:39:58,960
O projeto é um especificador de acesso básico uma demonstração

35726
23:39:58,960 --> 23:40:00,720
vamos fazer uma demo sobre isso, mas

35727
23:40:00,720 --> 23:40:02,320
Antes de fazermos isso, vamos agarrar

35728
23:40:02,320 --> 23:40:05,760
nossos arquivos de modelo e colocá-los no lugar

35729
23:40:05,760 --> 23:40:07,680
E nós vamos abrir este pequeno rapaz

35730
23:40:07,680 --> 23:40:09,760
em código de estúdio visual arrastando e

35731
23:40:09,760 --> 23:40:11,920
Deixando aqui isso vai nos dar um

35732
23:40:11,920 --> 23:40:13,680
Bom ponto de partida que vamos ter

35733
23:40:13,680 --> 23:40:16,080
nosso arquivo principal cpp vamos limpar

35734
23:40:16,080 --> 23:40:18,000
Isso e nós vamos montar nossa base

35735
23:40:18,000 --> 23:40:19,600
classe que vai ser a pessoa

35736
23:40:19,600 --> 23:40:22,480
classe então vamos colocar isso do zero

35737
23:40:22,480 --> 23:40:24,720
Vamos adicionar nossos arquivos que vamos

35738
23:40:24,720 --> 23:40:26,872
para dizer a página da pessoa e nós vamos

35739
23:40:26,872 --> 23:40:28,640
Diga person.cpp

35740
23:40:28,640 --> 23:40:30,872
nós vamos pular em nosso cabeçalho

35741
23:40:30,872 --> 23:40:33,600
arquivar e colocar em nosso código nada especial

35742
23:40:33,600 --> 23:40:35,920
até agora temos uma cabaço incluindo

35743
23:40:35,920 --> 23:40:37,832
nossa classe de pessoa tem um monte de

35744
23:40:37,832 --> 23:40:40,160
variáveis de membro que temos o nome completo

35745
23:40:40,160 --> 23:40:42,960
que é público, temos a idade que é

35746
23:40:42,960 --> 23:40:45,680
protegido e temos o endereço que

35747
23:40:45,680 --> 23:40:49,040
é privado para esta classe aqui este é

35748
23:40:49,040 --> 23:40:51,280
Vai ser o nosso ponto de partida

35749
23:40:51,280 --> 23:40:53,600
Temos também um monte de construtores

35750
23:40:53,600 --> 23:40:55,760
ter um padrão, também temos outro

35751
23:40:55,760 --> 23:40:57,920
um que vai pegar todos os dados

35752
23:40:57,920 --> 23:41:00,552
nós podemos usar o objeto da pessoa do construtor

35753
23:41:00,552 --> 23:41:03,120
e aqui estamos passando uma corda de custo por

35754
23:41:03,120 --> 23:41:05,440
referência acho que podemos corrigir isso e

35755
23:41:05,440 --> 23:41:07,600
passar uma visão de string que vai ser

35756
23:41:07,600 --> 23:41:10,232
Melhor vamos dizer string view e nós somos

35757
23:41:10,232 --> 23:41:12,480
vai mudar o primeiro parâmetro aqui

35758
23:41:12,480 --> 23:41:15,680
para ser um std string view por valor este

35759
23:41:15,680 --> 23:41:18,000
Vai ser muito melhor bem, temos

35760
23:41:18,000 --> 23:41:21,120
nossa classe nós podemos pular no cpp

35761
23:41:21,120 --> 23:41:24,080
arquivar e colocar em nossa implementação nós

35762
23:41:24,080 --> 23:41:26,080
vai mudar o construtor a

35763
23:41:26,080 --> 23:41:28,320
Um pouco e certifique-se de que estamos tomando

35764
23:41:28,320 --> 23:41:31,120
uma visão de string std por valor e se você

35765
23:41:31,120 --> 23:41:33,440
Eu queria digitar todo esse código que você pode obter

35766
23:41:33,440 --> 23:41:36,080
da seção de recursos deste

35767
23:41:36,080 --> 23:41:37,920
palestra eu vou anexar todo o

35768
23:41:37,920 --> 23:41:40,000
código fonte e você pode baixar e usar

35769
23:41:40,000 --> 23:41:42,232
Mas você quer realmente fazer

35770
23:41:42,232 --> 23:41:44,720
sua experiência de aprendizado tão agradável quanto

35771
23:41:44,720 --> 23:41:46,960
Possível, então temos nosso construtor aqui

35772
23:41:46,960 --> 23:41:49,120
vai encaminhar os dados para o nosso

35773
23:41:49,120 --> 23:41:50,960
membros variáveis o nome completo está indo

35774
23:41:50,960 --> 23:41:53,280
para entrar em nossa variável de membro de nome completo

35775
23:41:53,280 --> 23:41:54,800
nós vamos pegar a idade e a idade

35776
23:41:54,800 --> 23:41:56,400
endereço e vamos armazenar tudo

35777
23:41:56,400 --> 23:41:58,720
Esta informação também temos uma saída

35778
23:41:58,720 --> 23:42:00,400
Operador de fluxo que vai ser

35779
23:42:00,400 --> 23:42:02,872
Imprimindo toda essa informação aqui é

35780
23:42:02,872 --> 23:42:04,872
indo para passar pelos getters porque

35781
23:42:04,872 --> 23:42:07,120
Temos um objeto passado como um

35782
23:42:07,120 --> 23:42:10,000
parâmetro aqui e isso vai funcionar

35783
23:42:10,000 --> 23:42:12,400
nós podemos ir no arquivo principal cpp e

35784
23:42:12,400 --> 23:42:15,192
incluir a nossa classe de pessoa e criar um

35785
23:42:15,192 --> 23:42:17,192
Objetivamente podemos fazer algo como

35786
23:42:17,192 --> 23:42:20,080
pessoa pessoa um e nós podemos passar o

35787
23:42:20,080 --> 23:42:22,960
dados que nosso construtor espera que possamos

35788
23:42:22,960 --> 23:42:25,760
Passe no nome completo a idade e a

35789
23:42:25,760 --> 23:42:27,832
endereço para que vamos fazer isso

35790
23:42:27,832 --> 23:42:30,800
Diga o nome completo daniel cinza por que não

35791
23:42:30,800 --> 23:42:33,512
e a idade vai ser 27 que podemos colocar

35792
23:42:33,512 --> 23:42:35,360
em tudo o que quisermos e nós vamos

35793
23:42:35,360 --> 23:42:37,832
colocar no endereço que vamos dizer

35794
23:42:37,832 --> 23:42:40,800
Estria do céu azul você pode dizer dois três

35795
23:42:40,800 --> 23:42:43,360
três, por exemplo, e dizer o número de

35796
23:42:43,360 --> 23:42:46,160
A casa para b56, porque não isso é um

35797
23:42:46,160 --> 23:42:48,960
possível endereço para uma pessoa para que possamos

35798
23:42:48,960 --> 23:42:52,320
Diga pessoa um ou podemos usar htdc para fora

35799
23:42:52,320 --> 23:42:54,552
imprimir isso porque temos uma saída

35800
23:42:54,552 --> 23:42:57,760
operador do fluxo para nossa classe de pessoa

35801
23:42:57,760 --> 23:42:59,360
Podemos fazer isso, vamos dizer pessoa

35802
23:42:59,360 --> 23:43:02,160
Um e nós vamos colocá-lo para fora e

35803
23:43:02,160 --> 23:43:04,000
Se construirmos e executarmos este programa, nós somos

35804
23:43:04,000 --> 23:43:06,832
Vou ver que isso vai funcionar

35805
23:43:06,832 --> 23:43:09,360
Esperamos ter um problema porque

35806
23:43:09,360 --> 23:43:11,760
Não temos um ponto e vírgula no final de

35807
23:43:11,760 --> 23:43:14,320
Linha 6 aqui vamos consertar que estamos indo

35808
23:43:14,320 --> 23:43:17,120
para executar esta tarefa para construir com gcc o

35809
23:43:17,120 --> 23:43:19,040
O construtor vai ser bom que podemos trazer

35810
23:43:19,040 --> 23:43:21,512
para cima uma janela powershell

35811
23:43:21,512 --> 23:43:23,120
e nós vamos usar isso para executar o nosso

35812
23:43:23,120 --> 23:43:25,600
programa se dissermos galo, vamos

35813
23:43:25,600 --> 23:43:27,832
Veja que temos a pessoa impressa

35814
23:43:27,832 --> 23:43:30,480
O nome completo é daniel cinza a idade é

35815
23:43:30,480 --> 23:43:35,120
27o endereço é a rua azul do céu 233

35816
23:43:35,120 --> 23:43:38,000
e o número da casa é 56 assim

35817
23:43:38,000 --> 23:43:40,400
Esta é uma possível implementação para

35818
23:43:40,400 --> 23:43:42,720
A classe da pessoa, mas nós realmente não

35819
23:43:42,720 --> 23:43:44,872
interessado em criar uma classe de prisão

35820
23:43:44,872 --> 23:43:46,872
E fazendo coisas com que nós somos

35821
23:43:46,872 --> 23:43:49,680
interessado em herdar da pessoa

35822
23:43:49,680 --> 23:43:52,872
classe e aprender sobre diferentes tipos de

35823
23:43:52,872 --> 23:43:55,760
especificadores de acesso de classe base que podemos fazer

35824
23:43:55,760 --> 23:43:57,512
Vamos criar uma classe de jogadores

35825
23:43:57,512 --> 23:44:00,480
que vai herdar publicamente de

35826
23:44:00,480 --> 23:44:02,720
A classe da pessoa vamos fazer isso nós

35827
23:44:02,720 --> 23:44:04,640
Vou colocar o nosso jogador, vamos

35828
23:44:04,640 --> 23:44:06,960
para colocar no arquivo de cabeçalho, digamos

35829
23:44:06,960 --> 23:44:09,120
Jogador não pessoa e nós vamos dizer

35830
23:44:09,120 --> 23:44:12,400
player.h vamos colocar em um cpp

35831
23:44:12,400 --> 23:44:14,800
arquivo, vamos pular no

35832
23:44:14,800 --> 23:44:17,832
cabeçalho do jogador e colocar em nossa classe

35833
23:44:17,832 --> 23:44:20,400
Vamos fechar a barra lateral esquerda aqui, então

35834
23:44:20,400 --> 23:44:22,000
que você pode realmente ver tudo que nós

35835
23:44:22,000 --> 23:44:23,920
ter um protetor incluído em

35836
23:44:23,920 --> 23:44:26,480
Temos o jogador de classe declarado que é

35837
23:44:26,480 --> 23:44:28,800
Vou fazer a herança pública de

35838
23:44:28,800 --> 23:44:29,760
Pessoa

35839
23:44:29,760 --> 23:44:32,720
O que isso vai fazer é que

35840
23:44:32,720 --> 23:44:34,640
Tudo o que é público em pessoa é

35841
23:44:34,640 --> 23:44:37,512
Vai ficar público no jogador qualquer coisa

35842
23:44:37,512 --> 23:44:39,360
que está protegido vai ficar

35843
23:44:39,360 --> 23:44:41,040
protegido no jogador

35844
23:44:41,040 --> 23:44:43,512
e tudo o que é

35845
23:44:43,512 --> 23:44:46,000
O privado vai ficar privado, então nós

35846
23:44:46,000 --> 23:44:48,000
Quer ser capaz de acessar dados privados

35847
23:44:48,000 --> 23:44:50,480
de um objeto pessoal, por exemplo,

35848
23:44:50,480 --> 23:44:52,080
Não pode acessar

35849
23:44:52,080 --> 23:44:54,400
a variável membro do endereço aqui porque

35850
23:44:54,400 --> 23:44:57,192
é privado, mas nós podemos usar o pleno

35851
23:44:57,192 --> 23:44:58,872
O nome e a idade

35852
23:44:58,872 --> 23:45:00,552
A partir do

35853
23:45:00,552 --> 23:45:02,160
classe derivada

35854
23:45:02,160 --> 23:45:05,040
vamos ter certeza de que temos um arquivo cpp e

35855
23:45:05,040 --> 23:45:07,600
Antes de experimentar as coisas

35856
23:45:07,600 --> 23:45:09,832
então vamos pular para o arquivo cpp e

35857
23:45:09,832 --> 23:45:12,800
colocar em uma possível implementação que somos

35858
23:45:12,800 --> 23:45:15,192
Vou incluir a pessoa e o jogador

35859
23:45:15,192 --> 23:45:17,680
Porque nós vamos usar estes

35860
23:45:17,680 --> 23:45:20,080
e vamos criar um construtor

35861
23:45:20,080 --> 23:45:22,720
que não vai fazer nada por um

35862
23:45:22,720 --> 23:45:25,600
jogador, também temos nosso fluxo de saída

35863
23:45:25,600 --> 23:45:27,120
operador que vai imprimir o

35864
23:45:27,120 --> 23:45:29,920
dados que vão usar os getters

35865
23:45:29,920 --> 23:45:32,400
nós temos na classe base e temos

35866
23:45:32,400 --> 23:45:33,832
o acesso a eles

35867
23:45:33,832 --> 23:45:36,480
porque estamos fazendo herança pública

35868
23:45:36,480 --> 23:45:38,480
então eles vão ser públicos e nós

35869
23:45:38,480 --> 23:45:40,800
pode chamá-los de fora como nós

35870
23:45:40,800 --> 23:45:43,280
estão fazendo aqui a atenção que este é um

35871
23:45:43,280 --> 23:45:46,232
objeto de jogador externo e estamos chamando

35872
23:45:46,232 --> 23:45:48,552
nossos membros públicos sobre isso e isso é

35873
23:45:48,552 --> 23:45:50,400
indo para o trabalho, também temos um destruidor

35874
23:45:50,400 --> 23:45:52,000
O que realmente não vai fazer

35875
23:45:52,000 --> 23:45:54,552
Qualquer coisa, mas nós vamos mantê-lo dentro

35876
23:45:54,552 --> 23:45:57,120
aqui porque não vai doer assim

35877
23:45:57,120 --> 23:45:59,760
Agora o que queremos experimentar

35878
23:45:59,760 --> 23:46:02,480
é ver se podemos acessar agradecimentos a partir de

35879
23:46:02,480 --> 23:46:04,872
A classe base é a primeira coisa que temos

35880
23:46:04,872 --> 23:46:07,192
Na classe base é o

35881
23:46:07,192 --> 23:46:09,680
Nome completo e acho que podemos realmente

35882
23:46:09,680 --> 23:46:12,872
copiar estes espaços em branco ou não podemos simplesmente usar

35883
23:46:12,872 --> 23:46:15,832
eles m nome completo mh e m endereço estamos

35884
23:46:15,832 --> 23:46:18,320
vou tentar usá-los no derivado

35885
23:46:18,320 --> 23:46:21,512
classe então vamos tentar dizer m nome completo

35886
23:46:21,512 --> 23:46:24,000
e alterar o nome completo, por exemplo, para

35887
23:46:24,000 --> 23:46:24,720
ser

35888
23:46:24,720 --> 23:46:27,760
daniel cinza ou jon neve e nós vamos

35889
23:46:27,760 --> 23:46:28,720
A sua forma de

35890
23:46:28,720 --> 23:46:30,640
Mude a idade para ser

35891
23:46:30,640 --> 23:46:33,360
55 Por que não e vamos tentar

35892
23:46:33,360 --> 23:46:36,160
acessar o endereço, vamos ver o que nós

35893
23:46:36,160 --> 23:46:38,552
chamado nossa variável de membro de endereço é

35894
23:46:38,552 --> 23:46:40,960
m endereço que podemos pegar e usar isso

35895
23:46:40,960 --> 23:46:43,600
em nossa classe se tentarmos acessar isso

35896
23:46:43,600 --> 23:46:45,760
vamos ter um erro de compilador

35897
23:46:45,760 --> 23:46:47,440
Porque isso vai ser

35898
23:46:47,440 --> 23:46:50,080
privado para a classe base que você percebe

35899
23:46:50,080 --> 23:46:52,400
que se tentarmos colocar um pouco de lixo

35900
23:46:52,400 --> 23:46:54,400
dados que vamos ter uma linha de riscar

35901
23:46:54,400 --> 23:46:57,512
porque isso não é acessível aqui e

35902
23:46:57,512 --> 23:46:59,360
Código de estúdio visual vai dizer que

35903
23:46:59,360 --> 23:47:01,760
Isto não é acessível

35904
23:47:01,760 --> 23:47:04,320
porque é privado para a classe base

35905
23:47:04,320 --> 23:47:06,960
para que possamos acessar o nome completo m porque ele

35906
23:47:06,960 --> 23:47:10,160
foi herdado como público, então isso está acontecendo

35907
23:47:10,160 --> 23:47:13,680
para ficar bem, podemos usar a idade, porque foi

35908
23:47:13,680 --> 23:47:17,120
Herdado como protegido, podemos usá-lo em

35909
23:47:17,120 --> 23:47:19,680
uma classe derivada, mas não podemos usar o

35910
23:47:19,680 --> 23:47:22,320
Endereço porque foi herdado como

35911
23:47:22,320 --> 23:47:24,872
privado e é privado para a base

35912
23:47:24,872 --> 23:47:27,120
classe para que isso não funcione mesmo

35913
23:47:27,120 --> 23:47:28,800
Se tentarmos chamar biola de código, vamos

35914
23:47:28,800 --> 23:47:30,640
para obter um erro do compilador, vamos tentar fazer

35915
23:47:30,640 --> 23:47:32,480
para que você possa realmente ver por

35916
23:47:32,480 --> 23:47:35,192
Você está bem, então temos um compilador

35917
23:47:35,192 --> 23:47:39,192
erro e isso foi declarado na base

35918
23:47:39,192 --> 23:47:41,120
classe como privado, é isso que

35919
23:47:41,120 --> 23:47:43,600
O erro do compilador é dizer que não devemos

35920
23:47:43,600 --> 23:47:46,800
realmente fazer isso a classe derivada

35921
23:47:46,800 --> 23:47:48,480
Não tem nenhum negócio

35922
23:47:48,480 --> 23:47:51,920
Modificar um membro privado da base

35923
23:47:51,920 --> 23:47:53,832
classe Esta é a mensagem aqui, então nós somos

35924
23:47:53,832 --> 23:47:55,440
Vou comentar isso e dizer que

35925
23:47:55,440 --> 23:47:56,960
Isto vai dar-lhe um compilador

35926
23:47:56,960 --> 23:47:59,760
Erro, mas também vamos criar um

35927
23:47:59,760 --> 23:48:02,552
jogador de objeto e tentar acessar estes

35928
23:48:02,552 --> 23:48:05,280
Os rapazes e vejam como o acesso a partir do

35929
23:48:05,280 --> 23:48:07,280
Fora, então vamos no principal

35930
23:48:07,280 --> 23:48:09,440
arquivo cpp e vamos incluir

35931
23:48:09,440 --> 23:48:12,080
jogador dot h e vamos criar um

35932
23:48:12,080 --> 23:48:14,720
jogador objeto que podemos colocar em um separador

35933
23:48:14,720 --> 23:48:17,600
e dizer um monte de traços aqui este é

35934
23:48:17,600 --> 23:48:19,360
Eu acho que isso vai acontecer

35935
23:48:19,360 --> 23:48:21,600
trabalhar e vamos criar um jogador

35936
23:48:21,600 --> 23:48:24,480
Objeto podemos dizer jogador e jogador e

35937
23:48:24,480 --> 23:48:27,040
Não coloque nenhum parêntese aqui este é

35938
23:48:27,040 --> 23:48:29,040
vai chamar o construtor padrão

35939
23:48:29,040 --> 23:48:33,040
que temos em nossa classe de jogadores e nós

35940
23:48:33,040 --> 23:48:35,120
pode tentar usar isso, mas antes de fazer

35941
23:48:35,120 --> 23:48:37,192
Vamos tentar construir e ver que isso é

35942
23:48:37,192 --> 23:48:39,760
indo para construir muito bem, vamos

35943
23:48:39,760 --> 23:48:42,320
trabalhar com gcc vamos fazer isso que estamos indo

35944
23:48:42,320 --> 23:48:44,080
para ver que o mundo é bom, podemos tentar

35945
23:48:44,080 --> 23:48:47,192
e material de acesso a partir deste objeto de jogador

35946
23:48:47,192 --> 23:48:50,720
nós podemos dizer jogador e dizer m nome completo

35947
23:48:50,720 --> 23:48:52,480
Você vê que isso é acessível, podemos

35948
23:48:52,480 --> 23:48:54,160
Na verdade, mude isso

35949
23:48:54,160 --> 23:48:58,160
para samwell jackson nós podemos fazer isso, mas se

35950
23:48:58,160 --> 23:49:01,192
nós tentamos e dizemos jogador mh que vamos

35951
23:49:01,192 --> 23:49:03,280
Veja que isso não é acessível aqui

35952
23:49:03,280 --> 23:49:06,480
Porque isso foi herdado como protegido

35953
23:49:06,480 --> 23:49:07,920
Se voltarmos para a pessoa, vamos

35954
23:49:07,920 --> 23:49:11,280
Veja que a idade é protegida para que

35955
23:49:11,280 --> 23:49:14,080
ser acessível em classes derivadas apenas

35956
23:49:14,080 --> 23:49:18,080
como fizemos em nosso método de jogo do

35957
23:49:18,080 --> 23:49:20,960
Classe de jogadores, mas não podemos acessar a idade

35958
23:49:20,960 --> 23:49:24,000
do lado de fora de um objeto de jogador

35959
23:49:24,000 --> 23:49:25,280
Porque isso não vai ser

35960
23:49:25,280 --> 23:49:27,280
acessível a partir do exterior este é um

35961
23:49:27,280 --> 23:49:30,872
Definição da característica do acesso protegido

35962
23:49:30,872 --> 23:49:32,800
nível, então isso não vai funcionar mesmo

35963
23:49:32,800 --> 23:49:34,320
Se tentarmos construir, vamos ter um

35964
23:49:34,320 --> 23:49:38,232
Erro do compilador ao longo das linhas deste

35965
23:49:38,232 --> 23:49:41,760
não é acessível neste contexto e

35966
23:49:41,760 --> 23:49:43,600
foi declarado na classe base, então nós

35967
23:49:43,600 --> 23:49:46,000
Não pode realmente acessá-lo de fora

35968
23:49:46,000 --> 23:49:47,920
Este é o erro do compilador aqui, então nós somos

35969
23:49:47,920 --> 23:49:50,160
Vou comentar isso e dizer que

35970
23:49:50,160 --> 23:49:51,680
Isto vai dar-lhe um compilador

35971
23:49:51,680 --> 23:49:53,600
Erro, então espero que você saiba que você

35972
23:49:53,600 --> 23:49:55,760
Não pode sequer ter uma chance de acessar um

35973
23:49:55,760 --> 23:49:59,040
membro privado de uma classe base de um

35974
23:49:59,040 --> 23:50:02,080
objeto derivado na função principal como

35975
23:50:02,080 --> 23:50:05,280
Fazemos aqui, então se tentarmos fazer jogadores

35976
23:50:05,280 --> 23:50:08,080
e dizer m endereço que isso não vai

35977
23:50:08,080 --> 23:50:09,920
trabalhar bem, então se tentarmos mudar isso

35978
23:50:09,920 --> 23:50:12,080
Por exemplo, para alguns dados inúteis, este é

35979
23:50:12,080 --> 23:50:13,360
Não vamos trabalhar, vamos conseguir um

35980
23:50:13,360 --> 23:50:16,872
Erro do compilador porque isso foi declarado

35981
23:50:16,872 --> 23:50:19,280
privado na classe base e é

35982
23:50:19,280 --> 23:50:20,872
privado para a classe base que você não pode

35983
23:50:20,872 --> 23:50:23,192
realmente acessá-lo de fora de você

35984
23:50:23,192 --> 23:50:25,192
não pode nem acessá-lo de um derivado

35985
23:50:25,192 --> 23:50:28,000
Aula para muito menos acessar isso no

35986
23:50:28,000 --> 23:50:29,832
fora na função principal, então isso é

35987
23:50:29,832 --> 23:50:31,280
não vai funcionar, vai dar

35988
23:50:31,280 --> 23:50:33,360
você é um erro do compilador, mas nós vamos

35989
23:50:33,360 --> 23:50:35,192
soldar e mostrar o erro do compilador

35990
23:50:35,192 --> 23:50:37,920
Porque estamos aprendendo aqui, então estamos

35991
23:50:37,920 --> 23:50:40,480
vai ter um erro de compilador que diz

35992
23:50:40,480 --> 23:50:43,680
m endereço é privado dentro do contexto

35993
23:50:43,680 --> 23:50:45,760
onde estamos tentando usá-lo para que possamos

35994
23:50:45,760 --> 23:50:47,832
Não pode realmente usá-lo de fora

35995
23:50:47,832 --> 23:50:50,000
Aqui novamente isso vai nos dar um

35996
23:50:50,000 --> 23:50:52,552
Erro do compilador, digamos que aqui e

35997
23:50:52,552 --> 23:50:55,040
Isso é realmente o que eu queria que você

35998
23:50:55,040 --> 23:50:57,600
Saiba sobre a herança pública qualquer coisa

35999
23:50:57,600 --> 23:50:59,512
que é público na classe base é

36000
23:50:59,512 --> 23:51:02,320
Vai ser público na classe derivada

36001
23:51:02,320 --> 23:51:04,160
Tudo o que está protegido vai

36002
23:51:04,160 --> 23:51:06,872
Ficar protegido e o que isso significa

36003
23:51:06,872 --> 23:51:10,000
será utilizável na classe derivada, mas

36004
23:51:10,000 --> 23:51:12,640
você não pode usar isso de fora e

36005
23:51:12,640 --> 23:51:14,232
Tudo o que é privado na base

36006
23:51:14,232 --> 23:51:16,320
A classe vai ficar privada, então você

36007
23:51:16,320 --> 23:51:18,640
Não pode usar isso da classe derivada

36008
23:51:18,640 --> 23:51:20,872
e você não pode nem usar isso a partir do

36009
23:51:20,872 --> 23:51:22,640
Como estamos fazendo no principal

36010
23:51:22,640 --> 23:51:25,280
Função aqui, isso não vai funcionar

36011
23:51:25,280 --> 23:51:27,600
Tudo bem agora que temos isso no lugar

36012
23:51:27,600 --> 23:51:29,280
Vamos montar outra classe que

36013
23:51:29,280 --> 23:51:30,960
Vai fazer

36014
23:51:30,960 --> 23:51:33,040
Herança protegida e isso está indo

36015
23:51:33,040 --> 23:51:35,360
para ser nossa classe de enfermeira, então vamos

36016
23:51:35,360 --> 23:51:38,080
colocar isso em um cabeçalho de enfermeira

36017
23:51:38,080 --> 23:51:40,800
arquivo este vai ser enfermeira.h

36018
23:51:40,800 --> 23:51:44,080
também indo colocar em enfermeiro.cpp bem, então

36019
23:51:44,080 --> 23:51:45,920
nós vamos cabeçar no cabeçalho

36020
23:51:45,920 --> 23:51:48,800
arquivar e colocar o código para o nosso enfermeiro

36021
23:51:48,800 --> 23:51:51,040
classe vamos dizer enfermeira de cluster

36022
23:51:51,040 --> 23:51:53,280
e dizer protegido para significar que queremos

36023
23:51:53,280 --> 23:51:55,832
para fazer a herança protegida e o que

36024
23:51:55,832 --> 23:51:57,440
Isto vai fazer tudo o que é

36025
23:51:57,440 --> 23:52:00,400
O público na classe base será

36026
23:52:00,400 --> 23:52:03,280
protegido na classe derivada que é

36027
23:52:03,280 --> 23:52:05,120
nossa enfermeira classifica qualquer coisa que seja

36028
23:52:05,120 --> 23:52:07,360
Protegido vai ficar protegido

36029
23:52:07,360 --> 23:52:09,192
Tudo o que é privado vai

36030
23:52:09,192 --> 23:52:10,800
ficar privado

36031
23:52:10,800 --> 23:52:12,960
Para a classe base, isso é o que queremos dizer

36032
23:52:12,960 --> 23:52:15,280
Aqui está tudo bem agora que temos esse fim

36033
23:52:15,280 --> 23:52:18,160
pode colocar na implementação para o nosso

36034
23:52:18,160 --> 23:52:20,640
classe de enfermeira e nós vamos ter um

36035
23:52:20,640 --> 23:52:22,800
construtor e nós vamos ter o nosso

36036
23:52:22,800 --> 23:52:24,800
operador do fluxo de saída e nós estamos indo

36037
23:52:24,800 --> 23:52:26,720
ter um destruidor que realmente não é

36038
23:52:26,720 --> 23:52:28,720
Vou fazer qualquer coisa porque nós não fazemos

36039
23:52:28,720 --> 23:52:31,920
ter qualquer alocação de memória dinâmica em

36040
23:52:31,920 --> 23:52:33,192
a nossa classe

36041
23:52:33,192 --> 23:52:35,760
Vamos tentar construir este código

36042
23:52:35,760 --> 23:52:38,552
para ver que vai funcionar que temos

36043
23:52:38,552 --> 23:52:41,192
uma linha irritante no arquivo cpp principal, mas

36044
23:52:41,192 --> 23:52:44,160
Foi por causa da linha 15 aqui e

36045
23:52:44,160 --> 23:52:46,640
foi comentado para baixo, vamos ver se

36046
23:52:46,640 --> 23:52:49,192
nós podemos construir este programa OK você vê

36047
23:52:49,192 --> 23:52:51,120
que o mundo vai ser bom e

36048
23:52:51,120 --> 23:52:52,720
Somos capazes

36049
23:52:52,720 --> 23:52:54,320
para ligar

36050
23:52:54,320 --> 23:52:56,960
Obrigado pelo nosso operador de fluxo de saída

36051
23:52:56,960 --> 23:52:59,760
Você vê que temos um operando de terra que somos

36052
23:52:59,760 --> 23:53:03,280
capaz de chamar este nome de portão e obter

36053
23:53:03,280 --> 23:53:05,280
função do membro da idade

36054
23:53:05,280 --> 23:53:07,680
porque agora estão protegidos no

36055
23:53:07,680 --> 23:53:09,920
classe de enfermeira, mas somos capazes de chamá-los

36056
23:53:09,920 --> 23:53:11,512
A partir do exterior

36057
23:53:11,512 --> 23:53:15,512
porque este operador é um amigo do nosso

36058
23:53:15,512 --> 23:53:18,080
classe de enfermeira aqui eu quero que você diga isso

36059
23:53:18,080 --> 23:53:20,160
Alguns de vocês vão perguntar

36060
23:53:20,160 --> 23:53:23,192
Não estamos usando um objeto e chamando um

36061
23:53:23,192 --> 23:53:25,760
método usando o operador dot este

36062
23:53:25,760 --> 23:53:28,400
qualifica como chamando agradecimento do

36063
23:53:28,400 --> 23:53:31,600
Fora e sim, isso é verdade, mas isso

36064
23:53:31,600 --> 23:53:34,640
O método é realmente como uma função de membro

36065
23:53:34,640 --> 23:53:38,000
na verdade que tem acesso a privado e

36066
23:53:38,000 --> 23:53:40,640
dados protegidos da nossa classe de enfermeiros e

36067
23:53:40,640 --> 23:53:43,192
A razão é que é um amigo do

36068
23:53:43,192 --> 23:53:45,360
Aula de enfermagem aqui é por isso que somos capazes

36069
23:53:45,360 --> 23:53:46,480
para fazer

36070
23:53:46,480 --> 23:53:48,640
Algo assim, mas o que eu realmente

36071
23:53:48,640 --> 23:53:51,120
Você quer ver agora que essa dúvida é

36072
23:53:51,120 --> 23:53:54,320
liberado é o tipo de acesso que temos que

36073
23:53:54,320 --> 23:53:56,720
Obrigado pela classe base, ainda vamos

36074
23:53:56,720 --> 23:53:59,440
ser capaz de usar o nome completo aqui porque

36075
23:53:59,440 --> 23:54:02,480
foi herdado como protegido para que possamos

36076
23:54:02,480 --> 23:54:05,680
usá-lo a partir de uma classe derivada, podemos dizer m

36077
23:54:05,680 --> 23:54:08,640
nome completo jon snow isso vai funcionar

36078
23:54:08,640 --> 23:54:10,320
Porque isso foi

36079
23:54:10,320 --> 23:54:12,960
Herdado como protegido agora que é

36080
23:54:12,960 --> 23:54:15,360
protegidos nos olhos da classe enfermeira

36081
23:54:15,360 --> 23:54:17,512
Isto é o que queremos dizer aqui, então isso é

36082
23:54:17,512 --> 23:54:19,680
Tudo bem, isso vai funcionar que podemos conseguir

36083
23:54:19,680 --> 23:54:23,680
A idade que podemos usar isso e podemos dizer

36084
23:54:23,680 --> 23:54:25,832
João e podemos dizer

36085
23:54:25,832 --> 23:54:27,920
23, por exemplo, isso vai funcionar

36086
23:54:27,920 --> 23:54:30,400
Porque isso é protegido, mas não podemos

36087
23:54:30,400 --> 23:54:33,120
Use o endereço se fizermos isso

36088
23:54:33,120 --> 23:54:34,720
ser capaz de mudá-lo, vamos ter um

36089
23:54:34,720 --> 23:54:37,360
Erro do compilador porque

36090
23:54:37,360 --> 23:54:39,440
Isto é privado para a classe base este

36091
23:54:39,440 --> 23:54:41,192
É a mesma coisa que vimos no último

36092
23:54:41,192 --> 23:54:42,960
Uma palestra que vai nos dar uma

36093
23:54:42,960 --> 23:54:45,040
Erro do compilador se tentarmos construir isso

36094
23:54:45,040 --> 23:54:48,232
programa, vamos tentar construí-lo para realmente

36095
23:54:48,232 --> 23:54:50,320
Prova que este o corpo vai ser bom

36096
23:54:50,320 --> 23:54:53,440
sem a linha 17 aqui, mas se nós

36097
23:54:53,440 --> 23:54:55,512
não comentado e tentando construir o

36098
23:54:55,512 --> 23:54:58,000
programa, vamos fazer isso, vamos

36099
23:54:58,000 --> 23:55:00,080
obter um erro do compilador e um compilador

36100
23:55:00,080 --> 23:55:03,192
O erro vai dizer que vamos subir e

36101
23:55:03,192 --> 23:55:05,600
Veja se podemos receber esta mensagem, é

36102
23:55:05,600 --> 23:55:06,800
Vou dizer

36103
23:55:06,800 --> 23:55:10,000
m endereço é privado dentro deste contexto

36104
23:55:10,000 --> 23:55:12,400
onde estamos tentando usá-lo e isso é

36105
23:55:12,400 --> 23:55:15,120
linha 17 da classe de enfermeira se formos

36106
23:55:15,120 --> 23:55:16,960
Lá vamos encontrar a ofensa

36107
23:55:16,960 --> 23:55:18,800
linha aqui, então vamos comentar isso

36108
23:55:18,800 --> 23:55:20,552
fora e dizer que isso vai dar

36109
23:55:20,552 --> 23:55:22,320
nós somos um erro do compilador, então você

36110
23:55:22,320 --> 23:55:24,640
Não deveria fazer isso agora que nós sabemos

36111
23:55:24,640 --> 23:55:26,960
Coisas de dentro, vamos ver como

36112
23:55:26,960 --> 23:55:28,232
Coisas justas

36113
23:55:28,232 --> 23:55:31,192
do lado de fora, vamos pular

36114
23:55:31,192 --> 23:55:34,400
para o arquivo principal cpp e incluir o nosso

36115
23:55:34,400 --> 23:55:36,960
classe de enfermeira e vamos criar um

36116
23:55:36,960 --> 23:55:39,400
objeto de enfermeira, podemos descer e dizer

36117
23:55:39,400 --> 23:55:42,160
stdcl e nós vamos colocar em nosso

36118
23:55:42,160 --> 23:55:44,400
Assou e nós vamos criar uma enfermeira

36119
23:55:44,400 --> 23:55:46,160
Objeto acho que temos um padrão

36120
23:55:46,160 --> 23:55:48,720
construtor para uma enfermeira que vamos

36121
23:55:48,720 --> 23:55:51,600
Diga enfermeira 1 e nós vamos basicamente

36122
23:55:51,600 --> 23:55:53,920
Tente fazer as mesmas coisas pelas quais fizemos

36123
23:55:53,920 --> 23:55:56,800
o objeto do jogador de fora se nós

36124
23:55:56,800 --> 23:55:59,120
Tente acessar o nome completo agora que não é

36125
23:55:59,120 --> 23:56:01,360
vai ser acessível porque foi

36126
23:56:01,360 --> 23:56:02,640
Herdado

36127
23:56:02,640 --> 23:56:06,080
com nível de acesso protegido, portanto, se o fizermos

36128
23:56:06,080 --> 23:56:08,720
enfermeira e dizer m nome completo que você está indo

36129
23:56:08,720 --> 23:56:11,120
para ver que autocomplete não está aqui

36130
23:56:11,120 --> 23:56:13,192
Este é um bom sinal de que este não é

36131
23:56:13,192 --> 23:56:16,480
acessível a partir deste lugar se dissermos

36132
23:56:16,480 --> 23:56:18,640
davy jones nós vamos ter um compilador

36133
23:56:18,640 --> 23:56:20,480
Erro e se tentarmos construir, vamos

36134
23:56:20,480 --> 23:56:23,440
para obter um erro de compilador descritivo em

36135
23:56:23,440 --> 23:56:25,440
Pelo menos eu espero que vamos construir nós estamos indo

36136
23:56:25,440 --> 23:56:28,800
ver isso com o mundo com erros e

36137
23:56:28,800 --> 23:56:30,480
Se subirmos, vamos ter o nosso

36138
23:56:30,480 --> 23:56:33,192
O enfermeiro de erro não foi declarado nesta

36139
23:56:33,192 --> 23:56:36,320
O escopo você quis dizer enfermeira um sim, nós conhecemos

36140
23:56:36,320 --> 23:56:38,640
enfermeira um desculpe por isso nós vamos

36141
23:56:38,640 --> 23:56:41,680
construir novamente obrigado gcc para apontar

36142
23:56:41,680 --> 23:56:43,512
Isso vamos conseguir outro

36143
23:56:43,512 --> 23:56:46,480
tipo de erro e se olharmos para o nosso

36144
23:56:46,480 --> 23:56:48,160
Erro aqui vamos ver que m

36145
23:56:48,160 --> 23:56:50,640
O nome completo é inacessível dentro deste

36146
23:56:50,640 --> 23:56:54,000
contexto porque é um membro protegido

36147
23:56:54,000 --> 23:56:57,512
da classe de enfermagem agora que foi herdada

36148
23:56:57,512 --> 23:57:00,400
como protegido e não podemos acessá-lo a partir de

36149
23:57:00,400 --> 23:57:02,872
O exterior podemos acessar isso a partir do

36150
23:57:02,872 --> 23:57:05,440
por dentro, porque é protegido, mas se nós

36151
23:57:05,440 --> 23:57:07,360
Tente acessá-lo de fora, estamos

36152
23:57:07,360 --> 23:57:09,360
obterá um erro de compilador e isso

36153
23:57:09,360 --> 23:57:11,280
É uma característica definidora

36154
23:57:11,280 --> 23:57:14,552
de herança protegida até mesmo coisas

36155
23:57:14,552 --> 23:57:16,872
que eram públicos na classe base são

36156
23:57:16,872 --> 23:57:19,440
tornar-se protegido no derivado

36157
23:57:19,440 --> 23:57:21,600
classe, então esta é a mensagem aqui e

36158
23:57:21,600 --> 23:57:23,040
Isto vai dar-nos um compilador

36159
23:57:23,040 --> 23:57:25,680
erro bem, então se nós também tentamos acessar

36160
23:57:25,680 --> 23:57:28,320
enfermeira 1 e dizer m

36161
23:57:28,320 --> 23:57:30,480
h também vai nos dar um

36162
23:57:30,480 --> 23:57:32,552
Seta do compilador vamos tentar colocar em um

36163
23:57:32,552 --> 23:57:35,120
edge aqui vamos colocar em 51. você está indo

36164
23:57:35,120 --> 23:57:36,640
para ver que nós vamos conseguir o mesmo

36165
23:57:36,640 --> 23:57:38,080
Um tipo de erro

36166
23:57:38,080 --> 23:57:40,320
vamos realmente tentar essas coisas e

36167
23:57:40,320 --> 23:57:43,360
Saiba mais sobre todas as maneiras possíveis

36168
23:57:43,360 --> 23:57:45,040
Estar com essas coisas

36169
23:57:45,040 --> 23:57:47,120
Se olharmos para o erro que vamos

36170
23:57:47,120 --> 23:57:49,600
Veja que a imagem está protegida dentro deste

36171
23:57:49,600 --> 23:57:52,640
contexto para que não possamos realmente acessá-lo, então

36172
23:57:52,640 --> 23:57:54,960
este é o erro do compilador que oceimos e

36173
23:57:54,960 --> 23:57:57,360
Espero que você saiba que se você tentar e acessar

36174
23:57:57,360 --> 23:57:59,040
O endereço que você também vai conseguir

36175
23:57:59,040 --> 23:58:01,440
Erro do compilador porque isso é privado para

36176
23:58:01,440 --> 23:58:04,232
a classe base para que não possamos nem usar isso

36177
23:58:04,232 --> 23:58:07,120
de uma classe derivada como enfermeira aqui

36178
23:58:07,120 --> 23:58:08,872
que não vai funcionar, digamos que

36179
23:58:08,872 --> 23:58:10,872
Aqui temos um erro de compilador e estamos

36180
23:58:10,872 --> 23:58:13,040
Vou montar outra classe que é

36181
23:58:13,040 --> 23:58:16,000
indo para herdar em particular e ver como

36182
23:58:16,000 --> 23:58:18,080
que funciona a classe vai ser

36183
23:58:18,080 --> 23:58:19,920
engenheiro, vamos ver que

36184
23:58:19,920 --> 23:58:22,720
O erro aqui vai embora, então vamos criar o nosso

36185
23:58:22,720 --> 23:58:24,800
classe de engenharia que vamos colocar em um

36186
23:58:24,800 --> 23:58:27,640
arquivo de cabeçalho que vai ser o nosso

36187
23:58:27,640 --> 23:58:31,760
engineer.h também vamos colocar

36188
23:58:31,760 --> 23:58:34,480
cpp ok, então vamos pular para

36189
23:58:34,480 --> 23:58:37,120
nosso arquivo de cabeçalho e colocar em nosso engenheiro

36190
23:58:37,120 --> 23:58:39,512
classe, vamos dizer engenheiro e

36191
23:58:39,512 --> 23:58:42,232
Digamos que queremos herdar em particular

36192
23:58:42,232 --> 23:58:44,400
da classe da pessoa esta é a sintaxe

36193
23:58:44,400 --> 23:58:46,480
Aqui e isso vai fazer privado

36194
23:58:46,480 --> 23:58:49,512
Herança e o que isto significa é que

36195
23:58:49,512 --> 23:58:51,120
Tudo o que é público vai

36196
23:58:51,120 --> 23:58:54,080
tornar-se privado para esta classe qualquer coisa

36197
23:58:54,080 --> 23:58:56,160
que é protegido na classe base é

36198
23:58:56,160 --> 23:58:58,400
Vai tornar-se privado para esta classe

36199
23:58:58,400 --> 23:59:00,480
e qualquer coisa que fosse privada no

36200
23:59:00,480 --> 23:59:03,280
A classe base vai ficar privada nós

36201
23:59:03,280 --> 23:59:06,552
Não terá acesso a isso em

36202
23:59:06,552 --> 23:59:09,512
A classe derivada diretamente estamos indo

36203
23:59:09,512 --> 23:59:12,080
para pular para o arquivo cpp e colocar em

36204
23:59:12,080 --> 23:59:15,120
nossas implementações que teremos

36205
23:59:15,120 --> 23:59:17,360
um construtor padrão para engenheiro que

36206
23:59:17,360 --> 23:59:19,512
não vai tomar nenhum parâmetro

36207
23:59:19,512 --> 23:59:21,512
nós vamos ter o nosso fluxo de saída

36208
23:59:21,512 --> 23:59:24,000
Operador que ainda vai funcionar

36209
23:59:24,000 --> 23:59:26,320
Porque é amigo do engenheiro

36210
23:59:26,320 --> 23:59:29,360
classe assim todas essas coisas que foram

36211
23:59:29,360 --> 23:59:32,480
Herdado para ser privado vai ser

36212
23:59:32,480 --> 23:59:35,600
privado para a classe de engenharia e qualquer

36213
23:59:35,600 --> 23:59:37,832
Amigo da classe do engenheiro terá

36214
23:59:37,832 --> 23:59:40,160
acesso a isso é por isso que somos capazes de

36215
23:59:40,160 --> 23:59:42,872
call get full name get age e get

36216
23:59:42,872 --> 23:59:45,440
endereçar aqui e levar essas coisas para

36217
23:59:45,440 --> 23:59:47,832
trabalhe bem agora que isso está fora do

36218
23:59:47,832 --> 23:59:50,872
Como podemos tentar aceder aos nossos agradecimentos

36219
23:59:50,872 --> 23:59:52,232
Vamos tentar fazer o mesmo

36220
23:59:52,232 --> 23:59:55,280
Coisas que fizemos em nosso cabeçalho de enfermeira que somos

36221
23:59:55,280 --> 23:59:57,280
Vou copiar o código porque nós somos

36222
23:59:57,280 --> 23:59:58,800
Tentando acessar o mesmo membro

36223
23:59:58,800 --> 24:00:00,872
variáveis e vamos ver como

36224
24:00:00,872 --> 24:00:03,832
Esta feira em nossa classe de engenheiros é

36225
24:00:03,832 --> 24:00:06,480
Vou nos poupar alguns segundos

36226
24:00:06,480 --> 24:00:08,552
se tentarmos acessar o nome completo deste

36227
24:00:08,552 --> 24:00:10,720
Vai trabalhar porque é privado

36228
24:00:10,720 --> 24:00:13,280
para esta classe se tentarmos acessar o

36229
24:00:13,280 --> 24:00:15,040
edge isso vai funcionar porque tudo

36230
24:00:15,040 --> 24:00:17,120
Esses caras agora são privados

36231
24:00:17,120 --> 24:00:20,160
para esta classe aqui, mas se tentarmos

36232
24:00:20,160 --> 24:00:22,720
acessar o endereço que isso vai dar

36233
24:00:22,720 --> 24:00:25,192
nós um erro de compilador porque o endereço é

36234
24:00:25,192 --> 24:00:27,680
privado para a classe base se voltarmos

36235
24:00:27,680 --> 24:00:29,280
para pessoa nós vamos ver que isso

36236
24:00:29,280 --> 24:00:30,640
É o caso

36237
24:00:30,640 --> 24:00:33,120
e se você tentar herdar isso

36238
24:00:33,120 --> 24:00:35,600
classe de qualquer maneira que você não vai ser

36239
24:00:35,600 --> 24:00:38,480
capaz de alterar este nível de acesso este

36240
24:00:38,480 --> 24:00:40,480
A variável membro sempre vai ficar

36241
24:00:40,480 --> 24:00:43,440
privado para a classe base e sem derivado

36242
24:00:43,440 --> 24:00:46,160
A classe será capaz de modificar ou ler

36243
24:00:46,160 --> 24:00:48,480
A partir disso de qualquer forma, então este é o

36244
24:00:48,480 --> 24:00:50,720
configuração temos aqui se tentarmos construir

36245
24:00:50,720 --> 24:00:52,640
vamos ter um erro de compilador

36246
24:00:52,640 --> 24:00:54,800
Vamos primeiro tirar isso e mostrar a você

36247
24:00:54,800 --> 24:00:56,720
que isso vai construir

36248
24:00:56,720 --> 24:00:59,832
Só bem sem esta linha aqui

36249
24:00:59,832 --> 24:01:02,000
e eu vou construir novamente e mostrar

36250
24:01:02,000 --> 24:01:04,640
Você que se trouxermos isso, vamos

36251
24:01:04,640 --> 24:01:06,552
para obter um erro de compilador para que a compilação seja

36252
24:01:06,552 --> 24:01:08,960
Bom podemos voltar em nosso engenheiro

36253
24:01:08,960 --> 24:01:12,080
classe e trazer a linha ofensiva nós

36254
24:01:12,080 --> 24:01:14,640
pode descomer isso e se quisermos

36255
24:01:14,640 --> 24:01:17,040
obter um erro do compilador vamos fazer

36256
24:01:17,040 --> 24:01:19,760
Certifique-se de ver o erro do compilador aqui, então

36257
24:01:19,760 --> 24:01:22,080
O mundo acabou com erros e

36258
24:01:22,080 --> 24:01:23,920
Se subirmos, vamos ver que nós

36259
24:01:23,920 --> 24:01:26,160
tem um erro aqui e o erro é

36260
24:01:26,160 --> 24:01:28,960
indo dizer que o endereço m é privado dentro

36261
24:01:28,960 --> 24:01:31,600
Este contexto e o contexto é o que

36262
24:01:31,600 --> 24:01:34,640
ter na linha 17 no

36263
24:01:34,640 --> 24:01:36,800
classe de engenharia para que possamos ir lá e

36264
24:01:36,800 --> 24:01:38,960
Encontre a linha ofensiva e nós vamos

36265
24:01:38,960 --> 24:01:40,640
para comentar isso e isso vai

36266
24:01:40,640 --> 24:01:43,120
dar-nos um erro de compilador agora que você sabe

36267
24:01:43,120 --> 24:01:45,760
Isso mas é assim que as coisas vão

36268
24:01:45,760 --> 24:01:48,480
trabalho de dentro, mas também precisamos

36269
24:01:48,480 --> 24:01:51,512
Veja como as coisas se saem do exterior

36270
24:01:51,512 --> 24:01:54,480
vamos voltar em nosso arquivo principal cpp

36271
24:01:54,480 --> 24:01:57,280
vai incluir a nossa classe de engenharia

36272
24:01:57,280 --> 24:01:59,360
E vamos criar um engenheiro

36273
24:01:59,360 --> 24:02:02,320
Objeto que podemos descer e dizer ao sddc para fora

36274
24:02:02,320 --> 24:02:05,040
e colocar em um monte de traços para separar

36275
24:02:05,040 --> 24:02:08,160
em agradecimento e podemos criar um

36276
24:02:08,160 --> 24:02:10,872
Engenheiro objeto e isso vai ser

36277
24:02:10,872 --> 24:02:14,160
engenheiro um e se tentarmos acessar o

36278
24:02:14,160 --> 24:02:15,832
Nome completo que não vai funcionar

36279
24:02:15,832 --> 24:02:18,160
Porque agora é privado

36280
24:02:18,160 --> 24:02:20,720
para a classe do engenheiro

36281
24:02:20,720 --> 24:02:23,760
se dissermos engenheiro um e tentarmos dizer m

36282
24:02:23,760 --> 24:02:26,480
Nome completo e tentar mudar o nome em

36283
24:02:26,480 --> 24:02:28,872
de qualquer maneira e dizer, por exemplo

36284
24:02:28,872 --> 24:02:31,832


36285
24:02:31,832 --> 24:02:34,480
Não sei se esse nome existe, mas

36286
24:02:34,480 --> 24:02:36,480
O ponto é que isso não vai funcionar

36287
24:02:36,480 --> 24:02:38,552
ele vai lhe dar um erro de compilador

36288
24:02:38,552 --> 24:02:41,440
porque o nome completo m agora é privado para

36289
24:02:41,440 --> 24:02:44,720
a classe de engenheiro que foi herdado para

36290
24:02:44,720 --> 24:02:47,120
ser privado para a classe de engenharia e se

36291
24:02:47,120 --> 24:02:48,480
você tenta fazer isso, você vai ter um

36292
24:02:48,480 --> 24:02:51,360
Erro do compilador, vamos tentar trabalhar com

36293
24:02:51,360 --> 24:02:53,760
gcc para realmente mostrar-lhe isso e a

36294
24:02:53,760 --> 24:02:55,760
O mundo vai acabar com

36295
24:02:55,760 --> 24:02:57,440
erros e se subirmos, vamos

36296
24:02:57,440 --> 24:02:58,960
Encontre o nosso erro

36297
24:02:58,960 --> 24:03:01,440
O nome completo é inacessível a partir de dentro

36298
24:03:01,440 --> 24:03:04,800
Este contexto e a linha ofensiva é

36299
24:03:04,800 --> 24:03:09,280
na linha 27 do arquivo cpp principal se formos

36300
24:03:09,280 --> 24:03:11,440
Aí vamos encontrar nossa linha e

36301
24:03:11,440 --> 24:03:12,872
nós vamos dizer que isso vai

36302
24:03:12,872 --> 24:03:15,360
dar-nos um erro de compilador, então vamos dizer

36303
24:03:15,360 --> 24:03:19,280
Isso e não podemos sequer ter acesso à idade

36304
24:03:19,280 --> 24:03:21,760
e os membros do endereço variáveis a idade

36305
24:03:21,760 --> 24:03:24,232
Também será privado para projetar

36306
24:03:24,232 --> 24:03:27,680
mas o endereço é privado para a base

36307
24:03:27,680 --> 24:03:28,720
classe de classe

36308
24:03:28,720 --> 24:03:30,960
então isso não vai funcionar também, então nós

36309
24:03:30,960 --> 24:03:32,640
Não posso realmente acessar isso a partir do

36310
24:03:32,640 --> 24:03:35,760
Fora porque agora é privado para o

36311
24:03:35,760 --> 24:03:38,080
classe de engenharia, então vamos descer e

36312
24:03:38,080 --> 24:03:40,080
Realmente mostrar a você que nós vamos embora

36313
24:03:40,080 --> 24:03:43,920
para baixo e dizer engenheiro um e dizer mh se

36314
24:03:43,920 --> 24:03:45,680
Nós tentamos fazer isso que não vai

36315
24:03:45,680 --> 24:03:47,512
trabalho que nos dará um compilador

36316
24:03:47,512 --> 24:03:49,280
Erro e se tentarmos construir, vamos

36317
24:03:49,280 --> 24:03:51,920
para obter um erro de compilador ao longo do mesmo

36318
24:03:51,920 --> 24:03:54,400
linhas como o que acabamos de chegar aqui

36319
24:03:54,400 --> 24:03:56,320
O livro vai terminar com erros

36320
24:03:56,320 --> 24:03:58,232
E se olharmos para o nosso erro, vamos

36321
24:03:58,232 --> 24:04:00,800
para ver que mh está protegido dentro deste

36322
24:04:00,800 --> 24:04:04,720
contexto para que não possamos usá-lo na linha 28 de

36323
24:04:04,720 --> 24:04:07,360
o arquivo cpp principal que vai dar

36324
24:04:07,360 --> 24:04:09,512
Nós, um erro do compilador, vamos fazer isso

36325
24:04:09,512 --> 24:04:12,160
vamos dizer isso aqui e se tentarmos e

36326
24:04:12,160 --> 24:04:15,440
acessar a variável membro do endereço m

36327
24:04:15,440 --> 24:04:17,600
Isso também não vai funcionar porque

36328
24:04:17,600 --> 24:04:21,040
Isso é ainda mais restrito para o acesso

36329
24:04:21,040 --> 24:04:23,192
é privado para a classe base, então nós

36330
24:04:23,192 --> 24:04:25,192
Não pode acessá-lo de uma classe derivada

36331
24:04:25,192 --> 24:04:27,440
diretamente, não podemos acessar isso de

36332
24:04:27,440 --> 24:04:29,192
O exterior para que você realmente saiba

36333
24:04:29,192 --> 24:04:31,920
isso se colocarmos alguns dados inúteis aqui

36334
24:04:31,920 --> 24:04:33,920
e tentar construir isso vai dar

36335
24:04:33,920 --> 24:04:36,872
um erro de compilador que diz que este

36336
24:04:36,872 --> 24:04:40,320
não é acessível a partir do arquivo principal cpp

36337
24:04:40,320 --> 24:04:43,280
Como estamos tentando fazer na linha 29 aqui

36338
24:04:43,280 --> 24:04:45,360
então vamos receber um erro e

36339
24:04:45,360 --> 24:04:47,280
o erro vai dizer que m endereço é

36340
24:04:47,280 --> 24:04:50,000
privado dentro deste contexto e

36341
24:04:50,000 --> 24:04:53,680
linha ofensiva é em 29 do cpp principal

36342
24:04:53,680 --> 24:04:55,280
arquivo, vamos tirar isso e

36343
24:04:55,280 --> 24:04:56,720
nós vamos dizer que isso vai

36344
24:04:56,720 --> 24:04:58,640
dar-nos um erro de compilador este é realmente

36345
24:04:58,640 --> 24:05:01,120
Tudo que eu queria que você visse nesta palestra

36346
24:05:01,120 --> 24:05:03,360
e antes de encerrarmos isso, vamos tentar

36347
24:05:03,360 --> 24:05:05,832
construir novamente e fazer o erro desaparecer

36348
24:05:05,832 --> 24:05:08,720
Porque eu não gosto de deixar você com

36349
24:05:08,720 --> 24:05:11,120
código que tem erros de compilador e

36350
24:05:11,120 --> 24:05:13,760
O livro é bom e isso é realmente tudo

36351
24:05:13,760 --> 24:05:16,232
Queria que você visse nesta palestra que

36352
24:05:16,232 --> 24:05:19,040
você pode fazer todos os tipos de heranças em

36353
24:05:19,040 --> 24:05:21,440
seu c plus código que você pode fazer público

36354
24:05:21,440 --> 24:05:23,192
Herança que você pode fazer protegido

36355
24:05:23,192 --> 24:05:25,192
Herança você pode fazer privado

36356
24:05:25,192 --> 24:05:27,360
Herança e tivemos uma chance de olhar

36357
24:05:27,360 --> 24:05:29,832
em todos esses cenários nesta palestra

36358
24:05:29,832 --> 24:05:32,640
Aqui a mensagem é a mesma que vimos

36359
24:05:32,640 --> 24:05:35,440
na última palestra se você fizer o público

36360
24:05:35,440 --> 24:05:37,832
herança de tudo o que é público em

36361
24:05:37,832 --> 24:05:40,552
A classe base vai permanecer pública

36362
24:05:40,552 --> 24:05:42,552
na classe derivada, qualquer coisa que seja

36363
24:05:42,552 --> 24:05:44,720
Protegido vai ficar protegido

36364
24:05:44,720 --> 24:05:46,320
Tudo o que é privado vai

36365
24:05:46,320 --> 24:05:49,040
ficar privado e isso é realmente

36366
24:05:49,040 --> 24:05:52,080
enganar de uma forma que os dados privados

36367
24:05:52,080 --> 24:05:54,160
da classe base não vai ser

36368
24:05:54,160 --> 24:05:56,800
privado para a classe derivada que está indo

36369
24:05:56,800 --> 24:06:00,800
para ficar privado para a classe base, então se

36370
24:06:00,800 --> 24:06:03,360
você tenta usar isso de qualquer maneira a partir do

36371
24:06:03,360 --> 24:06:04,640
classes derivadas que você vai conseguir

36372
24:06:04,640 --> 24:06:07,040
erros de compilador porque você não pode acessar

36373
24:06:07,040 --> 24:06:10,160
que mesmo que seja parte de você jogador

36374
24:06:10,160 --> 24:06:12,720
tem uma pessoa parte dele, mas não pode

36375
24:06:12,720 --> 24:06:15,192
Acesse membros privados a partir da base

36376
24:06:15,192 --> 24:06:17,280
classe que você realmente deve saber disso nós

36377
24:06:17,280 --> 24:06:19,512
Temos visto que nós também podemos fazer proteção

36378
24:06:19,512 --> 24:06:21,040
Herança e isso vai

36379
24:06:21,040 --> 24:06:23,280
restringir os eventos para ter

36380
24:06:23,280 --> 24:06:25,680
O mais alto nível de acesso a ser

36381
24:06:25,680 --> 24:06:28,232
protegidos para que tudo o que é público seja

36382
24:06:28,232 --> 24:06:30,552
vai ser despojado para ser protegido

36383
24:06:30,552 --> 24:06:33,120
O acesso a qualquer coisa protegida é

36384
24:06:33,120 --> 24:06:35,440
Vou ficar protegido tudo o que é

36385
24:06:35,440 --> 24:06:38,080
O privado será privado para o

36386
24:06:38,080 --> 24:06:40,640
classe base que você realmente deve fazer isso

36387
24:06:40,640 --> 24:06:42,640
super claro nós também podemos fazer privado

36388
24:06:42,640 --> 24:06:45,040
herança como vimos e isso está indo

36389
24:06:45,040 --> 24:06:47,920
para remover o acesso de nível mais alto

36390
24:06:47,920 --> 24:06:50,480
para ser privado, então tudo o que é público

36391
24:06:50,480 --> 24:06:52,960
Vai ser constrangido a ser privado

36392
24:06:52,960 --> 24:06:54,872
Tudo o que está protegido vai

36393
24:06:54,872 --> 24:06:57,832
ser herdado como protegido ao jogador

36394
24:06:57,832 --> 24:07:00,400
classe, mas tudo o que era privado em

36395
24:07:00,400 --> 24:07:03,120
A classe base vai ficar privada

36396
24:07:03,120 --> 24:07:05,680
para a classe base até mesmo a classe do jogador

36397
24:07:05,680 --> 24:07:07,920
Não terá acesso a este membro

36398
24:07:07,920 --> 24:07:10,640
diretamente se realmente precisamos de acesso a

36399
24:07:10,640 --> 24:07:12,872
dados privados da classe base que nós

36400
24:07:12,872 --> 24:07:15,040
pode passar por getters públicos ou

36401
24:07:15,040 --> 24:07:17,512
qualquer coisa que obtemos da classe base, mas

36402
24:07:17,512 --> 24:07:20,320
não podemos acessar o m3 diretamente e usá-lo

36403
24:07:20,320 --> 24:07:22,400
da classe derivada que vai

36404
24:07:22,400 --> 24:07:24,640
dar-nos um erro de compilador este é realmente

36405
24:07:24,640 --> 24:07:26,800
Tudo que eu queria que você visse nesta palestra

36406
24:07:26,800 --> 24:07:29,192
E espero que você ache este interessante

36407
24:07:29,192 --> 24:07:31,280
Vou parar aqui nesta palestra

36408
24:07:31,280 --> 24:07:32,872
No próximo vamos tentar

36409
24:07:32,872 --> 24:07:36,160
zoom em herança privada e show

36410
24:07:36,160 --> 24:07:38,160
Você algumas coisas que você realmente precisa ser

36411
24:07:38,160 --> 24:07:39,440
Cuidado com isso

36412
24:07:39,440 --> 24:07:41,512
então vá em frente e termine aqui e conheça

36413
24:07:41,512 --> 24:07:42,480
eu lá

36414
24:07:42,480 --> 24:07:44,400
Nesta palestra vamos ampliar

36415
24:07:44,400 --> 24:07:47,120
em herança privada e nós vamos

36416
24:07:47,120 --> 24:07:49,040
para ver que a classe que faz a

36417
24:07:49,040 --> 24:07:52,400
A herança privada é realmente egoísta

36418
24:07:52,400 --> 24:07:54,552
Aqui está uma estrutura simples que seremos

36419
24:07:54,552 --> 24:07:56,552
usando nesta palestra aqui vamos definir

36420
24:07:56,552 --> 24:07:58,720
uma classe de pessoa que vai agir

36421
24:07:58,720 --> 24:08:01,512
Como nossa classe base, vamos

36422
24:08:01,512 --> 24:08:04,080
herdar desta classe em particular e

36423
24:08:04,080 --> 24:08:06,400
Criar uma classe de engenheiro

36424
24:08:06,400 --> 24:08:08,400
E o que isso vai fazer, está indo

36425
24:08:08,400 --> 24:08:12,000
para tirar tudo da pessoa de classe

36426
24:08:12,000 --> 24:08:15,040
e torná-lo privado para o engenheiro

36427
24:08:15,040 --> 24:08:17,920
classe assim o m1 variável membro que

36428
24:08:17,920 --> 24:08:20,232
O público na classe base está indo para

36429
24:08:20,232 --> 24:08:22,960
ser privado para a classe de engenharia este é

36430
24:08:22,960 --> 24:08:25,920
O que temos aqui a variável m2 membro

36431
24:08:25,920 --> 24:08:28,080
O que estava protegido vai se tornar um

36432
24:08:28,080 --> 24:08:31,192
privado no engenheiro isso é o que temos

36433
24:08:31,192 --> 24:08:32,080
Aqui

36434
24:08:32,080 --> 24:08:34,400
e a variável membro m3 que foi

36435
24:08:34,400 --> 24:08:37,600
Classe privada para pessoa vai ficar

36436
24:08:37,600 --> 24:08:40,872
privado para pessoa nos olhos de

36437
24:08:40,872 --> 24:08:43,120
Engenheiro esta é a situação que temos

36438
24:08:43,120 --> 24:08:45,280
Então o problema vai realmente

36439
24:08:45,280 --> 24:08:48,232
aparecer quando alguém tenta

36440
24:08:48,232 --> 24:08:52,800
Herdeira do engenheiro porque m1 e m2

36441
24:08:52,800 --> 24:08:55,832
Agora são privadas para projetar que serão

36442
24:08:55,832 --> 24:08:59,512
herdado, mas ainda inacessível ao

36443
24:08:59,512 --> 24:09:03,120
classe de engenheiro civil aqui m1 e m2 vai

36444
24:09:03,120 --> 24:09:07,192
ser privado para a classe de engenharia, mas m3

36445
24:09:07,192 --> 24:09:10,320
Será privado para a classe base que

36446
24:09:10,320 --> 24:09:12,872
É pessoa, então espero que você possa ver o

36447
24:09:12,872 --> 24:09:15,512
mensagem que se uma variável de membro é

36448
24:09:15,512 --> 24:09:16,552
Privado

36449
24:09:16,552 --> 24:09:19,120
Não pode ser herdado de forma alguma

36450
24:09:19,120 --> 24:09:21,040
Não importa que tipo de herança

36451
24:09:21,040 --> 24:09:23,680
Você faz isso a partir do engenheiro, que

36452
24:09:23,680 --> 24:09:28,400
fez m1 e m2 privado para si

36453
24:09:28,400 --> 24:09:31,040
Já não é possível encaminhar estes

36454
24:09:31,040 --> 24:09:34,720
Caras para baixo na hierarquia de herança

36455
24:09:34,720 --> 24:09:36,552
Outra maneira de olhar para isso é ver

36456
24:09:36,552 --> 24:09:38,400
que a classe do engenheiro é realmente

36457
24:09:38,400 --> 24:09:41,440
egoísta, está dizendo que eu vou levar

36458
24:09:41,440 --> 24:09:43,760
Tudo o que posso obter dos meus pais

36459
24:09:43,760 --> 24:09:46,232
aulas porque eu sou

36460
24:09:46,232 --> 24:09:49,192
Herdar em particular, mas ninguém mais

36461
24:09:49,192 --> 24:09:51,120
Será capaz de tirar as coisas de mim

36462
24:09:51,120 --> 24:09:52,960
Porque eu vou torná-los privados

36463
24:09:52,960 --> 24:09:55,832
para mim, mesmo que engenheiro civil seja

36464
24:09:55,832 --> 24:09:58,320
Fazendo a herança pública

36465
24:09:58,320 --> 24:10:00,800
que não lhe dará acesso

36466
24:10:00,800 --> 24:10:03,600
para essas variáveis de membros que agora são

36467
24:10:03,600 --> 24:10:06,160
privado para a classe de engenharia esperançosamente

36468
24:10:06,160 --> 24:10:08,960
Você pode realmente ver isso e privado

36469
24:10:08,960 --> 24:10:12,000
A herança vai realmente restringir

36470
24:10:12,000 --> 24:10:14,960
O que você pode avançar para baixo para outros

36471
24:10:14,960 --> 24:10:17,280
Classes que vão herdar

36472
24:10:17,280 --> 24:10:19,832
A partir de você esta é a mensagem que eu estou tentando

36473
24:10:19,832 --> 24:10:22,720
para transmitir aqui ok, então aqui é o mesmo

36474
24:10:22,720 --> 24:10:25,192
exemplo no código temos nossa classe de pessoa

36475
24:10:25,192 --> 24:10:27,360
terá nossas variáveis de membro

36476
24:10:27,360 --> 24:10:29,440
nós vamos ter o nome completo de

36477
24:10:29,440 --> 24:10:31,600
idade eo endereço que eles vão

36478
24:10:31,600 --> 24:10:35,040
ter acesso público protegido e privado

36479
24:10:35,040 --> 24:10:37,600
Vamos herdar da pessoa e

36480
24:10:37,600 --> 24:10:40,160
criar nossa classe de engenheiros que estamos indo

36481
24:10:40,160 --> 24:10:42,800
para herdar privadamente da pessoa e

36482
24:10:42,800 --> 24:10:45,280
Isto vai levar tudo o que temos

36483
24:10:45,280 --> 24:10:48,960
de pessoa e torná-lo privado para o

36484
24:10:48,960 --> 24:10:51,512
classe de engenharia e uma exceção é

36485
24:10:51,512 --> 24:10:52,800
Vou ser

36486
24:10:52,800 --> 24:10:55,440
O que já era privado para a base

36487
24:10:55,440 --> 24:10:57,600
classe que é a nossa classe de pessoa aqui

36488
24:10:57,600 --> 24:11:00,080
Isso ainda vai ficar privado para

36489
24:11:00,080 --> 24:11:03,040
A classe da pessoa, independentemente de que tipo

36490
24:11:03,040 --> 24:11:05,920
de herança que você faz de pessoa, mas

36491
24:11:05,920 --> 24:11:08,000
qualquer outra coisa se tivermos algum membro

36492
24:11:08,000 --> 24:11:10,640
variável que são públicos ou protegidos

36493
24:11:10,640 --> 24:11:12,872
ou mesmo se tivermos algumas funções de membro

36494
24:11:12,872 --> 24:11:15,832
que são públicos ou protegidos tudo

36495
24:11:15,832 --> 24:11:18,480
Vai ser privado para o engenheiro

36496
24:11:18,480 --> 24:11:20,960
classe porque nós fizemos privado

36497
24:11:20,960 --> 24:11:24,400
herança aqui, então se herdarmos de

36498
24:11:24,400 --> 24:11:27,360
Engenheiro e faça qualquer tipo de herança

36499
24:11:27,360 --> 24:11:30,480
Vamos fazer o tipo mais relaxado

36500
24:11:30,480 --> 24:11:32,480
de herança que vai manter

36501
24:11:32,480 --> 24:11:35,120
O tipo de acesso que tivemos na base

36502
24:11:35,120 --> 24:11:37,600
classe, mas isso não vai melhorar

36503
24:11:37,600 --> 24:11:40,160
Tudo o que tudo vai ficar

36504
24:11:40,160 --> 24:11:43,680
privado para a classe de engenharia e a

36505
24:11:43,680 --> 24:11:45,440
O engenheiro civil realmente não vai

36506
24:11:45,440 --> 24:11:48,400
ter qualquer acesso a qualquer variável de membro

36507
24:11:48,400 --> 24:11:50,720
ou função de membro que é herdada

36508
24:11:50,720 --> 24:11:53,040
da classe do engenheiro e nós vamos

36509
24:11:53,040 --> 24:11:54,720
para ver isso em um minuto quando nós batemos

36510
24:11:54,720 --> 24:11:56,960
código de estúdio visual

36511
24:11:56,960 --> 24:11:59,680
então, novamente, se uma classe está fazendo privado

36512
24:11:59,680 --> 24:12:01,920
Herança é realmente outra maneira de

36513
24:12:01,920 --> 24:12:04,232
Diga que esta classe é egoísta que vai

36514
24:12:04,232 --> 24:12:07,040
tome tudo o que puder do pai

36515
24:12:07,040 --> 24:12:09,280
classe, mas não vai para a frente

36516
24:12:09,280 --> 24:12:12,320
Nada para a herança a jusante

36517
24:12:12,320 --> 24:12:14,720
classes e esta é a configuração que eu realmente

36518
24:12:14,720 --> 24:12:17,760
Quero que você entenda aqui e só faça

36519
24:12:17,760 --> 24:12:20,160
Herança privada quando você quer isso

36520
24:12:20,160 --> 24:12:22,480
tipo de comportamento agora que você sabe disso

36521
24:12:22,480 --> 24:12:23,832
nós vamos ir para o visual

36522
24:12:23,832 --> 24:12:25,680
código de estúdio e jogar com a gente um pouco

36523
24:12:25,680 --> 24:12:26,552
Mais

36524
24:12:26,552 --> 24:12:29,280
Aqui estamos em nossa pasta de trabalho o

36525
24:12:29,280 --> 24:12:32,320
O projeto atual está se aproximando do privado

36526
24:12:32,320 --> 24:12:34,552
Herança, vamos ampliar

36527
24:12:34,552 --> 24:12:37,680
Isso e realmente entender os efeitos

36528
24:12:37,680 --> 24:12:40,080
de fazer herança privada que estamos indo

36529
24:12:40,080 --> 24:12:42,000
para pegar o código do anterior

36530
24:12:42,000 --> 24:12:43,760
palestra e nós vamos pegar o

36531
24:12:43,760 --> 24:12:45,192
Engenheiro

36532
24:12:45,192 --> 24:12:46,400
E a

36533
24:12:46,400 --> 24:12:49,040
A classe da pessoa estes vão ser

36534
24:12:49,040 --> 24:12:51,440
Nosso ponto de partida aqui garante que você

36535
24:12:51,440 --> 24:12:54,232
Pegue a pasta ponto vs código se você estiver

36536
24:12:54,232 --> 24:12:56,640
usando vs código com este curso que é

36537
24:12:56,640 --> 24:12:58,640
vamos dar as configurações básicas que nós

36538
24:12:58,640 --> 24:13:01,600
necessidade de fazer o nosso c plus plus programa i am

36539
24:13:01,600 --> 24:13:04,480
indo copiar esses caras para baixo e colocar

36540
24:13:04,480 --> 24:13:07,832
nestes em nosso projeto atual e novamente

36541
24:13:07,832 --> 24:13:10,480
certifique-se de que você tem o arquivo cpp principal

36542
24:13:10,480 --> 24:13:13,360
classe de pessoa e a classe de engenharia e

36543
24:13:13,360 --> 24:13:15,512
Estes serão o nosso ponto de partida

36544
24:13:15,512 --> 24:13:17,120
Vamos abrir este pequeno rapaz

36545
24:13:17,120 --> 24:13:19,192
em código de estúdio visual arrastando e

36546
24:13:19,192 --> 24:13:22,232
deixando cair aqui, vamos olhar para o nosso

36547
24:13:22,232 --> 24:13:25,040
programa principal do cpp que não vamos

36548
24:13:25,040 --> 24:13:28,320
inclua enfermeira porque não temos isso

36549
24:13:28,320 --> 24:13:29,760
Incluído aqui

36550
24:13:29,760 --> 24:13:32,480
e nós podemos realmente tirar tudo o que nós

36551
24:13:32,480 --> 24:13:35,040
Temos na função principal que vamos

36552
24:13:35,040 --> 24:13:37,600
Adicionamos a nossa própria coisa aqui também

36553
24:13:37,600 --> 24:13:40,080
Não preciso da classe do jogador aqui estamos

36554
24:13:40,080 --> 24:13:42,320
Vou usar a pessoa e

36555
24:13:42,320 --> 24:13:45,040
Engenheiro, veja a classe da pessoa

36556
24:13:45,040 --> 24:13:46,960
vai ter as variáveis do membro

36557
24:13:46,960 --> 24:13:48,800
O que esperamos

36558
24:13:48,800 --> 24:13:50,720
Vamos ter um membro público

36559
24:13:50,720 --> 24:13:53,120
variável o nome completo um protegido

36560
24:13:53,120 --> 24:13:55,832
membro variável mh e um membro privado

36561
24:13:55,832 --> 24:13:58,480
variável m endereço aqui estamos indo para

36562
24:13:58,480 --> 24:14:01,512
criar uma classe de engenheiro que está indo

36563
24:14:01,512 --> 24:14:04,640
para herdar privadamente da pessoa

36564
24:14:04,640 --> 24:14:06,480
então vai fazer tudo

36565
24:14:06,480 --> 24:14:09,192
privado para si mesmo a classe de engenharia é

36566
24:14:09,192 --> 24:14:12,720
vou ter uma pessoa participando, mas

36567
24:14:12,720 --> 24:14:15,680
as variáveis membros que olhemos a partir do

36568
24:14:15,680 --> 24:14:17,832
A classe de pessoa vai ser despojada

36569
24:14:17,832 --> 24:14:22,000
até o nível de acesso privado, exceto para

36570
24:14:22,000 --> 24:14:24,400
as variáveis membros que já são

36571
24:14:24,400 --> 24:14:26,640
Privado na classe base e que

36572
24:14:26,640 --> 24:14:29,192
Acontece que é o endereço para que não

36573
24:14:29,192 --> 24:14:31,360
importa qual tipo de herança você faz

36574
24:14:31,360 --> 24:14:33,600
a variável de membro de endereço m está indo

36575
24:14:33,600 --> 24:14:36,160
Ainda não estar acessível a

36576
24:14:36,160 --> 24:14:38,552
Classes de herança, isso vai

36577
24:14:38,552 --> 24:14:41,600
ainda ser privado para a classe base que

36578
24:14:41,600 --> 24:14:44,480
É a classe da pessoa aqui, então o

36579
24:14:44,480 --> 24:14:46,640
O nome completo vai ser despojado

36580
24:14:46,640 --> 24:14:50,080
para nível de acesso privado em engenheiro

36581
24:14:50,080 --> 24:14:52,160
A borda também vai ser despojada

36582
24:14:52,160 --> 24:14:54,960
para o acesso privado e estes vão

36583
24:14:54,960 --> 24:14:58,640
ser privado agora para a classe de engenharia e

36584
24:14:58,640 --> 24:15:01,192
qualquer classe que tenta herdar de

36585
24:15:01,192 --> 24:15:03,832
Engenheiro não terá acesso a

36586
24:15:03,832 --> 24:15:06,720
Esses caras, então se fizermos qualquer tipo de

36587
24:15:06,720 --> 24:15:08,552
Herança do engenheiro que queremos

36588
24:15:08,552 --> 24:15:10,552
ter acesso ao nome completo que queremos ter

36589
24:15:10,552 --> 24:15:12,800
acesso ao mh porque estes vão

36590
24:15:12,800 --> 24:15:16,000
ser privado para esta classe aqui este é

36591
24:15:16,000 --> 24:15:18,160
A configuração que queremos entender neste

36592
24:15:18,160 --> 24:15:20,320
para que o que vamos fazer, estamos

36593
24:15:20,320 --> 24:15:22,000
Vou montar uma nova classe que é

36594
24:15:22,000 --> 24:15:25,120
vai herdar da nossa classe de engenheiros

36595
24:15:25,120 --> 24:15:28,000
e vai fazer herança pública

36596
24:15:28,000 --> 24:15:29,760
e vamos ver como isso funciona

36597
24:15:29,760 --> 24:15:31,680
Vamos criar um engenheiro civil

36598
24:15:31,680 --> 24:15:33,440
classe que vai herdar de

36599
24:15:33,440 --> 24:15:35,512
Engenheiro, então vamos fazer isso, vamos

36600
24:15:35,512 --> 24:15:37,680
criar um arquivo de cabeçalho para o nosso civil

36601
24:15:37,680 --> 24:15:40,000
classe de engenharia e vamos criar

36602
24:15:40,000 --> 24:15:41,920
um arquivo cpp

36603
24:15:41,920 --> 24:15:44,400
Vamos nos dirigir em nosso cabeçalho

36604
24:15:44,400 --> 24:15:46,480
arquivo e colocar na classe que não está indo

36605
24:15:46,480 --> 24:15:49,440
para sermos qualquer coisa sofisticada, somos apenas

36606
24:15:49,440 --> 24:15:51,440
ter em nossa inclusão guarda que estamos

36607
24:15:51,440 --> 24:15:53,440
Criar uma classe de engenheiro civil

36608
24:15:53,440 --> 24:15:55,600
que vai herdar publicamente de

36609
24:15:55,600 --> 24:15:58,232
Engenheiro, mas lembre-se que tudo estava

36610
24:15:58,232 --> 24:16:01,192
feito privado para a classe de engenharia assim

36611
24:16:01,192 --> 24:16:03,832
Mesmo se estivermos fazendo herança pública

36612
24:16:03,832 --> 24:16:05,760
a variável de membro de nome completo está indo

36613
24:16:05,760 --> 24:16:08,080
ser privado para projetar a idade é

36614
24:16:08,080 --> 24:16:10,080
Vai ser privado para projetar e

36615
24:16:10,080 --> 24:16:12,480
O engenheiro não terá acesso a estes

36616
24:16:12,480 --> 24:16:14,872
Caras, mas antes realmente jogamos com isso

36617
24:16:14,872 --> 24:16:17,360
Vamos colocar em nossa implementação

36618
24:16:17,360 --> 24:16:19,040
no arquivo cpp

36619
24:16:19,040 --> 24:16:21,280
Então vamos colocar o código aqui estamos

36620
24:16:21,280 --> 24:16:24,080
para colocar na implementação e

36621
24:16:24,080 --> 24:16:26,232
Vamos ter o nosso construtor em

36622
24:16:26,232 --> 24:16:29,192
lugar, mas observe o que acontece em nosso

36623
24:16:29,192 --> 24:16:32,480
operador do fluxo de saída do fluxo de saída

36624
24:16:32,480 --> 24:16:35,512
O operador é um amigo do civil

36625
24:16:35,512 --> 24:16:38,160
classe de engenharia para que ele deve ter acesso

36626
24:16:38,160 --> 24:16:40,640
para qualquer coisa que temos em nosso civil

36627
24:16:40,640 --> 24:16:43,120
classe de engenheiro, mas observe o que é

36628
24:16:43,120 --> 24:16:44,400
A acontecer aqui

36629
24:16:44,400 --> 24:16:47,440
o método de nome completo não está funcionando

36630
24:16:47,440 --> 24:16:49,920
Porque foi feito

36631
24:16:49,920 --> 24:16:53,120
privado para a classe upstream que

36632
24:16:53,120 --> 24:16:54,800
Acontece que ser

36633
24:16:54,800 --> 24:16:57,192
nossa classe de engenheiros e não podemos realmente

36634
24:16:57,192 --> 24:16:59,512
acessá-los mesmo se soubermos que

36635
24:16:59,512 --> 24:17:02,720
são realmente parte da interface do

36636
24:17:02,720 --> 24:17:04,960
classe de pessoa que temos como público

36637
24:17:04,960 --> 24:17:08,232
membros da classe da pessoa, mas quando

36638
24:17:08,232 --> 24:17:11,440
A classe de engenheiros fez herança privada

36639
24:17:11,440 --> 24:17:14,552
fez tudo o que não é privado

36640
24:17:14,552 --> 24:17:17,920
para pessoa privada para si mesma para que estes

36641
24:17:17,920 --> 24:17:20,320
Os gatadores vão ser privados para

36642
24:17:20,320 --> 24:17:23,360
Engenheiro quando faz privado

36643
24:17:23,360 --> 24:17:25,760
herança das variáveis membros que

36644
24:17:25,760 --> 24:17:27,760
São públicos e protegidos todos estes

36645
24:17:27,760 --> 24:17:30,232
As coisas vão ser despojadas para baixo

36646
24:17:30,232 --> 24:17:32,960
Nível de acesso privado para que eles estejam indo

36647
24:17:32,960 --> 24:17:35,832
ser privado para projetar e qualquer tipo

36648
24:17:35,832 --> 24:17:37,832
de herança que você vai fazer não é

36649
24:17:37,832 --> 24:17:39,920
Vou mudar que eles vão

36650
24:17:39,920 --> 24:17:42,720
ser herdado como privado para o engenheiro

36651
24:17:42,720 --> 24:17:45,512
Classe é por isso que não podemos sequer chamá-los

36652
24:17:45,512 --> 24:17:48,720
de uma função que é um amigo de nossa

36653
24:17:48,720 --> 24:17:51,600
classe de engenharia civil e sabemos disso se

36654
24:17:51,600 --> 24:17:53,280
Você marca algo como um amigo é

36655
24:17:53,280 --> 24:17:55,680
Realmente vai ter acesso a qualquer coisa

36656
24:17:55,680 --> 24:17:58,552
Você tem incluindo membros privados, mas

36657
24:17:58,552 --> 24:18:01,600
Não podemos chamar nenhum dos membros de

36658
24:18:01,600 --> 24:18:03,680
A classe do engenheiro porque tudo é

36659
24:18:03,680 --> 24:18:06,000
agora privado para a classe de engenheiro esta

36660
24:18:06,000 --> 24:18:08,000
é o que eu quero que você veja se você faz

36661
24:18:08,000 --> 24:18:10,000
Herança privada isto vai

36662
24:18:10,000 --> 24:18:11,832
Real realmente tira para baixo

36663
24:18:11,832 --> 24:18:14,480
qualquer coisa da classe upstream e

36664
24:18:14,480 --> 24:18:16,960
tornar isso privado para a classe que é

36665
24:18:16,960 --> 24:18:18,872
Fazendo herança privada, este é o

36666
24:18:18,872 --> 24:18:22,000
mensagem aqui e novamente se você for em algum

36667
24:18:22,000 --> 24:18:24,320
método da classe de engenharia civil e

36668
24:18:24,320 --> 24:18:27,280
Tente fazer qualquer tipo de acesso, por exemplo

36669
24:18:27,280 --> 24:18:29,360
Chamando o nome completo

36670
24:18:29,360 --> 24:18:32,080
O método não vai embarcar bem, estamos

36671
24:18:32,080 --> 24:18:34,000
Vou ver que isso é inacessível

36672
24:18:34,000 --> 24:18:37,440
Aqui se tentarmos acessar o nome completo m

36673
24:18:37,440 --> 24:18:39,600
Por exemplo, mudar isso para ser algo

36674
24:18:39,600 --> 24:18:41,680
mais vamos dizer daniel

36675
24:18:41,680 --> 24:18:44,000
cinza isso não vai funcionar se você

36676
24:18:44,000 --> 24:18:46,080
Tente acessar o mh

36677
24:18:46,080 --> 24:18:48,552
e alterá-lo para 45, por exemplo, isso é

36678
24:18:48,552 --> 24:18:50,640
Não vamos trabalhar, já sabemos que

36679
24:18:50,640 --> 24:18:52,872
O endereço é privado para pessoa, então nós

36680
24:18:52,872 --> 24:18:54,480
Não deveria realmente tentar acessá-lo

36681
24:18:54,480 --> 24:18:58,160
porque é inacessível, independentemente de

36682
24:18:58,160 --> 24:19:00,960
qualquer tipo de herança que você faz, mas a

36683
24:19:00,960 --> 24:19:03,192
Membros que eram públicos de pessoas

36684
24:19:03,192 --> 24:19:06,080
Não pode ser acessado a partir de qualquer classe que seja

36685
24:19:06,080 --> 24:19:09,440
Herdar de pessoa, mesmo que saibamos

36686
24:19:09,440 --> 24:19:11,280
que essas coisas são públicas ou

36687
24:19:11,280 --> 24:19:13,760
Protegido na classe da pessoa

36688
24:19:13,760 --> 24:19:15,920
E isso é realmente o que eu quero que você

36689
24:19:15,920 --> 24:19:18,720
Veja se tentamos construir nosso programa

36690
24:19:18,720 --> 24:19:20,320
nós vamos ter um monte de compilador

36691
24:19:20,320 --> 24:19:22,872
erros dizendo que não podemos acessar estes

36692
24:19:22,872 --> 24:19:23,760
Os rapazes

36693
24:19:23,760 --> 24:19:26,960
da nossa classe de engenheiros civis somos

36694
24:19:26,960 --> 24:19:29,120
Vou usar o compilador gcc aqui

36695
24:19:29,120 --> 24:19:31,040
Porque é o nosso favorito e nós somos

36696
24:19:31,040 --> 24:19:33,280
vamos ver nossos erros de compilador aqui

36697
24:19:33,280 --> 24:19:35,832
Tudo bem, então nós vamos ter um monte de

36698
24:19:35,832 --> 24:19:39,360
Erros, vamos subir e ver todos eles

36699
24:19:39,360 --> 24:19:41,280
nós vamos ter um erro dizendo que

36700
24:19:41,280 --> 24:19:44,832
getfullname é inacessível dentro do

36701
24:19:44,832 --> 24:19:48,800
contexto da classe de cabeçalho do engenheiro c4

36702
24:19:48,800 --> 24:19:51,760
Na linha 13 estamos chamando este método

36703
24:19:51,760 --> 24:19:54,960
que não vai funcionar, temos outro

36704
24:19:54,960 --> 24:19:57,680
Erro aqui dizendo que o befullname

36705
24:19:57,680 --> 24:20:01,040
O método não é acessível a partir da linha 13 de

36706
24:20:01,040 --> 24:20:03,192
O cabeçalho do engenheiro civil

36707
24:20:03,192 --> 24:20:05,600
Ok é realmente o mesmo erro, mas se

36708
24:20:05,600 --> 24:20:07,832
nós descemos, vemos que temos um monte de

36709
24:20:07,832 --> 24:20:10,800
outros erros temos o nome completo m que

36710
24:20:10,800 --> 24:20:13,832
não é acessível, temos m borda que

36711
24:20:13,832 --> 24:20:16,232
Não é acessível, não podemos realmente fazer

36712
24:20:16,232 --> 24:20:18,872
esses tipos de coisas do civil

36713
24:20:18,872 --> 24:20:20,872
classe de engenharia, porque todos estes são

36714
24:20:20,872 --> 24:20:23,512
Vai tornar-se privado para o upstream

36715
24:20:23,512 --> 24:20:26,960
classe que fez herança privada assim

36716
24:20:26,960 --> 24:20:29,120
Vamos tirar isso e

36717
24:20:29,120 --> 24:20:32,000
mostrar isso, mesmo que não possamos acessar

36718
24:20:32,000 --> 24:20:34,872
Esses caras eles ainda fazem parte do nosso

36719
24:20:34,872 --> 24:20:36,552
classe de engenheiro civil e nós vamos

36720
24:20:36,552 --> 24:20:39,280
Use um depurador para fazer isso eu vou

36721
24:20:39,280 --> 24:20:41,832
tirar essas coisas ou posso comentar

36722
24:20:41,832 --> 24:20:44,160
para fora e dizer que eles vão

36723
24:20:44,160 --> 24:20:46,160
dar-lhe erros de compilador eu acho que isso é

36724
24:20:46,160 --> 24:20:48,160
Vai ser mais descritivo, então vamos

36725
24:20:48,160 --> 24:20:49,760
Diga o erro do compilador

36726
24:20:49,760 --> 24:20:52,000
e o acesso à borda também vai

36727
24:20:52,000 --> 24:20:54,400
dar-lhe um erro de compilador e nós estamos

36728
24:20:54,400 --> 24:20:56,872
indo para descer e mostrar que nós somos

36729
24:20:56,872 --> 24:20:59,120
Também terá o mesmo problema em

36730
24:20:59,120 --> 24:21:01,760
nosso operador de fluxo de saída, então se você

36731
24:21:01,760 --> 24:21:04,232
realmente quer o seu operador de fluxo de saída

36732
24:21:04,232 --> 24:21:07,360
Para trabalhar aqui o que você pode fazer é colocar alguns

36733
24:21:07,360 --> 24:21:09,192
Os membros do público

36734
24:21:09,192 --> 24:21:12,080
na classe do engenheiro e fazê-lo dar

36735
24:21:12,080 --> 24:21:15,120
Você acessa os membros que foram

36736
24:21:15,120 --> 24:21:18,232
Eclipsado para acesso privado nesta classe

36737
24:21:18,232 --> 24:21:20,400
Aqui, por exemplo, você pode devolver a plenitude

36738
24:21:20,400 --> 24:21:22,160
O nome você vê que podemos acessar isso

36739
24:21:22,160 --> 24:21:24,400
Aqui você pode voltar a idade, mas você

36740
24:21:24,400 --> 24:21:27,040
ainda não tem acesso ao endereço m

36741
24:21:27,040 --> 24:21:29,512
variável de membro porque isso é privado

36742
24:21:29,512 --> 24:21:32,000
para a classe da pessoa, mas eu realmente não

36743
24:21:32,000 --> 24:21:34,232
Até querer fazer isso porque fazer isso

36744
24:21:34,232 --> 24:21:35,832
Tipo de design

36745
24:21:35,832 --> 24:21:39,040
é sinal de mau design em primeiro lugar

36746
24:21:39,040 --> 24:21:41,600
Então, se você precisa fazer esses tipos de

36747
24:21:41,600 --> 24:21:44,000
getters e avance-os para baixo

36748
24:21:44,000 --> 24:21:46,872
Classes de herança, por que não mudar o

36749
24:21:46,872 --> 24:21:49,600
projetar em primeiro lugar e não fazer

36750
24:21:49,600 --> 24:21:52,080
herança privada aqui, por exemplo, se

36751
24:21:52,080 --> 24:21:54,480
você muda essa herança para proteção

36752
24:21:54,480 --> 24:21:57,600
ou público esses membros serão

36753
24:21:57,600 --> 24:22:00,960
diretamente encaminhado automaticamente para baixo para baixo

36754
24:22:00,960 --> 24:22:04,080
qualquer classe de herança, então saiba que

36755
24:22:04,080 --> 24:22:06,960
você pode colocar getters públicos que são

36756
24:22:06,960 --> 24:22:09,280
dar acesso ao nome completo

36757
24:22:09,280 --> 24:22:11,680
e idade, mas você ainda quer ser capaz de

36758
24:22:11,680 --> 24:22:14,640
Acesse o membro do endereço

36759
24:22:14,640 --> 24:22:17,120
da classe de herança porque isso

36760
24:22:17,120 --> 24:22:19,832
é o projeto que você consegue marcando

36761
24:22:19,832 --> 24:22:22,080
Algo como privado na classe base

36762
24:22:22,080 --> 24:22:24,160
Se você quiser que o endereço seja encaminhado

36763
24:22:24,160 --> 24:22:26,552
Você pode alterar o nível de acesso

36764
24:22:26,552 --> 24:22:28,872
nós temos aqui e talvez torná-lo protegido

36765
24:22:28,872 --> 24:22:31,440
ou público, então essas são as ideias que eu realmente

36766
24:22:31,440 --> 24:22:33,920
Quero que você entenda eu vou comentar

36767
24:22:33,920 --> 24:22:36,552
fora o código ofensivo aqui porque eu

36768
24:22:36,552 --> 24:22:38,160
Quer que você possa construir isso

36769
24:22:38,160 --> 24:22:41,040
programar e ver isso, mesmo que não possamos

36770
24:22:41,040 --> 24:22:43,832
acessar este nome completo e obter

36771
24:22:43,832 --> 24:22:46,800
se dirigir membros de classes herdadas

36772
24:22:46,800 --> 24:22:49,832
Eles ainda fazem parte da nossa interface

36773
24:22:49,832 --> 24:22:52,400
Não pode ter acesso a eles porque

36774
24:22:52,400 --> 24:22:55,040
das escolhas que fizemos no upstream

36775
24:22:55,040 --> 24:22:57,760
Aulas assim o que eu vou fazer eu sou

36776
24:22:57,760 --> 24:23:00,552
indo para ir no meu arquivo principal cpp e eu sou

36777
24:23:00,552 --> 24:23:03,832
Criar um objeto de engenharia

36778
24:23:03,832 --> 24:23:06,720
Eu também vou incluir engenheiro civil aqui

36779
24:23:06,720 --> 24:23:09,280
Vamos fazer isso e eu vou criar

36780
24:23:09,280 --> 24:23:12,000
um objeto engenheiro e eu vou

36781
24:23:12,000 --> 24:23:14,720
Criar um objeto de engenharia civil

36782
24:23:14,720 --> 24:23:18,640
e eu vou apenas dizer feito aqui e

36783
24:23:18,640 --> 24:23:20,640
Eu vou colocar o ponto de ruptura em

36784
24:23:20,640 --> 24:23:23,040
linha 12. vamos usar um depurador

36785
24:23:23,040 --> 24:23:24,232
para realmente ver

36786
24:23:24,232 --> 24:23:27,512
que projetam os objetos e a civil

36787
24:23:27,512 --> 24:23:29,360
objetos de engenharia

36788
24:23:29,360 --> 24:23:32,232
Ainda temos uma pessoa parte deles apenas nós

36789
24:23:32,232 --> 24:23:34,640
Não pode acessar a interface que foi

36790
24:23:34,640 --> 24:23:37,832
eclipsada pela classe do engenheiro, então nós somos

36791
24:23:37,832 --> 24:23:41,280
indo para bater a guia de execução aqui

36792
24:23:41,280 --> 24:23:43,120
E nós vamos para

36793
24:23:43,120 --> 24:23:45,832
iniciar nossa sessão de depuração clicando

36794
24:23:45,832 --> 24:23:47,760
no botão verde aqui

36795
24:23:47,760 --> 24:23:50,232
vamos construir nosso programa e se

36796
24:23:50,232 --> 24:23:52,232
A construção é boa, vamos ligar

36797
24:23:52,232 --> 24:23:55,120
O binário que foi gerado em nosso

36798
24:23:55,120 --> 24:23:57,512
debugger e nós vamos bater o nosso

36799
24:23:57,512 --> 24:24:00,080
ponto de ruptura em um minuto, uma vez que nós batemos o nosso

36800
24:24:00,080 --> 24:24:02,552
ponto de ruptura, vamos olhar para o

36801
24:24:02,552 --> 24:24:04,400
variáveis locais que temos no

36802
24:24:04,400 --> 24:24:06,400
Função que vamos vê-los no

36803
24:24:06,400 --> 24:24:09,040
Deixado aqui se expandirmos, vamos

36804
24:24:09,040 --> 24:24:12,232
Veja que temos um engenheiro um objeto

36805
24:24:12,232 --> 24:24:14,640
e nós temos um engenheiro civil um objeto

36806
24:24:14,640 --> 24:24:17,192
Se olharmos para o nosso engenheiro, vamos

36807
24:24:17,192 --> 24:24:19,512
para ver que temos uma pessoa parte de

36808
24:24:19,512 --> 24:24:22,960
isto que é a nossa classe base e se

36809
24:24:22,960 --> 24:24:25,040
olhar para o engenheiro civil que também está indo

36810
24:24:25,040 --> 24:24:29,440
ter uma base de engenheiro para que qualquer civil

36811
24:24:29,440 --> 24:24:32,480
O engenheiro também será um engenheiro

36812
24:24:32,480 --> 24:24:34,872
mas o engenheiro parte do civil

36813
24:24:34,872 --> 24:24:38,552
Engenheiro também tem uma parte da pessoa

36814
24:24:38,552 --> 24:24:40,720
Você realmente deve ver essa informação

36815
24:24:40,720 --> 24:24:42,552
e a mensagem principal que quero transmitir

36816
24:24:42,552 --> 24:24:45,192
Aqui é que todos esses objetos têm

36817
24:24:45,192 --> 24:24:48,160
pessoa parte deles nós simplesmente não podemos acessar

36818
24:24:48,160 --> 24:24:51,600
Parte em objetos de nossa herança

36819
24:24:51,600 --> 24:24:54,552
Aulas por causa das decisões de design

36820
24:24:54,552 --> 24:24:57,280
Fizemos fechar isto agora

36821
24:24:57,280 --> 24:24:59,600
que você viu isso e de novo

36822
24:24:59,600 --> 24:25:01,920
Estamos realmente trabalhando nisso

36823
24:25:01,920 --> 24:25:04,720
hierarquia de herança, a classe base é

36824
24:25:04,720 --> 24:25:05,760
Pessoa

36825
24:25:05,760 --> 24:25:07,280
E vai ter esses membros

36826
24:25:07,280 --> 24:25:08,480
As variáveis

36827
24:25:08,480 --> 24:25:10,960
mas se fizermos herança privada de

36828
24:25:10,960 --> 24:25:13,192
A pessoa classifica qualquer coisa que não é

36829
24:25:13,192 --> 24:25:16,480
O público vai ser eclipsado para baixo

36830
24:25:16,480 --> 24:25:19,512
acesso de nível privado para que qualquer outra classe

36831
24:25:19,512 --> 24:25:21,680
que vai herdar de nossa

36832
24:25:21,680 --> 24:25:24,160
A classe de engenheiros agora não vai ter

36833
24:25:24,160 --> 24:25:26,552
acesso direto a esses membros porque

36834
24:25:26,552 --> 24:25:29,040
eles vão se tornar privados para isso

36835
24:25:29,040 --> 24:25:31,832
classe aqui e essa é a experiência que nós

36836
24:25:31,832 --> 24:25:33,680
Se tentarmos

36837
24:25:33,680 --> 24:25:36,720
usar qualquer um desses métodos e membros que

36838
24:25:36,720 --> 24:25:38,480
obter a partir do engenheiro

36839
24:25:38,480 --> 24:25:40,480
Isso não vai funcionar porque eles

36840
24:25:40,480 --> 24:25:41,760
É agora

36841
24:25:41,760 --> 24:25:43,600
privado para a classe de engenharia este é

36842
24:25:43,600 --> 24:25:46,080
a mensagem aqui para que fique o nome completo

36843
24:25:46,080 --> 24:25:47,440
obter a idade

36844
24:25:47,440 --> 24:25:50,232
Os métodos não vão funcionar se tentarmos

36845
24:25:50,232 --> 24:25:52,872
usar o membro da contagem do contrato que

36846
24:25:52,872 --> 24:25:55,040
vem da classe do engenheiro que não é

36847
24:25:55,040 --> 24:25:57,440
também vamos trabalhar se olharmos para o nosso

36848
24:25:57,440 --> 24:25:59,120
cabeçalho e tentar usar qualquer um destes

36849
24:25:59,120 --> 24:26:00,552
membros, vamos receber compilador

36850
24:26:00,552 --> 24:26:02,800
erros porque todos esses caras estão agora

36851
24:26:02,800 --> 24:26:05,440
privado para a classe de engenharia este é

36852
24:26:05,440 --> 24:26:07,512
Realmente tudo que eu queria compartilhar disso

36853
24:26:07,512 --> 24:26:10,080
palestra vamos para o arquivo cpp

36854
24:26:10,080 --> 24:26:12,320
e comentar isso novamente porque eu

36855
24:26:12,320 --> 24:26:14,480
Não quero deixar você com isso

36856
24:26:14,480 --> 24:26:16,640
erros do compilador espero que você tenha encontrado isso

36857
24:26:16,640 --> 24:26:19,280
palestra informativa e divertida

36858
24:26:19,280 --> 24:26:21,680
Vamos parar aqui nesta em

36859
24:26:21,680 --> 24:26:23,360
O próximo vamos ver que nós

36860
24:26:23,360 --> 24:26:26,552
Na verdade, pode ressuscitar alguns membros de volta

36861
24:26:26,552 --> 24:26:27,760
em âmbito de aplicação

36862
24:26:27,760 --> 24:26:30,160
se eles foram eclipsados pelo tipo de

36863
24:26:30,160 --> 24:26:32,720
Herança que fizemos de um upstream

36864
24:26:32,720 --> 24:26:33,760
classe de classe

36865
24:26:33,760 --> 24:26:36,000
Vá em frente e termine aqui e me encontre

36866
24:26:36,000 --> 24:26:37,440
lá

36867
24:26:37,440 --> 24:26:39,440
Nesta palestra vamos explorar

36868
24:26:39,440 --> 24:26:42,160
Como podemos ressuscitar os membros de volta

36869
24:26:42,160 --> 24:26:44,960
escopo para que o que queremos dizer aqui suponha que nós

36870
24:26:44,960 --> 24:26:47,920
Temos nossa árvore de herança confiável aqui nós

36871
24:26:47,920 --> 24:26:50,320
ter uma pessoa de classe base, o engenheiro

36872
24:26:50,320 --> 24:26:52,480
A classe vai fazer herança privada

36873
24:26:52,480 --> 24:26:54,480
E vai ser realmente egoísta e

36874
24:26:54,480 --> 24:26:55,440
Dizê

36875
24:26:55,440 --> 24:26:57,600
Eu vou levar tudo o que posso de

36876
24:26:57,600 --> 24:27:00,640
A classe da pessoa upstream, mas eu estou indo

36877
24:27:00,640 --> 24:27:04,320
Para fazer tudo o que é meu e ninguém

36878
24:27:04,320 --> 24:27:06,960
Herdado de mim terá acesso a

36879
24:27:06,960 --> 24:27:10,232
Esses caras, por exemplo, m1 e m2 são

36880
24:27:10,232 --> 24:27:12,552
Vai ser privado para o engenheiro

36881
24:27:12,552 --> 24:27:13,512
classe de classe

36882
24:27:13,512 --> 24:27:16,320
Começando aqui quando a classe de engenharia

36883
24:27:16,320 --> 24:27:19,040
faz herança privada para que qualquer outro

36884
24:27:19,040 --> 24:27:21,440
classe, por exemplo, engenheiro civil que

36885
24:27:21,440 --> 24:27:23,360
está herdando de

36886
24:27:23,360 --> 24:27:26,320
a classe do engenheiro de qualquer forma não terá

36887
24:27:26,320 --> 24:27:27,440
acesso

36888
24:27:27,440 --> 24:27:31,280
para as variáveis m1 e m2 membros assim

36889
24:27:31,280 --> 24:27:34,000
Supor por alguma razão que temos

36890
24:27:34,000 --> 24:27:36,872
Este tipo de configuração aqui, mas novamente nós

36891
24:27:36,872 --> 24:27:40,000
Quer que alguns membros sejam acessíveis

36892
24:27:40,000 --> 24:27:42,552
outras classes downstream

36893
24:27:42,552 --> 24:27:45,120
Supor, por exemplo, que queremos o m1

36894
24:27:45,120 --> 24:27:47,280
variável de membro para ainda ser acessível

36895
24:27:47,280 --> 24:27:50,160
para classes downstream enquanto temos feito

36896
24:27:50,160 --> 24:27:52,640
herança privada c plus plus é

36897
24:27:52,640 --> 24:27:55,040
Realmente estranho de uma forma que vai

36898
24:27:55,040 --> 24:27:57,600
Trabalhar duro para realmente evitar que você faça

36899
24:27:57,600 --> 24:28:00,000
Obrigado e isso lhe dá uma porta dos fundos

36900
24:28:00,000 --> 24:28:01,832
Você pode passar para

36901
24:28:01,832 --> 24:28:04,160
Permitir a mesma coisa que você estava tentando

36902
24:28:04,160 --> 24:28:06,400
Evite no mesmo lugar que é o mesmo

36903
24:28:06,400 --> 24:28:08,872
tipo de lógica que temos aqui permite que você

36904
24:28:08,872 --> 24:28:11,832
usar herança privada para evitar

36905
24:28:11,832 --> 24:28:15,120
classes downstream para acesso a qualquer coisa

36906
24:28:15,120 --> 24:28:18,080
Você obtém de aulas upstream, mas depois

36907
24:28:18,080 --> 24:28:20,160
Mais uma vez, permite que você mude isso e

36908
24:28:20,160 --> 24:28:23,280
Relaxe o acesso às aulas a jusante

36909
24:28:23,280 --> 24:28:25,280
Por exemplo, podemos alterar o acesso de

36910
24:28:25,280 --> 24:28:29,280
m1 e m2 tornam-se mais relaxado torná-lo

36911
24:28:29,280 --> 24:28:32,800
público ou protegido se quiséssemos isso

36912
24:28:32,800 --> 24:28:35,120
Vamos dar uma olhada em algum código porque eu

36913
24:28:35,120 --> 24:28:36,872
Saiba que essas coisas podem realmente ser

36914
24:28:36,872 --> 24:28:39,360
Confundindo ok, vamos começar

36915
24:28:39,360 --> 24:28:41,040
de uma classe de pessoa que vai

36916
24:28:41,040 --> 24:28:43,512
ter um monte de variáveis de membros que vamos

36917
24:28:43,512 --> 24:28:45,192
Também tem um monte de getters que são

36918
24:28:45,192 --> 24:28:46,720
Vou devolver todos esses membros

36919
24:28:46,720 --> 24:28:49,280
variáveis e vamos fazer privado

36920
24:28:49,280 --> 24:28:52,872
Herança de pessoa em um engenheiro

36921
24:28:52,872 --> 24:28:56,080
classe isso vai retirar o acesso

36922
24:28:56,080 --> 24:28:58,800
para os membros que olhemos de pessoa

36923
24:28:58,800 --> 24:28:59,680
A sua forma de

36924
24:28:59,680 --> 24:29:02,400
Acesso de nível privado, por exemplo,

36925
24:29:02,400 --> 24:29:04,552
obter o nome completo membro função o portão

36926
24:29:04,552 --> 24:29:06,800
age the gate address members funções

36927
24:29:06,800 --> 24:29:09,832
Vai ser privado para o

36928
24:29:09,832 --> 24:29:12,800
classe de engenheiro agora, mas por alguma razão

36929
24:29:12,800 --> 24:29:15,192
Você pode querer ressuscintá-los

36930
24:29:15,192 --> 24:29:18,720
para um nível de acesso mais descontraído e você

36931
24:29:18,720 --> 24:29:21,600
fazer isso usando a palavra-chave usando para que

36932
24:29:21,600 --> 24:29:23,360
A primeira coisa que você precisa fazer é escolher

36933
24:29:23,360 --> 24:29:24,960
A seção em que você vai ser

36934
24:29:24,960 --> 24:29:27,120
colocando essas declarações de uso para

36935
24:29:27,120 --> 24:29:29,192
Exemplo porque os colocamos em um

36936
24:29:29,192 --> 24:29:31,120
Secção protegida

36937
24:29:31,120 --> 24:29:32,640
Todos esses caras vão ser

36938
24:29:32,640 --> 24:29:35,600
ressuscitados com um nível de nexo de

36939
24:29:35,600 --> 24:29:38,400
protegido se os colocarmos em público

36940
24:29:38,400 --> 24:29:40,552
seção que eles vão ser ressuscitados

36941
24:29:40,552 --> 24:29:43,760
com um nível de acesso público e são

36942
24:29:43,760 --> 24:29:46,232
Será acessível a partir da herança

36943
24:29:46,232 --> 24:29:48,800
Aula uma coisa que você deve saber é

36944
24:29:48,800 --> 24:29:51,040
que você não pode ressuscitar

36945
24:29:51,040 --> 24:29:54,400
Algo que já é privado para uma

36946
24:29:54,400 --> 24:29:56,960
classe upstream, por exemplo, sabemos que

36947
24:29:56,960 --> 24:29:58,872
nossa variável m membro de endereço foi

36948
24:29:58,872 --> 24:30:01,440
privado para a classe da pessoa para que não possamos

36949
24:30:01,440 --> 24:30:04,232
Realmente ressuscita que em uma herança

36950
24:30:04,232 --> 24:30:06,080
classe se fizermos isso, vamos ter um

36951
24:30:06,080 --> 24:30:08,320
erro do compilador e espero que isso seja

36952
24:30:08,320 --> 24:30:09,832
indo para conduzir o ponto para casa que

36953
24:30:09,832 --> 24:30:12,080
A herança privada é realmente realmente

36954
24:30:12,080 --> 24:30:14,552
sério e que vai despir-se

36955
24:30:14,552 --> 24:30:17,512
acesso ao acesso de nível privado em

36956
24:30:17,512 --> 24:30:20,640
uma classe de herança e qualquer downstream

36957
24:30:20,640 --> 24:30:23,040
A classe de herança nunca será capaz de

36958
24:30:23,040 --> 24:30:26,232
ressuscitar essas variáveis de membro para um

36959
24:30:26,232 --> 24:30:29,600
Nível de acesso mais descontraído assim porque

36960
24:30:29,600 --> 24:30:32,320
Tudo aqui é herdado como privado

36961
24:30:32,320 --> 24:30:35,280
por padrão qualquer herança downstream

36962
24:30:35,280 --> 24:30:37,192
A classe nunca será capaz de ressuscitar

36963
24:30:37,192 --> 24:30:39,512
Esses caras, por exemplo, para o público ou

36964
24:30:39,512 --> 24:30:42,000
escopo protegido, esta é a mensagem aqui

36965
24:30:42,000 --> 24:30:44,160
e você pode usar este tipo de design se

36966
24:30:44,160 --> 24:30:46,320
Você quer isso, mas pessoalmente eu não

36967
24:30:46,320 --> 24:30:48,000
Gosto de fazer isso porque vai

36968
24:30:48,000 --> 24:30:50,160
fazer o seu código muito mais

36969
24:30:50,160 --> 24:30:52,960
É difícil ler e entender se você quiser

36970
24:30:52,960 --> 24:30:55,512
Esses caras são públicos ou protegidos por quê

36971
24:30:55,512 --> 24:30:58,160
não torná-los públicos ou protegidos no

36972
24:30:58,160 --> 24:31:00,232
primeiro lugar e realmente não usar privado

36973
24:31:00,232 --> 24:31:03,040
Herança que vai ser muito mais

36974
24:31:03,040 --> 24:31:05,360
Dirigir para ver e compreender e seu

36975
24:31:05,360 --> 24:31:07,832
O código será mais fácil de trabalhar

36976
24:31:07,832 --> 24:31:10,232
para você no futuro ou para algum outro

36977
24:31:10,232 --> 24:31:12,960
desenvolvedores que começarão a trabalhar em sua

36978
24:31:12,960 --> 24:31:14,720
código no futuro, então este é o

36979
24:31:14,720 --> 24:31:16,800
mensagem aqui você pode usar este recurso para

36980
24:31:16,800 --> 24:31:18,800
ressuscitar os membros de volta

36981
24:31:18,800 --> 24:31:22,480
para um nível de acesso descontraído e agora que

36982
24:31:22,480 --> 24:31:24,872
Você tem uma ideia sobre isso, estamos indo

36983
24:31:24,872 --> 24:31:27,040
para ir até o código do estúdio visual e

36984
24:31:27,040 --> 24:31:28,720
brincar um pouco mais com a gente

36985
24:31:28,720 --> 24:31:31,192
Aqui estamos em nossa pasta de trabalho o

36986
24:31:31,192 --> 24:31:33,832
O projeto atual está ressuscitando os membros

36987
24:31:33,832 --> 24:31:36,160
De volta ao contexto, vamos

36988
24:31:36,160 --> 24:31:38,400
Reutilizar completamente o código do último

36989
24:31:38,400 --> 24:31:40,320
palestra porque vai nos dar uma

36990
24:31:40,320 --> 24:31:42,080
Bom ponto de partida que podemos copiar

36991
24:31:42,080 --> 24:31:44,800
Tudo, exceto o binário aqui,

36992
24:31:44,800 --> 24:31:47,832
Não precisa disso em nosso projeto atual

36993
24:31:47,832 --> 24:31:50,232
Nós vamos colocar em nosso código inicial

36994
24:31:50,232 --> 24:31:51,920
E nós vamos abrir esse garotinho

36995
24:31:51,920 --> 24:31:54,160
em código de estúdio visual, então vamos

36996
24:31:54,160 --> 24:31:56,400
Temos o nosso código que vamos ter

36997
24:31:56,400 --> 24:31:58,400
função principal e nós vamos ter

36998
24:31:58,400 --> 24:32:00,552
Todos esses objetos criados aqui eu sou

36999
24:32:00,552 --> 24:32:02,232
Realmente não tenho certeza se vamos precisar

37000
24:32:02,232 --> 24:32:04,720
que ainda assim vamos tirar isso e

37001
24:32:04,720 --> 24:32:06,400
nós vamos olhar para o nosso pessoal

37002
24:32:06,400 --> 24:32:08,640
classe que vai ter os nossos membros

37003
24:32:08,640 --> 24:32:11,120
Aqui e nós vamos ter um monte de

37004
24:32:11,120 --> 24:32:13,192
getters que vão voltar

37005
24:32:13,192 --> 24:32:15,120
essas variáveis de membro e nós temos uma

37006
24:32:15,120 --> 24:32:16,872
construtor aqui que realmente está indo

37007
24:32:16,872 --> 24:32:19,360
para construir uma pessoa nada

37008
24:32:19,360 --> 24:32:21,832
complicado aqui temos um engenheiro

37009
24:32:21,832 --> 24:32:23,680
classe que vai para privadamente

37010
24:32:23,680 --> 24:32:26,552
Herdar de pessoa e nós sabemos que

37011
24:32:26,552 --> 24:32:29,440
Isso vai eclipsar tudo que

37012
24:32:29,440 --> 24:32:32,640
Não é privado na classe da pessoa para

37013
24:32:32,640 --> 24:32:35,360
acesso de nível privado para que tudo seja

37014
24:32:35,360 --> 24:32:37,440
Vai ser privado para o engenheiro

37015
24:32:37,440 --> 24:32:40,160
classe agora, mas às vezes não queremos

37016
24:32:40,160 --> 24:32:43,040
fazer isso, por exemplo, se descermos em nosso

37017
24:32:43,040 --> 24:32:45,360
classe de engenharia civil

37018
24:32:45,360 --> 24:32:46,960
nós vamos ver isso

37019
24:32:46,960 --> 24:32:49,680
o nome completo e os métodos de getage

37020
24:32:49,680 --> 24:32:51,360
Vai ser privado para o app

37021
24:32:51,360 --> 24:32:53,680
classe de engenheiro de fluxo e isso está indo

37022
24:32:53,680 --> 24:32:56,552
para quebrar o código para o nosso fluxo de saída

37023
24:32:56,552 --> 24:32:58,720
Operador e não vai funcionar

37024
24:32:58,720 --> 24:33:00,800
porque queremos ter acesso para

37025
24:33:00,800 --> 24:33:03,440
nome completo e ter idade e isso também é

37026
24:33:03,440 --> 24:33:05,832
vou matar o acesso que tivemos no get

37027
24:33:05,832 --> 24:33:08,320
método de endereçamento que nos daria

37028
24:33:08,320 --> 24:33:11,360
acesso ao membro de endereço que nós

37029
24:33:11,360 --> 24:33:14,080
ter em nossa classe de pessoa, vamos ter certeza

37030
24:33:14,080 --> 24:33:16,232
Estamos olhando para a pessoa

37031
24:33:16,232 --> 24:33:18,552
Estou confuso aqui temos um monte de

37032
24:33:18,552 --> 24:33:20,400
Peças de código aqui

37033
24:33:20,400 --> 24:33:23,040
Onde está o cabeçalho da pessoa

37034
24:33:23,040 --> 24:33:25,120
É aqui em baixo, então temos a vantagem

37035
24:33:25,120 --> 24:33:27,280
método de endereço que vai voltar

37036
24:33:27,280 --> 24:33:29,680
O endereço que queremos ter acesso a

37037
24:33:29,680 --> 24:33:32,640
que em nossa classe de engenharia civil seja

37038
24:33:32,640 --> 24:33:35,280
capaz de imprimir todas essas informações se nós

37039
24:33:35,280 --> 24:33:37,760
também queremos imprimir a contagem de contratos

37040
24:33:37,760 --> 24:33:40,872
pode ir em nossa classe de engenheiros e colocar em

37041
24:33:40,872 --> 24:33:43,040
Um método que vai devolver isso

37042
24:33:43,040 --> 24:33:45,192
para que possamos dizer acabar

37043
24:33:45,192 --> 24:33:47,920
e dizer obter a contagem de contratos e isso é

37044
24:33:47,920 --> 24:33:49,760
vai ser uma função de membro const

37045
24:33:49,760 --> 24:33:51,760
porque não vai mudar

37046
24:33:51,760 --> 24:33:53,920
nosso objeto, vamos apenas devolver um

37047
24:33:53,920 --> 24:33:55,760
valor, vamos devolver o contrato

37048
24:33:55,760 --> 24:33:58,400
Contar e nós podemos ir em nosso civil

37049
24:33:58,400 --> 24:34:01,920
arquivo de implementação de engenharia e mudança

37050
24:34:01,920 --> 24:34:03,280
Isto para dizer

37051
24:34:03,280 --> 24:34:04,552
Operand de ópera

37052
24:34:04,552 --> 24:34:06,960
obter uma conta de contrato que podemos fazer isso ok

37053
24:34:06,960 --> 24:34:08,960
Temos esse método agora que queremos que isso

37054
24:34:08,960 --> 24:34:11,120
O trabalho vai funcionar porque nós

37055
24:34:11,120 --> 24:34:13,512
estão fazendo herança pública do

37056
24:34:13,512 --> 24:34:15,920
classe de engenharia civil, mas queremos que isso

37057
24:34:15,920 --> 24:34:18,160
trabalho que queremos ter o nome completo para ter idade

37058
24:34:18,160 --> 24:34:20,640
e obter endereço para trabalhar aqui e podemos

37059
24:34:20,640 --> 24:34:23,760
usar o recurso de uso para ressuscitar estes

37060
24:34:23,760 --> 24:34:26,872
membros para um nível de acesso que irá

37061
24:34:26,872 --> 24:34:29,680
permitir que nossa classe de engenheiro civil escolha

37062
24:34:29,680 --> 24:34:32,320
eles para que possamos ir em nosso engenheiro

37063
24:34:32,320 --> 24:34:35,040
classe e configurar, por exemplo, um público ou

37064
24:34:35,040 --> 24:34:36,960
escopo protegido que vamos usar

37065
24:34:36,960 --> 24:34:39,120
protegido porque queremos que estes apenas

37066
24:34:39,120 --> 24:34:40,960
ser acessível a partir de

37067
24:34:40,960 --> 24:34:42,960
classes herdadas, por exemplo, nós somos

37068
24:34:42,960 --> 24:34:44,800
Vou dizer protegido e nós vamos

37069
24:34:44,800 --> 24:34:46,872
para dizer que usar isso é a sintaxe que somos

37070
24:34:46,872 --> 24:34:48,552
vamos dizer pessoa e nós vamos

37071
24:34:48,552 --> 24:34:50,640
Diga para obter o nome completo, vamos dizer

37072
24:34:50,640 --> 24:34:53,832
Usando a pessoa obter idade indo para escolher

37073
24:34:53,832 --> 24:34:55,832
Isso e nós vamos dizer usando

37074
24:34:55,832 --> 24:34:59,040
pessoa e dizer obter endereço eu acho que nós

37075
24:34:59,040 --> 24:35:01,440
Tenho esse método aqui no momento em que fazemos

37076
24:35:01,440 --> 24:35:03,360
Isso nós vamos entrar em nosso civil

37077
24:35:03,360 --> 24:35:04,872
classe de engenharia que você vai ver isso

37078
24:35:04,872 --> 24:35:07,760
Vai funcionar agora porque o que nós

37079
24:35:07,760 --> 24:35:11,680
Acabou de ressuscitar esses membros para

37080
24:35:11,680 --> 24:35:14,552
ter nível de acesso protegido no

37081
24:35:14,552 --> 24:35:17,280
Classe de engenharia para que a herança

37082
24:35:17,280 --> 24:35:18,960
As aulas vão olhar para isso e

37083
24:35:18,960 --> 24:35:21,920
Veja que eles têm um acesso protegido

37084
24:35:21,920 --> 24:35:24,160
nível na classe de engenharia e eles são

37085
24:35:24,160 --> 24:35:26,552
indo para ser encaminhado para baixo para baixo para qualquer

37086
24:35:26,552 --> 24:35:28,320
Classe de herança também podemos mudar

37087
24:35:28,320 --> 24:35:30,000
Isso para o público isso também vai

37088
24:35:30,000 --> 24:35:32,232
trabalho que serão herdados como

37089
24:35:32,232 --> 24:35:35,120
público e espero que você possa ver isso

37090
24:35:35,120 --> 24:35:37,280
qualquer membro que você ressuscitar está indo

37091
24:35:37,280 --> 24:35:39,760
para tomar o nível de excesso da seção

37092
24:35:39,760 --> 24:35:42,872
onde você ressustá-lo se ressuscitarmos

37093
24:35:42,872 --> 24:35:45,512
em um âmbito público que eles vão

37094
24:35:45,512 --> 24:35:47,920
ser ressuscitado com acesso público

37095
24:35:47,920 --> 24:35:50,232
nível se os ressuscitarmos em um

37096
24:35:50,232 --> 24:35:52,800
escopo protegido que eles vão ser

37097
24:35:52,800 --> 24:35:54,800
ressuscitados com

37098
24:35:54,800 --> 24:35:56,960
nível de acesso protegido e este é o

37099
24:35:56,960 --> 24:36:00,080
Mensagem aqui agora, se acontecer de você ter um

37100
24:36:00,080 --> 24:36:03,440
monte de sobrecargas em uma classe upstream

37101
24:36:03,440 --> 24:36:06,480
Por exemplo, suponha que temos um monte de

37102
24:36:06,480 --> 24:36:07,360
add

37103
24:36:07,360 --> 24:36:10,640
funções na classe da pessoa que podemos ir

37104
24:36:10,640 --> 24:36:13,832
dentro e colocar dentro, vamos fazer isso nós podemos ir

37105
24:36:13,832 --> 24:36:15,192
Para baixo e dizer

37106
24:36:15,192 --> 24:36:18,160
duplo ou ent vamos dizer e isso está indo

37107
24:36:18,160 --> 24:36:20,800
para ser muito mais simples podemos dizer adicionar e

37108
24:36:20,800 --> 24:36:22,000
Diga fim

37109
24:36:22,000 --> 24:36:25,120
a e dizer ent b e dizer ent c

37110
24:36:25,120 --> 24:36:26,320
Vou ter

37111
24:36:26,320 --> 24:36:28,720
Três coisas que estamos adicionando isso é

37112
24:36:28,720 --> 24:36:31,040
vai ser uma função de membro const que é

37113
24:36:31,040 --> 24:36:33,280
não vou modificar nossos membros em

37114
24:36:33,280 --> 24:36:36,160
de qualquer maneira, então vamos voltar

37115
24:36:36,160 --> 24:36:38,080
a plus b

37116
24:36:38,080 --> 24:36:40,480
Além disso, isso é algo que podemos voltar

37117
24:36:40,480 --> 24:36:42,960
de uma função de membro aqui

37118
24:36:42,960 --> 24:36:45,600
e nós vamos fazer uma sobrecarga do

37119
24:36:45,600 --> 24:36:47,120
add membro

37120
24:36:47,120 --> 24:36:49,120
para fazer

37121
24:36:49,120 --> 24:36:51,832
A adição de dois parâmetros, então nós somos

37122
24:36:51,832 --> 24:36:54,400
só vou ter um e b e eu acho

37123
24:36:54,400 --> 24:36:57,512
Podemos usar a e b no primeiro

37124
24:36:57,512 --> 24:36:59,760
sobrecarga aqui que vai ser muito

37125
24:36:59,760 --> 24:37:01,832
É mais fácil seguir para que tenhamos um que

37126
24:37:01,832 --> 24:37:04,232
adiciona dois parâmetros

37127
24:37:04,232 --> 24:37:05,600
e nós temos outro que está indo

37128
24:37:05,600 --> 24:37:08,232
para adicionar três parâmetros se nós

37129
24:37:08,232 --> 24:37:11,192
Herdem em particular da pessoa esses caras

37130
24:37:11,192 --> 24:37:14,160
vai ser despojado para privado

37131
24:37:14,160 --> 24:37:17,120
acesso de nível na classe de engenharia e

37132
24:37:17,120 --> 24:37:19,920
Eles querem ser acessíveis a partir de qualquer

37133
24:37:19,920 --> 24:37:22,640
outra classe downstream, por exemplo, se

37134
24:37:22,640 --> 24:37:25,920
Vamos na nossa classe de engenharia civil

37135
24:37:25,920 --> 24:37:27,760
e tentar dizer adicionar

37136
24:37:27,760 --> 24:37:30,400
10 a dois, por exemplo, vamos conseguir

37137
24:37:30,400 --> 24:37:32,160
um erro de compilador porque não temos

37138
24:37:32,160 --> 24:37:35,120
acesso a isso, mas também podemos ressuscitar

37139
24:37:35,120 --> 24:37:38,640
esses membros do anúncio em nossa classe de engenheiros

37140
24:37:38,640 --> 24:37:40,400
então vamos lá e nós vamos nos estabelecer

37141
24:37:40,400 --> 24:37:41,760
Para um público

37142
24:37:41,760 --> 24:37:44,400
seção nesta classe aqui e nós estamos

37143
24:37:44,400 --> 24:37:47,920
Vou dizer que usar pessoa adicionar isso é

37144
24:37:47,920 --> 24:37:50,400
Vou ressuscitar todas as sobrecargas

37145
24:37:50,400 --> 24:37:53,512
que temos em nossa classe upstream e

37146
24:37:53,512 --> 24:37:55,192
Este vai ser o caso porque nós

37147
24:37:55,192 --> 24:37:57,512
ressuscitar apenas com base no nome do

37148
24:37:57,512 --> 24:37:58,400
A função

37149
24:37:58,400 --> 24:37:59,120
E a

37150
24:37:59,120 --> 24:38:02,000
o mesmo nome para uma função de membro pode

37151
24:38:02,000 --> 24:38:05,440
ser compartilhado por muitas sobrecargas, por isso, se fizermos

37152
24:38:05,440 --> 24:38:08,320
Este tipo de ressuscitação que estamos fazendo

37153
24:38:08,320 --> 24:38:10,000
para o add

37154
24:38:10,000 --> 24:38:12,160
função de membro da pessoa que estamos indo

37155
24:38:12,160 --> 24:38:14,720
para obter todas as sobrecargas se entrarmos

37156
24:38:14,720 --> 24:38:17,360
Engenheiro civil que poderemos usar

37157
24:38:17,360 --> 24:38:19,120
A função de membro tomando dois

37158
24:38:19,120 --> 24:38:21,680
parâmetros que também poderemos usar

37159
24:38:21,680 --> 24:38:24,320
Aquele que leva três parâmetros

37160
24:38:24,320 --> 24:38:26,480
Todos serão ressuscitados aqui

37161
24:38:26,480 --> 24:38:28,872
Esta é a mensagem que quero transmitir se

37162
24:38:28,872 --> 24:38:30,320
Nós fazemos isso você vai ver que isso

37163
24:38:30,320 --> 24:38:32,552
vai funcionar e nosso código está indo

37164
24:38:32,552 --> 24:38:35,920
para apenas o mundo bem, vamos construir e ver

37165
24:38:35,920 --> 24:38:37,512
Se a construção é boa, na verdade, nós somos

37166
24:38:37,512 --> 24:38:40,552
indo para passar isso através do Gcc o mundo

37167
24:38:40,552 --> 24:38:42,400
Vai ser bom, então tudo é

37168
24:38:42,400 --> 24:38:45,040
trabalhando muito bem e a mensagem i

37169
24:38:45,040 --> 24:38:47,040
Eu realmente queria transmitir é que é

37170
24:38:47,040 --> 24:38:49,360
Possível para ressuscitar membros

37171
24:38:49,360 --> 24:38:53,120
em um nível de acesso mais ressuscitado se

37172
24:38:53,120 --> 24:38:56,232
Você está herdando usando um

37173
24:38:56,232 --> 24:39:00,160
especificador de acesso de classe de base restrito restrito

37174
24:39:00,160 --> 24:39:02,720
Por exemplo, estamos herdando usando um

37175
24:39:02,720 --> 24:39:03,680
Privado

37176
24:39:03,680 --> 24:39:05,680
especificador de acesso que isso vai

37177
24:39:05,680 --> 24:39:07,512
eclipse tudo o que temos do

37178
24:39:07,512 --> 24:39:10,080
classe upstream para nível privado, mas se

37179
24:39:10,080 --> 24:39:12,320
Você acha que é demais e você tem um

37180
24:39:12,320 --> 24:39:15,120
Poucos membros que você gostaria de colocar

37181
24:39:15,120 --> 24:39:18,080
em um nível de acesso mais relaxado que você pode

37182
24:39:18,080 --> 24:39:20,640
use esse recurso de ressuscitação e é

37183
24:39:20,640 --> 24:39:23,192
vai tornar as coisas acessíveis em

37184
24:39:23,192 --> 24:39:25,440
classes downstream se isso é o que você

37185
24:39:25,440 --> 24:39:27,760
Quero em seu programa e novamente eu espero

37186
24:39:27,760 --> 24:39:29,360
Isso impulsiona o ponto para casa que

37187
24:39:29,360 --> 24:39:31,832
ziploc plus vai às vezes trabalhar

37188
24:39:31,832 --> 24:39:34,320
É muito difícil evitar que você faça

37189
24:39:34,320 --> 24:39:36,872
Uma coisa e, em seguida, novamente, dar-lhe uma volta

37190
24:39:36,872 --> 24:39:39,120
porta que você pode passar para fazer o mesmo

37191
24:39:39,120 --> 24:39:41,680
A coisa é a mesma coisa aqui que somos

37192
24:39:41,680 --> 24:39:44,160
fazendo herança privada, mas nós não

37193
24:39:44,160 --> 24:39:46,080
permitido

37194
24:39:46,080 --> 24:39:47,120
Matar

37195
24:39:47,120 --> 24:39:48,000
ou

37196
24:39:48,000 --> 24:39:50,960
Relaxe os efeitos da herança privada

37197
24:39:50,960 --> 24:39:54,080
trazendo as coisas em um mais descontraído

37198
24:39:54,080 --> 24:39:56,640
nível de acesso e você pode usar isso se ele

37199
24:39:56,640 --> 24:39:59,040
Faz sentido para o seu código novamente eu não

37200
24:39:59,040 --> 24:40:00,640
Como isso pessoalmente porque está indo

37201
24:40:00,640 --> 24:40:02,872
tornar o código confuso se outros

37202
24:40:02,872 --> 24:40:04,720
Os desenvolvedores vêem que você está fazendo

37203
24:40:04,720 --> 24:40:06,480
herança privada que eles estão indo para

37204
24:40:06,480 --> 24:40:08,480
espere tudo do fluxo de aplicativos

37205
24:40:08,480 --> 24:40:10,160
classe para ser privado

37206
24:40:10,160 --> 24:40:11,920
para a classe que está fazendo privado

37207
24:40:11,920 --> 24:40:14,080
herança e se eles vêem que

37208
24:40:14,080 --> 24:40:16,232
Pode usar isso graças que deve ser

37209
24:40:16,232 --> 24:40:18,960
privado por padrão e downstream

37210
24:40:18,960 --> 24:40:20,800
aulas isso vai realmente confundir

37211
24:40:20,800 --> 24:40:23,360
eles e vai custar-lhes mais

37212
24:40:23,360 --> 24:40:25,192
minutos para ver o seu código para realmente

37213
24:40:25,192 --> 24:40:27,440
Entenda o que está acontecendo, então se você

37214
24:40:27,440 --> 24:40:29,680
realmente quero que essa dança seja acessível

37215
24:40:29,680 --> 24:40:33,120
em classes a jusante, por que não fazer público

37216
24:40:33,120 --> 24:40:35,600
ou herança protegida no primeiro

37217
24:40:35,600 --> 24:40:38,160
lugar Este é o meu argumento aqui, mas é

37218
24:40:38,160 --> 24:40:40,552
Vou ser sua escolha meu trabalho aqui é

37219
24:40:40,552 --> 24:40:42,960
para torná-lo consciente das possibilidades

37220
24:40:42,960 --> 24:40:45,040
que você tem no ziploc mais

37221
24:40:45,040 --> 24:40:47,440
Linguagem de programação é a última coisa

37222
24:40:47,440 --> 24:40:49,440
Eu quero que você veja nesta palestra é

37223
24:40:49,440 --> 24:40:51,680
que se há algo que foi

37224
24:40:51,680 --> 24:40:54,080
já privado em uma classe de stream de aplicativos

37225
24:40:54,080 --> 24:40:56,320
Você não pode ressuscitar isso se você tentar

37226
24:40:56,320 --> 24:40:58,080
fazer isso você vai ter um compilador

37227
24:40:58,080 --> 24:41:00,000
Este também vai conduzir o

37228
24:41:00,000 --> 24:41:02,320
apontar para casa que você também pode ressuscitar

37229
24:41:02,320 --> 24:41:04,720
variáveis de membro até agora o que temos

37230
24:41:04,720 --> 24:41:07,280
Apenas ressuscitado foi todo membro

37231
24:41:07,280 --> 24:41:09,920
funções e também podemos ressuscitar

37232
24:41:09,920 --> 24:41:11,832
variáveis de membro, então vamos tentar

37233
24:41:11,832 --> 24:41:15,280
e ressuscitar o membro do endereço m em

37234
24:41:15,280 --> 24:41:17,760
A classe do engenheiro e vamos ver como

37235
24:41:17,760 --> 24:41:20,232
Isso funciona, então vamos entrar no nosso

37236
24:41:20,232 --> 24:41:22,320
classe de engenharia que podemos ir em nosso

37237
24:41:22,320 --> 24:41:25,280
seção protegida, podemos fazer isso realmente

37238
24:41:25,280 --> 24:41:27,192
em qualquer tipo de seção que vamos

37239
24:41:27,192 --> 24:41:29,760
Diga usando e nós vamos dizer pessoa

37240
24:41:29,760 --> 24:41:32,320
e nós vamos dizer m endereço que você vê

37241
24:41:32,320 --> 24:41:34,400
que isso não vai ser

37242
24:41:34,400 --> 24:41:36,552
disponível em autocomplete isto está em andamento

37243
24:41:36,552 --> 24:41:38,232
para ser um sinal de que isso vai dar

37244
24:41:38,232 --> 24:41:40,160
um erro de compilador e se estamos tentando

37245
24:41:40,160 --> 24:41:41,680
para fazer isso, vamos ver que estamos

37246
24:41:41,680 --> 24:41:43,440
vai ter um erro do compilador

37247
24:41:43,440 --> 24:41:46,080
Mensagem aqui é que se algo é

37248
24:41:46,080 --> 24:41:50,400
já privado em uma classe de fluxo de cochilo

37249
24:41:50,400 --> 24:41:53,040
Você não pode ressusci-lo é que ele bate palmas

37250
24:41:53,040 --> 24:41:54,000
Para baixo

37251
24:41:54,000 --> 24:41:55,120
para sempre

37252
24:41:55,120 --> 24:41:57,040
e espero que isso dirija o ponto para casa

37253
24:41:57,040 --> 24:41:59,512
Mais uma vez, essa herança privada é realmente

37254
24:41:59,512 --> 24:42:02,800
sérios, por exemplo, no nosso civil

37255
24:42:02,800 --> 24:42:06,000
classe de engenharia que não podemos ressuscitar

37256
24:42:06,000 --> 24:42:08,400
Algo que já estava eclipsado para

37257
24:42:08,400 --> 24:42:11,040
Acesso de nível privado pelo engenheiro

37258
24:42:11,040 --> 24:42:14,080
classe vamos para a nossa classe pessoal e

37259
24:42:14,080 --> 24:42:16,552
ver se temos qualquer outra função de membro

37260
24:42:16,552 --> 24:42:17,760
Podemos

37261
24:42:17,760 --> 24:42:19,760
jogar com nós vamos colocar em um membro

37262
24:42:19,760 --> 24:42:21,920
Função que diz fazer algo que nós somos

37263
24:42:21,920 --> 24:42:23,600
Vou dizer vazio

37264
24:42:23,600 --> 24:42:25,680
fazer alguma coisa e vai ser

37265
24:42:25,680 --> 24:42:27,760
constante, só vai dizer olá

37266
24:42:27,760 --> 24:42:29,440
Podemos fazer algo assim que somos

37267
24:42:29,440 --> 24:42:30,640
Aprendizagem

37268
24:42:30,640 --> 24:42:32,960
e este método vai ser eclipsado

37269
24:42:32,960 --> 24:42:36,000
até o acesso ao nível privado porque nós

37270
24:42:36,000 --> 24:42:37,920
estão fazendo herança privada de

37271
24:42:37,920 --> 24:42:40,960
pessoa vamos voltar para o nosso engenheiro e

37272
24:42:40,960 --> 24:42:42,800
Compromete isso porque vai

37273
24:42:42,800 --> 24:42:44,552
dar-lhe um erro de compilador se você construir

37274
24:42:44,552 --> 24:42:45,832
Você vai conseguir

37275
24:42:45,832 --> 24:42:48,000
um estranho erro do compilador eu acho que eu deveria

37276
24:42:48,000 --> 24:42:49,760
realmente te mostrar isso porque nós somos

37277
24:42:49,760 --> 24:42:51,920
aprendendo aqui, então vamos tentar e

37278
24:42:51,920 --> 24:42:53,920
construir o nosso programa de qualquer maneira que nós vamos

37279
24:42:53,920 --> 24:42:56,000
passar por isso através do gcc

37280
24:42:56,000 --> 24:42:57,192
e nós vamos ver o tipo de

37281
24:42:57,192 --> 24:42:59,360
Erro do compilador que oceimos

37282
24:42:59,360 --> 24:43:02,232
E vamos ver que não há

37283
24:43:02,232 --> 24:43:05,600
membro std este é um problema nós apenas

37284
24:43:05,600 --> 24:43:09,040
introduzido em nossa classe aqui eu acho que

37285
24:43:09,040 --> 24:43:12,720
resolver este problema nós podemos apenas colocar o nosso

37286
24:43:12,720 --> 24:43:15,760
definição no arquivo cpp que podemos fazer

37287
24:43:15,760 --> 24:43:18,160
que nós vamos pegar isso e nós somos

37288
24:43:18,160 --> 24:43:20,440
Vou colocar a definição em

37289
24:43:20,440 --> 24:43:23,120
person.cpp porque nós temos o io stream

37290
24:43:23,120 --> 24:43:25,512
incluído lá, isso vai fazer

37291
24:43:25,512 --> 24:43:28,160
Nosso código funciona muito melhor, vamos fazer isso

37292
24:43:28,160 --> 24:43:30,872
nós vamos dizer vazio e dizer pessoa

37293
24:43:30,872 --> 24:43:33,920
e nós vamos dizer o esddc para fora Olá

37294
24:43:33,920 --> 24:43:36,320
Isto vai resolver o nosso problema aqui

37295
24:43:36,320 --> 24:43:38,320
E o único problema que teremos será

37296
24:43:38,320 --> 24:43:40,232
Esteja em um engenheiro

37297
24:43:40,232 --> 24:43:42,872
onde estamos tentando acessar as coisas

37298
24:43:42,872 --> 24:43:46,232
que agora são privados para a classe base

37299
24:43:46,232 --> 24:43:48,960
Por que temos essa linha semanal aqui

37300
24:43:48,960 --> 24:43:50,872
Vamos acabar com isto.

37301
24:43:50,872 --> 24:43:53,040
e tentar construir realmente certifique-se de que

37302
24:43:53,040 --> 24:43:55,760
Este problema não existe

37303
24:43:55,760 --> 24:43:58,960
e era um código de estúdio visual confuso

37304
24:43:58,960 --> 24:44:02,400
Com a gente, então vamos trazer isso

37305
24:44:02,400 --> 24:44:03,680
e o mundo e nós vamos ver o

37306
24:44:03,680 --> 24:44:06,640
tipo de erro do compilador que nós olhemos aqui

37307
24:44:06,640 --> 24:44:09,040
Isto é o que eu estou tentando fazer você ver

37308
24:44:09,040 --> 24:44:10,640
Você vê a bala com

37309
24:44:10,640 --> 24:44:13,512
erros se voltarmos, vamos ver

37310
24:44:13,512 --> 24:44:16,872
que string pessoa m endereço é privado

37311
24:44:16,872 --> 24:44:19,120
Neste contexto não podemos realmente

37312
24:44:19,120 --> 24:44:20,960
ressuscitar se fizermos isso, vamos

37313
24:44:20,960 --> 24:44:23,680
para obter este erro do compilador aqui este é

37314
24:44:23,680 --> 24:44:26,080
A mensagem que você não deve realmente tentar

37315
24:44:26,080 --> 24:44:27,440
A ressuscitação

37316
24:44:27,440 --> 24:44:30,232
Algo que já é privado para uma

37317
24:44:30,232 --> 24:44:32,080
classe upstream e isso é o que nós somos

37318
24:44:32,080 --> 24:44:34,800
Fazendo aqui estamos tentando ressuscitar uma

37319
24:44:34,800 --> 24:44:37,040
membro que é privado para pessoa e

37320
24:44:37,040 --> 24:44:39,192
isso não é permitido em c plus plus se nós

37321
24:44:39,192 --> 24:44:41,440
fazer isso, vamos ter um compilador

37322
24:44:41,440 --> 24:44:42,480
Erro de erro

37323
24:44:42,480 --> 24:44:44,400
Tudo bem, mas o que eu quero que você veja aqui

37324
24:44:44,400 --> 24:44:48,232
é um membro público que estava no

37325
24:44:48,232 --> 24:44:51,360
A classe base também foi eclipsada até

37326
24:44:51,360 --> 24:44:54,720
acesso de nível privado no engenheiro, portanto, se

37327
24:44:54,720 --> 24:44:57,360
Tentamos e ressuscitamos

37328
24:44:57,360 --> 24:45:00,000
fazer algo em nosso civil

37329
24:45:00,000 --> 24:45:01,440
classe de engenheiro, vamos ter um

37330
24:45:01,440 --> 24:45:03,832
Erro do compilador, então vamos tentar fazer isso

37331
24:45:03,832 --> 24:45:06,080
Vamos colocar uma seção pública por quê

37332
24:45:06,080 --> 24:45:08,232
Não é

37333
24:45:08,232 --> 24:45:10,400
e nós vamos descer e dizer usando

37334
24:45:10,400 --> 24:45:13,400
Pessoa

37335
24:45:13,512 --> 24:45:15,760
E ele diz fazer algo que temos isso

37336
24:45:15,760 --> 24:45:17,680
método aqui, mas se fizermos isso, estamos

37337
24:45:17,680 --> 24:45:20,000
vai ter um erro de compilador porque

37338
24:45:20,000 --> 24:45:22,872
Este método é agora privado para o

37339
24:45:22,872 --> 24:45:25,440
classe de engenharia e por que é privado para

37340
24:45:25,440 --> 24:45:28,160
Engenheiro de engenharia está fazendo privado

37341
24:45:28,160 --> 24:45:30,552
Herança que vai aceitar

37342
24:45:30,552 --> 24:45:33,280
tudo para o acesso ao nível privado por

37343
24:45:33,280 --> 24:45:36,000
padrão para que este membro seja privado para

37344
24:45:36,000 --> 24:45:39,280
Engenheiro, estamos herdando do engenheiro

37345
24:45:39,280 --> 24:45:41,440
em engenheiro civil

37346
24:45:41,440 --> 24:45:43,680
E isso já será privado

37347
24:45:43,680 --> 24:45:46,160
para projetar e não podemos ressuscitar isso

37348
24:45:46,160 --> 24:45:49,440
Então, se você eclipsar algo usando

37349
24:45:49,440 --> 24:45:51,680
Herança privada que você quer ser capaz

37350
24:45:51,680 --> 24:45:54,960
para ressuscitar isso para um mais descontraído

37351
24:45:54,960 --> 24:45:58,000
nível de acesso em classes downstream este

37352
24:45:58,000 --> 24:45:59,832
É a mensagem que estou tentando transmitir

37353
24:45:59,832 --> 24:46:01,832
Aqui, então isso também vai nos dar uma

37354
24:46:01,832 --> 24:46:03,280
Erro do compilador

37355
24:46:03,280 --> 24:46:05,280
e se tentarmos construir o nosso programa, estamos

37356
24:46:05,280 --> 24:46:07,192
Vou ver que vamos passar isto

37357
24:46:07,192 --> 24:46:09,680
através do gcc nós vamos ver isso

37358
24:46:09,680 --> 24:46:12,080
O mundo terminou com erros e se

37359
24:46:12,080 --> 24:46:14,320
Vamos voltar, vamos ter algum tipo de

37360
24:46:14,320 --> 24:46:17,192
Erro que diz que fazer alguma coisa é

37361
24:46:17,192 --> 24:46:20,720
privado para alguma classe é inacessível

37362
24:46:20,720 --> 24:46:22,800
Neste contexto, esta é a mensagem

37363
24:46:22,800 --> 24:46:25,440
oceimos deste compilador em particular, nós

37364
24:46:25,440 --> 24:46:28,480
estão usando, mas a linha inferior é que

37365
24:46:28,480 --> 24:46:30,960
Você não deve realmente tentar ressuscitar

37366
24:46:30,960 --> 24:46:33,120
Algo que já é privado para uma

37367
24:46:33,120 --> 24:46:34,960
classe upstream e isso é o que somos

37368
24:46:34,960 --> 24:46:37,120
Fazendo aqui você não deveria realmente fazer isso

37369
24:46:37,120 --> 24:46:39,512
Vamos comentar isso e obter um código para

37370
24:46:39,512 --> 24:46:41,040
compilar novamente

37371
24:46:41,040 --> 24:46:43,440
então a web é boa e estamos todos bem

37372
24:46:43,440 --> 24:46:45,832
Aqui isso é realmente tudo que eu tinha que compartilhar

37373
24:46:45,832 --> 24:46:47,440
Nesta palestra espero que você a tenha encontrado

37374
24:46:47,440 --> 24:46:50,000
interessante, vamos parar por aqui

37375
24:46:50,000 --> 24:46:51,760
Este o próximo vamos

37376
24:46:51,760 --> 24:46:55,192
explorar como os construtores trabalham

37377
24:46:55,192 --> 24:46:56,552
Herança

37378
24:46:56,552 --> 24:46:58,800
Vá em frente e termine aqui e me encontre

37379
24:46:58,800 --> 24:47:00,080
lá

37380
24:47:00,080 --> 24:47:01,920
Nesta palestra vamos ampliar

37381
24:47:01,920 --> 24:47:05,040
em como os objetos derivados são construídos e

37382
24:47:05,040 --> 24:47:06,400
nós vamos ampliar o

37383
24:47:06,400 --> 24:47:09,280
construtores que temos ignorado

37384
24:47:09,280 --> 24:47:12,480
De propósito até agora, aqui temos o

37385
24:47:12,480 --> 24:47:14,720
Hierarquia de herança que usaremos

37386
24:47:14,720 --> 24:47:17,040
É o que estamos familiarizados com isso

37387
24:47:17,040 --> 24:47:19,192
No ponto temos uma classe pessoal que é

37388
24:47:19,192 --> 24:47:20,872
Vamos ser a nossa classe base, temos um

37389
24:47:20,872 --> 24:47:23,120
classe de engenharia que agora vai ser

37390
24:47:23,120 --> 24:47:25,600
fazendo herança pública porque temos

37391
24:47:25,600 --> 24:47:29,192
visto o suficiente da herança privada nosso

37392
24:47:29,192 --> 24:47:31,760
A classe de engenheiros agora vai ser boa

37393
24:47:31,760 --> 24:47:32,800
E dizer

37394
24:47:32,800 --> 24:47:35,360
Estou herdando de pessoa, mas eu também

37395
24:47:35,360 --> 24:47:38,320
Quero que minhas aulas de downstream tenham

37396
24:47:38,320 --> 24:47:40,720
acesso às coisas legais que estou recebendo

37397
24:47:40,720 --> 24:47:42,720
da pessoa é assim

37398
24:47:42,720 --> 24:47:45,512
nossa classe de engenheiros está se comportando agora

37399
24:47:45,512 --> 24:47:47,440
Também terá um engenheiro civil

37400
24:47:47,440 --> 24:47:49,512
classe que vai herdar publicamente

37401
24:47:49,512 --> 24:47:52,000
do engenheiro, mas o que queremos focar

37402
24:47:52,000 --> 24:47:55,440
Aqui está o que orramos das classes base

37403
24:47:55,440 --> 24:47:57,512
Então a classe do engenheiro vai ter um

37404
24:47:57,512 --> 24:48:00,320
pessoa parte disso, mas também está indo

37405
24:48:00,320 --> 24:48:03,192
para construir em cima disso e adicionar um

37406
24:48:03,192 --> 24:48:06,480
nível de engenheiro e personalizar o tipo

37407
24:48:06,480 --> 24:48:09,760
da pessoa é assim se herdamos de

37408
24:48:09,760 --> 24:48:12,000
Engenheiro e que soldam o nosso civil

37409
24:48:12,000 --> 24:48:14,232
Engenheiro classe o primeiro link a ser

37410
24:48:14,232 --> 24:48:16,552
Construida por c plus plus é a parte da pessoa

37411
24:48:16,552 --> 24:48:19,040
É disso que vai construir um engenheiro

37412
24:48:19,040 --> 24:48:21,280
nível disso e depois vamos

37413
24:48:21,280 --> 24:48:24,080
adicionar um nível de engenheiro civil

37414
24:48:24,080 --> 24:48:27,920
para adicionar as personalizações que o civil

37415
24:48:27,920 --> 24:48:30,080
A classe de engenheiros está adicionando

37416
24:48:30,080 --> 24:48:32,640
e um c plus vai fazer isso

37417
24:48:32,640 --> 24:48:35,440
usando construtores por padrão, somos

37418
24:48:35,440 --> 24:48:37,832
Vou usar construtores padrão

37419
24:48:37,832 --> 24:48:40,160
se não especificarmos um caminho para o

37420
24:48:40,160 --> 24:48:42,480
estrutura básica a ser chamada c plus

37421
24:48:42,480 --> 24:48:44,000
plus vai chamar o padrão

37422
24:48:44,000 --> 24:48:47,512
construtor para construir seus objetos base

37423
24:48:47,512 --> 24:48:50,320
então se nós estabelecemos algo assim e

37424
24:48:50,320 --> 24:48:52,960
Tente executar um programa que vamos conseguir

37425
24:48:52,960 --> 24:48:54,872
Saída como esta, vamos ver que

37426
24:48:54,872 --> 24:48:56,640
a pessoa construtora padrão está indo

37427
24:48:56,640 --> 24:48:58,960
ser chamado em primeiro lugar e notar que nós

37428
24:48:58,960 --> 24:49:01,832
estão construindo um objeto de engenharia civil, então

37429
24:49:01,832 --> 24:49:04,160
o construtor padrão da maioria

37430
24:49:04,160 --> 24:49:06,480
A classe base será chamada então

37431
24:49:06,480 --> 24:49:08,552
Vamos construir um engenheiro

37432
24:49:08,552 --> 24:49:11,192
camada em cima das coisas da pessoa que nós

37433
24:49:11,192 --> 24:49:13,680
Então vamos construir uma civil

37434
24:49:13,680 --> 24:49:17,120
Camada de engenharia em cima do engenheiro

37435
24:49:17,120 --> 24:49:19,360
coisas que já temos e

37436
24:49:19,360 --> 24:49:21,280
O compilador vai fazer isso usando o

37437
24:49:21,280 --> 24:49:23,512
construtores padrão por padrão, então estamos

37438
24:49:23,512 --> 24:49:25,120
vai chamar o construtor padrão

37439
24:49:25,120 --> 24:49:27,192
para a pessoa em primeiro lugar vamos chamar de

37440
24:49:27,192 --> 24:49:29,280
construtor padrão para engenheiro e

37441
24:49:29,280 --> 24:49:31,120
Então vamos chamar o padrão

37442
24:49:31,120 --> 24:49:33,360
construtor para engenheiro civil para

37443
24:49:33,360 --> 24:49:36,160
completar a construção do nosso objeto

37444
24:49:36,160 --> 24:49:38,000
O objeto será completo neste

37445
24:49:38,000 --> 24:49:40,080
Ponto e nós seremos capazes de usá-lo

37446
24:49:40,080 --> 24:49:43,440
Mais tarde, em nosso programa aqui e

37447
24:49:43,440 --> 24:49:45,120
Espero que isso vá dirigir o

37448
24:49:45,120 --> 24:49:46,400
ponto de casa

37449
24:49:46,400 --> 24:49:49,040
que você realmente deve realmente sempre

37450
24:49:49,040 --> 24:49:51,360
fornecer aos fotoconstrutores para

37451
24:49:51,360 --> 24:49:54,320
suas classes porque o compilador pode

37452
24:49:54,320 --> 24:49:56,960
chamar estes construtores default em

37453
24:49:56,960 --> 24:50:00,080
maneiras inesperadas, especialmente se sua classe

37454
24:50:00,080 --> 24:50:03,600
faz parte de uma hierarquia de herança para

37455
24:50:03,600 --> 24:50:05,760
Se alguém tentar construir o

37456
24:50:05,760 --> 24:50:08,552
objeto de engenharia civil e você não tem

37457
24:50:08,552 --> 24:50:11,440
um construtor padrão para uma pessoa

37458
24:50:11,440 --> 24:50:13,192
O compilador vai tentar e codificar que

37459
24:50:13,192 --> 24:50:14,872
E não vai encontrar isso e ele

37460
24:50:14,872 --> 24:50:17,512
vai lançar um erro do compilador como nós

37461
24:50:17,512 --> 24:50:20,320
estão prestes a ver em um minuto, então o

37462
24:50:20,320 --> 24:50:22,232
Mensagem realmente nesta palestra é que

37463
24:50:22,232 --> 24:50:24,400
A parte mais básica da sua classe é

37464
24:50:24,400 --> 24:50:27,120
vai ser parafuso, por exemplo, para o nosso

37465
24:50:27,120 --> 24:50:28,640
classe de engenheiro civil que vamos

37466
24:50:28,640 --> 24:50:30,960
construir o porto da prisão primeiro, então nós somos

37467
24:50:30,960 --> 24:50:33,040
vai construir o parque de engenharia e

37468
24:50:33,040 --> 24:50:34,640
Então nós vamos construir o civil

37469
24:50:34,640 --> 24:50:36,872
projetar parte disso e então nós somos

37470
24:50:36,872 --> 24:50:39,680
Vou terminar a construção do nosso

37471
24:50:39,680 --> 24:50:42,320
Objeto esta é a mensagem aqui agora que

37472
24:50:42,320 --> 24:50:43,832
Você percebe que nós vamos ir para

37473
24:50:43,832 --> 24:50:45,760
código de estúdio visual e jogar com este

37474
24:50:45,760 --> 24:50:46,960
Pouco mais

37475
24:50:46,960 --> 24:50:49,760
Aqui estamos em nossa pasta de trabalho o

37476
24:50:49,760 --> 24:50:52,400
Projeto atual é argumento padrão

37477
24:50:52,400 --> 24:50:55,192
construtor com herança nós somos

37478
24:50:55,192 --> 24:50:56,960
Vou reutilizar o código a partir do último

37479
24:50:56,960 --> 24:50:58,640
palestra porque isso vai nos dar

37480
24:50:58,640 --> 24:51:01,280
As classes que precisamos jogar

37481
24:51:01,280 --> 24:51:03,280
com o que queremos fazer nesta palestra

37482
24:51:03,280 --> 24:51:04,960
e isso é jogar com padrão

37483
24:51:04,960 --> 24:51:07,920
construtores vamos colocar em nosso starter

37484
24:51:07,920 --> 24:51:09,512
código e nós vamos abrir este pequeno

37485
24:51:09,512 --> 24:51:12,160
Cara no código do estúdio visual vamos fazer isso

37486
24:51:12,160 --> 24:51:13,920
Vamos ter nossas aulas que somos

37487
24:51:13,920 --> 24:51:16,320
ter a função principal que

37488
24:51:16,320 --> 24:51:17,832
Você pode jogar com

37489
24:51:17,832 --> 24:51:20,720
e nós vamos olhar para a pessoa

37490
24:51:20,720 --> 24:51:23,040
classe e certifique-se de que temos um padrão

37491
24:51:23,040 --> 24:51:25,760
construtor, não vamos entrar em default

37492
24:51:25,760 --> 24:51:28,000
desta vez porque queremos ter um

37493
24:51:28,000 --> 24:51:32,480
corpo nós podemos colocar nossas declarações de saída em

37494
24:51:32,480 --> 24:51:34,160
Então, neste caso, vamos entrar no

37495
24:51:34,160 --> 24:51:36,320
arquivo cpp e colocar em um padrão

37496
24:51:36,320 --> 24:51:38,080
construtor, vamos dizer pessoa

37497
24:51:38,080 --> 24:51:41,512
e pessoa e pessoa aqui e isso é

37498
24:51:41,512 --> 24:51:43,192
Vou ser o nosso construtor, vamos

37499
24:51:43,192 --> 24:51:47,040
para dizer stdcl padrão construtor para

37500
24:51:47,040 --> 24:51:48,720
A pessoa chamada

37501
24:51:48,720 --> 24:51:51,120
Tudo bem para que a aula pessoal seja feita

37502
24:51:51,120 --> 24:51:53,680
ter um construtor padrão que funciona como

37503
24:51:53,680 --> 24:51:56,480
nós queremos e nós vamos para o nosso

37504
24:51:56,480 --> 24:51:58,480
Engenheiro de classe e nós vamos mudar

37505
24:51:58,480 --> 24:52:01,120
para fazer herança pública eu acho que isso

37506
24:52:01,120 --> 24:52:03,440
Vai ser muito mais fácil de lidar com

37507
24:52:03,440 --> 24:52:04,232
E agora

37508
24:52:04,232 --> 24:52:06,960
e nós vamos remover tudo isso

37509
24:52:06,960 --> 24:52:09,440
ressurreição estávamos fazendo aqui a partir do

37510
24:52:09,440 --> 24:52:11,512
A última palestra, porque isso não é mais

37511
24:52:11,512 --> 24:52:14,000
Vou ser necessário

37512
24:52:14,000 --> 24:52:16,320
O que realmente queremos é olhar

37513
24:52:16,320 --> 24:52:18,960
nosso construtor padrão, que é realmente

37514
24:52:18,960 --> 24:52:21,120
Aqui já vamos olhar para o

37515
24:52:21,120 --> 24:52:23,192
implementação de tudo o que realmente precisamos fazer

37516
24:52:23,192 --> 24:52:26,320
é colocado em sddc para fora e dizer default

37517
24:52:26,320 --> 24:52:27,760
construtor

37518
24:52:27,760 --> 24:52:28,872
para a

37519
24:52:28,872 --> 24:52:30,000
Engenheiro

37520
24:52:30,000 --> 24:52:31,040
Chamada

37521
24:52:31,040 --> 24:52:33,760
e nós vamos pular para o civil

37522
24:52:33,760 --> 24:52:36,400
projetar classe e ver se temos um

37523
24:52:36,400 --> 24:52:38,960
construtor padrão e nós temos isso

37524
24:52:38,960 --> 24:52:41,360
e vamos para o arquivo cpp

37525
24:52:41,360 --> 24:52:44,232
e dizer sddcl

37526
24:52:44,232 --> 24:52:46,720
Construtor padrão chamado

37527
24:52:46,720 --> 24:52:49,360
para o engenheiro civil

37528
24:52:49,360 --> 24:52:52,000
Então isso vai basicamente fazer o que nós

37529
24:52:52,000 --> 24:52:54,720
Queremos e o que realmente queremos ver

37530
24:52:54,720 --> 24:52:57,360
É como ou a ordem em que

37531
24:52:57,360 --> 24:52:59,680
Os construtores serão chamados se

37532
24:52:59,680 --> 24:53:02,720
Construímos um objeto de engenharia civil como nós

37533
24:53:02,720 --> 24:53:04,640
Tenho visto aqui a parte da pessoa está indo

37534
24:53:04,640 --> 24:53:06,552
para ser construído primeiro para que isso vá

37535
24:53:06,552 --> 24:53:08,872
chamar o construtor de pessoa e

37536
24:53:08,872 --> 24:53:11,120
porque não estamos fazendo nenhum tipo de

37537
24:53:11,120 --> 24:53:13,600
customização em que construtor é

37538
24:53:13,600 --> 24:53:15,600
vai ser chamado de compilador está indo

37539
24:53:15,600 --> 24:53:17,440
para chamar o construtor padrão por

37540
24:53:17,440 --> 24:53:19,040
padrão para que possamos construir o

37541
24:53:19,040 --> 24:53:21,192
pessoa porta primeiro e nós vamos ver

37542
24:53:21,192 --> 24:53:22,872
O construtor padrão para uma pessoa

37543
24:53:22,872 --> 24:53:25,192
Chamados depois disso vamos construir

37544
24:53:25,192 --> 24:53:27,760
A parte do engenheiro de nós

37545
24:53:27,760 --> 24:53:29,440
e isso vai chamar o padrão

37546
24:53:29,440 --> 24:53:32,160
construtor para engenheiro e depois disso

37547
24:53:32,160 --> 24:53:34,640
Nós vamos soldar o engenheiro civil

37548
24:53:34,640 --> 24:53:36,720
parte de nós e isso vai chamar o

37549
24:53:36,720 --> 24:53:39,512
construtor padrão do engenheiro civil este

37550
24:53:39,512 --> 24:53:41,192
É o que queremos ver

37551
24:53:41,192 --> 24:53:44,800
se construirmos um objeto de engenharia civil assim

37552
24:53:44,800 --> 24:53:47,120
nós vamos pular no cpp principal

37553
24:53:47,120 --> 24:53:49,040
arquivar e realmente construir o civil

37554
24:53:49,040 --> 24:53:51,832
Engenheiro objeto, vamos dizer civil

37555
24:53:51,832 --> 24:53:55,360
Engenheiro e nós vamos dizer ce1 nós

37556
24:53:55,360 --> 24:53:57,440
Podemos fazer isso e vamos ver o que

37557
24:53:57,440 --> 24:54:00,232
Acontece que vamos tentar construir este programa

37558
24:54:00,232 --> 24:54:03,040
nós vamos construir isso com gcc

37559
24:54:03,040 --> 24:54:05,832
O livro vai ser bom, poderíamos executá-lo

37560
24:54:05,832 --> 24:54:08,320
vamos trazer uma janela powershell nós

37561
24:54:08,320 --> 24:54:10,000
Você pode jogar com

37562
24:54:10,000 --> 24:54:13,040
Queremos trazer uma janela powershell

37563
24:54:13,040 --> 24:54:14,640
nós podemos limpar

37564
24:54:14,640 --> 24:54:16,480
e correr o galo

37565
24:54:16,480 --> 24:54:17,832
e você vai ver esse padrão

37566
24:54:17,832 --> 24:54:20,000
construtor para uma pessoa chamada de

37567
24:54:20,000 --> 24:54:22,480
Primeiro construtor para engenheiro chamado

37568
24:54:22,480 --> 24:54:24,800
construtor padrão para

37569
24:54:24,800 --> 24:54:27,760
O engenheiro chamado é o que queremos

37570
24:54:27,760 --> 24:54:30,080
Veja e espero que isso prove que o

37571
24:54:30,080 --> 24:54:31,832
O compilador realmente vai construir um

37572
24:54:31,832 --> 24:54:35,280
objeto de engenharia civil em partes

37573
24:54:35,280 --> 24:54:36,872
O compilador vai ver que é um

37574
24:54:36,872 --> 24:54:38,960
objeto derivado e ele vai ver tudo

37575
24:54:38,960 --> 24:54:41,680
as classes que isso está derivando de

37576
24:54:41,680 --> 24:54:44,080
por isso vai construir a mais base

37577
24:54:44,080 --> 24:54:46,400
Parte primeiro depois que vai

37578
24:54:46,400 --> 24:54:48,720
construir outras camadas até que ele atinja o

37579
24:54:48,720 --> 24:54:51,920
nível em que estamos nesta situação civil

37580
24:54:51,920 --> 24:54:55,040
projetar objetos novamente se colocarmos outro

37581
24:54:55,040 --> 24:54:57,512
Declaração aqui vou dizer

37582
24:54:57,512 --> 24:54:58,960
Olá aqui dentro

37583
24:54:58,960 --> 24:55:01,920
e nós vamos dizer sdd-endl

37584
24:55:01,920 --> 24:55:04,400
E eu estou fazendo isso para que eu tenha apenas

37585
24:55:04,400 --> 24:55:07,040
Um ponto onde eu posso colocar meu ponto de ruptura

37586
24:55:07,040 --> 24:55:09,440
alguns ides não vão gostar se

37587
24:55:09,440 --> 24:55:12,160
você coloca um ponto de ruptura em uma linha vazia, então

37588
24:55:12,160 --> 24:55:14,640
É por isso que eu estou fazendo isso aqui e eu estou

37589
24:55:14,640 --> 24:55:16,552
Vou tentar depurar e realmente mostrar

37590
24:55:16,552 --> 24:55:19,512
você que nós temos um engenheiro e um

37591
24:55:19,512 --> 24:55:21,600
pessoa parte em nós eu te mostrei isso

37592
24:55:21,600 --> 24:55:23,512
Antes, mas não dói realmente

37593
24:55:23,512 --> 24:55:24,872
Repita isso

37594
24:55:24,872 --> 24:55:27,680
Porque debugging é muito legal é muito legal

37595
24:55:27,680 --> 24:55:30,232
dar mais informações do que

37596
24:55:30,232 --> 24:55:32,320
Você poderia sempre pedir

37597
24:55:32,320 --> 24:55:34,960
nós vamos acertar nosso ponto de ruptura aqui

37598
24:55:34,960 --> 24:55:37,280
E se olharmos em nosso

37599
24:55:37,280 --> 24:55:39,280
locais nós vamos ter o nosso civil

37600
24:55:39,280 --> 24:55:42,160
objeto de engenharia que está no escopo agora

37601
24:55:42,160 --> 24:55:44,080
E você vê que temos um engenheiro

37602
24:55:44,080 --> 24:55:47,512
parte de nós e do engenheiro tem uma pessoa

37603
24:55:47,512 --> 24:55:49,760
parceiro para o que o compilador é realmente

37604
24:55:49,760 --> 24:55:51,760
indo fazer quando ele está construindo um civil

37605
24:55:51,760 --> 24:55:54,720
objeto de engenharia que vai construir o

37606
24:55:54,720 --> 24:55:57,280
A parte mais baseada de nós, por isso vai

37607
24:55:57,280 --> 24:55:59,512
construir uma parte pessoal depois que é

37608
24:55:59,512 --> 24:56:01,680
Vou construir uma camada de engenheiro no topo

37609
24:56:01,680 --> 24:56:03,600
E depois vai para o mundo

37610
24:56:03,600 --> 24:56:06,232
A camada servongemeira e é isso que

37611
24:56:06,232 --> 24:56:09,120
Vemos em nossa produção quando podemos correr

37612
24:56:09,120 --> 24:56:11,512
nosso programa aqui se voltarmos, estamos

37613
24:56:11,512 --> 24:56:13,360
Vou ver que ainda temos o nosso

37614
24:56:13,360 --> 24:56:15,512
Binário, ainda podemos executá-lo

37615
24:56:15,512 --> 24:56:17,760
vamos trazer uma janela de terminal que podemos

37616
24:56:17,760 --> 24:56:19,280
Use para executar isso, vamos correr

37617
24:56:19,280 --> 24:56:21,360
Galo e nós vamos ver a ordem

37618
24:56:21,360 --> 24:56:24,160
em que nossos construtores são chamados

37619
24:56:24,160 --> 24:56:26,160
Isso é muito legal agora que temos

37620
24:56:26,160 --> 24:56:28,480
apenas depurado este programa que você pode tomar

37621
24:56:28,480 --> 24:56:30,400
fora desta linha hello porque é realmente

37622
24:56:30,400 --> 24:56:32,960
inútil e isso é realmente o que eu queria

37623
24:56:32,960 --> 24:56:35,360
Você ver que os construtores vão ser

37624
24:56:35,360 --> 24:56:38,640
Chamado em sua hierarquia de herança

37625
24:56:38,640 --> 24:56:41,192
A partir dos mais básicos

37626
24:56:41,192 --> 24:56:44,160
Indo para o mais especializado

37627
24:56:44,160 --> 24:56:45,680
Então vamos chamar o mais melhor

37628
24:56:45,680 --> 24:56:47,680
construtor que é pessoa e nós somos

37629
24:56:47,680 --> 24:56:49,920
Vou continuar até chegarmos ao

37630
24:56:49,920 --> 24:56:52,480
mais especializada, que é civil

37631
24:56:52,480 --> 24:56:56,160
projetar aqui para construir nosso objeto e

37632
24:56:56,160 --> 24:56:58,400
Nosso objeto vai realmente ser construído

37633
24:56:58,400 --> 24:57:00,960
em camadas esta é a mensagem que eu sou

37634
24:57:00,960 --> 24:57:03,192
Tentando transmitir aqui isso é realmente tudo

37635
24:57:03,192 --> 24:57:05,120
Eu tive que compartilhar nesta palestra eu espero

37636
24:57:05,120 --> 24:57:07,512
Você achou interessante que vamos

37637
24:57:07,512 --> 24:57:09,832
Parar aqui neste o próximo que somos

37638
24:57:09,832 --> 24:57:11,832
Vou ver que nós podemos realmente

37639
24:57:11,832 --> 24:57:15,280
chamar ativamente um construtor de classe base

37640
24:57:15,280 --> 24:57:17,832
da nossa classe derivada e isso está indo

37641
24:57:17,832 --> 24:57:21,360
para adicionar muito mais flexibilidade em como

37642
24:57:21,360 --> 24:57:23,680
Os objetos são construídos, não vamos

37643
24:57:23,680 --> 24:57:25,280
chamar o construtor padrão que estamos indo

37644
24:57:25,280 --> 24:57:28,160
para chamar nossos próprios construtores e

37645
24:57:28,160 --> 24:57:30,552
ter muito mais controle sobre como

37646
24:57:30,552 --> 24:57:34,320
Objetos derivados são criados no mundo

37647
24:57:34,320 --> 24:57:36,552
Vá em frente e termine aqui e me encontre

37648
24:57:36,552 --> 24:57:38,000
Na próxima palestra

37649
24:57:38,000 --> 24:57:40,232
Nesta palestra, vamos ver uma maneira

37650
24:57:40,232 --> 24:57:43,192
nós podemos instruir para construtores personalizados

37651
24:57:43,192 --> 24:57:44,552
para ser chamado

37652
24:57:44,552 --> 24:57:47,920
quando nossos objetos derivados estão sendo construídos

37653
24:57:47,920 --> 24:57:49,040
e configurar

37654
24:57:49,040 --> 24:57:51,760
Na última palestra vimos uma figura como

37655
24:57:51,760 --> 24:57:54,640
tínhamos uma hierarquia de herança

37656
24:57:54,640 --> 24:57:57,120
que passou de pessoa para engenheiro e para

37657
24:57:57,120 --> 24:57:59,832
engenheiro civil e vimos que, se definirmos

37658
24:57:59,832 --> 24:58:02,080
Um engenheiro civil objeto um pessoal

37659
24:58:02,080 --> 24:58:04,320
A parte será construída primeiro a

37660
24:58:04,320 --> 24:58:06,000
A parte do engenheiro será construída sobre

37661
24:58:06,000 --> 24:58:08,000
no topo e da parte do engenheiro civil

37662
24:58:08,000 --> 24:58:09,600
Isso vai ser

37663
24:58:09,600 --> 24:58:11,192
construído e então nós vamos ter o

37664
24:58:11,192 --> 24:58:13,600
Construção completa para o nosso civil

37665
24:58:13,600 --> 24:58:16,552
objeto de engenharia, mas na última palestra

37666
24:58:16,552 --> 24:58:18,872
Vimos que isso estava chamando o padrão

37667
24:58:18,872 --> 24:58:21,280
construtores e às vezes você não

37668
24:58:21,280 --> 24:58:24,552
Quer que você queira seus objetos embutidos

37669
24:58:24,552 --> 24:58:27,192
Uma maneira específica, por exemplo, através de

37670
24:58:27,192 --> 24:58:29,040
Um monte de parâmetros para os quais você passa

37671
24:58:29,040 --> 24:58:30,960
seu construtor e se você quiser isso

37672
24:58:30,960 --> 24:58:32,800
tipo de configuração é isso que estamos indo

37673
24:58:32,800 --> 24:58:35,600
para aprender sobre esta palestra e o que

37674
24:58:35,600 --> 24:58:37,680
Queremos acabar com algo como

37675
24:58:37,680 --> 24:58:39,512
Será capaz de construir uma pessoa

37676
24:58:39,512 --> 24:58:41,192
objeto passando em um monte de

37677
24:58:41,192 --> 24:58:43,192
parâmetros que nós podemos passar

37678
24:58:43,192 --> 24:58:45,832
O nome completo que podemos passar na idade i

37679
24:58:45,832 --> 24:58:47,680
Acho que esta é a idade que podemos passar em um

37680
24:58:47,680 --> 24:58:50,232
endereço, podemos construir um objeto de engenharia

37681
24:58:50,232 --> 24:58:52,080
passando neste tipo de informação

37682
24:58:52,080 --> 24:58:54,480
Podemos passar no nome a idade e a

37683
24:58:54,480 --> 24:58:56,800
endereço, mas também podemos passar no

37684
24:58:56,800 --> 24:58:59,760
contagem de contrato eu acho que este é o novo

37685
24:58:59,760 --> 24:59:02,640
membro variável que tínhamos em nosso engenheiro

37686
24:59:02,640 --> 24:59:04,872
classe, mas não vamos parar por aí

37687
24:59:04,872 --> 24:59:06,872
Também podemos construir um engenheiro civil

37688
24:59:06,872 --> 24:59:08,872
Objeto e podemos passar no

37689
24:59:08,872 --> 24:59:11,040
Mais uma informação, um engenheiro civil é

37690
24:59:11,040 --> 24:59:13,280
Também uma pessoa, então nós vamos ser

37691
24:59:13,280 --> 24:59:15,120
Passar a informação que vai fazer

37692
24:59:15,120 --> 24:59:16,872
inicializar a parte da pessoa e que

37693
24:59:16,872 --> 24:59:19,920
é o nome da idade e do

37694
24:59:19,920 --> 24:59:22,720
Um engenheiro civil também é um

37695
24:59:22,720 --> 24:59:24,232
Engenheiro para que vamos passar

37696
24:59:24,232 --> 24:59:27,360
Informações que retratam ao nível

37697
24:59:27,360 --> 24:59:28,960
de um engenheiro e isso vai ser

37698
24:59:28,960 --> 24:59:31,192
A contagem do contrato e nós vamos

37699
24:59:31,192 --> 24:59:33,512
passar a informação para inicializar o

37700
24:59:33,512 --> 24:59:36,640
engenheiro civil parte deste objeto e

37701
24:59:36,640 --> 24:59:39,120
que vai ser a força da estrada

37702
24:59:39,120 --> 24:59:41,120
E espero que a partir disso você possa ver que

37703
24:59:41,120 --> 24:59:42,640
Precisamos de um jeito

37704
24:59:42,640 --> 24:59:44,960
para encaminhar toda essa informação para o

37705
24:59:44,960 --> 24:59:47,440
construtor onde esta informação é

37706
24:59:47,440 --> 24:59:49,832
Necessidade, por exemplo, se estamos construindo um

37707
24:59:49,832 --> 24:59:53,040
Objetos de engenharia civil que queremos encaminhar

37708
24:59:53,040 --> 24:59:56,320
o nome da idade e do endereço para o

37709
24:59:56,320 --> 24:59:59,192
pessoa parte de nós, então precisamos analisar

37710
24:59:59,192 --> 25:00:01,512
Isto para o nosso construtor pessoal em

37711
25:00:01,512 --> 25:00:06,232
Como precisamos passar o 31 aqui para o nosso

37712
25:00:06,232 --> 25:00:08,960
Engenheiro construtor porque isso

37713
25:00:08,960 --> 25:00:12,000
A informação será armazenada em nosso

37714
25:00:12,000 --> 25:00:14,720
nível de engenharia e precisamos armazenar o

37715
25:00:14,720 --> 25:00:18,000
informações sobre a força da estrada no civil

37716
25:00:18,000 --> 25:00:20,720
projetar parte de nós, porque é onde

37717
25:00:20,720 --> 25:00:23,040
Esta variável de membro é declarada

37718
25:00:23,040 --> 25:00:24,960
Espero que você possa ver a necessidade de ligar

37719
25:00:24,960 --> 25:00:27,280
construtores personalizados que não são

37720
25:00:27,280 --> 25:00:29,600
padrão, esses construtores personalizados são

37721
25:00:29,600 --> 25:00:32,160
permitindo-nos encaminhar informações

37722
25:00:32,160 --> 25:00:35,280
Quando construir nossos objetos como nós somos

37723
25:00:35,280 --> 25:00:37,920
fazendo aqui na função principal, então vamos

37724
25:00:37,920 --> 25:00:40,320
Veja como podemos fazer isso alguns de vocês

37725
25:00:40,320 --> 25:00:42,232
pensar uh-huh se eu estou construindo um

37726
25:00:42,232 --> 25:00:44,960
Engenheiro objeto eu posso simplesmente pegar o

37727
25:00:44,960 --> 25:00:47,120
informação e passar isso para a minha base

37728
25:00:47,120 --> 25:00:49,600
classe e isso é simples para que possamos

37729
25:00:49,600 --> 25:00:51,512
Pegue todas essas informações que podemos pegar

37730
25:00:51,512 --> 25:00:54,480
O nome completo a idade e endereço

37731
25:00:54,480 --> 25:00:57,192
e passar isso para a nossa classe base usando

37732
25:00:57,192 --> 25:00:59,760
as sintaxes que temos aqui se formos

37733
25:00:59,760 --> 25:01:01,600
Fazendo herança pública, vamos

37734
25:01:01,600 --> 25:01:03,600
Tenho acesso a esses caras de qualquer maneira, então nós

37735
25:01:03,600 --> 25:01:06,400
pode dizer que nome completo é igual ao nome completo mag

37736
25:01:06,400 --> 25:01:09,280
igual a idade e dizer m endereço é igual a

37737
25:01:09,280 --> 25:01:10,552
Endereço

37738
25:01:10,552 --> 25:01:11,920
Exceto

37739
25:01:11,920 --> 25:01:15,600
para o endereço é realmente privado para

37740
25:01:15,600 --> 25:01:18,720
A classe da pessoa e nós não podemos fazer

37741
25:01:18,720 --> 25:01:21,120
Algo assim se tentarmos acessar

37742
25:01:21,120 --> 25:01:23,280
A variável membro de endereço a partir do

37743
25:01:23,280 --> 25:01:25,680
classe base e modificá-lo que vamos

37744
25:01:25,680 --> 25:01:27,600
obter um erro do compilador que diz que

37745
25:01:27,600 --> 25:01:30,320
O endereço é realmente privado para a base

37746
25:01:30,320 --> 25:01:33,280
pessoa de classe, não podemos fazer isso, então isso é

37747
25:01:33,280 --> 25:01:35,680
não vai funcionar bem alguns de vocês

37748
25:01:35,680 --> 25:01:38,480
Pense uh-huh e se eu tentar usar um

37749
25:01:38,480 --> 25:01:41,192
lista de inicializadores e fazer algo como

37750
25:01:41,192 --> 25:01:43,680
para que eu possa dizer m nome completo e passar

37751
25:01:43,680 --> 25:01:46,480
na minha informação eu posso dizer mh e colocar

37752
25:01:46,480 --> 25:01:49,040
nas minhas informações posso dizer m endereço

37753
25:01:49,040 --> 25:01:50,800
e colocar na minha informação e, em seguida,

37754
25:01:50,800 --> 25:01:52,232
inicializar

37755
25:01:52,232 --> 25:01:54,720
a variável membro que realmente

37756
25:01:54,720 --> 25:01:57,280
pertence à classe de engenharia que nós

37757
25:01:57,280 --> 25:02:00,000
estão tentando construir um objeto para aqui

37758
25:02:00,000 --> 25:02:01,680
E espero que isso funcione

37759
25:02:01,680 --> 25:02:04,320
Exceto que o compilador também não vai

37760
25:02:04,320 --> 25:02:07,192
aceitar isso a razão é com

37761
25:02:07,192 --> 25:02:10,400
initializer listar que você não pode inicializar um

37762
25:02:10,400 --> 25:02:13,192
variável de membro que não pertence a

37763
25:02:13,192 --> 25:02:15,440
A classe que você está tentando construir

37764
25:02:15,440 --> 25:02:17,832
um objeto para isso, por exemplo, aqui estamos

37765
25:02:17,832 --> 25:02:20,800
tentando inicializar o nome completo mh e

37766
25:02:20,800 --> 25:02:23,440
m endereço, mas essas variáveis de membro

37767
25:02:23,440 --> 25:02:26,160
Não pertença à classe de engenharia que

37768
25:02:26,160 --> 25:02:28,320
Estamos tentando construir um objeto para isso

37769
25:02:28,320 --> 25:02:30,232
vamos ter um erro de compilador aqui

37770
25:02:30,232 --> 25:02:32,552
Isso não vai funcionar, não é

37771
25:02:32,552 --> 25:02:34,480
O trabalho do engenheiro

37772
25:02:34,480 --> 25:02:37,512
para construir ou configurar estas variáveis de membro

37773
25:02:37,512 --> 25:02:40,160
então isso não vai funcionar bem, então

37774
25:02:40,160 --> 25:02:42,160
Como devemos avançar

37775
25:02:42,160 --> 25:02:45,440
informações de classes derivadas para base

37776
25:02:45,440 --> 25:02:46,640
classes

37777
25:02:46,640 --> 25:02:48,872
Não se preocupe aqui ainda podemos usar

37778
25:02:48,872 --> 25:02:51,512
listas inicializadoras, mas nós vamos

37779
25:02:51,512 --> 25:02:54,232
Use construtores cujo trabalho vai

37780
25:02:54,232 --> 25:02:56,960
para inicializar essas variáveis de membro

37781
25:02:56,960 --> 25:02:59,360
então, se estamos construindo um objeto de engenharia

37782
25:02:59,360 --> 25:03:01,280
e nós temos informações que realmente

37783
25:03:01,280 --> 25:03:04,080
Pertence à parte de nós que somos

37784
25:03:04,080 --> 25:03:05,920
chamar a pessoa de construtor para

37785
25:03:05,920 --> 25:03:08,720
realmente usar esta informação para construir

37786
25:03:08,720 --> 25:03:10,640
A parte pessoal de nós e nós vamos

37787
25:03:10,640 --> 25:03:13,120
estar chamando a pessoa de construtor em

37788
25:03:13,120 --> 25:03:16,080
nossa lista de inicializadores aqui e depois de nós

37789
25:03:16,080 --> 25:03:18,480
para que vamos inicializar um

37790
25:03:18,480 --> 25:03:20,800
variável de membro que realmente pertence a

37791
25:03:20,800 --> 25:03:24,080
Nós em nossa lista inicializadora isso está indo

37792
25:03:24,080 --> 25:03:25,920
para encaminhar informações de derivadas

37793
25:03:25,920 --> 25:03:28,640
aulas neste caso, o engenheiro é o

37794
25:03:28,640 --> 25:03:30,872
classe derivada e a informação é

37795
25:03:30,872 --> 25:03:33,280
Vou ser encaminhado para a pessoa

37796
25:03:33,280 --> 25:03:35,680
construtor que é a nossa classe base este

37797
25:03:35,680 --> 25:03:37,600
É assim que isso vai funcionar

37798
25:03:37,600 --> 25:03:39,120
Tudo bem agora que você sabe disso, estamos indo

37799
25:03:39,120 --> 25:03:41,192
para ir até o código do estúdio visual e

37800
25:03:41,192 --> 25:03:42,872
brincar um pouco mais com a gente

37801
25:03:42,872 --> 25:03:45,280
Aqui estamos em nossa pasta de trabalho o

37802
25:03:45,280 --> 25:03:47,680
O projeto atual é construtores com

37803
25:03:47,680 --> 25:03:50,320
Herança vamos pegar o

37804
25:03:50,320 --> 25:03:52,160
código da última palestra porque

37805
25:03:52,160 --> 25:03:54,480
que vai ser o nosso ponto de partida

37806
25:03:54,480 --> 25:03:55,680
E nós vamos para

37807
25:03:55,680 --> 25:03:57,120
colar isso

37808
25:03:57,120 --> 25:03:59,832
em nosso projeto atual

37809
25:03:59,832 --> 25:04:02,080
Nós vamos abrir este pequeno rapaz em

37810
25:04:02,080 --> 25:04:03,920
código visual do estúdio arrastando e

37811
25:04:03,920 --> 25:04:06,320
caindo aqui e isso vai dar

37812
25:04:06,320 --> 25:04:08,640
Nós o nosso código inicial que vamos ter

37813
25:04:08,640 --> 25:04:11,040
uma pessoa classifica uma classe de engenheiro e um

37814
25:04:11,040 --> 25:04:13,512
classe de engenharia civil e isso é

37815
25:04:13,512 --> 25:04:15,512
basicamente vai configurar a hierarquia

37816
25:04:15,512 --> 25:04:18,640
Temos aqui e o que queremos alcançar

37817
25:04:18,640 --> 25:04:21,360
É ser capaz de chamar o nosso próprio costume

37818
25:04:21,360 --> 25:04:22,872
construtores

37819
25:04:22,872 --> 25:04:25,512
Quando construímos nosso objeto em camadas

37820
25:04:25,512 --> 25:04:27,512
A informação virá de um

37821
25:04:27,512 --> 25:04:29,512
objeto de engenharia civil

37822
25:04:29,512 --> 25:04:31,600
e vamos inicializar o

37823
25:04:31,600 --> 25:04:33,512
Uma parte de nós com relevante

37824
25:04:33,512 --> 25:04:34,400
Informações sobre a informação

37825
25:04:34,400 --> 25:04:36,232
Vamos inicializar o engenheiro

37826
25:04:36,232 --> 25:04:38,640
parte de nós com informações relevantes e

37827
25:04:38,640 --> 25:04:40,480
Vamos inicializar o civil

37828
25:04:40,480 --> 25:04:42,960
Engenheiro de nós com relevante

37829
25:04:42,960 --> 25:04:44,800
informação é o que queremos

37830
25:04:44,800 --> 25:04:47,760
conseguir ok para que isso funcione, precisamos

37831
25:04:47,760 --> 25:04:50,160
Não chamar construtores padrão que queremos

37832
25:04:50,160 --> 25:04:52,872
chamar os construtores reais que estão indo

37833
25:04:52,872 --> 25:04:55,512
para pegar a informação e encaminhar isso

37834
25:04:55,512 --> 25:04:58,480
em nossas variáveis de membros, por exemplo, em

37835
25:04:58,480 --> 25:05:00,160
Pessoa que temos um construtor que é

37836
25:05:00,160 --> 25:05:01,920
Vou tomar três pedaços de

37837
25:05:01,920 --> 25:05:03,192
Informações sobre a informação

37838
25:05:03,192 --> 25:05:05,600
e vai passar esta informação

37839
25:05:05,600 --> 25:05:08,640
em nossas variáveis de membro que precisamos

37840
25:05:08,640 --> 25:05:11,360
aplicar algumas mudanças aqui, por exemplo,

37841
25:05:11,360 --> 25:05:14,832
O terceiro parâmetro é passado como um custo

37842
25:05:14,832 --> 25:05:17,680
tipo de membro de força que vamos

37843
25:05:17,680 --> 25:05:20,000
mudar isso para ser uma visão de força

37844
25:05:20,000 --> 25:05:22,320
Porque isso vai nos salvar

37845
25:05:22,320 --> 25:05:24,080
em cópias

37846
25:05:24,080 --> 25:05:26,232
Vamos dizer string view aqui isso está indo

37847
25:05:26,232 --> 25:05:27,600
para o trabalho

37848
25:05:27,600 --> 25:05:30,320
e isso vai encaminhar informações

37849
25:05:30,320 --> 25:05:32,800
de uma forma que queremos, vamos mudar

37850
25:05:32,800 --> 25:05:36,640
nosso terceiro parâmetro para bhtd string view

37851
25:05:36,640 --> 25:05:38,400
Vamos dizer que a vista de string aqui estamos indo

37852
25:05:38,400 --> 25:05:41,360
para dizer std string view isto é o que nós

37853
25:05:41,360 --> 25:05:44,552
Temos em nosso cabeçalho que vamos ser

37854
25:05:44,552 --> 25:05:46,960
ter a mesma assinatura para o nosso

37855
25:05:46,960 --> 25:05:48,552
A função aqui

37856
25:05:48,552 --> 25:05:50,552
E o que é errado

37857
25:05:50,552 --> 25:05:55,120
nós temos m nome completo mh e temos m

37858
25:05:55,120 --> 25:05:57,440
Endereço aqui, vamos tentar construir e ver

37859
25:05:57,440 --> 25:05:59,680
Se o erro desaparecer às vezes visual

37860
25:05:59,680 --> 25:06:02,400
Código do estúdio está jogando jogos em nós

37861
25:06:02,400 --> 25:06:03,920
Se tivermos um erro do compilador, vamos

37862
25:06:03,920 --> 25:06:05,760
para tentar consertar que você vê que é

37863
25:06:05,760 --> 25:06:08,000
código visual do estúdio que joga conosco o

37864
25:06:08,000 --> 25:06:10,080
O código está muito bem aqui

37865
25:06:10,080 --> 25:06:10,960
Então,

37866
25:06:10,960 --> 25:06:13,192
Temos nosso construtor para pessoa que é

37867
25:06:13,192 --> 25:06:15,440
indo para a frente informações usando o nosso

37868
25:06:15,440 --> 25:06:18,000
lista de inicializadores aqui vamos

37869
25:06:18,000 --> 25:06:19,760
Olhe para o nosso

37870
25:06:19,760 --> 25:06:22,000
classe de engenharia se formos lá nós estamos

37871
25:06:22,000 --> 25:06:23,920
Vou ver que não temos nenhum

37872
25:06:23,920 --> 25:06:26,000
construtor que vai agarrar

37873
25:06:26,000 --> 25:06:29,280
informações de qualquer forma significativa e

37874
25:06:29,280 --> 25:06:31,920
Coloque isso em nossa classe

37875
25:06:31,920 --> 25:06:34,320
então vamos colocar em um construtor

37876
25:06:34,320 --> 25:06:37,040
Parece o que temos em nosso

37877
25:06:37,040 --> 25:06:40,400
pessoa de classe para que possamos simplesmente pegar este eu

37878
25:06:40,400 --> 25:06:42,552
como copiar e colar porque isso é

37879
25:06:42,552 --> 25:06:44,232
Vou me salvar

37880
25:06:44,232 --> 25:06:46,552
alguns segundos, então eu vou colocar o meu

37881
25:06:46,552 --> 25:06:48,800
construtor aqui só não vai

37882
25:06:48,800 --> 25:06:50,552
ser chamado de pessoa que vai ser

37883
25:06:50,552 --> 25:06:53,040
Engenheiro e eu vou adicionar um

37884
25:06:53,040 --> 25:06:54,400
contagem de construção

37885
25:06:54,400 --> 25:06:56,552
membro e isso vai ser um

37886
25:06:56,552 --> 25:06:59,600
inteiro aqui para manter as coisas mais simples

37887
25:06:59,600 --> 25:07:01,192
e nós vamos colocar um

37888
25:07:01,192 --> 25:07:03,512
implementação deste construtor em

37889
25:07:03,512 --> 25:07:06,552
nossa classe de engenheiros podemos ir até aqui

37890
25:07:06,552 --> 25:07:08,160
e colocar isso na frente de outros

37891
25:07:08,160 --> 25:07:10,232
construtores, vamos olhar para a ordem

37892
25:07:10,232 --> 25:07:12,320
ter em nosso

37893
25:07:12,320 --> 25:07:14,720
cabeçalho porque eu gosto de ser consistente

37894
25:07:14,720 --> 25:07:17,600
O construtor padrão é primeiro assim

37895
25:07:17,600 --> 25:07:19,680
Este construtor vai ser o segundo

37896
25:07:19,680 --> 25:07:21,760
e nós vamos dizer que ele pertence

37897
25:07:21,760 --> 25:07:23,920
para a classe do engenheiro

37898
25:07:23,920 --> 25:07:26,640
usando um operador de resolução de escopo aqui

37899
25:07:26,640 --> 25:07:28,480
e nós vamos colocar em nosso

37900
25:07:28,480 --> 25:07:30,232
lista de initializer

37901
25:07:30,232 --> 25:07:33,832
Agora o que queremos fazer é chamar

37902
25:07:33,832 --> 25:07:36,232
O construtor para a pessoa para inicializar

37903
25:07:36,232 --> 25:07:38,552
Uma pessoa parte de nós e então nós vamos

37904
25:07:38,552 --> 25:07:40,000
para pegar as informações do

37905
25:07:40,000 --> 25:07:41,512
Contar contrato e nós vamos

37906
25:07:41,512 --> 25:07:44,720
encaminá-mo em nossa própria variável de membro

37907
25:07:44,720 --> 25:07:45,920
A maneira como vamos conseguir isso

37908
25:07:45,920 --> 25:07:47,360
Vamos chamar a pessoa

37909
25:07:47,360 --> 25:07:49,512
construtor e nós vamos passar

37910
25:07:49,512 --> 25:07:51,832
O nome completo vamos passar o

37911
25:07:51,832 --> 25:07:54,480
idade e vamos passar o endereço

37912
25:07:54,480 --> 25:07:56,872
e então vamos inicializar o nosso

37913
25:07:56,872 --> 25:07:59,040
variável de membro próprio que é contrato

37914
25:07:59,040 --> 25:08:00,872
Contagem I pensar

37915
25:08:00,872 --> 25:08:02,960
Vamos ao cabeçalho e olhe para isso

37916
25:08:02,960 --> 25:08:04,640
nós vamos ver que nosso membro

37917
25:08:04,640 --> 25:08:06,232
variável é a contagem de contratos, então nós somos

37918
25:08:06,232 --> 25:08:08,552
vamos dizer a contagem de contratos e nós somos

37919
25:08:08,552 --> 25:08:11,512
vamos dizer que a contagem de contrato param nós somos

37920
25:08:11,512 --> 25:08:13,832
Vou nomear isso de forma diferente, porque

37921
25:08:13,832 --> 25:08:16,552
Não queremos problemas com a nomeação aqui, então

37922
25:08:16,552 --> 25:08:19,680
Vamos dar ao nosso parâmetro aqui.

37923
25:08:19,680 --> 25:08:21,360
Isso não vai confundir o

37924
25:08:21,360 --> 25:08:23,832
compilador e uma vez que temos esse fim,

37925
25:08:23,832 --> 25:08:26,480
só pode colocar no corpo que está indo

37926
25:08:26,480 --> 25:08:28,080
Estar vazio porque todo o

37927
25:08:28,080 --> 25:08:30,800
A inicialização agora é feita em nosso

37928
25:08:30,800 --> 25:08:32,800
lista de inicializadores aqui

37929
25:08:32,800 --> 25:08:34,960
então, se fizermos isso, vamos ver que

37930
25:08:34,960 --> 25:08:37,040
O compilador vai ficar feliz com

37931
25:08:37,040 --> 25:08:39,760
Nossa coisa aqui nós vamos descer

37932
25:08:39,760 --> 25:08:40,800
nosso

37933
25:08:40,800 --> 25:08:43,280
classe de engenharia civil

37934
25:08:43,280 --> 25:08:45,040
e nós vamos pegar o construtor

37935
25:08:45,040 --> 25:08:46,552
Temos um engenheiro porque vamos

37936
25:08:46,552 --> 25:08:48,720
Usar isso como ponto de partida

37937
25:08:48,720 --> 25:08:51,192
nós vamos copiá-lo e ir em nosso

37938
25:08:51,192 --> 25:08:52,800
classe de engenheiro civil que vamos ver

37939
25:08:52,800 --> 25:08:54,080
que não temos um cliente

37940
25:08:54,080 --> 25:08:56,640
construtor, vamos colocar isso e

37941
25:08:56,640 --> 25:08:58,832
Vamos nomear este civil

37942
25:08:58,832 --> 25:09:01,680
Engenheiro e nós vamos adicionar um

37943
25:09:01,680 --> 25:09:03,832
Membro da especialidade

37944
25:09:03,832 --> 25:09:05,600
que queremos inicializar para que sejamos

37945
25:09:05,600 --> 25:09:06,800
Vou dizer

37946
25:09:06,800 --> 25:09:08,800
std string view porque nós queremos

37947
25:09:08,800 --> 25:09:10,640
dados de strings forward que vamos dizer

37948
25:09:10,640 --> 25:09:13,600
std string view aqui e nós vamos

37949
25:09:13,600 --> 25:09:16,960
Diga especialidade e vamos colocar

37950
25:09:16,960 --> 25:09:18,800
A implementação desta

37951
25:09:18,800 --> 25:09:22,480
em nosso arquivo cpp para um engenheiro civil

37952
25:09:22,480 --> 25:09:24,552
nós vamos colocar isso abaixo do nosso

37953
25:09:24,552 --> 25:09:26,232
construtor padrão

37954
25:09:26,232 --> 25:09:29,192
Vamos pegar isso eu perdi a mesa de alguma forma

37955
25:09:29,192 --> 25:09:31,512
Por isso, vamos copiar

37956
25:09:31,512 --> 25:09:34,000
E nós vamos colar aqui em baixo

37957
25:09:34,000 --> 25:09:35,760
nós vamos dizer que este construtor

37958
25:09:35,760 --> 25:09:38,480
pertence à classe do engenheiro civil i'm

37959
25:09:38,480 --> 25:09:40,832
usar nossa resolução de escopo

37960
25:09:40,832 --> 25:09:42,872
Operador e depois disso vamos

37961
25:09:42,872 --> 25:09:46,000
colocar nossa lista de inicializadores em civil

37962
25:09:46,000 --> 25:09:48,640
Engenheiro, vamos chamar o nosso engenheiro

37963
25:09:48,640 --> 25:09:50,552
construtor

37964
25:09:50,552 --> 25:09:53,512
e vai levar quatro agradecimentos

37965
25:09:53,512 --> 25:09:56,000
Nós vamos passar no nome completo

37966
25:09:56,000 --> 25:09:57,512
Vamos passar na idade em que estamos

37967
25:09:57,512 --> 25:09:59,600
indo passar no endereço e nós estamos

37968
25:09:59,600 --> 25:10:01,832
passar na conta do contrato

37969
25:10:01,832 --> 25:10:05,040
que obteremos do nosso construtor

37970
25:10:05,040 --> 25:10:07,832
do engenheiro civil, mas também

37971
25:10:07,832 --> 25:10:11,040
inicialize nosso membro da especialidade

37972
25:10:11,040 --> 25:10:12,640
variáveis, então vamos dizer m

37973
25:10:12,640 --> 25:10:15,280
especialidade e vamos passar o

37974
25:10:15,280 --> 25:10:18,080
Informações sobre a espacialidade aqui

37975
25:10:18,080 --> 25:10:20,160
E isso vai inicializar o nosso então

37976
25:10:20,160 --> 25:10:22,480
Nós vamos colocar em um corpo vazio e

37977
25:10:22,480 --> 25:10:24,720
Nossas informações serão adequadas

37978
25:10:24,720 --> 25:10:28,960
encaminhado para nossas classes base, então se nós

37979
25:10:28,960 --> 25:10:31,120
construir o objeto de engenharia civil adequado

37980
25:10:31,120 --> 25:10:32,960
A informação será encaminhada para

37981
25:10:32,960 --> 25:10:35,120
A parte do engenheiro de nós

37982
25:10:35,120 --> 25:10:37,040
e as informações adequadas vão

37983
25:10:37,040 --> 25:10:40,640
ser encaminhado para a parte da pessoa de nós

37984
25:10:40,640 --> 25:10:43,280
Agora que temos isso no lugar, podemos

37985
25:10:43,280 --> 25:10:47,360
colocar em nosso htdc out declarações para nos deixar

37986
25:10:47,360 --> 25:10:48,400
- Conhecer

37987
25:10:48,400 --> 25:10:51,040
qual construtor foi realmente chamado para

37988
25:10:51,040 --> 25:10:53,440
construir authen nós vamos dizer que

37989
25:10:53,440 --> 25:10:56,320
Foi o nosso construtor personalizado que foi

37990
25:10:56,320 --> 25:10:57,920
chamados, digamos que aqui estamos indo

37991
25:10:57,920 --> 25:10:59,040
para dizer

37992
25:10:59,040 --> 25:11:01,280
Construtor de clientes pediu civil

37993
25:11:01,280 --> 25:11:04,552
Engenheiro, vamos para o nosso

37994
25:11:04,552 --> 25:11:07,512
classe de engenharia e também dizer o mesmo

37995
25:11:07,512 --> 25:11:11,040
A coisa vamos para este arquivo cpp para isso

37996
25:11:11,040 --> 25:11:13,512
e nós vamos colocar em nosso htdc para fora

37997
25:11:13,512 --> 25:11:15,360
Declaração e nós vamos dizer costume

37998
25:11:15,360 --> 25:11:18,320
construtor, podemos copiar isso para ser

37999
25:11:18,320 --> 25:11:21,600
consistente com o que tínhamos em nosso

38000
25:11:21,600 --> 25:11:24,000
construtor padrão do construtor i deve

38001
25:11:24,000 --> 25:11:25,832
Diga e vamos dizer costume

38002
25:11:25,832 --> 25:11:28,552
O construtor pediu o nosso engenheiro

38003
25:11:28,552 --> 25:11:30,872
classe, vamos voltar para pessoa

38004
25:11:30,872 --> 25:11:32,320
E nós vamos para o

38005
25:11:32,320 --> 25:11:34,640
Arquivo de implementação e vamos

38006
25:11:34,640 --> 25:11:36,720
copiar a mensagem do nosso padrão

38007
25:11:36,720 --> 25:11:38,720
construtor e nós vamos colocar isso

38008
25:11:38,720 --> 25:11:41,680
e dizer que

38009
25:11:41,680 --> 25:11:44,400
foi chamado para a pessoa aqui agora que

38010
25:11:44,400 --> 25:11:46,872
nós temos esses caras em que podemos ir para o nosso

38011
25:11:46,872 --> 25:11:49,680
arquivo cpp principal e incluir as classes

38012
25:11:49,680 --> 25:11:52,720
Eles estão incluídos aqui nós podemos tentar

38013
25:11:52,720 --> 25:11:55,120
criar um objeto de pessoa como vimos

38014
25:11:55,120 --> 25:11:57,440
nos slides e vamos tentar

38015
25:11:57,440 --> 25:11:59,280
Construa este programa e veja quais

38016
25:11:59,280 --> 25:12:01,512
O construtor é chamado para configurar este

38017
25:12:01,512 --> 25:12:03,040
objeto de pessoa

38018
25:12:03,040 --> 25:12:05,680
Isso não deveria ser ciência de foguetes até agora

38019
25:12:05,680 --> 25:12:08,720
nós sabemos que o nosso construtor personalizado é

38020
25:12:08,720 --> 25:12:10,552
Será chamado porque nós somos

38021
25:12:10,552 --> 25:12:13,192
passando três parâmetros que devem ser

38022
25:12:13,192 --> 25:12:15,440
encaminhados para nossas variáveis de membro

38023
25:12:15,440 --> 25:12:18,640
através deste inicializador por último, então vamos

38024
25:12:18,640 --> 25:12:21,512
construir com gcc e certifique-se de que este é

38025
25:12:21,512 --> 25:12:23,680
O que esperamos que vamos usar o nosso

38026
25:12:23,680 --> 25:12:25,280
Compilador aqui

38027
25:12:25,280 --> 25:12:27,440
o parafuso vai ser bom como você vê

38028
25:12:27,440 --> 25:12:30,552
aqui e se trouxermos nossa powershell

38029
25:12:30,552 --> 25:12:32,720
Janela e correr galo para que vamos

38030
25:12:32,720 --> 25:12:34,800
Veja que nosso construtor personalizado é

38031
25:12:34,800 --> 25:12:37,600
chamado vamos trazer o arquivo cpp principal

38032
25:12:37,600 --> 25:12:40,080
para que possamos ver nossa coisa que somos

38033
25:12:40,080 --> 25:12:42,160
passando esta informação aqui e nós estamos

38034
25:12:42,160 --> 25:12:44,400
Imprimir nosso objeto de pessoa e nós estamos

38035
25:12:44,400 --> 25:12:46,320
Vou ver que o nome completo é jon

38036
25:12:46,320 --> 25:12:49,760
neve a idade é de 27 anos e o endereço é

38037
25:12:49,760 --> 25:12:52,232
Winterfell chamou e toda essa bobura

38038
25:12:52,232 --> 25:12:54,640
Temos aqui o nosso construtor é realmente

38039
25:12:54,640 --> 25:12:57,040
sendo chamado de ok, então isso está funcionando

38040
25:12:57,040 --> 25:12:59,512
também pode configurar um objeto de engenharia e

38041
25:12:59,512 --> 25:13:01,440
Veja que a informação está sendo

38042
25:13:01,440 --> 25:13:04,720
Prova adequadamente para a parte da pessoa

38043
25:13:04,720 --> 25:13:08,000
do nosso objeto de engenharia porque engenheiro

38044
25:13:08,000 --> 25:13:10,552
está herdando de uma pessoa

38045
25:13:10,552 --> 25:13:12,480
Estamos passando a informação para o

38046
25:13:12,480 --> 25:13:15,040
nome completo para a idade do endereço, mas nós somos

38047
25:13:15,040 --> 25:13:18,232
passando também na contagem de contratos que

38048
25:13:18,232 --> 25:13:20,640
Deve ser usado para inicializar o

38049
25:13:20,640 --> 25:13:23,832
projetar parte de nós, então vamos

38050
25:13:23,832 --> 25:13:26,720
executar a tarefa para construir com gcc

38051
25:13:26,720 --> 25:13:28,232
A construção vai passar

38052
25:13:28,232 --> 25:13:31,040
com sucesso e podemos trazer a nossa

38053
25:13:31,040 --> 25:13:33,192
janela powershell e executar o programa

38054
25:13:33,192 --> 25:13:34,080
Mais uma vez

38055
25:13:34,080 --> 25:13:36,000
nós vamos ver que nós vamos

38056
25:13:36,000 --> 25:13:38,320
ramificar a informação para pessoa personalizada

38057
25:13:38,320 --> 25:13:41,040
construtor para pessoa chamado, mas o que

38058
25:13:41,040 --> 25:13:43,600
Estamos realmente interessados aqui

38059
25:13:43,600 --> 25:13:46,400
É ver que o construtor personalizado

38060
25:13:46,400 --> 25:13:48,232
pois a pessoa é chamada

38061
25:13:48,232 --> 25:13:51,280
para construir nosso objeto de engenharia e

38062
25:13:51,280 --> 25:13:54,800
então nós chamamos o engenheiro construtor

38063
25:13:54,800 --> 25:13:57,120
e novamente isso está de acordo com o que

38064
25:13:57,120 --> 25:13:59,512
Vimos na última palestra o mais

38065
25:13:59,512 --> 25:14:01,680
O construtor baseado é chamado primeiro e

38066
25:14:01,680 --> 25:14:05,192
Então o construtor deve especializado é

38067
25:14:05,192 --> 25:14:07,192
chamado por último neste caso, nós somos apenas

38068
25:14:07,192 --> 25:14:10,232
estabelecendo agradecimentos de tal forma que

38069
25:14:10,232 --> 25:14:13,600
construtores personalizados são chamados e nós fazemos

38070
25:14:13,600 --> 25:14:17,680
que da nossa classe de engenheiros chamando

38071
25:14:17,680 --> 25:14:21,440
O construtor de base explicitamente

38072
25:14:21,440 --> 25:14:23,832
usando a sintaxe que temos aqui em

38073
25:14:23,832 --> 25:14:26,400
nossa lista inicializadora depois de termos a

38074
25:14:26,400 --> 25:14:28,640
Um construtor de base chamado vamos

38075
25:14:28,640 --> 25:14:31,512
inicializar nossas próprias variáveis de membros e

38076
25:14:31,512 --> 25:14:33,192
Isso é o que vemos

38077
25:14:33,192 --> 25:14:35,600
e desta forma a informação para o

38078
25:14:35,600 --> 25:14:37,760
A classe atual será inicializada

38079
25:14:37,760 --> 25:14:40,232
corretamente e isso é o que vemos aqui eu

38080
25:14:40,232 --> 25:14:42,400
Acho que isso é um pouco enganador

38081
25:14:42,400 --> 25:14:44,480
Porque ainda temos a informação

38082
25:14:44,480 --> 25:14:45,440
A partir de

38083
25:14:45,440 --> 25:14:47,912
Os objetos que compramos

38084
25:14:47,912 --> 25:14:50,872
impresso aqui podemos comentar isso

38085
25:14:50,872 --> 25:14:52,872
E construir novamente nós vamos passar isso

38086
25:14:52,872 --> 25:14:55,280
através do gcc para construir o nosso programa

38087
25:14:55,280 --> 25:14:57,440
A construção vai ser boa nós podemos

38088
25:14:57,440 --> 25:14:59,912
claro e correr o galo e nós vamos

38089
25:14:59,912 --> 25:15:01,512
Veja que o construtor personalizado é

38090
25:15:01,512 --> 25:15:04,320
Convocou uma pessoa para criar a pessoa

38091
25:15:04,320 --> 25:15:07,040
parte de nós e depois outra camada de

38092
25:15:07,040 --> 25:15:09,192
O engenheiro será criado em nosso

38093
25:15:09,192 --> 25:15:12,800
objeto de inicialização da contagem de contratos

38094
25:15:12,800 --> 25:15:15,192
membro variável parte de nós e nós somos

38095
25:15:15,192 --> 25:15:16,872
ter a informação aqui, então se

38096
25:15:16,872 --> 25:15:18,320
Nós imprimimos o nome completo para o que vamos

38097
25:15:18,320 --> 25:15:20,232
obter daniel cinza a idade vai ser

38098
25:15:20,232 --> 25:15:22,552
41. o endereço vai ser o

38099
25:15:22,552 --> 25:15:24,800
gibberish que esperamos aqui e

38100
25:15:24,800 --> 25:15:26,720
A contagem de contratos será repassada

38101
25:15:26,720 --> 25:15:29,280
com sucesso e isso é muito legal nós

38102
25:15:29,280 --> 25:15:33,120
também pode comentar isso e configurar um

38103
25:15:33,120 --> 25:15:36,160
objeto de engenharia civil, podemos fazer isso

38104
25:15:36,160 --> 25:15:38,800
Tudo bem, então vamos descer e colocar isso dentro

38105
25:15:38,800 --> 25:15:40,552
lugar que vamos criar um civil

38106
25:15:40,552 --> 25:15:43,192
objeto de engenharia, podemos fechar

38107
25:15:43,192 --> 25:15:45,832
A barra lateral esquerda aqui para ter um pouco mais

38108
25:15:45,832 --> 25:15:47,680
sala de respiração, vamos construir um

38109
25:15:47,680 --> 25:15:49,512
objeto de engenharia civil, vamos

38110
25:15:49,512 --> 25:15:52,080
passar em contrato de endereço de idade de nome completo

38111
25:15:52,080 --> 25:15:55,360
contagem e uma especialidade que penso que

38112
25:15:55,360 --> 25:15:59,040
esperar de nosso engenheiro civil personalizado

38113
25:15:59,040 --> 25:16:00,400
O construtor aqui

38114
25:16:00,400 --> 25:16:02,552
que vai ser uma força std

38115
25:16:02,552 --> 25:16:04,480
Isso é o que estamos passando aqui eu

38116
25:16:04,480 --> 25:16:06,552
Devo dizer que vai ser

38117
25:16:06,552 --> 25:16:09,760
uma visão de string, mas podemos passar na string

38118
25:16:09,760 --> 25:16:12,320
dados como este e a exibição de string

38119
25:16:12,320 --> 25:16:13,680
Vai levar

38120
25:16:13,680 --> 25:16:15,360
Então o que vamos ver aqui estamos

38121
25:16:15,360 --> 25:16:17,192
Vou ver o construtor da pessoa

38122
25:16:17,192 --> 25:16:19,600
chamado de construtor personalizado da pessoa i

38123
25:16:19,600 --> 25:16:21,912
Devo dizer que vamos ver o

38124
25:16:21,912 --> 25:16:24,800
Engenheiro construtor personalizado chamado e

38125
25:16:24,800 --> 25:16:26,960
Depois disso, vamos ver

38126
25:16:26,960 --> 25:16:29,440
o construtor personalizado do engenheiro civil

38127
25:16:29,440 --> 25:16:31,760
Chamados a passar e avançar tudo isso

38128
25:16:31,760 --> 25:16:32,872
Informações sobre a informação

38129
25:16:32,872 --> 25:16:36,480
em partes relacionadas do nosso engenheiro civil

38130
25:16:36,480 --> 25:16:39,040
Objeto, vamos construir e ver que este é

38131
25:16:39,040 --> 25:16:41,832
Na verdade, indo até mesmo para compilar

38132
25:16:41,832 --> 25:16:43,360
O livro vai ser bom nós podemos

38133
25:16:43,360 --> 25:16:44,800
claro

38134
25:16:44,800 --> 25:16:46,552
e correr o galo e nós vamos ver

38135
25:16:46,552 --> 25:16:49,040
Que isso é exatamente o que esperamos

38136
25:16:49,040 --> 25:16:50,872
Construtor personalizado para pessoa está indo

38137
25:16:50,872 --> 25:16:53,120
para ser chamado depois disso

38138
25:16:53,120 --> 25:16:54,960
o construtor personalizado para o engenheiro é

38139
25:16:54,960 --> 25:16:57,512
vai ser chamado e, em seguida, o costume

38140
25:16:57,512 --> 25:17:00,000
construtor de um engenheiro civil é

38141
25:17:00,000 --> 25:17:01,512
Vou ser chamado

38142
25:17:01,512 --> 25:17:03,680
E isso realmente está de acordo com o que

38143
25:17:03,680 --> 25:17:06,080
Esperamos se estamos construindo um civil

38144
25:17:06,080 --> 25:17:08,872
Objeto de engenharia e o engenheiro civil

38145
25:17:08,872 --> 25:17:11,912
A classe está herdando ambos de

38146
25:17:11,912 --> 25:17:15,280
engenheiro e de pessoa para quem vamos

38147
25:17:15,280 --> 25:17:19,120
ter a pessoa parte de nós no mundo primeiro

38148
25:17:19,120 --> 25:17:20,872
e por causa disso vamos ver

38149
25:17:20,872 --> 25:17:23,120
a pessoa construtor chamada, mas em

38150
25:17:23,120 --> 25:17:25,760
esta palestra que o Foco do Rio está recebendo

38151
25:17:25,760 --> 25:17:28,160
nosso construtor personalizado chamado assim

38152
25:17:28,160 --> 25:17:30,160
pessoa construtor personalizado vai ser

38153
25:17:30,160 --> 25:17:32,400
Liguei depois disso vamos chamar

38154
25:17:32,400 --> 25:17:34,720
O construtor personalizado para o engenheiro

38155
25:17:34,720 --> 25:17:37,120
parte de nós e isso vai configurar

38156
25:17:37,120 --> 25:17:40,232
as variáveis membros específicas do engenheiro

38157
25:17:40,232 --> 25:17:42,960
em nosso objeto depois disso, vamos

38158
25:17:42,960 --> 25:17:45,512
criar outra camada de engenheiro civil

38159
25:17:45,512 --> 25:17:48,232
em nosso objeto e isso vai

38160
25:17:48,232 --> 25:17:50,160
inicialize a variável membro que

38161
25:17:50,160 --> 25:17:52,480
Pertence ao engenheiro civil

38162
25:17:52,480 --> 25:17:55,512
parte de nós em nosso objeto, então isso é

38163
25:17:55,512 --> 25:17:58,400
O principal objetivo desta palestra

38164
25:17:58,400 --> 25:18:00,640
mostrando você que você pode configurar fãs em

38165
25:18:00,640 --> 25:18:03,440
de tal forma que seus construtores personalizados

38166
25:18:03,440 --> 25:18:06,400
são chamados ao configurar seu objeto

38167
25:18:06,400 --> 25:18:07,680
em camadas

38168
25:18:07,680 --> 25:18:10,160
Como você vê aqui bem agora que temos

38169
25:18:10,160 --> 25:18:12,640
Este trabalho eu quero que você veja que

38170
25:18:12,640 --> 25:18:14,552
Existem algumas maneiras ruins de fazer isso

38171
25:18:14,552 --> 25:18:16,552
As coisas e algumas pessoas são realmente

38172
25:18:16,552 --> 25:18:19,600
Vou tentar colocar as coisas nisso

38173
25:18:19,600 --> 25:18:22,552
O primeiro caminho ruim é tentar e

38174
25:18:22,552 --> 25:18:24,800
inicialize nossas variáveis de membro no

38175
25:18:24,800 --> 25:18:27,600
corpo da classe se você fizer coisas como

38176
25:18:27,600 --> 25:18:30,552
Isso novamente vai funcionar porque

38177
25:18:30,552 --> 25:18:32,800
O nome completo e a idade vão ser

38178
25:18:32,800 --> 25:18:35,512
Herdado publicamente da classe da pessoa

38179
25:18:35,512 --> 25:18:38,080
O código aqui vai funcionar, mas nós

38180
25:18:38,080 --> 25:18:40,320
Não tem como inicializar o endereço

38181
25:18:40,320 --> 25:18:42,872
variável de membro porque é privado para

38182
25:18:42,872 --> 25:18:45,440
a classe da pessoa, por isso, se tentarmos acessar

38183
25:18:45,440 --> 25:18:47,440
que vamos ter um erro de compilador

38184
25:18:47,440 --> 25:18:49,832
Vamos tentar isso no código e ver o

38185
25:18:49,832 --> 25:18:52,480
Erro de compilador real para tentar isso i

38186
25:18:52,480 --> 25:18:54,960
Vou comentar o bom código

38187
25:18:54,960 --> 25:18:57,760
aqui e eu vou copiar e colocar em

38188
25:18:57,760 --> 25:18:59,360
Algo que vai ser

38189
25:18:59,360 --> 25:19:02,232
problemático como vimos nos slides eu sou

38190
25:19:02,232 --> 25:19:04,480
indo colar no meu construtor aqui eu

38191
25:19:04,480 --> 25:19:07,192
deveria fechar minha janela powershell aqui

38192
25:19:07,192 --> 25:19:09,120
E eu vou tirar o meu

38193
25:19:09,120 --> 25:19:11,360
brilho inicializador porque não estamos indo

38194
25:19:11,360 --> 25:19:13,440
para usar isso aqui

38195
25:19:13,440 --> 25:19:15,600
e nós vamos apenas pegar os dados

38196
25:19:15,600 --> 25:19:19,512
e use isso para inicializar nossos dados em

38197
25:19:19,512 --> 25:19:21,192
nossa variável de membro aqui, então vamos

38198
25:19:21,192 --> 25:19:23,512
para pegar o nome completo e dizer m cheio

38199
25:19:23,512 --> 25:19:26,640
nome é igual ao nome completo que podemos fazer isso

38200
25:19:26,640 --> 25:19:29,680
nós vamos dizer mh igual a h que é

38201
25:19:29,680 --> 25:19:31,360
A informação que obtemos nós vamos

38202
25:19:31,360 --> 25:19:34,160
Diga m endereço e você vê que não

38203
25:19:34,160 --> 25:19:37,120
Mesmo ter isso em autocompleta, então nós somos

38204
25:19:37,120 --> 25:19:38,720
Vou passar o endereço para o qual vamos

38205
25:19:38,720 --> 25:19:41,512
ser teimoso e ignore esses squiggly

38206
25:19:41,512 --> 25:19:43,600
linhas e nós vamos dizer m

38207
25:19:43,600 --> 25:19:45,760
especialidade e nós vamos pegar o

38208
25:19:45,760 --> 25:19:49,192
especialidade e passar isso, mas você vê

38209
25:19:49,192 --> 25:19:51,912
essa linha 26 tem um monte de...

38210
25:19:51,912 --> 25:19:52,872
Linhas de linha

38211
25:19:52,872 --> 25:19:55,440
e a razão é o membro do endereço m

38212
25:19:55,440 --> 25:19:57,832
A variável é invisível e não

38213
25:19:57,832 --> 25:20:00,872
Manipulável de uma classe de engenheiro civil

38214
25:20:00,872 --> 25:20:03,120
Mais uma vez, a razão é que o endereço

38215
25:20:03,120 --> 25:20:05,680
A variável membro é privada para a pessoa

38216
25:20:05,680 --> 25:20:08,800
classe para que a classe de engenharia civil não

38217
25:20:08,800 --> 25:20:12,640
Negócios inicializando isso no corpo

38218
25:20:12,640 --> 25:20:15,512
Isso não vai funcionar, então se tentarmos

38219
25:20:15,512 --> 25:20:18,232
E construir isso, vamos passar por isso

38220
25:20:18,232 --> 25:20:20,800
através do gcc nós vamos ver que o

38221
25:20:20,800 --> 25:20:22,960
O mundo vai terminar com erros e

38222
25:20:22,960 --> 25:20:25,680
Se subirmos, provavelmente veremos

38223
25:20:25,680 --> 25:20:28,640
o endereço da pessoa do erro m é privado

38224
25:20:28,640 --> 25:20:31,040
dentro deste contexto e não temos

38225
25:20:31,040 --> 25:20:33,600
Negócios acessando isso no civil

38226
25:20:33,600 --> 25:20:37,360
engenheiro cpp arquivo na linha 26 este é

38227
25:20:37,360 --> 25:20:39,512
O que vemos aqui e este é o

38228
25:20:39,512 --> 25:20:41,512
linha ofensiva que não deveríamos realmente ser

38229
25:20:41,512 --> 25:20:44,080
fazendo isso se comentarmos esta linha

38230
25:20:44,080 --> 25:20:46,000
Isso vai funcionar, mas nosso membro

38231
25:20:46,000 --> 25:20:48,000
A variável vai ser deixada

38232
25:20:48,000 --> 25:20:51,120
com um valor de lixo e isso realmente não é

38233
25:20:51,120 --> 25:20:54,000
Bom porque nosso endereço que trabalhamos

38234
25:20:54,000 --> 25:20:55,192
tão difícil

38235
25:20:55,192 --> 25:20:57,680
para configurar em nosso parâmetro aqui é apenas

38236
25:20:57,680 --> 25:21:00,320
Vou ser ignorado, então isso é ruim você

38237
25:21:00,320 --> 25:21:02,160
Não deveria realmente inicializar o seu

38238
25:21:02,160 --> 25:21:04,400
variáveis como este, especialmente se

38239
25:21:04,400 --> 25:21:07,360
Você tem uma hierarquia de herança em

38240
25:21:07,360 --> 25:21:09,280
suas aulas, então vamos comentar

38241
25:21:09,280 --> 25:21:11,832
Isso e dizer que isso é realmente ruim

38242
25:21:11,832 --> 25:21:13,912
vai dar-lhe erros de compilador

38243
25:21:13,912 --> 25:21:15,832
E alguns de vocês vão dizer ok

38244
25:21:15,832 --> 25:21:18,232
Isso não está funcionando, mas se tentarmos

38245
25:21:18,232 --> 25:21:21,360
para usar uma lista de inicializadores diretamente

38246
25:21:21,360 --> 25:21:23,760
Vamos ver se isso realmente funciona

38247
25:21:23,760 --> 25:21:25,360
nós vamos para

38248
25:21:25,360 --> 25:21:27,912
Construa outro construtor aqui e nós

38249
25:21:27,912 --> 25:21:30,720
vamos configurar os dados em nosso

38250
25:21:30,720 --> 25:21:33,120
lista de inicializadores vamos dizer

38251
25:21:33,120 --> 25:21:34,832
Vamos dizer m cheio

38252
25:21:34,832 --> 25:21:37,760
nome e passe no nome completo que podemos fazer

38253
25:21:37,760 --> 25:21:39,912
que vamos tentar isso nós vamos

38254
25:21:39,912 --> 25:21:42,000
Diga mh

38255
25:21:42,000 --> 25:21:44,480
e vamos passar a idade que podemos fazer

38256
25:21:44,480 --> 25:21:48,080
Isso e nós vamos pegar o endereço

38257
25:21:48,080 --> 25:21:50,552
E vamos passar um endereço aqui

38258
25:21:50,552 --> 25:21:52,160
E depois disso vamos dizer m

38259
25:21:52,160 --> 25:21:54,232
espacialidade e vamos passar

38260
25:21:54,232 --> 25:21:56,640
a nossa informação de espacialidade

38261
25:21:56,640 --> 25:21:59,120
E se fizermos algo assim, mas

38262
25:21:59,120 --> 25:22:00,232
Você vai ver que nós temos

38263
25:22:00,232 --> 25:22:02,160
linhas piggly aqui e o problema com

38264
25:22:02,160 --> 25:22:05,120
Esta maneira de fazer as coisas é que o

38265
25:22:05,120 --> 25:22:08,640
Classe de engenharia civil não tem negócio

38266
25:22:08,640 --> 25:22:10,800
A inicialização de agradecimento

38267
25:22:10,800 --> 25:22:13,760
que pertencem à classe da pessoa no

38268
25:22:13,760 --> 25:22:17,192
initializer lista sua lista de inicializadores

38269
25:22:17,192 --> 25:22:19,440
só tem a capacidade de inicializar

38270
25:22:19,440 --> 25:22:21,760
As variáveis membros que pertencem ao

38271
25:22:21,760 --> 25:22:25,680
classe atual e m nome completo mh e m

38272
25:22:25,680 --> 25:22:28,080
O endereço não pertence à cifra

38273
25:22:28,080 --> 25:22:30,400
classe de engenharia é por isso que vamos

38274
25:22:30,400 --> 25:22:32,480
ter um erro de compilador se tentarmos definir

38275
25:22:32,480 --> 25:22:34,872
levantar as coisas desta forma, se estamos tentando

38276
25:22:34,872 --> 25:22:37,040
construir o programa que vamos ter um

38277
25:22:37,040 --> 25:22:39,680
estranho erro do compilador

38278
25:22:39,680 --> 25:22:41,040
Vamos ver que a construção é

38279
25:22:41,040 --> 25:22:43,440
vai terminar com erros e é

38280
25:22:43,440 --> 25:22:46,480
vai dizer inicializador esperado antes

38281
25:22:46,480 --> 25:22:49,360
m nome completo

38282
25:22:49,360 --> 25:22:51,760
e precisamos de uma coluna aqui, desculpe

38283
25:22:51,760 --> 25:22:54,232
para isso não é o erro que

38284
25:22:54,232 --> 25:22:56,400
Espere, mas você vê que no momento em que fazemos

38285
25:22:56,400 --> 25:22:58,720
Temos um bando de linhas squiggly

38286
25:22:58,720 --> 25:23:02,000
na idade e endereço do nome completo e vamos

38287
25:23:02,000 --> 25:23:04,320
construir e ver o problema que temos e

38288
25:23:04,320 --> 25:23:06,400
Vamos construir com erros enquanto nós

38289
25:23:06,400 --> 25:23:08,800
Veja aqui se subirmos

38290
25:23:08,800 --> 25:23:11,360
Vamos ver nossos erros civis

38291
25:23:11,360 --> 25:23:13,832
O engenheiro não tem nenhum campo chamado

38292
25:23:13,832 --> 25:23:16,160
m nome completo, vamos ver isso

38293
25:23:16,160 --> 25:23:18,320
Engenheiro civil não tem campo

38294
25:23:18,320 --> 25:23:20,800
chamado mh e engenheiro civil não

38295
25:23:20,800 --> 25:23:24,320
ter qualquer campo chamado m nome completo ou m

38296
25:23:24,320 --> 25:23:27,192
Endereço aqui que é o problema que temos

38297
25:23:27,192 --> 25:23:29,440
sem negócio inicializando esses membros

38298
25:23:29,440 --> 25:23:32,320
variáveis que não pertencem ao civil

38299
25:23:32,320 --> 25:23:34,552
classe de engenharia em primeiro lugar, então

38300
25:23:34,552 --> 25:23:37,120
Isso também não vai funcionar o melhor

38301
25:23:37,120 --> 25:23:39,192
A aposta que já temos é chamar o melhor

38302
25:23:39,192 --> 25:23:42,232
construtor e deixe que isso inicialize o

38303
25:23:42,232 --> 25:23:44,720
variáveis de membro que pertencem ao nosso

38304
25:23:44,720 --> 25:23:46,480
classe upstream

38305
25:23:46,480 --> 25:23:49,832
na hierarquia da herança, por exemplo

38306
25:23:49,832 --> 25:23:52,160
em nosso engenheiro civil construtor aqui

38307
25:23:52,160 --> 25:23:54,480
Precisamos chamar o engenheiro

38308
25:23:54,480 --> 25:23:57,760
construtor para inicializar o engenheiro

38309
25:23:57,760 --> 25:23:59,440
parte de nós e nós vamos ser

38310
25:23:59,440 --> 25:24:01,440
encaminhar a informação do nome completo

38311
25:24:01,440 --> 25:24:03,360
a idade do endereço e do contrato

38312
25:24:03,360 --> 25:24:06,232
conta a classe do engenheiro é por sua vez

38313
25:24:06,232 --> 25:24:08,552
vamos chamar seu construtor de base para

38314
25:24:08,552 --> 25:24:10,720
encaminçar as informações sobre a íntegra

38315
25:24:10,720 --> 25:24:13,120
nome do agente o endereço e é

38316
25:24:13,120 --> 25:24:14,872
vai inicializar seu próprio membro

38317
25:24:14,872 --> 25:24:17,192
variável m contagem de construção e

38318
25:24:17,192 --> 25:24:19,440
A informação será passada para dentro

38319
25:24:19,440 --> 25:24:21,600
corretamente e se tentarmos construir o nosso

38320
25:24:21,600 --> 25:24:23,120
classe agora vamos ver isso

38321
25:24:23,120 --> 25:24:25,512
Tudo vai funcionar e eu realmente

38322
25:24:25,512 --> 25:24:27,512
Queria que você estivesse ciente disso porque

38323
25:24:27,512 --> 25:24:29,360
O momento em que você entende isso você é

38324
25:24:29,360 --> 25:24:31,040
Vou estabelecer sua herança

38325
25:24:31,040 --> 25:24:33,120
hierarquias de uma forma que vai

38326
25:24:33,120 --> 25:24:34,720
fazer sentido e você não vai ser

38327
25:24:34,720 --> 25:24:37,760
obtendo todos esses erros estranhos do compilador

38328
25:24:37,760 --> 25:24:39,912
Isso é realmente tudo o que nos prossamos fazer em

38329
25:24:39,912 --> 25:24:41,832
Esta palestra mostrando como você pode definir

38330
25:24:41,832 --> 25:24:45,280
seus próprios construtores personalizados em seu

38331
25:24:45,280 --> 25:24:48,160
própria hierarquia de herança e no

38332
25:24:48,160 --> 25:24:49,912
momento em que você faz que você vai conseguir

38333
25:24:49,912 --> 25:24:52,960
suas aulas chamadas na ordem de que

38334
25:24:52,960 --> 25:24:54,960
Você espera que as coisas sejam criadas

38335
25:24:54,960 --> 25:24:57,120
em camadas os construtores de base são

38336
25:24:57,120 --> 25:24:59,040
vai ser chamado de uma forma que você

38337
25:24:59,040 --> 25:25:01,120
Esperar e seus objetos vão ser

38338
25:25:01,120 --> 25:25:03,512
construído de uma forma que você pode imprimi-los

38339
25:25:03,512 --> 25:25:06,080
Veja as informações que você espera

38340
25:25:06,080 --> 25:25:08,800
configurar em seu objeto se você quiser

38341
25:25:08,800 --> 25:25:10,872
também pode usar um depurador para ver o

38342
25:25:10,872 --> 25:25:13,360
informações em seu polegar para que vamos

38343
25:25:13,360 --> 25:25:15,440
para configurar um ponto de ruptura aqui e nós estamos

38344
25:25:15,440 --> 25:25:17,680
indo para trazer a nossa

38345
25:25:17,680 --> 25:25:19,512
Debugging tab que vamos acertar o

38346
25:25:19,512 --> 25:25:21,600
botão verde para começar a depurar isso

38347
25:25:21,600 --> 25:25:24,232
programa que o binário vai ser configurado

38348
25:25:24,232 --> 25:25:26,480
Uma vez que o voto é bom, o binário é

38349
25:25:26,480 --> 25:25:29,360
vai passar em nosso depurador e

38350
25:25:29,360 --> 25:25:31,600
Vamos atingir nosso ponto de ruptura em um

38351
25:25:31,600 --> 25:25:34,232
minuto vamos esperar por isso para que tenhamos

38352
25:25:34,232 --> 25:25:37,360
acertar o ponto de ruptura na linha 20 e se nós

38353
25:25:37,360 --> 25:25:40,400
expandir o nosso objeto de engenharia civil em nossa

38354
25:25:40,400 --> 25:25:42,800
Locais, vamos ver que temos

38355
25:25:42,800 --> 25:25:46,000
Uma parte de engenheiro de nós podemos expandir

38356
25:25:46,000 --> 25:25:48,552
e ver que também temos uma pessoa

38357
25:25:48,552 --> 25:25:49,832
Uma parte de nós

38358
25:25:49,832 --> 25:25:51,512
Se olharmos para a pessoa que vamos ver

38359
25:25:51,512 --> 25:25:54,720
que o nome completo é que podemos ver John

38360
25:25:54,720 --> 25:25:56,720
Travolta, que é o que estamos passando

38361
25:25:56,720 --> 25:26:00,640
Aqui também podemos olhar para a nossa idade a idade

38362
25:26:00,640 --> 25:26:03,040
é 51 como você vê aqui

38363
25:26:03,040 --> 25:26:05,600
e nós também teremos informações

38364
25:26:05,600 --> 25:26:07,600
sobre o nosso endereço

38365
25:26:07,600 --> 25:26:09,680
Se expandirmos isso, vamos ver

38366
25:26:09,680 --> 25:26:13,280
que o endereço é este pincel gibb que

38367
25:26:13,280 --> 25:26:16,400
Acabamos de colocar em um cachorro minúsculo

38368
25:26:16,400 --> 25:26:19,040
42 stret e

38369
25:26:19,040 --> 25:26:21,360
número 89 podemos ver esta informação

38370
25:26:21,360 --> 25:26:23,192
Aqui e você pode realmente expandir e ver

38371
25:26:23,192 --> 25:26:26,400
todas essas coisas que compõem o nosso objetivo

38372
25:26:26,400 --> 25:26:28,320
Por exemplo, podemos ver a informação

38373
25:26:28,320 --> 25:26:30,960
sobre a contagem de contratos que é 31 e

38374
25:26:30,960 --> 25:26:33,120
É o que estamos passando quando construímos

38375
25:26:33,120 --> 25:26:35,832
Este objeto aqui e a especialidade

38376
25:26:35,832 --> 25:26:40,000
Acontece que a força da estrada, como vemos em

38377
25:26:40,000 --> 25:26:42,000
nossos locais aqui você pode realmente ver tudo

38378
25:26:42,000 --> 25:26:44,640
Essas coisas nós vamos parar aqui

38379
25:26:44,640 --> 25:26:46,552
Nesta palestra no próximo somos

38380
25:26:46,552 --> 25:26:49,360
Vou explorar como copiar construtores

38381
25:26:49,360 --> 25:26:53,120
trabalhar em nossa hierarquia de herança assim ir

38382
25:26:53,120 --> 25:26:54,872
à frente e terminar aqui

38383
25:26:54,872 --> 25:26:56,400
e me encontrar lá

38384
25:26:56,400 --> 25:26:59,192
Nesta palestra queremos explorar como

38385
25:26:59,192 --> 25:27:01,440
Trabalho de construtores de cópias

38386
25:27:01,440 --> 25:27:04,960
com nossas hierarquias de herança e nós

38387
25:27:04,960 --> 25:27:07,040
Ainda usará o mesmo exemplo que nós

38388
25:27:07,040 --> 25:27:09,440
temos usado neste capítulo que vamos

38389
25:27:09,440 --> 25:27:12,160
temos essa hierarquia de herança e nós

38390
25:27:12,160 --> 25:27:14,640
Ainda usará o mesmo exemplo que nós

38391
25:27:14,640 --> 25:27:17,040
têm usado neste capítulo a base

38392
25:27:17,040 --> 25:27:18,720
A classe vai ser a pessoa que vamos

38393
25:27:18,720 --> 25:27:21,120
para herdar isso publicamente para

38394
25:27:21,120 --> 25:27:24,232
criar uma classe de engenheiro e nós seremos

38395
25:27:24,232 --> 25:27:26,320
Herdar da classe do engenheiro

38396
25:27:26,320 --> 25:27:28,800
criar publicamente o engenheiro civil

38397
25:27:28,800 --> 25:27:31,040
classe e com isso queremos ser capazes

38398
25:27:31,040 --> 25:27:34,000
para copiar objetos de construção e código

38399
25:27:34,000 --> 25:27:36,400
Queremos correr é algo como

38400
25:27:36,400 --> 25:27:38,872
Temos um objeto de engenharia que queremos

38401
25:27:38,872 --> 25:27:41,440
para ser capaz de criar um outro objeto a partir de

38402
25:27:41,440 --> 25:27:44,160
este objeto de engenharia usando a sintaxe

38403
25:27:44,160 --> 25:27:46,552
Aqui e pelo que já sabemos disso

38404
25:27:46,552 --> 25:27:48,872
vai chamar o nosso construtor de cópias

38405
25:27:48,872 --> 25:27:50,960
O engraçado é que isto vai funcionar

38406
25:27:50,960 --> 25:27:53,120
por padrão, mesmo se você não colocar em seu

38407
25:27:53,120 --> 25:27:55,360
Copiar construtor, a razão é a

38408
25:27:55,360 --> 25:27:57,360
O compilador vai inserir uma cópia

38409
25:27:57,360 --> 25:27:59,512
construtor para você e as coisas estão indo

38410
25:27:59,512 --> 25:28:01,832
ser copiado de uma forma que você espera

38411
25:28:01,832 --> 25:28:05,832
porque nenhuma de nossas aulas está usando

38412
25:28:05,832 --> 25:28:08,400
alocação de memória dinâmica para tudo

38413
25:28:08,400 --> 25:28:10,400
Só vai cair no lugar e é

38414
25:28:10,400 --> 25:28:12,400
indo para o trabalho, mas se você precisar

38415
25:28:12,400 --> 25:28:14,320
para configurar seu próprio construtor de cópias

38416
25:28:14,320 --> 25:28:15,912
nós vamos ver como você poderia fazer isso

38417
25:28:15,912 --> 25:28:17,680
Nesta palestra e vamos começar

38418
25:28:17,680 --> 25:28:19,280
pela classe base que vamos configurar

38419
25:28:19,280 --> 25:28:21,832
um construtor de cópias para a classe da pessoa

38420
25:28:21,832 --> 25:28:24,552
E isso não é nada complicado apenas

38421
25:28:24,552 --> 25:28:26,720
passar o nosso parâmetro por referência este é

38422
25:28:26,720 --> 25:28:28,872
Será o nosso objeto de origem e nós

38423
25:28:28,872 --> 25:28:31,280
copiará os dados da nossa fonte

38424
25:28:31,280 --> 25:28:33,680
Objeção para inicializar o membro

38425
25:28:33,680 --> 25:28:36,232
variáveis no objeto atual que nós

38426
25:28:36,232 --> 25:28:39,120
estão copiando aqui novamente esta é uma cópia

38427
25:28:39,120 --> 25:28:40,872
construtor que será cópia

38428
25:28:40,872 --> 25:28:43,120
construindo a partir do parâmetro que nós

38429
25:28:43,120 --> 25:28:46,160
passar por referência agora como fazemos o

38430
25:28:46,160 --> 25:28:49,600
construtor para a classe de engenharia que

38431
25:28:49,600 --> 25:28:52,080
Acontece que está herdando da pessoa tentar

38432
25:28:52,080 --> 25:28:54,160
Para pensar nessa maneira de fazer as coisas

38433
25:28:54,160 --> 25:28:56,552
É criar coisas como esta e esta

38434
25:28:56,552 --> 25:28:59,512
será apenas inicializar o engenheiro

38435
25:28:59,512 --> 25:29:03,440
camada da nossa classe, mas nada está indo

38436
25:29:03,440 --> 25:29:06,080
para inicializar a parte da pessoa de nós

38437
25:29:06,080 --> 25:29:07,760
E isso é ruim, isso vai chamar

38438
25:29:07,760 --> 25:29:10,320
o construtor padrão para inicializar

38439
25:29:10,320 --> 25:29:12,720
a pessoa parte de nós e nós vamos apenas

38440
25:29:12,720 --> 25:29:15,760
ser deixado com dados de lixo que são

38441
25:29:15,760 --> 25:29:17,680
inicializando o objeto da pessoa por

38442
25:29:17,680 --> 25:29:20,800
padrão e todos os dados que temos em nosso

38443
25:29:20,800 --> 25:29:23,280
Objeto de engenheiro de parâmetros está apenas indo

38444
25:29:23,280 --> 25:29:26,160
estar perdido para a pessoa parte de nós, então

38445
25:29:26,160 --> 25:29:28,480
Nós não queremos fazer isso isso é ruim

38446
25:29:28,480 --> 25:29:30,960
Design você não deve fazer isso alguns de vocês

38447
25:29:30,960 --> 25:29:33,280
Vamos dizer, mas e se chamarmos o

38448
25:29:33,280 --> 25:29:35,192
O melhor construtor que vimos que

38449
25:29:35,192 --> 25:29:38,320
poderia fazer isso direito, mas lembre-se que isso é

38450
25:29:38,320 --> 25:29:40,872
um construtor de cópia o que temos no

38451
25:29:40,872 --> 25:29:42,640
A esquerda é um objeto

38452
25:29:42,640 --> 25:29:45,440
E acontece que é que

38453
25:29:45,440 --> 25:29:47,680
se você configurar uma sintaxe como essa com

38454
25:29:47,680 --> 25:29:49,832
o construtor de cópia, o compilador é

38455
25:29:49,832 --> 25:29:52,160
Vou criar uma pessoa temporária

38456
25:29:52,160 --> 25:29:55,120
objeto e uma cópia desse objeto para

38457
25:29:55,120 --> 25:29:57,912
inicialize a parte da pessoa de nós para que isso

38458
25:29:57,912 --> 25:30:00,320
vai criar uma cópia temporária

38459
25:30:00,320 --> 25:30:02,960
objeto contendo os mesmos dados que temos

38460
25:30:02,960 --> 25:30:06,400
em nosso objeto de engenharia assim até certo ponto

38461
25:30:06,400 --> 25:30:08,800
Isso vai funcionar, mas o problema nós

38462
25:30:08,800 --> 25:30:11,680
ainda temos que estamos usando o m

38463
25:30:11,680 --> 25:30:14,400
variável de membro de endereço diretamente de um

38464
25:30:14,400 --> 25:30:16,872
Engenheiro de objeto e do que já temos

38465
25:30:16,872 --> 25:30:19,912
Saiba que esta variável de membro de endereço m é

38466
25:30:19,912 --> 25:30:22,320
privado para a classe da pessoa e nós temos

38467
25:30:22,320 --> 25:30:24,640
Não há negócios acessando isso

38468
25:30:24,640 --> 25:30:26,720
de uma construção de um engenheiro, então isso é

38469
25:30:26,720 --> 25:30:28,552
vamos nos dar um erro de compilador, mas

38470
25:30:28,552 --> 25:30:31,040
Você sabe que é possível criar um

38471
25:30:31,040 --> 25:30:34,080
getter na classe de engenharia que é

38472
25:30:34,080 --> 25:30:36,872
vai devolver esse endereço e você pode

38473
25:30:36,872 --> 25:30:38,960
chamar isso juntos aqui e obter isso

38474
25:30:38,960 --> 25:30:41,360
Uma coisa para inicializar seus dados é

38475
25:30:41,360 --> 25:30:43,512
indo para o trabalho, mas isso é realmente estranho

38476
25:30:43,512 --> 25:30:45,600
Você não deve fazer isso, este é um mau design

38477
25:30:45,600 --> 25:30:47,280
Há uma maneira melhor que eu vou mostrar

38478
25:30:47,280 --> 25:30:49,360
Você, mas antes de olharmos para essa onda

38479
25:30:49,360 --> 25:30:51,760
Vamos tentar resumir os problemas que nós

38480
25:30:51,760 --> 25:30:54,480
Tenho com essa maneira de fazer isso

38481
25:30:54,480 --> 25:30:56,160
Não vai reutilizar a cópia

38482
25:30:56,160 --> 25:30:59,120
construtor, nós trabalhamos duro para definir

38483
25:30:59,120 --> 25:31:01,832
em cima em pessoa, então isso vai ser

38484
25:31:01,832 --> 25:31:04,552
chamado de duplicação outra coisa é que

38485
25:31:04,552 --> 25:31:07,280
a variável membro do endereço m é privada

38486
25:31:07,280 --> 25:31:10,080
para pessoa, então se tentarmos usá-lo como

38487
25:31:10,080 --> 25:31:12,160
Isto vamos ter um erro de compilador

38488
25:31:12,160 --> 25:31:15,360
novamente é possível configurar um getter

38489
25:31:15,360 --> 25:31:17,680
que poderia devolver isso e poderíamos usar

38490
25:31:17,680 --> 25:31:20,160
que getter neste lugar, mas isso é

38491
25:31:20,160 --> 25:31:23,680
mau design que somos realmente forçados a definir

38492
25:31:23,680 --> 25:31:26,320
para cima um getter que é possivelmente usado

38493
25:31:26,320 --> 25:31:28,320
Neste lugar que é mau design, nós não

38494
25:31:28,320 --> 25:31:30,480
Quero fazer algo assim outro

38495
25:31:30,480 --> 25:31:32,232
A coisa é que isso vai criar um

38496
25:31:32,232 --> 25:31:35,192
cópia temporária da pessoa a partir da qual

38497
25:31:35,192 --> 25:31:38,480
estará copiando para inicializar a pessoa

38498
25:31:38,480 --> 25:31:40,800
Parte de nós não queremos fazer

38499
25:31:40,800 --> 25:31:43,832
essa cópia porque odiamos cópias em c

38500
25:31:43,832 --> 25:31:46,000
mais código para que a melhor maneira de fazer

38501
25:31:46,000 --> 25:31:48,320
Isto é para configurar o seu construtor de cópia

38502
25:31:48,320 --> 25:31:51,040
Desta forma, vamos dizer pessoa

38503
25:31:51,040 --> 25:31:54,480
e passando diretamente o nosso objeto de engenharia

38504
25:31:54,480 --> 25:31:56,800
O compilador é inteligente o suficiente para ver que

38505
25:31:56,800 --> 25:32:00,080
Estamos passando um objeto de engenharia para

38506
25:32:00,080 --> 25:32:03,040
inicialize um objeto de pessoa e o que

38507
25:32:03,040 --> 25:32:05,760
O compilador vai fazer é realmente inteligente

38508
25:32:05,760 --> 25:32:09,040
Suponha que nosso objeto de engenharia seja feito

38509
25:32:09,040 --> 25:32:11,360
de duas camadas a camada interna está indo

38510
25:32:11,360 --> 25:32:14,160
para conter as informações sobre

38511
25:32:14,160 --> 25:32:16,800
A pessoa parte de nós e do exterior

38512
25:32:16,800 --> 25:32:18,960
A camada vai conter o

38513
25:32:18,960 --> 25:32:21,760
projetar parte de nós ok, então este é o

38514
25:32:21,760 --> 25:32:23,512
configuração que temos para que o compilador esteja indo

38515
25:32:23,512 --> 25:32:25,040
para ver que estamos passando em um

38516
25:32:25,040 --> 25:32:27,512
objeto de engenharia para inicializar uma pessoa

38517
25:32:27,512 --> 25:32:29,680
O objeto e o que ele vai fazer é

38518
25:32:29,680 --> 25:32:31,912
Realmente inteligente, ele vai se despir

38519
25:32:31,912 --> 25:32:35,280
toda essa parte do engenheiro se eu puder descrever

38520
25:32:35,280 --> 25:32:37,120
Como isso, nós vamos nos despir

38521
25:32:37,120 --> 25:32:39,280
toda essa parte do engenheiro

38522
25:32:39,280 --> 25:32:42,552
que temos em nosso objeto de engenharia e

38523
25:32:42,552 --> 25:32:45,680
Vamos ficar com a pessoa

38524
25:32:45,680 --> 25:32:48,640
parte que passamos então para inicializar

38525
25:32:48,640 --> 25:32:50,480
nosso objeto de pessoa e isso é realmente

38526
25:32:50,480 --> 25:32:52,872
inteligente e vai funcionar assim novamente

38527
25:32:52,872 --> 25:32:55,192
A sintaxe é o que você vê aqui

38528
25:32:55,192 --> 25:32:57,360
Nós dizemos pessoa que passamos em nossa fonte

38529
25:32:57,360 --> 25:33:00,080
objeto e então podemos inicializar o

38530
25:33:00,080 --> 25:33:02,552
variável membro que pertence ao

38531
25:33:02,552 --> 25:33:04,232
Engenheiro de uma parte de nós, nós seremos

38532
25:33:04,232 --> 25:33:06,480
inicialização da contagem de contratos e isso é

38533
25:33:06,480 --> 25:33:08,000
indo trabalhar agora que você sabe disso

38534
25:33:08,000 --> 25:33:09,512
nós vamos ir para o visual

38535
25:33:09,512 --> 25:33:11,440
código de estúdio e jogar com a gente um pouco

38536
25:33:11,440 --> 25:33:14,000
Mais aqui estamos em nossa pasta de trabalho

38537
25:33:14,000 --> 25:33:16,552
O projeto atual é construtores de cópias

38538
25:33:16,552 --> 25:33:19,440
Com herança estaremos reutilizando a

38539
25:33:19,440 --> 25:33:22,080
código da última palestra, então nós somos

38540
25:33:22,080 --> 25:33:24,160
Vou pegar tudo com isso

38541
25:33:24,160 --> 25:33:26,720
Exceto pelo binário e nós vamos

38542
25:33:26,720 --> 25:33:30,080
Copie isso e coloque isso em nossa atual

38543
25:33:30,080 --> 25:33:32,552
Projeto vamos fazer isso e nós vamos

38544
25:33:32,552 --> 25:33:34,960
para abrir este bad boy no estúdio visual

38545
25:33:34,960 --> 25:33:37,512
código arrastando e soltando aqui e

38546
25:33:37,512 --> 25:33:40,160
teremos o nosso ponto de partida

38547
25:33:40,160 --> 25:33:42,720
ter nossa classe de pessoa, classe de engenheiro

38548
25:33:42,720 --> 25:33:46,080
e a classe civil de engenharia e nós vamos

38549
25:33:46,080 --> 25:33:49,192
Estar apenas fazendo herança pública para fazer

38550
25:33:49,192 --> 25:33:51,280
As coisas mais fáceis aqui, então o engenheiro está indo

38551
25:33:51,280 --> 25:33:54,080
Herdar publicamente de pessoa e

38552
25:33:54,080 --> 25:33:56,232
Engenheiro civil vai ao público

38553
25:33:56,232 --> 25:33:58,872
herdar do engenheiro e isso é

38554
25:33:58,872 --> 25:34:00,960
Tudo o que tivemos da última palestra

38555
25:34:00,960 --> 25:34:03,600
Nada de especial, mas o que queremos é

38556
25:34:03,600 --> 25:34:06,640
configurar construtores de cópia de tal forma

38557
25:34:06,640 --> 25:34:09,360
que seremos capazes de construir objetos

38558
25:34:09,360 --> 25:34:12,320
de outros, por exemplo, se sairmos

38559
25:34:12,320 --> 25:34:14,800
nosso objeto de engenharia eu acho que é isso que

38560
25:34:14,800 --> 25:34:16,872
nós usamos nos slides que nós vamos

38561
25:34:16,872 --> 25:34:19,832
ter nosso engenheiro 1 objeto

38562
25:34:19,832 --> 25:34:23,120
Queremos ser capazes de criar um outro

38563
25:34:23,120 --> 25:34:25,760
Engenheiro, digamos, engenheiro dois e

38564
25:34:25,760 --> 25:34:28,232
acima disso, do engenheiro, a coisa

38565
25:34:28,232 --> 25:34:31,120
Isso pode ser intrigante para alguns de vocês é

38566
25:34:31,120 --> 25:34:32,960
que isso vai funcionar fora do

38567
25:34:32,960 --> 25:34:35,360
caixa mesmo se nós realmente não colocássemos em um

38568
25:34:35,360 --> 25:34:37,832
Copiar construtor, mas a coisa é a

38569
25:34:37,832 --> 25:34:40,000
O compilador vai inserir uma cópia

38570
25:34:40,000 --> 25:34:42,720
construtor para você, mas esse construtor

38571
25:34:42,720 --> 25:34:45,440
Vai ser em termos de membro

38572
25:34:45,440 --> 25:34:47,600
copiar para que ele seja basicamente

38573
25:34:47,600 --> 25:34:50,232
copiar graças memberwise que vai

38574
25:34:50,232 --> 25:34:52,400
tirar a contagem de contratos do engenheiro

38575
25:34:52,400 --> 25:34:55,440
uma e copiar isso para o engenheiro dois e

38576
25:34:55,440 --> 25:34:57,192
Basicamente vamos ter o mesmo

38577
25:34:57,192 --> 25:34:58,552
Os dados de

38578
25:34:58,552 --> 25:35:01,440
Engenheiro um em engenheiro dois, vamos tentar

38579
25:35:01,440 --> 25:35:03,832
e o engenheiro de impressão dois podem fazer isso

38580
25:35:03,832 --> 25:35:06,400
vamos dizer e dois e nós vamos

38581
25:35:06,400 --> 25:35:09,512
Coloque isso para fora e nós vamos correr o

38582
25:35:09,512 --> 25:35:12,232
tarefa para construir com gcc que é o que nós

38583
25:35:12,232 --> 25:35:14,000
Quero aqui e você vai ver isso

38584
25:35:14,000 --> 25:35:16,552
vai funcionar fora da caixa se nós

38585
25:35:16,552 --> 25:35:19,040
trazer uma janela powershell e correr

38586
25:35:19,040 --> 25:35:21,440
Galo vamos ver que temos

38587
25:35:21,440 --> 25:35:23,912
Os dados aqui temos engenheiro completo

38588
25:35:23,912 --> 25:35:26,160
nome daniel cinza que são os dados que temos

38589
25:35:26,160 --> 25:35:28,480
no engenheiro um, mas note que nós somos

38590
25:35:28,480 --> 25:35:31,120
O engenheiro de impressão dois aqui a idade é

38591
25:35:31,120 --> 25:35:33,280
serão 41 e o endereço vai

38592
25:35:33,280 --> 25:35:35,832
ser exatamente o que tínhamos no engenheiro

38593
25:35:35,832 --> 25:35:37,832
Um e você vai ver que

38594
25:35:37,832 --> 25:35:39,680
Os construtores serão chamados para

38595
25:35:39,680 --> 25:35:42,640
configurar engenheiro 2 e personalizado

38596
25:35:42,640 --> 25:35:44,320
construtor para uma pessoa vai ser

38597
25:35:44,320 --> 25:35:46,160
chamado de construtor personalizado para

38598
25:35:46,160 --> 25:35:47,912
O engenheiro vai ser chamado e isso

38599
25:35:47,912 --> 25:35:49,192
É exatamente

38600
25:35:49,192 --> 25:35:52,000
O que esperamos aqui, mas e se quisermos

38601
25:35:52,000 --> 25:35:54,640
para criar nosso próprio construtor de cópias e

38602
25:35:54,640 --> 25:35:57,120
A necessidade de fazer isso pode surgir

38603
25:35:57,120 --> 25:35:59,760
Se acontecer de estarmos fazendo alguma dinâmica

38604
25:35:59,760 --> 25:36:02,800
A alocação de memória em nossas aulas supor

38605
25:36:02,800 --> 25:36:05,440
Talvez a classe pessoal tenha alguma dinâmica

38606
25:36:05,440 --> 25:36:07,680
alocação de memória tem algum ponteiro

38607
25:36:07,680 --> 25:36:09,832
variável de membro e no pessoal

38608
25:36:09,832 --> 25:36:12,400
Construtor personalizado, estamos fazendo alguns

38609
25:36:12,400 --> 25:36:14,720
alocação de memória dinâmica para inicializar

38610
25:36:14,720 --> 25:36:16,800
que podemos estar fazendo o mesmo

38611
25:36:16,800 --> 25:36:19,120
coisa no nível do engenheiro ou no civil

38612
25:36:19,120 --> 25:36:21,512
nível de engenheiro e isso irá forçá-lo

38613
25:36:21,512 --> 25:36:23,832
para configurar seu próprio construtor de cópias e

38614
25:36:23,832 --> 25:36:25,360
nós vamos ver como você poderia fazer isso

38615
25:36:25,360 --> 25:36:28,000
Nas suas aulas, vamos começar

38616
25:36:28,000 --> 25:36:29,832
com a classe da pessoa que vamos ir

38617
25:36:29,832 --> 25:36:32,872
em cima e configurar um construtor de cópia em

38618
25:36:32,872 --> 25:36:35,600
diante de nosso destruidor aqui estamos indo

38619
25:36:35,600 --> 25:36:37,192
para dizer pessoa e nós vamos dizer

38620
25:36:37,192 --> 25:36:40,080
fonte de referência da pessoa do const

38621
25:36:40,080 --> 25:36:42,160
Esta é a sintaxe que você usa para configurar

38622
25:36:42,160 --> 25:36:44,080
seu copy constructor que você já conhece

38623
25:36:44,080 --> 25:36:46,872
Isso de um capítulo anterior e nós somos

38624
25:36:46,872 --> 25:36:48,640
vai colocar na implementação para

38625
25:36:48,640 --> 25:36:51,760
Isso vamos entrar no arquivo cpp

38626
25:36:51,760 --> 25:36:54,872
antes do destruidor ou devemos ir

38627
25:36:54,872 --> 25:36:55,832
Depois de

38628
25:36:55,832 --> 25:36:58,320
nosso construtor personalizado não é realmente

38629
25:36:58,320 --> 25:37:00,400
importa onde você coloca isso e nós estamos

38630
25:37:00,400 --> 25:37:02,800
vamos colocar em nossa resolução de escopo

38631
25:37:02,800 --> 25:37:05,192
Operador vamos fazer pessoa aqui e nós

38632
25:37:05,192 --> 25:37:07,440
só estará copiando os dados do

38633
25:37:07,440 --> 25:37:09,912
pessoa de origem, então vamos colocar

38634
25:37:09,912 --> 25:37:12,160
nossa lista inicializadora e nós vamos

38635
25:37:12,160 --> 25:37:14,400
Diga m nome completo, vamos pegar o

38636
25:37:14,400 --> 25:37:16,160
nome da pessoa de origem que estamos indo

38637
25:37:16,160 --> 25:37:18,720
para dizer fonte m nome completo, vamos

38638
25:37:18,720 --> 25:37:21,440
inicialize a idade que vamos dizer mh

38639
25:37:21,440 --> 25:37:23,912
e nós vamos pegar a idade do

38640
25:37:23,912 --> 25:37:26,640
fonte pessoa tão mh aqui

38641
25:37:26,640 --> 25:37:28,872
e nós podemos ir para a próxima linha para que

38642
25:37:28,872 --> 25:37:31,512
nós vemos a coisa toda aqui e dizemos m

38643
25:37:31,512 --> 25:37:34,160
Endereço e vamos dizer fonte

38644
25:37:34,160 --> 25:37:36,800
e dizer m endereço que isso vai definir

38645
25:37:36,800 --> 25:37:39,440
para cima do nosso construtor e para baixo podemos

38646
25:37:39,440 --> 25:37:41,512
colocar em nosso corpo isso vai funcionar

38647
25:37:41,512 --> 25:37:43,600
Mas isso é tudo o que vimos

38648
25:37:43,600 --> 25:37:46,000
para longe isso não é novidade a sintaxe para

38649
25:37:46,000 --> 25:37:47,832
configurar o seu construtor de cópias você apenas

38650
25:37:47,832 --> 25:37:50,640
Passe por const referência se você não fizer isso

38651
25:37:50,640 --> 25:37:52,552
Passe por referência aqui você vai

38652
25:37:52,552 --> 25:37:55,680
obter uma cadeia interminável de construtor de cópias

38653
25:37:55,680 --> 25:37:56,640
chamadas

38654
25:37:56,640 --> 25:37:58,552
Se isso é confuso para você, por favor vá

38655
25:37:58,552 --> 25:38:00,640
de volta ao capítulo sobre as aulas que você é

38656
25:38:00,640 --> 25:38:03,440
Vou ver tudo sobre isso e

38657
25:38:03,440 --> 25:38:05,680
Isso é realmente tudo o que precisamos fazer aqui para

38658
25:38:05,680 --> 25:38:08,000
ter um copy constructor para uma pessoa agora

38659
25:38:08,000 --> 25:38:10,480
Vamos fazer as coisas no nível do engenheiro

38660
25:38:10,480 --> 25:38:13,192
Vamos para a nossa classe de engenheiros

38661
25:38:13,192 --> 25:38:15,192
e precisamos criar um construtor de cópias

38662
25:38:15,192 --> 25:38:16,960
A sintaxe vai ser a mesma que nós somos

38663
25:38:16,960 --> 25:38:19,440
Vamos dizer engenheiro e nós seremos

38664
25:38:19,440 --> 25:38:22,320
construção de um objeto de engenharia de custos

38665
25:38:22,320 --> 25:38:24,400
Passamos como um parâmetro aqui, então estamos

38666
25:38:24,400 --> 25:38:27,440
vamos dizer engenheiro de custos por referência

38667
25:38:27,440 --> 25:38:29,680
e dizer fonte e o problema está indo

38668
25:38:29,680 --> 25:38:32,480
para sermos como implementamos essa coisa que somos

38669
25:38:32,480 --> 25:38:34,720
Vou copiar isso e ir em nosso

38670
25:38:34,720 --> 25:38:37,832
engenheiro cpp arquivo vamos colocar o nosso

38671
25:38:37,832 --> 25:38:40,160
Copiar construtor após nosso cliente

38672
25:38:40,160 --> 25:38:42,160
construtor e nós vamos colocar em

38673
25:38:42,160 --> 25:38:44,000
nosso operador de resolução de escopo nós somos

38674
25:38:44,000 --> 25:38:46,000
vamos dizer engenheiro e nós vamos

38675
25:38:46,000 --> 25:38:48,480
colocar em nosso corpo vamos abaixo e colocar

38676
25:38:48,480 --> 25:38:50,720
que se fizermos coisas assim

38677
25:38:50,720 --> 25:38:53,440
só vai inicializar o nosso engenheiro

38678
25:38:53,440 --> 25:38:55,912
com dados inúteis não queremos isso, mas

38679
25:38:55,912 --> 25:38:58,480
Alguns de vocês podem dizer uh-huh eu não

38680
25:38:58,480 --> 25:39:01,680
saber como chamar meu construtor de base, mas

38681
25:39:01,680 --> 25:39:04,960
pelo menos posso inicializar meu contrato

38682
25:39:04,960 --> 25:39:07,360
conte bem, vamos voltar e ver se nós

38683
25:39:07,360 --> 25:39:09,600
ter esta variável de membro aqui sim é

38684
25:39:09,600 --> 25:39:12,080
chamada contagem de contratos, podemos dizer

38685
25:39:12,080 --> 25:39:14,552
contagem de contrato aqui e nós vamos

38686
25:39:14,552 --> 25:39:17,120
inicialize isso com contrato de fonte

38687
25:39:17,120 --> 25:39:19,280
conte isso vai funcionar, mas isso é

38688
25:39:19,280 --> 25:39:21,760
Vou chamar o construtor padrão de

38689
25:39:21,760 --> 25:39:24,400
pessoa para inicializar a parte da pessoa

38690
25:39:24,400 --> 25:39:27,600
Nós e vamos voltar em nosso cpp principal

38691
25:39:27,600 --> 25:39:30,160
e ver o que estamos usando para tentar

38692
25:39:30,160 --> 25:39:32,232
Coisas que estamos construindo um engenheiro

38693
25:39:32,232 --> 25:39:34,872
objeto de outro vamos tentar isso

38694
25:39:34,872 --> 25:39:37,512
e ver se o nosso construtor de cópias é

38695
25:39:37,512 --> 25:39:40,000
Chamou aqui, então vamos dizer costume

38696
25:39:40,000 --> 25:39:42,800
Copiar construtor chamado para engenheiro

38697
25:39:42,800 --> 25:39:44,720
Vamos colocar na mensagem e

38698
25:39:44,720 --> 25:39:46,552
nós vamos dizer cópia personalizada

38699
25:39:46,552 --> 25:39:49,120
construtor e nós vamos construir o nosso

38700
25:39:49,120 --> 25:39:51,760
Código, vamos construir, vamos passar

38701
25:39:51,760 --> 25:39:54,640
Isso através do gcc para ver o que acontece

38702
25:39:54,640 --> 25:39:57,040
A construção vai ser boa e vamos ver

38703
25:39:57,040 --> 25:39:58,872
O que acontece nós vamos limpar e

38704
25:39:58,872 --> 25:40:01,440
corre galo vamos ver que o

38705
25:40:01,440 --> 25:40:03,192
Os construtores serão chamados para

38706
25:40:03,192 --> 25:40:05,120
configurar a pessoa um

38707
25:40:05,120 --> 25:40:07,760
Mas vemos que o construtor de cópias para

38708
25:40:07,760 --> 25:40:10,000
O engenheiro é chamado de

38709
25:40:10,000 --> 25:40:11,912
e o que eu quero fazer para realmente fazer

38710
25:40:11,912 --> 25:40:14,080
Este super claro é colocado um separador

38711
25:40:14,080 --> 25:40:16,320
Entre esses dois caras para realmente saber

38712
25:40:16,320 --> 25:40:18,160
O que está acontecendo aqui eu vou colocar

38713
25:40:18,160 --> 25:40:20,400
em um monte de traços assim eu sou

38714
25:40:20,400 --> 25:40:22,552
Vou colocar no meu novo personagem de linha

38715
25:40:22,552 --> 25:40:24,400
e eu vou aparafusar novamente o parafuso é

38716
25:40:24,400 --> 25:40:26,320
Vou ser bom como você vê aqui nós podemos

38717
25:40:26,320 --> 25:40:29,512
clear e run galo agora estamos indo

38718
25:40:29,512 --> 25:40:31,680
para ver que o construtor padrão para

38719
25:40:31,680 --> 25:40:34,320
Uma pessoa foi chamada para criar a pessoa

38720
25:40:34,320 --> 25:40:37,512
parte de nós em nossa cópia de engenharia

38721
25:40:37,512 --> 25:40:40,640
O construtor e a razão é que não somos

38722
25:40:40,640 --> 25:40:43,600
fazer qualquer coisa para chamar a cópia personalizada

38723
25:40:43,600 --> 25:40:46,400
O construtor da pessoa

38724
25:40:46,400 --> 25:40:48,160
e vamos voltar pessoalmente e fazer

38725
25:40:48,160 --> 25:40:50,872
Certamente estamos imprimindo informações adequadas

38726
25:40:50,872 --> 25:40:52,400
para realmente ver isso

38727
25:40:52,400 --> 25:40:54,640
Quando fazemos isso direito, não

38728
25:40:54,640 --> 25:40:57,280
colocando em qualquer mensagem aqui, então devemos

38729
25:40:57,280 --> 25:40:59,680
Fazemos isso, vamos dizer costume

38730
25:40:59,680 --> 25:41:02,552
construtor ou construtor de cópia personalizado

38731
25:41:02,552 --> 25:41:05,280
chamado de pessoa, mas isso não é chamado

38732
25:41:05,280 --> 25:41:07,040
Você vê que estamos chamando o padrão

38733
25:41:07,040 --> 25:41:08,960
construtor e isso vai

38734
25:41:08,960 --> 25:41:12,080
inicializar nossa parte da pessoa com lixo

38735
25:41:12,080 --> 25:41:14,232
dados se imprimirmos o engenheiro dois aqui

38736
25:41:14,232 --> 25:41:15,600
Você vai ver que o nome completo

38737
25:41:15,600 --> 25:41:18,160
Não é nenhum a vantagem é zero e o endereço

38738
25:41:18,160 --> 25:41:21,040
Não é nenhum, então estamos basicamente recebendo o

38739
25:41:21,040 --> 25:41:24,000
dados padrão que temos em nossa pessoa

38740
25:41:24,000 --> 25:41:25,912
Objetiva, vamos voltar e realmente te mostrar

38741
25:41:25,912 --> 25:41:27,192
que o

38742
25:41:27,192 --> 25:41:29,440
Nome completo padrão não será nenhum

38743
25:41:29,440 --> 25:41:31,280
O endereço padrão não será nenhum

38744
25:41:31,280 --> 25:41:33,360
da borda vai ser 0 por padrão

38745
25:41:33,360 --> 25:41:36,400
E isso é o que temos porque em nosso

38746
25:41:36,400 --> 25:41:38,872
Copiar construtor que não estamos fazendo

38747
25:41:38,872 --> 25:41:42,160
qualquer coisa para obter o nosso construtor de clientes

38748
25:41:42,160 --> 25:41:44,720
em pessoa para ser chamado de bem, então isso é

38749
25:41:44,720 --> 25:41:46,720
Não vou trabalhar isso é ruim, nós não

38750
25:41:46,720 --> 25:41:49,360
Quero fazer algo assim, mas vamos

38751
25:41:49,360 --> 25:41:51,120
Comente e mostre-lhe outro

38752
25:41:51,120 --> 25:41:53,832
Como podemos tentar fazer as coisas e nós somos

38753
25:41:53,832 --> 25:41:56,320
vou copiar o nosso construtor de cópias, vamos

38754
25:41:56,320 --> 25:41:58,080
descer e fazer isso nós vamos colocar

38755
25:41:58,080 --> 25:42:00,232
em outra cópia disso, mas nós não

38756
25:42:00,232 --> 25:42:03,040
Queremos apenas inicializar o nosso contrato

38757
25:42:03,040 --> 25:42:04,800
variável de membro da contagem

38758
25:42:04,800 --> 25:42:07,120
Em vez disso, queremos fazer outra coisa

38759
25:42:07,120 --> 25:42:09,120
Vamos colocar uma vírgula aqui e

38760
25:42:09,120 --> 25:42:11,120
nós vamos dizer alguém alguns de vocês

38761
25:42:11,120 --> 25:42:13,120
Pode estar pensando o que se chamarmos o

38762
25:42:13,120 --> 25:42:16,000
construtor de base diretamente que podemos fazer

38763
25:42:16,000 --> 25:42:17,832
Algo assim podemos dizer pessoa

38764
25:42:17,832 --> 25:42:20,960
e podemos dizer fonte m nome completo que podemos

38765
25:42:20,960 --> 25:42:24,320
para que possamos dizer fonte mh e alguns de

38766
25:42:24,320 --> 25:42:27,120
você vai dizer fonte m endereço

38767
25:42:27,120 --> 25:42:29,912
Vamos fazer esse endereço de fonte m e nós somos

38768
25:42:29,912 --> 25:42:32,160
vai construir o objeto e usar

38769
25:42:32,160 --> 25:42:35,360
que para inicializar a parte de nós

38770
25:42:35,360 --> 25:42:37,832
Nós basicamente vamos chamar de

38771
25:42:37,832 --> 25:42:40,720
outro construtor que temos

38772
25:42:40,720 --> 25:42:42,800
que leva três parâmetros este

38773
25:42:42,800 --> 25:42:44,872
construtor aqui é isso que nós somos

38774
25:42:44,872 --> 25:42:46,320
Tentando chamar

38775
25:42:46,320 --> 25:42:49,512
em nossa cópia construtor, mas como vimos em

38776
25:42:49,512 --> 25:42:51,192
Os slides isso vai ter um monte

38777
25:42:51,192 --> 25:42:53,192
dos problemas que isso vai criar

38778
25:42:53,192 --> 25:42:55,760
Um objeto temporário que nós somos

38779
25:42:55,760 --> 25:42:57,760
vou copiar para configurar o

38780
25:42:57,760 --> 25:43:00,080
pessoa parte de nós, mas outro problema nós

38781
25:43:00,080 --> 25:43:01,600
ter que realmente vai causar um

38782
25:43:01,600 --> 25:43:03,832
O erro do compilador é que não temos

38783
25:43:03,832 --> 25:43:06,320
acesso à variável membro do endereço m

38784
25:43:06,320 --> 25:43:08,552
de um engenheiro construtor e isso é

38785
25:43:08,552 --> 25:43:10,232
vamos nos dar um erro de compilador, vamos

38786
25:43:10,232 --> 25:43:12,640
realmente tentar compilar este programa para

38787
25:43:12,640 --> 25:43:14,400
realmente mostram isso que estamos aprendendo que nós

38788
25:43:14,400 --> 25:43:15,912
deveria realmente ver

38789
25:43:15,912 --> 25:43:19,280
tantos erros de compilador quanto possível.

38790
25:43:19,280 --> 25:43:21,912
O mundo está acabado com erros e se

38791
25:43:21,912 --> 25:43:24,400
Vamos subir, vamos ver que nosso erro

38792
25:43:24,400 --> 25:43:27,440
é que a variável membro do endereço m é

38793
25:43:27,440 --> 25:43:30,000
privado para a classe da pessoa e nós temos

38794
25:43:30,000 --> 25:43:32,640
Não há negócios acessando isso no

38795
25:43:32,640 --> 25:43:35,832
arquivo cpp de engenheiro na linha 27 em nosso

38796
25:43:35,832 --> 25:43:38,552
construtor aqui e isso vai ser

38797
25:43:38,552 --> 25:43:41,440
nossa linha ofensiva não podemos fazer isso

38798
25:43:41,440 --> 25:43:44,000
poderia ir em nossa classe de pessoa e configurar

38799
25:43:44,000 --> 25:43:46,000
um método de getter público que vai

38800
25:43:46,000 --> 25:43:48,960
ser herdado pelo engenheiro e nós poderíamos

38801
25:43:48,960 --> 25:43:50,872
chamar isso para devolver o endereço, vamos

38802
25:43:50,872 --> 25:43:53,120
Na verdade, faça isso para mostrar que você

38803
25:43:53,120 --> 25:43:54,480
Pode fazer isso

38804
25:43:54,480 --> 25:43:58,000
então nós vamos entrar e colocar em um

38805
25:43:58,000 --> 25:43:59,760
método público que vai voltar

38806
25:43:59,760 --> 25:44:02,080
O endereço que realmente temos isso aqui

38807
25:44:02,080 --> 25:44:04,480
para que possamos ligar para que possamos dizer

38808
25:44:04,480 --> 25:44:06,800
fonte get address que vai funcionar

38809
25:44:06,800 --> 25:44:09,120
isso vai montar o nosso polegar

38810
25:44:09,120 --> 25:44:11,600
Vamos tentar construir porque eu penso a

38811
25:44:11,600 --> 25:44:13,680
Código de estúdio visual está mexendo conosco

38812
25:44:13,680 --> 25:44:15,912
Aqui, tudo bem, você vê os dois é bom

38813
25:44:15,912 --> 25:44:18,160
Código de estúdio visual que não foi

38814
25:44:18,160 --> 25:44:20,800
Entendendo nosso código aqui e se

38815
25:44:20,800 --> 25:44:22,400
executar o nosso programa vamos ver que

38816
25:44:22,400 --> 25:44:24,400
As coisas vão funcionar exatamente como nós

38817
25:44:24,400 --> 25:44:26,232
Espere vamos realmente

38818
25:44:26,232 --> 25:44:27,760
Exescutar o programa aqui vamos

38819
25:44:27,760 --> 25:44:30,320
clear e run galo que vamos ver

38820
25:44:30,320 --> 25:44:32,232
que agora a informação está sendo

38821
25:44:32,232 --> 25:44:34,960
encaminhados corretamente, mas estamos nos preparando

38822
25:44:34,960 --> 25:44:37,912
uma cópia temporária que somos

38823
25:44:37,912 --> 25:44:39,440
A cópia a partir de

38824
25:44:39,440 --> 25:44:42,080
para encaminhar os dados para a pessoa

38825
25:44:42,080 --> 25:44:45,512
parte de nós este não é bom design e

38826
25:44:45,512 --> 25:44:47,680
O que realmente queremos é a configuração que é

38827
25:44:47,680 --> 25:44:50,320
permitindo-nos chamar a cópia

38828
25:44:50,320 --> 25:44:53,120
construtor que trabalhamos duro para definir

38829
25:44:53,120 --> 25:44:55,512
Em nossa classe base aqui vamos voltar

38830
25:44:55,512 --> 25:44:57,760
para pessoa e ver que se subirmos, estamos

38831
25:44:57,760 --> 25:44:59,600
Vamos ver que temos uma cópia

38832
25:44:59,600 --> 25:45:01,760
construtor, nós realmente trabalhamos duro para definir

38833
25:45:01,760 --> 25:45:04,160
Queríamos reutilizar isso em nosso

38834
25:45:04,160 --> 25:45:06,640
classe de engenharia e isso é o que nós somos

38835
25:45:06,640 --> 25:45:09,280
indo ver aqui, então isso está funcionando, mas

38836
25:45:09,280 --> 25:45:11,280
Não é o ideal

38837
25:45:11,280 --> 25:45:14,000
e devemos realmente tentar reutilizar o nosso

38838
25:45:14,000 --> 25:45:16,552
codificar tanto quanto pudermos, então o que somos

38839
25:45:16,552 --> 25:45:19,512
O fazer é criar um mecanismo que

38840
25:45:19,512 --> 25:45:21,600
vai reutilizar o construtor de cópias

38841
25:45:21,600 --> 25:45:24,400
Temos em pessoa e tudo o que precisamos fazer

38842
25:45:24,400 --> 25:45:26,960
para conseguir isso para o trabalho, podemos dizer pessoa

38843
25:45:26,960 --> 25:45:29,192
e, em seguida, chamar o construtor de cópia de

38844
25:45:29,192 --> 25:45:32,320
pessoa passando diretamente em nossa fonte

38845
25:45:32,320 --> 25:45:35,040
objeto note que não precisamos definir

38846
25:45:35,040 --> 25:45:37,440
um objeto temporário, vamos

38847
25:45:37,440 --> 25:45:40,080
Copie diretamente do nosso engenheiro

38848
25:45:40,080 --> 25:45:42,320
objeto, mas isso vai fazer o

38849
25:45:42,320 --> 25:45:45,440
cortando nós vimos nos slides novamente se nós

38850
25:45:45,440 --> 25:45:48,640
ter duas camadas em nosso objeto o interior

38851
25:45:48,640 --> 25:45:50,800
A camada vai ser a parte da pessoa

38852
25:45:50,800 --> 25:45:54,232
nós e a camada verde exterior vamos

38853
25:45:54,232 --> 25:45:55,192
ser

38854
25:45:55,192 --> 25:45:57,512
A parte do engenheiro de nós

38855
25:45:57,512 --> 25:45:59,440
O que o compilador vai fazer

38856
25:45:59,440 --> 25:46:01,120
O compilador vai ver que estamos

38857
25:46:01,120 --> 25:46:02,960
Na verdade, passando novamente

38858
25:46:02,960 --> 25:46:03,680
a

38859
25:46:03,680 --> 25:46:07,120
objeto de engenharia para inicializar a pessoa

38860
25:46:07,120 --> 25:46:08,960
parte de nós aqui e vai dizer

38861
25:46:08,960 --> 25:46:11,440
Só precisamos da parte vermelha que não precisamos

38862
25:46:11,440 --> 25:46:13,832
precisa da parte verde aqui o compilador é

38863
25:46:13,832 --> 25:46:16,232
Realmente inteligente, então ele vai cortar

38864
25:46:16,232 --> 25:46:18,720
A camada do engenheiro exterior

38865
25:46:18,720 --> 25:46:20,640
E somente saindo

38866
25:46:20,640 --> 25:46:21,832
o verde

38867
25:46:21,832 --> 25:46:24,160
parte da pessoa e vai usar isso

38868
25:46:24,160 --> 25:46:26,720
para inicializar a parte da pessoa de nossos

38869
25:46:26,720 --> 25:46:29,680
objeto de engenharia e isso será reutilização

38870
25:46:29,680 --> 25:46:33,912
o construtor de cópias que temos em nosso

38871
25:46:33,912 --> 25:46:35,760
pessoa objeto, então isso é muito legal

38872
25:46:35,760 --> 25:46:38,800
Esta é a melhor maneira de configurar o seu

38873
25:46:38,800 --> 25:46:41,360
estruturas cópicas se você tem um

38874
25:46:41,360 --> 25:46:44,232
hierarquia de herança, então vamos tentar

38875
25:46:44,232 --> 25:46:46,000
construir o código novamente vamos passar

38876
25:46:46,000 --> 25:46:48,720
isso através do gcc para ver se isso realmente

38877
25:46:48,720 --> 25:46:50,480
funciona a bala vai ser bom nós

38878
25:46:50,480 --> 25:46:52,720
pode limpar e correr galo que vamos

38879
25:46:52,720 --> 25:46:54,552
Veja que o construtor de cópias está indo

38880
25:46:54,552 --> 25:46:56,872
para ser chamado para que a pessoa crie o

38881
25:46:56,872 --> 25:46:59,440
pessoa parte de nós e, em seguida, o costume

38882
25:46:59,440 --> 25:47:01,280
Copiar construtor para engenheiro está indo

38883
25:47:01,280 --> 25:47:03,600
para ser chamado para montar a peça do engenheiro

38884
25:47:03,600 --> 25:47:06,320
de nós e se olharmos para a informação

38885
25:47:06,320 --> 25:47:08,480
nós temos na função principal que você é

38886
25:47:08,480 --> 25:47:10,232
ver que são os mesmos dados

38887
25:47:10,232 --> 25:47:13,360
daniel cinza para o nome completo Idades 41

38888
25:47:13,360 --> 25:47:16,080
endereço é este gibberish aqui e

38889
25:47:16,080 --> 25:47:18,552
A contagem de contratos é 12 é exatamente o que

38890
25:47:18,552 --> 25:47:21,280
Passamos por aqui e nosso construtor de cópias

38891
25:47:21,280 --> 25:47:23,680
está trabalhando agora que temos isso funcionando

38892
25:47:23,680 --> 25:47:27,040
Podemos reutilizar com segurança as mesmas ideias

38893
25:47:27,040 --> 25:47:30,720
em nosso construtor de cópia de engenharia civil

38894
25:47:30,720 --> 25:47:33,680
Podemos ir em nosso engenheiro civil

38895
25:47:33,680 --> 25:47:35,440
e configurar o copy constructor assim vamos

38896
25:47:35,440 --> 25:47:37,440
Faz o que podemos

38897
25:47:37,440 --> 25:47:39,760
fechar a barra lateral esquerda aqui para que nós

38898
25:47:39,760 --> 25:47:43,192
Veja a coisa toda que vamos dizer

38899
25:47:43,192 --> 25:47:46,160
engenheiro civil e queremos criar uma

38900
25:47:46,160 --> 25:47:47,912
Copiar construtor, então vamos dizer

38901
25:47:47,912 --> 25:47:51,040
lançou um engenheiro civil aqui e nós seremos

38902
25:47:51,040 --> 25:47:53,192
passando isso por referência, vamos

38903
25:47:53,192 --> 25:47:55,912
Diga fonte e vamos colocar o

38904
25:47:55,912 --> 25:47:59,360
implementação disso em nosso arquivo cpp

38905
25:47:59,360 --> 25:48:02,400
Podemos pular por lá e ir abaixo do nosso

38906
25:48:02,400 --> 25:48:05,360
Construtor personalizado que nós podemos colocar em nosso

38907
25:48:05,360 --> 25:48:06,720
construtor aqui nós vamos dizer

38908
25:48:06,720 --> 25:48:09,192
engenheiro civil e colocar em nosso escopo

38909
25:48:09,192 --> 25:48:11,040
Operador de resolução e nós vamos

38910
25:48:11,040 --> 25:48:14,232
descer e colocar no corpo e em nosso

38911
25:48:14,232 --> 25:48:16,160
lista de inicializadores vamos chamar de

38912
25:48:16,160 --> 25:48:18,720
Copiar construtor do engenheiro porque

38913
25:48:18,720 --> 25:48:21,760
Lembre-se que o engenheiro civil está herdando

38914
25:48:21,760 --> 25:48:24,232
da classe do engenheiro, então estamos indo

38915
25:48:24,232 --> 25:48:27,040
para chamar o engenheiro copy construtor

38916
25:48:27,040 --> 25:48:29,360
Nós vamos passar na fonte e novamente

38917
25:48:29,360 --> 25:48:31,440
Isso vai cortar o civil

38918
25:48:31,440 --> 25:48:35,040
Engenheiro portuário e usar apenas o engenheiro

38919
25:48:35,040 --> 25:48:37,760
Parte de nós para construir um engenheiro

38920
25:48:37,760 --> 25:48:41,280
objeto desta fatia de engenheiro

38921
25:48:41,280 --> 25:48:44,160
objeto que obtemos do nosso construtor de cópias

38922
25:48:44,160 --> 25:48:46,160
Aqui e isso é muito legal depois disso

38923
25:48:46,160 --> 25:48:49,760
inicializaremos nossa contagem de contratos

38924
25:48:49,760 --> 25:48:52,872
membro variável oh é especialidade se

38925
25:48:52,872 --> 25:48:55,280
Eu me lembro corretamente e nós vamos

38926
25:48:55,280 --> 25:48:58,640
pegar uma fonte m especialidade e vamos

38927
25:48:58,640 --> 25:49:01,280
Use isso para inicializar o civil

38928
25:49:01,280 --> 25:49:04,400
Engenheiro de nós aqui vamos entrar e

38929
25:49:04,400 --> 25:49:06,960
Diga que o construtor de cópias personalizadas é

38930
25:49:06,960 --> 25:49:09,192
sendo chamado aqui e nós vamos dizer

38931
25:49:09,192 --> 25:49:11,600
Construtor de cópia personalizado chamado para

38932
25:49:11,600 --> 25:49:14,320
Engenheiro civil o que fizemos aqui

38933
25:49:14,320 --> 25:49:18,000
disse engenheiro, vamos fazer engenheiro, isto é

38934
25:49:18,000 --> 25:49:20,080
O que queremos e vamos dizer

38935
25:49:20,080 --> 25:49:23,360
Engenheiro aqui desculpe por isso

38936
25:49:23,360 --> 25:49:25,912
Mas isso não é grande coisa e agora que nós

38937
25:49:25,912 --> 25:49:28,232
Temos isso no lugar que podemos realmente construir

38938
25:49:28,232 --> 25:49:30,960
Objetos de engenharia civil e cópia

38939
25:49:30,960 --> 25:49:32,800
Construiu-os nós podemos

38940
25:49:32,800 --> 25:49:34,800
Comentar as coisas de engenharia que nós

38941
25:49:34,800 --> 25:49:37,832
Temos e podemos simplesmente colocar isso em um preto

38942
25:49:37,832 --> 25:49:39,680
Comentar e vamos copiar

38943
25:49:39,680 --> 25:49:42,480
Construir engenheiros civis como é legal

38944
25:49:42,480 --> 25:49:44,552
que nós vamos criar um civil

38945
25:49:44,552 --> 25:49:46,872
Engenheiro, vamos fazer isso

38946
25:49:46,872 --> 25:49:49,680
e este vai ser um engenheiro civil

38947
25:49:49,680 --> 25:49:51,440
e nós vamos dizer daniel cinza nós somos

38948
25:49:51,440 --> 25:49:53,040
vamos colocar todos os dados e nós somos

38949
25:49:53,040 --> 25:49:55,440
Vou especificar a especialidade a ser

38950
25:49:55,440 --> 25:49:57,360
força da estrada isso é algo que eu apenas

38951
25:49:57,360 --> 25:49:59,280
made up eu nem sei

38952
25:49:59,280 --> 25:50:02,640
Se esse tipo de especialidade existe e nós

38953
25:50:02,640 --> 25:50:04,552
criará outro engenheiro civil

38954
25:50:04,552 --> 25:50:07,832
objeto chamado n2 que vamos

38955
25:50:07,832 --> 25:50:10,320
ser cópia construindo e nós vamos

38956
25:50:10,320 --> 25:50:13,192
Veja o que acontece quando copiamos a construção

38957
25:50:13,192 --> 25:50:15,680
Esta coisa aqui devemos chamar a nossa cópia

38958
25:50:15,680 --> 25:50:18,400
construtor em engenheiro civil e

38959
25:50:18,400 --> 25:50:21,440
As coisas devem se propagar por todo o caminho

38960
25:50:21,440 --> 25:50:23,280
para a parte de nós e nós vamos

38961
25:50:23,280 --> 25:50:25,760
para ver o que acontece, vamos construir isso

38962
25:50:25,760 --> 25:50:27,680
Código que vamos passar por isso

38963
25:50:27,680 --> 25:50:30,640
gcc como sempre fazemos o orçamento está indo

38964
25:50:30,640 --> 25:50:32,720
para ser bom, então esta é uma boa notícia que somos

38965
25:50:32,720 --> 25:50:35,040
indo para limpar e correr o galo e nós estamos

38966
25:50:35,040 --> 25:50:36,552
ver que a cópia personalizada

38967
25:50:36,552 --> 25:50:38,720
O construtor é chamado para pessoa de

38968
25:50:38,720 --> 25:50:40,400
Construtor de cópia personalizado vai ser

38969
25:50:40,400 --> 25:50:43,120
chamado para o engenheiro e a cópia personalizada

38970
25:50:43,120 --> 25:50:44,720
O construtor será chamado completo

38971
25:50:44,720 --> 25:50:47,040
Engenheiro civil e você vê essas coisas

38972
25:50:47,040 --> 25:50:49,192
estão realmente se propagando todo o caminho para

38973
25:50:49,192 --> 25:50:51,440
a pessoa parte e nós estamos chamando e

38974
25:50:51,440 --> 25:50:53,680
reutilizando nossos construtores de cópias e isso

38975
25:50:53,680 --> 25:50:55,360
É muito legal se você descer você está

38976
25:50:55,360 --> 25:50:57,120
Vou ver que a informação é

38977
25:50:57,120 --> 25:50:59,680
impresso corretamente o nome completo é

38978
25:50:59,680 --> 25:51:02,080
daniel cinza que temos em engenheiro

38979
25:51:02,080 --> 25:51:05,120
Uma que a idade é 41, o endereço é tudo

38980
25:51:05,120 --> 25:51:08,080
Este rabbeish a contagem de contratos é 12

38981
25:51:08,080 --> 25:51:10,960
e a especialidade é a força da estrada e

38982
25:51:10,960 --> 25:51:12,080
nós somos nós

38983
25:51:12,080 --> 25:51:15,192
reutilização adequada de nossos construtores de cópias

38984
25:51:15,192 --> 25:51:18,080
em nossa hierarquia de herança, isso é

38985
25:51:18,080 --> 25:51:19,912
Realmente tudo que eu tinha para compartilhar isso

38986
25:51:19,912 --> 25:51:21,912
dê uma vez mais a sintaxe que você deve ser

38987
25:51:21,912 --> 25:51:24,720
Usando para configurar seus construtores de cópias

38988
25:51:24,720 --> 25:51:26,960
é o que vemos aqui que vai ser

38989
25:51:26,960 --> 25:51:30,480
reutilizando o código que temos em nossa parte superior

38990
25:51:30,480 --> 25:51:33,360
classes em nossa hierarquia, seremos

38991
25:51:33,360 --> 25:51:35,760
evitando as cópias temporárias que vimos

38992
25:51:35,760 --> 25:51:37,832
Quando chamamos o outro construtor

38993
25:51:37,832 --> 25:51:40,400
diretamente e isso é muito mais limpo, é

38994
25:51:40,400 --> 25:51:43,360
reutilizando o código que temos em outras classes que

38995
25:51:43,360 --> 25:51:45,512
Vou parar aqui nesta palestra

38996
25:51:45,512 --> 25:51:47,120
No próximo vamos ver isso

38997
25:51:47,120 --> 25:51:50,160
É realmente possível herdar a base

38998
25:51:50,160 --> 25:51:52,872
Os construtores vão em frente e terminam aqui

38999
25:51:52,872 --> 25:51:55,120
e encontrar-me lá nesta palestra nós somos

39000
25:51:55,120 --> 25:51:57,760
Vou explorar o fato de que podemos

39001
25:51:57,760 --> 25:52:00,872
herdar os construtores de base e usá-los

39002
25:52:00,872 --> 25:52:03,512
em nossas classes derivadas construiremos

39003
25:52:03,512 --> 25:52:05,360
Estamos usando a mesma hierarquia que temos

39004
25:52:05,360 --> 25:52:07,440
Estou usando assim que teremos a pessoa

39005
25:52:07,440 --> 25:52:09,832
classe e nós estaremos herdando de

39006
25:52:09,832 --> 25:52:12,480
Esta pessoa para criar uma classe de engenheiro

39007
25:52:12,480 --> 25:52:14,160
E isso é o que vamos usar

39008
25:52:14,160 --> 25:52:17,280
para aprender sobre este conceito aqui para que

39009
25:52:17,280 --> 25:52:20,160
A classe pessoal é o que sabemos a partir do

39010
25:52:20,160 --> 25:52:22,720
Palestras anteriores temos um monte de

39011
25:52:22,720 --> 25:52:25,120
variáveis de membro aqui temos a plenitude

39012
25:52:25,120 --> 25:52:27,680
nomear a idade e o endereço e nós temos

39013
25:52:27,680 --> 25:52:29,832
um monte de construtores agora temos um

39014
25:52:29,832 --> 25:52:32,640
construtor padrão um construtor personalizado

39015
25:52:32,640 --> 25:52:35,440
e um construtor de cópias que nós configuramos

39016
25:52:35,440 --> 25:52:38,320
incansavelmente na última palestra agora o que

39017
25:52:38,320 --> 25:52:40,800
Significamos quando dizemos que podemos

39018
25:52:40,800 --> 25:52:42,960
Herdar um construtor bem baseado

39019
25:52:42,960 --> 25:52:45,280
Os construtores não são herdados por

39020
25:52:45,280 --> 25:52:48,160
o que queremos dizer com isso é que

39021
25:52:48,160 --> 25:52:51,512
por padrão, não é realmente possível

39022
25:52:51,512 --> 25:52:54,872
para obter classes derivadas para usar base

39023
25:52:54,872 --> 25:52:58,000
construtores para montar as coisas, mas é

39024
25:52:58,000 --> 25:53:00,232
Possível dizer ao compilador para usar o

39025
25:53:00,232 --> 25:53:03,832
construtor de base para criar o nosso próprio

39026
25:53:03,832 --> 25:53:06,800
objetos, por exemplo, podemos colocar o nosso

39027
25:53:06,800 --> 25:53:08,800
Declaração aqui dizendo

39028
25:53:08,800 --> 25:53:12,160
usando pessoa coluna de coluna pessoa esta

39029
25:53:12,160 --> 25:53:14,400
vai dizer ao compilador quando

39030
25:53:14,400 --> 25:53:17,600
objetos de engenharia de soldagem não usam o seu

39031
25:53:17,600 --> 25:53:20,400
próprio construtor criou uma base como um

39032
25:53:20,400 --> 25:53:22,400
construtor que só vai

39033
25:53:22,400 --> 25:53:25,760
inicializar as variáveis do membro base e

39034
25:53:25,760 --> 25:53:27,360
o compilador vai ver isso

39035
25:53:27,360 --> 25:53:30,000
declaração e vai gerar um

39036
25:53:30,000 --> 25:53:32,720
construtor para você que parece algo

39037
25:53:32,720 --> 25:53:35,040
assim, então vai ser engenheiro

39038
25:53:35,040 --> 25:53:36,720
Vai estar tomando o todo

39039
25:53:36,720 --> 25:53:39,360
nomear a idade e o endereço e é

39040
25:53:39,360 --> 25:53:41,280
Vou encaminhar o trabalho para

39041
25:53:41,280 --> 25:53:44,320
inicialize seu objeto para a pessoa

39042
25:53:44,320 --> 25:53:46,720
classe e isso é tudo esse construtor

39043
25:53:46,720 --> 25:53:48,872
Vai fazer espero que você possa ver

39044
25:53:48,872 --> 25:53:51,512
que isso é chamado de herdar uma base

39045
25:53:51,512 --> 25:53:53,912
construtor porque todo esse construtor

39046
25:53:53,912 --> 25:53:57,192
Está realmente fazendo é inicializar a base

39047
25:53:57,192 --> 25:54:00,000
variáveis de membro que não está inicializando

39048
25:54:00,000 --> 25:54:03,120
qualquer variável de membro que pertença ao

39049
25:54:03,120 --> 25:54:05,680
classe de engenharia para que o engenheiro faça parte de

39050
25:54:05,680 --> 25:54:07,360
Nós vamos ser basicamente vazios

39051
25:54:07,360 --> 25:54:10,480
contendo dados inúteis que olhemos apenas

39052
25:54:10,480 --> 25:54:12,960
chamando o construtor padrão e nós

39053
25:54:12,960 --> 25:54:15,760
Será apenas inicializar os dados

39054
25:54:15,760 --> 25:54:18,480
pertencente à pessoa parte de nós esta

39055
25:54:18,480 --> 25:54:20,960
é realmente o que eu quero que você veja novamente

39056
25:54:20,960 --> 25:54:23,760
A sintaxe é o que vemos aqui

39057
25:54:23,760 --> 25:54:25,440
Isto vai dizer ao compilador para

39058
25:54:25,440 --> 25:54:27,440
gerar um construtor que é apenas

39059
25:54:27,440 --> 25:54:30,232
vai inicializar o membro da base

39060
25:54:30,232 --> 25:54:32,640
variáveis, mas este construtor será

39061
25:54:32,640 --> 25:54:36,232
Contável e utilizável do engenheiro

39062
25:54:36,232 --> 25:54:37,192
classe de classe

39063
25:54:37,192 --> 25:54:39,512
Tudo bem, então isso é realmente o que queremos dizer

39064
25:54:39,512 --> 25:54:43,192
Herdando construtores uma coisa que você

39065
25:54:43,192 --> 25:54:45,120
deveria saber que o construtor é

39066
25:54:45,120 --> 25:54:47,192
Vai ser herdado com o que

39067
25:54:47,192 --> 25:54:48,232
acesso

39068
25:54:48,232 --> 25:54:51,440
specificador que tinha na classe base, então se

39069
25:54:51,440 --> 25:54:54,080
nosso construtor estava no âmbito público

39070
25:54:54,080 --> 25:54:56,000
Vai ser herdado com público

39071
25:54:56,000 --> 25:54:58,480
acesso para que possamos usá-lo a partir de

39072
25:54:58,480 --> 25:55:01,280
os objetos exteriores e do engenheiro mundial

39073
25:55:01,280 --> 25:55:03,360
se foi em um escopo protegido que queremos

39074
25:55:03,360 --> 25:55:05,760
para poder usá-lo de fora se

39075
25:55:05,760 --> 25:55:08,080
Era privado, não seremos capazes de

39076
25:55:08,080 --> 25:55:10,160
usá-lo a partir de uma classe derivada que você deve

39077
25:55:10,160 --> 25:55:12,400
realmente sei que vai ser

39078
25:55:12,400 --> 25:55:15,280
herdado com qualquer especificador de acesso

39079
25:55:15,280 --> 25:55:18,640
tínhamos em nossa classe base agora que nós

39080
25:55:18,640 --> 25:55:20,872
Saiba isso vamos ver algumas coisas que você

39081
25:55:20,872 --> 25:55:23,280
Deve realmente ter cuidado com o primeiro

39082
25:55:23,280 --> 25:55:25,760
é que os construtores de cópias não são

39083
25:55:25,760 --> 25:55:28,232
herdado se você tentar fazer isso você é

39084
25:55:28,232 --> 25:55:30,320
vai ter um erro de compilador, mas você

39085
25:55:30,320 --> 25:55:32,400
Normalmente não vai notar isso porque o

39086
25:55:32,400 --> 25:55:34,400
O compilador vai inserir cópia

39087
25:55:34,400 --> 25:55:36,400
construtores para você, de qualquer maneira, isso é

39088
25:55:36,400 --> 25:55:38,160
Vai se tornar um problema se você for

39089
25:55:38,160 --> 25:55:40,960
fazer alguma alocação de memória dinâmica e

39090
25:55:40,960 --> 25:55:42,960
você vai ter ponteiros copiou isso

39091
25:55:42,960 --> 25:55:44,960
É realmente ruim se você não sabe sobre

39092
25:55:44,960 --> 25:55:47,040
Este, por favor, volte para o capítulo sobre

39093
25:55:47,040 --> 25:55:49,360
aulas e você vai ver tudo

39094
25:55:49,360 --> 25:55:51,760
história sobre cópia superficial e profunda

39095
25:55:51,760 --> 25:55:53,912
Copiando, falamos sobre essas coisas

39096
25:55:53,912 --> 25:55:55,912
Outra coisa que você deve saber é que

39097
25:55:55,912 --> 25:55:58,160
Os construtores herdados são realmente baseados

39098
25:55:58,160 --> 25:56:00,400
construtores e o que queremos dizer com isso é

39099
25:56:00,400 --> 25:56:03,512
que eles só estarão inicializando o

39100
25:56:03,512 --> 25:56:05,912
variáveis de membros de base porque são

39101
25:56:05,912 --> 25:56:07,912
construtores baseados em que não têm

39102
25:56:07,912 --> 25:56:10,400
conhecimento das variáveis de membros derivados

39103
25:56:10,400 --> 25:56:12,800
É por isso que eles só inicializam a base

39104
25:56:12,800 --> 25:56:14,960
variáveis de membro novamente, como dissemos

39105
25:56:14,960 --> 25:56:17,280
Os construtores são herdados com o que

39106
25:56:17,280 --> 25:56:19,512
especificador de acesso que eles tinham na base

39107
25:56:19,512 --> 25:56:21,680
classe e é possível configurar o seu

39108
25:56:21,680 --> 25:56:25,280
construtores próprios em cima dos herdados

39109
25:56:25,280 --> 25:56:27,192
construtores e você pode usar estes

39110
25:56:27,192 --> 25:56:28,872
Coisas outra coisa que eu realmente deveria

39111
25:56:28,872 --> 25:56:30,552
Diga que é essa herança

39112
25:56:30,552 --> 25:56:32,720
Os construtores vão fazer o seu código

39113
25:56:32,720 --> 25:56:34,960
A confusão é uma técnica

39114
25:56:34,960 --> 25:56:37,600
possibilidade, mas eu recomendo fortemente

39115
25:56:37,600 --> 25:56:40,000
contra usar isso em seu código porque

39116
25:56:40,000 --> 25:56:41,912
Só vai confundir as pessoas

39117
25:56:41,912 --> 25:56:43,600
As pessoas vão ver, por exemplo, a

39118
25:56:43,600 --> 25:56:45,600
Engenheiro construtor e eles estão indo

39119
25:56:45,600 --> 25:56:47,912
pensar que esse construtor está indo

39120
25:56:47,912 --> 25:56:50,552
até mesmo inicializar o membro do engenheiro

39121
25:56:50,552 --> 25:56:52,872
variáveis, mas não vai fazer isso

39122
25:56:52,872 --> 25:56:55,280
porque é um construtor de base é

39123
25:56:55,280 --> 25:56:57,600
só vai inicializar a base

39124
25:56:57,600 --> 25:56:59,832
variáveis de membros e que podem levar a

39125
25:56:59,832 --> 25:57:02,160
alguma confusão ou mesmo muito ruim

39126
25:57:02,160 --> 25:57:04,552
problemas em seu código, então não use isso

39127
25:57:04,552 --> 25:57:06,000
Só vai fazer as coisas

39128
25:57:06,000 --> 25:57:08,552
confuso, mas eu queria que você estivesse ciente

39129
25:57:08,552 --> 25:57:11,280
disto e se você vê esse tipo de

39130
25:57:11,280 --> 25:57:14,232
configuração em aulas lá fora você vai saber

39131
25:57:14,232 --> 25:57:16,160
O que eles querem dizer isso é apenas para

39132
25:57:16,160 --> 25:57:18,720
herdar um construtor de base e usá-lo para

39133
25:57:18,720 --> 25:57:20,872
construir objetos agora que sabemos disso

39134
25:57:20,872 --> 25:57:22,320
nós vamos ir para o visual

39135
25:57:22,320 --> 25:57:23,912
código de estúdio e jogar com a gente um pouco

39136
25:57:23,912 --> 25:57:26,960
Mais aqui estamos em nossa pasta de trabalho

39137
25:57:26,960 --> 25:57:30,232
O projeto atual está herdando com base

39138
25:57:30,232 --> 25:57:33,120
construtores, vamos roubar código

39139
25:57:33,120 --> 25:57:35,440
A partir da última palestra e seremos

39140
25:57:35,440 --> 25:57:38,400
usando o arquivo cpp principal da classe da pessoa

39141
25:57:38,400 --> 25:57:40,800
e a classe de engenheiros isso é apenas

39142
25:57:40,800 --> 25:57:43,512
Será suficiente para nossos propósitos aqui

39143
25:57:43,512 --> 25:57:45,512
Nós vamos voltar em nossa corrente

39144
25:57:45,512 --> 25:57:48,320
projeto e nós vamos colocar isso em

39145
25:57:48,320 --> 25:57:50,480
e vamos abrir isso no estúdio visual

39146
25:57:50,480 --> 25:57:52,552
código arrastando e soltando aqui isso

39147
25:57:52,552 --> 25:57:54,552
Vai dar-nos o nosso polegar

39148
25:57:54,552 --> 25:57:56,800
e vamos para a pessoa e ver que nós

39149
25:57:56,800 --> 25:57:59,512
Tenho os nossos construtores e temos um

39150
25:57:59,512 --> 25:58:01,360
Construtor padrão, temos um costume

39151
25:58:01,360 --> 25:58:03,512
construtor e nós temos uma cópia

39152
25:58:03,512 --> 25:58:05,512
construtor uma coisa que você deve saber é

39153
25:58:05,512 --> 25:58:08,400
que os construtores de cópias não são herdados

39154
25:58:08,400 --> 25:58:10,480
então você precisará configurar sua cópia

39155
25:58:10,480 --> 25:58:12,872
construtores explicitamente se você quiser

39156
25:58:12,872 --> 25:58:14,960
usá-los sabem que querem ser

39157
25:58:14,960 --> 25:58:16,800
vindo da classe upstream você

39158
25:58:16,800 --> 25:58:18,872
deve saber que tudo bem, então este é o

39159
25:58:18,872 --> 25:58:21,600
Mensagem aqui agora vamos olhar para o nosso

39160
25:58:21,600 --> 25:58:23,600
classe de engenheiro que a classe de engenheiros é

39161
25:58:23,600 --> 25:58:26,640
Herdar publicamente de pessoa e isso

39162
25:58:26,640 --> 25:58:30,000
tem um monte de seus próprios construtores, mas

39163
25:58:30,000 --> 25:58:32,480
O que queremos fazer é tirar tudo

39164
25:58:32,480 --> 25:58:35,512
Estes construtores e nós vamos

39165
25:58:35,512 --> 25:58:38,640
tirá-los eu acho que nós podemos uh yeah

39166
25:58:38,640 --> 25:58:40,320
nós vamos tirá-los para fora, vamos fazer

39167
25:58:40,320 --> 25:58:42,640
Isso e nós vamos entrar em nosso cpp

39168
25:58:42,640 --> 25:58:44,800
arquivo e também tirar tudo isso

39169
25:58:44,800 --> 25:58:46,800
construtores aqui vamos comentar

39170
25:58:46,800 --> 25:58:48,640
eles para fora eu acho que nós podemos tirar tudo

39171
25:58:48,640 --> 25:58:50,720
Este código ruim que temos de antes

39172
25:58:50,720 --> 25:58:53,040
Palestras e vamos apenas comentar

39173
25:58:53,040 --> 25:58:55,600
para fora nossos construtores nós vamos

39174
25:58:55,600 --> 25:58:58,720
Feche todos eles com um comentário de blog e

39175
25:58:58,720 --> 25:59:01,832
O que vamos fazer em nossa classe é

39176
25:59:01,832 --> 25:59:02,720
Dizê

39177
25:59:02,720 --> 25:59:04,640
usando a pessoa que vamos dizer

39178
25:59:04,640 --> 25:59:07,360
usando pessoa que isso vai

39179
25:59:07,360 --> 25:59:10,400
herdar os construtores da pessoa e

39180
25:59:10,400 --> 25:59:12,552
Agora que temos isso no lugar

39181
25:59:12,552 --> 25:59:14,640
O compilador vai realmente gerar um

39182
25:59:14,640 --> 25:59:17,760
base como construtor em nosso engenheiro

39183
25:59:17,760 --> 25:59:19,760
classe em outras palavras, vamos ter

39184
25:59:19,760 --> 25:59:22,080
um construtor de engenheiro padrão que é

39185
25:59:22,080 --> 25:59:24,800
Só não vamos inicializar nada que nós

39186
25:59:24,800 --> 25:59:27,040
vai ter um construtor personalizado

39187
25:59:27,040 --> 25:59:29,192
que vai tomar três parâmetros

39188
25:59:29,192 --> 25:59:31,040
Mas vai ser um engenheiro

39189
25:59:31,040 --> 25:59:33,040
construtor e vamos provar isso nós somos

39190
25:59:33,040 --> 25:59:35,912
indo para ir em nosso arquivo principal cpp e

39191
25:59:35,912 --> 25:59:37,440
Vamos tirar tudo o que nós

39192
25:59:37,440 --> 25:59:40,000
Temos aqui e nós não temos um civil

39193
25:59:40,000 --> 25:59:41,912
arquivo de engenharia, então não devemos realmente

39194
25:59:41,912 --> 25:59:44,080
Inclui isso e vamos criar

39195
25:59:44,080 --> 25:59:46,872
Um objeto de engenharia que podemos dizer e um

39196
25:59:46,872 --> 25:59:48,872
usando o construtor padrão que podemos tentar

39197
25:59:48,872 --> 25:59:50,320
e imprima isso e você vai

39198
25:59:50,320 --> 25:59:53,360
Veja que este código parece funcionar em

39199
25:59:53,360 --> 25:59:55,120
código de estúdio visual que podemos tentar construir

39200
25:59:55,120 --> 25:59:56,800
Isso nós vamos passar por isso

39201
25:59:56,800 --> 26:00:00,000
gcc e nós vamos

39202
26:00:00,000 --> 26:00:02,552
configurar uma janela powershell que podemos usar para

39203
26:00:02,552 --> 26:00:04,320
correr e ver as coisas

39204
26:00:04,320 --> 26:00:06,000
e vamos ver que é o padrão

39205
26:00:06,000 --> 26:00:08,160
O construtor para pessoa foi chamado para

39206
26:00:08,160 --> 26:00:10,232
inicialize esse cara

39207
26:00:10,232 --> 26:00:12,800
e os dados são realmente dados inúteis que temos

39208
26:00:12,800 --> 26:00:15,512
em pessoa, então o que o compilador é realmente

39209
26:00:15,512 --> 26:00:18,640
fazer nos bastidores é gerar um

39210
26:00:18,640 --> 26:00:21,440
Construtor de moldura no engenheiro

39211
26:00:21,440 --> 26:00:23,680
nível e vai chamar a base

39212
26:00:23,680 --> 26:00:25,680
construtor para inicializar a pessoa

39213
26:00:25,680 --> 26:00:28,960
parte de nós, então os dados vão apenas

39214
26:00:28,960 --> 26:00:31,040
ser dados inúteis que temos pessoalmente e

39215
26:00:31,040 --> 26:00:32,480
Você vai ver que é o contrato

39216
26:00:32,480 --> 26:00:34,552
contagem vai ser zero, isso é apenas um

39217
26:00:34,552 --> 26:00:36,640
construtor padrão que está apenas indo

39218
26:00:36,640 --> 26:00:38,800
para pegar quaisquer dados padrão que tenhamos em

39219
26:00:38,800 --> 26:00:41,280
nosso objeto você vê que a contagem de contratos é

39220
26:00:41,280 --> 26:00:43,600
zero se voltarmos pessoalmente, vamos

39221
26:00:43,600 --> 26:00:46,400
para ver que o nome completo não é nenhum que

39222
26:00:46,400 --> 26:00:48,720
é o que vemos aqui a idade é zero e

39223
26:00:48,720 --> 26:00:50,800
O endereço não é nenhum este é um padrão

39224
26:00:50,800 --> 26:00:53,512
construtor, mas podemos mesmo explicitamente

39225
26:00:53,512 --> 26:00:55,360
Passe nos dados e isso vai

39226
26:00:55,360 --> 26:00:57,280
também trabalhar para que possamos passar ao máximo

39227
26:00:57,280 --> 26:00:58,640
O nome para ser

39228
26:00:58,640 --> 26:01:00,872
daniel cinza nós podemos passar na borda para

39229
26:01:00,872 --> 26:01:03,600
b23 por exemplo e podemos passar em um

39230
26:01:03,600 --> 26:01:05,360
endereço de lixo vamos dizer algo como

39231
26:01:05,360 --> 26:01:07,440
Isso e você vê que isso vai

39232
26:01:07,440 --> 26:01:10,552
trabalho mesmo se não tivermos nenhum engenheiro

39233
26:01:10,552 --> 26:01:11,912
construtor

39234
26:01:11,912 --> 26:01:13,912
que leva três parâmetros, vamos

39235
26:01:13,912 --> 26:01:15,512
De volta e você vai ver isso tudo

39236
26:01:15,512 --> 26:01:18,800
Nossos construtores são comentados, mas

39237
26:01:18,800 --> 26:01:20,640
Isso está funcionando porque nós dissemos o

39238
26:01:20,640 --> 26:01:23,360
Compilador para gerar

39239
26:01:23,360 --> 26:01:27,040
uma base como construtor para o nosso engenheiro

39240
26:01:27,040 --> 26:01:30,080
então também vai ter em

39241
26:01:30,080 --> 26:01:33,192
Um engenheiro construtor que se parece

39242
26:01:33,192 --> 26:01:35,832
Este construtor aqui que leva em

39243
26:01:35,832 --> 26:01:38,400
três parâmetros e isso é muito legal

39244
26:01:38,400 --> 26:01:40,552
E isso é realmente crucial para entender

39245
26:01:40,552 --> 26:01:42,080
então, novamente, vamos montar um

39246
26:01:42,080 --> 26:01:44,480
construtor para engenheiro, então ele está indo

39247
26:01:44,480 --> 26:01:46,640
para ser um engenheiro construtor, mas é

39248
26:01:46,640 --> 26:01:49,680
Vou tomar apenas três parâmetros

39249
26:01:49,680 --> 26:01:51,760
como a pessoa construtor aqui e

39250
26:01:51,760 --> 26:01:53,760
Esta é a mensagem que eu realmente quero

39251
26:01:53,760 --> 26:01:55,832
Transmito aqui, portanto, se executarmos este código

39252
26:01:55,832 --> 26:01:57,192
você vai ver que vai

39253
26:01:57,192 --> 26:02:00,000
trabalho que vai chamar a nossa linha de base

39254
26:02:00,000 --> 26:02:02,232
construtor de engenheiro e vamos

39255
26:02:02,232 --> 26:02:04,400
ter os dados encaminhados e

39256
26:02:04,400 --> 26:02:06,080
Você vai ver que é o contrato

39257
26:02:06,080 --> 26:02:08,232
A contagem não vai ser levada para dentro

39258
26:02:08,232 --> 26:02:10,400
conta para que ainda contenha

39259
26:02:10,400 --> 26:02:13,040
alguns dados padrão se tentarmos passar

39260
26:02:13,040 --> 26:02:15,120
que em nós vamos ver que nós somos

39261
26:02:15,120 --> 26:02:16,872
vai ter um erro de compilador porque

39262
26:02:16,872 --> 26:02:19,440
Agora não temos tal construtor que

39263
26:02:19,440 --> 26:02:21,600
leva quatro parâmetros o único que nós

39264
26:02:21,600 --> 26:02:24,640
tem é aquele que é gerado por causa de

39265
26:02:24,640 --> 26:02:26,872
Esta declaração aqui e isso vai

39266
26:02:26,872 --> 26:02:29,760
ser um construtor de linha de base que é apenas

39267
26:02:29,760 --> 26:02:32,640
Vou tomar três parâmetros, assim como

39268
26:02:32,640 --> 26:02:34,872
Este construtor aqui e outra coisa

39269
26:02:34,872 --> 26:02:37,832
Eu não acho que eu deixei claro o suficiente é

39270
26:02:37,832 --> 26:02:39,680
que isso vai trazer em todos os

39271
26:02:39,680 --> 26:02:41,832
construtores que você tem que perceber que nós

39272
26:02:41,832 --> 26:02:44,160
apenas colocar nesta declaração, mas é

39273
26:02:44,160 --> 26:02:46,480
vamos pegar todos esses construtores nós

39274
26:02:46,480 --> 26:02:49,760
ter, exceto para os construtores de cópias

39275
26:02:49,760 --> 26:02:52,400
que não são herdados em c plus mais

39276
26:02:52,400 --> 26:02:54,400
Então você realmente deve saber disso se nós

39277
26:02:54,400 --> 26:02:55,680
construir este código, vamos conseguir um

39278
26:02:55,680 --> 26:02:58,000
Erro do compilador porque o compilador

39279
26:02:58,000 --> 26:02:59,280
Quer saber

39280
26:02:59,280 --> 26:03:01,912
O que fazer com o parâmetro 45 que nós

39281
26:03:01,912 --> 26:03:04,080
Tenho aqui, mas vamos construir e realmente

39282
26:03:04,080 --> 26:03:05,912
mostrar-lhe isso você precisa ver isso

39283
26:03:05,912 --> 26:03:08,872
Erro do compilador com seus próprios olhos, vamos

39284
26:03:08,872 --> 26:03:11,360
Ir para que o mundo esteja acabado com

39285
26:03:11,360 --> 26:03:13,832
erros e temos um erro dizendo não

39286
26:03:13,832 --> 26:03:15,440
função de correspondência chamada a isso

39287
26:03:15,440 --> 26:03:18,232
construtor que leva quatro parâmetros

39288
26:03:18,232 --> 26:03:19,912
Se tirarmos isto, vamos ver

39289
26:03:19,912 --> 26:03:21,912
que isso vai funcionar isso está indo

39290
26:03:21,912 --> 26:03:24,320
para usar o compilador gerado

39291
26:03:24,320 --> 26:03:25,600
construtor

39292
26:03:25,600 --> 26:03:28,232
como resultado desta declaração, temos em

39293
26:03:28,232 --> 26:03:30,552
nosso código agora, se quisermos, vamos

39294
26:03:30,552 --> 26:03:32,480
Veja que isso vai funcionar ok

39295
26:03:32,480 --> 26:03:34,720
construir é bom pode limpar e executar galo

39296
26:03:34,720 --> 26:03:36,480
nós vamos ver que temos o máximo

39297
26:03:36,480 --> 26:03:39,680
nome para ser daniel cinza temos o h2b23

39298
26:03:39,680 --> 26:03:41,912
temos nosso endereço, que é realmente alguns

39299
26:03:41,912 --> 26:03:44,800
dados de lixo e a contagem de contratos não tem

39300
26:03:44,800 --> 26:03:47,680
Os dados nele são apenas os dados padrão que nós

39301
26:03:47,680 --> 26:03:50,320
Temos em nossa variável de membro aqui que temos

39302
26:03:50,320 --> 26:03:53,040
nenhuma maneira de inicializar isso a partir de uma base

39303
26:03:53,040 --> 26:03:55,680
Como um construtor, mas nem tudo é

39304
26:03:55,680 --> 26:03:58,000
Realmente más notícias se você não quer ser

39305
26:03:58,000 --> 26:04:00,080
limitada pelos construtores que são

39306
26:04:00,080 --> 26:04:02,640
gerado pelo seu compilador como resultado

39307
26:04:02,640 --> 26:04:04,872
de herança você pode montar a sua própria

39308
26:04:04,872 --> 26:04:07,912
construtores, por exemplo, podemos descobrir

39309
26:04:07,912 --> 26:04:10,720
nosso engenheiro construtor aqui e trazer

39310
26:04:10,720 --> 26:04:12,960
fora de nosso comentário, podemos fazer

39311
26:04:12,960 --> 26:04:15,600
Algo assim podemos ir no

39312
26:04:15,600 --> 26:04:18,720
arquivo de implementação e também trazer isso

39313
26:04:18,720 --> 26:04:22,080
fora da nossa seção de comentários e agora nós

39314
26:04:22,080 --> 26:04:24,080
será capaz de usar este construtor

39315
26:04:24,080 --> 26:04:25,912
que vai levar o quarto

39316
26:04:25,912 --> 26:04:28,000
parâmetro aqui e fazer algo com

39317
26:04:28,000 --> 26:04:31,120
que agora se voltarmos em geral o código

39318
26:04:31,120 --> 26:04:32,960
Com três parâmetros vai funcionar

39319
26:04:32,960 --> 26:04:34,552
ele vai usar o compilador

39320
26:04:34,552 --> 26:04:38,232
gerado construtor, mas se passarmos o

39321
26:04:38,232 --> 26:04:41,120
contagem de contratos para b4 isso também está indo

39322
26:04:41,120 --> 26:04:43,280
para trabalhar porque vai usar

39323
26:04:43,280 --> 26:04:46,160
nosso próprio construtor aqui, se construirmos o

39324
26:04:46,160 --> 26:04:47,680
Código, vamos ver que ele está indo

39325
26:04:47,680 --> 26:04:50,320
para trabalhar muito bem vamos usar gcc para mostrar

39326
26:04:50,320 --> 26:04:51,440
Isto é

39327
26:04:51,440 --> 26:04:52,872
Você vai ver que o mundo é

39328
26:04:52,872 --> 26:04:54,800
Bom que podemos limpar

39329
26:04:54,800 --> 26:04:56,400
e correr o galo

39330
26:04:56,400 --> 26:04:59,120
Agora nossa contagem de contrato é levada

39331
26:04:59,120 --> 26:05:01,360
Conta isso é muito legal, isso é

39332
26:05:01,360 --> 26:05:03,440
Realmente tudo que eu queria que você visse isso

39333
26:05:03,440 --> 26:05:06,080
palestra que você pode deixar o compilador

39334
26:05:06,080 --> 26:05:09,120
gerar o construtor de linha de base usando

39335
26:05:09,120 --> 26:05:12,080
A sintaxe que temos em nosso cabeçalho aqui

39336
26:05:12,080 --> 26:05:14,552
esta declaração de uso pode realmente aparecer

39337
26:05:14,552 --> 26:05:17,360
em qualquer lugar, mas vai herdar o

39338
26:05:17,360 --> 26:05:19,680
construtor com qualquer acesso

39339
26:05:19,680 --> 26:05:22,480
especificador que o construtor tinha no

39340
26:05:22,480 --> 26:05:24,720
classe base e você deve realmente manter

39341
26:05:24,720 --> 26:05:27,680
Estes pontos em mente, especialmente o último

39342
26:05:27,680 --> 26:05:29,192
um que

39343
26:05:29,192 --> 26:05:31,280
Herdar construtores vai fazer

39344
26:05:31,280 --> 26:05:34,232
Seu código confundindo as pessoas vão

39345
26:05:34,232 --> 26:05:36,800
Note que eles podem chamar construtores

39346
26:05:36,800 --> 26:05:38,400
que realmente não vai ser

39347
26:05:38,400 --> 26:05:41,192
inicializando variáveis de membros derivados

39348
26:05:41,192 --> 26:05:43,512
e isso pode causar sérios problemas em

39349
26:05:43,512 --> 26:05:46,160
Seu código vamos parar aqui dentro

39350
26:05:46,160 --> 26:05:48,232
Esta palestra no próximo vamos

39351
26:05:48,232 --> 26:05:51,440
para explorar como a herança funciona

39352
26:05:51,440 --> 26:05:53,760
Essas estruturas até agora temos sido

39353
26:05:53,760 --> 26:05:56,080
Ignorando as estruturas para as quais vamos

39354
26:05:56,080 --> 26:05:58,640
Concentre-se neles na próxima palestra, então vá

39355
26:05:58,640 --> 26:06:00,480
Na frente e terminar aqui e me encontrar

39356
26:06:00,480 --> 26:06:02,232
lá nesta palestra vamos

39357
26:06:02,232 --> 26:06:05,120
Concentre-se em como os destruidores trabalham

39358
26:06:05,120 --> 26:06:07,912
herança e supor que temos um

39359
26:06:07,912 --> 26:06:10,640
Hierarquia de herança como temos sido

39360
26:06:10,640 --> 26:06:13,120
usando o tempo todo neste capítulo para que o nosso

39361
26:06:13,120 --> 26:06:15,192
A classe base é a pessoa que temos

39362
26:06:15,192 --> 26:06:17,040
classe de engenheiros que é publicamente

39363
26:06:17,040 --> 26:06:19,192
herdar da pessoa e nós temos um

39364
26:06:19,192 --> 26:06:21,440
classe de engenheiro civil que está herdando

39365
26:06:21,440 --> 26:06:25,120
do engenheiro publicamente quando criamos

39366
26:06:25,120 --> 26:06:28,232
um objeto de engenharia civil que vimos

39367
26:06:28,232 --> 26:06:31,040
que a parte da explosão é construída primeiro, então nós

39368
26:06:31,040 --> 26:06:33,120
Vamos construir a parte pessoal de

39369
26:06:33,120 --> 26:06:35,512
Nós vamos construir o engenheiro

39370
26:06:35,512 --> 26:06:37,680
parte de nós em cima disso e estamos

39371
26:06:37,680 --> 26:06:39,680
Vai construir a parte do engenheiro civil

39372
26:06:39,680 --> 26:06:42,552
de nós em cima disso, então os construtores

39373
26:06:42,552 --> 26:06:44,320
Vamos ser chamados nesta ordem nós

39374
26:06:44,320 --> 26:06:46,552
chamará a pessoa de construtor primeiro

39375
26:06:46,552 --> 26:06:48,872
engenheiro construtor depois disso e depois

39376
26:06:48,872 --> 26:06:51,440
um construtor de engenharia civil depois disso

39377
26:06:51,440 --> 26:06:54,800
para configurar o nosso objeto de engenharia civil

39378
26:06:54,800 --> 26:06:57,280
O que eu quero que você veja nesta palestra

39379
26:06:57,280 --> 26:06:59,832
é que as estruturas são chamadas no

39380
26:06:59,832 --> 26:07:02,480
ordem inversa a isso para que mais

39381
26:07:02,480 --> 26:07:04,640
Destructor especializado vai ser

39382
26:07:04,640 --> 26:07:07,440
chamado primeiro, então vamos destruir

39383
26:07:07,440 --> 26:07:10,232
A parte do engenheiro de nós e a pessoa

39384
26:07:10,232 --> 26:07:13,040
Parte de nós vai ser destruída por último

39385
26:07:13,040 --> 26:07:15,040
Então vamos construir coisas em

39386
26:07:15,040 --> 26:07:17,680
Esta ordem desde a parte de base até a

39387
26:07:17,680 --> 26:07:20,232
mais especializado e depois somos

39388
26:07:20,232 --> 26:07:24,160
Vou destruir graças nesta ordem, então

39389
26:07:24,160 --> 26:07:26,080
Essas estruturas serão chamadas

39390
26:07:26,080 --> 26:07:28,640
Na ordem inversa do que a

39391
26:07:28,640 --> 26:07:31,280
construtores que é a mensagem que eu quero

39392
26:07:31,280 --> 26:07:33,440
para transmitir aqui e nós vamos montar

39393
26:07:33,440 --> 26:07:35,192
Um exemplo simples para brincar com a gente

39394
26:07:35,192 --> 26:07:37,440
Vai criar um objeto de engenharia civil

39395
26:07:37,440 --> 26:07:39,120
e nós vamos ver a ordem em

39396
26:07:39,120 --> 26:07:41,600
que essas coisas são chamadas e vamos

39397
26:07:41,600 --> 26:07:43,760
dirija-se ao código do estúdio visual e

39398
26:07:43,760 --> 26:07:46,400
Na verdade, faça isso aqui estamos em nosso

39399
26:07:46,400 --> 26:07:48,960
pasta de trabalho o projeto atual é

39400
26:07:48,960 --> 26:07:51,680
herança e destruidores, vamos

39401
26:07:51,680 --> 26:07:54,080
estar reutilizando o código de um

39402
26:07:54,080 --> 26:07:56,640
palestra Eu não acho a última palestra

39403
26:07:56,640 --> 26:07:58,720
É um bom exemplo porque não temos

39404
26:07:58,720 --> 26:08:01,192
uma classe de engenheiro civil, então estamos indo

39405
26:08:01,192 --> 26:08:03,832
para ir à palestra antes disso e usar

39406
26:08:03,832 --> 26:08:06,080
o código da nossa palestra ou da cópia

39407
26:08:06,080 --> 26:08:08,232
construtores com herança que é

39408
26:08:08,232 --> 26:08:10,160
Vamos nos dar todas as aulas que temos

39409
26:08:10,160 --> 26:08:12,800
engenheiro e engenheiro civil e

39410
26:08:12,800 --> 26:08:14,960
Precisamos disso nesta palestra aqui para que

39411
26:08:14,960 --> 26:08:17,360
Vamos pegar todas essas coisas que estamos indo

39412
26:08:17,360 --> 26:08:20,232
para copiá-los e colocá-los em nossa corrente

39413
26:08:20,232 --> 26:08:21,512
objeto

39414
26:08:21,512 --> 26:08:24,400
que é herança e as estruturas

39415
26:08:24,400 --> 26:08:26,552
e nós vamos abrir isso em

39416
26:08:26,552 --> 26:08:28,800
Código de estúdio e vai ser o nosso

39417
26:08:28,800 --> 26:08:31,120
ponto de partida aqui, então temos pessoa

39418
26:08:31,120 --> 26:08:33,512
Engenheiro e engenheiro civil, vamos ver

39419
26:08:33,512 --> 26:08:36,960
o que estamos fazendo e o arquivo cpp principal

39420
26:08:36,960 --> 26:08:39,512
Podemos tirar todo o lixo aqui ou nós

39421
26:08:39,512 --> 26:08:42,480
pode sair no objeto de engenharia civil

39422
26:08:42,480 --> 26:08:44,232
Estamos criando aqui e vamos

39423
26:08:44,232 --> 26:08:45,512
Veja como

39424
26:08:45,512 --> 26:08:48,320
Os construtores e os instrutores são

39425
26:08:48,320 --> 26:08:50,320
chamados, vamos para a pessoa e

39426
26:08:50,320 --> 26:08:52,872
Certifique-se de que temos um construtor e nós

39427
26:08:52,872 --> 26:08:56,080
tem um monte de construtores e

39428
26:08:56,080 --> 26:08:58,960
Vamos para o arquivo cpp e ver que nós

39429
26:08:58,960 --> 26:09:01,512
ter mensagens em nossos construtores isso

39430
26:09:01,512 --> 26:09:02,800
É realmente

39431
26:09:02,800 --> 26:09:05,280
O que esperamos, mas queremos também colocar um

39432
26:09:05,280 --> 26:09:08,232
mensagem no destructor, digamos,

39433
26:09:08,232 --> 26:09:11,360
fora e dizer destruidor para pessoa chamada

39434
26:09:11,360 --> 26:09:13,512
Isto vai fazer nós vamos entrar

39435
26:09:13,512 --> 26:09:15,280
nossa classe de engenheiros vamos ver

39436
26:09:15,280 --> 26:09:17,360
Temos um monte de construtores

39437
26:09:17,360 --> 26:09:19,280
Tenho um destruidor aqui nós vamos

39438
26:09:19,280 --> 26:09:22,000
pular no arquivo cpp

39439
26:09:22,000 --> 26:09:24,960
e certifique-se de tirar o código ruim

39440
26:09:24,960 --> 26:09:26,552
Porque nós realmente não precisamos disso

39441
26:09:26,552 --> 26:09:29,832
Só precisamos de um bom código e certificamo-nos de que

39442
26:09:29,832 --> 26:09:32,160
que temos declarações de saída em nosso

39443
26:09:32,160 --> 26:09:34,000
construtores para saber quando são

39444
26:09:34,000 --> 26:09:36,320
chamado parece que somos bons nós somos

39445
26:09:36,320 --> 26:09:38,800
indo para colocar uma declaração sddc para fora em

39446
26:09:38,800 --> 26:09:41,760
nosso destruidor para engenheiro ou engenheiro

39447
26:09:41,760 --> 26:09:43,832
chamado isso vai fazer e nós somos

39448
26:09:43,832 --> 26:09:46,320
Vou pular em nosso engenheiro civil

39449
26:09:46,320 --> 26:09:47,760
classe que vamos ter um monte de

39450
26:09:47,760 --> 26:09:50,400
construtores, vamos ter um civil

39451
26:09:50,400 --> 26:09:51,760
Engenheiro

39452
26:09:51,760 --> 26:09:53,120
destructor

39453
26:09:53,120 --> 26:09:55,680
podemos ir no arquivo cpp e ter certeza

39454
26:09:55,680 --> 26:09:58,232
que temos declarações de saída em nosso

39455
26:09:58,232 --> 26:10:00,872
Construtores de engenheiros civis parecem

39456
26:10:00,872 --> 26:10:02,960
Somos bons aqui podemos tirar todos os

39457
26:10:02,960 --> 26:10:05,832
Código ruim que não precisamos e estamos indo

39458
26:10:05,832 --> 26:10:08,552
para colocar uma mensagem em nosso destruidor aqui

39459
26:10:08,552 --> 26:10:11,192
então vamos fazer isso a estrutura

39460
26:10:11,192 --> 26:10:14,080
pedindo engenheiro civil, acho que isso

39461
26:10:14,080 --> 26:10:16,480
Vai ser bom o suficiente, vamos voltar

39462
26:10:16,480 --> 26:10:18,552
e certifique-se de que temos as mesmas mensagens

39463
26:10:18,552 --> 26:10:20,552
aqui para o engenheiro

39464
26:10:20,552 --> 26:10:22,720
e nós temos um destruidor para pessoa

39465
26:10:22,720 --> 26:10:24,960
Chamamos mensagem e vamos tentar

39466
26:10:24,960 --> 26:10:26,480
e executar o código e ver como

39467
26:10:26,480 --> 26:10:29,280
construtores e destruidores são chamados

39468
26:10:29,280 --> 26:10:31,680
Esta é a ordem que queremos ter certeza

39469
26:10:31,680 --> 26:10:34,080
nós entendemos se você quer que você possa mesmo

39470
26:10:34,080 --> 26:10:36,320
Use um depurador para seguir as coisas, mas eu sou

39471
26:10:36,320 --> 26:10:38,480
Não vou fazer isso aqui eu estou apenas

39472
26:10:38,480 --> 26:10:40,320
indo para soldar e mostrar-lhe a saída

39473
26:10:40,320 --> 26:10:41,600
Declarações

39474
26:10:41,600 --> 26:10:43,440
Espero que isso seja prova

39475
26:10:43,440 --> 26:10:44,320
O suficiente

39476
26:10:44,320 --> 26:10:47,120
que as coisas acontecem na ordem que eu

39477
26:10:47,120 --> 26:10:49,600
apenas descrito nos slides a construção

39478
26:10:49,600 --> 26:10:51,832
É bom que podemos esclarecer que podemos trazer a

39479
26:10:51,832 --> 26:10:54,320
janela powershell e, em seguida, claro e

39480
26:10:54,320 --> 26:10:56,232
nós vamos correr o galo nós vamos

39481
26:10:56,232 --> 26:10:57,832
para ver que o construtor vai

39482
26:10:57,832 --> 26:11:01,440
ser chamado para pessoa para engenheiro civil

39483
26:11:01,440 --> 26:11:02,800
E você vai ver que as coisas são

39484
26:11:02,800 --> 26:11:05,912
vai acontecer a partir do must-based

39485
26:11:05,912 --> 26:11:08,480
construtor para os mais especializados

39486
26:11:08,480 --> 26:11:11,360
construtor, assim vamos chamar

39487
26:11:11,360 --> 26:11:13,912
engenheiro e engenheiro civil, mas

39488
26:11:13,912 --> 26:11:15,600
Você vai ver que as estruturas

39489
26:11:15,600 --> 26:11:17,600
vai ser chamado no inverso

39490
26:11:17,600 --> 26:11:18,480
ordem

39491
26:11:18,480 --> 26:11:20,480
O mais especializado do destruidor é

39492
26:11:20,480 --> 26:11:22,480
vai ser chamado o primeiro, então nós somos

39493
26:11:22,480 --> 26:11:24,480
Vou chamar o distrator para

39494
26:11:24,480 --> 26:11:26,320
Engenheiro, então vamos chamar o

39495
26:11:26,320 --> 26:11:29,120
Destructor para a classe base, então as coisas

39496
26:11:29,120 --> 26:11:30,872
Vai acontecer ao contrário

39497
26:11:30,872 --> 26:11:33,600
Ordem que vamos construir graças a partir de

39498
26:11:33,600 --> 26:11:35,512
a base e depois

39499
26:11:35,512 --> 26:11:38,160
Acabamento pela classe mais especializada

39500
26:11:38,160 --> 26:11:40,960
que está fazendo a herança e então

39501
26:11:40,960 --> 26:11:42,960
vamos chamar o destruidor para

39502
26:11:42,960 --> 26:11:45,600
a classe mais especializada em primeiro lugar e

39503
26:11:45,600 --> 26:11:48,232
então o destruidor para os mais

39504
26:11:48,232 --> 26:11:50,640
A classe vai ser fria por último você

39505
26:11:50,640 --> 26:11:52,400
Deve realmente ter certeza de que você entende

39506
26:11:52,400 --> 26:11:54,872
Porque às vezes suas coisas são

39507
26:11:54,872 --> 26:11:57,040
vai depender desta ordem e

39508
26:11:57,040 --> 26:11:58,720
Você precisa entender isso e isso é

39509
26:11:58,720 --> 26:12:00,960
Realmente a principal mensagem aqui que o

39510
26:12:00,960 --> 26:12:03,360
Estruturas são ridicularizados no inverso

39511
26:12:03,360 --> 26:12:04,320
ordem

39512
26:12:04,320 --> 26:12:06,080
Mais do que os construtores

39513
26:12:06,080 --> 26:12:07,680
Vamos parar aqui neste

39514
26:12:07,680 --> 26:12:09,280
palestra no próximo, vamos

39515
26:12:09,280 --> 26:12:12,480
Veja que podemos realmente reutilizar nomes em

39516
26:12:12,480 --> 26:12:15,040
nossa hierarquia de herança e nós somos

39517
26:12:15,040 --> 26:12:16,720
Vou ver como isso funciona no

39518
26:12:16,720 --> 26:12:18,872
próxima palestra, então vá em frente e termine

39519
26:12:18,872 --> 26:12:21,440
Aqui e encontre-me lá nesta palestra

39520
26:12:21,440 --> 26:12:23,440
Vamos ver que podemos reutilizar

39521
26:12:23,440 --> 26:12:27,192
Nomes em nossa hierarquia de herança

39522
26:12:27,192 --> 26:12:29,760
O que queremos dizer com isso é que podemos

39523
26:12:29,760 --> 26:12:32,400
ter uma classe de pais, por exemplo, e ter

39524
26:12:32,400 --> 26:12:34,960
Uma classe de criança que herda do pai

39525
26:12:34,960 --> 26:12:38,640
classe e ter exatamente os mesmos nomes

39526
26:12:38,640 --> 26:12:41,280
para as variáveis e tipos dos membros ou

39527
26:12:41,280 --> 26:12:43,512
As mesmas assinaturas para funções

39528
26:12:43,512 --> 26:12:45,912
Exemplo na classe dos pais você vê que

39529
26:12:45,912 --> 26:12:48,320
temos uma função de membro chamada

39530
26:12:48,320 --> 26:12:50,480
printfur vai imprimir alguns

39531
26:12:50,480 --> 26:12:53,600
informação que podemos ter uma função nomeada

39532
26:12:53,600 --> 26:12:56,400
exatamente o mesmo na classe infantil e

39533
26:12:56,400 --> 26:12:58,640
c plus vai permitir isso

39534
26:12:58,640 --> 26:13:00,640
Também pode fazer as mesmas coisas para o membro

39535
26:13:00,640 --> 26:13:03,280
variáveis, por exemplo, temos m var

39536
26:13:03,280 --> 26:13:06,720
que é de tipo e nós temos exatamente o

39537
26:13:06,720 --> 26:13:09,832
A mesma coisa em nossa classe infantil e c plus

39538
26:13:09,832 --> 26:13:12,232
Plus vai permitir que isso agora

39539
26:13:12,232 --> 26:13:14,800
O problema é se você criar um objeto de

39540
26:13:14,800 --> 26:13:17,832
criança qual método será chamado se você

39541
26:13:17,832 --> 26:13:20,080
call printvar agora

39542
26:13:20,080 --> 26:13:23,120
O que c plus mais faz é que vai

39543
26:13:23,120 --> 26:13:25,192
override ou se esconder

39544
26:13:25,192 --> 26:13:27,280
coisas que você tem na classe base se você

39545
26:13:27,280 --> 26:13:30,080
Acontece para configurar exatamente a mesma coisa

39546
26:13:30,080 --> 26:13:33,192
em uma classe derivada, por exemplo, o

39547
26:13:33,192 --> 26:13:36,552
Os membros da nossa classe infantil vão

39548
26:13:36,552 --> 26:13:39,040
Esconder os membros que tínhamos na base

39549
26:13:39,040 --> 26:13:41,600
classe e se chamarmos esses métodos em um

39550
26:13:41,600 --> 26:13:44,160
Filho objeto, vamos conseguir o

39551
26:13:44,160 --> 26:13:46,960
Versões na classe infantil chamadas se nós

39552
26:13:46,960 --> 26:13:49,600
chamar esses métodos em um objeto pai nós

39553
26:13:49,600 --> 26:13:51,680


39554
26:13:51,680 --> 26:13:53,360
chamado e vamos ver os dados

39555
26:13:53,360 --> 26:13:55,360
na classe dos pais impressa, isso é

39556
26:13:55,360 --> 26:13:57,832
A mensagem aqui é possível usar

39557
26:13:57,832 --> 26:14:00,400
Os mesmos nomes em pais e filhos

39558
26:14:00,400 --> 26:14:03,512
aulas e se você fizer essas coisas

39559
26:14:03,512 --> 26:14:05,912
As aulas de crianças vão se esconder ou

39560
26:14:05,912 --> 26:14:08,720
substituir o que tínhamos na classe dos pais

39561
26:14:08,720 --> 26:14:10,800
Esta é a mensagem que quero transmitir

39562
26:14:10,800 --> 26:14:13,192
Aqui e aqui está um exemplo simples para

39563
26:14:13,192 --> 26:14:15,832
dirigir para casa como você pode usar essas coisas

39564
26:14:15,832 --> 26:14:18,400
Por exemplo, podemos criar um objeto filho

39565
26:14:18,400 --> 26:14:20,400
usando esta sintaxe aqui

39566
26:14:20,400 --> 26:14:23,040
e se chamarmos um método sobre a criança

39567
26:14:23,040 --> 26:14:24,872
Objeto isto vai chamar o método

39568
26:14:24,872 --> 26:14:27,760
na criança, mas é possível forçar a

39569
26:14:27,760 --> 26:14:31,192
compilador para chamar a versão na base

39570
26:14:31,192 --> 26:14:32,960
classe e você vai ver isso

39571
26:14:32,960 --> 26:14:35,512
sintaxe usada em algum lugar no seu código

39572
26:14:35,512 --> 26:14:38,872
Então a sintaxe é para dizer o objeto

39573
26:14:38,872 --> 26:14:41,440
O nome que você coloca, você diz o nome para

39574
26:14:41,440 --> 26:14:44,232
a classe dos pais e então você chama de

39575
26:14:44,232 --> 26:14:46,400
método usando a resolução do escopo

39576
26:14:46,400 --> 26:14:48,480
Operador aqui e isso vai segurar

39577
26:14:48,480 --> 26:14:50,720
O método no pai ok agora que

39578
26:14:50,720 --> 26:14:52,160
Você sabe que vamos cabeçar

39579
26:14:52,160 --> 26:14:54,160
para código de estúdio visual e jogar com isso

39580
26:14:54,160 --> 26:14:56,872
Um pouco mais aqui estamos trabalhando

39581
26:14:56,872 --> 26:14:59,280
pasta do projeto atual é reutilizado

39582
26:14:59,280 --> 26:15:02,400
símbolos e herança que vamos

39583
26:15:02,400 --> 26:15:05,440
Basta pegar os arquivos do modelo porque nós

39584
26:15:05,440 --> 26:15:07,280
Eles vão construir coisas a partir de

39585
26:15:07,280 --> 26:15:09,440
Arranque aqui e nós vamos colocar

39586
26:15:09,440 --> 26:15:12,400
nossos arquivos não há grande problema aqui e nós podemos

39587
26:15:12,400 --> 26:15:14,872
abrir isso em código de estúdio visual este é

39588
26:15:14,872 --> 26:15:18,080
vamos nos dar um cpp principal mínimo nu

39589
26:15:18,080 --> 26:15:21,040
arquivo podemos limpá-lo um pouco e

39590
26:15:21,040 --> 26:15:22,960
Vamos montar a nossa classe de pais

39591
26:15:22,960 --> 26:15:24,640
Vamos fazer isso muito rápido que vamos

39592
26:15:24,640 --> 26:15:27,360
Diga pai e configurar o cabeçalho e

39593
26:15:27,360 --> 26:15:29,120
Vamos configurar a implementação

39594
26:15:29,120 --> 26:15:32,000
arquivo cpp vamos configurar o arquivo

39595
26:15:32,000 --> 26:15:35,600
arquivo de cabeçalho e isso vai fazer

39596
26:15:35,600 --> 26:15:38,640
Tudo o que queremos temos um construtor

39597
26:15:38,640 --> 26:15:40,872
que está realmente inadimplente aqui, então vamos

39598
26:15:40,872 --> 26:15:43,512
Diga padrão e não podemos fazer o padrão

39599
26:15:43,512 --> 26:15:45,600
O destructor pode fazer o padrão, vamos fazer

39600
26:15:45,600 --> 26:15:47,832
e ver o que acontece e nós não

39601
26:15:47,832 --> 26:15:50,400
Eu realmente precisa fazer qualquer coisa no cpp

39602
26:15:50,400 --> 26:15:52,320
arquivo podemos deixá-lo vazio este não é

39603
26:15:52,320 --> 26:15:54,960
vamos machucar qualquer coisa e com isso nós

39604
26:15:54,960 --> 26:15:57,512
pode criar objetos pais, vamos fazer isso

39605
26:15:57,512 --> 26:15:58,872
nós vamos dizer

39606
26:15:58,872 --> 26:16:00,720
nós vamos pular para o cpp principal

39607
26:16:00,720 --> 26:16:02,800
arquivo e incluir corrente e certifique-se de

39608
26:16:02,800 --> 26:16:04,800
que nós podemos usar isso e nós vamos

39609
26:16:04,800 --> 26:16:07,192
criar um objeto pai, vamos fazer isso

39610
26:16:07,192 --> 26:16:10,232
nós vamos dizer pai p1 e dizer

39611
26:16:10,232 --> 26:16:13,040
p1 valores de impressão que podemos fazer isso e nós

39612
26:16:13,040 --> 26:16:15,280
pode trabalhar e executar este programa eu acho que

39613
26:16:15,280 --> 26:16:17,760
Vai trabalhar muito bem o melhor

39614
26:16:17,760 --> 26:16:20,232
construir é bom que podemos limpar ou podemos definir

39615
26:16:20,232 --> 26:16:23,120
para cima uma janela powershell e uma clara

39616
26:16:23,120 --> 26:16:25,360
e correr galo isto vai dizer o

39617
26:16:25,360 --> 26:16:27,912
O valor no pai é 100, que é o que nós

39618
26:16:27,912 --> 26:16:29,832
Temos por padrão aqui temos um simples

39619
26:16:29,832 --> 26:16:32,872
membro variável que é de ant type it

39620
26:16:32,872 --> 26:16:35,600
É protegido porque queremos que seja

39621
26:16:35,600 --> 26:16:38,320
herdado e nós temos um monte de

39622
26:16:38,320 --> 26:16:40,000
construtores aqui temos um construtor

39623
26:16:40,000 --> 26:16:41,600
que vai ter um valor, mas nós somos

39624
26:16:41,600 --> 26:16:43,360
não usar isso aqui o padrão

39625
26:16:43,360 --> 26:16:45,512
É bom que você pode usar isso se você

39626
26:16:45,512 --> 26:16:47,680
Queremos e temos uma função de membro que

39627
26:16:47,680 --> 26:16:49,600
vai imprimir o valor no pai

39628
26:16:49,600 --> 26:16:51,832
Agora que isso está funcionando, podemos criar um

39629
26:16:51,832 --> 26:16:53,680
classe de criança que vai ser

39630
26:16:53,680 --> 26:16:56,232
herdar da classe dos pais aqui, então

39631
26:16:56,232 --> 26:16:58,080
Vamos fazer isso, vamos configurar o

39632
26:16:58,080 --> 26:17:01,192
cabeçalho de criança arquivo criança dot h e nós somos

39633
26:17:01,192 --> 26:17:03,760
Vou configurar um arquivo cpp para que

39634
26:17:03,760 --> 26:17:06,552
cpp então vamos colocar os dados em

39635
26:17:06,552 --> 26:17:08,960
O arquivo de cabeçalho novamente não é nada

39636
26:17:08,960 --> 26:17:11,680
Complicou que é apenas uma classe simples

39637
26:17:11,680 --> 26:17:13,680
que vai herdar de

39638
26:17:13,680 --> 26:17:16,480
pai e nós vamos ter o nosso próprio

39639
26:17:16,480 --> 26:17:17,832
variável de membro que está indo para

39640
26:17:17,832 --> 26:17:20,160
eclipse o que tivemos no pai, então

39641
26:17:20,160 --> 26:17:22,720
Os nomes aqui devem ser os mesmos m um membro

39642
26:17:22,720 --> 26:17:25,912
de r se formos no pai é m membro

39643
26:17:25,912 --> 26:17:28,960
pois e o que temos na criança está indo

39644
26:17:28,960 --> 26:17:31,360
para eclipsar o que tivemos no pai

39645
26:17:31,360 --> 26:17:34,080
classe em outras palavras, se imprimirmos o

39646
26:17:34,080 --> 26:17:36,400
membro variável na criança que vamos

39647
26:17:36,400 --> 26:17:39,680
Veja 1000 impressos aqui queremos ver

39648
26:17:39,680 --> 26:17:43,192
100 que temos nos pais impressos

39649
26:17:43,192 --> 26:17:45,360
para fora espero que isso vai conduzir o

39650
26:17:45,360 --> 26:17:48,000
apontar para casa que se você tem membros

39651
26:17:48,000 --> 26:17:50,400
O nome exatamente da mesma

39652
26:17:50,400 --> 26:17:53,120
O que você tem em suas classes derivadas é

39653
26:17:53,120 --> 26:17:56,080
ir eclipsar ou esconder o que tivemos em

39654
26:17:56,080 --> 26:17:57,832
A classe dos pais é a mensagem

39655
26:17:57,832 --> 26:18:01,192
Aqui, mas mesmo que este seja o caso c plus

39656
26:18:01,192 --> 26:18:04,080
O plus nos permite especificar que queremos

39657
26:18:04,080 --> 26:18:07,512
para pegar os dados dos pais de uma criança

39658
26:18:07,512 --> 26:18:10,960
objeto, por exemplo, em nossos valores de show

39659
26:18:10,960 --> 26:18:13,440
método podemos imprimir o valor em criança

39660
26:18:13,440 --> 26:18:16,232
diretamente usando m membro de guerra, mas nós podemos

39661
26:18:16,232 --> 26:18:18,552
especificar também que queremos o valor em

39662
26:18:18,552 --> 26:18:21,192
a classe dos pais porque mesmo que isso seja

39663
26:18:21,192 --> 26:18:24,720
uma criança objeto que tem uma parte atual de

39664
26:18:24,720 --> 26:18:27,360
para que possamos acessar os dados no pai

39665
26:18:27,360 --> 26:18:30,000
e imprimir se os dados acontecerem

39666
26:18:30,000 --> 26:18:32,720
acessível a partir da nossa classe derivada e

39667
26:18:32,720 --> 26:18:34,720
É por isso que configuramos nossa variável de membro

39668
26:18:34,720 --> 26:18:37,512
ser protegido para que seja acessível

39669
26:18:37,512 --> 26:18:39,760
em nossas classes derivadas, isso vai

39670
26:18:39,760 --> 26:18:41,832
Permita-nos imprimir algo assim

39671
26:18:41,832 --> 26:18:44,000
E isso vai realmente funcionar agora

39672
26:18:44,000 --> 26:18:46,232
que temos isso no lugar em que podemos entrar

39673
26:18:46,232 --> 26:18:48,320
O arquivo principal do cpp

39674
26:18:48,320 --> 26:18:50,960
e apenas incluir a criança que podemos fazer

39675
26:18:50,960 --> 26:18:53,120
Isso e nós vamos criar uma criança

39676
26:18:53,120 --> 26:18:55,600
objeto ou podemos simplesmente tirar

39677
26:18:55,600 --> 26:18:57,440
Tudo aqui

39678
26:18:57,440 --> 26:18:59,440
e ajustar a colocação do código que podemos usar

39679
26:18:59,440 --> 26:19:01,912
para brincar com essas coisas que podemos criar

39680
26:19:01,912 --> 26:19:03,680
o objeto da criança

39681
26:19:03,680 --> 26:19:06,160
e nesta criança podemos imprimir para que possamos

39682
26:19:06,160 --> 26:19:07,680
Vou ver que os dados vão

39683
26:19:07,680 --> 26:19:10,080
ser impresso fora, mas também podemos usar isso

39684
26:19:10,080 --> 26:19:13,192
sintaxe para imprimir os dados no pai

39685
26:19:13,192 --> 26:19:14,800
parte de nós e vamos ver isso

39686
26:19:14,800 --> 26:19:17,120
os dados são impressos para fora que também podemos mostrar

39687
26:19:17,120 --> 26:19:20,160
os valores e certifique-se de que vemos isso

39688
26:19:20,160 --> 26:19:22,720
de um membro da função da criança

39689
26:19:22,720 --> 26:19:25,192
classe isto vai chamar este membro

39690
26:19:25,192 --> 26:19:26,800
e nós vamos chegar ao valor em

39691
26:19:26,800 --> 26:19:28,480
criança e nós vamos obter o valor

39692
26:19:28,480 --> 26:19:31,832
nos pais impressos no console agora

39693
26:19:31,832 --> 26:19:34,080
que temos isso, podemos realmente tentar

39694
26:19:34,080 --> 26:19:36,480
e trabalhar isso, vamos usar gcc para

39695
26:19:36,480 --> 26:19:37,512
- Faz isso.

39696
26:19:37,512 --> 26:19:39,680
nós vamos ver que nós vamos

39697
26:19:39,680 --> 26:19:42,160
acabamento construindo com erros o que é

39698
26:19:42,160 --> 26:19:44,320
O problema aqui temos um

39699
26:19:44,320 --> 26:19:46,872
Referência para crianças destruidores

39700
26:19:46,872 --> 26:19:49,192
Não fizemos uma definição para o

39701
26:19:49,192 --> 26:19:52,000
criança destruitor, então vamos lá

39702
26:19:52,000 --> 26:19:54,800
e padrão, podemos fazer o que somos

39703
26:19:54,800 --> 26:19:56,552
indo dizer igual a inadimplência e o

39704
26:19:56,552 --> 26:20:00,320
O compilador vai gerar um para nós

39705
26:20:00,320 --> 26:20:02,872
E agora, se construirmos, vamos construir

39706
26:20:02,872 --> 26:20:05,192
com gcc novamente o parafuso vai ser

39707
26:20:05,192 --> 26:20:08,000
Bom você pode limpar e correr galo e

39708
26:20:08,000 --> 26:20:09,512
nós vamos ver que o valor em

39709
26:20:09,512 --> 26:20:12,720
A criança tem 33 anos porque nós passamos isso em

39710
26:20:12,720 --> 26:20:15,360
explicitamente e isso vai chamar o

39711
26:20:15,360 --> 26:20:17,680
construtor que temos em criança que

39712
26:20:17,680 --> 26:20:20,232
Acontece que é esse cara aqui e você vê

39713
26:20:20,232 --> 26:20:22,400
que estamos realmente mantendo as coisas simples

39714
26:20:22,400 --> 26:20:24,480
Não estamos chamando o construtor de base

39715
26:20:24,480 --> 26:20:27,832
Aqui o compilador só vai chamar

39716
26:20:27,832 --> 26:20:30,232
o construtor padrão que temos em

39717
26:20:30,232 --> 26:20:32,552
pai aqui e isso vai apenas

39718
26:20:32,552 --> 26:20:34,480
A mensagem principal aqui é que você

39719
26:20:34,480 --> 26:20:37,600
pode configurar variáveis de membro e membro

39720
26:20:37,600 --> 26:20:40,800
funções nomeadas exatamente da mesma maneira em

39721
26:20:40,800 --> 26:20:43,192
A classe dos pais e nas classes infantis

39722
26:20:43,192 --> 26:20:45,360
e o que você tem em seu derivado

39723
26:20:45,360 --> 26:20:48,480
As aulas vão esconder o que temos

39724
26:20:48,480 --> 26:20:51,440
nossas aulas atuais, por isso, se chamarmos a

39725
26:20:51,440 --> 26:20:54,080
método em um objeto de criança, por exemplo

39726
26:20:54,080 --> 26:20:56,160
Como estamos fazendo aqui, isso vai

39727
26:20:56,160 --> 26:20:58,232
chamar o método em criança, mas nós ainda

39728
26:20:58,232 --> 26:21:00,480
ter a capacidade de chamar dados no

39729
26:21:00,480 --> 26:21:02,960
pai parte de nós e isso é o que fazemos

39730
26:21:02,960 --> 26:21:05,280
Aqui eu gostaria de recebê-lo neste

39731
26:21:05,280 --> 26:21:07,040
Novo capítulo onde vamos estar

39732
26:21:07,040 --> 26:21:09,760
aprender sobre polimorfismo e

39733
26:21:09,760 --> 26:21:12,800
O polimorfismo é a configuração que podemos fazer

39734
26:21:12,800 --> 26:21:15,280
nossos c plus programas

39735
26:21:15,280 --> 26:21:18,400
para usar um ponteiro base e gerenciar derivado

39736
26:21:18,400 --> 26:21:21,040
Objetos supõem que temos uma herança

39737
26:21:21,040 --> 26:21:23,192
hierarquia como temos aqui que temos

39738
26:21:23,192 --> 26:21:26,320
moldado como nossa classe base e nós podemos

39739
26:21:26,320 --> 26:21:28,872
Herdar do oval e criar um círculo

39740
26:21:28,872 --> 26:21:31,360
A classe imagine que podemos criar tudo

39741
26:21:31,360 --> 26:21:34,160
tipos de formas loucas que herdam de

39742
26:21:34,160 --> 26:21:36,400
forma em nosso programa de caminho mais simples para

39743
26:21:36,400 --> 26:21:38,320
exemplo, temos uma classe de retângulo, nós

39744
26:21:38,320 --> 26:21:40,400
ter uma classe triangular que temos todos os tipos

39745
26:21:40,400 --> 26:21:42,960
de formas loucas agora se tivermos isso

39746
26:21:42,960 --> 26:21:45,680
Hierarquia de herança aqui é algo

39747
26:21:45,680 --> 26:21:48,000
Podemos querer fazer, podemos querer definir

39748
26:21:48,000 --> 26:21:50,720
um ponteiro base que está gerenciando um

39749
26:21:50,720 --> 26:21:53,600
objeto derivado e configurar código como este

39750
26:21:53,600 --> 26:21:56,400
por exemplo, dizemos ponteiro de forma e i

39751
26:21:56,400 --> 26:21:58,480
configurar uma variável ponteiro aqui e usar

39752
26:21:58,480 --> 26:22:01,440
Este ponteiro para gerenciar um objeto circular

39753
26:22:01,440 --> 26:22:04,232
que alocamos dinamicamente para isso

39754
26:22:04,232 --> 26:22:07,120
linha aqui também podemos fazer um ponteiro de forma

39755
26:22:07,120 --> 26:22:09,600
que está gerenciando um rectângulo que podemos definir

39756
26:22:09,600 --> 26:22:11,512
um ponteiro de forma que está gerenciando um

39757
26:22:11,512 --> 26:22:14,232
Objeto novo que podemos realmente criar uma base

39758
26:22:14,232 --> 26:22:16,552
ponteiro que está gerenciando qualquer tipo de

39759
26:22:16,552 --> 26:22:19,192
Objeto que apoiamos em nossa herança

39760
26:22:19,192 --> 26:22:21,360
Hierarquia agora alguns de vocês vão

39761
26:22:21,360 --> 26:22:23,680
fazer umas perguntas, uma delas está indo

39762
26:22:23,680 --> 26:22:27,040
Esta é ainda legal c plus plus

39763
26:22:27,040 --> 26:22:30,320
A sintaxe e a resposta são sim porque se

39764
26:22:30,320 --> 26:22:33,440
O círculo é herdado de alguma forma da forma a

39765
26:22:33,440 --> 26:22:35,280
O círculo é realmente uma forma e se

39766
26:22:35,280 --> 26:22:37,912
O retângulo está herdando da forma que é

39767
26:22:37,912 --> 26:22:40,400
uma forma e se tentarmos atribuir um círculo

39768
26:22:40,400 --> 26:22:41,760
para uma forma, vamos ver isso

39769
26:22:41,760 --> 26:22:44,320
que vai funcionar, então isso é válido c

39770
26:22:44,320 --> 26:22:46,960
mais mais sintaxe e podemos fazer o mesmo

39771
26:22:46,960 --> 26:22:49,120
A coisa usando referências como vemos aqui

39772
26:22:49,120 --> 26:22:50,872
Pode criar uma referência que vai

39773
26:22:50,872 --> 26:22:52,400
estar gerenciando

39774
26:22:52,400 --> 26:22:55,120
Um objeto de círculo que temos através

39775
26:22:55,120 --> 26:22:57,512
círculo um, podemos estabelecer uma referência a

39776
26:22:57,512 --> 26:22:59,832
gerenciar um retângulo que temos em forma

39777
26:22:59,832 --> 26:23:02,320
dois podemos criar uma referência para gerenciar

39778
26:23:02,320 --> 26:23:04,640
Um objeto terrível podemos realmente fazer tudo

39779
26:23:04,640 --> 26:23:05,912
Essas coisas

39780
26:23:05,912 --> 26:23:08,160
Agora alguns de vocês estão perguntando

39781
26:23:08,160 --> 26:23:10,160
Por que queremos fazer algo como

39782
26:23:10,160 --> 26:23:12,480
Agora tente pensar sobre o seu

39783
26:23:12,480 --> 26:23:14,960
Hierarquia de herança aqui e tentar

39784
26:23:14,960 --> 26:23:17,600
Pense sobre o que se você quiser

39785
26:23:17,600 --> 26:23:20,080
desenhar este tipo de navio, por exemplo, se

39786
26:23:20,080 --> 26:23:22,800
Você não usou polimorfismo

39787
26:23:22,800 --> 26:23:24,960
precisa configurar todos os tipos de loucura

39788
26:23:24,960 --> 26:23:27,912
métodos para desenhar cada tipo de objeto e

39789
26:23:27,912 --> 26:23:29,912
Não temos como contornar isso porque estes

39790
26:23:29,912 --> 26:23:32,320
são tipos diferentes se você tem um método

39791
26:23:32,320 --> 26:23:34,480
que leva um romance e você passa em um

39792
26:23:34,480 --> 26:23:35,760
círculo que vai te dar um

39793
26:23:35,760 --> 26:23:38,400
erro do compilador, mas com o polimorfismo nós

39794
26:23:38,400 --> 26:23:40,480
pode configurar um único método que leva a

39795
26:23:40,480 --> 26:23:43,192
shape pointer ou uma referência de forma

39796
26:23:43,192 --> 26:23:45,680
e nós podemos passar em todos os tipos de loucos

39797
26:23:45,680 --> 26:23:48,640
objetos cuja classe deriva da forma

39798
26:23:48,640 --> 26:23:50,552
Por exemplo, podemos passar no endereço

39799
26:23:50,552 --> 26:23:52,232
do círculo e esta função está indo

39800
26:23:52,232 --> 26:23:54,232
para desenhar um círculo que podemos passar no

39801
26:23:54,232 --> 26:23:56,160
endereço de um retângulo isto vai

39802
26:23:56,160 --> 26:23:58,232
desenhar um retângulo que podemos passar no

39803
26:23:58,232 --> 26:24:00,080
endereço de um romance e isso vai

39804
26:24:00,080 --> 26:24:02,320
Desenhe um romance espero que você possa ver como

39805
26:24:02,320 --> 26:24:04,720
Isso é útil até mesmo podemos fazer isso usando

39806
26:24:04,720 --> 26:24:07,120
Referências como se passarmos em um retângulo

39807
26:24:07,120 --> 26:24:09,120
isso vai desenhar um retângulo se nós

39808
26:24:09,120 --> 26:24:11,360
passar em um círculo isso vai desenhar um

39809
26:24:11,360 --> 26:24:14,320
Círculo você tem a ideia de que este é um dos

39810
26:24:14,320 --> 26:24:17,120
os benefícios de usar novamente o polimorfismo

39811
26:24:17,120 --> 26:24:20,232
O polimorfismo é sobre o uso de classe base

39812
26:24:20,232 --> 26:24:23,512
ponteiros ou referências para gerenciar derivados

39813
26:24:23,512 --> 26:24:26,480
objetos em nossas hierarquias de herança

39814
26:24:26,480 --> 26:24:29,192
Outro benefício do polimorfismo é

39815
26:24:29,192 --> 26:24:31,512
permitir-nos poder armazenar

39816
26:24:31,512 --> 26:24:33,680
diferentes tipos de objetos em um único

39817
26:24:33,680 --> 26:24:36,552
Coleção lembre que um array pode armazenar

39818
26:24:36,552 --> 26:24:39,192
objetos de diferentes tipos se você disser

39819
26:24:39,192 --> 26:24:41,600
toque em uma matriz final e tente armazenar em um

39820
26:24:41,600 --> 26:24:43,192
string ou um duplo que você vai ter um

39821
26:24:43,192 --> 26:24:44,720
Erro do compilador porque não é

39822
26:24:44,720 --> 26:24:47,512
permitido se você tiver um array que é

39823
26:24:47,512 --> 26:24:49,912
indo para armazenar círculos que você não pode colocar

39824
26:24:49,912 --> 26:24:52,000
um romance que você não pode colocar em um retângulo você

39825
26:24:52,000 --> 26:24:54,872
pode colocar uma estrela que você não pode realmente fazer

39826
26:24:54,872 --> 26:24:57,760
porque um array por design está indo

39827
26:24:57,760 --> 26:25:00,480
para armazenar objetos do mesmo tipo, mas nós

39828
26:25:00,480 --> 26:25:02,552
pode evitar esta limitação usando

39829
26:25:02,552 --> 26:25:04,872
Polimorfismo novamente podemos criar um

39830
26:25:04,872 --> 26:25:07,760
array que vai armazenar classe base

39831
26:25:07,760 --> 26:25:10,552
ponteiros e nós podemos armazenar em todos os tipos

39832
26:25:10,552 --> 26:25:13,440
de objetos loucos cuja classe derivou

39833
26:25:13,440 --> 26:25:16,232
a partir desta classe base aqui, aqui podemos

39834
26:25:16,232 --> 26:25:18,232
armazenar em um objeto de círculo que podemos armazenar em

39835
26:25:18,232 --> 26:25:20,232
Um romance que podemos armazenar em qualquer tipo de

39836
26:25:20,232 --> 26:25:23,192
o objeto que faz parte da nossa herança

39837
26:25:23,192 --> 26:25:26,400
Hierarquia com a classe base como forma

39838
26:25:26,400 --> 26:25:28,160
E isso vai funcionar e isso é

39839
26:25:28,160 --> 26:25:29,832
usará polimorfismo para

39840
26:25:29,832 --> 26:25:31,360
exemplo se você olhar através disso

39841
26:25:31,360 --> 26:25:33,832
coleção chamando o método joe para

39842
26:25:33,832 --> 26:25:35,512
O primeiro elemento isso vai chamar

39843
26:25:35,512 --> 26:25:37,760
o método de desenho no círculo para o

39844
26:25:37,760 --> 26:25:39,192
segundo elemento, vamos chamar de

39845
26:25:39,192 --> 26:25:41,192
desenhar método em um romance e isso está indo

39846
26:25:41,192 --> 26:25:42,080
para ser

39847
26:25:42,080 --> 26:25:43,760
muito legal isso é algo que podemos

39848
26:25:43,760 --> 26:25:46,400
conseguir com polimorfismo e eu quero

39849
26:25:46,400 --> 26:25:48,552
Volte um pouco e fale sobre o que

39850
26:25:48,552 --> 26:25:50,640
é realmente entendido pelo polimorfismo

39851
26:25:50,640 --> 26:25:53,760
O polimorfismo realmente significa múltiplas formas

39852
26:25:53,760 --> 26:25:56,232
e, na minha opinião, o que isto significa é

39853
26:25:56,232 --> 26:25:58,720
que o ponteiro da classe base ou base

39854
26:25:58,720 --> 26:26:01,360
A referência de classe pode assumir várias formas

39855
26:26:01,360 --> 26:26:03,280
em um ponto, pode estar gerenciando um

39856
26:26:03,280 --> 26:26:05,360
círculo em um ponto que pode estar gerenciando

39857
26:26:05,360 --> 26:26:07,280
um retângulo em um ponto que pode ser

39858
26:26:07,280 --> 26:26:10,080
gerenciar um novo objeto para que seja um

39859
26:26:10,080 --> 26:26:13,192
ponteiro, mas pode assumir várias formas

39860
26:26:13,192 --> 26:26:14,960
porque ele pode estar gerenciando múltiplos

39861
26:26:14,960 --> 26:26:18,400
tipos de objetos cuja classe faz parte de

39862
26:26:18,400 --> 26:26:21,120
Nossa hierarquia de herança é isso que

39863
26:26:21,120 --> 26:26:23,512
queremos dizer por polimorfismo, então novamente o

39864
26:26:23,512 --> 26:26:25,680
A ideia é que podemos usar a classe base

39865
26:26:25,680 --> 26:26:27,832
ponteiro ou referência para gerenciar todos os tipos

39866
26:26:27,832 --> 26:26:30,400
de objetos loucos em nosso programa e isso

39867
26:26:30,400 --> 26:26:32,800
Vai ter muitos benefícios como nós

39868
26:26:32,800 --> 26:26:35,440
prestes a experimentar neste capítulo aqui

39869
26:26:35,440 --> 26:26:37,760
Estou realmente animado para explicar

39870
26:26:37,760 --> 26:26:39,832
Isso para você é um dos mais

39871
26:26:39,832 --> 26:26:42,400
características poderosas em c plus plus que somos

39872
26:26:42,400 --> 26:26:44,320
Começará na próxima palestra e

39873
26:26:44,320 --> 26:26:46,640
mostrar que você não tem polimorfismo

39874
26:26:46,640 --> 26:26:49,280
por padrão em c plus plus e que você

39875
26:26:49,280 --> 26:26:52,000
get is static binding vá em frente e

39876
26:26:52,000 --> 26:26:54,552
Termine aqui e me encontre lá

39877
26:26:54,552 --> 26:26:57,040
gerenciar objetos derivados em nosso c plus

39878
26:26:57,040 --> 26:26:59,440
além do programa, espero que isso vá

39879
26:26:59,440 --> 26:27:02,400
dar-lhe uma ideia clara sobre por que podemos

39880
26:27:02,400 --> 26:27:04,720
Precisamos fazer isso, então vamos olhar para o nosso

39881
26:27:04,720 --> 26:27:06,400
classes que vamos usar

39882
26:27:06,400 --> 26:27:08,232
Aqui vamos montar uma aula de forma

39883
26:27:08,232 --> 26:27:10,552
que vai representar o nosso

39884
26:27:10,552 --> 26:27:12,800
formas que isso vai ser a nossa base

39885
26:27:12,800 --> 26:27:15,360
classe que é o uso básico para isso aqui

39886
26:27:15,360 --> 26:27:17,360
tem uma variável de membro simples que é

39887
26:27:17,360 --> 26:27:20,000
vai armazenar a descrição para o nosso

39888
26:27:20,000 --> 26:27:22,720
forma também vai ter o nosso sorteio

39889
26:27:22,720 --> 26:27:24,640
método que realmente não vai desenhar

39890
26:27:24,640 --> 26:27:26,800
qualquer coisa que só vai dizer o

39891
26:27:26,800 --> 26:27:29,680
descrição para a nossa forma aqui uma vez

39892
26:27:29,680 --> 26:27:31,512
Temos esta forma que podemos criar outros

39893
26:27:31,512 --> 26:27:33,512
formas a partir dele, por exemplo, podemos criar

39894
26:27:33,512 --> 26:27:35,680
Uma nova classe que vai ser

39895
26:27:35,680 --> 26:27:38,080
representando uma forma como esta é

39896
26:27:38,080 --> 26:27:40,480
ter duas variáveis de membro um

39897
26:27:40,480 --> 26:27:43,192
vai ser o raio mx o outro é

39898
26:27:43,192 --> 26:27:45,512
vai ser o raio m y que pode

39899
26:27:45,512 --> 26:27:47,120
Representar

39900
26:27:47,120 --> 26:27:50,552
os raios para oval aqui para

39901
26:27:50,552 --> 26:27:53,120
exemplo, o raio x pode ser algo

39902
26:27:53,120 --> 26:27:55,360
Como este o raio y pode ser

39903
26:27:55,360 --> 26:27:57,040
Algo assim e é assim

39904
26:27:57,040 --> 26:27:59,192
nós vamos representar

39905
26:27:59,192 --> 26:28:01,512
Esta forma aqui também temos um empate

39906
26:28:01,512 --> 26:28:03,040
método que vai imprimir o

39907
26:28:03,040 --> 26:28:05,832
informações sobre essa forma aqui é

39908
26:28:05,832 --> 26:28:07,600
Vou dizer a descrição que nós somos

39909
26:28:07,600 --> 26:28:09,760
Vai herdar publicamente de

39910
26:28:09,760 --> 26:28:12,000
forma, mas também vai dizer o

39911
26:28:12,000 --> 26:28:14,480
informações de raio para esta forma é

39912
26:28:14,480 --> 26:28:17,280
vamos nos dar o raio x e o y

39913
26:28:17,280 --> 26:28:19,832
raio aqui e nós temos um monte de

39914
26:28:19,832 --> 26:28:21,760
construtores aqui temos um padrão

39915
26:28:21,760 --> 26:28:23,512
construtor que realmente não vai

39916
26:28:23,512 --> 26:28:25,832
fazer qualquer coisa que também temos um construtor

39917
26:28:25,832 --> 26:28:27,360
que vai levar dois

39918
26:28:27,360 --> 26:28:30,552
parâmetros para encaminhar os dados em nosso

39919
26:28:30,552 --> 26:28:32,960
variáveis de membro aqui este é o tipo

39920
26:28:32,960 --> 26:28:34,872
de classe que vamos estabelecer em nosso

39921
26:28:34,872 --> 26:28:37,600
programa também temos outro derivado

39922
26:28:37,600 --> 26:28:40,552
classe do oval e isso vai ser

39923
26:28:40,552 --> 26:28:42,912
uma classe de círculo que vai ser um

39924
26:28:42,912 --> 26:28:47,192
especialização no oval em que ambos x

39925
26:28:47,192 --> 26:28:50,552
e o raio y são iguais assim que o raio x

39926
26:28:50,552 --> 26:28:52,480
Vai ser algo assim e

39927
26:28:52,480 --> 26:28:54,552
O y raio vai ser algo

39928
26:28:54,552 --> 26:28:57,360
assim e ambos vão

39929
26:28:57,360 --> 26:28:59,912
ser igual, então isso vai nos dar um

39930
26:28:59,912 --> 26:29:02,720
forma do círculo também temos um método de desenho

39931
26:29:02,720 --> 26:29:05,040
que vai imprimir a descrição

39932
26:29:05,040 --> 26:29:07,912
e o raio que podemos realmente escolher qualquer

39933
26:29:07,912 --> 26:29:10,320
raio que podemos escolher o raio x que podemos

39934
26:29:10,320 --> 26:29:12,400
escolha o y radius que eles estão realmente indo

39935
26:29:12,400 --> 26:29:14,552
ser o mesmo porque eles são iguais

39936
26:29:14,552 --> 26:29:17,360
para a nossa forma de círculo também temos um

39937
26:29:17,360 --> 26:29:19,120
simples construtor que vai

39938
26:29:19,120 --> 26:29:21,600
tomar o raio e nós vamos ser

39939
26:29:21,600 --> 26:29:23,440
usando este raio

39940
26:29:23,440 --> 26:29:26,800
para encaminhar os dados para a nossa parte oval de

39941
26:29:26,800 --> 26:29:29,440
Nós e nós vamos definir isso como

39942
26:29:29,440 --> 26:29:32,160
ambos x e y raio esta é a configuração que nós

39943
26:29:32,160 --> 26:29:34,640
Tenho aqui ok agora que temos o nosso

39944
26:29:34,640 --> 26:29:37,040
Hierarquia de herança que vamos tentar

39945
26:29:37,040 --> 26:29:39,600
e usá-lo e realmente explorar a ideia

39946
26:29:39,600 --> 26:29:42,400
de ligação estática em c plus plus

39947
26:29:42,400 --> 26:29:45,040
hierarquias de herança, então aqui estamos

39948
26:29:45,040 --> 26:29:47,040
Tentando criar simples

39949
26:29:47,040 --> 26:29:50,160
Objetos de nossas classes temos uma forma

39950
26:29:50,160 --> 26:29:52,640
Objeto temos um objeto oval e nós

39951
26:29:52,640 --> 26:29:55,440
ter um objeto de círculo, vamos embora

39952
26:29:55,440 --> 26:29:58,480
através de um ponteiro base e tentar gerenciar

39953
26:29:58,480 --> 26:30:00,160
Os nossos objetos aqui

39954
26:30:00,160 --> 26:30:02,000
em nossa primeira linha, vamos montar

39955
26:30:02,000 --> 26:30:03,832
um ponteiro de forma e vamos armazenar

39956
26:30:03,832 --> 26:30:06,872
no endereço da forma um e no que nós

39957
26:30:06,872 --> 26:30:09,760
Gostaria que em nosso c plus programa é

39958
26:30:09,760 --> 26:30:12,720
que se chamarmos o método draw sobre isso

39959
26:30:12,720 --> 26:30:15,192
shape pointer nós queremos a forma

39960
26:30:15,192 --> 26:30:17,680
desenhar método a ser chamado porque temos

39961
26:30:17,680 --> 26:30:20,552
um objeto de forma armazenado em nossa base

39962
26:30:20,552 --> 26:30:22,960
ponteiro aqui ou em outras palavras, estamos

39963
26:30:22,960 --> 26:30:25,912
usando um ponteiro base para gerenciar isso

39964
26:30:25,912 --> 26:30:28,552
objeto na memória aqui em baixo nós armazenamos um

39965
26:30:28,552 --> 26:30:32,080
objeto novo em nosso ponteiro de forma ou em

39966
26:30:32,080 --> 26:30:34,080
Outras palavras, vamos usar isso

39967
26:30:34,080 --> 26:30:37,360
ponteiro base para gerenciar um oval real

39968
26:30:37,360 --> 26:30:40,000
objeto na memória e a configuração que queremos

39969
26:30:40,000 --> 26:30:42,480
é isso se chamarmos o método de desenho em

39970
26:30:42,480 --> 26:30:44,872
Este ponteiro de forma agora nós vamos

39971
26:30:44,872 --> 26:30:47,832
obter o método de desenho oval para ser chamado

39972
26:30:47,832 --> 26:30:49,832
Esta é a configuração que queremos

39973
26:30:49,832 --> 26:30:52,080
E aqui em baixo temos outro exemplo

39974
26:30:52,080 --> 26:30:54,640
onde estamos usando este ponteiro base para

39975
26:30:54,640 --> 26:30:57,680
gerenciar um objeto de círculo para onde vamos

39976
26:30:57,680 --> 26:31:00,080
Armazenar o endereço do objeto do círculo

39977
26:31:00,080 --> 26:31:02,000
Neste ponto base, é assim que fazemos

39978
26:31:02,000 --> 26:31:04,480
Isso e quando nós chamamos

39979
26:31:04,480 --> 26:31:07,760
um método de desenho neste ponteiro base

39980
26:31:07,760 --> 26:31:10,552
Quer que o método de desenho do círculo seja chamado

39981
26:31:10,552 --> 26:31:13,912
Então com o polimorfismo o que realmente queremos

39982
26:31:13,912 --> 26:31:18,160
é chamar um método no ponteiro base

39983
26:31:18,160 --> 26:31:20,640
e obter o mais específico possível

39984
26:31:20,640 --> 26:31:23,360
Método chamado nosso ponteiro, este é o

39985
26:31:23,360 --> 26:31:25,600
Configuração que queremos, mas não é isso que nós

39986
26:31:25,600 --> 26:31:28,400
obter por padrão em c plus plus se nós

39987
26:31:28,400 --> 26:31:31,192
acontecer para fazer isso e executar o nosso programa como

39988
26:31:31,192 --> 26:31:33,760
Agora é com o conhecimento atual de que

39989
26:31:33,760 --> 26:31:36,080
Temos na primeira linha aqui que estamos

39990
26:31:36,080 --> 26:31:37,832
vai obter o método de desenho de forma

39991
26:31:37,832 --> 26:31:40,000
Chamamos isto é o que queremos, mas no

39992
26:31:40,000 --> 26:31:42,000
Segundo exemplo aqui veremos que

39993
26:31:42,000 --> 26:31:44,720
ver o método de desenho de forma também chamado

39994
26:31:44,720 --> 26:31:47,280
E nesta linha também veremos que

39995
26:31:47,280 --> 26:31:49,512
nós temos o método de desenho de forma a ser

39996
26:31:49,512 --> 26:31:52,080
Chamamos isso não é o que queremos e isso

39997
26:31:52,080 --> 26:31:54,960
É ligação estática, então o que está acontecendo

39998
26:31:54,960 --> 26:31:58,000
Aqui está o compilador olhando para o

39999
26:31:58,000 --> 26:32:00,872
tipo do ponteiro e está usando isso

40000
26:32:00,872 --> 26:32:03,912
para decidir qual método de sorteio chamar assim

40001
26:32:03,912 --> 26:32:06,080
o compilador é assim que o compilador é

40002
26:32:06,080 --> 26:32:08,960
basicamente dizendo que eu tenho um ponteiro de forma

40003
26:32:08,960 --> 26:32:11,440
então eu vou chamar o método joe em

40004
26:32:11,440 --> 26:32:14,080
A classe de forma aqui vai

40005
26:32:14,080 --> 26:32:16,960
Veja que ele também tem um ponteiro de forma e

40006
26:32:16,960 --> 26:32:19,512
ele vai chamar o método de desenho em

40007
26:32:19,512 --> 26:32:22,080
forma e aqui vai ver

40008
26:32:22,080 --> 26:32:24,552
que tem um ponteiro de forma e é

40009
26:32:24,552 --> 26:32:27,040
Vou chamar o método da mandíbula no

40010
26:32:27,040 --> 26:32:30,000
classe de forma esta é a ligação estática

40011
26:32:30,000 --> 26:32:31,760
É tudo sobre o compilador vai

40012
26:32:31,760 --> 26:32:35,360
resolver o método joe estaticamente e

40013
26:32:35,360 --> 26:32:37,680
O que isso significa é que o compilador é

40014
26:32:37,680 --> 26:32:39,680
Vou olhar para o tipo do ponteiro

40015
26:32:39,680 --> 26:32:42,320
que temos e vai usar isso

40016
26:32:42,320 --> 26:32:46,000
para decidir qual método de joe chamar

40017
26:32:46,000 --> 26:32:48,720
nossa hierarquia de herança, então esta é a

40018
26:32:48,720 --> 26:32:51,040
padrão e é chamado de ligação estática

40019
26:32:51,040 --> 26:32:53,360
em c plus plus também temos o mesmo

40020
26:32:53,360 --> 26:32:55,760
comportamento se tentarmos usar uma base

40021
26:32:55,760 --> 26:32:58,640
referência para gerenciar nosso objeto real em

40022
26:32:58,640 --> 26:33:01,192
Memória aqui temos os mesmos tipos de

40023
26:33:01,192 --> 26:33:04,232
objetos que tínhamos em um slide anterior e

40024
26:33:04,232 --> 26:33:07,512
Estamos usando uma referência de base para gerenciar

40025
26:33:07,512 --> 26:33:10,640
nosso objetivo e o que realmente queremos é

40026
26:33:10,640 --> 26:33:13,280
que se passarmos por uma referência de base

40027
26:33:13,280 --> 26:33:16,160
para chamar o nosso método de sorteio, vamos obter o

40028
26:33:16,160 --> 26:33:19,512
método de desenho mais específico chamado se

40029
26:33:19,512 --> 26:33:22,080
nossa referência básica está gerenciando uma forma

40030
26:33:22,080 --> 26:33:24,872
nós obteremos o método de desenho de forma chamado

40031
26:33:24,872 --> 26:33:27,440
se a nossa referência básica está gerenciando um

40032
26:33:27,440 --> 26:33:30,000
Objeto alfa nós queremos o desenho oval

40033
26:33:30,000 --> 26:33:33,360
método para ser chamado aqui e se nossa base

40034
26:33:33,360 --> 26:33:36,320
referência é gerenciar um objeto de círculo nós

40035
26:33:36,320 --> 26:33:39,440
Quer o ciclo joe método chamado aqui

40036
26:33:39,440 --> 26:33:41,280
Isto é o que queremos, mas novamente o

40037
26:33:41,280 --> 26:33:43,192
O compilador só vai olhar para o

40038
26:33:43,192 --> 26:33:45,512
Tipo da referência para a primeira

40039
26:33:45,512 --> 26:33:47,360
linha aqui vai dizer que eu tenho um

40040
26:33:47,360 --> 26:33:50,000
Referência de forma para que eu vou chamar

40041
26:33:50,000 --> 26:33:51,912
o método de desenho de forma que é o que somos

40042
26:33:51,912 --> 26:33:54,320
Vai chegar aqui na segunda linha

40043
26:33:54,320 --> 26:33:56,160
Aqui vai dizer uh-huh eu tenho um

40044
26:33:56,160 --> 26:33:59,040
Referência de forma para que eu vou chamar

40045
26:33:59,040 --> 26:34:01,040
o método de desenho da classe de forma

40046
26:34:01,040 --> 26:34:02,400
Isso é o que vamos ver aqui

40047
26:34:02,400 --> 26:34:04,872
padrão e nesta linha aqui é

40048
26:34:04,872 --> 26:34:07,360
Vou dizer que eu tenho uma referência de forma, então

40049
26:34:07,360 --> 26:34:09,512
Eu vou chamar o método draw em

40050
26:34:09,512 --> 26:34:11,360
A classe de forma e este é o comportamento

40051
26:34:11,360 --> 26:34:14,400
nós olhemos por padrão e isso é estático

40052
26:34:14,400 --> 26:34:16,960
Ligação em ação ok, então agora que nós

40053
26:34:16,960 --> 26:34:19,040
Já viram o que é a ligação estática é tudo

40054
26:34:19,040 --> 26:34:22,480
sobre vamos reexaminar a ideia de por que

40055
26:34:22,480 --> 26:34:24,960
Precisamos de polimorfismo e eu vou

40056
26:34:24,960 --> 26:34:26,640
dar-lhe um exemplo aqui suponha

40057
26:34:26,640 --> 26:34:29,120
Temos um monte de formas em que conseguimos

40058
26:34:29,120 --> 26:34:32,080
nossos programas e queremos desenhar todos

40059
26:34:32,080 --> 26:34:34,552
essas formas se quisermos desenhar um círculo

40060
26:34:34,552 --> 26:34:37,120
com a configuração atual que temos, nós gostaríamos

40061
26:34:37,120 --> 26:34:39,360
configurar um método de círculo de desenho se quisermos

40062
26:34:39,360 --> 26:34:41,360
para desenhar um romance que precisaríamos criar

40063
26:34:41,360 --> 26:34:44,000
um método de draw over e isso chamará

40064
26:34:44,000 --> 26:34:46,232
nosso círculo desencadeia o método e isso irá

40065
26:34:46,232 --> 26:34:48,960
chamar o nosso método oval joe isso está indo

40066
26:34:48,960 --> 26:34:51,120
para fazer o que queremos, mas tente pensar

40067
26:34:51,120 --> 26:34:54,160
sobre isso se tivermos 100 formas em nosso

40068
26:34:54,160 --> 26:34:57,832
programa que precisaremos para configurar 100 desses

40069
26:34:57,832 --> 26:34:59,600
métodos e isso é uma bagunça, eu não acho

40070
26:34:59,600 --> 26:35:01,760
Você quer fazer algo assim

40071
26:35:01,760 --> 26:35:04,400
e nós temos outro caso simples que eu

40072
26:35:04,400 --> 26:35:06,720
Quero que você considere supor que queremos

40073
26:35:06,720 --> 26:35:10,000
armazenar todos esses objetos em coleções

40074
26:35:10,000 --> 26:35:12,000
e vamos usar um array para tentar

40075
26:35:12,000 --> 26:35:14,800
e dirigir este ponto para casa aqui se nós

40076
26:35:14,800 --> 26:35:16,720
Quero armazenar esses caras em coleções

40077
26:35:16,720 --> 26:35:18,160
Precisamos criar diferentes

40078
26:35:18,160 --> 26:35:21,912
coleções porque como nós temos agora nós

40079
26:35:21,912 --> 26:35:24,800
Não é possível armazenar tipos diferentes em um array

40080
26:35:24,800 --> 26:35:27,120
Então, o que precisaríamos fazer agora é

40081
26:35:27,120 --> 26:35:29,832
configurar um array para círculos e configurar

40082
26:35:29,832 --> 26:35:32,640
uma matriz para ovais e fazer mais

40083
26:35:32,640 --> 26:35:34,480
coleções para diferentes tipos de

40084
26:35:34,480 --> 26:35:36,720
formas que apoiamos no nosso programa

40085
26:35:36,720 --> 26:35:38,872
E se quisermos desenhá-los, não temos

40086
26:35:38,872 --> 26:35:40,872
escolha, mas para configurar diferentes tipos de

40087
26:35:40,872 --> 26:35:43,192
loops e cada um desses loops está indo

40088
26:35:43,192 --> 26:35:44,960
estar em loop em cada um destes

40089
26:35:44,960 --> 26:35:47,040
Coleções aqui espero que você possa ver

40090
26:35:47,040 --> 26:35:49,040
que isso é por design que não queremos

40091
26:35:49,040 --> 26:35:51,360
Fazemos isso, queremos montar algo que

40092
26:35:51,360 --> 26:35:53,192
é realmente mais fácil de gerenciar em nossa

40093
26:35:53,192 --> 26:35:56,552
O programa e o polimorfismo foram

40094
26:35:56,552 --> 26:35:59,040
e polimorfismo e c mais plus foi

40095
26:35:59,040 --> 26:36:02,320
projetado para resolver exatamente esse tipo de

40096
26:36:02,320 --> 26:36:03,280
Problema

40097
26:36:03,280 --> 26:36:05,040
O que realmente queremos em nosso c plus mais

40098
26:36:05,040 --> 26:36:08,160
Programas é configurar um método de sorteio

40099
26:36:08,160 --> 26:36:10,160
Por exemplo, podemos dar-lhe uma base

40100
26:36:10,160 --> 26:36:12,720
ponteiro e não importa qual tipo

40101
26:36:12,720 --> 26:36:15,280
do objeto, passamos quando chamamos isso de

40102
26:36:15,280 --> 26:36:17,760
nós vamos fazer com que esse método seja chamado

40103
26:36:17,760 --> 26:36:20,872
Tempo de execução quando realmente precisamos desenhar

40104
26:36:20,872 --> 26:36:23,192
Esta forma se passarmos em um círculo

40105
26:36:23,192 --> 26:36:25,280
vai desenhar o método de desenho em um

40106
26:36:25,280 --> 26:36:28,800
círculo se passarmos em um romance, ele vai

40107
26:36:28,800 --> 26:36:32,000
chamar o método de desenho em nosso objeto oval

40108
26:36:32,000 --> 26:36:34,552
se passarmos em um retângulo, por exemplo

40109
26:36:34,552 --> 26:36:36,800
vai chamar o método de desenho em nosso

40110
26:36:36,800 --> 26:36:39,192
Objeto rectangle este é o que queremos

40111
26:36:39,192 --> 26:36:41,280
também quero o mesmo tipo de configuração se

40112
26:36:41,280 --> 26:36:43,040
exemplo, nossas funções estão tomando

40113
26:36:43,040 --> 26:36:44,800
referência e isso é o que estamos indo

40114
26:36:44,800 --> 26:36:46,960
Para obter isso é o que queremos com

40115
26:36:46,960 --> 26:36:49,280
O polimorfismo e isso realmente vai

40116
26:36:49,280 --> 26:36:51,760
Melhorar o design que tivemos

40117
26:36:51,760 --> 26:36:54,320
Mais cedo, quando precisávamos criar um

40118
26:36:54,320 --> 26:36:56,640
método específico para cada forma e nós

40119
26:36:56,640 --> 26:36:58,640
acabaria com centenas de empate

40120
26:36:58,640 --> 26:37:00,960
métodos e isso é realmente ruim, não é

40121
26:37:00,960 --> 26:37:02,960
gerenciável, isso também vai resolver

40122
26:37:02,960 --> 26:37:05,360
nosso problema com as coleções

40123
26:37:05,360 --> 26:37:07,600
nós realmente precisamos criar uma coleção

40124
26:37:07,600 --> 26:37:09,760
que vai levar em conta

40125
26:37:09,760 --> 26:37:12,480
todos os navios que administramos em nosso

40126
26:37:12,480 --> 26:37:15,280
hierarquia de herança para que a configuração que fazemos

40127
26:37:15,280 --> 26:37:16,640
É algo assim que nós vamos

40128
26:37:16,640 --> 26:37:18,552
configurar uma matriz que vai ser

40129
26:37:18,552 --> 26:37:21,440
armazenando ponteiros para moldar e nós podemos

40130
26:37:21,440 --> 26:37:24,320
loja no endereço de uma forma que podemos

40131
26:37:24,320 --> 26:37:26,400
loja no endereço de um romance que podemos

40132
26:37:26,400 --> 26:37:28,080
Armazenar no endereço do círculo

40133
26:37:28,080 --> 26:37:30,000
porque se você realmente pensar sobre isso a

40134
26:37:30,000 --> 26:37:32,080
O círculo é uma forma que um romance é a forma

40135
26:37:32,080 --> 26:37:33,912
e a forma é a forma, então isso é

40136
26:37:33,912 --> 26:37:36,720
indo para o trabalho e quando chegamos ao loop

40137
26:37:36,720 --> 26:37:38,552
através desta coleção e chamar o

40138
26:37:38,552 --> 26:37:41,192
método de desenho para o primeiro item aqui

40139
26:37:41,192 --> 26:37:43,440
vai chamar o método de desenho na forma

40140
26:37:43,440 --> 26:37:45,512
para o segundo elemento aqui vamos chamar

40141
26:37:45,512 --> 26:37:48,960
o método joe no objeto oval e

40142
26:37:48,960 --> 26:37:51,040
para o terceiro elemento aqui vamos chamar

40143
26:37:51,040 --> 26:37:54,000
o método de desenho em nosso objeto circular e

40144
26:37:54,000 --> 26:37:56,400
Vamos desenhar uma forma de romance e um

40145
26:37:56,400 --> 26:37:59,120
círculo com apenas um loop e este é

40146
26:37:59,120 --> 26:38:01,440
Realmente legal este é o design que queremos

40147
26:38:01,440 --> 26:38:03,680
Agora este não é o comportamento padrão que nós

40148
26:38:03,680 --> 26:38:06,232
entrar em nossos c plus mais classes se definirmos

40149
26:38:06,232 --> 26:38:08,400
uma hierarquia de herança

40150
26:38:08,400 --> 26:38:10,800
com nossos métodos de desenho que o que nós oceimos

40151
26:38:10,800 --> 26:38:13,440
o padrão é a ligação estática, mas nós vamos

40152
26:38:13,440 --> 26:38:16,640
ver como podemos obter ligação dinâmica ou

40153
26:38:16,640 --> 26:38:19,192
Polimorfismo na próxima palestra para

40154
26:38:19,192 --> 26:38:20,872
Este vamos explorar a estática

40155
26:38:20,872 --> 26:38:22,640
amarrar e nós vamos ir para

40156
26:38:22,640 --> 26:38:24,552
código de estúdio visual e jogar com a gente um

40157
26:38:24,552 --> 26:38:27,192
Pouco mais aqui estamos em nosso trabalho

40158
26:38:27,192 --> 26:38:29,440
pasta do projeto atual é estático

40159
26:38:29,440 --> 26:38:32,232
Ligação com a herança que vamos

40160
26:38:32,232 --> 26:38:35,040
Pegue nossos arquivos de modelo que isso vai

40161
26:38:35,040 --> 26:38:37,360
ser o nosso ponto de partida aqui estamos indo

40162
26:38:37,360 --> 26:38:40,232
para colocar nesses arquivos e eu vou

40163
26:38:40,232 --> 26:38:42,872
colocar em nossas aulas para economizar tempo

40164
26:38:42,872 --> 26:38:44,640
Se você quiser, você pode fazer o download destes

40165
26:38:44,640 --> 26:38:47,192
classes do anexo

40166
26:38:47,192 --> 26:38:48,960
seção de recursos sobre esta palestra que você é

40167
26:38:48,960 --> 26:38:50,800
indo para encontrá-los e você pode usá-los

40168
26:38:50,800 --> 26:38:52,800
Como ponto de partida, isso vai

40169
26:38:52,800 --> 26:38:54,872
Salve-nos alguns segundos porque não

40170
26:38:54,872 --> 26:38:56,960
Eu realmente quero digitar essas aulas

40171
26:38:56,960 --> 26:38:59,192
já sabe como criar aulas se

40172
26:38:59,192 --> 26:39:02,232
você fez isso até aqui no curso, então eu

40173
26:39:02,232 --> 26:39:04,640
Vou arrastar isso e cair aqui para

40174
26:39:04,640 --> 26:39:07,040
aberto em código de estúdio visual e isso é

40175
26:39:07,040 --> 26:39:08,720
Vamos nos dar um bom ponto de partida

40176
26:39:08,720 --> 26:39:11,440
Aqui temos uma classe base que é nossa

40177
26:39:11,440 --> 26:39:13,760
classe de forma que vai ter um simples

40178
26:39:13,760 --> 26:39:15,832
variável membro que vai ser o

40179
26:39:15,832 --> 26:39:18,552
descrição de uma coisa que eu acho que precisamos

40180
26:39:18,552 --> 26:39:21,280
melhorar isso é usar uma exibição de string

40181
26:39:21,280 --> 26:39:23,760
para passar o nosso parâmetro aqui

40182
26:39:23,760 --> 26:39:26,640
então vamos incluir a visão de string que podemos

40183
26:39:26,640 --> 26:39:28,400
Inclua que aqui vamos dizer

40184
26:39:28,400 --> 26:39:31,120
incluir a visão de string porque estamos usando

40185
26:39:31,120 --> 26:39:32,872
moderno c plus plus e nós vamos

40186
26:39:32,872 --> 26:39:36,480
mudar isso para ser uma visão de string sdd por

40187
26:39:36,480 --> 26:39:39,192
valor, podemos fazer isso ok para que tenhamos o nosso

40188
26:39:39,192 --> 26:39:41,680
classe aqui e temos um método de desenho

40189
26:39:41,680 --> 26:39:43,512
O que realmente não vai fazer nada

40190
26:39:43,512 --> 26:39:45,280
especial vai apenas imprimir o

40191
26:39:45,280 --> 26:39:47,512
descrição aqui e nós vamos ver

40192
26:39:47,512 --> 26:39:50,720
ele impresso no fluxo de saída

40193
26:39:50,720 --> 26:39:53,760
Se olharmos para o arquivo cpp apenas temos

40194
26:39:53,760 --> 26:39:56,080
uma implementação do nosso construtor e

40195
26:39:56,080 --> 26:39:58,720
Temos um destruidor que vamos consertar

40196
26:39:58,720 --> 26:40:01,680
nosso parâmetro aqui para torná-lo um std

40197
26:40:01,680 --> 26:40:05,192
string view, vamos olhar para a nossa classe oval

40198
26:40:05,192 --> 26:40:06,720
Vai ser

40199
26:40:06,720 --> 26:40:09,440
derivando publicamente da forma

40200
26:40:09,440 --> 26:40:11,600
e temos um monte de variáveis de membros

40201
26:40:11,600 --> 26:40:13,760
Aqui dois para ser exato um vai ser

40202
26:40:13,760 --> 26:40:16,160
O raio x o outro vai ser

40203
26:40:16,160 --> 26:40:19,360
nosso raio y temos um construtor aqui

40204
26:40:19,360 --> 26:40:21,120
que vai tomar três

40205
26:40:21,120 --> 26:40:24,232
Parâmetros dois parâmetros para os dados

40206
26:40:24,232 --> 26:40:28,400
para o nosso raio aqui e nós temos um

40207
26:40:28,400 --> 26:40:30,480
terceiro parâmetro que vai armazenar

40208
26:40:30,480 --> 26:40:33,120
nossos dados de descrição também vamos

40209
26:40:33,120 --> 26:40:36,400
mudar isso para bstd string view e isso

40210
26:40:36,400 --> 26:40:38,960
Vamos fazer nós temos um método de sorteio

40211
26:40:38,960 --> 26:40:41,040
que vai imprimir o

40212
26:40:41,040 --> 26:40:44,480
descrição e nossos dados de raio e isso

40213
26:40:44,480 --> 26:40:46,552
É realmente que nós não precisamos de nada

40214
26:40:46,552 --> 26:40:50,232
fantasia aqui vamos olhar para o nosso oval cpp

40215
26:40:50,232 --> 26:40:51,832
arquivo que vai ter o

40216
26:40:51,832 --> 26:40:54,400
Implementação para o nosso construtor

40217
26:40:54,400 --> 26:40:56,400
e o nosso destruidor aqui

40218
26:40:56,400 --> 26:40:59,440
Só precisamos mudar o tipo para o nosso

40219
26:40:59,440 --> 26:41:01,912
descrição aqui e fazer disso um esdd

40220
26:41:01,912 --> 26:41:04,400
string view vamos fazer isso e nós vamos

40221
26:41:04,400 --> 26:41:06,960
Olhe para a nossa classe de círculo que está indo

40222
26:41:06,960 --> 26:41:10,000
Estar herdando de

40223
26:41:10,000 --> 26:41:12,640
publicamente não terá nenhum membro

40224
26:41:12,640 --> 26:41:14,232
variável porque ele está apenas indo para

40225
26:41:14,232 --> 26:41:18,000
encaminhar os dados para o portoverso

40226
26:41:18,000 --> 26:41:20,360
Realmente não precisa fazer qualquer outro

40227
26:41:20,360 --> 26:41:23,040
especialização, mas o que precisamos é de

40228
26:41:23,040 --> 26:41:24,552
método que vai devolver o

40229
26:41:24,552 --> 26:41:26,480
raio porque queremos imprimir isso

40230
26:41:26,480 --> 26:41:30,080
Aqui para que possamos ir em nosso oval

40231
26:41:30,080 --> 26:41:33,040
classe e configurar uma seção protegida

40232
26:41:33,040 --> 26:41:34,960
que vai nos dar esses métodos

40233
26:41:34,960 --> 26:41:36,960
Aqui, então eu só vou colocá-los

40234
26:41:36,960 --> 26:41:39,440
Aqui para economizar em algum tempo

40235
26:41:39,440 --> 26:41:41,680
protegido porque queremos que isso seja

40236
26:41:41,680 --> 26:41:44,720
utilizáveis em classes derivadas, mas nós não

40237
26:41:44,720 --> 26:41:47,512
Quer que isso seja utilizável do lado de fora

40238
26:41:47,512 --> 26:41:49,600
é a configuração que podemos alcançar fazendo

40239
26:41:49,600 --> 26:41:52,480
Estes caras protegidos aqui têm x rad é

40240
26:41:52,480 --> 26:41:55,512
indo para retornar o raio x obter y rad

40241
26:41:55,512 --> 26:41:57,832
vai retornar o raio y que eles são

40242
26:41:57,832 --> 26:42:00,080
Const porque não pretendemos isso

40243
26:42:00,080 --> 26:42:03,360
para modificar nosso objeto e se formos em nosso

40244
26:42:03,360 --> 26:42:06,320
classe de círculo isso vai funcionar agora

40245
26:42:06,320 --> 26:42:08,800
Nós seremos capazes de imprimir o nosso

40246
26:42:08,800 --> 26:42:11,360
informações sobre o nosso objeto circular e nós

40247
26:42:11,360 --> 26:42:14,800
veremos em nosso fluxo de saída se olharmos

40248
26:42:14,800 --> 26:42:17,040
na implementação do nosso círculo

40249
26:42:17,040 --> 26:42:19,680
classe, não é nada complicado, é

40250
26:42:19,680 --> 26:42:22,160
apenas indo para tomar o raio duplo e

40251
26:42:22,160 --> 26:42:24,232
vai encaminhar os dados para o

40252
26:42:24,232 --> 26:42:27,680
uma parte oval de nós e nossa descrição aqui

40253
26:42:27,680 --> 26:42:29,832
Vai ter que mudar

40254
26:42:29,832 --> 26:42:32,480
para levar em conta que queremos usar

40255
26:42:32,480 --> 26:42:34,800
std string view aqui, então vamos mudar

40256
26:42:34,800 --> 26:42:38,960
esta vista de string a bhd podemos fazer aquilo

40257
26:42:38,960 --> 26:42:42,160
e nós vamos ir em nosso cpp

40258
26:42:42,160 --> 26:42:45,600
arquivo e alterar isso também string std

40259
26:42:45,600 --> 26:42:48,552
Você pode fazer isso e agora nossas aulas

40260
26:42:48,552 --> 26:42:51,040
são realmente completos, podemos ir para dentro

40261
26:42:51,040 --> 26:42:54,480
nosso arquivo cpp principal podemos limpar que

40262
26:42:54,480 --> 26:42:56,160
Pouco e vamos remover

40263
26:42:56,160 --> 26:42:58,080
O que não precisamos aqui

40264
26:42:58,080 --> 26:43:00,160
Vamos incluir nossas aulas, então

40265
26:43:00,160 --> 26:43:02,232
nós vamos incluir a forma, vamos fazer

40266
26:43:02,232 --> 26:43:03,040
que

40267
26:43:03,040 --> 26:43:05,832
nós vamos colocar no oval, vamos fazer

40268
26:43:05,832 --> 26:43:09,280
esse oval dot h e vamos colocar

40269
26:43:09,280 --> 26:43:11,440
em círculo e vamos criar

40270
26:43:11,440 --> 26:43:13,512
objetos dessas classes e tentar

40271
26:43:13,512 --> 26:43:15,760
imprimir suas informações para que vamos

40272
26:43:15,760 --> 26:43:18,000
para configurar uma forma chamada forma uma

40273
26:43:18,000 --> 26:43:19,512
Vamos criar um romance chamado

40274
26:43:19,512 --> 26:43:21,600
oval um nós vamos montar um círculo

40275
26:43:21,600 --> 26:43:23,360
chamado de círculo um e nós vamos ver

40276
26:43:23,360 --> 26:43:25,832
Que tipo de informação vemos

40277
26:43:25,832 --> 26:43:28,720
Se tentarmos chamar o método de trabalho novamente

40278
26:43:28,720 --> 26:43:30,640
em forma o método de desenho está apenas indo

40279
26:43:30,640 --> 26:43:33,512
para dizer que estamos chamando de shape joe

40280
26:43:33,512 --> 26:43:35,600
No alvo, vamos dizer que estamos

40281
26:43:35,600 --> 26:43:38,000
desenhando um oval e vamos dizer

40282
26:43:38,000 --> 26:43:40,640
A descrição e o raio no círculo

40283
26:43:40,640 --> 26:43:42,320
nós vamos dizer que estamos chamando

40284
26:43:42,320 --> 26:43:44,800
o método de desenho no objeto do círculo e

40285
26:43:44,800 --> 26:43:47,120
Diga a descrição e o raio aqui

40286
26:43:47,120 --> 26:43:49,512
Esta é a informação que queremos para que

40287
26:43:49,512 --> 26:43:52,872
Vou tentar construir este programa

40288
26:43:52,872 --> 26:43:55,680
usando gcc nosso compilador favorito você pode

40289
26:43:55,680 --> 26:43:57,760
realmente usar qualquer compilador que você tem seu

40290
26:43:57,760 --> 26:44:00,080
hands on mas vamos usar gcc

40291
26:44:00,080 --> 26:44:02,480
Porque é o nosso favorito e

40292
26:44:02,480 --> 26:44:05,512
Vamos ter um monte de erros

40293
26:44:05,512 --> 26:44:08,232
O que é que temos aqui o que é

40294
26:44:08,232 --> 26:44:10,320
Que temos aqui vamos entrar em forma

40295
26:44:10,320 --> 26:44:11,360
header jogo:

40296
26:44:11,360 --> 26:44:14,960
na linha 4 e ver o que temos e nós

40297
26:44:14,960 --> 26:44:17,280
Tenho um j aqui que não queremos vamos

40298
26:44:17,280 --> 26:44:19,040
tirar isso e nós vamos construir

40299
26:44:19,040 --> 26:44:20,872
Isso e nós vamos passar por isso

40300
26:44:20,872 --> 26:44:23,512
gcc e o parafuso vai ser bom nós

40301
26:44:23,512 --> 26:44:26,080
pode trazer uma janela powershell para executar

40302
26:44:26,080 --> 26:44:28,640
Nosso programa vamos executar o galo e nós somos

40303
26:44:28,640 --> 26:44:30,960
Vou ver que desenho de forma foi chamado

40304
26:44:30,960 --> 26:44:33,832
desenhando forma um que você vê que temos apenas

40305
26:44:33,832 --> 26:44:36,720
Criou a forma um aqui e nós somos

40306
26:44:36,720 --> 26:44:38,800
Imprimir as suas informações

40307
26:44:38,800 --> 26:44:41,360
vamos chamar a broca oval

40308
26:44:41,360 --> 26:44:43,832
método e vamos imprimir

40309
26:44:43,832 --> 26:44:45,600
a informação sobre que você vê que

40310
26:44:45,600 --> 26:44:48,000
Está sobre um aqui e nós vamos colocar

40311
26:44:48,000 --> 26:44:50,960
para fora nossos dados de raio x raio está indo para

40312
26:44:50,960 --> 26:44:54,080
ser 2 como nós especificamos aqui y raio é

40313
26:44:54,080 --> 26:44:56,232
indo para ser 3,5 e este é o nosso

40314
26:44:56,232 --> 26:44:58,800
Informações que também vamos chamar

40315
26:44:58,800 --> 26:45:01,120
o método de desenho em nosso objeto circular

40316
26:45:01,120 --> 26:45:03,600
Isto é o que temos e nós vamos

40317
26:45:03,600 --> 26:45:05,760
Dizem que estamos desenhando o círculo 1 e o

40318
26:45:05,760 --> 26:45:08,320
O raio vai ser 3 3 este é nosso

40319
26:45:08,320 --> 26:45:11,440
Informações aqui, mas não queremos ir

40320
26:45:11,440 --> 26:45:14,160
através de objetos diretos para gerenciar nossos

40321
26:45:14,160 --> 26:45:16,800
Os dados aqui que queremos é ir

40322
26:45:16,800 --> 26:45:20,320
através de ponteiros de base ou referências de base

40323
26:45:20,320 --> 26:45:22,232
Então vamos criar uma forma

40324
26:45:22,232 --> 26:45:24,160
pontodor vamos fazer isso nós vamos dizer

40325
26:45:24,160 --> 26:45:26,480
mudar porque essa é a nossa classe base e

40326
26:45:26,480 --> 26:45:27,832
nós vamos dizer

40327
26:45:27,832 --> 26:45:30,960
forma ptr para representar o nosso ponteiro e

40328
26:45:30,960 --> 26:45:33,360
Vamos armazenar no endereço de

40329
26:45:33,360 --> 26:45:35,512
forma um nós podemos fazer algo assim

40330
26:45:35,512 --> 26:45:37,360
E isso é realmente ver o que está acontecendo

40331
26:45:37,360 --> 26:45:39,832
nós vamos comentar nossas chamadas para

40332
26:45:39,832 --> 26:45:42,160
desenhar métodos aqui e vamos ver

40333
26:45:42,160 --> 26:45:46,232
o que acontece se dissermos forma ptr e

40334
26:45:46,232 --> 26:45:48,320
chamar o método draw que podemos fazer isso

40335
26:45:48,320 --> 26:45:50,480
Vamos tentar construir o nosso programa

40336
26:45:50,480 --> 26:45:52,800
nós vamos passar isso através do gcc

40337
26:45:52,800 --> 26:45:54,232
você vai ver que vai

40338
26:45:54,232 --> 26:45:56,080
O trabalho e vai fazer o que nós

40339
26:45:56,080 --> 26:45:58,400
espere se executarmos este programa aqui você

40340
26:45:58,400 --> 26:46:00,640
pode limpar e correr galo que vamos

40341
26:46:00,640 --> 26:46:03,360
Veja que desenho de forma foi chamado e nós

40342
26:46:03,360 --> 26:46:05,440
vai estar desenhando forma um aqui

40343
26:46:05,440 --> 26:46:08,232
Isto é o que esperamos, mas se cairmos

40344
26:46:08,232 --> 26:46:11,192
e dizer que não queremos chamar o sorteio

40345
26:46:11,192 --> 26:46:13,680
Método aqui que vamos armazenar em

40346
26:46:13,680 --> 26:46:15,760
Vamos dizer forma ptr e nós vamos

40347
26:46:15,760 --> 26:46:19,440
loja no endereço do nosso sobre um

40348
26:46:19,440 --> 26:46:20,480
objeto

40349
26:46:20,480 --> 26:46:23,832
e queremos chamar o método draw aqui

40350
26:46:23,832 --> 26:46:26,232
Agora, se você fizer isso como vimos no

40351
26:46:26,232 --> 26:46:28,320
desliza o que realmente queremos

40352
26:46:28,320 --> 26:46:32,160
é obter o método de desenho em nosso real

40353
26:46:32,160 --> 26:46:35,120
objeto oval chamado e se quisermos para

40354
26:46:35,120 --> 26:46:37,040
exemplo desenhando coisas na tela

40355
26:46:37,040 --> 26:46:39,192
iria desenhar um romance este é o que queremos

40356
26:46:39,192 --> 26:46:41,040
Aqui, mas não é para isso que vamos

40357
26:46:41,040 --> 26:46:42,720
Você vai ver que nós ainda

40358
26:46:42,720 --> 26:46:43,832


40359
26:46:43,832 --> 26:46:46,552
método de trabalho da classe de forma chamada

40360
26:46:46,552 --> 26:46:48,400
e vai e vai

40361
26:46:48,400 --> 26:46:51,680
Diga desenho sobre um vamos tentar construir

40362
26:46:51,680 --> 26:46:53,600
Este programa e eu realmente quero que você

40363
26:46:53,600 --> 26:46:55,912
Veja isso para que o construtor seja bom

40364
26:46:55,912 --> 26:46:57,912
clear e run galo que você está indo para

40365
26:46:57,912 --> 26:46:59,360
Veja

40366
26:46:59,360 --> 26:47:02,640
fileira mesmo se estivermos armazenando novamente

40367
26:47:02,640 --> 26:47:03,912
Podemos

40368
26:47:03,912 --> 26:47:07,120
objeto assim que este é o comportamento padrão

40369
26:47:07,120 --> 26:47:09,280
nós obtemos e isso é uma ligação estática que

40370
26:47:09,280 --> 26:47:12,640
nós obtemos por padrão em nossa herança

40371
26:47:12,640 --> 26:47:15,040
hierarquias para que é o compilador

40372
26:47:15,040 --> 26:47:16,640
Real realmente vai fazer aqui que vai

40373
26:47:16,640 --> 26:47:19,040
Olhe para o tipo de ponteiro que nós

40374
26:47:19,040 --> 26:47:21,360
Tenho aqui vai dizer que eu tenho um

40375
26:47:21,360 --> 26:47:24,400
shape pointer assim eu vou chamar o

40376
26:47:24,400 --> 26:47:26,872
método mandíbula no tipo de forma que eu tenho

40377
26:47:26,872 --> 26:47:29,280
no meu ponteiro aqui e nós vamos

40378
26:47:29,280 --> 26:47:30,080
Veja

40379
26:47:30,080 --> 26:47:32,480
que isso está chamando o método de desenho em

40380
26:47:32,480 --> 26:47:35,680
nossa forma e isso não é o que queremos

40381
26:47:35,680 --> 26:47:38,320
Na maioria dos casos, vamos ver que

40382
26:47:38,320 --> 26:47:41,120
Temos o mesmo comportamento se armazenarmos um

40383
26:47:41,120 --> 26:47:43,512
Um objeto circular vamos fazer isso

40384
26:47:43,512 --> 26:47:45,440
vamos dizer shift pointer e nós estamos

40385
26:47:45,440 --> 26:47:48,232
indo para armazenar no endereço do nosso

40386
26:47:48,232 --> 26:47:50,480
Círculo um e então vamos chamar

40387
26:47:50,480 --> 26:47:53,760
nosso método de desenho em nosso ponteiro de forma

40388
26:47:53,760 --> 26:47:57,192
Mais uma vez isso vai desenhar uma forma que é

40389
26:47:57,192 --> 26:47:59,680
Não vamos desenhar um círculo que nós

40390
26:47:59,680 --> 26:48:02,232
realmente estão gerenciando com nossa base

40391
26:48:02,232 --> 26:48:04,480
ponteiro aqui e alguns de vocês devem ser

40392
26:48:04,480 --> 26:48:05,600
O pensamento

40393
26:48:05,600 --> 26:48:09,192
por que somos capazes de armazenar ponteiros de círculo

40394
26:48:09,192 --> 26:48:11,680
Por exemplo, em uma forma bem um círculo é

40395
26:48:11,680 --> 26:48:14,320
uma forma segundo a nossa herança

40396
26:48:14,320 --> 26:48:16,960
Hierarquia se olharmos mais de perto

40397
26:48:16,960 --> 26:48:19,120
Aqui você vai ver que oval é

40398
26:48:19,120 --> 26:48:22,960
vai herdar da forma

40399
26:48:22,960 --> 26:48:25,600
E o círculo vai herdar

40400
26:48:25,600 --> 26:48:28,640
do oval, então com o que aprendemos no

40401
26:48:28,640 --> 26:48:30,000
O último capítulo

40402
26:48:30,000 --> 26:48:32,872
oval tem uma parte de forma nele e

40403
26:48:32,872 --> 26:48:36,000
O círculo tem uma parte nova em que

40404
26:48:36,000 --> 26:48:38,552
A vez vai ter uma placa em forma de

40405
26:48:38,552 --> 26:48:40,720
assim a partir deste entendimento

40406
26:48:40,720 --> 26:48:43,280
Não deveria realmente ser surpreendente que nós

40407
26:48:43,280 --> 26:48:45,760
são capazes de gerenciar um

40408
26:48:45,760 --> 26:48:49,440
objeto novo com um ponteiro de forma ou

40409
26:48:49,440 --> 26:48:52,000
que somos capazes de gerenciar um círculo

40410
26:48:52,000 --> 26:48:53,040
objeto

40411
26:48:53,040 --> 26:48:55,600
Usando um ponteiro de forma, é por isso que somos

40412
26:48:55,600 --> 26:48:58,320
capaz de fazer algo assim bem, então eu

40413
26:48:58,320 --> 26:49:00,800
Espero que isso seja super claro, mas novamente

40414
26:49:00,800 --> 26:49:03,280
não estão recebendo o comportamento padrão

40415
26:49:03,280 --> 26:49:05,512
que queremos, mas vamos ver como podemos

40416
26:49:05,512 --> 26:49:08,320
conseguir isso na próxima palestra por enquanto

40417
26:49:08,320 --> 26:49:10,720
Eu realmente quero que você entenda o que

40418
26:49:10,720 --> 26:49:13,120
A ligação estática é tudo sobre e é

40419
26:49:13,120 --> 26:49:15,120
o fato de que o compilador vai

40420
26:49:15,120 --> 26:49:17,680
Olhe para o tipo do ponteiro aqui e

40421
26:49:17,680 --> 26:49:20,320
Use isso para decidir qual método é

40422
26:49:20,320 --> 26:49:21,832
Vou estar chamando

40423
26:49:21,832 --> 26:49:24,160
em nossa hierarquia de herança o

40424
26:49:24,160 --> 26:49:25,600
Compilador, por exemplo, vai ver

40425
26:49:25,600 --> 26:49:28,400
que temos um objeto circular armazenado n em

40426
26:49:28,400 --> 26:49:31,192
lineup 25 aqui, mas quando quiser

40427
26:49:31,192 --> 26:49:34,480
decidir qual versão joe para chamá-lo é

40428
26:49:34,480 --> 26:49:36,400
Vou olhar para o tipo disso

40429
26:49:36,400 --> 26:49:38,800
ponteiro aqui e vai usar isso

40430
26:49:38,800 --> 26:49:41,360
para decidir qual método de desenho para chamar e

40431
26:49:41,360 --> 26:49:43,120
Neste caso, ele vai chamar o

40432
26:49:43,120 --> 26:49:45,512
versão de forma porque o tipo disso

40433
26:49:45,512 --> 26:49:48,232
O ponteiro é a forma bem, então eu realmente espero

40434
26:49:48,232 --> 26:49:50,640
Isto é super claro aqui nós vamos

40435
26:49:50,640 --> 26:49:52,800
obter o mesmo comportamento se tentarmos

40436
26:49:52,800 --> 26:49:55,832
gerenciar nossos objetos usando referências para

40437
26:49:55,832 --> 26:49:58,160
Exemplo se passarmos por uma forma

40438
26:49:58,160 --> 26:49:59,680
referência, vamos fazer isso, vamos

40439
26:49:59,680 --> 26:50:02,400
Diga referência de forma e diga forma ref

40440
26:50:02,400 --> 26:50:04,640
e nós vamos armazenar em forma um

40441
26:50:04,640 --> 26:50:06,960
Por exemplo, vamos fazer isso

40442
26:50:06,960 --> 26:50:09,912
e queremos chamar o método de desenho em

40443
26:50:09,912 --> 26:50:13,040
referência de navio vamos fazer isso, então vamos

40444
26:50:13,040 --> 26:50:15,440
chamar o método joe e você está indo para

40445
26:50:15,440 --> 26:50:18,080
Veja que vamos ter o método de forma

40446
26:50:18,080 --> 26:50:19,040
Chamada

40447
26:50:19,040 --> 26:50:20,960
E isso está realmente fazendo sentido porque

40448
26:50:20,960 --> 26:50:23,120
Temos um objeto de forma

40449
26:50:23,120 --> 26:50:25,512
gerenciado por esta referência aqui, então se

40450
26:50:25,512 --> 26:50:27,192
construir o nosso programa vamos fazer isso nós

40451
26:50:27,192 --> 26:50:29,360
vai passar por isso através do gcc

40452
26:50:29,360 --> 26:50:31,040
Você vai ver que nós conseguimos o que nós

40453
26:50:31,040 --> 26:50:32,800
Espero que a construção seja boa

40454
26:50:32,800 --> 26:50:35,192
nós vamos limpar e correr o galo e

40455
26:50:35,192 --> 26:50:37,680
vemos a broca de forma chamada isso é o que

40456
26:50:37,680 --> 26:50:40,720
nós queremos, mas se usarmos esta referência para

40457
26:50:40,720 --> 26:50:43,120
gerenciar objeto derivado, por exemplo, vamos

40458
26:50:43,120 --> 26:50:45,680
Colocado sobre um que podemos fazer que nós somos

40459
26:50:45,680 --> 26:50:48,552
Vou ver que não conseguimos mais

40460
26:50:48,552 --> 26:50:51,760
método de desenho específico para oval aqui

40461
26:50:51,760 --> 26:50:54,400
chamado, ainda vamos ter o método

40462
26:50:54,400 --> 26:50:56,320
para uma forma chamada vamos construir e mostrar

40463
26:50:56,320 --> 26:50:59,040
Esta é uma ligação estática novamente

40464
26:50:59,040 --> 26:51:01,280
Ok, a construção é boa, podemos limpar e

40465
26:51:01,280 --> 26:51:02,800
correr galo, vamos ver isso

40466
26:51:02,800 --> 26:51:05,832
forma desenhá-lo é desenhar que nós não temos

40467
26:51:05,832 --> 26:51:08,872
o método do desenho de ovo chamado nós temos forma

40468
26:51:08,872 --> 26:51:10,960
método de perfuração novamente o compilador está indo

40469
26:51:10,960 --> 26:51:12,960
olhar para o tipo desta referência por

40470
26:51:12,960 --> 26:51:15,192
padrão e ele vai usar isso para

40471
26:51:15,192 --> 26:51:17,832
decidir qual método de sorteio chamar se nós

40472
26:51:17,832 --> 26:51:20,320
mesmo em um círculo que vamos conseguir

40473
26:51:20,320 --> 26:51:23,280
O mesmo comportamento, vamos construir com gcc

40474
26:51:23,280 --> 26:51:25,512
o parafuso é bom nós podemos limpar e correr

40475
26:51:25,512 --> 26:51:27,912
Galo que vemos que desenho de forma é chamado

40476
26:51:27,912 --> 26:51:29,512
E isso realmente não é

40477
26:51:29,512 --> 26:51:31,832
O que queremos bem, então isso é estático

40478
26:51:31,832 --> 26:51:34,232
vinculação e é o comportamento padrão

40479
26:51:34,232 --> 26:51:36,960
Temos se tivermos uma herança

40480
26:51:36,960 --> 26:51:40,320
hierarquia com o mesmo método spread

40481
26:51:40,320 --> 26:51:43,192
em cada classe derivada, vamos

40482
26:51:43,192 --> 26:51:45,600
obter a versão de forma chamada mesmo se

40483
26:51:45,600 --> 26:51:47,912
o que realmente estamos gerenciando com uma forma

40484
26:51:47,912 --> 26:51:50,480
ponteiro ou uma referência de forma é a

40485
26:51:50,480 --> 26:51:52,480
objeto derivado eu realmente quero que você

40486
26:51:52,480 --> 26:51:55,120
Entenda isso agora vamos ver por que isso

40487
26:51:55,120 --> 26:51:58,000
é realmente mal projetado por padrão em c

40488
26:51:58,000 --> 26:52:00,400
mais mais se você precisar passar

40489
26:52:00,400 --> 26:52:02,872
Parâmetros de envio para funções, por exemplo

40490
26:52:02,872 --> 26:52:04,800
Podemos fazer algo assim que pudéssemos

40491
26:52:04,800 --> 26:52:06,960
Precisa de uma função para desenhar um círculo que nós

40492
26:52:06,960 --> 26:52:08,960
pode precisar de uma função para desenhar um romance

40493
26:52:08,960 --> 26:52:11,680
e se acontecer de você ter 100 objetos

40494
26:52:11,680 --> 26:52:14,080
você pode desenhar em seu programa você não tem

40495
26:52:14,080 --> 26:52:17,192
escolha, mas para configurar 100 métodos de desenho

40496
26:52:17,192 --> 26:52:19,512
ou funções isso é realmente um mau design

40497
26:52:19,512 --> 26:52:21,600
Você não quer fazer algo assim

40498
26:52:21,600 --> 26:52:23,680
Então, o que você faria em seu programa

40499
26:52:23,680 --> 26:52:25,832
O exemplo é ir para baixo

40500
26:52:25,832 --> 26:52:27,680
e dizer desenho

40501
26:52:27,680 --> 26:52:29,760
e você diria, por exemplo, desenhar

40502
26:52:29,760 --> 26:52:32,800
círculo e passar em um círculo e dizer empate

40503
26:52:32,800 --> 26:52:35,280
oval, temos um desenho ou função completa

40504
26:52:35,280 --> 26:52:37,512
Vamos ver sim, nós temos que podemos ir

40505
26:52:37,512 --> 26:52:40,800
para baixo e dizer desenhar oval e passar em nosso

40506
26:52:40,800 --> 26:52:43,280
oval um este vai funcionar muito bem

40507
26:52:43,280 --> 26:52:44,872
Mas espero que você possa ver que isso é

40508
26:52:44,872 --> 26:52:47,600
mau design se você tem muitas formas

40509
26:52:47,600 --> 26:52:50,000
em seu programa isso vai rapidamente

40510
26:52:50,000 --> 26:52:52,232
tornar-se e gerenciável e você não quer

40511
26:52:52,232 --> 26:52:54,800
para fazer algo assim o que queremos

40512
26:52:54,800 --> 26:52:56,720
É para ser capaz

40513
26:52:56,720 --> 26:52:59,760
para ter apenas um método e chegar ao c

40514
26:52:59,760 --> 26:53:02,080
mais mais tempo de execução para resolver qual

40515
26:53:02,080 --> 26:53:05,120
é chamado em tempo de execução quando podemos passar

40516
26:53:05,120 --> 26:53:08,080
nossos objetos reais e só teremos

40517
26:53:08,080 --> 26:53:10,400
uma função que vai levar em

40518
26:53:10,400 --> 26:53:13,192
Contar centenas de formas que podemos

40519
26:53:13,192 --> 26:53:14,960
potencialmente ter em nosso c plus mais

40520
26:53:14,960 --> 26:53:17,360
programa isso vai ser muito mais fácil

40521
26:53:17,360 --> 26:53:19,512
para gerenciar e realmente seremos capazes

40522
26:53:19,512 --> 26:53:22,160
para conseguir isso na próxima palestra assim

40523
26:53:22,160 --> 26:53:24,552
Fique atento para esse outro problema com

40524
26:53:24,552 --> 26:53:26,872
Nós estamos se você precisar armazenar

40525
26:53:26,872 --> 26:53:29,440
estas formas em coleções, se você precisar

40526
26:53:29,440 --> 26:53:31,120
para configurar algo assim você vai

40527
26:53:31,120 --> 26:53:33,600
Não tem escolha a não ser configurar diferente

40528
26:53:33,600 --> 26:53:36,800
coleções para cada tipo, por exemplo, nós

40529
26:53:36,800 --> 26:53:39,120
pode configurar uma coleção para um círculo

40530
26:53:39,120 --> 26:53:41,760
coleção para oval e aqui estamos apenas

40531
26:53:41,760 --> 26:53:44,480
usando arrays para modelar nossas coleções

40532
26:53:44,480 --> 26:53:46,400
Este é realmente um design ruim se você acontecer

40533
26:53:46,400 --> 26:53:49,120
para ter 100 formas no seu programa

40534
26:53:49,120 --> 26:53:52,552
estabelecerão 100 dessas coleções e a

40535
26:53:52,552 --> 26:53:54,400
A única diferença é que eles são apenas

40536
26:53:54,400 --> 26:53:56,320
Diferentes tipos e isso é realmente ruim

40537
26:53:56,320 --> 26:53:58,000
design porque mesmo que sejam

40538
26:53:58,000 --> 26:54:00,640
diferentes tipos estão relacionados e

40539
26:54:00,640 --> 26:54:02,720
todos são formas em nosso c plus plus

40540
26:54:02,720 --> 26:54:05,192
Programa e o que realmente queremos é

40541
26:54:05,192 --> 26:54:07,192
configurar uma coleção que vai

40542
26:54:07,192 --> 26:54:09,600
Levar em conta todos esses tipos de

40543
26:54:09,600 --> 26:54:11,600
formas que podemos ter em nosso c plus

40544
26:54:11,600 --> 26:54:14,000
além do programa e poderemos

40545
26:54:14,000 --> 26:54:16,480
conseguir isso novamente na próxima palestra

40546
26:54:16,480 --> 26:54:18,320
Mas o ponto principal desta palestra foi

40547
26:54:18,320 --> 26:54:20,640
para mostrar a ligação estática que o recebemos

40548
26:54:20,640 --> 26:54:22,800
por defeito com a nossa herança

40549
26:54:22,800 --> 26:54:26,000
hierarquias de ligação estática podem ser ruins se

40550
26:54:26,000 --> 26:54:29,280
Você realmente está gerenciando muitos relacionados

40551
26:54:29,280 --> 26:54:31,680
objetos em seu programa c plus plus

40552
26:54:31,680 --> 26:54:34,320
Todos esses objetos têm o mesmo

40553
26:54:34,320 --> 26:54:35,360
O método

40554
26:54:35,360 --> 26:54:38,400
que cada classe derivada é especializada

40555
26:54:38,400 --> 26:54:40,800
Mas você quer o método mais especializado

40556
26:54:40,800 --> 26:54:43,912
ser chamado ao objeto real que

40557
26:54:43,912 --> 26:54:46,800
você está gerenciando com um ponteiro base ou

40558
26:54:46,800 --> 26:54:48,960
uma referência base espero que isso seja super

40559
26:54:48,960 --> 26:54:51,440
claro eu peço desculpas esta palestra virada

40560
26:54:51,440 --> 26:54:54,000
para ser muito longo, mas eu queria você

40561
26:54:54,000 --> 26:54:56,480
para deixar isso super claro e tudo

40562
26:54:56,480 --> 26:54:58,552
O outro fazemos na lembrança disso

40563
26:54:58,552 --> 26:55:00,640
O capítulo vai realmente cair no lugar

40564
26:55:00,640 --> 26:55:02,640
para que você entenda isso e se

40565
26:55:02,640 --> 26:55:04,872
Você tem um problema, você me pergunta que eu vou

40566
26:55:04,872 --> 26:55:07,040
fazer o melhor que posso para ajudar isso

40567
26:55:07,040 --> 26:55:08,640
É realmente tudo que eu tive que compartilhar disso

40568
26:55:08,640 --> 26:55:10,872
Uma palestra espero que você tenha achado interessante

40569
26:55:10,872 --> 26:55:12,720
Vamos parar aqui neste

40570
26:55:12,720 --> 26:55:14,400
palestra no próximo, vamos

40571
26:55:14,400 --> 26:55:16,872
mostrar como você pode alcançar a dinâmica

40572
26:55:16,872 --> 26:55:20,080
Ligação usando funções virtuais em c

40573
26:55:20,080 --> 26:55:21,192
plus plus

40574
26:55:21,192 --> 26:55:23,440
Vá em frente e termine aqui e me encontre

40575
26:55:23,440 --> 26:55:25,512
lá nesta palestra vamos ver

40576
26:55:25,512 --> 26:55:28,800
como podemos alcançar a ligação dinâmica ou

40577
26:55:28,800 --> 26:55:30,552
O polimorfismo

40578
26:55:30,552 --> 26:55:32,960
Usando funções virtuais em nosso

40579
26:55:32,960 --> 26:55:35,280
hierarquias de herança no último

40580
26:55:35,280 --> 26:55:37,912
palestra que tivemos uma hierarquia como essa

40581
26:55:37,912 --> 26:55:40,320
onde a classe base foi moldada que tivemos

40582
26:55:40,320 --> 26:55:43,280
uma classe superior que estava publicamente derivando

40583
26:55:43,280 --> 26:55:45,832
ou herdar de forma e nós tivemos um

40584
26:55:45,832 --> 26:55:48,000
classe de círculo que era pública

40585
26:55:48,000 --> 26:55:50,232
Herdado do excesso e do problema

40586
26:55:50,232 --> 26:55:53,280
tinha sido que se acontecer de estarmos gerenciando

40587
26:55:53,280 --> 26:55:56,480
objetos ovais ou circulares usando

40588
26:55:56,480 --> 26:55:59,600
shape pointers ou shape referências nós

40589
26:55:59,600 --> 26:56:02,080
Não obtenha os métodos corretos chamados se

40590
26:56:02,080 --> 26:56:04,160
Chamamos o método draw

40591
26:56:04,160 --> 26:56:07,512
em nosso ponteiro base ou referência base

40592
26:56:07,512 --> 26:56:09,440
E isso foi muito ruim e isso é

40593
26:56:09,440 --> 26:56:12,160
algo que queremos na prática c plus

40594
26:56:12,160 --> 26:56:14,400
além de programas que estou aqui para lhe dizer em

40595
26:56:14,400 --> 26:56:16,400
Esta palestra que você pode apenas alcançar

40596
26:56:16,400 --> 26:56:17,192
que

40597
26:56:17,192 --> 26:56:20,160
fazendo uma pequena modificação em seu

40598
26:56:20,160 --> 26:56:22,640
hierarquia de herança tudo que você precisa fazer

40599
26:56:22,640 --> 26:56:25,192
é marcar os métodos que você precisa ser

40600
26:56:25,192 --> 26:56:27,600
resolvidos de forma dinâmica

40601
26:56:27,600 --> 26:56:30,640
virtual e fazemos isso inserindo isso

40602
26:56:30,640 --> 26:56:33,832
palavra-chave virtual na frente da nossa função

40603
26:56:33,832 --> 26:56:35,440
Vamos fazer isso em nossa forma

40604
26:56:35,440 --> 26:56:37,600
classe, vamos fazer isso no nosso

40605
26:56:37,600 --> 26:56:40,000
classe e nós vamos fazer isso em nosso

40606
26:56:40,000 --> 26:56:42,800
classe de círculo uma vez que fazemos isso o c plus

40607
26:56:42,800 --> 26:56:45,280
plus compilador vai saber que eu quero

40608
26:56:45,280 --> 26:56:47,832
olhar para o tipo do ponteiro ou

40609
26:56:47,832 --> 26:56:50,160
Referência para saber que tipo de método

40610
26:56:50,160 --> 26:56:53,360
para chamar e minha hierarquia de herança se

40611
26:56:53,360 --> 26:56:55,832
Acontece que estou usando um ponteiro de base ou um

40612
26:56:55,832 --> 26:56:58,640
Referência base para gerenciar um derivado

40613
26:56:58,640 --> 26:57:00,400
objeto e nós vamos fazer isso

40614
26:57:00,400 --> 26:57:02,800
super claro em um minuto e se você é

40615
26:57:02,800 --> 26:57:04,640
Perdido, por favor, tenha paciência comigo, você vai

40616
26:57:04,640 --> 26:57:06,640
Entenda, então vamos fazer isso, vamos

40617
26:57:06,640 --> 26:57:10,080
para modificar nossa classe de forma e mudar a nossa

40618
26:57:10,080 --> 26:57:12,232
método de draw para ser virtual

40619
26:57:12,232 --> 26:57:14,480
como você vê aqui, vamos nos dirigir

40620
26:57:14,480 --> 26:57:16,800
em nossa classe oval, vamos modificar

40621
26:57:16,800 --> 26:57:18,960
nosso método de sorteio e marque-o como

40622
26:57:18,960 --> 26:57:21,760
virtual usando a palavra-chave virtual aqui

40623
26:57:21,760 --> 26:57:24,080
E nós vamos nos mover em nosso círculo

40624
26:57:24,080 --> 26:57:27,912
classe e mudar para ser virtual como você

40625
26:57:27,912 --> 26:57:29,760
Veja aqui, isso é realmente tudo que precisamos

40626
26:57:29,760 --> 26:57:30,720
para fazer

40627
26:57:30,720 --> 26:57:33,600
do que tivemos na última palestra e

40628
26:57:33,600 --> 26:57:36,160
Isso vai ser mágico, vamos olhar para

40629
26:57:36,160 --> 26:57:38,160
O que podemos alcançar agora vamos

40630
26:57:38,160 --> 26:57:41,040
configurar três objetos em forma oval e

40631
26:57:41,040 --> 26:57:43,192
círculo como você vê aqui e nós vamos

40632
26:57:43,192 --> 26:57:45,120
estar chamando o nosso método que está indo

40633
26:57:45,120 --> 26:57:46,960
Tomemos referências e vamos

40634
26:57:46,960 --> 26:57:50,000
para ver que nós obtemos o mais correto

40635
26:57:50,000 --> 26:57:52,552
Método específico chamado, por exemplo

40636
26:57:52,552 --> 26:57:55,280
Aqui vamos chamar a forma joe para baixo

40637
26:57:55,280 --> 26:57:57,512
aqui vamos chamar o método de desenho oval

40638
26:57:57,512 --> 26:58:00,480
Porque acabamos de passar em um novo objeto

40639
26:58:00,480 --> 26:58:02,720
e na terceira linha aqui vamos conseguir

40640
26:58:02,720 --> 26:58:05,360
o método do círculo joe chamado e nós vamos

40641
26:58:05,360 --> 26:58:07,680
vê-lo impresso no console este

40642
26:58:07,680 --> 26:58:09,360
É realmente legal isto é o que queremos

40643
26:58:09,360 --> 26:58:12,000
alcançar se quisermos chamar nossos métodos

40644
26:58:12,000 --> 26:58:14,800
que tomar ponteiros que podemos fazer isso e sobre

40645
26:58:14,800 --> 26:58:16,872
A primeira linha aqui vamos chamar forma

40646
26:58:16,872 --> 26:58:19,192
desenhar na segunda linha aqui vamos

40647
26:58:19,192 --> 26:58:21,832
call overdraw e na terceira linha aqui

40648
26:58:21,832 --> 26:58:24,080
Vamos chamar circuito draw isto é o que

40649
26:58:24,080 --> 26:58:26,320
Queremos alcançar e se acontecermos

40650
26:58:26,320 --> 26:58:29,120
Estar configurando um ponteiro base de rolo como

40651
26:58:29,120 --> 26:58:31,120
Fazemos aqui e armazenamos em

40652
26:58:31,120 --> 26:58:34,400
um objeto derivado como este ou outro

40653
26:58:34,400 --> 26:58:36,800
maneira de dizer isso se acontecer de nós estar usando

40654
26:58:36,800 --> 26:58:39,440
Este ponteiro base para gerenciar um

40655
26:58:39,440 --> 26:58:42,160
objeto e nós chamamos o método de desenho em

40656
26:58:42,160 --> 26:58:44,800
o ponteiro base o compilador está indo

40657
26:58:44,800 --> 26:58:47,280
para saber que ele precisará resolver

40658
26:58:47,280 --> 26:58:50,720
Este método de desenho dinamicamente a razão

40659
26:58:50,720 --> 26:58:53,760
Este é um método virtual e se

40660
26:58:53,760 --> 26:58:56,000
método é virtual que o compilador deseja

40661
26:58:56,000 --> 26:58:56,720
- É assim.

40662
26:58:56,720 --> 26:58:58,800
ligação estática como fizemos no último

40663
26:58:58,800 --> 26:59:00,320
lição que o compilador vai ser

40664
26:59:00,320 --> 26:59:04,400
fazendo a ligação dinâmica e com dinâmica

40665
26:59:04,400 --> 26:59:06,160
vincular o compilador não vai

40666
26:59:06,160 --> 26:59:08,552
Veja o tipo de ponteiro que é

40667
26:59:08,552 --> 26:59:11,280
Vou olhar para o tipo de real

40668
26:59:11,280 --> 26:59:14,552
objeto que o ponteiro está gerenciando e

40669
26:59:14,552 --> 26:59:16,872
Isso vai nos dar o comportamento

40670
26:59:16,872 --> 26:59:19,040
Queríamos começar do último

40671
26:59:19,040 --> 26:59:20,800
dar uma palestra agora que você sabe disso

40672
26:59:20,800 --> 26:59:22,232
nós vamos ir para o visual

40673
26:59:22,232 --> 26:59:24,080
código de estúdio e jogar com a gente um pouco

40674
26:59:24,080 --> 26:59:26,960
Mais aqui estamos em nossa pasta de trabalho

40675
26:59:26,960 --> 26:59:29,760
O projeto atual é polimorfismo com

40676
26:59:29,760 --> 26:59:32,320
Funções virtuais que vamos ser

40677
26:59:32,320 --> 26:59:34,320
reutilização do código da última palestra

40678
26:59:34,320 --> 26:59:35,680
Porque isso vai nos dar

40679
26:59:35,680 --> 26:59:37,440
Tudo o que queremos

40680
26:59:37,440 --> 26:59:39,600
Vamos deixar de fora o

40681
26:59:39,600 --> 26:59:42,160
arquivo binário aqui que é galo e

40682
26:59:42,160 --> 26:59:43,832
Vamos copiar tudo o que queremos

40683
26:59:43,832 --> 26:59:46,000
Vamos colocar isso na corrente

40684
26:59:46,000 --> 26:59:48,480
projeto e vamos abrir isso em

40685
26:59:48,480 --> 26:59:51,120
código de estúdio visual que vamos ter

40686
26:59:51,120 --> 26:59:54,080
nosso arquivo principal cpp com um monte de

40687
26:59:54,080 --> 26:59:55,512
Os métodos aqui

40688
26:59:55,512 --> 26:59:58,232
e só precisaremos modificar isso a

40689
26:59:58,232 --> 27:00:01,120
um pouco para alcançar a ligação dinâmica como

40690
27:00:01,120 --> 27:00:03,600
Vimos nos slides tudo o que precisamos fazer

40691
27:00:03,600 --> 27:00:06,480
é marcar todos esses métodos de atração como

40692
27:00:06,480 --> 27:00:08,720
virtual, então vamos dizer virtual

40693
27:00:08,720 --> 27:00:11,600
void draw na classe de forma que estamos indo

40694
27:00:11,600 --> 27:00:14,000
para ir na classe oval e fazer isso

40695
27:00:14,000 --> 27:00:15,760
Vamos marcar o nosso método como

40696
27:00:15,760 --> 27:00:18,320
virtual e nós vamos entrar em nosso

40697
27:00:18,320 --> 27:00:21,512
classe de círculo e marcar o nosso método de desenho como

40698
27:00:21,512 --> 27:00:23,680
virtual vamos fazer isso e no momento

40699
27:00:23,680 --> 27:00:25,760
Fazemos isso, vamos ser dinâmicos

40700
27:00:25,760 --> 27:00:29,192
Comportamento obrigatório em nossa herança

40701
27:00:29,192 --> 27:00:31,360
Hierarquia aqui e isso é muito legal

40702
27:00:31,360 --> 27:00:34,160
Então vamos voltar e tentar jogar com

40703
27:00:34,160 --> 27:00:36,720
O que tínhamos antes eu vou comentar

40704
27:00:36,720 --> 27:00:39,512
fora tudo o que tínhamos e nós vamos

40705
27:00:39,512 --> 27:00:42,552
estar fazendo as coisas em passo aqui vamos ir

40706
27:00:42,552 --> 27:00:45,360
através do código que usa ponteiros de base

40707
27:00:45,360 --> 27:00:46,400
porque

40708
27:00:46,400 --> 27:00:48,552
É aí que começamos no

40709
27:00:48,552 --> 27:00:49,832
A última palestra

40710
27:00:49,832 --> 27:00:52,320
E nós vamos para

40711
27:00:52,320 --> 27:00:54,400
marcar isso aqui vamos colocar em algum espaço

40712
27:00:54,400 --> 27:00:57,760
para torná-lo fácil de seguir para que nós sejamos

40713
27:00:57,760 --> 27:01:00,320
Vou descomentar a linha aqui que

40714
27:01:00,320 --> 27:01:02,552
Chama o método draw quando temos um

40715
27:01:02,552 --> 27:01:05,600
objeto de forma armazenado em nosso ponteiro base

40716
27:01:05,600 --> 27:01:08,000
ou quando estamos usando um ponteiro base para

40717
27:01:08,000 --> 27:01:10,552
gerenciar um objeto de forma aqui nós podemos também

40718
27:01:10,552 --> 27:01:12,640
Comentar todas essas linhas porque nós

40719
27:01:12,640 --> 27:01:15,040
Não quero que isso faça nada

40720
27:01:15,040 --> 27:01:17,680
E vamos ver sim, isso é o que queremos

40721
27:01:17,680 --> 27:01:20,232
Nós estamos montando nossas formas e nós estamos

40722
27:01:20,232 --> 27:01:22,720
usando um ponteiro base para gerenciar um

40723
27:01:22,720 --> 27:01:25,280
objeto de forma e se nós chamamos o sorteio

40724
27:01:25,280 --> 27:01:27,512
método que esperamos que isso chame

40725
27:01:27,512 --> 27:01:29,440
shape draw e isso é o que estamos indo

40726
27:01:29,440 --> 27:01:31,120
para obter, vamos construir nosso programa, nós somos

40727
27:01:31,120 --> 27:01:33,832
indo passar isso através de gcc nosso

40728
27:01:33,832 --> 27:01:35,760
compilador favorito que a compilação vai

40729
27:01:35,760 --> 27:01:38,160
ser bom nós podemos trazer uma powershell

40730
27:01:38,160 --> 27:01:40,320
janela que podemos usar para brincar conosco se nós

40731
27:01:40,320 --> 27:01:42,000
chamar o galo, vamos ver isso

40732
27:01:42,000 --> 27:01:44,400
O desenho da forma é chamado e nós estamos desenhando

40733
27:01:44,400 --> 27:01:46,552
forma um agora se mudarmos isso para

40734
27:01:46,552 --> 27:01:49,360
gerenciar um objeto oval real que podemos fazer

40735
27:01:49,360 --> 27:01:51,440
que podemos fazer isso através desta linha

40736
27:01:51,440 --> 27:01:54,960
aqui e esperamos que isso chame overdraw

40737
27:01:54,960 --> 27:01:57,280
e porque o método draw é agora

40738
27:01:57,280 --> 27:02:00,160
virtual isso vai usar a ligação dinâmica

40739
27:02:00,160 --> 27:02:02,480
novamente com a ligação dinâmica que somos

40740
27:02:02,480 --> 27:02:04,720
Dizer ao compilador não olhe para o

40741
27:02:04,720 --> 27:02:07,600
tipo do ponteiro de base olhar para o

40742
27:02:07,600 --> 27:02:10,552
tipo do objeto real que

40743
27:02:10,552 --> 27:02:12,480
O ponteiro está gerenciando e o compilador é

40744
27:02:12,480 --> 27:02:14,640
Vou ver que este objeto é um romance

40745
27:02:14,640 --> 27:02:17,280
Objeto e ele vai chamar

40746
27:02:17,280 --> 27:02:20,640
A versão oval do método draw aqui

40747
27:02:20,640 --> 27:02:22,160
E isso é muito legal, isso é o que nós

40748
27:02:22,160 --> 27:02:24,720
Quero vamos executar a tarefa para construir com

40749
27:02:24,720 --> 27:02:27,192
gcc novamente o mundo vai ser bom

40750
27:02:27,192 --> 27:02:29,360
Como você vê aqui podemos limpar

40751
27:02:29,360 --> 27:02:31,832
e se nós executarmos booster olhar para isso

40752
27:02:31,832 --> 27:02:34,232
Retirar chamadas e nós vamos ser

40753
27:02:34,232 --> 27:02:37,680
desenhando nosso objeto oval e este é o

40754
27:02:37,680 --> 27:02:39,680
Os dados que temos dentro podemos usar isso

40755
27:02:39,680 --> 27:02:42,320
dados de raio para desenhar isso na tela

40756
27:02:42,320 --> 27:02:44,640
Se isso é o que estamos atrás em nosso c

40757
27:02:44,640 --> 27:02:46,400
Plus plus programa e isso é realmente

40758
27:02:46,400 --> 27:02:49,280
cool nós podemos até usar o nosso ponteiro base para

40759
27:02:49,280 --> 27:02:52,160
Gerenciar um objeto circular, podemos fazer isso

40760
27:02:52,160 --> 27:02:54,232
e se fizermos isso e chamarmos o Joe

40761
27:02:54,232 --> 27:02:57,360
método porque este método de sorteio é agora

40762
27:02:57,360 --> 27:03:00,000
virtual o compilador irá notar que

40763
27:03:00,000 --> 27:03:02,552
não precisa olhar para o tipo de

40764
27:03:02,552 --> 27:03:05,512
pontodor que estamos usando para gerenciar o nosso

40765
27:03:05,512 --> 27:03:06,400
objeto

40766
27:03:06,400 --> 27:03:08,160
O compilador vai olhar para o

40767
27:03:08,160 --> 27:03:11,192
Tipo do objeto real que a base

40768
27:03:11,192 --> 27:03:13,512
O ponteiro está gerenciando e, neste caso,

40769
27:03:13,512 --> 27:03:16,000
Acontece que é um objeto de círculo, então aqui nós

40770
27:03:16,000 --> 27:03:19,192
vai chamar o circle draw e isso está indo

40771
27:03:19,192 --> 27:03:21,600
para desenhar um círculo na tela e isso

40772
27:03:21,600 --> 27:03:23,680
Será realmente muito legal, então

40773
27:03:23,680 --> 27:03:26,232
Vamos passar isso através do gcc

40774
27:03:26,232 --> 27:03:28,232
e nós vamos ver isso em ação

40775
27:03:28,232 --> 27:03:29,760
A construção vai ser boa nós podemos

40776
27:03:29,760 --> 27:03:32,160
limpar e correr galo e você vê isso

40777
27:03:32,160 --> 27:03:34,552
Estamos desenhando um círculo e isso é

40778
27:03:34,552 --> 27:03:37,120
muito legal e apenas usando virtual

40779
27:03:37,120 --> 27:03:40,000
funções que podemos realmente alcançar poderosos

40780
27:03:40,000 --> 27:03:42,232
características e você vê que isso não foi

40781
27:03:42,232 --> 27:03:45,040
É muito difícil conseguir tudo o que tínhamos que fazer

40782
27:03:45,040 --> 27:03:48,872
para marcar nossos métodos herdados como um

40783
27:03:48,872 --> 27:03:50,872
virtual e isso vai dizer o

40784
27:03:50,872 --> 27:03:53,832
compilador para fazer ligação dinâmica e isso

40785
27:03:53,832 --> 27:03:55,832
Vai ser super legal, vamos ver isso

40786
27:03:55,832 --> 27:03:58,160
também podemos conseguir a mesma coisa usando

40787
27:03:58,160 --> 27:04:00,800
referências base eu não vou correr

40788
27:04:00,800 --> 27:04:03,680
O código onde estamos usando um

40789
27:04:03,680 --> 27:04:06,320
base referência eu não vou ser

40790
27:04:06,320 --> 27:04:08,872
executando o código onde estamos usando um

40791
27:04:08,872 --> 27:04:11,120
referência base para gerenciar

40792
27:04:11,120 --> 27:04:12,640
uma base

40793
27:04:12,640 --> 27:04:14,720
Objeto porque isso vai ser realmente

40794
27:04:14,720 --> 27:04:17,440
chato, mas o que podemos fazer é colocar em um

40795
27:04:17,440 --> 27:04:19,192
Objeto terrível, por exemplo, você pode dizer

40796
27:04:19,192 --> 27:04:22,320
sobre um e dizer forma ref e chamar o

40797
27:04:22,320 --> 27:04:24,960
draw method novamente isso é dinâmico

40798
27:04:24,960 --> 27:04:27,040
vinculação porque o método de desenho é

40799
27:04:27,040 --> 27:04:29,360
virtual para que o compilador não vá

40800
27:04:29,360 --> 27:04:31,600
Veja o tipo de referência a

40801
27:04:31,600 --> 27:04:33,832
decidir qual versão do método draw

40802
27:04:33,832 --> 27:04:36,552
para chamá-lo vai olhar para o

40803
27:04:36,552 --> 27:04:39,680
objeto real de que esta referência é

40804
27:04:39,680 --> 27:04:42,000
gerencie e vai ver que o

40805
27:04:42,000 --> 27:04:44,720
Tipo do objeto é horrível, então c mais

40806
27:04:44,720 --> 27:04:48,000
Plus vai chamar a versão oval

40807
27:04:48,000 --> 27:04:50,000
do método draw que é o que somos

40808
27:04:50,000 --> 27:04:52,552
indo para obter se executarmos este programa aqui

40809
27:04:52,552 --> 27:04:54,160
Vamos construir e ver isso vamos

40810
27:04:54,160 --> 27:04:56,552
passar isso através de gcc a tensão deve

40811
27:04:56,552 --> 27:04:59,040
ser bom como vemos aqui, vamos

40812
27:04:59,040 --> 27:05:01,680
claro e correr galo você vê que estamos

40813
27:05:01,680 --> 27:05:04,320
desenhar oval se acontecer de nós estar usando

40814
27:05:04,320 --> 27:05:06,720
para gerenciar nosso objeto circular, vamos

40815
27:05:06,720 --> 27:05:07,760
- Faz isso.

40816
27:05:07,760 --> 27:05:10,400
Vamos ver que vamos conseguir o círculo

40817
27:05:10,400 --> 27:05:12,640
Método chamado ok vamos construir e nós somos

40818
27:05:12,640 --> 27:05:14,640
passar isso através do gcc para fazer

40819
27:05:14,640 --> 27:05:16,480
Que ambos vão ser bons nós podemos

40820
27:05:16,480 --> 27:05:19,192
clear e run galo você vê que nós

40821
27:05:19,192 --> 27:05:21,912
estão desenhando um círculo porque nossa base

40822
27:05:21,912 --> 27:05:25,680
O ponteiro agora está gerenciando um objeto de círculo

40823
27:05:25,680 --> 27:05:29,040
Agora porque estamos usando ligação dinâmica

40824
27:05:29,040 --> 27:05:32,000
ou vínculo tardio como algumas pessoas chamam

40825
27:05:32,000 --> 27:05:33,912
Podemos realmente fazer todos os tipos de loucura

40826
27:05:33,912 --> 27:05:36,080
A primeira coisa que podemos alcançar é

40827
27:05:36,080 --> 27:05:38,800
configurar um único método que é realmente

40828
27:05:38,800 --> 27:05:41,360
vamos desenhar qualquer tipo de forma que lançamos

40829
27:05:41,360 --> 27:05:43,280
nele, então vamos fazer algo assim

40830
27:05:43,280 --> 27:05:44,872
nós vamos dizer vazio e nós vamos

40831
27:05:44,872 --> 27:05:47,120
para dizer desenhar forma e ele vai

40832
27:05:47,120 --> 27:05:50,232
tomar um ponteiro de forma, vamos dizer s e

40833
27:05:50,232 --> 27:05:51,912
A única coisa que vamos fazer nisso

40834
27:05:51,912 --> 27:05:54,720
função e dizer que é desenhar isso vai

40835
27:05:54,720 --> 27:05:56,400
chamar o método de desenho em qualquer coisa

40836
27:05:56,400 --> 27:05:58,552
parâmetro que passamos aqui

40837
27:05:58,552 --> 27:06:01,512
e veja isso se descermos aqui e

40838
27:06:01,512 --> 27:06:04,552
não comer esta seção sobre formas de desenho

40839
27:06:04,552 --> 27:06:08,000
se dissermos desenhar e passar em um círculo para

40840
27:06:08,000 --> 27:06:10,320
exemplo ou vamos passar um oval e fazer

40841
27:06:10,320 --> 27:06:13,040
este nível e fazer este nível por

40842
27:06:13,040 --> 27:06:15,040
Nível que vamos passar por cima de um

40843
27:06:15,040 --> 27:06:16,720
e devemos passar um endereço porque

40844
27:06:16,720 --> 27:06:18,872
Isto é tomar um ponteiro, vamos então vamos

40845
27:06:18,872 --> 27:06:21,512
fazer isso e se construirmos e executarmos isso

40846
27:06:21,512 --> 27:06:23,280
Programa, vamos ver o que acontece aqui

40847
27:06:23,280 --> 27:06:25,600
nós vamos construir com o Gcc o mundo

40848
27:06:25,600 --> 27:06:27,360
vai ser bom como você vê aqui se

40849
27:06:27,360 --> 27:06:30,400
Nós limpamos e corremos o galo que você vê

40850
27:06:30,400 --> 27:06:33,360
e vamos tirar essa coisa usando a base

40851
27:06:33,360 --> 27:06:35,600
referências aqui, porque isso é apenas

40852
27:06:35,600 --> 27:06:37,192
vamos nos confundir, vamos construir

40853
27:06:37,192 --> 27:06:40,320
novamente e eu uso gcc para esta construção

40854
27:06:40,320 --> 27:06:42,640
vai ser bom dentro de claro e correr

40855
27:06:42,640 --> 27:06:44,800
Galo você vê perfuração oval porque nós

40856
27:06:44,800 --> 27:06:47,912
estão passando em um novo objeto se passarmos

40857
27:06:47,912 --> 27:06:50,320
em nossa forma, digamos, moldar um para

40858
27:06:50,320 --> 27:06:52,720
O exemplo vamos construir o livro é

40859
27:06:52,720 --> 27:06:54,480
Vou ser bom como você vê aqui, se nós

40860
27:06:54,480 --> 27:06:57,440
clear e run galo que vamos ver

40861
27:06:57,440 --> 27:06:59,832
desenho de forma se passarmos em círculo, vamos fazer

40862
27:06:59,832 --> 27:07:00,872
que

40863
27:07:00,872 --> 27:07:02,552
e o ousado novamente vamos construir

40864
27:07:02,552 --> 27:07:05,360
com gcc vamos limpar e correr

40865
27:07:05,360 --> 27:07:07,120
Galo você vai ver esse círculo

40866
27:07:07,120 --> 27:07:09,360
draw é chamado e isso é muito legal

40867
27:07:09,360 --> 27:07:12,800
só podemos usar um único método e este

40868
27:07:12,800 --> 27:07:14,640
O método vai tomar qualquer forma que nós

40869
27:07:14,640 --> 27:07:16,872
jogar nele e ele vai desenrará-lo

40870
27:07:16,872 --> 27:07:19,600
Se acontecer de termos 100 tipos de

40871
27:07:19,600 --> 27:07:21,600
formas em nosso programa podemos apenas para

40872
27:07:21,600 --> 27:07:23,280
exemplo loop através de uma coleção

40873
27:07:23,280 --> 27:07:25,600
contendo essas formas e se chamarmos

40874
27:07:25,600 --> 27:07:28,320
o método de desenho em qualquer forma que armazenamos em

40875
27:07:28,320 --> 27:07:30,320
nossa coleção, vamos conseguir o

40876
27:07:30,320 --> 27:07:32,720
de forma correta drone e isso é super

40877
27:07:32,720 --> 27:07:35,040
legal isso é realmente poderoso e eu espero

40878
27:07:35,040 --> 27:07:37,192
Você está animado para ser capaz de alcançar

40879
27:07:37,192 --> 27:07:39,680
isso em c plus plus agora nós também podemos

40880
27:07:39,680 --> 27:07:42,000
alcançar a mesma coisa usando um método

40881
27:07:42,000 --> 27:07:44,640
que toma uma referência, por exemplo, para que

40882
27:07:44,640 --> 27:07:48,480
pode dizer void joe shape vamos dizer v1 e

40883
27:07:48,480 --> 27:07:50,800
Vamos passar uma referência

40884
27:07:50,800 --> 27:07:53,680
podemos dizer const e passar uma referência

40885
27:07:53,680 --> 27:07:56,552
e dizer sr para dizer referência do navio nós podemos

40886
27:07:56,552 --> 27:07:59,280
fazer isso e nós vamos dizer sjo nós somos

40887
27:07:59,280 --> 27:08:01,360
Vou chamar o método da mandíbula sobre isso

40888
27:08:01,360 --> 27:08:03,440
referência e vamos ver o que acontece se

40889
27:08:03,440 --> 27:08:06,400
nós tentamos isso vamos dizer que é isso que

40890
27:08:06,400 --> 27:08:08,800
Devemos dizer aqui e isso vai

40891
27:08:08,800 --> 27:08:11,600
ser tomado pelo nosso código de estúdio visual

40892
27:08:11,600 --> 27:08:14,552
Editor se entrarmos aqui e mudarmos isso

40893
27:08:14,552 --> 27:08:15,760
para dizer

40894
27:08:15,760 --> 27:08:19,280
desenhar forma v1 nós podemos passar na forma um

40895
27:08:19,280 --> 27:08:21,192
Podemos fazer isso porque isso está tomando um

40896
27:08:21,192 --> 27:08:22,552
Referência agora

40897
27:08:22,552 --> 27:08:25,512
Se construirmos com gcc, vamos ver

40898
27:08:25,512 --> 27:08:27,600
que o mundo é bom, podemos limpar

40899
27:08:27,600 --> 27:08:29,280
Vamos deixar claro que vamos correr o

40900
27:08:29,280 --> 27:08:31,280
Galo isto vai chamar shape draw

40901
27:08:31,280 --> 27:08:33,512
porque estamos usando uma referência para

40902
27:08:33,512 --> 27:08:36,000
gerenciar um objeto em forma que também podemos passar

40903
27:08:36,000 --> 27:08:38,000
Isso sobre um e nós vamos construir

40904
27:08:38,000 --> 27:08:41,440
novamente e ver como isso funciona o parafuso é

40905
27:08:41,440 --> 27:08:43,600
Vou ser bom, podemos limpar e correr

40906
27:08:43,600 --> 27:08:45,440
Galo vamos dizer overdraw e

40907
27:08:45,440 --> 27:08:47,760
Vamos ver as nossas informações aqui

40908
27:08:47,760 --> 27:08:50,640
Se passarmos em nosso ciclo objeto

40909
27:08:50,640 --> 27:08:52,872
e o parafuso vamos passar isto

40910
27:08:52,872 --> 27:08:55,192
através de gcc o parafuso vai ser bom

40911
27:08:55,192 --> 27:08:57,440
nós podemos limpar e correr galo este é

40912
27:08:57,440 --> 27:08:59,600
Vou desenhar um círculo para nós, isto é

40913
27:08:59,600 --> 27:09:02,320
muito legal, temos um método novamente

40914
27:09:02,320 --> 27:09:04,552
que está tomando um parâmetro por referência

40915
27:09:04,552 --> 27:09:07,440
mas nós podemos usar este método para desenhar qualquer

40916
27:09:07,440 --> 27:09:09,912
tipo de forma em nossa herança

40917
27:09:09,912 --> 27:09:12,232
Hierarquia isso vai realmente funcionar

40918
27:09:12,232 --> 27:09:15,192
bem e está fazendo uma ligação dinâmica

40919
27:09:15,192 --> 27:09:17,680
que é alimentado por funções virtuais que nós

40920
27:09:17,680 --> 27:09:20,552
estão usando em nossa hierarquia de herança

40921
27:09:20,552 --> 27:09:22,872
Aqui você deve realmente manter isso em mente

40922
27:09:22,872 --> 27:09:25,680
Agora vamos voltar e ver se nós podemos

40923
27:09:25,680 --> 27:09:28,720
usar ponteiros de linha para fazer coisas que eu estou indo

40924
27:09:28,720 --> 27:09:30,640
para comentar isso e eu vou

40925
27:09:30,640 --> 27:09:33,192
Diga marcadores de rolo porque eu quero que você

40926
27:09:33,192 --> 27:09:34,800
ver algo que vamos montar um

40927
27:09:34,800 --> 27:09:36,552
shape pointer nós vamos dizer forma

40928
27:09:36,552 --> 27:09:37,760
ptr

40929
27:09:37,760 --> 27:09:40,000
Temos isso no topo aqui vamos ver se

40930
27:09:40,000 --> 27:09:41,280
nós fazemos isso.

40931
27:09:41,280 --> 27:09:44,872
Sim, temos forma ptr, então vamos dizer forma

40932
27:09:44,872 --> 27:09:46,320
ptr

40933
27:09:46,320 --> 27:09:48,480
e passar um novo objeto que estamos indo

40934
27:09:48,480 --> 27:09:50,552
para passar um romance novamente e nós vamos

40935
27:09:50,552 --> 27:09:53,280
passar o endereço de 01 que vai

40936
27:09:53,280 --> 27:09:56,000
Podemos chamar o método draw e obter

40937
27:09:56,000 --> 27:09:58,320
É chamado de polimorfia

40938
27:09:58,320 --> 27:10:00,960
ou obtê-lo chamado usando ligação dinâmica

40939
27:10:00,960 --> 27:10:03,192
nós podemos dizer forma ptr

40940
27:10:03,192 --> 27:10:05,912
e dizer empate que isso vai chamar de

40941
27:10:05,912 --> 27:10:08,800
Versão correta, mas uma coisa eu quero você

40942
27:10:08,800 --> 27:10:11,832
Ver é que se um método não é

40943
27:10:11,832 --> 27:10:14,800
polimórfico ou se um método não é

40944
27:10:14,800 --> 27:10:15,912
virtual

40945
27:10:15,912 --> 27:10:18,040
você quer obtê-lo chamado de uso

40946
27:10:18,040 --> 27:10:21,040
O polimorfismo, por exemplo, se formos para o nosso

40947
27:10:21,040 --> 27:10:22,800
classe oval vamos ver que nós

40948
27:10:22,800 --> 27:10:25,680
Tenho um monte de getters vamos entrar e

40949
27:10:25,680 --> 27:10:27,832
torná-los públicos para que sejam

40950
27:10:27,832 --> 27:10:31,192
callável de fora e se tentarmos

40951
27:10:31,192 --> 27:10:33,160
E obter isso chamado

40952
27:10:33,160 --> 27:10:36,480
polimorfiamente ou usando ligação dinâmica

40953
27:10:36,480 --> 27:10:38,320
que não vai funcionar vamos fazer isso

40954
27:10:38,320 --> 27:10:41,120
nós vamos dizer para obter x rad e

40955
27:10:41,120 --> 27:10:42,960
A razão podemos querer fazer alguma coisa

40956
27:10:42,960 --> 27:10:45,120
Como isso é porque temos esse método

40957
27:10:45,120 --> 27:10:46,000
Aqui

40958
27:10:46,000 --> 27:10:49,440
e está configurado em nossa classe oval

40959
27:10:49,440 --> 27:10:52,080
assim porque estamos usando um ponteiro base

40960
27:10:52,080 --> 27:10:54,960
para gerenciar um novo objeto alguns de vocês

40961
27:10:54,960 --> 27:10:57,192
pode pensar uh-huh eu posso ser capaz de

40962
27:10:57,192 --> 27:11:00,232
chamar este método porque eu sou capaz de

40963
27:11:00,232 --> 27:11:03,280
chamar o método de trabalho que também está no

40964
27:11:03,280 --> 27:11:06,720
escopo público de nossa classe, mas isso é

40965
27:11:06,720 --> 27:11:08,720
não vai funcionar porque este método

40966
27:11:08,720 --> 27:11:10,872
Aqui não é virtual

40967
27:11:10,872 --> 27:11:14,320
A ligação dinâmica ou polimorfismo é apenas

40968
27:11:14,320 --> 27:11:16,720
indo trabalhar se seus métodos são

40969
27:11:16,720 --> 27:11:19,760
virtual e eles estão configurados em todo o seu

40970
27:11:19,760 --> 27:11:22,552
hierarquia de herança, então isso não é

40971
27:11:22,552 --> 27:11:24,400
Vou trabalhar se você tentar fazer algo

40972
27:11:24,400 --> 27:11:26,160
Como este vai lhe dar um

40973
27:11:26,160 --> 27:11:28,800
Erro do compilador, vamos tentar construir e

40974
27:11:28,800 --> 27:11:30,552
Veja o erro do compilador e vamos

40975
27:11:30,552 --> 27:11:33,440
para ver um erro que diz que não

40976
27:11:33,440 --> 27:11:36,480
método sobre este objeto vamos aqui

40977
27:11:36,480 --> 27:11:38,320
A forma de classe não tem

40978
27:11:38,320 --> 27:11:41,360
A forma da classe não tem nome de membro para obter x

40979
27:11:41,360 --> 27:11:42,320
Vermelho

40980
27:11:42,320 --> 27:11:44,480
porque o método não é virtual

40981
27:11:44,480 --> 27:11:46,960
compilador vai fazer ligação estática

40982
27:11:46,960 --> 27:11:49,512
e vai usar o tipo de

40983
27:11:49,512 --> 27:11:51,600
o ponteiro que é moldado para resolver

40984
27:11:51,600 --> 27:11:54,000
Este método e vai ver que

40985
27:11:54,000 --> 27:11:56,000
em forma não temos um método chamado

40986
27:11:56,000 --> 27:11:58,400
obter xrad e o compilador está indo para

40987
27:11:58,400 --> 27:12:00,640
lançar este erro do compilador aqui este é

40988
27:12:00,640 --> 27:12:02,800
o que temos para que isso não funcione

40989
27:12:02,800 --> 27:12:05,120
E eu quero que você esteja ciente disso

40990
27:12:05,120 --> 27:12:06,960
Outra coisa que eu quero que você veja

40991
27:12:06,960 --> 27:12:10,080
é porque estamos usando dinâmica

40992
27:12:10,080 --> 27:12:11,600
Ligação agora

40993
27:12:11,600 --> 27:12:14,080
Não precisamos que não precisemos de nos estabelecer

40994
27:12:14,080 --> 27:12:16,720
todos os tipos de coleções loucas para levar

40995
27:12:16,720 --> 27:12:18,960
em consideração diferentes formas que nós

40996
27:12:18,960 --> 27:12:22,160
ter em nosso c plus programa que

40997
27:12:22,160 --> 27:12:24,320
nós vamos fazer aqui é usar uma base

40998
27:12:24,320 --> 27:12:27,192
ponteiro para gerenciar os dados que armazenamos

40999
27:12:27,192 --> 27:12:30,480
em nossa matriz aqui, então tudo que eu vou

41000
27:12:30,480 --> 27:12:33,360
fazer é remover toda essa sujeira aqui porque

41001
27:12:33,360 --> 27:12:35,120
Isto é realmente sujeira que você não quer fazer

41002
27:12:35,120 --> 27:12:37,120
Algo assim e nós vamos

41003
27:12:37,120 --> 27:12:39,192
usar um ponteiro base que é uma forma

41004
27:12:39,192 --> 27:12:42,232
ponteiro e use isso para configurar um array

41005
27:12:42,232 --> 27:12:44,232
que pode lidar com qualquer tipo de forma que nós

41006
27:12:44,232 --> 27:12:47,440
Temos em nossa hierarquia de herança, então nós

41007
27:12:47,440 --> 27:12:50,000
pode armazená-lo em forma de objetos que podemos armazenar

41008
27:12:50,000 --> 27:12:52,320
Isso sobre objetos que podemos armazenar em círculo

41009
27:12:52,320 --> 27:12:54,960
objetos e se nós nos parecemos que fazemos aqui

41010
27:12:54,960 --> 27:12:56,640
Vamos obter o método correto

41011
27:12:56,640 --> 27:12:58,720
chamado e isso vai ser super

41012
27:12:58,720 --> 27:13:01,192
legal, então vamos tentar executar este programa

41013
27:13:01,192 --> 27:13:03,680
nós vamos passar isso por Gcc por quê

41014
27:13:03,680 --> 27:13:05,912
Temos a coisa vermelha aqui vamos

41015
27:13:05,912 --> 27:13:08,960
construir e ver se ele vai embora talvez isso

41016
27:13:08,960 --> 27:13:11,192
é código de estúdio visual que tem um problema

41017
27:13:11,192 --> 27:13:13,120
com o nosso código o mundo é bom

41018
27:13:13,120 --> 27:13:15,360
Código de estúdio visual estava brincando conosco

41019
27:13:15,360 --> 27:13:17,512
nós vamos limpar e correr o galo

41020
27:13:17,512 --> 27:13:19,192
você vai ver que nós vamos

41021
27:13:19,192 --> 27:13:22,552
estar fazendo loop através desta matriz aqui e

41022
27:13:22,552 --> 27:13:24,160
Na primeira iteração, vamos

41023
27:13:24,160 --> 27:13:26,160
call shape draw porque a primeira coisa

41024
27:13:26,160 --> 27:13:28,480
é a forma da segunda iteração

41025
27:13:28,480 --> 27:13:30,552
nós vamos chamar overdraw porque o

41026
27:13:30,552 --> 27:13:33,192
A segunda coisa é um romance e nós vamos

41027
27:13:33,192 --> 27:13:34,160
A sua forma de

41028
27:13:34,160 --> 27:13:36,720
acertar a terceira iteração e call circle

41029
27:13:36,720 --> 27:13:39,280
desenhar porque a terceira coisa nisso

41030
27:13:39,280 --> 27:13:41,832
Coleção é um círculo espero que você possa

41031
27:13:41,832 --> 27:13:44,080
Veja que isso vai simplificar o nosso

41032
27:13:44,080 --> 27:13:47,192
Programas muito em comparação com o que éramos

41033
27:13:47,192 --> 27:13:48,480
capaz de fazer

41034
27:13:48,480 --> 27:13:50,160
na última palestra e isso é realmente

41035
27:13:50,160 --> 27:13:52,160
Tudo que eu tinha que compartilhar nesta palestra

41036
27:13:52,160 --> 27:13:54,720
mostrando que você pode alcançar dinâmica

41037
27:13:54,720 --> 27:13:58,480
ligação ou polimorfismo ou ligação tardia

41038
27:13:58,480 --> 27:14:01,040
como algumas pessoas chamam de uso virtual

41039
27:14:01,040 --> 27:14:03,832
funções em sua hierarquia de herança

41040
27:14:03,832 --> 27:14:06,720
Mais uma vez tudo o que tínhamos que fazer era marcar o nosso

41041
27:14:06,720 --> 27:14:09,512
O membro funciona como um virtual e

41042
27:14:09,512 --> 27:14:11,360
O compilador vai saber que ele pode

41043
27:14:11,360 --> 27:14:14,160
configurar o polimorfismo dinâmico para o seu

41044
27:14:14,160 --> 27:14:17,040
Tipos se você estiver gerenciando-os

41045
27:14:17,040 --> 27:14:20,232
usando um ponteiro de base ou uma referência base

41046
27:14:20,232 --> 27:14:21,912
Vamos parar aqui neste

41047
27:14:21,912 --> 27:14:23,680
palestra e a próxima que vamos

41048
27:14:23,680 --> 27:14:26,552
Aprenda sobre o polimento e o tamanho de

41049
27:14:26,552 --> 27:14:28,800
Objetos polimórficos

41050
27:14:28,800 --> 27:14:31,120
Vá em frente e termine aqui e me encontre

41051
27:14:31,120 --> 27:14:32,872
lá nesta palestra vamos

41052
27:14:32,872 --> 27:14:37,040
Explorar o tamanho de objetos polimórficos

41053
27:14:37,040 --> 27:14:40,160
ou objetos que usam ligação dinâmica e

41054
27:14:40,160 --> 27:14:42,160
Vamos aprender sobre o conceito

41055
27:14:42,160 --> 27:14:45,192
de cortar se você atribuir um

41056
27:14:45,192 --> 27:14:48,400
objeto derivado para um objeto base que somos

41057
27:14:48,400 --> 27:14:50,232
Vou ver como isso funciona no

41058
27:14:50,232 --> 27:14:52,232
As duas últimas palestras vimos que poderíamos

41059
27:14:52,232 --> 27:14:54,872
alcançar a ligação estática usando uma configuração

41060
27:14:54,872 --> 27:14:57,192
Como isso, podemos criar uma herança

41061
27:14:57,192 --> 27:15:00,000
Hierarquia e nós vamos ter oval

41062
27:15:00,000 --> 27:15:02,800
derivar ou herdar da forma e nós somos

41063
27:15:02,800 --> 27:15:06,400
ter um círculo herdando ou derivando

41064
27:15:06,400 --> 27:15:09,440
daqui e nossos métodos estão indo

41065
27:15:09,440 --> 27:15:11,440
para ser remo, eles não vão ser

41066
27:15:11,440 --> 27:15:13,600
virtual em qualquer coisa e isso vai

41067
27:15:13,600 --> 27:15:16,080
fazer ligação estática se acontecer de

41068
27:15:16,080 --> 27:15:18,552
gerenciar um objeto derivado através de uma base

41069
27:15:18,552 --> 27:15:21,040
ponteiro ou referência que você quer obter

41070
27:15:21,040 --> 27:15:23,360
buracos dinâmicos que você vai ficar estático

41071
27:15:23,360 --> 27:15:25,512
a ligação e o compilador irá usar o

41072
27:15:25,512 --> 27:15:28,000
ponteiro de base ou referência de base para decidir

41073
27:15:28,000 --> 27:15:31,120
que draw método para chamar o seu objeto

41074
27:15:31,120 --> 27:15:32,872
Também vimos que poderíamos alcançar

41075
27:15:32,872 --> 27:15:36,080
ligação dinâmica usando funções virtuais

41076
27:15:36,080 --> 27:15:38,640
E tudo o que precisávamos fazer era marcar o nosso

41077
27:15:38,640 --> 27:15:41,680
métodos como virtuais em nossa herança

41078
27:15:41,680 --> 27:15:44,120
Hierarquia aqui e isso nos daria

41079
27:15:44,120 --> 27:15:47,912
Polimorfismo ou ligação dinâmica, mas um

41080
27:15:47,912 --> 27:15:50,232
O que você deve saber é essa dinâmica

41081
27:15:50,232 --> 27:15:52,480
A ligação não é livre que você vai ser

41082
27:15:52,480 --> 27:15:55,600
pagando em termos de memória para obter tudo

41083
27:15:55,600 --> 27:15:57,512
Essas coisas legais que vimos no último

41084
27:15:57,512 --> 27:15:59,192
palestra e vamos provar

41085
27:15:59,192 --> 27:16:01,360
que nesta palestra estamos indo

41086
27:16:01,360 --> 27:16:03,512
Estar fazendo é basicamente configurar o nosso

41087
27:16:03,512 --> 27:16:05,912
Hierarquia de herança e nós vamos

41088
27:16:05,912 --> 27:16:08,400
para estabelecer isso de tal forma que seja

41089
27:16:08,400 --> 27:16:10,232
Vou usar a ligação estática que somos

41090
27:16:10,232 --> 27:16:12,000
Vou ver os tamanhos que somos impressos

41091
27:16:12,000 --> 27:16:14,400
Aqui e vamos usar dinâmica

41092
27:16:14,400 --> 27:16:17,360
vincular e comparar os tamanhos e a

41093
27:16:17,360 --> 27:16:19,912
A Constituição vai ser isso com

41094
27:16:19,912 --> 27:16:22,872
ligação dinâmica que seus objetos estão indo

41095
27:16:22,872 --> 27:16:25,760
ser muito maior porque seu mais simples

41096
27:16:25,760 --> 27:16:28,800
O programa plus precisará acompanhar

41097
27:16:28,800 --> 27:16:30,320
a informação

41098
27:16:30,320 --> 27:16:32,960
que permite resolver

41099
27:16:32,960 --> 27:16:35,280
chamadas de função de forma dinâmica e que

41100
27:16:35,280 --> 27:16:37,360
A informação é armazenada no que chamamos de

41101
27:16:37,360 --> 27:16:40,320
mesas virtuais, mas eu não vou

41102
27:16:40,320 --> 27:16:42,552
Isso aqui porque está realmente fora

41103
27:16:42,552 --> 27:16:45,512
de escopo de um curso como este, mas eu

41104
27:16:45,512 --> 27:16:47,600
Quer que você esteja ciente disso se você usar

41105
27:16:47,600 --> 27:16:50,640
dinâmica se você usar a ligação dinâmica

41106
27:16:50,640 --> 27:16:53,280
Objetos vão ser muito maiores ok

41107
27:16:53,280 --> 27:16:55,040
A primeira coisa que eu quero trazer você

41108
27:16:55,040 --> 27:16:56,232
Atenção para

41109
27:16:56,232 --> 27:16:58,800
é objetos cortando e nós vamos

41110
27:16:58,800 --> 27:17:01,040
Veja um exemplo simples aqui que temos

41111
27:17:01,040 --> 27:17:03,512
nossos objetos temos um objeto de forma, nós

41112
27:17:03,512 --> 27:17:06,080
ter um objeto oval e temos um círculo

41113
27:17:06,080 --> 27:17:10,080
objeto e aqui em baixo queremos atribuir

41114
27:17:10,080 --> 27:17:14,080
nosso objeto de círculo para um objeto de forma

41115
27:17:14,080 --> 27:17:16,800
Agora observe que aqui não estamos usando um

41116
27:17:16,800 --> 27:17:19,192
ponteiro ou uma referência estes são apenas

41117
27:17:19,192 --> 27:17:21,600
os objetos de linha aos quais estamos atribuindo

41118
27:17:21,600 --> 27:17:23,760
E o que é um concorrente

41119
27:17:23,760 --> 27:17:25,440
basicamente indo fazer

41120
27:17:25,440 --> 27:17:28,160
Vai notar que um círculo tem um

41121
27:17:28,160 --> 27:17:30,872
forma de acordo com ele e vai

41122
27:17:30,872 --> 27:17:33,832
tira das camadas externas ou no outro

41123
27:17:33,832 --> 27:17:35,832
palavras que vai tirar o

41124
27:17:35,832 --> 27:17:38,320
camada de círculo que vai se despir

41125
27:17:38,320 --> 27:17:40,552
a camada oval e vai sair

41126
27:17:40,552 --> 27:17:43,360
na parte da forma e é isso que é

41127
27:17:43,360 --> 27:17:46,400
vamos atribuir ao nosso objeto de forma aqui

41128
27:17:46,400 --> 27:17:49,040
Vamos visualizar esta nossa classe de forma

41129
27:17:49,040 --> 27:17:51,360
Parece o que temos aqui na esquerda

41130
27:17:51,360 --> 27:17:55,192
nossa classe oval tem uma parte de forma nela

41131
27:17:55,192 --> 27:17:57,440
e nosso círculo vai ter um over

41132
27:17:57,440 --> 27:17:59,832
parte dele e essa parte oval está indo

41133
27:17:59,832 --> 27:18:02,160
ter uma parte da forma e isso é

41134
27:18:02,160 --> 27:18:05,120
A configuração que temos aqui agora, se fizermos

41135
27:18:05,120 --> 27:18:06,872
nossa tarefa nós vamos fazer

41136
27:18:06,872 --> 27:18:08,640
algo assim o compilador é

41137
27:18:08,640 --> 27:18:10,400
Vou ver que já estamos

41138
27:18:10,400 --> 27:18:12,552
A atribuição de um círculo

41139
27:18:12,552 --> 27:18:14,400
para uma forma e o compilador vai

41140
27:18:14,400 --> 27:18:16,640
Veja que o que temos à esquerda é

41141
27:18:16,640 --> 27:18:19,512
Apenas uma forma e não temos o suficiente

41142
27:18:19,512 --> 27:18:22,640
espaço para armazenar informações sobre o oval

41143
27:18:22,640 --> 27:18:24,960
e o círculo aqui, então qual é o compilador

41144
27:18:24,960 --> 27:18:26,872
Vai fazer isso vai se despir

41145
27:18:26,872 --> 27:18:28,872
todas essas coisas que nós realmente não

41146
27:18:28,872 --> 27:18:31,680
necessidade e vai sair apenas em

41147
27:18:31,680 --> 27:18:32,552
O que é

41148
27:18:32,552 --> 27:18:36,000
forma parte que podemos atribuir sobre o que nós

41149
27:18:36,000 --> 27:18:38,552
Você tem para a esquerda, então ele vai tirar

41150
27:18:38,552 --> 27:18:40,552
de todas essas arquibancadas e nós vamos

41151
27:18:40,552 --> 27:18:42,480
ser deixado com algo assim e

41152
27:18:42,480 --> 27:18:44,480
Então o que temos na direita está indo

41153
27:18:44,480 --> 27:18:46,640
ser atribuído à esquerda e nós vamos

41154
27:18:46,640 --> 27:18:50,320
ter nossos dados armazenados em nosso navio para

41155
27:18:50,320 --> 27:18:52,960
objeto e se tentarmos usá-lo que é

41156
27:18:52,960 --> 27:18:55,192
O que você vai ficar na memória, então

41157
27:18:55,192 --> 27:18:57,832
Isto é referido como cortando novamente o

41158
27:18:57,832 --> 27:18:59,440
O compilador vai notar que ele

41159
27:18:59,440 --> 27:19:01,512
Realmente não tem espaço suficiente no

41160
27:19:01,512 --> 27:19:03,040
para a loja

41161
27:19:03,040 --> 27:19:04,872
Tudo que temos à direita do

41162
27:19:04,872 --> 27:19:07,512
tarefa aqui e vai despir

41163
27:19:07,512 --> 27:19:09,680
fora ou cortar fora

41164
27:19:09,680 --> 27:19:12,640
Tudo que não precisamos e é apenas

41165
27:19:12,640 --> 27:19:15,600
sair na parte da forma e

41166
27:19:15,600 --> 27:19:18,720
Isso é o que vai atribuir em nosso

41167
27:19:18,720 --> 27:19:21,440
Objeto que temos à esquerda do

41168
27:19:21,440 --> 27:19:23,760
Operador de atribuição aqui e este é

41169
27:19:23,760 --> 27:19:27,280
referido como fatiar em c mais mais

41170
27:19:27,280 --> 27:19:29,360
Terminologia eu só quero que você esteja ciente

41171
27:19:29,360 --> 27:19:31,512
Isso e vamos ver um monte de

41172
27:19:31,512 --> 27:19:34,000
Isso a partir de agora agora que você sabe

41173
27:19:34,000 --> 27:19:35,600
Isso nós vamos ir para o visual

41174
27:19:35,600 --> 27:19:37,440
código de estúdio e jogar com isso um pouco

41175
27:19:37,440 --> 27:19:40,160
Mais aqui estamos em nossa pasta de trabalho

41176
27:19:40,160 --> 27:19:42,800
O projeto atual é o tamanho de

41177
27:19:42,800 --> 27:19:46,320
objetos polimórficos e cortando nós somos

41178
27:19:46,320 --> 27:19:48,000
Vou pegar o código do último

41179
27:19:48,000 --> 27:19:50,552
palestra, então vamos pegar tudo, exceto

41180
27:19:50,552 --> 27:19:53,600
para o arquivo binário que vamos copiar

41181
27:19:53,600 --> 27:19:55,760
Tudo e nós vamos colocar isso

41182
27:19:55,760 --> 27:19:58,480
na pasta atual e nós vamos

41183
27:19:58,480 --> 27:20:00,552
abrir este pequeno cara no estúdio visual

41184
27:20:00,552 --> 27:20:03,040
código arrastando e soltando aqui isso

41185
27:20:03,040 --> 27:20:05,512
vai nos dar o nosso projeto e nós

41186
27:20:05,512 --> 27:20:09,192
pode ir sobre o arquivo principal cpp

41187
27:20:09,192 --> 27:20:11,512
e limpar toda a bagunça que temos

41188
27:20:11,512 --> 27:20:14,232
As últimas palestras anteriores podemos também

41189
27:20:14,232 --> 27:20:16,640
tirar essas funções porque eu não

41190
27:20:16,640 --> 27:20:18,800
Acho que precisamos deles aqui

41191
27:20:18,800 --> 27:20:21,280
e nós vamos verificar o nosso

41192
27:20:21,280 --> 27:20:24,000
As aulas notam que estamos usando dinâmica

41193
27:20:24,000 --> 27:20:26,720
Polimorfismo porque temos virtualmente

41194
27:20:26,720 --> 27:20:29,192
Funciona aqui, então se acontecer de nós sermos

41195
27:20:29,192 --> 27:20:31,832
usando ponteiros de base ou referências de base

41196
27:20:31,832 --> 27:20:35,040
para gerenciar nossos objetos derivados, vamos

41197
27:20:35,040 --> 27:20:37,912
obter resultados polimórficos ok the first

41198
27:20:37,912 --> 27:20:40,640
O que queremos ver é o tamanho de

41199
27:20:40,640 --> 27:20:43,680
objetos para nossas aulas aqui porque

41200
27:20:43,680 --> 27:20:46,400
estão usando funções virtuais, vamos cabeça

41201
27:20:46,400 --> 27:20:48,960
sobre no arquivo principal cpp e nós estamos

41202
27:20:48,960 --> 27:20:51,192
Vou colocar um pedaço de código que é

41203
27:20:51,192 --> 27:20:53,440
apenas usar o tamanho do operador

41204
27:20:53,440 --> 27:20:55,280
para imprimir os tamanhos

41205
27:20:55,280 --> 27:20:58,400
de objetos dessas classes podemos tentar

41206
27:20:58,400 --> 27:21:00,480
para construir e executar este programa nós somos

41207
27:21:00,480 --> 27:21:02,872
indo para usar gcc aqui o mundo é apenas

41208
27:21:02,872 --> 27:21:05,600
Vou ser bom, podemos trazer uma

41209
27:21:05,600 --> 27:21:07,600
janela powershell que podemos usar para executar

41210
27:21:07,600 --> 27:21:09,120
Estes programas

41211
27:21:09,120 --> 27:21:11,832
Vamos fazer esse novo terminal.

41212
27:21:11,832 --> 27:21:13,832
Vai trazer-nos a nossa janela aqui nós

41213
27:21:13,832 --> 27:21:16,480
pode limpar e correr galo que vamos

41214
27:21:16,480 --> 27:21:19,600
obter 40 56 e 56

41215
27:21:19,600 --> 27:21:22,640
Então você vê que estes são nossos tamanhos, então

41216
27:21:22,640 --> 27:21:25,360
Vamos dizer que com uh dinâmica está indo

41217
27:21:25,360 --> 27:21:28,232
ser 40 para a classe base com dinâmica

41218
27:21:28,232 --> 27:21:31,280
Portal morphism nós vamos ter 56

41219
27:21:31,280 --> 27:21:32,400
para o

41220
27:21:32,400 --> 27:21:35,040
objeto oval e nós vamos chegar

41221
27:21:35,040 --> 27:21:38,320
dinâmica 56 para o

41222
27:21:38,320 --> 27:21:41,040
objeto de círculo aqui agora vamos

41223
27:21:41,040 --> 27:21:44,720
remover a configuração que usa polimorfismo

41224
27:21:44,720 --> 27:21:46,232
e vamos ver os resultados que

41225
27:21:46,232 --> 27:21:48,640
Tudo o que precisamos fazer é remover

41226
27:21:48,640 --> 27:21:51,040
A palavra-chave virtual aqui podemos comentar

41227
27:21:51,040 --> 27:21:53,760
Isso você pode fazer algo assim em

41228
27:21:53,760 --> 27:21:56,480
forma e vamos saltar para dentro

41229
27:21:56,480 --> 27:21:59,192
oval e comentar a chave virtual

41230
27:21:59,192 --> 27:22:00,872
mundo nós podemos fazer algo assim e

41231
27:22:00,872 --> 27:22:02,320
Isto vai para

41232
27:22:02,320 --> 27:22:04,640
trabalhar sem remover isso completamente

41233
27:22:04,640 --> 27:22:06,872
do nosso código porque ainda precisamos

41234
27:22:06,872 --> 27:22:09,680
Deixe isso como uma referência que estamos indo

41235
27:22:09,680 --> 27:22:12,160
para saltar para circular e fazer o mesmo

41236
27:22:12,160 --> 27:22:13,120
uma coisa

41237
27:22:13,120 --> 27:22:15,280
E agora que temos essa configuração, podemos

41238
27:22:15,280 --> 27:22:17,912
saltar para o nosso arquivo cpp principal que somos

41239
27:22:17,912 --> 27:22:19,512
Vou ver que não temos nenhum

41240
27:22:19,512 --> 27:22:22,080
squiggly linhas de algum tipo, então isso é

41241
27:22:22,080 --> 27:22:24,640
será aceito pelo compilador, mas

41242
27:22:24,640 --> 27:22:26,720
Se construirmos e executarmos este programa, nós somos

41243
27:22:26,720 --> 27:22:28,960
Vou ver diferentes tamanhos, vamos ver

41244
27:22:28,960 --> 27:22:30,960
Se o mundo é bom, é bom como você

41245
27:22:30,960 --> 27:22:33,912
Veja aqui podemos limpar e correr o galo

41246
27:22:33,912 --> 27:22:36,080
Agora você vê isso com

41247
27:22:36,080 --> 27:22:39,912
A ligação estática o objeto base é 32

41248
27:22:39,912 --> 27:22:43,600
bytes o objeto terrível vai ser 48

41249
27:22:43,600 --> 27:22:45,120
E espero que você possa ver isso com

41250
27:22:45,120 --> 27:22:48,080
polimorfismo dinâmico nossos objetos são

41251
27:22:48,080 --> 27:22:50,232
Vai ser muito maior porque o

41252
27:22:50,232 --> 27:22:52,160
O compilador tem que manter o controle do

41253
27:22:52,160 --> 27:22:54,480
Informações que permitem que

41254
27:22:54,480 --> 27:22:56,720
A resolução dinâmica

41255
27:22:56,720 --> 27:22:59,192
A função virtual chama, é por isso que

41256
27:22:59,192 --> 27:23:02,872
objetos são maiores com polimorfismo e

41257
27:23:02,872 --> 27:23:04,960
Você deve saber que você não está recebendo

41258
27:23:04,960 --> 27:23:07,680
Polymorphic resultados grátis you are

41259
27:23:07,680 --> 27:23:11,040
Vou pagar em termos de muito mais

41260
27:23:11,040 --> 27:23:13,680
memória que você usa para seus objetos em

41261
27:23:13,680 --> 27:23:16,080
seus c plus programas este é o

41262
27:23:16,080 --> 27:23:17,912
primeira coisa que eu quero que você veja nisso

41263
27:23:17,912 --> 27:23:19,832
dar uma palestra a segunda coisa que eu quero que você

41264
27:23:19,832 --> 27:23:23,360
Esteja ciente do conceito de polimento

41265
27:23:23,360 --> 27:23:25,192
E isso vai acontecer se você

41266
27:23:25,192 --> 27:23:27,440
Acontecer para tomar um cru

41267
27:23:27,440 --> 27:23:30,552
objeto derivado e atribuir isso a uma linha

41268
27:23:30,552 --> 27:23:32,552
Objeto baseado, vamos fazer algo como

41269
27:23:32,552 --> 27:23:34,800
que vamos criar um círculo

41270
27:23:34,800 --> 27:23:36,872
Objeto e então vamos dizer forma

41271
27:23:36,872 --> 27:23:39,360
e dizer forma aqui e nós vamos

41272
27:23:39,360 --> 27:23:41,680
Diga é igual ao círculo um

41273
27:23:41,680 --> 27:23:43,512
Isso é algo que poderíamos fazer

41274
27:23:43,512 --> 27:23:46,160
mas perceber que o compilador não é

41275
27:23:46,160 --> 27:23:48,320
dando-nos qualquer tipo de erro do compilador

41276
27:23:48,320 --> 27:23:50,080
porque podemos atribuir um círculo a

41277
27:23:50,080 --> 27:23:52,232
forma porque um círculo é realmente uma forma

41278
27:23:52,232 --> 27:23:54,872
mas do que sabemos em nossa herança

41279
27:23:54,872 --> 27:23:57,832
Hierarquia um círculo é realmente muito mais

41280
27:23:57,832 --> 27:24:00,320
do que uma forma de linha, um círculo tem horrível

41281
27:24:00,320 --> 27:24:03,440
informação nele e também tem círculo

41282
27:24:03,440 --> 27:24:05,760
informações nele, então é realmente muito

41283
27:24:05,760 --> 27:24:08,080
maior e muito mais largo do que uma forma

41284
27:24:08,080 --> 27:24:10,320
objeto mas o compilador vai ver

41285
27:24:10,320 --> 27:24:12,960
que estamos tentando atribuir um círculo para

41286
27:24:12,960 --> 27:24:15,120
uma forma e vai ser inteligente

41287
27:24:15,120 --> 27:24:16,552
o suficiente para saber

41288
27:24:16,552 --> 27:24:18,720
que nós realmente não precisamos de oval e

41289
27:24:18,720 --> 27:24:21,360
informações do círculo em nosso objeto de forma

41290
27:24:21,360 --> 27:24:23,680
que estamos armazenando aqui para o compilador

41291
27:24:23,680 --> 27:24:26,160
vai cortar o círculo e oval

41292
27:24:26,160 --> 27:24:29,040
informação e vai sair em

41293
27:24:29,040 --> 27:24:30,960
informação de forma e isso é o único

41294
27:24:30,960 --> 27:24:33,512
O que poderemos usar com isso

41295
27:24:33,512 --> 27:24:35,440
variável de forma que temos em nosso c

41296
27:24:35,440 --> 27:24:38,080
plus plus programa, por isso, se dissermos forma

41297
27:24:38,080 --> 27:24:40,232
drill você pode tentar adivinhar o que somos

41298
27:24:40,232 --> 27:24:42,320
indo para chegar e vamos voltar e

41299
27:24:42,320 --> 27:24:45,600
reenable polimorfismo porque alguns

41300
27:24:45,600 --> 27:24:47,192
Você pode pensar que nós vamos conseguir

41301
27:24:47,192 --> 27:24:49,360
Resultados polimórficos

41302
27:24:49,360 --> 27:24:51,680
com esta configuração aqui que não é o que

41303
27:24:51,680 --> 27:24:54,552
nós vamos conseguir porque não estamos

41304
27:24:54,552 --> 27:24:57,120
passando por referências de moldura ou base

41305
27:24:57,120 --> 27:24:58,480
ponteiros para

41306
27:24:58,480 --> 27:25:01,040
fazer o que estamos fazendo neste exemplo em

41307
27:25:01,040 --> 27:25:03,600
cortando aqui porque não estamos usando

41308
27:25:03,600 --> 27:25:06,160
referências de base ou ponteiros de base neste

41309
27:25:06,160 --> 27:25:08,480
linha aqui o compilador vai ver

41310
27:25:08,480 --> 27:25:10,800
que estes são objetos crus e é

41311
27:25:10,800 --> 27:25:13,280
Vou fazer fatias e fatias de coisas

41312
27:25:13,280 --> 27:25:16,480
Não precisamos em nossa forma variável

41313
27:25:16,480 --> 27:25:19,280
que estamos montando na linha 16 aqui

41314
27:25:19,280 --> 27:25:21,680
então, se chamarmos o método draw, isso é

41315
27:25:21,680 --> 27:25:23,832
indo para chamar shape draw

41316
27:25:23,832 --> 27:25:25,440
Não vai fazer dinâmica

41317
27:25:25,440 --> 27:25:27,832
Polimorfismo aqui você deve estar ciente

41318
27:25:27,832 --> 27:25:29,760
Isso se você não estiver usando a base

41319
27:25:29,760 --> 27:25:32,080
ponteiros ou referências e você espera

41320
27:25:32,080 --> 27:25:35,680
obter resultados de polimorfismo dinâmico que eu odeio

41321
27:25:35,680 --> 27:25:37,040
para quebrá-lo para você, mas você está indo para

41322
27:25:37,040 --> 27:25:39,280
ficar desapontado porque o compilador é

41323
27:25:39,280 --> 27:25:41,360
vai cortar a classe derivada

41324
27:25:41,360 --> 27:25:43,680
informação e tudo o que você vai ser

41325
27:25:43,680 --> 27:25:46,480
com informações de classe base aqui

41326
27:25:46,480 --> 27:25:48,872
É por isso que isto vai chamar o navio

41327
27:25:48,872 --> 27:25:51,120
desenhar vamos construir e correr e realmente fazer

41328
27:25:51,120 --> 27:25:52,960
você vê que isso vai passar

41329
27:25:52,960 --> 27:25:55,912
gcc nosso compilador favorito a bala é

41330
27:25:55,912 --> 27:25:58,160
Vamos ser bons, não podemos limpar e correr

41331
27:25:58,160 --> 27:26:00,400
Galo você vai ver que é

41332
27:26:00,400 --> 27:26:03,192
vamos dizer desenho de forma mesmo se tentarmos

41333
27:26:03,192 --> 27:26:06,640
para atribuir um círculo a uma forma aqui este

41334
27:26:06,640 --> 27:26:08,400
vai nos decepcionar porque isso

41335
27:26:08,400 --> 27:26:11,040
é realmente cortar fora do círculo e

41336
27:26:11,040 --> 27:26:12,400
informações ovais

41337
27:26:12,400 --> 27:26:14,800
E só vai sair no

41338
27:26:14,800 --> 27:26:18,480
Núcleo de forma que temos em nosso círculo

41339
27:26:18,480 --> 27:26:19,760
O objeto aqui

41340
27:26:19,760 --> 27:26:22,080
se eu posso dizer assim que isso é realmente

41341
27:26:22,080 --> 27:26:23,912
Tudo que eu tinha que compartilhar nesta palestra i

41342
27:26:23,912 --> 27:26:26,080
Espero que você tenha achado interessante que somos

41343
27:26:26,080 --> 27:26:27,912
Vou parar aqui nesta palestra em

41344
27:26:27,912 --> 27:26:29,680
O próximo vamos ver o que

41345
27:26:29,680 --> 27:26:32,800
acontece se tentarmos armazenar polimórfico

41346
27:26:32,800 --> 27:26:35,040
objetos em coleções

41347
27:26:35,040 --> 27:26:37,280
Vá em frente e termine aqui e me encontre

41348
27:26:37,280 --> 27:26:39,280
lá nesta palestra vamos

41349
27:26:39,280 --> 27:26:42,400
Explore o que acontece se você tentar

41350
27:26:42,400 --> 27:26:46,400
armazenar diretamente objetos polimórficos em um

41351
27:26:46,400 --> 27:26:48,640
Coleção como um array

41352
27:26:48,640 --> 27:26:50,872
na última palestra vimos que se

41353
27:26:50,872 --> 27:26:54,552
você atribui um objeto derivado a uma base

41354
27:26:54,552 --> 27:26:55,760
objeto

41355
27:26:55,760 --> 27:26:58,320
Os dados do objeto derivado são

41356
27:26:58,320 --> 27:27:01,440
vai ser basicamente cortado fora se você

41357
27:27:01,440 --> 27:27:04,720
atribuir um oval a uma forma da parte oval

41358
27:27:04,720 --> 27:27:07,440
do objeto vai ser cortado

41359
27:27:07,440 --> 27:27:10,232
e nós vamos ficar com apenas

41360
27:27:10,232 --> 27:27:12,960
dados em forma que atribuímos ao nosso

41361
27:27:12,960 --> 27:27:15,440
Objeta de forma que vimos que isso era

41362
27:27:15,440 --> 27:27:18,552
referido como fatiar em c mais mais

41363
27:27:18,552 --> 27:27:20,400
e o mesmo vai acontecer se você

41364
27:27:20,400 --> 27:27:23,192
atribuir um objeto circular a uma forma

41365
27:27:23,192 --> 27:27:25,280
Informações do círculo serão cortadas

41366
27:27:25,280 --> 27:27:26,232
De fora

41367
27:27:26,232 --> 27:27:29,040
então a informação oval também está indo

41368
27:27:29,040 --> 27:27:31,040
para ser cortado fora e nós vamos ser

41369
27:27:31,040 --> 27:27:34,400
à esquerda com a parte interna da forma

41370
27:27:34,400 --> 27:27:38,080
que atribuímos ao nosso objeto de forma aqui

41371
27:27:38,080 --> 27:27:39,912
Agora eu quero que você veja que isso pode

41372
27:27:39,912 --> 27:27:42,640
Acontece indiretamente de maneiras que você pode

41373
27:27:42,640 --> 27:27:45,512
Não espere e vamos usar o nosso

41374
27:27:45,512 --> 27:27:48,080
Hierarquia de herança novamente a base

41375
27:27:48,080 --> 27:27:50,552
A classe vai ser a forma que estamos indo

41376
27:27:50,552 --> 27:27:53,040
para herdar disso e obter oval e

41377
27:27:53,040 --> 27:27:55,512
Vamos herdar do oval e conseguir

41378
27:27:55,512 --> 27:27:57,760
nossa classe de círculo aqui

41379
27:27:57,760 --> 27:28:00,640
então vamos olhar para um pedaço de código aqui nós

41380
27:28:00,640 --> 27:28:03,040
Estamos criando um monte de objetos que temos

41381
27:28:03,040 --> 27:28:06,080
um monte de círculos e ovais e nós somos

41382
27:28:06,080 --> 27:28:08,400
A criação de um array que vai

41383
27:28:08,400 --> 27:28:11,360
armazenar diretamente objetos de forma

41384
27:28:11,360 --> 27:28:14,800
Mas o que estamos fazendo é armazenar o nosso

41385
27:28:14,800 --> 27:28:19,360
objetos pré criados em nossa matriz aqui

41386
27:28:19,360 --> 27:28:22,000
e do que você já sabe se você

41387
27:28:22,000 --> 27:28:25,512
armazene objetos em uma matriz como esta

41388
27:28:25,512 --> 27:28:27,760
vai criar cópias mesmo se você

41389
27:28:27,760 --> 27:28:30,320
Não posso ver isso diretamente, então o que temos

41390
27:28:30,320 --> 27:28:33,360
em nossa matriz aqui não é sujeira, então o que nós

41391
27:28:33,360 --> 27:28:36,640
ter em nossa matriz aqui não é qualquer tipo

41392
27:28:36,640 --> 27:28:39,040
de referência direta ao objeto que nós

41393
27:28:39,040 --> 27:28:42,400
Tenho no topo aqui estas são apenas cópias

41394
27:28:42,400 --> 27:28:44,320
e perceber o que está acontecendo, nós somos

41395
27:28:44,320 --> 27:28:47,120
cópia de objetos derivados

41396
27:28:47,120 --> 27:28:49,912
em locais projetados para armazenar

41397
27:28:49,912 --> 27:28:52,960
Objetos de forma direta e você pode adivinhar

41398
27:28:52,960 --> 27:28:54,552
O que isso vai fazer isso está acontecendo

41399
27:28:54,552 --> 27:28:56,160
para cortar fora

41400
27:28:56,160 --> 27:28:59,192
Círculo e informações ovais e somente

41401
27:28:59,192 --> 27:29:01,120
A informação da forma será armazenada

41402
27:29:01,120 --> 27:29:03,440
neste array aqui, então se acontecermos com

41403
27:29:03,440 --> 27:29:05,680
Olhe através deste array como fazemos aqui

41404
27:29:05,680 --> 27:29:07,040
E tentar

41405
27:29:07,040 --> 27:29:09,120
chamar o método draw

41406
27:29:09,120 --> 27:29:11,600
Isso não vai chamar mais

41407
27:29:11,600 --> 27:29:14,720
Método de perfuração específico para círculo ou oval

41408
27:29:14,720 --> 27:29:16,872
Isso só vai chamar a forma

41409
27:29:16,872 --> 27:29:19,832
versão do nosso método de sorteio aqui é

41410
27:29:19,832 --> 27:29:22,400
Algo que eu quero que você veja ok um pouco

41411
27:29:22,400 --> 27:29:24,800
Você pode dizer e se eu tomar o meu

41412
27:29:24,800 --> 27:29:27,280
fornecer informações aqui e atribuir

41413
27:29:27,280 --> 27:29:29,360
Isso para um ponteiro e depois passar

41414
27:29:29,360 --> 27:29:31,680
Esse ponteiro para chamar o método draw

41415
27:29:31,680 --> 27:29:34,232
Bem eu odeio quebrá-lo para você, mas o

41416
27:29:34,232 --> 27:29:36,640
momento em que seus dados são cortados em um

41417
27:29:36,640 --> 27:29:39,040
situação como esta, você nunca vai ter

41418
27:29:39,040 --> 27:29:41,280
esses dados de volta, mesmo se você tentar

41419
27:29:41,280 --> 27:29:43,512
tomar o objeto e assinar isso para um

41420
27:29:43,512 --> 27:29:45,832
ponteiro ou uma referência que você nunca é

41421
27:29:45,832 --> 27:29:48,872
obterá dados polimórficos novamente

41422
27:29:48,872 --> 27:29:51,120
Os dados foram perdidos permanentemente e você

41423
27:29:51,120 --> 27:29:53,760
Nunca consiga isso, mesmo se você tentar ir

41424
27:29:53,760 --> 27:29:55,680
através de um ponteiro ou uma referência a

41425
27:29:55,680 --> 27:29:58,000
gerenciar seu objeto que temos neste

41426
27:29:58,000 --> 27:30:00,720
array se nós chamamos o método de sorteio que queremos

41427
27:30:00,720 --> 27:30:03,280
para obter o comportamento polimórfico que vamos ter

41428
27:30:03,280 --> 27:30:06,080
para a versão forma do nosso método de desenho

41429
27:30:06,080 --> 27:30:09,040
Chamados os dados foram cortados

41430
27:30:09,040 --> 27:30:11,912
permanentemente se armazenarmos o nosso derivado

41431
27:30:11,912 --> 27:30:15,192
objetos em um array como este ou mesmo se

41432
27:30:15,192 --> 27:30:18,800
atribuímos diretamente um objeto derivado a

41433
27:30:18,800 --> 27:30:21,440
objeto base isso vai cortar

41434
27:30:21,440 --> 27:30:24,400
os dados e nunca o receberemos de volta

41435
27:30:24,400 --> 27:30:27,040
De qualquer forma, você deve realmente saber isso ok

41436
27:30:27,040 --> 27:30:29,680
Sempre que eu tentar explicar isso

41437
27:30:29,680 --> 27:30:31,680
Os estudantes, na maioria das vezes, surgem com isso

41438
27:30:31,680 --> 27:30:34,800
E se eu tentar armazenar

41439
27:30:34,800 --> 27:30:37,512
Referências no meu array

41440
27:30:37,512 --> 27:30:39,760
E fazer algo assim agora este é

41441
27:30:39,760 --> 27:30:42,160
não vai funcionar e isso não é mesmo

41442
27:30:42,160 --> 27:30:45,192
Saí da fase de compilação do seu

41443
27:30:45,192 --> 27:30:48,080
programar a razão é que não podemos armazenar

41444
27:30:48,080 --> 27:30:50,800
Referências em uma coleção e

41445
27:30:50,800 --> 27:30:53,040
A razão tem a ver com a esquerda

41446
27:30:53,040 --> 27:30:56,800
Atribuição de regra de capacidade que você não pode atribuir a um

41447
27:30:56,800 --> 27:30:59,600
referência e eu mudei a referência para

41448
27:30:59,600 --> 27:31:02,160
loja em outro lugar e realmente dirige

41449
27:31:02,160 --> 27:31:04,480
Esta casa vamos olhar para este exemplo

41450
27:31:04,480 --> 27:31:07,040
Aqui temos uma variável chamada

41451
27:31:07,040 --> 27:31:09,760
de entertype e temos um valor 56

41452
27:31:09,760 --> 27:31:12,232
dentro e estabelecemos uma referência que

41453
27:31:12,232 --> 27:31:14,480
vai fazer referência aos dados que nós

41454
27:31:14,480 --> 27:31:17,440
Temos em uma e para baixo nesta linha aqui nós

41455
27:31:17,440 --> 27:31:20,232
tentar alterar os dados em nossa referência

41456
27:31:20,232 --> 27:31:22,400
Mas isso não vai mudar

41457
27:31:22,400 --> 27:31:25,760
quando esta referência indicar ou

41458
27:31:25,760 --> 27:31:28,480
onde esta referência refere isso

41459
27:31:28,480 --> 27:31:32,320
Será apenas mudar os valores em

41460
27:31:32,320 --> 27:31:35,912
nossa referência aqui e uma vez que temos isso

41461
27:31:35,912 --> 27:31:38,480
referência que nunca seremos capazes de mudar

41462
27:31:38,480 --> 27:31:41,120
onde está apontando novamente para isso

41463
27:31:41,120 --> 27:31:42,800
Espero que você possa entender que

41464
27:31:42,800 --> 27:31:46,080
As referências não são deixadas atribuíveis a você

41465
27:31:46,080 --> 27:31:48,960
Não pode armazenar graças que não são deixados

41466
27:31:48,960 --> 27:31:51,192
atribuível em um array

41467
27:31:51,192 --> 27:31:54,080
porque um array é projetado para modificar

41468
27:31:54,080 --> 27:31:57,120
os dados do que é armazenado dentro de si se

41469
27:31:57,120 --> 27:31:59,280
nós configuramos um array como este

41470
27:31:59,280 --> 27:32:01,512
o compilador pensa que em alguns mais tarde

41471
27:32:01,512 --> 27:32:04,000
Ponto que você vai querer atribuir

41472
27:32:04,000 --> 27:32:06,400
outros dados para o que já está armazenado em

41473
27:32:06,400 --> 27:32:08,640
Este array e há um difícil

41474
27:32:08,640 --> 27:32:10,960
requisito sobre os dados que você armazena em

41475
27:32:10,960 --> 27:32:13,600
suas coleções para o tipo de

41476
27:32:13,600 --> 27:32:16,400
dados pelo menos para serem cedidos

41477
27:32:16,400 --> 27:32:18,800
e as referências não são deixadas atribuíveis

41478
27:32:18,800 --> 27:32:21,040
Então não podemos armazená-los em uma coleção

41479
27:32:21,040 --> 27:32:22,872
Como isso se estamos tentando fazer isso

41480
27:32:22,872 --> 27:32:25,192
vamos ter um erro de compilador, mas

41481
27:32:25,192 --> 27:32:26,960
Mais uma vez alguns de vocês vão dizer o que

41482
27:32:26,960 --> 27:32:28,800
se nós armazenamos bem em ponteiros isso é

41483
27:32:28,800 --> 27:32:31,600
Vou trabalhar este é o trabalho básico

41484
27:32:31,600 --> 27:32:33,912
O princípio do polimorfismo

41485
27:32:33,912 --> 27:32:36,320
passando por ponteiros básicos para gerenciar

41486
27:32:36,320 --> 27:32:39,480
objetos derivados que isso vai usar

41487
27:32:39,480 --> 27:32:42,000
Polimorfismo e aqui vamos conseguir o

41488
27:32:42,000 --> 27:32:44,552
método mais básico chamado

41489
27:32:44,552 --> 27:32:46,960
Se o nosso objeto é um círculo, vamos

41490
27:32:46,960 --> 27:32:49,120
chamar o método de desenho no círculo

41491
27:32:49,120 --> 27:32:51,280
Objeto se for um romance que vamos

41492
27:32:51,280 --> 27:32:54,960
chamar o método de sorteio para a parte over

41493
27:32:54,960 --> 27:32:57,832
do nosso objeto aqui isso vai até

41494
27:32:57,832 --> 27:33:00,640
trabalho se passarmos por ponteiros inteligentes, então

41495
27:33:00,640 --> 27:33:03,280
Se fizermos algo assim e armazenarmos

41496
27:33:03,280 --> 27:33:06,160
em ponteiros inteligentes e criar o nosso smart

41497
27:33:06,160 --> 27:33:08,640
ponteiros na mosca em nosso inicializador

41498
27:33:08,640 --> 27:33:10,480
Aqui isso vai funcionar porque

41499
27:33:10,480 --> 27:33:13,280
realmente um ponteiro inteligente é um invólucro em

41500
27:33:13,280 --> 27:33:16,080
topo do ponteiro de rolo regular em c

41501
27:33:16,080 --> 27:33:18,720
plus plus, novamente a mensagem aqui é

41502
27:33:18,720 --> 27:33:21,120
que você precisa ter cuidado com o que você

41503
27:33:21,120 --> 27:33:24,080
armazene em suas coleções se for um raw

41504
27:33:24,080 --> 27:33:26,320
Um pedaço de ghana seus dados vão ser

41505
27:33:26,320 --> 27:33:29,912
fatiado se você armazenar objetos derivados

41506
27:33:29,912 --> 27:33:32,320
em uma coleção projetada para

41507
27:33:32,320 --> 27:33:33,360
loja

41508
27:33:33,360 --> 27:33:36,232
dados de classe base se você armazenar qualquer

41509
27:33:36,232 --> 27:33:38,160
referências que nem sequer vão

41510
27:33:38,160 --> 27:33:40,720
compile, mas se você está armazenando qualquer tipo

41511
27:33:40,720 --> 27:33:43,512
de linha de ponteiro ou inteligente isso vai

41512
27:33:43,512 --> 27:33:46,160
trabalho porque o polimorfismo foi projetado

41513
27:33:46,160 --> 27:33:48,400
em primeiro lugar para trabalhar com base

41514
27:33:48,400 --> 27:33:50,640
ponteiros que estão gerenciando derivados

41515
27:33:50,640 --> 27:33:52,872
objetos isso é muito legal e eu quero

41516
27:33:52,872 --> 27:33:55,280
Você está ciente disso agora que você

41517
27:33:55,280 --> 27:33:56,640
Eu sei que vamos nos dirigir para

41518
27:33:56,640 --> 27:33:58,552
código de estúdio visual e jogar com este

41519
27:33:58,552 --> 27:34:01,192
Pouco mais aqui estamos em nosso trabalho

41520
27:34:01,192 --> 27:34:03,040
pasta do projeto atual é

41521
27:34:03,040 --> 27:34:05,512
objetos polimórficos armazenados em

41522
27:34:05,512 --> 27:34:07,912
Coleções que vamos reutilizar o

41523
27:34:07,912 --> 27:34:10,160
código da última palestra porque nós

41524
27:34:10,160 --> 27:34:13,440
Precisa da nossa hierarquia de herança aqui e

41525
27:34:13,440 --> 27:34:15,680
Isso vai nos servir muito bem

41526
27:34:15,680 --> 27:34:17,360
nós vamos copiar isso

41527
27:34:17,360 --> 27:34:20,160
e nós vamos nos dirigir em nosso

41528
27:34:20,160 --> 27:34:22,400
projeto atual e colocar em nosso código e

41529
27:34:22,400 --> 27:34:24,000
Então vamos abrir isso em visual

41530
27:34:24,000 --> 27:34:26,000
Código de estúdio muito rápido, vamos fazer isso

41531
27:34:26,000 --> 27:34:28,080
Isto vai dar-nos o nosso código e nós

41532
27:34:28,080 --> 27:34:30,080
ter a nossa classe de forma que é realmente

41533
27:34:30,080 --> 27:34:32,960
O que já sabemos que temos nosso oval

41534
27:34:32,960 --> 27:34:33,912
classe de classe

41535
27:34:33,912 --> 27:34:36,640
e nós temos a nossa classe de círculo ter um bom

41536
27:34:36,640 --> 27:34:39,280
Olhe para isso e o que queremos ver é

41537
27:34:39,280 --> 27:34:40,720
O que acontece

41538
27:34:40,720 --> 27:34:44,320
se nós usamos diferentes tipos de configurações para

41539
27:34:44,320 --> 27:34:47,120
Armazenar objetos desta herança

41540
27:34:47,120 --> 27:34:49,912
hierarquia em uma coleção como uma matriz

41541
27:34:49,912 --> 27:34:52,872
vamos voltar ao nosso arquivo principal cpp e

41542
27:34:52,872 --> 27:34:54,960
Vamos tirar o que temos

41543
27:34:54,960 --> 27:34:56,552
Aqui vamos montar o que nós somos

41544
27:34:56,552 --> 27:34:59,120
Vou usar nesta palestra que estamos

41545
27:34:59,120 --> 27:35:00,872
Vou montar um monte de objetos que

41546
27:35:00,872 --> 27:35:02,872
Vamos usar aqui basicamente um

41547
27:35:02,872 --> 27:35:05,600
Um monte de círculos e ovais podemos fechar

41548
27:35:05,600 --> 27:35:08,320
a barra lateral esquerda aqui e ter um pouco mais

41549
27:35:08,320 --> 27:35:10,400
espaço para respirar depois disso, vamos

41550
27:35:10,400 --> 27:35:12,872
configurar um array que vai armazenar

41551
27:35:12,872 --> 27:35:16,480
cópias deste objeto neste array aqui

41552
27:35:16,480 --> 27:35:18,960
que é chamado de formas um e depois

41553
27:35:18,960 --> 27:35:20,720
Isso nós vamos tentar passar

41554
27:35:20,720 --> 27:35:23,192
Este array e tentar fazer coisas com ele

41555
27:35:23,192 --> 27:35:26,320
Por exemplo, podemos dizer por forma e nós

41556
27:35:26,320 --> 27:35:30,080
pode querer chamar o método de desenho em nosso

41557
27:35:30,080 --> 27:35:33,280
copiar aqui, por exemplo, podemos dizer s

41558
27:35:33,280 --> 27:35:35,512
e dizer desenhar indo para ver o que acontece

41559
27:35:35,512 --> 27:35:36,960
Aqui e aqui e

41560
27:35:36,960 --> 27:35:39,120
Vamos dizer referências porque nós não

41561
27:35:39,120 --> 27:35:41,360
Quer cópias em nosso

41562
27:35:41,360 --> 27:35:43,912
alcance baseado em loop aqui, então isso é

41563
27:35:43,912 --> 27:35:46,480
Vou evitar cópias que fazemos neste loop

41564
27:35:46,480 --> 27:35:48,000
e nós vamos ser diretamente

41565
27:35:48,000 --> 27:35:50,232
Referindo tudo o que temos nisso

41566
27:35:50,232 --> 27:35:51,440
Array aqui

41567
27:35:51,440 --> 27:35:53,832
Agora o que você espera obter, nós temos

41568
27:35:53,832 --> 27:35:56,320
objetos derivados nesta matriz

41569
27:35:56,320 --> 27:35:59,120
e com a configuração que temos aqui porque

41570
27:35:59,120 --> 27:36:01,832
Estamos usando funções virtuais

41571
27:36:01,832 --> 27:36:04,160
Seria de esperar

41572
27:36:04,160 --> 27:36:06,480
comportamento polimórfico, então aqui nós gostaríamos

41573
27:36:06,480 --> 27:36:08,160
Espera para obter o

41574
27:36:08,160 --> 27:36:11,192
versões de joe em círculo e oval para ser

41575
27:36:11,192 --> 27:36:13,192
chamado, mas isso não é o que vai fazer

41576
27:36:13,192 --> 27:36:14,480
Acontece que nós vamos ver que nós somos

41577
27:36:14,480 --> 27:36:16,800
vai chamar versões de forma de

41578
27:36:16,800 --> 27:36:19,680
nossos métodos de sorteio, vamos tentar construir e

41579
27:36:19,680 --> 27:36:21,912
mostrar-lhe isso que estamos indo para o mundo com

41580
27:36:21,912 --> 27:36:24,552
gcc nosso compilador favorito que a compilação é

41581
27:36:24,552 --> 27:36:26,960
indo para passar, podemos matar isso e

41582
27:36:26,960 --> 27:36:29,512
trazer uma janela powershell para nos permitir

41583
27:36:29,512 --> 27:36:31,440
para executar o nosso programa vamos dizer

41584
27:36:31,440 --> 27:36:33,192
Galo aqui e você vai ver

41585
27:36:33,192 --> 27:36:36,400
que estamos desenhando um círculo sobre um

41586
27:36:36,400 --> 27:36:38,720
círculo dois sobre dois círculos três ovais

41587
27:36:38,720 --> 27:36:41,680
Três mas estamos chamando a forma

41588
27:36:41,680 --> 27:36:44,320
Versões do nosso método draw

41589
27:36:44,320 --> 27:36:47,440
e a razão é que estamos cortando

41590
27:36:47,440 --> 27:36:50,800
informações de classe derivadas em nossos objetos

41591
27:36:50,800 --> 27:36:53,192
no momento em que tentamos fazer uma cópia e

41592
27:36:53,192 --> 27:36:56,800
cópia em um local que é projetado para armazenar

41593
27:36:56,800 --> 27:37:00,080
objetos da classe base, então isso é

41594
27:37:00,080 --> 27:37:01,832
basicamente o que vimos no último

41595
27:37:01,832 --> 27:37:02,872
A palestra

41596
27:37:02,872 --> 27:37:05,680
no cortar, mas está disfarçado

41597
27:37:05,680 --> 27:37:08,872
porque estamos armazenando dados em um array

41598
27:37:08,872 --> 27:37:11,440
e quando você armazena dados em um array como

41599
27:37:11,440 --> 27:37:13,280
Isso você vai fazer cópias

41600
27:37:13,280 --> 27:37:16,640
e armazenando cópias em sua matriz e em

41601
27:37:16,640 --> 27:37:18,160
Qualquer cópia que você faz você vai ser

41602
27:37:18,160 --> 27:37:20,800
basicamente cortando oval e círculo

41603
27:37:20,800 --> 27:37:23,760
informação e apenas armazenamento em forma

41604
27:37:23,760 --> 27:37:26,552
informação para os nossos objetos aqui é

41605
27:37:26,552 --> 27:37:28,400
O que o compilador vai fazer e

41606
27:37:28,400 --> 27:37:30,800
que realmente tentar provar isso nós podemos

41607
27:37:30,800 --> 27:37:34,000
Tente imprimir o tamanho desses objetos

41608
27:37:34,000 --> 27:37:36,800
e ver os tamanhos desses objetos em

41609
27:37:36,800 --> 27:37:39,192
este array aqui quando nós fazemos loop assim para

41610
27:37:39,192 --> 27:37:43,760
exemplo, podemos dizer stdc fora do tamanho de

41611
27:37:43,760 --> 27:37:47,280
círculo um fazemos nós temos círculo um sim nós

41612
27:37:47,280 --> 27:37:49,760
Fazê-lo, vamos dizer o tamanho do círculo

41613
27:37:49,760 --> 27:37:50,960
Um aqui

41614
27:37:50,960 --> 27:37:52,400
e nós vamos colocar o seu tamanho

41615
27:37:52,400 --> 27:37:55,040
informação aqui para ser visto por

41616
27:37:55,040 --> 27:37:57,192
Todos nós vamos dizer o tamanho de

41617
27:37:57,192 --> 27:37:59,040
Círculo um e nós vamos imprimi-lo

41618
27:37:59,040 --> 27:38:01,360
fora e nós também vamos imprimir o

41619
27:38:01,360 --> 27:38:04,480
tamanho de qualquer iteração em que estejamos

41620
27:38:04,480 --> 27:38:06,400
nosso loop aqui que é a primeira coisa

41621
27:38:06,400 --> 27:38:08,000
nós vamos nos preparar e nós vamos

41622
27:38:08,000 --> 27:38:10,640
Diga tamanho do objeto e nós vamos

41623
27:38:10,640 --> 27:38:13,912
Diga que o tamanho de s isso vai fazer

41624
27:38:13,912 --> 27:38:15,680
e nós vamos fazer loop e ver se o

41625
27:38:15,680 --> 27:38:17,832
As informações que temos no exterior são

41626
27:38:17,832 --> 27:38:20,480
O mesmo que temos do lado de fora novamente

41627
27:38:20,480 --> 27:38:22,872
estamos imprimindo esta informação no

41628
27:38:22,872 --> 27:38:24,800
O objeto direto

41629
27:38:24,800 --> 27:38:28,000
que ainda não está em nossa matriz e

41630
27:38:28,000 --> 27:38:29,512
De fato, nós podemos

41631
27:38:29,512 --> 27:38:32,640
Trate isso na frente do nosso array para fazer

41632
27:38:32,640 --> 27:38:35,760
este super claro e em nosso loop estamos

41633
27:38:35,760 --> 27:38:38,160
imprimir informações em uma cópia que nós

41634
27:38:38,160 --> 27:38:41,120
ter em nossa matriz porque este é o

41635
27:38:41,120 --> 27:38:44,232
real deal nós temos em nossa matriz porque

41636
27:38:44,232 --> 27:38:45,912
Esta é uma referência espero que seja

41637
27:38:45,912 --> 27:38:48,320
Vou fazer sentido e provar a você

41638
27:38:48,320 --> 27:38:51,192
que vamos trabalhar com

41639
27:38:51,192 --> 27:38:53,680
objetos derivados e os dados vão

41640
27:38:53,680 --> 27:38:57,120
ser cortado fora se copiarmos os dados em nosso

41641
27:38:57,120 --> 27:38:58,960
array aqui este é o que eu quero que você

41642
27:38:58,960 --> 27:39:01,120
Veja, então vamos correr isso de novo

41643
27:39:01,120 --> 27:39:03,192
nós vamos passar por isso através do gcc o

41644
27:39:03,192 --> 27:39:04,720
A construção vai ser boa nós vamos

41645
27:39:04,720 --> 27:39:06,080
claro

41646
27:39:06,080 --> 27:39:07,760
e correr o galo

41647
27:39:07,760 --> 27:39:10,000
Agora vamos ver o que temos aqui tamanho

41648
27:39:10,000 --> 27:39:12,872
do círculo 1 é 56, mas você vai

41649
27:39:12,872 --> 27:39:16,000
Veja que o tamanho de todos os nossos objetos em

41650
27:39:16,000 --> 27:39:17,440
a nossa matriz

41651
27:39:17,440 --> 27:39:20,720
encolheu para 40 porque classes derivadas

41652
27:39:20,720 --> 27:39:23,192
A informação foi cortada do

41653
27:39:23,192 --> 27:39:26,232
Momento que copiamos nossos dados em nossa matriz

41654
27:39:26,232 --> 27:39:28,552
Aqui e isso é o que eu quero que você veja

41655
27:39:28,552 --> 27:39:30,872
e eu acho que podemos até ver isso se nós

41656
27:39:30,872 --> 27:39:33,832
Passar pelo nosso depurador, por exemplo, nós

41657
27:39:33,832 --> 27:39:36,552
pode colocar um ponto de ruptura aqui

41658
27:39:36,552 --> 27:39:40,080
e uh abrir nossa guia de corrida e se tentarmos

41659
27:39:40,080 --> 27:39:42,080
executar o nosso programa através do depurador

41660
27:39:42,080 --> 27:39:44,800
A construção vai ser boa e o binário

41661
27:39:44,800 --> 27:39:47,600
Vai ser passado para o nosso depurador

41662
27:39:47,600 --> 27:39:49,280
E nós vamos atingir o nosso ponto de ruptura

41663
27:39:49,280 --> 27:39:52,000
em um minuto, então vamos esperar por isso e

41664
27:39:52,000 --> 27:39:54,160
nós atingimos nosso ponto de ruptura aqui, mas

41665
27:39:54,160 --> 27:39:56,000
O que podemos fazer agora

41666
27:39:56,000 --> 27:39:59,120
é olhar para as nossas variáveis locais sobre o

41667
27:39:59,120 --> 27:40:01,760
à esquerda, vamos olhar para a nossa matriz a matriz

41668
27:40:01,760 --> 27:40:03,832
É chamado de navios

41669
27:40:03,832 --> 27:40:07,280
E se subirmos, vamos ver o nosso

41670
27:40:07,280 --> 27:40:09,440
Navis um array

41671
27:40:09,440 --> 27:40:11,280
e vamos ver que temos cinco

41672
27:40:11,280 --> 27:40:13,280
índices aqui porque temos seis

41673
27:40:13,280 --> 27:40:14,872
Elementos no interior

41674
27:40:14,872 --> 27:40:17,360
Podemos expandir e ver o que temos em

41675
27:40:17,360 --> 27:40:19,680
indexar zero e você vai ver isso

41676
27:40:19,680 --> 27:40:22,320
Temos apenas dados de descrição porque

41677
27:40:22,320 --> 27:40:24,552
Esta é uma forma se voltarmos em nosso

41678
27:40:24,552 --> 27:40:26,480
classe, vamos ver que a única

41679
27:40:26,480 --> 27:40:28,480
A coisa que temos em nossa classe de forma é

41680
27:40:28,480 --> 27:40:31,192
Realmente uma variável de membro de descrição e

41681
27:40:31,192 --> 27:40:34,000
É o que vemos em nossa matriz aqui apenas

41682
27:40:34,000 --> 27:40:36,320
informações de descrição porque isso é

41683
27:40:36,320 --> 27:40:39,040
um objeto em forma e nós perdemos ou

41684
27:40:39,040 --> 27:40:41,360
informações de classe derivadas e esta

41685
27:40:41,360 --> 27:40:43,600
muito legal, mas se formos no topo e para

41686
27:40:43,600 --> 27:40:45,832
Exemplo expando círculo um que vamos

41687
27:40:45,832 --> 27:40:48,480
Veja que temos uma parte nova de nós e

41688
27:40:48,480 --> 27:40:50,640
Temos uma parte de navio, mas estes

41689
27:40:50,640 --> 27:40:53,360
Os eventos foram retirados em nosso

41690
27:40:53,360 --> 27:40:56,552
array quando cortamos os dados de

41691
27:40:56,552 --> 27:40:59,440
Objetos derivados para armazenar apenas forma

41692
27:40:59,440 --> 27:41:01,832
informações em nosso array aqui eu espero

41693
27:41:01,832 --> 27:41:04,000
Isso faz sentido agora que vamos matar

41694
27:41:04,000 --> 27:41:06,080
nossa sessão de depuração porque não

41695
27:41:06,080 --> 27:41:08,480
Preciso disso mais e vamos

41696
27:41:08,480 --> 27:41:10,960
Comente e veja alguns outros

41697
27:41:10,960 --> 27:41:13,440
Coisas assim nós vamos

41698
27:41:13,440 --> 27:41:15,192
Comente com nossos dados aqui estamos indo

41699
27:41:15,192 --> 27:41:18,552
para dizer se você armazenar objetos derivados da linha

41700
27:41:18,552 --> 27:41:21,360
em uma matriz que foi criada para armazenar

41701
27:41:21,360 --> 27:41:23,440
classe base objeto os dados estão indo para

41702
27:41:23,440 --> 27:41:25,360
ser cortado fora disso é algo que eu quero

41703
27:41:25,360 --> 27:41:27,680
Você sabe, mas alguns de vocês vão

41704
27:41:27,680 --> 27:41:28,480
Dizê

41705
27:41:28,480 --> 27:41:30,872
E se nós armazená-lo em referências ok

41706
27:41:30,872 --> 27:41:32,400
Então vamos tentar fazer isso, vamos

41707
27:41:32,400 --> 27:41:34,160
configurar um pedaço de código como este e

41708
27:41:34,160 --> 27:41:35,832
nós vamos configurar um array chamado

41709
27:41:35,832 --> 27:41:38,400
shapes2 e esta matriz vai ser

41710
27:41:38,400 --> 27:41:40,640
Basicamente armazena referências ao

41711
27:41:40,640 --> 27:41:43,280
objetos que temos no topo e nós somos

41712
27:41:43,280 --> 27:41:44,800
Vou ver o que você percebe

41713
27:41:44,800 --> 27:41:47,832
que já temos uma linha de luto e

41714
27:41:47,832 --> 27:41:50,480
Isso está dizendo que isso não vai funcionar

41715
27:41:50,480 --> 27:41:52,480
Porque as referências não podem realmente ser

41716
27:41:52,480 --> 27:41:54,400
armazenados em coleções

41717
27:41:54,400 --> 27:41:56,720
novamente como vimos nos slides a razão

41718
27:41:56,720 --> 27:41:58,080
É porque

41719
27:41:58,080 --> 27:42:00,960
As referências não são deixadas atribuíveis e

41720
27:42:00,960 --> 27:42:03,440
Eles não podem ser armazenados em uma coleção

41721
27:42:03,440 --> 27:42:06,480
Como uma matriz aqui o requisito básico

41722
27:42:06,480 --> 27:42:09,192
sobre os tipos que você pode armazenar em seu

41723
27:42:09,192 --> 27:42:11,600
A matriz é que eles têm que ser deixados

41724
27:42:11,600 --> 27:42:15,120
atribuíveis e nossas referências não são

41725
27:42:15,120 --> 27:42:17,192
descanso atribuível para que isso não vá

41726
27:42:17,192 --> 27:42:20,320
compilar se tentarmos construir nosso programa

41727
27:42:20,320 --> 27:42:21,600
nós vamos ver que nós vamos

41728
27:42:21,600 --> 27:42:24,080
obter erros estranhos do compilador

41729
27:42:24,080 --> 27:42:25,912
e a construção vai terminar com

41730
27:42:25,912 --> 27:42:27,912
erros e se subirmos, vamos

41731
27:42:27,912 --> 27:42:31,192
Veja essa declaração de formas para nós

41732
27:42:31,192 --> 27:42:33,512
variedade de referências e isso não é

41733
27:42:33,512 --> 27:42:35,680
permitido que você não possa ter uma matriz de

41734
27:42:35,680 --> 27:42:38,480
referências em c plus plus e isso é

41735
27:42:38,480 --> 27:42:39,912
a razão pela qual vamos ter um

41736
27:42:39,912 --> 27:42:42,160
Erro do compilador aqui ok, então agora você sabe

41737
27:42:42,160 --> 27:42:43,600
Mas alguns de vocês vão dizer

41738
27:42:43,600 --> 27:42:45,280
E se passarmos bem por ponteiros

41739
27:42:45,280 --> 27:42:47,232
Isso vai funcionar porque

41740
27:42:47,232 --> 27:42:50,720
Polimorfismo através de funções virtuais

41741
27:42:50,720 --> 27:42:53,040
foi basicamente projetado para trabalhar com base

41742
27:42:53,040 --> 27:42:55,680
ponteiros que estão gerenciando derivados

41743
27:42:55,680 --> 27:42:58,232
objetos e isso é o que temos aqui, então

41744
27:42:58,232 --> 27:43:00,400
Se olharmos, vamos estar recebendo

41745
27:43:00,400 --> 27:43:03,440
Comportamento polimórfico e se chamarmos nosso

41746
27:43:03,440 --> 27:43:05,512
desenhar método em nosso ponteiro aqui estamos

41747
27:43:05,512 --> 27:43:08,480
Vou obter o mais específico

41748
27:43:08,480 --> 27:43:10,872
método chamado e isso é o que nós

41749
27:43:10,872 --> 27:43:13,040
Quero, então vamos tentar soldar isso

41750
27:43:13,040 --> 27:43:14,720
novamente e mostrar que isso vai

41751
27:43:14,720 --> 27:43:16,552
trabalhar a construção vai ser bom nós

41752
27:43:16,552 --> 27:43:17,680
pode limpar

41753
27:43:17,680 --> 27:43:20,080
e correr o galo e nós vamos ver

41754
27:43:20,080 --> 27:43:22,480
que nós vamos fazer looping ao redor

41755
27:43:22,480 --> 27:43:24,080
e se nós chamarmos o método draw nós somos

41756
27:43:24,080 --> 27:43:26,720
indo para chamar o círculo do método overdraw

41757
27:43:26,720 --> 27:43:29,120
draw method overdraw method circle draw

41758
27:43:29,120 --> 27:43:31,360
Método este é basicamente o que queremos

41759
27:43:31,360 --> 27:43:33,440
e estamos passando por ponteiros de base

41760
27:43:33,440 --> 27:43:36,232
para realmente usar o polimorfismo aqui este é

41761
27:43:36,232 --> 27:43:37,912
definitivamente indo para o trabalho se você for

41762
27:43:37,912 --> 27:43:40,232
através de ponteiros inteligentes então vamos comentar

41763
27:43:40,232 --> 27:43:42,400
Isso e faça outro exemplo para

41764
27:43:42,400 --> 27:43:44,552
realmente dirigir esta casa você pode realmente

41765
27:43:44,552 --> 27:43:46,720
usar qualquer tipo de ponteiro inteligente que você pode

41766
27:43:46,720 --> 27:43:50,160
use ponteiros exclusivos ou ponteiros compartilhados

41767
27:43:50,160 --> 27:43:52,640
Aqui vamos apenas armazenar em

41768
27:43:52,640 --> 27:43:54,480
apontadores porque isso é mais fácil de

41769
27:43:54,480 --> 27:43:56,640
manusear e nós vamos ir até

41770
27:43:56,640 --> 27:43:58,800
a parte superior e incluir o cabeçalho da memória se

41771
27:43:58,800 --> 27:44:01,192
Você se lembra se você quer usar inteligente

41772
27:44:01,192 --> 27:44:03,832
ponteiros em c plus plus que você terá que

41773
27:44:03,832 --> 27:44:05,912
incluir o cabeçalho de memória que traz

41774
27:44:05,912 --> 27:44:08,640
nos dados para configurar ponteiros inteligentes em

41775
27:44:08,640 --> 27:44:10,400
o seu excedente mais código

41776
27:44:10,400 --> 27:44:13,360
então isso vai parecer bom agora e se

41777
27:44:13,360 --> 27:44:14,960
nós construímos que vamos conseguir o máximo

41778
27:44:14,960 --> 27:44:18,000
versão específica do nosso método draw

41779
27:44:18,000 --> 27:44:20,800
chamado através do polimorfismo que é

41780
27:44:20,800 --> 27:44:23,120
usando funções virtuais aqui, então vamos

41781
27:44:23,120 --> 27:44:24,872
construir e mostrar que isso vai

41782
27:44:24,872 --> 27:44:26,872
O livro vai ser bom, podemos

41783
27:44:26,872 --> 27:44:28,080
claro

41784
27:44:28,080 --> 27:44:30,552
e correr galo e nós vamos chegar

41785
27:44:30,552 --> 27:44:33,680
nossas versões de draw chamada versão

41786
27:44:33,680 --> 27:44:36,160
para um círculo e a versão para oval

41787
27:44:36,160 --> 27:44:38,640
porque estamos usando ponteiros de base para

41788
27:44:38,640 --> 27:44:41,680
gerenciar objetos derivados aqui e nosso

41789
27:44:41,680 --> 27:44:44,000
A hierarquia de herança de classe está usando

41790
27:44:44,000 --> 27:44:46,480
funções virtuais para o método draw

41791
27:44:46,480 --> 27:44:48,400
Aqui, então isso vai funcionar, isso é

41792
27:44:48,400 --> 27:44:50,400
Realmente tudo que eu queria que você visse isso

41793
27:44:50,400 --> 27:44:53,280
palestra que você deve ter cuidado se você tentar

41794
27:44:53,280 --> 27:44:54,640
para a loja

41795
27:44:54,640 --> 27:44:58,320
objetos derivados em uma matriz que era

41796
27:44:58,320 --> 27:45:01,680
projetado para armazenar dados de classe base se você

41797
27:45:01,680 --> 27:45:03,760
estão usando dados brutos que você vai obter
O 
41798
27:45:03,760 --> 27:45:05,040
slicing

41799
27:45:05,040 --> 27:45:07,512
e você realmente precisa estar ciente disso

41800
27:45:07,512 --> 27:45:09,680
porque você quer ter classe derivada

41801
27:45:09,680 --> 27:45:12,000
informação se você tentar armazenar qualquer

41802
27:45:12,000 --> 27:45:13,760
Referências isso nem vai

41803
27:45:13,760 --> 27:45:16,232
compilar porque referências não são deixadas

41804
27:45:16,232 --> 27:45:18,400
atribuível, mas isso vai funcionar se

41805
27:45:18,400 --> 27:45:20,960
você usa ponteiros de função ou ponteiros inteligentes

41806
27:45:20,960 --> 27:45:23,120
porque o polimorfismo era basicamente

41807
27:45:23,120 --> 27:45:25,760
projetado para trabalhar com ponteiros de base ou

41808
27:45:25,760 --> 27:45:28,720
referências que estão gerenciando um derivado

41809
27:45:28,720 --> 27:45:32,160
objeto que usa o polimorfismo que somos

41810
27:45:32,160 --> 27:45:34,000
Vou parar aqui nesta palestra:

41811
27:45:34,000 --> 27:45:35,760
A seguir, vamos aprender sobre o

41812
27:45:35,760 --> 27:45:39,192
mecanismo de substituição em c plus plus go

41813
27:45:39,192 --> 27:45:41,360
Na frente e terminar aqui e me encontrar

41814
27:45:41,360 --> 27:45:42,872
lá nesta palestra vamos

41815
27:45:42,872 --> 27:45:45,832
Saiba mais sobre a especificação de substituição

41816
27:45:45,832 --> 27:45:49,440
um tipo de configuração que você pode fazer para evitar

41817
27:45:49,440 --> 27:45:52,480
erros em suas hierarquias de herança

41818
27:45:52,480 --> 27:45:54,800
Se você usa funções virtuais para configurar

41819
27:45:54,800 --> 27:45:58,000
comportamento polimórfico para seu derivado

41820
27:45:58,000 --> 27:46:00,640
objetos e isso é algo que foi

41821
27:46:00,640 --> 27:46:03,360
configurado em ziplus plus para evitar fácil de

41822
27:46:03,360 --> 27:46:04,720
Comete erros

41823
27:46:04,720 --> 27:46:07,440
Se você tem uma herança

41824
27:46:07,440 --> 27:46:10,232
hierarquia como essa, você pode estar significando

41825
27:46:10,232 --> 27:46:12,960
para montar um empate substitui o que nós

41826
27:46:12,960 --> 27:46:15,440
ter na classe base e uma substituição

41827
27:46:15,440 --> 27:46:17,912
É realmente uma obrigação específica

41828
27:46:17,912 --> 27:46:20,552
método que você tem em seu derivado

41829
27:46:20,552 --> 27:46:23,512
classe para realmente esconder o que tínhamos no

41830
27:46:23,512 --> 27:46:25,760
classe base, por exemplo, o método de desenho

41831
27:46:25,760 --> 27:46:28,000
A novela vai ser primordial ou

41832
27:46:28,000 --> 27:46:30,400
Escondendo o que temos em forma

41833
27:46:30,400 --> 27:46:32,480
e o método de desenho em círculo está indo

41834
27:46:32,480 --> 27:46:35,120
para estar substituindo ou escondendo o que temos

41835
27:46:35,120 --> 27:46:38,000
em oval esta é a ideia aqui, mas como você

41836
27:46:38,000 --> 27:46:40,720
configurar suas substituições que você pode fazer

41837
27:46:40,720 --> 27:46:42,720
Erros, por exemplo, você pode significar dizer

41838
27:46:42,720 --> 27:46:46,640
desenhar e eu uso um w que está em maiúsculas

41839
27:46:46,640 --> 27:46:49,040
E isso vai ser ruim porque o que

41840
27:46:49,040 --> 27:46:51,280
você vai colocar em oval vai

41841
27:46:51,280 --> 27:46:54,160
ser um método completamente separado que é

41842
27:46:54,160 --> 27:46:56,232
diferente do que temos no topo

41843
27:46:56,232 --> 27:46:58,000
E isso vai ser muito ruim

41844
27:46:58,000 --> 27:46:59,832
Você não vai ficar polimórfico

41845
27:46:59,832 --> 27:47:02,640
comportamento para o método draw em oval

41846
27:47:02,640 --> 27:47:05,120
porque simplesmente não estamos substituindo o

41847
27:47:05,120 --> 27:47:07,440
método da mandíbula da forma e isso está indo

41848
27:47:07,440 --> 27:47:10,320
para ser ruim assim em ziploc mais podemos evitar

41849
27:47:10,320 --> 27:47:14,232
estes problemas especificando explicitamente

41850
27:47:14,232 --> 27:47:16,960
que o método de desenho que temos em alfa é

41851
27:47:16,960 --> 27:47:19,360
uma substituição e podemos acrescentar isso

41852
27:47:19,360 --> 27:47:23,192
especificação após o nosso cabeçalho do método

41853
27:47:23,192 --> 27:47:25,440
e o compilador c plus plus vai

41854
27:47:25,440 --> 27:47:28,232
fazer isso que estamos realmente substituindo

41855
27:47:28,232 --> 27:47:31,040
Um método que existe em nossos pais

41856
27:47:31,040 --> 27:47:34,232
classe que passa a ser forma aqui se

41857
27:47:34,232 --> 27:47:36,552
Não temos nenhum método chamado draw no

41858
27:47:36,552 --> 27:47:38,160
classe base que vamos ter um compilador

41859
27:47:38,160 --> 27:47:40,552
Erro porque queremos ser basicamente

41860
27:47:40,552 --> 27:47:42,960
substituindo qualquer método aqui, isso está acontecendo

41861
27:47:42,960 --> 27:47:45,680
para nos proteger de problemas se fizermos

41862
27:47:45,680 --> 27:47:48,552
erros de digitação na criação do nosso polimórfico

41863
27:47:48,552 --> 27:47:51,192
métodos aqui esta é a principal coisa que nós

41864
27:47:51,192 --> 27:47:53,512
pode conseguir com a substituição

41865
27:47:53,512 --> 27:47:55,760
Especificações agora que você sabe disso

41866
27:47:55,760 --> 27:47:57,120
nós vamos ir para o visual

41867
27:47:57,120 --> 27:47:58,872
código de estúdio e jogar com a gente um pouco

41868
27:47:58,872 --> 27:48:01,760
Mais aqui estamos em nossa pasta de trabalho

41869
27:48:01,760 --> 27:48:04,080
O projeto atual está sobressantelando aqui

41870
27:48:04,080 --> 27:48:05,600
Vamos pegar o código do

41871
27:48:05,600 --> 27:48:07,680
última palestra porque somos basicamente

41872
27:48:07,680 --> 27:48:09,912
Vou reutilizar o mesmo código sobre

41873
27:48:09,912 --> 27:48:10,872
e mais

41874
27:48:10,872 --> 27:48:13,360
construção em cima disso, se precisarmos fazer

41875
27:48:13,360 --> 27:48:16,160
que vamos colocar em nosso código

41876
27:48:16,160 --> 27:48:18,080
e nós vamos abrir isso em

41877
27:48:18,080 --> 27:48:19,832
código de estúdio arrastando e soltando

41878
27:48:19,832 --> 27:48:22,160
Aqui isso vai nos dar o nosso código

41879
27:48:22,160 --> 27:48:24,080
e nós podemos realmente fazer o que quisermos

41880
27:48:24,080 --> 27:48:27,040
com isso eu acho que podemos deixar no

41881
27:48:27,040 --> 27:48:29,912
código que está usando o ponteiro base para

41882
27:48:29,912 --> 27:48:32,640
gerenciar nossos objetos derivados eu penso isso

41883
27:48:32,640 --> 27:48:34,320
Vai nos servir

41884
27:48:34,320 --> 27:48:36,080
O suficiente e podemos tirar

41885
27:48:36,080 --> 27:48:37,760
Tudo o mais porque isso é só

41886
27:48:37,760 --> 27:48:40,232
Será uma confusão, não precisamos de tudo

41887
27:48:40,232 --> 27:48:42,960
Isto aqui vai estar nos servindo

41888
27:48:42,960 --> 27:48:45,192
Bem agora queremos aprender sobre o

41889
27:48:45,192 --> 27:48:46,960
sobrerpor o mundo chave

41890
27:48:46,960 --> 27:48:49,440
E para aprender sobre isso, vamos

41891
27:48:49,440 --> 27:48:52,232
introduzir um título de propósito aqui para

41892
27:48:52,232 --> 27:48:55,440
Um exemplo suponha que queremos montar um empate

41893
27:48:55,440 --> 27:48:57,440
substituir e nós usamos

41894
27:48:57,440 --> 27:49:00,000
uma letra maiúscula aqui para a tecla w

41895
27:49:00,000 --> 27:49:02,232
mundo eu não acho que isso é realmente fácil

41896
27:49:02,232 --> 27:49:04,800
para identificar uma vez que você cometeu esse erro

41897
27:49:04,800 --> 27:49:06,480
e você não vai conseguir nenhum

41898
27:49:06,480 --> 27:49:09,192
Erro do compilador porque

41899
27:49:09,192 --> 27:49:11,192
Isso é algo válido que você pode configurar

41900
27:49:11,192 --> 27:49:14,872
método completamente novo e chamá-lo de joe

41901
27:49:14,872 --> 27:49:16,960
E isso vai funcionar, mas isso vai

41902
27:49:16,960 --> 27:49:20,400
ser muito difícil de detectar em seu programa e

41903
27:49:20,400 --> 27:49:22,232
o compilador não irá protegê-lo como nós

41904
27:49:22,232 --> 27:49:24,552
apenas disse que se construirmos o nosso programa você é

41905
27:49:24,552 --> 27:49:26,232
Vou ver que vai a granel

41906
27:49:26,232 --> 27:49:29,760
Está tudo bem, então vamos passar por gcc

41907
27:49:29,760 --> 27:49:31,512
a tensão vai ser boa, mas nós

41908
27:49:31,512 --> 27:49:33,912
Quero chegar ao comportamento que queremos

41909
27:49:33,912 --> 27:49:36,320
Acho que podemos tirar este sddc para fora

41910
27:49:36,320 --> 27:49:39,440
declaração dentro do nosso loop para loop aqui e

41911
27:49:39,440 --> 27:49:41,440
Podemos soldar novamente isso vai ser

41912
27:49:41,440 --> 27:49:44,400
menos confuso bem para que a construção seja boa

41913
27:49:44,400 --> 27:49:47,680
nós podemos trazer a nossa janela powershell

41914
27:49:47,680 --> 27:49:49,440
e eu vou correr o galo e ver

41915
27:49:49,440 --> 27:49:51,440
O que acontece você vai ver isso

41916
27:49:51,440 --> 27:49:53,280
para um círculo vamos desenhar um

41917
27:49:53,280 --> 27:49:54,320
Círculo

41918
27:49:54,320 --> 27:49:56,000
mas para oval

41919
27:49:56,000 --> 27:49:58,080
Vamos desenhar forma, então o que

41920
27:49:58,080 --> 27:50:02,000
Está acontecendo aqui estamos substituindo o nosso

41921
27:50:02,000 --> 27:50:04,640
método joe na classe aberta, então devemos

41922
27:50:04,640 --> 27:50:07,192
obter comportamento polimórfico porque isso é

41923
27:50:07,192 --> 27:50:10,000
uma função virtual e é chamada draw

41924
27:50:10,000 --> 27:50:12,872
exatamente a mesma coisa como nós tivemos em

41925
27:50:12,872 --> 27:50:15,120
A classe base, exceto que fizemos um

41926
27:50:15,120 --> 27:50:17,912
muito simples erro de digitação aqui, mas é realmente

41927
27:50:17,912 --> 27:50:20,320
difícil de rastrear e se apossar de que temos

41928
27:50:20,320 --> 27:50:24,000
chamado nosso método draw, mas o w está em

41929
27:50:24,000 --> 27:50:26,080
Mais baixo, então isso é completamente

41930
27:50:26,080 --> 27:50:29,912
método diferente do que o método de desenho que nós

41931
27:50:29,912 --> 27:50:33,040
originalmente destinado a substituir em nosso

41932
27:50:33,040 --> 27:50:34,960
classe base e isso é realmente difícil de

41933
27:50:34,960 --> 27:50:37,680
seguir e manter o controle de que podemos proteger

41934
27:50:37,680 --> 27:50:40,000
Somos nós mesmos adicionando a substituição

41935
27:50:40,000 --> 27:50:43,040
especificação, portanto, se dissermos substituir o

41936
27:50:43,040 --> 27:50:44,960
O compilador vai ajudar e fazer

41937
27:50:44,960 --> 27:50:47,120
Certamente que estamos realmente tentando

41938
27:50:47,120 --> 27:50:49,912
substituir o método que existe no

41939
27:50:49,912 --> 27:50:52,400
classe de forma e se não existe

41940
27:50:52,400 --> 27:50:54,000
Vamos obter um erro de compilador, então

41941
27:50:54,000 --> 27:50:55,680
nós vamos olhar para isso e realmente

41942
27:50:55,680 --> 27:50:57,912
Veja este erro aqui é o que você

41943
27:50:57,912 --> 27:51:00,640
pode conseguir com a palavra-chave override

41944
27:51:00,640 --> 27:51:03,760
e na verdade eu recomendo e aconselho

41945
27:51:03,760 --> 27:51:06,320
você para usar isso em sua herança

41946
27:51:06,320 --> 27:51:08,720
hierarquia se você estiver usando

41947
27:51:08,720 --> 27:51:10,400
As funções virtuais porque

41948
27:51:10,400 --> 27:51:12,552
Isso vai te poupar muito tempo

41949
27:51:12,552 --> 27:51:14,720
Se você cometer erros como este, então nós somos

41950
27:51:14,720 --> 27:51:16,400
Vou tentar correr isso e mostrar a você

41951
27:51:16,400 --> 27:51:18,800
o erro do compilador que o recebemos, então vamos fazer

41952
27:51:18,800 --> 27:51:20,400
que vamos passar por isso

41953
27:51:20,400 --> 27:51:22,800
gcc a placa vai

41954
27:51:22,800 --> 27:51:24,552
falhar como vemos aqui e nós vamos

41955
27:51:24,552 --> 27:51:27,680
obter um compilador dizendo errol virtual vazio

41956
27:51:27,680 --> 27:51:30,640
geral do custo de joe marcado acima, mas

41957
27:51:30,640 --> 27:51:33,832
não substitui que isso é super claro que nós

41958
27:51:33,832 --> 27:51:36,552
Estamos dizendo que queremos substituir aqui, mas

41959
27:51:36,552 --> 27:51:39,440
Não estamos substituindo nenhum método chamado

41960
27:51:39,440 --> 27:51:42,000
joe com um maiúsculo porque nós não

41961
27:51:42,000 --> 27:51:43,600
ter isso em forma aqui esta é a

41962
27:51:43,600 --> 27:51:45,760
mensagem uma vez que vemos o problema que podemos

41963
27:51:45,760 --> 27:51:47,440
Corrigir isso, vamos usar em

41964
27:51:47,440 --> 27:51:50,320
letra minúscula para w e isso está indo

41965
27:51:50,320 --> 27:51:52,552
para trabalhar muito bem agora vamos usar

41966
27:51:52,552 --> 27:51:55,280
O mesmo mecanismo para nos proteger

41967
27:51:55,280 --> 27:51:57,832
de nós mesmos na classe do círculo, então nós somos

41968
27:51:57,832 --> 27:51:59,832
indo para substituir o nosso método de sorteio, mas

41969
27:51:59,832 --> 27:52:01,512
nós vamos dizer que nós queremos

41970
27:52:01,512 --> 27:52:04,960
superar explicitamente e se nós somos ambos

41971
27:52:04,960 --> 27:52:07,760
Agora vamos passar por isso Gcc isto é

41972
27:52:07,760 --> 27:52:09,680
vamos construir com sucesso e se nós

41973
27:52:09,680 --> 27:52:11,192
executar o nosso programa que vamos ter

41974
27:52:11,192 --> 27:52:14,080
Comportamento polimórfico vamos fazer isso

41975
27:52:14,080 --> 27:52:16,232
Veja esse círculo desenhar círculo de desenho

41976
27:52:16,232 --> 27:52:18,480
draw overdraw isso é o que esperamos

41977
27:52:18,480 --> 27:52:20,552
Isso é muito legal, isso é realmente tudo que eu

41978
27:52:20,552 --> 27:52:22,400
Tive que compartilhar esta palestra eu espero que você

41979
27:52:22,400 --> 27:52:25,040
achou interessante usar a substituição

41980
27:52:25,040 --> 27:52:27,512
palavra-chave na hierarquia de herança

41981
27:52:27,512 --> 27:52:29,832
Porque isso vai te proteger de

41982
27:52:29,832 --> 27:52:32,080
Fácil de fazer erros de digitação que realmente estão indo

41983
27:52:32,080 --> 27:52:35,040
para lhe dar um tempo difícil, caso contrário, estamos

41984
27:52:35,040 --> 27:52:37,040
Vou parar aqui nesta palestra em

41985
27:52:37,040 --> 27:52:38,800
O próximo vamos explorar o

41986
27:52:38,800 --> 27:52:42,160
conceitos de substituir e se esconder em

41987
27:52:42,160 --> 27:52:43,280
Detalhe de pormenor

41988
27:52:43,280 --> 27:52:45,512
Vá em frente e termine aqui e me encontre

41989
27:52:45,512 --> 27:52:47,192
lá nesta palestra vamos

41990
27:52:47,192 --> 27:52:50,232
zoom na sobrecarga de sobrecarga e

41991
27:52:50,232 --> 27:52:53,192
escondendo nós vimos que a imperada é uma

41992
27:52:53,192 --> 27:52:55,680
mecanismo que temos em c plus plus para ser

41993
27:52:55,680 --> 27:52:57,192
capaz de configurar

41994
27:52:57,192 --> 27:53:00,640
versões mais específicas do nosso virtual

41995
27:53:00,640 --> 27:53:03,120
métodos em classes derivadas, então para

41996
27:53:03,120 --> 27:53:05,600
exemplo o método de desenho que temos em oval

41997
27:53:05,600 --> 27:53:08,400
está substituindo ou eclipsando aquele que

41998
27:53:08,400 --> 27:53:11,512
ter em forma e o método de desenho em

41999
27:53:11,512 --> 27:53:13,760
O círculo está substituindo

42000
27:53:13,760 --> 27:53:17,280
ou escondendo ou eclipsando aquele que temos

42001
27:53:17,280 --> 27:53:20,232
em terrível este é o conceito aqui, mas

42002
27:53:20,232 --> 27:53:23,360
O que acontece se introduzirmos o conceito

42003
27:53:23,360 --> 27:53:26,160
de sobrecarga e misturar isso com

42004
27:53:26,160 --> 27:53:28,640
substituindo como vimos até agora

42005
27:53:28,640 --> 27:53:30,800
Suponha que façamos algo assim isso

42006
27:53:30,800 --> 27:53:33,832
é a nossa classe de forma que vai ter

42007
27:53:33,832 --> 27:53:36,080
duas versões do método draw que temos

42008
27:53:36,080 --> 27:53:38,872
um que leva um parâmetro, por exemplo

42009
27:53:38,872 --> 27:53:41,040
Esta pode ser a cor que queremos

42010
27:53:41,040 --> 27:53:43,440
Desenhe nossa forma e outra é

42011
27:53:43,440 --> 27:53:45,832
não vai tomar nenhum parâmetro e

42012
27:53:45,832 --> 27:53:49,040
Estas são duas sobrecargas do nosso virtual

42013
27:53:49,040 --> 27:53:51,360
Método aqui, então o que vai acontecer

42014
27:53:51,360 --> 27:53:54,232
em nossas classes derivadas que vão

42015
27:53:54,232 --> 27:53:56,720
herdar este método virtual, então vamos

42016
27:53:56,720 --> 27:53:58,720
Veja um exemplo aqui temos uma simples

42017
27:53:58,720 --> 27:54:01,120
Um exemplo que está criando objetos de

42018
27:54:01,120 --> 27:54:03,512
nossas formas temos um objeto de forma

42019
27:54:03,512 --> 27:54:05,760
Tenho um novo objeto e temos um círculo

42020
27:54:05,760 --> 27:54:08,480
objeto aqui, se chamarmos o método draw

42021
27:54:08,480 --> 27:54:10,960
em nossa classe mais derivada, que é

42022
27:54:10,960 --> 27:54:12,800
Círculo vamos ver que isso é

42023
27:54:12,800 --> 27:54:14,400
indo para o trabalho que podemos desenhar sem um

42024
27:54:14,400 --> 27:54:16,480
parâmetro e nós podemos desenhar com um

42025
27:54:16,480 --> 27:54:19,120
parâmetro que vai ser a nossa cor

42026
27:54:19,120 --> 27:54:21,512
profundidade isso vai funcionar muito bem

42027
27:54:21,512 --> 27:54:23,280
Vai estar a reutilizar

42028
27:54:23,280 --> 27:54:25,760
nosso método herdado da forma

42029
27:54:25,760 --> 27:54:28,080
classe e isso é muito legal, mas o que

42030
27:54:28,080 --> 27:54:31,600
acontece se você substituir este método em

42031
27:54:31,600 --> 27:54:34,640
a nossa classe supor que nós sequestramos o

42032
27:54:34,640 --> 27:54:36,872
processo de herança e montar outro

42033
27:54:36,872 --> 27:54:40,640
desenhar método em nossa classe e nós apenas

42034
27:54:40,640 --> 27:54:44,160
substituir a sobrecarga que não leva

42035
27:54:44,160 --> 27:54:45,912
Qualquer parâmetro que possamos fazer algo como

42036
27:54:45,912 --> 27:54:48,720
Isso mas no momento em que você faz isso, isso é

42037
27:54:48,720 --> 27:54:51,440
só vai substituir este método e

42038
27:54:51,440 --> 27:54:53,912
vai esconder todos os outros empate

42039
27:54:53,912 --> 27:54:57,600
métodos que tínhamos em nossa classe base

42040
27:54:57,600 --> 27:54:59,120
que é moldado aqui e isso é

42041
27:54:59,120 --> 27:55:01,600
Algo que eu quero que você saiba assim, uma vez

42042
27:55:01,600 --> 27:55:04,480
substituir uma única sobrecarga de sua

42043
27:55:04,480 --> 27:55:06,232
Funções virtuais

42044
27:55:06,232 --> 27:55:08,480
Todas as outras sobrecargas vão ser

42045
27:55:08,480 --> 27:55:11,512
escondidos e eles não serão mais utilizáveis

42046
27:55:11,512 --> 27:55:14,800
por classes de herança downstream se você

42047
27:55:14,800 --> 27:55:17,040
Quer que todas as sobrecargas estejam disponíveis

42048
27:55:17,040 --> 27:55:19,120
para a herança a jusante

42049
27:55:19,120 --> 27:55:21,912
aulas que você não tem escolha a não ser

42050
27:55:21,912 --> 27:55:24,960
substituir explicitamente cada um deles e

42051
27:55:24,960 --> 27:55:27,192
É assim que vai funcionar, então se nós

42052
27:55:27,192 --> 27:55:28,872
Veja o exemplo aqui que vamos

42053
27:55:28,872 --> 27:55:31,600
Veja que a chamada sem um

42054
27:55:31,600 --> 27:55:33,600
O parâmetro vai funcionar porque isso

42055
27:55:33,600 --> 27:55:37,440
é substituído em nossa classe oval, mas se

42056
27:55:37,440 --> 27:55:39,832
Chamamos aquele que leva um parâmetro

42057
27:55:39,832 --> 27:55:42,320
Isso vai ser escondido no oval

42058
27:55:42,320 --> 27:55:44,960
nível e queremos ter acesso a isso

42059
27:55:44,960 --> 27:55:46,800
em círculo e se tentarmos chamar isso de

42060
27:55:46,800 --> 27:55:48,552
vamos ter um erro de compilador

42061
27:55:48,552 --> 27:55:52,232
novamente a mensagem é se você substituir um

42062
27:55:52,232 --> 27:55:56,160
sobrecarga de suas funções virtuais em

42063
27:55:56,160 --> 27:55:58,320
A classe base todos os outros são

42064
27:55:58,320 --> 27:56:00,320
Vou ficar escondido e você não tem

42065
27:56:00,320 --> 27:56:03,120
escolha, mas para superá-los explicitamente

42066
27:56:03,120 --> 27:56:06,000
para que estejam disponíveis e utilizáveis em

42067
27:56:06,000 --> 27:56:08,800
classes downstream esta é a mensagem i

42068
27:56:08,800 --> 27:56:10,800
Eu queria transmitir aqui ok, então agora nós

42069
27:56:10,800 --> 27:56:13,760
Saiba isso, mas e se nós montarmos outro

42070
27:56:13,760 --> 27:56:15,280
sobrecarga

42071
27:56:15,280 --> 27:56:17,912
downstream, por exemplo, e se entrarmos

42072
27:56:17,912 --> 27:56:20,640
nossa classe oval e montar outra

42073
27:56:20,640 --> 27:56:22,800
sobrecarga que vai ter dois

42074
27:56:22,800 --> 27:56:24,720
Os parâmetros, por exemplo, podemos ter a

42075
27:56:24,720 --> 27:56:27,360
profundidade de cor e a cor aqui que nós

42076
27:56:27,360 --> 27:56:29,440
Quero desenhar bem, então uma coisa você

42077
27:56:29,440 --> 27:56:31,680
deve saber que este método é

42078
27:56:31,680 --> 27:56:33,680
Não vai participar em forma

42079
27:56:33,680 --> 27:56:37,040
O polimorfismo e o que quero dizer é que se

42080
27:56:37,040 --> 27:56:38,800
nós passamos por um ponteiro base ou

42081
27:56:38,800 --> 27:56:41,600
referência para gerenciar objetos derivados

42082
27:56:41,600 --> 27:56:43,680
Não pode realmente chamar este método com forma

42083
27:56:43,680 --> 27:56:46,160
Polimorfismo, então se passarmos por nós

42084
27:56:46,160 --> 27:56:48,232
shape pointer ou referência que queremos ser

42085
27:56:48,232 --> 27:56:50,552
realmente capaz de chamar este método se nós

42086
27:56:50,552 --> 27:56:52,552
Tente chamá-lo, vamos ter um compilador

42087
27:56:52,552 --> 27:56:55,440
erro o motivo é que este método não é

42088
27:56:55,440 --> 27:56:56,480
conhecidos

42089
27:56:56,480 --> 27:56:58,720
para a classe de forma é por isso que não é

42090
27:56:58,720 --> 27:57:00,872
indo para participar na forma

42091
27:57:00,872 --> 27:57:03,360
Polimorfismo, os únicos métodos que são

42092
27:57:03,360 --> 27:57:05,040
indo para participar na forma

42093
27:57:05,040 --> 27:57:07,600
O polimorfismo são os métodos que são

42094
27:57:07,600 --> 27:57:10,160
declarados na classe base e eles são

42095
27:57:10,160 --> 27:57:12,320
virtual esta é a condição aqui e

42096
27:57:12,320 --> 27:57:15,192
se você violar esta condição de alguma forma

42097
27:57:15,192 --> 27:57:17,280
polimorfismo de forma ou classe base

42098
27:57:17,280 --> 27:57:19,280
O polimorfismo, neste caso, não está indo

42099
27:57:19,280 --> 27:57:21,192
para trabalhar e você terá um compilador

42100
27:57:21,192 --> 27:57:23,440
Erro, se você tentar fazer algo como

42101
27:57:23,440 --> 27:57:25,512
Isso e você quer chamar seu sorteio

42102
27:57:25,512 --> 27:57:27,512
método com dois parâmetros que você está indo

42103
27:57:27,512 --> 27:57:29,192
para obter um monte de erros de compilador e

42104
27:57:29,192 --> 27:57:31,192
Isso não vai funcionar outra coisa

42105
27:57:31,192 --> 27:57:33,360
Eu quero que você veja é que se você atribuir

42106
27:57:33,360 --> 27:57:36,720
um objeto derivado para um objeto base

42107
27:57:36,720 --> 27:57:40,400
suas funções virtuais derivadas estão indo

42108
27:57:40,400 --> 27:57:43,912
ser eliminado como parte do empate

42109
27:57:43,912 --> 27:57:46,400
que já aprendemos sobre isso

42110
27:57:46,400 --> 27:57:49,192
O porto do círculo vai ser eliminado

42111
27:57:49,192 --> 27:57:51,600
A parte oval vai ser cortada

42112
27:57:51,600 --> 27:57:54,000
e o método de desenho vai ir com

42113
27:57:54,000 --> 27:57:56,872
nossa parte oval e só ficaremos

42114
27:57:56,872 --> 27:57:59,120
com o shareport e se tentarmos chamar

42115
27:57:59,120 --> 27:58:01,040
Este método aqui vamos obter um compilador

42116
27:58:01,040 --> 27:58:03,360
Erro porque não está mais disponível

42117
27:58:03,360 --> 27:58:05,600
Foi cortado disto é realmente o que

42118
27:58:05,600 --> 27:58:07,760
Eu quero que você veja aqui agora que nós sabemos

42119
27:58:07,760 --> 27:58:09,280
Isso nós vamos ir para o visual

42120
27:58:09,280 --> 27:58:11,120
código de estúdio e jogar com isso um pouco

42121
27:58:11,120 --> 27:58:13,832
Mais aqui estamos em nossa pasta de trabalho

42122
27:58:13,832 --> 27:58:16,232
O projeto atual está sobrecarregando

42123
27:58:16,232 --> 27:58:18,720
substituindo e escondendo, queremos explorar

42124
27:58:18,720 --> 27:58:21,280
Estes conceitos em um pouco mais de detalhes

42125
27:58:21,280 --> 27:58:22,720
Vamos pegar o código do

42126
27:58:22,720 --> 27:58:24,480
A última palestra, porque isso vai ser

42127
27:58:24,480 --> 27:58:26,160
Um bom ponto de partida nós vamos

42128
27:58:26,160 --> 27:58:28,232
tirar o binário que não queremos isso

42129
27:58:28,232 --> 27:58:30,080
E nós vamos copiar e nós vamos

42130
27:58:30,080 --> 27:58:32,720
para colocar isso em nosso projeto atual aqui

42131
27:58:32,720 --> 27:58:34,872
Isso vai fazer e nós vamos

42132
27:58:34,872 --> 27:58:36,800
abrir isso em código de estúdio visual bastante

42133
27:58:36,800 --> 27:58:39,040
rápido arrastando e soltando aqui e

42134
27:58:39,040 --> 27:58:41,192
nós vamos ver que nós temos um monte

42135
27:58:41,192 --> 27:58:42,320
de

42136
27:58:42,320 --> 27:58:44,160
funções virtuais aqui que têm apenas os

42137
27:58:44,160 --> 27:58:47,192
desenhar versão, mas podemos configurar um

42138
27:58:47,192 --> 27:58:49,512
sobrecarga deste método de sorteio aqui este

42139
27:58:49,512 --> 27:58:51,600
É o que queremos fazer para que eu vá

42140
27:58:51,600 --> 27:58:54,000
ir abaixo aqui e configurar uma sobrecarga de

42141
27:58:54,000 --> 27:58:55,912
Este método vai estar tomando

42142
27:58:55,912 --> 27:58:59,120
a profundidade da cor como um parâmetro e nós

42143
27:58:59,120 --> 27:59:01,440
Quer ver como isso é utilizável

42144
27:59:01,440 --> 27:59:04,320
downstream para que vamos descer

42145
27:59:04,320 --> 27:59:06,872
A principal função de cpp

42146
27:59:06,872 --> 27:59:09,440
e tirar o que não precisamos aqui

42147
27:59:09,440 --> 27:59:12,000
Precisamos de um monte de objetos que possamos

42148
27:59:12,000 --> 27:59:15,120
configurar o círculo um e sobre um e nós

42149
27:59:15,120 --> 27:59:17,120
veremos que podemos chamar esse método

42150
27:59:17,120 --> 27:59:19,192
nós vamos dizer círculo um empate

42151
27:59:19,192 --> 27:59:20,720
Sem um parâmetro e nós vamos

42152
27:59:20,720 --> 27:59:24,552
Diga círculo um empate e passe e 44 como

42153
27:59:24,552 --> 27:59:26,872
nosso parâmetro e vamos voltar e fazer

42154
27:59:26,872 --> 27:59:30,000
certeza de que temos nossa sobrecarga e isso

42155
27:59:30,000 --> 27:59:32,720
Vai levar a profundidade da cor

42156
27:59:32,720 --> 27:59:34,872
e vamos tentar construir o nosso programa

42157
27:59:34,872 --> 27:59:37,192
porque temos uma linha aqui

42158
27:59:37,192 --> 27:59:39,440
Vamos ver se é apenas um estúdio visual

42159
27:59:39,440 --> 27:59:41,360
códigos jogando jogos conosco, estamos indo

42160
27:59:41,360 --> 27:59:43,600
para passar isso através de gcc e vamos

42161
27:59:43,600 --> 27:59:45,912
ter um erro de compilador aqui, então o que é

42162
27:59:45,912 --> 27:59:49,040
indo para o candidato virtual draw custo

42163
27:59:49,040 --> 27:59:51,912
Vamos subir e ver que tipo de problema

42164
27:59:51,912 --> 27:59:54,552
Temos aqui ah este é o conceito que nós

42165
27:59:54,552 --> 27:59:57,120
Só falei nos slides que somos

42166
27:59:57,120 --> 28:00:00,480
configurando nossas sobrecargas aqui, mas isso

42167
28:00:00,480 --> 28:00:03,280
está sendo eclipsado pelas sobrecargas que

42168
28:00:03,280 --> 28:00:05,360
Estamos nos instalando no oval, você vê

42169
28:00:05,360 --> 28:00:07,760
ter uma substituição de empate e isso também é

42170
28:00:07,760 --> 28:00:10,800
sendo eclipsado pela substituição que temos

42171
28:00:10,800 --> 28:00:14,320
em nossa classe circular aqui, se quisermos o

42172
28:00:14,320 --> 28:00:16,552
duas sobrecargas que temos da forma a ser

42173
28:00:16,552 --> 28:00:18,400
disponíveis, podemos comentar o

42174
28:00:18,400 --> 28:00:20,720
substituições que temos em círculo e

42175
28:00:20,720 --> 28:00:23,040
oval vamos fazer isso e isso vai

42176
28:00:23,040 --> 28:00:25,600
estar disponível e utilizável, então vamos fazer isso

42177
28:00:25,600 --> 28:00:26,960
Este é um aprendizado muito bom

42178
28:00:26,960 --> 28:00:30,480
oportunidade e agora se formos no cpp principal

42179
28:00:30,480 --> 28:00:31,912
nós vamos ver que isso vai

42180
28:00:31,912 --> 28:00:34,480
tornar-se disponível para que possamos fazer upload deste

42181
28:00:34,480 --> 28:00:37,760
com gcc novamente para trazer estúdio visual

42182
28:00:37,760 --> 28:00:40,232
código atualizado e você vê que a compilação é

42183
28:00:40,232 --> 28:00:43,040
O bem e nossos métodos são utilizáveis mesmo

42184
28:00:43,040 --> 28:00:46,080
de classes derivadas, por exemplo,

42185
28:00:46,080 --> 28:00:49,280
também pode criar um novo objeto, digamos

42186
28:00:49,280 --> 28:00:51,912
oval e diga desenhar isso vai

42187
28:00:51,912 --> 28:00:54,800
trabalhar se disser ovo um empatar e passar em

42188
28:00:54,800 --> 28:00:57,832
um parâmetro vamos colocar em 54, por exemplo

42189
28:00:57,832 --> 28:00:59,832
Isso vai fazer você vai ver

42190
28:00:59,832 --> 28:01:01,680
que isso vai ser aceito por

42191
28:01:01,680 --> 28:01:05,040
código de estúdio visual e se soldamos e

42192
28:01:05,040 --> 28:01:07,512
executar este programa que vai construí-lo

42193
28:01:07,512 --> 28:01:09,912
Vai chamar os herdados

42194
28:01:09,912 --> 28:01:12,552
funções em oval e

42195
28:01:12,552 --> 28:01:15,440
Círculo aqui o barco é bom que podemos matar

42196
28:01:15,440 --> 28:01:17,680
nosso terminal aqui e trazer uma

42197
28:01:17,680 --> 28:01:19,680
janela powershell que podemos usar para executar o nosso

42198
28:01:19,680 --> 28:01:21,912
programa, vamos ver que chamamos

42199
28:01:21,912 --> 28:01:24,800
desenho de forma e desenho de forma porque estes

42200
28:01:24,800 --> 28:01:27,512
São funções herdadas de

42201
28:01:27,512 --> 28:01:29,680
A classe de forma é por isso que estamos dizendo

42202
28:01:29,680 --> 28:01:31,600
Forma desenhar aqui e nós vamos ser

42203
28:01:31,600 --> 28:01:34,320
desenhando um oval e um desenho com um

42204
28:01:34,320 --> 28:01:36,160
profundidade de cor que vamos estar desenhando

42205
28:01:36,160 --> 28:01:38,160
o círculo e desenho com a cor

42206
28:01:38,160 --> 28:01:40,160
profundidade aqui esta é a mensagem que eu quero

42207
28:01:40,160 --> 28:01:42,872
transmitir, mas no momento vamos sobrepor estes

42208
28:01:42,872 --> 28:01:45,680
métodos em qualquer classe downstream para

42209
28:01:45,680 --> 28:01:48,800
exemplo se entrarmos em nossa classe e

42210
28:01:48,800 --> 28:01:51,040
e comentar a substituição para o

42211
28:01:51,040 --> 28:01:53,760
draw method note que somos apenas

42212
28:01:53,760 --> 28:01:56,960
substituindo uma única sobrecarga novamente se nós

42213
28:01:56,960 --> 28:01:59,120
voltar à nossa classe de forma, temos um

42214
28:01:59,120 --> 28:02:01,440
sobrecarga que não leva nenhum parâmetro

42215
28:02:01,440 --> 28:02:03,360
Temos também uma sobrecarga que está indo

42216
28:02:03,360 --> 28:02:05,832
para tomar um parâmetro no oval nós somos

42217
28:02:05,832 --> 28:02:09,512
apenas vai substituir a sobrecarga que

42218
28:02:09,512 --> 28:02:11,512
não toma nenhum parâmetro, mas isto é

42219
28:02:11,512 --> 28:02:13,912
Vou esconder todas as outras sobrecargas que nós

42220
28:02:13,912 --> 28:02:17,040
tinha para o método draw aqui e este é

42221
28:02:17,040 --> 28:02:19,192
A única sobrecarga que vai ser

42222
28:02:19,192 --> 28:02:20,400
Disponível

42223
28:02:20,400 --> 28:02:23,192
em classes a jusante, então se voltarmos

42224
28:02:23,192 --> 28:02:24,720
Principal vamos ver que aquele

42225
28:02:24,720 --> 28:02:26,552
com um parâmetro não vai funcionar

42226
28:02:26,552 --> 28:02:27,760
e nós vamos ter um monte de

42227
28:02:27,760 --> 28:02:30,232
erros do compilador este será o

42228
28:02:30,232 --> 28:02:32,872
caso mesmo em círculo se nós

42229
28:02:32,872 --> 28:02:35,280
descomentado esse cara, os outros estão indo

42230
28:02:35,280 --> 28:02:37,832
para ser eclipsado novamente o outro que nós

42231
28:02:37,832 --> 28:02:40,160
tem é apenas aquele com um parâmetro

42232
28:02:40,160 --> 28:02:42,320
mas isso vai permanecer verdadeiro mesmo se

42233
28:02:42,320 --> 28:02:44,872
Você tem uma centena de sobrecargas todas as

42234
28:02:44,872 --> 28:02:46,800
Outros não estarão disponíveis se

42235
28:02:46,800 --> 28:02:49,600
Você apenas supera um dos

42236
28:02:49,600 --> 28:02:51,832
sobrecargas em outras palavras

42237
28:02:51,832 --> 28:02:53,760
As outras sobrecargas serão

42238
28:02:53,760 --> 28:02:57,192
Escondido por este passeio geral que você

42239
28:02:57,192 --> 28:02:59,280
estão colocando em sua herança

42240
28:02:59,280 --> 28:03:01,680
hierarquia, você deve realmente saber disso se

42241
28:03:01,680 --> 28:03:03,912
Você quer que este guia esteja disponível em

42242
28:03:03,912 --> 28:03:06,400
classes downstream, por exemplo, você pode

42243
28:03:06,400 --> 28:03:09,280
também anulando que em classes derivadas

42244
28:03:09,280 --> 28:03:12,160
Esta é uma opção que podemos ir em oval e

42245
28:03:12,160 --> 28:03:14,800
colocar em outra sobrecarga para isso é

42246
28:03:14,800 --> 28:03:17,600
vamos trazer isso de volta ao escopo, então nós

42247
28:03:17,600 --> 28:03:21,192
pode dizer overdraw aqui com a cor

42248
28:03:21,192 --> 28:03:23,360
profundidade eu não acho que nós copiemos o certo

42249
28:03:23,360 --> 28:03:25,912
A coisa nós podemos pegar isso e ir no oval

42250
28:03:25,912 --> 28:03:28,232
e colocar isso no lugar que isso vai

42251
28:03:28,232 --> 28:03:31,440
nós vamos dizer desenho oval e

42252
28:03:31,440 --> 28:03:33,832
Podemos ir em círculo e também colocar isso

42253
28:03:33,832 --> 28:03:36,320
O fim é uma opção e nós vamos

42254
28:03:36,320 --> 28:03:39,760
Diga desenho do círculo e agora você vê isso

42255
28:03:39,760 --> 28:03:41,912
as linhas do pé no principal vão embora

42256
28:03:41,912 --> 28:03:44,552
porque nós superamos todos os

42257
28:03:44,552 --> 28:03:47,120
sobrecargas bem se construirmos e executarmos o nosso

42258
28:03:47,120 --> 28:03:48,640
programa vamos ver que isto é

42259
28:03:48,640 --> 28:03:50,872
Vou trabalhar como esperamos que o mundo seja

42260
28:03:50,872 --> 28:03:53,440
Vamos ser bons e podemos limpar

42261
28:03:53,440 --> 28:03:55,120
e correr o galo, vamos ver isso

42262
28:03:55,120 --> 28:03:58,080
overdraw chamado overdraw chamado estamos

42263
28:03:58,080 --> 28:04:00,800
chamando nossas substituições derivadas e isso

42264
28:04:00,800 --> 28:04:03,120
É muito legal isto é o que queremos aqui

42265
28:04:03,120 --> 28:04:05,192
Vamos levar isso de volta porque nós não

42266
28:04:05,192 --> 28:04:06,480
Quero estes

42267
28:04:06,480 --> 28:04:09,440
primordial em nossas classes herdadas assim

42268
28:04:09,440 --> 28:04:12,232
nós vamos tirar isso no oval

42269
28:04:12,232 --> 28:04:14,160
E nós vamos tirar isso para dentro

42270
28:04:14,160 --> 28:04:17,440
círculo e eu quero que você veja essa forma

42271
28:04:17,440 --> 28:04:20,232
O polimorfismo não vai funcionar se você

42272
28:04:20,232 --> 28:04:23,760
substituir seus métodos em um downstream

42273
28:04:23,760 --> 28:04:25,760
O que vamos fazer, estamos

42274
28:04:25,760 --> 28:04:28,232
indo para ir no nível oval e configurar

42275
28:04:28,232 --> 28:04:31,760
Outra sobrecarga para o método joe aqui

42276
28:04:31,760 --> 28:04:33,912
mas este método de sorteio não vai

42277
28:04:33,912 --> 28:04:36,400
Participar do polimorfismo de forma

42278
28:04:36,400 --> 28:04:38,640
porque é realmente declarado no

42279
28:04:38,640 --> 28:04:41,832
nível oval e qualquer ponte de base que temos

42280
28:04:41,832 --> 28:04:44,232
ou qualquer ponteiro de forma que temos não é

42281
28:04:44,232 --> 28:04:46,080
ter todo o conhecimento disso

42282
28:04:46,080 --> 28:04:48,160
sobrecarga que estamos prestes a configurar

42283
28:04:48,160 --> 28:04:50,232
Aqui é isso que eu quero que você saiba

42284
28:04:50,232 --> 28:04:52,552
Tudo bem, então vamos entrar em nosso oval

42285
28:04:52,552 --> 28:04:54,872
classe e configurar essa sobrecarga que podemos

42286
28:04:54,872 --> 28:04:58,160
configurar que aqui vai ser tomado

42287
28:04:58,160 --> 28:05:00,480
Dois parâmetros um vai ser o

42288
28:05:00,480 --> 28:05:02,320
profundidade de cor o outro vai ser o

42289
28:05:02,320 --> 28:05:05,192
cor e nós não queremos passar uma corda

42290
28:05:05,192 --> 28:05:07,360
por um valor como este, podemos usar std

42291
28:05:07,360 --> 28:05:10,480
string view e podemos incluir isso se

42292
28:05:10,480 --> 28:05:12,800
Precisamos, mas parece visual

42293
28:05:12,800 --> 28:05:15,280
O código do estúdio tem isso de algo

42294
28:05:15,280 --> 28:05:17,680
Caso incluamos antes, mas podemos

42295
28:05:17,680 --> 28:05:19,760
Inclua isso explicitamente para evitar

42296
28:05:19,760 --> 28:05:21,680
Problemas para que vamos fazer isso

42297
28:05:21,680 --> 28:05:24,480
Diga streaming view aqui e agora queremos

42298
28:05:24,480 --> 28:05:26,232
Veja que esse método não vai

42299
28:05:26,232 --> 28:05:29,360
participar do polimorfismo de forma mesmo

42300
28:05:29,360 --> 28:05:31,760
Se for uma função virtual, o motivo

42301
28:05:31,760 --> 28:05:34,000
É que isso não vai ser conhecido pelo seu

42302
28:05:34,000 --> 28:05:36,000
Forma ponteiros porque não é

42303
28:05:36,000 --> 28:05:38,320
declarada no nível sherpa aqui i

42304
28:05:38,320 --> 28:05:40,080
Eu realmente quero que você saiba que estamos indo

42305
28:05:40,080 --> 28:05:42,552
para tirar tudo o que tínhamos aqui e

42306
28:05:42,552 --> 28:05:44,080
Podemos configurar um ponteiro de forma que somos

42307
28:05:44,080 --> 28:05:47,040
vou dizer forma e dizer navio ptr e

42308
28:05:47,040 --> 28:05:49,360
Vamos criar um objeto derivado

42309
28:05:49,360 --> 28:05:52,080
Aqui podemos dizer novo e sério círculo

42310
28:05:52,080 --> 28:05:54,232
O que precisamos para construir o círculo

42311
28:05:54,232 --> 28:05:56,720
o objeto precisamos do raio e do

42312
28:05:56,720 --> 28:05:58,800
descrição então nós vamos colocar isso

42313
28:05:58,800 --> 28:06:01,040
no lugar aqui o raio vai ser

42314
28:06:01,040 --> 28:06:03,360
Algo como 10 por que não e

42315
28:06:03,360 --> 28:06:05,120
A descrição vai ser o círculo um

42316
28:06:05,120 --> 28:06:08,080
Quão criativo e queremos ver se o nosso

42317
28:06:08,080 --> 28:06:10,552
O método está disponível através do polimorfismo

42318
28:06:10,552 --> 28:06:12,480
e não vai estar disponível

42319
28:06:12,480 --> 28:06:15,360
porque o método não foi declarado em

42320
28:06:15,360 --> 28:06:18,320
O nível de forma, então se nós moldamos ptr

42321
28:06:18,320 --> 28:06:20,872
e dizer draw e temos um método que

42322
28:06:20,872 --> 28:06:23,600
vai tomar dois parâmetros no

42323
28:06:23,600 --> 28:06:26,000
nível oval temos a profundidade de cor e

42324
28:06:26,000 --> 28:06:27,280
a cor

42325
28:06:27,280 --> 28:06:30,160
por exemplo, se formos principais e dissermos

42326
28:06:30,160 --> 28:06:34,000
A profundidade de cor é 45.21

42327
28:06:34,000 --> 28:06:35,832
Não vamos dizer que isso é algo que

42328
28:06:35,832 --> 28:06:37,832
Faz sentido ou vamos usar

42329
28:06:37,832 --> 28:06:40,552
45 porque este é um parâmetro inteiro

42330
28:06:40,552 --> 28:06:42,160
E nós vamos passar em uma corda

42331
28:06:42,160 --> 28:06:44,480
Vamos dizer vermelho você vai ver isso

42332
28:06:44,480 --> 28:06:46,552
Isso não vai compilar

42333
28:06:46,552 --> 28:06:48,552
Porque é o método draw com dois

42334
28:06:48,552 --> 28:06:51,192
Os parâmetros não são conhecidos na forma

42335
28:06:51,192 --> 28:06:53,360
Nível Esta é a mensagem que eu quero

42336
28:06:53,360 --> 28:06:56,232
Transmito aqui se você quiser o seu método

42337
28:06:56,232 --> 28:06:58,960
para ser utilizável com polimorfismo o

42338
28:06:58,960 --> 28:07:02,080
O método tem que aparecer no nível superior

42339
28:07:02,080 --> 28:07:04,232
Isto é o que eu quero que você veja aqui se

42340
28:07:04,232 --> 28:07:05,600
Estamos tentando construir isso que estamos indo

42341
28:07:05,600 --> 28:07:07,912
para obter um erro de compilador e você precisa

42342
28:07:07,912 --> 28:07:11,040
Esteja ciente disso, mas saiba que mesmo se

42343
28:07:11,040 --> 28:07:12,720
Isso não está funcionando com forma

42344
28:07:12,720 --> 28:07:15,640
Polimorfismo que pode funcionar com oval

42345
28:07:15,640 --> 28:07:18,320
Polimorfismo e esta é uma ideia

42346
28:07:18,320 --> 28:07:20,800
Vou explorar na próxima palestra

42347
28:07:20,800 --> 28:07:23,512
onde aprendemos sobre o fato de que o polar

42348
28:07:23,512 --> 28:07:26,160
O morfismo pode ser configurado em diferentes

42349
28:07:26,160 --> 28:07:28,232
níveis, então vamos parar por aqui

42350
28:07:28,232 --> 28:07:30,960
Esta palestra e explorar essa ideia em

42351
28:07:30,960 --> 28:07:33,360
Detalhe na próxima palestra, então vá em frente

42352
28:07:33,360 --> 28:07:35,760
e terminar aqui e encontrar-me lá dentro

42353
28:07:35,760 --> 28:07:37,760
Esta palestra vamos explorar o

42354
28:07:37,760 --> 28:07:40,120
ideia de que podemos fazer

42355
28:07:40,120 --> 28:07:43,360
polimorfismo em diferentes níveis em nossa

42356
28:07:43,360 --> 28:07:45,280
Hierarquia de herança

42357
28:07:45,280 --> 28:07:48,080
Suponhamos que temos uma hierarquia como vemos

42358
28:07:48,080 --> 28:07:50,872
Aqui a classe de nível superior é animal e

42359
28:07:50,872 --> 28:07:53,600
Podemos derivar do animal e criar um

42360
28:07:53,600 --> 28:07:56,720
animal felino que podemos derivar do felino

42361
28:07:56,720 --> 28:07:59,680
e criar um animal de cão que podemos obter

42362
28:07:59,680 --> 28:08:02,480
do felino criar um animal de gato que pudermos

42363
28:08:02,480 --> 28:08:04,640
também fazê-lo para o outro lado e criar um

42364
28:08:04,640 --> 28:08:07,360
pássaro que também é um animal que um pássaro é

42365
28:08:07,360 --> 28:08:09,760
ter seus próprios métodos e membros

42366
28:08:09,760 --> 28:08:12,480
variáveis que fazem dele um pássaro que podemos

42367
28:08:12,480 --> 28:08:15,040
deriva de um pássaro cria um pombo e

42368
28:08:15,040 --> 28:08:17,440
Podemos derivar de um pássaro e criar um

42369
28:08:17,440 --> 28:08:18,480
Multidão

42370
28:08:18,480 --> 28:08:20,232
e nós podemos fazer todas essas coisas que

42371
28:08:20,232 --> 28:08:22,080
Estes animais fazem

42372
28:08:22,080 --> 28:08:24,320
A ideia que quero expor aqui é

42373
28:08:24,320 --> 28:08:26,400
O polimorfismo

42374
28:08:26,400 --> 28:08:29,280
Não tem que sempre trabalhar apenas no

42375
28:08:29,280 --> 28:08:31,832
classe de nível superior se você tem um

42376
28:08:31,832 --> 28:08:34,160
Hierarquia de herança como esta, se você

42377
28:08:34,160 --> 28:08:37,360
Quer que você possa declarar um método virtual em

42378
28:08:37,360 --> 28:08:39,912
o nível felino e certifique-se de que

42379
28:08:39,912 --> 28:08:42,080
O método também está disponível em derivação

42380
28:08:42,080 --> 28:08:44,320
classe e você pode configurar felino

42381
28:08:44,320 --> 28:08:46,800
Polimorfismo se isso faz sentido para

42382
28:08:46,800 --> 28:08:49,360
sua aplicação seguindo a mesma ideia

42383
28:08:49,360 --> 28:08:51,760
Você também pode configurar um método virtual em

42384
28:08:51,760 --> 28:08:54,160
a classe de pássaro e você pode ter isso

42385
28:08:54,160 --> 28:08:56,552
método substituído em downstream

42386
28:08:56,552 --> 28:08:59,512
classes de herança como pombo e corvo

42387
28:08:59,512 --> 28:09:02,320
e você pode configurar o polimorfismo de aves em

42388
28:09:02,320 --> 28:09:04,960
seu c plus plus programa se isso for

42389
28:09:04,960 --> 28:09:07,040
senso de curso você ainda pode usar animal

42390
28:09:07,040 --> 28:09:09,832
polimorfismo se você quiser fazer isso e

42391
28:09:09,832 --> 28:09:12,080
que vai funcionar também este é o

42392
28:09:12,080 --> 28:09:14,400
ideia que vamos explorar aqui bem, então

42393
28:09:14,400 --> 28:09:17,040
com essa hierarquia de herança em mente

42394
28:09:17,040 --> 28:09:20,160
podemos criar polimorfismo animal e

42395
28:09:20,160 --> 28:09:22,552
O polimorfismo animal está apenas indo

42396
28:09:22,552 --> 28:09:25,192
através do ponteiro de base animal e

42397
28:09:25,192 --> 28:09:28,400
usando isso para gerenciar objetos derivados para

42398
28:09:28,400 --> 28:09:30,400
Exemplo aqui temos um cão que temos um gato

42399
28:09:30,400 --> 28:09:32,552
Temos um pombo, temos um corvo que podemos

42400
28:09:32,552 --> 28:09:35,280
fazer polimorfismo animal e armazenar qualquer

42401
28:09:35,280 --> 28:09:37,040
tipo de animal que temos aqui você vê que nós

42402
28:09:37,040 --> 28:09:39,360
estão colocando em um cão que estamos colocando em um

42403
28:09:39,360 --> 28:09:41,280
Gato estamos colocando em um pombo e nós

42404
28:09:41,280 --> 28:09:42,960
estão colocando em um corvo

42405
28:09:42,960 --> 28:09:45,680
e se fizermos o polimorfismo animal e

42406
28:09:45,680 --> 28:09:48,320
chamar o método da respiração que existe em

42407
28:09:48,320 --> 28:09:49,760
qualquer tipo de animal que temos em nosso

42408
28:09:49,760 --> 28:09:52,320
programa que vai chamar de mais

42409
28:09:52,320 --> 28:09:55,040
Método específico da respiração em cada animal

42410
28:09:55,040 --> 28:09:56,552
E isso vai funcionar muito bem

42411
28:09:56,552 --> 28:09:59,192
Isso vai fazer polimorfismo animal

42412
28:09:59,192 --> 28:10:01,040
seguindo a mesma ideia que também podemos fazer

42413
28:10:01,040 --> 28:10:04,080
O polimorfismo felino e neste caso

42414
28:10:04,080 --> 28:10:06,800
O felino vai agir como nossa base

42415
28:10:06,800 --> 28:10:09,440
ponto, então novamente temos o nosso cão que temos

42416
28:10:09,440 --> 28:10:11,832
nosso gato temos nosso pombo se fizermos

42417
28:10:11,832 --> 28:10:14,480
Polimorfismo felino que teremos que colocar

42418
28:10:14,480 --> 28:10:17,280
em todos os tipos de felinos loucos que temos em

42419
28:10:17,280 --> 28:10:19,440
Nosso programa, por exemplo, podemos colocar em

42420
28:10:19,440 --> 28:10:21,680
cão e gato e isso vai funcionar se

42421
28:10:21,680 --> 28:10:23,832
Você preenche um polimorfismo como nós

42422
28:10:23,832 --> 28:10:26,960
estão fazendo aqui e colocar em um animal este

42423
28:10:26,960 --> 28:10:29,440
Não vai trabalhar porque o animal

42424
28:10:29,440 --> 28:10:32,872
Classe de nível superior provavelmente não vai

42425
28:10:32,872 --> 28:10:34,552
substituir o

42426
28:10:34,552 --> 28:10:37,280
Método virtual em que estamos interessados aqui

42427
28:10:37,280 --> 28:10:39,040
Por exemplo, aqui estamos chamando a corrida

42428
28:10:39,040 --> 28:10:41,360
O método de execução não é configurado

42429
28:10:41,360 --> 28:10:43,912
no nível animal vamos voltar e

42430
28:10:43,912 --> 28:10:46,480
Olhe para a nossa hierarquia de herança aqui

42431
28:10:46,480 --> 28:10:49,040
Você vê que esta é a nossa classe animal nosso

42432
28:10:49,040 --> 28:10:51,192
O método virtual vai ser respirado

42433
28:10:51,192 --> 28:10:53,120
Porque qualquer tipo de animal que temos é

42434
28:10:53,120 --> 28:10:55,832
Vou precisar respirar, mas a corrida

42435
28:10:55,832 --> 28:10:59,120
O método é configurado no nível felino assim

42436
28:10:59,120 --> 28:11:02,800
se tentarmos armazenar um animal em um

42437
28:11:02,800 --> 28:11:06,080
configuração que usa polimorfismo de arquivo

42438
28:11:06,080 --> 28:11:08,000
O método de execução não estará disponível

42439
28:11:08,000 --> 28:11:09,600
e vamos ter um erro de compilador

42440
28:11:09,600 --> 28:11:11,440
então eu quero que você saiba disso, mas nós vamos

42441
28:11:11,440 --> 28:11:13,512
veja isso em um minuto quando batemos

42442
28:11:13,512 --> 28:11:15,512
código de estúdio visual para realmente jogar com

42443
28:11:15,512 --> 28:11:18,400
nós ok nós também podemos fazer polimorfismo de aves

42444
28:11:18,400 --> 28:11:20,480
E aqui você vê que temos dois objetos um

42445
28:11:20,480 --> 28:11:23,040
É um pombo, o outro é um corvo

42446
28:11:23,040 --> 28:11:25,360
e nós vamos fazer polimorfismo de aves

42447
28:11:25,360 --> 28:11:28,400
Aqui e o que isso significa é que vamos

42448
28:11:28,400 --> 28:11:31,440
Use um ponteiro de pássaro para gerenciar todos os tipos

42449
28:11:31,440 --> 28:11:33,440
de pássaros loucos em nosso c plus mais

42450
28:11:33,440 --> 28:11:35,832
programa, por exemplo, podemos usar isso para

42451
28:11:35,832 --> 28:11:37,600
gerir um pombo que podemos usar isso para

42452
28:11:37,600 --> 28:11:40,232
gerenciar um corvo e se nós percorrermos o nosso

42453
28:11:40,232 --> 28:11:43,512
aves e chamar o método da mosca mais

42454
28:11:43,512 --> 28:11:45,680
O método específico da mosca será

42455
28:11:45,680 --> 28:11:47,832
convocados neste caso no primeiro

42456
28:11:47,832 --> 28:11:49,512
iteração, vamos chamar a mosca

42457
28:11:49,512 --> 28:11:52,160
método em nosso objeto de pombo no

42458
28:11:52,160 --> 28:11:53,912
segunda iteração, vamos chamar de

42459
28:11:53,912 --> 28:11:57,360
método fly em nosso objeto de rastreamento aqui e

42460
28:11:57,360 --> 28:11:59,512
Isso vai funcionar agora que você sabe

42461
28:11:59,512 --> 28:12:01,040
Isso nós vamos ir para o visual

42462
28:12:01,040 --> 28:12:02,872
código de estúdio e jogar com isso um pouco

42463
28:12:02,872 --> 28:12:06,000
Mais aqui estamos em nossa pasta de trabalho

42464
28:12:06,000 --> 28:12:08,800
O projeto atual é o polimorfismo em

42465
28:12:08,800 --> 28:12:11,360
Diferentes níveis nós vamos pegar o nosso

42466
28:12:11,360 --> 28:12:13,512
Arquivos de modelo vamos pegar tudo o que somos

42467
28:12:13,512 --> 28:12:16,000
Vou copiar isso e colocar isso em nosso

42468
28:12:16,000 --> 28:12:17,760
Projeto atual

42469
28:12:17,760 --> 28:12:19,512
E nós vamos abrir esse garotinho

42470
28:12:19,512 --> 28:12:22,080
em código de estúdio visual como sempre fazemos

42471
28:12:22,080 --> 28:12:24,552
e antes que abramos isso eu vou

42472
28:12:24,552 --> 28:12:27,040
colocar nas aulas que eu tenho deitado ao redor

42473
28:12:27,040 --> 28:12:29,680
na minha unidade e estes vão ser

42474
28:12:29,680 --> 28:12:32,480
as classes que compõem nossa herança

42475
28:12:32,480 --> 28:12:36,160
Hierarquia aqui para fazer as coisas irem mais rápido

42476
28:12:36,160 --> 28:12:38,160
Se você quiser, você pode pegar essas aulas

42477
28:12:38,160 --> 28:12:40,720
da seção de recursos anexada em

42478
28:12:40,720 --> 28:12:42,640
Esta palestra você vai encontrar tudo

42479
28:12:42,640 --> 28:12:44,480
estes arquivos você pode baixá-los e

42480
28:12:44,480 --> 28:12:46,720
Coloque-os em seu projeto e use isso como

42481
28:12:46,720 --> 28:12:48,552
Um ponto de partida porque você não

42482
28:12:48,552 --> 28:12:50,320
realmente quero estar criando tudo isso

42483
28:12:50,320 --> 28:12:52,720
aulas isso vai desperdiçar seu

42484
28:12:52,720 --> 28:12:55,040
tempo a ideia básica que eu queria expor

42485
28:12:55,040 --> 28:12:58,080
Aqui está fazendo polimorfismo em diferentes

42486
28:12:58,080 --> 28:13:00,232
níveis, então vamos abrir isso em

42487
28:13:00,232 --> 28:13:02,000
código visual do estúdio arrastando e

42488
28:13:02,000 --> 28:13:04,160
Dando aqui isso vai nos dar

42489
28:13:04,160 --> 28:13:06,720
Nosso bom ponto de partida você vê que temos

42490
28:13:06,720 --> 28:13:09,120
um monte de aulas aqui, mas tudo isso

42491
28:13:09,120 --> 28:13:11,440
As aulas estão realmente tentando configurar o

42492
28:13:11,440 --> 28:13:14,000
Hierarquia de herança que temos aqui o

42493
28:13:14,000 --> 28:13:15,832
A classe superior vai ser o animal

42494
28:13:15,832 --> 28:13:16,800
classe de classe

42495
28:13:16,800 --> 28:13:19,120
Podemos derivar do animal e criar um

42496
28:13:19,120 --> 28:13:20,720
enchimento em uma classe

42497
28:13:20,720 --> 28:13:23,040
e podemos derivar de animais e também

42498
28:13:23,040 --> 28:13:26,000
criar uma classe de pássaro da qual podemos derivar

42499
28:13:26,000 --> 28:13:28,080
felino e criar uma escuridão que podemos obter

42500
28:13:28,080 --> 28:13:30,080
do felino e criar um gato

42501
28:13:30,080 --> 28:13:32,400
e também podemos derivar da criação de aves

42502
28:13:32,400 --> 28:13:34,960
um pombo que também podemos derivar do pássaro

42503
28:13:34,960 --> 28:13:38,160
e criar uma classe de multidão e em cada um

42504
28:13:38,160 --> 28:13:39,912
Nível nós vamos ter um virtual

42505
28:13:39,912 --> 28:13:41,680
Método que nós configuramos

42506
28:13:41,680 --> 28:13:45,192
que outras classes derivais podem chamar

42507
28:13:45,192 --> 28:13:47,440
através do polimorfismo, por exemplo, se

42508
28:13:47,440 --> 28:13:49,680
fazer polimorfismo animal, vamos ter

42509
28:13:49,680 --> 28:13:52,552
método correto da respiração chamado independentemente

42510
28:13:52,552 --> 28:13:55,280
do objeto real que estamos gerenciando

42511
28:13:55,280 --> 28:13:57,280
com o nosso ponteiro animal

42512
28:13:57,280 --> 28:14:00,000
Se fizermos o polimorfismo felino, podemos

42513
28:14:00,000 --> 28:14:02,400
gerenciar nossos objetos através do felino

42514
28:14:02,400 --> 28:14:05,192
ponteiros, mas vamos obter a corrida correta

42515
28:14:05,192 --> 28:14:07,912
método chamado independentemente de qual tipo

42516
28:14:07,912 --> 28:14:10,400
do objeto que estamos chamando este método em

42517
28:14:10,400 --> 28:14:13,040
então, se chamarmos o método de execução em uma base

42518
28:14:13,040 --> 28:14:15,760
ponteiro que gerencia um objeto de cão nós vamos

42519
28:14:15,760 --> 28:14:18,000
obter o método de corrida chamado para o cão

42520
28:14:18,000 --> 28:14:20,232
Objeto isto é o que queremos dizer aqui, então

42521
28:14:20,232 --> 28:14:22,320
Temos nossas aulas aqui, vamos tomar um

42522
28:14:22,320 --> 28:14:25,440
Olhe mais de perto para a nossa classe animal que é

42523
28:14:25,440 --> 28:14:27,760
nossa classe de alto nível e vai

42524
28:14:27,760 --> 28:14:30,080
ter um método virtual chamado

42525
28:14:30,080 --> 28:14:32,640
Respirá-lo é causado porque não é

42526
28:14:32,640 --> 28:14:35,600
modificar nossa classe aqui note que nós

42527
28:14:35,600 --> 28:14:37,680
Não tenha um destruidor virtual porque

42528
28:14:37,680 --> 28:14:40,232
Eu queria manter isso simples, mas no seu

42529
28:14:40,232 --> 28:14:42,960
Objeto prático que você deve fazer seu

42530
28:14:42,960 --> 28:14:45,600
Destructores virtuais se você acontecer

42531
28:14:45,600 --> 28:14:47,680
ter uma função virtual em sua classe

42532
28:14:47,680 --> 28:14:49,832
Aqui, por exemplo, podemos até fazer isso

42533
28:14:49,832 --> 28:14:51,680
Vamos fazer isso virtual, isso não é

42534
28:14:51,680 --> 28:14:53,760
Vou nos custar qualquer coisa

42535
28:14:53,760 --> 28:14:54,552
E a

42536
28:14:54,552 --> 28:14:56,720
Esta vai ser a nossa classe superior nós

42537
28:14:56,720 --> 28:14:59,040
não pode olhar para o arquivo de implementação

42538
28:14:59,040 --> 28:15:01,192
Não vai fazer nada de especial

42539
28:15:01,192 --> 28:15:03,440
Ele está apenas indo para a frente em qualquer coisa

42540
28:15:03,440 --> 28:15:05,680
parâmetro que passamos e usamos isso para

42541
28:15:05,680 --> 28:15:07,912
inicialize nossa variável de membro, eu acho

42542
28:15:07,912 --> 28:15:10,552
Também podemos entrar e mudar o nosso

42543
28:15:10,552 --> 28:15:13,280
parâmetro para uma exibição de string para que possamos fazer

42544
28:15:13,280 --> 28:15:16,552
que hdd string view vamos entrar no cpp

42545
28:15:16,552 --> 28:15:18,640
arquivo e também mudar isso muito rápido

42546
28:15:18,640 --> 28:15:21,192
nós vamos dizer std string view aqui

42547
28:15:21,192 --> 28:15:23,440
E esta é a nossa classe animal que vamos

42548
28:15:23,440 --> 28:15:26,720
para ir em nossa classe felina, porque isso é

42549
28:15:26,720 --> 28:15:28,720
A classe de derivação

42550
28:15:28,720 --> 28:15:30,640
O felino vai herdar de

42551
28:15:30,640 --> 28:15:34,000
animal publicamente, como vemos aqui

42552
28:15:34,000 --> 28:15:35,600
nós não vamos realmente fazer nada

42553
28:15:35,600 --> 28:15:37,280
Especial vamos criar um membro

42554
28:15:37,280 --> 28:15:39,680
variável chamada estilo de pele

42555
28:15:39,680 --> 28:15:41,680
e vamos encaminhar os dados de

42556
28:15:41,680 --> 28:15:43,512
nosso construtor e usar isso para

42557
28:15:43,512 --> 28:15:46,232
inicialize coisas em nossa classe aqui

42558
28:15:46,232 --> 28:15:48,640
Os parâmetros também serão passados

42559
28:15:48,640 --> 28:15:51,680
como std string view tipos, então vamos fazer

42560
28:15:51,680 --> 28:15:54,552
que aqui e isso está no lugar, nós também

42561
28:15:54,552 --> 28:15:57,192
ter um método virtual chamado

42562
28:15:57,192 --> 28:16:00,080
correr e dentro nós estamos apenas imprimindo

42563
28:16:00,080 --> 28:16:02,320
Que tipo de objeto temos

42564
28:16:02,320 --> 28:16:05,192
E uh dar uma dica sobre o método que

42565
28:16:05,192 --> 28:16:06,960
está sendo chamado aqui, isso é o que nós

42566
28:16:06,960 --> 28:16:09,512
apenas faça aqui e nós não pretendemos

42567
28:16:09,512 --> 28:16:12,720
criar objetos felinos diretamente que é

42568
28:16:12,720 --> 28:16:15,760
Por que não estamos montando nenhuma subscrito

42569
28:16:15,760 --> 28:16:18,160
do topo, é por isso que não estamos definindo

42570
28:16:18,160 --> 28:16:20,552
para cima de qualquer específico direto

42571
28:16:20,552 --> 28:16:22,640
substitui esses métodos, mas vamos

42572
28:16:22,640 --> 28:16:24,552
fazer isso em classes downstream para

42573
28:16:24,552 --> 28:16:26,552
Exemplo de cão e gato porque isso está indo

42574
28:16:26,552 --> 28:16:28,960
Para fazer sentido lá vamos entrar no cpp

42575
28:16:28,960 --> 28:16:31,680
arquivo para felino e também mudar as coisas a

42576
28:16:31,680 --> 28:16:33,680
Um pouco vamos usar a corda std

42577
28:16:33,680 --> 28:16:35,912
Veja os parâmetros, vamos fazer isso para o

42578
28:16:35,912 --> 28:16:38,400
segundo parâmetro também e este é o nosso

42579
28:16:38,400 --> 28:16:41,192
classe de enchimento para que possamos entrar e olhar

42580
28:16:41,192 --> 28:16:43,912
em nossa classe de cães, vamos ver se podemos

42581
28:16:43,912 --> 28:16:46,480
encontrá-lo e eu não acho que nós fizemos o nosso

42582
28:16:46,480 --> 28:16:48,720
Destructor em felino um virtual, então vamos

42583
28:16:48,720 --> 28:16:51,512
fazer isso e olhar para a nossa classe delta

42584
28:16:51,512 --> 28:16:53,360
muito rápido aqui temos o nosso cão é

42585
28:16:53,360 --> 28:16:56,320
não ter nenhuma variável de membro em tudo

42586
28:16:56,320 --> 28:16:59,680
e apenas encaminhará esses dados para

42587
28:16:59,680 --> 28:17:02,872
classes upstream, mas podemos substituir o nosso

42588
28:17:02,872 --> 28:17:05,280
Respirar o método que olhemos do animal

42589
28:17:05,280 --> 28:17:08,320
classe que podemos fazer isso e vamos

42590
28:17:08,320 --> 28:17:11,120
Digamos que podemos pegar essa coisa toda e

42591
28:17:11,120 --> 28:17:13,360
nós vamos no escuro, podemos fazer isso

42592
28:17:13,360 --> 28:17:14,872
Se nós queremos que vamos colocar isso

42593
28:17:14,872 --> 28:17:16,960
método abaixo aqui e vamos

42594
28:17:16,960 --> 28:17:18,800
para dizer que vamos dizer que

42595
28:17:18,800 --> 28:17:21,832
Isso está substituindo o que temos no topo

42596
28:17:21,832 --> 28:17:23,912
E nós vamos dizer que o cão respira

42597
28:17:23,912 --> 28:17:26,400
Chamamos isso vai fazer e nós também

42598
28:17:26,400 --> 28:17:29,440
necessidade de mudar nossos parâmetros para hdd

42599
28:17:29,440 --> 28:17:32,320
visão de força vamos fazer que isso é

42600
28:17:32,320 --> 28:17:34,400
vai fazer as coisas funcionarem melhor porque

42601
28:17:34,400 --> 28:17:37,440
evitaremos cópias desnecessárias e nós

42602
28:17:37,440 --> 28:17:40,000
será capaz de passar string literals como

42603
28:17:40,000 --> 28:17:42,400
parâmetros para este construtor aqui este

42604
28:17:42,400 --> 28:17:44,800
É o que queremos alcançar conosco

42605
28:17:44,800 --> 28:17:47,832
pode bater o arquivo cpp para uma classe de cão e

42606
28:17:47,832 --> 28:17:48,960
nós vamos

42607
28:17:48,960 --> 28:17:51,680
alterar os parâmetros novamente string std

42608
28:17:51,680 --> 28:17:54,080
ver e nós vamos dizer std string

42609
28:17:54,080 --> 28:17:55,912
veja também aqui e vamos embora

42610
28:17:55,912 --> 28:17:58,000
para o arquivo de cabeçalho novamente e certifique-se

42611
28:17:58,000 --> 28:18:00,160
Temos um destruidor virtual aqui

42612
28:18:00,160 --> 28:18:02,480
porque isso é uma boa prática se você é

42613
28:18:02,480 --> 28:18:04,640
Usando funções virtuais como nós somos

42614
28:18:04,640 --> 28:18:06,800
Fazendo aqui podemos agarrar nossa respiração

42615
28:18:06,800 --> 28:18:09,832
método e saltar para a nossa classe de gato

42616
28:18:09,832 --> 28:18:12,400
Lembre-se novamente da hierarquia de herança

42617
28:18:12,400 --> 28:18:15,192
Estamos indo atrás é o que temos aqui

42618
28:18:15,192 --> 28:18:17,512
Então, se você está confuso, por favor volte

42619
28:18:17,512 --> 28:18:18,960
e olhar para isso você vai realmente

42620
28:18:18,960 --> 28:18:20,960
Entenda o que estamos fazendo aqui, estamos

42621
28:18:20,960 --> 28:18:22,720
ir para a aula de cães e fazer

42622
28:18:22,720 --> 28:18:25,192
Com certeza está funcionando como queremos, então nós apenas

42623
28:18:25,192 --> 28:18:28,160
fez a aula de cão e nós apenas nos certificamos

42624
28:18:28,160 --> 28:18:30,320
Isso funciona como nós queremos agora que vamos

42625
28:18:30,320 --> 28:18:32,872
suba para o gato e certifique-se de que é agora

42626
28:18:32,872 --> 28:18:34,720
nós vamos pular para a classe de gatos

42627
28:18:34,720 --> 28:18:37,760
e certifique-se de que está substituindo o briefing

42628
28:18:37,760 --> 28:18:40,400
método para garantir o método correto

42629
28:18:40,400 --> 28:18:42,232
É chamado de tudo bem, então vamos fazer isso nós

42630
28:18:42,232 --> 28:18:44,960
ir pular para a nossa classe de gato é

42631
28:18:44,960 --> 28:18:46,080
Indo para dentro de nós.

42632
28:18:46,080 --> 28:18:49,360
ter seu próprio método meow, mas também pode

42633
28:18:49,360 --> 28:18:52,080
substituir o método de respiração que oviamos

42634
28:18:52,080 --> 28:18:54,480
A classe animal, então vamos fazer isso nós

42635
28:18:54,480 --> 28:18:55,600
Agarr isto

42636
28:18:55,600 --> 28:18:58,480
e nós podemos ir para a nossa classe de gato vamos fazer

42637
28:18:58,480 --> 28:19:00,080
que vamos colocar em nosso virtual

42638
28:19:00,080 --> 28:19:02,320
método e vamos dizer gato

42639
28:19:02,320 --> 28:19:05,360
Respirar e isso é realmente tudo que nós também

42640
28:19:05,360 --> 28:19:08,232
Precisamos configurar nossos parâmetros corretamente

42641
28:19:08,232 --> 28:19:11,360
usando std string view vamos fazer isso std

42642
28:19:11,360 --> 28:19:14,320
visão de string e isso é realmente tudo que nós

42643
28:19:14,320 --> 28:19:16,720
Precisamos fazer aqui também podemos fazer o nosso

42644
28:19:16,720 --> 28:19:18,800
Destructor virtual porque isso é bom

42645
28:19:18,800 --> 28:19:21,600
pratique nós pulamos no arquivo cpp e

42646
28:19:21,600 --> 28:19:24,480
mudar nossos parâmetros para ser do tipo std

42647
28:19:24,480 --> 28:19:27,120
string view vamos fazer isso e isso é

42648
28:19:27,120 --> 28:19:28,872
Fizemos que realmente trabalhar com isso

42649
28:19:28,872 --> 28:19:31,040
Hierarquia de herança aqui estamos indo

42650
28:19:31,040 --> 28:19:34,160
para também ir muito rápido e trabalhar no

42651
28:19:34,160 --> 28:19:36,960
outro lado da nossa hierarquia de herança

42652
28:19:36,960 --> 28:19:39,440
nós vamos trabalhar em pássaros, vamos olhar

42653
28:19:39,440 --> 28:19:41,760
na classe de pássaros vai herdar

42654
28:19:41,760 --> 28:19:44,000
do animal não vai fazer

42655
28:19:44,000 --> 28:19:45,912
Qualquer coisa especial, mas nós só queremos

42656
28:19:45,912 --> 28:19:48,160
para alterar o tipo de nossos parâmetros para

42657
28:19:48,160 --> 28:19:50,720
std string view e eu vou fazer isso

42658
28:19:50,720 --> 28:19:53,280
no segundo parâmetro e nós vamos

42659
28:19:53,280 --> 28:19:55,512
para pular no arquivo cpp e mudar

42660
28:19:55,512 --> 28:19:57,440
Essas coisas aqui vamos fazer que nós somos

42661
28:19:57,440 --> 28:20:00,000
indo dizer std string view e fazer o

42662
28:20:00,000 --> 28:20:04,080
A mesma coisa aqui std string view e pássaro

42663
28:20:04,080 --> 28:20:06,960
É feito podemos pegar nosso método de respiração

42664
28:20:06,960 --> 28:20:09,280
Por exemplo, vamos voltar ao topo e

42665
28:20:09,280 --> 28:20:12,000
agarrar isso da nossa classe animal e

42666
28:20:12,000 --> 28:20:14,400
nós vamos pular para um tipo de

42667
28:20:14,400 --> 28:20:16,720
pássaro que temos em nosso programa podemos olhar

42668
28:20:16,720 --> 28:20:17,760
A este.

42669
28:20:17,760 --> 28:20:19,912
pombo, por exemplo, a última classe aqui

42670
28:20:19,912 --> 28:20:21,440
nós vamos substituir a respiração

42671
28:20:21,440 --> 28:20:24,080
método e eu vou dizer pombo

42672
28:20:24,080 --> 28:20:26,232
Respire e vamos mudar o

42673
28:20:26,232 --> 28:20:28,720
tipo de nossos parâmetros aqui para std

42674
28:20:28,720 --> 28:20:30,960
string view e eu vou fazer o mesmo

42675
28:20:30,960 --> 28:20:34,080
Aqui e vamos pular para o arquivo cpp

42676
28:20:34,080 --> 28:20:36,960
e mudar o tipo de nosso parâmetro

42677
28:20:36,960 --> 28:20:38,872
Vamos fazer isso pelo segundo parâmetro

42678
28:20:38,872 --> 28:20:41,680
Aqui isso é feito, vamos olhar para o

42679
28:20:41,680 --> 28:20:44,872
Segundo tipo de pássaro que temos eu acho que nós

42680
28:20:44,872 --> 28:20:48,480
ter a classe de corvos que também queremos

42681
28:20:48,480 --> 28:20:50,480
substituir o método de respiração que estamos indo

42682
28:20:50,480 --> 28:20:54,640
dizer que o corvo respira e nós podemos subir e

42683
28:20:54,640 --> 28:20:57,760
mudar nosso parâmetro para ser do tipo std

42684
28:20:57,760 --> 28:20:59,760
string view e nós vamos fazer isso

42685
28:20:59,760 --> 28:21:02,160
Aqui novamente se você não estiver interessado

42686
28:21:02,160 --> 28:21:04,640
essas mudanças você pode simplesmente pegar o código

42687
28:21:04,640 --> 28:21:06,000
E você vai ter tudo isso

42688
28:21:06,000 --> 28:21:08,400
aulas prontas para uso eu só queria

42689
28:21:08,400 --> 28:21:10,720
Corrige este pequeno problema que eu tive no meu

42690
28:21:10,720 --> 28:21:13,120
aulas na minha unidade porque isso não é

42691
28:21:13,120 --> 28:21:15,760
bom para projetar em moderno c plus plus we

42692
28:21:15,760 --> 28:21:17,760
Eu queria fazer as coisas corretamente porque nós

42693
28:21:17,760 --> 28:21:19,912
estão realmente aprendendo sobre o moderno c plus

42694
28:21:19,912 --> 28:21:22,640
Além disso, vamos pular para o arquivo cpp

42695
28:21:22,640 --> 28:21:24,640
E terminei isso, vamos mudar

42696
28:21:24,640 --> 28:21:28,080
o tipo para hdd stream view e uh vamos

42697
28:21:28,080 --> 28:21:30,640
usar a visão corretamente e nós vamos

42698
28:21:30,640 --> 28:21:32,960
Diga std string view no segundo

42699
28:21:32,960 --> 28:21:35,440
parâmetro e isso é feito agora que temos

42700
28:21:35,440 --> 28:21:37,832
nossa hierarquia de herança e nós somos

42701
28:21:37,832 --> 28:21:40,400
Vou começar olhando para o animal

42702
28:21:40,400 --> 28:21:42,960
Polimorfismo novamente nós apenas configuramos isso

42703
28:21:42,960 --> 28:21:45,440
Hierarquia de herança agora estamos indo

42704
28:21:45,440 --> 28:21:48,872
para tentar fazer polimorfismo animal bem

42705
28:21:48,872 --> 28:21:50,720
então agora vamos pular para o

42706
28:21:50,720 --> 28:21:53,512
arquivo cpp principal e vamos limpar

42707
28:21:53,512 --> 28:21:55,680
ele para cima um pouco remover o que quer que seja

42708
28:21:55,680 --> 28:21:58,720
nós não precisamos que vamos colocar em nosso

42709
28:21:58,720 --> 28:22:00,720
inclui que vamos incluir todos os

42710
28:22:00,720 --> 28:22:04,080
os fãs em nosso arquivo aqui animal felino

42711
28:22:04,080 --> 28:22:06,480
cão gato pássaro pombo e corvo vamos

42712
28:22:06,480 --> 28:22:09,440
para incluir tudo isso e nós só queremos

42713
28:22:09,440 --> 28:22:12,480
brincar com o polimorfismo animal aqui nós

42714
28:22:12,480 --> 28:22:14,480
Vamos montar um monte de objetos

42715
28:22:14,480 --> 28:22:17,040
e nós vamos colocar em cão gato pombo

42716
28:22:17,040 --> 28:22:19,832
e corar todos os tipos de animais loucos nós

42717
28:22:19,832 --> 28:22:21,912
pode criar em nosso programa c plus plus

42718
28:22:21,912 --> 28:22:24,480
e nós vamos colocá-los em uma matriz

42719
28:22:24,480 --> 28:22:27,280
que está armazenando ponteiro animal e isso

42720
28:22:27,280 --> 28:22:29,680
O ponteiro animal vai

42721
28:22:29,680 --> 28:22:32,800
permitir o polimorfismo para nossos objetos que

42722
28:22:32,800 --> 28:22:35,912
nós temos aqui lembrar animais

42723
28:22:35,912 --> 28:22:38,232
um método virtual chamado draw se formos

42724
28:22:38,232 --> 28:22:40,552
Volta, vamos descobrir isso e nós

42725
28:22:40,552 --> 28:22:43,040
Certifique-se de substituir este método em tudo

42726
28:22:43,040 --> 28:22:45,600
tipos de animais loucos que podemos criar para

42727
28:22:45,600 --> 28:22:47,832
Exemplo em nosso gato temos uma respiração

42728
28:22:47,832 --> 28:22:50,960
método substituído em nossa classe de cães nós

42729
28:22:50,960 --> 28:22:53,192
ter o método da respiração substituído e

42730
28:22:53,192 --> 28:22:56,160
o que queremos alcançar em nosso cpp principal

42731
28:22:56,160 --> 28:22:59,680
arquivo vamos lá se eu puder encontrá-lo nós

42732
28:22:59,680 --> 28:23:02,552
Queremos uma configuração para que, se

42733
28:23:02,552 --> 28:23:04,000
chamar o método de respiração que estamos indo para

42734
28:23:04,000 --> 28:23:06,872
chamar o método de respiração mais específico em

42735
28:23:06,872 --> 28:23:09,280
nosso ponteiro de animais aqui, mesmo que sejamos

42736
28:23:09,280 --> 28:23:11,600
chamando esse método em um ponteiro base

42737
28:23:11,600 --> 28:23:13,760
Isso é o que queremos alcançar isso é

42738
28:23:13,760 --> 28:23:16,160
vai ser polimorfismo animal porque

42739
28:23:16,160 --> 28:23:19,280
o ponteiro base é de tipo animal este

42740
28:23:19,280 --> 28:23:21,680
é o que queremos dizer aqui vamos tentar construir

42741
28:23:21,680 --> 28:23:23,912
Este programa, portanto, se olharmos e chamarmos o

42742
28:23:23,912 --> 28:23:25,512
Respirar método a respiração correta

42743
28:23:25,512 --> 28:23:27,680
O método será chamado e o que nós

42744
28:23:27,680 --> 28:23:29,832
esperar para o primeiro objeto que é

42745
28:23:29,832 --> 28:23:31,912
Objeto escuro vamos ficar escuros

42746
28:23:31,912 --> 28:23:34,160
Método da respiração chamado para o segundo

42747
28:23:34,160 --> 28:23:36,000
iteração o método de respiração de categoria é

42748
28:23:36,000 --> 28:23:38,640
Vai ser chamado para o terceiro

42749
28:23:38,640 --> 28:23:41,440
para a terceira iteração o pombo

42750
28:23:41,440 --> 28:23:43,360
O método da respiração será chamado para

42751
28:23:43,360 --> 28:23:45,512
A última iteração do

42752
28:23:45,512 --> 28:23:47,360
O método da respiração de corvo vai ser

42753
28:23:47,360 --> 28:23:49,680
Chamamos isso é o que esperamos ver

42754
28:23:49,680 --> 28:23:52,000
Se executarmos este programa aqui, então vamos fazer

42755
28:23:52,000 --> 28:23:53,832
Isso nós vamos passar por isso

42756
28:23:53,832 --> 28:23:57,192
gcc nosso compilador favorito podemos usar qualquer

42757
28:23:57,192 --> 28:23:59,912
Compilador que queremos, mas gcc vai fazer

42758
28:23:59,912 --> 28:24:02,080
Neste caso, ok, a construção é boa

42759
28:24:02,080 --> 28:24:04,480
pode trazer uma janela powershell para jogar

42760
28:24:04,480 --> 28:24:06,872
com e nós vamos correr o galo nosso

42761
28:24:06,872 --> 28:24:09,040
programa e se nós executarmos isso você está indo

42762
28:24:09,040 --> 28:24:11,760
para ver isso em nosso loop o primeiro

42763
28:24:11,760 --> 28:24:13,912
A iteração vai chamar o cão de respirar

42764
28:24:13,912 --> 28:24:16,080
Porque o primeiro objeto é um cão

42765
28:24:16,080 --> 28:24:18,080
A segunda iteração vai chamar o gato

42766
28:24:18,080 --> 28:24:19,912
Respire porque o segundo objeto é um

42767
28:24:19,912 --> 28:24:20,720
gato

42768
28:24:20,720 --> 28:24:22,400
A terceira iteração vai chamar

42769
28:24:22,400 --> 28:24:24,640
O pombo respira porque o terceiro objeto

42770
28:24:24,640 --> 28:24:26,800
É um pombo e a última iteração é

42771
28:24:26,800 --> 28:24:29,120
vai chamar o corvo respirar porque o

42772
28:24:29,120 --> 28:24:31,912
O último objeto é um corvo e percebe que nós

42773
28:24:31,912 --> 28:24:34,080
estão chamando o método da respiração através de um

42774
28:24:34,080 --> 28:24:36,680
ponteiro de animal base e é isso que

42775
28:24:36,680 --> 28:24:39,192
O polimorfismo é tudo sobre o que nós

42776
28:24:39,192 --> 28:24:41,680
Está fazendo aqui é polimorfismo animal

42777
28:24:41,680 --> 28:24:44,232
Mas isso não é o que realmente procuramos

42778
28:24:44,232 --> 28:24:46,552
Nesta palestra queremos ver que

42779
28:24:46,552 --> 28:24:48,080
Também pode fazer

42780
28:24:48,080 --> 28:24:50,400
felino e

42781
28:24:50,400 --> 28:24:52,960
Polimorfismo de aves em nossa herança

42782
28:24:52,960 --> 28:24:55,040
hierarquia, então vamos colocar em um

42783
28:24:55,040 --> 28:24:58,320
separador vamos fazer esddc para fora e colocar em um

42784
28:24:58,320 --> 28:25:00,872
monte de traços aqui ou hífens alguns

42785
28:25:00,872 --> 28:25:02,800
As pessoas os chamam assim não

42786
28:25:02,800 --> 28:25:05,280
Realmente importa e nós vamos jogar

42787
28:25:05,280 --> 28:25:08,160
com polimorfismo felino vamos fazer isso

42788
28:25:08,160 --> 28:25:10,480
vamos descer e colocar em um

42789
28:25:10,480 --> 28:25:12,552
simples pedaço de casaco que vamos

42790
28:25:12,552 --> 28:25:15,120
Use para brincar com as coisas aqui e

42791
28:25:15,120 --> 28:25:16,720
Vamos criar um monte de objetos

42792
28:25:16,720 --> 28:25:18,872
Temos um cão, temos um gato, temos um

42793
28:25:18,872 --> 28:25:22,400
pombo e nós vamos usar um felino

42794
28:25:22,400 --> 28:25:26,160
ponteiro para gerenciar objetos derivados de felinos

42795
28:25:26,160 --> 28:25:27,760
Por exemplo, vamos usar isso

42796
28:25:27,760 --> 28:25:30,000
ponteiro para gerenciar um cão e um gato, mas

42797
28:25:30,000 --> 28:25:31,760
Uma coisa que eu quero que você veja é que se

42798
28:25:31,760 --> 28:25:34,000
você coloca um pombo, por exemplo, isso é

42799
28:25:34,000 --> 28:25:36,720
não vai trabalhar porque um pombo é

42800
28:25:36,720 --> 28:25:39,120
não um felino, então o compilador vai

42801
28:25:39,120 --> 28:25:41,120
dar-lhe um erro de compilador, vamos tentar

42802
28:25:41,120 --> 28:25:43,192
para que vamos tentar colocar

42803
28:25:43,192 --> 28:25:46,160
pombos aqui pombo 2 você pode selecionar este

42804
28:25:46,160 --> 28:25:47,832
E se fizermos isso, você vai ver

42805
28:25:47,832 --> 28:25:50,232
que nós temos uma linha escorrendo este é o

42806
28:25:50,232 --> 28:25:51,912
Sinal que isso vai dar errado

42807
28:25:51,912 --> 28:25:53,120
porque

42808
28:25:53,120 --> 28:25:55,680
estamos armazenando em felinos e no pombo

42809
28:25:55,680 --> 28:25:58,960
Realmente não é um felino, mesmo pelo nosso

42810
28:25:58,960 --> 28:26:01,280
hierarquia de herança para que o compilador seja

42811
28:26:01,280 --> 28:26:02,872
vamos nos dar um erro de compilador, vamos

42812
28:26:02,872 --> 28:26:04,960
tentar e soldar para mostrar o compilador

42813
28:26:04,960 --> 28:26:07,440
Erro OK o mundo terminou com

42814
28:26:07,440 --> 28:26:09,192
erros e se vamos e vamos

42815
28:26:09,192 --> 28:26:12,480
descobrir que não pode converter pombo para alimentar

42816
28:26:12,480 --> 28:26:14,800
ponteiro de linha, então este é o erro aqui

42817
28:26:14,800 --> 28:26:16,872
você não pode fazer algo assim, mesmo se

42818
28:26:16,872 --> 28:26:19,040
Você cria um objeto animal, digamos

42819
28:26:19,040 --> 28:26:21,600
que vamos entrar e criar

42820
28:26:21,600 --> 28:26:23,912
animal e nós vamos dizer animal um

42821
28:26:23,912 --> 28:26:25,760
Podemos fazer isso e vamos passar

42822
28:26:25,760 --> 28:26:27,680
Na descrição eu acho que podemos fazer

42823
28:26:27,680 --> 28:26:30,000
que nós podemos fazer algo assim e

42824
28:26:30,000 --> 28:26:32,232
se tentarmos passar no endereço de

42825
28:26:32,232 --> 28:26:34,552
um animal vamos fazer que isso também é

42826
28:26:34,552 --> 28:26:36,872
vamos nos dar um erro de compilador

42827
28:26:36,872 --> 28:26:40,400
porque o animal não é um felino novamente se

42828
28:26:40,400 --> 28:26:42,720
Você fica confuso voltar e olhar

42829
28:26:42,720 --> 28:26:45,280
nossa hierarquia de herança aqui

42830
28:26:45,280 --> 28:26:47,512
O que estamos preparando em nosso código

42831
28:26:47,512 --> 28:26:50,640
estamos usando o polimorfismo felino, mas nós

42832
28:26:50,640 --> 28:26:53,680
Quero armazenar um animal em um ataque que

42833
28:26:53,680 --> 28:26:56,480
está armazenando felinos e isso vai

42834
28:26:56,480 --> 28:26:59,040
ser um problema porque o compilador não é

42835
28:26:59,040 --> 28:27:01,280
Realmente será capaz de processar isso

42836
28:27:01,280 --> 28:27:03,440
nosso ponteiro base é um felino e nós

42837
28:27:03,440 --> 28:27:06,000
Deve realmente ser capaz de apenas armazenar em

42838
28:27:06,000 --> 28:27:09,040
tipos derivados do felino, mas nós somos

42839
28:27:09,040 --> 28:27:11,680
Colocar uma superclasse ou um pai

42840
28:27:11,680 --> 28:27:13,280
A classe do felino

42841
28:27:13,280 --> 28:27:16,680
que não será capaz de ter estes

42842
28:27:16,680 --> 28:27:19,040
Especializações que felino está fazendo isso

42843
28:27:19,040 --> 28:27:20,800
O compilador está realmente dizendo que isso é

42844
28:27:20,800 --> 28:27:22,872
louco eu não posso fazer isso eu vou

42845
28:27:22,872 --> 28:27:24,800
lançar um erro de compilador este é o

42846
28:27:24,800 --> 28:27:26,872
Comportamento que chegamos aqui bem, então isso é

42847
28:27:26,872 --> 28:27:28,552
vamos nos dar um erro de compilador e

42848
28:27:28,552 --> 28:27:30,320
Vamos correr e ver que nós vamos

42849
28:27:30,320 --> 28:27:32,872
use gcc o livro vai terminar com

42850
28:27:32,872 --> 28:27:34,960
um erro e vamos ver que nós

42851
28:27:34,960 --> 28:27:37,440
ter uma conversão inválida do animal

42852
28:27:37,440 --> 28:27:39,600
ponteiro para o ponteiro de filamento, isso é o que

42853
28:27:39,600 --> 28:27:41,600
Queremos fazer aqui queremos converter um

42854
28:27:41,600 --> 28:27:45,440
ponteiro de animais e armazene isso em um slot

42855
28:27:45,440 --> 28:27:48,400
que só é suposto armazenar felinos

42856
28:27:48,400 --> 28:27:50,640
apontadores para que isso não funcione

42857
28:27:50,640 --> 28:27:52,960
mas se você fizer tudo certo e apenas

42858
28:27:52,960 --> 28:27:54,160
colocar em in

42859
28:27:54,160 --> 28:27:56,320
Tipos derivados de felinos que você vai

42860
28:27:56,320 --> 28:27:59,120
obter o comprimento correto para trabalhar e vamos

42861
28:27:59,120 --> 28:28:02,080
Olhe para a nossa aula de cães, vamos abri-la

42862
28:28:02,080 --> 28:28:04,400
Mais uma vez vamos olhar para o cão e

42863
28:28:04,400 --> 28:28:07,512
nós vamos ter um método de execução, mas nós

42864
28:28:07,512 --> 28:28:10,400
Não tenho essa configuração para a nossa aula de cães

42865
28:28:10,400 --> 28:28:12,160
Mas nós podemos fazer isso muito rápido, vamos

42866
28:28:12,160 --> 28:28:14,080
Olhe para o gato e veja se temos uma corrida

42867
28:28:14,080 --> 28:28:16,872
método que não fazemos, mas podemos configurar isso

42868
28:28:16,872 --> 28:28:19,600
Vamos ao felino e copiar o nosso virtual

42869
28:28:19,600 --> 28:28:21,760
Função que podemos fazer isso

42870
28:28:21,760 --> 28:28:24,320
e nós vamos entrar em cão

42871
28:28:24,320 --> 28:28:26,480
e configurar outro método virtual que

42872
28:28:26,480 --> 28:28:28,160
- Vai ser

42873
28:28:28,160 --> 28:28:30,800
correr e isso vai ser uma substituição

42874
28:28:30,800 --> 28:28:33,280
do que temos em nossa herança

42875
28:28:33,280 --> 28:28:35,600
hierarquia, portanto, este é um método de substituição

42876
28:28:35,600 --> 28:28:38,080
Também vamos fazer o mesmo, mas

42877
28:28:38,080 --> 28:28:40,320
antes de ir, vamos dizer que este é o

42878
28:28:40,320 --> 28:28:42,800
classe de cães que estamos fazendo graças de

42879
28:28:42,800 --> 28:28:44,960
Vamos pegar esse método novamente

42880
28:28:44,960 --> 28:28:46,960
e ir para o gato porque isso é outro

42881
28:28:46,960 --> 28:28:49,440
felino que temos em nosso programa que podemos fazer

42882
28:28:49,440 --> 28:28:51,192
Algo assim e nós vamos

42883
28:28:51,192 --> 28:28:53,040
Diga gato aqui

42884
28:28:53,040 --> 28:28:56,080
Tudo bem, então agora vamos voltar ao maine

42885
28:28:56,080 --> 28:28:58,160
E nós vamos soldar novamente nós somos

42886
28:28:58,160 --> 28:29:00,640
indo para passar isso através de gcc e nós

42887
28:29:00,640 --> 28:29:03,280
Ainda tenho um pombo aqui, então este é

42888
28:29:03,280 --> 28:29:05,440
Não é bom, vamos verificar isso

42889
28:29:05,440 --> 28:29:07,832
Certifique-se de que temos apenas algumas linhas

42890
28:29:07,832 --> 28:29:10,552
neste array aqui vamos construir novamente

42891
28:29:10,552 --> 28:29:12,480
Ok, você vê que o parafuso é bom

42892
28:29:12,480 --> 28:29:14,232
nós podemos limpar

42893
28:29:14,232 --> 28:29:16,080
e correr galo vamos ter o nosso

42894
28:29:16,080 --> 28:29:18,160
Separador aqui e você vai ver

42895
28:29:18,160 --> 28:29:20,872
que estamos chamando o nosso método de cão em

42896
28:29:20,872 --> 28:29:22,640
A primeira iteração porque a primeira

42897
28:29:22,640 --> 28:29:26,000
O objeto é um cão e nós estamos chamando um gato

42898
28:29:26,000 --> 28:29:28,640
método de execução porque segundo objeto

42899
28:29:28,640 --> 28:29:32,080
é um gato e isso é polimorfismo de arquivo

42900
28:29:32,080 --> 28:29:34,320
em ação espero que isso prove para você

42901
28:29:34,320 --> 28:29:37,280
que podemos fazer polimorfismo em diferentes

42902
28:29:37,280 --> 28:29:39,600
níveis dependendo do que queremos

42903
28:29:39,600 --> 28:29:42,480
alcançar em nosso programa c plus plus para

42904
28:29:42,480 --> 28:29:44,400
Feia fora desta palestra que também estamos indo

42905
28:29:44,400 --> 28:29:47,120
para configurar o polimorfismo de aves vamos fazer

42906
28:29:47,120 --> 28:29:49,120
que vamos colocar em um separador

42907
28:29:49,120 --> 28:29:51,680
e nós vamos dizer demod vertical

42908
28:29:51,680 --> 28:29:53,912
presente e vamos colocar em um

42909
28:29:53,912 --> 28:29:56,552
Um monte de objetos e configurar uma base

42910
28:29:56,552 --> 28:29:57,600
O ponteiro

42911
28:29:57,600 --> 28:29:59,512
array que vai ser um pássaro

42912
28:29:59,512 --> 28:30:01,192
referência neste caso e nós somos

42913
28:30:01,192 --> 28:30:03,832
vai armazenar em objetos derivados

42914
28:30:03,832 --> 28:30:06,720
do tipo ponteiro base, então estamos indo

42915
28:30:06,720 --> 28:30:08,800
para armazenar quaisquer objetos derivados de

42916
28:30:08,800 --> 28:30:11,360
pássaro e nós temos um pombo e um corvo e

42917
28:30:11,360 --> 28:30:13,680
Esta é a configuração que queremos aqui agora, vamos

42918
28:30:13,680 --> 28:30:17,040
ir e olhar para a configuração que temos em nosso

42919
28:30:17,040 --> 28:30:19,280
pombo, por exemplo, não temos uma mosca

42920
28:30:19,280 --> 28:30:21,280
método, temos apenas um método legal

42921
28:30:21,280 --> 28:30:23,280
Porque o pombo coos

42922
28:30:23,280 --> 28:30:26,000
Se entrarmos em nosso corvo, vamos ver

42923
28:30:26,000 --> 28:30:27,912
que nós não temos

42924
28:30:27,912 --> 28:30:30,320
método da mosca nós estamos apenas tendo a vaca

42925
28:30:30,320 --> 28:30:32,720
método porque a multidão chama

42926
28:30:32,720 --> 28:30:36,400
mas se chamarmos o nosso método de voo porque nós

42927
28:30:36,400 --> 28:30:38,800
Não tem este método substituído em qualquer

42928
28:30:38,800 --> 28:30:41,192
classes a jusante de pássaro

42929
28:30:41,192 --> 28:30:42,800
nós vamos conseguir o

42930
28:30:42,800 --> 28:30:43,760
base

42931
28:30:43,760 --> 28:30:46,000
versão do método fly chamado assim nós

42932
28:30:46,000 --> 28:30:48,080
vai ter este método aqui

42933
28:30:48,080 --> 28:30:50,552
Eu quero que você veja isso vamos pular

42934
28:30:50,552 --> 28:30:52,800
mais para o arquivo cpp principal e certifique-se

42935
28:30:52,800 --> 28:30:54,872
nós temos a configuração correta como

42936
28:30:54,872 --> 28:30:56,552
Isto é o que queremos que vamos

42937
28:30:56,552 --> 28:30:59,040
construir isso com gcc o livro vai

42938
28:30:59,040 --> 28:31:01,832
ser bom como vemos aqui e vamos

42939
28:31:01,832 --> 28:31:04,640
para correr agora nós vamos ver ave voar

42940
28:31:04,640 --> 28:31:07,680
pássaro voar para pombo um e corvo um

42941
28:31:07,680 --> 28:31:11,440
mas isso não está usando nenhum método derivado

42942
28:31:11,440 --> 28:31:14,320
que temos em nosso corvo

42943
28:31:14,320 --> 28:31:16,400
e uma classe de pombos, se você quiser, você pode

42944
28:31:16,400 --> 28:31:18,400
Além disso, sobrepor o

42945
28:31:18,400 --> 28:31:20,232
método de voar e você vai conseguir isso

42946
28:31:20,232 --> 28:31:22,872
chamado vamos realmente fazer isso porque

42947
28:31:22,872 --> 28:31:25,192
Eu gostaria de mostrar as coisas diretamente assim

42948
28:31:25,192 --> 28:31:26,872
que você pode realmente ver com o seu próprio

42949
28:31:26,872 --> 28:31:29,360
olhos para que vamos entrar no pássaro e

42950
28:31:29,360 --> 28:31:31,512
Pegue o método da mosca e nós vamos

42951
28:31:31,512 --> 28:31:34,552
substituir isso em pombo, podemos fazer isso

42952
28:31:34,552 --> 28:31:37,760
e nós vamos substituir aqui e nós

42953
28:31:37,760 --> 28:31:40,720
Vamos dizer pombo aqui e nós podemos

42954
28:31:40,720 --> 28:31:43,760
agarrar isso e eu coloco este método também em

42955
28:31:43,760 --> 28:31:46,960
A classe da multidão pode fazer isso e nós somos

42956
28:31:46,960 --> 28:31:49,760
Vou dizer corvo aqui agora se corrermos

42957
28:31:49,760 --> 28:31:51,192
este programa

42958
28:31:51,192 --> 28:31:53,680
usando o que temos no arquivo cpp principal

42959
28:31:53,680 --> 28:31:55,192
para a primeira iteração que vamos

42960
28:31:55,192 --> 28:31:57,680
chamar o método da mosca no objeto pombo

42961
28:31:57,680 --> 28:31:59,512
Porque temos o método da mosca

42962
28:31:59,512 --> 28:32:02,080
sobrescrito no nível do pombo

42963
28:32:02,080 --> 28:32:03,832
como vemos aqui, isso está aqui

42964
28:32:03,832 --> 28:32:05,512
sob nossos olhos e vamos ver

42965
28:32:05,512 --> 28:32:08,080
isso em ação se executarmos este programa

42966
28:32:08,080 --> 28:32:10,000
Aqui o mesmo vai acontecer para o

42967
28:32:10,000 --> 28:32:13,440
objeto de corvo aqui vamos construir com gcc para

42968
28:32:13,440 --> 28:32:15,120
realmente provar isso que o construtor está indo

42969
28:32:15,120 --> 28:32:17,192
para passar por nós podemos limpar e correr

42970
28:32:17,192 --> 28:32:18,872
Galo e vamos ver o pombo

42971
28:32:18,872 --> 28:32:21,760
A multidão voadora voa, isso está provando o que nós

42972
28:32:21,760 --> 28:32:23,832
criado nesta palestra aqui este é

42973
28:32:23,832 --> 28:32:25,760
Realmente tudo que eu tinha para compartilhar eu espero que você

42974
28:32:25,760 --> 28:32:27,760
Achei isso interessante a mensagem principal

42975
28:32:27,760 --> 28:32:30,640
é que você pode configurar o polimorfismo em

42976
28:32:30,640 --> 28:32:32,872
Diferentes níveis em sua herança

42977
28:32:32,872 --> 28:32:35,192
Hierarquia dependendo do que você quer

42978
28:32:35,192 --> 28:32:37,512
alcançar em seu c plus programa

42979
28:32:37,512 --> 28:32:39,680
Viu que poderíamos fazer a coisa normal e

42980
28:32:39,680 --> 28:32:41,600
Use a classe de nível superior

42981
28:32:41,600 --> 28:32:44,320
como o motor do nosso polimorfismo e

42982
28:32:44,320 --> 28:32:47,040
Fizemos o polimorfismo animal aqui, mas

42983
28:32:47,040 --> 28:32:49,440
Nada impede que você faça felino

42984
28:32:49,440 --> 28:32:52,872
Polimorfismo ou polimorfismo de aves como nós

42985
28:32:52,872 --> 28:32:55,192
visto nesta palestra vamos parar

42986
28:32:55,192 --> 28:32:56,720
Aqui neste no próximo estamos

42987
28:32:56,720 --> 28:32:59,280
Vamos ver como podemos fazer o polimorfismo

42988
28:32:59,280 --> 28:33:01,120
com os membros estáticos

42989
28:33:01,120 --> 28:33:03,280
Vá em frente e termine aqui e me faça

42990
28:33:03,280 --> 28:33:05,120
lá nesta palestra vamos

42991
28:33:05,120 --> 28:33:08,960
explorar como herança e polimorfismo

42992
28:33:08,960 --> 28:33:11,680
brincar com os membros estáticos que nós

42993
28:33:11,680 --> 28:33:14,640
Temos em nossas aulas e nós vamos

42994
28:33:14,640 --> 28:33:17,120
usar essa hierarquia de herança aqui

42995
28:33:17,120 --> 28:33:18,640
nossa classe base vai ser forma

42996
28:33:18,640 --> 28:33:21,040
Vamos herdar disso e

42997
28:33:21,040 --> 28:33:23,912
criar uma classe de elipse, vamos olhar para

42998
28:33:23,912 --> 28:33:25,760
algum código aqui, então vamos configurar

42999
28:33:25,760 --> 28:33:28,720
nossa classe base como forma como dissemos e

43000
28:33:28,720 --> 28:33:31,120
nós vamos ter uma variável de membro

43001
28:33:31,120 --> 28:33:33,040
que vai ser a nossa descrição

43002
28:33:33,040 --> 28:33:35,192
Aqui vamos ter um construtor

43003
28:33:35,192 --> 28:33:36,800
e um destructor

43004
28:33:36,800 --> 28:33:37,912
e nós vamos ter um padrão

43005
28:33:37,912 --> 28:33:39,192
Construtor que realmente não é

43006
28:33:39,192 --> 28:33:41,912
importante aqui, mas note que temos um

43007
28:33:41,912 --> 28:33:45,192
membro estático chamado m count

43008
28:33:45,192 --> 28:33:47,192
e se você se lembrar de um membro estático

43009
28:33:47,192 --> 28:33:48,320
a variável

43010
28:33:48,320 --> 28:33:50,552
é um tipo de variável que é

43011
28:33:50,552 --> 28:33:53,760
associado ao tipo em si não é

43012
28:33:53,760 --> 28:33:56,080
associados a qualquer objeto que você

43013
28:33:56,080 --> 28:33:58,640
criar se você esqueceu isso, por favor volte

43014
28:33:58,640 --> 28:34:01,120
para o nosso capítulo sobre classes ou usuário

43015
28:34:01,120 --> 28:34:03,192
Tipos definidos que você vai aprender tudo

43016
28:34:03,192 --> 28:34:05,912
sobre as variáveis estáticas aqui estamos apenas

43017
28:34:05,912 --> 28:34:08,160
explorando como eles se desenrolam com

43018
28:34:08,160 --> 28:34:11,280
herança e polimorfismo agora que temos

43019
28:34:11,280 --> 28:34:13,760
uma classe de forma se herdarmos dela e

43020
28:34:13,760 --> 28:34:16,160
criar uma classe de elipse, por exemplo

43021
28:34:16,160 --> 28:34:18,640
nós vamos ter todos os dados que

43022
28:34:18,640 --> 28:34:21,440
era público em nossa classe base para ser

43023
28:34:21,440 --> 28:34:23,680
público nesta classe também por isso

43024
28:34:23,680 --> 28:34:25,760
lógica, também vamos conseguir isso

43025
28:34:25,760 --> 28:34:27,832
variável estática herdada e nós somos

43026
28:34:27,832 --> 28:34:30,160
será capaz de acessá-lo a partir de

43027
28:34:30,160 --> 28:34:32,872
objetos ellipse vamos tentar usar isso

43028
28:34:32,872 --> 28:34:34,872
em código aqui para realmente conduzir o ponto

43029
28:34:34,872 --> 28:34:37,120
Aqui estamos criando um lote de

43030
28:34:37,120 --> 28:34:39,912
objetos de forma aqui é a nossa primeira forma

43031
28:34:39,912 --> 28:34:42,080
imprimir a nossa variável estática através deste

43032
28:34:42,080 --> 28:34:44,080
sintaxe aqui porque é público que podemos

43033
28:34:44,080 --> 28:34:46,160
fazer isso, vamos conseguir um porque

43034
28:34:46,160 --> 28:34:48,872
Só temos uma forma aqui que criamos um

43035
28:34:48,872 --> 28:34:50,640
segunda forma e nós imprimimos a contagem

43036
28:34:50,640 --> 28:34:52,552
nós vamos ter dois porque nós apenas

43037
28:34:52,552 --> 28:34:55,192
Temos duas formas aqui que criamos o nosso

43038
28:34:55,192 --> 28:34:57,360
terceira forma e nós tentamos imprimir o

43039
28:34:57,360 --> 28:34:59,120
que vamos ter três e se

43040
28:34:59,120 --> 28:35:01,600
Você se pergunta como estamos aumentando isso

43041
28:35:01,600 --> 28:35:04,000
variável estática podemos fazer isso em nosso

43042
28:35:04,000 --> 28:35:05,600
construtor, vamos ver como isso

43043
28:35:05,600 --> 28:35:07,760
funciona exatamente quando chegamos ao estúdio visual

43044
28:35:07,760 --> 28:35:09,760
código em um minuto, mas note que cada

43045
28:35:09,760 --> 28:35:11,360
Tempo em que criamos um objeto para o qual vamos

43046
28:35:11,360 --> 28:35:13,680
incremente nossa variável estática

43047
28:35:13,680 --> 28:35:16,232
É por isso que vemos um dois três como nós

43048
28:35:16,232 --> 28:35:18,640
Criou estes objetos aqui este é o

43049
28:35:18,640 --> 28:35:21,192
Lógica agora temos três formas aqui

43050
28:35:21,192 --> 28:35:23,832
descer e criar um novo objeto que é

43051
28:35:23,832 --> 28:35:26,400
do tipo de elipse se imprimimos a forma

43052
28:35:26,400 --> 28:35:28,400
conte que vamos ter quatro porque um

43053
28:35:28,400 --> 28:35:31,040
a elipse é uma forma e a elipse é

43054
28:35:31,040 --> 28:35:33,600
Herdar a variável estática de

43055
28:35:33,600 --> 28:35:35,912
forma, então vamos ter um 4 impresso

43056
28:35:35,912 --> 28:35:39,120
Aqui fora, mas se imprimirmos também ellipse

43057
28:35:39,120 --> 28:35:41,192
Contar que vamos ter um 4

43058
28:35:41,192 --> 28:35:44,232
Mesmo que tenhamos apenas uma elipse

43059
28:35:44,232 --> 28:35:46,960
assim, a variável estática da forma é

43060
28:35:46,960 --> 28:35:49,512
sendo herdado e usado em nossa elipse

43061
28:35:49,512 --> 28:35:52,080
classe e isso pode não ser

43062
28:35:52,080 --> 28:35:53,760
O que nós queremos assim

43063
28:35:53,760 --> 28:35:55,680
O problema aqui é que a estática

43064
28:35:55,680 --> 28:35:57,760
variável estamos usando em forma e

43065
28:35:57,760 --> 28:36:00,160
A elipse é a mesma porque aquela que

43066
28:36:00,160 --> 28:36:03,120
ter na elipse foi herdado da forma

43067
28:36:03,120 --> 28:36:05,280
É por isso que temos esses resultados aqui

43068
28:36:05,280 --> 28:36:08,160
Mas às vezes nós só queremos ter

43069
28:36:08,160 --> 28:36:11,280
elipse contagem para b1 aqui porque em

43070
28:36:11,280 --> 28:36:13,600
Realidade nós realmente temos uma elipse assim

43071
28:36:13,600 --> 28:36:16,160
Como fazer isso para obter esse comportamento

43072
28:36:16,160 --> 28:36:18,160
Você também pode configurar outra estática

43073
28:36:18,160 --> 28:36:20,960
variável chamada exatamente da mesma maneira em

43074
28:36:20,960 --> 28:36:23,280
o nível da elipse e você pode fazer isso

43075
28:36:23,280 --> 28:36:25,600
Como este você também pode substituir o portão

43076
28:36:25,600 --> 28:36:28,000
método de contagem para retornar a contagem atual

43077
28:36:28,000 --> 28:36:30,400
na elipse isso vai funcionar

43078
28:36:30,400 --> 28:36:32,800
Polimorfismo porque é o método getcount

43079
28:36:32,800 --> 28:36:34,552
É uma função virtual

43080
28:36:34,552 --> 28:36:36,552
se você chamar este método através de um

43081
28:36:36,552 --> 28:36:38,800
basepointer você obterá o correto

43082
28:36:38,800 --> 28:36:40,800
chamado que vai ser o mais

43083
28:36:40,800 --> 28:36:43,512
específico através do polimorfismo, mas

43084
28:36:43,512 --> 28:36:45,600
O que queremos ver é como

43085
28:36:45,600 --> 28:36:47,360
As coisas vão funcionar agora que nós

43086
28:36:47,360 --> 28:36:50,080
ter uma variável estática chamada

43087
28:36:50,080 --> 28:36:53,280
exatamente o mesmo que temos em

43088
28:36:53,280 --> 28:36:56,080
nossa classe base aqui a forma é

43089
28:36:56,080 --> 28:36:58,720
exatamente chamado m count é uma estática

43090
28:36:58,720 --> 28:37:01,680
variável de tipo e o que temos em

43091
28:37:01,680 --> 28:37:04,232
A elipse também é a mesma que é uma estática

43092
28:37:04,232 --> 28:37:07,512
variável chamada contagem de m do tipo e mas

43093
28:37:07,512 --> 28:37:08,480
E agora

43094
28:37:08,480 --> 28:37:10,232
A elipse vai manter a sua própria

43095
28:37:10,232 --> 28:37:12,640
variável e forma estática está indo para

43096
28:37:12,640 --> 28:37:15,360
manter sua própria variável estática agora que nós

43097
28:37:15,360 --> 28:37:17,680
Vai ter esse tipo de comportamento

43098
28:37:17,680 --> 28:37:20,160
nós vamos ver isso se tentarmos e

43099
28:37:20,160 --> 28:37:22,400
imprimir a contagem de formas que temos nós somos

43100
28:37:22,400 --> 28:37:24,960
vou ter um quatro aqui, mas agora, se nós

43101
28:37:24,960 --> 28:37:27,040
Tente imprimir a contagem de elipse

43102
28:37:27,040 --> 28:37:28,552
nós vamos ter um porque nós

43103
28:37:28,552 --> 28:37:31,512
já tem uma elipse e isso é

43104
28:37:31,512 --> 28:37:33,440
trabalhando porque a elipse vai

43105
28:37:33,440 --> 28:37:35,360
manter a sua própria

43106
28:37:35,360 --> 28:37:37,040
variável estática e isso vai

43107
28:37:37,040 --> 28:37:39,600
dar-lhe este comportamento se é o que nós

43108
28:37:39,600 --> 28:37:42,320
estão atrás em nosso c plus programa agora

43109
28:37:42,320 --> 28:37:44,552
Também podemos continuar e criar um monte de

43110
28:37:44,552 --> 28:37:46,720
Outros objetos aqui vamos armazenar

43111
28:37:46,720 --> 28:37:48,720
Neste array que será

43112
28:37:48,720 --> 28:37:51,912
Armazenar ponteiros compartilhados para moldar

43113
28:37:51,912 --> 28:37:53,680
e nós vamos armazenar em

43114
28:37:53,680 --> 28:37:55,760
objetos esta é a sintaxe que podemos usar para

43115
28:37:55,760 --> 28:37:58,080
fazer isso e no momento fazemos isso

43116
28:37:58,080 --> 28:38:01,192
Nós vamos ter seis formas porque

43117
28:38:01,192 --> 28:38:03,912
no total já temos seis formas, mas

43118
28:38:03,912 --> 28:38:05,760
Três dessas formas vão ser

43119
28:38:05,760 --> 28:38:07,832
elipses e se tentarmos imprimir o

43120
28:38:07,832 --> 28:38:09,832
contagem de elipse vamos ver que nós

43121
28:38:09,832 --> 28:38:12,640
tem três elipses em nosso c plus mais

43122
28:38:12,640 --> 28:38:14,552
programa e isso vai fazer

43123
28:38:14,552 --> 28:38:16,640
O que queremos outra coisa que você poderia fazer

43124
28:38:16,640 --> 28:38:20,000
também é moldar polimorfismo e chamada

43125
28:38:20,000 --> 28:38:22,000
o método gatecount e você está indo para

43126
28:38:22,000 --> 28:38:24,160
obter o método getcount correto e

43127
28:38:24,160 --> 28:38:27,280
imprimir a conta mais específica se nós

43128
28:38:27,280 --> 28:38:29,440
estão chamando esse método em uma elipse

43129
28:38:29,440 --> 28:38:31,192
Objeto, por exemplo, vamos imprimir

43130
28:38:31,192 --> 28:38:33,680
três se chamarmos isso em um objeto de forma

43131
28:38:33,680 --> 28:38:35,280
nós vamos fazer sexo e esse é o

43132
28:38:35,280 --> 28:38:37,320
Comportamento que poderíamos alcançar com

43133
28:38:37,320 --> 28:38:39,600
Polimorfismo com membro estático

43134
28:38:39,600 --> 28:38:41,512
variáveis e eu realmente quero que você seja

43135
28:38:41,512 --> 28:38:43,600
Consciente disso agora que você sabe disso

43136
28:38:43,600 --> 28:38:44,872
nós vamos ir para o visual

43137
28:38:44,872 --> 28:38:46,720
código de estúdio e jogar com a gente um pouco

43138
28:38:46,720 --> 28:38:49,600
Mais aqui estamos em nossa pasta de trabalho

43139
28:38:49,600 --> 28:38:52,080
O projeto atual é herança e

43140
28:38:52,080 --> 28:38:54,720
Polimorfismo com membros estáticos

43141
28:38:54,720 --> 28:38:57,192
Vou pegar nossos arquivos de modelo e colocar

43142
28:38:57,192 --> 28:39:00,160
eles no lugar e eu vou pegar o nosso

43143
28:39:00,160 --> 28:39:03,280
aulas da minha unidade e usar isso como

43144
28:39:03,280 --> 28:39:05,512
O ponto de partida novamente se você não fizer

43145
28:39:05,512 --> 28:39:08,080
quer digitar ou criar essas classes que você

43146
28:39:08,080 --> 28:39:10,320
pode usar os arquivos fornecidos no

43147
28:39:10,320 --> 28:39:12,400
seção de recursos desta palestra que você pode

43148
28:39:12,400 --> 28:39:14,320
baixá-los e usá-los diretamente

43149
28:39:14,320 --> 28:39:16,232
sem ter que criá-las porque nós

43150
28:39:16,232 --> 28:39:18,640
estão realmente interessados em quão estático

43151
28:39:18,640 --> 28:39:22,000
Os membros se comportam com nossa herança

43152
28:39:22,000 --> 28:39:24,552
hierarquia que está configurando

43153
28:39:24,552 --> 28:39:26,232
Polimorfismo é isso que queremos

43154
28:39:26,232 --> 28:39:28,480
Saiba aqui que vou abrir isso

43155
28:39:28,480 --> 28:39:30,232
em código de estúdio visual e nós vamos

43156
28:39:30,232 --> 28:39:32,872
para dar uma boa olhada em nossas aulas

43157
28:39:32,872 --> 28:39:34,800
Classe base vai ser forma que é

43158
28:39:34,800 --> 28:39:37,120
O que temos aqui vai ter um

43159
28:39:37,120 --> 28:39:39,832
Método virtual que é obter contagem aqui

43160
28:39:39,832 --> 28:39:42,960
e temos um membro estático que é de

43161
28:39:42,960 --> 28:39:44,320
tipo e

43162
28:39:44,320 --> 28:39:46,160
Eu vou mudar meu parâmetro aqui

43163
28:39:46,160 --> 28:39:48,400
para bsdd string view

43164
28:39:48,400 --> 28:39:50,000
Porque é isso que devemos fazer em

43165
28:39:50,000 --> 28:39:52,872
moderno c plus plus vamos olhar para o cpp

43166
28:39:52,872 --> 28:39:55,192
arquivo para isso e nós vamos consertar

43167
28:39:55,192 --> 28:39:57,120
Isso um pouco e nós vamos pular

43168
28:39:57,120 --> 28:39:59,192
de volta ao arquivo de cabeçalho e olhar para

43169
28:39:59,192 --> 28:40:01,192
O que temos temos um método virtual

43170
28:40:01,192 --> 28:40:03,280
que vai devolver essa contagem aqui

43171
28:40:03,280 --> 28:40:05,040
é um método de const porque é realmente

43172
28:40:05,040 --> 28:40:07,280
não vai mudar isso só vai

43173
28:40:07,280 --> 28:40:09,192
devolver uma cópia do membro da contagem

43174
28:40:09,192 --> 28:40:10,872
Variável que temos aqui

43175
28:40:10,872 --> 28:40:12,960
e esta é uma variável de membro estática

43176
28:40:12,960 --> 28:40:16,160
notar que não está na linha, então vamos

43177
28:40:16,160 --> 28:40:18,872
precisa definir isso no arquivo cpp

43178
28:40:18,872 --> 28:40:21,512
Em algum lugar, porque esta é uma declaração

43179
28:40:21,512 --> 28:40:24,000
Precisamos colocar em uma definição que é

43180
28:40:24,000 --> 28:40:26,160
o que temos em nosso arquivo cpp aqui

43181
28:40:26,160 --> 28:40:28,640
porque estamos fazendo graças no mais velho

43182
28:40:28,640 --> 28:40:31,192
c plus plus way que vamos

43183
28:40:31,192 --> 28:40:34,080
incrementar nossa variável de membro de conta em

43184
28:40:34,080 --> 28:40:36,720
nosso construtor e isso vai

43185
28:40:36,720 --> 28:40:39,280
alcançar o comportamento que realmente queremos

43186
28:40:39,280 --> 28:40:41,680
ter a variável m count membro que

43187
28:40:41,680 --> 28:40:43,832
é static incremented cada vez que vamos

43188
28:40:43,832 --> 28:40:46,480
criar um objeto de forma aqui vamos voltar

43189
28:40:46,480 --> 28:40:49,192
e olhar para o nosso destruidor e certifique-se

43190
28:40:49,192 --> 28:40:51,760
que é virtual porque nós temos

43191
28:40:51,760 --> 28:40:53,600
funções virtuais nesta classe e isso

43192
28:40:53,600 --> 28:40:55,912
é a configuração que temos, vamos olhar

43193
28:40:55,912 --> 28:40:58,000
ellipse e nós vamos tirar isso

43194
28:40:58,000 --> 28:41:00,480
variável de membro estático porque

43195
28:41:00,480 --> 28:41:03,280
Não queremos configurá-lo a partir de agora

43196
28:41:03,280 --> 28:41:05,832
irá habilitá-lo em um minuto vamos fazer

43197
28:41:05,832 --> 28:41:07,760
Certamente nós removemos isso

43198
28:41:07,760 --> 28:41:08,960
E a

43199
28:41:08,960 --> 28:41:10,872
Vamos remover isso porque eu não quero

43200
28:41:10,872 --> 28:41:13,760
Isso e agora podemos tentar criar

43201
28:41:13,760 --> 28:41:16,000
objetos de nossas aulas e ver como estes

43202
28:41:16,000 --> 28:41:19,040
Os caras jogam fora nós também podemos ir em ellipse

43203
28:41:19,040 --> 28:41:22,640
e certifique-se de que o construtor é levado

43204
28:41:22,640 --> 28:41:25,280
std string views onde estamos precisando

43205
28:41:25,280 --> 28:41:28,080
strings que você pode fazer isso e pular para

43206
28:41:28,080 --> 28:41:31,360
o arquivo cpp e fazer essa exibição de string std

43207
28:41:31,360 --> 28:41:33,192
Eu acho que isso vai fazer um visual

43208
28:41:33,192 --> 28:41:35,360
Código de estúdio feliz até agora

43209
28:41:35,360 --> 28:41:37,832
podemos pular para o arquivo principal cpp e

43210
28:41:37,832 --> 28:41:40,552
Limpe-o um pouco e nós estamos

43211
28:41:40,552 --> 28:41:42,000
Indo para dentro de nós.

43212
28:41:42,000 --> 28:41:45,360
incluir a elipse e na nossa função principal

43213
28:41:45,360 --> 28:41:47,192
Vamos criar um monte de objetos

43214
28:41:47,192 --> 28:41:49,280
Vamos fechar a barra lateral esquerda aqui

43215
28:41:49,280 --> 28:41:51,360
Porque nós realmente não precisamos disso

43216
28:41:51,360 --> 28:41:53,280
Vamos pegar uma forma

43217
28:41:53,280 --> 28:41:54,800
objeto e vamos imprimir o

43218
28:41:54,800 --> 28:41:56,872
contagem de formas que esperamos obter um

43219
28:41:56,872 --> 28:41:59,192
porque temos apenas uma forma nisso

43220
28:41:59,192 --> 28:42:01,192
Momento vamos criar um segundo

43221
28:42:01,192 --> 28:42:03,512
forma aqui e se imprimirmos a contagem

43222
28:42:03,512 --> 28:42:05,280
nós vamos ter dois porque nós temos

43223
28:42:05,280 --> 28:42:07,760
Duas formas é o que esperamos

43224
28:42:07,760 --> 28:42:09,360
criar uma outra forma que vai

43225
28:42:09,360 --> 28:42:11,120
ser forma três aqui nós imprimimos a contagem

43226
28:42:11,120 --> 28:42:12,800
vamos ter um três, mas o

43227
28:42:12,800 --> 28:42:14,720
O problema virá quando criarmos

43228
28:42:14,720 --> 28:42:17,040
uma elipse aqui se criarmos uma elipse

43229
28:42:17,040 --> 28:42:18,720
e imprimir a contagem que vamos ter um

43230
28:42:18,720 --> 28:42:21,040
quatro porque temos quatro formas em nosso

43231
28:42:21,040 --> 28:42:23,832
c plus programa, mas se imprimirmos o

43232
28:42:23,832 --> 28:42:26,160
ellipse contagem aqui esperamos obter um

43233
28:42:26,160 --> 28:42:28,160
Um, mas não é isso que nós vamos

43234
28:42:28,160 --> 28:42:30,800
Nós vamos ter um 4 porque o m

43235
28:42:30,800 --> 28:42:34,080
variável de contagem na elipse é herdada

43236
28:42:34,080 --> 28:42:36,232
da nossa classe de forma para que vá

43237
28:42:36,232 --> 28:42:38,400
ser a mesma coisa que temos em forma aqui

43238
28:42:38,400 --> 28:42:39,832
Porque se você voltar, você vai

43239
28:42:39,832 --> 28:42:42,480
Veja que neste ponto elipse não

43240
28:42:42,480 --> 28:42:45,192
ter uma contagem de m variável estática de

43241
28:42:45,192 --> 28:42:47,512
possuir, então ele vai usar o que é

43242
28:42:47,512 --> 28:42:50,320
herança da classe de forma esta é

43243
28:42:50,320 --> 28:42:52,640
O comportamento que vamos chegar aqui e

43244
28:42:52,640 --> 28:42:54,480
Eu quero que você esteja ciente disso se isso

43245
28:42:54,480 --> 28:42:56,720
é o que você quer isso é bom, mas em

43246
28:42:56,720 --> 28:42:58,960
na maioria dos casos, você vai querer que isso seja

43247
28:42:58,960 --> 28:43:01,512
diferente porque você quer muito claro

43248
28:43:01,512 --> 28:43:04,000
Informações sobre quantos objetos de

43249
28:43:04,000 --> 28:43:05,440
cada tipo que você criou em seu

43250
28:43:05,440 --> 28:43:08,160
z-plus mais programa se for moldado

43251
28:43:08,160 --> 28:43:10,160
Isso vai ser muito vago porque

43252
28:43:10,160 --> 28:43:12,480
você quer saber se é uma elipse se

43253
28:43:12,480 --> 28:43:14,720
é um retângulo se for um triângulo

43254
28:43:14,720 --> 28:43:16,640
Isso não vai ser super claro, então

43255
28:43:16,640 --> 28:43:18,160
Vamos soldar e realmente mostrar-lhe o

43256
28:43:18,160 --> 28:43:19,760
O problema aqui nós vamos passar isso

43257
28:43:19,760 --> 28:43:22,400
através do gcc nosso compilador favorito nós podemos

43258
28:43:22,400 --> 28:43:24,320
Também traga a barra lateral esquerda no

43259
28:43:24,320 --> 28:43:26,232
problema aqui e nós vamos trazer à tona

43260
28:43:26,232 --> 28:43:28,720
uma janela de terminal ou uma janela powershell

43261
28:43:28,720 --> 28:43:30,080
Eu posso dizer

43262
28:43:30,080 --> 28:43:31,680
nós vamos limpar

43263
28:43:31,680 --> 28:43:33,912
e correr galo você vai ver que

43264
28:43:33,912 --> 28:43:36,320
A contagem de formas vai ser um dois

43265
28:43:36,320 --> 28:43:37,120
Três

43266
28:43:37,120 --> 28:43:39,512
E nós temos um cinco aqui

43267
28:43:39,512 --> 28:43:42,400
porque também estamos aumentando o m

43268
28:43:42,400 --> 28:43:44,872
variável de contagem em nossa classe derivada, então

43269
28:43:44,872 --> 28:43:47,280
Estamos incrementando duas vezes se criarmos

43270
28:43:47,280 --> 28:43:50,000
um objeto de elipse vamos te mostrar isso em

43271
28:43:50,000 --> 28:43:52,720
elipse cpp estamos a incrementar o m

43272
28:43:52,720 --> 28:43:55,192
variável de membro da contagem, mas na base

43273
28:43:55,192 --> 28:43:58,080
classe também estamos implementando isso em

43274
28:43:58,080 --> 28:44:00,960
O arquivo cpp é o que temos aqui

43275
28:44:00,960 --> 28:44:03,360
e observe que a classe derivada é

43276
28:44:03,360 --> 28:44:06,400
Também chamando a classe base

43277
28:44:06,400 --> 28:44:08,800
através do nosso inicializador lust here

43278
28:44:08,800 --> 28:44:10,640
Este é o comportamento que temos

43279
28:44:10,640 --> 28:44:13,360
Não deveria estar aumentando isso porque

43280
28:44:13,360 --> 28:44:15,760
A elipse não tem sua própria estática

43281
28:44:15,760 --> 28:44:18,080
variável a partir de agora agora estamos indo para

43282
28:44:18,080 --> 28:44:20,800
construir e realmente resolver este problema agora

43283
28:44:20,800 --> 28:44:22,480
Você vê os tipos de problemas que você pode

43284
28:44:22,480 --> 28:44:24,872
se você tiver uma variável estática

43285
28:44:24,872 --> 28:44:27,120
que é chamado exatamente da mesma forma e

43286
28:44:27,120 --> 28:44:29,440
Você tem uma hierarquia de herança

43287
28:44:29,440 --> 28:44:31,680
Problemas realmente estranhos podem aparecer e você

43288
28:44:31,680 --> 28:44:34,552
precisa estar ciente disso, vamos construir e

43289
28:44:34,552 --> 28:44:36,080
Veja que realmente o problema

43290
28:44:36,080 --> 28:44:38,480
Desapareceu bem o parafuso é bom que podemos

43291
28:44:38,480 --> 28:44:39,760
claro

43292
28:44:39,760 --> 28:44:41,440
e correr o galo, vamos ver isso

43293
28:44:41,440 --> 28:44:43,912
Agora é isso que esperamos um dois três

43294
28:44:43,912 --> 28:44:46,000
porque temos três formas criadas

43295
28:44:46,000 --> 28:44:48,320
para este ponto aqui se criarmos um

43296
28:44:48,320 --> 28:44:50,000
elipse que vai ser outra forma

43297
28:44:50,000 --> 28:44:51,600
Se conseguirmos a contagem de formas, vamos

43298
28:44:51,600 --> 28:44:54,400
obter uma contagem de 4, mas elipse também está dando

43299
28:44:54,400 --> 28:44:57,120
nós 4 porque a elipse não tem

43300
28:44:57,120 --> 28:44:59,280
sua variável estática para resolver isso

43301
28:44:59,280 --> 28:45:01,280
problema podemos ir para ellipse e configurar

43302
28:45:01,280 --> 28:45:03,832
nossa própria variável de membro na elipse

43303
28:45:03,832 --> 28:45:06,800
nível para que possamos permitir isso e

43304
28:45:06,800 --> 28:45:08,400
desmentição de que vamos para o

43305
28:45:08,400 --> 28:45:10,232
arquivo cpp e certifique-se de que estamos

43306
28:45:10,232 --> 28:45:12,800
incremento para obter a contagem correta

43307
28:45:12,800 --> 28:45:15,280
incrementado aqui eu acho que isso é tudo que nós

43308
28:45:15,280 --> 28:45:17,192
Precisamos fazer, nós também vamos

43309
28:45:17,192 --> 28:45:19,832
inicializar a variável estática que temos

43310
28:45:19,832 --> 28:45:22,080
no nível da elipse isso vai fazer

43311
28:45:22,080 --> 28:45:24,960
O que queremos e podemos construir de novo agora

43312
28:45:24,960 --> 28:45:27,192
nós vamos ter o comportamento que queremos

43313
28:45:27,192 --> 28:45:29,440
Porque neste ponto vamos

43314
28:45:29,440 --> 28:45:30,872
imprimir um one

43315
28:45:30,872 --> 28:45:32,960
para contar elipse e isso realmente

43316
28:45:32,960 --> 28:45:35,360
Faz sentido porque temos uma elipse

43317
28:45:35,360 --> 28:45:38,232
Mesmo que tenhamos quatro formas no total

43318
28:45:38,232 --> 28:45:40,720
Este é o design que eu acho

43319
28:45:40,720 --> 28:45:43,912
faz mais sentido em nosso c plus plus

43320
28:45:43,912 --> 28:45:46,160
programa aqui vamos construir isso

43321
28:45:46,160 --> 28:45:48,720
novamente e passar isso através de gcc

43322
28:45:48,720 --> 28:45:51,040
O construtor vai ser bom, podemos limpar

43323
28:45:51,040 --> 28:45:52,960
e correr galo agora nós vamos ver

43324
28:45:52,960 --> 28:45:55,440
que temos quatro formas e uma elipse

43325
28:45:55,440 --> 28:45:57,680
Isto é o que queremos agora que temos

43326
28:45:57,680 --> 28:45:59,832
Isso nós podemos realmente fazer todos os tipos de loucura

43327
28:45:59,832 --> 28:46:01,440
Espero que você possa ver que

43328
28:46:01,440 --> 28:46:04,552
A variável estática está funcionando exatamente como nós

43329
28:46:04,552 --> 28:46:06,552
Queremos que possamos imprimir a contagem de elipses nós

43330
28:46:06,552 --> 28:46:08,800
pode imprimir a contagem de formas se é isso que

43331
28:46:08,800 --> 28:46:11,192
Queremos em nosso programa c plus plus, mas

43332
28:46:11,192 --> 28:46:12,832
nós também podemos fazer a forma

43333
28:46:12,832 --> 28:46:15,512
Polimorfismo e obter o correto get

43334
28:46:15,512 --> 28:46:18,320
método de contagem chamado em nosso c mais primeiro

43335
28:46:18,320 --> 28:46:20,872
programa, por exemplo, se chamarmos o

43336
28:46:20,872 --> 28:46:23,120
getcount método no ponto de referência que

43337
28:46:23,120 --> 28:46:25,440
está gerenciando uma forma que vamos ter

43338
28:46:25,440 --> 28:46:27,512
Este chamado se tivermos o melhor

43339
28:46:27,512 --> 28:46:29,280
ponteiro que está gerenciando uma elipse

43340
28:46:29,280 --> 28:46:30,960
nós vamos chegar a este chamado

43341
28:46:30,960 --> 28:46:33,192
Isso vai ser super legal, vamos embora

43342
28:46:33,192 --> 28:46:35,512
em nosso programa e configurar isso, estamos

43343
28:46:35,512 --> 28:46:37,760
Vou fazer isso na mosca, digamos

43344
28:46:37,760 --> 28:46:40,000
forma polimorfismo e nós vamos

43345
28:46:40,000 --> 28:46:42,720
Diga shift pointer e vai ser

43346
28:46:42,720 --> 28:46:45,040
Um array vamos dizer formas que isso está indo

43347
28:46:45,040 --> 28:46:46,720
para fazer e vai ser apenas um

43348
28:46:46,720 --> 28:46:48,960
array e vamos inicializar isso

43349
28:46:48,960 --> 28:46:51,360
e armazenar em um monte de objetos, vamos

43350
28:46:51,360 --> 28:46:54,320
colocar em uma cinta de fechamento aqui vamos subir

43351
28:46:54,320 --> 28:46:56,232
e ver o que temos, por exemplo, temos

43352
28:46:56,232 --> 28:46:59,192
forma um e elipse um que podemos usar

43353
28:46:59,192 --> 28:47:00,872
Estes vamos colocar no endereço

43354
28:47:00,872 --> 28:47:02,720
de forma um e vamos colocar

43355
28:47:02,720 --> 28:47:04,640
o endereço da elipse um que está indo

43356
28:47:04,640 --> 28:47:05,680
para fazer

43357
28:47:05,680 --> 28:47:07,512
e nós podemos percorrer esses caras e

43358
28:47:07,512 --> 28:47:09,600
chamar o método get count, então vamos fazer

43359
28:47:09,600 --> 28:47:12,400
Isso vamos dizer para automóveis

43360
28:47:12,400 --> 28:47:14,400
e vamos fazer uma referência porque nós

43361
28:47:14,400 --> 28:47:17,360
Não quero cópias e vamos dizer

43362
28:47:17,360 --> 28:47:19,512
em formas e nós vamos chamar o

43363
28:47:19,512 --> 28:47:21,912
método gatecount nós vamos dizer s

43364
28:47:21,912 --> 28:47:24,640
e dizer getcount isso vai

43365
28:47:24,640 --> 28:47:26,480
nos dar a contagem e podemos imprimir isso

43366
28:47:26,480 --> 28:47:29,192
Se quisermos, podemos dizer

43367
28:47:29,192 --> 28:47:31,280
Contagem e nós vamos para

43368
28:47:31,280 --> 28:47:33,832
Coloque um novo personagem de linha aqui para

43369
28:47:33,832 --> 28:47:35,680
separar esses caras

43370
28:47:35,680 --> 28:47:37,280
E nós podemos

43371
28:47:37,280 --> 28:47:39,440
colocar um separador aqui podemos copiar o que nós

43372
28:47:39,440 --> 28:47:41,440
usado em nosso programa c plus plus

43373
28:47:41,440 --> 28:47:43,832
aqui apenas para ter certeza de que isso é super

43374
28:47:43,832 --> 28:47:46,320
claro quando imprimimos as coisas no

43375
28:47:46,320 --> 28:47:47,912
terminal aqui nós vamos construir o nosso

43376
28:47:47,912 --> 28:47:51,040
programar e ver se realmente funciona o

43377
28:47:51,040 --> 28:47:52,960
O corpo vai ser bom, podemos limpar

43378
28:47:52,960 --> 28:47:55,440
e correr o galo, vamos ver isso

43379
28:47:55,440 --> 28:47:57,600
A contagem vai ser 4 para o primeiro

43380
28:47:57,600 --> 28:47:59,040
iteração porque nós vamos ser

43381
28:47:59,040 --> 28:48:01,760
chamando o método get count de

43382
28:48:01,760 --> 28:48:04,960
forma porque esse é o nosso ponteiro base, então

43383
28:48:04,960 --> 28:48:06,232
Isto é o que nós vamos conseguir

43384
28:48:06,232 --> 28:48:08,400
vai imprimir o m contagem de membros

43385
28:48:08,400 --> 28:48:10,720
variável da classe base que é o porquê

43386
28:48:10,720 --> 28:48:13,280
Temos um quatro, mas no segundo

43387
28:48:13,280 --> 28:48:16,552
iteração do objeto é elipse e nós

43388
28:48:16,552 --> 28:48:18,552
Estamos usando polimorfismo porque nós somos

43389
28:48:18,552 --> 28:48:20,800
passando por um ponteiro de base e isso

43390
28:48:20,800 --> 28:48:23,120
O ponteiro base acontece para apoiar o

43391
28:48:23,120 --> 28:48:25,760
O método virtual obtém a contagem

43392
28:48:25,760 --> 28:48:28,552
mais específico um chamado na corrente

43393
28:48:28,552 --> 28:48:31,680
Objeto que nosso ponteiro base está gerenciando

43394
28:48:31,680 --> 28:48:33,600
Aqui e isso acontece para ser uma elipse

43395
28:48:33,600 --> 28:48:35,040
Vamos chamar a elipse

43396
28:48:35,040 --> 28:48:37,832
versão da nossa função virtual aqui e

43397
28:48:37,832 --> 28:48:40,000
vamos ter um, porque nós realmente temos

43398
28:48:40,000 --> 28:48:42,552
uma elipse em nosso c plus programa

43399
28:48:42,552 --> 28:48:44,800
Isto é o que vemos aqui, isso é realmente

43400
28:48:44,800 --> 28:48:47,040
Tudo que eu queria que você visse nesta palestra

43401
28:48:47,040 --> 28:48:48,400
Como você pode usar

43402
28:48:48,400 --> 28:48:50,872
variáveis de membro estático com herança

43403
28:48:50,872 --> 28:48:53,192
e polimorfismo e você precisa ser

43404
28:48:53,192 --> 28:48:55,280
Consciente dessas pequenas coisas que podem

43405
28:48:55,280 --> 28:48:57,832
Na verdade, seja confuso, especialmente para

43406
28:48:57,832 --> 28:48:59,912
iniciantes, vamos parar aqui em

43407
28:48:59,912 --> 28:49:01,680
Esta palestra é a próxima que vamos

43408
28:49:01,680 --> 28:49:04,640
Saiba mais sobre a especificação final que nós

43409
28:49:04,640 --> 28:49:07,832
pode usar em nossa hierarquia de herança ir

43410
28:49:07,832 --> 28:49:09,912
Na frente e terminar aqui e me encontrar

43411
28:49:09,912 --> 28:49:11,120
lá

43412
28:49:11,120 --> 28:49:13,280
Vá em frente e termine aqui e me encontre

43413
28:49:13,280 --> 28:49:14,960
lá nesta palestra vamos

43414
28:49:14,960 --> 28:49:18,960
Saiba mais sobre o especificador final usado em

43415
28:49:18,960 --> 28:49:21,512
hierarquias de herança isto vai

43416
28:49:21,512 --> 28:49:24,480
permitir que você faça uma das duas coisas que você

43417
28:49:24,480 --> 28:49:26,800
Será capaz de restringir a forma como você

43418
28:49:26,800 --> 28:49:30,000
métodos de substituição nas classes derivadas

43419
28:49:30,000 --> 28:49:32,720
ou você pode restringir como você pode derivar

43420
28:49:32,720 --> 28:49:35,512
de classes de base eu sei que isso está no

43421
28:49:35,512 --> 28:49:37,040
ar, mas vamos olhar para alguns

43422
28:49:37,040 --> 28:49:39,040
exemplos para realmente conduzir isso para casa

43423
28:49:39,040 --> 28:49:41,512
Suponha que temos uma hierarquia de herança

43424
28:49:41,512 --> 28:49:43,440
Como vemos aqui a classe superior é animal

43425
28:49:43,440 --> 28:49:45,760
Podemos derivar disso e ter felino

43426
28:49:45,760 --> 28:49:47,760
você pode ter o pássaro como uma classe derivada

43427
28:49:47,760 --> 28:49:50,080
felino pode ser herdado para ter um cão

43428
28:49:50,080 --> 28:49:52,720
e gato e você pode derivar de gato para

43429
28:49:52,720 --> 28:49:55,120
exemplo para ter gato selvagem e bulldog

43430
28:49:55,120 --> 28:49:57,192
do cão você pode fazer todas essas coisas

43431
28:49:57,192 --> 28:49:59,512
aqui e esta é a hierarquia de herança

43432
28:49:59,512 --> 28:50:01,512
Vamos usar para aprender sobre

43433
28:50:01,512 --> 28:50:04,080
Estas coisas agora aqui é um possível

43434
28:50:04,080 --> 28:50:06,000
implementação para a classe do cão que

43435
28:50:06,000 --> 28:50:08,320
Vai ser herdado do felino

43436
28:50:08,320 --> 28:50:11,040
publicamente, como vemos aqui, mas dê uma olhada

43437
28:50:11,040 --> 28:50:13,680
no método de execução que estamos configurando

43438
28:50:13,680 --> 28:50:17,360
dag nós estamos anexando um especificador final

43439
28:50:17,360 --> 28:50:20,320
E o que isso vai significar é que

43440
28:50:20,320 --> 28:50:23,832
nenhuma classe de herança downstream será

43441
28:50:23,832 --> 28:50:26,080
capaz de substituir o método aleatório

43442
28:50:26,080 --> 28:50:28,232
Isto é o que podemos alcançar assim

43443
28:50:28,232 --> 28:50:30,960
se não queremos nossas classes derivadas para

43444
28:50:30,960 --> 28:50:32,720
substituir o nosso

43445
28:50:32,720 --> 28:50:35,512
Método virtual podemos marcar esse método

43446
28:50:35,512 --> 28:50:37,512
como final em nossa classe e nós somos

43447
28:50:37,512 --> 28:50:40,000
basicamente dizendo que eu vou colocar no meu

43448
28:50:40,000 --> 28:50:42,720
implementação, mas eu não quero nenhum

43449
28:50:42,720 --> 28:50:46,400
derivando classe downstream para substituir

43450
28:50:46,400 --> 28:50:48,720
Este método se eles fizerem isso

43451
28:50:48,720 --> 28:50:50,400
vai ter um erro de compilador e

43452
28:50:50,400 --> 28:50:52,720
Isso é algo que podemos conseguir usando

43453
28:50:52,720 --> 28:50:55,760
O especificador final em nossa herança

43454
28:50:55,760 --> 28:50:57,912
Hierarquia novamente neste caso, somos

43455
28:50:57,912 --> 28:51:00,480
Usando isso para restringir

43456
28:51:00,480 --> 28:51:04,000
Como as pessoas podem substituir o nosso próprio virtual

43457
28:51:04,000 --> 28:51:06,960
método em classes downstream ou i

43458
28:51:06,960 --> 28:51:08,800
Não deveria realmente dizer nosso próprio método

43459
28:51:08,800 --> 28:51:11,440
porque pode estar vindo de upstream

43460
28:51:11,440 --> 28:51:13,832
Mas você está restringindo as pessoas de

43461
28:51:13,832 --> 28:51:16,552
substituindo esse método ainda mais em

43462
28:51:16,552 --> 28:51:18,872
aulas downstream aqui está tudo bem, então isso é

43463
28:51:18,872 --> 28:51:21,512
O primeiro uso que temos para a final

43464
28:51:21,512 --> 28:51:24,232
specifier mas também podemos restringir

43465
28:51:24,232 --> 28:51:27,760
pessoas de herdar completamente assim

43466
28:51:27,760 --> 28:51:29,600
Aqui temos um exemplo simples para dirigir

43467
28:51:29,600 --> 28:51:32,160
Esta casa temos nossa classe de gato é

43468
28:51:32,160 --> 28:51:34,552
vai herdar do felino, mas

43469
28:51:34,552 --> 28:51:37,760
Estamos marcando nossa classe de gato como final

43470
28:51:37,760 --> 28:51:40,080
e o que isso vai significar se

43471
28:51:40,080 --> 28:51:43,360
Qualquer um tenta herdar ou derivar de

43472
28:51:43,360 --> 28:51:45,832
gato de qualquer maneira que eles vão conseguir um

43473
28:51:45,832 --> 28:51:47,512
erro do compilador e isso é o que podemos

43474
28:51:47,512 --> 28:51:50,720
conseguir com o especificador final novamente

43475
28:51:50,720 --> 28:51:52,480
Há duas coisas que você pode restringir

43476
28:51:52,480 --> 28:51:55,280
Como as pessoas superam seus métodos virtuais

43477
28:51:55,280 --> 28:51:58,000
se você quiser restringir isso do

43478
28:51:58,000 --> 28:52:00,800
Classe atual você pode marcar o seu virtual

43479
28:52:00,800 --> 28:52:03,280
método como final você também pode restringir

43480
28:52:03,280 --> 28:52:05,600
Como as pessoas herdam todas juntas de

43481
28:52:05,600 --> 28:52:07,832
sua classe e se você quer esse comportamento

43482
28:52:07,832 --> 28:52:11,040
você pode marcar sua classe como final usando

43483
28:52:11,040 --> 28:52:13,120
A sintaxe que acabamos de ver nos slides

43484
28:52:13,120 --> 28:52:15,440
Aqui está tudo bem agora que você sabe essas coisas

43485
28:52:15,440 --> 28:52:17,680
Vejamos algumas coisas que podem ser

43486
28:52:17,680 --> 28:52:20,160
interessante, por exemplo, aqui é simples

43487
28:52:20,160 --> 28:52:22,160
Você pode criar uma classe certa

43488
28:52:22,160 --> 28:52:25,440
fora no mercado como final e quando você faz

43489
28:52:25,440 --> 28:52:28,480
Isso ninguém será capaz de herdar

43490
28:52:28,480 --> 28:52:30,800
desta classe no seu programa e se

43491
28:52:30,800 --> 28:52:33,120
Fazemos isso, obteremos um erro de compilador

43492
28:52:33,120 --> 28:52:35,600
Por exemplo, isso é uma coisa que eu acho

43493
28:52:35,600 --> 28:52:37,912
Interessante e eu realmente queria que você

43494
28:52:37,912 --> 28:52:40,000
Sei que outra coisa é que é

43495
28:52:40,000 --> 28:52:42,400
Possível introduzir inútil virtual

43496
28:52:42,400 --> 28:52:45,360
métodos em sua hierarquia de herança

43497
28:52:45,360 --> 28:52:48,080
por exemplo, se nossa classe de gato é marcada

43498
28:52:48,080 --> 28:52:50,960
como final o que isso significa é que ninguém

43499
28:52:50,960 --> 28:52:53,512
Será capaz de herdar disso

43500
28:52:53,512 --> 28:52:55,600
classe, mas estamos indo mais longe

43501
28:52:55,600 --> 28:52:57,680
configurar um método virtual que é

43502
28:52:57,680 --> 28:53:00,400
destinado a ser herdado ou sobrescrito em

43503
28:53:00,400 --> 28:53:02,720
classes downstream, mas como conseguir um

43504
28:53:02,720 --> 28:53:05,040
classe downstream se não pudermos herdar

43505
28:53:05,040 --> 28:53:07,120
da classe de gato que é marcada final

43506
28:53:07,120 --> 28:53:10,320
para que tenhamos ideias conflitantes aqui em

43507
28:53:10,320 --> 28:53:12,320
Por uma mão, estamos dizendo que nunca podemos

43508
28:53:12,320 --> 28:53:15,192
herdar desta classe de concessão, mas no

43509
28:53:15,192 --> 28:53:17,280
outra mão que estamos configurando um método

43510
28:53:17,280 --> 28:53:20,232
que é destinado a ser usado ou especializado

43511
28:53:20,232 --> 28:53:22,640
em classes derivadas, então isso é algo

43512
28:53:22,640 --> 28:53:24,720
que é interessante que este código está indo

43513
28:53:24,720 --> 28:53:27,760
para compilar e eu acho que talvez no futuro

43514
28:53:27,760 --> 28:53:29,680
padrões de c plus plus eles estão indo

43515
28:53:29,680 --> 28:53:31,912
para corrigir este problema e talvez dar-lhe um

43516
28:53:31,912 --> 28:53:33,512
Erro do compilador se você tentar fazer

43517
28:53:33,512 --> 28:53:35,440
Algo assim, mas neste momento

43518
28:53:35,440 --> 28:53:37,280
você não vai ter um erro de compilador

43519
28:53:37,280 --> 28:53:39,040
isso será apenas válido c plus

43520
28:53:39,040 --> 28:53:41,680
além de sintaxe, mesmo que isso seja realmente estranho

43521
28:53:41,680 --> 28:53:44,320
Temos ideias conflitantes aqui, tudo bem

43522
28:53:44,320 --> 28:53:47,040
O que você deve saber é que nós

43523
28:53:47,040 --> 28:53:49,192
pode substituir em uma classe final e esta

43524
28:53:49,192 --> 28:53:50,720
vai fazer sentido porque para

43525
28:53:50,720 --> 28:53:53,440
exemplo de que o método de execução vem

43526
28:53:53,440 --> 28:53:55,192
A classe felina

43527
28:53:55,192 --> 28:53:57,760
e aqui estamos apenas nos especializando que

43528
28:53:57,760 --> 28:54:00,480
assim, estamos marcando isso como uma substituição

43529
28:54:00,480 --> 28:54:03,040
Aqui mesmo que esta seja a classe final, então

43530
28:54:03,040 --> 28:54:05,512
ter cuidado este é válido c plus plus

43531
28:54:05,512 --> 28:54:07,680
sintaxe, isso vai funcionar muito bem

43532
28:54:07,680 --> 28:54:09,512
Outra coisa que você pode fazer é bonita

43533
28:54:09,512 --> 28:54:11,912
inútil em seu programa c plus plus é

43534
28:54:11,912 --> 28:54:14,720
para introduzir um método e marca virtual

43535
28:54:14,720 --> 28:54:18,872
É como final imediatamente, então novamente isso é

43536
28:54:18,872 --> 28:54:21,912
Realmente estranho temos duas ideias que são

43537
28:54:21,912 --> 28:54:24,552
meios de palavras-chave virtuais conflitantes

43538
28:54:24,552 --> 28:54:27,040
que queremos que isso seja visualizado em

43539
28:54:27,040 --> 28:54:29,680
as aulas a jusante, mas novamente estamos

43540
28:54:29,680 --> 28:54:32,400
Dizendo este método é final, então não

43541
28:54:32,400 --> 28:54:34,640
A classe downstream vai substituir isso se

43542
28:54:34,640 --> 28:54:36,080
eles tentam fazer isso que eles vão

43543
28:54:36,080 --> 28:54:38,320
obter um erro de compilador, então este é novamente um

43544
28:54:38,320 --> 28:54:40,960
Um monte de ideias conflitantes c plus plus

43545
28:54:40,960 --> 28:54:42,640
permitirá que essa sintaxe isso seja

43546
28:54:42,640 --> 28:54:44,552
não vai dar-lhe um erro de compilador

43547
28:54:44,552 --> 28:54:46,720
Mas isso é estranho e você precisa ser

43548
28:54:46,720 --> 28:54:48,720
ciente disso ok agora que você sabe

43549
28:54:48,720 --> 28:54:50,480
essas ideias para as quais vamos nos dirigir

43550
28:54:50,480 --> 28:54:53,192
código de estúdio visual e jogar com o

43551
28:54:53,192 --> 28:54:55,832
Especificador final em nossa herança

43552
28:54:55,832 --> 28:54:57,912
hierarquia, estaremos configurando isso

43553
28:54:57,912 --> 28:55:00,320
tipo de hierarquia de herança e nós

43554
28:55:00,320 --> 28:55:02,400
configurar um monte de métodos virtuais

43555
28:55:02,400 --> 28:55:04,960
e marcá-los como final eu acho que vamos

43556
28:55:04,960 --> 28:55:07,512
fazer isso na aula de cães e nós vamos

43557
28:55:07,512 --> 28:55:10,160
Marque um monte de aulas como final e veja

43558
28:55:10,160 --> 28:55:12,552
que se herdarmos deles, vamos

43559
28:55:12,552 --> 28:55:14,720
para obter um monte de erros de compilador, então

43560
28:55:14,720 --> 28:55:17,760
Vamos fazer isso aqui estamos trabalhando

43561
28:55:17,760 --> 28:55:21,120
pasta o projeto atual é final e

43562
28:55:21,120 --> 28:55:23,360
Vamos trazer o nosso template

43563
28:55:23,360 --> 28:55:24,872
Arquivos muito rápido que vamos usar

43564
28:55:24,872 --> 28:55:27,440
como nosso ponto de partida, estamos indo

43565
28:55:27,440 --> 28:55:29,600
para colocar isso no lugar

43566
28:55:29,600 --> 28:55:31,600
E eu vou colocar em um monte de

43567
28:55:31,600 --> 28:55:34,000
classes que eu tenho no meu sistema

43568
28:55:34,000 --> 28:55:36,400
porque eu não quero configurar estes

43569
28:55:36,400 --> 28:55:38,320
classes que seriam um desperdício de seu

43570
28:55:38,320 --> 28:55:40,800
O tempo só sabe que estamos tentando definir

43571
28:55:40,800 --> 28:55:43,280
Este tipo de hierarquia de herança

43572
28:55:43,280 --> 28:55:45,760
animal vai ser o nosso cão superior ou

43573
28:55:45,760 --> 28:55:47,600
animal vai ser a nossa classe superior e

43574
28:55:47,600 --> 28:55:50,232
Estaremos herdando desta criação

43575
28:55:50,232 --> 28:55:52,480
uma hierarquia de herança que podemos jogar

43576
28:55:52,480 --> 28:55:55,040
em nosso código aqui está tudo bem, então estamos

43577
28:55:55,040 --> 28:55:57,280
Vou abrir isso no estúdio visual

43578
28:55:57,280 --> 28:55:59,192
código então vamos fazer isso arrastando e

43579
28:55:59,192 --> 28:56:01,600
Dando aqui isso vai nos dar

43580
28:56:01,600 --> 28:56:04,080
todas essas classes loucas que temos

43581
28:56:04,080 --> 28:56:06,400
A classe superior vai ser animal e

43582
28:56:06,400 --> 28:56:08,400
vai definir as características

43583
28:56:08,400 --> 28:56:10,160
qualquer tipo de animal que apoiamos você sabe c

43584
28:56:10,160 --> 28:56:12,232
Plus plus programa vai ter para

43585
28:56:12,232 --> 28:56:14,720
exemplo, qualquer tipo de animal precisará

43586
28:56:14,720 --> 28:56:17,832
Respire e vamos configurar este virtual

43587
28:56:17,832 --> 28:56:19,192
O método aqui

43588
28:56:19,192 --> 28:56:21,280
e nós estaremos herdando disso

43589
28:56:21,280 --> 28:56:24,000
classe animal para criar uma classe felina

43590
28:56:24,000 --> 28:56:26,232
E uma classe de pássaro isso é algo que nós

43591
28:56:26,232 --> 28:56:28,400
em algumas palestras anteriores e nós

43592
28:56:28,400 --> 28:56:30,160
estão apenas reutilizando esta herança

43593
28:56:30,160 --> 28:56:32,160
Hierarquia aqui, vamos olhar para o felino

43594
28:56:32,160 --> 28:56:34,000
classe da classe de filamentos vai definir

43595
28:56:34,000 --> 28:56:36,720
um método virtual chamado de execução

43596
28:56:36,720 --> 28:56:39,040
e o método vai ser substituído

43597
28:56:39,040 --> 28:56:41,120
No cão, por exemplo

43598
28:56:41,120 --> 28:56:43,760
Podemos substituir o método de execução, mas

43599
28:56:43,760 --> 28:56:47,360
note que estamos marcando isso como final

43600
28:56:47,360 --> 28:56:50,232
Tudo bem, então olhe para isso o método é final

43601
28:56:50,232 --> 28:56:52,480
O que isso significa é que

43602
28:56:52,480 --> 28:56:55,360
sem classes downstream herdando de

43603
28:56:55,360 --> 28:56:58,552
doug será capaz de se especializar ou

43604
28:56:58,552 --> 28:57:01,280
substituir ainda mais este método se eles tentarem

43605
28:57:01,280 --> 28:57:03,280
para fazer isso, eles receberão um compilador

43606
28:57:03,280 --> 28:57:05,912
aviso de erro de que este pode ser o nosso método

43607
28:57:05,912 --> 28:57:08,000
ou pode ser um método proveniente de

43608
28:57:08,000 --> 28:57:10,480
classes upstream neste caso a corrida

43609
28:57:10,480 --> 28:57:13,040
O método foi introduzido no felino

43610
28:57:13,040 --> 28:57:16,232
nível que você vê que foi introduzido aqui e

43611
28:57:16,232 --> 28:57:18,960
O doug está substituindo isso

43612
28:57:18,960 --> 28:57:21,040
método aqui é por isso que temos o

43613
28:57:21,040 --> 28:57:23,280
superride do mundo chave, mas

43614
28:57:23,280 --> 28:57:25,280
Ao mesmo tempo, vamos marcá-lo

43615
28:57:25,280 --> 28:57:26,640
Como final

43616
28:57:26,640 --> 28:57:29,192
e proibir ou impedir

43617
28:57:29,192 --> 28:57:31,912
classes a jusante de sobrepor isso

43618
28:57:31,912 --> 28:57:35,360
método adicional se olharmos para o nosso bulldog

43619
28:57:35,360 --> 28:57:37,912
classe para a qual vamos encontrar a classe para

43620
28:57:37,912 --> 28:57:42,160
herdar da escuridão nós temos o nosso método de execução

43621
28:57:42,160 --> 28:57:44,480
Aqui é comentado neste momento

43622
28:57:44,480 --> 28:57:46,400
Eu só quero que você veja que o nosso código é

43623
28:57:46,400 --> 28:57:48,872
apenas indo para compilar se nós compilá-lo

43624
28:57:48,872 --> 28:57:50,000
E agora

43625
28:57:50,000 --> 28:57:51,512
Vamos fazer isso, vamos passar isso

43626
28:57:51,512 --> 28:57:54,000
através de gcc OK você vê o parafuso é

43627
28:57:54,000 --> 28:57:56,232
bom e nós geramos o nosso binário

43628
28:57:56,232 --> 28:57:57,760
O que realmente não está fazendo nada

43629
28:57:57,760 --> 28:58:00,232
Porque a nossa principal função é apenas alguns

43630
28:58:00,232 --> 28:58:02,640
código fictício que temos aqui para ter certeza

43631
28:58:02,640 --> 28:58:05,040
funciona com c plus mais 20 mas o que eu

43632
28:58:05,040 --> 28:58:06,400
Quero que você veja

43633
28:58:06,400 --> 28:58:09,440
É que se você entrar em Bulldog vamos entrar

43634
28:58:09,440 --> 28:58:12,640
nossa classe bulldog e descomendo

43635
28:58:12,640 --> 28:58:15,512
Esta classe aqui ou este método virtual

43636
28:58:15,512 --> 28:58:16,640
nós vamos ver que nós vamos

43637
28:58:16,640 --> 28:58:18,320
obter um erro de compilador, temos um erro

43638
28:58:18,320 --> 28:58:21,120
linha significando que fizemos algo errado

43639
28:58:21,120 --> 28:58:23,760
e bem, vamos olhar para a aba de problemas

43640
28:58:23,760 --> 28:58:26,160
Código visual do estúdio aqui não pode

43641
28:58:26,160 --> 28:58:29,120
substituir encontrar uma função cão de corrida este é

43642
28:58:29,120 --> 28:58:31,120
Um método final a partir de

43643
28:58:31,120 --> 28:58:33,832
A classe do cão se tentarmos sobressí-la

43644
28:58:33,832 --> 28:58:36,080
Além disso, obteremos um erro de compilador

43645
28:58:36,080 --> 28:58:38,400
Isso é algo que podemos alcançar

43646
28:58:38,400 --> 28:58:41,912
marcando nosso método virtual tão final quanto

43647
28:58:41,912 --> 28:58:44,552
Estamos fazendo aqui agora se tentarmos construir

43648
28:58:44,552 --> 28:58:46,000
Este programa nós vamos ter um

43649
28:58:46,000 --> 28:58:48,232
Erro do compilador, vamos passar por isso

43650
28:58:48,232 --> 28:58:51,600
gcc e deixá-lo ver isso ok você vê que nós

43651
28:58:51,600 --> 28:58:54,872
obter um erro de compilador e uh o erro é

43652
28:58:54,872 --> 28:58:57,912
que estamos substituindo, vamos subir e

43653
28:58:57,912 --> 28:59:02,480
veja o erro aqui erro e na linha 12

43654
28:59:02,480 --> 28:59:05,280
em bulldog h vemos que nós somos

43655
28:59:05,280 --> 28:59:08,320
substituindo um método final virtual

43656
28:59:08,320 --> 28:59:11,600
void bulldog é uma função final e nós

43657
28:59:11,600 --> 28:59:14,000
estão substituindo isso e isso vai

43658
28:59:14,000 --> 28:59:15,680
nos dar um erro de compilador, este é o

43659
28:59:15,680 --> 28:59:17,680
comportamento que obtemos para que a mensagem aqui seja

43660
28:59:17,680 --> 28:59:19,912
que você pode ir em sua herança

43661
28:59:19,912 --> 28:59:22,320
hierarquia em qualquer nível e marcar um

43662
28:59:22,320 --> 28:59:25,360
método virtual como final e prevenir

43663
28:59:25,360 --> 28:59:27,440
baixar classes de stream a partir de

43664
28:59:27,440 --> 28:59:30,232
especializando ou substituindo esse método

43665
28:59:30,232 --> 28:59:32,400
e se eles fizerem isso, eles vão

43666
28:59:32,400 --> 28:59:34,480
obter um erro do compilador, isso é algo

43667
28:59:34,480 --> 28:59:36,080
nós podemos alcançar em nosso c plus plus

43668
28:59:36,080 --> 28:59:38,080
programar outra coisa que você pode fazer

43669
28:59:38,080 --> 28:59:40,720
O especificador final é que você pode

43670
28:59:40,720 --> 28:59:43,680
impedir que as pessoas herdem de sua

43671
28:59:43,680 --> 28:59:47,120
classe completamente, vamos ao nosso gato

43672
28:59:47,120 --> 28:59:49,040
classe Eu acho que esse é o exemplo que

43673
28:59:49,040 --> 28:59:52,000
estabelece que temos uma classe de gato que é

43674
28:59:52,000 --> 28:59:54,552
vai herdar do felino, mas

43675
28:59:54,552 --> 28:59:57,280
A classe é marcada como final

43676
28:59:57,280 --> 28:59:59,512
Agora o que isso vai fazer

43677
28:59:59,512 --> 29:00:01,600
ele vai lançar um erro de compilador

43678
29:00:01,600 --> 29:00:04,160
Sempre que alguém tenta derivar ou

43679
29:00:04,160 --> 29:00:06,232
herdar desta classe aqui, então se

43680
29:00:06,232 --> 29:00:09,040
Alguém tenta herdar do gato como nós

43681
29:00:09,040 --> 29:00:11,832
estão fazendo aqui criar um gato selvagem a partir de um

43682
29:00:11,832 --> 29:00:13,680
gato, vamos ter um erro de compilador

43683
29:00:13,680 --> 29:00:16,160
Porque não podemos herdar do gato

43684
29:00:16,160 --> 29:00:18,640
É uma classe final neste

43685
29:00:18,640 --> 29:00:22,160
momento bom, então vamos olhar para o nosso gato selvagem

43686
29:00:22,160 --> 29:00:24,640
classe que vai tentar

43687
29:00:24,640 --> 29:00:25,832
E a

43688
29:00:25,832 --> 29:00:29,192
derivam do gato que podemos fazer algo como

43689
29:00:29,192 --> 29:00:31,440
podemos remover nossos comentários aqui e

43690
29:00:31,440 --> 29:00:33,280
Se tentarmos fazer isso, vamos ter um

43691
29:00:33,280 --> 29:00:35,192
Seta do compilador vamos olhar para o cpp

43692
29:00:35,192 --> 29:00:37,440
e ver o que temos não tem nada

43693
29:00:37,440 --> 29:00:39,912
especial mas se tentarmos fazer isso e

43694
29:00:39,912 --> 29:00:42,800
Herdar de gato vamos ter um compilador

43695
29:00:42,800 --> 29:00:45,360
porque a classe de gato é final e

43696
29:00:45,360 --> 29:00:47,680
Você não pode derivar disso se você fizer isso

43697
29:00:47,680 --> 29:00:49,440
você terá um erro de compilador porque

43698
29:00:49,440 --> 29:00:52,000
A classe de gato é final isto é o que eu

43699
29:00:52,000 --> 29:00:54,320
Quer que você veja aqui vamos tentar construir

43700
29:00:54,320 --> 29:00:55,832
Nosso programa novamente vamos passar

43701
29:00:55,832 --> 29:00:58,320
Isso através do gcc e vamos ver o nosso

43702
29:00:58,320 --> 29:01:00,552
Erro do compilador ok o mundo é

43703
29:01:00,552 --> 29:01:03,120
Terminou com erros se subirmos, vamos

43704
29:01:03,120 --> 29:01:06,400
Veja que não podemos derivar de um final

43705
29:01:06,400 --> 29:01:08,640
classe base se fizermos isso, vamos ter um

43706
29:01:08,640 --> 29:01:10,552
erro do compilador e isso é o que eu quero

43707
29:01:10,552 --> 29:01:12,552
Você para ver aqui bem agora que nós notamos

43708
29:01:12,552 --> 29:01:14,720
nós vamos levar isso de volta

43709
29:01:14,720 --> 29:01:17,280
e tirar o erro do compilador aqui

43710
29:01:17,280 --> 29:01:19,360
porque queremos que o nosso código compile

43711
29:01:19,360 --> 29:01:21,512
nós vamos ter certeza de que está compilando

43712
29:01:21,512 --> 29:01:23,832
Tudo bem agora o código está compilando

43713
29:01:23,832 --> 29:01:25,832
Porque não estamos mais tentando

43714
29:01:25,832 --> 29:01:29,280
Herdar de gato e eu quero que você agora

43715
29:01:29,280 --> 29:01:32,320
Veja alguns fatos interessantes sobre o

43716
29:01:32,320 --> 29:01:35,120
Especificador final quando funciona em conjunto

43717
29:01:35,120 --> 29:01:37,512
com funções virtuais, vamos para o

43718
29:01:37,512 --> 29:01:40,000
arquivo cpp principal e mostrar-lhe o primeiro

43719
29:01:40,000 --> 29:01:42,232
E isso é que você pode criar um

43720
29:01:42,232 --> 29:01:45,360
classe imediatamente e marcar isso como vinil

43721
29:01:45,360 --> 29:01:48,160
como você o cria como fazemos aqui, se você fizer

43722
29:01:48,160 --> 29:01:50,320
Que esta classe não vai ser

43723
29:01:50,320 --> 29:01:52,800
herdável e se você tentar herdar

43724
29:01:52,800 --> 29:01:54,640
a partir dele você vai ter um erro de compilador

43725
29:01:54,640 --> 29:01:56,872
Vamos tirar tudo o que temos aqui

43726
29:01:56,872 --> 29:01:59,280
e apenas diga olá em nossa principal função

43727
29:01:59,280 --> 29:02:00,960
Isso vai fazer apenas para ter

43728
29:02:00,960 --> 29:02:02,552
Algo que isso vai nos dar a

43729
29:02:02,552 --> 29:02:04,720
Erro do compilador porque não podemos herdar

43730
29:02:04,720 --> 29:02:07,120
de uma classe final, vamos construir e mostrar

43731
29:02:07,120 --> 29:02:09,832
você o erro do compilador, isso vai fazer

43732
29:02:09,832 --> 29:02:12,160
passar por gcc e o mundo vai

43733
29:02:12,160 --> 29:02:14,960
Acabar com erros e que temos nossos

43734
29:02:14,960 --> 29:02:18,160
mensagem aqui e não temos o erro

43735
29:02:18,160 --> 29:02:21,280
esperávamos porque nos esquecemos de colocar o nosso

43736
29:02:21,280 --> 29:02:23,040
fechar ponto e vírgula na nossa classe

43737
29:02:23,040 --> 29:02:25,360
definição aqui, mas podemos construir novamente

43738
29:02:25,360 --> 29:02:28,000
e obter o nosso erro ok, o mundo é

43739
29:02:28,000 --> 29:02:29,912
Terminou com erros

43740
29:02:29,912 --> 29:02:32,080
E o erro será que nós

43741
29:02:32,080 --> 29:02:34,320
não pode derivar de uma classe final que este é

43742
29:02:34,320 --> 29:02:36,552
O que esperamos aqui vamos comentar isso

43743
29:02:36,552 --> 29:02:38,800
Porque eu só queria que você visse

43744
29:02:38,800 --> 29:02:41,600
Este fato é outra coisa interessante c

43745
29:02:41,600 --> 29:02:44,000
Plus plus permite que você faça

43746
29:02:44,000 --> 29:02:47,760
é configurar um novo método virtual em um

43747
29:02:47,760 --> 29:02:50,080
Classe final, vamos primeiro construir e fazer

43748
29:02:50,080 --> 29:02:52,720
Certifique-se que o erro do compilador aqui vai embora

43749
29:02:52,720 --> 29:02:54,720
e eu vou te mostrar que tudo bem

43750
29:02:54,720 --> 29:02:57,120
construir é bom vamos voltar em nossa final

43751
29:02:57,120 --> 29:02:59,360
Classe da classe do gato

43752
29:02:59,360 --> 29:03:02,160
Se eu me lembro corretamente, este é um final

43753
29:03:02,160 --> 29:03:04,800
classe que não podemos derivar desta classe

43754
29:03:04,800 --> 29:03:06,960
mas podemos configurar um método virtual para

43755
29:03:06,960 --> 29:03:07,912
O exemplo

43756
29:03:07,912 --> 29:03:10,872
O método virtual aqui chamado meow é

43757
29:03:10,872 --> 29:03:12,000
inúteis

43758
29:03:12,000 --> 29:03:14,480
por que é inútil é um virtual e

43759
29:03:14,480 --> 29:03:16,480
Marcando isso virtual significa que

43760
29:03:16,480 --> 29:03:19,040
Você, pelo menos, quer que as pessoas herdem de

43761
29:03:19,040 --> 29:03:21,512
esta classe para herdá-lo e usá-lo ou

43762
29:03:21,512 --> 29:03:23,360
É ainda melhor que você queira que eles tenham o

43763
29:03:23,360 --> 29:03:25,512
capacidade de se especializar

43764
29:03:25,512 --> 29:03:27,912
ou substituir este método e torná-lo para

43765
29:03:27,912 --> 29:03:30,720
fazer coisas mais especializadas, mas você não pode

43766
29:03:30,720 --> 29:03:32,720
realmente fazer isso porque você não pode obter

43767
29:03:32,720 --> 29:03:35,040
desta classe todos juntos, então isso é

43768
29:03:35,040 --> 29:03:37,280
Algo que c plus plus nos permite

43769
29:03:37,280 --> 29:03:39,600
Mas este é um método inútil que

43770
29:03:39,600 --> 29:03:42,320
nunca será usado de forma alguma, então isso é

43771
29:03:42,320 --> 29:03:43,912
Algo que eu quero que você esteja ciente, mas

43772
29:03:43,912 --> 29:03:45,760
Isso vai compilar novamente, vamos

43773
29:03:45,760 --> 29:03:47,832
passar isso através do gcc que você vai

43774
29:03:47,832 --> 29:03:49,440
Veja que isso vai compilar e

43775
29:03:49,440 --> 29:03:51,280
trabalho mesmo se este método é realmente

43776
29:03:51,280 --> 29:03:53,440
inútil quero que você esteja ciente disso

43777
29:03:53,440 --> 29:03:55,360
Tudo bem, então a construção é boa aqui bem, então

43778
29:03:55,360 --> 29:03:58,800
Este é o nosso fato interessante número dois

43779
29:03:58,800 --> 29:04:01,832
Tudo bem, mesmo que este método seja inútil

43780
29:04:01,832 --> 29:04:05,360
É possível especializar um método

43781
29:04:05,360 --> 29:04:07,832
vindo de classes upstream de seu

43782
29:04:07,832 --> 29:04:10,640
classe final, por exemplo, no felino

43783
29:04:10,640 --> 29:04:11,760


43784
29:04:11,760 --> 29:04:14,720
um método chamado run que foi introduzido

43785
29:04:14,720 --> 29:04:17,360
Lá eu acho que podemos substituir isso

43786
29:04:17,360 --> 29:04:19,760
método em nossa classe final, que é a

43787
29:04:19,760 --> 29:04:21,832
classe de gato aqui, então este método está indo

43788
29:04:21,832 --> 29:04:24,040
Para ser inútil porque será

43789
29:04:24,040 --> 29:04:26,480
Especializar o que o nosso

43790
29:04:26,480 --> 29:04:28,872
classe upstream que vai funcionar

43791
29:04:28,872 --> 29:04:31,280
Tudo bem, pois estamos olhando para alguns

43792
29:04:31,280 --> 29:04:33,440
Coisas inúteis que você pode fazer com a final

43793
29:04:33,440 --> 29:04:35,192
Combinados com o

43794
29:04:35,192 --> 29:04:38,232
mecanismos virtuais em c plus plus i want

43795
29:04:38,232 --> 29:04:40,400
para ver que é possível configurar

43796
29:04:40,400 --> 29:04:44,080
um método virtual e marcá-lo como um final

43797
29:04:44,080 --> 29:04:46,232
na mesma declaração e nós vamos

43798
29:04:46,232 --> 29:04:48,160
para ir para a classe de pássaros e realmente mostrar

43799
29:04:48,160 --> 29:04:49,912
Você que, por exemplo

43800
29:04:49,912 --> 29:04:52,552
temos um método virtual chamado

43801
29:04:52,552 --> 29:04:55,832
voar, mas isso é marcado final o momento

43802
29:04:55,832 --> 29:04:57,512
nós declaramos e isso vai ser

43803
29:04:57,512 --> 29:04:59,832
Contrariado, por exemplo, o virtual

43804
29:04:59,832 --> 29:05:02,400
palavra-chave significa que as pessoas downstream

43805
29:05:02,400 --> 29:05:04,400
será capaz de especializar isso ou

43806
29:05:04,400 --> 29:05:07,512
herdar isso, mas ao mesmo tempo somos

43807
29:05:07,512 --> 29:05:09,680
Marcando esse cara como final, então estamos

43808
29:05:09,680 --> 29:05:12,720
Dizer que ninguém downstream será capaz de

43809
29:05:12,720 --> 29:05:14,872
substituir este método se eles fizerem isso

43810
29:05:14,872 --> 29:05:17,600
eles receberão um erro de compilador agora que

43811
29:05:17,600 --> 29:05:19,832
Um deles vai ganhar virtual ou final

43812
29:05:19,832 --> 29:05:21,832
A final vai ganhar porque se você tentar

43813
29:05:21,832 --> 29:05:24,160
para substituir este método em downstream

43814
29:05:24,160 --> 29:05:26,400
classes que você receberá um erro de compilador

43815
29:05:26,400 --> 29:05:29,440
vamos descer e olhar para um pássaro nós

43816
29:05:29,440 --> 29:05:31,912
Pode ter em nosso programa, por exemplo,

43817
29:05:31,912 --> 29:05:34,000
pode ter um pombo vamos pegar isso

43818
29:05:34,000 --> 29:05:35,680
método e tente substituir você

43819
29:05:35,680 --> 29:05:37,120
Vou ver que nós temos um compilador

43820
29:05:37,120 --> 29:05:39,440
erro, vamos entrar em pidgin e

43821
29:05:39,440 --> 29:05:41,912
colocar no método fly e uh por exemplo

43822
29:05:41,912 --> 29:05:44,160
nós vamos dizer que o pombo voe aqui e

43823
29:05:44,160 --> 29:05:46,080
nós vamos dizer que anular estamos

43824
29:05:46,080 --> 29:05:48,080
tentando substituir este método, mas nós estamos

43825
29:05:48,080 --> 29:05:49,680
obter um erro de compilador que você vê

43826
29:05:49,680 --> 29:05:51,512
ter uma linha muito lenta porque este é um

43827
29:05:51,512 --> 29:05:53,912
Método final e estamos tentando

43828
29:05:53,912 --> 29:05:57,120
substituir isso em uma classe downstream

43829
29:05:57,120 --> 29:06:00,080
e esta classe é uma classe downstream

43830
29:06:00,080 --> 29:06:03,360
do pássaro e no pássaro mapeamos este método

43831
29:06:03,360 --> 29:06:05,440
como final para que isso não funcione

43832
29:06:05,440 --> 29:06:07,440
Mesmo que isso seja virtual, você quer ser

43833
29:06:07,440 --> 29:06:10,232
capaz de realmente usar o mecanismo virtual

43834
29:06:10,232 --> 29:06:12,552
Porque isso é final se tentarmos

43835
29:06:12,552 --> 29:06:15,192
herdar disso se tentarmos substituir

43836
29:06:15,192 --> 29:06:17,360
assim como estamos fazendo no pombo aqui nós

43837
29:06:17,360 --> 29:06:19,512
obterá o erro do compilador, vamos tentar

43838
29:06:19,512 --> 29:06:21,600
e construir o nosso programa e vamos ver

43839
29:06:21,600 --> 29:06:24,160
que obremos nosso erro de compilação confiável

43840
29:06:24,160 --> 29:06:25,760
A bala vai terminar com

43841
29:06:25,760 --> 29:06:28,400
erros e se subirmos, vamos

43842
29:06:28,400 --> 29:06:30,960
Encontre o nosso erro, vamos dizer

43843
29:06:30,960 --> 29:06:33,912
Função virtual fly sobresto final

43844
29:06:33,912 --> 29:06:36,800
Função que estamos substituindo uma final

43845
29:06:36,800 --> 29:06:39,040
método virtual e isso vai dar

43846
29:06:39,040 --> 29:06:40,960
Nós, um erro do compilador, não podemos fazer isso

43847
29:06:40,960 --> 29:06:42,800
Isso é algo que você pode fazer em seu c

43848
29:06:42,800 --> 29:06:44,800
mais além de programa, então isso é realmente

43849
29:06:44,800 --> 29:06:47,512
confuso porque no pássaro o virtual

43850
29:06:47,512 --> 29:06:49,512
A palavra-chave sugere que você realmente pode

43851
29:06:49,512 --> 29:06:52,000
especializar isso em classe downstream, mas

43852
29:06:52,000 --> 29:06:54,320
isso é contraditório e c plus plus

43853
29:06:54,320 --> 29:06:55,912
permite que você faça isso que você precisa ser

43854
29:06:55,912 --> 29:06:58,000
consciente disso novamente se não substituirmos

43855
29:06:58,000 --> 29:07:00,080
Isso e deixar isso no código está indo

43856
29:07:00,080 --> 29:07:02,960
para compilar, mas na minha opinião isso é

43857
29:07:02,960 --> 29:07:05,120
Realmente confuso e você precisa ser

43858
29:07:05,120 --> 29:07:06,720
Conscientes disto que é o objectivo de

43859
29:07:06,720 --> 29:07:08,400
Esta palestra aqui vamos ter certeza de que

43860
29:07:08,400 --> 29:07:10,800
O código está sendo construído e isso é realmente tudo

43861
29:07:10,800 --> 29:07:13,120
Eu tive que compartilhar nesta palestra

43862
29:07:13,120 --> 29:07:15,360
Apresentar a palavra-chave final para você

43863
29:07:15,360 --> 29:07:17,832
pode usá-lo para restringir a forma como as pessoas

43864
29:07:17,832 --> 29:07:20,872
substituir sua função virtual ou você

43865
29:07:20,872 --> 29:07:22,960
pode usá-lo para restringir

43866
29:07:22,960 --> 29:07:25,440
pessoas de herdar de sua classe

43867
29:07:25,440 --> 29:07:28,080
completamente e usar essas coisas se

43868
29:07:28,080 --> 29:07:30,552
Faça sentido para qualquer aplicação que você

43869
29:07:30,552 --> 29:07:33,440
estamos projetando com c plus plus que somos

43870
29:07:33,440 --> 29:07:35,280
Vou parar aqui nesta palestra e

43871
29:07:35,280 --> 29:07:37,192
O próximo eu vou te mostrar um

43872
29:07:37,192 --> 29:07:39,832
Segredo que você provavelmente não sabia, então vá

43873
29:07:39,832 --> 29:07:42,000
Na frente e terminar aqui e me encontrar

43874
29:07:42,000 --> 29:07:43,832
lá nesta palestra vamos

43875
29:07:43,832 --> 29:07:46,320
Explorar como funciona ou

43876
29:07:46,320 --> 29:07:48,960
O polimorfismo joga com padrão

43877
29:07:48,960 --> 29:07:51,280
argumentos e quando dizemos padrão

43878
29:07:51,280 --> 29:07:53,680
argumentos queremos dizer uma configuração como esta nós

43879
29:07:53,680 --> 29:07:55,680
ter uma função virtual aqui que é

43880
29:07:55,680 --> 29:07:58,400
chamado adicione, ele vai retornar o dobro

43881
29:07:58,400 --> 29:07:59,760
E ele tem

43882
29:07:59,760 --> 29:08:02,640
parâmetros padrão aqui para a e b e

43883
29:08:02,640 --> 29:08:05,360
O valor é cinco aqui em nosso

43884
29:08:05,360 --> 29:08:07,760
classe também temos a mesma função

43885
29:08:07,760 --> 29:08:10,320
estamos substituindo isso e nós temos um

43886
29:08:10,320 --> 29:08:13,512
diferentes valores que atuam como nossos

43887
29:08:13,512 --> 29:08:15,832
parâmetro padrão aqui estamos usando 10

43888
29:08:15,832 --> 29:08:19,040
para a e b aqui e queremos ver como

43889
29:08:19,040 --> 29:08:21,832
isso brinca com o polimorfismo agora por favor

43890
29:08:21,832 --> 29:08:24,160
Note que com polimorfismo se formos

43891
29:08:24,160 --> 29:08:26,160
através de um ponteiro base para gerenciar um

43892
29:08:26,160 --> 29:08:29,512
objeto de classe derivado o que queremos é

43893
29:08:29,512 --> 29:08:32,320
chamar a implementação mais específica de

43894
29:08:32,320 --> 29:08:34,720
A função virtual aqui, por exemplo, se

43895
29:08:34,720 --> 29:08:37,592
temos um ponteiro base gerenciando um

43896
29:08:37,592 --> 29:08:40,552
objeto derivado e chamamos o add

43897
29:08:40,552 --> 29:08:43,280
método de um ponteiro de base que obteremos

43898
29:08:43,280 --> 29:08:46,160
O método mais específico aqui chamado

43899
29:08:46,160 --> 29:08:48,720
mas o que você obtém com estes padrões

43900
29:08:48,720 --> 29:08:51,280
Argumentos é que o compilador está indo

43901
29:08:51,280 --> 29:08:54,640
usar a ligação estática para decidir quais

43902
29:08:54,640 --> 29:08:56,400
parâmetros padrão para passar para o seu

43903
29:08:56,400 --> 29:08:58,872
funcionar assim mesmo se você conseguir isso

43904
29:08:58,872 --> 29:09:01,440
método aqui chamado compilador irá

43905
29:09:01,440 --> 29:09:04,320
ainda usar os argumentos padrão que temos

43906
29:09:04,320 --> 29:09:06,720
em nossa classe base, então vamos chamar isso

43907
29:09:06,720 --> 29:09:09,040
método aqui, mas vamos usar o padrão

43908
29:09:09,040 --> 29:09:11,760
argumentos provenientes da classe base e

43909
29:09:11,760 --> 29:09:13,592
Este é o comportamento que você precisa ser

43910
29:09:13,592 --> 29:09:15,912
consciente de OK, então outra maneira de colocar isso

43911
29:09:15,912 --> 29:09:18,800
é que os argumentos padrão são tratados em

43912
29:09:18,800 --> 29:09:21,192
Tempo de compilação que o compilador está indo para

43913
29:09:21,192 --> 29:09:23,512
fio essas coisas em tempo de compilação onde

43914
29:09:23,512 --> 29:09:25,760
Você está construindo sua aplicação

43915
29:09:25,760 --> 29:09:28,232
e as funções virtuais são chamadas em

43916
29:09:28,232 --> 29:09:31,280
tempo de execução com polimorfismo, por isso, se você usar

43917
29:09:31,280 --> 29:09:33,440
argumentos padrão com funções virtuais

43918
29:09:33,440 --> 29:09:35,832
Você pode obter resultados estranhos com

43919
29:09:35,832 --> 29:09:38,160
Polimorfismo porque o padrão

43920
29:09:38,160 --> 29:09:40,400
argumentos que você vai usar estão indo para

43921
29:09:40,400 --> 29:09:43,592
ser decidido por ligação estática, mas

43922
29:09:43,592 --> 29:09:45,512
A função real que você recebe chamada é

43923
29:09:45,512 --> 29:09:48,400
será decidido por encadernação dinâmica

43924
29:09:48,400 --> 29:09:50,800
Então vamos chamar a função virtual em

43925
29:09:50,800 --> 29:09:53,280
nossa classe derivada, mas usaremos

43926
29:09:53,280 --> 29:09:55,512
os argumentos padrão da base

43927
29:09:55,512 --> 29:09:57,592
classe Esta é o comportamento que vamos ter você

43928
29:09:57,592 --> 29:09:59,760
precisa estar ciente disso e ter certeza

43929
29:09:59,760 --> 29:10:02,232
Isto é o que você deseja o meu pessoal

43930
29:10:02,232 --> 29:10:04,320
A preferência é não usar o padrão

43931
29:10:04,320 --> 29:10:06,480
parâmetros ou argumentos padrão com

43932
29:10:06,480 --> 29:10:08,552
funções virtuais porque isso é realmente

43933
29:10:08,552 --> 29:10:10,552
Vou tornar meu código difícil de seguir e

43934
29:10:10,552 --> 29:10:13,120
É difícil de entender especialmente para outros

43935
29:10:13,120 --> 29:10:15,280
desenvolvedores que podem ter que trabalhar no meu

43936
29:10:15,280 --> 29:10:17,912
base de código no futuro ok aqui é um

43937
29:10:17,912 --> 29:10:20,000
exemplo simples temos um ponteiro base

43938
29:10:20,000 --> 29:10:22,232
que vai estar gerenciando um derivado

43939
29:10:22,232 --> 29:10:25,120
objeto e vamos chamar a função add

43940
29:10:25,120 --> 29:10:27,592
Aqui o que esperamos para ficar bem

43941
29:10:27,592 --> 29:10:29,760
porque temos o polimorfismo aqui nós

43942
29:10:29,760 --> 29:10:32,400
chamar a função de adição mais específica

43943
29:10:32,400 --> 29:10:34,552
Aqui e isso vai ser o add

43944
29:10:34,552 --> 29:10:37,760
função de nossa classe derivada

43945
29:10:37,760 --> 29:10:40,160
mas o argumento padrão que passamos não são

43946
29:10:40,160 --> 29:10:42,720
será decidido pela classe derivada

43947
29:10:42,720 --> 29:10:44,400
Os argumentos padrão serão

43948
29:10:44,400 --> 29:10:47,040
conectado em tempo de compilação usando estática

43949
29:10:47,040 --> 29:10:49,832
vinculação assim porque o ponteiro de base é um

43950
29:10:49,832 --> 29:10:52,232
objeto base, estaremos usando o padrão

43951
29:10:52,232 --> 29:10:54,160
argumentos da implementação da base

43952
29:10:54,160 --> 29:10:56,480
do método add para que vamos apenas plug

43953
29:10:56,480 --> 29:10:59,192
em cinco e cinco, então adicionaremos cinco a

43954
29:10:59,192 --> 29:11:02,232
cinco e adicionar um dois, é por isso que temos um

43955
29:11:02,232 --> 29:11:04,400
12 aqui mesmo

43956
29:11:04,400 --> 29:11:06,872
e se passarmos por essas referências,

43957
29:11:06,872 --> 29:11:09,280
obterá o mesmo resultado, porque isso é

43958
29:11:09,280 --> 29:11:12,720
ativar ou desencadear polimórfico

43959
29:11:12,720 --> 29:11:15,912
comportamento em nossos programas c+ se formos

43960
29:11:15,912 --> 29:11:18,552
através de objetos diretos estaremos fazendo

43961
29:11:18,552 --> 29:11:21,040
ligação estática e vamos usar o

43962
29:11:21,040 --> 29:11:23,360
argumentos padrão ou parâmetros do dispositivo

43963
29:11:23,360 --> 29:11:25,680
do nosso objeto derivado e lembre-se

43964
29:11:25,680 --> 29:11:27,680
que usamos o valor de 10 lá, então

43965
29:11:27,680 --> 29:11:30,160
Vamos adicionar 10 a 10 e adicionar um 2

43966
29:11:30,160 --> 29:11:32,480
e nós vamos ter um 22 como você vê

43967
29:11:32,480 --> 29:11:35,440
aqui através de ligação estática se fizermos

43968
29:11:35,440 --> 29:11:38,552
cortar atribuindo um objeto derivado a

43969
29:11:38,552 --> 29:11:41,280
um objeto base, a informação derivada é

43970
29:11:41,280 --> 29:11:44,160
vai ser cortado fora e se nós adicionarmos nós

43971
29:11:44,160 --> 29:11:46,480
usará os parâmetros padrão do

43972
29:11:46,480 --> 29:11:48,640
classe base e vamos usar o

43973
29:11:48,640 --> 29:11:51,040
implementação na classe base assim se

43974
29:11:51,040 --> 29:11:53,760
Voltamos ao nosso código aqui vamos

43975
29:11:53,760 --> 29:11:55,760
usar os argumentos padrão da base

43976
29:11:55,760 --> 29:11:57,760
classe e isso é um cinco e um cinco que somos

43977
29:11:57,760 --> 29:11:59,680
Vou adicioná-los porque o corpo é

43978
29:11:59,680 --> 29:12:02,080
vai ser da classe base lembre-se

43979
29:12:02,080 --> 29:12:04,080
A informação derivada tem sido

43980
29:12:04,080 --> 29:12:07,120
completamente cortados, então nós vamos

43981
29:12:07,120 --> 29:12:09,040
Adicione um cinco e um e um e um

43982
29:12:09,040 --> 29:12:11,360
Vamos ter 11 impressos se nós

43983
29:12:11,360 --> 29:12:14,480
fazer fatiar e esse é o resultado que obtemos

43984
29:12:14,480 --> 29:12:16,640
Aqui como uma nota de encerramento antes de nós

43985
29:12:16,640 --> 29:12:19,120
cabeça para o código do estúdio visual novamente

43986
29:12:19,120 --> 29:12:21,192
argumentos padrão com funções virtuais

43987
29:12:21,192 --> 29:12:23,440
Pode ser muito confuso, eles são os melhores

43988
29:12:23,440 --> 29:12:25,680
Evitar porque eles realmente vão

43989
29:12:25,680 --> 29:12:28,320
dar um tempo difícil para qualquer um que é

43990
29:12:28,320 --> 29:12:30,232
Vou trabalhar no seu código no

43991
29:12:30,232 --> 29:12:31,832
Futuro agora que você sabe disso, nós somos

43992
29:12:31,832 --> 29:12:33,832
indo para ir para o código do estúdio visual

43993
29:12:33,832 --> 29:12:35,440
e brincar com isso um pouco mais aqui

43994
29:12:35,440 --> 29:12:38,080
estão em nossa pasta de trabalho a atual

43995
29:12:38,080 --> 29:12:40,552
O projeto é uma função virtual com

43996
29:12:40,552 --> 29:12:42,400
argumentos padrão que vamos pegar

43997
29:12:42,400 --> 29:12:45,040
o código do nosso projeto de modelo que somos

43998
29:12:45,040 --> 29:12:47,040
Vou copiar isso e colocar isso no

43999
29:12:47,040 --> 29:12:49,680
Projeto atual e eu vou pegar

44000
29:12:49,680 --> 29:12:52,232
minha base de classes e derivadas de que somos

44001
29:12:52,232 --> 29:12:54,640
Vou usar aqui se você não quiser

44002
29:12:54,640 --> 29:12:56,800
para digitar junto você pode pegar a fonte

44003
29:12:56,800 --> 29:12:59,040
código da seção de recursos do

44004
29:12:59,040 --> 29:13:00,000
O curso

44005
29:13:00,000 --> 29:13:01,680
se você não quiser digitar tudo isso

44006
29:13:01,680 --> 29:13:04,160
classes ou criá-los você pode pegar o

44007
29:13:04,160 --> 29:13:07,192
código fonte da seção de recursos em

44008
29:13:07,192 --> 29:13:08,552
Esta palestra você vai baixar

44009
29:13:08,552 --> 29:13:10,552
Isso e use isso que você não precisa

44010
29:13:10,552 --> 29:13:12,720
perder tempo digitando essas coisas porque

44011
29:13:12,720 --> 29:13:15,120
Muitas dessas coisas já estão

44012
29:13:15,120 --> 29:13:17,280
familiar para você, vamos abrir isso

44013
29:13:17,280 --> 29:13:19,040
em código de estúdio visual e nós vamos

44014
29:13:19,040 --> 29:13:21,360
Temos nossas aulas aqui, temos uma base

44015
29:13:21,360 --> 29:13:23,440
classe que vai ter um virtual

44016
29:13:23,440 --> 29:13:24,552
A função

44017
29:13:24,552 --> 29:13:25,440
em

44018
29:13:25,440 --> 29:13:28,400
um par de argumentos padrão aqui estamos

44019
29:13:28,400 --> 29:13:31,192
usando 5 5 em nosso anúncio

44020
29:13:31,192 --> 29:13:33,120
Função virtual aqui

44021
29:13:33,120 --> 29:13:35,440
E se formos e derivamos, ele vai

44022
29:13:35,440 --> 29:13:38,000
derivam publicamente da base e é

44023
29:13:38,000 --> 29:13:40,232
indo para substituir o nosso

44024
29:13:40,232 --> 29:13:42,872
Função virtual aqui, mas note que

44025
29:13:42,872 --> 29:13:45,040
vai criar o seu próprio

44026
29:13:45,040 --> 29:13:47,192
parâmetros padrão, portanto, se fizermos

44027
29:13:47,192 --> 29:13:49,040
O polimorfismo

44028
29:13:49,040 --> 29:13:51,192
e usar o ponteiro base para chamar o add

44029
29:13:51,192 --> 29:13:53,440
método aqui vamos obter o máximo

44030
29:13:53,440 --> 29:13:56,872
A versão específica ou mais especializada

44031
29:13:56,872 --> 29:13:58,960
do método add chamado e este é

44032
29:13:58,960 --> 29:14:01,040
Vou chamar esse corpo aqui

44033
29:14:01,040 --> 29:14:03,592
Mas os parâmetros vão ser

44034
29:14:03,592 --> 29:14:06,400
decidido pela ligação estática assim porque nós

44035
29:14:06,400 --> 29:14:08,960
passará por um ponteiro base que nós

44036
29:14:08,960 --> 29:14:11,192
usará os argumentos padrão do

44037
29:14:11,192 --> 29:14:13,832
classe base que vai ser cinco cinco

44038
29:14:13,832 --> 29:14:15,120
e nós vamos brincar com isso e

44039
29:14:15,120 --> 29:14:17,192
Veja o que isso vai nos dar no

44040
29:14:17,192 --> 29:14:19,912
arquivo principal do cpp aqui vamos limpar um

44041
29:14:19,912 --> 29:14:21,120
Um pouco nós vamos remover

44042
29:14:21,120 --> 29:14:23,192
O que não precisamos aqui

44043
29:14:23,192 --> 29:14:25,680
e vamos incluir o nosso derivado

44044
29:14:25,680 --> 29:14:28,160
classe que podemos fazer que vamos colocar

44045
29:14:28,160 --> 29:14:30,552
em nosso código para realmente brincar com a gente, vamos

44046
29:14:30,552 --> 29:14:32,552
remover esses espaços porque não

44047
29:14:32,552 --> 29:14:34,720
Precisamos deles, vamos passar por um

44048
29:14:34,720 --> 29:14:37,440
ponto de referência para gerenciar um objeto derivado

44049
29:14:37,440 --> 29:14:39,760
e esta é uma configuração que podemos usar para colocar

44050
29:14:39,760 --> 29:14:41,832
As coisas no lugar aqui nós vamos

44051
29:14:41,832 --> 29:14:44,160
chamar o aviso de adição de método que nós somos

44052
29:14:44,160 --> 29:14:46,720
não passar em nenhum parâmetro porque nós

44053
29:14:46,720 --> 29:14:48,960
estão passando por um ponteiro de base e a

44054
29:14:48,960 --> 29:14:51,080
O método add é virtual

44055
29:14:51,080 --> 29:14:53,592
O polimorfismo entrará em ação e nós vamos

44056
29:14:53,592 --> 29:14:55,680
obter a versão derivada

44057
29:14:55,680 --> 29:14:59,440
de nosso código de função adicionar para que possamos chamar

44058
29:14:59,440 --> 29:15:02,000
esta função adiciona aqui, mas

44059
29:15:02,000 --> 29:15:04,232
Tenha cuidado porque queremos usar

44060
29:15:04,232 --> 29:15:06,872
esses parâmetros padrão aqui, se o fizermos

44061
29:15:06,872 --> 29:15:10,320
gostaríamos de adicionar um 10 para um 10 e chegar a 22

44062
29:15:10,320 --> 29:15:12,720
em nossa principal função aqui, mas isso não é

44063
29:15:12,720 --> 29:15:14,960
Será o caso que o compilador é

44064
29:15:14,960 --> 29:15:17,512
usar a ligação estática para decidir

44065
29:15:17,512 --> 29:15:20,080
Quais parâmetros padrão para usar

44066
29:15:20,080 --> 29:15:22,080
aqueles na classe base ou aqueles na

44067
29:15:22,080 --> 29:15:24,480
classe derivada e note que se nós

44068
29:15:24,480 --> 29:15:26,872
passar o mouse sobre esta função que você vê

44069
29:15:26,872 --> 29:15:29,360
que o compilador tenha conectado aqueles

44070
29:15:29,360 --> 29:15:31,280
da classe base e é isso que

44071
29:15:31,280 --> 29:15:32,800
O compilador vai fazer isso indo

44072
29:15:32,800 --> 29:15:35,280
para adicionar um cinco a um cinco e está indo

44073
29:15:35,280 --> 29:15:37,280
para adicionar dois a isso eu acho que é isso que

44074
29:15:37,280 --> 29:15:40,552
Estamos fazendo em nossa versão derivada e

44075
29:15:40,552 --> 29:15:43,192
Vamos começar a 12 impressos

44076
29:15:43,192 --> 29:15:45,512
Vamos construir e ver se isso é realmente

44077
29:15:45,512 --> 29:15:46,872
O caso vamos passar por isso

44078
29:15:46,872 --> 29:15:48,552
através do gcc

44079
29:15:48,552 --> 29:15:51,040
e esse é o compilador que é nosso

44080
29:15:51,040 --> 29:15:53,192
favorito agora que o livro vai ser

44081
29:15:53,192 --> 29:15:55,680
Bom podemos fechar isso e trazer uma

44082
29:15:55,680 --> 29:15:58,720
janela powershell e se corremos o galo

44083
29:15:58,720 --> 29:16:00,800
nós vamos ver que o anúncio chegou

44084
29:16:00,800 --> 29:16:03,680
foi chamado e o resultado foi 12 aqui

44085
29:16:03,680 --> 29:16:05,760
É isso que temos de novo

44086
29:16:05,760 --> 29:16:08,080
o compilador vai chamar mais

44087
29:16:08,080 --> 29:16:11,512
substituição de função virtual especializada

44088
29:16:11,512 --> 29:16:14,320
Aqui, mas ele vai usar o padrão

44089
29:16:14,320 --> 29:16:16,400
parâmetros da classe base que você

44090
29:16:16,400 --> 29:16:18,872
deve realmente notar isso e isso pode

44091
29:16:18,872 --> 29:16:20,960
Na verdade, seja confuso, especialmente se você

44092
29:16:20,960 --> 29:16:24,640
Somos um iniciante para o polimorfismo se formos

44093
29:16:24,640 --> 29:16:27,040
através de uma referência de base, também

44094
29:16:27,040 --> 29:16:29,360
obter comportamento polimórfico

44095
29:16:29,360 --> 29:16:31,760
Se tivermos um objeto derivado e

44096
29:16:31,760 --> 29:16:34,232
estabelecer uma referência ao que é de

44097
29:16:34,232 --> 29:16:36,640
digite base e nós passamos por essa base

44098
29:16:36,640 --> 29:16:38,720
referência e chamado o método de adicionar nós

44099
29:16:38,720 --> 29:16:40,640
obterá o add mais especializado

44100
29:16:40,640 --> 29:16:42,480
Versão chamada assim que vai ser

44101
29:16:42,480 --> 29:16:46,552
derivado e mas vamos usar o padrão

44102
29:16:46,552 --> 29:16:48,872
parâmetros da classe base porque

44103
29:16:48,872 --> 29:16:50,872
quais argumentos padrão que usamos são

44104
29:16:50,872 --> 29:16:54,160
decidido usando a ligação estática que é

44105
29:16:54,160 --> 29:16:56,160
O que temos aqui e estúdio oficial

44106
29:16:56,160 --> 29:16:58,160
O código é realmente útil aqui, porque se

44107
29:16:58,160 --> 29:17:00,232
nós pairamos sobre a função de adição que somos

44108
29:17:00,232 --> 29:17:02,480
ver quais parâmetros padrão

44109
29:17:02,480 --> 29:17:04,640
estavam conectados pelo compilador e você

44110
29:17:04,640 --> 29:17:06,960
Veja que eles são aqueles da base

44111
29:17:06,960 --> 29:17:09,120
classe, então vamos novamente adicionar cinco

44112
29:17:09,120 --> 29:17:11,360
para um cinco e vamos adicionar dois

44113
29:17:11,360 --> 29:17:14,480
e vamos ter 12 impressos aqui se

44114
29:17:14,480 --> 29:17:16,320
fervemos e corremos, vamos ver isso

44115
29:17:16,320 --> 29:17:18,800
Este é o caso da construção é boa

44116
29:17:18,800 --> 29:17:20,000
pode limpar

44117
29:17:20,000 --> 29:17:21,912
e correr o galo, vamos ver isso

44118
29:17:21,912 --> 29:17:23,680
com uma referência de base, também estamos indo

44119
29:17:23,680 --> 29:17:26,872
para obter um 12. vamos obter o máximo

44120
29:17:26,872 --> 29:17:28,232
específicos

44121
29:17:28,232 --> 29:17:31,360
implementação do método add chamado

44122
29:17:31,360 --> 29:17:33,832
mas vamos ligar o padrão

44123
29:17:33,832 --> 29:17:35,912
parâmetros da classe base i realmente

44124
29:17:35,912 --> 29:17:38,872
Queria que isso ficasse super claro se você definir

44125
29:17:38,872 --> 29:17:40,720
levantar as coisas de uma forma que você vai

44126
29:17:40,720 --> 29:17:43,360
obter ligação estática, em seguida, se você estiver indo

44127
29:17:43,360 --> 29:17:45,832
através de um objeto base, você chamará de

44128
29:17:45,832 --> 29:17:48,080
versão base do método add e você

44129
29:17:48,080 --> 29:17:50,232
usará os parâmetros padrão do

44130
29:17:50,232 --> 29:17:52,080
classe base se acontecer de você ser

44131
29:17:52,080 --> 29:17:54,960
manipular um objeto derivado você vai

44132
29:17:54,960 --> 29:17:57,280
Use a informação na classe derivada

44133
29:17:57,280 --> 29:17:59,512
A versão derivada do método add é

44134
29:17:59,512 --> 29:18:01,280
Vou ser chamado e nós vamos

44135
29:18:01,280 --> 29:18:03,680
Use o argumento padrão do

44136
29:18:03,680 --> 29:18:06,960
classe derivada, então se configurarmos outro

44137
29:18:06,960 --> 29:18:09,192
Exemplo aqui podemos configurar um objeto base

44138
29:18:09,192 --> 29:18:11,592
Por exemplo, vamos dizer base e

44139
29:18:11,592 --> 29:18:13,040
Diga base

44140
29:18:13,040 --> 29:18:16,232
3 podemos fazer isso e tentamos chamar o

44141
29:18:16,232 --> 29:18:19,120
adicionar método, podemos dizer base 3 e dizer adicionar

44142
29:18:19,120 --> 29:18:21,192
Podemos tentar armazenar isso em nosso

44143
29:18:21,192 --> 29:18:23,360
variável de pesquisa e podemos imprimir isso

44144
29:18:23,360 --> 29:18:26,080
fora nós vamos dizer sdbcl row

44145
29:18:26,080 --> 29:18:28,480
Pesquise podemos dizer algo assim

44146
29:18:28,480 --> 29:18:30,552
e vamos imprimir o resultado

44147
29:18:30,552 --> 29:18:32,480
Aqui, se construirmos e corrermos, vamos

44148
29:18:32,480 --> 29:18:34,480
Veja que isso vai chamar

44149
29:18:34,480 --> 29:18:36,800
a versão base do método add e

44150
29:18:36,800 --> 29:18:38,232
ele vai usar o padrão

44151
29:18:38,232 --> 29:18:40,960
parâmetros da base se voltarmos

44152
29:18:40,960 --> 29:18:42,720
para a base, vamos ver que estamos

44153
29:18:42,720 --> 29:18:46,000
vamos adicionar um 5 a 5 e nós vamos ter

44154
29:18:46,000 --> 29:18:49,040
11 porque vamos ligar um 1 e

44155
29:18:49,040 --> 29:18:51,512
Retorne o resultado aqui, vamos construir e

44156
29:18:51,512 --> 29:18:53,592
correr e ver que esta é realmente a

44157
29:18:53,592 --> 29:18:55,832
Caso assim vai ser completamente

44158
29:18:55,832 --> 29:18:58,800
fazendo a ligação estática, vamos limpar e correr

44159
29:18:58,800 --> 29:19:00,400
Você vê que o mundo é bom

44160
29:19:00,400 --> 29:19:02,160
indo para o restaurante e nós vamos ter

44161
29:19:02,160 --> 29:19:04,400
11 impresso aqui espero que você possa

44162
29:19:04,400 --> 29:19:07,680
Veja isso se você atribuir um objeto derivado

44163
29:19:07,680 --> 29:19:08,552
A sua forma de

44164
29:19:08,552 --> 29:19:11,680
um objeto base que você terá cortando

44165
29:19:11,680 --> 29:19:14,000
Vamos ver que nós podemos realmente fazer isso

44166
29:19:14,000 --> 29:19:16,800
Mas antes de fazermos isso eu também quero que você

44167
29:19:16,800 --> 29:19:19,040
Veja que você também pode fazer

44168
29:19:19,040 --> 29:19:22,232
linha direta de objetos de classes derivadas se

44169
29:19:22,232 --> 29:19:24,000
Você faz isso você vai

44170
29:19:24,000 --> 29:19:26,320
obter as informações do derivado

44171
29:19:26,320 --> 29:19:28,232
Classe vamos usar o corpo a partir do

44172
29:19:28,232 --> 29:19:30,872
classe derivada e vamos usar o

44173
29:19:30,872 --> 29:19:32,640
Parâmetros padrão do derivado

44174
29:19:32,640 --> 29:19:35,680
classe então vamos levar 10 e adicionar um 10

44175
29:19:35,680 --> 29:19:37,832
e vamos adicionar o 2 a isso e nós

44176
29:19:37,832 --> 29:19:40,800
vai ter um 22 impresso para fora Eu acho que podemos

44177
29:19:40,800 --> 29:19:42,480
Faz isto

44178
29:19:42,480 --> 29:19:43,280
Então,

44179
29:19:43,280 --> 29:19:45,760
Vamos colocar um separador porque isso é

44180
29:19:45,760 --> 29:19:47,832
tornar mais fácil seguir estes

44181
29:19:47,832 --> 29:19:50,160
comprimentos e vamos construir com

44182
29:19:50,160 --> 29:19:52,640
o gcc os dois vai ser bom

44183
29:19:52,640 --> 29:19:53,832
Esperamos que

44184
29:19:53,832 --> 29:19:56,160
O volume é bom, podemos limpar

44185
29:19:56,160 --> 29:19:58,080
e correr o galo e nós vamos ver

44186
29:19:58,080 --> 29:20:01,512
que temos um 22 aqui se atribuirmos um

44187
29:20:01,512 --> 29:20:04,552
objeto derivado para um objeto base diretamente

44188
29:20:04,552 --> 29:20:06,640
Fazendo algo como este evento

44189
29:20:06,640 --> 29:20:09,040
Não preciso desse cara aqui

44190
29:20:09,040 --> 29:20:12,400
podemos remover isso, temos um objeto base

44191
29:20:12,400 --> 29:20:15,040
que estamos nos preparando aqui e estamos

44192
29:20:15,040 --> 29:20:17,512
Atribuindo um objeto derivado a essa base

44193
29:20:17,512 --> 29:20:18,800
O objeto aqui

44194
29:20:18,800 --> 29:20:21,440
Se chamarmos o método add, vamos receber

44195
29:20:21,440 --> 29:20:24,080
a versão da classe base porque

44196
29:20:24,080 --> 29:20:26,480
mente seus passos isso vai cortar

44197
29:20:26,480 --> 29:20:29,120
de todas as informações derivadas, porque

44198
29:20:29,120 --> 29:20:31,040
Não estamos passando por qualquer tipo de

44199
29:20:31,040 --> 29:20:32,960
base ou referência para que isso vá

44200
29:20:32,960 --> 29:20:35,680
cortar todas as informações que temos em

44201
29:20:35,680 --> 29:20:37,192
o derivado

44202
29:20:37,192 --> 29:20:39,760
Objeto aqui e ficaremos com o

44203
29:20:39,760 --> 29:20:42,552
informações básicas e se chamarmos o add

44204
29:20:42,552 --> 29:20:44,720
A função aqui você vê que estamos usando

44205
29:20:44,720 --> 29:20:46,480
os parâmetros padrão da base

44206
29:20:46,480 --> 29:20:49,680
classe e usaremos o corpo do

44207
29:20:49,680 --> 29:20:51,912
implementação de classe base aqui, então nós

44208
29:20:51,912 --> 29:20:54,872
adicionaremos um 5 a 5 e adicionaremos 1 a

44209
29:20:54,872 --> 29:20:57,592
Isso e vamos receber 11 impressos como

44210
29:20:57,592 --> 29:20:59,680
Vemos aqui vamos construir e realmente

44211
29:20:59,680 --> 29:21:01,120
Prove que vamos passar isso

44212
29:21:01,120 --> 29:21:02,960
através do gcc o mundo vai ser

44213
29:21:02,960 --> 29:21:05,512
Bom podemos limpar e correr galo e nós

44214
29:21:05,512 --> 29:21:07,760
Vamos ver que o resultado é

44215
29:21:07,760 --> 29:21:11,040
irreverente se fizermos objeto de linha

44216
29:21:11,040 --> 29:21:12,960
atribuição aqui esta é realmente tudo que eu

44217
29:21:12,960 --> 29:21:15,360
Queria que você visse nesta palestra que

44218
29:21:15,360 --> 29:21:17,440
Você realmente deve ter cuidado se você é

44219
29:21:17,440 --> 29:21:19,440
Usando funções virtuais

44220
29:21:19,440 --> 29:21:22,000
misturado com argumentos padrão a

44221
29:21:22,000 --> 29:21:24,232
O compilador não vai fazer dinâmico

44222
29:21:24,232 --> 29:21:26,640
vinculação sobre os parâmetros padrão que é

44223
29:21:26,640 --> 29:21:29,360
vai decidir quais parâmetros padrão

44224
29:21:29,360 --> 29:21:32,960
para ligar em tempo de compilação usando estática

44225
29:21:32,960 --> 29:21:34,720
vinculação para que o compilador seja basicamente

44226
29:21:34,720 --> 29:21:36,960
Vou olhar para o tipo do ponteiro

44227
29:21:36,960 --> 29:21:39,592
ou objeto que você tem e ele está indo

44228
29:21:39,592 --> 29:21:41,760
usar isso para decidir qual padrão

44229
29:21:41,760 --> 29:21:44,552
parâmetros para ligar assim neste exemplo

44230
29:21:44,552 --> 29:21:46,552
Aqui, por exemplo, na linha 7 está indo

44231
29:21:46,552 --> 29:21:49,040
para ver que tipo de ponteiro eu tenho eu

44232
29:21:49,040 --> 29:21:50,960
ter um ponteiro base, então eu vou usar

44233
29:21:50,960 --> 29:21:53,360
os parâmetros padrão da base

44234
29:21:53,360 --> 29:21:55,440
implementação e se você pairar sobre

44235
29:21:55,440 --> 29:21:56,720
Aqui você vai ver que é

44236
29:21:56,720 --> 29:21:59,040
vamos conectar um 5 e um 5. mesmo se nós

44237
29:21:59,040 --> 29:22:01,280
estão usando o add mais especializado

44238
29:22:01,280 --> 29:22:04,160
versão em nossa hierarquia de herança

44239
29:22:04,160 --> 29:22:06,000
O compilador ainda vai usar o

44240
29:22:06,000 --> 29:22:08,232
Argumento padrão a partir da base

44241
29:22:08,232 --> 29:22:11,040
implementação aqui na linha 16 a

44242
29:22:11,040 --> 29:22:13,120
O compilador vai dizer que tipo de

44243
29:22:13,120 --> 29:22:15,040
Referência, eu tenho, vai dizer

44244
29:22:15,040 --> 29:22:17,280
base porque é isso que temos aqui, então

44245
29:22:17,280 --> 29:22:18,720
ele vai usar o padrão

44246
29:22:18,720 --> 29:22:21,280
parâmetros da base e é isso que

44247
29:22:21,280 --> 29:22:23,280
vai ligar aqui 5 e 5 e 5

44248
29:22:23,280 --> 29:22:25,512
nós vamos conseguir esse resultado aqui

44249
29:22:25,512 --> 29:22:28,232
Aqui na linha 25 o compilador é

44250
29:22:28,232 --> 29:22:30,160
Vou ver que tipo de objeto faço eu

44251
29:22:30,160 --> 29:22:32,872
Tenho aqui este três é uma base, então eu sou

44252
29:22:32,872 --> 29:22:35,120
usar os parâmetros padrão de

44253
29:22:35,120 --> 29:22:36,160
base

44254
29:22:36,160 --> 29:22:39,120
abaixo na linha 31, o compilador é

44255
29:22:39,120 --> 29:22:40,552
Vou olhar e ver

44256
29:22:40,552 --> 29:22:42,800
que tipo de objeto eu tenho aqui o

44257
29:22:42,800 --> 29:22:45,760
objeto é derivado assim que eu vou ligar o

44258
29:22:45,760 --> 29:22:48,000
Parâmetros padrão para ele derivado novamente

44259
29:22:48,000 --> 29:22:49,440
Isto é realmente o que é o compilador

44260
29:22:49,440 --> 29:22:52,160
vai fazer com os parâmetros padrão do

44261
29:22:52,160 --> 29:22:54,720
O compilador nunca vai fazer dinâmica

44262
29:22:54,720 --> 29:22:56,800
ligação e isso vai fazer seu

44263
29:22:56,800 --> 29:23:00,160
Código realmente confuso novamente meu conselho é

44264
29:23:00,160 --> 29:23:03,440
para evitar argumentos padrão ou dedicar

44265
29:23:03,440 --> 29:23:06,800
parâmetros se você estiver usando polimorfismo

44266
29:23:06,800 --> 29:23:09,512
Na sua hierarquia de herança, nós somos

44267
29:23:09,512 --> 29:23:11,592
Vou parar aqui nesta palestra e

44268
29:23:11,592 --> 29:23:13,440
O próximo que vamos aprender sobre

44269
29:23:13,440 --> 29:23:15,512
destruidores virtuais

44270
29:23:15,512 --> 29:23:17,832
Vá em frente e termine aqui e me encontre

44271
29:23:17,832 --> 29:23:19,832
lá nesta palestra vamos

44272
29:23:19,832 --> 29:23:23,192
explorar destruidores virtuais e estes

44273
29:23:23,192 --> 29:23:25,832
são métodos destructor que você pode querer

44274
29:23:25,832 --> 29:23:27,040
ser chamado

44275
29:23:27,040 --> 29:23:30,400
usando ligação dinâmica ou polimórfico

44276
29:23:30,400 --> 29:23:31,592
Comportamento

44277
29:23:31,592 --> 29:23:33,040
nós vamos usar isso

44278
29:23:33,040 --> 29:23:34,800
Hierarquia de herança para jogar com

44279
29:23:34,800 --> 29:23:36,400
Obrigado para que a classe animal vá

44280
29:23:36,400 --> 29:23:38,552
ser nossa classe base que vamos derivar

44281
29:23:38,552 --> 29:23:41,040
A partir disso publicamente e ter um felino

44282
29:23:41,040 --> 29:23:43,832
classe e nós vamos derivar de

44283
29:23:43,832 --> 29:23:46,552
felino e ter uma classe de cão este é o

44284
29:23:46,552 --> 29:23:49,280
Configuração que vamos usar aqui

44285
29:23:49,280 --> 29:23:51,592
Agora vamos olhar para algum código que estamos indo

44286
29:23:51,592 --> 29:23:53,760
para montar a nossa classe animal como há

44287
29:23:53,760 --> 29:23:56,232
Nada realmente especial aqui percebe que

44288
29:23:56,232 --> 29:23:58,400
O destruidor é um destruidor regular

44289
29:23:58,400 --> 29:23:59,512
Temos

44290
29:23:59,512 --> 29:24:03,192
derivaremos do animal e criaremos uma

44291
29:24:03,192 --> 29:24:05,440
classe felina que vai configurar

44292
29:24:05,440 --> 29:24:07,280
sua própria função virtual que está indo

44293
29:24:07,280 --> 29:24:10,160
para ser executado se você quiser que você pode substituir

44294
29:24:10,160 --> 29:24:12,160
O método da respiração, mas não queremos

44295
29:24:12,160 --> 29:24:14,480
fazer isso aqui porque nós só queremos

44296
29:24:14,480 --> 29:24:15,512
Foco

44297
29:24:15,512 --> 29:24:18,640
sobre os destruidores aqui e a ordem em

44298
29:24:18,640 --> 29:24:20,960
que eles serão chamados, nós somos

44299
29:24:20,960 --> 29:24:23,832
vai derivar do felino e montar um

44300
29:24:23,832 --> 29:24:26,552
classe de cão e esta classe de cão vai

44301
29:24:26,552 --> 29:24:29,040
configurar sua própria função virtual e

44302
29:24:29,040 --> 29:24:31,120
note que tem um destruidor que é

44303
29:24:31,120 --> 29:24:33,680
Realmente um destruidor regular agora, uma vez

44304
29:24:33,680 --> 29:24:36,160
ter esta hierarquia de herança configurada

44305
29:24:36,160 --> 29:24:38,480
Podemos querer fazer algo assim

44306
29:24:38,480 --> 29:24:40,552
Podemos criar um objeto escuro

44307
29:24:40,552 --> 29:24:43,512
e quando é hora deste objeto para

44308
29:24:43,512 --> 29:24:46,640
ser destruído eu quero que você se concentre no

44309
29:24:46,640 --> 29:24:48,552
A ordem em que os destruidores estão indo

44310
29:24:48,552 --> 29:24:50,800
para sermos chamados, já vimos isso antes

44311
29:24:50,800 --> 29:24:53,192
Os destruidores serão chamados

44312
29:24:53,192 --> 29:24:56,640
do especialista à mais básica

44313
29:24:56,640 --> 29:24:58,872
implementação do destructor para que

44314
29:24:58,872 --> 29:25:01,440
Destructor for doug será chamado primeiro

44315
29:25:01,440 --> 29:25:03,192
então vamos chamar o destruidor para

44316
29:25:03,192 --> 29:25:05,760
felino, então vamos chamar o destruidor

44317
29:25:05,760 --> 29:25:08,320
para o animal agora um problema vai estourar

44318
29:25:08,320 --> 29:25:11,192
acima, se estamos usando um ponteiro base para

44319
29:25:11,192 --> 29:25:14,480
gerenciar um objeto derivado com polimórfico

44320
29:25:14,480 --> 29:25:16,720
comportamento que podemos querer para o nosso

44321
29:25:16,720 --> 29:25:18,960
Hierarquia de herança aqui para que

44322
29:25:18,960 --> 29:25:21,192
usar um ponteiro animal para gerenciar

44323
29:25:21,192 --> 29:25:23,680
um objeto escuro como este e quando é

44324
29:25:23,680 --> 29:25:25,512
Tempo para liberar a memória para isso

44325
29:25:25,512 --> 29:25:26,720
objeto

44326
29:25:26,720 --> 29:25:29,912
Podemos ser tentados a chamar a exclusão

44327
29:25:29,912 --> 29:25:33,040
Operador em nosso ponteiro animal aqui, mas

44328
29:25:33,040 --> 29:25:34,720
Isso só vai chamar o

44329
29:25:34,720 --> 29:25:36,000
destructor

44330
29:25:36,000 --> 29:25:38,800
para a classe base e espero que você possa

44331
29:25:38,800 --> 29:25:41,040
Veja o problema aqui porque o nosso

44332
29:25:41,040 --> 29:25:44,232
Destructores não são virtual o compilador

44333
29:25:44,232 --> 29:25:46,720
vai usar a ligação estática para decidir

44334
29:25:46,720 --> 29:25:48,960
qual destructor chamar para que vá

44335
29:25:48,960 --> 29:25:50,872
para olhar para o tipo de um ponteiro que é

44336
29:25:50,872 --> 29:25:52,232
Vou ver que é um animal

44337
29:25:52,232 --> 29:25:54,000
ponteiro e vai decidir

44338
29:25:54,000 --> 29:25:56,872
chamar o destruidor para o animal aqui

44339
29:25:56,872 --> 29:25:59,120
É por isso que temos esta reserva que somos

44340
29:25:59,120 --> 29:26:01,440
Gerenciar um objeto que não é apenas um

44341
29:26:01,440 --> 29:26:04,160
animal deriva informação nele

44342
29:26:04,160 --> 29:26:06,800
Mas estamos apenas chamando o destruidor

44343
29:26:06,800 --> 29:26:09,592
para a parte de base deste atordoamento, então qualquer

44344
29:26:09,592 --> 29:26:11,680
pedaços de memória dinâmica que podemos ter

44345
29:26:11,680 --> 29:26:14,800
alocados nos construtores para felinos

44346
29:26:14,800 --> 29:26:17,512
ou cão vai vazar porque

44347
29:26:17,512 --> 29:26:20,480
Lembre-se mesmo que este seja um objeto escuro

44348
29:26:20,480 --> 29:26:22,552
é composto de peças de base o

44349
29:26:22,552 --> 29:26:24,552
A base para isso vai ser

44350
29:26:24,552 --> 29:26:26,800
animal e em cima disso estamos indo

44351
29:26:26,800 --> 29:26:29,440
para construir um nível felino e em cima de

44352
29:26:29,440 --> 29:26:31,912
que vamos construir um nível de cão

44353
29:26:31,912 --> 29:26:34,160
Neste caso, apenas o destruidor para o cão

44354
29:26:34,160 --> 29:26:37,512
vai ser chamado e qualquer dinâmica

44355
29:26:37,512 --> 29:26:40,232
memória que poderia ter sido alocada em

44356
29:26:40,232 --> 29:26:43,512
o nível felino e cão vai ser

44357
29:26:43,512 --> 29:26:45,280
Vazou e isso é algo que nós

44358
29:26:45,280 --> 29:26:47,192
Não quero que você realmente precise manter seu

44359
29:26:47,192 --> 29:26:49,512
De olho sobre isso e isso é algo

44360
29:26:49,512 --> 29:26:51,360
É muito ruim que você realmente precisa manter o seu

44361
29:26:51,360 --> 29:26:53,832
olho para isso, então isso é realmente um grande

44362
29:26:53,832 --> 29:26:55,912
problema e para resolvê-lo precisamos de

44363
29:26:55,912 --> 29:26:58,400
destruidores a serem chamados a usar

44364
29:26:58,400 --> 29:27:01,280
Polimorfismo e você pode configurar isso por

44365
29:27:01,280 --> 29:27:04,640
marcando seus destruidores como um virtual se

44366
29:27:04,640 --> 29:27:06,872
você faz isso, o compilador saberá

44367
29:27:06,872 --> 29:27:08,872
que se você está passando por uma base

44368
29:27:08,872 --> 29:27:11,592
ponteiro para gerenciar um objeto derivado quando

44369
29:27:11,592 --> 29:27:13,592
A hora chega para que a memória seja

44370
29:27:13,592 --> 29:27:15,512
liberado e você libera a memória

44371
29:27:15,512 --> 29:27:17,912
através de um ponteiro base o compilador é

44372
29:27:17,912 --> 29:27:19,912
Vou chamar o mais específico

44373
29:27:19,912 --> 29:27:22,320
Destructor pode encontrar e isso está indo

44374
29:27:22,320 --> 29:27:24,800
para resolver o nosso problema, então nós vamos reutilizar

44375
29:27:24,800 --> 29:27:27,192
A ordem que mais conhecemos

44376
29:27:27,192 --> 29:27:29,912
Destructor derivado será chamado e

44377
29:27:29,912 --> 29:27:32,160
vai chamar o seu melhor destruidor e que é

44378
29:27:32,160 --> 29:27:34,000
Vou acontecer até que mais atingamos

44379
29:27:34,000 --> 29:27:36,720
classe base em nossa hierarquia de herança

44380
29:27:36,720 --> 29:27:38,480
E a memória será liberada

44381
29:27:38,480 --> 29:27:40,640
Exatamente como gostaríamos agora que você

44382
29:27:40,640 --> 29:27:42,000
Eu sei que vamos nos dirigir para

44383
29:27:42,000 --> 29:27:43,832
código de estúdio visual e jogar com a gente um

44384
29:27:43,832 --> 29:27:46,552
Pouco mais aqui estamos em nosso trabalho

44385
29:27:46,552 --> 29:27:48,232
pasta que vamos aprender sobre

44386
29:27:48,232 --> 29:27:50,720
destruidores virtuais e antes de nós

44387
29:27:50,720 --> 29:27:52,720
que vamos pegar nosso modelo

44388
29:27:52,720 --> 29:27:55,280
arquivos e colocá-los no lugar, vamos fazer

44389
29:27:55,280 --> 29:27:57,280
Isso e eu vou colocar no

44390
29:27:57,280 --> 29:27:59,680
classes que compõem a nossa herança

44391
29:27:59,680 --> 29:28:02,000
hierarquia nossa classe mais baseada está indo

44392
29:28:02,000 --> 29:28:04,552
para ser base nossa classe mais baseada está indo

44393
29:28:04,552 --> 29:28:06,480
para ser animal depois disso vamos

44394
29:28:06,480 --> 29:28:08,720
derivar que vamos derivar disso

44395
29:28:08,720 --> 29:28:11,192
e criar a classe felin e nós somos

44396
29:28:11,192 --> 29:28:13,592
vai derivar do felino e criar um

44397
29:28:13,592 --> 29:28:16,160
classe de cão aqui esta é a herança

44398
29:28:16,160 --> 29:28:18,552
hierarquia sobre a qual falamos em nossos slides

44399
29:28:18,552 --> 29:28:20,400
Tudo bem, vamos abrir isso para dentro

44400
29:28:20,400 --> 29:28:22,640
código visual do estúdio e isso vai

44401
29:28:22,640 --> 29:28:25,360
dar nossas aulas aqui e nós estamos

44402
29:28:25,360 --> 29:28:27,440
remover essas palavras-chave virtuais

44403
29:28:27,440 --> 29:28:29,192
Porque nós queremos ver

44404
29:28:29,192 --> 29:28:31,912
O que aconteceria se você não marcar o seu

44405
29:28:31,912 --> 29:28:34,400
Destrutores como virtual, vamos

44406
29:28:34,400 --> 29:28:36,232
fazer isso para felino que vamos fazer

44407
29:28:36,232 --> 29:28:38,480
que para doug vamos remover o virtual

44408
29:28:38,480 --> 29:28:40,640
palavra-chave aqui vamos remover isso

44409
29:28:40,640 --> 29:28:42,480
e nós vamos remover isso para o

44410
29:28:42,480 --> 29:28:44,800
classe animal e queremos ver o

44411
29:28:44,800 --> 29:28:47,192
implementações para nossos destruidores para

44412
29:28:47,192 --> 29:28:49,512
animal, vamos apenas dizer que o

44413
29:28:49,512 --> 29:28:52,160
Destructor para animais foi chamado para

44414
29:28:52,160 --> 29:28:53,912
felino, vamos dizer a mesma coisa

44415
29:28:53,912 --> 29:28:56,000
O destructor felino pediu dúvidas que somos

44416
29:28:56,000 --> 29:28:57,680
Vou dizer a mesma coisa que vamos

44417
29:28:57,680 --> 29:29:00,800
para dizer destruidor para cão chamado aqui

44418
29:29:00,800 --> 29:29:04,640
Estamos usando os pontos fortes como nossos parâmetros

44419
29:29:04,640 --> 29:29:07,040
Então eu acho que é uma boa ideia

44420
29:29:07,040 --> 29:29:09,192
mudar esses caras para usar string view i

44421
29:29:09,192 --> 29:29:10,400
Eu vou fazer isso

44422
29:29:10,400 --> 29:29:12,552
e voltar quando isso é feito

44423
29:29:12,552 --> 29:29:15,280
Tudo bem, isso é feito todos os nossos parâmetros são

44424
29:29:15,280 --> 29:29:18,552
tipo de exibição de string std e agora que nós

44425
29:29:18,552 --> 29:29:20,872
ter essa hierarquia de herança, vamos

44426
29:29:20,872 --> 29:29:23,680
Certifique-se de que nenhum dos destruidores é

44427
29:29:23,680 --> 29:29:26,232
virtual Este é o caso aqui que podemos

44428
29:29:26,232 --> 29:29:29,592
cabeça para o arquivo principal cpp e usar

44429
29:29:29,592 --> 29:29:31,760
Esta hierarquia de herança aqui estamos

44430
29:29:31,760 --> 29:29:34,160
indo para rachar e remover

44431
29:29:34,160 --> 29:29:36,640
O que não precisamos aqui

44432
29:29:36,640 --> 29:29:40,000
Vamos incluir a nossa aula de cães

44433
29:29:40,000 --> 29:29:42,872
que vai incluir implicitamente ou

44434
29:29:42,872 --> 29:29:44,800
suas classes de pais, então vamos

44435
29:29:44,800 --> 29:29:47,592
incluir dog.h aqui e nós vamos

44436
29:29:47,592 --> 29:29:50,160
criar um row.object por padrão aqui

44437
29:29:50,160 --> 29:29:52,400
nós vamos dizer cão e vamos dizer cão

44438
29:29:52,400 --> 29:29:55,040
Um que podemos fazer isso e talvez nem

44439
29:29:55,040 --> 29:29:57,512
dar qualquer parâmetro que isso vai fazer

44440
29:29:57,512 --> 29:29:59,512
chamar o construtor padrão e se nós

44441
29:29:59,512 --> 29:30:01,912
ir para doug vamos ver que é

44442
29:30:01,912 --> 29:30:04,160
Possível especificar informações aqui

44443
29:30:04,160 --> 29:30:06,552
primeira descrição de estilo, mas vamos

44444
29:30:06,552 --> 29:30:09,680
para ignorar isso e nós só queremos ver

44445
29:30:09,680 --> 29:30:12,640
em que os destruidores são

44446
29:30:12,640 --> 29:30:15,192
chamados, vamos construir e executar este programa

44447
29:30:15,192 --> 29:30:17,440
nós vamos passar por isso através do gcc o

44448
29:30:17,440 --> 29:30:19,680
O livro vai ser bom se formos claros

44449
29:30:19,680 --> 29:30:21,832
vamos trazer uma janela powershell para fazer

44450
29:30:21,832 --> 29:30:23,832
que nós vamos limpar

44451
29:30:23,832 --> 29:30:26,160
e correr galo você vai ver que

44452
29:30:26,160 --> 29:30:28,552
cão destructor foi chamado felino

44453
29:30:28,552 --> 29:30:30,720
O destructor foi chamado destruidor animal

44454
29:30:30,720 --> 29:30:32,480
Foi chamado e isso é muito legal

44455
29:30:32,480 --> 29:30:36,000
é a ordem que esperamos por padrão, mas se

44456
29:30:36,000 --> 29:30:38,640
Não fazemos algo assim e dizemos

44457
29:30:38,640 --> 29:30:41,832
ponteiro de animais e dizer p animal para significar

44458
29:30:41,832 --> 29:30:44,872
um ponteiro para o animal e dizemos novo cão

44459
29:30:44,872 --> 29:30:46,960
Vamos alocar um cachorro no

44460
29:30:46,960 --> 29:30:48,960
monte e vamos conseguir isso

44461
29:30:48,960 --> 29:30:53,040
usando um ponteiro base e se tentarmos

44462
29:30:53,040 --> 29:30:54,872
Liberte a memória aqui vamos fazer isso

44463
29:30:54,872 --> 29:30:57,360
nós vamos dizer delete p animal vamos

44464
29:30:57,360 --> 29:31:00,080
Veja qual destruidor é chamado aqui

44465
29:31:00,080 --> 29:31:02,080
porque notamos que estamos usando uma base

44466
29:31:02,080 --> 29:31:06,160
ponteiro para gerenciar um objeto específico

44467
29:31:06,160 --> 29:31:08,640
Aqui, que é uma classe derivada de cão

44468
29:31:08,640 --> 29:31:11,360
indiretamente e veremos que não

44469
29:31:11,360 --> 29:31:14,552
obter os destruidores chamados na ordem

44470
29:31:14,552 --> 29:31:16,800
que esperamos vamos construir e executar isso

44471
29:31:16,800 --> 29:31:18,960
programa para realmente ver isso, estamos indo

44472
29:31:18,960 --> 29:31:21,040
para usar o gcc para construí-lo

44473
29:31:21,040 --> 29:31:23,280
O mundo vai ser bom como você vê

44474
29:31:23,280 --> 29:31:25,440
Aqui nós vamos limpar

44475
29:31:25,440 --> 29:31:28,232
e correr galo agora você vê que só

44476
29:31:28,232 --> 29:31:31,592
O destruidor para o animal é chamado mesmo

44477
29:31:31,592 --> 29:31:34,480
se estamos realmente gerenciando um objeto de cão

44478
29:31:34,480 --> 29:31:36,320
Para que as coisas funcionem muito bem, nós

44479
29:31:36,320 --> 29:31:38,480
Espero que o destruidor para o pato seja

44480
29:31:38,480 --> 29:31:40,640
chamado e, em seguida, o destruidor para um

44481
29:31:40,640 --> 29:31:42,640
felino e, em seguida, o destruidor para

44482
29:31:42,640 --> 29:31:45,912
animal para liberar ou a memória que

44483
29:31:45,912 --> 29:31:48,640
poderia ter sido alocado por estes

44484
29:31:48,640 --> 29:31:51,440
classes de pais para nossa classe de cães se você

44485
29:31:51,440 --> 29:31:53,832
Volte no arquivo cpp, por exemplo, para

44486
29:31:53,832 --> 29:31:55,592
Cada uma dessas aulas que você vai

44487
29:31:55,592 --> 29:31:57,512
Veja que o compilador vai ser

44488
29:31:57,512 --> 29:31:58,400
A ligar

44489
29:31:58,400 --> 29:32:00,480
cada classe de base do nível atual

44490
29:32:00,480 --> 29:32:02,872
que estamos em doug cpp, estamos indo

44491
29:32:02,872 --> 29:32:05,440
para chamar o construtor para felino

44492
29:32:05,440 --> 29:32:07,120
construtor para felino vai ser

44493
29:32:07,120 --> 29:32:09,512
chamado se ele está fazendo alguma memória dinâmica

44494
29:32:09,512 --> 29:32:11,360
alocação que precisamos liberar isso

44495
29:32:11,360 --> 29:32:13,680
Construtor de memória para felino também é

44496
29:32:13,680 --> 29:32:15,680
Vou chamar o construtor de animais

44497
29:32:15,680 --> 29:32:18,000
e se o animal está fazendo alguma dinâmica

44498
29:32:18,000 --> 29:32:19,832
alocação de memória que vai precisar

44499
29:32:19,832 --> 29:32:22,232
ser chamado, mas note que somos apenas

44500
29:32:22,232 --> 29:32:25,192
cólon o destructor para o animal e se

44501
29:32:25,192 --> 29:32:27,512
Chamamos isso destruidor todos os

44502
29:32:27,512 --> 29:32:29,440
memória que foi alocada pelo arquivamento

44503
29:32:29,440 --> 29:32:31,592
O construtor vai ser vazado

44504
29:32:31,592 --> 29:32:33,592
Porque apenas o destruidor animal é

44505
29:32:33,592 --> 29:32:35,120
Vai ser chamado espero que você possa ver

44506
29:32:35,120 --> 29:32:37,512
O problema aqui, mas este não é o

44507
29:32:37,512 --> 29:32:39,912
apenas problema o c plus padrão

44508
29:32:39,912 --> 29:32:42,080
Diz que se você fizer algo como nós

44509
29:32:42,080 --> 29:32:45,512
estão fazendo aqui e chamar um destruidor

44510
29:32:45,512 --> 29:32:47,760
usando um ponteiro para a classe base, mas

44511
29:32:47,760 --> 29:32:49,832
O ponteiro está gerenciando a

44512
29:32:49,832 --> 29:32:52,232
objeto derivado isso vai lhe dar

44513
29:32:52,232 --> 29:32:54,000
Comportamento indefinido para que você não seja

44514
29:32:54,000 --> 29:32:56,400
Garantir chegar ao mesmo comportamento

44515
29:32:56,400 --> 29:32:58,160
em diferentes compiladores em diferentes

44516
29:32:58,160 --> 29:33:00,160
sistemas operacionais, então isso é algo

44517
29:33:00,160 --> 29:33:02,552
É muito ruim que queremos todos os destruidores

44518
29:33:02,552 --> 29:33:05,192
em nossa hierarquia de herança para ser

44519
29:33:05,192 --> 29:33:08,320
Chamado para liberar corretamente a memória

44520
29:33:08,320 --> 29:33:10,320
Isso seria potencialmente dinâmico

44521
29:33:10,320 --> 29:33:12,872
alocados por cada nível em nossa

44522
29:33:12,872 --> 29:33:14,872
construtor chama a correção para isso é

44523
29:33:14,872 --> 29:33:17,192
Tudo o que você precisa fazer é marcar

44524
29:33:17,192 --> 29:33:20,080
seus destruidores como virtuais e

44525
29:33:20,080 --> 29:33:23,040
O compilador chamará o mais específico

44526
29:33:23,040 --> 29:33:24,232
destructor

44527
29:33:24,232 --> 29:33:27,192
para suas aulas, então tudo o que precisamos fazer é

44528
29:33:27,192 --> 29:33:29,760
Entrá e marque esses caras como virtuais

44529
29:33:29,760 --> 29:33:31,912
Vamos fazer isso a classe base

44530
29:33:31,912 --> 29:33:33,760
O destructor será marcado como

44531
29:33:33,760 --> 29:33:35,832
virtual nós vamos para felino e

44532
29:33:35,832 --> 29:33:37,360
Faz o mesmo o que vamos marcar

44533
29:33:37,360 --> 29:33:39,592
Isso como virtual e nós vamos para

44534
29:33:39,592 --> 29:33:40,480
cão

44535
29:33:40,480 --> 29:33:43,512
e marcar o seu destruidor como virtual

44536
29:33:43,512 --> 29:33:45,760
Vou fazer algo assim e agora

44537
29:33:45,760 --> 29:33:48,000
notar que não precisamos mudar nenhum outro

44538
29:33:48,000 --> 29:33:49,680
Se construirmos nosso programa, somos

44539
29:33:49,680 --> 29:33:52,232
indo passá-lo através de gcc ele está indo

44540
29:33:52,232 --> 29:33:54,872
para fazer exatamente o que queremos porque

44541
29:33:54,872 --> 29:33:57,760
agora o compilador irá resolver as chamadas

44542
29:33:57,760 --> 29:34:00,000
aos destruidores polimorficamente

44543
29:34:00,000 --> 29:34:01,680
Porque estamos passando por uma base

44544
29:34:01,680 --> 29:34:03,832
pontor o compilador chamará mais

44545
29:34:03,832 --> 29:34:05,832
implementação específica para este

44546
29:34:05,832 --> 29:34:07,912
estrutura porque estamos passando por uma

44547
29:34:07,912 --> 29:34:10,160
ponto de referência de base para chamar o destruidor aqui

44548
29:34:10,160 --> 29:34:12,400
O compilador chamará

44549
29:34:12,400 --> 29:34:15,440
O destruidor mais especializado que podemos

44550
29:34:15,440 --> 29:34:16,872
encontrar e ele vai encontrar o

44551
29:34:16,872 --> 29:34:19,512
Destructor para pato que vai ser

44552
29:34:19,512 --> 29:34:21,760
O destruidor mais especializado que podemos

44553
29:34:21,760 --> 29:34:24,480
encontrar em nossa hierarquia de herança que é

44554
29:34:24,480 --> 29:34:26,640
Vou chamar o cão destruidor que é

44555
29:34:26,640 --> 29:34:29,512
indo para ir o destructor para felino em

44556
29:34:29,512 --> 29:34:32,000
virar e então isso vai chamar o

44557
29:34:32,000 --> 29:34:34,400
Destructor para animais e nossa memória é

44558
29:34:34,400 --> 29:34:36,480
vai ser liberado corretamente que é

44559
29:34:36,480 --> 29:34:38,400
O que vamos ver aqui vamos fazer

44560
29:34:38,400 --> 29:34:40,800
Certamente nós soldamos isso novamente porque eu não sou

44561
29:34:40,800 --> 29:34:43,680
certeza se eu realmente construí este corpo

44562
29:34:43,680 --> 29:34:45,192
Vai ser bom de qualquer maneira, então estamos

44563
29:34:45,192 --> 29:34:48,000
indo para limpar e correr galo agora você

44564
29:34:48,000 --> 29:34:49,912
Veja que o ducto destruidor é chamado

44565
29:34:49,912 --> 29:34:51,912
o vlan destructor é chamado de animal

44566
29:34:51,912 --> 29:34:53,680
Destructor é ouro e tudo é

44567
29:34:53,680 --> 29:34:56,400
Só vou cair no lugar, então meu conselho

44568
29:34:56,400 --> 29:34:58,800
se você estiver usando funções virtuais em

44569
29:34:58,800 --> 29:35:01,760
Sua hierarquia de herança certifique-se de que você

44570
29:35:01,760 --> 29:35:04,872
também marcar seus destruidores como virtuais

44571
29:35:04,872 --> 29:35:06,800
Isso vai te salvar o futuro

44572
29:35:06,800 --> 29:35:09,592
dores de cabeça que você pode entrar em contato

44573
29:35:09,592 --> 29:35:11,440
se você estiver usando um ponteiro base para

44574
29:35:11,440 --> 29:35:13,760
gerenciar um objeto derivado e você é

44575
29:35:13,760 --> 29:35:15,760
Fazendo algum tipo de memória dinâmica

44576
29:35:15,760 --> 29:35:18,232
alocações em seus construtores que são

44577
29:35:18,232 --> 29:35:20,872
vai liberar a memória corretamente se

44578
29:35:20,872 --> 29:35:23,360
Você está liberando a memória através de um

44579
29:35:23,360 --> 29:35:26,160
ponto de referência de base como estamos fazendo na linha 8

44580
29:35:26,160 --> 29:35:28,080
Aqui isso é realmente tudo que eu tinha que compartilhar

44581
29:35:28,080 --> 29:35:29,592
Nesta palestra espero que você a tenha encontrado

44582
29:35:29,592 --> 29:35:31,680
interessante, vamos parar por aqui

44583
29:35:31,680 --> 29:35:33,360
Este no próximo vamos

44584
29:35:33,360 --> 29:35:36,160
Aprenda sobre os elencos dinâmicos

44585
29:35:36,160 --> 29:35:38,400
Vá em frente e termine aqui e me encontre

44586
29:35:38,400 --> 29:35:40,232
lá nesta palestra vamos

44587
29:35:40,232 --> 29:35:43,040
Aprenda sobre os elencos dinâmicos e a

44588
29:35:43,040 --> 29:35:45,680
os moldes dinâmicos são uma facilidade em que temos

44589
29:35:45,680 --> 29:35:47,120
c plus plus

44590
29:35:47,120 --> 29:35:50,800
para fazer transformações downstream

44591
29:35:50,800 --> 29:35:54,000
entre nossos tipos polimórficos

44592
29:35:54,000 --> 29:35:56,400
então, se tivermos um planer base, por exemplo

44593
29:35:56,400 --> 29:35:59,440
podemos transformá-lo em um tipo derivado

44594
29:35:59,440 --> 29:36:01,760
e ser capaz de usá-lo como usamos qualquer

44595
29:36:01,760 --> 29:36:04,480
objeto de linha, por exemplo, se fizermos isso

44596
29:36:04,480 --> 29:36:06,480
Tipo de transformação que seremos capazes

44597
29:36:06,480 --> 29:36:09,192
para chamar funções não polimórficas e

44598
29:36:09,192 --> 29:36:12,800
Isso pode vir a calhar às vezes

44599
29:36:12,800 --> 29:36:14,720
Esta é a hierarquia que vamos usar

44600
29:36:14,720 --> 29:36:17,440
nossa classe superior será animal aqui nós

44601
29:36:17,440 --> 29:36:19,592
derivarão disso e criarão o nosso

44602
29:36:19,592 --> 29:36:21,760
felino classe e nós estaremos ao vivo de

44603
29:36:21,760 --> 29:36:25,360
felino e criar nossa aula de cães aqui se

44604
29:36:25,360 --> 29:36:27,512
temos um ponteiro base apontando para um

44605
29:36:27,512 --> 29:36:29,912
Objeto escuro, por exemplo, o mais

44606
29:36:29,912 --> 29:36:32,232
classe especializada que podemos ter em nosso

44607
29:36:32,232 --> 29:36:35,360
Hierarquia de herança às vezes podemos

44608
29:36:35,360 --> 29:36:39,120
Queremos transformar a partir deste ponteiro base

44609
29:36:39,120 --> 29:36:42,400
para o objeto mais derivado aqui e obter

44610
29:36:42,400 --> 29:36:45,440
para o objeto mais derivado direto que

44611
29:36:45,440 --> 29:36:47,592
Podemos realmente chamar qualquer coisa se você

44612
29:36:47,592 --> 29:36:50,080
Lembre-se com um planador de base como animal

44613
29:36:50,080 --> 29:36:52,800
Aqui, a única coisa que podemos fazer é realmente

44614
29:36:52,800 --> 29:36:53,680
chamada

44615
29:36:53,680 --> 29:36:56,720
funções polimórficas ou virtuais, mas

44616
29:36:56,720 --> 29:36:58,800
às vezes queremos fazer muito mais do que

44617
29:36:58,800 --> 29:37:01,040
Isso, por exemplo, se quisermos chamar

44618
29:37:01,040 --> 29:37:03,040
funções não polimórficas este não é

44619
29:37:03,040 --> 29:37:04,872
Vai trabalhar porque o melhor ponteiro

44620
29:37:04,872 --> 29:37:07,280
não tem conhecimento dessas funções, então

44621
29:37:07,280 --> 29:37:09,912
Se precisamos fazer isso explicitamente

44622
29:37:09,912 --> 29:37:12,320
Transformando de um ponteiro base para um

44623
29:37:12,320 --> 29:37:14,552
O ponteiro derivado vai nos dar isso

44624
29:37:14,552 --> 29:37:17,512
capacidade se o objeto real nós somos

44625
29:37:17,512 --> 29:37:20,552
apontando para acontecer para ter esse método

44626
29:37:20,552 --> 29:37:22,552
Tudo bem, então isso é o que estamos procurando

44627
29:37:22,552 --> 29:37:24,232
Esta palestra queremos ser capazes de

44628
29:37:24,232 --> 29:37:27,360
Transformar de um ponteiro de classe base

44629
29:37:27,360 --> 29:37:30,080
ou referência a um ponteiro de classe derivado

44630
29:37:30,080 --> 29:37:32,640
ou referência em tempo de execução de outra forma você

44631
29:37:32,640 --> 29:37:34,872
pode enviar um texto para isso para pensar na base

44632
29:37:34,872 --> 29:37:37,760
ponteiro de classe ou referência como entrada e

44633
29:37:37,760 --> 29:37:40,232
Queremos obter um ponteiro de classe derivado

44634
29:37:40,232 --> 29:37:43,192
ou referência como saída em nosso c plus

44635
29:37:43,192 --> 29:37:45,592
além do programa e do principal benefício de

44636
29:37:45,592 --> 29:37:47,552
Isto é para poder chamar

44637
29:37:47,552 --> 29:37:50,400
métodos não polimórficos em derivados

44638
29:37:50,400 --> 29:37:52,552
ponteiros ou referências que isso vai

44639
29:37:52,552 --> 29:37:55,512
ser super legal em alguns casos, tudo bem, então

44640
29:37:55,512 --> 29:37:58,400
Vejamos a nossa hierarquia de herança

44641
29:37:58,400 --> 29:38:00,400
Aqui a classe superior vai ser animal

44642
29:38:00,400 --> 29:38:02,552
Como você vê aqui vai ter um

44643
29:38:02,552 --> 29:38:04,960
método virtual único que também vai

44644
29:38:04,960 --> 29:38:06,960
ter um disruptor virtual porque nós sabemos

44645
29:38:06,960 --> 29:38:09,360
Como fazer isso agora que podemos derivar de

44646
29:38:09,360 --> 29:38:11,680
isso e criar nossa classe de enchimento que

44647
29:38:11,680 --> 29:38:12,872
- Vai ser

44648
29:38:12,872 --> 29:38:15,040
Herançando publicamente, isso vai ter

44649
29:38:15,040 --> 29:38:17,192
seu próprio método de execução e vai

44650
29:38:17,192 --> 29:38:19,832
declarar seu próprio outro método que é

44651
29:38:19,832 --> 29:38:22,160
Não virtual, também podemos derivar de

44652
29:38:22,160 --> 29:38:25,192
felino e criar uma aula de cães este é

44653
29:38:25,192 --> 29:38:27,440
Como fazemos isso e vamos nos estabelecer

44654
29:38:27,440 --> 29:38:29,760
nosso próprio método virtual no cão, que é

44655
29:38:29,760 --> 29:38:31,760
Vou ser latido e nós podemos realmente fazer

44656
29:38:31,760 --> 29:38:34,080
Tudo o que queremos com esta herança

44657
29:38:34,080 --> 29:38:35,760
Hierarquia o que nós vamos ser

44658
29:38:35,760 --> 29:38:38,160
Usando como entrada é um ponteiro de classe base

44659
29:38:38,160 --> 29:38:40,480
ou uma referência de classe base e nós definamos

44660
29:38:40,480 --> 29:38:43,512
Eles aqui em cima, este é o nosso ponteiro base

44661
29:38:43,512 --> 29:38:45,760
Esta é a nossa referência básica e nós queremos

44662
29:38:45,760 --> 29:38:48,720
para ir a partir destes e criar um

44663
29:38:48,720 --> 29:38:51,280
ponto de aula ou referência que podemos

44664
29:38:51,280 --> 29:38:52,960
Use para até mesmo ligar

44665
29:38:52,960 --> 29:38:55,360
funções não polimórficas e nós podemos

44666
29:38:55,360 --> 29:38:58,232
conseguir isso usando moldes dinâmicos aqui

44667
29:38:58,232 --> 29:38:59,912
nós vamos te mostrar como você pode escalar

44668
29:38:59,912 --> 29:39:02,640
apontadores novamente nosso ponteiro de base animal

44669
29:39:02,640 --> 29:39:06,552
vai agir como nossa contribuição e a

44670
29:39:06,552 --> 29:39:08,640
A produção vai ser o que queremos

44671
29:39:08,640 --> 29:39:11,120
Saie dessa transformação

44672
29:39:11,120 --> 29:39:13,760
e tudo o que fazemos é dizer elenco dinâmico

44673
29:39:13,760 --> 29:39:17,192
Especifique um par de suportes angulares para dentro

44674
29:39:17,192 --> 29:39:18,872
vamos especificar a saída que nós

44675
29:39:18,872 --> 29:39:21,192
Quero ficar e isso geralmente vai

44676
29:39:21,192 --> 29:39:24,000
ser um ponteiro de classe derivado para que a base

44677
29:39:24,000 --> 29:39:25,912
O ponteiro de classe vai estar dentro disso

44678
29:39:25,912 --> 29:39:28,000
parênteses e vai ser o nosso

44679
29:39:28,000 --> 29:39:29,832
saída e isso vai fazer o

44680
29:39:29,832 --> 29:39:31,680
Transformação e vai nos dar

44681
29:39:31,680 --> 29:39:34,232
Um resultado que vamos armazenar

44682
29:39:34,232 --> 29:39:37,440
em nosso ponteiro felino aqui e se isso

44683
29:39:37,440 --> 29:39:41,192
O sucesso teremos um felino válido

44684
29:39:41,192 --> 29:39:44,040
ponteiro aqui e podemos usá-lo para chamar

44685
29:39:44,040 --> 29:39:47,440
Funções não polimórficas ou não virtuais

44686
29:39:47,440 --> 29:39:49,440
Como estamos fazendo aqui e isso é super

44687
29:39:49,440 --> 29:39:51,512
esfria outra coisa que você pode fazer com isso

44688
29:39:51,512 --> 29:39:53,912
é usar o resultado desta transformação

44689
29:39:53,912 --> 29:39:56,480
Em uma verificação de ponte, por exemplo, podemos

44690
29:39:56,480 --> 29:39:58,800
Verifique e veja se este ponteiro não é um

44691
29:39:58,800 --> 29:40:01,040
Ir ponteiro nulo se não for um ponteiro nulo

44692
29:40:01,040 --> 29:40:03,592
Podemos chamar nossa função não-polimórfica

44693
29:40:03,592 --> 29:40:06,400
para ele o resultado foi bem sucedido, mas se

44694
29:40:06,400 --> 29:40:08,960
Não é nenhum ponteiro que vamos falhar e

44695
29:40:08,960 --> 29:40:11,192
cair aqui e podemos dizer que nós

44696
29:40:11,192 --> 29:40:14,400
Não poderia lançar um ponto de referência e

44697
29:40:14,400 --> 29:40:16,232
Alguns de vocês podem perguntar

44698
29:40:16,232 --> 29:40:19,440
Como essa transformação pode falhar bem se

44699
29:40:19,440 --> 29:40:22,872
Voltamos ao nosso código aqui temos um

44700
29:40:22,872 --> 29:40:25,192
ponteiro base animal que é realmente

44701
29:40:25,192 --> 29:40:28,552
apontando para um objeto felino na memória

44702
29:40:28,552 --> 29:40:31,360
se tentarmos lançar este ponteiro animal

44703
29:40:31,360 --> 29:40:32,720
para o cão

44704
29:40:32,720 --> 29:40:34,832
Suponha que queremos fazer esse tipo de

44705
29:40:34,832 --> 29:40:37,120
Transformação tente pensar sobre isso

44706
29:40:37,120 --> 29:40:38,800
Isso não vai funcionar porque nós

44707
29:40:38,800 --> 29:40:41,040
Realmente não tem informações de cães neste

44708
29:40:41,040 --> 29:40:43,512
Objeto vilão e se tentarmos lançar

44709
29:40:43,512 --> 29:40:45,912
Isto para cão o compilador vai realmente

44710
29:40:45,912 --> 29:40:47,680
Não tenho como fazer isso e

44711
29:40:47,680 --> 29:40:50,640
transformação através do elenco dinâmico irá

44712
29:40:50,640 --> 29:40:53,912
falhar e vamos dizer a mensagem aqui

44713
29:40:53,912 --> 29:40:55,280
significando que não poderíamos fazer o

44714
29:40:55,280 --> 29:40:58,080
transformação que o usuário pediu para isso

44715
29:40:58,080 --> 29:41:00,232
Aqui podemos fazer a transformação e

44716
29:41:00,232 --> 29:41:02,720
transformar de um ponteiro base para um

44717
29:41:02,720 --> 29:41:04,960
ponteiro derivado, mas nós também podemos

44718
29:41:04,960 --> 29:41:07,592
transformar em referência derivada e i

44719
29:41:07,592 --> 29:41:09,592
Vou mostrar-lhe a sintaxe para fazer

44720
29:41:09,592 --> 29:41:11,592
Isso e é super simples nós dizemos

44721
29:41:11,592 --> 29:41:14,552
elenco dinâmico e nós especificamos nossa entrada

44722
29:41:14,552 --> 29:41:15,680
Referência

44723
29:41:15,680 --> 29:41:17,440
notar que esta é uma referência que você tem

44724
29:41:17,440 --> 29:41:20,640
para dizer que não é um ponteiro e você

44725
29:41:20,640 --> 29:41:23,680
especificar a saída dentro deste ângulo

44726
29:41:23,680 --> 29:41:26,000
suportes aqui uma vez que você faz isso o

44727
29:41:26,000 --> 29:41:28,232
A produção disso vai ser um derivado

44728
29:41:28,232 --> 29:41:30,400
referência e vamos armazenar isso

44729
29:41:30,400 --> 29:41:33,760
em nossa referência felina aqui uma vez que fazemos

44730
29:41:33,760 --> 29:41:35,192
Esta transformação e a

44731
29:41:35,192 --> 29:41:36,960
A transformação é bem sucedida, estamos indo

44732
29:41:36,960 --> 29:41:39,120
para ser capaz de chamar a nossa não-polimórfica

44733
29:41:39,120 --> 29:41:41,512
função isso vai funcionar, mas com

44734
29:41:41,512 --> 29:41:43,680
referências que não temos o luxo de

44735
29:41:43,680 --> 29:41:45,512
fazer algo como um teste de ponteiro

44736
29:41:45,512 --> 29:41:47,912
Porque não existe tal coisa como um nulo

44737
29:41:47,912 --> 29:41:50,400
referência que uma referência está sempre apontando

44738
29:41:50,400 --> 29:41:51,760
para alguma coisa

44739
29:41:51,760 --> 29:41:54,080
E se a transformação falhar, nós

44740
29:41:54,080 --> 29:41:56,720
ter algum tipo de referência inválida e

44741
29:41:56,720 --> 29:41:58,720
Se isso falhar, provavelmente vai

44742
29:41:58,720 --> 29:42:01,360
explodir e nos dar um comportamento indefinido

44743
29:42:01,360 --> 29:42:03,832
então você realmente não quer fazer isso eu

44744
29:42:03,832 --> 29:42:06,400
Geralmente não recomenda

44745
29:42:06,400 --> 29:42:08,552
fazer esse tipo de transformação com

44746
29:42:08,552 --> 29:42:10,800
Referências a não ser que você saiba

44747
29:42:10,800 --> 29:42:12,960
Que a transformação é possível

44748
29:42:12,960 --> 29:42:15,760
de antemão o que eu recomendo é

44749
29:42:15,760 --> 29:42:16,800
A sua forma de

44750
29:42:16,800 --> 29:42:18,960
passar por ponteiros e é mesmo

44751
29:42:18,960 --> 29:42:21,360
É possível transformar uma referência base

44752
29:42:21,360 --> 29:42:24,552
em um ponteiro derivado e a sintaxe para

44753
29:42:24,552 --> 29:42:27,192
fazer isso é o que você vê aqui bem e uh

44754
29:42:27,192 --> 29:42:30,480
Uma vez que fazemos uma transformação para um ponteiro

44755
29:42:30,480 --> 29:42:32,400
Se a transformação for bem-sucedida

44756
29:42:32,400 --> 29:42:34,080
Nós vamos ter um ponteiro válido em

44757
29:42:34,080 --> 29:42:36,400
Aqui, se a transformação falhar, estamos

44758
29:42:36,400 --> 29:42:38,400
ter um ponteiro nulo e a

44759
29:42:38,400 --> 29:42:40,960
O check vai nos atrair aqui e nós estamos

44760
29:42:40,960 --> 29:42:43,280
Vou imprimir esta mensagem para dizer que

44761
29:42:43,280 --> 29:42:45,680
Não podemos fazer a transformação aqui bem

44762
29:42:45,680 --> 29:42:48,552
Mais uma vez o elenco pode falhar se falhar

44763
29:42:48,552 --> 29:42:50,720
enquanto estamos tentando transformá-lo em um

44764
29:42:50,720 --> 29:42:52,800
dog pointer vamos cair

44765
29:42:52,800 --> 29:42:55,592
Aqui e dizer que o elenco falhou, podemos

44766
29:42:55,592 --> 29:42:56,960
fazer a mesma coisa através

44767
29:42:56,960 --> 29:42:59,120
referências, por exemplo, se quisermos

44768
29:42:59,120 --> 29:43:01,120
transformar esta referência base para um

44769
29:43:01,120 --> 29:43:02,872
Ponto de referência derivado

44770
29:43:02,872 --> 29:43:04,720
E isso falha, vamos seguir

44771
29:43:04,720 --> 29:43:06,800
por causa da verificação que estamos fazendo

44772
29:43:06,800 --> 29:43:08,720
Aqui podemos fazer algo assim para

44773
29:43:08,720 --> 29:43:11,512
tornar nosso código muito mais seguro para trabalhar

44774
29:43:11,512 --> 29:43:13,192
e outra coisa que eu realmente deveria apontar

44775
29:43:13,192 --> 29:43:15,440
Para fora é que na prática

44776
29:43:15,440 --> 29:43:17,912
Fundição como esta geralmente é feita em

44777
29:43:17,912 --> 29:43:20,720
funções onde você está passando uma base

44778
29:43:20,720 --> 29:43:22,832
ponteiro ou uma referência de base como

44779
29:43:22,832 --> 29:43:25,832
parâmetro e nesta função você

44780
29:43:25,832 --> 29:43:28,552
De alguma forma precisa chamar de um não-polimórfico

44781
29:43:28,552 --> 29:43:30,480
Função para que você possa fazer algo como

44782
29:43:30,480 --> 29:43:32,232
isto e tomar o ponteiro e virar que

44783
29:43:32,232 --> 29:43:34,640
em um ponteiro derivado e se o

44784
29:43:34,640 --> 29:43:36,080
A transformação é bem sucedida você

44785
29:43:36,080 --> 29:43:37,912
vai chamar o seu método e se o

44786
29:43:37,912 --> 29:43:39,680
Check falha que você vai seguir aqui

44787
29:43:39,680 --> 29:43:42,000
e imprimir uma mensagem de erro que você pode fazer

44788
29:43:42,000 --> 29:43:44,320
Algo assim com ponteiros e nós

44789
29:43:44,320 --> 29:43:46,720
pode fazer exatamente a mesma coisa com

44790
29:43:46,720 --> 29:43:48,872
referências, mas aqui porque queremos

44791
29:43:48,872 --> 29:43:51,120
fazer este cheque vamos transformar

44792
29:43:51,120 --> 29:43:53,512
nossa referência básica em um

44793
29:43:53,512 --> 29:43:55,912
apontar e chamar o nosso método no

44794
29:43:55,912 --> 29:43:58,080
ponteiro derivado, em vez disso, isso vai

44795
29:43:58,080 --> 29:44:00,232
dar-nos a capacidade de fazer este tipo de

44796
29:44:00,232 --> 29:44:03,120
Verifique para tornar nosso código muito mais seguro

44797
29:44:03,120 --> 29:44:05,360
trabalhar com uma palavra de cautela aqui

44798
29:44:05,360 --> 29:44:08,400
O excesso de lançamento é um sinal de ruim

44799
29:44:08,400 --> 29:44:10,872
design se você se encontrar fazendo isso

44800
29:44:10,872 --> 29:44:12,640
É muito para chamar

44801
29:44:12,640 --> 29:44:15,192
Função não-polimórfica que talvez seja um

44802
29:44:15,192 --> 29:44:16,960
Assine que você deve fazer isso

44803
29:44:16,960 --> 29:44:18,960
Função não polimórfica

44804
29:44:18,960 --> 29:44:21,120
Polimórfico porque isso vai salvar

44805
29:44:21,120 --> 29:44:22,400
você de fazer esse tipo de

44806
29:44:22,400 --> 29:44:24,720
Transformações muito apenas certifique-se de que

44807
29:44:24,720 --> 29:44:27,912
Não usar isso demais e faça isso em alguns

44808
29:44:27,912 --> 29:44:30,160
casos em que você realmente precisa fazer isso

44809
29:44:30,160 --> 29:44:31,680
Uma coisa agora que você sabe disso

44810
29:44:31,680 --> 29:44:33,040
nós vamos ir para o visual

44811
29:44:33,040 --> 29:44:34,872
código de estúdio e jogar com a gente um pouco

44812
29:44:34,872 --> 29:44:37,680
Mais aqui estamos em nossa pasta de trabalho

44813
29:44:37,680 --> 29:44:40,080
O projeto atual é de moldes dinâmicos

44814
29:44:40,080 --> 29:44:43,192
nós vamos pegar nossos arquivos de modelo

44815
29:44:43,192 --> 29:44:44,640
E nós vamos colocá-los no lugar

44816
29:44:44,640 --> 29:44:46,872
Vamos fazer isso e nós vamos agarrar

44817
29:44:46,872 --> 29:44:49,440
Os arquivos que compõem a nossa herança

44818
29:44:49,440 --> 29:44:51,592
Hierarquia, vamos colocar isso em nós

44819
29:44:51,592 --> 29:44:54,720
ter cão de estimação e felino e isso é

44820
29:44:54,720 --> 29:44:56,872
Vou fazer a nossa herança

44821
29:44:56,872 --> 29:44:59,192
Hierarquia aqui, uma vez que temos isso em

44822
29:44:59,192 --> 29:45:00,872
lugar onde podemos abrir isso em

44823
29:45:00,872 --> 29:45:02,720
código de estúdio arrastando e soltando

44824
29:45:02,720 --> 29:45:04,960
Aqui e isso vai nos dar o nosso

44825
29:45:04,960 --> 29:45:07,760
Arquivos OK temos nossos arquivos aqui

44826
29:45:07,760 --> 29:45:10,080
pode abrir a classe animal que é

44827
29:45:10,080 --> 29:45:12,320
nossa classe base podemos ver que é

44828
29:45:12,320 --> 29:45:14,000
Realmente simples só vai ter

44829
29:45:14,000 --> 29:45:16,160
um método virtual que é breve é

44830
29:45:16,160 --> 29:45:18,400
ter uma única variável de membro

44831
29:45:18,400 --> 29:45:20,720
que é descrição aqui que podemos derivar

44832
29:45:20,720 --> 29:45:22,720
a partir disso e criar nossa classe felina

44833
29:45:22,720 --> 29:45:24,960
que vai herdar publicamente de

44834
29:45:24,960 --> 29:45:28,320
o felino animal vai montar o seu próprio

44835
29:45:28,320 --> 29:45:30,400
método que não é virtual

44836
29:45:30,400 --> 29:45:32,400
e teremos um método virtual chamado

44837
29:45:32,400 --> 29:45:34,800
correr, podemos substituir em downstream

44838
29:45:34,800 --> 29:45:37,192
classes se quisermos fazer isso e vamos

44839
29:45:37,192 --> 29:45:39,680
Veja a implementação do felino

44840
29:45:39,680 --> 29:45:41,680
cpp se você quiser fazer isso, você pode tomar

44841
29:45:41,680 --> 29:45:43,360
Um olhar é apenas ir para a frente

44842
29:45:43,360 --> 29:45:46,480
construção para a classe base para construir

44843
29:45:46,480 --> 29:45:48,552
A parte base de nós

44844
29:45:48,552 --> 29:45:50,400
Vamos olhar para o cão cão vai

44845
29:45:50,400 --> 29:45:52,400
herdar do felino e vai

44846
29:45:52,400 --> 29:45:55,040
configurar uma função virtual simples chamada

44847
29:45:55,040 --> 29:45:56,800
trabalho e vai ter um virtual

44848
29:45:56,800 --> 29:45:58,480
Destructor agora sabemos que devemos

44849
29:45:58,480 --> 29:45:59,760
Realmente colocado em

44850
29:45:59,760 --> 29:46:02,232
disruptores virtuais se acontecermos até

44851
29:46:02,232 --> 29:46:04,960
ter um único método virtual em nosso

44852
29:46:04,960 --> 29:46:06,800
Hierarquia de herança porque isso é

44853
29:46:06,800 --> 29:46:09,680
Vou tornar os eventos mais fáceis agora que queremos

44854
29:46:09,680 --> 29:46:12,720
para ir para o arquivo principal cpp e jogar com

44855
29:46:12,720 --> 29:46:14,872
moldes dinâmicos que vamos remover

44856
29:46:14,872 --> 29:46:17,040
Seja o que for, não precisamos aqui e

44857
29:46:17,040 --> 29:46:19,440
que podemos incluir o nosso mais derivado

44858
29:46:19,440 --> 29:46:22,400
classe vamos incluir doug aqui este é

44859
29:46:22,400 --> 29:46:24,720
indo para implicitamente incluir

44860
29:46:24,720 --> 29:46:27,592
tanto felino quanto animal, porque isso

44861
29:46:27,592 --> 29:46:30,000
O cabeçalho vai incluir seu pai

44862
29:46:30,000 --> 29:46:32,160
e seu pai vai incluir

44863
29:46:32,160 --> 29:46:34,872
Pai próprio pai, esta é a lógica aqui que somos

44864
29:46:34,872 --> 29:46:37,832
começar usando um simples

44865
29:46:37,832 --> 29:46:39,680
exemplo aqui e mostrar que você não pode

44866
29:46:39,680 --> 29:46:42,960
realmente chamar funções não polimórficas

44867
29:46:42,960 --> 29:46:45,440
de um ponteiro base que está gerenciando o

44868
29:46:45,440 --> 29:46:48,400
O objeto derivado e aqui temos uma

44869
29:46:48,400 --> 29:46:51,120
ponteiro animal é um ponteiro base e

44870
29:46:51,120 --> 29:46:54,800
está gerenciando um objeto felino real em

44871
29:46:54,800 --> 29:46:57,280
memória, mas se tentarmos chamar a

44872
29:46:57,280 --> 29:46:59,512
Função não virtual através desta base

44873
29:46:59,512 --> 29:47:01,912
pontodor isso vai explodir isso é

44874
29:47:01,912 --> 29:47:04,320
Não vou trabalhar porque

44875
29:47:04,320 --> 29:47:06,480
Não podemos realmente chamar um não polimórfico

44876
29:47:06,480 --> 29:47:08,800
função através de um ponteiro base porque

44877
29:47:08,800 --> 29:47:10,800
que não é uma função virtual

44878
29:47:10,800 --> 29:47:12,800
A exigência de ser capaz de fazer isso é para

44879
29:47:12,800 --> 29:47:15,760
A função de ser virtual e fazer alguns

44880
29:47:15,760 --> 29:47:18,640
Sentir thingy não é uma função virtual

44881
29:47:18,640 --> 29:47:20,960
que sabemos no nível básico, então isso

44882
29:47:20,960 --> 29:47:22,960
não vai funcionar por padrão e se

44883
29:47:22,960 --> 29:47:24,552
Estamos tentando construir um código como este

44884
29:47:24,552 --> 29:47:26,080
Isto vai dar-nos um compilador

44885
29:47:26,080 --> 29:47:28,872
Erro vamos passar isso através do gcc, estamos

44886
29:47:28,872 --> 29:47:31,192
Vou fazer isso, vamos terminar

44887
29:47:31,192 --> 29:47:33,192
O mundo com erros e se subirmos

44888
29:47:33,192 --> 29:47:35,512
nós vamos encontrar esse animal de classe

44889
29:47:35,512 --> 29:47:38,000
Não tem nome de membro para fazer algum felino

44890
29:47:38,000 --> 29:47:39,912
thingy, então este é o erro do compilador

44891
29:47:39,912 --> 29:47:42,232
Aqui isso não vai funcionar se nós

44892
29:47:42,232 --> 29:47:44,232
Preciso fazer algo como este

44893
29:47:44,232 --> 29:47:47,192
A solução pode ser fazer moldes dinâmicos

44894
29:47:47,192 --> 29:47:48,960
que estamos aprendendo sobre isso

44895
29:47:48,960 --> 29:47:51,040
palestra aqui e a sintaxe é

44896
29:47:51,040 --> 29:47:53,832
ridiculamente simples para que possamos descer

44897
29:47:53,832 --> 29:47:56,400
aqui e colocar em um simples separador para ser

44898
29:47:56,400 --> 29:47:58,720
capaz de seguir esta lente em nosso

44899
29:47:58,720 --> 29:48:00,960
janela powershell você pode fazer isso se você

44900
29:48:00,960 --> 29:48:03,440
Queremos e nós vamos fazer a nossa dinâmica

44901
29:48:03,440 --> 29:48:06,552
elenco, por exemplo, se quiséssemos fazer um

44902
29:48:06,552 --> 29:48:09,360
Transformar e transformar isso em um

44903
29:48:09,360 --> 29:48:12,320
Objeto escuro isso nos daria um problema

44904
29:48:12,320 --> 29:48:14,160
e vamos tentar olhar para isso novamente nós

44905
29:48:14,160 --> 29:48:16,720
Tenho um objeto felino aqui e nós estamos

44906
29:48:16,720 --> 29:48:19,192
gerenciando isso através de um ponteiro base e

44907
29:48:19,192 --> 29:48:21,280
O que queremos fazer é tomar este espaço

44908
29:48:21,280 --> 29:48:23,680
ponteiro e transformá-lo em

44909
29:48:23,680 --> 29:48:26,232
Um objeto de cão se você olhar para isso

44910
29:48:26,232 --> 29:48:28,080
Lembre-se que nós realmente não temos nenhum

44911
29:48:28,080 --> 29:48:30,400
informações do cão em nosso objeto felino

44912
29:48:30,400 --> 29:48:32,480
isso vai subir ao nível

44913
29:48:32,480 --> 29:48:35,192
de felino, mas queremos transformar isso

44914
29:48:35,192 --> 29:48:37,592
para um cão para deixar isso super claro, vamos

44915
29:48:37,592 --> 29:48:40,552
Olhe para a nossa hierarquia de herança novamente

44916
29:48:40,552 --> 29:48:43,280
O que temos é um objeto felino e

44917
29:48:43,280 --> 29:48:45,360
A informação que temos realmente sobe

44918
29:48:45,360 --> 29:48:46,400
Este nível

44919
29:48:46,400 --> 29:48:48,552
e estamos gerenciando nosso objeto de sentimento

44920
29:48:48,552 --> 29:48:50,800
através de um ponteiro base esta é a configuração

44921
29:48:50,800 --> 29:48:52,640
nós temos, mas nós queremos fazer o

44922
29:48:52,640 --> 29:48:54,720
Transformação e transformar essa base

44923
29:48:54,720 --> 29:48:57,832
ponteiro em um objeto de cão e este é

44924
29:48:57,832 --> 29:49:00,080
Vou explodir especialmente se tivermos

44925
29:49:00,080 --> 29:49:02,640
quaisquer variáveis de membros específicos do cão este

44926
29:49:02,640 --> 29:49:04,232
Vai explodir isso não vai

44927
29:49:04,232 --> 29:49:06,960
trabalho se tentarmos acessar a informação do cão

44928
29:49:06,960 --> 29:49:07,832
Por meio de

44929
29:49:07,832 --> 29:49:09,832
O que temos através da transformação

44930
29:49:09,832 --> 29:49:11,912
Para o animal para o cão nós vamos ter um

44931
29:49:11,912 --> 29:49:13,440
crush porque não temos tal

44932
29:49:13,440 --> 29:49:15,280
informações e vamos olhar para um

44933
29:49:15,280 --> 29:49:17,592
Exemplo simples para realmente levar isso para casa

44934
29:49:17,592 --> 29:49:19,592
Então, o que vamos fazer é voltar para

44935
29:49:19,592 --> 29:49:21,592
nossa classe de cães e nós vamos colocar

44936
29:49:21,592 --> 29:49:23,440
uma variável de membro de amostra que vamos

44937
29:49:23,440 --> 29:49:26,000
torná-lo privado e, por exemplo, podemos

44938
29:49:26,000 --> 29:49:28,400
fazer disso uma variável de membro para manter

44939
29:49:28,400 --> 29:49:30,400
pista da velocidade para a doca que podemos

44940
29:49:30,400 --> 29:49:32,552
fazer isso e vamos inicializar

44941
29:49:32,552 --> 29:49:34,400
isso para 0 por padrão e nós vamos

44942
29:49:34,400 --> 29:49:36,800
configurar uma função que vai

44943
29:49:36,800 --> 29:49:39,512
imprimir algumas informações do cão vamos voltar

44944
29:49:39,512 --> 29:49:42,080
para felino e copiar o fazer algum felino

44945
29:49:42,080 --> 29:49:44,640
método de coisa e nós vamos fazer alguns

44946
29:49:44,640 --> 29:49:47,120
cão coisa que é o que vamos fazer

44947
29:49:47,120 --> 29:49:48,960
Aqui eu vou colocar neste método

44948
29:49:48,960 --> 29:49:51,040
E adaptá-lo um pouco, vamos

44949
29:49:51,040 --> 29:49:53,760
fazer alguma coisa de cão e nós vamos

44950
29:49:53,760 --> 29:49:56,552
explicar isso no corpo, mas nós também

44951
29:49:56,552 --> 29:49:58,552
Quer imprimir a velocidade para este cão

44952
29:49:58,552 --> 29:50:00,640
Aqui, vamos dizer velocidade e

44953
29:50:00,640 --> 29:50:03,040
nós vamos imprimir isso, suponha que nós

44954
29:50:03,040 --> 29:50:05,040
ter este tipo de configuração em nosso

44955
29:50:05,040 --> 29:50:07,832
Hierarquia de herança aqui um objeto escuro

44956
29:50:07,832 --> 29:50:10,080
tem alguma dúvida de informações específicas

44957
29:50:10,080 --> 29:50:12,080
tem uma variável de membro adicional que

44958
29:50:12,080 --> 29:50:14,400
é m velocidade aqui que não vamos nos preocupar

44959
29:50:14,400 --> 29:50:16,320
inicializando isso a partir do construtor

44960
29:50:16,320 --> 29:50:17,912
Você pode fazer isso se quisermos tudo o que nós

44961
29:50:17,912 --> 29:50:21,360
realmente querer é adicionar alguns dados extras em

44962
29:50:21,360 --> 29:50:23,360
o nível do cão e nós vamos ver

44963
29:50:23,360 --> 29:50:25,760
que se tentarmos transformar para doug isso

44964
29:50:25,760 --> 29:50:27,912
vai nos dar alguns problemas assim

44965
29:50:27,912 --> 29:50:30,720
O que queremos é transformar essa base de animais

44966
29:50:30,720 --> 29:50:33,280
ponteiro para um objeto escuro, vamos fazer isso

44967
29:50:33,280 --> 29:50:34,400
nós vamos

44968
29:50:34,400 --> 29:50:37,280
mudar isso para o cão e o objeto de resultado

44969
29:50:37,280 --> 29:50:39,680
nós vamos ser um ponteiro de cachorro e

44970
29:50:39,680 --> 29:50:41,760
Nós queremos chamar o fazer

44971
29:50:41,760 --> 29:50:43,912
Um pouco de dog thingy

44972
29:50:43,912 --> 29:50:46,480
método no ponteiro que obtemos como resultado

44973
29:50:46,480 --> 29:50:48,552
dessa transformação aqui vamos ver

44974
29:50:48,552 --> 29:50:50,160
O que acontece você vai ver isso

44975
29:50:50,160 --> 29:50:51,680
Isso não vai nos dar nenhum

44976
29:50:51,680 --> 29:50:53,760
Indicar que estamos fazendo algo

44977
29:50:53,760 --> 29:50:56,320
errado, mas se for a transformação aqui

44978
29:50:56,320 --> 29:50:59,192
falhar isso vai falhar silenciosamente e

44979
29:50:59,192 --> 29:51:01,912
armazenar dados de lixo em nosso ponteiro felino

44980
29:51:01,912 --> 29:51:04,000
Aqui e aqui vamos tentar

44981
29:51:04,000 --> 29:51:07,192
chamar um método que vai possivelmente

44982
29:51:07,192 --> 29:51:10,000
Use algumas coisas de cachorro no objeto felino

44983
29:51:10,000 --> 29:51:12,232
Isso vai explodir de novo, nós não

44984
29:51:12,232 --> 29:51:14,320
ter informações do cão neste felino

44985
29:51:14,320 --> 29:51:16,640
objeto e fazer algum cão pensando

44986
29:51:16,640 --> 29:51:18,552
O método vai tentar imprimir o

44987
29:51:18,552 --> 29:51:21,040
velocidade do cão que nós realmente não

44988
29:51:21,040 --> 29:51:23,360
Não temos nenhuma informação do cão

44989
29:51:23,360 --> 29:51:26,160
por isso não temos negócios para acessar o cão

44990
29:51:26,160 --> 29:51:28,232
informações deste objeto para começar

44991
29:51:28,232 --> 29:51:30,160
com isso vai explodir e

44992
29:51:30,160 --> 29:51:32,160
Provavelmente vai nos dar um acidente

44993
29:51:32,160 --> 29:51:34,080
Vamos tentar construir e ver o que acontece

44994
29:51:34,080 --> 29:51:35,760
nós vamos passar isso através do gcc

44995
29:51:35,760 --> 29:51:37,760
Como sempre fazemos, o barco vai

44996
29:51:37,760 --> 29:51:40,000
passar por você ver que isso vai

44997
29:51:40,000 --> 29:51:43,360
até mesmo explodir no tempo de execução quando os usuários estão

44998
29:51:43,360 --> 29:51:45,440
Na verdade, usando sua aplicação, isso é

44999
29:51:45,440 --> 29:51:48,080
Super perigoso vamos correr isso

45000
29:51:48,080 --> 29:51:50,080
e ver o que acontece você vê fazendo alguns

45001
29:51:50,080 --> 29:51:51,912
cavado coisay e vai tentar e

45002
29:51:51,912 --> 29:51:54,160
Imprimir a velocidade que o compilador é realmente

45003
29:51:54,160 --> 29:51:56,232
tentando o seu melhor, mas isso realmente está indo

45004
29:51:56,232 --> 29:51:59,440
para falhar e estamos quebrando nosso programa

45005
29:51:59,440 --> 29:52:02,480
Se você descer aqui e dizer feito para fazer

45006
29:52:02,480 --> 29:52:05,120
Saiba quando o programa é feito

45007
29:52:05,120 --> 29:52:07,192
e tentamos executar nosso programa novamente

45008
29:52:07,192 --> 29:52:09,280
Vamos passar isso através do gcc para levar para

45009
29:52:09,280 --> 29:52:11,680
conta desta coisa temos na linha 20.

45010
29:52:11,680 --> 29:52:12,960
O livro vai ser bom você

45011
29:52:12,960 --> 29:52:14,872
Vou ver que o computador está indo

45012
29:52:14,872 --> 29:52:16,800
para tentar realmente executar isso, mas é

45013
29:52:16,800 --> 29:52:18,320
Vou ver que não tem realmente

45014
29:52:18,320 --> 29:52:20,872
qualquer informação do cão e o computador é

45015
29:52:20,872 --> 29:52:22,552
Não vamos ter sucesso porque nós somos

45016
29:52:22,552 --> 29:52:24,800
tentando acessar este dub specific

45017
29:52:24,800 --> 29:52:27,832
informações realmente sobre um objeto felino, então

45018
29:52:27,832 --> 29:52:29,592
nós vamos ter um acidente novamente

45019
29:52:29,592 --> 29:52:30,400
Mensagem de mensagem

45020
29:52:30,400 --> 29:52:33,592
é que esses moldes dinâmicos podem falhar

45021
29:52:33,592 --> 29:52:35,912
e precisamos de uma maneira melhor de fazer algum tipo

45022
29:52:35,912 --> 29:52:38,800
de verificações antes de chamarmos nossos métodos

45023
29:52:38,800 --> 29:52:41,360
aqui e podemos fazer isso apenas usando

45024
29:52:41,360 --> 29:52:43,192
O ponteiro que temos a partir disso

45025
29:52:43,192 --> 29:52:45,512
Transformação aqui para que possamos dizer se

45026
29:52:45,512 --> 29:52:48,080
ponteiro felino e verificar e ver se nós

45027
29:52:48,080 --> 29:52:50,640
ter alguns dados válidos neste vilão

45028
29:52:50,640 --> 29:52:52,552
ponteiro e se esse é o caso, nós somos

45029
29:52:52,552 --> 29:52:54,720
Vou fazer o que quisermos fazer com

45030
29:52:54,720 --> 29:52:57,192
Este ponteiro aqui está bem, então isso é

45031
29:52:57,192 --> 29:52:58,720
Algo que nós podemos fazer

45032
29:52:58,720 --> 29:53:01,192
E se a transformação falhar, nós somos

45033
29:53:01,192 --> 29:53:03,512
vamos cair neste outro bloco e nós

45034
29:53:03,512 --> 29:53:05,760
Pode colocar alguma mensagem agradável aqui em vez disso

45035
29:53:05,760 --> 29:53:08,480
de deixar o usuário travar em tempo de execução

45036
29:53:08,480 --> 29:53:11,192
Isso é muito melhor na minha opinião, então

45037
29:53:11,192 --> 29:53:13,120
nós vamos dizer que não poderia fazer o

45038
29:53:13,120 --> 29:53:16,320
transformação do ponteiro dos animais para

45039
29:53:16,320 --> 29:53:18,320
dog pointer porque nós realmente não temos

45040
29:53:18,320 --> 29:53:20,640
informações do cão e este ponteiro de base

45041
29:53:20,640 --> 29:53:22,552
que temos aqui isso é algo que nós

45042
29:53:22,552 --> 29:53:24,480
Podemos fazer isso nós vamos dizer sddc para fora

45043
29:53:24,480 --> 29:53:27,680
Eu vou dizer stdendl aqui e nós estamos

45044
29:53:27,680 --> 29:53:30,160
Vou ver o que acontece, vamos construir

45045
29:53:30,160 --> 29:53:31,512
Espero que não consigamos o

45046
29:53:31,512 --> 29:53:33,440
Acidente porque estamos fazendo algo

45047
29:53:33,440 --> 29:53:35,832
Mais inteligente agora estamos verificando para ver

45048
29:53:35,832 --> 29:53:37,832
se tivermos alguma informação de cão neste

45049
29:53:37,832 --> 29:53:40,480
ponteiro antes de chamarmos alguma dúvida

45050
29:53:40,480 --> 29:53:42,720
método específico sobre este ponteiro aqui

45051
29:53:42,720 --> 29:53:44,872
Esta é a beleza disso que estamos indo

45052
29:53:44,872 --> 29:53:47,440
para limpar e correr galo agora você vê

45053
29:53:47,440 --> 29:53:49,120
Não poderia fazer a transformação de

45054
29:53:49,120 --> 29:53:52,232
animal para cão e nosso programa não é

45055
29:53:52,232 --> 29:53:54,960
quebra mais longa está terminando corretamente

45056
29:53:54,960 --> 29:53:56,872
E isso é muito melhor, isso é o que você

45057
29:53:56,872 --> 29:53:59,040
deve apontar para isso novamente o

45058
29:53:59,040 --> 29:54:01,360
Transformações aqui podem falhar

45059
29:54:01,360 --> 29:54:02,160


45060
29:54:02,160 --> 29:54:04,800
Se voltarmos isso para fazer v-line

45061
29:54:04,800 --> 29:54:07,120
transformação, vamos fazer ponteiro felino

45062
29:54:07,120 --> 29:54:08,640
nós vamos mudar isso para preencher

45063
29:54:08,640 --> 29:54:11,512
ponteiro novamente e nós vamos fazer alguns

45064
29:54:11,512 --> 29:54:13,760
A coisa felina agora nós vamos aparafusar

45065
29:54:13,760 --> 29:54:15,440
Mais uma vez e isso é verdade

45066
29:54:15,440 --> 29:54:16,960
nós vamos fugir de novo e isso é

45067
29:54:16,960 --> 29:54:18,800
indo para construir com sucesso e é

45068
29:54:18,800 --> 29:54:20,872
provavelmente vai fazer algum filamento

45069
29:54:20,872 --> 29:54:23,360
Enoado a construção é bom que podemos limpar

45070
29:54:23,360 --> 29:54:25,280
e correr galo que vai funcionar

45071
29:54:25,280 --> 29:54:27,192
Está tudo bem e o nosso programa vai

45072
29:54:27,192 --> 29:54:30,160
terminar corretamente, então aqui acabamos de ver que nós

45073
29:54:30,160 --> 29:54:32,160
Poderia fazer uma transformação a partir de uma base

45074
29:54:32,160 --> 29:54:35,040
ponteiro para um ponteiro derivado e isso é

45075
29:54:35,040 --> 29:54:37,280
indo para o trabalho muito bem, nós também podemos fazer

45076
29:54:37,280 --> 29:54:40,000
a transformação para referências, vamos

45077
29:54:40,000 --> 29:54:42,480
Diga isso aqui e nós vamos descer

45078
29:54:42,480 --> 29:54:44,480
e colocar um exemplo simples para dirigir

45079
29:54:44,480 --> 29:54:46,232
Esta casa nós vamos ter um felino

45080
29:54:46,232 --> 29:54:48,320
Objeto, vamos criar uma referência

45081
29:54:48,320 --> 29:54:51,040
para isso e se tentarmos chamar um

45082
29:54:51,040 --> 29:54:52,960
Método não virtual nesta base

45083
29:54:52,960 --> 29:54:55,040
referência isso vai explodir

45084
29:54:55,040 --> 29:54:56,232
porque

45085
29:54:56,232 --> 29:54:58,480
A classe base não tem informações sobre

45086
29:54:58,480 --> 29:55:01,280
Este método não virtual que declaramos

45087
29:55:01,280 --> 29:55:03,120
no nível felino que isso vai

45088
29:55:03,120 --> 29:55:05,512
blow up se tentarmos construir o nosso programa

45089
29:55:05,512 --> 29:55:06,640
nós vamos ver que nós temos um

45090
29:55:06,640 --> 29:55:09,832
Erro do compilador dizendo que não há tal método

45091
29:55:09,832 --> 29:55:10,720
Como

45092
29:55:10,720 --> 29:55:12,400
fazer alguma coisa de sentimento que vamos ver

45093
29:55:12,400 --> 29:55:15,120
que aqui nenhum membro nomeou

45094
29:55:15,120 --> 29:55:18,552
Desta forma, ao nível animal

45095
29:55:18,552 --> 29:55:20,800
Este é o erro do compilador que o recebemos se nós

45096
29:55:20,800 --> 29:55:24,080
tentar chamar um método não virtual através de

45097
29:55:24,080 --> 29:55:26,320
uma referência básica que temos aqui

45098
29:55:26,320 --> 29:55:29,440
não vai funcionar, mas também podemos fazer

45099
29:55:29,440 --> 29:55:32,320
um molde dinâmico e transformar a partir de uma base

45100
29:55:32,320 --> 29:55:33,680
Referência a

45101
29:55:33,680 --> 29:55:35,912
uma referência derivada e a sintaxe a fazer

45102
29:55:35,912 --> 29:55:38,080
que é realmente aqui vamos definir

45103
29:55:38,080 --> 29:55:39,040
para cima a

45104
29:55:39,040 --> 29:55:41,040
referência derivada neste caso é

45105
29:55:41,040 --> 29:55:43,120
vai ser uma referência de feedline que somos

45106
29:55:43,120 --> 29:55:45,192
inicializar isso com uma dinâmica

45107
29:55:45,192 --> 29:55:47,760
Transformação de elenco e o resultado de

45108
29:55:47,760 --> 29:55:49,512
O elenco vai ser usado para

45109
29:55:49,512 --> 29:55:51,832
inicialize esta referência aqui e nós somos

45110
29:55:51,832 --> 29:55:53,512
Vou levar

45111
29:55:53,512 --> 29:55:56,400
uma referência de base e transformando isso em um

45112
29:55:56,400 --> 29:55:58,160
A referência derivada aqui esta é a

45113
29:55:58,160 --> 29:56:00,720
sintaxe a saída que você deseja vai

45114
29:56:00,720 --> 29:56:03,440
estar dentro deste suporte de ângulo e

45115
29:56:03,440 --> 29:56:05,280
A entrada vai ser através disso

45116
29:56:05,280 --> 29:56:07,680
Parentesis aqui se isso for bem-sucedido

45117
29:56:07,680 --> 29:56:10,000
será capaz de chamar o nosso método aqui e

45118
29:56:10,000 --> 29:56:12,000
Isso vai funcionar muito bem, vamos

45119
29:56:12,000 --> 29:56:13,512
Experimente isso

45120
29:56:13,512 --> 29:56:16,480
vamos colocar em um separador para ser

45121
29:56:16,480 --> 29:56:18,872
capaz de seguir essas coisas, vamos colocar

45122
29:56:18,872 --> 29:56:22,872
que na linha 24 aqui isso vai fazer

45123
29:56:22,872 --> 29:56:24,400
e nós vamos tentar construir o nosso

45124
29:56:24,400 --> 29:56:26,320
programa, vamos passar por isso

45125
29:56:26,320 --> 29:56:29,120
gcc o barco é bom que podemos limpar e

45126
29:56:29,120 --> 29:56:31,680
correr galo agora vamos ver isso

45127
29:56:31,680 --> 29:56:34,640
Estamos fazendo algum preenchimento através

45128
29:56:34,640 --> 29:56:36,640
uma referência e isso é super legal

45129
29:56:36,640 --> 29:56:38,320
Pode fazer isso você pode fazer esse tipo de

45130
29:56:38,320 --> 29:56:40,960
Transformação aqui e no final você

45131
29:56:40,960 --> 29:56:43,192
Veja que estamos chamando nossos destruidores

45132
29:56:43,192 --> 29:56:45,760
em nossos objetos e isso é um bom

45133
29:56:45,760 --> 29:56:48,320
Lembre-se de que não liberamos corretamente

45134
29:56:48,320 --> 29:56:50,720
a memória neste ponteiro animal que

45135
29:56:50,720 --> 29:56:51,760
que tínhamos

45136
29:56:51,760 --> 29:56:54,320
então nós vamos descer no final de

45137
29:56:54,320 --> 29:56:56,552
o programa e liberar essa memória

45138
29:56:56,552 --> 29:56:58,872
é uma boa prática e espero que você possa

45139
29:56:58,872 --> 29:57:02,080
Veja como é fácil esquecer de liberar

45140
29:57:02,080 --> 29:57:04,552
alguma memória que você aloca para

45141
29:57:04,552 --> 29:57:06,720
com o novo operador, isso é um bom

45142
29:57:06,720 --> 29:57:08,960
Experiência de aprendizagem aqui, mas este é um

45143
29:57:08,960 --> 29:57:10,720
Boa experiência de aprendizagem aqui, mas nós somos

45144
29:57:10,720 --> 29:57:12,232
vamos resolver este problema que vamos

45145
29:57:12,232 --> 29:57:13,912
Diga animal um e nós vamos

45146
29:57:13,912 --> 29:57:16,320
Libere a memória agora se executarmos o

45147
29:57:16,320 --> 29:57:18,080
programa vamos ver que estamos

45148
29:57:18,080 --> 29:57:21,680
liberando dois objetos quando o programa

45149
29:57:21,680 --> 29:57:23,912
Termina, vamos limpar e correr

45150
29:57:23,912 --> 29:57:25,760
O galo e o destruidor vão

45151
29:57:25,760 --> 29:57:28,720
ser chamado duas vezes para esse cara

45152
29:57:28,720 --> 29:57:30,872
E um segundo para esse cara é o que

45153
29:57:30,872 --> 29:57:33,680
Queremos e você vê isso porque temos

45154
29:57:33,680 --> 29:57:36,400
Destrutores virtuais em nossas aulas

45155
29:57:36,400 --> 29:57:39,192
estão destruindo em cada nível, então aqui nós

45156
29:57:39,192 --> 29:57:41,592
estão destruindo no nível felino e

45157
29:57:41,592 --> 29:57:43,760
Estamos destruindo no nível animal

45158
29:57:43,760 --> 29:57:46,080
e isso vai liberar corretamente

45159
29:57:46,080 --> 29:57:48,400
A memória da nossa herança

45160
29:57:48,400 --> 29:57:50,480
Hierarquia aqui, então agora você sabe que você

45161
29:57:50,480 --> 29:57:52,960
pode fazer uma transformação de referências

45162
29:57:52,960 --> 29:57:54,960
usando moldes dinâmicos

45163
29:57:54,960 --> 29:57:57,592
Mas com elenco dinâmico não temos como

45164
29:57:57,592 --> 29:58:00,000
Veja se a transformação foi

45165
29:58:00,000 --> 29:58:03,040
Mais uma vez, se tentarmos transformar isso

45166
29:58:03,040 --> 29:58:05,440
em uma referência escura podemos fazer isso e

45167
29:58:05,440 --> 29:58:07,512
nós vamos dizer referência de cachorro aqui

45168
29:58:07,512 --> 29:58:10,552
e vamos tentar chamar o fazer alguns

45169
29:58:10,552 --> 29:58:13,120
duck thingy método isto não vai

45170
29:58:13,120 --> 29:58:14,872
Dá-nos uma indicação de um problema, mas

45171
29:58:14,872 --> 29:58:17,120
isso vai cair em tempo de execução

45172
29:58:17,120 --> 29:58:18,800
Porque nós realmente não temos nenhum cão

45173
29:58:18,800 --> 29:58:20,400
Informações em nosso site

45174
29:58:20,400 --> 29:58:23,360
objeto felino original aqui, então se você

45175
29:58:23,360 --> 29:58:25,760
Tente transformar essa referência em um

45176
29:58:25,760 --> 29:58:28,080
referência de cachorro, isso obviamente não é

45177
29:58:28,080 --> 29:58:29,912
Vou trabalhar porque não temos cachorro

45178
29:58:29,912 --> 29:58:32,232
informações para começar com

45179
29:58:32,232 --> 29:58:34,800
Ferver e mostrar-lhe o problema do livro

45180
29:58:34,800 --> 29:58:37,120
Vai ser bom para que possamos limpar

45181
29:58:37,120 --> 29:58:39,680
e correr galo você vai ver que

45182
29:58:39,680 --> 29:58:41,832
Vamos encerrar nosso programa

45183
29:58:41,832 --> 29:58:44,320
com o elenco da banda e isso vai

45184
29:58:44,320 --> 29:58:46,232
esmagar você vê que nós não chegamos ao

45185
29:58:46,232 --> 29:58:48,960
ponto onde nós imprimimos e nós não somos

45186
29:58:48,960 --> 29:58:50,640
Até mesmo ter uma chance de liberar

45187
29:58:50,640 --> 29:58:52,480
A memória que alocamos em

45188
29:58:52,480 --> 29:58:54,720
Esta função principal espero que você possa ver

45189
29:58:54,720 --> 29:58:56,872
que isso é realmente ruim com

45190
29:58:56,872 --> 29:58:59,280
Referências não temos como

45191
29:58:59,280 --> 29:59:01,512
para verificar e ver se é

45192
29:59:01,512 --> 29:59:04,800
foi bem sucedido e esta é uma limitação

45193
29:59:04,800 --> 29:59:07,280
É por isso que na maioria dos casos eu costumo fazer o meu

45194
29:59:07,280 --> 29:59:10,080
transformações através de ponteiros e

45195
29:59:10,080 --> 29:59:12,000
Há uma maneira que você pode até virar isso

45196
29:59:12,000 --> 29:59:14,872
referência de base em um ponteiro de base e i

45197
29:59:14,872 --> 29:59:16,960
Vou mostrar como você pode fazer isso

45198
29:59:16,960 --> 29:59:19,512
Então vamos descer aqui e tentar

45199
29:59:19,512 --> 29:59:21,280
Mudar as coisas um pouco nós somos

45200
29:59:21,280 --> 29:59:23,440
Vou dizer fazer as verificações adequadas com

45201
29:59:23,440 --> 29:59:25,592
referências e vamos colocar em um

45202
29:59:25,592 --> 29:59:28,000
pedaço de código para jogar conosco e o que

45203
29:59:28,000 --> 29:59:29,592
nós vamos fazer nós vamos levar

45204
29:59:29,592 --> 29:59:30,552
O que é

45205
29:59:30,552 --> 29:59:33,592
referência base e transformar isso em uma base

45206
29:59:33,592 --> 29:59:35,760
pontodor esta é a sintaxe aqui novamente

45207
29:59:35,760 --> 29:59:38,400
a entrada é a referência de base, mas o

45208
29:59:38,400 --> 29:59:40,640
saída que desejamos é um ponteiro de base e

45209
29:59:40,640 --> 29:59:43,280
isso é possível em c plus mais este é

45210
29:59:43,280 --> 29:59:45,440
indo para o trabalho muito bem agora estamos indo

45211
29:59:45,440 --> 29:59:47,280
para ir no topo e comentar isso

45212
29:59:47,280 --> 29:59:49,760
Transformação problemática que nós apenas tentamos

45213
29:59:49,760 --> 29:59:51,512
para fazer e vamos tentar construir

45214
29:59:51,512 --> 29:59:53,912
e veja se isso está realmente funcionando

45215
29:59:53,912 --> 29:59:56,080
Se essa transformação for bem-sucedida, somos

45216
29:59:56,080 --> 29:59:58,400
vou fazer algum vilão, se isso

45217
29:59:58,400 --> 30:00:00,160
falha, vamos dizer que não poderia ser lançado

45218
30:00:00,160 --> 30:00:02,080
para referência felina e nós vamos

45219
30:00:02,080 --> 30:00:04,232
Digamos que lamentamos que isso seja bom

45220
30:00:04,232 --> 30:00:06,640
mensagem de saída se tivermos algo errado

45221
30:00:06,640 --> 30:00:08,640
vamos construir isso com gcc e

45222
30:00:08,640 --> 30:00:11,192
Veja se isso realmente funciona o mundo

45223
30:00:11,192 --> 30:00:12,872
Bom que podemos limpar

45224
30:00:12,872 --> 30:00:15,512
e correr galo você vê que isso é

45225
30:00:15,512 --> 30:00:17,280
trabalhando muito bem, vamos bater o

45226
30:00:17,280 --> 30:00:19,120
Fim do programa e vamos

45227
30:00:19,120 --> 30:00:21,440
destruir nossos objetos aqui isso é super

45228
30:00:21,440 --> 30:00:22,320
cool

45229
30:00:22,320 --> 30:00:23,280


45230
30:00:23,280 --> 30:00:25,280
Se tentarmos fazer a transformação e

45231
30:00:25,280 --> 30:00:27,912
transformá-lo em um objeto escuro, mesmo se

45232
30:00:27,912 --> 30:00:29,592
Eu sei que não temos nenhum cão

45233
30:00:29,592 --> 30:00:32,232
informações neste objeto que somos

45234
30:00:32,232 --> 30:00:34,800
Referindo para começar, esperamos que

45235
30:00:34,800 --> 30:00:37,440
nós vamos receber uma boa mensagem e

45236
30:00:37,440 --> 30:00:39,120
O programa vai acabar corretamente

45237
30:00:39,120 --> 30:00:41,440
nós não vamos ter uma paixão, então vamos

45238
30:00:41,440 --> 30:00:43,440
Certifique-se de que estamos nos transformando em cão

45239
30:00:43,440 --> 30:00:45,120
Aqui vamos passar por um ponteiro de cachorro

45240
30:00:45,120 --> 30:00:47,680
como nossa produção e vamos armazenar

45241
30:00:47,680 --> 30:00:49,760
isso como um ponteiro para cães, mesmo se o nome

45242
30:00:49,760 --> 30:00:52,400
ainda é vlan ponteiro espero que isso seja

45243
30:00:52,400 --> 30:00:54,552
Não vai confundir você, mesmo que isso seja

45244
30:00:54,552 --> 30:00:56,720
chamado feline pointer é um ponteiro de pontos

45245
30:00:56,720 --> 30:00:59,280
Aqui porque nós só queremos ver

45246
30:00:59,280 --> 30:01:01,512
se recebermos a mensagem de erro que temos

45247
30:01:01,512 --> 30:01:03,832
Aqui estamos virando esta referência

45248
30:01:03,832 --> 30:01:06,960
em um ponteiro e o benefício disso

45249
30:01:06,960 --> 30:01:09,680
É que um ponteiro pode armazenar

45250
30:01:09,680 --> 30:01:12,160
apontadores null e podemos usar isso para o nosso

45251
30:01:12,160 --> 30:01:14,400
vantagem para verificar e ver se o

45252
30:01:14,400 --> 30:01:16,800
A transformação aqui foi bem sucedida se

45253
30:01:16,800 --> 30:01:19,192
Foi bem sucedido vamos chamar algum cão

45254
30:01:19,192 --> 30:01:22,232
O método de agradecimento, digamos, aqui e se

45255
30:01:22,232 --> 30:01:23,760
Isso falha, vamos dizer que nós

45256
30:01:23,760 --> 30:01:26,552
não poderia transformar em doug e isso é

45257
30:01:26,552 --> 30:01:28,960
vamos nos dar uma boa mensagem e nossa

45258
30:01:28,960 --> 30:01:30,960
O programa não vai cair, nós somos

45259
30:01:30,960 --> 30:01:33,440
vai construir isso novamente com gcc o que

45260
30:01:33,440 --> 30:01:35,360
Vai ser bom como você vê aqui

45261
30:01:35,360 --> 30:01:37,760
Nós vamos limpar e correr o galo agora

45262
30:01:37,760 --> 30:01:39,512
Você vê que estamos dizendo que não poderíamos

45263
30:01:39,512 --> 30:01:41,680
pegar a referência do cão e nosso programa

45264
30:01:41,680 --> 30:01:44,080
Não está caindo, então se você tem um

45265
30:01:44,080 --> 30:01:46,232
referência para começar e você quer

45266
30:01:46,232 --> 30:01:48,640
fazer algumas verificações adequadas depois de fazer o

45267
30:01:48,640 --> 30:01:51,192
transformação para um ponteiro derivado ou um

45268
30:01:51,192 --> 30:01:53,440
Esta referência derivada é o melhor de

45269
30:01:53,440 --> 30:01:55,120
Ambos os mundos você pode fazer algo como

45270
30:01:55,120 --> 30:01:57,192
este e seu programa vai ser

45271
30:01:57,192 --> 30:01:59,440
Muito mais seguro a última coisa que eu quero que você

45272
30:01:59,440 --> 30:02:02,400
Ver é que esses tipos de elencos dinâmicos

45273
30:02:02,400 --> 30:02:05,040
são realmente úteis se você estiver passando

45274
30:02:05,040 --> 30:02:07,280
ponto de referência ou base em

45275
30:02:07,280 --> 30:02:10,720
funções e aqui vou colocar

45276
30:02:10,720 --> 30:02:12,800
um monte de funções o primeiro é

45277
30:02:12,800 --> 30:02:14,960
Vou tomar um ponteiro base o segundo

45278
30:02:14,960 --> 30:02:16,720
Um deles vai tomar uma referência de base

45279
30:02:16,720 --> 30:02:18,552
e vai dizer com

45280
30:02:18,552 --> 30:02:20,720
ponteiro de animais e faça algo com

45281
30:02:20,720 --> 30:02:22,552
Referência animal e dentro estamos indo

45282
30:02:22,552 --> 30:02:24,160
para fazer a nossa coisa aqui nós vamos levar

45283
30:02:24,160 --> 30:02:25,832
O ponteiro animal transforma isso em um

45284
30:02:25,832 --> 30:02:27,760
Ponto de referência felino e vamos fazer o nosso

45285
30:02:27,760 --> 30:02:29,280
verificação adequada e vamos fazer alguns

45286
30:02:29,280 --> 30:02:31,680
felino se a transformação foi

45287
30:02:31,680 --> 30:02:33,832
bem sucedidos, podemos fazer algo assim

45288
30:02:33,832 --> 30:02:36,160
Também podemos fazer exatamente a mesma coisa

45289
30:02:36,160 --> 30:02:37,912
em referências vamos levar o nosso

45290
30:02:37,912 --> 30:02:39,912
Referência de entrada, vamos transformar isso

45291
30:02:39,912 --> 30:02:42,320
em um objeto derivado e podemos chamar

45292
30:02:42,320 --> 30:02:44,552
nosso método neste ponteiro e nós somos

45293
30:02:44,552 --> 30:02:46,480
vamos fazer bate-papos adequados porque temos

45294
30:02:46,480 --> 30:02:49,120
Um ponteiro que tem um conceito de nó

45295
30:02:49,120 --> 30:02:51,120
pontor que nós obtemos se

45296
30:02:51,120 --> 30:02:53,440
A transformação aqui falha é este

45297
30:02:53,440 --> 30:02:56,160
configuração que podemos usar em nossos programas c plus

45298
30:02:56,160 --> 30:02:58,000
e nós podemos usar esses métodos para obter

45299
30:02:58,000 --> 30:03:00,480
ponteiros derivados que podemos chamar até

45300
30:03:00,480 --> 30:03:02,552
funções não polimórficas e isso é

45301
30:03:02,552 --> 30:03:05,120
Vou trabalhar muito bem para que possamos ir

45302
30:03:05,120 --> 30:03:08,320
para baixo e comentar tudo que eu acho

45303
30:03:08,320 --> 30:03:11,120
para tornar isso super fácil de seguir, mas eu

45304
30:03:11,120 --> 30:03:12,480
Não pense que precisamos comentar

45305
30:03:12,480 --> 30:03:14,320
Tudo que podemos comentar o que

45306
30:03:14,320 --> 30:03:16,160
nós apenas fizemos aqui e nós vamos ser

45307
30:03:16,160 --> 30:03:19,040
reutilizando a referência que temos aqui e

45308
30:03:19,040 --> 30:03:21,040
O ponteiro que temos todo o caminho para o

45309
30:03:21,040 --> 30:03:23,192
No topo, então vamos descer e colocar

45310
30:03:23,192 --> 30:03:25,360
um separador aqui nós podemos fazer isso e

45311
30:03:25,360 --> 30:03:27,280
Por causa deste separador eu não acho

45312
30:03:27,280 --> 30:03:30,080
nós até precisamos comentar as coisas que nós

45313
30:03:30,080 --> 30:03:31,592
pode remover o nosso comentário e deixar o

45314
30:03:31,592 --> 30:03:34,000
código porque eu quero que você veja isso

45315
30:03:34,000 --> 30:03:36,552
super facilmente e nós vamos chamar o nosso

45316
30:03:36,552 --> 30:03:37,832
funções aqui nós vamos dizer fazer

45317
30:03:37,832 --> 30:03:40,000
Algo com ponteiro animal e nós somos

45318
30:03:40,000 --> 30:03:42,080
passar um animal que é um animal

45319
30:03:42,080 --> 30:03:43,680
ponteiro e nós vamos dizer fazer

45320
30:03:43,680 --> 30:03:46,080
Algo com animal ref

45321
30:03:46,080 --> 30:03:48,080
Nós podemos fazer algo assim e nós somos

45322
30:03:48,080 --> 30:03:50,480
Vou passar um animal

45323
30:03:50,480 --> 30:03:52,320
Ref temos esta referência aqui e nós

45324
30:03:52,320 --> 30:03:54,160
Pode fazer algo assim que você está indo

45325
30:03:54,160 --> 30:03:56,800
para ver que isso não vai nos dar

45326
30:03:56,800 --> 30:03:58,480
qualquer tipo de problema e vai

45327
30:03:58,480 --> 30:04:00,232
trabalhar muito bem que é o mundo que estamos indo

45328
30:04:00,232 --> 30:04:02,320
para passar isso através de gcc a foto é

45329
30:04:02,320 --> 30:04:04,400
Vou ser bom, podemos limpar e correr

45330
30:04:04,400 --> 30:04:06,552
O galo e aqui você vê isso em

45331
30:04:06,552 --> 30:04:08,720
função tomando ponteiro base fazendo alguns

45332
30:04:08,720 --> 30:04:11,192
felino na função tomando alguns

45333
30:04:11,192 --> 30:04:13,512
biz referência fazendo algum sentimento

45334
30:04:13,512 --> 30:04:15,592
E isso está funcionando muito bem, isso é

45335
30:04:15,592 --> 30:04:18,480
O que queremos em nossos programas c plus plus

45336
30:04:18,480 --> 30:04:20,400
Isso é realmente tudo que eu queria que você visse

45337
30:04:20,400 --> 30:04:22,080
Nesta palestra espero que você não tenha

45338
30:04:22,080 --> 30:04:24,480
Acho que confundir novamente a mensagem é

45339
30:04:24,480 --> 30:04:27,040
que você pode fazer moldes dinâmicos para

45340
30:04:27,040 --> 30:04:29,440
transformar de um ponteiro base para um

45341
30:04:29,440 --> 30:04:32,640
ponteiro derivado ou para transformar de um

45342
30:04:32,640 --> 30:04:35,440
referência de base a uma referência derivada como

45343
30:04:35,440 --> 30:04:36,552
nós fizemos isso.

45344
30:04:36,552 --> 30:04:39,440
Aqui mesmo, mas transformando-se em uma

45345
30:04:39,440 --> 30:04:42,640
A referência tem uma desvantagem em que você

45346
30:04:42,640 --> 30:04:45,040
Não tem uma maneira de verificar e ver

45347
30:04:45,040 --> 30:04:47,512
Se a transformação foi bem sucedida assim

45348
30:04:47,512 --> 30:04:49,360
Se você quer ser capaz de fazer bate-papos você

45349
30:04:49,360 --> 30:04:51,192
pode fazer algo assim e virar um

45350
30:04:51,192 --> 30:04:53,760
referência de base em um ponteiro derivado

45351
30:04:53,760 --> 30:04:55,912
e então podemos verificar e ver se o

45352
30:04:55,912 --> 30:04:58,000
o ponteiro não é um ponteiro de node se for um

45353
30:04:58,000 --> 30:04:59,440
Não há ponteiro, saberemos que o

45354
30:04:59,440 --> 30:05:01,512
A transformação falhou e vamos imprimir

45355
30:05:01,512 --> 30:05:03,360
uma mensagem de erro boa se o

45356
30:05:03,360 --> 30:05:05,192
A transformação foi bem-sucedida

45357
30:05:05,192 --> 30:05:07,680
ter um ponteiro válido aqui e nós vamos

45358
30:05:07,680 --> 30:05:10,872
chamar o nosso método não-polimórfico derivado

45359
30:05:10,872 --> 30:05:13,120
Em nosso ponteiro isso vai funcionar

45360
30:05:13,120 --> 30:05:14,960
muito bem a última coisa que eu quero que você

45361
30:05:14,960 --> 30:05:17,680
veja antes de terminar esta palestra é

45362
30:05:17,680 --> 30:05:20,552
que os moldes dinâmicos só vão

45363
30:05:20,552 --> 30:05:23,280
trabalho com herança polimórfica

45364
30:05:23,280 --> 30:05:26,232
hierarquias, por exemplo, se tentarmos e

45365
30:05:26,232 --> 30:05:29,680
transformar um duplo em uma corda, obviamente

45366
30:05:29,680 --> 30:05:31,040
que não vai trabalhar com o

45367
30:05:31,040 --> 30:05:33,280
elenco dinâmico, mas vamos tentar fazer isso

45368
30:05:33,280 --> 30:05:34,960
para realmente mostrar que isso vai

45369
30:05:34,960 --> 30:05:36,800
dar-nos um problema que vamos dizer

45370
30:05:36,800 --> 30:05:38,720
Oddc para fora e nós vamos colocar em um

45371
30:05:38,720 --> 30:05:40,800
Separador aqui e vamos montar

45372
30:05:40,800 --> 30:05:42,960
Duas variáveis um vai ser uma rede

45373
30:05:42,960 --> 30:05:44,640
Por exemplo, e vamos dizer dados

45374
30:05:44,640 --> 30:05:47,680
nós vamos colocar em um 45 e se o fizermos

45375
30:05:47,680 --> 30:05:50,232
um elenco dinâmico para uma string sdd para

45376
30:05:50,232 --> 30:05:52,320
Um exemplo que não vai funcionar, nós somos

45377
30:05:52,320 --> 30:05:56,160
indo para dizer std string yana str significado

45378
30:05:56,160 --> 30:05:58,400
que esta é uma corda que vamos dizer

45379
30:05:58,400 --> 30:06:00,800
elenco dinâmico, digamos que queremos virar

45380
30:06:00,800 --> 30:06:03,592
isso em uma string sdd por exemplo e

45381
30:06:03,592 --> 30:06:05,440
a entrada vai ser nossos dados se

45382
30:06:05,440 --> 30:06:06,872
Você está tentando fazer algo assim

45383
30:06:06,872 --> 30:06:08,480
Isso vai explodir você vê que

45384
30:06:08,480 --> 30:06:10,320
Até mesmo o código visual do estúdio está nos dando uma

45385
30:06:10,320 --> 30:06:12,320
linha por muito

45386
30:06:12,320 --> 30:06:16,160
trabalho apenas certifique-se de usar elenco dinâmico

45387
30:06:16,160 --> 30:06:19,120
em uma hierarquia de herança que

45388
30:06:19,120 --> 30:06:22,320
suporta funções virtuais que este é o

45389
30:06:22,320 --> 30:06:25,680
finalidade do projeto para o elenco dinâmico se

45390
30:06:25,680 --> 30:06:28,552
você usa isso fora deste contexto que você é

45391
30:06:28,552 --> 30:06:30,800
Vou ter um comportamento indefinido ou até mesmo

45392
30:06:30,800 --> 30:06:33,040
Erros de compilador se você tiver sorte, vamos

45393
30:06:33,040 --> 30:06:34,480
Tente soldar e mostrar isso, nós somos

45394
30:06:34,480 --> 30:06:36,720
indo passar por isso através de gcc e nós somos

45395
30:06:36,720 --> 30:06:38,400
Provavelmente vai receber um erro dizendo

45396
30:06:38,400 --> 30:06:41,360
que não podemos nos transformar de um inteiro

45397
30:06:41,360 --> 30:06:43,512
para uma string, por exemplo, vamos aqui

45398
30:06:43,512 --> 30:06:46,480
não pode lançar dinâmico, então basicamente é

45399
30:06:46,480 --> 30:06:49,512
Dizer elencos dinâmicos são destinados a trabalhar

45400
30:06:49,512 --> 30:06:52,400
apenas com ponteiros ou referências, mas

45401
30:06:52,400 --> 30:06:55,832
Mesmo assim, vamos ver se podemos transformar

45402
30:06:55,832 --> 30:06:58,552
de um ponteiro final para um ponteiro de corda

45403
30:06:58,552 --> 30:07:01,120
Vamos tentar fazer isso, digamos que queremos

45404
30:07:01,120 --> 30:07:04,400
para ativar o endereço dos dados ou vamos definir

45405
30:07:04,400 --> 30:07:06,640
Um ponteiro para ser explícito, estamos indo

45406
30:07:06,640 --> 30:07:09,280
para dizer dados ptr e nós vamos

45407
30:07:09,280 --> 30:07:11,760
inicialize isso com o endereço dos dados

45408
30:07:11,760 --> 30:07:13,592
Nós podemos fazer algo assim e nós somos

45409
30:07:13,592 --> 30:07:17,040
indo para lançar dados ptr para um std

45410
30:07:17,040 --> 30:07:18,960
força ponteiro vamos ver se podemos fazer

45411
30:07:18,960 --> 30:07:21,512
porque é para ser lançado

45412
30:07:21,512 --> 30:07:23,592
entre ponteiros e referências, mas você

45413
30:07:23,592 --> 30:07:26,160
Veja que isso nem vai funcionar

45414
30:07:26,160 --> 30:07:28,000
então você não deve realmente fazer alguma coisa

45415
30:07:28,000 --> 30:07:31,280
assim, se sua entrada e saída forem

45416
30:07:31,280 --> 30:07:33,680
Não faz parte do mesmo polimórfico

45417
30:07:33,680 --> 30:07:36,160
Hierarquia de herança novamente dinâmica

45418
30:07:36,160 --> 30:07:38,232
Os elencos são feitos para lançar

45419
30:07:38,232 --> 30:07:40,640
Da informação de base para derivada

45420
30:07:40,640 --> 30:07:43,680
informação e entrada e saída

45421
30:07:43,680 --> 30:07:46,960
deve fazer parte do mesmo polimórfico

45422
30:07:46,960 --> 30:07:49,040
Hierarquia de herança, esta é a

45423
30:07:49,040 --> 30:07:51,440
informação que estou tentando transmitir aqui

45424
30:07:51,440 --> 30:07:53,360
então isso é ruim, não faça algo como

45425
30:07:53,360 --> 30:07:55,040
Isto se você fizer isso, você vai conseguir

45426
30:07:55,040 --> 30:07:57,192
Comportamento indefinido ou você está indo

45427
30:07:57,192 --> 30:07:59,360
para obter um monte de erros de compilador se você

45428
30:07:59,360 --> 30:08:01,680
Temos sorte de ser tudo o que estabelecemos

45429
30:08:01,680 --> 30:08:03,592
fazer nesta palestra mostrando que

45430
30:08:03,592 --> 30:08:06,232
você pode usar casts dinâmicos que estamos indo

45431
30:08:06,232 --> 30:08:08,232
para parar aqui nesta palestra o próximo

45432
30:08:08,232 --> 30:08:10,640
Um que vamos mostrar-lhe o que acontece

45433
30:08:10,640 --> 30:08:12,872
Se você tentar chamar de polimórfico

45434
30:08:12,872 --> 30:08:15,440
A função de um destruidor

45435
30:08:15,440 --> 30:08:17,592
Vá em frente e termine aqui e me encontre

45436
30:08:17,592 --> 30:08:19,912
lá nesta palestra vou dar

45437
30:08:19,912 --> 30:08:23,512
Você é um aviso e que é nunca chamar

45438
30:08:23,512 --> 30:08:26,640
funções virtuais de construtores ou

45439
30:08:26,640 --> 30:08:29,192
Destructores eu vou repetir isso

45440
30:08:29,192 --> 30:08:32,080
Nunca chame virtual ou polimórfico

45441
30:08:32,080 --> 30:08:34,720
funções de construtores ou

45442
30:08:34,720 --> 30:08:36,800
Destruidores e vamos explorar

45443
30:08:36,800 --> 30:08:38,480
Por que vamos usar isso

45444
30:08:38,480 --> 30:08:39,912
Hierarquia de herança que nós vamos

45445
30:08:39,912 --> 30:08:42,160
ter uma classe base chamada base como

45446
30:08:42,160 --> 30:08:44,400
Criativo vamos herdar de

45447
30:08:44,400 --> 30:08:47,040
base e criar derivado que é o nosso

45448
30:08:47,040 --> 30:08:49,440
Aula herdada e nós vamos ser

45449
30:08:49,440 --> 30:08:51,912
usando isso para explorar por que não podemos chamar

45450
30:08:51,912 --> 30:08:54,320
funções virtuais de construtores e

45451
30:08:54,320 --> 30:08:55,680
Destructors destruidores

45452
30:08:55,680 --> 30:08:57,512
Isto é o que o nosso código vai olhar

45453
30:08:57,512 --> 30:09:00,080
Como a classe base vai ter um

45454
30:09:00,080 --> 30:09:02,232
variável de membro protegida que vai

45455
30:09:02,232 --> 30:09:04,480
ter um monte de funções virtuais

45456
30:09:04,480 --> 30:09:07,120
teremos uma função virtual para definir

45457
30:09:07,120 --> 30:09:09,192
as coisas e só vai definir

45458
30:09:09,192 --> 30:09:11,912
o valor da nossa variável membro para 10

45459
30:09:11,912 --> 30:09:13,280
e nós vamos ter um virtual

45460
30:09:13,280 --> 30:09:15,280
Função chamada limpeza que está indo

45461
30:09:15,280 --> 30:09:17,512
para talvez fazer alguma limpeza, vamos

45462
30:09:17,512 --> 30:09:20,080
Veja como isso funciona, também temos um

45463
30:09:20,080 --> 30:09:22,000
método para obter o valor, mas eu não

45464
30:09:22,000 --> 30:09:24,160
Acho que vamos usar isso, mas você pode manter

45465
30:09:24,160 --> 30:09:26,800
Isto e se você quiser perceber que nós somos

45466
30:09:26,800 --> 30:09:29,192
tentando chamar o método de configuração a partir do

45467
30:09:29,192 --> 30:09:30,720
construtor

45468
30:09:30,720 --> 30:09:32,872
E você vê que temos um comentário que

45469
30:09:32,872 --> 30:09:34,552
Diz que isso vai fazer estática

45470
30:09:34,552 --> 30:09:36,320
amarrar, mas vamos ver o porquê em um

45471
30:09:36,320 --> 30:09:38,872
minuto assim esta é a nossa classe base que podemos

45472
30:09:38,872 --> 30:09:41,120
derivam desta classe e criam a nossa

45473
30:09:41,120 --> 30:09:42,960
Classe derivada que vamos herdar

45474
30:09:42,960 --> 30:09:44,160
em público

45475
30:09:44,160 --> 30:09:46,872
e vamos substituir os métodos

45476
30:09:46,872 --> 30:09:49,120
Temos na classe base que vamos

45477
30:09:49,120 --> 30:09:51,192
substituir o método de configuração como você vê

45478
30:09:51,192 --> 30:09:52,872
Aqui vamos substituir a limpeza

45479
30:09:52,872 --> 30:09:54,800
o método e

45480
30:09:54,800 --> 30:09:56,640
O nosso destructor também vai ser

45481
30:09:56,640 --> 30:09:58,872
virtual porque somos bons c plus plus

45482
30:09:58,872 --> 30:10:01,440
cidadãos e esta é a configuração que temos

45483
30:10:01,440 --> 30:10:03,512
Depois de ter sua hierarquia de herança

45484
30:10:03,512 --> 30:10:05,360
configurar você vai fazer algo como

45485
30:10:05,360 --> 30:10:07,440
porque você quer polimórfico

45486
30:10:07,440 --> 30:10:09,440
Comportamento que você vai configurar a base

45487
30:10:09,440 --> 30:10:11,192
ponteiro e você vai usar isso para

45488
30:10:11,192 --> 30:10:13,912
gerenciar um objeto derivado e você pode fazer

45489
30:10:13,912 --> 30:10:16,080
Algo assim agora

45490
30:10:16,080 --> 30:10:18,160
Considerando esta declaração aqui eu quero

45491
30:10:18,160 --> 30:10:20,720
você pensa sobre a ordem em que

45492
30:10:20,720 --> 30:10:22,960
construtores e destruidores estão indo

45493
30:10:22,960 --> 30:10:25,120
para sermos chamados, tocamos nisso

45494
30:10:25,120 --> 30:10:27,832
sujeito antes e nós vamos

45495
30:10:27,832 --> 30:10:29,760
Revise isso porque é realmente

45496
30:10:29,760 --> 30:10:30,960
Importante

45497
30:10:30,960 --> 30:10:33,592
em termos de chamar funções virtuais em

45498
30:10:33,592 --> 30:10:35,832
destruidores e destruidores

45499
30:10:35,832 --> 30:10:37,832
Quando fazemos algo assim

45500
30:10:37,832 --> 30:10:40,232
Parte da base deste objeto vai ser

45501
30:10:40,232 --> 30:10:42,552
A riqueza primeiro, então vamos chamar o

45502
30:10:42,552 --> 30:10:44,320
construtor de base primeiro vamos

45503
30:10:44,320 --> 30:10:46,800
configurar a melhor parte de nós depois disso

45504
30:10:46,800 --> 30:10:48,872
Nós vamos configurar a parte derivada

45505
30:10:48,872 --> 30:10:50,400
de nós e nós vamos chamar de

45506
30:10:50,400 --> 30:10:52,160
construtor derivado

45507
30:10:52,160 --> 30:10:54,960
e depois que a parte derivada de nós é definida

45508
30:10:54,960 --> 30:10:57,512
Nós podemos usar o nosso objeto como fazemos

45509
30:10:57,512 --> 30:10:59,832
Sempre assim vamos usar o nosso objeto

45510
30:10:59,832 --> 30:11:02,080
para fazer o que quisermos fazer quando

45511
30:11:02,080 --> 30:11:04,720
A hora chega para que este objeto seja

45512
30:11:04,720 --> 30:11:07,120
Destruídos, vamos destruir o

45513
30:11:07,120 --> 30:11:09,512
Parte derivada em primeiro lugar

45514
30:11:09,512 --> 30:11:11,760
E então vamos destruir a base

45515
30:11:11,760 --> 30:11:13,440
A primeira parte

45516
30:11:13,440 --> 30:11:15,760
Agora que já consideramos esta ordem

45517
30:11:15,760 --> 30:11:17,512
Tente pensar sobre a configuração quando nós

45518
30:11:17,512 --> 30:11:20,080
Chamar uma função virtual

45519
30:11:20,080 --> 30:11:21,760
De um construtor é o que somos

45520
30:11:21,760 --> 30:11:23,512
Vou olhar primeiro para o melhor

45521
30:11:23,512 --> 30:11:25,592
O construtor vai ser chamado, mas

45522
30:11:25,592 --> 30:11:27,760
note que no momento em que chamamos a base

45523
30:11:27,760 --> 30:11:30,640
construtor, a parte derivada de nós não vai

45524
30:11:30,640 --> 30:11:33,912
ser configurado ainda assim, se tentarmos chamar a

45525
30:11:33,912 --> 30:11:36,960
Função virtual no construtor de base

45526
30:11:36,960 --> 30:11:39,760
Não haverá uma parte derivada para chamar

45527
30:11:39,760 --> 30:11:42,720
o método mais especializado para

45528
30:11:42,720 --> 30:11:44,640
O compilador notará que não temos

45529
30:11:44,640 --> 30:11:47,040
uma parte derivada, mas estaremos nisso

45530
30:11:47,040 --> 30:11:49,592
palco construindo a parte da base e se nós

45531
30:11:49,592 --> 30:11:52,000
chamar uma função polimórfica virtual que nós

45532
30:11:52,000 --> 30:11:54,000
Quer que as partes mais específicas sejam

45533
30:11:54,000 --> 30:11:56,640
chamados que devem viver no

45534
30:11:56,640 --> 30:11:58,720
parte, mas não fizemos o derivado

45535
30:11:58,720 --> 30:12:01,280
Parte ainda estamos construindo a base

45536
30:12:01,280 --> 30:12:03,040
parte de nós para que o compilador vá

45537
30:12:03,040 --> 30:12:05,192
notar que não temos uma parte derivada

45538
30:12:05,192 --> 30:12:07,120
e vai chamar a versão base

45539
30:12:07,120 --> 30:12:09,192
da nossa função virtual, é por isso que

45540
30:12:09,192 --> 30:12:11,440
Disse isso se você chamar uma função virtual

45541
30:12:11,440 --> 30:12:13,760
de um construtor ou um destruidor

45542
30:12:13,760 --> 30:12:15,360
você vai ter uma ligação estática

45543
30:12:15,360 --> 30:12:17,592
resultados se você chamar uma função virtual

45544
30:12:17,592 --> 30:12:19,512
Você quer a versão mais específica

45545
30:12:19,512 --> 30:12:22,160
chamado mas ainda não temos isso no

45546
30:12:22,160 --> 30:12:24,872
parte de base porque parte derivada

45547
30:12:24,872 --> 30:12:26,872
Não foi criado é por isso que obtemos

45548
30:12:26,872 --> 30:12:29,040
resultados de ligação estática que eu espero que isso faça

45549
30:12:29,040 --> 30:12:30,800
Sensação e nós vamos chegar ao mesmo

45550
30:12:30,800 --> 30:12:32,800
resultado se você tentar chamar um virtual

45551
30:12:32,800 --> 30:12:35,680
função de um destruidor se chegarmos a

45552
30:12:35,680 --> 30:12:37,680
O ponto em que o nosso objeto precisa ser

45553
30:12:37,680 --> 30:12:39,592
destruído a parte derivada vai

45554
30:12:39,592 --> 30:12:41,680
ser dizimado primeiro que vamos ser

45555
30:12:41,680 --> 30:12:43,440
à esquerda com o destruidor de base e quando

45556
30:12:43,440 --> 30:12:46,000
nós batemos nesta base destructor e chamamos um

45557
30:12:46,000 --> 30:12:47,512
a função virtual

45558
30:12:47,512 --> 30:12:49,360
Isso significaria chamar de mais

45559
30:12:49,360 --> 30:12:50,640
Especializada

45560
30:12:50,640 --> 30:12:54,080
versão desse método, mas a derivada

45561
30:12:54,080 --> 30:12:56,320
Parte do nosso objeto já foi

45562
30:12:56,320 --> 30:12:59,120
limpo para baixo, então isso não existe mais

45563
30:12:59,120 --> 30:13:00,800
e estamos tentando chamar o método em

45564
30:13:00,800 --> 30:13:02,552
assim, o compilador vai fazer o

45565
30:13:02,552 --> 30:13:04,640
A melhor coisa que pode fazer, vai

45566
30:13:04,640 --> 30:13:06,552
chamar a melhor versão do nosso virtual

45567
30:13:06,552 --> 30:13:08,720
Função e novamente vamos conseguir

45568
30:13:08,720 --> 30:13:11,832
resultados de ligação estática é por isso que

45569
30:13:11,832 --> 30:13:13,680
Não é realmente sábio chamar de virtual

45570
30:13:13,680 --> 30:13:16,320
função de um construtor ou de um

45571
30:13:16,320 --> 30:13:18,232
Destructor agora alguns de vocês devem ser

45572
30:13:18,232 --> 30:13:20,960
perguntando se eu realmente preciso configurar

45573
30:13:20,960 --> 30:13:22,872
e limpar da maneira que montamos

45574
30:13:22,872 --> 30:13:25,280
essas coisas em nossas classes e se isso

45575
30:13:25,280 --> 30:13:27,040
O método é realmente útil, talvez seja

45576
30:13:27,040 --> 30:13:28,320
criando coisas que nós vamos ser

45577
30:13:28,320 --> 30:13:30,480
usando em nossa aplicação nós realmente precisamos

45578
30:13:30,480 --> 30:13:33,192
este e o ponto mais lógico para chamar

45579
30:13:33,192 --> 30:13:35,440
Este é o construtor de base bem você

45580
30:13:35,440 --> 30:13:36,872
Não deveria realmente colocá-los em um

45581
30:13:36,872 --> 30:13:39,592
construtor do que você poderia fazer

45582
30:13:39,592 --> 30:13:42,640
é talvez chamar este método virtual em

45583
30:13:42,640 --> 30:13:45,592
seu objeto diretamente quando o objeto tem

45584
30:13:45,592 --> 30:13:47,512
Acabado de ser um construtor que é

45585
30:13:47,512 --> 30:13:49,832
Vai ser um lugar melhor para fazer isso

45586
30:13:49,832 --> 30:13:52,872
porque se você colocar isso em um construtor

45587
30:13:52,872 --> 30:13:54,872
ou um destructor que você não vai conseguir

45588
30:13:54,872 --> 30:13:56,872
resultados dinâmicos de encadernação e isso está indo

45589
30:13:56,872 --> 30:13:59,832
para ser realmente ruim, então para resumir chamando a

45590
30:13:59,832 --> 30:14:01,192
a função virtual

45591
30:14:01,192 --> 30:14:03,440
de um construtor ou um destruidor quer

45592
30:14:03,440 --> 30:14:05,832
para lhe dar polimórfico ou dinâmico

45593
30:14:05,832 --> 30:14:08,400
Resultados vinculativos que a chamada nunca irá

45594
30:14:08,400 --> 30:14:10,320
para uma classe mais derivada do que a

45595
30:14:10,320 --> 30:14:12,400
Atualmente executando construtor ou

45596
30:14:12,400 --> 30:14:13,680
O disruptor

45597
30:14:13,680 --> 30:14:15,912
e obteremos resultados de ligação estática

45598
30:14:15,912 --> 30:14:18,720
Esta é a ideia que eu quero transmitir aqui

45599
30:14:18,720 --> 30:14:21,592
e como uma diretriz que você nunca deve chamar

45600
30:14:21,592 --> 30:14:23,760
funções virtuais ou polimórficos

45601
30:14:23,760 --> 30:14:26,080
funções de construtores ou

45602
30:14:26,080 --> 30:14:28,320
disruptores se você realmente precisar disso

45603
30:14:28,320 --> 30:14:31,440
A melhor coisa que você pode fazer é ligar

45604
30:14:31,440 --> 30:14:33,760
suas funções virtuais diretamente em sua

45605
30:14:33,760 --> 30:14:36,400
objeto depois que o objeto foi

45606
30:14:36,400 --> 30:14:37,440
corretamente

45607
30:14:37,440 --> 30:14:39,440
configuramos podemos fazer algo assim e

45608
30:14:39,440 --> 30:14:41,680
chamar o nosso método de configuração e, em seguida, podemos

45609
30:14:41,680 --> 30:14:43,512
limpeza de chamadas quando pensamos que precisamos

45610
30:14:43,512 --> 30:14:46,000
para limpar e você chama a limpeza depois

45611
30:14:46,000 --> 30:14:48,160
Você constrói o objeto e chama

45612
30:14:48,160 --> 30:14:50,480
excluir depois de limpar seu objeto

45613
30:14:50,480 --> 30:14:52,872
Isso vai fazer o que for você

45614
30:14:52,872 --> 30:14:54,800
Quero fazer com o seu polimórfico

45615
30:14:54,800 --> 30:14:57,120
funções e as chamadas para estes

45616
30:14:57,120 --> 30:14:59,192
As funções querem sair dentro de um

45617
30:14:59,192 --> 30:15:01,280
construtor ou um disruptor e este é

45618
30:15:01,280 --> 30:15:03,040
Vai trabalhar muito bem agora que você

45619
30:15:03,040 --> 30:15:04,400
Eu sei que vamos nos dirigir para

45620
30:15:04,400 --> 30:15:06,160
código de estúdio visual e jogar com a gente um

45621
30:15:06,160 --> 30:15:08,960
Pouco mais aqui estamos em nosso trabalho

45622
30:15:08,960 --> 30:15:10,720
pasta do projeto atual é

45623
30:15:10,720 --> 30:15:13,192
Funções polimórficas e as estruturas

45624
30:15:13,192 --> 30:15:15,360
Devemos realmente dizer com construtores

45625
30:15:15,360 --> 30:15:17,440
e instrutores, mas isso vai fazer

45626
30:15:17,440 --> 30:15:20,160
nós vamos pegar nossos arquivos de modelo

45627
30:15:20,160 --> 30:15:22,480
e nós vamos colocá-los no lugar e

45628
30:15:22,480 --> 30:15:24,400
Nós vamos abrir este pequeno rapaz em

45629
30:15:24,400 --> 30:15:26,080
código visual do estúdio arrastando e

45630
30:15:26,080 --> 30:15:28,232
Dando aqui isso vai nos dar

45631
30:15:28,232 --> 30:15:30,800
nosso arquivo principal cpp podemos limpar um

45632
30:15:30,800 --> 30:15:32,552
Um pouco remover o que quer que seja

45633
30:15:32,552 --> 30:15:35,192
Não preciso e eu só vou colocar

45634
30:15:35,192 --> 30:15:37,592
Minhas aulas vou fazer isso no

45635
30:15:37,592 --> 30:15:40,000
arquivo principal do cpp porque isso vai ser

45636
30:15:40,000 --> 30:15:42,872
Muito mais fácil de seguir temos nossa base

45637
30:15:42,872 --> 30:15:44,960
classe vai ter um único

45638
30:15:44,960 --> 30:15:47,440
variável membro chamada valor m e nós

45639
30:15:47,440 --> 30:15:50,552
terá um destruidor virtual

45640
30:15:50,552 --> 30:15:52,640
teremos um monte de virtuais

45641
30:15:52,640 --> 30:15:54,640
funções um vai ser configurado que

45642
30:15:54,640 --> 30:15:56,552
vai definir o nosso valor o outro é

45643
30:15:56,552 --> 30:15:58,320
Vai ser uma limpeza que vai ser

45644
30:15:58,320 --> 30:16:00,720
Fazendo alguma limpeza aqui nós também

45645
30:16:00,720 --> 30:16:03,280
ter um método de getvalue que vai obter

45646
30:16:03,280 --> 30:16:05,440
este valor e imprimi-lo se quisermos

45647
30:16:05,440 --> 30:16:08,000
Mas não é realmente tão útil aqui nós

45648
30:16:08,000 --> 30:16:10,080
também irá criar uma classe derivada que

45649
30:16:10,080 --> 30:16:12,800
vai herdar publicamente da base

45650
30:16:12,800 --> 30:16:14,720
Não vai ter seu próprio membro

45651
30:16:14,720 --> 30:16:17,040
variável tudo o que vai fazer é configurar

45652
30:16:17,040 --> 30:16:19,512
Um monte de substituições para

45653
30:16:19,512 --> 30:16:21,360
As funções virtuais que temos no

45654
30:16:21,360 --> 30:16:23,760
classe base que vamos substituir a configuração

45655
30:16:23,760 --> 30:16:25,592
E em derivada, vamos definir o nosso

45656
30:16:25,592 --> 30:16:28,160
valor para 100 e vamos limpar

45657
30:16:28,160 --> 30:16:30,080
e colocar uma mensagem de que estamos limpando

45658
30:16:30,080 --> 30:16:32,480
Aqui em cima, uma vez que temos esta configuração, podemos

45659
30:16:32,480 --> 30:16:34,872
cabeça sobre na função principal e conjunto

45660
30:16:34,872 --> 30:16:36,720
Um ponteiro base que vai ser

45661
30:16:36,720 --> 30:16:39,832
Gerenciando um objeto derivado um clássico

45662
30:16:39,832 --> 30:16:41,912
Configuração para comportamento polimórfico, então nós somos

45663
30:16:41,912 --> 30:16:44,160
Vou dizer base e eu vou dizer p

45664
30:16:44,160 --> 30:16:46,080
baixo e nós vamos dizer igual a novo

45665
30:16:46,080 --> 30:16:48,872
derivadas, isso vai nos dar o nosso

45666
30:16:48,872 --> 30:16:51,040
objeto que é gerenciado por uma base

45667
30:16:51,040 --> 30:16:53,192
ponteiro e uma coisa que eu não te mostrei

45668
30:16:53,192 --> 30:16:55,592
É que estamos chamando a configuração de virtual

45669
30:16:55,592 --> 30:16:56,720
A função

45670
30:16:56,720 --> 30:17:00,000
do construtor de base, isto é o que

45671
30:17:00,000 --> 30:17:01,512
Queremos ver o que é

45672
30:17:01,512 --> 30:17:04,400
acontecendo aqui agora, se chamarmos essa configuração

45673
30:17:04,400 --> 30:17:05,512
A função

45674
30:17:05,512 --> 30:17:08,232
Seria de esperar que o polimorfismo entrasse em ação

45675
30:17:08,232 --> 30:17:10,320
Porque esta é uma função virtual

45676
30:17:10,320 --> 30:17:12,640
se a peça derivada estiver disponível,

45677
30:17:12,640 --> 30:17:15,280
chamar a função de configuração mais específica

45678
30:17:15,280 --> 30:17:18,320
e isso criaria o valor a ser

45679
30:17:18,320 --> 30:17:21,040
100 aqui se conseguirmos o valor que é isso

45680
30:17:21,040 --> 30:17:23,120
gostaríamos de ter, vamos ver o que temos aqui

45681
30:17:23,120 --> 30:17:25,280
Se tentarmos obter o

45682
30:17:25,280 --> 30:17:27,760
valor que temos neste objeto aqui

45683
30:17:27,760 --> 30:17:30,480
Então nós vamos ter valor de automóvel e nós somos

45684
30:17:30,480 --> 30:17:33,512
indo dizer p base obter valor que temos

45685
30:17:33,512 --> 30:17:35,440
Esta função aqui e vamos tentar

45686
30:17:35,440 --> 30:17:37,512
imprimir isso bem, isso é algo que nós

45687
30:17:37,512 --> 30:17:40,080
pode fazer em nosso programa de ônibus c plus e

45688
30:17:40,080 --> 30:17:41,592
nós vamos ver o valor que temos

45689
30:17:41,592 --> 30:17:43,512
Porque estamos chamando isso de virtual

45690
30:17:43,512 --> 30:17:45,912
Função que esperamos que o polimorfismo chute

45691
30:17:45,912 --> 30:17:48,480
e se o polimorfismo entra em ação, somos

45692
30:17:48,480 --> 30:17:50,640
Vamos chamar os mais especializados

45693
30:17:50,640 --> 30:17:52,800
Versão da nossa função virtual aqui

45694
30:17:52,800 --> 30:17:54,480
que seria a substituição que temos em

45695
30:17:54,480 --> 30:17:57,040
derivada e isso nos daria 100.

45696
30:17:57,040 --> 30:17:59,680
um deles conseguiria obter 100 impressos

45697
30:17:59,680 --> 30:18:01,360
Aqui, mas vamos ver o que temos, estamos

45698
30:18:01,360 --> 30:18:04,080
indo para correr isso através de gcc nosso

45699
30:18:04,080 --> 30:18:05,832
compilador favorito que o construtor está indo

45700
30:18:05,832 --> 30:18:08,480
para sermos bons, podemos limpar ou trazer uma

45701
30:18:08,480 --> 30:18:10,720
janela powershell vamos limpar

45702
30:18:10,720 --> 30:18:13,040
Agora e correr o galo, vamos ver

45703
30:18:13,040 --> 30:18:14,960
que o construtor de base vai ser

45704
30:18:14,960 --> 30:18:17,192
chamado base setup foi chamado você ver nós

45705
30:18:17,192 --> 30:18:19,832
chamada a versão base disso e a

45706
30:18:19,832 --> 30:18:22,480
O construtor derivado será chamado e

45707
30:18:22,480 --> 30:18:24,232
nós vamos ver que o valor

45708
30:18:24,232 --> 30:18:26,960
não existe oh, não colocamos o valor

45709
30:18:26,960 --> 30:18:29,360
Vamos fazer isso meu mal aqui estamos

45710
30:18:29,360 --> 30:18:31,040
Vou construir novamente, vamos usar

45711
30:18:31,040 --> 30:18:33,512
gcc para construir e o mundo é bom

45712
30:18:33,512 --> 30:18:36,232
pode limpar e correr galo agora que vemos

45713
30:18:36,232 --> 30:18:38,232
que o método de configuração base foi chamado

45714
30:18:38,232 --> 30:18:41,440
e definir o valor para b10 e nós somos

45715
30:18:41,440 --> 30:18:43,680
Realmente obtendo resultados de ligação estática

45716
30:18:43,680 --> 30:18:46,080
porque estamos chamando a configuração

45717
30:18:46,080 --> 30:18:48,400
método da classe base e da base

45718
30:18:48,400 --> 30:18:50,800
A versão está sendo chamada assim é

45719
30:18:50,800 --> 30:18:54,000
Comportamento clássico de ligação estática, mas nós

45720
30:18:54,000 --> 30:18:56,720
Quer que o comportamento polimórfico funcione

45721
30:18:56,720 --> 30:19:00,000
Aqui, mas vimos a razão pela qual isso

45722
30:19:00,000 --> 30:19:02,640
está nos slides no momento em que chamamos

45723
30:19:02,640 --> 30:19:05,360
Esta função virtual não configuramos

45724
30:19:05,360 --> 30:19:07,680
A parte derivada de nós ainda

45725
30:19:07,680 --> 30:19:11,040
e não temos como chamar isso de virtual

45726
30:19:11,040 --> 30:19:13,912
Função que vive na parte derivada

45727
30:19:13,912 --> 30:19:16,000
de nós para que o compilador faça o

45728
30:19:16,000 --> 30:19:18,000
A melhor coisa que pode fazer, vai fazer

45729
30:19:18,000 --> 30:19:20,080
chamar a melhor versão deste método e

45730
30:19:20,080 --> 30:19:22,480
Vamos obter uma ligação estática

45731
30:19:22,480 --> 30:19:24,872
resultados e vamos conseguir o mesmo

45732
30:19:24,872 --> 30:19:27,280
resultados se tentarmos chamar de virtual

45733
30:19:27,280 --> 30:19:30,080
função do destruidor, por exemplo

45734
30:19:30,080 --> 30:19:33,360
Se entrarmos no nosso destruidor aqui

45735
30:19:33,360 --> 30:19:35,040
Vamos ver se conseguimos encontrá-lo, vamos

45736
30:19:35,040 --> 30:19:36,960
para ir em nosso instrutor aqui e dizer

45737
30:19:36,960 --> 30:19:39,120
Isso e dizer limpeza pode fazer algo

45738
30:19:39,120 --> 30:19:41,120
Assim e você vai ver aquilo

45739
30:19:41,120 --> 30:19:43,512
A versão de limpeza que chamamos é a base

45740
30:19:43,512 --> 30:19:45,280
Versão da limpeza

45741
30:19:45,280 --> 30:19:47,280
E nós realmente não queremos fazer alguma coisa

45742
30:19:47,280 --> 30:19:49,912
Assim queremos os mais derivados

45743
30:19:49,912 --> 30:19:51,832
Versão de limpeza para ser chamada, mas nós

45744
30:19:51,832 --> 30:19:54,232
Não vai conseguir isso porque no momento nós

45745
30:19:54,232 --> 30:19:57,280
chamar esta função virtual a partir da nossa base

45746
30:19:57,280 --> 30:19:58,320
classe de classe

45747
30:19:58,320 --> 30:20:00,872
A parte derivada já terá sido

45748
30:20:00,872 --> 30:20:03,512
Apagado para que não esteja disponível e

45749
30:20:03,512 --> 30:20:06,480
O compilador fará a próxima melhor coisa

45750
30:20:06,480 --> 30:20:08,640
Pode fazê-lo vai chamar o melhor

45751
30:20:08,640 --> 30:20:10,552
versão da nossa função de limpeza aqui i

45752
30:20:10,552 --> 30:20:12,872
Espero que isso faça sentido

45753
30:20:12,872 --> 30:20:14,872
novamente para realmente conduzir esta casa i

45754
30:20:14,872 --> 30:20:17,192
Percebe que isso pode ser confuso para muitos

45755
30:20:17,192 --> 30:20:19,760
Pessoas especialmente iniciantes se nós

45756
30:20:19,760 --> 30:20:21,280
Chamando uma função virtual de um

45757
30:20:21,280 --> 30:20:23,760
Construtor vamos chamar isso de virtual

45758
30:20:23,760 --> 30:20:25,440
Função quando atingimos a base

45759
30:20:25,440 --> 30:20:27,680
construtor, mas no momento em que atingimos o

45760
30:20:27,680 --> 30:20:29,832
construtor de base, a parte derivada de nós

45761
30:20:29,832 --> 30:20:32,640
Ainda não foi construído, então se tentarmos

45762
30:20:32,640 --> 30:20:34,960
para chamar uma função polimórfica que precisa

45763
30:20:34,960 --> 30:20:37,192
para manter a implementação derivada que

45764
30:20:37,192 --> 30:20:39,512
não estará disponível e o compilador irá

45765
30:20:39,512 --> 30:20:42,080
fazer a próxima melhor coisa que pode fazer é

45766
30:20:42,080 --> 30:20:43,912
Vou chamar a versão base da mesma

45767
30:20:43,912 --> 30:20:45,512
O fenômeno vai acontecer no

45768
30:20:45,512 --> 30:20:48,232
Destructor quando terminamos de usar o nosso

45769
30:20:48,232 --> 30:20:50,720
Objeto vamos destruir a parte derivada

45770
30:20:50,720 --> 30:20:53,512
informações primeiro e quando atingimos o

45771
30:20:53,512 --> 30:20:55,440
base destruidor e chamar um virtual

45772
30:20:55,440 --> 30:20:57,440
A função não haverá mais

45773
30:20:57,440 --> 30:20:59,760
versão especializada do virtual

45774
30:20:59,760 --> 30:21:02,160
Função porque a parte derivada tem

45775
30:21:02,160 --> 30:21:04,160
Já foi destruído e não

45776
30:21:04,160 --> 30:21:06,800
Existem mais, então se chamarmos de virtual

45777
30:21:06,800 --> 30:21:08,960
função do destruidor de base que nós

45778
30:21:08,960 --> 30:21:10,872
obterá a melhor versão chamada e

45779
30:21:10,872 --> 30:21:13,040
Isso nos dará uma ligação estática

45780
30:21:13,040 --> 30:21:15,040
Comportamento é o que somos

45781
30:21:15,040 --> 30:21:17,912
experimentando aqui ok, então vamos tentar

45782
30:21:17,912 --> 30:21:20,640
executar este programa e ver o que temos

45783
30:21:20,640 --> 30:21:22,480
vai imprimir o valor aqui que está indo

45784
30:21:22,480 --> 30:21:25,040
para nos dar resultados de ligação estática, mas nós

45785
30:21:25,040 --> 30:21:28,232
Quer ver qual versão da limpeza é

45786
30:21:28,232 --> 30:21:30,232
Chamado isso é o que queremos ver aqui

45787
30:21:30,232 --> 30:21:32,000
Vamos executar a tarefa de construir

45788
30:21:32,000 --> 30:21:34,552
com gcc o mundo vai ser bom

45789
30:21:34,552 --> 30:21:36,640
Como de costume, vamos limpar e correr

45790
30:21:36,640 --> 30:21:38,480
O galo e eu vou ver a base

45791
30:21:38,480 --> 30:21:40,480
construtor chamado construtor derivado

45792
30:21:40,480 --> 30:21:42,400
Ligado e nós vamos ter um valor

45793
30:21:42,400 --> 30:21:44,400
que é um valor de lixo porque nós nunca

45794
30:21:44,400 --> 30:21:46,720
inicialize esse valor, mas não vemos

45795
30:21:46,720 --> 30:21:49,360
Nossa destruitura é chamada o que está acontecendo

45796
30:21:49,360 --> 30:21:50,480
em diante aqui

45797
30:21:50,480 --> 30:21:53,040
Vamos investigar isso um pouco mais

45798
30:21:53,040 --> 30:21:55,680
A razão é que não somos explicitamente

45799
30:21:55,680 --> 30:21:57,680
liberando esta memória através do

45800
30:21:57,680 --> 30:21:59,360
Ponto de referência base vamos fazer isso nós vamos

45801
30:21:59,360 --> 30:22:02,232
para excluir a base aqui e nós vamos

45802
30:22:02,232 --> 30:22:05,192
correr novamente nós vamos soldar com gcc

45803
30:22:05,192 --> 30:22:07,680
Agora nossos destruidores devem ser chamados

45804
30:22:07,680 --> 30:22:09,760
Nós vamos correr o galo e nós estamos

45805
30:22:09,760 --> 30:22:11,440
Vou ver que a limpeza da base

45806
30:22:11,440 --> 30:22:13,360
A versão foi chamada e novamente isso é

45807
30:22:13,360 --> 30:22:16,080
dando-nos resultados de ligação estática que você

45808
30:22:16,080 --> 30:22:18,480
Não quero algo assim, então se você

45809
30:22:18,480 --> 30:22:19,592
Querar

45810
30:22:19,592 --> 30:22:22,000
para chegar a este comportamento eu aconselharia não

45811
30:22:22,000 --> 30:22:24,480
para chamar as funções de limpeza ou configuração

45812
30:22:24,480 --> 30:22:27,192
dentro de construtores ou destruidores e

45813
30:22:27,192 --> 30:22:28,872
essa é a diretriz que eu dei no

45814
30:22:28,872 --> 30:22:30,960
slides que você realmente nunca deve chamar

45815
30:22:30,960 --> 30:22:32,960
Funções virtuais de qualquer um

45816
30:22:32,960 --> 30:22:35,912
construtores ou disruptores, especialmente se

45817
30:22:35,912 --> 30:22:38,720
você está fazendo isso de uma classe de pais

45818
30:22:38,720 --> 30:22:41,760
Na esperança de obter o mais específico virtual

45819
30:22:41,760 --> 30:22:44,800
função chamada através do polimorfismo se

45820
30:22:44,800 --> 30:22:46,960
Você quer fazer isso a melhor coisa que você

45821
30:22:46,960 --> 30:22:49,832
pode fazer é chamar as funções de limpeza

45822
30:22:49,832 --> 30:22:50,800
E a

45823
30:22:50,800 --> 30:22:52,480
é chamar a configuração e limpeza

45824
30:22:52,480 --> 30:22:54,872
funções após o seu objeto ter sido

45825
30:22:54,872 --> 30:22:57,512
devidamente construído ou antes de sua

45826
30:22:57,512 --> 30:23:00,320
O objeto começa a ser destruído para que você

45827
30:23:00,320 --> 30:23:03,760
pode fazer aqui é chamar o método de configuração em

45828
30:23:03,760 --> 30:23:06,720
O ponteiro pbes aqui vamos fazer isso e

45829
30:23:06,720 --> 30:23:08,640
nós vamos chamar a configuração de que isso está acontecendo

45830
30:23:08,640 --> 30:23:10,800
para chamar nossa função virtual e nós somos

45831
30:23:10,800 --> 30:23:13,120
vai ter um comportamento polimórfico este

45832
30:23:13,120 --> 30:23:15,760
Vai imprimir um 100 como esperamos

45833
30:23:15,760 --> 30:23:17,592
Porque ele vai chamar

45834
30:23:17,592 --> 30:23:20,872
a versão derivada da configuração aqui e

45835
30:23:20,872 --> 30:23:24,000
antes de excluir nosso objeto, precisaremos

45836
30:23:24,000 --> 30:23:26,320
para chamar a função de limpeza se precisarmos

45837
30:23:26,320 --> 30:23:28,640
para fazer alguma limpeza personalizada aqui, então eu estou

45838
30:23:28,640 --> 30:23:29,912
Vou dizer

45839
30:23:29,912 --> 30:23:32,640
base e chamar a função de limpeza e

45840
30:23:32,640 --> 30:23:35,120
Isso vai nos dar o comportamento que nós

45841
30:23:35,120 --> 30:23:37,760
Queremos que vamos construir o nosso programa

45842
30:23:37,760 --> 30:23:40,232
passar isso através de gcc os dois estão indo

45843
30:23:40,232 --> 30:23:42,320
para sermos bons, podemos limpar

45844
30:23:42,320 --> 30:23:44,960
e correr o galo e nós vamos ver

45845
30:23:44,960 --> 30:23:47,120
que esse construtor foi chamado

45846
30:23:47,120 --> 30:23:49,440
O construtor foi chamado, vamos chamar de

45847
30:23:49,440 --> 30:23:51,592
Versão derivada da configuração do nosso valor irá

45848
30:23:51,592 --> 30:23:54,552
ser 100 e quando podemos liberar ou

45849
30:23:54,552 --> 30:23:57,120
limpar nossa memória a versão derivada

45850
30:23:57,120 --> 30:23:59,680
A limpeza será chamada e então nós

45851
30:23:59,680 --> 30:24:01,912
destruirá a parte derivada de nós e

45852
30:24:01,912 --> 30:24:04,320
Então vamos destruir a parte básica de nós

45853
30:24:04,320 --> 30:24:07,192
Isso vai funcionar de acordo com o

45854
30:24:07,192 --> 30:24:09,440
Com o comportamento com o qual estamos familiarizados

45855
30:24:09,440 --> 30:24:11,592
Polimorfismo e isso é muito legal, então

45856
30:24:11,592 --> 30:24:13,592
Isto é o que você deve fazer você deve

45857
30:24:13,592 --> 30:24:16,160
Nunca chame funções virtuais de

45858
30:24:16,160 --> 30:24:18,160
distratores e construtores porque

45859
30:24:18,160 --> 30:24:20,480
que lhe dará uma ligação estática

45860
30:24:20,480 --> 30:24:22,400
resultados e tudo o que você quer neste caso

45861
30:24:22,400 --> 30:24:23,440
É realmente

45862
30:24:23,440 --> 30:24:26,320
Comportamento de ligação dinâmica isso é realmente

45863
30:24:26,320 --> 30:24:28,080
Tudo que eu tenho que compartilhar nesta palestra i

45864
30:24:28,080 --> 30:24:30,320
Espero que você tenha achado interessante que somos

45865
30:24:30,320 --> 30:24:32,400
Vou parar aqui neste no próximo

45866
30:24:32,400 --> 30:24:34,160
Um que vamos aprender sobre o tipo

45867
30:24:34,160 --> 30:24:37,680
id operador que pode vir a um lado

45868
30:24:37,680 --> 30:24:40,000
Especialmente se você quiser depurar

45869
30:24:40,000 --> 30:24:42,320
código polimórfico em seu c plus mais

45870
30:24:42,320 --> 30:24:45,120
O programa vá em frente e termine aqui e

45871
30:24:45,120 --> 30:24:47,040
Encontre-me lá nesta palestra que estamos

45872
30:24:47,040 --> 30:24:48,720
Vou aprender sobre o puro virtual

45873
30:24:48,720 --> 30:24:52,232
funções e classes abstratas e pura

45874
30:24:52,232 --> 30:24:54,800
As funções virtuais são um mecanismo que nós

45875
30:24:54,800 --> 30:24:56,720
ter em c plus plus

45876
30:24:56,720 --> 30:24:59,680
significando que o método não é destinado a

45877
30:24:59,680 --> 30:25:01,592
ser implementado

45878
30:25:01,592 --> 30:25:03,832
na classe base

45879
30:25:03,832 --> 30:25:05,832
Aqui temos uma herança simples

45880
30:25:05,832 --> 30:25:08,720
hierarquia para tentar conduzir esta casa

45881
30:25:08,720 --> 30:25:11,120
A classe base é forma e nós estamos derivando

45882
30:25:11,120 --> 30:25:13,760
desta classe para criar uma classe de círculo

45883
30:25:13,760 --> 30:25:16,160
e do outro lado estamos derivando para

45884
30:25:16,160 --> 30:25:18,800
criar uma classe de retângulo se olharmos para dentro

45885
30:25:18,800 --> 30:25:20,552
A classe de forma temos dois virtuais

45886
30:25:20,552 --> 30:25:22,232
métodos que alguém vai ser usado para

45887
30:25:22,232 --> 30:25:24,480
calcular o perímetro da forma

45888
30:25:24,480 --> 30:25:26,160
O outro será usado para computar

45889
30:25:26,160 --> 30:25:28,552
a superfície da forma, mas se formos

45890
30:25:28,552 --> 30:25:30,960
em nossas classes de herança, nós somos

45891
30:25:30,960 --> 30:25:32,320
Vou ver que temos o mesmo

45892
30:25:32,320 --> 30:25:34,640
métodos estes vão ser overrides

45893
30:25:34,640 --> 30:25:37,440
do que temos na classe base

45894
30:25:37,440 --> 30:25:39,120
Mas a coisa especial sobre isso

45895
30:25:39,120 --> 30:25:41,040
Hierarquia de herança

45896
30:25:41,040 --> 30:25:43,360
É que não temos implementações

45897
30:25:43,360 --> 30:25:46,480
para estes métodos na classe base aqui

45898
30:25:46,480 --> 30:25:48,800
e isso é por design se você pensar em

45899
30:25:48,800 --> 30:25:51,120
Esta é uma forma abstrata que não

45900
30:25:51,120 --> 30:25:52,800
Sei que se é um retângulo, não sabemos

45901
30:25:52,800 --> 30:25:54,552
Se é um círculo, não sabemos se é

45902
30:25:54,552 --> 30:25:57,440
um triângulo para que não tenhamos realmente

45903
30:25:57,440 --> 30:25:59,760
informações concretas que podemos usar

45904
30:25:59,760 --> 30:26:02,000
para calcular corretamente o seu perímetro e

45905
30:26:02,000 --> 30:26:04,872
sua superfície, por isso faz sentido realmente

45906
30:26:04,872 --> 30:26:07,512
Deixe na declaração para estes

45907
30:26:07,512 --> 30:26:10,000
métodos, mas deixar a implementação

45908
30:26:10,000 --> 30:26:13,120
detalhes para herdar as classes porque

45909
30:26:13,120 --> 30:26:15,192
Essas aulas terão concreto

45910
30:26:15,192 --> 30:26:17,760
informações que podemos usar para ser confiável

45911
30:26:17,760 --> 30:26:19,760
calcular o perímetro e a superfície

45912
30:26:19,760 --> 30:26:22,080
e podemos obter esta informação aqui

45913
30:26:22,080 --> 30:26:24,800
Então em c plus mais queremos dizer este tipo de

45914
30:26:24,800 --> 30:26:27,120
design configurando esses métodos como

45915
30:26:27,120 --> 30:26:29,360
funções virtuais puras

45916
30:26:29,360 --> 30:26:30,872
e o que isto vai dizer ao

45917
30:26:30,872 --> 30:26:33,512
compilador é que esses métodos não são destinados

45918
30:26:33,512 --> 30:26:36,400
ser implementado na classe base

45919
30:26:36,400 --> 30:26:37,912
Eles estão destinados a ser

45920
30:26:37,912 --> 30:26:39,832
substituídos e implementados por

45921
30:26:39,832 --> 30:26:42,720
Classes de herança e outro lado

45922
30:26:42,720 --> 30:26:45,360
O efeito disso é que o compilador é

45923
30:26:45,360 --> 30:26:47,280
Impedindo você de criar

45924
30:26:47,280 --> 30:26:50,000
objetos desta classe porque realmente

45925
30:26:50,000 --> 30:26:52,080
Não faz sentido criar um objeto

45926
30:26:52,080 --> 30:26:54,320
de moldar o seu design

45927
30:26:54,320 --> 30:26:56,232
se você quer ser capaz de calcular a sua

45928
30:26:56,232 --> 30:26:57,760
perímetro se você quer ser capaz de

45929
30:26:57,760 --> 30:26:59,912
calcular sua superfície, então por que se preocupar

45930
30:26:59,912 --> 30:27:02,000
Criando um objeto que você não vai realmente

45931
30:27:02,000 --> 30:27:04,232
estar usando em seu c plus programa

45932
30:27:04,232 --> 30:27:06,400
O significado para esta classe base é apenas para

45933
30:27:06,400 --> 30:27:10,232
ser uma ideia ou uma representação de um

45934
30:27:10,232 --> 30:27:12,552
forma sem realmente entrar no

45935
30:27:12,552 --> 30:27:14,872
implementação concreta de como isso

45936
30:27:14,872 --> 30:27:16,480
A forma realmente funciona

45937
30:27:16,480 --> 30:27:18,720
espero que isso faça sentido, então vamos ver

45938
30:27:18,720 --> 30:27:21,120
Como podemos fazer isso em código aqui que temos

45939
30:27:21,120 --> 30:27:23,280
uma classe simples que vai ser nossa

45940
30:27:23,280 --> 30:27:26,552
Classe de forma, vamos ter dois

45941
30:27:26,552 --> 30:27:28,232
Funções virtuais que vamos ter

45942
30:27:28,232 --> 30:27:30,232
a função do perímetro que vamos

45943
30:27:30,232 --> 30:27:31,760
ter a função de superfície estes são

45944
30:27:31,760 --> 30:27:33,912
serão funções virtuais ou virtuais

45945
30:27:33,912 --> 30:27:36,872
funções de membro eu devo dizer, mas nós somos

45946
30:27:36,872 --> 30:27:38,400
indo para fazê-los

45947
30:27:38,400 --> 30:27:41,040
Funções virtuais puras usando o

45948
30:27:41,040 --> 30:27:43,040
sintaxe que você vê aqui, então nós vamos

45949
30:27:43,040 --> 30:27:46,232
Prepare um eco zero e isso está indo

45950
30:27:46,232 --> 30:27:48,872
para dizer ao compilador que estes são puros

45951
30:27:48,872 --> 30:27:51,280
funções virtuais uma vez que você criá-los

45952
30:27:51,280 --> 30:27:52,872
funções algumas coisas vão

45953
30:27:52,872 --> 30:27:55,680
Acontece em sua classe que esta classe está indo

45954
30:27:55,680 --> 30:27:58,640
tornar-se uma classe abstrata em que

45955
30:27:58,640 --> 30:28:00,720
você quer ser capaz de criar objetos de

45956
30:28:00,720 --> 30:28:02,720
Esta classe se você tentar fazer isso

45957
30:28:02,720 --> 30:28:04,960
você vai ter um erro de compilador outro

45958
30:28:04,960 --> 30:28:07,192
A coisa é que você não precisa colocar

45959
30:28:07,192 --> 30:28:09,440
Implementações para esses métodos

45960
30:28:09,440 --> 30:28:12,872
porque você os marcou como puro virtual

45961
30:28:12,872 --> 30:28:14,960
O que isto significa é que o

45962
30:28:14,960 --> 30:28:17,440
As implementações serão colocadas por

45963
30:28:17,440 --> 30:28:20,640
Herdar classes a jusante porque

45964
30:28:20,640 --> 30:28:22,552
eles terão informações concretas para

45965
30:28:22,552 --> 30:28:25,192
computar o perímetro ou a superfície como

45966
30:28:25,192 --> 30:28:27,280
Temos aqui para que não precisemos nos preocupar

45967
30:28:27,280 --> 30:28:29,280
Definições para essas funções

45968
30:28:29,280 --> 30:28:31,120
Aqui se você tentar colocar em um

45969
30:28:31,120 --> 30:28:32,872
Definição aqui você vai ter um

45970
30:28:32,872 --> 30:28:35,040
Erro do compilador porque este é um virtual

45971
30:28:35,040 --> 30:28:37,512
Função que não temos para colocar um

45972
30:28:37,512 --> 30:28:39,832
implementação na classe base aqui

45973
30:28:39,832 --> 30:28:42,160
Estes devem ser implementados por

45974
30:28:42,160 --> 30:28:44,872
classes de herança downstream bem uma vez

45975
30:28:44,872 --> 30:28:47,192
Temos nossa classe de navios e nossa

45976
30:28:47,192 --> 30:28:49,592
hierarquia de herança que podemos tentar executar

45977
30:28:49,592 --> 30:28:52,400
isso em nosso código, por exemplo, se tentarmos

45978
30:28:52,400 --> 30:28:54,320
e criar um objeto de forma que vamos

45979
30:28:54,320 --> 30:28:56,872
obter um erro de compilador porque a forma é uma

45980
30:28:56,872 --> 30:28:58,800
classe abstrata para que não possamos criar

45981
30:28:58,800 --> 30:29:01,360
Objetos disso e eu não acho que eu fiz

45982
30:29:01,360 --> 30:29:03,912
Este super claro uma vez que você se configura

45983
30:29:03,912 --> 30:29:06,872
pelo menos uma função virtual pura em seu

45984
30:29:06,872 --> 30:29:09,512
classe a classe está indo automaticamente

45985
30:29:09,512 --> 30:29:12,232
tornar-se uma classe abstrata e o que

45986
30:29:12,232 --> 30:29:14,080
Isso significa que você quer ser capaz

45987
30:29:14,080 --> 30:29:16,640
para criar objetos desta classe para que isso

45988
30:29:16,640 --> 30:29:19,680
É uma classe abstrata que temos aqui e se

45989
30:29:19,680 --> 30:29:22,400
Nós tentamos criar um objeto como nós

45990
30:29:22,400 --> 30:29:24,960
estão fazendo nesta linha aqui que isso é

45991
30:29:24,960 --> 30:29:27,512
vamos nos dar um erro de compilador, mas nós

45992
30:29:27,512 --> 30:29:30,552
ainda pode usar um ponteiro base para gerenciar um

45993
30:29:30,552 --> 30:29:32,160
objeto derivado

45994
30:29:32,160 --> 30:29:34,552
uma configuração comum que fazemos com polimorfismo

45995
30:29:34,552 --> 30:29:36,080
por exemplo, aqui podemos criar uma

45996
30:29:36,080 --> 30:29:38,552
shape pointer e usar isso para gerenciar um

45997
30:29:38,552 --> 30:29:41,512
objeto retangular se nós chamamos a superfície

45998
30:29:41,512 --> 30:29:44,232
função de membro em nosso ponteiro base este

45999
30:29:44,232 --> 30:29:46,960
vai fazer uma chamada polimórfica e nós

46000
30:29:46,960 --> 30:29:49,280
obterá a superfície do retângulo

46001
30:29:49,280 --> 30:29:50,800
e nós vamos imprimir isso aqui

46002
30:29:50,800 --> 30:29:52,080
Você vai ver que isso está acontecendo

46003
30:29:52,080 --> 30:29:54,232
para trabalhar, também podemos usar o ponteiro base

46004
30:29:54,232 --> 30:29:56,640
para gerenciar um objeto circular como vemos aqui

46005
30:29:56,640 --> 30:29:58,552
se chamarmos o método da superfície, isso é

46006
30:29:58,552 --> 30:30:00,872
indo para fazer polimorfismo e ele está indo

46007
30:30:00,872 --> 30:30:03,440
para chamar a versão de superfície do

46008
30:30:03,440 --> 30:30:05,680
classe de círculo e podemos vê-lo impresso

46009
30:30:05,680 --> 30:30:07,592
Este é o design que podemos

46010
30:30:07,592 --> 30:30:10,000
alcançar mesmo se a forma for abstrata

46011
30:30:10,000 --> 30:30:12,800
classe que não podemos criar objetos diretos de

46012
30:30:12,800 --> 30:30:15,592
forma como estamos fazendo aqui, mas podemos

46013
30:30:15,592 --> 30:30:18,720
usar um ponteiro base ou um ponteiro de forma para

46014
30:30:18,720 --> 30:30:21,040
gerenciar objeto derivado através de

46015
30:30:21,040 --> 30:30:23,912
O polimorfismo e você precisa estar ciente de

46016
30:30:23,912 --> 30:30:26,080
Isso está bem agora que você tem uma ideia

46017
30:30:26,080 --> 30:30:28,720
O que é uma função virtual pura

46018
30:30:28,720 --> 30:30:31,192
O que é uma classe abstrata

46019
30:30:31,192 --> 30:30:33,832
Vamos ver algumas ideias que você precisa manter

46020
30:30:33,832 --> 30:30:36,400
tendo em mente se a sua classe tem pelo menos um

46021
30:30:36,400 --> 30:30:39,280
pura função virtual que se tornará um

46022
30:30:39,280 --> 30:30:41,512
classe abstrata que você já sabe disso

46023
30:30:41,512 --> 30:30:43,440
Não pode criar objetos de um resumo

46024
30:30:43,440 --> 30:30:45,440
classe se você tentar fazer isso você vai ter

46025
30:30:45,440 --> 30:30:47,760
um erro de compilador outra coisa que eu não

46026
30:30:47,760 --> 30:30:50,400
Pense em meio ao super claro é que derivado

46027
30:30:50,400 --> 30:30:53,440
aulas de uma classe abstrata devem

46028
30:30:53,440 --> 30:30:56,872
substituir explicitamente todo o virtual puro

46029
30:30:56,872 --> 30:30:59,280
funções da classe base

46030
30:30:59,280 --> 30:31:01,440
Se você sair em algum

46031
30:31:01,440 --> 30:31:03,832
classe virtual pura que você não coloca

46032
30:31:03,832 --> 30:31:06,640
uma implementação para o seu

46033
30:31:06,640 --> 30:31:08,232
A classe também vai se tornar um

46034
30:31:08,232 --> 30:31:10,320
classe abstrata e você quer ser capaz

46035
30:31:10,320 --> 30:31:12,000
para criar objetos que você precisa

46036
30:31:12,000 --> 30:31:13,760
Mantenha isso em mente outra coisa que você

46037
30:31:13,760 --> 30:31:16,720
Você não pode chamar de puro virtual

46038
30:31:16,720 --> 30:31:17,912
Funções

46039
30:31:17,912 --> 30:31:20,480
A partir do construtor do abstract

46040
30:31:20,480 --> 30:31:22,000
classe se você fizer isso você vai conseguir

46041
30:31:22,000 --> 30:31:24,160
um erro de compilador porque não temos

46042
30:31:24,160 --> 30:31:26,552
implementações para essas coisas, então isso

46043
30:31:26,552 --> 30:31:28,800
Não vai trabalhar o construtor de

46044
30:31:28,800 --> 30:31:31,760
nossa classe abstrata é usada por derivação

46045
30:31:31,760 --> 30:31:34,480
aulas para construir a parte base do nosso

46046
30:31:34,480 --> 30:31:37,120
objetos derivados, mas não se querem dizer

46047
30:31:37,120 --> 30:31:39,760
para ser usado de fora porque nós

46048
30:31:39,760 --> 30:31:41,440
Não pode realmente criar um objeto de um

46049
30:31:41,440 --> 30:31:43,912
aula abstrata agora que você percebe

46050
30:31:43,912 --> 30:31:45,192
nós vamos ir para o visual

46051
30:31:45,192 --> 30:31:47,040
código de estúdio e jogar com isso um pouco

46052
30:31:47,040 --> 30:31:50,160
Mais aqui estamos em nossa pasta de trabalho

46053
30:31:50,160 --> 30:31:52,480
O projeto atual é puro virtual

46054
30:31:52,480 --> 30:31:55,680
funções e classes abstratas que somos

46055
30:31:55,680 --> 30:31:58,160
Vou pegar nossos arquivos de modelo e colocar

46056
30:31:58,160 --> 30:32:00,232
eles no lugar e nós vamos colar

46057
30:32:00,232 --> 30:32:03,040
Eles neste projeto aqui e nós somos

46058
30:32:03,040 --> 30:32:05,592
Vou pegar os arquivos que compõem o nosso

46059
30:32:05,592 --> 30:32:07,592
Hierarquia de herança que você está indo

46060
30:32:07,592 --> 30:32:09,512
obter esses arquivos do recurso

46061
30:32:09,512 --> 30:32:11,440
seção do curso, se você quiser

46062
30:32:11,440 --> 30:32:13,592
pode baixá-los e usá-los como eu sou

46063
30:32:13,592 --> 30:32:16,480
usando-os aqui ou melhor ainda, você pode

46064
30:32:16,480 --> 30:32:19,192
digite o código e veja como essas coisas

46065
30:32:19,192 --> 30:32:21,192
realmente trabalho que é a melhor maneira de aprender

46066
30:32:21,192 --> 30:32:23,680
Eu recomendo isso, mas queremos salvar

46067
30:32:23,680 --> 30:32:25,832
A tempo aqui, então eu vou apenas reutilizar

46068
30:32:25,832 --> 30:32:28,480
Estes óculos que eu tenho deitado no meu

46069
30:32:28,480 --> 30:32:30,400
drive eu vou abrir isso em visual

46070
30:32:30,400 --> 30:32:32,400
código de estúdio arrastando e soltando

46071
30:32:32,400 --> 30:32:35,680
Aqui temos nossa classe de forma aqui esta

46072
30:32:35,680 --> 30:32:38,080
Vai ser a nossa classe base você é

46073
30:32:38,080 --> 30:32:40,640
Vamos ver que temos o nosso membro

46074
30:32:40,640 --> 30:32:42,080
variável que vai ser a

46075
30:32:42,080 --> 30:32:45,040
descrição para a nossa forma que temos a

46076
30:32:45,040 --> 30:32:47,680
Um monte de construtores aqui, mas o mais

46077
30:32:47,680 --> 30:32:50,232
O importante aqui é que temos um

46078
30:32:50,232 --> 30:32:53,192
monte de funções virtuais puras aqui e

46079
30:32:53,192 --> 30:32:54,872
se você entrar no arquivo cpp você está indo

46080
30:32:54,872 --> 30:32:56,080
para ver que não temos

46081
30:32:56,080 --> 30:32:58,720
Implementações então para o perímetro

46082
30:32:58,720 --> 30:33:01,512
e funções de superfície estes são puros

46083
30:33:01,512 --> 30:33:03,360
Funções virtuais e não temos

46084
30:33:03,360 --> 30:33:05,912
empresas que colocam uma implementação em

46085
30:33:05,912 --> 30:33:08,320
A classe base, uma vez que temos estes

46086
30:33:08,320 --> 30:33:11,120
funções virtuais em e marcá-los como

46087
30:33:11,120 --> 30:33:14,400
funções virtuais puras, prependendo n

46088
30:33:14,400 --> 30:33:16,800
igual a zero aqui esta classe aqui é

46089
30:33:16,800 --> 30:33:19,440
tornar-se uma classe abstrata e

46090
30:33:19,440 --> 30:33:21,760
O que isso significa é que não podemos criar

46091
30:33:21,760 --> 30:33:24,640
Objetos desta classe significam pronto

46092
30:33:24,640 --> 30:33:28,000
ser herdado e downstream

46093
30:33:28,000 --> 30:33:30,552
As aulas de herança vão ser

46094
30:33:30,552 --> 30:33:32,000
forçados a

46095
30:33:32,000 --> 30:33:34,400
substituir esses métodos aqui de outra forma

46096
30:33:34,400 --> 30:33:36,480
Eles mesmos vão se tornar

46097
30:33:36,480 --> 30:33:38,640
classes abstratas que vamos ter um

46098
30:33:38,640 --> 30:33:40,800
chance de olhar para isso aqui também temos

46099
30:33:40,800 --> 30:33:42,640
nossa classe retangular que vai ser

46100
30:33:42,640 --> 30:33:44,960
Herançando da forma que vai

46101
30:33:44,960 --> 30:33:47,192
substituir nossos dois métodos para os quais vamos

46102
30:33:47,192 --> 30:33:49,040
substituir a função do perímetro que somos

46103
30:33:49,040 --> 30:33:50,960
indo para substituir a função de superfície

46104
30:33:50,960 --> 30:33:53,280
para retângulo o perímetro é computado

46105
30:33:53,280 --> 30:33:55,760
Dessa forma, vamos nos multiplicar

46106
30:33:55,760 --> 30:33:58,720
a largura por dois e a altura por dois

46107
30:33:58,720 --> 30:34:00,800
e nós vamos adicionar essas duas coisas

46108
30:34:00,800 --> 30:34:02,720
Vamos calcular a superfície por

46109
30:34:02,720 --> 30:34:04,960
multiplicando a largura e a altura e isso é

46110
30:34:04,960 --> 30:34:06,872
vamos nos dar os dados que queremos que possamos

46111
30:34:06,872 --> 30:34:08,960
Olhe para o círculo, ele também vai

46112
30:34:08,960 --> 30:34:10,960
herdar da forma e vai

46113
30:34:10,960 --> 30:34:13,360
substituir nossos métodos aqui, se quisermos

46114
30:34:13,360 --> 30:34:16,800
pode até mesmo colocar um raio e uma variável

46115
30:34:16,800 --> 30:34:19,680
para manter o controle de pi nós podemos fazer isso você

46116
30:34:19,680 --> 30:34:21,760
Pode realmente fazer isso como você quer que você queira isso

46117
30:34:21,760 --> 30:34:23,680
só vai nos permitir calcular o

46118
30:34:23,680 --> 30:34:26,080
superfície relativamente fácil nesta classe

46119
30:34:26,080 --> 30:34:28,232
Aqui vamos olhar para a implementação

46120
30:34:28,232 --> 30:34:30,400
Nada de especial aqui isso está apenas indo

46121
30:34:30,400 --> 30:34:32,720
para encaminhar a construção da base

46122
30:34:32,720 --> 30:34:34,480
parte de nós para o

46123
30:34:34,480 --> 30:34:36,640
construtor de base e isso vai fazer

46124
30:34:36,640 --> 30:34:38,960
O que quer que queiramos fazer aqui vamos

46125
30:34:38,960 --> 30:34:40,960
cabeça para o arquivo principal cpp e

46126
30:34:40,960 --> 30:34:43,040
Na verdade, use essas coisas

46127
30:34:43,040 --> 30:34:46,000
Vamos incluir o círculo e

46128
30:34:46,000 --> 30:34:49,120
retângulo vamos fazer esse círculo dot h e

46129
30:34:49,120 --> 30:34:51,760
nós vamos colocar em retângulo que h

46130
30:34:51,760 --> 30:34:54,320
e vamos primeiro tentar criar

46131
30:34:54,320 --> 30:34:56,720
Um objeto de forma, vamos fazer isso, estamos indo

46132
30:34:56,720 --> 30:34:59,912
para dizer forma e dizer ponteiro de forma e

46133
30:34:59,912 --> 30:35:02,400
Esta será uma nova forma que podemos usar

46134
30:35:02,400 --> 30:35:04,640
um construtor padrão e se o fizermos

46135
30:35:04,640 --> 30:35:05,912
Algo assim você vai ver

46136
30:35:05,912 --> 30:35:07,760
que vamos ter um compilador

46137
30:35:07,760 --> 30:35:10,000
Erro aqui temos uma linha rompida, mas

46138
30:35:10,000 --> 30:35:12,960
Se trouxermos uma janela terminal e

46139
30:35:12,960 --> 30:35:15,440
Olhe para a aba de problemas que vamos

46140
30:35:15,440 --> 30:35:18,400
Veja o objeto do tipo de classe abstrata

46141
30:35:18,400 --> 30:35:20,800
A forma não é permitida, então a forma é uma

46142
30:35:20,800 --> 30:35:22,800
Classe abstrata agora

46143
30:35:22,800 --> 30:35:25,040
Por que é uma classe abstrata porque

46144
30:35:25,040 --> 30:35:28,160
Temos pelo menos um puro virtual

46145
30:35:28,160 --> 30:35:30,480
Função aqui, na verdade, temos dois e

46146
30:35:30,480 --> 30:35:32,960
Isto vai fazer a nossa classe de forma um

46147
30:35:32,960 --> 30:35:35,512
classe abstrata o que isso significa é que

46148
30:35:35,512 --> 30:35:37,912
Não podemos criar objetos desta classe

46149
30:35:37,912 --> 30:35:39,360
E se fizermos isso, vamos ter um

46150
30:35:39,360 --> 30:35:41,832
Erro do compilador, vamos tentar construir isso

46151
30:35:41,832 --> 30:35:43,512
programa, vamos passar por isso

46152
30:35:43,512 --> 30:35:46,232
gcc nosso compilador favorito que estamos indo

46153
30:35:46,232 --> 30:35:48,000
para ver que o parafuso vai falhar

46154
30:35:48,000 --> 30:35:50,000
vamos ter um monte de erros se

46155
30:35:50,000 --> 30:35:53,360
Vamos subir e olhar para o erro que temos

46156
30:35:53,360 --> 30:35:56,552
nova expressão de classe abstrata

46157
30:35:56,552 --> 30:35:58,320
forma do tipo

46158
30:35:58,320 --> 30:36:00,640
então não podemos realmente criar um objeto de

46159
30:36:00,640 --> 30:36:03,040
Isso vamos descer e ver o que estes

46160
30:36:03,040 --> 30:36:05,760
Os erros são notar porque o

46161
30:36:05,760 --> 30:36:07,760
As seguintes funções virtuais são puras

46162
30:36:07,760 --> 30:36:10,232
dentro da forma e eles vão tentar

46163
30:36:10,232 --> 30:36:12,552
E realmente ser útil nos erros que

46164
30:36:12,552 --> 30:36:15,040
Eles dão aqui e tudo o que estão dizendo

46165
30:36:15,040 --> 30:36:17,512
é que não podemos criar objetos deste

46166
30:36:17,512 --> 30:36:19,760
classe porque temos puro virtual

46167
30:36:19,760 --> 30:36:22,160
funções dentro de tudo bem agora você sabe disso

46168
30:36:22,160 --> 30:36:24,800
Se uma classe é abstrata, você não pode criar

46169
30:36:24,800 --> 30:36:27,360
objetos dessa classe, mas você ainda pode

46170
30:36:27,360 --> 30:36:29,912
usar um ponteiro base para gerenciar derivado

46171
30:36:29,912 --> 30:36:32,800
objetos dessa classe, então vamos comentar

46172
30:36:32,800 --> 30:36:35,192
isso porque isso vai fazer

46173
30:36:35,192 --> 30:36:37,592
Nosso código não compila e nós vamos

46174
30:36:37,592 --> 30:36:39,040
Diga que isso vai nos dar uma

46175
30:36:39,040 --> 30:36:41,440
Erro do compilador e vamos tentar

46176
30:36:41,440 --> 30:36:43,592
e use o ponteiro base para gerenciar um

46177
30:36:43,592 --> 30:36:46,160
objeto retangular, podemos fazer isso para que sejamos

46178
30:36:46,160 --> 30:36:48,480
Vou montar um ponteiro de forma e ele

46179
30:36:48,480 --> 30:36:50,552
vai gerir a memória de um

46180
30:36:50,552 --> 30:36:52,640
objeto do retângulo, vamos embora

46181
30:36:52,640 --> 30:36:54,400
através do ponteiro base e chamar o

46182
30:36:54,400 --> 30:36:56,800
método de superfície e isso vai chamar

46183
30:36:56,800 --> 30:36:59,120
A implementação em retângulo porque

46184
30:36:59,120 --> 30:37:01,040
nosso ponteiro base está realmente gerenciando o

46185
30:37:01,040 --> 30:37:03,360
objeto retangular se você quiser você pode

46186
30:37:03,360 --> 30:37:06,160
até mesmo usar o tipo id operador para imprimir

46187
30:37:06,160 --> 30:37:08,720
o tipo dinâmico desta forma de rect

46188
30:37:08,720 --> 30:37:10,160
ponteiro que você vai ver que é

46189
30:37:10,160 --> 30:37:12,080
Gerenciando um retângulo que você pode realmente fazer

46190
30:37:12,080 --> 30:37:13,592
porque aprendemos sobre isso em

46191
30:37:13,592 --> 30:37:15,832
A última palestra então vamos praticar que

46192
30:37:15,832 --> 30:37:18,480
Vamos dizer tipo dinâmico de forma

46193
30:37:18,480 --> 30:37:21,512
Envolve e vamos dizer tipo id e

46194
30:37:21,512 --> 30:37:23,280
nós vamos desreferenciar o ponteiro

46195
30:37:23,280 --> 30:37:25,040
Nós vamos dizer naufragado e nós estamos

46196
30:37:25,040 --> 30:37:27,040
Vou imprimir o nome disso e

46197
30:37:27,040 --> 30:37:29,512
nós vamos vê-lo imprimir no nosso

46198
30:37:29,512 --> 30:37:31,832
janela powershell e depois disso estamos

46199
30:37:31,832 --> 30:37:33,912
Vou imprimir a superfície que temos

46200
30:37:33,912 --> 30:37:36,552
A partir desta chamada aqui e nós vamos

46201
30:37:36,552 --> 30:37:39,120
Veja o que isso nos dá, vamos tentar e

46202
30:37:39,120 --> 30:37:40,872
construir este programa vamos passar

46203
30:37:40,872 --> 30:37:43,680
através de gcc nosso compilador favorito

46204
30:37:43,680 --> 30:37:45,192
A bala vai ser boa nós vamos

46205
30:37:45,192 --> 30:37:47,360
para limpar e correr galo, vamos

46206
30:37:47,360 --> 30:37:50,000
Veja que o tipo dinâmico é retângulo

46207
30:37:50,000 --> 30:37:52,232
você pode ver isso aqui para que a base

46208
30:37:52,232 --> 30:37:54,800
O ponteiro está realmente gerenciando um retângulo

46209
30:37:54,800 --> 30:37:57,592
Objeto e isso é o que temos aqui e

46210
30:37:57,592 --> 30:37:59,912
se chamarmos o método da superfície, seremos

46211
30:37:59,912 --> 30:38:03,280
Chamando o método no tipo dinâmico

46212
30:38:03,280 --> 30:38:04,960
Então vamos chamar essa superfície

46213
30:38:04,960 --> 30:38:07,680
método na classe retângulo e nós

46214
30:38:07,680 --> 30:38:08,720
Será

46215
30:38:08,720 --> 30:38:11,192
usando a implementação que temos aqui, então

46216
30:38:11,192 --> 30:38:13,512
A função de superfície que vai ser

46217
30:38:13,512 --> 30:38:16,480
chamado é o que temos na linha 20 em

46218
30:38:16,480 --> 30:38:18,720
Retângulo aqui e isso vai apenas

46219
30:38:18,720 --> 30:38:21,360
ser uma multiplicação de largura e altura

46220
30:38:21,360 --> 30:38:24,080
e nós vamos conseguir 100 aqui porque

46221
30:38:24,080 --> 30:38:26,400
Nossa largura e altura acontecem para ser

46222
30:38:26,400 --> 30:38:28,800
10 e 10, então multiplicar isso está indo

46223
30:38:28,800 --> 30:38:31,680
para nos dar 100 como vemos aqui este é

46224
30:38:31,680 --> 30:38:33,512
Isso é o que esperamos

46225
30:38:33,512 --> 30:38:36,160
pode até usar nosso ponteiro base para gerenciar

46226
30:38:36,160 --> 30:38:38,400
um objeto circular, então vamos fazer isso

46227
30:38:38,400 --> 30:38:40,320
Vou colocar em um separador para ser capaz

46228
30:38:40,320 --> 30:38:43,760
para seguir isso facilmente e nossa saída assim

46229
30:38:43,760 --> 30:38:46,232
Vamos dizer stdndl aqui e nós vamos

46230
30:38:46,232 --> 30:38:48,320
colocar o código para que vamos configurar

46231
30:38:48,320 --> 30:38:50,232
Um ponteiro base que realmente vai

46232
30:38:50,232 --> 30:38:53,120
estar gerenciando um objeto de círculo aqui e nós

46233
30:38:53,120 --> 30:38:55,680
chamará o nosso método de superfície este é

46234
30:38:55,680 --> 30:38:57,592
Vou chamar esse método

46235
30:38:57,592 --> 30:38:59,512
polimorfia porque a superfície é uma

46236
30:38:59,512 --> 30:39:00,960
a função virtual

46237
30:39:00,960 --> 30:39:03,680
então vamos ter polimorfismo aqui e nós

46238
30:39:03,680 --> 30:39:05,512
chamará o método da superfície no

46239
30:39:05,512 --> 30:39:07,832
objeto de círculo que é realmente nosso

46240
30:39:07,832 --> 30:39:09,760
tipo dinâmico se imprimirmos isso, estamos

46241
30:39:09,760 --> 30:39:12,160
Vou ver a superfície impressa, mas

46242
30:39:12,160 --> 30:39:14,960
Se quisermos, podemos até imprimir a dinâmica

46243
30:39:14,960 --> 30:39:16,720
Tipo de nosso tipo

46244
30:39:16,720 --> 30:39:18,320
ponto base aqui, então vamos fazer

46245
30:39:18,320 --> 30:39:20,720
A mesma coisa que fizemos para o retângulo nós

46246
30:39:20,720 --> 30:39:23,592
pode usar o nosso tipo id operador para imprimir

46247
30:39:23,592 --> 30:39:26,480
o tipo dinâmico de círculo de forma e

46248
30:39:26,480 --> 30:39:28,640
nós vamos dizer círculo de forma aqui e

46249
30:39:28,640 --> 30:39:31,120
Isto vai fazer o que queremos vamos

46250
30:39:31,120 --> 30:39:32,872
Olhe para isso, vamos imprimir

46251
30:39:32,872 --> 30:39:35,592
A superfície aqui é exatamente o que nós

46252
30:39:35,592 --> 30:39:37,592
Quero, então vamos construir e correr, vamos

46253
30:39:37,592 --> 30:39:40,000
para passar isso através do gcc o parafuso é

46254
30:39:40,000 --> 30:39:41,912
indo para passar como você vê aqui se

46255
30:39:41,912 --> 30:39:42,960
nós limpamos

46256
30:39:42,960 --> 30:39:45,360
e correr o galo, vamos ver isso

46257
30:39:45,360 --> 30:39:47,912
o tipo dinâmico é agora um círculo, então o

46258
30:39:47,912 --> 30:39:50,400
ponteiro base ou o ponteiro de forma que nós

46259
30:39:50,400 --> 30:39:52,640
ter aqui está realmente gerenciando

46260
30:39:52,640 --> 30:39:55,512
um objeto de círculo polimorficamente, então se nós

46261
30:39:55,512 --> 30:39:57,832
chamar uma função virtual nesta base

46262
30:39:57,832 --> 30:39:59,912
pointer é chamar

46263
30:39:59,912 --> 30:40:01,120
O mais

46264
30:40:01,120 --> 30:40:03,592
Implementação específica da superfície

46265
30:40:03,592 --> 30:40:05,912
Objeto que temos e isso acontece para ser

46266
30:40:05,912 --> 30:40:08,000
para este objeto circular aqui é o que

46267
30:40:08,000 --> 30:40:08,960
Eu quero dizer

46268
30:40:08,960 --> 30:40:10,720
Se calcularmos a superfície, vamos

46269
30:40:10,720 --> 30:40:12,480
Veja que vai usar o

46270
30:40:12,480 --> 30:40:14,872
dados que temos aqui e vamos conseguir isso

46271
30:40:14,872 --> 30:40:17,440
número como a nossa superfície se você ligar isso

46272
30:40:17,440 --> 30:40:18,640
em você vai ver que isso é

46273
30:40:18,640 --> 30:40:21,040
Realmente certo, então isso é realmente tudo que eu tinha

46274
30:40:21,040 --> 30:40:23,592
para compartilhar esta palestra podemos criar

46275
30:40:23,592 --> 30:40:26,640
funções virtuais puras em uma classe base

46276
30:40:26,640 --> 30:40:28,400
e o que isso vai fazer está indo

46277
30:40:28,400 --> 30:40:31,760
para tornar nossa classe uma classe abstrata, mas

46278
30:40:31,760 --> 30:40:33,592
Queremos também ser capazes de colocar em

46279
30:40:33,592 --> 30:40:35,680
Implementações para estes

46280
30:40:35,680 --> 30:40:37,592
métodos mais na classe base

46281
30:40:37,592 --> 30:40:39,512
Porque eles estão destinados a ser

46282
30:40:39,512 --> 30:40:41,680
sobrescrito e implementado por

46283
30:40:41,680 --> 30:40:44,720
classes de herança downstream, então se você

46284
30:40:44,720 --> 30:40:46,640
entrar aqui e tentar colocar em um

46285
30:40:46,640 --> 30:40:49,192
implementação, provavelmente teremos a

46286
30:40:49,192 --> 30:40:50,960
Erro do compilador porque este não é

46287
30:40:50,960 --> 30:40:53,120
permite que você veja que temos um problema aqui

46288
30:40:53,120 --> 30:40:55,280
Se tentarmos construir, vamos ter um estranho

46289
30:40:55,280 --> 30:40:57,280
Erro do compilador, certifique-se de que vemos

46290
30:40:57,280 --> 30:40:59,832
O erro do compilador assim o mundo terminou

46291
30:40:59,832 --> 30:41:02,872
com erros e vamos ver

46292
30:41:02,872 --> 30:41:05,192
Qual é o problema aqui vamos subir e

46293
30:41:05,192 --> 30:41:06,232
Veja

46294
30:41:06,232 --> 30:41:09,832
Especificante puro na definição da função assim

46295
30:41:09,832 --> 30:41:12,640
Isso não é permitido, então estamos realmente

46296
30:41:12,640 --> 30:41:15,592
Nos em conflito aqui estamos

46297
30:41:15,592 --> 30:41:18,000
marcando esta função como um puro virtual

46298
30:41:18,000 --> 30:41:19,040
A função

46299
30:41:19,040 --> 30:41:22,320
e o que isso significa e um puro virtual

46300
30:41:22,320 --> 30:41:24,000
funções não é para ter um

46301
30:41:24,000 --> 30:41:26,400
definição, mas também estamos colocando em um

46302
30:41:26,400 --> 30:41:28,000
definição aqui para que o compilador esteja indo

46303
30:41:28,000 --> 30:41:29,912
Estar confuso isso não é algo que nós

46304
30:41:29,912 --> 30:41:32,160
Deve estar fazendo outra coisa que eu quero

46305
30:41:32,160 --> 30:41:34,800
apontar antes de encerrar esta palestra

46306
30:41:34,800 --> 30:41:35,912
É isso que

46307
30:41:35,912 --> 30:41:39,680
classes herdadas a jusante são forçadas

46308
30:41:39,680 --> 30:41:42,160
para substituir e implementar todos os puros

46309
30:41:42,160 --> 30:41:44,720
funções virtuais da classe que

46310
30:41:44,720 --> 30:41:47,440
Eles herdam se não fizerem isso

46311
30:41:47,440 --> 30:41:49,440
Eles mesmos vão se tornar

46312
30:41:49,440 --> 30:41:51,440
Abstract e queremos ser capazes de

46313
30:41:51,440 --> 30:41:54,232
criar objetos deles, então vamos tentar

46314
30:41:54,232 --> 30:41:56,080
Por exemplo, comentar a superfície

46315
30:41:56,080 --> 30:41:58,232
implementação aqui e isso vai

46316
30:41:58,232 --> 30:42:02,000
fazer da nossa classe circular uma classe abstrata

46317
30:42:02,000 --> 30:42:03,912
e se tentarmos criar um objeto com

46318
30:42:03,912 --> 30:42:06,000
Círculo vamos ter um erro de compilador

46319
30:42:06,000 --> 30:42:08,640
Porque agora o círculo é uma classe abstrata

46320
30:42:08,640 --> 30:42:10,232
Vamos tentar construir e mostrar-lhe o

46321
30:42:10,232 --> 30:42:12,480
erro do compilador e isso pode realmente ser

46322
30:42:12,480 --> 30:42:15,280
confuso se você é um iniciante sobre isso

46323
30:42:15,280 --> 30:42:17,760
Você vai se perguntar por que você não pode

46324
30:42:17,760 --> 30:42:20,720
criar objetos de sua classe, mesmo se você

46325
30:42:20,720 --> 30:42:23,832
Realmente não colocou explicitamente em nenhum puro

46326
30:42:23,832 --> 30:42:26,232
A função virtual, a razão é que somos

46327
30:42:26,232 --> 30:42:29,360
Herdar de uma classe abstrata que

46328
30:42:29,360 --> 30:42:32,720
tem duas funções virtuais puras, mas nós

46329
30:42:32,720 --> 30:42:35,760
estão apenas substituindo um puro virtual

46330
30:42:35,760 --> 30:42:38,160
A função precisamos substituir todos eles

46331
30:42:38,160 --> 30:42:40,400
Caso contrário, nossa classe também será

46332
30:42:40,400 --> 30:42:42,720
uma classe abstrata, vamos olhar para o

46333
30:42:42,720 --> 30:42:44,640
Erro do compilador que estamos recebendo aqui vamos

46334
30:42:44,640 --> 30:42:47,440
suba e veja se podemos encontrá-lo, somos

46335
30:42:47,440 --> 30:42:49,912
Vamos dizer em função principal

46336
30:42:49,912 --> 30:42:52,480
Avaliar nova expressão de abstract

46337
30:42:52,480 --> 30:42:55,120
classe tipo círculo que estamos tentando

46338
30:42:55,120 --> 30:42:58,160
criar um objeto a partir de uma classe abstrata

46339
30:42:58,160 --> 30:43:00,232
Este é o erro que temos aqui e você

46340
30:43:00,232 --> 30:43:01,832
deveria realmente anotar isso

46341
30:43:01,832 --> 30:43:04,400
então vamos voltar e ter certeza de que estamos

46342
30:43:04,400 --> 30:43:06,552
substituindo todas essas acrobacias porque nós

46343
30:43:06,552 --> 30:43:08,720
Precisamos fazer isso para poder criar

46344
30:43:08,720 --> 30:43:11,512
objetos de um círculo e agora isso é

46345
30:43:11,512 --> 30:43:14,080
Vou trabalhar exatamente como deveria, vamos

46346
30:43:14,080 --> 30:43:16,160
construir e certificar-se de que a bala

46347
30:43:16,160 --> 30:43:18,232
Vai ser bom, estamos bem, isso é

46348
30:43:18,232 --> 30:43:20,800
Trabalhar exatamente como queremos isso é

46349
30:43:20,800 --> 30:43:22,480
Realmente tudo que eu queria que você visse isso

46350
30:43:22,480 --> 30:43:24,720
Uma palestra espero que você tenha achado interessante

46351
30:43:24,720 --> 30:43:27,120
Vamos parar por aqui neste

46352
30:43:27,120 --> 30:43:28,960
O próximo que vamos aprender sobre

46353
30:43:28,960 --> 30:43:31,592
interfaces em c plus plus e eles são

46354
30:43:31,592 --> 30:43:33,440
Vamos reutilizar o conhecimento que nós

46355
30:43:33,440 --> 30:43:35,360
Aprendi sobre esta palestra ir em frente

46356
30:43:35,360 --> 30:43:37,832
e terminar aqui e encontrar-me lá dentro

46357
30:43:37,832 --> 30:43:39,360
Esta palestra vamos ver que nós

46358
30:43:39,360 --> 30:43:43,120
pode modelar interfaces em c plus plus

46359
30:43:43,120 --> 30:43:45,592
usando classes abstratas

46360
30:43:45,592 --> 30:43:47,280
E agora há um monte de coisas que

46361
30:43:47,280 --> 30:43:50,000
pode não fazer sentido no que eu acabei de dizer

46362
30:43:50,000 --> 30:43:52,480
Então vamos quebrar essa interface

46363
30:43:52,480 --> 30:43:55,912
Pode ser pensado como uma classe abstrata

46364
30:43:55,912 --> 30:43:59,440
apenas com funções virtuais puras e não

46365
30:43:59,440 --> 30:44:02,080
membro variável, portanto, se você tiver uma configuração

46366
30:44:02,080 --> 30:44:03,832
Assim, você pode chamar essa coisa de

46367
30:44:03,832 --> 30:44:06,232
Interface, veja um exemplo simples

46368
30:44:06,232 --> 30:44:08,160
Aqui temos uma classe simples chamada

46369
30:44:08,160 --> 30:44:10,232
fluxo inserível você vê que

46370
30:44:10,232 --> 30:44:12,872
não tem nenhuma variável de membro apenas

46371
30:44:12,872 --> 30:44:16,232
tem uma função virtual pura aqui e

46372
30:44:16,232 --> 30:44:18,232
função de ajudante que poderíamos configurar para

46373
30:44:18,232 --> 30:44:20,400
Ajude-nos a fazer algumas coisas apenas

46374
30:44:20,400 --> 30:44:23,832
especificação para fazer desta interface

46375
30:44:23,832 --> 30:44:26,720
É ter apenas em puro virtual

46376
30:44:26,720 --> 30:44:29,512
funções e sem variáveis de membro se você

46377
30:44:29,512 --> 30:44:31,360
ter em uma variável membro que está indo

46378
30:44:31,360 --> 30:44:33,760
para parar de se tornar uma interface em c plus

46379
30:44:33,760 --> 30:44:35,440
Mais OK para que você possa pensar em um

46380
30:44:35,440 --> 30:44:38,000
Interface como uma classe abstrata

46381
30:44:38,000 --> 30:44:40,960
com pelo menos uma função virtual pura

46382
30:44:40,960 --> 30:44:43,120
e nenhuma variável de membro que vai

46383
30:44:43,120 --> 30:44:45,440
torná-lo uma interface aqui você vê

46384
30:44:45,440 --> 30:44:48,160
que uma interface pode ser pensada como a

46385
30:44:48,160 --> 30:44:51,120
especificação de algo que será

46386
30:44:51,120 --> 30:44:54,080
totalmente implementado em uma classe derivada

46387
30:44:54,080 --> 30:44:56,552
mas a especificação em si vai

46388
30:44:56,552 --> 30:44:59,680
Residir na classe abstrata de outra forma

46389
30:44:59,680 --> 30:45:02,552
pensar em uma interface é tratar

46390
30:45:02,552 --> 30:45:05,040
Uma interface como uma coisa

46391
30:45:05,040 --> 30:45:07,280
você pode anexar aos seus tipos para dar

46392
30:45:07,280 --> 30:45:10,320
eles superpoderes, por exemplo, este fluxo

46393
30:45:10,320 --> 30:45:12,160
interface insertable

46394
30:45:12,160 --> 30:45:14,480
tem um único trabalho e isso vai

46395
30:45:14,480 --> 30:45:17,912
permitir que nossos tipos insiram dados em

46396
30:45:17,912 --> 30:45:20,872
fluxos de saída como sddc out este é o

46397
30:45:20,872 --> 30:45:22,800
A única coisa para essa interface

46398
30:45:22,800 --> 30:45:25,440
adicionar aos nossos tempos para que possamos levar isso

46399
30:45:25,440 --> 30:45:27,360
interface e anexá isso a um ponto

46400
30:45:27,360 --> 30:45:29,360
Classe, por exemplo, e nós vamos

46401
30:45:29,360 --> 30:45:31,760
ser automaticamente capaz de imprimir ponto

46402
30:45:31,760 --> 30:45:34,480
objetos para o fluxo de saída e nós queremos

46403
30:45:34,480 --> 30:45:37,040
para precisar sobrecarregar a saída do fluxo

46404
30:45:37,040 --> 30:45:39,592
operador na classe de pontos que podemos fazer

46405
30:45:39,592 --> 30:45:41,680
A mesma coisa para a nossa classe de pássaros que podemos

46406
30:45:41,680 --> 30:45:44,160
fazer a mesma coisa para nossa aula de cães e

46407
30:45:44,160 --> 30:45:46,080
Seremos capazes de imprimir essas coisas

46408
30:45:46,080 --> 30:45:48,232
sem ter que sobrecarregar o fluxo

46409
30:45:48,232 --> 30:45:50,400
operador de saída espero que você possa ver

46410
30:45:50,400 --> 30:45:53,512
Quão poderoso isso é se conseguirmos definir

46411
30:45:53,512 --> 30:45:55,680
Este tipo de relação entre o nosso

46412
30:45:55,680 --> 30:45:58,720
tipo e nossas interfaces novamente

46413
30:45:58,720 --> 30:46:00,800
Interface é algo que você pode anexar

46414
30:46:00,800 --> 30:46:03,592
seus tipos para dar poderes ou

46415
30:46:03,592 --> 30:46:05,832
características que eles originalmente não tinham

46416
30:46:05,832 --> 30:46:07,912
ter e isso vai te salvar de

46417
30:46:07,912 --> 30:46:10,232
Ter que implementar essas características

46418
30:46:10,232 --> 30:46:12,400
separadamente em cada classe em tempo real

46419
30:46:12,400 --> 30:46:14,400
então este é um grande economizador de tempo agora você

46420
30:46:14,400 --> 30:46:16,800
Deve estar perguntando como eu tomei meu

46421
30:46:16,800 --> 30:46:19,440
interface e anexá-lo ao meu tipo bem

46422
30:46:19,440 --> 30:46:22,080
A maneira como c plus mais faz isso que você tem

46423
30:46:22,080 --> 30:46:25,760
Herdar da interface do seu

46424
30:46:25,760 --> 30:46:28,160
digite para conectar a interface ao seu

46425
30:46:28,160 --> 30:46:30,080
digite, por exemplo, se quiséssemos

46426
30:46:30,080 --> 30:46:32,872
anexar esta interface à nossa classe de pontos

46427
30:46:32,872 --> 30:46:34,720
O que nós fariamos é algo assim

46428
30:46:34,720 --> 30:46:37,440
criaríamos nossa classe de pontos

46429
30:46:37,440 --> 30:46:40,720
e herdar da nossa interface que é

46430
30:46:40,720 --> 30:46:42,800
fluxo inserível no momento em que fazemos isso

46431
30:46:42,800 --> 30:46:44,720
Nosso ponto vai ser capaz de imprimir

46432
30:46:44,720 --> 30:46:47,192
graças ao console através do fluxo

46433
30:46:47,192 --> 30:46:49,512
operador de saída, mas espero que você possa

46434
30:46:49,512 --> 30:46:52,160
Veja que algo está faltando como

46435
30:46:52,160 --> 30:46:55,040
nossa classe de pontos sabe como imprimir coisas

46436
30:46:55,040 --> 30:46:57,360
Se subirmos e olharmos para o nosso fluxo

46437
30:46:57,360 --> 30:46:59,592
interface inserível que vamos ver

46438
30:46:59,592 --> 30:47:02,160
que está declarando uma saída de fluxo

46439
30:47:02,160 --> 30:47:05,040
Operador é essa coisa que é usada

46440
30:47:05,040 --> 30:47:07,592
para imprimir dados para o fluxo de saída

46441
30:47:07,592 --> 30:47:09,680
ver este é um fluxo de saída regular

46442
30:47:09,680 --> 30:47:12,960
Operador, estaremos imprimindo para sddo

46443
30:47:12,960 --> 30:47:16,000
fluxo e o objeto é nomeado aqui

46444
30:47:16,000 --> 30:47:18,160
e estaremos imprimindo qualquer operando

46445
30:47:18,160 --> 30:47:20,080
que é passado como um segundo parâmetro

46446
30:47:20,080 --> 30:47:22,400
Aqui, mas as capturas

46447
30:47:22,400 --> 30:47:24,552
Precisamos criar um virtual

46448
30:47:24,552 --> 30:47:25,592
A função

46449
30:47:25,592 --> 30:47:28,080
que terá de ser implementado por

46450
30:47:28,080 --> 30:47:31,680
Quem herda da nossa interface aqui

46451
30:47:31,680 --> 30:47:34,080
E isso vai ser super poderoso

46452
30:47:34,080 --> 30:47:36,160
Vamos assumir o trabalho para

46453
30:47:36,160 --> 30:47:38,872
impressão para o fluxo de saída mas nós vamos

46454
30:47:38,872 --> 30:47:42,232
deixar herdar as classes de download para

46455
30:47:42,232 --> 30:47:44,232
Especifique o que imprimimos e eles estão indo

46456
30:47:44,232 --> 30:47:47,760
para especificar isso neste método virtual

46457
30:47:47,760 --> 30:47:49,832
Vamos olhar para a nossa classe point novamente e

46458
30:47:49,832 --> 30:47:52,640
Realmente colocar os quebra-cabeças juntos aqui e

46459
30:47:52,640 --> 30:47:55,280
Entenda como isso funciona ok, isso é

46460
30:47:55,280 --> 30:47:57,832
nossa classe de pontos e vai ser

46461
30:47:57,832 --> 30:48:00,552
herdar a partir da nossa interface e é

46462
30:48:00,552 --> 30:48:02,872
implementar nossa função virtual

46463
30:48:02,872 --> 30:48:04,720
Aqui vamos diná-lo aqui e

46464
30:48:04,720 --> 30:48:07,040
Vamos marcá-lo como uma substituição

46465
30:48:07,040 --> 30:48:09,280
porque está substituindo um método que

46466
30:48:09,280 --> 30:48:11,192
vem do nosso fluxo inserível

46467
30:48:11,192 --> 30:48:13,120
Interface aqui e vai

46468
30:48:13,120 --> 30:48:16,160
especificar quais dados nós imprimimos para o

46469
30:48:16,160 --> 30:48:18,160
fluxo de saída e como os dados estão indo

46470
30:48:18,160 --> 30:48:20,552
para ser impresso para fora você pode especificar

46471
30:48:20,552 --> 30:48:22,640
Essas coisas aqui nós vamos formatar

46472
30:48:22,640 --> 30:48:24,320
os dados em um ponto e nós vamos

46473
30:48:24,320 --> 30:48:27,040
estar usando estes colchetes para colocar mx

46474
30:48:27,040 --> 30:48:30,000
e o meu aqui e observe que este é um

46475
30:48:30,000 --> 30:48:33,760
substituir para que a classe de herança tenha

46476
30:48:33,760 --> 30:48:36,000
todas as informações que precisamos colocar

46477
30:48:36,000 --> 30:48:38,552
nosso operador de fluxo de saída e vamos

46478
30:48:38,552 --> 30:48:40,800
fazer isso através da nossa inserção de fluxo

46479
30:48:40,800 --> 30:48:43,120
override aqui agora vamos voltar para o nosso

46480
30:48:43,120 --> 30:48:46,552
transmissão de interface inserível para ver como

46481
30:48:46,552 --> 30:48:48,960
nosso operador de fluxo de saída realmente

46482
30:48:48,960 --> 30:48:51,592
O que temos aqui é o que seria

46483
30:48:51,592 --> 30:48:53,512
um cabeçalho e isso vai apenas colocar

46484
30:48:53,512 --> 30:48:55,760
em uma declaração para isso, mas nós podemos

46485
30:48:55,760 --> 30:48:58,400
até mesmo olhar para a sua implementação

46486
30:48:58,400 --> 30:49:00,640
implementação para o nosso fluxo de saída

46487
30:49:00,640 --> 30:49:02,720
O operador pode parecer algo assim

46488
30:49:02,720 --> 30:49:04,552
Vai passar no primeiro operando

46489
30:49:04,552 --> 30:49:06,872
e o segundo operando aqui, mas note

46490
30:49:06,872 --> 30:49:09,192
O que estamos fazendo aqui nós vamos

46491
30:49:09,192 --> 30:49:10,000
chamada

46492
30:49:10,000 --> 30:49:13,192
O fluxo insere a função virtual em

46493
30:49:13,192 --> 30:49:16,400
nosso operando aqui e isso vai

46494
30:49:16,400 --> 30:49:17,360
chamada

46495
30:49:17,360 --> 30:49:20,320
A implementação mais específica que podemos

46496
30:49:20,320 --> 30:49:22,872
encontrar para a inserção do fluxo se nós somos

46497
30:49:22,872 --> 30:49:24,720
Tentando imprimir um círculo, por exemplo

46498
30:49:24,720 --> 30:49:27,592
isso vai chamar o fluxo de inserção

46499
30:49:27,592 --> 30:49:30,320
substituir um objeto circular se nós somos

46500
30:49:30,320 --> 30:49:32,872
Tentando imprimir um ponto que isso vai

46501
30:49:32,872 --> 30:49:35,440
chamar este método em nosso objeto de ponto e

46502
30:49:35,440 --> 30:49:37,512
Isso vai usar o polimorfismo

46503
30:49:37,512 --> 30:49:40,232
Porque o nosso segundo operando aqui é passar

46504
30:49:40,232 --> 30:49:42,480
por referência espero que você possa ver como

46505
30:49:42,480 --> 30:49:44,480
Isso é super poderoso eu sei que isso é

46506
30:49:44,480 --> 30:49:46,552
Convolumente porque estamos pulando

46507
30:49:46,552 --> 30:49:49,040
Tentando explicar isso, mas eu não poderia

46508
30:49:49,040 --> 30:49:51,360
Realmente chegar a uma maneira mais fácil de colocar

46509
30:49:51,360 --> 30:49:54,160
que temos que tentar esta codificação para

46510
30:49:54,160 --> 30:49:57,192
realmente ver o poder disso, mas isso é

46511
30:49:57,192 --> 30:49:59,680
Realmente o poder das interfaces que podemos

46512
30:49:59,680 --> 30:50:02,000
projetar nossas características e envolvê-las em um

46513
30:50:02,000 --> 30:50:04,480
interface e podemos realmente anexar isso

46514
30:50:04,480 --> 30:50:06,552
interface para qualquer tipo que temos em nosso c

46515
30:50:06,552 --> 30:50:09,040
mais mais programa e esse tipo está indo

46516
30:50:09,040 --> 30:50:11,512
para herdar automaticamente os recursos

46517
30:50:11,512 --> 30:50:14,080
que nós estabelecemos em nossa interface para

46518
30:50:14,080 --> 30:50:16,400
Exemplo agora que nós anexamos isso

46519
30:50:16,400 --> 30:50:19,280
interface para o nosso ponto aqui podemos imprimir

46520
30:50:19,280 --> 30:50:21,440
nossos pontos no fluxo de saída e isso

46521
30:50:21,440 --> 30:50:23,360
vai funcionar automaticamente você vê

46522
30:50:23,360 --> 30:50:25,512
que não precisamos configurar uma saída

46523
30:50:25,512 --> 30:50:28,320
Operador de fluxo em nossa classe completamente

46524
30:50:28,320 --> 30:50:30,800
Podemos até ir mais longe e anexar isso

46525
30:50:30,800 --> 30:50:33,360
Interface para uma herança completa

46526
30:50:33,360 --> 30:50:35,912
hierarquia, por exemplo, se tivermos o nosso

46527
30:50:35,912 --> 30:50:38,552
classe base para ser animal e nós herdamos

46528
30:50:38,552 --> 30:50:40,552
desta classe para criar todos os tipos de

46529
30:50:40,552 --> 30:50:43,760
classes loucas que podemos continuar e anexar

46530
30:50:43,760 --> 30:50:46,480
nossa interface para a classe base aqui e

46531
30:50:46,480 --> 30:50:49,592
Isto vai fazer todas as nossas aulas em

46532
30:50:49,592 --> 30:50:52,000
Nossa hierarquia de herança tem o

46533
30:50:52,000 --> 30:50:54,480
recursos que a interface trouxe

46534
30:50:54,480 --> 30:50:57,192
para a classe base, por exemplo, podemos

46535
30:50:57,192 --> 30:50:59,760
anexar nossa interface à classe animal

46536
30:50:59,760 --> 30:51:02,480
herdando de fluxo inserível

46537
30:51:02,480 --> 30:51:05,040
Aqui e isso vai dar o nosso

46538
30:51:05,040 --> 30:51:08,400
animal os poderes a serem impressos para

46539
30:51:08,400 --> 30:51:10,872
fluxos de saída e isso vai ser

46540
30:51:10,872 --> 30:51:13,120
alimentados pela função virtual que nós

46541
30:51:13,120 --> 30:51:15,592
estão substituindo aqui você vê

46542
30:51:15,592 --> 30:51:18,480
vamos especificar quais dados

46543
30:51:18,480 --> 30:51:20,640
imprimir em nossa classe animal e como

46544
30:51:20,640 --> 30:51:22,872
Os dados serão impressos aqui e

46545
30:51:22,872 --> 30:51:24,960
Podemos fazer isso neste override e isso

46546
30:51:24,960 --> 30:51:27,040
É super poderoso quando fazemos isso, nós somos

46547
30:51:27,040 --> 30:51:28,960
indo para cada classe em nossa

46548
30:51:28,960 --> 30:51:31,680
Hierarquia de herança e implementar o

46549
30:51:31,680 --> 30:51:33,280
inserção de fluxo

46550
30:51:33,280 --> 30:51:35,592
substituir porque se não fizermos isso

46551
30:51:35,592 --> 30:51:37,192
Esta classe também vai se tornar um

46552
30:51:37,192 --> 30:51:40,000
classe abstrata porque está herdando

46553
30:51:40,000 --> 30:51:42,400
de uma classe que tem um puro virtual

46554
30:51:42,400 --> 30:51:45,280
A função lembre-se se você herdar de um

46555
30:51:45,280 --> 30:51:48,320
classe que tem pelo menos um puro virtual

46556
30:51:48,320 --> 30:51:51,120
função que você será forçado a implementar

46557
30:51:51,120 --> 30:51:54,000
todas as funções virtuais puras que vêm

46558
30:51:54,000 --> 30:51:55,832
da sua classe de pais se você não fizer

46559
30:51:55,832 --> 30:51:58,232
que você vai se tornar um abstrato

46560
30:51:58,232 --> 30:52:00,160
classifique a si mesmo e nós realmente não queremos

46561
30:52:00,160 --> 30:52:02,640
É por isso que estamos substituindo o

46562
30:52:02,640 --> 30:52:05,192
fluxo insert override aqui e com

46563
30:52:05,192 --> 30:52:07,280
Isso vamos especificar quais

46564
30:52:07,280 --> 30:52:09,360
informações para imprimir a partir do nosso objeto

46565
30:52:09,360 --> 30:52:11,592
Aqui e aqui nós vamos colocar para fora

46566
30:52:11,592 --> 30:52:14,080
a descrição e a cor da asa e

46567
30:52:14,080 --> 30:52:16,480
Este é o formato que especificamos aqui e

46568
30:52:16,480 --> 30:52:18,800
Este método será chamado pelo nosso

46569
30:52:18,800 --> 30:52:21,192
operador do fluxo de saída que está vindo

46570
30:52:21,192 --> 30:52:24,232
a partir de nossa interface flutuável

46571
30:52:24,232 --> 30:52:26,232
Espero que você possa ver como isso é super

46572
30:52:26,232 --> 30:52:28,000
poderoso ok agora que você sabe disso

46573
30:52:28,000 --> 30:52:29,360
nós vamos ir para o visual

46574
30:52:29,360 --> 30:52:31,120
código de estúdio e jogar com a gente um pouco

46575
30:52:31,120 --> 30:52:34,080
Mais aqui estamos em nossa pasta de trabalho

46576
30:52:34,080 --> 30:52:36,960
O projeto atual são classes abstratas

46577
30:52:36,960 --> 30:52:39,832
como interfaces, vamos pegar o nosso

46578
30:52:39,832 --> 30:52:42,960
template files e colocar os dados no lugar

46579
30:52:42,960 --> 30:52:45,040
E eu vou copiar isso e colocar aquilo

46580
30:52:45,040 --> 30:52:46,232
dentro aqui

46581
30:52:46,232 --> 30:52:48,160
vamos colocar os arquivos que estamos

46582
30:52:48,160 --> 30:52:50,480
Vou usar em nossa herança

46583
30:52:50,480 --> 30:52:52,960
Hierarquia, você vê que temos nosso animal

46584
30:52:52,960 --> 30:52:55,512
hierarquia aqui você pode pegar esses arquivos

46585
30:52:55,512 --> 30:52:58,160
da seção de recursos deste

46586
30:52:58,160 --> 30:53:00,080
palestra e você pode reutilizá-los como nós

46587
30:53:00,080 --> 30:53:02,480
estão usando aqui ou se você quer que você possa

46588
30:53:02,480 --> 30:53:04,160
Até digite isso, mas eu realmente não

46589
30:53:04,160 --> 30:53:05,912
Recomendo isso porque isso é demais

46590
30:53:05,912 --> 30:53:07,912
digitando só queremos aprender sobre

46591
30:53:07,912 --> 30:53:10,080
Interfaces aqui e é isso que você

46592
30:53:10,080 --> 30:53:11,832
Devemos nos concentrar para que vamos abrir

46593
30:53:11,832 --> 30:53:14,320
isso em vídeos de código de vídeo e isso é

46594
30:53:14,320 --> 30:53:16,552
vamos nos dar todos os arquivos que precisamos

46595
30:53:16,552 --> 30:53:18,960
nós vamos olhar para a classe superior e

46596
30:53:18,960 --> 30:53:21,192
veremos que ele está herdando de

46597
30:53:21,192 --> 30:53:24,400
nossa interface inserível do fluxo, então vamos

46598
30:53:24,400 --> 30:53:27,120
olhar para a nossa interface insertable stream

46599
30:53:27,120 --> 30:53:29,040
Porque este é o foco disso

46600
30:53:29,040 --> 30:53:32,080
palestra aqui, então é uma classe regular como

46601
30:53:32,080 --> 30:53:33,832
você vê aqui que é fluxo de classe

46602
30:53:33,832 --> 30:53:35,680
Insertável vamos configurar um

46603
30:53:35,680 --> 30:53:38,400
operador do fluxo de saída e é realmente

46604
30:53:38,400 --> 30:53:40,720
como qualquer outro operador de fluxo de saída

46605
30:53:40,720 --> 30:53:42,080
Você viu que nós vamos passar o

46606
30:53:42,080 --> 30:53:44,640
Segunda ópera por referência

46607
30:53:44,640 --> 30:53:47,280
e vamos especificar o nosso puro

46608
30:53:47,280 --> 30:53:49,512
Função virtual que vai ser

46609
30:53:49,512 --> 30:53:52,000
implementado pela herdação a jusante

46610
30:53:52,000 --> 30:53:54,800
aulas desta classe aqui e isso é

46611
30:53:54,800 --> 30:53:57,440
Vou estabelecer o polimorfismo e o que

46612
30:53:57,440 --> 30:53:58,872
Isso vai fazer

46613
30:53:58,872 --> 30:54:02,000
é se chamarmos este método em nosso segundo

46614
30:54:02,000 --> 30:54:04,400
operando aqui, vamos chamar isso

46615
30:54:04,400 --> 30:54:06,800
método polimorfia se você é

46616
30:54:06,800 --> 30:54:08,480
Tentando imprimir um ponto que vamos

46617
30:54:08,480 --> 30:54:10,552
chamar este método em um objeto de ponto e

46618
30:54:10,552 --> 30:54:12,960
Vamos imprimi-lo exatamente como

46619
30:54:12,960 --> 30:54:15,360
O ponto quer ser impresso se nós somos

46620
30:54:15,360 --> 30:54:17,680
Imprimindo um círculo que chamaremos disso

46621
30:54:17,680 --> 30:54:20,080
método de inserção de fluxo no círculo e

46622
30:54:20,080 --> 30:54:22,720
Vamos imprimir um círculo exatamente como

46623
30:54:22,720 --> 30:54:25,360
O círculo quer ser impresso para fora, vamos

46624
30:54:25,360 --> 30:54:27,760
Olhe para a implementação e é

46625
30:54:27,760 --> 30:54:29,680
Nada realmente complicado estamos indo

46626
30:54:29,680 --> 30:54:32,480
para especificar nosso objeto de fluxo de saída como

46627
30:54:32,480 --> 30:54:34,872
O primeiro parâmetro aqui e a segunda

46628
30:54:34,872 --> 30:54:37,040
O parâmetro é o que queremos imprimir

46629
30:54:37,040 --> 30:54:39,192
passaremos isso por referência e isso

46630
30:54:39,192 --> 30:54:41,760
vai nos permitir fazer polimorfismo

46631
30:54:41,760 --> 30:54:43,592
Lembre-se que o fluxo inserível é

46632
30:54:43,592 --> 30:54:45,760
Realmente vai se tornar nossa base superior

46633
30:54:45,760 --> 30:54:48,872
classe, então estaremos basicamente configurando

46634
30:54:48,872 --> 30:54:51,592
Polimorfismo inserível aqui você

46635
30:54:51,592 --> 30:54:53,512
Precisamos manter isso em mente que estamos indo

46636
30:54:53,512 --> 30:54:56,552
para chamar nosso método de inserção de fluxo em nosso

46637
30:54:56,552 --> 30:54:58,160
operando e nós vamos passar o

46638
30:54:58,160 --> 30:55:00,480
saída do fluxo que queremos imprimir em e

46639
30:55:00,480 --> 30:55:02,960
Vamos devolver este fluxo de saída

46640
30:55:02,960 --> 30:55:05,512
para realmente fazer isso se comportar

46641
30:55:05,512 --> 30:55:08,552
como um operador de fluxo de saída regular para

46642
30:55:08,552 --> 30:55:11,512
permitir a cadeia de saída em nosso operador

46643
30:55:11,512 --> 30:55:14,232
aqui uma vez que temos este fluxo inserível

46644
30:55:14,232 --> 30:55:16,400
Interface podemos realmente usá-lo no entanto

46645
30:55:16,400 --> 30:55:19,280
nós queremos vamos para o cpp principal

46646
30:55:19,280 --> 30:55:22,080
arquivar e tentar jogar conosco para que nós

46647
30:55:22,080 --> 30:55:25,120
vai fazer é quebrar isso aberto e

46648
30:55:25,120 --> 30:55:27,280
Nós vamos remover o que quer que seja

46649
30:55:27,280 --> 30:55:30,640
Não precisamos que vamos incluir o nosso

46650
30:55:30,640 --> 30:55:32,640
Interface para que vamos incluir

46651
30:55:32,640 --> 30:55:35,232
fluxo inserível vamos fazer isso

46652
30:55:35,232 --> 30:55:37,760
Insertable.h Eu acho que este é o nome

46653
30:55:37,760 --> 30:55:39,592
e nós vamos montar uma classe de pontos

46654
30:55:39,592 --> 30:55:42,400
que queremos ser impressos no

46655
30:55:42,400 --> 30:55:44,720
aviso de fluxo de saída que queremos

46656
30:55:44,720 --> 30:55:47,360
herdar do fluxo inserível e o que

46657
30:55:47,360 --> 30:55:50,000
Isso está realmente fazendo é anexar o

46658
30:55:50,000 --> 30:55:52,872
Interface para a classe point aqui e

46659
30:55:52,872 --> 30:55:55,592
Porque este fluxo é inserível

46660
30:55:55,592 --> 30:55:58,552
A interface tem uma função virtual pura

46661
30:55:58,552 --> 30:56:00,000
Precisamos de

46662
30:56:00,000 --> 30:56:02,872
substituir esta função virtual pura aqui

46663
30:56:02,872 --> 30:56:04,800
Se não queremos ser capazes de criar

46664
30:56:04,800 --> 30:56:07,040
Objetos do nosso ponto aqui vamos descer

46665
30:56:07,040 --> 30:56:08,480
e mostrar a você que nós vamos conseguir

46666
30:56:08,480 --> 30:56:11,040
Nesse problema se não fizermos isso, estamos

46667
30:56:11,040 --> 30:56:12,800
Vou dizer ponto

46668
30:56:12,800 --> 30:56:15,832
e dizer p1 e, por exemplo, colocar em 10 e

46669
30:56:15,832 --> 30:56:16,872
20

46670
30:56:16,872 --> 30:56:19,192
teremos um erro de compilador porque

46671
30:56:19,192 --> 30:56:22,080
Agora a classe point é uma classe abstrata

46672
30:56:22,080 --> 30:56:24,720
porque é herdado de uma classe

46673
30:56:24,720 --> 30:56:27,280
que tem uma função virtual pura e

46674
30:56:27,280 --> 30:56:29,680
Não está substituindo esse puro virtual

46675
30:56:29,680 --> 30:56:30,640
A função

46676
30:56:30,640 --> 30:56:34,512
Então, em outras palavras, esta classe ainda tem um

46677
30:56:34,512 --> 30:56:37,192
Função virtual pura não implementada

46678
30:56:37,192 --> 30:56:38,800
É por isso que é

46679
30:56:38,800 --> 30:56:41,120
uma classe abstrata e não podemos criar um

46680
30:56:41,120 --> 30:56:43,440
Objeto disso se estamos tentando executar isso

46681
30:56:43,440 --> 30:56:45,192
Código que vamos passar por isso

46682
30:56:45,192 --> 30:56:48,320
gcc vamos ter um compilador ok que temos

46683
30:56:48,320 --> 30:56:50,232
um erro de compilador aqui e precisamos corrigir

46684
30:56:50,232 --> 30:56:52,960
Tudo o que precisamos fazer é implementar

46685
30:56:52,960 --> 30:56:55,832
A interface que vem do nosso stream

46686
30:56:55,832 --> 30:56:58,552
interface insertable aqui para que possamos agarrar

46687
30:56:58,552 --> 30:57:01,512
nossa função virtual pura e implementar

46688
30:57:01,512 --> 30:57:05,280
ele em nosso arquivo principal cpp para o ponto

46689
30:57:05,280 --> 30:57:07,440
classe, vamos colocá-lo aqui e

46690
30:57:07,440 --> 30:57:10,640
nós removeremos a função virtual pura

46691
30:57:10,640 --> 30:57:12,552
especificador aqui e vamos colocar em um

46692
30:57:12,552 --> 30:57:15,040
Implementação queremos especificar que

46693
30:57:15,040 --> 30:57:17,280
Esta é uma substituição de um método que é

46694
30:57:17,280 --> 30:57:21,360
vindo da nossa classe de pais upstream

46695
30:57:21,360 --> 30:57:23,040
e vamos nos dirigir no

46696
30:57:23,040 --> 30:57:25,680
corpo da nossa função e colocar no

46697
30:57:25,680 --> 30:57:27,760
Informações que queremos colocar para fora

46698
30:57:27,760 --> 30:57:29,912
Este é um objeto ponto, então nós só queremos

46699
30:57:29,912 --> 30:57:33,592
para imprimir o m x coordenada e o m y

46700
30:57:33,592 --> 30:57:36,080
coordenar aqui e este é o formato

46701
30:57:36,080 --> 30:57:39,592
que queremos e neste momento o trabalho

46702
30:57:39,592 --> 30:57:41,680
Dessa função é realmente feita

46703
30:57:41,680 --> 30:57:44,720
e será captado polimorfiamente

46704
30:57:44,720 --> 30:57:46,800
Se alguém tenta chamar isso em um

46705
30:57:46,800 --> 30:57:49,360
objeto de ponto através do polimorfismo e

46706
30:57:49,360 --> 30:57:50,960
Isso vai funcionar agora que temos

46707
30:57:50,960 --> 30:57:53,192
Este ponto podemos tentar construir e fazer

46708
30:57:53,192 --> 30:57:55,512
Certamente isso está funcionando, vamos ter certeza de que nós

46709
30:57:55,512 --> 30:57:57,760
Não tem mais o erro do compilador

46710
30:57:57,760 --> 30:57:59,912
O mundo terminou com sucesso, então nós

46711
30:57:59,912 --> 30:58:02,400
São legais aqui, mas o que queremos ver é

46712
30:58:02,400 --> 30:58:04,400
Que nós somos capazes de imprimir

46713
30:58:04,400 --> 30:58:06,320
pontos de objetos porque isso é o todo

46714
30:58:06,320 --> 30:58:09,592
ponto de anexar esta interface ao nosso

46715
30:58:09,592 --> 30:58:11,680
classe de pontos aqui, então o que vamos

46716
30:58:11,680 --> 30:58:13,280
O faz é imprimir isso, vamos dizer

46717
30:58:13,280 --> 30:58:15,832
esddc para fora nós vamos dizer p1 e nós somos

46718
30:58:15,832 --> 30:58:18,552
Vamos dizer: 1 aqui é assim que nós

46719
30:58:18,552 --> 30:58:21,040
usaria nosso operador de fluxo de saída você

46720
30:58:21,040 --> 30:58:22,800
Veja que não temos um erro de compilador neste

46721
30:58:22,800 --> 30:58:25,040
É realmente mágico que alguns de vocês vão

46722
30:58:25,040 --> 30:58:27,280
Pergunte como isso é trabalhar alguém

46723
30:58:27,280 --> 30:58:28,720
Vou olhar para a sua classe que eles são

46724
30:58:28,720 --> 30:58:30,400
Vou olhar que você não tem uma saída

46725
30:58:30,400 --> 30:58:32,720
operador de fluxo, mas você pode imprimir o seu

46726
30:58:32,720 --> 30:58:35,512
objetos, então como isso está funcionando bem, isso

46727
30:58:35,512 --> 30:58:37,280
está trabalhando através da magia de

46728
30:58:37,280 --> 30:58:40,000
interfaces que estamos anexando isso

46729
30:58:40,000 --> 30:58:43,120
interface para nossa classe de pontos e isso é

46730
30:58:43,120 --> 30:58:45,512
Vamos dar à nossa classe os poderes que

46731
30:58:45,512 --> 30:58:47,592
vem dessa interface e de um dos

46732
30:58:47,592 --> 30:58:50,232
esses poderes são para usar o fluxo de saída

46733
30:58:50,232 --> 30:58:52,552
Operador que obtemos a partir desta interface

46734
30:58:52,552 --> 30:58:54,872
pode usar isso diretamente e o que isso é

46735
30:58:54,872 --> 30:58:56,160
Vou fazer, vamos olhar para o

46736
30:58:56,160 --> 30:58:58,552
implementação desta interface é

46737
30:58:58,552 --> 30:59:01,512
indo apenas chamar o fluxo de inserção

46738
30:59:01,512 --> 30:59:04,480
método virtual sobre o objeto que nós

46739
30:59:04,480 --> 30:59:07,040
passar como um segundo parâmetro neste

46740
30:59:07,040 --> 30:59:09,512
operador aqui e o segundo parâmetro

46741
30:59:09,512 --> 30:59:11,360
Acontece que é o ponto em que somos

46742
30:59:11,360 --> 30:59:13,912
imprimir aqui o que é realmente

46743
30:59:13,912 --> 30:59:15,192
Vou fazer isso

46744
30:59:15,192 --> 30:59:17,360
É algo assim que nós vamos

46745
30:59:17,360 --> 30:59:19,680
Tente descobrir o que é o compilador

46746
30:59:19,680 --> 30:59:22,720
Vou tentar e fazer nós vamos dizer

46747
30:59:22,720 --> 30:59:25,280
p1 e vamos dizer operador

46748
30:59:25,280 --> 30:59:27,440
fluxo de saída e vamos dizer

46749
30:59:27,440 --> 30:59:30,232
stdc out que é o fluxo que queremos ser

46750
30:59:30,232 --> 30:59:32,080
impressão para

46751
30:59:32,080 --> 30:59:34,552
e o ponto que queremos imprimir é p1

46752
30:59:34,552 --> 30:59:36,232
Isto é basicamente o que é o compilador

46753
30:59:36,232 --> 30:59:38,640
indo fazer e vai imprimir o nosso

46754
30:59:38,640 --> 30:59:41,040
polegar e este método está disponível em

46755
30:59:41,040 --> 30:59:43,680
nosso fluxo de cabeçalho inserível e é um

46756
30:59:43,680 --> 30:59:46,720
amigo da nossa interface, é por isso que nós

46757
30:59:46,720 --> 30:59:49,040
são capazes de fazer algo assim

46758
30:59:49,040 --> 30:59:51,360
acessar os dados da nossa interface

46759
30:59:51,360 --> 30:59:52,872
Vamos construir e realmente mostrar que

46760
30:59:52,872 --> 30:59:54,232
Isso vai funcionar que nós vamos

46761
30:59:54,232 --> 30:59:57,120
passar isso através do nosso compilador gcc

46762
30:59:57,120 --> 30:59:58,800
A construção vai ser boa para que possamos

46763
30:59:58,800 --> 31:00:01,360
claro não claro, vamos controlar z

46764
31:00:01,360 --> 31:00:03,280
sobre isso e nós vamos trazer um

46765
31:00:03,280 --> 31:00:05,440
janela powershell e nós vamos

46766
31:00:05,440 --> 31:00:07,440
limpar desta vez e correr galo que você vê

46767
31:00:07,440 --> 31:00:09,040
que estamos criando nosso ponto aqui e

46768
31:00:09,040 --> 31:00:10,872
Isso é muito legal, podemos até

46769
31:00:10,872 --> 31:00:13,360
descomer isso e vamos usar

46770
31:00:13,360 --> 31:00:15,760
O sddc out porque o compilador está indo

46771
31:00:15,760 --> 31:00:18,232
para tomar isso e transformar isso em isso e

46772
31:00:18,232 --> 31:00:21,360
nós temos a capacidade de ter um código que é

46773
31:00:21,360 --> 31:00:23,440
muito mais legível por c plus mais

46774
31:00:23,440 --> 31:00:25,592
Desenvolvedores lá fora nós vamos

46775
31:00:25,592 --> 31:00:27,760
construir e executar isso novamente a construção é

46776
31:00:27,760 --> 31:00:30,160
Vou ser bom, podemos limpar e correr

46777
31:00:30,160 --> 31:00:32,160
galo e isso vai imprimir o nosso

46778
31:00:32,160 --> 31:00:34,872
ponto aqui isso é muito legal, mas isso

46779
31:00:34,872 --> 31:00:37,192
não é o fim da nossa loja nós podemos mesmo

46780
31:00:37,192 --> 31:00:40,552
Imprimir uma hierarquia de herança inteira

46781
31:00:40,552 --> 31:00:43,760
Veja o que fizemos na nossa classe animal

46782
31:00:43,760 --> 31:00:47,040
Aqui anexamos esta interface ao nosso

46783
31:00:47,040 --> 31:00:49,760
classe animal e o momento em que fazemos isso

46784
31:00:49,760 --> 31:00:52,640
Precisamos substituir o virtual puro

46785
31:00:52,640 --> 31:00:53,592
A função

46786
31:00:53,592 --> 31:00:55,592
que vem com esta interface e

46787
31:00:55,592 --> 31:00:57,912
Isso é o que nós fizemos aqui em baixo nós temos

46788
31:00:57,912 --> 31:01:00,552
sobrescrever a inserção do fluxo

46789
31:01:00,552 --> 31:01:02,000
a função virtual

46790
31:01:02,000 --> 31:01:04,232
E no corpo vamos especificar

46791
31:01:04,232 --> 31:01:06,400
quais dados queremos imprimir e como

46792
31:01:06,400 --> 31:01:08,800
imprimir esses dados que é o ponto principal

46793
31:01:08,800 --> 31:01:11,360
desta substituição que estamos fazendo aqui nós

46794
31:01:11,360 --> 31:01:14,160
Vai fazer a mesma coisa em cada

46795
31:01:14,160 --> 31:01:16,480
classe de herança do animal para

46796
31:01:16,480 --> 31:01:18,400
exemplo, se formos ao felino, vamos

46797
31:01:18,400 --> 31:01:20,720
Para fazer exatamente a mesma coisa que somos

46798
31:01:20,720 --> 31:01:23,280
indo herdar do animal e isso

46799
31:01:23,280 --> 31:01:25,512
Será indiretamente herdaremos de nossa

46800
31:01:25,512 --> 31:01:26,872
interface assim

46801
31:01:26,872 --> 31:01:28,872
Precisamos nos substituir

46802
31:01:28,872 --> 31:01:31,040
A função virtual pura que vem

46803
31:01:31,040 --> 31:01:33,360
com essa interface e fazemos isso aqui

46804
31:01:33,360 --> 31:01:35,192
vamos especificar quais dados nós

46805
31:01:35,192 --> 31:01:36,552
Quero imprimir neste caso, vamos

46806
31:01:36,552 --> 31:01:39,280
para colocar a descrição e a primeira

46807
31:01:39,280 --> 31:01:42,232
estilo e vamos especificar o

46808
31:01:42,232 --> 31:01:44,232
formato em que queremos que os dados sejam

46809
31:01:44,232 --> 31:01:46,320
impresso novamente, esse é o ponto

46810
31:01:46,320 --> 31:01:49,440
de substituir esta função virtual aqui

46811
31:01:49,440 --> 31:01:51,360
Vamos fazer a mesma coisa em cada um

46812
31:01:51,360 --> 31:01:53,512
Classe de herança em nossa herança

46813
31:01:53,512 --> 31:01:55,832
hierarquia, por exemplo, fizemos o exato

46814
31:01:55,832 --> 31:01:57,592
A mesma coisa para doug

46815
31:01:57,592 --> 31:02:00,400
Fizemos exatamente a mesma coisa para um gato

46816
31:02:00,400 --> 31:02:02,400
E nós vamos fazer a mesma coisa em

46817
31:02:02,400 --> 31:02:05,440
nossas aulas de pássaros são exatamente o que nós

46818
31:02:05,440 --> 31:02:08,552
aqui especifica quais dados devem ser impressos

46819
31:02:08,552 --> 31:02:10,400
e como os dados serão impressos

46820
31:02:10,400 --> 31:02:13,912
para fora e esta substituição de inserção de fluxo é

46821
31:02:13,912 --> 31:02:16,640
vai ser pego pela nossa interface

46822
31:02:16,640 --> 31:02:19,912
quando nós começamos a chamar o fluxo de saída

46823
31:02:19,912 --> 31:02:22,160
O operador aqui percebe que estamos chamando

46824
31:02:22,160 --> 31:02:24,640
Esta coisa polimorfia somos

46825
31:02:24,640 --> 31:02:27,192
chamando o nosso fluxo de inserção

46826
31:02:27,192 --> 31:02:30,400
método em uma referência que passamos aqui

46827
31:02:30,400 --> 31:02:32,552
e isso vai resolver este uso

46828
31:02:32,552 --> 31:02:34,960
Ligação dinâmica que vai funcionar

46829
31:02:34,960 --> 31:02:37,280
muito bem agora que temos essa configuração

46830
31:02:37,280 --> 31:02:39,592
podemos ir até o arquivo principal do cpp

46831
31:02:39,592 --> 31:02:42,080
E realmente fazer todos os tipos de coisas loucas

46832
31:02:42,080 --> 31:02:44,800
Vamos colocar um separador aqui e nós estamos

46833
31:02:44,800 --> 31:02:46,000
Indo para dentro de nós.

46834
31:02:46,000 --> 31:02:49,120
brincando conosco, vamos incluir o

46835
31:02:49,120 --> 31:02:52,232
Classes que precisamos montar nossos animais

46836
31:02:52,232 --> 31:02:54,160
e nós vamos colocá-los aqui nós

46837
31:02:54,160 --> 31:02:56,800
ter animal felino cão gato pássaro pombo

46838
31:02:56,800 --> 31:02:59,192
e corria no momento em que fazemos isso, nós não fazemos

46839
31:02:59,192 --> 31:03:01,120
precisa colocar neste fluxo inserível

46840
31:03:01,120 --> 31:03:02,872
porque está entrando diretamente de

46841
31:03:02,872 --> 31:03:04,720
Isso mas não precisamos nos preocupar com

46842
31:03:04,720 --> 31:03:07,280
porque temos guardas em

46843
31:03:07,280 --> 31:03:09,592
Mas vamos usar inteligente

46844
31:03:09,592 --> 31:03:12,080
dicas, então vamos incluir a memória

46845
31:03:12,080 --> 31:03:14,960
cabeçalho e podemos montar um animal e

46846
31:03:14,960 --> 31:03:16,800
Tente imprimi-lo, estaremos usando

46847
31:03:16,800 --> 31:03:18,960
Polimorfismo para que possamos passar por um

46848
31:03:18,960 --> 31:03:22,080
ponto de referência para animal e usar isso para

46849
31:03:22,080 --> 31:03:24,320
gerenciar um objeto de cão aqui estamos apenas

46850
31:03:24,320 --> 31:03:26,720
vamos passar nos dados e nós vamos

46851
31:03:26,720 --> 31:03:29,680
Tente imprimir este animal observe que

46852
31:03:29,680 --> 31:03:31,912
Estamos passando por um ponteiro base

46853
31:03:31,912 --> 31:03:34,080
chamando o operador do fluxo de saída assim

46854
31:03:34,080 --> 31:03:35,912
Isto vai resolver

46855
31:03:35,912 --> 31:03:37,760
a chamada para transmitir inserção

46856
31:03:37,760 --> 31:03:40,160
polimorfos e vai imprimir

46857
31:03:40,160 --> 31:03:42,872
esta informação ao nível do cão e

46858
31:03:42,872 --> 31:03:45,512
O que quero dizer com isso é que se entrarmos

46859
31:03:45,512 --> 31:03:47,440
cão, vamos encontrar nosso córrego

46860
31:03:47,440 --> 31:03:49,360
Insiro que vai imprimir isso

46861
31:03:49,360 --> 31:03:50,800
Informações aqui

46862
31:03:50,800 --> 31:03:52,872
Como nós queremos imprimir um cachorro e isso é

46863
31:03:52,872 --> 31:03:55,592
super poderoso espero que você possa ver como

46864
31:03:55,592 --> 31:03:57,512
legal isso é que vamos tentar e

46865
31:03:57,512 --> 31:03:59,192
construir este programa vamos passar

46866
31:03:59,192 --> 31:04:01,440
isso através do gcc o barco vai ser

46867
31:04:01,440 --> 31:04:03,912
Bom podemos limpar e correr galo, estamos

46868
31:04:03,912 --> 31:04:06,552
Vou ver que nós imprimimos isso como um cachorro

46869
31:04:06,552 --> 31:04:08,960
mesmo se usuávamos um ponteiro base para tentar

46870
31:04:08,960 --> 31:04:11,512
e imprima isso o quão legal é isso nós

46871
31:04:11,512 --> 31:04:14,400
pode até usar isso para montar um pássaro e

46872
31:04:14,400 --> 31:04:16,000
imprimi-lo, vamos montar um

46873
31:04:16,000 --> 31:04:18,000
ponteiro base que vai ser

46874
31:04:18,000 --> 31:04:20,232
Gerenciando um pássaro, você pode ver que nós somos

46875
31:04:20,232 --> 31:04:21,832
usando um ponteiro único aqui você pode

46876
31:04:21,832 --> 31:04:23,832
realmente usar qualquer tipo de ponteiro inteligente você

46877
31:04:23,832 --> 31:04:25,512
Queremos que vamos imprimir isso e

46878
31:04:25,512 --> 31:04:28,160
Isso será impresso como um pássaro

46879
31:04:28,160 --> 31:04:30,160
quer ser impresso e isso está indo

46880
31:04:30,160 --> 31:04:31,680
para estar usando

46881
31:04:31,680 --> 31:04:34,640
A substituição da nossa classe de aves e

46882
31:04:34,640 --> 31:04:36,400
que vai dizer que o pássaro vai colocar

46883
31:04:36,400 --> 31:04:38,160
fora a descrição que vai colocar

46884
31:04:38,160 --> 31:04:39,592
fora a cor da asa e isso é realmente

46885
31:04:39,592 --> 31:04:42,080
indo para trabalhar muito bem nós vamos

46886
31:04:42,080 --> 31:04:44,552
passar isso através de gcc novamente o mundo é

46887
31:04:44,552 --> 31:04:46,640
Vou ser bom, podemos limpar e correr

46888
31:04:46,640 --> 31:04:48,480
Galo você vê que estamos imprimindo

46889
31:04:48,480 --> 31:04:51,760
pássaro aqui e isso está usando polimorfismo

46890
31:04:51,760 --> 31:04:54,960
combinado com interfaces e isso pode

46891
31:04:54,960 --> 31:04:57,512
Venha à mão se isso ajudar você

46892
31:04:57,512 --> 31:04:59,760
Aplicação dependendo do que você quer

46893
31:04:59,760 --> 31:05:02,000
para conseguir com zipclose plus nós podemos

46894
31:05:02,000 --> 31:05:05,040
até mesmo colocar nossos dados animais em uma matriz e

46895
31:05:05,040 --> 31:05:07,440
Tente imprimir isso para que vamos

46896
31:05:07,440 --> 31:05:10,000
colocar para fora um separador para ser capaz de seguir

46897
31:05:10,000 --> 31:05:13,760
Isto muito bem em nosso terminal de saída este

46898
31:05:13,760 --> 31:05:15,912
Vai fazer e nós vamos embora

46899
31:05:15,912 --> 31:05:17,832
para baixo e colocar no código para jogar com a gente

46900
31:05:17,832 --> 31:05:20,080
Vamos compartilhar uma variedade de compartilhados

46901
31:05:20,080 --> 31:05:22,232
apontadores é assim que fazemos isso e

46902
31:05:22,232 --> 31:05:24,080
Vamos inicializar isso com tudo

46903
31:05:24,080 --> 31:05:26,232
Tipos de animais loucos que vamos

46904
31:05:26,232 --> 31:05:28,080
colocar em um cão que vamos colocar em um gato

46905
31:05:28,080 --> 31:05:29,512
nós vamos colocar em um corvo e um

46906
31:05:29,512 --> 31:05:32,480
pombo e vamos conseguir isso

46907
31:05:32,480 --> 31:05:34,480
através de ponteiros de base notar que este

46908
31:05:34,480 --> 31:05:37,040
é uma matriz de ponteiros de base

46909
31:05:37,040 --> 31:05:39,512
e nós vamos chamar a saída

46910
31:05:39,512 --> 31:05:42,232
operador do fluxo polimorfia para

46911
31:05:42,232 --> 31:05:44,160
O primeiro elemento aqui vamos imprimir um

46912
31:05:44,160 --> 31:05:47,040
Cão como um cão quer ser impresso assim

46913
31:05:47,040 --> 31:05:49,680
nós estaremos usando o fluxo de inserção

46914
31:05:49,680 --> 31:05:51,832
substituir a classe do cão se formos

46915
31:05:51,832 --> 31:05:53,040
Aí vamos ver que estamos

46916
31:05:53,040 --> 31:05:56,000
Vou prefixar nossos dados com o cão se nós

46917
31:05:56,000 --> 31:05:57,592
Atingir o segundo elemento que nós vamos

46918
31:05:57,592 --> 31:05:59,912
imprimir isso como um gato quer ser

46919
31:05:59,912 --> 31:06:01,832
impresso para baixo o terceiro elemento está indo

46920
31:06:01,832 --> 31:06:04,320
para ser impresso como um corvo o quarto

46921
31:06:04,320 --> 31:06:06,080
O elemento será impresso como um

46922
31:06:06,080 --> 31:06:08,080
pombo e isso vai cair e

46923
31:06:08,080 --> 31:06:08,872
trabalho

46924
31:06:08,872 --> 31:06:11,192
Aqui em baixo você vê que estamos

46925
31:06:11,192 --> 31:06:13,360
looping chamando nosso fluxo de saída

46926
31:06:13,360 --> 31:06:14,800
Operador e isso vai funcionar

46927
31:06:14,800 --> 31:06:17,120
muito bem, vamos tentar construir isso

46928
31:06:17,120 --> 31:06:18,800
programa, vamos passar por isso

46929
31:06:18,800 --> 31:06:21,280
gcc a construção vai ser bom, então nós

46930
31:06:21,280 --> 31:06:23,760
pode limpar e correr galo e você está

46931
31:06:23,760 --> 31:06:25,760
Vamos ver que estamos imprimindo o nosso

46932
31:06:25,760 --> 31:06:27,440
A informação aqui a primeira coisa é

46933
31:06:27,440 --> 31:06:30,000
cão, a segunda coisa é um gato o terceiro

46934
31:06:30,000 --> 31:06:32,232
A coisa é uma equipe que o quarto fã é um

46935
31:06:32,232 --> 31:06:34,720
pombo e isso está funcionando muito bem

46936
31:06:34,720 --> 31:06:37,440
Espero que você possa ver como as interfaces podem

46937
31:06:37,440 --> 31:06:40,400
ser poderoso em seu design c plus plus

46938
31:06:40,400 --> 31:06:42,552
Use isso se fizer sentido para qualquer coisa

46939
31:06:42,552 --> 31:06:44,232
Aplicação que você está projetando com z

46940
31:06:44,232 --> 31:06:46,800
mais mais o meu principal objetivo aqui é

46941
31:06:46,800 --> 31:06:50,232
Apresentá-lo à ideia de interfaces

46942
31:06:50,232 --> 31:06:52,640
e quão poderosos eles podem ser novamente um

46943
31:06:52,640 --> 31:06:54,480
Interface é algo que você pode anexar

46944
31:06:54,480 --> 31:06:56,400
seu tipo em c plus plus

46945
31:06:56,400 --> 31:06:58,160
e no momento em que você anexar que

46946
31:06:58,160 --> 31:07:00,400
interface para o seu tipo que seu tipo é

46947
31:07:00,400 --> 31:07:02,480
ter os poderes que vêm com

46948
31:07:02,480 --> 31:07:05,360
essa interface e tudo o que você precisa fazer

46949
31:07:05,360 --> 31:07:08,160
suas aulas derivais é implementar

46950
31:07:08,160 --> 31:07:10,160
As funções virtuais que vêm com

46951
31:07:10,160 --> 31:07:12,800
essa interface e a interface

46952
31:07:12,800 --> 31:07:14,800
pegá-los e usá-los para fazer qualquer coisa

46953
31:07:14,800 --> 31:07:16,480
É que você quer fazer

46954
31:07:16,480 --> 31:07:18,720
Polimorfiamente e isso vai ser

46955
31:07:18,720 --> 31:07:21,120
É muito legal que vamos parar por aqui

46956
31:07:21,120 --> 31:07:23,360
Esta palestra este vamos tentar

46957
31:07:23,360 --> 31:07:26,320
e recapitular o que vimos neste capítulo

46958
31:07:26,320 --> 31:07:28,640
Vá em frente e termine aqui e me encontre

46959
31:07:28,640 --> 31:07:31,120
lá


