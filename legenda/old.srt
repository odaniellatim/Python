1
00:00:00,160 --> 00:00:03,040
this complete c plus plus course will

2
00:00:03,040 --> 00:00:08,160
take you from being an absolute beginner

3
00:00:08,160 --> 00:00:08,160
to using advanced c plus plus features

4
00:00:08,160 --> 00:00:10,480
danielle gaguaya teaches this course he

5
00:00:10,480 --> 00:00:12,719
is an experienced software developer and

6
00:00:12,719 --> 00:00:15,440
has created many popular courses

7
00:00:15,440 --> 00:00:18,400
hello guys and welcome to this modern c

8
00:00:18,400 --> 00:00:20,880
plus plus 20 course this is a course

9
00:00:20,880 --> 00:00:22,560
that is going to take you from the

10
00:00:22,560 --> 00:00:24,400
absolute beginning where you know

11
00:00:24,400 --> 00:00:26,080
nothing about c plus plus and you're

12
00:00:26,080 --> 00:00:28,800
going to go all the way to a point where

13
00:00:28,800 --> 00:00:30,880
you can use some advanced features in

14
00:00:30,880 --> 00:00:33,200
the c plus plus programming language

15
00:00:33,200 --> 00:00:34,600
that includes things like

16
00:00:34,600 --> 00:00:36,559
object-oriented programming with

17
00:00:36,559 --> 00:00:38,960
inheritance and polymorphism with the c

18
00:00:38,960 --> 00:00:41,200
plus plus programming language now i'm

19
00:00:41,200 --> 00:00:42,960
not going to spend a lot of time

20
00:00:42,960 --> 00:00:45,360
convincing you on why you should use c

21
00:00:45,360 --> 00:00:47,840
plus plus but c plus plus is a very

22
00:00:47,840 --> 00:00:49,920
powerful programming language you can

23
00:00:49,920 --> 00:00:52,960
use to do all kinds of crazy things you

24
00:00:52,960 --> 00:00:55,039
can use it to do systems programming you

25
00:00:55,039 --> 00:00:57,360
can build games with it and it is used

26
00:00:57,360 --> 00:01:00,079
in a wide range of areas so you can do a

27
00:01:00,079 --> 00:01:03,039
lot with c plus plus now who is this

28
00:01:03,039 --> 00:01:05,439
course for this course is built for

29
00:01:05,439 --> 00:01:07,680
complete beginners if you already have

30
00:01:07,680 --> 00:01:09,600
some experience with c plus plus you

31
00:01:09,600 --> 00:01:11,840
will still find some good things you can

32
00:01:11,840 --> 00:01:14,479
learn from the course but i am going to

33
00:01:14,479 --> 00:01:16,720
go from the absolute beginning showing

34
00:01:16,720 --> 00:01:19,119
you every little thing showing you the

35
00:01:19,119 --> 00:01:21,439
tools showing you the compilers and the

36
00:01:21,439 --> 00:01:23,439
editor we're going to be using here so

37
00:01:23,439 --> 00:01:25,280
we're going to spend a lot of time

38
00:01:25,280 --> 00:01:26,560
making sure you understand the

39
00:01:26,560 --> 00:01:28,720
fundamentals by the time you are done

40
00:01:28,720 --> 00:01:30,640
with this course you will understand the

41
00:01:30,640 --> 00:01:33,840
bare fundamentals about c plus we will

42
00:01:33,840 --> 00:01:36,159
spend a lot of time exploring the

43
00:01:36,159 --> 00:01:38,479
procedure programming side of c plus

44
00:01:38,479 --> 00:01:40,079
plus so you're going to be writing

45
00:01:40,079 --> 00:01:42,720
programs that run from top to bottom and

46
00:01:42,720 --> 00:01:44,240
we're going to spend a lot of time in

47
00:01:44,240 --> 00:01:46,320
the editor writing code making sure you

48
00:01:46,320 --> 00:01:48,399
really understand what is going on here

49
00:01:48,399 --> 00:01:49,840
towards the end we're going to learn

50
00:01:49,840 --> 00:01:51,920
about object oriented programming and

51
00:01:51,920 --> 00:01:53,520
we're going to touch on classes

52
00:01:53,520 --> 00:01:55,920
inheritance and polymorphism and these

53
00:01:55,920 --> 00:01:57,680
are the tools you're going to be using a

54
00:01:57,680 --> 00:02:00,000
lot in your career as a c plus plus

55
00:02:00,000 --> 00:02:02,240
developer another great feature of this

56
00:02:02,240 --> 00:02:04,320
course is that we spend a lot of time

57
00:02:04,320 --> 00:02:06,640
making sure you understand the tools so

58
00:02:06,640 --> 00:02:08,560
if you don't know what a compiler is if

59
00:02:08,560 --> 00:02:10,879
you don't know what an ide is we're

60
00:02:10,879 --> 00:02:12,560
going to make sure you understand these

61
00:02:12,560 --> 00:02:14,319
things and we're going to spend a lot of

62
00:02:14,319 --> 00:02:16,560
time using these things and by the time

63
00:02:16,560 --> 00:02:17,760
you're done with the course you're going

64
00:02:17,760 --> 00:02:20,480
to be very comfortable using the tools

65
00:02:20,480 --> 00:02:22,319
the editor of choice for the course is

66
00:02:22,319 --> 00:02:25,040
going to be visual studio code so that's

67
00:02:25,040 --> 00:02:26,720
an editor that is going to allow us to

68
00:02:26,720 --> 00:02:29,200
type in the code and give us some things

69
00:02:29,200 --> 00:02:31,599
like a syntax highlighting but we're

70
00:02:31,599 --> 00:02:34,239
going to be connecting our editor to a

71
00:02:34,239 --> 00:02:36,480
background compiler which is going to

72
00:02:36,480 --> 00:02:39,200
make sure our code is transformed

73
00:02:39,200 --> 00:02:41,760
to run on our computer but don't worry

74
00:02:41,760 --> 00:02:43,680
about all that craziness right now we're

75
00:02:43,680 --> 00:02:46,400
going to go in detail about these things

76
00:02:46,400 --> 00:02:48,800
for now i just want you to have a bird's

77
00:02:48,800 --> 00:02:51,440
eye view on what you can expect from the

78
00:02:51,440 --> 00:02:54,000
course here now i hope you know what to

79
00:02:54,000 --> 00:02:57,120
expect from the course but i also expect

80
00:02:57,120 --> 00:03:00,159
you to be ready to take the course and

81
00:03:00,159 --> 00:03:02,800
the requirements are really not that bad

82
00:03:02,800 --> 00:03:04,560
the only requirement is that you have

83
00:03:04,560 --> 00:03:06,560
time set aside to really practice what

84
00:03:06,560 --> 00:03:08,400
you learn from the course here and you

85
00:03:08,400 --> 00:03:10,319
need to have a strong drive and

86
00:03:10,319 --> 00:03:12,239
willingness to learn now if you want to

87
00:03:12,239 --> 00:03:14,560
follow along i am going to share a link

88
00:03:14,560 --> 00:03:17,360
to the github repository for the code i

89
00:03:17,360 --> 00:03:19,280
use in the course so you can check that

90
00:03:19,280 --> 00:03:21,920
out and really follow along if you want

91
00:03:21,920 --> 00:03:24,000
if you want some support we have a

92
00:03:24,000 --> 00:03:26,319
discord server dedicated for our

93
00:03:26,319 --> 00:03:28,640
students so you can join and be part of

94
00:03:28,640 --> 00:03:30,799
the community if you have a question you

95
00:03:30,799 --> 00:03:32,640
can ask but another thing i would

96
00:03:32,640 --> 00:03:35,040
encourage you to do is to also help

97
00:03:35,040 --> 00:03:37,360
others so if you see somebody asking a

98
00:03:37,360 --> 00:03:39,360
question try to help them you're going

99
00:03:39,360 --> 00:03:41,680
to learn a lot that way okay now that

100
00:03:41,680 --> 00:03:43,360
you know a bit about the course let's

101
00:03:43,360 --> 00:03:45,760
talk about myself here my name is daniel

102
00:03:45,760 --> 00:03:48,000
cacoya i am a software engineer i have

103
00:03:48,000 --> 00:03:50,720
been writing code since 2011 or

104
00:03:50,720 --> 00:03:51,760
something

105
00:03:51,760 --> 00:03:53,920
and i am a professional c plus plus

106
00:03:53,920 --> 00:03:56,560
developer i do a lot of freelance work i

107
00:03:56,560 --> 00:03:58,640
work for a few companies i do all kinds

108
00:03:58,640 --> 00:04:00,959
of crazy things i also like to teach

109
00:04:00,959 --> 00:04:03,599
others so i have a few courses on udemy

110
00:04:03,599 --> 00:04:05,280
if you are interested in cute you can

111
00:04:05,280 --> 00:04:07,439
check these things out i also have a

112
00:04:07,439 --> 00:04:09,680
trending c plus plus course that you can

113
00:04:09,680 --> 00:04:12,560
check out but don't feel the need to go

114
00:04:12,560 --> 00:04:14,480
and check this ziplesque course out

115
00:04:14,480 --> 00:04:17,280
because a lot is covered in this youtube

116
00:04:17,280 --> 00:04:19,759
course here so that's really all about

117
00:04:19,759 --> 00:04:22,400
me okay now that you have an idea about

118
00:04:22,400 --> 00:04:24,160
the course we're going to head over in

119
00:04:24,160 --> 00:04:26,160
the next lecture and learn about the

120
00:04:26,160 --> 00:04:28,240
tools we're going to be using throughout

121
00:04:28,240 --> 00:04:30,240
the course here go ahead and finish up

122
00:04:30,240 --> 00:04:32,479
here and meet me there

123
00:04:32,479 --> 00:04:34,400
welcome to this new chapter where we're

124
00:04:34,400 --> 00:04:37,199
going to be exploring the c plus plus

125
00:04:37,199 --> 00:04:39,840
development tools you need to start

126
00:04:39,840 --> 00:04:41,919
writing your own c plus plus

127
00:04:41,919 --> 00:04:44,320
applications and you really need two

128
00:04:44,320 --> 00:04:46,960
kinds of tools the first one is going to

129
00:04:46,960 --> 00:04:49,600
be an editor or an ide through which

130
00:04:49,600 --> 00:04:51,759
you're going to be writing your c plus

131
00:04:51,759 --> 00:04:53,919
plus code we are going to be using

132
00:04:53,919 --> 00:04:56,320
visual studio code as an editor in this

133
00:04:56,320 --> 00:04:58,560
course because it is very easy to

134
00:04:58,560 --> 00:05:01,199
install it is cross-platform it is going

135
00:05:01,199 --> 00:05:04,080
to run well on windows mac and linux and

136
00:05:04,080 --> 00:05:07,039
it supports a host of tools that are

137
00:05:07,039 --> 00:05:08,960
going to make your job easier as a

138
00:05:08,960 --> 00:05:11,600
surplus plus developer but that's not to

139
00:05:11,600 --> 00:05:14,000
say you can't use your favorite ide if

140
00:05:14,000 --> 00:05:16,160
you can but visual studio code is going

141
00:05:16,160 --> 00:05:18,560
to be our main editor in this course so

142
00:05:18,560 --> 00:05:20,479
i would recommend installing it to be

143
00:05:20,479 --> 00:05:22,400
able to follow along with what we do

144
00:05:22,400 --> 00:05:25,120
here now after we have an ide or an

145
00:05:25,120 --> 00:05:28,000
editor in place we will need a compiler

146
00:05:28,000 --> 00:05:31,120
and the compiler is a piece of software

147
00:05:31,120 --> 00:05:33,120
that takes the code we write in the

148
00:05:33,120 --> 00:05:37,039
editor and compiles that into code that

149
00:05:37,039 --> 00:05:40,639
can directly run on the hardware or

150
00:05:40,639 --> 00:05:43,280
binary executable format so this is what

151
00:05:43,280 --> 00:05:45,039
we're going to be doing here we're going

152
00:05:45,039 --> 00:05:48,000
to be typing our code in an editor like

153
00:05:48,000 --> 00:05:50,000
visual studio code we're going to be

154
00:05:50,000 --> 00:05:52,000
kicking off a process to compile our

155
00:05:52,000 --> 00:05:54,000
program and this is going to turn our

156
00:05:54,000 --> 00:05:56,720
program into a format that can run it

157
00:05:56,720 --> 00:05:59,120
directly on the hardware so for example

158
00:05:59,120 --> 00:06:00,880
if you are on a windows machine you're

159
00:06:00,880 --> 00:06:03,440
going to generate a binary executable

160
00:06:03,440 --> 00:06:05,919
that can directly run on windows if you

161
00:06:05,919 --> 00:06:08,080
are on linux we will generate a binary

162
00:06:08,080 --> 00:06:10,720
that can run on linux and the same

163
00:06:10,720 --> 00:06:13,680
concepts can really extend on mac or any

164
00:06:13,680 --> 00:06:15,600
other kind of operating system you might

165
00:06:15,600 --> 00:06:18,160
be working on with the course here so we

166
00:06:18,160 --> 00:06:20,319
need two tools we need an ide or an

167
00:06:20,319 --> 00:06:23,120
editor and a compiler and the tools you

168
00:06:23,120 --> 00:06:26,080
install are going to be depending on the

169
00:06:26,080 --> 00:06:28,160
operating system you are using to watch

170
00:06:28,160 --> 00:06:30,479
the course if you are on windows you're

171
00:06:30,479 --> 00:06:33,440
going to install a set of tools that are

172
00:06:33,440 --> 00:06:36,319
specific to windows if you are on linux

173
00:06:36,319 --> 00:06:38,080
you're going to install a set of tools

174
00:06:38,080 --> 00:06:40,319
for linux if you are on a mac you're

175
00:06:40,319 --> 00:06:44,000
going to install a set of tools specific

176
00:06:44,000 --> 00:06:46,319
to the apple operating system for

177
00:06:46,319 --> 00:06:49,919
desktop now on windows in terms of ides

178
00:06:49,919 --> 00:06:52,479
or integrated development environment it

179
00:06:52,479 --> 00:06:55,759
is possible to use a host of ides for

180
00:06:55,759 --> 00:06:58,319
example you can use code lite it is an

181
00:06:58,319 --> 00:07:00,639
ide you can use you can use microsoft

182
00:07:00,639 --> 00:07:03,039
visual studio but in this course we're

183
00:07:03,039 --> 00:07:05,039
going to be using visual studio code

184
00:07:05,039 --> 00:07:08,080
because it is easy to install it has a

185
00:07:08,080 --> 00:07:10,400
set of features that are really good it

186
00:07:10,400 --> 00:07:12,720
is popular it has a great community

187
00:07:12,720 --> 00:07:14,800
around it i think you're going to have a

188
00:07:14,800 --> 00:07:17,280
great time as a beginner to start

189
00:07:17,280 --> 00:07:19,919
writing your c plus plus programs using

190
00:07:19,919 --> 00:07:22,160
visual studio code that's not to say

191
00:07:22,160 --> 00:07:24,400
that you can't use another ide you can

192
00:07:24,400 --> 00:07:27,120
if you want but i am going to be using

193
00:07:27,120 --> 00:07:29,440
visual studio code in this course here

194
00:07:29,440 --> 00:07:31,440
now on linux we are also going to be

195
00:07:31,440 --> 00:07:34,479
using visual studio code as our editor

196
00:07:34,479 --> 00:07:37,120
in the course but there are other ides

197
00:07:37,120 --> 00:07:39,039
you can use for example you can use cute

198
00:07:39,039 --> 00:07:40,479
creator if you want you can use

199
00:07:40,479 --> 00:07:43,120
codelight you can use a host of other

200
00:07:43,120 --> 00:07:45,919
ides on linux but again visual studio

201
00:07:45,919 --> 00:07:47,520
code is going to be our thing in the

202
00:07:47,520 --> 00:07:49,440
course here and i would recommend

203
00:07:49,440 --> 00:07:52,319
installing it on your linux box if you

204
00:07:52,319 --> 00:07:54,479
are watching this course on the linux

205
00:07:54,479 --> 00:07:57,280
machine so for osx we are also going to

206
00:07:57,280 --> 00:07:59,440
be using visual studio code as our

207
00:07:59,440 --> 00:08:02,319
editor as i said it is cross platforms

208
00:08:02,319 --> 00:08:04,319
it runs where regardless of the

209
00:08:04,319 --> 00:08:06,240
operating system you might be using to

210
00:08:06,240 --> 00:08:08,319
watch the course but if you want you can

211
00:08:08,319 --> 00:08:09,840
use the apple

212
00:08:09,840 --> 00:08:12,639
ide which is xcode or even code lite all

213
00:08:12,639 --> 00:08:14,639
these are going to work if you want but

214
00:08:14,639 --> 00:08:16,960
again i would recommend going with

215
00:08:16,960 --> 00:08:19,919
visual studio code.plus to start out so

216
00:08:19,919 --> 00:08:22,240
that we have a common ground and you

217
00:08:22,240 --> 00:08:24,240
don't get confused very easily

218
00:08:24,240 --> 00:08:26,400
especially if you are a beginner now

219
00:08:26,400 --> 00:08:28,639
after we have an ide rolling we will

220
00:08:28,639 --> 00:08:30,400
need a compiler

221
00:08:30,400 --> 00:08:32,959
and as we say the compiler is a tool

222
00:08:32,959 --> 00:08:35,279
that is going to transform your c plus

223
00:08:35,279 --> 00:08:38,240
plus code into a format that can run

224
00:08:38,240 --> 00:08:40,800
directly on the hardware so the compiler

225
00:08:40,800 --> 00:08:42,479
you use again is going to depend on the

226
00:08:42,479 --> 00:08:44,240
operating system where you are watching

227
00:08:44,240 --> 00:08:46,480
the course i am going to show you a

228
00:08:46,480 --> 00:08:49,600
bunch of compilers you can use but gcc

229
00:08:49,600 --> 00:08:52,160
is going to be our common base so on

230
00:08:52,160 --> 00:08:54,399
windows i will be using what we call

231
00:08:54,399 --> 00:08:56,800
mingw don't worry if you don't what it

232
00:08:56,800 --> 00:08:58,320
is i am going to show you in a minute

233
00:08:58,320 --> 00:09:01,040
when we install it but this is a project

234
00:09:01,040 --> 00:09:03,920
that brings the gcc compiler on windows

235
00:09:03,920 --> 00:09:06,320
so that we can use it easily and i am

236
00:09:06,320 --> 00:09:08,399
going to show you how to install it but

237
00:09:08,399 --> 00:09:09,839
i am also going to show you how to

238
00:09:09,839 --> 00:09:12,160
install the compiler from microsoft and

239
00:09:12,160 --> 00:09:15,360
the clang llvm compiler these are all

240
00:09:15,360 --> 00:09:17,600
available to you on windows and it is

241
00:09:17,600 --> 00:09:20,160
really easy to install them these days

242
00:09:20,160 --> 00:09:22,880
and i will be using them all if you are

243
00:09:22,880 --> 00:09:24,959
on windows i would recommend installing

244
00:09:24,959 --> 00:09:27,279
them all so that you really have a

245
00:09:27,279 --> 00:09:30,240
chance to try your c plus plus code on

246
00:09:30,240 --> 00:09:31,839
the different compilers and that's a

247
00:09:31,839 --> 00:09:34,320
really good thing to do if you test your

248
00:09:34,320 --> 00:09:36,399
c plus plus code against multiple

249
00:09:36,399 --> 00:09:38,959
compilers you will be increasing your

250
00:09:38,959 --> 00:09:41,360
chances for your code to really be

251
00:09:41,360 --> 00:09:43,680
portable and work on multiple compilers

252
00:09:43,680 --> 00:09:46,399
and operating systems and that cannot be

253
00:09:46,399 --> 00:09:48,160
a bad thing so i would recommend

254
00:09:48,160 --> 00:09:50,240
installing all these compilers if you

255
00:09:50,240 --> 00:09:52,320
are on windows i am also going to show

256
00:09:52,320 --> 00:09:54,320
you how to install two compilers on

257
00:09:54,320 --> 00:09:56,320
linux i am going to show you gcc we're

258
00:09:56,320 --> 00:09:58,880
going to install the shiny new feature

259
00:09:58,880 --> 00:10:01,760
in gcc we're going to install clang lvm

260
00:10:01,760 --> 00:10:03,600
on linux and we will be able to use all

261
00:10:03,600 --> 00:10:05,760
these compilers again if you are on

262
00:10:05,760 --> 00:10:07,920
linux i would recommend installing all

263
00:10:07,920 --> 00:10:10,000
these compilers so that you have a

264
00:10:10,000 --> 00:10:12,720
chance to try your code against multiple

265
00:10:12,720 --> 00:10:14,480
compilers and that's going to make your

266
00:10:14,480 --> 00:10:18,000
code much portable and easier to use on

267
00:10:18,000 --> 00:10:21,120
multiple compilers and platforms on the

268
00:10:21,120 --> 00:10:22,959
mac i am going to show you how to

269
00:10:22,959 --> 00:10:25,200
install gcc

270
00:10:25,200 --> 00:10:27,120
and i am going to show you how to

271
00:10:27,120 --> 00:10:29,760
install clangle lvm but if you want you

272
00:10:29,760 --> 00:10:32,240
can also install xcode and the compiler

273
00:10:32,240 --> 00:10:34,160
that comes with that for c plus but

274
00:10:34,160 --> 00:10:37,040
development all these are options to you

275
00:10:37,040 --> 00:10:38,880
but again in this course we are mostly

276
00:10:38,880 --> 00:10:41,120
going to be using the gcc compiler so i

277
00:10:41,120 --> 00:10:43,360
would recommend getting a hold of this

278
00:10:43,360 --> 00:10:45,120
if you don't want to install other

279
00:10:45,120 --> 00:10:47,519
compilers if you only have to install

280
00:10:47,519 --> 00:10:50,399
one compiler please install gcc that's

281
00:10:50,399 --> 00:10:52,399
going to be our main compiler in the

282
00:10:52,399 --> 00:10:54,480
course here okay so these are the tools

283
00:10:54,480 --> 00:10:56,240
we need we are going to head over in the

284
00:10:56,240 --> 00:10:58,880
next lecture and show you how to install

285
00:10:58,880 --> 00:11:01,600
the visual studio code editor on windows

286
00:11:01,600 --> 00:11:03,600
and really get started with that

287
00:11:03,600 --> 00:11:05,680
go ahead and finish up here and meet me

288
00:11:05,680 --> 00:11:07,440
in the next lecture this video i am

289
00:11:07,440 --> 00:11:09,680
going to show you how to install a c

290
00:11:09,680 --> 00:11:12,079
plus plus compiler on your windows

291
00:11:12,079 --> 00:11:14,959
operating system so we're going to be

292
00:11:14,959 --> 00:11:16,959
looking at three kinds of compilers

293
00:11:16,959 --> 00:11:18,800
we're going to look at the mingw

294
00:11:18,800 --> 00:11:21,519
compiler which gives us access to a gcc

295
00:11:21,519 --> 00:11:23,760
like compiler on windows we're going to

296
00:11:23,760 --> 00:11:26,000
look at clan llvm which is another

297
00:11:26,000 --> 00:11:27,680
compiler we're going to look at the

298
00:11:27,680 --> 00:11:30,160
compiler from microsoft

299
00:11:30,160 --> 00:11:32,560
now before we talk about any compiler i

300
00:11:32,560 --> 00:11:34,800
would like you to come to google or your

301
00:11:34,800 --> 00:11:37,200
favorite search engine and say

302
00:11:37,200 --> 00:11:39,760
c plus plus compiler support okay so

303
00:11:39,760 --> 00:11:41,279
we're going to choose this little guy

304
00:11:41,279 --> 00:11:43,839
here and this is really going to give us

305
00:11:43,839 --> 00:11:46,079
a berg's eye view

306
00:11:46,079 --> 00:11:48,959
on which feature is supported by which c

307
00:11:48,959 --> 00:11:51,839
plus plus compiler for example if we are

308
00:11:51,839 --> 00:11:54,320
interested in c plus plus 20 which is

309
00:11:54,320 --> 00:11:56,079
the lattice standard that we have in

310
00:11:56,079 --> 00:11:58,639
simplest plus at the time of recording

311
00:11:58,639 --> 00:12:00,959
this video i am recording of this in

312
00:12:00,959 --> 00:12:01,959
august

313
00:12:01,959 --> 00:12:04,880
2021 but if we go here we're going to

314
00:12:04,880 --> 00:12:07,600
see c plus plus 20 core features and

315
00:12:07,600 --> 00:12:09,600
we're going to see that we have a list

316
00:12:09,600 --> 00:12:12,000
of what each compiler supports we have

317
00:12:12,000 --> 00:12:15,040
gcc we have clan we have msvc we have

318
00:12:15,040 --> 00:12:18,079
the clan version from the apple company

319
00:12:18,079 --> 00:12:20,079
and if we scroll down we can really see

320
00:12:20,079 --> 00:12:22,480
the features that are supported by each

321
00:12:22,480 --> 00:12:26,000
compiler again gcc is going to be our

322
00:12:26,000 --> 00:12:27,600
choice in this course this is going to

323
00:12:27,600 --> 00:12:30,079
be our main compiler but nothing really

324
00:12:30,079 --> 00:12:32,320
stops you from using the clan compiler

325
00:12:32,320 --> 00:12:34,800
or the msvc compiler and if you happen

326
00:12:34,800 --> 00:12:36,720
to see that your compiler of choice

327
00:12:36,720 --> 00:12:38,320
doesn't support what you need for

328
00:12:38,320 --> 00:12:40,800
example you can see that at the current

329
00:12:40,800 --> 00:12:44,320
time lambdas in an evaluated context are

330
00:12:44,320 --> 00:12:46,959
not supported in clan

331
00:12:46,959 --> 00:12:49,279
you can see that it is ready here but

332
00:12:49,279 --> 00:12:51,279
this is a feature you can use both in

333
00:12:51,279 --> 00:12:55,920
gcc and the msvc compiler from microsoft

334
00:12:55,920 --> 00:12:59,279
so keep an eye out on this page here to

335
00:12:59,279 --> 00:13:01,279
know which kind of things you can use in

336
00:13:01,279 --> 00:13:03,519
your compiler if you try something out

337
00:13:03,519 --> 00:13:05,839
and you see that it doesn't work this is

338
00:13:05,839 --> 00:13:07,920
a good place to come and figure out if

339
00:13:07,920 --> 00:13:10,240
your compiler supports the feature that

340
00:13:10,240 --> 00:13:12,399
you are using in this video i am going

341
00:13:12,399 --> 00:13:14,079
to show you how to install the three

342
00:13:14,079 --> 00:13:16,639
most common compilers and those are gcc

343
00:13:16,639 --> 00:13:19,839
clang msvc if you want you can come in

344
00:13:19,839 --> 00:13:22,560
your search engine and type gcc to see

345
00:13:22,560 --> 00:13:24,800
what this is it is a good thing to do to

346
00:13:24,800 --> 00:13:27,040
learn about your tools here you can see

347
00:13:27,040 --> 00:13:28,720
that it is a compiler that is mostly

348
00:13:28,720 --> 00:13:31,040
used on the lenox platform but we can

349
00:13:31,040 --> 00:13:33,760
also use it on windows the latest

350
00:13:33,760 --> 00:13:34,959
release that we're going to be

351
00:13:34,959 --> 00:13:37,600
installing is eleven two zero i think it

352
00:13:37,600 --> 00:13:39,120
was released

353
00:13:39,120 --> 00:13:41,440
six days ago so it is really fresh and

354
00:13:41,440 --> 00:13:43,040
we're going to be taking advantage of

355
00:13:43,040 --> 00:13:45,040
this another thing i should say here is

356
00:13:45,040 --> 00:13:47,519
that you should install the latest tools

357
00:13:47,519 --> 00:13:50,079
you can get your hands upon this is the

358
00:13:50,079 --> 00:13:52,320
version we're going to be mostly using

359
00:13:52,320 --> 00:13:54,320
in this course but if you are watching

360
00:13:54,320 --> 00:13:55,760
this in the future you're going to have

361
00:13:55,760 --> 00:13:57,760
a newer version i would recommend

362
00:13:57,760 --> 00:14:00,079
installing the latest version or the

363
00:14:00,079 --> 00:14:02,320
newest version you can get your hands

364
00:14:02,320 --> 00:14:04,880
upon so the first we're going to do is

365
00:14:04,880 --> 00:14:07,760
install a gcc compiler on windows i am

366
00:14:07,760 --> 00:14:10,000
going to show you a way we can get both

367
00:14:10,000 --> 00:14:13,360
gcc and clang in one go and to get

368
00:14:13,360 --> 00:14:15,279
access to that please go in your search

369
00:14:15,279 --> 00:14:17,760
engine and type windlabs and this is

370
00:14:17,760 --> 00:14:19,839
going to bring us to this project here

371
00:14:19,839 --> 00:14:22,320
if you want you can click upon this

372
00:14:22,320 --> 00:14:25,440
and this is a cool project by a guy who

373
00:14:25,440 --> 00:14:28,320
is providing worlds for these compilers

374
00:14:28,320 --> 00:14:30,399
that we can use on windows

375
00:14:30,399 --> 00:14:32,959
so if you want you can just go down here

376
00:14:32,959 --> 00:14:35,760
and look at the lettuce releases again i

377
00:14:35,760 --> 00:14:37,760
recommend using the

378
00:14:37,760 --> 00:14:39,839
lettuce you can get your hands upon in

379
00:14:39,839 --> 00:14:43,360
this case the lettuce happens to be 1120

380
00:14:43,360 --> 00:14:45,199
but in the future this is going to

381
00:14:45,199 --> 00:14:46,800
change you're going to find a version

382
00:14:46,800 --> 00:14:50,160
for 12 or 13 so please grab the newest

383
00:14:50,160 --> 00:14:52,480
version you can get your hands up on now

384
00:14:52,480 --> 00:14:54,399
i want you to install the version that

385
00:14:54,399 --> 00:14:58,000
says that it has llvm and clang so if

386
00:14:58,000 --> 00:15:01,040
you are on a 32-bit version on windows i

387
00:15:01,040 --> 00:15:03,440
would recommend getting this 7-zip

388
00:15:03,440 --> 00:15:06,320
archive on this zip archive here if you

389
00:15:06,320 --> 00:15:08,800
are on 64 i would recommend getting a

390
00:15:08,800 --> 00:15:11,199
hold of this or this little thing here

391
00:15:11,199 --> 00:15:13,120
it doesn't really matter but make sure

392
00:15:13,120 --> 00:15:15,040
you get the latest version you can get

393
00:15:15,040 --> 00:15:16,959
your hands upon and you can see that

394
00:15:16,959 --> 00:15:19,760
this conveniently says latest here so i

395
00:15:19,760 --> 00:15:22,480
am going to download the 64-bit version

396
00:15:22,480 --> 00:15:24,480
on windows i am going to grab the zip

397
00:15:24,480 --> 00:15:27,440
archive here and let's click upon this

398
00:15:27,440 --> 00:15:30,160
this should kick off my download and

399
00:15:30,160 --> 00:15:32,240
this is going to download on my system i

400
00:15:32,240 --> 00:15:34,399
can download this if i want and you're

401
00:15:34,399 --> 00:15:36,079
going to see that it is going to start

402
00:15:36,079 --> 00:15:38,480
downloading here and i am going to wait

403
00:15:38,480 --> 00:15:41,440
for this to finish again this is going

404
00:15:41,440 --> 00:15:44,320
to give us both the gcc compiler and the

405
00:15:44,320 --> 00:15:46,639
clan compiler and this is really like

406
00:15:46,639 --> 00:15:49,360
shooting two birds with one stone so

407
00:15:49,360 --> 00:15:51,519
this is going to be really good i

408
00:15:51,519 --> 00:15:53,440
already have this downloaded so i am

409
00:15:53,440 --> 00:15:56,160
just going to head over to the location

410
00:15:56,160 --> 00:15:58,560
where i have this downloaded i think i

411
00:15:58,560 --> 00:16:01,759
can just go in my drive here

412
00:16:01,759 --> 00:16:04,160
so let's crack this open and go in my

413
00:16:04,160 --> 00:16:06,079
downloads folder

414
00:16:06,079 --> 00:16:08,880
and if i go in my compressed folder i am

415
00:16:08,880 --> 00:16:12,959
going to find winlabs llvm and mingw

416
00:16:12,959 --> 00:16:15,360
this is what you really want but if you

417
00:16:15,360 --> 00:16:17,040
don't want the clan compiler you can

418
00:16:17,040 --> 00:16:20,639
grab the one that doesn't say llvm here

419
00:16:20,639 --> 00:16:22,160
because we really want both of these

420
00:16:22,160 --> 00:16:24,320
compilers we are going to grab the one

421
00:16:24,320 --> 00:16:26,560
that has both the gcc compiler and the

422
00:16:26,560 --> 00:16:28,959
clan compiler if we crack this open

423
00:16:28,959 --> 00:16:30,720
let's open this together so that you can

424
00:16:30,720 --> 00:16:32,880
see what is happening we are going to

425
00:16:32,880 --> 00:16:35,120
have this little folder here if we go in

426
00:16:35,120 --> 00:16:37,360
we're going to find a bin folder if we

427
00:16:37,360 --> 00:16:39,680
go in and crack that open we're going to

428
00:16:39,680 --> 00:16:40,959
have a folder

429
00:16:40,959 --> 00:16:44,160
that says clang you see we have a clang

430
00:16:44,160 --> 00:16:46,639
compiler we have our clan plus plus

431
00:16:46,639 --> 00:16:48,880
compiler for c plus plus and if we go

432
00:16:48,880 --> 00:16:50,959
down we're going to find our g plus plus

433
00:16:50,959 --> 00:16:53,680
compiler and the gcc compiler this is

434
00:16:53,680 --> 00:16:55,839
what we want so what we are going to do

435
00:16:55,839 --> 00:16:58,480
is extract this somewhere on our system

436
00:16:58,480 --> 00:17:01,040
i put this on my c drive so if you go

437
00:17:01,040 --> 00:17:03,759
here you're going to find mingw64

438
00:17:03,759 --> 00:17:06,160
so all you really have to do is go where

439
00:17:06,160 --> 00:17:08,720
you downloaded your compiler

440
00:17:08,720 --> 00:17:10,559
and say extract we're going to right

441
00:17:10,559 --> 00:17:12,079
click on this

442
00:17:12,079 --> 00:17:14,959
and say extract to a location and you're

443
00:17:14,959 --> 00:17:16,720
going to specify where you want this to

444
00:17:16,720 --> 00:17:19,760
go and this is going to be extracted or

445
00:17:19,760 --> 00:17:21,760
even if you want you can extract here

446
00:17:21,760 --> 00:17:23,439
this is something i like to do this is

447
00:17:23,439 --> 00:17:25,520
going to show up in the current folder

448
00:17:25,520 --> 00:17:28,079
and you can grab this and paste that in

449
00:17:28,079 --> 00:17:30,320
a location where you want this in my

450
00:17:30,320 --> 00:17:33,120
case i put this in my c drive as i said

451
00:17:33,120 --> 00:17:35,679
here so this is going to be my compiler

452
00:17:35,679 --> 00:17:37,760
now once you have these compilers

453
00:17:37,760 --> 00:17:39,520
installed again we have the clan

454
00:17:39,520 --> 00:17:42,480
compiler we have the gcc compiler if we

455
00:17:42,480 --> 00:17:44,080
go down we're going to find the g plus

456
00:17:44,080 --> 00:17:46,240
plus we even have gdb which is a

457
00:17:46,240 --> 00:17:48,400
debugger we can use to debug c plus plus

458
00:17:48,400 --> 00:17:50,720
applications but we will talk about this

459
00:17:50,720 --> 00:17:52,799
later once you have this i would

460
00:17:52,799 --> 00:17:54,559
recommend putting this in your

461
00:17:54,559 --> 00:17:57,120
environment variables on windows the way

462
00:17:57,120 --> 00:17:59,360
you do this you grab this path well we

463
00:17:59,360 --> 00:18:00,960
have our compilers here and we're going

464
00:18:00,960 --> 00:18:02,559
to copy this this is something i

465
00:18:02,559 --> 00:18:03,760
recommend

466
00:18:03,760 --> 00:18:06,640
and on windows 10 you can go on the

467
00:18:06,640 --> 00:18:10,559
start menu and type env

468
00:18:10,559 --> 00:18:12,799
and this is going to give us a window in

469
00:18:12,799 --> 00:18:15,039
which we can edit our environment

470
00:18:15,039 --> 00:18:16,799
variables we're going to click on this

471
00:18:16,799 --> 00:18:19,120
little thing this is going to open up on

472
00:18:19,120 --> 00:18:20,559
our system we're going to wait for this

473
00:18:20,559 --> 00:18:22,640
to open up and we're going to have a

474
00:18:22,640 --> 00:18:25,039
window that says system properties we're

475
00:18:25,039 --> 00:18:26,960
going to click on environment variables

476
00:18:26,960 --> 00:18:30,080
here and we can put this in our user

477
00:18:30,080 --> 00:18:32,880
environment variables or on our system

478
00:18:32,880 --> 00:18:34,960
environment variables since i am the

479
00:18:34,960 --> 00:18:37,280
only one using this system i like to put

480
00:18:37,280 --> 00:18:40,160
this in my path for my system variables

481
00:18:40,160 --> 00:18:42,480
so i am going to click on path and click

482
00:18:42,480 --> 00:18:45,360
edit here and i am going to add a path

483
00:18:45,360 --> 00:18:48,240
to my gcc and cloud installation here

484
00:18:48,240 --> 00:18:50,559
you can see that right here if you don't

485
00:18:50,559 --> 00:18:52,880
have this end you can click on new

486
00:18:52,880 --> 00:18:54,400
you're going to have a window here and

487
00:18:54,400 --> 00:18:56,880
you can paste this right in and you can

488
00:18:56,880 --> 00:18:58,720
click ok but i'm not going to do that

489
00:18:58,720 --> 00:19:01,679
because i already have this in here so

490
00:19:01,679 --> 00:19:04,000
what i am going to do is just delete

491
00:19:04,000 --> 00:19:06,880
this let's see if i can delete i can

492
00:19:06,880 --> 00:19:08,880
delete this little guy and i have my

493
00:19:08,880 --> 00:19:11,039
path in here so if you don't have this

494
00:19:11,039 --> 00:19:12,960
in please make sure you have this in

495
00:19:12,960 --> 00:19:15,440
your environment variables so we're

496
00:19:15,440 --> 00:19:17,520
going to cancel out of this but if this

497
00:19:17,520 --> 00:19:19,520
is the first time you do this you should

498
00:19:19,520 --> 00:19:22,480
click ok and one way to test that your

499
00:19:22,480 --> 00:19:24,960
environment variables are working or

500
00:19:24,960 --> 00:19:27,840
even if your compilers are working

501
00:19:27,840 --> 00:19:30,880
is to crack up a command line terminal

502
00:19:30,880 --> 00:19:32,880
so we're going to say cmd on the start

503
00:19:32,880 --> 00:19:34,559
menu here

504
00:19:34,559 --> 00:19:37,039
and all you need to do is say g plus

505
00:19:37,039 --> 00:19:40,640
plus just like this dash dash version

506
00:19:40,640 --> 00:19:41,919
if you do this you're going to see

507
00:19:41,919 --> 00:19:43,840
information about your c plus plus

508
00:19:43,840 --> 00:19:45,039
compiler

509
00:19:45,039 --> 00:19:46,960
and this is coming from the installation

510
00:19:46,960 --> 00:19:49,679
we just did and for clan you can say

511
00:19:49,679 --> 00:19:53,120
clan plus plus version and this is going

512
00:19:53,120 --> 00:19:55,120
to tell you the information about your

513
00:19:55,120 --> 00:19:57,280
clan compiler installation let's wait

514
00:19:57,280 --> 00:19:58,799
for this to come up i don't know why

515
00:19:58,799 --> 00:20:01,039
it's slow but you can see that we have a

516
00:20:01,039 --> 00:20:03,039
clank compiler the lattice version is

517
00:20:03,039 --> 00:20:06,240
1201 for the gcc compiler the latest

518
00:20:06,240 --> 00:20:08,559
version is 1120

519
00:20:08,559 --> 00:20:10,799
and these are the compilers we can use

520
00:20:10,799 --> 00:20:13,760
to write c plus plus 20 applications

521
00:20:13,760 --> 00:20:16,480
okay so by now we have a gcc compiler

522
00:20:16,480 --> 00:20:19,280
through the main gw project we have a

523
00:20:19,280 --> 00:20:22,320
client llcm compiler on our system we

524
00:20:22,320 --> 00:20:24,400
are also going to see how to get a hold

525
00:20:24,400 --> 00:20:27,440
of the compiler from microsoft and to

526
00:20:27,440 --> 00:20:29,600
get hold of this you need to install

527
00:20:29,600 --> 00:20:32,000
microsoft visual studio

528
00:20:32,000 --> 00:20:34,080
to install microsoft visual studio all

529
00:20:34,080 --> 00:20:36,080
you have to do is come to your favorite

530
00:20:36,080 --> 00:20:38,320
search engine and say microsoft visual

531
00:20:38,320 --> 00:20:41,280
studio we can look at the 2019 version

532
00:20:41,280 --> 00:20:43,440
which is the latest i think and we're

533
00:20:43,440 --> 00:20:45,840
going to click on the download link here

534
00:20:45,840 --> 00:20:48,480
we have as the first link and we're

535
00:20:48,480 --> 00:20:50,400
going to see ways we can download this

536
00:20:50,400 --> 00:20:52,720
little guy now microsoft visual studio

537
00:20:52,720 --> 00:20:55,039
has a community version you can download

538
00:20:55,039 --> 00:20:57,440
for free but we also have a professional

539
00:20:57,440 --> 00:20:59,679
and enterprise versions that we're not

540
00:20:59,679 --> 00:21:02,080
going to care about in this course here

541
00:21:02,080 --> 00:21:04,400
we are just going to download

542
00:21:04,400 --> 00:21:06,880
the community version and that's going

543
00:21:06,880 --> 00:21:09,039
to be enough for our purposes here so if

544
00:21:09,039 --> 00:21:11,600
you click on free download here this is

545
00:21:11,600 --> 00:21:14,400
going to download and install the visual

546
00:21:14,400 --> 00:21:16,640
studio compiler you can click on this

547
00:21:16,640 --> 00:21:18,320
little guy and it is going to download

548
00:21:18,320 --> 00:21:20,000
an installer you're going to crack this

549
00:21:20,000 --> 00:21:22,240
open on your system and it is going to

550
00:21:22,240 --> 00:21:25,440
install the visual studio installer so

551
00:21:25,440 --> 00:21:27,360
once you have it installed you can come

552
00:21:27,360 --> 00:21:29,360
to the start menu here

553
00:21:29,360 --> 00:21:32,320
and say visual studio installer i think

554
00:21:32,320 --> 00:21:33,919
if you say visual studio you're going to

555
00:21:33,919 --> 00:21:35,520
have this pop-up somewhere on your

556
00:21:35,520 --> 00:21:38,000
system we're going to click on this and

557
00:21:38,000 --> 00:21:39,840
if you crack the installer open you're

558
00:21:39,840 --> 00:21:41,600
going to see a window like this which is

559
00:21:41,600 --> 00:21:43,360
really going to give you a chance to

560
00:21:43,360 --> 00:21:46,000
install the tools you want to use with

561
00:21:46,000 --> 00:21:48,720
the microsoft visual studio

562
00:21:48,720 --> 00:21:51,679
ide and in this case we are interested

563
00:21:51,679 --> 00:21:53,840
in desktop development with c plus plus

564
00:21:53,840 --> 00:21:55,600
so we're going to click this little guy

565
00:21:55,600 --> 00:21:57,679
here we're going to take it open

566
00:21:57,679 --> 00:22:00,559
and once you do this you going to click

567
00:22:00,559 --> 00:22:02,400
download and install and this is going

568
00:22:02,400 --> 00:22:05,039
to install the visual studio compiler

569
00:22:05,039 --> 00:22:07,039
with the underlying compiler you see

570
00:22:07,039 --> 00:22:08,880
that this is going to give us access to

571
00:22:08,880 --> 00:22:11,600
the msvc compiler and all kinds of crazy

572
00:22:11,600 --> 00:22:13,360
things we really needed to write c plus

573
00:22:13,360 --> 00:22:16,480
plus applications on windows using the

574
00:22:16,480 --> 00:22:18,799
compiler from microsoft now i have to

575
00:22:18,799 --> 00:22:20,320
say this is going to take some time to

576
00:22:20,320 --> 00:22:22,480
install so if you see that this takes up

577
00:22:22,480 --> 00:22:24,880
20 minutes of your time don't worry this

578
00:22:24,880 --> 00:22:27,919
is really normal because this id and the

579
00:22:27,919 --> 00:22:30,640
compiler behind it and really large

580
00:22:30,640 --> 00:22:33,440
they're not like the gcc or the clan

581
00:22:33,440 --> 00:22:35,840
llvm compilers that we just installed

582
00:22:35,840 --> 00:22:38,320
okay so once you have this ticked or

583
00:22:38,320 --> 00:22:39,679
checked you're going to click on

584
00:22:39,679 --> 00:22:41,840
download or install whatever this button

585
00:22:41,840 --> 00:22:44,159
is saying here this is going to install

586
00:22:44,159 --> 00:22:47,280
both the microsoft visual studio ide

587
00:22:47,280 --> 00:22:49,520
and the compiler from microsoft that you

588
00:22:49,520 --> 00:22:51,840
can use directly to write c plus plus

589
00:22:51,840 --> 00:22:54,400
applications so once we have this open i

590
00:22:54,400 --> 00:22:56,320
am going to suppose that you have this

591
00:22:56,320 --> 00:22:58,080
installed already i am going to close

592
00:22:58,080 --> 00:22:59,919
out of this because i don't want to do

593
00:22:59,919 --> 00:23:00,720
this

594
00:23:00,720 --> 00:23:02,240
and you're going to have visual studio

595
00:23:02,240 --> 00:23:04,480
installed on your system once you have

596
00:23:04,480 --> 00:23:06,080
this installed you're going to come to

597
00:23:06,080 --> 00:23:09,120
the start menu and say developer

598
00:23:09,120 --> 00:23:10,880
and this is going to bring up two things

599
00:23:10,880 --> 00:23:12,320
one is going to be the developer

600
00:23:12,320 --> 00:23:15,520
powershell for visual studio 2019 and

601
00:23:15,520 --> 00:23:16,799
the other is going to be a command

602
00:23:16,799 --> 00:23:18,559
prompt it doesn't really matter what you

603
00:23:18,559 --> 00:23:19,919
choose i am going to click on the

604
00:23:19,919 --> 00:23:21,600
command prompt here

605
00:23:21,600 --> 00:23:23,679
and once you do this this is going to

606
00:23:23,679 --> 00:23:26,559
give you a terminal or a window through

607
00:23:26,559 --> 00:23:27,440
which

608
00:23:27,440 --> 00:23:29,919
the environment variables are already in

609
00:23:29,919 --> 00:23:31,679
to start using the compiler from

610
00:23:31,679 --> 00:23:34,159
microsoft and if we come here and type

611
00:23:34,159 --> 00:23:36,640
cl.exe

612
00:23:36,640 --> 00:23:37,840
we're going to see that we're going to

613
00:23:37,840 --> 00:23:39,919
see the information here if this gives

614
00:23:39,919 --> 00:23:41,679
you an error or something you're going

615
00:23:41,679 --> 00:23:43,840
to know that you didn't really install

616
00:23:43,840 --> 00:23:46,080
this properly so please go back and make

617
00:23:46,080 --> 00:23:48,240
sure you have this installed if you have

618
00:23:48,240 --> 00:23:50,080
a problem you can ask me i can do the

619
00:23:50,080 --> 00:23:52,720
best i can to help you out but by this

620
00:23:52,720 --> 00:23:54,880
moment we have three compilers on

621
00:23:54,880 --> 00:23:57,440
windows that we can use for c plus plus

622
00:23:57,440 --> 00:24:00,880
development we have the mingw or the gcc

623
00:24:00,880 --> 00:24:03,200
compiler in our hands we have the klanga

624
00:24:03,200 --> 00:24:06,080
lvm compiler and we have the compiler

625
00:24:06,080 --> 00:24:09,679
from microsoft and now we can install an

626
00:24:09,679 --> 00:24:11,919
ide or an editor and that's going to be

627
00:24:11,919 --> 00:24:14,400
visual studio code and we can connect

628
00:24:14,400 --> 00:24:16,480
that to these compilers so that we can

629
00:24:16,480 --> 00:24:19,039
start writing our own z plus bus 20

630
00:24:19,039 --> 00:24:21,200
applications we are going to head over

631
00:24:21,200 --> 00:24:23,120
in the next lecture and install the

632
00:24:23,120 --> 00:24:25,279
visual studio code editor

633
00:24:25,279 --> 00:24:27,520
go ahead and finish up here and meet me

634
00:24:27,520 --> 00:24:29,840
there in this lecture i am going to show

635
00:24:29,840 --> 00:24:31,679
you how to install the visual studio

636
00:24:31,679 --> 00:24:34,400
code editor on windows so if you are

637
00:24:34,400 --> 00:24:36,480
watching this course on windows this

638
00:24:36,480 --> 00:24:39,200
video here is going to be a must watch

639
00:24:39,200 --> 00:24:42,000
we are going to head over to our search

640
00:24:42,000 --> 00:24:44,080
engine and type visual studio code this

641
00:24:44,080 --> 00:24:46,080
is going to give you a link where we can

642
00:24:46,080 --> 00:24:48,720
download this cool editor if you want

643
00:24:48,720 --> 00:24:50,559
you can learn all you can about it it is

644
00:24:50,559 --> 00:24:52,960
a source code editor made by microsoft

645
00:24:52,960 --> 00:24:55,200
it supports multiple languages but we're

646
00:24:55,200 --> 00:24:57,840
going to be using that specifically for

647
00:24:57,840 --> 00:25:00,640
c plus plus in the course here here i am

648
00:25:00,640 --> 00:25:03,679
at the page for the editor and you can

649
00:25:03,679 --> 00:25:06,000
read all you want about it but we are

650
00:25:06,000 --> 00:25:08,559
interested in downloading this for

651
00:25:08,559 --> 00:25:10,720
windows if you want you can click on

652
00:25:10,720 --> 00:25:12,880
this download button here but i am just

653
00:25:12,880 --> 00:25:14,480
going to scroll down

654
00:25:14,480 --> 00:25:17,840
and have download links for windows if i

655
00:25:17,840 --> 00:25:19,679
want i can click on user installer

656
00:25:19,679 --> 00:25:21,440
system installer you can click on what

657
00:25:21,440 --> 00:25:24,159
you want if you are on a 32-bit system

658
00:25:24,159 --> 00:25:25,919
you're going to download a 32-bit

659
00:25:25,919 --> 00:25:28,080
version i am just going to click on

660
00:25:28,080 --> 00:25:31,840
64-bit here because i am on a 64-bit

661
00:25:31,840 --> 00:25:33,919
operating system again

662
00:25:33,919 --> 00:25:36,000
in this video we are doing this for

663
00:25:36,000 --> 00:25:38,480
windows so this is going to be our area

664
00:25:38,480 --> 00:25:40,960
of interest here i am going to click on

665
00:25:40,960 --> 00:25:43,200
this download link and i am going to

666
00:25:43,200 --> 00:25:45,520
wait for things to kick off

667
00:25:45,520 --> 00:25:47,360
and i will have a window to start

668
00:25:47,360 --> 00:25:49,520
downloading visual studio code setup

669
00:25:49,520 --> 00:25:51,600
here i can save this file and it is

670
00:25:51,600 --> 00:25:54,000
going to start downloading once it is

671
00:25:54,000 --> 00:25:55,919
downloaded i am going to double click

672
00:25:55,919 --> 00:25:58,240
and really click my way through this

673
00:25:58,240 --> 00:26:00,000
until i have a visual studio code

674
00:26:00,000 --> 00:26:02,960
installed on my computer here

675
00:26:02,960 --> 00:26:05,200
okay the download is good i can crack

676
00:26:05,200 --> 00:26:07,600
this open let's click on this

677
00:26:07,600 --> 00:26:08,960
and you're going to see that it is

678
00:26:08,960 --> 00:26:11,200
saying that it has detected that visual

679
00:26:11,200 --> 00:26:13,520
studio code is already running on my

680
00:26:13,520 --> 00:26:15,840
system because i have it installed but

681
00:26:15,840 --> 00:26:17,200
if you don't have it installed you're

682
00:26:17,200 --> 00:26:19,440
going to click your way through and

683
00:26:19,440 --> 00:26:21,679
install this on windows and after you

684
00:26:21,679 --> 00:26:23,440
have it you can start it

685
00:26:23,440 --> 00:26:25,279
okay once you start visual studio code

686
00:26:25,279 --> 00:26:26,880
you're going to have a window like this

687
00:26:26,880 --> 00:26:28,799
if you run it for the first time you are

688
00:26:28,799 --> 00:26:30,880
probably going to see a windows with

689
00:26:30,880 --> 00:26:33,600
documentation and whatever

690
00:26:33,600 --> 00:26:35,360
let's look at the welcome screen you're

691
00:26:35,360 --> 00:26:36,880
going to probably see you're going to

692
00:26:36,880 --> 00:26:38,640
probably see something like this but i

693
00:26:38,640 --> 00:26:40,960
am not sure but the most important thing

694
00:26:40,960 --> 00:26:42,640
is that you're going to have a window

695
00:26:42,640 --> 00:26:44,880
like this with visual studio code the

696
00:26:44,880 --> 00:26:46,480
first thing we want to do for c plus

697
00:26:46,480 --> 00:26:49,440
plus development is going to scroll down

698
00:26:49,440 --> 00:26:51,679
and click on this little thing that says

699
00:26:51,679 --> 00:26:54,880
extensions i am going to click on this

700
00:26:54,880 --> 00:26:57,279
and i am going to go in my search box

701
00:26:57,279 --> 00:27:00,720
here and type c and c plus i can even

702
00:27:00,720 --> 00:27:02,400
type c plus plus it doesn't really

703
00:27:02,400 --> 00:27:05,360
matter and this is an area where we can

704
00:27:05,360 --> 00:27:08,799
install extensions to make visual studio

705
00:27:08,799 --> 00:27:11,200
code do all kinds of crazy things in

706
00:27:11,200 --> 00:27:13,760
this case we are interested in making it

707
00:27:13,760 --> 00:27:16,480
support c and c plus plus so we are

708
00:27:16,480 --> 00:27:18,320
going to click on this extension that

709
00:27:18,320 --> 00:27:21,120
says microsoft here cnc plus plus i am

710
00:27:21,120 --> 00:27:23,440
going to click on this and if you don't

711
00:27:23,440 --> 00:27:25,200
have it installed you can click on the

712
00:27:25,200 --> 00:27:27,120
install button and it is going to

713
00:27:27,120 --> 00:27:29,120
install this little thing and make your

714
00:27:29,120 --> 00:27:32,080
computer ready to use visual studio code

715
00:27:32,080 --> 00:27:34,399
for c plus plus so make sure you install

716
00:27:34,399 --> 00:27:37,039
this and at the end it is going to say

717
00:27:37,039 --> 00:27:39,520
disable or uninstall because it will be

718
00:27:39,520 --> 00:27:43,039
already installed and enabled on your

719
00:27:43,039 --> 00:27:45,600
computer and this is really the end of

720
00:27:45,600 --> 00:27:47,840
our installation video for visual studio

721
00:27:47,840 --> 00:27:49,679
code we are going to head over in the

722
00:27:49,679 --> 00:27:51,919
next video and show you how you can make

723
00:27:51,919 --> 00:27:54,880
a visual studio code use the compilers

724
00:27:54,880 --> 00:27:57,360
that we installed in the previous video

725
00:27:57,360 --> 00:27:59,440
so go ahead and finish up here and meet

726
00:27:59,440 --> 00:28:01,440
me in the next lecture

727
00:28:01,440 --> 00:28:03,120
in this video we're going to see how to

728
00:28:03,120 --> 00:28:06,320
connect our visual studio code editor to

729
00:28:06,320 --> 00:28:09,440
a compiler so that we can compile our

730
00:28:09,440 --> 00:28:11,840
projects easily through the visual

731
00:28:11,840 --> 00:28:14,240
studio code editor we already have the

732
00:28:14,240 --> 00:28:17,039
ide installed from the last two previous

733
00:28:17,039 --> 00:28:18,960
lectures when we have a compiler

734
00:28:18,960 --> 00:28:20,480
installed in the last lecture we

735
00:28:20,480 --> 00:28:22,399
installed the gcc compiler through the

736
00:28:22,399 --> 00:28:25,840
mingw project we installed the clangela

737
00:28:25,840 --> 00:28:27,679
vm compiler we even installed the

738
00:28:27,679 --> 00:28:30,080
compiler from microsoft now we're going

739
00:28:30,080 --> 00:28:32,640
to connect the ide to the compiler to

740
00:28:32,640 --> 00:28:35,200
make it really easy to compile c plus

741
00:28:35,200 --> 00:28:38,399
plus applications using these tools here

742
00:28:38,399 --> 00:28:40,320
what i am going to do is really set up a

743
00:28:40,320 --> 00:28:42,240
template project we're going to be

744
00:28:42,240 --> 00:28:45,360
reusing throughout this course here so i

745
00:28:45,360 --> 00:28:48,080
am going to go on a folder in my system

746
00:28:48,080 --> 00:28:50,240
and i am going to right click on the

747
00:28:50,240 --> 00:28:52,240
folder and say

748
00:28:52,240 --> 00:28:55,279
open with visual studio code

749
00:28:55,279 --> 00:28:57,360
let's do this this is going to open this

750
00:28:57,360 --> 00:28:59,520
folder in visual studio code and i am

751
00:28:59,520 --> 00:29:02,080
going to trust this folder here be

752
00:29:02,080 --> 00:29:04,240
careful what you trust because some

753
00:29:04,240 --> 00:29:06,000
things are going to do some malicious

754
00:29:06,000 --> 00:29:08,159
things on your computer make sure you

755
00:29:08,159 --> 00:29:11,039
trust the folders that you open up so i

756
00:29:11,039 --> 00:29:12,960
am going to trust myself because i am

757
00:29:12,960 --> 00:29:15,760
the creator of this folder here and this

758
00:29:15,760 --> 00:29:18,159
is going to open visual studio code

759
00:29:18,159 --> 00:29:20,559
now in our install video we installed

760
00:29:20,559 --> 00:29:22,640
the c plus plus extension for visual

761
00:29:22,640 --> 00:29:24,840
studio code again if you don't have this

762
00:29:24,840 --> 00:29:27,120
installed please make sure you go back

763
00:29:27,120 --> 00:29:29,200
and install and make sure this is saying

764
00:29:29,200 --> 00:29:32,720
that this is enabled and now we want to

765
00:29:32,720 --> 00:29:34,559
use this to write c plus plus

766
00:29:34,559 --> 00:29:36,799
applications here we're going to write a

767
00:29:36,799 --> 00:29:39,200
simple toy c plus plus application to

768
00:29:39,200 --> 00:29:42,240
just test that our compilers support c

769
00:29:42,240 --> 00:29:44,799
plus plus 20 and then we're going to use

770
00:29:44,799 --> 00:29:46,799
this as a starting point or as a

771
00:29:46,799 --> 00:29:49,600
template project so i want you to click

772
00:29:49,600 --> 00:29:52,080
on this little plus icon here

773
00:29:52,080 --> 00:29:53,840
and we're going to create a file called

774
00:29:53,840 --> 00:29:56,159
main.cpp

775
00:29:56,159 --> 00:29:58,880
and once you do that you will be able to

776
00:29:58,880 --> 00:30:01,520
type c plus plus code in this year so we

777
00:30:01,520 --> 00:30:03,120
are just starting out here i would

778
00:30:03,120 --> 00:30:05,520
recommend to type this exactly as i do

779
00:30:05,520 --> 00:30:08,640
here so we're going to say include and

780
00:30:08,640 --> 00:30:11,520
say opening angle bracket and say io

781
00:30:11,520 --> 00:30:12,720
stream

782
00:30:12,720 --> 00:30:14,480
and we're going to go down here and say

783
00:30:14,480 --> 00:30:15,840
and main

784
00:30:15,840 --> 00:30:18,960
and we're going to go inside these curly

785
00:30:18,960 --> 00:30:23,520
braces and say auto result and you are

786
00:30:23,520 --> 00:30:26,240
going to exactly type what i tap here

787
00:30:26,240 --> 00:30:27,760
don't worry we're going to have a chance

788
00:30:27,760 --> 00:30:30,159
to learn about all these things here so

789
00:30:30,159 --> 00:30:33,440
i am going to put a pair of parentheses

790
00:30:33,440 --> 00:30:36,960
and i am going to say 10. and i am going

791
00:30:36,960 --> 00:30:39,600
to put a weird operator here this is

792
00:30:39,600 --> 00:30:42,159
called the spaceship operator it is just

793
00:30:42,159 --> 00:30:44,080
something we can use to test that our

794
00:30:44,080 --> 00:30:46,559
compiler supports it plus plus 20 and

795
00:30:46,559 --> 00:30:48,240
we're going to put a 20 here and then

796
00:30:48,240 --> 00:30:50,880
we're going to try and see if this is

797
00:30:50,880 --> 00:30:53,200
greater than zero and we're going to

798
00:30:53,200 --> 00:30:55,200
print this out we're going to say stdc

799
00:30:55,200 --> 00:30:57,360
out again don't worry if you don't know

800
00:30:57,360 --> 00:30:59,919
what this is this is just a way for us

801
00:30:59,919 --> 00:31:02,240
to test and see if our compiler is going

802
00:31:02,240 --> 00:31:05,200
to be able to use c plus plus 20. we're

803
00:31:05,200 --> 00:31:07,279
going to say result here

804
00:31:07,279 --> 00:31:10,320
and this is going to be our program now

805
00:31:10,320 --> 00:31:12,559
we want to make sure we compile this

806
00:31:12,559 --> 00:31:14,720
program so to bring in your compilers in

807
00:31:14,720 --> 00:31:17,120
visual studio code all you have to do is

808
00:31:17,120 --> 00:31:19,519
come to the terminal menu here so please

809
00:31:19,519 --> 00:31:20,720
come here

810
00:31:20,720 --> 00:31:22,559
and we're going to have

811
00:31:22,559 --> 00:31:25,519
an option to configure tasks i want you

812
00:31:25,519 --> 00:31:27,200
to click on this

813
00:31:27,200 --> 00:31:28,799
and once you do this you're going to see

814
00:31:28,799 --> 00:31:30,720
that visual studio code is going to find

815
00:31:30,720 --> 00:31:33,919
the compilers that we just installed you

816
00:31:33,919 --> 00:31:35,919
see that it has found

817
00:31:35,919 --> 00:31:36,799
the

818
00:31:36,799 --> 00:31:40,000
gcc compiler we installed in mingw you

819
00:31:40,000 --> 00:31:42,960
see that it has found the clan compiler

820
00:31:42,960 --> 00:31:45,200
i know about the g plus plus compiler

821
00:31:45,200 --> 00:31:46,720
because you can see the path here you

822
00:31:46,720 --> 00:31:50,080
can see c major w ben g plus plus dot

823
00:31:50,080 --> 00:31:52,799
exe this is where we installed our g

824
00:31:52,799 --> 00:31:55,279
plus plus compiler and i know about the

825
00:31:55,279 --> 00:31:56,960
clank compiler because that's what's

826
00:31:56,960 --> 00:31:59,120
being found here for example on this

827
00:31:59,120 --> 00:32:02,480
entry here you see it says cmajw bin

828
00:32:02,480 --> 00:32:05,279
clan plus plus so we wanted to configure

829
00:32:05,279 --> 00:32:07,679
these two compilers here and later

830
00:32:07,679 --> 00:32:10,080
visual studio could use them to build

831
00:32:10,080 --> 00:32:12,480
our c plus plus 20 projects

832
00:32:12,480 --> 00:32:14,240
now what we're going to do is click on

833
00:32:14,240 --> 00:32:17,039
the g plus plus compiler first

834
00:32:17,039 --> 00:32:18,880
and when we do that this is going to

835
00:32:18,880 --> 00:32:22,159
create a tasks that json file in our

836
00:32:22,159 --> 00:32:24,640
project and you see that it has created

837
00:32:24,640 --> 00:32:27,679
a folder called dot vs code if i click

838
00:32:27,679 --> 00:32:30,960
on my main cpp file here and do reveal

839
00:32:30,960 --> 00:32:33,440
in explorer

840
00:32:33,440 --> 00:32:35,360
this is going to open up on my system

841
00:32:35,360 --> 00:32:37,600
and you see that this has created a dot

842
00:32:37,600 --> 00:32:40,240
vs code folder and if we go and we're

843
00:32:40,240 --> 00:32:43,360
going to find this tasks.json file this

844
00:32:43,360 --> 00:32:45,120
is going to be our configuration to

845
00:32:45,120 --> 00:32:47,840
configure which compilers that

846
00:32:47,840 --> 00:32:50,080
visual studio code is using to compile

847
00:32:50,080 --> 00:32:53,679
our main.cpp file here so if we go in

848
00:32:53,679 --> 00:32:55,519
it's going to really have everything

849
00:32:55,519 --> 00:32:57,600
ready for us so you're going to see that

850
00:32:57,600 --> 00:32:59,840
it's going to be using our g plus plus

851
00:32:59,840 --> 00:33:03,039
compiler this is the path to it and in

852
00:33:03,039 --> 00:33:05,919
our args options here we have the

853
00:33:05,919 --> 00:33:08,640
options that we pass to the compiler to

854
00:33:08,640 --> 00:33:11,760
compile our program here now i want to

855
00:33:11,760 --> 00:33:13,519
change this to say which kind of

856
00:33:13,519 --> 00:33:15,600
compiler we are using

857
00:33:15,600 --> 00:33:17,760
so we're going to change the level here

858
00:33:17,760 --> 00:33:19,840
to say world width

859
00:33:19,840 --> 00:33:22,080
g plus plus and say the version i think

860
00:33:22,080 --> 00:33:24,399
that's going to be more descriptive here

861
00:33:24,399 --> 00:33:26,960
so we're going to save world with g plus

862
00:33:26,960 --> 00:33:28,960
plus or gcc

863
00:33:28,960 --> 00:33:31,159
and we're going to say

864
00:33:31,159 --> 00:33:34,480
11.2.0 because that's our version here

865
00:33:34,480 --> 00:33:36,240
and the rest is really going to be

866
00:33:36,240 --> 00:33:38,399
enough so let's try and see if we can

867
00:33:38,399 --> 00:33:40,720
compile our program here and see the

868
00:33:40,720 --> 00:33:42,640
thing here printing out

869
00:33:42,640 --> 00:33:43,519
but

870
00:33:43,519 --> 00:33:45,519
the other thing we need to do because

871
00:33:45,519 --> 00:33:48,799
this program is using c plus plus 20 we

872
00:33:48,799 --> 00:33:51,679
need to configure our compiler to use c

873
00:33:51,679 --> 00:33:54,480
plus plus 20. and one way to do that in

874
00:33:54,480 --> 00:33:56,559
gcc and you can really search these

875
00:33:56,559 --> 00:33:58,000
things for example

876
00:33:58,000 --> 00:34:00,480
if we come to our search engine here and

877
00:34:00,480 --> 00:34:04,000
say configure gcc to use c plus plus 20

878
00:34:04,000 --> 00:34:06,240
or even gcc

879
00:34:06,240 --> 00:34:08,720
and say c plus plus 20. you can search

880
00:34:08,720 --> 00:34:11,040
these things and find information and it

881
00:34:11,040 --> 00:34:13,359
is a really good way to test your things

882
00:34:13,359 --> 00:34:14,159
here

883
00:34:14,159 --> 00:34:16,639
so let's see if we can find a link to

884
00:34:16,639 --> 00:34:18,879
help out we have a stack overflow link

885
00:34:18,879 --> 00:34:22,000
here so we can crack this open and if we

886
00:34:22,000 --> 00:34:23,520
go and we're going to find a batch of

887
00:34:23,520 --> 00:34:25,919
things for example we can say std c plus

888
00:34:25,919 --> 00:34:28,079
plus 20 here as an option to our

889
00:34:28,079 --> 00:34:31,200
compiler and this is going to bring

890
00:34:31,200 --> 00:34:33,919
c plus plus 20 support in our gcc

891
00:34:33,919 --> 00:34:36,240
compiler so i am going to copy this

892
00:34:36,240 --> 00:34:38,560
and i am going to come back in my visual

893
00:34:38,560 --> 00:34:40,480
studio code editor

894
00:34:40,480 --> 00:34:43,280
and i am going to pass a flag to boiled

895
00:34:43,280 --> 00:34:45,760
in c plus 20 mode and it is something i

896
00:34:45,760 --> 00:34:48,480
just got from stack overflow here and we

897
00:34:48,480 --> 00:34:50,399
are going to pass this to our compiler

898
00:34:50,399 --> 00:34:52,720
and put a comma to make this a valid

899
00:34:52,720 --> 00:34:54,560
configuration file and i am going to

900
00:34:54,560 --> 00:34:55,760
close this

901
00:34:55,760 --> 00:34:58,400
now once we have this open and we want

902
00:34:58,400 --> 00:35:00,000
to build this we need to bring a

903
00:35:00,000 --> 00:35:01,680
terminal window so we we're going to

904
00:35:01,680 --> 00:35:03,359
bring the terminal window so that we can

905
00:35:03,359 --> 00:35:05,680
see things happening and we do that by

906
00:35:05,680 --> 00:35:07,440
coming to terminal and saying the new

907
00:35:07,440 --> 00:35:09,040
terminal

908
00:35:09,040 --> 00:35:11,760
and we will come back to terminal again

909
00:35:11,760 --> 00:35:14,640
and say that we want to run a task in

910
00:35:14,640 --> 00:35:16,560
this case we're going to be running our

911
00:35:16,560 --> 00:35:20,400
world with gcc 1120 again if you are

912
00:35:20,400 --> 00:35:22,079
using a newer version that's what you

913
00:35:22,079 --> 00:35:25,280
should use and if we click on this thing

914
00:35:25,280 --> 00:35:27,359
please make sure you have the main cpp

915
00:35:27,359 --> 00:35:29,599
file selected before you do this so i

916
00:35:29,599 --> 00:35:31,599
have this selected and i'm going to go

917
00:35:31,599 --> 00:35:34,079
to run task and i am going to click on

918
00:35:34,079 --> 00:35:36,079
this little thing you're going to see

919
00:35:36,079 --> 00:35:37,760
that this is going to kick off the

920
00:35:37,760 --> 00:35:40,640
process to build our program

921
00:35:40,640 --> 00:35:41,920
and we're going to wait for this to

922
00:35:41,920 --> 00:35:43,359
finish and you're going to see that it

923
00:35:43,359 --> 00:35:46,160
is using c plus plus 20 here we're going

924
00:35:46,160 --> 00:35:47,440
to see that the world finished

925
00:35:47,440 --> 00:35:51,200
successfully and we have a main.exe file

926
00:35:51,200 --> 00:35:55,359
created here so if we go in our terminal

927
00:35:55,359 --> 00:35:58,480
in visual studio code and click enter

928
00:35:58,480 --> 00:35:59,359
and

929
00:35:59,359 --> 00:36:01,599
type clear and hit enter this is going

930
00:36:01,599 --> 00:36:03,359
to clear the screen this is something

931
00:36:03,359 --> 00:36:05,920
you can do to clear things out we can

932
00:36:05,920 --> 00:36:09,760
run this main.exe binary directly here

933
00:36:09,760 --> 00:36:12,320
so we're going to run exe here and if

934
00:36:12,320 --> 00:36:14,880
you run it it's going to say zero and

935
00:36:14,880 --> 00:36:17,200
this is an indication that we have our

936
00:36:17,200 --> 00:36:19,839
visual studio code editor connected up

937
00:36:19,839 --> 00:36:22,320
to our gcc compiler and we can use that

938
00:36:22,320 --> 00:36:24,960
to compile c plus plus applications and

939
00:36:24,960 --> 00:36:27,040
this is really the configuration with it

940
00:36:27,040 --> 00:36:30,079
now you may ask how do i know this how

941
00:36:30,079 --> 00:36:32,079
do i did i know the steps to follow to

942
00:36:32,079 --> 00:36:33,760
get this to work

943
00:36:33,760 --> 00:36:36,079
well if you come to extension tab here

944
00:36:36,079 --> 00:36:37,920
and before we even do that i want to

945
00:36:37,920 --> 00:36:39,599
bring to your attention that we have a

946
00:36:39,599 --> 00:36:42,160
bunch of tabs here in visual studio code

947
00:36:42,160 --> 00:36:44,960
we have a tab that says file i think the

948
00:36:44,960 --> 00:36:47,680
one here saying explorer we have a one

949
00:36:47,680 --> 00:36:50,400
we can use for version control if you

950
00:36:50,400 --> 00:36:52,480
use something like git or whatever you

951
00:36:52,480 --> 00:36:54,400
can use this but in this course we're

952
00:36:54,400 --> 00:36:56,400
mostly going to be using the explorer

953
00:36:56,400 --> 00:36:58,800
tab here and the

954
00:36:58,800 --> 00:37:01,359
extensions tab to install things and at

955
00:37:01,359 --> 00:37:03,280
a later time i will show you how to use

956
00:37:03,280 --> 00:37:06,000
the debug tab here or run a debug tab

957
00:37:06,000 --> 00:37:07,520
but in most cases we're going to be

958
00:37:07,520 --> 00:37:10,320
using the explorer tab or the extensions

959
00:37:10,320 --> 00:37:12,240
tab here if you want you can click on

960
00:37:12,240 --> 00:37:14,320
this to close this so that you have some

961
00:37:14,320 --> 00:37:16,480
more space you can click again to bring

962
00:37:16,480 --> 00:37:18,000
this back these are some things you can

963
00:37:18,000 --> 00:37:20,240
do in visual studio code but i am going

964
00:37:20,240 --> 00:37:22,880
to show you how to configure your

965
00:37:22,880 --> 00:37:24,880
compilers where i got the information so

966
00:37:24,880 --> 00:37:27,200
click on extensions here

967
00:37:27,200 --> 00:37:29,200
and we're going to find our cnc plus

968
00:37:29,200 --> 00:37:30,640
plus extension

969
00:37:30,640 --> 00:37:32,960
if we scroll down we're going to find

970
00:37:32,960 --> 00:37:35,760
tutorials on how to set up this on

971
00:37:35,760 --> 00:37:37,839
different compilers for example you can

972
00:37:37,839 --> 00:37:39,440
crack this open

973
00:37:39,440 --> 00:37:41,359
to see how to set up a visual studio

974
00:37:41,359 --> 00:37:44,240
code to use your compiler from microsoft

975
00:37:44,240 --> 00:37:46,640
if we come back we can see a link to see

976
00:37:46,640 --> 00:37:49,440
how to use this with mingw on windows

977
00:37:49,440 --> 00:37:51,680
let's click on this

978
00:37:51,680 --> 00:37:53,920
and let's see what else we have we can

979
00:37:53,920 --> 00:37:56,240
come back to here and we can see how to

980
00:37:56,240 --> 00:37:58,640
use this with gcc on linux or clango on

981
00:37:58,640 --> 00:38:00,560
a mac you can really choose whatever is

982
00:38:00,560 --> 00:38:02,960
relevant for your operating system but

983
00:38:02,960 --> 00:38:05,839
in this case here we are just using the

984
00:38:05,839 --> 00:38:07,520
windows operating system so we're going

985
00:38:07,520 --> 00:38:10,720
to see how to use this with the mingw

986
00:38:10,720 --> 00:38:13,440
compiler that we just installed now we

987
00:38:13,440 --> 00:38:16,480
can use the mingw compiler and i would

988
00:38:16,480 --> 00:38:18,640
recommend reading up on this entire

989
00:38:18,640 --> 00:38:21,040
thing to have an idea on what is

990
00:38:21,040 --> 00:38:24,160
happening we already have our g plus

991
00:38:24,160 --> 00:38:26,240
plus compiler so this is this command is

992
00:38:26,240 --> 00:38:28,160
going to work again if we come back to

993
00:38:28,160 --> 00:38:30,720
terminal here and run g plus plus

994
00:38:30,720 --> 00:38:32,480
version i think we can see that we run

995
00:38:32,480 --> 00:38:34,160
these commands here to see these things

996
00:38:34,160 --> 00:38:37,280
working so we have this step here and if

997
00:38:37,280 --> 00:38:39,359
you wonder what gdb is it is just a

998
00:38:39,359 --> 00:38:41,040
debugger you can use to debug your

999
00:38:41,040 --> 00:38:43,520
programs and again if we come to our

1000
00:38:43,520 --> 00:38:47,200
terminal here and say gdb

1001
00:38:47,200 --> 00:38:48,720
version we're going to have this

1002
00:38:48,720 --> 00:38:51,119
available from our mingw installation

1003
00:38:51,119 --> 00:38:53,359
you can see that we have this here so

1004
00:38:53,359 --> 00:38:55,680
this is working just fine you can really

1005
00:38:55,680 --> 00:38:58,160
follow this and configure your visual

1006
00:38:58,160 --> 00:39:00,640
studio code installation but i am just

1007
00:39:00,640 --> 00:39:02,480
showing you how to do this pretty fast

1008
00:39:02,480 --> 00:39:04,800
you can see that this is what we set up

1009
00:39:04,800 --> 00:39:07,359
in our configuration file which is our

1010
00:39:07,359 --> 00:39:10,720
tasks dot json file now one thing you

1011
00:39:10,720 --> 00:39:14,079
can do is modify the task.json file to

1012
00:39:14,079 --> 00:39:17,040
build every single file in your project

1013
00:39:17,040 --> 00:39:18,480
and this is something that is going to

1014
00:39:18,480 --> 00:39:20,960
make things easier what i'm going to do

1015
00:39:20,960 --> 00:39:23,440
is go back to our visual studio code

1016
00:39:23,440 --> 00:39:25,760
instance and find our project we're

1017
00:39:25,760 --> 00:39:28,560
going to crack open our tasks that json

1018
00:39:28,560 --> 00:39:31,200
file which is living in our dot vs code

1019
00:39:31,200 --> 00:39:32,320
folder

1020
00:39:32,320 --> 00:39:34,640
and i am going to take out the craziness

1021
00:39:34,640 --> 00:39:37,200
i have in my arguments here i am going

1022
00:39:37,200 --> 00:39:39,839
to select everything i am going to

1023
00:39:39,839 --> 00:39:41,200
delete that

1024
00:39:41,200 --> 00:39:43,760
and i am going to put in a configuration

1025
00:39:43,760 --> 00:39:46,000
that i am using for my projects here to

1026
00:39:46,000 --> 00:39:48,560
make this super easy what this is doing

1027
00:39:48,560 --> 00:39:50,640
it is telling the compiler to build in c

1028
00:39:50,640 --> 00:39:53,520
plus plus 20 mode it is going to tell

1029
00:39:53,520 --> 00:39:55,040
visual studio it is going to tell the

1030
00:39:55,040 --> 00:39:57,839
compiler to build every single cpp file

1031
00:39:57,839 --> 00:40:00,240
in our project so if we have multiple

1032
00:40:00,240 --> 00:40:01,680
files they are going to be built

1033
00:40:01,680 --> 00:40:04,079
together and we're going to specify the

1034
00:40:04,079 --> 00:40:06,880
name for our output file for example if

1035
00:40:06,880 --> 00:40:09,040
we don't want our binary executable to

1036
00:40:09,040 --> 00:40:11,920
be named mainly.exe we can give it a

1037
00:40:11,920 --> 00:40:15,200
name and i am going to be naming mine

1038
00:40:15,200 --> 00:40:17,599
rooster.exe in the course here i would

1039
00:40:17,599 --> 00:40:19,359
recommend doing the same so that we can

1040
00:40:19,359 --> 00:40:20,720
really have

1041
00:40:20,720 --> 00:40:23,040
the same habits as we go through the

1042
00:40:23,040 --> 00:40:24,880
course here but of course you are free

1043
00:40:24,880 --> 00:40:26,880
to use whatever you want in your c plus

1044
00:40:26,880 --> 00:40:29,119
plus programs here so once you have this

1045
00:40:29,119 --> 00:40:31,760
you can click save here and this is

1046
00:40:31,760 --> 00:40:33,839
going to save our json file here i can

1047
00:40:33,839 --> 00:40:35,359
close this

1048
00:40:35,359 --> 00:40:37,760
and i am going to bring my terminal by

1049
00:40:37,760 --> 00:40:39,280
going to view

1050
00:40:39,280 --> 00:40:41,280
and the terminal here this is going to

1051
00:40:41,280 --> 00:40:44,160
bring back my terminal that i had before

1052
00:40:44,160 --> 00:40:46,800
and i am going to run the clear command

1053
00:40:46,800 --> 00:40:48,480
and hit enter

1054
00:40:48,480 --> 00:40:51,359
and i am going to do dir to show the

1055
00:40:51,359 --> 00:40:52,400
contents

1056
00:40:52,400 --> 00:40:55,440
of my folder on windows here i wanted to

1057
00:40:55,440 --> 00:40:58,160
remove the main.exe file from the

1058
00:40:58,160 --> 00:41:00,640
terminal here so what i am going to do

1059
00:41:00,640 --> 00:41:03,040
is say rm

1060
00:41:03,040 --> 00:41:05,520
and i am going to say the name of the

1061
00:41:05,520 --> 00:41:07,359
file i want to remove i am going to say

1062
00:41:07,359 --> 00:41:08,240
main

1063
00:41:08,240 --> 00:41:11,359
dot exe and if i hit enter notice what

1064
00:41:11,359 --> 00:41:12,960
is going to happen the file is going to

1065
00:41:12,960 --> 00:41:15,440
go away i don't see it anymore here i

1066
00:41:15,440 --> 00:41:17,440
want to build again using my new

1067
00:41:17,440 --> 00:41:21,040
configurations in my tasks the json file

1068
00:41:21,040 --> 00:41:23,920
i am going to run the task to build with

1069
00:41:23,920 --> 00:41:26,400
our gcc compiler

1070
00:41:26,400 --> 00:41:28,319
this is going to build again and you see

1071
00:41:28,319 --> 00:41:30,480
that it is using the configurations that

1072
00:41:30,480 --> 00:41:32,880
i passed you see that it is building

1073
00:41:32,880 --> 00:41:35,760
every single cpp file in the directory

1074
00:41:35,760 --> 00:41:38,000
here and it is going to generate a

1075
00:41:38,000 --> 00:41:40,800
program called rooster.exe and we if we

1076
00:41:40,800 --> 00:41:42,880
look here we're going to find it we can

1077
00:41:42,880 --> 00:41:45,280
hit enter in the terminal

1078
00:41:45,280 --> 00:41:47,599
and we can type clear to clear things

1079
00:41:47,599 --> 00:41:50,640
out and if we do the ir again we're

1080
00:41:50,640 --> 00:41:53,200
going to see that we have rooster.exe

1081
00:41:53,200 --> 00:41:55,720
and we can run it by doing

1082
00:41:55,720 --> 00:41:58,079
rooster.exe here and this is going to do

1083
00:41:58,079 --> 00:42:00,079
what we want this is really all you need

1084
00:42:00,079 --> 00:42:02,160
to do to connect visual studio code to

1085
00:42:02,160 --> 00:42:05,119
your gcc compiler now we're going to

1086
00:42:05,119 --> 00:42:07,200
connect visual studio code to our clan

1087
00:42:07,200 --> 00:42:09,200
compiler that we have installed we

1088
00:42:09,200 --> 00:42:10,800
really want to be able to use it with

1089
00:42:10,800 --> 00:42:12,319
our project here and we're going to go

1090
00:42:12,319 --> 00:42:14,240
through the seven steps again so we're

1091
00:42:14,240 --> 00:42:15,760
going to go to terminal and say

1092
00:42:15,760 --> 00:42:18,160
configure tasks

1093
00:42:18,160 --> 00:42:19,839
and we're going to choose something that

1094
00:42:19,839 --> 00:42:22,960
says the clanger compiler and we're

1095
00:42:22,960 --> 00:42:26,640
going to find clang plus plus so let's

1096
00:42:26,640 --> 00:42:29,680
hunt for that i have something that says

1097
00:42:29,680 --> 00:42:32,359
that here we have

1098
00:42:32,359 --> 00:42:34,480
cloneplusplus.exe i am going to click on

1099
00:42:34,480 --> 00:42:36,720
that and if i do this this is going to

1100
00:42:36,720 --> 00:42:39,079
add an entry in my

1101
00:42:39,079 --> 00:42:41,599
tasks.json file so watch out for this i

1102
00:42:41,599 --> 00:42:43,280
am going to click on this

1103
00:42:43,280 --> 00:42:46,960
and let's crack this test that json file

1104
00:42:46,960 --> 00:42:48,880
open and you're going to see that this

1105
00:42:48,880 --> 00:42:50,480
is going to also set up another

1106
00:42:50,480 --> 00:42:54,000
configuration to world using my clang

1107
00:42:54,000 --> 00:42:56,160
plus plus compiler

1108
00:42:56,160 --> 00:42:58,160
and again i can edit this out a little

1109
00:42:58,160 --> 00:43:00,800
bit to say what we want let's look at

1110
00:43:00,800 --> 00:43:02,640
the version of cloud we have installed

1111
00:43:02,640 --> 00:43:06,720
to say that out this is going to be 12

1112
00:43:06,720 --> 00:43:07,839
0

1113
00:43:07,839 --> 00:43:10,400
1 so we're going to say world with clank

1114
00:43:10,400 --> 00:43:11,760
plus plus

1115
00:43:11,760 --> 00:43:16,119
12 0 1 let's say that here in our level

1116
00:43:16,119 --> 00:43:19,119
12.0.1 we can say that right here and

1117
00:43:19,119 --> 00:43:20,960
you see that it is really doing the same

1118
00:43:20,960 --> 00:43:23,599
thing we did with our gcc compiler so

1119
00:43:23,599 --> 00:43:26,240
what i can really do is still everything

1120
00:43:26,240 --> 00:43:29,680
i did in my gcc compiler i can

1121
00:43:29,680 --> 00:43:30,960
copy this

1122
00:43:30,960 --> 00:43:33,359
and i am going to take out the arguments

1123
00:43:33,359 --> 00:43:36,800
i have in my args here and i use what i

1124
00:43:36,800 --> 00:43:39,359
have in my gcc compiler you can see that

1125
00:43:39,359 --> 00:43:41,359
you can use the client compiler and the

1126
00:43:41,359 --> 00:43:44,000
gcc compiler in the same way and this is

1127
00:43:44,000 --> 00:43:46,560
something really cool so now we have the

1128
00:43:46,560 --> 00:43:48,560
option to use two compilers and this is

1129
00:43:48,560 --> 00:43:50,720
really cool so we're going to close the

1130
00:43:50,720 --> 00:43:52,480
json file and it's going to be saved

1131
00:43:52,480 --> 00:43:54,480
automatically

1132
00:43:54,480 --> 00:43:56,480
and we're going to bring up our terminal

1133
00:43:56,480 --> 00:43:58,000
window again

1134
00:43:58,000 --> 00:44:00,160
and let's bring this up a little bit and

1135
00:44:00,160 --> 00:44:03,359
we're going to do dir on windows and

1136
00:44:03,359 --> 00:44:05,599
we're going to remove the binary again

1137
00:44:05,599 --> 00:44:08,480
we're going to remove roster.exe

1138
00:44:08,480 --> 00:44:10,400
and again what you can do you can start

1139
00:44:10,400 --> 00:44:12,240
typing the name of the file you want to

1140
00:44:12,240 --> 00:44:15,119
remove and hit tab if you do that the

1141
00:44:15,119 --> 00:44:16,800
terminal is going to autocomplete this

1142
00:44:16,800 --> 00:44:18,960
for you and this is really cool so if i

1143
00:44:18,960 --> 00:44:20,880
do this the file is going to go away you

1144
00:44:20,880 --> 00:44:23,440
see that it is going right here

1145
00:44:23,440 --> 00:44:25,200
and i can clear

1146
00:44:25,200 --> 00:44:27,040
and what i am going to do is world with

1147
00:44:27,040 --> 00:44:29,359
the clan compiler can do that by coming

1148
00:44:29,359 --> 00:44:31,839
to terminal i am going to say that i

1149
00:44:31,839 --> 00:44:34,720
want to run a task and i am going to be

1150
00:44:34,720 --> 00:44:37,119
given an option i can either build with

1151
00:44:37,119 --> 00:44:39,359
gcc so if i choose gcc here it's going

1152
00:44:39,359 --> 00:44:42,640
to be used but i can also use clan let's

1153
00:44:42,640 --> 00:44:44,640
use clang here so i'm going to click on

1154
00:44:44,640 --> 00:44:46,160
this

1155
00:44:46,160 --> 00:44:47,599
and you're going to see that visual

1156
00:44:47,599 --> 00:44:49,280
studio code is going to kick off the

1157
00:44:49,280 --> 00:44:50,400
world process

1158
00:44:50,400 --> 00:44:52,160
this is going to build my binary

1159
00:44:52,160 --> 00:44:54,720
executable and notice that it is using c

1160
00:44:54,720 --> 00:44:56,960
plus plus 20 again the build is going to

1161
00:44:56,960 --> 00:44:58,800
finish successfully and i will have a

1162
00:44:58,800 --> 00:45:00,640
binary here and this is going to be all

1163
00:45:00,640 --> 00:45:04,000
i need to do so if i hit enter and run

1164
00:45:04,000 --> 00:45:07,920
my binary by tapping the name

1165
00:45:07,920 --> 00:45:10,000
and hitting tab this is going to

1166
00:45:10,000 --> 00:45:12,079
auto-complete if i run it it's going to

1167
00:45:12,079 --> 00:45:14,640
say zero and this is what we expect here

1168
00:45:14,640 --> 00:45:16,400
if you have some kind of error please

1169
00:45:16,400 --> 00:45:18,480
try and fix it if you have a problem you

1170
00:45:18,480 --> 00:45:20,640
can ask me and i will do the best i can

1171
00:45:20,640 --> 00:45:22,240
to help you out

1172
00:45:22,240 --> 00:45:24,000
okay now we have our two compilers

1173
00:45:24,000 --> 00:45:26,240
working we need to configure the

1174
00:45:26,240 --> 00:45:29,359
compiler from microsoft now the compiler

1175
00:45:29,359 --> 00:45:31,359
from microsoft is a little bit weird

1176
00:45:31,359 --> 00:45:33,359
again you can read up on this by coming

1177
00:45:33,359 --> 00:45:35,599
to your extension documentation

1178
00:45:35,599 --> 00:45:37,760
and going to using the compiler from

1179
00:45:37,760 --> 00:45:39,920
microsoft with visual studio code on

1180
00:45:39,920 --> 00:45:41,680
windows you can read up on all this if

1181
00:45:41,680 --> 00:45:43,839
you want but i am just going to show you

1182
00:45:43,839 --> 00:45:46,160
a quick way to get this running so the

1183
00:45:46,160 --> 00:45:48,560
compiler from microsoft is special in

1184
00:45:48,560 --> 00:45:51,359
that you have to specify the path to it

1185
00:45:51,359 --> 00:45:53,440
for example if we open a regular

1186
00:45:53,440 --> 00:45:55,160
terminal window and say

1187
00:45:55,160 --> 00:45:58,319
cl.exe to call the compiler

1188
00:45:58,319 --> 00:45:59,839
we're going to see that the terminal is

1189
00:45:59,839 --> 00:46:01,480
going to say that the

1190
00:46:01,480 --> 00:46:04,880
cl.exe compiler is not recognized and

1191
00:46:04,880 --> 00:46:07,119
the reason is we don't have the proper

1192
00:46:07,119 --> 00:46:09,520
environment variable settings for the

1193
00:46:09,520 --> 00:46:11,839
operating system to find this compiler

1194
00:46:11,839 --> 00:46:14,160
when we call it right here we are able

1195
00:46:14,160 --> 00:46:16,560
to use g plus plus and clan because we

1196
00:46:16,560 --> 00:46:19,040
put the environment variables in place

1197
00:46:19,040 --> 00:46:20,720
if you remember when we installed them

1198
00:46:20,720 --> 00:46:22,400
we did something like this we came to

1199
00:46:22,400 --> 00:46:25,440
the start menu and did env we came to

1200
00:46:25,440 --> 00:46:28,000
environment variables here and we put

1201
00:46:28,000 --> 00:46:29,200
the path

1202
00:46:29,200 --> 00:46:32,160
to our compilers in our environment

1203
00:46:32,160 --> 00:46:33,920
variables here you can see them right

1204
00:46:33,920 --> 00:46:36,160
here so we don't have the same thing for

1205
00:46:36,160 --> 00:46:37,920
the compiler from microsoft and that's

1206
00:46:37,920 --> 00:46:40,079
for a reason because we may have

1207
00:46:40,079 --> 00:46:42,000
multiple compilers installed from

1208
00:46:42,000 --> 00:46:43,359
microsoft

1209
00:46:43,359 --> 00:46:45,440
then if you have multiple compilers it

1210
00:46:45,440 --> 00:46:47,200
would be really cumbersome to choose

1211
00:46:47,200 --> 00:46:49,839
which compiler you want the guys at

1212
00:46:49,839 --> 00:46:52,480
microsoft opted for the option for you

1213
00:46:52,480 --> 00:46:54,800
the developer to specify which compiler

1214
00:46:54,800 --> 00:46:57,680
you want to run by coming to the start

1215
00:46:57,680 --> 00:47:00,480
menu here and typing developer

1216
00:47:00,480 --> 00:47:02,560
and choose which powershell for the

1217
00:47:02,560 --> 00:47:04,960
compiler you want to use for example if

1218
00:47:04,960 --> 00:47:07,359
we want to use the visual studio 2019

1219
00:47:07,359 --> 00:47:09,599
compiler we can click on this and then

1220
00:47:09,599 --> 00:47:11,520
we will have a terminal

1221
00:47:11,520 --> 00:47:13,119
that can run

1222
00:47:13,119 --> 00:47:15,359
the c plus plus compiler from microsoft

1223
00:47:15,359 --> 00:47:17,440
for example if we wait for this to be

1224
00:47:17,440 --> 00:47:20,880
ready and say cl.exe

1225
00:47:20,880 --> 00:47:22,160
we're going to see that we're going to

1226
00:47:22,160 --> 00:47:23,920
have a message saying that this is our

1227
00:47:23,920 --> 00:47:26,240
compiler we can use it however we want

1228
00:47:26,240 --> 00:47:28,079
so what we're going to do is set up a

1229
00:47:28,079 --> 00:47:30,880
terminal like this and use this terminal

1230
00:47:30,880 --> 00:47:33,040
to start visual studio code and the

1231
00:47:33,040 --> 00:47:34,880
visual studio code is going to start in

1232
00:47:34,880 --> 00:47:36,079
the mode

1233
00:47:36,079 --> 00:47:38,000
where it can find the compiler from

1234
00:47:38,000 --> 00:47:40,000
microsoft i know this is confusing but

1235
00:47:40,000 --> 00:47:41,839
please bear with me this is what we need

1236
00:47:41,839 --> 00:47:44,559
to do to get this to work if we start

1237
00:47:44,559 --> 00:47:46,559
visual studio code in a mode where it

1238
00:47:46,559 --> 00:47:48,720
knows about the environment variables

1239
00:47:48,720 --> 00:47:51,920
for the compiler from microsoft we will

1240
00:47:51,920 --> 00:47:54,800
have the ability to say cl.exe

1241
00:47:54,800 --> 00:47:56,880
and we will be able to use that right

1242
00:47:56,880 --> 00:47:58,880
here but you see that it is not

1243
00:47:58,880 --> 00:48:01,359
recognized now but we can use the g plus

1244
00:48:01,359 --> 00:48:03,359
plus compiler if we do this

1245
00:48:03,359 --> 00:48:04,480
version

1246
00:48:04,480 --> 00:48:05,839
we're going to see that it's available

1247
00:48:05,839 --> 00:48:08,480
we can use it we can use clan plus plus

1248
00:48:08,480 --> 00:48:10,960
and if we do version as well we're going

1249
00:48:10,960 --> 00:48:12,720
to see that we can use this little guy

1250
00:48:12,720 --> 00:48:15,119
here we also want the ability to use the

1251
00:48:15,119 --> 00:48:17,760
compiler from microsoft but to have

1252
00:48:17,760 --> 00:48:20,079
access to that we will have to close the

1253
00:48:20,079 --> 00:48:22,640
visual studio code instance we have here

1254
00:48:22,640 --> 00:48:24,160
and we're going to come back to our

1255
00:48:24,160 --> 00:48:27,040
project let's see if i can find it here

1256
00:48:27,040 --> 00:48:28,559
so we're going to go to the location

1257
00:48:28,559 --> 00:48:30,720
where we have our project and we're

1258
00:48:30,720 --> 00:48:32,319
going to change to the location of the

1259
00:48:32,319 --> 00:48:34,720
project here so i can grab the location

1260
00:48:34,720 --> 00:48:37,440
from my visual studio code project that

1261
00:48:37,440 --> 00:48:39,839
i just set up i am going to come back to

1262
00:48:39,839 --> 00:48:41,920
my powershell window that knows about

1263
00:48:41,920 --> 00:48:44,079
the path to the c plus plus compiler

1264
00:48:44,079 --> 00:48:46,800
from microsoft and i am going to change

1265
00:48:46,800 --> 00:48:49,200
it to the location of my project here so

1266
00:48:49,200 --> 00:48:51,280
i am going to say cd and paste in the

1267
00:48:51,280 --> 00:48:53,920
path i just copied and if i hit enter

1268
00:48:53,920 --> 00:48:56,000
this is going to change to my location

1269
00:48:56,000 --> 00:48:58,240
and i really recommend using powershell

1270
00:48:58,240 --> 00:49:00,240
if you have access to this because it is

1271
00:49:00,240 --> 00:49:02,400
a little more convenient to use it

1272
00:49:02,400 --> 00:49:05,200
supports more commands that you can use

1273
00:49:05,200 --> 00:49:07,599
in the command prompt but again that's

1274
00:49:07,599 --> 00:49:10,240
going to be your choice now i am in the

1275
00:49:10,240 --> 00:49:13,280
location for my project if i do ls or

1276
00:49:13,280 --> 00:49:14,960
dir

1277
00:49:14,960 --> 00:49:17,040
you can see that i can see my main cpp

1278
00:49:17,040 --> 00:49:19,040
file can see the binary we generated

1279
00:49:19,040 --> 00:49:22,079
earlier but this is not problem so what

1280
00:49:22,079 --> 00:49:24,800
i can do here is say code

1281
00:49:24,800 --> 00:49:27,040
and i say a dot and this is going to

1282
00:49:27,040 --> 00:49:29,680
start visual studio code in the current

1283
00:49:29,680 --> 00:49:32,480
folder of our project year so if you hit

1284
00:49:32,480 --> 00:49:34,160
enter we're going to wait for visual

1285
00:49:34,160 --> 00:49:36,079
studio code to come up it is going to

1286
00:49:36,079 --> 00:49:38,240
come up with the project we had in that

1287
00:49:38,240 --> 00:49:39,280
folder

1288
00:49:39,280 --> 00:49:41,359
and the special thing about

1289
00:49:41,359 --> 00:49:43,680
starting visual studio code this way is

1290
00:49:43,680 --> 00:49:45,040
that it's going to know about the

1291
00:49:45,040 --> 00:49:47,520
compiler from microsoft if we come back

1292
00:49:47,520 --> 00:49:49,359
to our terminal here

1293
00:49:49,359 --> 00:49:52,160
and clear and say cl.exe

1294
00:49:52,160 --> 00:49:53,839
you're going to see that now it knows

1295
00:49:53,839 --> 00:49:56,079
about the compiler from microsoft and we

1296
00:49:56,079 --> 00:49:58,559
can use it to do things so let's set

1297
00:49:58,559 --> 00:50:00,400
this up again if you want you can read

1298
00:50:00,400 --> 00:50:02,720
up on how to do this

1299
00:50:02,720 --> 00:50:05,200
on the documentation from visual studio

1300
00:50:05,200 --> 00:50:07,280
code itself but again i am going to show

1301
00:50:07,280 --> 00:50:08,880
you how to do this you can see that it

1302
00:50:08,880 --> 00:50:11,200
is really the same things they are doing

1303
00:50:11,200 --> 00:50:13,359
here so let's come back to visual studio

1304
00:50:13,359 --> 00:50:15,520
code and we're going to go to terminal

1305
00:50:15,520 --> 00:50:18,400
and we want to configure a task

1306
00:50:18,400 --> 00:50:20,720
now you see that we have the compiler

1307
00:50:20,720 --> 00:50:22,559
from microsoft available you can see

1308
00:50:22,559 --> 00:50:25,520
that we can use that right here so what

1309
00:50:25,520 --> 00:50:28,599
i am going to do is click on

1310
00:50:28,599 --> 00:50:31,359
cl.exe world active file

1311
00:50:31,359 --> 00:50:33,359
and this is going to add a new entry in

1312
00:50:33,359 --> 00:50:35,760
our configuration file and it is going

1313
00:50:35,760 --> 00:50:37,920
to open up if we go here we are going to

1314
00:50:37,920 --> 00:50:40,800
find that we have a command to build

1315
00:50:40,800 --> 00:50:43,200
using the compiler from microsoft so

1316
00:50:43,200 --> 00:50:45,359
let's change the level here and i say

1317
00:50:45,359 --> 00:50:48,319
world with msvc i think this is going to

1318
00:50:48,319 --> 00:50:50,720
be more descriptive and this is really

1319
00:50:50,720 --> 00:50:52,880
going to build your thing now i am going

1320
00:50:52,880 --> 00:50:55,200
to change this up so that it works

1321
00:50:55,200 --> 00:50:57,599
everything in the current folder

1322
00:50:57,599 --> 00:50:59,920
and again i am going to remove

1323
00:50:59,920 --> 00:51:01,359
everything here and put in a

1324
00:51:01,359 --> 00:51:03,599
configuration that i have ready on my

1325
00:51:03,599 --> 00:51:05,760
system here this is what i use for all

1326
00:51:05,760 --> 00:51:08,079
my projects again this is just calling

1327
00:51:08,079 --> 00:51:10,319
the compiler and giving it options to do

1328
00:51:10,319 --> 00:51:12,720
things we just need to specify that we

1329
00:51:12,720 --> 00:51:14,720
want to use the lattice standard of the

1330
00:51:14,720 --> 00:51:17,280
c plus plus standard and it is going to

1331
00:51:17,280 --> 00:51:18,640
specify

1332
00:51:18,640 --> 00:51:20,240
the input files we're going to be

1333
00:51:20,240 --> 00:51:22,000
building everything in the current

1334
00:51:22,000 --> 00:51:24,400
folder this is what we are saying here

1335
00:51:24,400 --> 00:51:26,160
and the output file is going to be

1336
00:51:26,160 --> 00:51:28,480
called rooster.exe

1337
00:51:28,480 --> 00:51:31,520
if we save this by saying ctrl s or

1338
00:51:31,520 --> 00:51:33,119
command s

1339
00:51:33,119 --> 00:51:36,559
and close our tasks dot json file we can

1340
00:51:36,559 --> 00:51:38,720
bring up our terminal window by going to

1341
00:51:38,720 --> 00:51:41,200
view and saying the terminal here

1342
00:51:41,200 --> 00:51:44,319
and we can go down and clear we can say

1343
00:51:44,319 --> 00:51:46,319
clear and hit enter

1344
00:51:46,319 --> 00:51:50,960
and if we do rm and say rooster and hit

1345
00:51:50,960 --> 00:51:52,800
tab this is going to remove the binary

1346
00:51:52,800 --> 00:51:55,760
we generated with the clang llvm

1347
00:51:55,760 --> 00:51:58,559
compiler earlier now we want to build

1348
00:51:58,559 --> 00:52:01,040
with the compiler from microsoft so

1349
00:52:01,040 --> 00:52:02,559
let's do this we're going to say

1350
00:52:02,559 --> 00:52:04,640
terminal and we're going to say that we

1351
00:52:04,640 --> 00:52:07,680
want to run a task but this time we want

1352
00:52:07,680 --> 00:52:10,400
to build with msvc this is what we want

1353
00:52:10,400 --> 00:52:12,640
to do here if we click on this little

1354
00:52:12,640 --> 00:52:14,160
thing we're going to kick off the

1355
00:52:14,160 --> 00:52:16,680
process to build with the compiler from

1356
00:52:16,680 --> 00:52:18,880
microsoft and we're going to wait for

1357
00:52:18,880 --> 00:52:21,760
the compiler to do its thing

1358
00:52:21,760 --> 00:52:23,440
and if we wait we're going to see that

1359
00:52:23,440 --> 00:52:25,680
the world finished successfully and if

1360
00:52:25,680 --> 00:52:27,119
we look in our folder we're going to see

1361
00:52:27,119 --> 00:52:30,000
that we have our output file and we can

1362
00:52:30,000 --> 00:52:32,319
come in our terminal and hit to enter

1363
00:52:32,319 --> 00:52:34,960
and do clear to clear things up and if

1364
00:52:34,960 --> 00:52:38,319
we say rooster just like this

1365
00:52:38,319 --> 00:52:39,920
and hit enter you're going to see that

1366
00:52:39,920 --> 00:52:43,119
it's going to say zero and this is

1367
00:52:43,119 --> 00:52:46,400
confirmation that we are able to use our

1368
00:52:46,400 --> 00:52:49,119
visual studio code editor and be able to

1369
00:52:49,119 --> 00:52:51,520
use it with all kinds of crazy compilers

1370
00:52:51,520 --> 00:52:53,839
and this is really cool if you are on

1371
00:52:53,839 --> 00:52:56,240
windows i recommend setting this up

1372
00:52:56,240 --> 00:52:57,760
because it's it's going to make it

1373
00:52:57,760 --> 00:53:00,400
easier to run a c plus plus applications

1374
00:53:00,400 --> 00:53:02,079
from visual studio code using

1375
00:53:02,079 --> 00:53:04,880
state-of-the-art compilers like msvc

1376
00:53:04,880 --> 00:53:07,280
clone and gcc here and this is really

1377
00:53:07,280 --> 00:53:09,839
cool now we have everything we need to

1378
00:53:09,839 --> 00:53:12,240
start running c plus plus applications

1379
00:53:12,240 --> 00:53:14,319
but before i let you go let's show you

1380
00:53:14,319 --> 00:53:16,160
how you can set this up so that you have

1381
00:53:16,160 --> 00:53:18,960
an easier time with regards to

1382
00:53:18,960 --> 00:53:21,119
intellisense and whatever so what we're

1383
00:53:21,119 --> 00:53:22,720
going to do we're going to go to our

1384
00:53:22,720 --> 00:53:24,400
view menu and we're going to choose

1385
00:53:24,400 --> 00:53:25,920
command palette

1386
00:53:25,920 --> 00:53:28,880
and in this we're going to say c or c

1387
00:53:28,880 --> 00:53:30,319
plus plus

1388
00:53:30,319 --> 00:53:32,480
we can say something like this and we're

1389
00:53:32,480 --> 00:53:35,040
going to choose edit configuration ui

1390
00:53:35,040 --> 00:53:36,720
this is going to give us an option to

1391
00:53:36,720 --> 00:53:38,079
configure things

1392
00:53:38,079 --> 00:53:40,000
and i want you to configure things your

1393
00:53:40,000 --> 00:53:41,359
new system

1394
00:53:41,359 --> 00:53:43,920
so i am on a windows system

1395
00:53:43,920 --> 00:53:46,480
let's see the options we have here i am

1396
00:53:46,480 --> 00:53:49,280
only going to have the option for win32

1397
00:53:49,280 --> 00:53:52,880
but if we go down we can specify

1398
00:53:52,880 --> 00:53:54,640
the things we need

1399
00:53:54,640 --> 00:53:56,559
visual studio code configured for for

1400
00:53:56,559 --> 00:53:57,839
example it's going to give us

1401
00:53:57,839 --> 00:54:00,079
intellisense or autocomplete and all

1402
00:54:00,079 --> 00:54:02,000
kinds of greater things using the

1403
00:54:02,000 --> 00:54:04,240
setting we choose here if we want we can

1404
00:54:04,240 --> 00:54:06,960
choose the gcc compiler or whatever i am

1405
00:54:06,960 --> 00:54:08,960
just going to leave in the windows msvc

1406
00:54:08,960 --> 00:54:11,359
compiler because i am on windows here

1407
00:54:11,359 --> 00:54:13,359
but know that you can configure these

1408
00:54:13,359 --> 00:54:15,200
things now if we go down we're going to

1409
00:54:15,200 --> 00:54:17,359
see that we have the option to configure

1410
00:54:17,359 --> 00:54:20,000
the c plus plus standard and the

1411
00:54:20,000 --> 00:54:22,079
compiler path that is going to be used

1412
00:54:22,079 --> 00:54:23,599
to figure things out we're going to be

1413
00:54:23,599 --> 00:54:26,079
using the compiler from microsoft here

1414
00:54:26,079 --> 00:54:27,760
but know that you have the option to

1415
00:54:27,760 --> 00:54:29,839
choose any other compiler for example we

1416
00:54:29,839 --> 00:54:31,520
can choose the g plus plus compiler we

1417
00:54:31,520 --> 00:54:33,599
can choose the clank plus class compiler

1418
00:54:33,599 --> 00:54:35,599
you can configure these things and if

1419
00:54:35,599 --> 00:54:37,359
you need to change this please come back

1420
00:54:37,359 --> 00:54:40,079
here and do these configurations here

1421
00:54:40,079 --> 00:54:41,440
we're going to leave in this whole

1422
00:54:41,440 --> 00:54:43,839
intellisense and what we will do

1423
00:54:43,839 --> 00:54:46,720
is configure visual studio code to use

1424
00:54:46,720 --> 00:54:49,040
the c plus plus 20 standard so we're

1425
00:54:49,040 --> 00:54:50,839
going to do that right

1426
00:54:50,839 --> 00:54:53,520
here and if you set this up you're going

1427
00:54:53,520 --> 00:54:55,359
to see that visual studio code is going

1428
00:54:55,359 --> 00:54:58,160
to generate a cpp properties

1429
00:54:58,160 --> 00:55:00,559
file which is going to store all these

1430
00:55:00,559 --> 00:55:02,480
configurations here so it is really

1431
00:55:02,480 --> 00:55:03,760
going to be

1432
00:55:03,760 --> 00:55:06,319
a configuration for what we choose in

1433
00:55:06,319 --> 00:55:08,559
our configuration here so make sure you

1434
00:55:08,559 --> 00:55:10,319
choose what makes sense again i would

1435
00:55:10,319 --> 00:55:12,720
recommend using c plus plus 20 but if

1436
00:55:12,720 --> 00:55:14,400
you go on top you can really use any

1437
00:55:14,400 --> 00:55:16,160
compiler you want i am going to use the

1438
00:55:16,160 --> 00:55:18,559
compiler from microsoft this is okay i

1439
00:55:18,559 --> 00:55:20,240
am going to use windows msvc

1440
00:55:20,240 --> 00:55:22,559
configuration for intellisense here and

1441
00:55:22,559 --> 00:55:24,559
i am going to close this and we are

1442
00:55:24,559 --> 00:55:26,400
really ready to start using visual

1443
00:55:26,400 --> 00:55:28,880
studio code to ride c plus plus

1444
00:55:28,880 --> 00:55:31,040
application so let's clean this up a

1445
00:55:31,040 --> 00:55:32,799
little bit we're going to view our

1446
00:55:32,799 --> 00:55:35,119
terminal and we're going to remove the

1447
00:55:35,119 --> 00:55:37,920
junk that was generated by the compiler

1448
00:55:37,920 --> 00:55:40,720
from microsoft i am going to say rm and

1449
00:55:40,720 --> 00:55:42,559
say rooster

1450
00:55:42,559 --> 00:55:46,400
and i can remove the binary i can say rm

1451
00:55:46,400 --> 00:55:48,559
and say rooster and say tab this is

1452
00:55:48,559 --> 00:55:51,040
going to autocomplete and really remove

1453
00:55:51,040 --> 00:55:53,119
things i don't need i am going to remove

1454
00:55:53,119 --> 00:55:56,000
the pdb file i am going to remove

1455
00:55:56,000 --> 00:55:57,680
rooster

1456
00:55:57,680 --> 00:56:00,319
you know i am going to remove the main

1457
00:56:00,319 --> 00:56:04,640
object file so let's say main dot obj

1458
00:56:04,640 --> 00:56:07,599
and i am going to remove main dot

1459
00:56:07,599 --> 00:56:10,640
or vc we don't want to remove our cpd

1460
00:56:10,640 --> 00:56:13,599
file so now we have a project we can use

1461
00:56:13,599 --> 00:56:16,240
as a starting point to write c and c

1462
00:56:16,240 --> 00:56:19,040
plus plus applications here so what we

1463
00:56:19,040 --> 00:56:21,520
will be doing in the next few lectures

1464
00:56:21,520 --> 00:56:24,720
or the next few chapters is reusing

1465
00:56:24,720 --> 00:56:28,480
this thing here as a template project so

1466
00:56:28,480 --> 00:56:31,440
what i can do is uh call this

1467
00:56:31,440 --> 00:56:34,720
c plus plus 20 template project and

1468
00:56:34,720 --> 00:56:36,160
let's do this here i think i need to

1469
00:56:36,160 --> 00:56:37,839
close video studio code otherwise it's

1470
00:56:37,839 --> 00:56:40,079
going to complain so i am going to call

1471
00:56:40,079 --> 00:56:43,040
this little guy c plus plus 20 template

1472
00:56:43,040 --> 00:56:44,799
project and

1473
00:56:44,799 --> 00:56:46,559
later when we start learning about c

1474
00:56:46,559 --> 00:56:48,559
plus plus proper we're going to be using

1475
00:56:48,559 --> 00:56:50,640
this as a starting point and we want to

1476
00:56:50,640 --> 00:56:52,960
have to reconfigure the compilers our

1477
00:56:52,960 --> 00:56:55,599
project will be ready to use

1478
00:56:55,599 --> 00:56:58,079
the compilers that we set up here namely

1479
00:56:58,079 --> 00:57:00,799
the compiler from microsoft the g plus

1480
00:57:00,799 --> 00:57:03,040
plus compiler and the clang plus plus

1481
00:57:03,040 --> 00:57:05,200
compiler and that's going to be really

1482
00:57:05,200 --> 00:57:07,440
cool this is really all i have to share

1483
00:57:07,440 --> 00:57:09,200
in this lecture i hope you have visual

1484
00:57:09,200 --> 00:57:10,960
studio code set up to use all these

1485
00:57:10,960 --> 00:57:13,200
compilers we are going to stop here in

1486
00:57:13,200 --> 00:57:15,119
this lecture the next one we're going to

1487
00:57:15,119 --> 00:57:16,880
start and see how to set up your

1488
00:57:16,880 --> 00:57:19,280
development environment on linux and

1489
00:57:19,280 --> 00:57:20,960
we're going to start by installing

1490
00:57:20,960 --> 00:57:24,880
compilers on ubuntu 2004

1491
00:57:24,880 --> 00:57:27,040
go ahead and finish up here and meet me

1492
00:57:27,040 --> 00:57:29,119
there in this lecture we're going to see

1493
00:57:29,119 --> 00:57:31,920
how to install c plus plus compilers on

1494
00:57:31,920 --> 00:57:34,640
linux we are going to be working on an

1495
00:57:34,640 --> 00:57:38,799
ubuntu 2004 system and we will install a

1496
00:57:38,799 --> 00:57:42,079
new version of gcc and the latest

1497
00:57:42,079 --> 00:57:44,559
version i can get my hands on for clang

1498
00:57:44,559 --> 00:57:47,839
llvm so let's do this okay so here i am

1499
00:57:47,839 --> 00:57:52,240
on my linux box this is ubuntu 2004 if i

1500
00:57:52,240 --> 00:57:55,440
do you name and say a

1501
00:57:55,440 --> 00:57:56,880
we're going to see the information on

1502
00:57:56,880 --> 00:57:57,680
this

1503
00:57:57,680 --> 00:57:59,839
and you will have to adapt this for

1504
00:57:59,839 --> 00:58:02,960
whatever linux distribution you are on

1505
00:58:02,960 --> 00:58:05,680
and to install gcc it's really simple

1506
00:58:05,680 --> 00:58:08,160
but the problem is the latest version of

1507
00:58:08,160 --> 00:58:10,559
gcc at the time of recording this video

1508
00:58:10,559 --> 00:58:13,760
is gcc 11 and it's not available in the

1509
00:58:13,760 --> 00:58:16,319
ubuntu packages now for example if you

1510
00:58:16,319 --> 00:58:17,920
do see do

1511
00:58:17,920 --> 00:58:20,079
apt get install

1512
00:58:20,079 --> 00:58:22,480
gcc 11

1513
00:58:22,480 --> 00:58:24,799
this is how you get it

1514
00:58:24,799 --> 00:58:26,880
if you do this

1515
00:58:26,880 --> 00:58:28,319
you're going to put in your password

1516
00:58:28,319 --> 00:58:30,240
you're going to see that this is really

1517
00:58:30,240 --> 00:58:33,119
not available yet right we cannot find

1518
00:58:33,119 --> 00:58:36,160
this so the best version we can install

1519
00:58:36,160 --> 00:58:38,319
is gcc 10 which i happen to have

1520
00:58:38,319 --> 00:58:40,480
installed already on this system so

1521
00:58:40,480 --> 00:58:43,040
we're going to do gcc 10 that's what

1522
00:58:43,040 --> 00:58:44,880
we're going to install here

1523
00:58:44,880 --> 00:58:46,400
and if we do this we're going to see

1524
00:58:46,400 --> 00:58:48,079
that this is already available you can

1525
00:58:48,079 --> 00:58:50,559
also install g plus plus done i think

1526
00:58:50,559 --> 00:58:52,160
you can do that

1527
00:58:52,160 --> 00:58:53,680
okay so we're going to run the command

1528
00:58:53,680 --> 00:58:56,480
here and we're also going to see that

1529
00:58:56,480 --> 00:58:58,480
it's already available here but if you

1530
00:58:58,480 --> 00:59:00,240
don't have these

1531
00:59:00,240 --> 00:59:02,079
they are going to be installed and you

1532
00:59:02,079 --> 00:59:04,480
can use them on your linux system

1533
00:59:04,480 --> 00:59:07,040
another tool that is necessary on linux

1534
00:59:07,040 --> 00:59:09,520
is the gdb debugger so we're going to do

1535
00:59:09,520 --> 00:59:12,079
sudo apt

1536
00:59:12,079 --> 00:59:13,839
get install

1537
00:59:13,839 --> 00:59:15,440
gtb

1538
00:59:15,440 --> 00:59:17,359
right if you install it it's going to be

1539
00:59:17,359 --> 00:59:19,200
installed but i already have it

1540
00:59:19,200 --> 00:59:23,040
installed already so now if i do gcc 10

1541
00:59:23,040 --> 00:59:25,839
on my system here and say version we're

1542
00:59:25,839 --> 00:59:27,520
going to see the version printed out we

1543
00:59:27,520 --> 00:59:29,599
can do g plus plus stand we can see the

1544
00:59:29,599 --> 00:59:32,400
version here let's do that for c plus

1545
00:59:32,400 --> 00:59:34,480
plus

1546
00:59:34,480 --> 00:59:36,000
so we're going to see the version here

1547
00:59:36,000 --> 00:59:40,000
we can even do gdb version

1548
00:59:40,640 --> 00:59:42,400
and it is going to show up let's wait

1549
00:59:42,400 --> 00:59:44,319
for this we're going to see my gdp

1550
00:59:44,319 --> 00:59:46,880
version here and now i can use these

1551
00:59:46,880 --> 00:59:50,000
compilers to compile c plus plus code on

1552
00:59:50,000 --> 00:59:53,119
my linux box here so this completes our

1553
00:59:53,119 --> 00:59:56,319
steps to install a gcc compiler on linux

1554
00:59:56,319 --> 00:59:57,920
we're going to look at how we can get a

1555
00:59:57,920 --> 01:00:00,559
hold of the clang compiler

1556
01:00:00,559 --> 01:00:03,040
on our linux box here and it is really

1557
01:00:03,040 --> 01:00:05,359
simple all you have to do is to do

1558
01:00:05,359 --> 01:00:07,599
apt get install

1559
01:00:07,599 --> 01:00:10,160
and we're going to install clang 12

1560
01:00:10,160 --> 01:00:12,160
because that's the latest version at the

1561
01:00:12,160 --> 01:00:14,480
time of recording this video if we do

1562
01:00:14,480 --> 01:00:15,920
this we're going to see that it's going

1563
01:00:15,920 --> 01:00:17,920
to install i already have it installed

1564
01:00:17,920 --> 01:00:20,079
here but if you don't have it installed

1565
01:00:20,079 --> 01:00:22,319
it's going to install on your system and

1566
01:00:22,319 --> 01:00:24,160
this is going to give you all the tools

1567
01:00:24,160 --> 01:00:26,000
you need to compile with the clan

1568
01:00:26,000 --> 01:00:28,559
compiler on this particular ubuntu

1569
01:00:28,559 --> 01:00:30,559
system these installs are going to be

1570
01:00:30,559 --> 01:00:33,440
installed in my user bin directory so if

1571
01:00:33,440 --> 01:00:37,440
i see the there and do analysis to show

1572
01:00:37,440 --> 01:00:39,040
everything in here

1573
01:00:39,040 --> 01:00:41,119
and scroll up we're going to find all

1574
01:00:41,119 --> 01:00:42,960
the versions for clan you see i have

1575
01:00:42,960 --> 01:00:45,839
multiple versions clang 10 11 12

1576
01:00:45,839 --> 01:00:48,799
and we have clan plus plus variance of

1577
01:00:48,799 --> 01:00:51,280
this i think we do okay we have clank

1578
01:00:51,280 --> 01:00:53,920
plus plus and clan here and this is

1579
01:00:53,920 --> 01:00:55,760
going to do what we want we have the

1580
01:00:55,760 --> 01:00:58,640
clan combiner and the gcc compiler

1581
01:00:58,640 --> 01:01:01,359
installed on our system here now if you

1582
01:01:01,359 --> 01:01:03,599
want to get the latest version of gcc

1583
01:01:03,599 --> 01:01:05,280
installed on your system

1584
01:01:05,280 --> 01:01:08,880
one easy way i found is to go through a

1585
01:01:08,880 --> 01:01:11,280
package manager called homebrew let's

1586
01:01:11,280 --> 01:01:12,880
search for this

1587
01:01:12,880 --> 01:01:14,319
right if you search for this you're

1588
01:01:14,319 --> 01:01:16,000
going to find it and if you want you can

1589
01:01:16,000 --> 01:01:18,240
install it on your linux system

1590
01:01:18,240 --> 01:01:20,400
and when you install it it's going to to

1591
01:01:20,400 --> 01:01:23,680
be basically there ready to use

1592
01:01:23,680 --> 01:01:25,359
and to install it i think there's a

1593
01:01:25,359 --> 01:01:28,000
command there install home brew

1594
01:01:28,000 --> 01:01:30,720
let's do this install here and if we do

1595
01:01:30,720 --> 01:01:32,160
install

1596
01:01:32,160 --> 01:01:34,799
we should find a link to install this

1597
01:01:34,799 --> 01:01:37,359
let's find a link i think they have a

1598
01:01:37,359 --> 01:01:39,359
link you can copy aha it is this little

1599
01:01:39,359 --> 01:01:42,240
thing here you can copy it paste it in

1600
01:01:42,240 --> 01:01:44,000
your terminal and it is going to install

1601
01:01:44,000 --> 01:01:45,839
home brew on your system

1602
01:01:45,839 --> 01:01:48,480
and when you have home brew installed

1603
01:01:48,480 --> 01:01:50,240
you can go through it to install the

1604
01:01:50,240 --> 01:01:52,480
latest version of gcc for example if we

1605
01:01:52,480 --> 01:01:54,400
search for homo blue

1606
01:01:54,400 --> 01:01:57,920
gcc in our search engine here

1607
01:01:57,920 --> 01:02:00,400
we're going to find all the information

1608
01:02:00,400 --> 01:02:03,039
to install this through home brew and

1609
01:02:03,039 --> 01:02:05,599
you just have to do bro install gcc and

1610
01:02:05,599 --> 01:02:07,359
this is going to install this on your

1611
01:02:07,359 --> 01:02:09,039
system and you're going to see that it

1612
01:02:09,039 --> 01:02:11,280
is going to install the latest version

1613
01:02:11,280 --> 01:02:13,520
at the time of recording this video so

1614
01:02:13,520 --> 01:02:15,520
this is what you should do for example

1615
01:02:15,520 --> 01:02:19,280
if we go back to our linux box we can do

1616
01:02:19,280 --> 01:02:21,760
let's cd into our home directory and

1617
01:02:21,760 --> 01:02:23,599
we're going to say brew

1618
01:02:23,599 --> 01:02:26,160
install gcc

1619
01:02:26,160 --> 01:02:28,000
and it's going to tell me that it is

1620
01:02:28,000 --> 01:02:30,319
already installed because i installed

1621
01:02:30,319 --> 01:02:31,280
this

1622
01:02:31,280 --> 01:02:33,039
but if you don't have it installed it's

1623
01:02:33,039 --> 01:02:34,960
going to install it and you do this

1624
01:02:34,960 --> 01:02:37,839
after you have gone through the steps

1625
01:02:37,839 --> 01:02:39,760
to install

1626
01:02:39,760 --> 01:02:41,920
the home brew package manager on your

1627
01:02:41,920 --> 01:02:44,079
system and you do that by just copying

1628
01:02:44,079 --> 01:02:45,839
this link and pasting that in your

1629
01:02:45,839 --> 01:02:48,000
terminal and hitting enter and it's

1630
01:02:48,000 --> 01:02:49,839
going to give you directions on what you

1631
01:02:49,839 --> 01:02:52,559
can do to get this properly installed on

1632
01:02:52,559 --> 01:02:54,799
your system here so this is really cool

1633
01:02:54,799 --> 01:02:56,880
so if you want the absolute latest

1634
01:02:56,880 --> 01:02:59,839
version in gcc this is one way you have

1635
01:02:59,839 --> 01:03:01,760
to get a hold of it without really going

1636
01:03:01,760 --> 01:03:04,160
through the complex steps to build the

1637
01:03:04,160 --> 01:03:07,359
compiler yourself on linux okay it is

1638
01:03:07,359 --> 01:03:09,599
taking some more time here i am just

1639
01:03:09,599 --> 01:03:11,359
going to kill this because i already

1640
01:03:11,359 --> 01:03:14,480
have the latest version of gcc here if i

1641
01:03:14,480 --> 01:03:19,359
do jcc 11 on linux and the do version

1642
01:03:19,359 --> 01:03:21,760
i am going to see that i have 11 2 and

1643
01:03:21,760 --> 01:03:24,160
it was installed through homebrew and if

1644
01:03:24,160 --> 01:03:26,079
you let this run to completion it's

1645
01:03:26,079 --> 01:03:28,079
going to install this on your computer

1646
01:03:28,079 --> 01:03:30,559
we don't have to wait for this so now we

1647
01:03:30,559 --> 01:03:33,599
have the latest version of gcc on an

1648
01:03:33,599 --> 01:03:35,839
ubuntu system we also have the latest

1649
01:03:35,839 --> 01:03:38,000
version of clan this completes our

1650
01:03:38,000 --> 01:03:40,480
tutorial on how to set up compilers on

1651
01:03:40,480 --> 01:03:42,799
linux we are going to stop here in this

1652
01:03:42,799 --> 01:03:45,119
lecture this one we're going to install

1653
01:03:45,119 --> 01:03:47,599
visual studio code on the linux system

1654
01:03:47,599 --> 01:03:49,440
and then in the next one we're going to

1655
01:03:49,440 --> 01:03:51,839
link visual studio code to these

1656
01:03:51,839 --> 01:03:54,079
compilers and be able to use visual

1657
01:03:54,079 --> 01:03:56,799
studio code type code and compile our

1658
01:03:56,799 --> 01:03:59,760
programs using these two compilers here

1659
01:03:59,760 --> 01:04:01,520
so go ahead and finish up here and meet

1660
01:04:01,520 --> 01:04:03,599
me in the next lecture

1661
01:04:03,599 --> 01:04:05,359
in this lecture we're going to see how

1662
01:04:05,359 --> 01:04:08,319
to install the visual studio code editor

1663
01:04:08,319 --> 01:04:11,039
on a linux system and again we will be

1664
01:04:11,039 --> 01:04:15,280
working on our ubuntu 2004 system here

1665
01:04:15,280 --> 01:04:17,119
so let's head over to the website for

1666
01:04:17,119 --> 01:04:18,960
visual studio code and download our

1667
01:04:18,960 --> 01:04:22,000
binary and install it on our linux

1668
01:04:22,000 --> 01:04:24,319
system here okay so here we are at the

1669
01:04:24,319 --> 01:04:26,960
website for visual studio code you can

1670
01:04:26,960 --> 01:04:29,039
get there by searching for visual studio

1671
01:04:29,039 --> 01:04:31,119
code in your search engine and you're

1672
01:04:31,119 --> 01:04:33,359
going to land here and all we really

1673
01:04:33,359 --> 01:04:34,720
have to do

1674
01:04:34,720 --> 01:04:36,880
is go down to find our download links

1675
01:04:36,880 --> 01:04:38,640
we're going to see that for debian and

1676
01:04:38,640 --> 01:04:41,440
ubuntu we can download here but you can

1677
01:04:41,440 --> 01:04:43,440
also find something specific to other

1678
01:04:43,440 --> 01:04:45,920
distribution okay so we are going to

1679
01:04:45,920 --> 01:04:49,280
grab the 64-bit version of debian ubuntu

1680
01:04:49,280 --> 01:04:51,839
here because that's my system and you're

1681
01:04:51,839 --> 01:04:53,440
going to find whatever makes sense for

1682
01:04:53,440 --> 01:04:56,079
your distribution so let's grab this

1683
01:04:56,079 --> 01:04:58,319
here we're going to grab the link so if

1684
01:04:58,319 --> 01:05:00,000
you click on this

1685
01:05:00,000 --> 01:05:01,920
this is going to kick off the download

1686
01:05:01,920 --> 01:05:04,480
process and you will see this downloaded

1687
01:05:04,480 --> 01:05:07,039
on your system and once you have this

1688
01:05:07,039 --> 01:05:09,200
downloaded you're going to install it

1689
01:05:09,200 --> 01:05:11,520
and in ubuntu you can just double click

1690
01:05:11,520 --> 01:05:13,920
on this to install it or you can install

1691
01:05:13,920 --> 01:05:16,400
it like you install any debian package

1692
01:05:16,400 --> 01:05:19,520
on a linux system for example if you are

1693
01:05:19,520 --> 01:05:22,319
unsure on how to install debian packages

1694
01:05:22,319 --> 01:05:24,960
all you have to do is do a simple search

1695
01:05:24,960 --> 01:05:28,079
so let's do google.com and go there and

1696
01:05:28,079 --> 01:05:30,319
we're going to see how to install

1697
01:05:30,319 --> 01:05:32,880
to install debian

1698
01:05:32,880 --> 01:05:34,160
packages

1699
01:05:34,160 --> 01:05:35,680
on ubuntu

1700
01:05:35,680 --> 01:05:38,720
2004 so this is our version here and

1701
01:05:38,720 --> 01:05:40,000
you're going to find a lot of

1702
01:05:40,000 --> 01:05:42,240
instructions on how to do this it's

1703
01:05:42,240 --> 01:05:44,799
going to be really simple so we can go

1704
01:05:44,799 --> 01:05:47,920
down and find a way to install so all

1705
01:05:47,920 --> 01:05:51,359
you have to do is says you do dpkga

1706
01:05:51,359 --> 01:05:53,119
say i and you pass the name of the

1707
01:05:53,119 --> 01:05:54,640
package and this is going to install

1708
01:05:54,640 --> 01:05:56,799
visual studio code on your system once

1709
01:05:56,799 --> 01:05:58,720
you do this you will have visual studio

1710
01:05:58,720 --> 01:06:01,119
code installed and you will be ready to

1711
01:06:01,119 --> 01:06:03,839
start it and use it on your system here

1712
01:06:03,839 --> 01:06:05,520
once it is installed you will have the

1713
01:06:05,520 --> 01:06:08,160
ability to come in your system here for

1714
01:06:08,160 --> 01:06:11,440
example and say code dot and this is

1715
01:06:11,440 --> 01:06:13,359
going to open a visual studio code

1716
01:06:13,359 --> 01:06:15,520
instance on your system let's wait for

1717
01:06:15,520 --> 01:06:17,440
this to come up so that you really see

1718
01:06:17,440 --> 01:06:18,559
this

1719
01:06:18,559 --> 01:06:20,160
okay so this is going to open visual

1720
01:06:20,160 --> 01:06:22,240
studio coordinate system and you can

1721
01:06:22,240 --> 01:06:24,880
start using it like we will do in the

1722
01:06:24,880 --> 01:06:27,039
next lecture okay once you have a visual

1723
01:06:27,039 --> 01:06:29,440
studio code installed and started up on

1724
01:06:29,440 --> 01:06:31,440
your linux system the very first thing

1725
01:06:31,440 --> 01:06:32,799
you need to do

1726
01:06:32,799 --> 01:06:35,200
is to install the extension that is

1727
01:06:35,200 --> 01:06:37,520
going to allow you to do some c and c

1728
01:06:37,520 --> 01:06:40,000
plus plus and to do that you will come

1729
01:06:40,000 --> 01:06:43,280
to this tab here that says extension and

1730
01:06:43,280 --> 01:06:45,760
in our search box you can start typing c

1731
01:06:45,760 --> 01:06:47,520
and c plus plus

1732
01:06:47,520 --> 01:06:50,000
and you are going to have an entry that

1733
01:06:50,000 --> 01:06:53,280
says microsoft here so please select

1734
01:06:53,280 --> 01:06:55,119
this and this is going to be the

1735
01:06:55,119 --> 01:06:56,640
extension you need to install you're

1736
01:06:56,640 --> 01:06:58,160
going to click on install and it is

1737
01:06:58,160 --> 01:06:59,520
going to install

1738
01:06:59,520 --> 01:07:02,400
and this is what enables a visual studio

1739
01:07:02,400 --> 01:07:05,119
code to do some c plus plus programming

1740
01:07:05,119 --> 01:07:07,200
and this is really cool if you want you

1741
01:07:07,200 --> 01:07:09,839
can check out how to use it on linux and

1742
01:07:09,839 --> 01:07:11,760
you're going to have instructions on how

1743
01:07:11,760 --> 01:07:13,520
to do this but we will do this in the

1744
01:07:13,520 --> 01:07:15,440
next lecture and show you how to

1745
01:07:15,440 --> 01:07:18,240
configure visual studio code to use the

1746
01:07:18,240 --> 01:07:20,799
compilers that we have installed in a

1747
01:07:20,799 --> 01:07:22,799
previous lecture so we're going to tell

1748
01:07:22,799 --> 01:07:25,039
visual studio code to use our client

1749
01:07:25,039 --> 01:07:26,720
compiler we're going to tell it to use

1750
01:07:26,720 --> 01:07:29,039
our gcc compiler and we will have the

1751
01:07:29,039 --> 01:07:31,039
flexibility to come to terminal and

1752
01:07:31,039 --> 01:07:33,760
choose which compiler we want to use and

1753
01:07:33,760 --> 01:07:35,920
we're going to do all this in the next

1754
01:07:35,920 --> 01:07:38,640
lecture so go ahead and finish up here

1755
01:07:38,640 --> 01:07:40,799
and meet me there

1756
01:07:40,799 --> 01:07:42,880
in this lecture we're going to configure

1757
01:07:42,880 --> 01:07:45,920
our visual studio code editor to use the

1758
01:07:45,920 --> 01:07:49,039
compilers that we just installed in a

1759
01:07:49,039 --> 01:07:51,039
few previous lectures so we will be able

1760
01:07:51,039 --> 01:07:53,119
to type our code in our visual studio

1761
01:07:53,119 --> 01:07:56,400
code editor just like we do here and we

1762
01:07:56,400 --> 01:07:58,640
will pass the code through the compiler

1763
01:07:58,640 --> 01:08:01,839
to generate a binary that can in turn

1764
01:08:01,839 --> 01:08:04,400
run on our linux system here this is

1765
01:08:04,400 --> 01:08:06,319
what we want to do so we want visual

1766
01:08:06,319 --> 01:08:08,400
studio code to use the compilers that we

1767
01:08:08,400 --> 01:08:10,640
installed so let's head over to our

1768
01:08:10,640 --> 01:08:13,680
linux box and do this okay here i am on

1769
01:08:13,680 --> 01:08:15,920
my linux box this is the current

1770
01:08:15,920 --> 01:08:18,560
directory where i am at this is where i

1771
01:08:18,560 --> 01:08:21,040
am going to do my things here so i am

1772
01:08:21,040 --> 01:08:24,319
going to create a folder and call it a

1773
01:08:24,319 --> 01:08:26,799
template project let's do this we're

1774
01:08:26,799 --> 01:08:27,960
going to say

1775
01:08:27,960 --> 01:08:31,040
mkdir and we're going to say c plus plus

1776
01:08:31,040 --> 01:08:33,279
20 template project i think this is

1777
01:08:33,279 --> 01:08:34,640
going to do

1778
01:08:34,640 --> 01:08:37,199
or we can even say cpp because i'm not

1779
01:08:37,199 --> 01:08:39,040
sure the plus signs here are not going

1780
01:08:39,040 --> 01:08:41,679
to give us a problem let's play it on

1781
01:08:41,679 --> 01:08:44,319
the safe side and we are going to create

1782
01:08:44,319 --> 01:08:46,960
this folder and we're going to cd into

1783
01:08:46,960 --> 01:08:48,319
this folder

1784
01:08:48,319 --> 01:08:50,560
okay once we are in this folder we're

1785
01:08:50,560 --> 01:08:52,880
going to open this folder in visual

1786
01:08:52,880 --> 01:08:55,440
studio code and the easiest way to do

1787
01:08:55,440 --> 01:08:56,239
that

1788
01:08:56,239 --> 01:08:57,679
once you have visual studio code

1789
01:08:57,679 --> 01:09:00,400
installed is just to type code and type

1790
01:09:00,400 --> 01:09:01,359
dot

1791
01:09:01,359 --> 01:09:03,199
and you will basically be telling the

1792
01:09:03,199 --> 01:09:05,440
operating system to open visual studio

1793
01:09:05,440 --> 01:09:08,239
code in the current folder here so i am

1794
01:09:08,239 --> 01:09:10,000
going to hit enter

1795
01:09:10,000 --> 01:09:13,359
and this is going to kick it open and i

1796
01:09:13,359 --> 01:09:15,520
trust this folder because i just created

1797
01:09:15,520 --> 01:09:18,080
it and we are in our project here the

1798
01:09:18,080 --> 01:09:20,080
very first thing we're going to do is to

1799
01:09:20,080 --> 01:09:23,359
create a main cpp file so let's do that

1800
01:09:23,359 --> 01:09:25,520
and i did that by clicking on the plus

1801
01:09:25,520 --> 01:09:26,799
icon here

1802
01:09:26,799 --> 01:09:29,920
and i typed in the name of the file and

1803
01:09:29,920 --> 01:09:32,480
i am going to put in some dummy code

1804
01:09:32,480 --> 01:09:34,640
here that we want to use our starter

1805
01:09:34,640 --> 01:09:36,640
code we're going to say

1806
01:09:36,640 --> 01:09:39,520
iostream and we're going to put in our

1807
01:09:39,520 --> 01:09:41,359
code here we're going to say main and

1808
01:09:41,359 --> 01:09:43,199
again you don't have to type all this if

1809
01:09:43,199 --> 01:09:45,120
you want you can get the code from the

1810
01:09:45,120 --> 01:09:47,279
resource section on the lecture so you

1811
01:09:47,279 --> 01:09:49,279
can copy the code paste that in here and

1812
01:09:49,279 --> 01:09:51,600
be on your merry way because we haven't

1813
01:09:51,600 --> 01:09:53,359
really started learning about c plus

1814
01:09:53,359 --> 01:09:55,440
plus we are setting up the environment

1815
01:09:55,440 --> 01:09:57,760
so don't stress yourself here

1816
01:09:57,760 --> 01:09:59,679
this is just some simple code to test

1817
01:09:59,679 --> 01:10:02,480
our compilers to see if they support c

1818
01:10:02,480 --> 01:10:04,800
plus plus 20 because we want to use the

1819
01:10:04,800 --> 01:10:07,360
letter standard we can get our hands on

1820
01:10:07,360 --> 01:10:10,400
here so let's do equals

1821
01:10:10,400 --> 01:10:12,480
type exactly what i typed here so we're

1822
01:10:12,480 --> 01:10:14,239
going to say 10

1823
01:10:14,239 --> 01:10:15,920
and we're going to put this weird

1824
01:10:15,920 --> 01:10:18,640
operator and say 20 and we want to see

1825
01:10:18,640 --> 01:10:19,760
if this

1826
01:10:19,760 --> 01:10:22,239
madness here is greater than zero this

1827
01:10:22,239 --> 01:10:24,239
is what we want to do and we're going to

1828
01:10:24,239 --> 01:10:27,920
say stdc out and the same result okay so

1829
01:10:27,920 --> 01:10:30,480
type exactly what i type here and as we

1830
01:10:30,480 --> 01:10:31,920
progress in the course we're going to

1831
01:10:31,920 --> 01:10:34,000
make sense of all these madness we see

1832
01:10:34,000 --> 01:10:38,320
here so now that we have a cpp file

1833
01:10:38,320 --> 01:10:40,880
containing the code for our c plus plus

1834
01:10:40,880 --> 01:10:44,320
program we want to compile this and we

1835
01:10:44,320 --> 01:10:46,239
need to tell visual studio code which

1836
01:10:46,239 --> 01:10:48,159
compiler it's going to use to compile

1837
01:10:48,159 --> 01:10:50,640
this program here to give us a binary

1838
01:10:50,640 --> 01:10:52,560
that we can run so what we're going to

1839
01:10:52,560 --> 01:10:55,520
do is come to terminal here

1840
01:10:55,520 --> 01:10:57,120
and we're going to say that we want to

1841
01:10:57,120 --> 01:10:58,960
configure tasks

1842
01:10:58,960 --> 01:11:00,960
and the task is really a set of

1843
01:11:00,960 --> 01:11:02,880
instructions you give to visual studio

1844
01:11:02,880 --> 01:11:05,920
code on how to take your c plus plus

1845
01:11:05,920 --> 01:11:08,960
project and turn that into a binary that

1846
01:11:08,960 --> 01:11:11,199
can run on that system here so that's

1847
01:11:11,199 --> 01:11:12,800
what we want to do we want to tell

1848
01:11:12,800 --> 01:11:15,280
visual studio code which compiler it's

1849
01:11:15,280 --> 01:11:16,719
going to use we're going to configure

1850
01:11:16,719 --> 01:11:18,800
task here and you're going to see that

1851
01:11:18,800 --> 01:11:21,280
it's going to discover many compilers on

1852
01:11:21,280 --> 01:11:24,080
my system here you see we have clan 10

1853
01:11:24,080 --> 01:11:27,600
clang 11 clan 12 and we should also have

1854
01:11:27,600 --> 01:11:30,719
gcc 11 if we keep scrolling down we're

1855
01:11:30,719 --> 01:11:33,679
going to find these little guys here i

1856
01:11:33,679 --> 01:11:36,400
have many compilers on this system so i

1857
01:11:36,400 --> 01:11:38,080
am going to choose

1858
01:11:38,080 --> 01:11:38,880
the

1859
01:11:38,880 --> 01:11:40,400
gcc compiler

1860
01:11:40,400 --> 01:11:42,480
which is installed through home brew

1861
01:11:42,480 --> 01:11:44,320
this is what i'm going to choose here

1862
01:11:44,320 --> 01:11:46,880
you say it's saying g plus plus 11 but

1863
01:11:46,880 --> 01:11:48,960
if you have access to g plus plus 10 you

1864
01:11:48,960 --> 01:11:51,360
can also use that it's going to work

1865
01:11:51,360 --> 01:11:53,199
with what we want to do in this course

1866
01:11:53,199 --> 01:11:55,760
here mostly so i am going to choose the

1867
01:11:55,760 --> 01:11:58,560
best i have in terms of gcc

1868
01:11:58,560 --> 01:12:01,199
and this is going to set up an entry in

1869
01:12:01,199 --> 01:12:04,719
our tasks dot json file to build and run

1870
01:12:04,719 --> 01:12:06,719
this program here and that's what we're

1871
01:12:06,719 --> 01:12:09,120
going to do okay you see it is using

1872
01:12:09,120 --> 01:12:12,480
this particular compiler and one thing

1873
01:12:12,480 --> 01:12:14,560
we can do before we try and build this

1874
01:12:14,560 --> 01:12:16,560
we can change the level here to make it

1875
01:12:16,560 --> 01:12:17,760
a little bit

1876
01:12:17,760 --> 01:12:19,920
more descriptive so we're going to save

1877
01:12:19,920 --> 01:12:21,360
world

1878
01:12:21,360 --> 01:12:24,640
with gcc

1879
01:12:25,000 --> 01:12:27,679
11.2.0 if i am correct

1880
01:12:27,679 --> 01:12:30,080
and this is all we can save this

1881
01:12:30,080 --> 01:12:33,199
and we can close this json file and if

1882
01:12:33,199 --> 01:12:35,199
we bring up a terminal window we can do

1883
01:12:35,199 --> 01:12:37,679
that by hitting terminal here and

1884
01:12:37,679 --> 01:12:40,640
choosing a new terminal

1885
01:12:40,640 --> 01:12:42,320
this is going to open up the current

1886
01:12:42,320 --> 01:12:46,000
location for example if we do pwd in

1887
01:12:46,000 --> 01:12:49,040
this terminal here let's use lowercase i

1888
01:12:49,040 --> 01:12:50,400
think that's what it wants we're going

1889
01:12:50,400 --> 01:12:52,480
to see the location here this is my

1890
01:12:52,480 --> 01:12:55,120
project so to build i can come to

1891
01:12:55,120 --> 01:12:56,560
terminal

1892
01:12:56,560 --> 01:12:59,360
and i choose run task and i am going to

1893
01:12:59,360 --> 01:13:02,400
choose the task to compile with my gcc

1894
01:13:02,400 --> 01:13:05,440
installation here if i choose this

1895
01:13:05,440 --> 01:13:08,400
it is going to kick off the weld process

1896
01:13:08,400 --> 01:13:09,600
and you're going to see that the

1897
01:13:09,600 --> 01:13:11,920
gibberish i have here is not supported

1898
01:13:11,920 --> 01:13:13,280
because the

1899
01:13:13,280 --> 01:13:15,760
compiler is not configured to use the c

1900
01:13:15,760 --> 01:13:18,080
plus plus 20. so all we really need to

1901
01:13:18,080 --> 01:13:22,400
do is go back to our command and tell it

1902
01:13:22,400 --> 01:13:24,560
to use c plus plus 20. and we can do

1903
01:13:24,560 --> 01:13:26,960
that by passing a specific instruction

1904
01:13:26,960 --> 01:13:29,840
to the compiler to use c plus plus 20

1905
01:13:29,840 --> 01:13:32,000
like we do on line 10 here so we're

1906
01:13:32,000 --> 01:13:35,040
going to say std equals c plus plus 20.

1907
01:13:35,040 --> 01:13:36,640
we are going to save this a little bit

1908
01:13:36,640 --> 01:13:38,159
and i really wanted you to see this

1909
01:13:38,159 --> 01:13:39,679
problem here because many people are

1910
01:13:39,679 --> 01:13:41,840
going to forget this and we're going to

1911
01:13:41,840 --> 01:13:43,679
try and build again making sure we are

1912
01:13:43,679 --> 01:13:46,239
selecting the main cpp file here so

1913
01:13:46,239 --> 01:13:49,120
let's go to terminal run task and use

1914
01:13:49,120 --> 01:13:51,360
our compiler

1915
01:13:51,360 --> 01:13:53,199
and wait for it to do its thing you're

1916
01:13:53,199 --> 01:13:55,840
going to see that the world now finished

1917
01:13:55,840 --> 01:13:58,000
successfully

1918
01:13:58,000 --> 01:14:00,640
and if we come back to our terminal here

1919
01:14:00,640 --> 01:14:02,960
and do ls we're going to see that we

1920
01:14:02,960 --> 01:14:05,280
have a file called main

1921
01:14:05,280 --> 01:14:07,920
and if we run it we should see a zero so

1922
01:14:07,920 --> 01:14:10,320
let's say main here

1923
01:14:10,320 --> 01:14:11,760
and if we run it we're going to see a

1924
01:14:11,760 --> 01:14:14,239
zero meaning that our program is running

1925
01:14:14,239 --> 01:14:16,480
and working correctly we are able to

1926
01:14:16,480 --> 01:14:19,600
compile a c plus plus project on a linux

1927
01:14:19,600 --> 01:14:22,960
system here now if you want to see how i

1928
01:14:22,960 --> 01:14:24,960
came up with the information to use the

1929
01:14:24,960 --> 01:14:27,920
tax json file please come back to the

1930
01:14:27,920 --> 01:14:30,320
extensions tab here

1931
01:14:30,320 --> 01:14:33,199
and choose the c and c plus plus

1932
01:14:33,199 --> 01:14:35,440
extension we're going to click on this

1933
01:14:35,440 --> 01:14:36,560
and we're going to see all the

1934
01:14:36,560 --> 01:14:38,960
instructions on how to use this guy on

1935
01:14:38,960 --> 01:14:41,760
the linux system here so gcc on linux we

1936
01:14:41,760 --> 01:14:43,120
can choose this

1937
01:14:43,120 --> 01:14:44,159
and we're going to see all the

1938
01:14:44,159 --> 01:14:46,320
information here now you can read up on

1939
01:14:46,320 --> 01:14:48,400
all this if you want but what i am going

1940
01:14:48,400 --> 01:14:51,040
to do is go to visual studio code and

1941
01:14:51,040 --> 01:14:52,880
show you exactly what you need to do to

1942
01:14:52,880 --> 01:14:55,360
get this to work what i want to do in

1943
01:14:55,360 --> 01:14:57,920
there is set this up to compile

1944
01:14:57,920 --> 01:15:00,719
everything in my what i want to do is to

1945
01:15:00,719 --> 01:15:03,440
set what i really want to do is to what

1946
01:15:03,440 --> 01:15:06,640
i really wanted to do is to set this up

1947
01:15:06,640 --> 01:15:09,199
so that it compiles every single cpp

1948
01:15:09,199 --> 01:15:11,760
file in my directory here and i can do

1949
01:15:11,760 --> 01:15:13,679
that by putting in

1950
01:15:13,679 --> 01:15:15,920
a set of instructions i had prepared

1951
01:15:15,920 --> 01:15:17,199
beforehand

1952
01:15:17,199 --> 01:15:18,960
so we're going to tell it to compile in

1953
01:15:18,960 --> 01:15:21,120
c plus plus 20 mode we're going to tell

1954
01:15:21,120 --> 01:15:24,159
it to compile every single cpp file in

1955
01:15:24,159 --> 01:15:26,159
this directory and then we're going to

1956
01:15:26,159 --> 01:15:28,719
specify the output file name for our

1957
01:15:28,719 --> 01:15:31,120
binary now this is code i used on

1958
01:15:31,120 --> 01:15:33,440
windows i need to adapt it to be

1959
01:15:33,440 --> 01:15:35,280
specific to linux

1960
01:15:35,280 --> 01:15:36,080
so

1961
01:15:36,080 --> 01:15:37,280
let's see what they say in the

1962
01:15:37,280 --> 01:15:40,480
documentation there and we can

1963
01:15:40,480 --> 01:15:42,400
we can scroll down a little bit and

1964
01:15:42,400 --> 01:15:44,239
we're going to see that they use

1965
01:15:44,239 --> 01:15:46,000
backslashes here so that's what we're

1966
01:15:46,000 --> 01:15:47,679
going to use in visual video code to

1967
01:15:47,679 --> 01:15:50,719
play it safe so we can say this

1968
01:15:50,719 --> 01:15:53,760
a backslash and this is a backslash

1969
01:15:53,760 --> 01:15:56,159
and we will try and build this and we're

1970
01:15:56,159 --> 01:15:57,840
going to see what happens here this is

1971
01:15:57,840 --> 01:16:00,080
going to build our project in c plus

1972
01:16:00,080 --> 01:16:02,239
plus 20 mode we're going to be building

1973
01:16:02,239 --> 01:16:04,719
every single cpp file in the project and

1974
01:16:04,719 --> 01:16:07,280
the output will be called rooster this

1975
01:16:07,280 --> 01:16:09,440
is what we want to do here let's save

1976
01:16:09,440 --> 01:16:10,560
this up

1977
01:16:10,560 --> 01:16:13,600
and i am going to close this json file

1978
01:16:13,600 --> 01:16:15,840
and i will bring up my terminal by

1979
01:16:15,840 --> 01:16:19,679
coming to view and save a terminal here

1980
01:16:19,679 --> 01:16:23,120
and i can remove the main.exe file or

1981
01:16:23,120 --> 01:16:25,360
the main executable i had in there if i

1982
01:16:25,360 --> 01:16:28,880
do lsuc it's gone but now if we try and

1983
01:16:28,880 --> 01:16:31,840
compile with the gcc compiler

1984
01:16:31,840 --> 01:16:33,199
we're going to see what happens you see

1985
01:16:33,199 --> 01:16:35,280
the world is good and we have a binary

1986
01:16:35,280 --> 01:16:37,679
called rooster and we can run it here if

1987
01:16:37,679 --> 01:16:39,920
we do rooster we're going to see it run

1988
01:16:39,920 --> 01:16:41,760
and give us a zero and this is really

1989
01:16:41,760 --> 01:16:43,760
all we need to do now we have this

1990
01:16:43,760 --> 01:16:45,679
working for

1991
01:16:45,679 --> 01:16:48,239
our gcc compiler but we wanted the same

1992
01:16:48,239 --> 01:16:50,640
for a clanger compiler and we want the

1993
01:16:50,640 --> 01:16:52,239
flexibility to be able to switch

1994
01:16:52,239 --> 01:16:54,880
compilers by coming here and just

1995
01:16:54,880 --> 01:16:57,440
selecting the right task so let's do

1996
01:16:57,440 --> 01:16:59,120
this we're going to configure clan we're

1997
01:16:59,120 --> 01:17:01,040
going to come to terminal we want to

1998
01:17:01,040 --> 01:17:03,199
configure a task and we're going to

1999
01:17:03,199 --> 01:17:04,800
choose the best we have in terms of

2000
01:17:04,800 --> 01:17:07,600
clang that happens to be clang

2001
01:17:07,600 --> 01:17:09,679
plus plus 12 here so we're going to

2002
01:17:09,679 --> 01:17:11,840
choose this and this is going to add an

2003
01:17:11,840 --> 01:17:14,120
entry in our

2004
01:17:14,120 --> 01:17:16,640
tasks.json file we're going to change

2005
01:17:16,640 --> 01:17:18,960
this to say that we want to build with

2006
01:17:18,960 --> 01:17:21,199
clan let's do that we're going to say

2007
01:17:21,199 --> 01:17:23,840
world with clang

2008
01:17:23,840 --> 01:17:26,360
i think we have

2009
01:17:26,360 --> 01:17:29,360
12.0.1 if i remember correctly but we

2010
01:17:29,360 --> 01:17:30,480
can ask

2011
01:17:30,480 --> 01:17:33,040
our terminal here let's go to terminal

2012
01:17:33,040 --> 01:17:36,000
and we're going to say clang plus plus

2013
01:17:36,000 --> 01:17:37,840
and 12 that's the version and we're

2014
01:17:37,840 --> 01:17:39,920
going to ask it what's your version it's

2015
01:17:39,920 --> 01:17:42,320
going to tell us in detail and if we

2016
01:17:42,320 --> 01:17:44,560
wait we're going to see this speed out

2017
01:17:44,560 --> 01:17:47,600
on the terminal here and this happens to

2018
01:17:47,600 --> 01:17:50,480
be clank version 1200

2019
01:17:50,480 --> 01:17:52,000
so that's what we're going to say in our

2020
01:17:52,000 --> 01:17:53,520
file here

2021
01:17:53,520 --> 01:17:56,560
weld with clan 12 0 0

2022
01:17:56,560 --> 01:18:00,320
to be super clear on this

2023
01:18:00,320 --> 01:18:02,800
and uh this is really all all we need to

2024
01:18:02,800 --> 01:18:05,600
do is put in the instructions

2025
01:18:05,600 --> 01:18:07,920
to build in c plus plus 20 mod exactly

2026
01:18:07,920 --> 01:18:10,560
what we did for gcc here so i am going

2027
01:18:10,560 --> 01:18:14,080
to copy this and put that in my

2028
01:18:14,080 --> 01:18:16,239
arguments here i'm i am going to take

2029
01:18:16,239 --> 01:18:18,159
out whatever i had in there i am going

2030
01:18:18,159 --> 01:18:20,880
to put in my new things and let's see if

2031
01:18:20,880 --> 01:18:23,040
this compiler works now we're going to

2032
01:18:23,040 --> 01:18:26,159
save our tasks.json file and come back

2033
01:18:26,159 --> 01:18:28,640
to the cpp file we're going to bring up

2034
01:18:28,640 --> 01:18:30,719
our terminal window

2035
01:18:30,719 --> 01:18:33,199
and we're going to clear

2036
01:18:33,199 --> 01:18:35,600
and remove rooster because we wanted to

2037
01:18:35,600 --> 01:18:38,239
build a new one with our clank compiler

2038
01:18:38,239 --> 01:18:42,080
and we will come to terminal run task

2039
01:18:42,080 --> 01:18:43,760
now we're going to choose to build with

2040
01:18:43,760 --> 01:18:46,640
clang 12.0 we're going to fix this in a

2041
01:18:46,640 --> 01:18:48,719
minute but if we do this we're going to

2042
01:18:48,719 --> 01:18:51,040
see that our weld process is going to

2043
01:18:51,040 --> 01:18:53,360
start it's going to be building with our

2044
01:18:53,360 --> 01:18:55,520
clan compiler it's going to be using c

2045
01:18:55,520 --> 01:18:57,840
plus plus 20. it's going to be building

2046
01:18:57,840 --> 01:19:00,480
every single cpp file in this location

2047
01:19:00,480 --> 01:19:03,280
here and the output of the world will be

2048
01:19:03,280 --> 01:19:05,360
a binary called rooster that we have

2049
01:19:05,360 --> 01:19:07,920
right here so the build is good if we do

2050
01:19:07,920 --> 01:19:09,760
ls we're going to find rooster and if we

2051
01:19:09,760 --> 01:19:12,239
run it it's going to say zero exactly as

2052
01:19:12,239 --> 01:19:15,120
we expect here and we have visual studio

2053
01:19:15,120 --> 01:19:17,920
code properly configured to use our two

2054
01:19:17,920 --> 01:19:20,159
compilers the client compiler and the

2055
01:19:20,159 --> 01:19:22,719
gcc compiler let's come back to our

2056
01:19:22,719 --> 01:19:24,719
configuration and change this to say

2057
01:19:24,719 --> 01:19:26,880
12.0.0

2058
01:19:26,880 --> 01:19:29,600
to be super clear on the version we have

2059
01:19:29,600 --> 01:19:32,719
we can close our json file here

2060
01:19:32,719 --> 01:19:35,280
and come and try to build again if we do

2061
01:19:35,280 --> 01:19:38,640
terminal and run task we will have our

2062
01:19:38,640 --> 01:19:40,640
compiler here ignore all these things i

2063
01:19:40,640 --> 01:19:42,159
think visual video code is going to give

2064
01:19:42,159 --> 01:19:44,880
you duplicates but you can choose

2065
01:19:44,880 --> 01:19:47,440
the version that says what you want and

2066
01:19:47,440 --> 01:19:48,880
it is going to work so we're going to

2067
01:19:48,880 --> 01:19:52,080
choose gcc oh we are saying gcc but we

2068
01:19:52,080 --> 01:19:54,480
want clang here so let's say that we

2069
01:19:54,480 --> 01:19:56,560
want to build with clan we're going to

2070
01:19:56,560 --> 01:19:58,080
go to terminal

2071
01:19:58,080 --> 01:19:59,600
and run task

2072
01:19:59,600 --> 01:20:02,199
and we want clang

2073
01:20:02,199 --> 01:20:05,199
12.0.0 this is right here so we're going

2074
01:20:05,199 --> 01:20:06,639
to select it

2075
01:20:06,639 --> 01:20:08,400
and it's going to build successfully and

2076
01:20:08,400 --> 01:20:11,040
we will have our binary here if we run

2077
01:20:11,040 --> 01:20:11,840
it

2078
01:20:11,840 --> 01:20:13,440
it is going to say zero and this is

2079
01:20:13,440 --> 01:20:16,080
really what we need to do here so this

2080
01:20:16,080 --> 01:20:17,600
is really all i had to share in this

2081
01:20:17,600 --> 01:20:19,040
lecture showing you how you can

2082
01:20:19,040 --> 01:20:20,320
configure

2083
01:20:20,320 --> 01:20:22,400
visual studio code to compile using the

2084
01:20:22,400 --> 01:20:24,719
compilers that we have installed another

2085
01:20:24,719 --> 01:20:26,800
thing you can do to make your experience

2086
01:20:26,800 --> 01:20:30,480
better is come back to view and select

2087
01:20:30,480 --> 01:20:34,080
command palette here and you can do c

2088
01:20:34,080 --> 01:20:36,239
and the c plus and edit the

2089
01:20:36,239 --> 01:20:39,280
configurations through a user interface

2090
01:20:39,280 --> 01:20:40,639
and if we do this you're going to see

2091
01:20:40,639 --> 01:20:42,480
that this is going to create a cpp

2092
01:20:42,480 --> 01:20:45,360
properties json file so this is where we

2093
01:20:45,360 --> 01:20:46,480
can configure

2094
01:20:46,480 --> 01:20:48,560
what kind of intelligence what kind of

2095
01:20:48,560 --> 01:20:50,239
what kind of compiler is going to be

2096
01:20:50,239 --> 01:20:53,600
used we can do all these things here so

2097
01:20:53,600 --> 01:20:55,120
we're going to leave it to the default

2098
01:20:55,120 --> 01:20:57,360
it's on our linux system it's going to

2099
01:20:57,360 --> 01:20:59,840
be using gcc 11 which is the best we

2100
01:20:59,840 --> 01:21:00,719
have

2101
01:21:00,719 --> 01:21:02,719
in terms of gcc

2102
01:21:02,719 --> 01:21:06,800
but uh one thing you should note in this

2103
01:21:06,800 --> 01:21:08,800
course here is the c plus plus standard

2104
01:21:08,800 --> 01:21:10,800
we wanted to use so we wanted to use z

2105
01:21:10,800 --> 01:21:13,600
plus plus 20 and we want visual studio

2106
01:21:13,600 --> 01:21:16,000
code to give us intellisense

2107
01:21:16,000 --> 01:21:16,719
or

2108
01:21:16,719 --> 01:21:19,600
format our main cpp file based on the c

2109
01:21:19,600 --> 01:21:21,920
plus plus 20 standard year that's what

2110
01:21:21,920 --> 01:21:23,440
we can achieve with this so once you

2111
01:21:23,440 --> 01:21:24,880
have this and

2112
01:21:24,880 --> 01:21:27,520
you can come and close this

2113
01:21:27,520 --> 01:21:29,520
and if we go back to the main cpp file

2114
01:21:29,520 --> 01:21:30,800
you see now

2115
01:21:30,800 --> 01:21:33,520
that this is no longer flagged as a

2116
01:21:33,520 --> 01:21:35,360
problem with squiggly lines visual

2117
01:21:35,360 --> 01:21:37,280
studio code is properly understanding

2118
01:21:37,280 --> 01:21:39,280
what is happening here and this is

2119
01:21:39,280 --> 01:21:40,880
something you can do to make your

2120
01:21:40,880 --> 01:21:42,880
experience a little bit better

2121
01:21:42,880 --> 01:21:45,120
okay now that we have this project set

2122
01:21:45,120 --> 01:21:47,840
up and ready on linux we're going to be

2123
01:21:47,840 --> 01:21:50,639
reusing this as a template project every

2124
01:21:50,639 --> 01:21:53,600
time we start something new on linux so

2125
01:21:53,600 --> 01:21:54,960
every time we want to create a new

2126
01:21:54,960 --> 01:21:57,600
project we will grab this entire folder

2127
01:21:57,600 --> 01:21:59,840
so for example we will come to our

2128
01:21:59,840 --> 01:22:03,280
terminal here and go up a little bit

2129
01:22:03,280 --> 01:22:06,400
so cd and go up one level and if we do

2130
01:22:06,400 --> 01:22:08,320
ls we're going to have our c plus plus

2131
01:22:08,320 --> 01:22:11,520
20 template project we will copy it and

2132
01:22:11,520 --> 01:22:14,159
rename it to start a new project and

2133
01:22:14,159 --> 01:22:15,520
that's going to give us all the

2134
01:22:15,520 --> 01:22:17,520
configuration that we did we don't need

2135
01:22:17,520 --> 01:22:19,920
to reconfigure the compilers or whatever

2136
01:22:19,920 --> 01:22:22,800
it is going to work right out of the box

2137
01:22:22,800 --> 01:22:25,040
and that's really what we did here we

2138
01:22:25,040 --> 01:22:27,600
set up a template project that we will

2139
01:22:27,600 --> 01:22:30,159
be reusing all over again in the course

2140
01:22:30,159 --> 01:22:32,800
as we progress learning about c plus

2141
01:22:32,800 --> 01:22:35,440
plus 20. i am going to stop here in this

2142
01:22:35,440 --> 01:22:37,520
lecture the next one i am going to show

2143
01:22:37,520 --> 01:22:39,520
you how you can set up a development

2144
01:22:39,520 --> 01:22:42,800
environment on the mac os system

2145
01:22:42,800 --> 01:22:45,040
go ahead and finish up here and meet me

2146
01:22:45,040 --> 01:22:46,320
there

2147
01:22:46,320 --> 01:22:48,080
in this video i am going to show you how

2148
01:22:48,080 --> 01:22:50,800
to install c plus plus compiler on your

2149
01:22:50,800 --> 01:22:54,000
mac os system and we have a bunch of

2150
01:22:54,000 --> 01:22:56,639
options on the mac we can install the

2151
01:22:56,639 --> 01:22:59,199
gcc compiler we can install the clang

2152
01:22:59,199 --> 01:23:00,320
version

2153
01:23:00,320 --> 01:23:03,120
of the apple company or we can install

2154
01:23:03,120 --> 01:23:05,520
the clangle vm version all these are

2155
01:23:05,520 --> 01:23:07,520
options and i will show you how to

2156
01:23:07,520 --> 01:23:09,679
install these i don't have access to a

2157
01:23:09,679 --> 01:23:12,239
mac device so i won't really be able to

2158
01:23:12,239 --> 01:23:14,719
install xcode and show you but i think

2159
01:23:14,719 --> 01:23:17,040
you can manage if you are using a mac

2160
01:23:17,040 --> 01:23:19,120
system it is nothing complicated you

2161
01:23:19,120 --> 01:23:21,360
just have to go to the apple store and

2162
01:23:21,360 --> 01:23:23,040
click on xcode and it is going to

2163
01:23:23,040 --> 01:23:27,040
install for a gcc and clang llvm i will

2164
01:23:27,040 --> 01:23:28,960
show you how to do this using the

2165
01:23:28,960 --> 01:23:31,440
homebrew package manager which is also

2166
01:23:31,440 --> 01:23:34,400
going to make this super easy okay so

2167
01:23:34,400 --> 01:23:36,719
let's head over to our browser and we

2168
01:23:36,719 --> 01:23:39,520
have a good link here from digitalocean

2169
01:23:39,520 --> 01:23:42,800
on how to install and use homobrew on a

2170
01:23:42,800 --> 01:23:45,360
mac os system this is a really validated

2171
01:23:45,360 --> 01:23:47,679
link you can see that right here and you

2172
01:23:47,679 --> 01:23:50,159
can read up on this if you are using a

2173
01:23:50,159 --> 01:23:52,159
mac system i am going to share the link

2174
01:23:52,159 --> 01:23:54,880
here in the resources section of the

2175
01:23:54,880 --> 01:23:57,600
course and to use this we will go

2176
01:23:57,600 --> 01:24:00,000
through the mac os terminal and it is

2177
01:24:00,000 --> 01:24:01,760
nothing complicated you can search for

2178
01:24:01,760 --> 01:24:04,960
it and open it up and after you do this

2179
01:24:04,960 --> 01:24:07,520
you will have to install the tools

2180
01:24:07,520 --> 01:24:10,080
needed to build things on the mac os

2181
01:24:10,080 --> 01:24:12,639
system and that's going to install xcode

2182
01:24:12,639 --> 01:24:15,679
here so grab the command here and run it

2183
01:24:15,679 --> 01:24:18,239
in your terminal and this is going to

2184
01:24:18,239 --> 01:24:20,560
install everything you need and after

2185
01:24:20,560 --> 01:24:22,159
you have this installed you're going to

2186
01:24:22,159 --> 01:24:24,800
install home brew i do recommend coming

2187
01:24:24,800 --> 01:24:29,199
up to the website here for homebrew and

2188
01:24:29,199 --> 01:24:32,320
clicking on this copy icon here this is

2189
01:24:32,320 --> 01:24:34,960
going to copy the entire thing and you

2190
01:24:34,960 --> 01:24:36,560
can copy this

2191
01:24:36,560 --> 01:24:38,320
and once you copy it it is going to give

2192
01:24:38,320 --> 01:24:40,239
us a green tick here

2193
01:24:40,239 --> 01:24:42,159
and you can go in the terminal on your

2194
01:24:42,159 --> 01:24:44,800
mac os system i am using a linux

2195
01:24:44,800 --> 01:24:46,400
terminal here and then you're going to

2196
01:24:46,400 --> 01:24:49,199
paste this command in here and hit enter

2197
01:24:49,199 --> 01:24:51,040
once you do that you will be prompted to

2198
01:24:51,040 --> 01:24:52,719
put in the password it's going to tell

2199
01:24:52,719 --> 01:24:54,880
you that it needs to install homebrew

2200
01:24:54,880 --> 01:24:56,560
and you are basically going to wait for

2201
01:24:56,560 --> 01:24:58,880
this to finish i have to warn you this

2202
01:24:58,880 --> 01:25:00,719
is going to take some time even if you

2203
01:25:00,719 --> 01:25:02,880
have a good internet connection this is

2204
01:25:02,880 --> 01:25:04,719
going to take some time so be patient

2205
01:25:04,719 --> 01:25:06,480
here when it's done it's going to tell

2206
01:25:06,480 --> 01:25:08,639
you that it is finished and you will be

2207
01:25:08,639 --> 01:25:11,120
ready to install the gcc compiler and

2208
01:25:11,120 --> 01:25:13,920
the client llvm compiler through your

2209
01:25:13,920 --> 01:25:16,000
homebrew installation here i am not

2210
01:25:16,000 --> 01:25:18,159
going to click on this because

2211
01:25:18,159 --> 01:25:20,159
i already have this installed on my

2212
01:25:20,159 --> 01:25:22,400
linux system here let's go back to the

2213
01:25:22,400 --> 01:25:24,719
link and see what they say next so after

2214
01:25:24,719 --> 01:25:27,280
you paste that in it's going to install

2215
01:25:27,280 --> 01:25:30,880
and after that you will see that

2216
01:25:30,880 --> 01:25:32,480
homebrew is going to be installed on

2217
01:25:32,480 --> 01:25:33,679
your system

2218
01:25:33,679 --> 01:25:35,040
and uh

2219
01:25:35,040 --> 01:25:36,880
you can use home brew to start

2220
01:25:36,880 --> 01:25:38,800
installing and upgrading packages you

2221
01:25:38,800 --> 01:25:41,120
can really read up on this but what i

2222
01:25:41,120 --> 01:25:42,639
want you to see

2223
01:25:42,639 --> 01:25:44,880
is that you can use home brew to install

2224
01:25:44,880 --> 01:25:47,600
the gcc compiler and the clang ll vm

2225
01:25:47,600 --> 01:25:49,840
compiler so if we come to the search

2226
01:25:49,840 --> 01:25:52,840
here and say gcc homo

2227
01:25:52,840 --> 01:25:55,280
broom we're going to find instructions

2228
01:25:55,280 --> 01:25:57,840
on how to install this so all you need

2229
01:25:57,840 --> 01:26:00,639
to do really is to say brew install gcc

2230
01:26:00,639 --> 01:26:02,159
this is going to install the latest

2231
01:26:02,159 --> 01:26:04,480
version of gcc on your mac

2232
01:26:04,480 --> 01:26:07,600
if we come here and say llvm or clank

2233
01:26:07,600 --> 01:26:09,920
let's say clan

2234
01:26:09,920 --> 01:26:11,600
and

2235
01:26:11,600 --> 01:26:15,679
we can find that right here llvm

2236
01:26:15,679 --> 01:26:17,360
and it is going to give us instructions

2237
01:26:17,360 --> 01:26:19,360
on how to install this and all you have

2238
01:26:19,360 --> 01:26:20,239
to do

2239
01:26:20,239 --> 01:26:22,719
is brew install llvm and this is going

2240
01:26:22,719 --> 01:26:25,440
to install these two compilers on your

2241
01:26:25,440 --> 01:26:28,159
mac system so once you do that you will

2242
01:26:28,159 --> 01:26:30,800
have them stored somewhere let's go to

2243
01:26:30,800 --> 01:26:33,199
the install link and we're going to see

2244
01:26:33,199 --> 01:26:35,920
that homebrew is basically going to be

2245
01:26:35,920 --> 01:26:38,880
installed into things in your user local

2246
01:26:38,880 --> 01:26:41,520
directory on a mac device please tell me

2247
01:26:41,520 --> 01:26:43,760
if this is true for your case and if you

2248
01:26:43,760 --> 01:26:46,320
have a problem we'll try and go through

2249
01:26:46,320 --> 01:26:49,440
that and fix that up so if you are on a

2250
01:26:49,440 --> 01:26:51,120
mac i would really recommend going

2251
01:26:51,120 --> 01:26:53,440
through this to install homebrew once

2252
01:26:53,440 --> 01:26:55,199
you have that installed you will go

2253
01:26:55,199 --> 01:26:58,639
through that to install both of the llvm

2254
01:26:58,639 --> 01:27:01,520
compiler and the gcc compiler and that's

2255
01:27:01,520 --> 01:27:03,360
going to give you the latest versions

2256
01:27:03,360 --> 01:27:05,920
for these compilers to find out if they

2257
01:27:05,920 --> 01:27:08,560
will installed you can go in your user

2258
01:27:08,560 --> 01:27:11,040
local directory and you can hunt through

2259
01:27:11,040 --> 01:27:12,800
these compilers and you're going to find

2260
01:27:12,800 --> 01:27:15,440
binaries for them and start using them

2261
01:27:15,440 --> 01:27:17,440
to build your c plus plus applications

2262
01:27:17,440 --> 01:27:19,199
you okay so by now i am going to

2263
01:27:19,199 --> 01:27:21,840
consider that you have both gcc and a

2264
01:27:21,840 --> 01:27:24,400
clang installed on your mac system the

2265
01:27:24,400 --> 01:27:27,040
next logical thing to do is to want the

2266
01:27:27,040 --> 01:27:29,280
apple version of clang and i think

2267
01:27:29,280 --> 01:27:31,679
that's going to come as part of xcode

2268
01:27:31,679 --> 01:27:32,480
here

2269
01:27:32,480 --> 01:27:35,760
and it is going to come as a result of

2270
01:27:35,760 --> 01:27:38,400
running the command that we did before i

2271
01:27:38,400 --> 01:27:40,239
think it was this little command here

2272
01:27:40,239 --> 01:27:41,920
which is going to install everything you

2273
01:27:41,920 --> 01:27:43,520
need from the

2274
01:27:43,520 --> 01:27:44,840
xcode

2275
01:27:44,840 --> 01:27:47,360
ide so this is all i have to share in

2276
01:27:47,360 --> 01:27:49,920
this lecture again i apologize i don't

2277
01:27:49,920 --> 01:27:52,080
have access to a mac device but if you

2278
01:27:52,080 --> 01:27:53,600
have a problem you can tell me and i

2279
01:27:53,600 --> 01:27:56,239
will try to help you out and get this

2280
01:27:56,239 --> 01:27:57,440
sorted out

2281
01:27:57,440 --> 01:27:59,040
we are going to stop here in this

2282
01:27:59,040 --> 01:28:00,800
lecture the next one we're going to see

2283
01:28:00,800 --> 01:28:03,280
how we can install xcode on your mac

2284
01:28:03,280 --> 01:28:06,000
device go ahead and finish up here

2285
01:28:06,000 --> 01:28:07,440
and meet me there

2286
01:28:07,440 --> 01:28:09,280
in this video i am going to show you how

2287
01:28:09,280 --> 01:28:12,480
to install the visual studio code editor

2288
01:28:12,480 --> 01:28:15,120
on your mac os system please know that

2289
01:28:15,120 --> 01:28:17,840
you can also use other ides like x code

2290
01:28:17,840 --> 01:28:20,480
or code lite do c plus plus development

2291
01:28:20,480 --> 01:28:22,560
but visual studio code is going to be

2292
01:28:22,560 --> 01:28:25,520
our main editor in this course here and

2293
01:28:25,520 --> 01:28:27,600
i would recommend to install it so that

2294
01:28:27,600 --> 01:28:29,840
we are doing consistent things that's

2295
01:28:29,840 --> 01:28:31,920
going to reduce chances for you to get

2296
01:28:31,920 --> 01:28:34,560
confused so we are going to head over to

2297
01:28:34,560 --> 01:28:37,120
the website for visual studio code

2298
01:28:37,120 --> 01:28:40,159
and to get there we can just type visual

2299
01:28:40,159 --> 01:28:43,199
studio code in here on in our search

2300
01:28:43,199 --> 01:28:45,600
engine and we will have a link here that

2301
01:28:45,600 --> 01:28:47,920
we can use to download our fans

2302
01:28:47,920 --> 01:28:50,960
so we are going to go down and find

2303
01:28:50,960 --> 01:28:54,800
download links for windows linux and mac

2304
01:28:54,800 --> 01:28:57,280
please use the mac download button here

2305
01:28:57,280 --> 01:28:58,880
and you're going to download the binary

2306
01:28:58,880 --> 01:29:01,199
and install it i think it is going to be

2307
01:29:01,199 --> 01:29:03,840
in the download folder by default so all

2308
01:29:03,840 --> 01:29:05,040
you have to do

2309
01:29:05,040 --> 01:29:07,760
is drag that up in your installation

2310
01:29:07,760 --> 01:29:10,480
directory so that it becomes a runnable

2311
01:29:10,480 --> 01:29:12,239
application after you do that you're

2312
01:29:12,239 --> 01:29:14,480
going to run it and it is going to run

2313
01:29:14,480 --> 01:29:17,040
and you will have a user interface like

2314
01:29:17,040 --> 01:29:19,440
this with visual studio code opened up

2315
01:29:19,440 --> 01:29:21,600
once you have that up you will need to

2316
01:29:21,600 --> 01:29:24,000
install the c plus plus extension and

2317
01:29:24,000 --> 01:29:26,239
what you need to do is come to the

2318
01:29:26,239 --> 01:29:28,639
extensions tab here and type c and c

2319
01:29:28,639 --> 01:29:30,639
plus plus in here and you're going to

2320
01:29:30,639 --> 01:29:33,040
have an entry for microsoft click on

2321
01:29:33,040 --> 01:29:35,920
that and install this extension on your

2322
01:29:35,920 --> 01:29:38,239
system and your visual studio code

2323
01:29:38,239 --> 01:29:40,800
instance is going to be ready to handle

2324
01:29:40,800 --> 01:29:43,520
some c plus plus development and this is

2325
01:29:43,520 --> 01:29:44,960
really all i had to share in this

2326
01:29:44,960 --> 01:29:46,800
lecture showing you how you can get this

2327
01:29:46,800 --> 01:29:49,120
installed again i apologize i don't have

2328
01:29:49,120 --> 01:29:51,600
access to a mac device so i used my

2329
01:29:51,600 --> 01:29:54,560
linux box running inside window

2330
01:29:54,560 --> 01:29:56,639
subsystem for linux to show you this but

2331
01:29:56,639 --> 01:29:58,719
this is good enough i think if you have

2332
01:29:58,719 --> 01:30:00,800
a problem you can tell me and i will do

2333
01:30:00,800 --> 01:30:03,120
the best i can to help you out for now

2334
01:30:03,120 --> 01:30:05,280
we're going to stop here in this lecture

2335
01:30:05,280 --> 01:30:07,440
in the next one i will try and show you

2336
01:30:07,440 --> 01:30:09,920
how to set up a visual studio code to

2337
01:30:09,920 --> 01:30:12,080
use the compilers that we installed in

2338
01:30:12,080 --> 01:30:13,440
the last lecture

2339
01:30:13,440 --> 01:30:15,760
go ahead and finish up here and meet me

2340
01:30:15,760 --> 01:30:17,040
there

2341
01:30:17,040 --> 01:30:19,040
in this lecture i am going to try and

2342
01:30:19,040 --> 01:30:21,920
show you how to configure visual studio

2343
01:30:21,920 --> 01:30:24,239
code to use the compilers that we

2344
01:30:24,239 --> 01:30:26,639
installed on our mac system in a

2345
01:30:26,639 --> 01:30:28,639
previous lecture so we want visual

2346
01:30:28,639 --> 01:30:30,639
studio code to be able to pick up our

2347
01:30:30,639 --> 01:30:33,040
gcc compiler and use it we want it to

2348
01:30:33,040 --> 01:30:35,679
pick up our client compiler and use it

2349
01:30:35,679 --> 01:30:37,760
we also wanted to pick up our clanger

2350
01:30:37,760 --> 01:30:40,719
compiler from apple and use it to build

2351
01:30:40,719 --> 01:30:43,600
binaries that we can then run on our

2352
01:30:43,600 --> 01:30:46,560
system here so let's see how to do this

2353
01:30:46,560 --> 01:30:48,880
i have to say i don't own a mac device

2354
01:30:48,880 --> 01:30:51,360
so the best i can do here is describe

2355
01:30:51,360 --> 01:30:53,280
the process to you and if you have a

2356
01:30:53,280 --> 01:30:54,960
problem you can tell me i will do the

2357
01:30:54,960 --> 01:30:57,199
best i can to help you out okay so once

2358
01:30:57,199 --> 01:30:59,679
you have visual studio code installed

2359
01:30:59,679 --> 01:31:01,040
you're going to create a folder

2360
01:31:01,040 --> 01:31:03,360
somewhere and open visual studio code

2361
01:31:03,360 --> 01:31:06,080
from that folder and what you will

2362
01:31:06,080 --> 01:31:08,639
basically do is use the terminal to

2363
01:31:08,639 --> 01:31:10,159
navigate to a location you're going to

2364
01:31:10,159 --> 01:31:12,560
create a folder you can even call it cpp

2365
01:31:12,560 --> 01:31:14,560
template project you're going to hop

2366
01:31:14,560 --> 01:31:17,280
over into that folder and then open

2367
01:31:17,280 --> 01:31:19,920
visual studio code from that folder here

2368
01:31:19,920 --> 01:31:23,840
so for example we can hop over into cpp

2369
01:31:23,840 --> 01:31:26,800
and run code and say dot that's going to

2370
01:31:26,800 --> 01:31:29,600
open visual studio code in that folder

2371
01:31:29,600 --> 01:31:31,840
and from that folder you will create a

2372
01:31:31,840 --> 01:31:34,159
main cpp file by clicking on the plus

2373
01:31:34,159 --> 01:31:36,639
button here and you will create the cpp

2374
01:31:36,639 --> 01:31:39,280
file call it main cpp and you can put in

2375
01:31:39,280 --> 01:31:42,639
the content here and once you have this

2376
01:31:42,639 --> 01:31:45,199
the next task is going to be to set up a

2377
01:31:45,199 --> 01:31:48,560
compiler to build this little thing so

2378
01:31:48,560 --> 01:31:50,719
once you have this project you will come

2379
01:31:50,719 --> 01:31:52,480
to terminal i think there's going to be

2380
01:31:52,480 --> 01:31:55,199
a terminal menu somewhere and you will

2381
01:31:55,199 --> 01:31:58,080
choose configure tasks once you do that

2382
01:31:58,080 --> 01:32:00,159
visual studio code is smart enough to

2383
01:32:00,159 --> 01:32:03,280
scan your system and find any compiler

2384
01:32:03,280 --> 01:32:05,520
you have installed the first thing that

2385
01:32:05,520 --> 01:32:07,679
is likely to be found is the apple

2386
01:32:07,679 --> 01:32:09,600
client compiler so you're going to find

2387
01:32:09,600 --> 01:32:10,880
a clone

2388
01:32:10,880 --> 01:32:12,880
plus plus compiler so you can choose

2389
01:32:12,880 --> 01:32:15,600
that and you can use that for the apple

2390
01:32:15,600 --> 01:32:18,000
client compiler we are lucky we even

2391
01:32:18,000 --> 01:32:20,639
have a tutorial on how to do that so if

2392
01:32:20,639 --> 01:32:23,120
we click on our extensions tab here and

2393
01:32:23,120 --> 01:32:25,760
choose our c and c plus plus

2394
01:32:25,760 --> 01:32:26,960
extension

2395
01:32:26,960 --> 01:32:28,880
if we scroll down we're going to see a

2396
01:32:28,880 --> 01:32:32,080
link on using the client on mac os here

2397
01:32:32,080 --> 01:32:33,600
this is going to give us all the

2398
01:32:33,600 --> 01:32:36,159
instructions we need to use visual

2399
01:32:36,159 --> 01:32:38,719
studio code with the client compiler

2400
01:32:38,719 --> 01:32:41,600
from the apple company so if you scroll

2401
01:32:41,600 --> 01:32:43,120
down you're going to be able to read up

2402
01:32:43,120 --> 01:32:45,600
on all this but what i really want you

2403
01:32:45,600 --> 01:32:47,760
to see is the configuration file you're

2404
01:32:47,760 --> 01:32:49,280
going to see that it's going to be using

2405
01:32:49,280 --> 01:32:51,679
the clang compiler from the user bin

2406
01:32:51,679 --> 01:32:54,639
directory and this is mostly going to be

2407
01:32:54,639 --> 01:32:57,600
the clang version from the apple company

2408
01:32:57,600 --> 01:33:00,400
and sometimes you don't want this so if

2409
01:33:00,400 --> 01:33:02,560
you want to use the clang version that

2410
01:33:02,560 --> 01:33:04,960
we installed through home brew i think

2411
01:33:04,960 --> 01:33:07,199
you will need to go through the user

2412
01:33:07,199 --> 01:33:08,800
local directory because that's where

2413
01:33:08,800 --> 01:33:10,719
homebrew is going to put it you're going

2414
01:33:10,719 --> 01:33:12,000
to see that that's going to be the

2415
01:33:12,000 --> 01:33:14,159
location here from our tutorial and

2416
01:33:14,159 --> 01:33:16,480
you're going to hunt down for the clan

2417
01:33:16,480 --> 01:33:19,679
compiler and find your binary and that's

2418
01:33:19,679 --> 01:33:21,760
what we're going to be using next but

2419
01:33:21,760 --> 01:33:23,440
for the first time if you want to use

2420
01:33:23,440 --> 01:33:26,080
the clan compiler from apple this is the

2421
01:33:26,080 --> 01:33:28,080
configuration you need and all you need

2422
01:33:28,080 --> 01:33:30,639
to do in this case is change this to c

2423
01:33:30,639 --> 01:33:32,159
plus plus 20.

2424
01:33:32,159 --> 01:33:34,239
now once you have this configured you

2425
01:33:34,239 --> 01:33:35,840
will have the ability to come to

2426
01:33:35,840 --> 01:33:38,960
terminal let's show our files here you

2427
01:33:38,960 --> 01:33:40,320
will have the ability to come to

2428
01:33:40,320 --> 01:33:42,159
terminal and run task and choose the

2429
01:33:42,159 --> 01:33:44,480
compiler that's going to be the clang

2430
01:33:44,480 --> 01:33:46,719
compiler from apple but you can also

2431
01:33:46,719 --> 01:33:48,639
configure other compilers and all you

2432
01:33:48,639 --> 01:33:50,639
really have to do is choose them in the

2433
01:33:50,639 --> 01:33:52,800
list here and you're going to have a

2434
01:33:52,800 --> 01:33:55,760
configuration file it tasks

2435
01:33:55,760 --> 01:33:58,560
json file to be exact let's show that up

2436
01:33:58,560 --> 01:34:00,080
here

2437
01:34:00,080 --> 01:34:01,360
and that's going to give you the

2438
01:34:01,360 --> 01:34:03,600
instructions you need to build this

2439
01:34:03,600 --> 01:34:06,080
and in most cases you will just need to

2440
01:34:06,080 --> 01:34:07,679
be careful about the path to the

2441
01:34:07,679 --> 01:34:10,159
compiler so for example if you are using

2442
01:34:10,159 --> 01:34:12,239
the gcc version you installed through

2443
01:34:12,239 --> 01:34:14,719
homo brew you're going to find that in

2444
01:34:14,719 --> 01:34:17,120
your location you're going to make sure

2445
01:34:17,120 --> 01:34:19,520
that's the correct one and you will put

2446
01:34:19,520 --> 01:34:22,560
in these instructions here to tell your

2447
01:34:22,560 --> 01:34:25,520
compiler to build every single cpp file

2448
01:34:25,520 --> 01:34:28,080
in the directory here this is what we do

2449
01:34:28,080 --> 01:34:29,600
if you use clan you're going to have

2450
01:34:29,600 --> 01:34:32,080
something like this and again i am

2451
01:34:32,080 --> 01:34:34,080
describing this to you because i don't

2452
01:34:34,080 --> 01:34:36,639
have a mac available to me right now

2453
01:34:36,639 --> 01:34:38,239
and if you have a problem you can tell

2454
01:34:38,239 --> 01:34:41,040
me we can try and sort this out okay and

2455
01:34:41,040 --> 01:34:44,080
by this time you will have the ability

2456
01:34:44,080 --> 01:34:46,400
to use your visual studio code instance

2457
01:34:46,400 --> 01:34:47,760
and compile

2458
01:34:47,760 --> 01:34:50,560
c plus plus programs using either the

2459
01:34:50,560 --> 01:34:53,040
apple client compiler the llvm glango

2460
01:34:53,040 --> 01:34:55,520
compiler or the gcc compiler and all

2461
01:34:55,520 --> 01:34:57,360
these are going to be compiling in c

2462
01:34:57,360 --> 01:34:59,920
plus plus 20 mode again to both you need

2463
01:34:59,920 --> 01:35:02,000
to make sure you have the file selected

2464
01:35:02,000 --> 01:35:03,760
and choose whatever compiler you want to

2465
01:35:03,760 --> 01:35:05,920
use for example if you want to use clone

2466
01:35:05,920 --> 01:35:08,400
12 from homebrew you're going to you're

2467
01:35:08,400 --> 01:35:09,920
going to select that and it is going to

2468
01:35:09,920 --> 01:35:12,000
be used to build your project and you

2469
01:35:12,000 --> 01:35:13,600
will have the ability to run your

2470
01:35:13,600 --> 01:35:16,000
projects just like we do here and it is

2471
01:35:16,000 --> 01:35:18,080
going to work let's make sure we are

2472
01:35:18,080 --> 01:35:20,800
running rooster here our binary

2473
01:35:20,800 --> 01:35:23,119
and it is going to run and printer 0 and

2474
01:35:23,119 --> 01:35:25,520
this is going to work again i am really

2475
01:35:25,520 --> 01:35:27,199
sorry i don't have a mac device

2476
01:35:27,199 --> 01:35:28,400
available to me

2477
01:35:28,400 --> 01:35:31,040
but this is what i have to work with now

2478
01:35:31,040 --> 01:35:33,119
if you have a problem on a mac device

2479
01:35:33,119 --> 01:35:35,119
please tell me i will do the best i can

2480
01:35:35,119 --> 01:35:37,920
to help you out

2481
01:35:38,320 --> 01:35:40,239
in this lecture we're going to explore

2482
01:35:40,239 --> 01:35:43,679
the option to use online compilers if

2483
01:35:43,679 --> 01:35:46,159
for whatever reason we can't install a

2484
01:35:46,159 --> 01:35:49,520
radio compiler on our system and again

2485
01:35:49,520 --> 01:35:51,600
the goal is to be able to turn the code

2486
01:35:51,600 --> 01:35:54,800
we type into what looks like an ide

2487
01:35:54,800 --> 01:35:57,679
into a compiler and get a binary that we

2488
01:35:57,679 --> 01:36:00,880
can run and see the output of there are

2489
01:36:00,880 --> 01:36:03,040
a few online compilers that are very

2490
01:36:03,040 --> 01:36:05,920
popular within the c plus plus community

2491
01:36:05,920 --> 01:36:08,000
one box is one of them there is also

2492
01:36:08,000 --> 01:36:11,520
compiler explorer and kodiro but there

2493
01:36:11,520 --> 01:36:14,159
may be other ones out there if you do

2494
01:36:14,159 --> 01:36:16,480
research on your own we're going to go

2495
01:36:16,480 --> 01:36:19,199
to the browser and actually check each

2496
01:36:19,199 --> 01:36:22,000
of these out okay here we are in our

2497
01:36:22,000 --> 01:36:25,840
browser here i am on onebox.org

2498
01:36:25,840 --> 01:36:27,920
and you see that it really looks like an

2499
01:36:27,920 --> 01:36:30,159
ide inside we have the code we've been

2500
01:36:30,159 --> 01:36:32,960
running all along to make sure that it

2501
01:36:32,960 --> 01:36:36,080
compiles with c plus plus 20. on the

2502
01:36:36,080 --> 01:36:38,000
left here we have a few options we can

2503
01:36:38,000 --> 01:36:40,400
select which compiler we want to use you

2504
01:36:40,400 --> 01:36:42,719
see that there is a couple of gcc

2505
01:36:42,719 --> 01:36:43,840
versions

2506
01:36:43,840 --> 01:36:45,600
you can see that this is a really nice

2507
01:36:45,600 --> 01:36:48,159
way to test things across

2508
01:36:48,159 --> 01:36:51,920
gcc versions you see we have clan 12

2509
01:36:51,920 --> 01:36:54,480
so if you want to test clang out you can

2510
01:36:54,480 --> 01:36:57,679
select it let's actually try this

2511
01:36:57,679 --> 01:37:00,080
so we're going to use clang head

2512
01:37:00,080 --> 01:37:02,880
and try to compile this

2513
01:37:02,880 --> 01:37:06,560
so let's hit enter and see if clank 12

2514
01:37:06,560 --> 01:37:09,199
supports c plus plus 20

2515
01:37:09,199 --> 01:37:11,280
and you see that it really works clan

2516
01:37:11,280 --> 01:37:12,639
version 12

2517
01:37:12,639 --> 01:37:15,440
should support c plus plus 20 like this

2518
01:37:15,440 --> 01:37:17,040
let's go back to

2519
01:37:17,040 --> 01:37:20,400
gcc because that's what i like and you

2520
01:37:20,400 --> 01:37:22,400
can try putting different things in your

2521
01:37:22,400 --> 01:37:25,280
c plus plus code to see if the compiler

2522
01:37:25,280 --> 01:37:28,400
actually responds for example we can say

2523
01:37:28,400 --> 01:37:29,920
stdcl

2524
01:37:29,920 --> 01:37:31,440
hello there

2525
01:37:31,440 --> 01:37:33,679
stdendl

2526
01:37:33,679 --> 01:37:35,920
and if we run

2527
01:37:35,920 --> 01:37:37,280
we're going to see

2528
01:37:37,280 --> 01:37:40,000
the message output here another good

2529
01:37:40,000 --> 01:37:42,639
thing with these online compilers is

2530
01:37:42,639 --> 01:37:45,920
that you can share this code and anybody

2531
01:37:45,920 --> 01:37:48,000
will be able to look at the code here

2532
01:37:48,000 --> 01:37:50,639
and run it so this is a really good way

2533
01:37:50,639 --> 01:37:51,920
to

2534
01:37:51,920 --> 01:37:55,199
get help from your instructor so i do

2535
01:37:55,199 --> 01:37:57,679
encourage you if you run into a problem

2536
01:37:57,679 --> 01:37:59,679
come and use one of these compilers and

2537
01:37:59,679 --> 01:38:01,679
send me the link the way you can send

2538
01:38:01,679 --> 01:38:04,480
the link you can hit on share here this

2539
01:38:04,480 --> 01:38:07,040
button here you're going to get the url

2540
01:38:07,040 --> 01:38:09,679
that you can copy and send to anybody

2541
01:38:09,679 --> 01:38:12,080
and they will be able to see your code

2542
01:38:12,080 --> 01:38:14,000
just like we're going to see here in a

2543
01:38:14,000 --> 01:38:16,080
minute okay you see that it isn't the

2544
01:38:16,080 --> 01:38:18,400
exact same thing and anybody on the

2545
01:38:18,400 --> 01:38:20,320
internet will be able to see your code

2546
01:38:20,320 --> 01:38:22,560
and try to find whatever the problem is

2547
01:38:22,560 --> 01:38:24,159
and help you out

2548
01:38:24,159 --> 01:38:27,040
very fast one box is one compiler you

2549
01:38:27,040 --> 01:38:29,040
can play with the options that we have

2550
01:38:29,040 --> 01:38:31,360
here you can

2551
01:38:31,360 --> 01:38:33,520
load different libraries you see they

2552
01:38:33,520 --> 01:38:35,679
have a lot of boost libraries but this

2553
01:38:35,679 --> 01:38:38,400
is of no interest to us right now you

2554
01:38:38,400 --> 01:38:40,080
can play with it and see what you like

2555
01:38:40,080 --> 01:38:42,800
about it another one is kaliru which is

2556
01:38:42,800 --> 01:38:44,560
another online compiler you see it

2557
01:38:44,560 --> 01:38:47,119
doesn't have a lot of options like we

2558
01:38:47,119 --> 01:38:49,280
had in one box for example you cannot

2559
01:38:49,280 --> 01:38:51,280
change the compiler it's going to be

2560
01:38:51,280 --> 01:38:54,719
using g plus plus but if we hit compile

2561
01:38:54,719 --> 01:38:56,639
link and run it's going to run our code

2562
01:38:56,639 --> 01:38:58,800
and we're going to get the output here

2563
01:38:58,800 --> 01:39:00,960
again we can try and change this so that

2564
01:39:00,960 --> 01:39:02,960
you know i'm not lying to you so we can

2565
01:39:02,960 --> 01:39:04,960
say stdcl

2566
01:39:04,960 --> 01:39:07,280
and say the sky

2567
01:39:07,280 --> 01:39:09,119
is blue

2568
01:39:09,119 --> 01:39:12,560
std endl if you want you can hit control

2569
01:39:12,560 --> 01:39:15,360
plus on your browser and it's going to

2570
01:39:15,360 --> 01:39:17,600
make this a little bigger

2571
01:39:17,600 --> 01:39:21,600
and if we compile link and run

2572
01:39:21,600 --> 01:39:24,159
we should see the sky is blue in the

2573
01:39:24,159 --> 01:39:26,159
output window here this is really all

2574
01:39:26,159 --> 01:39:28,719
you can do with kolero and if you like

2575
01:39:28,719 --> 01:39:30,719
it you can donate to the developers i

2576
01:39:30,719 --> 01:39:32,960
think we have the same thing

2577
01:39:32,960 --> 01:39:36,400
on one box but it is in japanese so i

2578
01:39:36,400 --> 01:39:39,520
can't really read this

2579
01:39:39,520 --> 01:39:42,239
okay another one is compiler explorer

2580
01:39:42,239 --> 01:39:44,320
which is a really good one the main

2581
01:39:44,320 --> 01:39:46,560
purpose of this is really not giving you

2582
01:39:46,560 --> 01:39:49,280
the output it is actually seeing

2583
01:39:49,280 --> 01:39:52,239
assembly code that is generated for your

2584
01:39:52,239 --> 01:39:54,400
c plus plus code this is something a

2585
01:39:54,400 --> 01:39:56,639
little bit advanced for our purposes

2586
01:39:56,639 --> 01:39:58,719
here so we're going to ignore this we're

2587
01:39:58,719 --> 01:40:01,679
just going to be using it to test our

2588
01:40:01,679 --> 01:40:04,159
code with some of the popular compilers

2589
01:40:04,159 --> 01:40:07,040
if you look here on this drop box you

2590
01:40:07,040 --> 01:40:08,880
see that they also have a lot of

2591
01:40:08,880 --> 01:40:11,040
compilers you can use different gcc

2592
01:40:11,040 --> 01:40:13,600
compilers i think they have clan they

2593
01:40:13,600 --> 01:40:16,800
even have msvc how cool is this so you

2594
01:40:16,800 --> 01:40:20,080
can use a lot of compilers gcc clang you

2595
01:40:20,080 --> 01:40:22,080
see we have a lot of clan compilers we

2596
01:40:22,080 --> 01:40:23,760
have clang

2597
01:40:23,760 --> 01:40:26,480
11 here so this is a really good way to

2598
01:40:26,480 --> 01:40:28,960
try things out we're going to come back

2599
01:40:28,960 --> 01:40:30,639
to gcc

2600
01:40:30,639 --> 01:40:32,400
10 2

2601
01:40:32,400 --> 01:40:35,360
and i noticed that i passed the flag of

2602
01:40:35,360 --> 01:40:38,719
c plus 20 to be able to support c plus

2603
01:40:38,719 --> 01:40:41,520
plus 20. again if i come here in my code

2604
01:40:41,520 --> 01:40:44,159
and say stdc out

2605
01:40:44,159 --> 01:40:45,360
the sky

2606
01:40:45,360 --> 01:40:46,639
is white

2607
01:40:46,639 --> 01:40:48,239
don't worry about these errors they're

2608
01:40:48,239 --> 01:40:51,440
going to go away in a minute

2609
01:40:51,440 --> 01:40:53,440
let's wait for the program to compile

2610
01:40:53,440 --> 01:40:55,840
you see that it is compiling let's wait

2611
01:40:55,840 --> 01:40:58,800
a minute the sky is white and everything

2612
01:40:58,800 --> 01:40:59,920
is fine

2613
01:40:59,920 --> 01:41:01,920
if you don't see this output here it is

2614
01:41:01,920 --> 01:41:04,000
possible that you didn't check this

2615
01:41:04,000 --> 01:41:06,800
checkbox run the compiled output

2616
01:41:06,800 --> 01:41:08,320
so come to this

2617
01:41:08,320 --> 01:41:10,719
dropbox and make sure this is checked

2618
01:41:10,719 --> 01:41:13,040
and you should have a window like i have

2619
01:41:13,040 --> 01:41:16,239
here compiler explorer also allows you

2620
01:41:16,239 --> 01:41:18,880
to share your code with people on the

2621
01:41:18,880 --> 01:41:20,000
internet

2622
01:41:20,000 --> 01:41:22,960
let me see if i can find the option to

2623
01:41:22,960 --> 01:41:24,000
share

2624
01:41:24,000 --> 01:41:27,679
you come to this drop box and you get a

2625
01:41:27,679 --> 01:41:30,400
link here that you can copy

2626
01:41:30,400 --> 01:41:33,119
i'm going to copy this

2627
01:41:33,119 --> 01:41:36,000
and open a private window in my browser

2628
01:41:36,000 --> 01:41:38,480
here so that we know that it is some

2629
01:41:38,480 --> 01:41:39,440
other

2630
01:41:39,440 --> 01:41:42,400
browser that is going to be opening this

2631
01:41:42,400 --> 01:41:44,719
link and getting access to the same code

2632
01:41:44,719 --> 01:41:47,199
we have in compiler explorer and this is

2633
01:41:47,199 --> 01:41:48,719
going to be pretty cool

2634
01:41:48,719 --> 01:41:50,480
and you see that we get compiler

2635
01:41:50,480 --> 01:41:52,320
explorer privacy we're going to close

2636
01:41:52,320 --> 01:41:53,119
this

2637
01:41:53,119 --> 01:41:55,040
and you see that we have the same code

2638
01:41:55,040 --> 01:41:57,199
we can try modifying this code for

2639
01:41:57,199 --> 01:41:59,199
example we can take out this third line

2640
01:41:59,199 --> 01:42:01,440
here it's going to start compiling you

2641
01:42:01,440 --> 01:42:03,760
see that it is compiling and it is going

2642
01:42:03,760 --> 01:42:06,000
to give us the output that we expect

2643
01:42:06,000 --> 01:42:08,639
from this so this is a really good tool

2644
01:42:08,639 --> 01:42:11,760
to try out if you want to share your

2645
01:42:11,760 --> 01:42:14,320
code with some people that are not close

2646
01:42:14,320 --> 01:42:16,000
to you this is a really good way to do

2647
01:42:16,000 --> 01:42:18,719
this it is also good to try out

2648
01:42:18,719 --> 01:42:21,199
different compilers for example if you

2649
01:42:21,199 --> 01:42:24,320
don't have a gcc compiler you can try it

2650
01:42:24,320 --> 01:42:26,480
out here and see if it does things for

2651
01:42:26,480 --> 01:42:29,440
example we didn't install clang on our

2652
01:42:29,440 --> 01:42:32,000
system but we can try it out and see if

2653
01:42:32,000 --> 01:42:34,880
it runs or could but make sure you pass

2654
01:42:34,880 --> 01:42:37,360
the correct flats here because you are

2655
01:42:37,360 --> 01:42:39,600
responsible for this if you pass the

2656
01:42:39,600 --> 01:42:41,600
flats that don't work

2657
01:42:41,600 --> 01:42:43,679
you're going to get arrows for example

2658
01:42:43,679 --> 01:42:46,639
if we say hello here

2659
01:42:46,639 --> 01:42:47,920
we're going to get

2660
01:42:47,920 --> 01:42:49,840
weird arrows

2661
01:42:49,840 --> 01:42:52,880
and oh and recognize command line option

2662
01:42:52,880 --> 01:42:57,280
std hello but if we say c plus plus 20

2663
01:42:57,280 --> 01:42:59,119
it is going to work so make sure you

2664
01:42:59,119 --> 01:43:01,520
pass the correct options

2665
01:43:01,520 --> 01:43:03,199
in this lecture you're going to write

2666
01:43:03,199 --> 01:43:06,320
your first c plus 20 program and we're

2667
01:43:06,320 --> 01:43:08,639
going to start and attempt to understand

2668
01:43:08,639 --> 01:43:10,880
our program let's hop over to visual

2669
01:43:10,880 --> 01:43:13,440
studio code and actually do that the

2670
01:43:13,440 --> 01:43:15,679
first thing we want to do is to set up

2671
01:43:15,679 --> 01:43:18,480
our code so that we can open that in

2672
01:43:18,480 --> 01:43:20,880
visual studio code we're going to start

2673
01:43:20,880 --> 01:43:24,400
from our c plus 20 template project that

2674
01:43:24,400 --> 01:43:26,400
we set up in the last lecture

2675
01:43:26,400 --> 01:43:28,480
and i'm going to be doing the projects

2676
01:43:28,480 --> 01:43:31,280
for this chapter in this folder here so

2677
01:43:31,280 --> 01:43:33,440
we're going to do our very first c plus

2678
01:43:33,440 --> 01:43:35,679
plus program so what we're going to do

2679
01:43:35,679 --> 01:43:39,280
is go inside our c plus plus 20 template

2680
01:43:39,280 --> 01:43:40,560
project

2681
01:43:40,560 --> 01:43:42,719
and i noticed that we actually left in

2682
01:43:42,719 --> 01:43:45,520
the boiled files we don't want so

2683
01:43:45,520 --> 01:43:47,600
what we're going to do is remove this

2684
01:43:47,600 --> 01:43:49,199
main file

2685
01:43:49,199 --> 01:43:52,080
and that this vc 140 fan we don't want

2686
01:43:52,080 --> 01:43:54,080
these here

2687
01:43:54,080 --> 01:43:55,920
and we're going to copy

2688
01:43:55,920 --> 01:43:59,760
the main cpp file and the dot vs code

2689
01:43:59,760 --> 01:44:02,080
folder we're going to copy these things

2690
01:44:02,080 --> 01:44:04,800
and we're going to put them in our first

2691
01:44:04,800 --> 01:44:07,199
c plus plus program folder

2692
01:44:07,199 --> 01:44:08,960
and we're going to open this folder in

2693
01:44:08,960 --> 01:44:11,760
visual studio code visual studio code is

2694
01:44:11,760 --> 01:44:14,400
not opened up you see that i have my

2695
01:44:14,400 --> 01:44:17,280
developer powershell opened if you want

2696
01:44:17,280 --> 01:44:19,600
you can open visual studio code directly

2697
01:44:19,600 --> 01:44:21,520
without going through this if you're not

2698
01:44:21,520 --> 01:44:23,119
going to be using the visual studio

2699
01:44:23,119 --> 01:44:26,000
compiler but i want to have the option

2700
01:44:26,000 --> 01:44:28,320
to use that compiler so this is how i am

2701
01:44:28,320 --> 01:44:30,320
going to open my visual studio code

2702
01:44:30,320 --> 01:44:32,840
instance i am going to type

2703
01:44:32,840 --> 01:44:34,719
code.exe

2704
01:44:34,719 --> 01:44:37,280
to open this up i'm going to hit enter

2705
01:44:37,280 --> 01:44:39,679
and visual studio code is going to open

2706
01:44:39,679 --> 01:44:41,679
and it is going to open whatever we did

2707
01:44:41,679 --> 01:44:44,080
in the last lecture we don't want this

2708
01:44:44,080 --> 01:44:46,159
project because this is a template

2709
01:44:46,159 --> 01:44:48,159
project from the last chapter we're

2710
01:44:48,159 --> 01:44:51,280
going to close this folder go to file

2711
01:44:51,280 --> 01:44:52,639
and hit

2712
01:44:52,639 --> 01:44:54,960
close folder and we're going to open the

2713
01:44:54,960 --> 01:44:57,679
new folder we want to work on we're

2714
01:44:57,679 --> 01:45:00,560
going to go to file and hit open folder

2715
01:45:00,560 --> 01:45:02,239
we're going to go to the location where

2716
01:45:02,239 --> 01:45:04,239
our project is so you're going to go

2717
01:45:04,239 --> 01:45:06,080
where yours is i'm going to browse to

2718
01:45:06,080 --> 01:45:07,040
mine

2719
01:45:07,040 --> 01:45:08,960
and i'm going to go in the current

2720
01:45:08,960 --> 01:45:12,960
chapter and choose 3 2 first c plus plus

2721
01:45:12,960 --> 01:45:14,000
program

2722
01:45:14,000 --> 01:45:16,639
i'm going to select the folder

2723
01:45:16,639 --> 01:45:18,480
it's going to open up and you're going

2724
01:45:18,480 --> 01:45:20,800
to see that our settings from

2725
01:45:20,800 --> 01:45:24,400
the last template project are still

2726
01:45:24,400 --> 01:45:27,040
valid here they were copied over if we

2727
01:45:27,040 --> 01:45:29,040
open the main cpp file it's going to be

2728
01:45:29,040 --> 01:45:30,639
the main thing we had in the last

2729
01:45:30,639 --> 01:45:31,679
lecture

2730
01:45:31,679 --> 01:45:32,400
so

2731
01:45:32,400 --> 01:45:34,960
we have the option to run task you're

2732
01:45:34,960 --> 01:45:37,119
going to see that we have two compilers

2733
01:45:37,119 --> 01:45:39,760
available and this is really good we are

2734
01:45:39,760 --> 01:45:42,400
ready to start using this let's try and

2735
01:45:42,400 --> 01:45:45,119
build this with gcc

2736
01:45:45,119 --> 01:45:47,199
and we're going to have our binary

2737
01:45:47,199 --> 01:45:48,480
created

2738
01:45:48,480 --> 01:45:51,440
we can click in the terminal here

2739
01:45:51,440 --> 01:45:53,360
and if we want to open the terminal

2740
01:45:53,360 --> 01:45:54,880
again we have the option to come in

2741
01:45:54,880 --> 01:45:57,840
terminal and new terminal this is going

2742
01:45:57,840 --> 01:46:00,480
to open this up if we do dir in the

2743
01:46:00,480 --> 01:46:01,679
terminal

2744
01:46:01,679 --> 01:46:04,560
we're going to see our program generated

2745
01:46:04,560 --> 01:46:07,679
we can remove this thing here and say rm

2746
01:46:07,679 --> 01:46:08,719
rooster

2747
01:46:08,719 --> 01:46:13,520
dot exe and remove this we can clear

2748
01:46:13,520 --> 01:46:15,679
and we have a clean project we can start

2749
01:46:15,679 --> 01:46:17,840
learning from okay now we have the

2750
01:46:17,840 --> 01:46:20,159
project and it is building successfully

2751
01:46:20,159 --> 01:46:22,639
let's try to understand the code we have

2752
01:46:22,639 --> 01:46:25,280
in here the first statement we have it

2753
01:46:25,280 --> 01:46:28,000
this include io stream thung

2754
01:46:28,000 --> 01:46:31,040
this is a feature c plus plus offers to

2755
01:46:31,040 --> 01:46:34,000
load the pro built libraries that we can

2756
01:46:34,000 --> 01:46:37,040
use iostream is specifically going to

2757
01:46:37,040 --> 01:46:39,600
help us print thanks to the console

2758
01:46:39,600 --> 01:46:42,000
we've seen that we can for example print

2759
01:46:42,000 --> 01:46:43,280
hello world

2760
01:46:43,280 --> 01:46:44,480
if we want

2761
01:46:44,480 --> 01:46:47,600
let's take out all these things in here

2762
01:46:47,600 --> 01:46:51,679
and say std column column c out

2763
01:46:51,679 --> 01:46:54,639
this is coming from i iostream and we're

2764
01:46:54,639 --> 01:46:57,440
going to put two less than symbols we're

2765
01:46:57,440 --> 01:46:59,920
going to open two quotes and inside

2766
01:46:59,920 --> 01:47:02,080
we're going to type hello world

2767
01:47:02,080 --> 01:47:05,040
and we're going to go outside the quotes

2768
01:47:05,040 --> 01:47:09,520
and do two less than signs and say std

2769
01:47:09,520 --> 01:47:12,320
colon colon endl

2770
01:47:12,320 --> 01:47:14,800
and put a semicolon this is going to

2771
01:47:14,800 --> 01:47:16,960
print things on the console if we run

2772
01:47:16,960 --> 01:47:18,400
this program

2773
01:47:18,400 --> 01:47:21,520
so if we run this program the first

2774
01:47:21,520 --> 01:47:23,600
thing we need to do is to build this

2775
01:47:23,600 --> 01:47:26,719
program so we can come to terminal task

2776
01:47:26,719 --> 01:47:29,760
and we're going to build it with gcc and

2777
01:47:29,760 --> 01:47:32,480
after we've built it we can hit enter to

2778
01:47:32,480 --> 01:47:34,239
close the terminal

2779
01:47:34,239 --> 01:47:36,880
and we can do dirt to see the content of

2780
01:47:36,880 --> 01:47:38,800
the folder you see that a program has

2781
01:47:38,800 --> 01:47:41,600
been generated we can run it and if we

2782
01:47:41,600 --> 01:47:43,440
run it it's going to say hello world

2783
01:47:43,440 --> 01:47:46,320
this message is coming from this

2784
01:47:46,320 --> 01:47:48,560
statement here and we have this

2785
01:47:48,560 --> 01:47:51,679
statement because we have included io

2786
01:47:51,679 --> 01:47:54,400
stream to really make this super clear

2787
01:47:54,400 --> 01:47:57,040
we can try to remove this line that says

2788
01:47:57,040 --> 01:47:59,040
include io stream

2789
01:47:59,040 --> 01:48:00,960
and the moment we do that you're going

2790
01:48:00,960 --> 01:48:03,280
to see that this tab says we have

2791
01:48:03,280 --> 01:48:04,480
problems

2792
01:48:04,480 --> 01:48:07,040
and if you open this tab

2793
01:48:07,040 --> 01:48:08,639
you're going to see the message

2794
01:48:08,639 --> 01:48:11,600
namespace sdd has no member c out name

2795
01:48:11,600 --> 01:48:14,639
space std has no member a and dl

2796
01:48:14,639 --> 01:48:16,080
this is because

2797
01:48:16,080 --> 01:48:18,480
the z plus plus program doesn't know

2798
01:48:18,480 --> 01:48:21,440
what sddc out means because we don't

2799
01:48:21,440 --> 01:48:23,840
have the library included and you also

2800
01:48:23,840 --> 01:48:25,920
see that we have these squiggly lines to

2801
01:48:25,920 --> 01:48:27,920
make it really clear that we have a

2802
01:48:27,920 --> 01:48:30,639
problem so to really be able to use this

2803
01:48:30,639 --> 01:48:34,159
we have to include a third party library

2804
01:48:34,159 --> 01:48:36,400
that brings these features into our

2805
01:48:36,400 --> 01:48:38,800
program and that's what the include

2806
01:48:38,800 --> 01:48:41,119
statement here is really doing so let's

2807
01:48:41,119 --> 01:48:42,800
bring this in

2808
01:48:42,800 --> 01:48:46,800
and we're going to say i o stream again

2809
01:48:46,800 --> 01:48:48,880
and let's wait and see that the problem

2810
01:48:48,880 --> 01:48:50,159
goes away

2811
01:48:50,159 --> 01:48:51,920
and the one thing you should really know

2812
01:48:51,920 --> 01:48:54,320
is that we don't have a semicolon at the

2813
01:48:54,320 --> 01:48:57,440
end of the io stream statement we don't

2814
01:48:57,440 --> 01:49:00,159
need to put it there but many c

2815
01:49:00,159 --> 01:49:03,040
plus plus statements need a semicolon at

2816
01:49:03,040 --> 01:49:04,080
the end

2817
01:49:04,080 --> 01:49:06,320
okay i think this really makes it clear

2818
01:49:06,320 --> 01:49:09,679
what the include statement here is doing

2819
01:49:09,679 --> 01:49:11,920
the other thing we have in our program

2820
01:49:11,920 --> 01:49:15,360
is this ant main parenthesis

2821
01:49:15,360 --> 01:49:17,520
curly braces thing

2822
01:49:17,520 --> 01:49:19,760
this thing here is called the main

2823
01:49:19,760 --> 01:49:20,800
function

2824
01:49:20,800 --> 01:49:23,520
a function in c plus plus is a block of

2825
01:49:23,520 --> 01:49:26,080
code that does a lot of things

2826
01:49:26,080 --> 01:49:28,880
but the main function here is special

2827
01:49:28,880 --> 01:49:31,360
because it is the starting point of your

2828
01:49:31,360 --> 01:49:33,440
c plus plus program

2829
01:49:33,440 --> 01:49:36,000
we also call the main function the entry

2830
01:49:36,000 --> 01:49:38,719
point of the c plus plus program and

2831
01:49:38,719 --> 01:49:41,040
what that means is that if you open the

2832
01:49:41,040 --> 01:49:43,760
program the main function is going to be

2833
01:49:43,760 --> 01:49:46,239
the very first thing that is going to

2834
01:49:46,239 --> 01:49:48,080
run and the things are going to be

2835
01:49:48,080 --> 01:49:50,880
executed in the main function in order

2836
01:49:50,880 --> 01:49:52,880
so the statement on the top is going to

2837
01:49:52,880 --> 01:49:55,280
run first and the statement after that

2838
01:49:55,280 --> 01:49:57,360
until we hit the end of the function so

2839
01:49:57,360 --> 01:49:59,360
this is what we mean here to really

2840
01:49:59,360 --> 01:50:02,159
drive this home we can come here in our

2841
01:50:02,159 --> 01:50:05,520
main function and say sdd

2842
01:50:05,520 --> 01:50:06,880
number one

2843
01:50:06,880 --> 01:50:11,520
and say sdd engl and by the way this e n

2844
01:50:11,520 --> 01:50:13,840
d l statement is going to print a new

2845
01:50:13,840 --> 01:50:14,960
line

2846
01:50:14,960 --> 01:50:16,080
we're going to

2847
01:50:16,080 --> 01:50:19,520
see it in effect in a moment let's

2848
01:50:19,520 --> 01:50:22,000
actually take it out so that we can see

2849
01:50:22,000 --> 01:50:25,199
its effect we're going to also do sddc

2850
01:50:25,199 --> 01:50:28,000
out number two

2851
01:50:28,000 --> 01:50:30,159
and what this is going to do

2852
01:50:30,159 --> 01:50:33,280
is to print number one and number two on

2853
01:50:33,280 --> 01:50:36,719
the terminal let's build this program

2854
01:50:36,719 --> 01:50:38,960
and if you want to build the default

2855
01:50:38,960 --> 01:50:42,080
task you can hit ctrl shift b for it to

2856
01:50:42,080 --> 01:50:44,719
happen very fast but i am always going

2857
01:50:44,719 --> 01:50:47,520
to come here so that it is really clear

2858
01:50:47,520 --> 01:50:50,239
what i am doing a program should be

2859
01:50:50,239 --> 01:50:53,599
generated now if we try to run it

2860
01:50:53,599 --> 01:50:55,000
by typing

2861
01:50:55,000 --> 01:50:58,080
rooster.exe and again we can hit

2862
01:50:58,080 --> 01:51:01,119
the app arrow button on our keyboard so

2863
01:51:01,119 --> 01:51:03,760
that's the last command that we run from

2864
01:51:03,760 --> 01:51:05,760
this terminal runs and this is going to

2865
01:51:05,760 --> 01:51:07,840
speed things up a little bit so if we

2866
01:51:07,840 --> 01:51:10,080
run this program it should say number

2867
01:51:10,080 --> 01:51:13,199
one and number two as you see here

2868
01:51:13,199 --> 01:51:16,239
but these two things are cramped on one

2869
01:51:16,239 --> 01:51:19,040
line and the reason is we are not

2870
01:51:19,040 --> 01:51:21,679
printing new line characters after we

2871
01:51:21,679 --> 01:51:24,320
print number one and number two and we

2872
01:51:24,320 --> 01:51:28,000
can solve this problem by putting in two

2873
01:51:28,000 --> 01:51:31,440
less than symbols and saying std column

2874
01:51:31,440 --> 01:51:33,679
column e n d l

2875
01:51:33,679 --> 01:51:35,440
this is going to put a new line

2876
01:51:35,440 --> 01:51:38,000
character after number one we can build

2877
01:51:38,000 --> 01:51:39,119
again

2878
01:51:39,119 --> 01:51:42,159
for our new changes to tech effect

2879
01:51:42,159 --> 01:51:43,679
after we do that we click on the

2880
01:51:43,679 --> 01:51:46,800
terminal hit enter we hit the app arrow

2881
01:51:46,800 --> 01:51:48,880
button if we run it's going to say

2882
01:51:48,880 --> 01:51:51,599
number one and number two on two

2883
01:51:51,599 --> 01:51:54,159
separate lines because we are printing a

2884
01:51:54,159 --> 01:51:56,639
new line character after number one i

2885
01:51:56,639 --> 01:51:58,719
really hope this makes sense

2886
01:51:58,719 --> 01:52:00,960
please do take some time to play with us

2887
01:52:00,960 --> 01:52:02,960
because if this is the first time you're

2888
01:52:02,960 --> 01:52:05,280
doing this some things might not be

2889
01:52:05,280 --> 01:52:08,000
clear and the best way to really make

2890
01:52:08,000 --> 01:52:10,880
sense of this is to type code run it and

2891
01:52:10,880 --> 01:52:13,119
see the effect of what you type by

2892
01:52:13,119 --> 01:52:15,119
running your program so let's do this a

2893
01:52:15,119 --> 01:52:17,280
couple of times we're going to do sdd

2894
01:52:17,280 --> 01:52:19,119
endl

2895
01:52:19,119 --> 01:52:20,400
after

2896
01:52:20,400 --> 01:52:22,960
the statement for number two we're going

2897
01:52:22,960 --> 01:52:25,360
to do stdc out

2898
01:52:25,360 --> 01:52:28,080
number three

2899
01:52:28,159 --> 01:52:32,080
and we're going to do stdeandl

2900
01:52:32,080 --> 01:52:34,719
to really show the problem again we're

2901
01:52:34,719 --> 01:52:36,040
going to take out

2902
01:52:36,040 --> 01:52:39,280
stdendl on the number two line

2903
01:52:39,280 --> 01:52:41,920
we are going to weld the build is going

2904
01:52:41,920 --> 01:52:43,520
to be successful

2905
01:52:43,520 --> 01:52:45,599
we're going to click in the terminal hit

2906
01:52:45,599 --> 01:52:48,480
enter hit the app arrow button run the

2907
01:52:48,480 --> 01:52:50,159
program again and you're going to see

2908
01:52:50,159 --> 01:52:52,239
it's saying number one it's going on the

2909
01:52:52,239 --> 01:52:55,199
new line printing number two but we not

2910
01:52:55,199 --> 01:52:57,199
to jump into the new line from number

2911
01:52:57,199 --> 01:52:59,920
two so number two and number three are

2912
01:52:59,920 --> 01:53:02,320
going to be cramped on one line that's

2913
01:53:02,320 --> 01:53:04,800
what we see here we can solve this again

2914
01:53:04,800 --> 01:53:07,440
by putting in a new line after number

2915
01:53:07,440 --> 01:53:08,639
two

2916
01:53:08,639 --> 01:53:10,480
let's do std

2917
01:53:10,480 --> 01:53:12,480
e and d l here

2918
01:53:12,480 --> 01:53:14,960
and uh this should solve the problem

2919
01:53:14,960 --> 01:53:17,280
again let's build we're going to run our

2920
01:53:17,280 --> 01:53:19,760
build task the build is going to be

2921
01:53:19,760 --> 01:53:21,440
successful we're going to hit the app

2922
01:53:21,440 --> 01:53:23,599
arrow to run the program if we run it

2923
01:53:23,599 --> 01:53:25,840
it's going to say number one number two

2924
01:53:25,840 --> 01:53:28,880
and number three and this is really good

2925
01:53:28,880 --> 01:53:31,599
now it should be clear that statements

2926
01:53:31,599 --> 01:53:34,400
in the main function are run in order

2927
01:53:34,400 --> 01:53:36,719
from top to bottom and that the program

2928
01:53:36,719 --> 01:53:40,320
is going to end when it hits the end of

2929
01:53:40,320 --> 01:53:43,520
this curly brace that includes our

2930
01:53:43,520 --> 01:53:45,599
function we're going to have a chance to

2931
01:53:45,599 --> 01:53:47,679
learn more about functions

2932
01:53:47,679 --> 01:53:50,400
in detail later in the course but we are

2933
01:53:50,400 --> 01:53:52,080
just getting started and we need to

2934
01:53:52,080 --> 01:53:54,080
start somewhere so that's why we're

2935
01:53:54,080 --> 01:53:56,400
doing this main function thing here

2936
01:53:56,400 --> 01:53:59,520
another thing you can do is return from

2937
01:53:59,520 --> 01:54:02,560
the main function and in many examples

2938
01:54:02,560 --> 01:54:05,199
you will see people do return 0

2939
01:54:05,199 --> 01:54:06,800
something like this

2940
01:54:06,800 --> 01:54:09,360
and this is a way for the main function

2941
01:54:09,360 --> 01:54:12,239
to send the message to the operating

2942
01:54:12,239 --> 01:54:15,280
system if it's finished successfully or

2943
01:54:15,280 --> 01:54:17,599
if there was some kind of problem

2944
01:54:17,599 --> 01:54:19,520
we're not going to go into any more

2945
01:54:19,520 --> 01:54:21,360
details about the main function because

2946
01:54:21,360 --> 01:54:22,560
that's really

2947
01:54:22,560 --> 01:54:25,119
too much for now we are just getting

2948
01:54:25,119 --> 01:54:27,840
started we are trying to get a feel of

2949
01:54:27,840 --> 01:54:30,719
how c plus works the main message here

2950
01:54:30,719 --> 01:54:33,280
is really that you should be able to

2951
01:54:33,280 --> 01:54:36,560
print things to the console using sddc

2952
01:54:36,560 --> 01:54:38,880
out you should be able to print a new

2953
01:54:38,880 --> 01:54:40,960
line after your message

2954
01:54:40,960 --> 01:54:45,880
using sdd ndl this stdc out and

2955
01:54:45,880 --> 01:54:49,599
stdendl thank come from the iostream

2956
01:54:49,599 --> 01:54:52,239
library that we are including here

2957
01:54:52,239 --> 01:54:53,920
if we don't include this library we're

2958
01:54:53,920 --> 01:54:56,159
going to have problems because

2959
01:54:56,159 --> 01:54:58,480
our surplus plus program is not going to

2960
01:54:58,480 --> 01:55:00,960
know where they are coming from so we

2961
01:55:00,960 --> 01:55:03,280
should really put this in if we want to

2962
01:55:03,280 --> 01:55:04,960
use these features

2963
01:55:04,960 --> 01:55:07,679
and we can return from a function to let

2964
01:55:07,679 --> 01:55:10,560
the system know the operating system

2965
01:55:10,560 --> 01:55:13,599
if the program finished up successfully

2966
01:55:13,599 --> 01:55:16,320
or if there was some kind of problem and

2967
01:55:16,320 --> 01:55:18,400
again this project is using the

2968
01:55:18,400 --> 01:55:20,320
templates we've done before

2969
01:55:20,320 --> 01:55:22,480
and this is really all we set out to do

2970
01:55:22,480 --> 01:55:25,199
in this lecture trying to make sense of

2971
01:55:25,199 --> 01:55:27,679
the main function in c plus plus to

2972
01:55:27,679 --> 01:55:29,920
really practice these things i would

2973
01:55:29,920 --> 01:55:32,000
challenge you to write a c plus plus

2974
01:55:32,000 --> 01:55:34,159
program just like this that is going to

2975
01:55:34,159 --> 01:55:37,199
print your name 10 times try to do that

2976
01:55:37,199 --> 01:55:39,520
and if you have a problem please do ask

2977
01:55:39,520 --> 01:55:42,080
me and i will do the best i can to help

2978
01:55:42,080 --> 01:55:43,119
you out

2979
01:55:43,119 --> 01:55:44,800
this is really all we set out to do in

2980
01:55:44,800 --> 01:55:46,320
this lecture i hope you found it

2981
01:55:46,320 --> 01:55:48,159
interesting we're going to stop here in

2982
01:55:48,159 --> 01:55:49,760
this lecture in the next one we're going

2983
01:55:49,760 --> 01:55:52,239
to start and learn about comments in c

2984
01:55:52,239 --> 01:55:55,040
plus plus go ahead and finish up here

2985
01:55:55,040 --> 01:55:56,560
and meet me there

2986
01:55:56,560 --> 01:55:57,920
in this lecture we're going to learn

2987
01:55:57,920 --> 01:56:00,560
about comments and c plus plus

2988
01:56:00,560 --> 01:56:02,800
comments are the way to put some

2989
01:56:02,800 --> 01:56:05,920
messages in your c plus plus chord that

2990
01:56:05,920 --> 01:56:08,159
are really meant to be read by humans

2991
01:56:08,159 --> 01:56:10,320
and one way we have to do comments in c

2992
01:56:10,320 --> 01:56:12,560
plus plus is through this backslash

2993
01:56:12,560 --> 01:56:14,880
backslash thing we have here this is

2994
01:56:14,880 --> 01:56:17,040
going to comment out the line so the

2995
01:56:17,040 --> 01:56:18,719
compiler is really not going to care

2996
01:56:18,719 --> 01:56:20,639
about it it's going to think that it is

2997
01:56:20,639 --> 01:56:22,080
something that is meant for the

2998
01:56:22,080 --> 01:56:24,880
developer to see so this is a one line

2999
01:56:24,880 --> 01:56:26,880
comment and this is how you do it in c

3000
01:56:26,880 --> 01:56:29,520
plus plus you can also comment out a

3001
01:56:29,520 --> 01:56:31,760
block of code in your c plus bus code

3002
01:56:31,760 --> 01:56:33,360
and this is something that comes in

3003
01:56:33,360 --> 01:56:35,840
quite handy many times you put your

3004
01:56:35,840 --> 01:56:39,040
comment in a backslash star and a star

3005
01:56:39,040 --> 01:56:41,440
backslash like this this is going to

3006
01:56:41,440 --> 01:56:43,679
comment things out in your code and the

3007
01:56:43,679 --> 01:56:45,520
compiler is really not going to care

3008
01:56:45,520 --> 01:56:47,760
about this let's hop over to visual

3009
01:56:47,760 --> 01:56:50,239
studio code and actually play with us so

3010
01:56:50,239 --> 01:56:52,159
here we are in the folder that is going

3011
01:56:52,159 --> 01:56:54,239
to contain our code the first thing i'm

3012
01:56:54,239 --> 01:56:55,920
going to do is go through the template

3013
01:56:55,920 --> 01:56:58,639
project i'm going to copy my files

3014
01:56:58,639 --> 01:57:00,560
and i'm going to go up again and we're

3015
01:57:00,560 --> 01:57:02,480
going to be learning about comments so

3016
01:57:02,480 --> 01:57:04,480
i'm going to put this in the folder on

3017
01:57:04,480 --> 01:57:07,360
comments i am going to close whatever

3018
01:57:07,360 --> 01:57:09,760
folder we have opened in visual studio

3019
01:57:09,760 --> 01:57:11,760
code and i'm going to browse to the

3020
01:57:11,760 --> 01:57:14,159
location where my project on comment

3021
01:57:14,159 --> 01:57:15,360
says

3022
01:57:15,360 --> 01:57:17,920
my project is in this folder that is

3023
01:57:17,920 --> 01:57:20,080
named three three comments i'm going to

3024
01:57:20,080 --> 01:57:22,480
open the folder and if i open the main

3025
01:57:22,480 --> 01:57:25,199
cpp file i'm going to find the starter

3026
01:57:25,199 --> 01:57:27,360
project we're going to remove this const

3027
01:57:27,360 --> 01:57:29,280
eval thank because we're really not

3028
01:57:29,280 --> 01:57:31,520
ready to understand this yet it was in

3029
01:57:31,520 --> 01:57:33,440
here to help us

3030
01:57:33,440 --> 01:57:36,320
test that our compilers support c plus

3031
01:57:36,320 --> 01:57:38,719
plus 20. so we're going to remove this

3032
01:57:38,719 --> 01:57:40,480
and we're going to put in a message that

3033
01:57:40,480 --> 01:57:42,960
says hello world you already know how to

3034
01:57:42,960 --> 01:57:45,119
do that from the last lecture so we're

3035
01:57:45,119 --> 01:57:47,280
going to say sddc out

3036
01:57:47,280 --> 01:57:50,599
hello world and we're going to say

3037
01:57:50,599 --> 01:57:54,239
stdendl and don't forget this semicolon

3038
01:57:54,239 --> 01:57:55,920
at the end if you do you're going to

3039
01:57:55,920 --> 01:57:58,320
have problems so make sure your code

3040
01:57:58,320 --> 01:58:00,880
looks like this try to build it to make

3041
01:58:00,880 --> 01:58:03,920
sure it's working fine this is going to

3042
01:58:03,920 --> 01:58:07,119
run the gcc tasked world we can click on

3043
01:58:07,119 --> 01:58:09,280
the terminal here and it's going to

3044
01:58:09,280 --> 01:58:10,800
close the terminal

3045
01:58:10,800 --> 01:58:13,599
and we can open a new terminal here if

3046
01:58:13,599 --> 01:58:16,639
we want if we do dir we're going to find

3047
01:58:16,639 --> 01:58:19,360
our rooster program inside we can run it

3048
01:58:19,360 --> 01:58:21,679
and it's going to say hello world we

3049
01:58:21,679 --> 01:58:23,360
already know to do this from the last

3050
01:58:23,360 --> 01:58:25,440
lecture and in this one we are going to

3051
01:58:25,440 --> 01:58:28,159
be learning about comments the first

3052
01:58:28,159 --> 01:58:31,119
thing you can do is use slash slash so

3053
01:58:31,119 --> 01:58:32,639
let's do that

3054
01:58:32,639 --> 01:58:36,159
and uh let's put some message here this

3055
01:58:36,159 --> 01:58:40,080
branch and the iostream library this is

3056
01:58:40,080 --> 01:58:41,679
a nice message that is going to give

3057
01:58:41,679 --> 01:58:44,000
some more information about this

3058
01:58:44,000 --> 01:58:46,159
statement to whoever might be reading

3059
01:58:46,159 --> 01:58:48,159
this program and this is called a one

3060
01:58:48,159 --> 01:58:50,239
line comment you can really put this

3061
01:58:50,239 --> 01:58:52,320
wherever you want in your c plus plus

3062
01:58:52,320 --> 01:58:54,639
file we can go in the main function for

3063
01:58:54,639 --> 01:58:56,800
example and say this is going to print

3064
01:58:56,800 --> 01:58:59,119
hello world to the console or the

3065
01:58:59,119 --> 01:59:01,520
terminal we can really put this anywhere

3066
01:59:01,520 --> 01:59:03,840
we can even put it after the return

3067
01:59:03,840 --> 01:59:06,320
statement here and really put in

3068
01:59:06,320 --> 01:59:08,480
whatever piece of information we think

3069
01:59:08,480 --> 01:59:10,800
is going to make sense to wherever it's

3070
01:59:10,800 --> 01:59:13,599
going to be reading our program okay

3071
01:59:13,599 --> 01:59:16,239
this is how you do a line comment you

3072
01:59:16,239 --> 01:59:19,119
can also do comments across different

3073
01:59:19,119 --> 01:59:21,360
lines and the way you do that you put

3074
01:59:21,360 --> 01:59:23,040
that in the

3075
01:59:23,040 --> 01:59:27,440
slash star and go down and say star

3076
01:59:27,440 --> 01:59:29,679
slash like this and whatever is going to

3077
01:59:29,679 --> 01:59:31,760
be in the middle here is going to be a

3078
01:59:31,760 --> 01:59:33,920
comment this is usually called a block

3079
01:59:33,920 --> 01:59:36,320
comment you can put in whatever you want

3080
01:59:36,320 --> 01:59:38,880
so if you have a piece of text that you

3081
01:59:38,880 --> 01:59:40,560
would like to use as a comment in your

3082
01:59:40,560 --> 01:59:43,520
program this is one way you can do this

3083
01:59:43,520 --> 01:59:46,159
one thing you should know though is that

3084
01:59:46,159 --> 01:59:48,880
you cannot nest these things but before

3085
01:59:48,880 --> 01:59:50,480
we do that let's try to build our

3086
01:59:50,480 --> 01:59:52,960
program to really show that there is no

3087
01:59:52,960 --> 01:59:55,360
problem if we have these comments in the

3088
01:59:55,360 --> 01:59:58,320
world is successful and if we click on

3089
01:59:58,320 --> 02:00:00,719
this terminal and hit enter

3090
02:00:00,719 --> 02:00:03,599
and hit clear to clear things out in the

3091
02:00:03,599 --> 02:00:06,159
terminal we can try to run our rooster

3092
02:00:06,159 --> 02:00:08,080
program and it's going to say hello

3093
02:00:08,080 --> 02:00:10,800
world you see that all these green lines

3094
02:00:10,800 --> 02:00:12,960
which are comments are really not

3095
02:00:12,960 --> 02:00:15,360
affecting the program all the compiler

3096
02:00:15,360 --> 02:00:17,360
is going to care about is this include

3097
02:00:17,360 --> 02:00:19,440
thing it's going to care about the main

3098
02:00:19,440 --> 02:00:21,360
function here it's going to ignore these

3099
02:00:21,360 --> 02:00:23,599
green things it's going to be like these

3100
02:00:23,599 --> 02:00:26,000
green lines that are our comments are

3101
02:00:26,000 --> 02:00:28,400
not in there this is the effect comments

3102
02:00:28,400 --> 02:00:30,159
have in your program and we're going to

3103
02:00:30,159 --> 02:00:32,880
be using this a lot in this course

3104
02:00:32,880 --> 02:00:34,639
one thing you should know though is that

3105
02:00:34,639 --> 02:00:38,080
you cannot nest these block comments so

3106
02:00:38,080 --> 02:00:40,480
if you try to do something like this

3107
02:00:40,480 --> 02:00:44,000
and uh say this is one comment and uh

3108
02:00:44,000 --> 02:00:46,480
come again and say this is another

3109
02:00:46,480 --> 02:00:48,320
comment you see that we have problems

3110
02:00:48,320 --> 02:00:50,400
already nesting is not allowed you're

3111
02:00:50,400 --> 02:00:52,239
going to get a compiler error and we're

3112
02:00:52,239 --> 02:00:54,080
going to learn more about these errors

3113
02:00:54,080 --> 02:00:56,320
in the next lecture but don't do this

3114
02:00:56,320 --> 02:00:58,639
don't nest these block comments if you

3115
02:00:58,639 --> 02:01:00,800
do that you're going to get some

3116
02:01:00,800 --> 02:01:03,520
confusing errors and this is going to be

3117
02:01:03,520 --> 02:01:06,239
the cause for them so don't nest your

3118
02:01:06,239 --> 02:01:08,560
blog comments it's going to give you

3119
02:01:08,560 --> 02:01:10,880
headaches okay this is really all we set

3120
02:01:10,880 --> 02:01:12,560
out to do in this lecture learning about

3121
02:01:12,560 --> 02:01:15,199
comments in c plus plus you can do one

3122
02:01:15,199 --> 02:01:17,840
line comments on a single line like this

3123
02:01:17,840 --> 02:01:20,480
you can do block comments to comment out

3124
02:01:20,480 --> 02:01:23,679
a block of text you can't nest your blog

3125
02:01:23,679 --> 02:01:25,440
comments because that's going to give

3126
02:01:25,440 --> 02:01:27,520
you a lot of problems you don't want

3127
02:01:27,520 --> 02:01:31,760
that and really use comments wisely and

3128
02:01:31,760 --> 02:01:33,840
don't overdo it because it's going to

3129
02:01:33,840 --> 02:01:36,080
turn your program into a novel and i

3130
02:01:36,080 --> 02:01:38,320
don't think people want that so use this

3131
02:01:38,320 --> 02:01:40,080
feature when you need it to give some

3132
02:01:40,080 --> 02:01:42,000
more information about your code and

3133
02:01:42,000 --> 02:01:44,239
don't overdo this we are going to stop

3134
02:01:44,239 --> 02:01:46,000
here in this lecture the next one we're

3135
02:01:46,000 --> 02:01:48,320
going to learn about different kinds of

3136
02:01:48,320 --> 02:01:51,119
errors and warnings you can see in your

3137
02:01:51,119 --> 02:01:53,040
c plus plus program

3138
02:01:53,040 --> 02:01:55,679
go ahead and finish up here and meet me

3139
02:01:55,679 --> 02:01:57,440
there in this lecture we're going to

3140
02:01:57,440 --> 02:02:00,159
learn about errors and warnings in your

3141
02:02:00,159 --> 02:02:02,719
c plus plus programs there are three

3142
02:02:02,719 --> 02:02:05,520
kinds of errors or warnings you can get

3143
02:02:05,520 --> 02:02:08,080
you can get compile time errors you can

3144
02:02:08,080 --> 02:02:10,560
get runtime errors and you can get

3145
02:02:10,560 --> 02:02:13,119
warnings but what is really meant by

3146
02:02:13,119 --> 02:02:15,920
these things remember the ultimate goal

3147
02:02:15,920 --> 02:02:19,520
of every developer or every c plus plus

3148
02:02:19,520 --> 02:02:22,159
developer in our case here is to be able

3149
02:02:22,159 --> 02:02:25,679
to generate a binary executable file

3150
02:02:25,679 --> 02:02:28,080
from the c plus plus code and we have to

3151
02:02:28,080 --> 02:02:30,320
run the code through the compiler to be

3152
02:02:30,320 --> 02:02:32,400
able to do that and one thing you should

3153
02:02:32,400 --> 02:02:34,639
know is that there is a set of

3154
02:02:34,639 --> 02:02:36,159
requirements

3155
02:02:36,159 --> 02:02:38,880
that the compiler enforces on our code

3156
02:02:38,880 --> 02:02:40,880
for it to be able to compile

3157
02:02:40,880 --> 02:02:43,199
successfully and those requirements are

3158
02:02:43,199 --> 02:02:45,520
the rules really that we have to follow

3159
02:02:45,520 --> 02:02:47,599
in our c plus plus program and if we

3160
02:02:47,599 --> 02:02:49,280
break those rules we're going to get

3161
02:02:49,280 --> 02:02:51,360
problems and these problems are going to

3162
02:02:51,360 --> 02:02:54,000
come in the form of compile time errors

3163
02:02:54,000 --> 02:02:56,639
run time errors or warnings

3164
02:02:56,639 --> 02:02:59,599
let's look at compile time errors in

3165
02:02:59,599 --> 02:03:00,480
detail

3166
02:03:00,480 --> 02:03:02,400
here we have a simple c plus plus

3167
02:03:02,400 --> 02:03:05,599
program that has a few problems we have

3168
02:03:05,599 --> 02:03:08,239
forgotten to put the semicolon at the

3169
02:03:08,239 --> 02:03:12,239
end of our stdc out statement here and

3170
02:03:12,239 --> 02:03:14,320
the compiler is going to freak out

3171
02:03:14,320 --> 02:03:15,599
because of this

3172
02:03:15,599 --> 02:03:17,440
if we compile this program we're going

3173
02:03:17,440 --> 02:03:20,239
to get a bunch of errors and the ide is

3174
02:03:20,239 --> 02:03:22,719
going to show us this problem some ides

3175
02:03:22,719 --> 02:03:24,320
are going to give you different errors

3176
02:03:24,320 --> 02:03:27,119
for example here i was using codelite

3177
02:03:27,119 --> 02:03:28,800
and it was saying

3178
02:03:28,800 --> 02:03:31,840
error expected semicolon before return

3179
02:03:31,840 --> 02:03:33,760
or something like this so this is a

3180
02:03:33,760 --> 02:03:36,560
compiler error and if you have this kind

3181
02:03:36,560 --> 02:03:38,560
of errors your program is not going to

3182
02:03:38,560 --> 02:03:41,199
compile compilation is going to fail

3183
02:03:41,199 --> 02:03:42,960
you're going to get this error and

3184
02:03:42,960 --> 02:03:44,560
you're not going to get your binary

3185
02:03:44,560 --> 02:03:46,719
executable and when you have this you

3186
02:03:46,719 --> 02:03:48,719
basically have to go back and fix this

3187
02:03:48,719 --> 02:03:51,760
problem compile again and when you get

3188
02:03:51,760 --> 02:03:53,760
rid of these problems the compilation is

3189
02:03:53,760 --> 02:03:56,079
going to succeed this is what a compile

3190
02:03:56,079 --> 02:03:58,800
time error is another thing you can have

3191
02:03:58,800 --> 02:04:01,280
is the run time error this is not going

3192
02:04:01,280 --> 02:04:03,679
to cause a compile time error the

3193
02:04:03,679 --> 02:04:06,079
compilation is going to succeed but when

3194
02:04:06,079 --> 02:04:08,480
you run the program it's not going to do

3195
02:04:08,480 --> 02:04:11,199
what you intended it to do in the first

3196
02:04:11,199 --> 02:04:13,119
place for example you may want it to

3197
02:04:13,119 --> 02:04:16,159
print green on some user interface it's

3198
02:04:16,159 --> 02:04:18,480
going to print gray or whatever it's

3199
02:04:18,480 --> 02:04:20,560
really not going to do what you want so

3200
02:04:20,560 --> 02:04:22,400
it's a logical error that you have in

3201
02:04:22,400 --> 02:04:24,400
your program and you have to fix it to

3202
02:04:24,400 --> 02:04:26,880
get rid of this and another thing you

3203
02:04:26,880 --> 02:04:29,199
should know is that sometimes these run

3204
02:04:29,199 --> 02:04:32,480
time errors can cause your program to

3205
02:04:32,480 --> 02:04:35,119
fail and terminate immediately and we

3206
02:04:35,119 --> 02:04:37,199
say that the program has crashed we're

3207
02:04:37,199 --> 02:04:38,880
going to see an example of this in a

3208
02:04:38,880 --> 02:04:41,119
minute the last kind of problem you can

3209
02:04:41,119 --> 02:04:44,480
have in your program is a warning

3210
02:04:44,480 --> 02:04:46,880
this is a problem that is not serious

3211
02:04:46,880 --> 02:04:49,599
enough for the compiler to halt your

3212
02:04:49,599 --> 02:04:51,840
compilation compilation is going to

3213
02:04:51,840 --> 02:04:53,840
succeed but this is basically the

3214
02:04:53,840 --> 02:04:55,840
compiler telling you you are doing

3215
02:04:55,840 --> 02:04:58,480
something that has some problems and you

3216
02:04:58,480 --> 02:05:00,719
should really fix it before it becomes a

3217
02:05:00,719 --> 02:05:02,719
serious problem so that's going to be a

3218
02:05:02,719 --> 02:05:05,040
warning for example here you see some

3219
02:05:05,040 --> 02:05:07,840
compilers can warn you when you divide

3220
02:05:07,840 --> 02:05:10,079
stuff by zero and we're going to see how

3221
02:05:10,079 --> 02:05:12,000
this works the main message in this

3222
02:05:12,000 --> 02:05:14,320
lecture is that you may have problems in

3223
02:05:14,320 --> 02:05:16,960
your program and they are going to come

3224
02:05:16,960 --> 02:05:19,360
in three forms some are going to be

3225
02:05:19,360 --> 02:05:22,000
compile time errors some are going to be

3226
02:05:22,000 --> 02:05:24,480
run time errors some are going to be

3227
02:05:24,480 --> 02:05:26,639
warnings we are going to hop over to

3228
02:05:26,639 --> 02:05:28,880
visual studio code and actually play

3229
02:05:28,880 --> 02:05:31,840
with this okay here i am in visual

3230
02:05:31,840 --> 02:05:34,159
studio code the first thing i'm going to

3231
02:05:34,159 --> 02:05:36,000
do is to set up

3232
02:05:36,000 --> 02:05:37,760
the template project we're going to be

3233
02:05:37,760 --> 02:05:40,320
using in our project here the project is

3234
02:05:40,320 --> 02:05:42,480
going to leave in this folder errors and

3235
02:05:42,480 --> 02:05:44,880
warnings i am going to copy over the

3236
02:05:44,880 --> 02:05:47,440
files and i am going to go in the

3237
02:05:47,440 --> 02:05:48,880
current project we're going to be

3238
02:05:48,880 --> 02:05:51,440
working on and i am going to open this

3239
02:05:51,440 --> 02:05:53,840
folder in visual studio code i am going

3240
02:05:53,840 --> 02:05:56,400
to go to file close folder i am going to

3241
02:05:56,400 --> 02:05:58,800
close this one and i am going to open

3242
02:05:58,800 --> 02:06:01,119
our new project i am going to browse to

3243
02:06:01,119 --> 02:06:03,760
it the project is this one i am going to

3244
02:06:03,760 --> 02:06:06,239
select it and select folder and it is

3245
02:06:06,239 --> 02:06:08,480
going to open up in visual studio code i

3246
02:06:08,480 --> 02:06:10,719
am going to close this welcome screen

3247
02:06:10,719 --> 02:06:13,440
and open our main cpp file we are going

3248
02:06:13,440 --> 02:06:15,840
to get rid of this constable fan this is

3249
02:06:15,840 --> 02:06:18,159
a c plus plus 20 test

3250
02:06:18,159 --> 02:06:20,239
thing we had and we don't really need it

3251
02:06:20,239 --> 02:06:22,639
now we're going to get there in due time

3252
02:06:22,639 --> 02:06:25,199
what we want to see is compile time

3253
02:06:25,199 --> 02:06:28,000
errors we're going to put in our stdc

3254
02:06:28,000 --> 02:06:31,040
out statement hello world

3255
02:06:31,040 --> 02:06:33,199
as we usually do

3256
02:06:33,199 --> 02:06:36,480
we're going to end this stdndm and we're

3257
02:06:36,480 --> 02:06:37,520
going to

3258
02:06:37,520 --> 02:06:40,400
remove the semicolon on purpose and if

3259
02:06:40,400 --> 02:06:42,560
we try to compile our program like this

3260
02:06:42,560 --> 02:06:44,639
we're going to get a compile time error

3261
02:06:44,639 --> 02:06:47,040
this is what we want to see so let's try

3262
02:06:47,040 --> 02:06:49,440
and build our program we're going to run

3263
02:06:49,440 --> 02:06:52,880
the task to build with gcc and you see

3264
02:06:52,880 --> 02:06:55,280
that the world fails we're going to get

3265
02:06:55,280 --> 02:06:57,760
a bunch of errors in our terminal it's

3266
02:06:57,760 --> 02:07:00,560
going to say in function it main

3267
02:07:00,560 --> 02:07:03,840
expected a semicolon before return it's

3268
02:07:03,840 --> 02:07:05,920
going to try its best to tell you what

3269
02:07:05,920 --> 02:07:08,000
the problem is but sometimes these

3270
02:07:08,000 --> 02:07:10,639
errors can be really confusing in this

3271
02:07:10,639 --> 02:07:12,719
case it is really easy because we

3272
02:07:12,719 --> 02:07:15,440
introduced this error on purpose so

3273
02:07:15,440 --> 02:07:17,360
we're going to fix it in a minute but

3274
02:07:17,360 --> 02:07:19,199
before we do that i want you to see

3275
02:07:19,199 --> 02:07:21,520
these problems tab it is where the

3276
02:07:21,520 --> 02:07:23,440
problems are going to show up in visual

3277
02:07:23,440 --> 02:07:25,440
studio code so you should see your

3278
02:07:25,440 --> 02:07:28,480
problems in here or through the terminal

3279
02:07:28,480 --> 02:07:30,639
here okay one thing you should know is

3280
02:07:30,639 --> 02:07:32,960
that when you have a compiler arrow

3281
02:07:32,960 --> 02:07:34,960
compilation is not going to succeed and

3282
02:07:34,960 --> 02:07:36,719
you're not going to have your binary

3283
02:07:36,719 --> 02:07:39,040
file which is what you really want so to

3284
02:07:39,040 --> 02:07:41,599
fix this problem we're going to put in

3285
02:07:41,599 --> 02:07:43,840
our semicolon here we're going to build

3286
02:07:43,840 --> 02:07:46,079
again we're going to go to terminal run

3287
02:07:46,079 --> 02:07:49,119
task we're going to build with gcc and

3288
02:07:49,119 --> 02:07:50,560
this time you're going to see that

3289
02:07:50,560 --> 02:07:53,040
compilation is going to succeed and we

3290
02:07:53,040 --> 02:07:55,360
have our program here we can run it

3291
02:07:55,360 --> 02:07:57,119
through the terminal here so we're going

3292
02:07:57,119 --> 02:07:58,800
to click the terminal is going to go

3293
02:07:58,800 --> 02:08:01,679
away but we can open our own

3294
02:08:01,679 --> 02:08:04,400
and if we do dur we're going to see our

3295
02:08:04,400 --> 02:08:06,800
files in here and we can run our program

3296
02:08:06,800 --> 02:08:09,599
we can say rooster and if we run we're

3297
02:08:09,599 --> 02:08:12,239
going to have hello world so i hope this

3298
02:08:12,239 --> 02:08:14,960
really makes it very clear what a

3299
02:08:14,960 --> 02:08:18,480
compile time error as so this is one

3300
02:08:18,480 --> 02:08:20,800
kind of error you can get the other one

3301
02:08:20,800 --> 02:08:23,760
is around time error and this comes in

3302
02:08:23,760 --> 02:08:26,239
the form of things that don't work as

3303
02:08:26,239 --> 02:08:28,880
you really expected so let's say we are

3304
02:08:28,880 --> 02:08:31,199
trying to do some computation in our

3305
02:08:31,199 --> 02:08:32,320
program

3306
02:08:32,320 --> 02:08:33,119
we

3307
02:08:33,119 --> 02:08:37,280
try to take 7 and divide this by 0 for

3308
02:08:37,280 --> 02:08:39,840
example and this is a statement there is

3309
02:08:39,840 --> 02:08:42,320
a load in c plus plus so let's try and

3310
02:08:42,320 --> 02:08:44,719
build this and see what we get because

3311
02:08:44,719 --> 02:08:47,520
this is a common scenario where we have

3312
02:08:47,520 --> 02:08:49,840
run time errors we're going to run the

3313
02:08:49,840 --> 02:08:53,280
task to build with gcc okay if we do

3314
02:08:53,280 --> 02:08:55,599
this you see that world finished with

3315
02:08:55,599 --> 02:08:58,400
warnings we didn't get a compile time

3316
02:08:58,400 --> 02:09:01,440
arrow and our build was successful so to

3317
02:09:01,440 --> 02:09:03,679
really prove this i'm going to

3318
02:09:03,679 --> 02:09:06,400
go back in our directory i'm going to do

3319
02:09:06,400 --> 02:09:08,480
dur you're going to see that rooster is

3320
02:09:08,480 --> 02:09:10,719
there i'm going to remove it i'm going

3321
02:09:10,719 --> 02:09:12,119
to say

3322
02:09:12,119 --> 02:09:14,960
rooster.exe this is how we remove stuff

3323
02:09:14,960 --> 02:09:17,520
from the command line when i do this and

3324
02:09:17,520 --> 02:09:19,520
do dirt again the

3325
02:09:19,520 --> 02:09:21,840
executable file should be gone so let's

3326
02:09:21,840 --> 02:09:24,480
try and build with this statement and

3327
02:09:24,480 --> 02:09:25,840
and you're going to see that we get a

3328
02:09:25,840 --> 02:09:28,960
warning and not a compile time error

3329
02:09:28,960 --> 02:09:30,719
like we had here so we're going to go to

3330
02:09:30,719 --> 02:09:33,280
terminal run task we're going to build

3331
02:09:33,280 --> 02:09:35,360
with gcc and you're going to see that

3332
02:09:35,360 --> 02:09:37,679
we're going to have our executable here

3333
02:09:37,679 --> 02:09:39,840
but we had a warning and it's saying

3334
02:09:39,840 --> 02:09:42,960
that division by 0 was detected in our

3335
02:09:42,960 --> 02:09:45,920
program and it is a recipe for disaster

3336
02:09:45,920 --> 02:09:48,719
so why is it a disaster let's try and

3337
02:09:48,719 --> 02:09:51,760
run this program so we're going to

3338
02:09:51,760 --> 02:09:54,480
dirt to prove it's here and we're going

3339
02:09:54,480 --> 02:09:56,800
to run it if we run it it's going to say

3340
02:09:56,800 --> 02:09:59,440
hello world and it's going to end let's

3341
02:09:59,440 --> 02:10:02,400
try and actually use our own terminal to

3342
02:10:02,400 --> 02:10:04,719
see if we have a better chance of seeing

3343
02:10:04,719 --> 02:10:06,960
the problem here so i'm going to reveal

3344
02:10:06,960 --> 02:10:10,320
in explorer by clicking on main cpp and

3345
02:10:10,320 --> 02:10:12,800
i am going to try and open a terminal

3346
02:10:12,800 --> 02:10:15,199
window here powershell that we open

3347
02:10:15,199 --> 02:10:17,360
ourselves we've done this before

3348
02:10:17,360 --> 02:10:20,719
this shouldn't be new to you by now

3349
02:10:20,719 --> 02:10:23,199
so we're going to do dirt in here

3350
02:10:23,199 --> 02:10:24,560
and we're going to try and run the

3351
02:10:24,560 --> 02:10:27,520
program and it's going to run so so it's

3352
02:10:27,520 --> 02:10:30,480
not really giving us a run time error

3353
02:10:30,480 --> 02:10:33,360
here because we're not capturing this or

3354
02:10:33,360 --> 02:10:35,119
trying to use the result of this

3355
02:10:35,119 --> 02:10:36,639
division here we're just doing the

3356
02:10:36,639 --> 02:10:38,960
division which is a problem so let's try

3357
02:10:38,960 --> 02:10:40,800
and capture this we haven't learned

3358
02:10:40,800 --> 02:10:43,119
about variables yet but what we're going

3359
02:10:43,119 --> 02:10:46,239
to do now is do end value and we're

3360
02:10:46,239 --> 02:10:48,800
going to assign the result of this

3361
02:10:48,800 --> 02:10:51,360
division to this value and let's try

3362
02:10:51,360 --> 02:10:54,079
printing the result of dividing a number

3363
02:10:54,079 --> 02:10:56,880
by zero so we're going to do stdc out

3364
02:10:56,880 --> 02:10:59,119
and we're going to say value and this is

3365
02:10:59,119 --> 02:11:02,079
how you can print a value out on the

3366
02:11:02,079 --> 02:11:04,239
console okay now that we have this and

3367
02:11:04,239 --> 02:11:06,400
let's try and weld we're going to run

3368
02:11:06,400 --> 02:11:09,040
tasks and worldwide gcc we're going to

3369
02:11:09,040 --> 02:11:11,360
get the same warning but if we try to

3370
02:11:11,360 --> 02:11:13,599
run the program we're not going to get

3371
02:11:13,599 --> 02:11:17,040
what we expect let's run rooster exe we

3372
02:11:17,040 --> 02:11:19,440
expect it to say hello world and printed

3373
02:11:19,440 --> 02:11:21,440
the value but you see that it's really

3374
02:11:21,440 --> 02:11:23,360
struggling to print the value and it

3375
02:11:23,360 --> 02:11:26,239
gave up and ended immediately so this is

3376
02:11:26,239 --> 02:11:29,679
one example of a runtime error that you

3377
02:11:29,679 --> 02:11:31,599
can face in your program there are many

3378
02:11:31,599 --> 02:11:33,280
other kinds that we're going to see as

3379
02:11:33,280 --> 02:11:35,040
we progress in the course

3380
02:11:35,040 --> 02:11:37,440
here we are just trying to raise your

3381
02:11:37,440 --> 02:11:39,760
awareness on these problems so that you

3382
02:11:39,760 --> 02:11:41,760
can know how to fix them when they come

3383
02:11:41,760 --> 02:11:44,000
up okay so this is all i can share with

3384
02:11:44,000 --> 02:11:46,880
you now about runtime errors we also had

3385
02:11:46,880 --> 02:11:48,560
a chance to see that this is also going

3386
02:11:48,560 --> 02:11:50,800
to give you a warning and a visual

3387
02:11:50,800 --> 02:11:52,880
studio code here is also helping out

3388
02:11:52,880 --> 02:11:55,520
telling us that we may have a problem

3389
02:11:55,520 --> 02:11:58,320
it's turning the main cpp file yellow

3390
02:11:58,320 --> 02:11:59,920
and it's saying that there is one

3391
02:11:59,920 --> 02:12:02,159
problem in this file and if you go here

3392
02:12:02,159 --> 02:12:04,000
you're going to see that we have a

3393
02:12:04,000 --> 02:12:06,320
warning here okay so this is one way you

3394
02:12:06,320 --> 02:12:08,159
have to see this so this is not

3395
02:12:08,159 --> 02:12:09,599
recommended to do so we're going to

3396
02:12:09,599 --> 02:12:12,000
comment this out okay this is really all

3397
02:12:12,000 --> 02:12:14,719
i had to share in this lecture we had a

3398
02:12:14,719 --> 02:12:17,199
chance to look at compile time errors we

3399
02:12:17,199 --> 02:12:19,040
also had a chance to look at warnings

3400
02:12:19,040 --> 02:12:21,920
and run time errors using this example

3401
02:12:21,920 --> 02:12:24,079
if you get a warning it is a message the

3402
02:12:24,079 --> 02:12:26,159
compiler is giving you that you should

3403
02:12:26,159 --> 02:12:29,119
really look it up and fix the problem

3404
02:12:29,119 --> 02:12:32,000
before it becomes more serious compile

3405
02:12:32,000 --> 02:12:34,000
time errors are going to cause your

3406
02:12:34,000 --> 02:12:36,239
compilation to fail and that's a really

3407
02:12:36,239 --> 02:12:38,079
good thing because the compiler is going

3408
02:12:38,079 --> 02:12:41,280
to stop you from generating a binary

3409
02:12:41,280 --> 02:12:43,599
that doesn't really do what you expect

3410
02:12:43,599 --> 02:12:45,760
it to do so that's a good thing but

3411
02:12:45,760 --> 02:12:47,840
sometimes the compiler want to give you

3412
02:12:47,840 --> 02:12:50,239
a compile arrow and you have a chance to

3413
02:12:50,239 --> 02:12:52,400
run into a runtime error and that's

3414
02:12:52,400 --> 02:12:54,560
really bad so be careful about these

3415
02:12:54,560 --> 02:12:57,119
things and when you have problems visual

3416
02:12:57,119 --> 02:12:58,800
studio code is going to show you the

3417
02:12:58,800 --> 02:13:01,520
problem in terminal or in this problems

3418
02:13:01,520 --> 02:13:03,360
tab and you're going to be able to fix

3419
02:13:03,360 --> 02:13:05,199
it up we're going to stop here in this

3420
02:13:05,199 --> 02:13:06,800
lecture in the next one we're going to

3421
02:13:06,800 --> 02:13:09,360
learn a little more about statements and

3422
02:13:09,360 --> 02:13:11,520
functions go ahead and finish up here

3423
02:13:11,520 --> 02:13:13,520
and meet me there in this lecture we're

3424
02:13:13,520 --> 02:13:15,679
going to learn about a little more about

3425
02:13:15,679 --> 02:13:18,560
statements and functions in c plus plus

3426
02:13:18,560 --> 02:13:21,119
a statement is a basic unit of

3427
02:13:21,119 --> 02:13:23,760
computation in c plus plus you can say

3428
02:13:23,760 --> 02:13:26,880
that it is the smallest thing your cpu

3429
02:13:26,880 --> 02:13:30,000
can execute in your program every c plus

3430
02:13:30,000 --> 02:13:32,000
plus program is a collection of

3431
02:13:32,000 --> 02:13:33,760
statements so you're going to have a

3432
02:13:33,760 --> 02:13:37,040
bunch of statements that are organized

3433
02:13:37,040 --> 02:13:39,360
in a certain way to achieve whatever it

3434
02:13:39,360 --> 02:13:42,159
is you want and statements in c plus

3435
02:13:42,159 --> 02:13:44,960
plus must end with the semicolon we saw

3436
02:13:44,960 --> 02:13:47,440
in the last lecture that not putting

3437
02:13:47,440 --> 02:13:49,840
that semicolon is going to result in a

3438
02:13:49,840 --> 02:13:53,040
compile time error here is a basic

3439
02:13:53,040 --> 02:13:55,360
sample c plus plus program that we're

3440
02:13:55,360 --> 02:13:58,480
going to use to learn about statements

3441
02:13:58,480 --> 02:14:00,639
in the main function here we have two

3442
02:14:00,639 --> 02:14:03,360
variables declared we haven't really

3443
02:14:03,360 --> 02:14:05,360
learned about variables but they are a

3444
02:14:05,360 --> 02:14:08,239
way to store data in your program and

3445
02:14:08,239 --> 02:14:11,360
here we are storing two decimal numbers

3446
02:14:11,360 --> 02:14:13,840
one is called first number the second is

3447
02:14:13,840 --> 02:14:16,079
called second number we can do something

3448
02:14:16,079 --> 02:14:18,159
with these variables that we have in our

3449
02:14:18,159 --> 02:14:20,560
program for example we can add them to

3450
02:14:20,560 --> 02:14:23,280
have another variable in our program and

3451
02:14:23,280 --> 02:14:25,599
we can print that so you see here we are

3452
02:14:25,599 --> 02:14:28,880
saying stdc out the sum of two numbers

3453
02:14:28,880 --> 02:14:31,920
is sum so this is going to print 21

3454
02:14:31,920 --> 02:14:34,960
because it's going to add 12 and 9 and

3455
02:14:34,960 --> 02:14:36,480
the result of that is going to be

3456
02:14:36,480 --> 02:14:39,119
displayed on the terminal if we run this

3457
02:14:39,119 --> 02:14:41,360
program what i really want you to notice

3458
02:14:41,360 --> 02:14:44,320
is that this and first the number equals

3459
02:14:44,320 --> 02:14:47,840
12 thing is a statement in c plus plus

3460
02:14:47,840 --> 02:14:50,480
so it must end with a semicolon the line

3461
02:14:50,480 --> 02:14:52,719
here with second number is also a

3462
02:14:52,719 --> 02:14:55,280
statement so it must end with a

3463
02:14:55,280 --> 02:14:58,320
semicolon every single line we have here

3464
02:14:58,320 --> 02:14:59,920
in the main function is really a

3465
02:14:59,920 --> 02:15:02,639
statement and it must end with a

3466
02:15:02,639 --> 02:15:05,040
semicolon if we don't put the semicolon

3467
02:15:05,040 --> 02:15:07,119
in place we're going to get a compiler

3468
02:15:07,119 --> 02:15:09,040
error okay one other thing that is

3469
02:15:09,040 --> 02:15:11,520
really important to keep in mind is that

3470
02:15:11,520 --> 02:15:14,239
statements are executed in order in your

3471
02:15:14,239 --> 02:15:17,280
program and the order is from top to

3472
02:15:17,280 --> 02:15:19,520
bottom if you go back to our program

3473
02:15:19,520 --> 02:15:21,840
here so the first statement is the one

3474
02:15:21,840 --> 02:15:24,079
with first number here 12 is going to be

3475
02:15:24,079 --> 02:15:26,400
installed in memory when this statement

3476
02:15:26,400 --> 02:15:29,280
is executed by your computer and we're

3477
02:15:29,280 --> 02:15:31,360
going to go to the second statement with

3478
02:15:31,360 --> 02:15:33,280
second number and we're going to keep

3479
02:15:33,280 --> 02:15:35,760
going until we hit the end of the main

3480
02:15:35,760 --> 02:15:38,079
function and the return statement is

3481
02:15:38,079 --> 02:15:40,960
going to execute and when the main

3482
02:15:40,960 --> 02:15:43,440
function returns or terminates we're

3483
02:15:43,440 --> 02:15:45,920
going to get the return value sent to

3484
02:15:45,920 --> 02:15:47,920
your operating system and it's going to

3485
02:15:47,920 --> 02:15:50,800
know if your program ended successfully

3486
02:15:50,800 --> 02:15:52,800
or with a problem and the operating

3487
02:15:52,800 --> 02:15:54,880
system is going to know what to do with

3488
02:15:54,880 --> 02:15:57,199
that information execution keeps going

3489
02:15:57,199 --> 02:15:59,920
until we hit the end of the program or

3490
02:15:59,920 --> 02:16:02,079
if there is any other condition causing

3491
02:16:02,079 --> 02:16:04,000
for the program to terminate and we're

3492
02:16:04,000 --> 02:16:05,920
going to have more details about these

3493
02:16:05,920 --> 02:16:08,079
things later i just want you to know

3494
02:16:08,079 --> 02:16:10,880
that the statements are executed in

3495
02:16:10,880 --> 02:16:12,960
order in your main function another

3496
02:16:12,960 --> 02:16:14,960
concept i really want you to have an

3497
02:16:14,960 --> 02:16:18,239
idea about is the concept of functions a

3498
02:16:18,239 --> 02:16:20,239
function is really like a machine you

3499
02:16:20,239 --> 02:16:22,320
give it input and it's going to give you

3500
02:16:22,320 --> 02:16:25,280
output if we look at the operation here

3501
02:16:25,280 --> 02:16:27,599
to add first a number to second number

3502
02:16:27,599 --> 02:16:30,480
we can consider first number and second

3503
02:16:30,480 --> 02:16:33,439
number as input to the function and sum

3504
02:16:33,439 --> 02:16:35,359
is the output of the function we can

3505
02:16:35,359 --> 02:16:37,599
visualize that like this so we have a

3506
02:16:37,599 --> 02:16:39,679
first number and the second number we

3507
02:16:39,679 --> 02:16:42,080
pass that into our machine which is

3508
02:16:42,080 --> 02:16:44,000
really a function and we're going to get

3509
02:16:44,000 --> 02:16:46,880
the result of this function in a return

3510
02:16:46,880 --> 02:16:49,519
value or something that we get out of

3511
02:16:49,519 --> 02:16:52,399
the function as our result c plus plus

3512
02:16:52,399 --> 02:16:55,280
has a special syntax we use to define

3513
02:16:55,280 --> 02:16:57,840
functions this is our function to add

3514
02:16:57,840 --> 02:17:00,559
numbers on the left we have an integer

3515
02:17:00,559 --> 02:17:03,679
which is code name for a whole number in

3516
02:17:03,679 --> 02:17:05,519
c plus plus it's a number without

3517
02:17:05,519 --> 02:17:07,840
decimal points and it's a whole number

3518
02:17:07,840 --> 02:17:09,200
after that we have the name of the

3519
02:17:09,200 --> 02:17:11,200
function and we can name it whatever we

3520
02:17:11,200 --> 02:17:13,599
want and after that we're going to have

3521
02:17:13,599 --> 02:17:16,080
the list of parameters that we can pass

3522
02:17:16,080 --> 02:17:17,760
to the function and this is going to

3523
02:17:17,760 --> 02:17:20,399
work as the input to the function

3524
02:17:20,399 --> 02:17:22,719
after you do that you're going to have a

3525
02:17:22,719 --> 02:17:26,240
pair of curly braces the one is here the

3526
02:17:26,240 --> 02:17:28,479
other is here to the end and within

3527
02:17:28,479 --> 02:17:30,800
those curly braces it's going to be the

3528
02:17:30,800 --> 02:17:33,040
body of the function inside the function

3529
02:17:33,040 --> 02:17:35,439
you see that we are declaring a variable

3530
02:17:35,439 --> 02:17:37,120
which is called sum

3531
02:17:37,120 --> 02:17:39,679
and we are storing the sum of first

3532
02:17:39,679 --> 02:17:41,519
number and second number in this

3533
02:17:41,519 --> 02:17:42,479
variable

3534
02:17:42,479 --> 02:17:45,519
and we are making this function return

3535
02:17:45,519 --> 02:17:47,679
the sum as the result and we're going to

3536
02:17:47,679 --> 02:17:50,000
be able to capture it if we call this

3537
02:17:50,000 --> 02:17:52,000
function in a function like me you're

3538
02:17:52,000 --> 02:17:53,679
going to see how this works in a minute

3539
02:17:53,679 --> 02:17:56,080
a function must be defined before it's

3540
02:17:56,080 --> 02:17:58,639
used so you can't really call a function

3541
02:17:58,639 --> 02:18:01,359
you haven't defined first in your c plus

3542
02:18:01,359 --> 02:18:04,240
plus program and here is a slightly

3543
02:18:04,240 --> 02:18:06,639
complete program to really put all these

3544
02:18:06,639 --> 02:18:09,439
ideas together we have our function to

3545
02:18:09,439 --> 02:18:11,920
add numbers it takes two numbers first

3546
02:18:11,920 --> 02:18:14,080
number and second number it's going to

3547
02:18:14,080 --> 02:18:16,479
add them up and store the results and

3548
02:18:16,479 --> 02:18:19,280
we're going to return some to be used by

3549
02:18:19,280 --> 02:18:21,840
whoever called this function and if you

3550
02:18:21,840 --> 02:18:24,719
look in our main program we have a

3551
02:18:24,719 --> 02:18:27,280
statement here we're going to store the

3552
02:18:27,280 --> 02:18:30,479
result of add numbers in the sum

3553
02:18:30,479 --> 02:18:33,679
variable and we pass first number and

3554
02:18:33,679 --> 02:18:35,519
second number in the function and we're

3555
02:18:35,519 --> 02:18:37,599
going to have that result stored in here

3556
02:18:37,599 --> 02:18:39,920
here we also call the function with

3557
02:18:39,920 --> 02:18:42,559
direct numbers you see that we pass in

3558
02:18:42,559 --> 02:18:44,639
34 and the seven and we're going to

3559
02:18:44,639 --> 02:18:46,719
print out the result here this is the

3560
02:18:46,719 --> 02:18:48,719
basic idea i want you to have about

3561
02:18:48,719 --> 02:18:51,519
functions they are reusable pieces of

3562
02:18:51,519 --> 02:18:53,920
code that group together a bunch of

3563
02:18:53,920 --> 02:18:55,840
statements to do whatever it is we

3564
02:18:55,840 --> 02:18:58,160
wanted to do in that function one

3565
02:18:58,160 --> 02:19:00,240
benefit about functions is that we can

3566
02:19:00,240 --> 02:19:02,960
reuse the code here if you look here we

3567
02:19:02,960 --> 02:19:05,519
are calling this function multiple times

3568
02:19:05,519 --> 02:19:07,679
without really rewriting these

3569
02:19:07,679 --> 02:19:10,160
statements that are inside the function

3570
02:19:10,160 --> 02:19:12,000
i know some of these concepts might be

3571
02:19:12,000 --> 02:19:14,319
cryptic to you right now we are going to

3572
02:19:14,319 --> 02:19:17,200
go to visual studio code and try this in

3573
02:19:17,200 --> 02:19:18,960
code and you're going to see exactly how

3574
02:19:18,960 --> 02:19:21,599
this works okay here we are in our

3575
02:19:21,599 --> 02:19:24,080
folder where we are storing our projects

3576
02:19:24,080 --> 02:19:26,319
i am going to grab the code from the

3577
02:19:26,319 --> 02:19:28,719
template project i am going to put that

3578
02:19:28,719 --> 02:19:30,960
in the current project which is

3579
02:19:30,960 --> 02:19:33,439
statements and functions i'm going to

3580
02:19:33,439 --> 02:19:35,840
paste that in here and i am going to

3581
02:19:35,840 --> 02:19:38,479
open this up in visual studio code i am

3582
02:19:38,479 --> 02:19:40,399
going to close the project we have right

3583
02:19:40,399 --> 02:19:43,120
now and i am going to open our new

3584
02:19:43,120 --> 02:19:46,080
project let's browse to its location i

3585
02:19:46,080 --> 02:19:48,160
am going to open the project on

3586
02:19:48,160 --> 02:19:50,720
statements and functions let's open this

3587
02:19:50,720 --> 02:19:52,880
folder in visual studio code and we're

3588
02:19:52,880 --> 02:19:55,359
going to have our starter project here i

3589
02:19:55,359 --> 02:19:57,040
am going to take out whatever we have in

3590
02:19:57,040 --> 02:19:59,040
the main function and take out this

3591
02:19:59,040 --> 02:20:01,120
contival thing we don't really need it

3592
02:20:01,120 --> 02:20:03,359
and we are going to try and define two

3593
02:20:03,359 --> 02:20:05,920
variables using two statements we are

3594
02:20:05,920 --> 02:20:08,240
going to say and first number and we're

3595
02:20:08,240 --> 02:20:10,960
going to put in a value let's say three

3596
02:20:10,960 --> 02:20:13,200
and we have to remember to end this with

3597
02:20:13,200 --> 02:20:15,920
a semicolon so this makes our statement

3598
02:20:15,920 --> 02:20:18,240
we can encode this in a comment to make

3599
02:20:18,240 --> 02:20:20,240
this pretty clear we're going to also

3600
02:20:20,240 --> 02:20:22,800
define a second variable so we're going

3601
02:20:22,800 --> 02:20:24,560
to say ent to

3602
02:20:24,560 --> 02:20:26,960
mean that it is a whole number it

3603
02:20:26,960 --> 02:20:30,080
doesn't have decimal points like 2.5 it

3604
02:20:30,080 --> 02:20:32,319
is a whole number like one or seven or

3605
02:20:32,319 --> 02:20:34,319
ten so we're going to say second number

3606
02:20:34,319 --> 02:20:37,280
we can give it a name and uh let's put

3607
02:20:37,280 --> 02:20:39,439
in a seven we're going to store these

3608
02:20:39,439 --> 02:20:42,160
values in our program and we can print

3609
02:20:42,160 --> 02:20:44,240
these values out let's print them out

3610
02:20:44,240 --> 02:20:47,600
first so we're going to say stdc out we

3611
02:20:47,600 --> 02:20:49,840
already know how to do that and we can

3612
02:20:49,840 --> 02:20:53,120
say first number and we can change these

3613
02:20:53,120 --> 02:20:55,760
output statements and say the first

3614
02:20:55,760 --> 02:20:58,800
number is first number you can do that

3615
02:20:58,800 --> 02:21:02,240
std endl and you can notice that visual

3616
02:21:02,240 --> 02:21:04,479
studio code is really helping out in

3617
02:21:04,479 --> 02:21:06,880
auto completing things we have in our

3618
02:21:06,880 --> 02:21:09,040
program let's print the second number to

3619
02:21:09,040 --> 02:21:12,000
really practice this so if we do std

3620
02:21:12,000 --> 02:21:13,520
you're going to see that it's going to

3621
02:21:13,520 --> 02:21:15,439
give us a bunch of options we can choose

3622
02:21:15,439 --> 02:21:18,479
from if you want you can scroll through

3623
02:21:18,479 --> 02:21:20,800
this with your mouse or you can just

3624
02:21:20,800 --> 02:21:23,200
type whatever you want to type so i am

3625
02:21:23,200 --> 02:21:25,840
going to do c out and it's going to try

3626
02:21:25,840 --> 02:21:28,000
and help out if i really want i can come

3627
02:21:28,000 --> 02:21:30,399
on c out here and click on it and it's

3628
02:21:30,399 --> 02:21:32,000
going to be auto completed which is

3629
02:21:32,000 --> 02:21:34,080
pretty cool so we're going to say second

3630
02:21:34,080 --> 02:21:36,800
number and we're going to say second

3631
02:21:36,800 --> 02:21:38,880
number here and it's going to auto

3632
02:21:38,880 --> 02:21:40,720
complete for us

3633
02:21:40,720 --> 02:21:43,760
endl and we can try and compile this

3634
02:21:43,760 --> 02:21:46,399
program before we do i want you to guess

3635
02:21:46,399 --> 02:21:49,359
what we're going to get when we run this

3636
02:21:49,359 --> 02:21:51,439
program give it a guess we are then

3637
02:21:51,439 --> 02:21:53,840
going to go to terminal run task and

3638
02:21:53,840 --> 02:21:56,319
we're going to build this with gcc the

3639
02:21:56,319 --> 02:21:58,240
world is going to be successful we're

3640
02:21:58,240 --> 02:22:00,479
going to open this in our terminal the

3641
02:22:00,479 --> 02:22:02,479
terminal goes away no problem we're

3642
02:22:02,479 --> 02:22:04,640
going to open it again and we are going

3643
02:22:04,640 --> 02:22:08,160
to go in our folder and do the ir and

3644
02:22:08,160 --> 02:22:09,960
you're going to see that we have

3645
02:22:09,960 --> 02:22:12,960
rooster.exe our program we can run it

3646
02:22:12,960 --> 02:22:15,600
and it's going to say first number three

3647
02:22:15,600 --> 02:22:18,319
and second number s7 this is what we

3648
02:22:18,319 --> 02:22:20,399
have stored in these variables and the

3649
02:22:20,399 --> 02:22:22,479
benefit of storing your data in

3650
02:22:22,479 --> 02:22:25,040
variables is that you can change the

3651
02:22:25,040 --> 02:22:27,200
variables and let the rest of your

3652
02:22:27,200 --> 02:22:30,240
program really do the same things and

3653
02:22:30,240 --> 02:22:32,160
pick up the data that you have in those

3654
02:22:32,160 --> 02:22:35,760
variables for example we can put 13 in

3655
02:22:35,760 --> 02:22:37,200
the first number

3656
02:22:37,200 --> 02:22:39,200
and if we build again this number is

3657
02:22:39,200 --> 02:22:41,439
going to be picked up by this code and

3658
02:22:41,439 --> 02:22:43,920
we didn't need to go in and manually

3659
02:22:43,920 --> 02:22:46,960
change data in these sddc out statements

3660
02:22:46,960 --> 02:22:49,600
here let's weld so that we can see this

3661
02:22:49,600 --> 02:22:53,040
and we can close this by clicking and if

3662
02:22:53,040 --> 02:22:55,760
we run rooster again it's going to say

3663
02:22:55,760 --> 02:22:58,399
13 and 7. play with this a couple of

3664
02:22:58,399 --> 02:23:00,960
times until you really feel confident

3665
02:23:00,960 --> 02:23:02,800
and if you have any problem don't

3666
02:23:02,800 --> 02:23:04,800
hesitate to ask me i am going to do the

3667
02:23:04,800 --> 02:23:06,800
best i can to help you out

3668
02:23:06,800 --> 02:23:09,120
now that we have these numbers stored in

3669
02:23:09,120 --> 02:23:12,479
our program we can add them up let's say

3670
02:23:12,479 --> 02:23:14,640
and some we're going to declare another

3671
02:23:14,640 --> 02:23:16,960
variable and we're going to say it's

3672
02:23:16,960 --> 02:23:20,000
equal to first number plus second number

3673
02:23:20,000 --> 02:23:21,439
and we're going to end this with a

3674
02:23:21,439 --> 02:23:23,680
semicolon and we're going to print the

3675
02:23:23,680 --> 02:23:25,040
sum out

3676
02:23:25,040 --> 02:23:28,240
let's do sddc out and we're going to say

3677
02:23:28,240 --> 02:23:30,800
the sum is sum we're going to print our

3678
02:23:30,800 --> 02:23:33,520
variable here and we're going to print a

3679
02:23:33,520 --> 02:23:37,200
new line character with std endl we're

3680
02:23:37,200 --> 02:23:39,200
going to build our program so that our

3681
02:23:39,200 --> 02:23:42,160
changes are reflected in our binary here

3682
02:23:42,160 --> 02:23:44,399
so we're going to go to terminal

3683
02:23:44,399 --> 02:23:47,359
run task weld with gcc the build is

3684
02:23:47,359 --> 02:23:49,439
going to be successful we're going to

3685
02:23:49,439 --> 02:23:51,840
press any key we are going to click here

3686
02:23:51,840 --> 02:23:54,080
in the terminal and we're going to hit

3687
02:23:54,080 --> 02:23:56,800
enter and run rooster again and we

3688
02:23:56,800 --> 02:23:58,960
should see the sum and you see it says

3689
02:23:58,960 --> 02:24:02,399
the sum is 20 which is what we expect

3690
02:24:02,399 --> 02:24:05,200
now we are doing the sum here but it

3691
02:24:05,200 --> 02:24:07,520
would really be better if we're not

3692
02:24:07,520 --> 02:24:10,479
doing the sum in the main function here

3693
02:24:10,479 --> 02:24:13,359
what if we actually took this code and

3694
02:24:13,359 --> 02:24:15,680
wrapped it in a function that we could

3695
02:24:15,680 --> 02:24:18,240
reuse whatever we want we have seen how

3696
02:24:18,240 --> 02:24:20,399
we can declare a function so let's do

3697
02:24:20,399 --> 02:24:22,080
that we're going to follow the same

3698
02:24:22,080 --> 02:24:24,399
structure we saw in the slides earlier

3699
02:24:24,399 --> 02:24:26,319
so we're going to say and this is going

3700
02:24:26,319 --> 02:24:29,280
to be the return value or what we get

3701
02:24:29,280 --> 02:24:30,960
out of the function then we're going to

3702
02:24:30,960 --> 02:24:32,560
put in the name of the function we're

3703
02:24:32,560 --> 02:24:34,560
going to say add numbers and we're going

3704
02:24:34,560 --> 02:24:36,640
to pass in the parameters the parameters

3705
02:24:36,640 --> 02:24:38,800
can really have any name you want but

3706
02:24:38,800 --> 02:24:40,640
you have to specify

3707
02:24:40,640 --> 02:24:43,359
the type of the parameter first so the

3708
02:24:43,359 --> 02:24:45,280
parameters are also going to be whole

3709
02:24:45,280 --> 02:24:48,960
numbers like 1 5 7 or whatever you want

3710
02:24:48,960 --> 02:24:51,439
and we're going to say first program

3711
02:24:51,439 --> 02:24:53,520
and the second is going to also be a

3712
02:24:53,520 --> 02:24:55,600
whole number an integer and it's going

3713
02:24:55,600 --> 02:24:56,960
to be second

3714
02:24:56,960 --> 02:24:59,439
param okay after we do this we're going

3715
02:24:59,439 --> 02:25:02,160
to specify the body of the function

3716
02:25:02,160 --> 02:25:04,960
which is going to be between these curly

3717
02:25:04,960 --> 02:25:07,520
braces i am going to jump to the next

3718
02:25:07,520 --> 02:25:09,920
line so that this is really easy to see

3719
02:25:09,920 --> 02:25:12,880
so i am going to define our sum variable

3720
02:25:12,880 --> 02:25:14,880
inside the function it's going to be a

3721
02:25:14,880 --> 02:25:17,680
whole number and i can call it whatever

3722
02:25:17,680 --> 02:25:20,960
i want so let's call it result because

3723
02:25:20,960 --> 02:25:23,120
it's going to be the result of this

3724
02:25:23,120 --> 02:25:25,280
function and the result is going to be

3725
02:25:25,280 --> 02:25:28,080
the sum of first param and second param

3726
02:25:28,080 --> 02:25:30,240
okay i hope this makes sense and we're

3727
02:25:30,240 --> 02:25:32,399
going to end this with a semicolon

3728
02:25:32,399 --> 02:25:35,200
because every statement in c plus plus

3729
02:25:35,200 --> 02:25:37,280
has to end with the semicolon after we

3730
02:25:37,280 --> 02:25:38,399
have the result

3731
02:25:38,399 --> 02:25:40,880
we need to give it back to whoever

3732
02:25:40,880 --> 02:25:43,040
called this function and we're going to

3733
02:25:43,040 --> 02:25:45,359
do that with a return statement and

3734
02:25:45,359 --> 02:25:47,600
we're going to return the result to

3735
02:25:47,600 --> 02:25:48,720
whoever

3736
02:25:48,720 --> 02:25:50,800
might have called this function here now

3737
02:25:50,800 --> 02:25:52,319
that we have the function we can

3738
02:25:52,319 --> 02:25:54,479
actually use it we're going to go back

3739
02:25:54,479 --> 02:25:56,880
in our main function and what we're

3740
02:25:56,880 --> 02:25:58,240
going to do

3741
02:25:58,240 --> 02:26:01,680
is to reuse this sum variable and store

3742
02:26:01,680 --> 02:26:04,240
in whatever is returned from our

3743
02:26:04,240 --> 02:26:06,479
function the syntax for that is going to

3744
02:26:06,479 --> 02:26:07,520
be sum

3745
02:26:07,520 --> 02:26:09,359
and we're going to say equals and we're

3746
02:26:09,359 --> 02:26:12,080
going to say add numbers and we can pass

3747
02:26:12,080 --> 02:26:14,319
in whatever two numbers that we want to

3748
02:26:14,319 --> 02:26:18,640
add up let's pass in 25

3749
02:26:18,640 --> 02:26:20,560
and 7 for example

3750
02:26:20,560 --> 02:26:23,760
we would expect this to give us 32

3751
02:26:23,760 --> 02:26:27,200
so if we print the sum again we can just

3752
02:26:27,200 --> 02:26:29,280
complete this statement

3753
02:26:29,280 --> 02:26:32,240
that prints the sum and reuse it here

3754
02:26:32,240 --> 02:26:34,880
let's align this a little bit and i want

3755
02:26:34,880 --> 02:26:37,200
you to take a guess at what we are going

3756
02:26:37,200 --> 02:26:39,439
to get from this program right now we

3757
02:26:39,439 --> 02:26:41,359
have these two numbers we are adding

3758
02:26:41,359 --> 02:26:44,319
them up if we get here this should print

3759
02:26:44,319 --> 02:26:46,240
the first number which is going to be a

3760
02:26:46,240 --> 02:26:50,240
13 so here we expect to get 13 and by

3761
02:26:50,240 --> 02:26:52,399
the time we hit this second number

3762
02:26:52,399 --> 02:26:54,560
statement we are going to print the

3763
02:26:54,560 --> 02:26:57,280
second number it's going to be 7. if we

3764
02:26:57,280 --> 02:26:59,439
get here we're going to print whatever

3765
02:26:59,439 --> 02:27:02,479
is stored in sum and in sum we have the

3766
02:27:02,479 --> 02:27:05,439
sum of first number and second number so

3767
02:27:05,439 --> 02:27:08,960
this should print 20 right and here we

3768
02:27:08,960 --> 02:27:11,359
are doing another sum of two numbers but

3769
02:27:11,359 --> 02:27:14,479
we are using a predefined function

3770
02:27:14,479 --> 02:27:16,560
that we have here before the main

3771
02:27:16,560 --> 02:27:19,120
function because you have to define the

3772
02:27:19,120 --> 02:27:21,200
function before you use it okay if we

3773
02:27:21,200 --> 02:27:24,319
add 25 and seven we are going to fall

3774
02:27:24,319 --> 02:27:27,200
into this function and it's going to add

3775
02:27:27,200 --> 02:27:28,960
those numbers up and we're going to get

3776
02:27:28,960 --> 02:27:30,399
a 32 in here

3777
02:27:30,399 --> 02:27:32,560
and that's what we're going to return

3778
02:27:32,560 --> 02:27:34,319
and it is going to be saved in this

3779
02:27:34,319 --> 02:27:36,479
variable if we print it out it's going

3780
02:27:36,479 --> 02:27:39,280
to give us 32. i hope this makes sense

3781
02:27:39,280 --> 02:27:42,800
let's build and run our program run task

3782
02:27:42,800 --> 02:27:45,439
world with gcc the world is going to go

3783
02:27:45,439 --> 02:27:47,200
fine we're going to go back to our

3784
02:27:47,200 --> 02:27:49,680
terminal here that's clear so that

3785
02:27:49,680 --> 02:27:52,800
things don't disturb us and uh bring in

3786
02:27:52,800 --> 02:27:54,880
some confusion we're going to run our

3787
02:27:54,880 --> 02:27:58,000
rooster program and exactly what we have

3788
02:27:58,000 --> 02:28:00,080
here we have a 13 from the first

3789
02:28:00,080 --> 02:28:03,120
statement here we have a 7 from this

3790
02:28:03,120 --> 02:28:06,080
statement here we have a 20 from this

3791
02:28:06,080 --> 02:28:09,600
sum here which is here and we have a 32

3792
02:28:09,600 --> 02:28:12,080
that we got from this function the good

3793
02:28:12,080 --> 02:28:13,760
thing about functions is that we can

3794
02:28:13,760 --> 02:28:16,080
reuse them now that we know how to use

3795
02:28:16,080 --> 02:28:18,399
it we can use it again and we can say

3796
02:28:18,399 --> 02:28:20,080
sum equals

3797
02:28:20,080 --> 02:28:24,160
add numbers and we can say 30 and

3798
02:28:24,160 --> 02:28:26,479
54 for example you add them up and

3799
02:28:26,479 --> 02:28:28,080
you're going to get the results so we're

3800
02:28:28,080 --> 02:28:30,800
going to print the result some and we're

3801
02:28:30,800 --> 02:28:33,520
going to put in the sum i really want

3802
02:28:33,520 --> 02:28:35,520
you to take some time and play with this

3803
02:28:35,520 --> 02:28:37,359
statement so that these things make

3804
02:28:37,359 --> 02:28:39,760
sense it's really not that difficult but

3805
02:28:39,760 --> 02:28:41,760
you just have to rock your brains around

3806
02:28:41,760 --> 02:28:44,880
how c plus plus defines these things so

3807
02:28:44,880 --> 02:28:47,200
we have this statement and we are adding

3808
02:28:47,200 --> 02:28:51,760
30 and 54 so it should get an 84 after

3809
02:28:51,760 --> 02:28:54,640
the 32 here let's weld we're going to

3810
02:28:54,640 --> 02:28:57,359
run the task to world with gcc we're

3811
02:28:57,359 --> 02:28:59,600
going to click on the terminal here and

3812
02:28:59,600 --> 02:29:02,720
hit enter let's clear so that we don't

3813
02:29:02,720 --> 02:29:04,399
have things disturbing us and we're

3814
02:29:04,399 --> 02:29:07,359
going to run our program and we have our

3815
02:29:07,359 --> 02:29:10,720
trusty 84 here i really hope this makes

3816
02:29:10,720 --> 02:29:12,800
sense and as a bonus i'm going to show

3817
02:29:12,800 --> 02:29:15,680
you that you can also call things

3818
02:29:15,680 --> 02:29:19,200
in the stdc out statement here without

3819
02:29:19,200 --> 02:29:21,840
having to store them in some predefined

3820
02:29:21,840 --> 02:29:24,080
variables and sometimes this comes in

3821
02:29:24,080 --> 02:29:27,920
handy so you can say std see out and

3822
02:29:27,920 --> 02:29:31,200
we're going to say sum and you might say

3823
02:29:31,200 --> 02:29:33,600
add numbers right in here and you're

3824
02:29:33,600 --> 02:29:37,600
going to say 3 for example and uh 42 and

3825
02:29:37,600 --> 02:29:40,800
this is going to give us a 45 that's

3826
02:29:40,800 --> 02:29:43,200
what we should expect to see after 84

3827
02:29:43,200 --> 02:29:44,080
here

3828
02:29:44,080 --> 02:29:46,720
so that's world and running the task to

3829
02:29:46,720 --> 02:29:49,040
build with gcc the world is going to be

3830
02:29:49,040 --> 02:29:51,760
successful we click on the terminal here

3831
02:29:51,760 --> 02:29:54,080
we hit enter so that we see our terminal

3832
02:29:54,080 --> 02:29:56,319
with output we're going to clear so that

3833
02:29:56,319 --> 02:29:59,120
we see our output without noise we're

3834
02:29:59,120 --> 02:30:01,600
going to run our program and we're going

3835
02:30:01,600 --> 02:30:04,240
to see a 45 here i really hope this

3836
02:30:04,240 --> 02:30:06,000
makes sense the whole point of this

3837
02:30:06,000 --> 02:30:08,080
lecture was to make you aware of

3838
02:30:08,080 --> 02:30:10,560
statements and function a statement is

3839
02:30:10,560 --> 02:30:13,120
the most basic unit in your c plus plus

3840
02:30:13,120 --> 02:30:16,080
program it basically lives on one line

3841
02:30:16,080 --> 02:30:19,200
but it can also spread across different

3842
02:30:19,200 --> 02:30:20,960
lines but we're not going to look at

3843
02:30:20,960 --> 02:30:22,640
that here maybe we're going to see that

3844
02:30:22,640 --> 02:30:25,120
later in the course statements are

3845
02:30:25,120 --> 02:30:27,760
executed in order so when our main

3846
02:30:27,760 --> 02:30:30,240
function gets to be run by the computer

3847
02:30:30,240 --> 02:30:31,520
it's going to go from the first

3848
02:30:31,520 --> 02:30:33,439
statement second statement third

3849
02:30:33,439 --> 02:30:36,000
statement and it's going to go until it

3850
02:30:36,000 --> 02:30:39,040
hits the end and we can see that here in

3851
02:30:39,040 --> 02:30:40,960
the order in which our numbers are

3852
02:30:40,960 --> 02:30:43,680
printed it is going from top to bottom

3853
02:30:43,680 --> 02:30:46,000
we have also seen that we can split our

3854
02:30:46,000 --> 02:30:48,399
code in different functions and wrap

3855
02:30:48,399 --> 02:30:50,160
whatever functionality we have in a

3856
02:30:50,160 --> 02:30:52,800
function we have seen the basic concepts

3857
02:30:52,800 --> 02:30:54,960
on functions a function has a return

3858
02:30:54,960 --> 02:30:57,680
value it has a name and you have to give

3859
02:30:57,680 --> 02:31:00,080
it the parameters and you put the body

3860
02:31:00,080 --> 02:31:02,880
of your function within these two curly

3861
02:31:02,880 --> 02:31:05,760
braces as an exercise i would challenge

3862
02:31:05,760 --> 02:31:09,120
you to do a function that multiplies two

3863
02:31:09,120 --> 02:31:11,680
numbers and call it in the main function

3864
02:31:11,680 --> 02:31:14,000
here to see the result if you have any

3865
02:31:14,000 --> 02:31:16,080
problem please do ask me i am going to

3866
02:31:16,080 --> 02:31:18,880
do the best i can to help you out this

3867
02:31:18,880 --> 02:31:20,880
covers all we set out to do in this

3868
02:31:20,880 --> 02:31:22,560
lecture and i hope you found it

3869
02:31:22,560 --> 02:31:24,640
interesting we're going to stop here in

3870
02:31:24,640 --> 02:31:26,319
this lecture in the next one we're going

3871
02:31:26,319 --> 02:31:29,280
to see how we can input and output

3872
02:31:29,280 --> 02:31:32,240
things from our c plus plus program go

3873
02:31:32,240 --> 02:31:34,479
ahead and finish up here and meet me

3874
02:31:34,479 --> 02:31:35,920
there in this lecture we're going to

3875
02:31:35,920 --> 02:31:38,560
learn about how we can get thanks in our

3876
02:31:38,560 --> 02:31:41,120
program and get things out of our

3877
02:31:41,120 --> 02:31:43,359
program and that's basically input and

3878
02:31:43,359 --> 02:31:46,720
output to and from our program we have

3879
02:31:46,720 --> 02:31:49,040
actually been doing this all along we

3880
02:31:49,040 --> 02:31:51,040
have been printing things from our

3881
02:31:51,040 --> 02:31:52,880
program to the console

3882
02:31:52,880 --> 02:31:55,040
and with this technique you can really

3883
02:31:55,040 --> 02:31:57,680
think of stdc out

3884
02:31:57,680 --> 02:32:01,040
as a highway that goes from your program

3885
02:32:01,040 --> 02:32:02,960
to the terminal you can basically think

3886
02:32:02,960 --> 02:32:05,200
of it like this data is going from your

3887
02:32:05,200 --> 02:32:08,240
program to sddc out and it's going from

3888
02:32:08,240 --> 02:32:10,560
here to the terminal and from this you

3889
02:32:10,560 --> 02:32:13,280
might get an idea why these

3890
02:32:13,280 --> 02:32:16,080
less than signs kind of point to the

3891
02:32:16,080 --> 02:32:18,720
left because data is going from your

3892
02:32:18,720 --> 02:32:22,319
program to htdc out and these two

3893
02:32:22,319 --> 02:32:25,280
symbols point to the left they point to

3894
02:32:25,280 --> 02:32:29,840
hddc out to signal to the fact that data

3895
02:32:29,840 --> 02:32:33,120
is going from here to here i really hope

3896
02:32:33,120 --> 02:32:35,600
this makes sense because sometimes these

3897
02:32:35,600 --> 02:32:37,920
things can confuse people this is the

3898
02:32:37,920 --> 02:32:41,040
reason why it's going from your data to

3899
02:32:41,040 --> 02:32:43,520
stdc out data is basically going from

3900
02:32:43,520 --> 02:32:47,600
your program into httc out and the sddc

3901
02:32:47,600 --> 02:32:50,080
out is one way we have to get data from

3902
02:32:50,080 --> 02:32:52,000
our program to the console there are

3903
02:32:52,000 --> 02:32:57,200
many others we have std c e r r or std

3904
02:32:57,200 --> 02:32:59,520
server this is what i'd like to call it

3905
02:32:59,520 --> 02:33:02,160
and what it does it prints errors to the

3906
02:33:02,160 --> 02:33:05,120
console we have stdc log which is going

3907
02:33:05,120 --> 02:33:08,000
to print log messages why do we have

3908
02:33:08,000 --> 02:33:09,760
these different things different

3909
02:33:09,760 --> 02:33:12,479
programs might decide to format these

3910
02:33:12,479 --> 02:33:14,720
messages differently because they are

3911
02:33:14,720 --> 02:33:17,200
different messages one is a simple

3912
02:33:17,200 --> 02:33:19,520
message from the program another is the

3913
02:33:19,520 --> 02:33:22,080
narrows you might want to turn this red

3914
02:33:22,080 --> 02:33:24,240
to really bring the attention

3915
02:33:24,240 --> 02:33:26,399
to this message because the user has to

3916
02:33:26,399 --> 02:33:28,560
solve that problem another might be a

3917
02:33:28,560 --> 02:33:30,720
log message that you want to store in

3918
02:33:30,720 --> 02:33:33,040
some file or some database

3919
02:33:33,040 --> 02:33:35,439
uses for these things differ and c plus

3920
02:33:35,439 --> 02:33:37,280
plus makes sure to give you different

3921
02:33:37,280 --> 02:33:40,080
ways to state your intent through the

3922
02:33:40,080 --> 02:33:42,720
tools that you use we have looked at

3923
02:33:42,720 --> 02:33:47,600
sddc out sddc error and stdc log what

3924
02:33:47,600 --> 02:33:51,520
does sd c i n do it does the reverse

3925
02:33:51,520 --> 02:33:53,439
it's going to take data out of the

3926
02:33:53,439 --> 02:33:56,479
program and bring that into the program

3927
02:33:56,479 --> 02:33:58,880
so let's look at a few examples using

3928
02:33:58,880 --> 02:34:01,280
these here we have an example of

3929
02:34:01,280 --> 02:34:04,479
printing data from the program to the

3930
02:34:04,479 --> 02:34:06,800
terminal through c out

3931
02:34:06,800 --> 02:34:08,720
cr and c log

3932
02:34:08,720 --> 02:34:10,800
here we have a hello world message going

3933
02:34:10,800 --> 02:34:12,240
to c out

3934
02:34:12,240 --> 02:34:15,680
here we have a number going to c out

3935
02:34:15,680 --> 02:34:17,920
this is what we've been doing all along

3936
02:34:17,920 --> 02:34:20,399
we can also do a variable storing the

3937
02:34:20,399 --> 02:34:22,319
edge for example it's a whole number

3938
02:34:22,319 --> 02:34:23,680
it's an integer

3939
02:34:23,680 --> 02:34:26,399
so we print this out and the message is

3940
02:34:26,399 --> 02:34:30,000
going to go from the program to cl so

3941
02:34:30,000 --> 02:34:32,080
you can think that things are going from

3942
02:34:32,080 --> 02:34:35,680
the program to sddc out i really wanted

3943
02:34:35,680 --> 02:34:37,760
this to make sense okay if we go down

3944
02:34:37,760 --> 02:34:40,399
we're going to see that we can use cr to

3945
02:34:40,399 --> 02:34:42,960
print errors to the terminal and we

3946
02:34:42,960 --> 02:34:45,359
might say something went wrong or

3947
02:34:45,359 --> 02:34:47,280
something along these lines to bring the

3948
02:34:47,280 --> 02:34:50,160
attention to the problem and we can use

3949
02:34:50,160 --> 02:34:53,280
c log to print log messages and they

3950
02:34:53,280 --> 02:34:55,760
work the same way they all use the

3951
02:34:55,760 --> 02:34:58,560
stream output operator and it is going

3952
02:34:58,560 --> 02:35:01,280
to take data from the program to

3953
02:35:01,280 --> 02:35:03,520
the output stream really this is what we

3954
02:35:03,520 --> 02:35:05,760
mean here here is an example of how you

3955
02:35:05,760 --> 02:35:08,240
might read data and bring that into the

3956
02:35:08,240 --> 02:35:10,560
program here we have two variables one

3957
02:35:10,560 --> 02:35:12,880
is the age it's a whole number or an

3958
02:35:12,880 --> 02:35:15,600
integer and z plus plus and the other is

3959
02:35:15,600 --> 02:35:18,000
a string this is a type that allows you

3960
02:35:18,000 --> 02:35:20,720
to store strings in c plus plus we're

3961
02:35:20,720 --> 02:35:22,560
going to learn a little more about this

3962
02:35:22,560 --> 02:35:25,280
later but here i want to use it to

3963
02:35:25,280 --> 02:35:27,439
really make it clear that you can get

3964
02:35:27,439 --> 02:35:29,600
things from the outside and bring that

3965
02:35:29,600 --> 02:35:31,439
data in your program so we're going to

3966
02:35:31,439 --> 02:35:34,560
let the user type in the last name and

3967
02:35:34,560 --> 02:35:37,920
this statement here with cin

3968
02:35:37,920 --> 02:35:40,800
is getting data from the stream or from

3969
02:35:40,800 --> 02:35:43,359
the highway through which data comes

3970
02:35:43,359 --> 02:35:45,920
into our program and bringing that in

3971
02:35:45,920 --> 02:35:48,399
our program and here it should be clear

3972
02:35:48,399 --> 02:35:51,120
that the flow of data is in this

3973
02:35:51,120 --> 02:35:54,399
direction data is going from c i n and

3974
02:35:54,399 --> 02:35:56,560
we're storing that in a variable that we

3975
02:35:56,560 --> 02:35:59,120
have in our program that is called name

3976
02:35:59,120 --> 02:36:01,520
we do the same thing and ask the user to

3977
02:36:01,520 --> 02:36:03,760
print the age and they are going to

3978
02:36:03,760 --> 02:36:06,160
print that and the data is going to come

3979
02:36:06,160 --> 02:36:09,040
from cin and we're going to store that

3980
02:36:09,040 --> 02:36:11,439
in our edge variable here after we

3981
02:36:11,439 --> 02:36:13,120
collect the data from the user we're

3982
02:36:13,120 --> 02:36:14,800
going to print that and we're going to

3983
02:36:14,800 --> 02:36:16,960
say hello we're going to print the name

3984
02:36:16,960 --> 02:36:18,800
and we're going to say they are whatever

3985
02:36:18,800 --> 02:36:21,600
years old this is what this program does

3986
02:36:21,600 --> 02:36:24,000
and i really hope it makes it clear

3987
02:36:24,000 --> 02:36:27,200
how data input works through streams in

3988
02:36:27,200 --> 02:36:29,200
surplus plus another thing we can do

3989
02:36:29,200 --> 02:36:30,120
with

3990
02:36:30,120 --> 02:36:34,640
sddcin is chaining input and we can use

3991
02:36:34,640 --> 02:36:37,280
this technique to grab data in one

3992
02:36:37,280 --> 02:36:39,439
statement look at the program down here

3993
02:36:39,439 --> 02:36:41,200
to really understand this we have the

3994
02:36:41,200 --> 02:36:43,680
same variables age and name we let the

3995
02:36:43,680 --> 02:36:45,840
user type in the last name and age

3996
02:36:45,840 --> 02:36:47,840
separated by spaces

3997
02:36:47,840 --> 02:36:50,319
and we grab the data like this we first

3998
02:36:50,319 --> 02:36:53,120
grab the name after that we grab the age

3999
02:36:53,120 --> 02:36:55,200
and we're going to print the same things

4000
02:36:55,200 --> 02:36:57,040
and we can chain

4001
02:36:57,040 --> 02:37:00,479
input stream operators like this to grab

4002
02:37:00,479 --> 02:37:02,880
the data in one go and this may come in

4003
02:37:02,880 --> 02:37:04,479
handy sometimes

4004
02:37:04,479 --> 02:37:06,880
before we try these things in visual

4005
02:37:06,880 --> 02:37:08,720
studio code i want to bring your

4006
02:37:08,720 --> 02:37:10,800
attention to a problem that you are

4007
02:37:10,800 --> 02:37:13,760
likely to come in contact with and that

4008
02:37:13,760 --> 02:37:16,880
is reading data with spaces what if the

4009
02:37:16,880 --> 02:37:19,200
user types the name

4010
02:37:19,200 --> 02:37:21,359
with spaces for example you asked me to

4011
02:37:21,359 --> 02:37:23,439
type my name i'm not going to type

4012
02:37:23,439 --> 02:37:26,240
daniel i'm going to type daniel cafwaya

4013
02:37:26,240 --> 02:37:28,000
and your program is going to run into

4014
02:37:28,000 --> 02:37:30,560
problems c plus plus allows to solve

4015
02:37:30,560 --> 02:37:34,000
this problem using std get line and you

4016
02:37:34,000 --> 02:37:35,120
use it

4017
02:37:35,120 --> 02:37:37,920
using this syntax you're going to pass

4018
02:37:37,920 --> 02:37:39,840
in the stream where the data is going to

4019
02:37:39,840 --> 02:37:41,760
go and you're going to pass in the

4020
02:37:41,760 --> 02:37:43,920
variable that is going to read the data

4021
02:37:43,920 --> 02:37:45,040
and you're going to have this

4022
02:37:45,040 --> 02:37:47,200
information stored correctly in your

4023
02:37:47,200 --> 02:37:50,000
program this might be not making sense

4024
02:37:50,000 --> 02:37:52,479
yet to you we're going to go to visual

4025
02:37:52,479 --> 02:37:55,040
studio code and play with us and i am

4026
02:37:55,040 --> 02:37:57,280
sure it is going to make sense okay here

4027
02:37:57,280 --> 02:37:59,840
we are in visual studio code and we have

4028
02:37:59,840 --> 02:38:01,840
our project where we're going to store

4029
02:38:01,840 --> 02:38:04,479
our files data imported output we're

4030
02:38:04,479 --> 02:38:06,640
going to copy code from our template

4031
02:38:06,640 --> 02:38:08,960
project and we're going to put the data

4032
02:38:08,960 --> 02:38:11,120
in and i am going to open this folder in

4033
02:38:11,120 --> 02:38:13,439
visual studio code so let's close

4034
02:38:13,439 --> 02:38:15,920
whatever we have now and i am going to

4035
02:38:15,920 --> 02:38:18,960
open my folder let's browse there i am

4036
02:38:18,960 --> 02:38:21,520
on this folder data input and output i

4037
02:38:21,520 --> 02:38:24,000
am going to select that and the project

4038
02:38:24,000 --> 02:38:26,560
is going to open up in visual studio

4039
02:38:26,560 --> 02:38:28,800
code i am going to jump to my main

4040
02:38:28,800 --> 02:38:30,720
function i am going to take out things

4041
02:38:30,720 --> 02:38:32,800
we don't need and the first thing we're

4042
02:38:32,800 --> 02:38:34,800
going to do is printing data we have

4043
02:38:34,800 --> 02:38:36,080
really done this so we're going to

4044
02:38:36,080 --> 02:38:38,240
practice this a little bit we can say

4045
02:38:38,240 --> 02:38:40,000
stdc out

4046
02:38:40,000 --> 02:38:44,080
and we can say hello c plus plus 20 why

4047
02:38:44,080 --> 02:38:47,359
not and we're going to put an std

4048
02:38:47,359 --> 02:38:50,080
endl at the end and remember our

4049
02:38:50,080 --> 02:38:53,680
semicolon and here i want you to really

4050
02:38:53,680 --> 02:38:56,960
put in your head that data is going from

4051
02:38:56,960 --> 02:39:01,040
our program here to hddc out and sddc

4052
02:39:01,040 --> 02:39:02,880
out is going to dump that on the

4053
02:39:02,880 --> 02:39:05,120
terminal that's how this works you can

4054
02:39:05,120 --> 02:39:08,399
also do a variable let's say ant

4055
02:39:08,399 --> 02:39:11,760
age for example let's say 21 and end

4056
02:39:11,760 --> 02:39:14,000
this with the semicolon and we can also

4057
02:39:14,000 --> 02:39:17,280
print the h we can say sddc out

4058
02:39:17,280 --> 02:39:19,359
and we can say

4059
02:39:19,359 --> 02:39:21,920
age this is going to be sent to the

4060
02:39:21,920 --> 02:39:23,600
output stream

4061
02:39:23,600 --> 02:39:26,720
and we're going to do sdd and dl to add

4062
02:39:26,720 --> 02:39:27,600
a

4063
02:39:27,600 --> 02:39:30,240
new line character at the end and we can

4064
02:39:30,240 --> 02:39:32,240
try and build this before the program

4065
02:39:32,240 --> 02:39:34,160
gets more complicated let's go to

4066
02:39:34,160 --> 02:39:36,240
terminal we're going to run the test

4067
02:39:36,240 --> 02:39:38,800
world with gcc

4068
02:39:38,800 --> 02:39:42,319
and if we hit enter on the terminal here

4069
02:39:42,319 --> 02:39:44,319
the terminal is going to go away we're

4070
02:39:44,319 --> 02:39:47,040
going to create a new one no big deal

4071
02:39:47,040 --> 02:39:49,600
and uh if we do dir we're going to find

4072
02:39:49,600 --> 02:39:52,319
our rooster program if we run it it's

4073
02:39:52,319 --> 02:39:56,000
going to say hello c plus 20 and the age

4074
02:39:56,000 --> 02:39:59,040
is going to be 21. we are successfully

4075
02:39:59,040 --> 02:40:01,600
taking data from our program and

4076
02:40:01,600 --> 02:40:04,080
printing that to the terminal this is

4077
02:40:04,080 --> 02:40:06,640
pretty cool and you can think of sddc

4078
02:40:06,640 --> 02:40:09,359
out as the highway that is really going

4079
02:40:09,359 --> 02:40:12,080
to take your data from your program and

4080
02:40:12,080 --> 02:40:16,080
bring that to sddc out like this

4081
02:40:16,080 --> 02:40:18,000
we're also going to take the age it's

4082
02:40:18,000 --> 02:40:20,399
going to go through sddc out and it's

4083
02:40:20,399 --> 02:40:22,160
going to show up here you can think of

4084
02:40:22,160 --> 02:40:24,319
this like this okay now that we have

4085
02:40:24,319 --> 02:40:29,279
used sddc out we can use sddcr and sddc

4086
02:40:29,279 --> 02:40:31,439
log in the same way so we're going to

4087
02:40:31,439 --> 02:40:34,000
say sddcr

4088
02:40:34,000 --> 02:40:36,479
i'm going to say error message and the

4089
02:40:36,479 --> 02:40:38,800
message is going to be something is

4090
02:40:38,800 --> 02:40:41,359
wrong you may do whatever you want in

4091
02:40:41,359 --> 02:40:43,840
here and we have to remember to put a

4092
02:40:43,840 --> 02:40:45,840
new line character otherwise data is

4093
02:40:45,840 --> 02:40:48,240
going to be cramped on one line we can

4094
02:40:48,240 --> 02:40:51,359
also use sddc log it really works the

4095
02:40:51,359 --> 02:40:54,960
same way c log and we can say log

4096
02:40:54,960 --> 02:40:57,840
message and we're going to say something

4097
02:40:57,840 --> 02:40:58,800
happened

4098
02:40:58,800 --> 02:41:03,040
and we remember to put std endl and our

4099
02:41:03,040 --> 02:41:05,920
semicolon if we build this program you

4100
02:41:05,920 --> 02:41:07,520
might guess what it's going to do it's

4101
02:41:07,520 --> 02:41:09,359
going to print these things on the

4102
02:41:09,359 --> 02:41:10,479
terminal

4103
02:41:10,479 --> 02:41:12,319
but this might be

4104
02:41:12,319 --> 02:41:13,439
useful

4105
02:41:13,439 --> 02:41:15,680
to terminal programs that support

4106
02:41:15,680 --> 02:41:17,760
features to format different messages

4107
02:41:17,760 --> 02:41:20,080
directly the program is going to know

4108
02:41:20,080 --> 02:41:22,080
that one message is a simple message the

4109
02:41:22,080 --> 02:41:24,160
other is an arrow the other is a log

4110
02:41:24,160 --> 02:41:26,800
message let's run our program

4111
02:41:26,800 --> 02:41:28,640
but before we do that let's clear so

4112
02:41:28,640 --> 02:41:30,560
that we don't have noise here we're

4113
02:41:30,560 --> 02:41:32,640
going to run the program and it's going

4114
02:41:32,640 --> 02:41:34,960
to say the error message and the log

4115
02:41:34,960 --> 02:41:37,279
message here okay now what we're going

4116
02:41:37,279 --> 02:41:40,080
to look at is how we can get data into

4117
02:41:40,080 --> 02:41:42,479
our program and data is going to be

4118
02:41:42,479 --> 02:41:44,800
going in a different direction

4119
02:41:44,800 --> 02:41:46,319
it's going to be coming from the

4120
02:41:46,319 --> 02:41:49,359
terminal and flowing into our program

4121
02:41:49,359 --> 02:41:51,520
what we're going to do we're going to do

4122
02:41:51,520 --> 02:41:54,880
ant age one this is a new variable so

4123
02:41:54,880 --> 02:41:57,520
we're going to put in data and we're

4124
02:41:57,520 --> 02:42:00,640
going to bring in a string library to

4125
02:42:00,640 --> 02:42:04,080
allow our program to store strengths the

4126
02:42:04,080 --> 02:42:05,439
way we're going to do that we're going

4127
02:42:05,439 --> 02:42:06,880
to include

4128
02:42:06,880 --> 02:42:09,279
strength this is how you do it in c plus

4129
02:42:09,279 --> 02:42:11,279
plus we haven't really learned about

4130
02:42:11,279 --> 02:42:13,439
this type it's a powerful type in c plus

4131
02:42:13,439 --> 02:42:15,600
plus but we will get it there when we

4132
02:42:15,600 --> 02:42:17,600
have more powerful tools to really

4133
02:42:17,600 --> 02:42:19,200
understand it we are just getting

4134
02:42:19,200 --> 02:42:21,279
started here so what we're going to do

4135
02:42:21,279 --> 02:42:24,160
we're going to say std strength and

4136
02:42:24,160 --> 02:42:25,680
we're going to say name

4137
02:42:25,680 --> 02:42:28,000
and we're going to ask the user to print

4138
02:42:28,000 --> 02:42:30,960
their name and age you already know how

4139
02:42:30,960 --> 02:42:33,520
to do that so we're going to say please

4140
02:42:33,520 --> 02:42:35,760
type your name and age and we're going

4141
02:42:35,760 --> 02:42:38,800
to do stdndl on this and how we're going

4142
02:42:38,800 --> 02:42:41,520
to get data in the program we're going

4143
02:42:41,520 --> 02:42:43,319
to use

4144
02:42:43,319 --> 02:42:46,960
stdcin and we're going to do std

4145
02:42:46,960 --> 02:42:50,399
cim and data is going to be going from

4146
02:42:50,399 --> 02:42:53,200
the stream to the program so the

4147
02:42:53,200 --> 02:42:55,760
stream input operator here points to the

4148
02:42:55,760 --> 02:42:56,560
right

4149
02:42:56,560 --> 02:42:59,279
and the data is going to be going in the

4150
02:42:59,279 --> 02:43:00,960
name variable because that's what

4151
02:43:00,960 --> 02:43:02,880
they're going to be typing in first

4152
02:43:02,880 --> 02:43:04,960
because that's what we told them to do

4153
02:43:04,960 --> 02:43:07,040
so we're going to store the name

4154
02:43:07,040 --> 02:43:09,399
and we're going to say

4155
02:43:09,399 --> 02:43:12,680
stdcim data is going to be flowing from

4156
02:43:12,680 --> 02:43:17,439
sddcin into our h1 variable okay now

4157
02:43:17,439 --> 02:43:19,120
that the user has given us their

4158
02:43:19,120 --> 02:43:20,960
information we can greet them with a

4159
02:43:20,960 --> 02:43:23,200
personalized message we're going to say

4160
02:43:23,200 --> 02:43:26,800
stdc out hello and we're going to put

4161
02:43:26,800 --> 02:43:29,279
out their name and we're going to tell

4162
02:43:29,279 --> 02:43:31,760
them you are and we're going to put the

4163
02:43:31,760 --> 02:43:32,640
age

4164
02:43:32,640 --> 02:43:34,560
one because that's what they're going to

4165
02:43:34,560 --> 02:43:37,840
give us here and i'm going to say

4166
02:43:37,840 --> 02:43:38,880
years

4167
02:43:38,880 --> 02:43:41,920
and we're going to put an std endl here

4168
02:43:41,920 --> 02:43:44,640
i'm going to grab this and pull this to

4169
02:43:44,640 --> 02:43:47,600
the left so that we can see our entire

4170
02:43:47,600 --> 02:43:50,560
program here that's helpful so what we

4171
02:43:50,560 --> 02:43:52,240
are doing here we are getting data from

4172
02:43:52,240 --> 02:43:54,399
the user and we are storing that in our

4173
02:43:54,399 --> 02:43:56,560
variables and we are printing the

4174
02:43:56,560 --> 02:43:58,640
message so that the user can see it i

4175
02:43:58,640 --> 02:44:01,120
don't want the first things we did here

4176
02:44:01,120 --> 02:44:04,080
to disturb us when we world and try this

4177
02:44:04,080 --> 02:44:07,040
out so i am going to comment this out

4178
02:44:07,040 --> 02:44:10,000
and comment the first block of code out

4179
02:44:10,000 --> 02:44:12,000
using blog comments i think this is the

4180
02:44:12,000 --> 02:44:14,399
first time we use this and uh this is

4181
02:44:14,399 --> 02:44:16,560
going to be ignored by the compiler now

4182
02:44:16,560 --> 02:44:18,800
and it is only going to consider this

4183
02:44:18,800 --> 02:44:20,640
and this is going to be pretty cool

4184
02:44:20,640 --> 02:44:22,960
let's go down a little bit here and i

4185
02:44:22,960 --> 02:44:25,200
try to build the program we're going to

4186
02:44:25,200 --> 02:44:28,880
run the task that welds with gcc and uh

4187
02:44:28,880 --> 02:44:31,040
looks like the world is good we're going

4188
02:44:31,040 --> 02:44:33,600
to hit enter and we're going to clear so

4189
02:44:33,600 --> 02:44:36,560
that we are not disturbed by this we're

4190
02:44:36,560 --> 02:44:38,319
going to run the program let's say

4191
02:44:38,319 --> 02:44:40,000
rooster.exe

4192
02:44:40,000 --> 02:44:42,560
it's going to ask me to type my name and

4193
02:44:42,560 --> 02:44:44,560
age my name is daniel i'm going to type

4194
02:44:44,560 --> 02:44:47,279
that hit enter it's going to want me to

4195
02:44:47,279 --> 02:44:48,880
type my age

4196
02:44:48,880 --> 02:44:50,600
so i am going to say

4197
02:44:50,600 --> 02:44:53,600
33 for example

4198
02:44:53,600 --> 02:44:56,080
and it's going to tell me hello daniel

4199
02:44:56,080 --> 02:44:59,840
you are 33 years old i put a slash here

4200
02:44:59,840 --> 02:45:02,000
we can try and run it again so that i

4201
02:45:02,000 --> 02:45:04,160
don't have to make that mistake again so

4202
02:45:04,160 --> 02:45:07,680
daniel that's my name i hit enter i say

4203
02:45:07,680 --> 02:45:08,880
33

4204
02:45:08,880 --> 02:45:10,640
and if i run

4205
02:45:10,640 --> 02:45:13,040
it's going to say hello daniel you are

4206
02:45:13,040 --> 02:45:16,319
33 years old i really hope this brings

4207
02:45:16,319 --> 02:45:17,840
the point home

4208
02:45:17,840 --> 02:45:18,680
that

4209
02:45:18,680 --> 02:45:21,680
stdcin is a highway

4210
02:45:21,680 --> 02:45:24,720
that takes data from the terminal into

4211
02:45:24,720 --> 02:45:26,720
your program so this is really what is

4212
02:45:26,720 --> 02:45:28,560
happening here when i type daniel it's

4213
02:45:28,560 --> 02:45:30,640
going to flow from the terminal and it's

4214
02:45:30,640 --> 02:45:33,120
going to go into my variable which is

4215
02:45:33,120 --> 02:45:35,840
name here and when i type the age it's

4216
02:45:35,840 --> 02:45:38,720
going to go in my edge variable here and

4217
02:45:38,720 --> 02:45:41,680
all these happening through

4218
02:45:41,680 --> 02:45:44,800
in here okay one other thing we can do

4219
02:45:44,800 --> 02:45:46,000
is

4220
02:45:46,000 --> 02:45:48,319
grab the data and put that in our

4221
02:45:48,319 --> 02:45:51,040
variables in one go so what we can do

4222
02:45:51,040 --> 02:45:53,439
here is comment this out and we're going

4223
02:45:53,439 --> 02:45:54,359
to do

4224
02:45:54,359 --> 02:45:57,120
stdcin and we're going to put that in

4225
02:45:57,120 --> 02:45:59,439
name and we're going to change these two

4226
02:45:59,439 --> 02:46:02,720
things and put the other piece of data

4227
02:46:02,720 --> 02:46:05,200
in h1 if you run the program it's going

4228
02:46:05,200 --> 02:46:07,680
to work exactly the same way but we are

4229
02:46:07,680 --> 02:46:10,479
grabbing the data in one line so let's

4230
02:46:10,479 --> 02:46:12,319
weld to see this in action we're going

4231
02:46:12,319 --> 02:46:15,120
to run the task that worlds with gcc

4232
02:46:15,120 --> 02:46:16,880
we're going to click here and we're

4233
02:46:16,880 --> 02:46:18,960
going to clear if we run rooster it's

4234
02:46:18,960 --> 02:46:21,040
going to ask for the name and the age

4235
02:46:21,040 --> 02:46:23,040
i'm going to put in daniel and i'm going

4236
02:46:23,040 --> 02:46:26,160
to put my h and say 33 for example and

4237
02:46:26,160 --> 02:46:28,319
it's going to do exactly the same thing

4238
02:46:28,319 --> 02:46:30,399
but we have one compact line the last

4239
02:46:30,399 --> 02:46:32,160
thing i want to show you in this lecture

4240
02:46:32,160 --> 02:46:34,880
is how you can grab data with spaces

4241
02:46:34,880 --> 02:46:37,200
because if i try to put in data with

4242
02:46:37,200 --> 02:46:40,399
spaces here the program is going to fail

4243
02:46:40,399 --> 02:46:42,640
miserably let me show you this i'm going

4244
02:46:42,640 --> 02:46:44,640
to clear and i'm going to run rooster

4245
02:46:44,640 --> 02:46:47,439
again and i'm going to say daniel i'm

4246
02:46:47,439 --> 02:46:50,319
going to put in my full name and uh it's

4247
02:46:50,319 --> 02:46:52,880
really not grabbing the second name and

4248
02:46:52,880 --> 02:46:55,520
it didn't give me a chance to input my

4249
02:46:55,520 --> 02:46:57,439
age and this is really bad

4250
02:46:57,439 --> 02:46:59,840
so c plus plus provides a way to solve

4251
02:46:59,840 --> 02:47:03,040
this using std get line so let's see

4252
02:47:03,040 --> 02:47:04,880
what we are doing here and before we

4253
02:47:04,880 --> 02:47:06,240
play with this we're going to comment

4254
02:47:06,240 --> 02:47:08,720
out what we had here so that

4255
02:47:08,720 --> 02:47:11,279
it doesn't disturb us in what we are

4256
02:47:11,279 --> 02:47:14,160
about to do so let's come down here and

4257
02:47:14,160 --> 02:47:16,560
say that we were doing data input this

4258
02:47:16,560 --> 02:47:18,479
is helpful here and we're going to go

4259
02:47:18,479 --> 02:47:21,439
down and grab data with spaces so i am

4260
02:47:21,439 --> 02:47:23,600
going to set up another strength and

4261
02:47:23,600 --> 02:47:25,840
this is going to store my full name

4262
02:47:25,840 --> 02:47:28,319
that's what i'm going to say here and to

4263
02:47:28,319 --> 02:47:30,319
grab it i'm going to tell the user to

4264
02:47:30,319 --> 02:47:33,200
type in their full name and age so i am

4265
02:47:33,200 --> 02:47:35,760
going to sddc out so the way i'm going

4266
02:47:35,760 --> 02:47:38,880
to grab the data i'm going to do std get

4267
02:47:38,880 --> 02:47:40,880
line you see that we have this function

4268
02:47:40,880 --> 02:47:42,800
here and it's going to take an input

4269
02:47:42,800 --> 02:47:45,920
stream so asd dcin is going to work and

4270
02:47:45,920 --> 02:47:47,520
the second parameter is going to be the

4271
02:47:47,520 --> 02:47:49,760
variable where this string data is going

4272
02:47:49,760 --> 02:47:51,680
to be stored we're going to pass in our

4273
02:47:51,680 --> 02:47:54,560
full name and this is going to work just

4274
02:47:54,560 --> 02:47:57,920
fine and we're going to also grab the h

4275
02:47:57,920 --> 02:47:59,680
using the same technique we've used

4276
02:47:59,680 --> 02:48:01,560
before so we're going to say

4277
02:48:01,560 --> 02:48:04,560
stdcin and we're going to store that in

4278
02:48:04,560 --> 02:48:07,680
our h3 variable once we have the data we

4279
02:48:07,680 --> 02:48:10,720
can greet our user using the same

4280
02:48:10,720 --> 02:48:12,720
message we had before so i'm going to

4281
02:48:12,720 --> 02:48:15,279
copy that if i can do that and i'm going

4282
02:48:15,279 --> 02:48:17,600
to paste that here i'm going to bring

4283
02:48:17,600 --> 02:48:19,439
this to the same location it's going to

4284
02:48:19,439 --> 02:48:21,680
be full name here and it's going to say

4285
02:48:21,680 --> 02:48:25,040
h3 and let's try and weld we're going to

4286
02:48:25,040 --> 02:48:28,479
terminal run the task to bolt with gcc

4287
02:48:28,479 --> 02:48:31,600
and we have a problem because we forgot

4288
02:48:31,600 --> 02:48:33,760
our semicolon see how these problems

4289
02:48:33,760 --> 02:48:35,680
might come to you uh-huh so we're going

4290
02:48:35,680 --> 02:48:38,399
to put in our semicolon and another

4291
02:48:38,399 --> 02:48:41,120
thing i really want you to see

4292
02:48:41,120 --> 02:48:42,399
is that you can

4293
02:48:42,399 --> 02:48:44,640
bring these things to the next line if

4294
02:48:44,640 --> 02:48:47,200
they turn out too long like we see here

4295
02:48:47,200 --> 02:48:49,359
so i can for example put this to the

4296
02:48:49,359 --> 02:48:51,200
next line and it is going to work just

4297
02:48:51,200 --> 02:48:53,120
fine so what i am going to do i'm going

4298
02:48:53,120 --> 02:48:56,160
to try and weld again run task to build

4299
02:48:56,160 --> 02:48:59,279
with gcc you see that the world is good

4300
02:48:59,279 --> 02:49:00,399
we're going to

4301
02:49:00,399 --> 02:49:02,880
bring in our terminal i'm going to clear

4302
02:49:02,880 --> 02:49:05,520
so that we don't have noise here and

4303
02:49:05,520 --> 02:49:07,439
we're going to run our program it's

4304
02:49:07,439 --> 02:49:09,600
going to ask me to put in my full name

4305
02:49:09,600 --> 02:49:11,600
i'm going to say daniel

4306
02:49:11,600 --> 02:49:13,520
and it's going to want the age i'm going

4307
02:49:13,520 --> 02:49:15,600
to say 33 and it's going to reach me

4308
02:49:15,600 --> 02:49:18,640
hello daniel gaway you are 33 years old

4309
02:49:18,640 --> 02:49:21,600
we are able to bring data with spaces

4310
02:49:21,600 --> 02:49:24,479
into our program and this concludes what

4311
02:49:24,479 --> 02:49:26,800
we had to say in this lecture i hope it

4312
02:49:26,800 --> 02:49:30,640
made it very clear what these htd n and

4313
02:49:30,640 --> 02:49:33,520
stdc out things are they are basically

4314
02:49:33,520 --> 02:49:36,000
highways that take data out of your

4315
02:49:36,000 --> 02:49:38,640
program or bring data into your program

4316
02:49:38,640 --> 02:49:40,640
and the way you use them is what we've

4317
02:49:40,640 --> 02:49:42,399
done here in this course i would

4318
02:49:42,399 --> 02:49:44,160
encourage you to play with us a couple

4319
02:49:44,160 --> 02:49:45,840
of times if this is the first time

4320
02:49:45,840 --> 02:49:47,680
you're doing this we are going to stop

4321
02:49:47,680 --> 02:49:49,520
here in this lecture in the next one

4322
02:49:49,520 --> 02:49:51,920
we're going to try and recap on the c

4323
02:49:51,920 --> 02:49:54,560
plus plus development workflow go ahead

4324
02:49:54,560 --> 02:49:57,120
and finish up here and meet me there

4325
02:49:57,120 --> 02:49:59,040
in this lecture we're going to explore

4326
02:49:59,040 --> 02:50:02,160
the c plus plus execution model and show

4327
02:50:02,160 --> 02:50:04,800
you a simplified version of the memory

4328
02:50:04,800 --> 02:50:08,080
model of your c plus plus program here

4329
02:50:08,080 --> 02:50:11,279
is how our program looks it is a simple

4330
02:50:11,279 --> 02:50:13,680
program in our main function it is going

4331
02:50:13,680 --> 02:50:15,840
to call a simple function that is going

4332
02:50:15,840 --> 02:50:17,600
to add two numbers we have seen a

4333
02:50:17,600 --> 02:50:19,680
program like this before and when we

4334
02:50:19,680 --> 02:50:22,240
compile it it's going to be turned into

4335
02:50:22,240 --> 02:50:25,200
a binary this black icon here represents

4336
02:50:25,200 --> 02:50:28,160
the binary executable and it is not in

4337
02:50:28,160 --> 02:50:29,439
the format

4338
02:50:29,439 --> 02:50:31,680
that you can read with your eyes if we

4339
02:50:31,680 --> 02:50:34,160
come back here to what we were doing in

4340
02:50:34,160 --> 02:50:36,800
the last lecture we can see our rooster

4341
02:50:36,800 --> 02:50:39,600
executable binary here if you try to

4342
02:50:39,600 --> 02:50:41,279
open it here you're going to see that

4343
02:50:41,279 --> 02:50:43,040
visual studio code is going to say the

4344
02:50:43,040 --> 02:50:45,040
file is not displayed in the editor

4345
02:50:45,040 --> 02:50:48,240
because it is either binary or uses an

4346
02:50:48,240 --> 02:50:52,000
unsupported text encoding so it says i

4347
02:50:52,000 --> 02:50:53,520
can't really say this because it's

4348
02:50:53,520 --> 02:50:55,359
binary and it says do you want to open

4349
02:50:55,359 --> 02:50:57,760
it anyway if i try to open it it's going

4350
02:50:57,760 --> 02:50:59,600
to be just some gibberish because this

4351
02:50:59,600 --> 02:51:02,720
is binary it is meant to be

4352
02:51:02,720 --> 02:51:05,520
read by programs it is not meant to be

4353
02:51:05,520 --> 02:51:09,040
by ides or text editors like visual

4354
02:51:09,040 --> 02:51:11,760
studio code so this is the binary file

4355
02:51:11,760 --> 02:51:14,560
we have here i tried to put a simplified

4356
02:51:14,560 --> 02:51:16,479
version of this program to represent

4357
02:51:16,479 --> 02:51:18,560
binary so that we can follow it up but

4358
02:51:18,560 --> 02:51:21,279
it is not in the form that is readable

4359
02:51:21,279 --> 02:51:24,399
by any human out there unless you are a

4360
02:51:24,399 --> 02:51:26,720
machine so why is it in binary because

4361
02:51:26,720 --> 02:51:29,600
binary format is easily understandable

4362
02:51:29,600 --> 02:51:31,920
by your cpu and we're going to see how

4363
02:51:31,920 --> 02:51:34,080
your program is loaded in memory and

4364
02:51:34,080 --> 02:51:36,720
executed statement by statement by the

4365
02:51:36,720 --> 02:51:39,200
cpu so that you can really understand

4366
02:51:39,200 --> 02:51:41,680
this so here is a representation of your

4367
02:51:41,680 --> 02:51:44,319
program here we have our how to drive

4368
02:51:44,319 --> 02:51:45,840
and we have the program sitting

4369
02:51:45,840 --> 02:51:48,640
somewhere on our hard drive in binary

4370
02:51:48,640 --> 02:51:52,000
format and it's waiting to be run by you

4371
02:51:52,000 --> 02:51:54,640
by double clicking on it or opening it

4372
02:51:54,640 --> 02:51:56,880
in the terminal and on the left here we

4373
02:51:56,880 --> 02:51:59,680
see a representation of the memory of

4374
02:51:59,680 --> 02:52:02,479
our computer and when i say memory i

4375
02:52:02,479 --> 02:52:05,200
mean random access memory i don't mean

4376
02:52:05,200 --> 02:52:07,920
memory on your hard drive this should be

4377
02:52:07,920 --> 02:52:09,920
really clear this is the random access

4378
02:52:09,920 --> 02:52:12,319
memory of your computer that is running

4379
02:52:12,319 --> 02:52:15,200
your programs very fast so when you

4380
02:52:15,200 --> 02:52:18,240
double click on our program or if we

4381
02:52:18,240 --> 02:52:20,720
open it in the terminal the binary file

4382
02:52:20,720 --> 02:52:23,279
is going to be loaded up in memory and

4383
02:52:23,279 --> 02:52:25,120
you see it in red here this is a

4384
02:52:25,120 --> 02:52:27,520
representation of that and it is ready

4385
02:52:27,520 --> 02:52:30,240
to be run by the cpu by the time the cpu

4386
02:52:30,240 --> 02:52:32,319
says in the memory location it's going

4387
02:52:32,319 --> 02:52:34,479
to know i have a program to run and the

4388
02:52:34,479 --> 02:52:36,560
cpu is going to start running it

4389
02:52:36,560 --> 02:52:38,399
statement by statement it is going to

4390
02:52:38,399 --> 02:52:40,640
start by the top so it's going to see

4391
02:52:40,640 --> 02:52:43,760
that it needs to allocate space to store

4392
02:52:43,760 --> 02:52:46,479
our integer a it's going to allocate to

4393
02:52:46,479 --> 02:52:48,800
that somewhere on the memory in yellow

4394
02:52:48,800 --> 02:52:50,880
here you see a and it's going to see

4395
02:52:50,880 --> 02:52:53,920
that it should store in a value of 10

4396
02:52:53,920 --> 02:52:55,520
and it's going to do that you can see

4397
02:52:55,520 --> 02:52:57,760
that here it's going to go to the next

4398
02:52:57,760 --> 02:53:00,240
statement and the next statement tells

4399
02:53:00,240 --> 02:53:02,399
it to allocate space for

4400
02:53:02,399 --> 02:53:06,000
a value b and it's going to store in f5

4401
02:53:06,000 --> 02:53:08,080
it's going to go to the next statement

4402
02:53:08,080 --> 02:53:10,560
it's a variable called c it's going to

4403
02:53:10,560 --> 02:53:12,560
allocate space for it but we didn't

4404
02:53:12,560 --> 02:53:15,439
specify a value for c so what it's going

4405
02:53:15,439 --> 02:53:17,840
to do is store in some junk value the

4406
02:53:17,840 --> 02:53:20,640
value in there is really unspecified at

4407
02:53:20,640 --> 02:53:22,880
the moment it's going to jump to the

4408
02:53:22,880 --> 02:53:25,120
next statement and what it's going to do

4409
02:53:25,120 --> 02:53:27,600
is print some things on the console and

4410
02:53:27,600 --> 02:53:29,279
it is going to do that it's going to

4411
02:53:29,279 --> 02:53:31,439
jump to the next statement and it is

4412
02:53:31,439 --> 02:53:34,720
going to print statement 2 and here it

4413
02:53:34,720 --> 02:53:36,560
is going to notice that it is going to

4414
02:53:36,560 --> 02:53:38,399
call a function i don't know if you have

4415
02:53:38,399 --> 02:53:40,720
noticed but the cpu has allocated a

4416
02:53:40,720 --> 02:53:44,080
special memory location for our function

4417
02:53:44,080 --> 02:53:46,319
the function doesn't leave with our code

4418
02:53:46,319 --> 02:53:49,040
here or anywhere near the variables that

4419
02:53:49,040 --> 02:53:52,720
we have here there might be a huge chunk

4420
02:53:52,720 --> 02:53:55,040
of memory between these two or three

4421
02:53:55,040 --> 02:53:57,840
things so the cpu knows that it is going

4422
02:53:57,840 --> 02:54:00,080
to jump to another location it's going

4423
02:54:00,080 --> 02:54:02,720
to ask itself if i jump to that location

4424
02:54:02,720 --> 02:54:04,800
to run this function how am i going to

4425
02:54:04,800 --> 02:54:07,600
come back and the cpu is smart enough to

4426
02:54:07,600 --> 02:54:10,240
store the return address and that's what

4427
02:54:10,240 --> 02:54:12,160
it's going to do it's going to say if i

4428
02:54:12,160 --> 02:54:13,920
go to that function i want to come back

4429
02:54:13,920 --> 02:54:16,479
to the address 6 and run whatever is

4430
02:54:16,479 --> 02:54:18,080
after this address so it's going to

4431
02:54:18,080 --> 02:54:21,279
store 6 and cpu memory and it's going to

4432
02:54:21,279 --> 02:54:23,040
jump to the function it's going to take

4433
02:54:23,040 --> 02:54:25,600
the first parameter as a and the second

4434
02:54:25,600 --> 02:54:28,640
parameter as b so a is done the

4435
02:54:28,640 --> 02:54:30,800
parameter 1 is going to be 10 it's going

4436
02:54:30,800 --> 02:54:33,200
to take parameter 2 it's going to be 5

4437
02:54:33,200 --> 02:54:35,840
because it is b here and in b we have a

4438
02:54:35,840 --> 02:54:38,080
5 and it is going to jump to the next

4439
02:54:38,080 --> 02:54:40,240
statement in the function and it is

4440
02:54:40,240 --> 02:54:42,560
going to add up parameter 1 and

4441
02:54:42,560 --> 02:54:45,680
parameter 2. after it adds those things

4442
02:54:45,680 --> 02:54:48,479
up it's going to return the result to c

4443
02:54:48,479 --> 02:54:50,720
we can see that here okay that's what

4444
02:54:50,720 --> 02:54:52,880
the cpu is going to do it's going to put

4445
02:54:52,880 --> 02:54:55,439
the results in c and the result is a 15

4446
02:54:55,439 --> 02:54:57,359
so we're going to write that in there

4447
02:54:57,359 --> 02:55:00,080
and now that the function is really done

4448
02:55:00,080 --> 02:55:01,920
it's going to come back to its address

4449
02:55:01,920 --> 02:55:03,920
and it is going to jump to the next

4450
02:55:03,920 --> 02:55:06,560
segment after that it is going to

4451
02:55:06,560 --> 02:55:09,120
print three statement three it is going

4452
02:55:09,120 --> 02:55:11,439
to jump through the next line and print

4453
02:55:11,439 --> 02:55:14,560
statement four it's going to do that and

4454
02:55:14,560 --> 02:55:17,680
by this time we have reached the end of

4455
02:55:17,680 --> 02:55:20,240
our program and it is going to be popped

4456
02:55:20,240 --> 02:55:22,640
off the memory and your program is

4457
02:55:22,640 --> 02:55:24,960
basically going to end this is how your

4458
02:55:24,960 --> 02:55:28,479
program is executed by your cpu and why

4459
02:55:28,479 --> 02:55:30,560
am i showing you this because it is

4460
02:55:30,560 --> 02:55:32,800
really good to have an idea of how

4461
02:55:32,800 --> 02:55:35,359
memory is allocated and used by your

4462
02:55:35,359 --> 02:55:38,000
program another good reason is that some

4463
02:55:38,000 --> 02:55:40,319
c plus plus feature require you to have

4464
02:55:40,319 --> 02:55:42,720
an understanding of a memory model like

4465
02:55:42,720 --> 02:55:44,640
this to understand how they work for

4466
02:55:44,640 --> 02:55:46,880
example you have seen that to call this

4467
02:55:46,880 --> 02:55:49,359
function the program had to jump from

4468
02:55:49,359 --> 02:55:53,040
address 6 to 30 and this is really heavy

4469
02:55:53,040 --> 02:55:55,040
especially if you are running a simple

4470
02:55:55,040 --> 02:55:57,120
function like we are doing here to add

4471
02:55:57,120 --> 02:55:59,920
two numbers so the cpu can realize that

4472
02:55:59,920 --> 02:56:02,880
and optimize this call to the function

4473
02:56:02,880 --> 02:56:06,080
to an inline function and add these two

4474
02:56:06,080 --> 02:56:08,800
numbers up right here at address six

4475
02:56:08,800 --> 02:56:10,800
without jumping to this address here and

4476
02:56:10,800 --> 02:56:12,880
this may come in handy and you need an

4477
02:56:12,880 --> 02:56:14,960
understanding of this memory model to

4478
02:56:14,960 --> 02:56:17,279
really understand these features this is

4479
02:56:17,279 --> 02:56:19,439
just one example i am giving you you are

4480
02:56:19,439 --> 02:56:22,000
going to reuse this model a lot in your

4481
02:56:22,000 --> 02:56:24,560
career as a class plus developer and i

4482
02:56:24,560 --> 02:56:26,479
thought it was a really good idea for

4483
02:56:26,479 --> 02:56:29,120
you to understand it firsthand this is

4484
02:56:29,120 --> 02:56:30,640
really all i had to share in this

4485
02:56:30,640 --> 02:56:33,040
lecture i hope you found it interesting

4486
02:56:33,040 --> 02:56:34,720
in the next one we're going to try and

4487
02:56:34,720 --> 02:56:36,720
understand the difference between three

4488
02:56:36,720 --> 02:56:38,960
key components of the c plus plus

4489
02:56:38,960 --> 02:56:41,040
programming language go ahead and finish

4490
02:56:41,040 --> 02:56:43,200
up here and meet me there in this

4491
02:56:43,200 --> 02:56:45,120
lecture i want to highlight the

4492
02:56:45,120 --> 02:56:47,680
differences between what we call a c

4493
02:56:47,680 --> 02:56:50,640
plus plus core language feature or a

4494
02:56:50,640 --> 02:56:53,359
standard library feature or an stl

4495
02:56:53,359 --> 02:56:55,279
feature because these are terms that

4496
02:56:55,279 --> 02:56:57,920
come up a lot if you happen to read some

4497
02:56:57,920 --> 02:57:00,479
documentation about c plus plus a core

4498
02:57:00,479 --> 02:57:03,920
feature is really a basic building block

4499
02:57:03,920 --> 02:57:05,840
that makes up the c plus plus

4500
02:57:05,840 --> 02:57:08,240
programming language you can think of it

4501
02:57:08,240 --> 02:57:10,880
for example how you define variables the

4502
02:57:10,880 --> 02:57:13,760
rules that govern how you can define and

4503
02:57:13,760 --> 02:57:16,160
use a function in c plus plus the rules

4504
02:57:16,160 --> 02:57:18,800
that say what you can do and not do with

4505
02:57:18,800 --> 02:57:21,359
the basic features of c plus plus that's

4506
02:57:21,359 --> 02:57:24,240
really what can be qualified as the core

4507
02:57:24,240 --> 02:57:26,800
feature of the c plus plus programming

4508
02:57:26,800 --> 02:57:29,040
language i don't know if that makes any

4509
02:57:29,040 --> 02:57:31,439
sense if we come back in visual studio

4510
02:57:31,439 --> 02:57:33,359
code we have a program we have used in

4511
02:57:33,359 --> 02:57:35,920
the last few lectures for example these

4512
02:57:35,920 --> 02:57:38,640
basic types that you use in c plus plus

4513
02:57:38,640 --> 02:57:41,359
the rules that define how you can define

4514
02:57:41,359 --> 02:57:45,040
a function for example if you put a

4515
02:57:45,040 --> 02:57:47,439
an angle bracket here and try to compile

4516
02:57:47,439 --> 02:57:50,720
this program it is not going to work

4517
02:57:50,720 --> 02:57:53,840
because we have violated the rules of

4518
02:57:53,840 --> 02:57:56,880
the c plus plus programs the basic rules

4519
02:57:56,880 --> 02:57:59,120
that define how the c plus plus

4520
02:57:59,120 --> 02:58:01,439
programming language works the basic

4521
02:58:01,439 --> 02:58:03,279
types that are defined in the c plus

4522
02:58:03,279 --> 02:58:05,279
plus programming language these little

4523
02:58:05,279 --> 02:58:08,080
things make up the raw ingredients you

4524
02:58:08,080 --> 02:58:10,960
use to make up a proper c plus plus

4525
02:58:10,960 --> 02:58:14,080
programs and these little row components

4526
02:58:14,080 --> 02:58:16,319
that you use to put together a c plus

4527
02:58:16,319 --> 02:58:18,960
plus program are called core features

4528
02:58:18,960 --> 02:58:19,920
you can

4529
02:58:19,920 --> 02:58:22,800
think of them as the foundation on top

4530
02:58:22,800 --> 02:58:25,840
of which we really build daily use c

4531
02:58:25,840 --> 02:58:28,800
plus plus programs the standard library

4532
02:58:28,800 --> 02:58:31,600
is a set of ready to use

4533
02:58:31,600 --> 02:58:34,000
highly specialized components that we

4534
02:58:34,000 --> 02:58:36,080
can easily use in our c plus plus

4535
02:58:36,080 --> 02:58:38,479
programs and again coming back to our

4536
02:58:38,479 --> 02:58:41,760
program in visual studio code iostream

4537
02:58:41,760 --> 02:58:44,240
here is a standard library feature

4538
02:58:44,240 --> 02:58:46,880
string here is a standard library thing

4539
02:58:46,880 --> 02:58:49,040
we have in the c plus plus programming

4540
02:58:49,040 --> 02:58:51,920
language and again the c plus plus

4541
02:58:51,920 --> 02:58:54,960
standard library tries to provide highly

4542
02:58:54,960 --> 02:58:57,680
specialized components that we can use

4543
02:58:57,680 --> 02:59:00,800
in regular c plus plus programs when you

4544
02:59:00,800 --> 02:59:02,800
use the c plus plus programming language

4545
02:59:02,800 --> 02:59:05,520
you don't really want to extend the c

4546
02:59:05,520 --> 02:59:08,319
plus plus programming language you want

4547
02:59:08,319 --> 02:59:10,720
to use it to build something of your own

4548
02:59:10,720 --> 02:59:13,520
and uh the standard library features are

4549
02:59:13,520 --> 02:59:16,000
things you use to work on your programs

4550
02:59:16,000 --> 02:59:18,880
very fast for example we have used sddc

4551
02:59:18,880 --> 02:59:20,800
out without really going into the

4552
02:59:20,800 --> 02:59:23,120
details of how the data is taken from

4553
02:59:23,120 --> 02:59:25,040
this program to the terminal that's

4554
02:59:25,040 --> 02:59:27,680
really advanced and probably complicated

4555
02:59:27,680 --> 02:59:30,319
but it is wrapped into this reusable

4556
02:59:30,319 --> 02:59:33,120
components and one of them is iostream

4557
02:59:33,120 --> 02:59:36,080
and we can use it relatively easily in

4558
02:59:36,080 --> 02:59:38,800
our c plus plus program okay i hope now

4559
02:59:38,800 --> 02:59:40,880
you have a better idea of what the c

4560
02:59:40,880 --> 02:59:43,600
plus plus standard library is now what

4561
02:59:43,600 --> 02:59:47,359
is the stl the stl is really part of the

4562
02:59:47,359 --> 02:59:50,319
c plus plus standard library but it is a

4563
02:59:50,319 --> 02:59:53,279
collection of container types think of

4564
02:59:53,279 --> 02:59:56,080
them as collections of things and we

4565
02:59:56,080 --> 02:59:58,720
have a set of types that allow us to

4566
02:59:58,720 --> 03:00:02,240
store collections we have algorithms or

4567
03:00:02,240 --> 03:00:04,960
functions that work on these collections

4568
03:00:04,960 --> 03:00:08,080
and we have specialized types that are

4569
03:00:08,080 --> 03:00:10,800
called iterators that allow us to

4570
03:00:10,800 --> 03:00:12,960
navigate through these containers

4571
03:00:12,960 --> 03:00:16,080
potentially running these algorithms on

4572
03:00:16,080 --> 03:00:18,640
each element in the collection this is

4573
03:00:18,640 --> 03:00:21,040
probably not making sense by now but you

4574
03:00:21,040 --> 03:00:24,160
can think of the stl as a highly

4575
03:00:24,160 --> 03:00:26,560
specialized part of the c plus plus

4576
03:00:26,560 --> 03:00:28,080
standard library and we're going to

4577
03:00:28,080 --> 03:00:30,000
learn about many features of these

4578
03:00:30,000 --> 03:00:32,240
things throughout the course but i want

4579
03:00:32,240 --> 03:00:35,120
you to have a basic understanding

4580
03:00:35,120 --> 03:00:37,680
between these three terms a core feature

4581
03:00:37,680 --> 03:00:40,080
of the c plus plus programming language

4582
03:00:40,080 --> 03:00:43,279
is standard library feature and the stl

4583
03:00:43,279 --> 03:00:46,399
and i really hope this is clear to you

4584
03:00:46,399 --> 03:00:48,560
by now in this chapter we're going to

4585
03:00:48,560 --> 03:00:51,439
learn about variables and data types

4586
03:00:51,439 --> 03:00:53,520
before we talk about variables and data

4587
03:00:53,520 --> 03:00:55,520
types i would like to take a moment and

4588
03:00:55,520 --> 03:00:58,080
recap on what we know by now

4589
03:00:58,080 --> 03:01:00,240
and if you look at these cards many of

4590
03:01:00,240 --> 03:01:01,920
these things should make sense now you

4591
03:01:01,920 --> 03:01:03,520
know about the main function you know

4592
03:01:03,520 --> 03:01:05,200
that it is the entry point of your

4593
03:01:05,200 --> 03:01:07,439
program you know that your program is

4594
03:01:07,439 --> 03:01:09,600
going to be made up of statements and

4595
03:01:09,600 --> 03:01:12,000
statements and with a semicolon in c

4596
03:01:12,000 --> 03:01:13,040
plus plus

4597
03:01:13,040 --> 03:01:15,680
you know about functions errors warnings

4598
03:01:15,680 --> 03:01:18,160
you now have an idea about how you can

4599
03:01:18,160 --> 03:01:20,319
handle input and output from your

4600
03:01:20,319 --> 03:01:22,880
program you can use comments you know

4601
03:01:22,880 --> 03:01:25,359
about the memory model and the execution

4602
03:01:25,359 --> 03:01:27,520
model that we talked about in the last

4603
03:01:27,520 --> 03:01:29,520
lecture you know quite a lot now we have

4604
03:01:29,520 --> 03:01:31,760
been using a program like this to do

4605
03:01:31,760 --> 03:01:34,080
things in the last chapter but there is

4606
03:01:34,080 --> 03:01:36,479
one thing that isn't really explained

4607
03:01:36,479 --> 03:01:39,439
yet and that is this ant this end is a

4608
03:01:39,439 --> 03:01:42,880
type that is predefined in c plus plus

4609
03:01:42,880 --> 03:01:46,160
and c plus plus predefines many types

4610
03:01:46,160 --> 03:01:48,960
here we have a couple of these types for

4611
03:01:48,960 --> 03:01:51,760
you to see as examples it is one of them

4612
03:01:51,760 --> 03:01:53,920
we have seen it a lot of times in the

4613
03:01:53,920 --> 03:01:56,800
last chapter it is used to represent

4614
03:01:56,800 --> 03:01:59,520
whole numbers like one two and three but

4615
03:01:59,520 --> 03:02:02,160
we have others for example double and

4616
03:02:02,160 --> 03:02:05,200
float are used to represent fractional

4617
03:02:05,200 --> 03:02:08,160
numbers numbers that have decimal points

4618
03:02:08,160 --> 03:02:12,319
for example 2.5 7.3 and numbers like

4619
03:02:12,319 --> 03:02:13,840
that and we're going to see the

4620
03:02:13,840 --> 03:02:15,840
difference between these two another one

4621
03:02:15,840 --> 03:02:19,359
that is commonly used is char or car and

4622
03:02:19,359 --> 03:02:22,000
it is used to represent characters in

4623
03:02:22,000 --> 03:02:25,279
memory and you can store in characters

4624
03:02:25,279 --> 03:02:28,080
like a b c and d and all the other

4625
03:02:28,080 --> 03:02:30,000
characters you can really put in we have

4626
03:02:30,000 --> 03:02:32,560
a bull which is a type that is going to

4627
03:02:32,560 --> 03:02:35,040
store two possible states the only

4628
03:02:35,040 --> 03:02:37,359
values you can really store in here are

4629
03:02:37,359 --> 03:02:39,520
true or false and we're going to see how

4630
03:02:39,520 --> 03:02:43,279
this works void is uh somewhat confusing

4631
03:02:43,279 --> 03:02:46,240
because it represents a typeless type

4632
03:02:46,240 --> 03:02:49,200
and it is really meaningful when we get

4633
03:02:49,200 --> 03:02:51,760
to talk about functions in detail so

4634
03:02:51,760 --> 03:02:53,920
we're going to learn more about the void

4635
03:02:53,920 --> 03:02:56,319
type a little later in the course we

4636
03:02:56,319 --> 03:02:59,120
also have the auto type which is really

4637
03:02:59,120 --> 03:03:02,160
not a type it is a keyword you use in c

4638
03:03:02,160 --> 03:03:04,720
plus plus to deduce other types and

4639
03:03:04,720 --> 03:03:06,960
we're going to see how this works later

4640
03:03:06,960 --> 03:03:09,200
in the course these are a few examples

4641
03:03:09,200 --> 03:03:12,160
of types we can use in c plus plus and

4642
03:03:12,160 --> 03:03:14,479
we are going to play with most of them

4643
03:03:14,479 --> 03:03:16,399
in this chapter another thing i really

4644
03:03:16,399 --> 03:03:19,120
want you to see is what does it mean to

4645
03:03:19,120 --> 03:03:21,840
really put a 4 in a variable in your

4646
03:03:21,840 --> 03:03:23,680
program everything you have in this

4647
03:03:23,680 --> 03:03:26,800
program here is represented by ones and

4648
03:03:26,800 --> 03:03:29,520
zeros in the computer's memory it really

4649
03:03:29,520 --> 03:03:31,760
looks like this it's a bunch of ones and

4650
03:03:31,760 --> 03:03:34,800
zeros in the ram of your computer and

4651
03:03:34,800 --> 03:03:36,560
there must be a technique to make sense

4652
03:03:36,560 --> 03:03:39,359
of this gibberish here and store data

4653
03:03:39,359 --> 03:03:41,760
that makes sense to humans and the

4654
03:03:41,760 --> 03:03:44,560
starting point is to group these ones

4655
03:03:44,560 --> 03:03:47,439
and zeros into little chunks that we can

4656
03:03:47,439 --> 03:03:49,760
manipulate each of these ones and zeros

4657
03:03:49,760 --> 03:03:52,640
is called a bet so this zero here is a

4658
03:03:52,640 --> 03:03:55,040
bit this one here is a bet and if we

4659
03:03:55,040 --> 03:03:57,040
group eight beats together they are

4660
03:03:57,040 --> 03:03:59,840
going to form what we call a byte okay

4661
03:03:59,840 --> 03:04:01,920
if it makes sense you can group your

4662
03:04:01,920 --> 03:04:04,960
bits in bytes or if it makes sense to

4663
03:04:04,960 --> 03:04:07,439
group them in groups of 16 you can do

4664
03:04:07,439 --> 03:04:09,200
that like we see here we're going to see

4665
03:04:09,200 --> 03:04:11,200
a little more details about this in the

4666
03:04:11,200 --> 03:04:13,359
next lecture okay here you see that if

4667
03:04:13,359 --> 03:04:16,160
you really want you can treat each bit

4668
03:04:16,160 --> 03:04:19,520
as a self-contained piece of data but

4669
03:04:19,520 --> 03:04:21,840
this is really not very useful but there

4670
03:04:21,840 --> 03:04:24,640
are some corner use cases for this okay

4671
03:04:24,640 --> 03:04:26,800
now we really have two sides on the

4672
03:04:26,800 --> 03:04:29,520
right we have data in the format that is

4673
03:04:29,520 --> 03:04:32,319
really convenient and understandable by

4674
03:04:32,319 --> 03:04:35,120
humans and on the left we have how data

4675
03:04:35,120 --> 03:04:37,680
is represented in memory so there must

4676
03:04:37,680 --> 03:04:40,319
be a way to transform between these two

4677
03:04:40,319 --> 03:04:42,720
forms of data because humans can't

4678
03:04:42,720 --> 03:04:44,960
really handle these ones and zeros well

4679
03:04:44,960 --> 03:04:47,120
and we do the transformation between

4680
03:04:47,120 --> 03:04:50,399
these two representations of data using

4681
03:04:50,399 --> 03:04:52,640
number systems we have a few number

4682
03:04:52,640 --> 03:04:55,200
systems available to us that we can use

4683
03:04:55,200 --> 03:04:58,080
binary octal hexadecimal are a few

4684
03:04:58,080 --> 03:05:00,240
examples and we're going to learn about

4685
03:05:00,240 --> 03:05:02,720
them starting in the next lecture so go

4686
03:05:02,720 --> 03:05:04,720
ahead and finish up here and meet me

4687
03:05:04,720 --> 03:05:06,640
there in this lecture we're going to

4688
03:05:06,640 --> 03:05:09,600
learn a little more about number systems

4689
03:05:09,600 --> 03:05:11,840
number systems allow us to transform

4690
03:05:11,840 --> 03:05:14,080
data from the form that is really

4691
03:05:14,080 --> 03:05:16,720
convenient for humans in a form that is

4692
03:05:16,720 --> 03:05:19,200
convenient for computers in these ones

4693
03:05:19,200 --> 03:05:21,359
and zeros that you see on the left we

4694
03:05:21,359 --> 03:05:23,680
can also use them to do the reverse go

4695
03:05:23,680 --> 03:05:26,160
from ones and zeros and go in the format

4696
03:05:26,160 --> 03:05:28,560
that is convenient to humans like this

4697
03:05:28,560 --> 03:05:31,600
22 or this steve name here to make sense

4698
03:05:31,600 --> 03:05:33,920
of how these number systems work let's

4699
03:05:33,920 --> 03:05:36,560
analyze the decimal system that we

4700
03:05:36,560 --> 03:05:38,880
really use in daily life and that is

4701
03:05:38,880 --> 03:05:41,279
usually called base 10. so if you look

4702
03:05:41,279 --> 03:05:43,080
at this

4703
03:05:43,080 --> 03:05:46,479
2371 number here we can really split it

4704
03:05:46,479 --> 03:05:48,720
in the form that you see to the right

4705
03:05:48,720 --> 03:05:51,200
here if you try and take this expression

4706
03:05:51,200 --> 03:05:53,600
we have on the right here and evaluate

4707
03:05:53,600 --> 03:05:55,359
it you're going to get this number here

4708
03:05:55,359 --> 03:05:58,080
2 times 10 to the power of 3 this

4709
03:05:58,080 --> 03:06:01,200
evaluates to 2000 and this one here is

4710
03:06:01,200 --> 03:06:03,760
going to evaluate to 300 this one is

4711
03:06:03,760 --> 03:06:06,560
going to evaluate to 70 and the last one

4712
03:06:06,560 --> 03:06:08,960
is going to evaluate to one and if you

4713
03:06:08,960 --> 03:06:11,200
add these things up you're going to end

4714
03:06:11,200 --> 03:06:12,960
up with this number so this is how we

4715
03:06:12,960 --> 03:06:16,160
can take a number and uh make up a base

4716
03:06:16,160 --> 03:06:18,319
10 representation of it we can do the

4717
03:06:18,319 --> 03:06:22,319
same thing for 924 here or 47 here it

4718
03:06:22,319 --> 03:06:25,120
really is basic math you don't need to

4719
03:06:25,120 --> 03:06:27,520
have a lot of background in math to make

4720
03:06:27,520 --> 03:06:30,080
sense of this so we're going to use this

4721
03:06:30,080 --> 03:06:33,359
exact form and understand binary numbers

4722
03:06:33,359 --> 03:06:35,120
if you look at what we have here we have

4723
03:06:35,120 --> 03:06:37,760
a few binary numbers that are made up of

4724
03:06:37,760 --> 03:06:40,240
ones and zeros that's why it's called

4725
03:06:40,240 --> 03:06:42,479
binary because you can only have two

4726
03:06:42,479 --> 03:06:46,080
states or zero or one in your numbers so

4727
03:06:46,080 --> 03:06:48,960
we can really do the same thing we are

4728
03:06:48,960 --> 03:06:51,760
in base two so instead of using a ten

4729
03:06:51,760 --> 03:06:53,920
here we're going to be using a two but

4730
03:06:53,920 --> 03:06:55,920
it is the same operations we really did

4731
03:06:55,920 --> 03:06:58,640
if you take this and multiply and add

4732
03:06:58,640 --> 03:07:00,479
these things up what you're going to end

4733
03:07:00,479 --> 03:07:03,920
up is a base 10 representation of this

4734
03:07:03,920 --> 03:07:05,840
number if we go in the middle here we

4735
03:07:05,840 --> 03:07:08,240
have something we can easily do without

4736
03:07:08,240 --> 03:07:10,800
using a calculator the expression on the

4737
03:07:10,800 --> 03:07:13,359
left here is going to evaluate to

4738
03:07:13,359 --> 03:07:15,359
zero because we are multiplying with

4739
03:07:15,359 --> 03:07:18,000
zero the second one is going to be a two

4740
03:07:18,000 --> 03:07:20,160
because we are taking one and

4741
03:07:20,160 --> 03:07:22,479
multiplying this by two the others are

4742
03:07:22,479 --> 03:07:24,479
going to be zeros but the last one is

4743
03:07:24,479 --> 03:07:27,920
going to be 2 to the power of 4 which is

4744
03:07:27,920 --> 03:07:30,640
16 and we're going to add a 2 and this

4745
03:07:30,640 --> 03:07:33,760
is going to evaluate to 18. we can

4746
03:07:33,760 --> 03:07:36,160
actually bring up our calculator on

4747
03:07:36,160 --> 03:07:38,800
windows 10 i think it can help in this a

4748
03:07:38,800 --> 03:07:40,720
little bit we're going to bring it up

4749
03:07:40,720 --> 03:07:44,160
and we want to put it in a programmer

4750
03:07:44,160 --> 03:07:46,479
mode and we're going to go back on our

4751
03:07:46,479 --> 03:07:48,880
slide and find our number which is one

4752
03:07:48,880 --> 03:07:51,200
zero zero one zero so we're going to

4753
03:07:51,200 --> 03:07:55,120
type it out one zero zero one zero in

4754
03:07:55,120 --> 03:07:58,080
binary this is binary that we have typed

4755
03:07:58,080 --> 03:08:01,760
here so let's clear this and do one zero

4756
03:08:01,760 --> 03:08:04,399
zero one zero and you're going to see

4757
03:08:04,399 --> 03:08:06,960
that in the decimal it is 18 which is

4758
03:08:06,960 --> 03:08:10,000
what we came up by computing this in our

4759
03:08:10,000 --> 03:08:12,240
brain let's try the one we had before

4760
03:08:12,240 --> 03:08:14,479
that we couldn't really do in our brain

4761
03:08:14,479 --> 03:08:16,399
we're going to say one zero zero one

4762
03:08:16,399 --> 03:08:18,800
zero one let's do that we're going to

4763
03:08:18,800 --> 03:08:22,640
clear one zero zero one zero one this is

4764
03:08:22,640 --> 03:08:26,160
going to evaluate to 37 in decimal and

4765
03:08:26,160 --> 03:08:28,319
you can use calculators like this to

4766
03:08:28,319 --> 03:08:30,479
really do the transformations between

4767
03:08:30,479 --> 03:08:33,200
these different number representations

4768
03:08:33,200 --> 03:08:35,439
okay down below we have a one one one

4769
03:08:35,439 --> 03:08:38,240
which is going to evaluate to a seven in

4770
03:08:38,240 --> 03:08:40,880
base ten okay if we have three digits we

4771
03:08:40,880 --> 03:08:43,120
can really represent numbers between

4772
03:08:43,120 --> 03:08:45,760
zero and seven and you see a table here

4773
03:08:45,760 --> 03:08:48,000
that is going to prove that zero zero

4774
03:08:48,000 --> 03:08:50,000
zero is going to evaluate to zero in

4775
03:08:50,000 --> 03:08:52,399
decimal zero zero one is going to be a

4776
03:08:52,399 --> 03:08:55,279
one and if you go down to one one one

4777
03:08:55,279 --> 03:08:57,920
that is going to evaluate to a seven you

4778
03:08:57,920 --> 03:09:00,240
can try and use a calculator to prove

4779
03:09:00,240 --> 03:09:02,479
this and really understand how this

4780
03:09:02,479 --> 03:09:05,080
works if we use the three digits

4781
03:09:05,080 --> 03:09:07,439
representation our numbers are going to

4782
03:09:07,439 --> 03:09:09,279
look something like this in memory we're

4783
03:09:09,279 --> 03:09:11,520
going to take the bits in memory and

4784
03:09:11,520 --> 03:09:14,399
group them in groups of three and we are

4785
03:09:14,399 --> 03:09:16,240
going to use binary to actually make

4786
03:09:16,240 --> 03:09:18,319
sense of these numbers for example here

4787
03:09:18,319 --> 03:09:20,560
on the left this is going to be a one

4788
03:09:20,560 --> 03:09:22,479
the second one from the left is going to

4789
03:09:22,479 --> 03:09:25,120
be a six and this is going to be a six

4790
03:09:25,120 --> 03:09:27,840
as well this is going to be a zero this

4791
03:09:27,840 --> 03:09:30,640
is going to be a three because we have

4792
03:09:30,640 --> 03:09:33,359
one and two here we add those up we get

4793
03:09:33,359 --> 03:09:35,200
a three if this doesn't make sense you

4794
03:09:35,200 --> 03:09:37,200
can try and use a calculator you're

4795
03:09:37,200 --> 03:09:39,680
going to see that it makes sense okay so

4796
03:09:39,680 --> 03:09:42,800
what if we want to group our digits in

4797
03:09:42,800 --> 03:09:45,200
groups of four we can do that and we're

4798
03:09:45,200 --> 03:09:47,120
going to end up with something like this

4799
03:09:47,120 --> 03:09:49,600
the values we can represent are going to

4800
03:09:49,600 --> 03:09:52,720
go from 0 all the way to 15 and you can

4801
03:09:52,720 --> 03:09:55,760
try and prove this using the calculator

4802
03:09:55,760 --> 03:09:58,319
like we just did and it is going to look

4803
03:09:58,319 --> 03:10:00,319
like this in memory so what we really

4804
03:10:00,319 --> 03:10:03,359
are doing is grouping the bits in

4805
03:10:03,359 --> 03:10:06,640
different sizes of data and we have a

4806
03:10:06,640 --> 03:10:09,120
kind of formula that we can use to make

4807
03:10:09,120 --> 03:10:11,760
sense of the data in memory for example

4808
03:10:11,760 --> 03:10:14,239
on the left here we have zero one one

4809
03:10:14,239 --> 03:10:16,479
zero if we go back to our table and

4810
03:10:16,479 --> 03:10:20,000
defined zero one one zero this is a six

4811
03:10:20,000 --> 03:10:21,840
and we're going to know that these four

4812
03:10:21,840 --> 03:10:24,800
bits here are really storing s6 and

4813
03:10:24,800 --> 03:10:27,120
there are ways you can manipulate this

4814
03:10:27,120 --> 03:10:29,359
in your c plus plus program we're going

4815
03:10:29,359 --> 03:10:31,920
to see that you can also use five digits

4816
03:10:31,920 --> 03:10:33,359
and you're going to end up with

4817
03:10:33,359 --> 03:10:35,439
something like this and the numbers are

4818
03:10:35,439 --> 03:10:38,720
going to go from 0 all the way to 32 and

4819
03:10:38,720 --> 03:10:40,880
this is how it's going to look in memory

4820
03:10:40,880 --> 03:10:43,760
you can try and come up with what this

4821
03:10:43,760 --> 03:10:46,000
represents in decimal i'm not going to

4822
03:10:46,000 --> 03:10:48,319
tell you this but we can try and figure

4823
03:10:48,319 --> 03:10:51,200
out the one on the left here so it is 0

4824
03:10:51,200 --> 03:10:54,800
1 1 0 1. if we go back we're going to

4825
03:10:54,800 --> 03:10:59,439
come up to 0 1 1 0 1 which is a 13 here

4826
03:10:59,439 --> 03:11:02,800
so this memory location these five bits

4827
03:11:02,800 --> 03:11:06,080
represent a 17 number so if we want to

4828
03:11:06,080 --> 03:11:08,880
kind of generalize what we have talked

4829
03:11:08,880 --> 03:11:11,760
about in the last slides if you have one

4830
03:11:11,760 --> 03:11:14,000
digit you can really represent two

4831
03:11:14,000 --> 03:11:16,399
states zero and one if you have three

4832
03:11:16,399 --> 03:11:18,479
digits you can represent numbers between

4833
03:11:18,479 --> 03:11:20,640
zero and seven and you can go all the

4834
03:11:20,640 --> 03:11:24,080
way down and if we generalize this in a

4835
03:11:24,080 --> 03:11:27,040
mathematical formula we can say that if

4836
03:11:27,040 --> 03:11:29,120
we have n digits we're going to be able

4837
03:11:29,120 --> 03:11:31,760
to represent between 0 and 2 to the

4838
03:11:31,760 --> 03:11:34,720
power of n minus 1. and if you try to

4839
03:11:34,720 --> 03:11:36,880
plug in any number of digits you're

4840
03:11:36,880 --> 03:11:39,200
going to see that this formula works

4841
03:11:39,200 --> 03:11:43,279
okay so these are a few grouping of bits

4842
03:11:43,279 --> 03:11:45,680
we have in practice we can use eight

4843
03:11:45,680 --> 03:11:47,840
digits and we can represent numbers

4844
03:11:47,840 --> 03:11:51,359
between zero and two 255 if we have 16

4845
03:11:51,359 --> 03:11:54,160
bits we can represent this range if we

4846
03:11:54,160 --> 03:11:56,000
have 32 bits we can

4847
03:11:56,000 --> 03:11:59,520
represent this range if we have 64 bets

4848
03:11:59,520 --> 03:12:02,319
we can really represent a really huge

4849
03:12:02,319 --> 03:12:04,800
range i can't even say this number it's

4850
03:12:04,800 --> 03:12:06,720
really bad okay now you should have a

4851
03:12:06,720 --> 03:12:09,600
pretty good idea of the binary system

4852
03:12:09,600 --> 03:12:12,720
and different representations we can use

4853
03:12:12,720 --> 03:12:16,080
to make sense of binary numbers in a

4854
03:12:16,080 --> 03:12:18,160
computer's memory the last thing i want

4855
03:12:18,160 --> 03:12:21,439
you to see is what we call hexadecimal

4856
03:12:21,439 --> 03:12:24,399
number system and it is a technique we

4857
03:12:24,399 --> 03:12:27,439
use to shorten the length of how we

4858
03:12:27,439 --> 03:12:30,239
represent a binary number in memory how

4859
03:12:30,239 --> 03:12:32,960
does it work well we take our number and

4860
03:12:32,960 --> 03:12:36,399
split it in groups of four bets and each

4861
03:12:36,399 --> 03:12:38,880
group is assigned a symbol we can use to

4862
03:12:38,880 --> 03:12:41,200
represent it if we have four zeros

4863
03:12:41,200 --> 03:12:43,120
that's going to mean a zero in

4864
03:12:43,120 --> 03:12:46,000
hexadecimal if we have zero zero zero

4865
03:12:46,000 --> 03:12:48,560
one we're going to represent a one and

4866
03:12:48,560 --> 03:12:51,279
you can see that if we go up to nine

4867
03:12:51,279 --> 03:12:53,920
this is really similar to what we have

4868
03:12:53,920 --> 03:12:56,160
in the decimal number system but once we

4869
03:12:56,160 --> 03:12:58,160
hit 10 we're going to represent that

4870
03:12:58,160 --> 03:13:00,960
with an a in hexadecimal 11 is going to

4871
03:13:00,960 --> 03:13:04,000
be b 12 is going to be c 13 is going to

4872
03:13:04,000 --> 03:13:07,040
be d 14 is going to be e and 15 is going

4873
03:13:07,040 --> 03:13:09,040
to be f so how do we use this to

4874
03:13:09,040 --> 03:13:11,680
represent binary numbers let's see an

4875
03:13:11,680 --> 03:13:14,080
example here we have a huge number that

4876
03:13:14,080 --> 03:13:16,160
we represent in memory it starts with

4877
03:13:16,160 --> 03:13:18,560
zero and ends with the one here so the

4878
03:13:18,560 --> 03:13:20,160
first thing we're going to do is to

4879
03:13:20,160 --> 03:13:23,279
split this in groups of four and the one

4880
03:13:23,279 --> 03:13:25,760
on the left is going to be a one one one

4881
03:13:25,760 --> 03:13:28,000
one if we come back to our table here

4882
03:13:28,000 --> 03:13:30,479
one one one one means f so we're going

4883
03:13:30,479 --> 03:13:32,880
to represent this with an f if you go to

4884
03:13:32,880 --> 03:13:35,840
the second group of four bets we have

4885
03:13:35,840 --> 03:13:39,040
zero zero one one if we go back zero

4886
03:13:39,040 --> 03:13:42,000
zero one one means three so we're going

4887
03:13:42,000 --> 03:13:44,319
to have a three here i hope this makes

4888
03:13:44,319 --> 03:13:46,319
sense and we're going to keep using the

4889
03:13:46,319 --> 03:13:48,399
same transformations and we're going to

4890
03:13:48,399 --> 03:13:52,319
come up with one f 0 3 e 6 and we can

4891
03:13:52,319 --> 03:13:55,520
represent this binary number using these

4892
03:13:55,520 --> 03:13:57,520
symbols you can see that we go from

4893
03:13:57,520 --> 03:14:01,359
using 32 bits to using one two three

4894
03:14:01,359 --> 03:14:03,920
four five six seven eight symbols to

4895
03:14:03,920 --> 03:14:06,239
represent this and this is shorter and

4896
03:14:06,239 --> 03:14:09,200
easily manipulable by humans and we use

4897
03:14:09,200 --> 03:14:13,040
a zero x in front to mean that this is a

4898
03:14:13,040 --> 03:14:15,120
hexadecimal number i really hope this

4899
03:14:15,120 --> 03:14:18,160
makes sense so if we have numbers that

4900
03:14:18,160 --> 03:14:20,880
don't really fit in groups of four we're

4901
03:14:20,880 --> 03:14:23,200
going to go from the left and split this

4902
03:14:23,200 --> 03:14:25,439
in groups of four and we're going to end

4903
03:14:25,439 --> 03:14:28,640
up with a group on the left that doesn't

4904
03:14:28,640 --> 03:14:30,960
really meet our requirements and what we

4905
03:14:30,960 --> 03:14:34,160
can do is add the missing bits and make

4906
03:14:34,160 --> 03:14:36,479
them zeros and we call this operation

4907
03:14:36,479 --> 03:14:38,640
padding this is what you can do to

4908
03:14:38,640 --> 03:14:40,560
really represent any number in

4909
03:14:40,560 --> 03:14:42,960
hexadecimal if you don't have enough

4910
03:14:42,960 --> 03:14:45,279
bits on the left we also have another

4911
03:14:45,279 --> 03:14:47,840
system that is really not widely used

4912
03:14:47,840 --> 03:14:51,040
today but i am mentioning it here for

4913
03:14:51,040 --> 03:14:53,680
completeness it is called octal system

4914
03:14:53,680 --> 03:14:56,000
it goes from zero all the way to seven

4915
03:14:56,000 --> 03:14:59,439
and we can divide our binary number into

4916
03:14:59,439 --> 03:15:02,399
groups of three and represent using

4917
03:15:02,399 --> 03:15:04,640
these zeros and ones to shorten the

4918
03:15:04,640 --> 03:15:06,319
length of the binary number we can

4919
03:15:06,319 --> 03:15:07,920
really do the same thing we did with

4920
03:15:07,920 --> 03:15:10,319
hexadecimal so we're going to take our

4921
03:15:10,319 --> 03:15:13,200
binary number and divide this in groups

4922
03:15:13,200 --> 03:15:15,439
of three the one on the left is going to

4923
03:15:15,439 --> 03:15:19,120
evaluate to a 7 because it's 1 1 1 and

4924
03:15:19,120 --> 03:15:22,080
one one one evaluates to seven in octal

4925
03:15:22,080 --> 03:15:23,920
system the second one is also going to

4926
03:15:23,920 --> 03:15:26,239
be a one one one the third one is going

4927
03:15:26,239 --> 03:15:29,279
to be one zero zero if we go in our

4928
03:15:29,279 --> 03:15:31,680
table it's going to be one zero zero

4929
03:15:31,680 --> 03:15:33,439
it's going to be a four and you see we

4930
03:15:33,439 --> 03:15:35,680
have a 4 here and you can do the same

4931
03:15:35,680 --> 03:15:37,840
things until you have figured out the

4932
03:15:37,840 --> 03:15:39,760
entire number here and you see on the

4933
03:15:39,760 --> 03:15:42,239
left we are doing padding and adding a

4934
03:15:42,239 --> 03:15:44,880
missing bit and making it to 0 so we are

4935
03:15:44,880 --> 03:15:48,080
coming up with 0 0 1 and if we go back

4936
03:15:48,080 --> 03:15:51,520
to our table here 0 0 1 is a 1 and

4937
03:15:51,520 --> 03:15:53,120
that's what we put here so we're going

4938
03:15:53,120 --> 03:15:55,120
to put this number here it's going to be

4939
03:15:55,120 --> 03:15:59,680
15 61 41 70 47 7 and we're going to add

4940
03:15:59,680 --> 03:16:03,040
a zero in front to mean that this is a

4941
03:16:03,040 --> 03:16:05,760
number represented in the octal system i

4942
03:16:05,760 --> 03:16:07,920
really hope this makes sense okay so we

4943
03:16:07,920 --> 03:16:10,560
have seen all these binary numbers and

4944
03:16:10,560 --> 03:16:12,800
different number systems we can use to

4945
03:16:12,800 --> 03:16:15,840
represent them but how do we use them in

4946
03:16:15,840 --> 03:16:18,479
a c plus plus program well i'm glad you

4947
03:16:18,479 --> 03:16:20,560
asked here is a simple example of how

4948
03:16:20,560 --> 03:16:23,520
you can represent the number 15 through

4949
03:16:23,520 --> 03:16:26,560
different number systems in c plus plus

4950
03:16:26,560 --> 03:16:28,640
if you just say 15 like this it's going

4951
03:16:28,640 --> 03:16:31,600
to be in decimal if you add a zero in

4952
03:16:31,600 --> 03:16:34,399
front it's going to mean that the number

4953
03:16:34,399 --> 03:16:37,040
is in octal system so this can be

4954
03:16:37,040 --> 03:16:40,160
confusing sometimes if you do 0 17 it's

4955
03:16:40,160 --> 03:16:43,439
not going to be 17. so if you say 0 17 c

4956
03:16:43,439 --> 03:16:45,520
plus plus is going to interpret this

4957
03:16:45,520 --> 03:16:48,239
number as if it is in octal system and

4958
03:16:48,239 --> 03:16:50,800
it is going to turn this into 15. down

4959
03:16:50,800 --> 03:16:53,520
here you see the same representation in

4960
03:16:53,520 --> 03:16:56,319
hexadecimal we saw that you use a 0x in

4961
03:16:56,319 --> 03:16:58,319
front to represent that it is in

4962
03:16:58,319 --> 03:17:01,439
hexadecimal and this is going to be 15

4963
03:17:01,439 --> 03:17:03,040
in memory and here we have

4964
03:17:03,040 --> 03:17:06,319
representation in binary using zeros and

4965
03:17:06,319 --> 03:17:09,040
ones and you use zero b in front like

4966
03:17:09,040 --> 03:17:11,040
this i have to say that this was only

4967
03:17:11,040 --> 03:17:14,239
possible since c plus plus 14. so if you

4968
03:17:14,239 --> 03:17:17,120
are using an older standard of c plus

4969
03:17:17,120 --> 03:17:18,880
plus you want to be able to represent

4970
03:17:18,880 --> 03:17:21,040
binary like this and if we run this

4971
03:17:21,040 --> 03:17:22,960
program it is going to print the same

4972
03:17:22,960 --> 03:17:25,279
thing it is going to print 15 but we

4973
03:17:25,279 --> 03:17:27,680
stored the number using different number

4974
03:17:27,680 --> 03:17:30,000
systems let's go to visual studio code

4975
03:17:30,000 --> 03:17:32,880
and try this out okay here we are in a

4976
03:17:32,880 --> 03:17:35,200
folder i have on my system where i am

4977
03:17:35,200 --> 03:17:37,359
going to be storing my projects for this

4978
03:17:37,359 --> 03:17:39,520
chapter the first thing i am going to do

4979
03:17:39,520 --> 03:17:42,800
is copy code from a template project i

4980
03:17:42,800 --> 03:17:45,359
am going to go in and copy things over

4981
03:17:45,359 --> 03:17:48,640
and i am going to put these in 4 2

4982
03:17:48,640 --> 03:17:51,040
number systems i am going to open this

4983
03:17:51,040 --> 03:17:53,279
folder in visual studio code so i am

4984
03:17:53,279 --> 03:17:55,920
going to go to file close the folder we

4985
03:17:55,920 --> 03:17:58,239
have now and i am going to open up a new

4986
03:17:58,239 --> 03:18:01,040
one open folder and i am going to browse

4987
03:18:01,040 --> 03:18:03,680
to the location of my project i am going

4988
03:18:03,680 --> 03:18:05,920
to open this project here that says

4989
03:18:05,920 --> 03:18:08,319
number systems we are going to get rid

4990
03:18:08,319 --> 03:18:11,040
of the welcome screen and open our main

4991
03:18:11,040 --> 03:18:13,359
cpp file we're going to get rid of this

4992
03:18:13,359 --> 03:18:16,239
constival thing and clear everything we

4993
03:18:16,239 --> 03:18:19,279
have in the main function here the first

4994
03:18:19,279 --> 03:18:21,439
thing we want to do is to store an

4995
03:18:21,439 --> 03:18:23,680
integer that is 15 and we're going to

4996
03:18:23,680 --> 03:18:26,479
say and number one the exact same thing

4997
03:18:26,479 --> 03:18:28,239
we had in the slides and we're going to

4998
03:18:28,239 --> 03:18:31,040
store 15 in this variable here this is

4999
03:18:31,040 --> 03:18:33,680
going to be represented in decimal and

5000
03:18:33,680 --> 03:18:36,319
if we want to store the semi number in

5001
03:18:36,319 --> 03:18:39,840
octo we saw that in our slides we could

5002
03:18:39,840 --> 03:18:42,960
store this as 0 17. so let's do that

5003
03:18:42,960 --> 03:18:45,520
we're going to say it number 2 and we're

5004
03:18:45,520 --> 03:18:48,960
going to store in 0 17. this is not

5005
03:18:48,960 --> 03:18:51,279
going to be 17 this is going to be a

5006
03:18:51,279 --> 03:18:54,239
representation of a number in octo

5007
03:18:54,239 --> 03:18:56,239
system so we're going to say that this

5008
03:18:56,239 --> 03:18:58,880
is octo and we can represent the number

5009
03:18:58,880 --> 03:19:01,600
in hexadecimal as well so we're going to

5010
03:19:01,600 --> 03:19:04,399
say it number three and it is going to

5011
03:19:04,399 --> 03:19:05,120
be

5012
03:19:05,120 --> 03:19:08,160
0x because it is hexadecimal and we're

5013
03:19:08,160 --> 03:19:10,640
going to say zero f this is how we

5014
03:19:10,640 --> 03:19:12,880
represent it you can use lowercase or

5015
03:19:12,880 --> 03:19:15,040
uppercase it won't really matter let's

5016
03:19:15,040 --> 03:19:17,520
use uppercase here and we can use binary

5017
03:19:17,520 --> 03:19:19,760
because we are using c plus plus 20. so

5018
03:19:19,760 --> 03:19:22,000
we're going to say and number four and

5019
03:19:22,000 --> 03:19:24,399
we're going to store in a representation

5020
03:19:24,399 --> 03:19:28,160
of 15 in binary and it happens to be

5021
03:19:28,160 --> 03:19:31,840
four zeros and four ones and we have to

5022
03:19:31,840 --> 03:19:35,279
prefix this with a zero b this is how it

5023
03:19:35,279 --> 03:19:37,840
works so this is going to be in binary

5024
03:19:37,840 --> 03:19:40,239
and if we print all these numbers up

5025
03:19:40,239 --> 03:19:42,640
we're going to see let me not tell you

5026
03:19:42,640 --> 03:19:44,800
this what do you think we'll see okay so

5027
03:19:44,800 --> 03:19:47,920
i went ahead and typed this out what do

5028
03:19:47,920 --> 03:19:50,399
you think we will see when we build and

5029
03:19:50,399 --> 03:19:52,399
run this program before we do that we're

5030
03:19:52,399 --> 03:19:54,640
going to open a terminal so that we see

5031
03:19:54,640 --> 03:19:56,399
it here and we're going to go to

5032
03:19:56,399 --> 03:19:58,640
terminal run task we're going to build

5033
03:19:58,640 --> 03:20:01,439
with gcc let's wait and see if the world

5034
03:20:01,439 --> 03:20:03,600
is successful world finished

5035
03:20:03,600 --> 03:20:05,840
successfully we have a rooster program

5036
03:20:05,840 --> 03:20:07,520
in here we're going to

5037
03:20:07,520 --> 03:20:10,239
click somewhere in this terminal and our

5038
03:20:10,239 --> 03:20:12,080
terminal is going to show up if we do

5039
03:20:12,080 --> 03:20:14,080
dur you're going to see that our rooster

5040
03:20:14,080 --> 03:20:16,560
program is here and if we run it i want

5041
03:20:16,560 --> 03:20:18,319
you to take a moment and guess what

5042
03:20:18,319 --> 03:20:21,120
we're going to see hmm number one 15

5043
03:20:21,120 --> 03:20:24,160
number 215 in number 315 and number four

5044
03:20:24,160 --> 03:20:26,560
15. this is really the same number we

5045
03:20:26,560 --> 03:20:28,800
are storing in these variables but we

5046
03:20:28,800 --> 03:20:31,680
are using a different representation

5047
03:20:31,680 --> 03:20:33,840
that is going to be convenient depending

5048
03:20:33,840 --> 03:20:36,160
on whatever it is we are doing if it is

5049
03:20:36,160 --> 03:20:37,920
more convenient to use binary we are

5050
03:20:37,920 --> 03:20:39,920
going to use binary if it is more

5051
03:20:39,920 --> 03:20:42,560
convenient use hexadecimal please do use

5052
03:20:42,560 --> 03:20:45,359
hexadecimal but the representation of

5053
03:20:45,359 --> 03:20:48,319
this number in memory is really going to

5054
03:20:48,319 --> 03:20:50,080
be the same i really want you to take

5055
03:20:50,080 --> 03:20:52,560
some time and let this sink in because

5056
03:20:52,560 --> 03:20:54,399
you're going to see these things a lot

5057
03:20:54,399 --> 03:20:57,279
of times in your career as a software

5058
03:20:57,279 --> 03:21:00,160
developer so please do yourself a favor

5059
03:21:00,160 --> 03:21:02,319
and make sure you really understand this

5060
03:21:02,319 --> 03:21:04,160
okay this is really all we set up to do

5061
03:21:04,160 --> 03:21:06,239
in this lecture trying to make sense of

5062
03:21:06,239 --> 03:21:08,720
the binary numbers we have in memory and

5063
03:21:08,720 --> 03:21:10,960
how we transform between them and

5064
03:21:10,960 --> 03:21:13,840
different forms of data that is easily

5065
03:21:13,840 --> 03:21:16,560
manipulable by humans all data is

5066
03:21:16,560 --> 03:21:18,880
represented by a bunch of grouped cells

5067
03:21:18,880 --> 03:21:21,359
of zeros and ones we have seen this as

5068
03:21:21,359 --> 03:21:23,439
the range of your data grows so will be

5069
03:21:23,439 --> 03:21:25,040
the number of digits you need to

5070
03:21:25,040 --> 03:21:27,040
represent the data in memory we have

5071
03:21:27,040 --> 03:21:29,520
seen that the hexadecimal system makes

5072
03:21:29,520 --> 03:21:31,760
it a little easier for humans to handle

5073
03:21:31,760 --> 03:21:34,239
streams of data in ones and zeros octo

5074
03:21:34,239 --> 03:21:36,800
has the same goal as hexadecimal but

5075
03:21:36,800 --> 03:21:39,200
it's almost no longer used in modern

5076
03:21:39,200 --> 03:21:41,760
times i just mentioned it here for

5077
03:21:41,760 --> 03:21:44,000
completeness we are going to stop here

5078
03:21:44,000 --> 03:21:46,080
in this lecture in the next one we're

5079
03:21:46,080 --> 03:21:48,160
going to look at integers in a little

5080
03:21:48,160 --> 03:21:50,560
more detail so go ahead and finish up

5081
03:21:50,560 --> 03:21:53,200
here and meet me there in this lecture

5082
03:21:53,200 --> 03:21:55,200
we're going to learn a little more about

5083
03:21:55,200 --> 03:21:58,080
integers in c plus plus integers are

5084
03:21:58,080 --> 03:22:00,960
represented by ant and z plus plus it's

5085
03:22:00,960 --> 03:22:03,600
what you see on the left here and they

5086
03:22:03,600 --> 03:22:06,239
are used to store whole numbers things

5087
03:22:06,239 --> 03:22:09,680
like 1 2 and 3. they typically occupy 4

5088
03:22:09,680 --> 03:22:12,319
bytes or more in memory but in most

5089
03:22:12,319 --> 03:22:14,800
times it's going to be 4 bytes so for

5090
03:22:14,800 --> 03:22:17,040
example if you have a variable called

5091
03:22:17,040 --> 03:22:19,680
age and it is an integer this is how

5092
03:22:19,680 --> 03:22:21,439
it's most probably going to look in

5093
03:22:21,439 --> 03:22:23,680
memory it's going to take four bytes and

5094
03:22:23,680 --> 03:22:25,840
i really want to make it clear what a

5095
03:22:25,840 --> 03:22:28,560
variable is it is a named piece of

5096
03:22:28,560 --> 03:22:31,359
memory that you use to store specific

5097
03:22:31,359 --> 03:22:34,319
types of data okay so here if we have a

5098
03:22:34,319 --> 03:22:37,520
variable named age it is a named piece

5099
03:22:37,520 --> 03:22:39,840
of memory edge is going to be the name

5100
03:22:39,840 --> 03:22:42,399
of that piece of memory and we can store

5101
03:22:42,399 --> 03:22:44,560
data in that memory it's going to look

5102
03:22:44,560 --> 03:22:46,560
like this in memory but the value is

5103
03:22:46,560 --> 03:22:48,880
going to be stored in here in binary

5104
03:22:48,880 --> 03:22:51,040
format i really hope this makes sense a

5105
03:22:51,040 --> 03:22:54,080
variable is a named piece of memory that

5106
03:22:54,080 --> 03:22:56,399
we can use to store different kinds of

5107
03:22:56,399 --> 03:22:58,479
data and okay now we're going to look at

5108
03:22:58,479 --> 03:23:01,200
a few examples of how you can work with

5109
03:23:01,200 --> 03:23:04,319
integers in your c plus program you can

5110
03:23:04,319 --> 03:23:07,040
define a few variables here we have one

5111
03:23:07,040 --> 03:23:09,120
that is going to store the number of

5112
03:23:09,120 --> 03:23:11,840
elephants we have you can declare it

5113
03:23:11,840 --> 03:23:14,960
like this and not put in a value and if

5114
03:23:14,960 --> 03:23:17,279
you do it like this the compiler is just

5115
03:23:17,279 --> 03:23:19,760
going to put in some garbage value that

5116
03:23:19,760 --> 03:23:21,920
is really not meaningful for your

5117
03:23:21,920 --> 03:23:24,800
program so you see the warning we have

5118
03:23:24,800 --> 03:23:27,040
here as a comment the variable may

5119
03:23:27,040 --> 03:23:29,600
contain random garbage value and this is

5120
03:23:29,600 --> 03:23:31,359
something you need to be aware of

5121
03:23:31,359 --> 03:23:33,760
another way we can define integers in

5122
03:23:33,760 --> 03:23:36,160
our c plus plus program is this

5123
03:23:36,160 --> 03:23:38,720
statement here that declares a variable

5124
03:23:38,720 --> 03:23:40,479
called lion count it's going to

5125
03:23:40,479 --> 03:23:43,120
initialize to zero if we use curly

5126
03:23:43,120 --> 03:23:44,800
braces like this it's going to

5127
03:23:44,800 --> 03:23:47,200
initialize to 0 by default we can also

5128
03:23:47,200 --> 03:23:49,680
explicitly put in a value we can do the

5129
03:23:49,680 --> 03:23:52,560
same with cat count and we can use these

5130
03:23:52,560 --> 03:23:55,520
variables to do operations for example

5131
03:23:55,520 --> 03:23:57,760
we can declare another variable and it

5132
03:23:57,760 --> 03:24:00,080
is going to store the number of

5133
03:24:00,080 --> 03:24:02,399
domesticated animals and we're going to

5134
03:24:02,399 --> 03:24:05,680
add up the numbers for dogs and cats and

5135
03:24:05,680 --> 03:24:07,760
we're going to store the result of that

5136
03:24:07,760 --> 03:24:09,920
in our variable that is called

5137
03:24:09,920 --> 03:24:11,760
domesticated animals this is something

5138
03:24:11,760 --> 03:24:14,000
you can do another thing that can be

5139
03:24:14,000 --> 03:24:16,800
problematic is trying to use variables

5140
03:24:16,800 --> 03:24:19,680
that you haven't defined or declared in

5141
03:24:19,680 --> 03:24:21,600
your program that is going to give you a

5142
03:24:21,600 --> 03:24:23,520
compiler error and the compiler is

5143
03:24:23,520 --> 03:24:25,439
basically going to say i don't know what

5144
03:24:25,439 --> 03:24:27,680
doesn't exist one here is i don't know

5145
03:24:27,680 --> 03:24:30,399
what this doesn't exist to is it is not

5146
03:24:30,399 --> 03:24:33,040
defined anywhere in the program another

5147
03:24:33,040 --> 03:24:36,560
thing you can do is try and store a

5148
03:24:36,560 --> 03:24:39,120
fractional number in a variable that you

5149
03:24:39,120 --> 03:24:41,279
declared as an integer and this is going

5150
03:24:41,279 --> 03:24:43,840
to give you a warning because fractional

5151
03:24:43,840 --> 03:24:47,359
numbers are usually bigger in size than

5152
03:24:47,359 --> 03:24:49,760
integers and this is going to lose some

5153
03:24:49,760 --> 03:24:51,840
of your data we don't really have enough

5154
03:24:51,840 --> 03:24:54,080
tools to understand this now but we are

5155
03:24:54,080 --> 03:24:55,520
going to understand this a little bit

5156
03:24:55,520 --> 03:24:57,040
later in the course but this is

5157
03:24:57,040 --> 03:24:58,880
something you can do you can take a

5158
03:24:58,880 --> 03:25:01,600
fractional number and store that in an

5159
03:25:01,600 --> 03:25:03,840
integer variable and we're going to do

5160
03:25:03,840 --> 03:25:06,720
an example and see how this behaves with

5161
03:25:06,720 --> 03:25:10,000
our compiler that is gcc10 okay here we

5162
03:25:10,000 --> 03:25:12,960
have mostly used curly braces to

5163
03:25:12,960 --> 03:25:15,520
initialize our variables but we can also

5164
03:25:15,520 --> 03:25:18,080
use parenthesis and this is going to be

5165
03:25:18,080 --> 03:25:20,239
usually referred to

5166
03:25:20,239 --> 03:25:23,279
as functional variable initialization

5167
03:25:23,279 --> 03:25:25,279
because we are using parenthesis and

5168
03:25:25,279 --> 03:25:26,880
this is mostly going to do the same

5169
03:25:26,880 --> 03:25:29,520
thing we saw in the last slide with

5170
03:25:29,520 --> 03:25:33,040
curly braces but when we come to the

5171
03:25:33,040 --> 03:25:35,200
example here where we are storing a

5172
03:25:35,200 --> 03:25:38,000
fractional number this is going to

5173
03:25:38,000 --> 03:25:41,040
silently chop off the data you have in a

5174
03:25:41,040 --> 03:25:43,680
fractional number and turn that into an

5175
03:25:43,680 --> 03:25:45,680
integer and this is called implicit

5176
03:25:45,680 --> 03:25:47,680
conversions but if we go to the last

5177
03:25:47,680 --> 03:25:50,640
example here where we are storing 2.9

5178
03:25:50,640 --> 03:25:52,640
into an integer this is going to take

5179
03:25:52,640 --> 03:25:54,800
this fractional number chop off the

5180
03:25:54,800 --> 03:25:57,680
decimal point and only store 2 in this

5181
03:25:57,680 --> 03:25:59,520
integer and this might not be what you

5182
03:25:59,520 --> 03:26:02,080
want and it is going to happen silently

5183
03:26:02,080 --> 03:26:04,479
so this is a really bad way to do this

5184
03:26:04,479 --> 03:26:06,560
if you want to do something like this it

5185
03:26:06,560 --> 03:26:09,840
is preferable to use curly braces

5186
03:26:09,840 --> 03:26:12,160
because you are either going to get a

5187
03:26:12,160 --> 03:26:14,080
warning that this is going to lose you

5188
03:26:14,080 --> 03:26:16,319
data or you're going to get a compiler

5189
03:26:16,319 --> 03:26:18,080
error and the compiler is going to

5190
03:26:18,080 --> 03:26:20,479
completely stop you from doing this and

5191
03:26:20,479 --> 03:26:22,960
again if any of this doesn't make any

5192
03:26:22,960 --> 03:26:25,200
sense we're going to go in visual studio

5193
03:26:25,200 --> 03:26:27,279
code play with us and see how the

5194
03:26:27,279 --> 03:26:29,840
compiler behaves with these things we

5195
03:26:29,840 --> 03:26:32,479
have another way we can initialize our

5196
03:26:32,479 --> 03:26:34,640
variables in surplus plus we can use

5197
03:26:34,640 --> 03:26:36,960
assignment and we have done this a

5198
03:26:36,960 --> 03:26:39,840
couple of times in the course but this

5199
03:26:39,840 --> 03:26:41,680
is something you can do and we are going

5200
03:26:41,680 --> 03:26:44,160
to play with this in visual studio code

5201
03:26:44,160 --> 03:26:45,920
in a minute and you're going to see how

5202
03:26:45,920 --> 03:26:48,479
it works okay by now we have seen three

5203
03:26:48,479 --> 03:26:50,800
ways we can initialize our integer

5204
03:26:50,800 --> 03:26:53,040
variables we can use breast

5205
03:26:53,040 --> 03:26:55,439
initialization which is basically using

5206
03:26:55,439 --> 03:26:58,000
curly braces we can use functional

5207
03:26:58,000 --> 03:27:01,279
notation which is using the parenthesis

5208
03:27:01,279 --> 03:27:03,200
and we can use the assignment

5209
03:27:03,200 --> 03:27:05,520
initialization which is what we have

5210
03:27:05,520 --> 03:27:07,600
here another thing i really want you to

5211
03:27:07,600 --> 03:27:09,920
see is that it is possible

5212
03:27:09,920 --> 03:27:13,279
to query for the size of your variable

5213
03:27:13,279 --> 03:27:16,160
here we are trying to print the size an

5214
03:27:16,160 --> 03:27:17,920
integer is going to take on our

5215
03:27:17,920 --> 03:27:20,319
operating system and compiler and if we

5216
03:27:20,319 --> 03:27:22,800
try to run this on our compiler it's

5217
03:27:22,800 --> 03:27:25,120
going to tell us exactly how much memory

5218
03:27:25,120 --> 03:27:28,720
an integer occupies in our program we

5219
03:27:28,720 --> 03:27:31,840
can either pass and explicitly like this

5220
03:27:31,840 --> 03:27:34,000
or we can pass a variable name and it is

5221
03:27:34,000 --> 03:27:36,560
going to work equally well okay ants are

5222
03:27:36,560 --> 03:27:38,560
mostly going to take up four bytes in

5223
03:27:38,560 --> 03:27:40,600
new memory so here we have a

5224
03:27:40,600 --> 03:27:43,680
representation of three ants in memory

5225
03:27:43,680 --> 03:27:45,760
if we go from this zero to this zero

5226
03:27:45,760 --> 03:27:48,000
this is going to be exactly four bytes

5227
03:27:48,000 --> 03:27:50,479
and this is how it may look in memory

5228
03:27:50,479 --> 03:27:52,479
one other thing i haven't really talked

5229
03:27:52,479 --> 03:27:55,359
about on purpose is that there are a few

5230
03:27:55,359 --> 03:27:57,920
rules you have to follow to name your

5231
03:27:57,920 --> 03:28:00,479
variables in c plus plus one of those

5232
03:28:00,479 --> 03:28:03,359
rules is that a variable must start with

5233
03:28:03,359 --> 03:28:06,800
a letter like a b c d up to z or an

5234
03:28:06,800 --> 03:28:08,880
underscore you can't start a variable

5235
03:28:08,880 --> 03:28:10,720
for example with a number that's going

5236
03:28:10,720 --> 03:28:13,120
to be a problem after the first

5237
03:28:13,120 --> 03:28:15,760
character in your variable name you can

5238
03:28:15,760 --> 03:28:17,840
really put in anything you can put in

5239
03:28:17,840 --> 03:28:20,239
numbers you can put in letters you can

5240
03:28:20,239 --> 03:28:22,080
really put anything you want but the

5241
03:28:22,080 --> 03:28:24,479
first one can't be a number variable

5242
03:28:24,479 --> 03:28:27,600
names are also case sensitive so if you

5243
03:28:27,600 --> 03:28:30,160
have a variable called bike account with

5244
03:28:30,160 --> 03:28:31,920
the lowercase b

5245
03:28:31,920 --> 03:28:34,080
and you have another one that starts

5246
03:28:34,080 --> 03:28:36,479
with uppercase b

5247
03:28:36,479 --> 03:28:38,080
these are going to be two different

5248
03:28:38,080 --> 03:28:40,640
variables and uh you have to be aware of

5249
03:28:40,640 --> 03:28:44,000
this no spaces or spatial characters are

5250
03:28:44,000 --> 03:28:46,560
allowed in your variables you can use

5251
03:28:46,560 --> 03:28:48,800
underscores but you can't use something

5252
03:28:48,800 --> 03:28:50,640
like plus because that's going to be

5253
03:28:50,640 --> 03:28:52,960
confusing to your compiler and these are

5254
03:28:52,960 --> 03:28:54,960
a few rules you really need to be aware

5255
03:28:54,960 --> 03:28:57,279
of and you're mostly going to be fine

5256
03:28:57,279 --> 03:29:00,000
the general form for declaring and

5257
03:29:00,000 --> 03:29:02,720
initializing your variable is what you

5258
03:29:02,720 --> 03:29:04,960
see here you're going to pass the type

5259
03:29:04,960 --> 03:29:07,359
in this case we have used and because we

5260
03:29:07,359 --> 03:29:09,680
are learning about ants you're going to

5261
03:29:09,680 --> 03:29:11,600
pass the variable name and you're going

5262
03:29:11,600 --> 03:29:13,359
to put whatever it is you are

5263
03:29:13,359 --> 03:29:15,760
initializing your variable with of

5264
03:29:15,760 --> 03:29:18,080
course this is braced initialization

5265
03:29:18,080 --> 03:29:21,439
because it is using curly braces but you

5266
03:29:21,439 --> 03:29:23,920
can also use functional initialization

5267
03:29:23,920 --> 03:29:26,640
or assignment initialization and it is

5268
03:29:26,640 --> 03:29:28,560
going to work equally well okay now we

5269
03:29:28,560 --> 03:29:31,040
have enough information to go in visual

5270
03:29:31,040 --> 03:29:34,479
studio code and play with us okay here i

5271
03:29:34,479 --> 03:29:37,520
am in my folder for the projects of this

5272
03:29:37,520 --> 03:29:40,239
chapter i am going to hop over in my

5273
03:29:40,239 --> 03:29:43,359
template project and copy the files that

5274
03:29:43,359 --> 03:29:46,080
i need i am going to go up again

5275
03:29:46,080 --> 03:29:48,960
and go on the project that is called

5276
03:29:48,960 --> 03:29:50,479
integer types

5277
03:29:50,479 --> 03:29:52,720
i am going to go in and paste in my

5278
03:29:52,720 --> 03:29:55,279
files and i am going to open up this

5279
03:29:55,279 --> 03:29:58,080
folder in visual studio code i am going

5280
03:29:58,080 --> 03:30:00,160
to close the welcome screen here and

5281
03:30:00,160 --> 03:30:02,399
open my main cpp file

5282
03:30:02,399 --> 03:30:05,040
and i am going to do the usual take out

5283
03:30:05,040 --> 03:30:07,920
the things we don't need to save on time

5284
03:30:07,920 --> 03:30:10,160
i am going to put in a piece of code

5285
03:30:10,160 --> 03:30:13,520
that i have lying on my drive and we're

5286
03:30:13,520 --> 03:30:14,640
going to

5287
03:30:14,640 --> 03:30:17,200
go through it to save on typing time i

5288
03:30:17,200 --> 03:30:19,200
don't want you to suffer watching me

5289
03:30:19,200 --> 03:30:21,439
type this the first thing we have is the

5290
03:30:21,439 --> 03:30:23,439
elephant count this is a variable that

5291
03:30:23,439 --> 03:30:25,840
is not initialized so this is going to

5292
03:30:25,840 --> 03:30:28,399
contain garbage data it's not going to

5293
03:30:28,399 --> 03:30:30,800
contain anything that is useful to us

5294
03:30:30,800 --> 03:30:33,120
but some compilers are going to usefully

5295
03:30:33,120 --> 03:30:35,600
put in a zero because that's a logical

5296
03:30:35,600 --> 03:30:37,760
number to put in here if you didn't

5297
03:30:37,760 --> 03:30:40,080
explicitly put a number in here the

5298
03:30:40,080 --> 03:30:43,120
second one is using curly braces and

5299
03:30:43,120 --> 03:30:45,200
this is going to automatically

5300
03:30:45,200 --> 03:30:47,439
initialize to zero the third one is

5301
03:30:47,439 --> 03:30:50,399
going to be explicitly initialized with

5302
03:30:50,399 --> 03:30:53,120
the 10 and the cat count is going to be

5303
03:30:53,120 --> 03:30:55,920
initialized with 15. you can try and

5304
03:30:55,920 --> 03:30:58,000
print this out and see what you come up

5305
03:30:58,000 --> 03:31:00,319
with after compiling this application

5306
03:31:00,319 --> 03:31:02,239
another thing we have seen is that we

5307
03:31:02,239 --> 03:31:04,479
can do something like this and put an

5308
03:31:04,479 --> 03:31:09,520
expression into our curly braces and the

5309
03:31:09,520 --> 03:31:12,640
value this evaluates to is going to

5310
03:31:12,640 --> 03:31:15,359
initialize this domesticated animals

5311
03:31:15,359 --> 03:31:18,239
variable and now you should know that

5312
03:31:18,239 --> 03:31:20,239
this is probably going to take 4 bytes

5313
03:31:20,239 --> 03:31:22,640
in memory because it is an integer

5314
03:31:22,640 --> 03:31:25,760
this is really how c plus plus works

5315
03:31:25,760 --> 03:31:28,640
each fundamental type has

5316
03:31:28,640 --> 03:31:31,439
a size associated to it

5317
03:31:31,439 --> 03:31:34,239
most times so integers is mostly going

5318
03:31:34,239 --> 03:31:36,160
to be four bytes on your system and

5319
03:31:36,160 --> 03:31:38,800
we're going to query this a little later

5320
03:31:38,800 --> 03:31:41,520
in this video okay let's try and compile

5321
03:31:41,520 --> 03:31:44,479
this program and see if it actually

5322
03:31:44,479 --> 03:31:46,479
works we're going to start world and you

5323
03:31:46,479 --> 03:31:49,120
see that the world is successful another

5324
03:31:49,120 --> 03:31:51,840
thing we can do is try and use variables

5325
03:31:51,840 --> 03:31:53,520
we haven't really declared in our

5326
03:31:53,520 --> 03:31:55,359
program and you can guess what is going

5327
03:31:55,359 --> 03:31:57,840
to happen if we try to do

5328
03:31:57,840 --> 03:32:01,040
and new number for example and putin

5329
03:32:01,040 --> 03:32:03,120
doesn't exist you know it's a number

5330
03:32:03,120 --> 03:32:05,359
that doesn't exist the compiler is not

5331
03:32:05,359 --> 03:32:07,359
going to know what this is because we

5332
03:32:07,359 --> 03:32:10,399
didn't declare a variable called doesn't

5333
03:32:10,399 --> 03:32:12,160
exist if you try to compile this you're

5334
03:32:12,160 --> 03:32:13,920
going to get a problem you see that we

5335
03:32:13,920 --> 03:32:16,640
have a problem before we even compile so

5336
03:32:16,640 --> 03:32:19,359
visual studio code is this smart it can

5337
03:32:19,359 --> 03:32:22,080
analyze our code before we compile it

5338
03:32:22,080 --> 03:32:24,960
and give us hints to problems that might

5339
03:32:24,960 --> 03:32:27,120
come up you see here it is saying

5340
03:32:27,120 --> 03:32:30,160
doesn't exist isn't defined so if we try

5341
03:32:30,160 --> 03:32:32,479
to compile this we're going to get an

5342
03:32:32,479 --> 03:32:34,640
error that we expect it's going to say

5343
03:32:34,640 --> 03:32:36,720
doesn't exist doesn't really exist i

5344
03:32:36,720 --> 03:32:38,560
don't know what that is so you shouldn't

5345
03:32:38,560 --> 03:32:40,479
really do that you shouldn't try to use

5346
03:32:40,479 --> 03:32:43,600
variables you haven't declared this is

5347
03:32:43,600 --> 03:32:45,840
braced initialization

5348
03:32:45,840 --> 03:32:48,800
we can also do functional initialization

5349
03:32:48,800 --> 03:32:50,560
as we have seen

5350
03:32:50,560 --> 03:32:53,200
okay another thing we can do is store a

5351
03:32:53,200 --> 03:32:56,080
fractional number in an empty variable

5352
03:32:56,080 --> 03:32:57,840
and we're going to see what this does

5353
03:32:57,840 --> 03:32:59,760
we're going to try and compile this code

5354
03:32:59,760 --> 03:33:02,000
you see we have a 2.9 we're trying to

5355
03:33:02,000 --> 03:33:04,319
store this in an integer if we try to

5356
03:33:04,319 --> 03:33:07,760
compile this let's try and use gcc let's

5357
03:33:07,760 --> 03:33:11,279
clear this let's bring up a terminal and

5358
03:33:11,279 --> 03:33:13,840
try to build this we're going to try and

5359
03:33:13,840 --> 03:33:16,880
run our gcc compiler on this program it

5360
03:33:16,880 --> 03:33:19,359
is going to say errol narrowing a

5361
03:33:19,359 --> 03:33:21,800
conversion of

5362
03:33:21,800 --> 03:33:25,120
2.899 from double to integer c plus plus

5363
03:33:25,120 --> 03:33:28,080
20 isn't even going to allow this so

5364
03:33:28,080 --> 03:33:30,880
this is a good thing because you might

5365
03:33:30,880 --> 03:33:34,080
think that you have a 2.9 and some

5366
03:33:34,080 --> 03:33:36,640
compilers are going to chop this off and

5367
03:33:36,640 --> 03:33:39,920
store a 2 instead so this is one of the

5368
03:33:39,920 --> 03:33:42,160
safe things about this way of doing

5369
03:33:42,160 --> 03:33:44,560
thanks so i am going to comment this out

5370
03:33:44,560 --> 03:33:46,880
because otherwise our program wouldn't

5371
03:33:46,880 --> 03:33:49,520
compile now that we know how to use

5372
03:33:49,520 --> 03:33:51,840
these things we can try to print the

5373
03:33:51,840 --> 03:33:54,399
values in here okay i am going to put in

5374
03:33:54,399 --> 03:33:57,040
a piece of code i have lying around on

5375
03:33:57,040 --> 03:33:59,279
my drive i am going to remove these

5376
03:33:59,279 --> 03:34:01,520
spaces inside because it is annoying

5377
03:34:01,520 --> 03:34:04,160
let's do this and if we try and build

5378
03:34:04,160 --> 03:34:06,160
this program it should compile

5379
03:34:06,160 --> 03:34:08,720
successfully and if we run it we should

5380
03:34:08,720 --> 03:34:11,120
see our numbers we're going to go in our

5381
03:34:11,120 --> 03:34:13,600
terminal here and do der and we're going

5382
03:34:13,600 --> 03:34:15,760
to run rooster and we're going to see

5383
03:34:15,760 --> 03:34:19,279
elephant count is one because this is a

5384
03:34:19,279 --> 03:34:21,279
garbage value so it could really be

5385
03:34:21,279 --> 03:34:22,319
anything

5386
03:34:22,319 --> 03:34:24,560
lion count should be zero

5387
03:34:24,560 --> 03:34:26,880
dog account should be 10

5388
03:34:26,880 --> 03:34:29,200
cat count should be 15 it is what we

5389
03:34:29,200 --> 03:34:32,800
have and a domesticated animal count is

5390
03:34:32,800 --> 03:34:35,840
25 because we have drug account

5391
03:34:35,840 --> 03:34:38,239
and we add that to cat count and we're

5392
03:34:38,239 --> 03:34:41,120
going to end up with 25. this is what we

5393
03:34:41,120 --> 03:34:43,279
expect now that we know how to work with

5394
03:34:43,279 --> 03:34:45,600
this we can also try and play with

5395
03:34:45,600 --> 03:34:48,479
functional initialization before i put

5396
03:34:48,479 --> 03:34:50,720
in my code i am going to comment all

5397
03:34:50,720 --> 03:34:52,880
this out because i don't want this to

5398
03:34:52,880 --> 03:34:55,200
disturb us as we work with our

5399
03:34:55,200 --> 03:34:57,680
functional initialization code so i am

5400
03:34:57,680 --> 03:35:00,000
going to comment all this out and go all

5401
03:35:00,000 --> 03:35:02,479
the way down and put in my code for

5402
03:35:02,479 --> 03:35:04,960
functional initialization

5403
03:35:04,960 --> 03:35:06,880
and you see here we have a variable

5404
03:35:06,880 --> 03:35:09,840
called ethel we initialize this to 5 we

5405
03:35:09,840 --> 03:35:12,399
have orange count which is 10 we have

5406
03:35:12,399 --> 03:35:13,920
fruit count

5407
03:35:13,920 --> 03:35:16,000
and we have a bad initialization that is

5408
03:35:16,000 --> 03:35:18,239
not going to work it doesn't exist 3 and

5409
03:35:18,239 --> 03:35:21,600
doesn't exist 4 don't really exist so so

5410
03:35:21,600 --> 03:35:23,359
this is going to give us a compiler

5411
03:35:23,359 --> 03:35:24,479
error

5412
03:35:24,479 --> 03:35:27,600
and if we do something like we do in

5413
03:35:27,600 --> 03:35:30,399
narrowing the conversion function here

5414
03:35:30,399 --> 03:35:32,960
this is mostly going to compile and this

5415
03:35:32,960 --> 03:35:36,239
is going to chop off data and store a 2

5416
03:35:36,239 --> 03:35:39,040
instead of the 2.9 this is something you

5417
03:35:39,040 --> 03:35:41,520
should really be aware of and you see

5418
03:35:41,520 --> 03:35:43,920
the comment here says information lost

5419
03:35:43,920 --> 03:35:46,239
this is less safe than braced

5420
03:35:46,239 --> 03:35:49,040
initializer because breast initializer

5421
03:35:49,040 --> 03:35:50,479
is going to

5422
03:35:50,479 --> 03:35:52,640
give you a compiler error if you try to

5423
03:35:52,640 --> 03:35:54,800
do this and that's a good thing

5424
03:35:54,800 --> 03:35:57,520
so we also try and print these out so i

5425
03:35:57,520 --> 03:36:00,239
am going to tidy this up a little bit

5426
03:36:00,239 --> 03:36:02,399
and i am going to try and compile this

5427
03:36:02,399 --> 03:36:05,040
piece of code run task and world with

5428
03:36:05,040 --> 03:36:08,000
gcc the world is going to pass through

5429
03:36:08,000 --> 03:36:09,600
without a problem

5430
03:36:09,600 --> 03:36:13,120
and if we do clear and run rooster we're

5431
03:36:13,120 --> 03:36:16,239
going to see apple count is 5 which is

5432
03:36:16,239 --> 03:36:18,640
what we have in here orange count is

5433
03:36:18,640 --> 03:36:21,600
going to be 10 so this is right fruit

5434
03:36:21,600 --> 03:36:24,000
count is going to be 15 because it is 5

5435
03:36:24,000 --> 03:36:25,279
plus 10

5436
03:36:25,279 --> 03:36:29,120
and what is really worrying is that

5437
03:36:29,120 --> 03:36:31,680
narrowing conversion is 2 but we didn't

5438
03:36:31,680 --> 03:36:34,880
store in a 2 we started in a 2.9

5439
03:36:34,880 --> 03:36:38,160
and because an integer can really store

5440
03:36:38,160 --> 03:36:43,120
4 bytes 2.9 is more than 4 bytes and it

5441
03:36:43,120 --> 03:36:46,000
is going to store what it can and it is

5442
03:36:46,000 --> 03:36:48,960
going to chop off this 2.9 and only

5443
03:36:48,960 --> 03:36:51,439
store in a 2 so this is really something

5444
03:36:51,439 --> 03:36:54,239
you should be aware of sometimes this is

5445
03:36:54,239 --> 03:36:56,960
going to cause problems in your program

5446
03:36:56,960 --> 03:36:58,080
and

5447
03:36:58,080 --> 03:37:00,800
really really if you are trying to store

5448
03:37:00,800 --> 03:37:03,680
fractional numbers in an integer please

5449
03:37:03,680 --> 03:37:06,560
use a braced initialization

5450
03:37:06,560 --> 03:37:08,399
form because the compiler is going to

5451
03:37:08,399 --> 03:37:11,279
stop you from doing this if you try okay

5452
03:37:11,279 --> 03:37:13,359
so this is really the difference between

5453
03:37:13,359 --> 03:37:15,279
functional notation and breast

5454
03:37:15,279 --> 03:37:18,399
initializer notation functional notation

5455
03:37:18,399 --> 03:37:20,399
is not going to give you an arrow if you

5456
03:37:20,399 --> 03:37:23,279
try to store something that can't really

5457
03:37:23,279 --> 03:37:25,840
fit in a net it is going to silently

5458
03:37:25,840 --> 03:37:28,960
chop it off and put in whatever it can

5459
03:37:28,960 --> 03:37:31,359
and braced initializer is going to give

5460
03:37:31,359 --> 03:37:33,279
you a compiler error so this is the

5461
03:37:33,279 --> 03:37:36,000
difference between these two okay i am

5462
03:37:36,000 --> 03:37:39,040
going to comment this out as well and i

5463
03:37:39,040 --> 03:37:41,359
am going to put the starting comment

5464
03:37:41,359 --> 03:37:43,760
here and i am going to go down and show

5465
03:37:43,760 --> 03:37:45,600
you that you can do assignment

5466
03:37:45,600 --> 03:37:48,319
initialization as well i am going to put

5467
03:37:48,319 --> 03:37:50,160
in my code here because i don't want to

5468
03:37:50,160 --> 03:37:52,399
type it really and i am going to print

5469
03:37:52,399 --> 03:37:54,960
all this out and we have a bike account

5470
03:37:54,960 --> 03:37:57,279
variable that we initialize using the

5471
03:37:57,279 --> 03:37:59,840
assignment notation track count is going

5472
03:37:59,840 --> 03:38:02,319
to be seven fake account is going to be

5473
03:38:02,319 --> 03:38:04,800
bike account plus track count and we're

5474
03:38:04,800 --> 03:38:06,640
going to be narrowing conversion here

5475
03:38:06,640 --> 03:38:08,800
and we're going to see if this actually

5476
03:38:08,800 --> 03:38:11,760
works we're going to try and weld this

5477
03:38:11,760 --> 03:38:13,600
we're going to run the task to world

5478
03:38:13,600 --> 03:38:15,120
with gcc

5479
03:38:15,120 --> 03:38:17,120
it is going to pass through you can

5480
03:38:17,120 --> 03:38:19,600
guess what we're going to see if we run

5481
03:38:19,600 --> 03:38:21,279
the program

5482
03:38:21,279 --> 03:38:24,319
bike account is 2 track count is 7 which

5483
03:38:24,319 --> 03:38:28,080
is what we expect vehicle count is nine

5484
03:38:28,080 --> 03:38:31,040
and uh the narrowing conversion is also

5485
03:38:31,040 --> 03:38:33,840
chopping off what we have here so this

5486
03:38:33,840 --> 03:38:35,600
is something you need to be careful

5487
03:38:35,600 --> 03:38:37,840
about another thing i want you to see is

5488
03:38:37,840 --> 03:38:39,680
that you can check the size of your

5489
03:38:39,680 --> 03:38:42,000
variables in memory so we're going to

5490
03:38:42,000 --> 03:38:45,120
check the size

5491
03:38:45,120 --> 03:38:46,479
with

5492
03:38:46,479 --> 03:38:48,640
size of

5493
03:38:48,640 --> 03:38:50,720
and i am going to put in a piece of code

5494
03:38:50,720 --> 03:38:52,239
to really play with this i don't want to

5495
03:38:52,239 --> 03:38:55,080
type all this because it's really

5496
03:38:55,080 --> 03:38:57,439
self-explanatory by now we're going to

5497
03:38:57,439 --> 03:38:59,760
print sites of ant and inside we're

5498
03:38:59,760 --> 03:39:02,560
going to say size of ant and this is

5499
03:39:02,560 --> 03:39:04,479
going to give us how much memory is

5500
03:39:04,479 --> 03:39:07,279
really occupied by an end and we can use

5501
03:39:07,279 --> 03:39:09,680
this form here by passing in a variable

5502
03:39:09,680 --> 03:39:12,560
name track count is a variable we have

5503
03:39:12,560 --> 03:39:15,359
declared and initialized here

5504
03:39:15,359 --> 03:39:18,080
so if we build this program

5505
03:39:18,080 --> 03:39:20,880
let's do that with gcc the build is

5506
03:39:20,880 --> 03:39:23,120
going to pass through and if we run

5507
03:39:23,120 --> 03:39:25,439
rooster we're going to see that the size

5508
03:39:25,439 --> 03:39:28,160
of int is four you're going to see that

5509
03:39:28,160 --> 03:39:31,199
this is in bytes and size of track count

5510
03:39:31,199 --> 03:39:34,399
is for as well because track account is

5511
03:39:34,399 --> 03:39:37,439
also an integer so these are all little

5512
03:39:37,439 --> 03:39:39,920
tools you can really use to

5513
03:39:39,920 --> 03:39:42,640
know how much memory is really being

5514
03:39:42,640 --> 03:39:45,760
used and occupied by your program and

5515
03:39:45,760 --> 03:39:47,279
this is really all we set up to do in

5516
03:39:47,279 --> 03:39:49,760
this lecture to learn as much as we can

5517
03:39:49,760 --> 03:39:53,120
about integers integers occupy 4 bytes

5518
03:39:53,120 --> 03:39:56,239
in memory for the most part and we have

5519
03:39:56,239 --> 03:39:58,880
seen different ways we can initialize

5520
03:39:58,880 --> 03:40:01,920
our integer variables we can use breast

5521
03:40:01,920 --> 03:40:04,800
initializers which is going to use curly

5522
03:40:04,800 --> 03:40:07,120
braces we can do functional

5523
03:40:07,120 --> 03:40:09,439
initialization using parentheses like

5524
03:40:09,439 --> 03:40:12,960
this we can also do assignment notation

5525
03:40:12,960 --> 03:40:15,439
using the from like this and we can use

5526
03:40:15,439 --> 03:40:18,560
size of to check the size of our integer

5527
03:40:18,560 --> 03:40:21,359
variables i have to say that these kinds

5528
03:40:21,359 --> 03:40:24,080
of initialization also work on other

5529
03:40:24,080 --> 03:40:27,040
variables but we took the chance to

5530
03:40:27,040 --> 03:40:29,520
introduce all these concepts using

5531
03:40:29,520 --> 03:40:31,439
integers this is really all we set out

5532
03:40:31,439 --> 03:40:33,120
to do in this lecture i hope you found

5533
03:40:33,120 --> 03:40:35,840
it interesting we are going to stop here

5534
03:40:35,840 --> 03:40:37,680
in this lecture the next one we're going

5535
03:40:37,680 --> 03:40:40,319
to start and learn about integer

5536
03:40:40,319 --> 03:40:43,120
modifiers go ahead and finish up here

5537
03:40:43,120 --> 03:40:44,560
and meet me there

5538
03:40:44,560 --> 03:40:46,000
in this lecture we're going to learn

5539
03:40:46,000 --> 03:40:49,359
about integer modifiers and these are

5540
03:40:49,359 --> 03:40:51,439
little things you can sprinkle around

5541
03:40:51,439 --> 03:40:54,239
your integer types to modify their

5542
03:40:54,239 --> 03:40:56,880
behavior a little bit but before we dive

5543
03:40:56,880 --> 03:40:58,399
deep into this

5544
03:40:58,399 --> 03:41:00,960
let's talk about how we can store

5545
03:41:00,960 --> 03:41:03,920
positive or negative numbers in integers

5546
03:41:03,920 --> 03:41:06,800
and we can do something like this if we

5547
03:41:06,800 --> 03:41:10,399
put a tan inside our value 1 variable

5548
03:41:10,399 --> 03:41:12,080
which is an integer

5549
03:41:12,080 --> 03:41:14,560
it's going to work we can also put in a

5550
03:41:14,560 --> 03:41:18,000
negative number like minus 300

5551
03:41:18,000 --> 03:41:20,160
and it is going to work so what's the

5552
03:41:20,160 --> 03:41:21,520
magic here

5553
03:41:21,520 --> 03:41:22,479
well

5554
03:41:22,479 --> 03:41:24,880
this is signed by default and this is a

5555
03:41:24,880 --> 03:41:28,399
modifier we can apply to our variable

5556
03:41:28,399 --> 03:41:31,199
to signal that we have the possibility

5557
03:41:31,199 --> 03:41:33,920
to store in negative or positive numbers

5558
03:41:33,920 --> 03:41:36,319
and it is going to work if you only want

5559
03:41:36,319 --> 03:41:38,560
to store positive numbers in your end

5560
03:41:38,560 --> 03:41:41,120
variables you can use another

5561
03:41:41,120 --> 03:41:44,479
modifier called unsigned and if you put

5562
03:41:44,479 --> 03:41:46,319
in a negative number you're going to get

5563
03:41:46,319 --> 03:41:48,000
a compiler error we're going to see how

5564
03:41:48,000 --> 03:41:50,479
this works in a minute okay regardless

5565
03:41:50,479 --> 03:41:53,199
of whether your integer variables are

5566
03:41:53,199 --> 03:41:56,080
unsigned or signed they are going to

5567
03:41:56,080 --> 03:41:58,720
still occupy 4 bytes in memory so this

5568
03:41:58,720 --> 03:42:01,040
is how it's going to look in memory and

5569
03:42:01,040 --> 03:42:03,359
here is a simple formula we can use to

5570
03:42:03,359 --> 03:42:04,720
come up with

5571
03:42:04,720 --> 03:42:07,600
the range of values we can store in our

5572
03:42:07,600 --> 03:42:08,960
int values

5573
03:42:08,960 --> 03:42:12,160
if they are unsigned or signed if the

5574
03:42:12,160 --> 03:42:14,640
number is inside you can use this

5575
03:42:14,640 --> 03:42:17,279
unsigned range formula and plug in the

5576
03:42:17,279 --> 03:42:19,359
number of bits you have

5577
03:42:19,359 --> 03:42:22,800
in your data type if you are using a

5578
03:42:22,800 --> 03:42:24,399
signed integer

5579
03:42:24,399 --> 03:42:26,399
this is what you're going to use and

5580
03:42:26,399 --> 03:42:28,720
here is a simple example for example if

5581
03:42:28,720 --> 03:42:31,279
we have an unsigned and this is the

5582
03:42:31,279 --> 03:42:33,520
range of values we can store we can

5583
03:42:33,520 --> 03:42:36,080
basically go from 0 all the way to 4

5584
03:42:36,080 --> 03:42:38,640
billion if the number is signed the

5585
03:42:38,640 --> 03:42:40,800
range is going to basically be divided

5586
03:42:40,800 --> 03:42:42,880
into half the half is going to go on the

5587
03:42:42,880 --> 03:42:45,199
left and store negative numbers and the

5588
03:42:45,199 --> 03:42:47,279
other half is going to go to the right

5589
03:42:47,279 --> 03:42:49,840
and store positive numbers and you can

5590
03:42:49,840 --> 03:42:52,239
see that we can basically go from minus

5591
03:42:52,239 --> 03:42:55,680
two billion to two billion if the number

5592
03:42:55,680 --> 03:42:58,160
is signed okay by now we have seen two

5593
03:42:58,160 --> 03:43:01,520
modifiers unsigned and designed but

5594
03:43:01,520 --> 03:43:04,319
there are others for example you can

5595
03:43:04,319 --> 03:43:07,920
flag your integer types as short or long

5596
03:43:07,920 --> 03:43:11,279
what does this do well this is a table

5597
03:43:11,279 --> 03:43:14,080
that i put together to try and come up

5598
03:43:14,080 --> 03:43:15,920
with all the combinations you can come

5599
03:43:15,920 --> 03:43:19,120
up with if you have a short variable it

5600
03:43:19,120 --> 03:43:21,279
is going to be two bytes in memory this

5601
03:43:21,279 --> 03:43:23,600
is the modification that this modifier

5602
03:43:23,600 --> 03:43:26,399
does to your type if you have short and

5603
03:43:26,399 --> 03:43:28,640
it's going to be two bytes if you have a

5604
03:43:28,640 --> 03:43:30,720
signed short and it's going to be two

5605
03:43:30,720 --> 03:43:33,439
bytes if you have unsigned shirt and

5606
03:43:33,439 --> 03:43:35,920
it's going to be two bites you can see

5607
03:43:35,920 --> 03:43:38,960
that the effect of short is really

5608
03:43:38,960 --> 03:43:43,120
shortening the original size in memory

5609
03:43:43,120 --> 03:43:46,319
for whatever type you applied this on

5610
03:43:46,319 --> 03:43:48,640
this is really working on an editor even

5611
03:43:48,640 --> 03:43:51,120
if we don't specify int here for example

5612
03:43:51,120 --> 03:43:53,040
short short here it's going to

5613
03:43:53,040 --> 03:43:55,600
implicitly be and that's why

5614
03:43:55,600 --> 03:43:58,000
we have two bytes because it's basically

5615
03:43:58,000 --> 03:44:01,359
an end that we have split into here in

5616
03:44:01,359 --> 03:44:04,399
the second column we have ant which is

5617
03:44:04,399 --> 03:44:07,199
going to be 4 bytes if it is assigned

5618
03:44:07,199 --> 03:44:09,520
and it's going to be 4 bytes this is

5619
03:44:09,520 --> 03:44:11,279
really the sizes you're going to come up

5620
03:44:11,279 --> 03:44:14,880
with if you use these combinations of

5621
03:44:14,880 --> 03:44:17,920
modifiers on your integer types one

5622
03:44:17,920 --> 03:44:19,520
thing i really want you to be careful

5623
03:44:19,520 --> 03:44:22,560
about is that these modifiers only work

5624
03:44:22,560 --> 03:44:26,479
for integral types so they work for data

5625
03:44:26,479 --> 03:44:28,800
types in which you can store

5626
03:44:28,800 --> 03:44:31,439
decimal or whole numbers you can't use

5627
03:44:31,439 --> 03:44:34,239
this on types in which you can store

5628
03:44:34,239 --> 03:44:37,359
fractional numbers like 2.9 that's going

5629
03:44:37,359 --> 03:44:39,520
to give you a compiler error now that

5630
03:44:39,520 --> 03:44:42,080
you have an idea about this why don't we

5631
03:44:42,080 --> 03:44:44,560
go in visual studio code and actually

5632
03:44:44,560 --> 03:44:47,359
play with us okay here we are in our

5633
03:44:47,359 --> 03:44:50,160
folder that contains our projects we're

5634
03:44:50,160 --> 03:44:53,040
going to do the usual and copy the files

5635
03:44:53,040 --> 03:44:55,760
from our template project and we're

5636
03:44:55,760 --> 03:44:58,960
going to put those files in our integer

5637
03:44:58,960 --> 03:45:02,160
modifiers project here let's open it up

5638
03:45:02,160 --> 03:45:04,239
and paste in the files we're going to go

5639
03:45:04,239 --> 03:45:06,479
up again and we're going to open this up

5640
03:45:06,479 --> 03:45:08,640
in visual studio code the first thing i

5641
03:45:08,640 --> 03:45:10,800
want to play with is storing positive

5642
03:45:10,800 --> 03:45:13,040
and negative numbers in our integer

5643
03:45:13,040 --> 03:45:15,199
types so we're going to say end value

5644
03:45:15,199 --> 03:45:17,920
one and we're going to store in a 10 for

5645
03:45:17,920 --> 03:45:20,479
example and we're going to do any value

5646
03:45:20,479 --> 03:45:21,439
2

5647
03:45:21,439 --> 03:45:24,239
and we're going to put in a minus 300. i

5648
03:45:24,239 --> 03:45:25,760
think this is what we had you know a

5649
03:45:25,760 --> 03:45:27,760
slide so we're going to keep this

5650
03:45:27,760 --> 03:45:29,920
if you try to print this out so we're

5651
03:45:29,920 --> 03:45:31,920
going to say value 1 and we're going to

5652
03:45:31,920 --> 03:45:33,760
say value 2

5653
03:45:33,760 --> 03:45:36,640
and we're going to try and build this so

5654
03:45:36,640 --> 03:45:38,399
we're going to open our terminal so that

5655
03:45:38,399 --> 03:45:40,479
we can play with it right away

5656
03:45:40,479 --> 03:45:42,720
and we're going to run the task to world

5657
03:45:42,720 --> 03:45:44,880
with gcc the world is going to be

5658
03:45:44,880 --> 03:45:48,160
successful if we run our program we're

5659
03:45:48,160 --> 03:45:49,520
going to see that it's going to say

5660
03:45:49,520 --> 03:45:52,479
value 1 is 10 and value 2

5661
03:45:52,479 --> 03:45:55,760
is -3 300 this is really cool we can

5662
03:45:55,760 --> 03:45:57,840
store positive numbers and negative

5663
03:45:57,840 --> 03:46:00,319
numbers in our end times and this is

5664
03:46:00,319 --> 03:46:01,760
going to occupy

5665
03:46:01,760 --> 03:46:04,000
4 bytes in memory we can prove this by

5666
03:46:04,000 --> 03:46:06,160
printing the size of value 1 and value

5667
03:46:06,160 --> 03:46:08,880
2. let's do that so we're going to say

5668
03:46:08,880 --> 03:46:12,880
size of value 1 is size of value 1. we

5669
03:46:12,880 --> 03:46:16,720
can also do it for value 2 size of value

5670
03:46:16,720 --> 03:46:21,600
2 and it's going to be size of value two

5671
03:46:21,600 --> 03:46:24,319
std and yeah if we build this again

5672
03:46:24,319 --> 03:46:26,319
we're going to run the test world with

5673
03:46:26,319 --> 03:46:30,080
gcc and uh we run our application it's

5674
03:46:30,080 --> 03:46:31,920
going to save four bytes so it doesn't

5675
03:46:31,920 --> 03:46:34,000
really matter if we store in a positive

5676
03:46:34,000 --> 03:46:36,160
number or a negative number it's going

5677
03:46:36,160 --> 03:46:38,800
to be 4 bytes this is the point i want

5678
03:46:38,800 --> 03:46:41,600
to make here another thing you can do is

5679
03:46:41,600 --> 03:46:43,120
actually make it

5680
03:46:43,120 --> 03:46:46,080
very clear that you have signed numbers

5681
03:46:46,080 --> 03:46:49,359
in here and you can use the signed

5682
03:46:49,359 --> 03:46:52,160
integer modifier here so this is going

5683
03:46:52,160 --> 03:46:55,199
to give us the same result and if we try

5684
03:46:55,199 --> 03:46:56,960
to both again

5685
03:46:56,960 --> 03:47:00,160
run the task to build with gcc the world

5686
03:47:00,160 --> 03:47:02,720
is going to be successful if we run the

5687
03:47:02,720 --> 03:47:04,800
program we're going to get the same

5688
03:47:04,800 --> 03:47:07,840
result so if you don't put aside or if

5689
03:47:07,840 --> 03:47:09,920
you put it here it's going to be exactly

5690
03:47:09,920 --> 03:47:12,000
the same thing another thing you can do

5691
03:47:12,000 --> 03:47:14,960
is make it very clear that you want to

5692
03:47:14,960 --> 03:47:16,160
store

5693
03:47:16,160 --> 03:47:18,960
positive numbers in your variables we

5694
03:47:18,960 --> 03:47:21,920
can do that by using the unsigned

5695
03:47:21,920 --> 03:47:24,000
integer modifier so we're going to say

5696
03:47:24,000 --> 03:47:25,439
unsigned

5697
03:47:25,439 --> 03:47:28,239
and value three for example and we're

5698
03:47:28,239 --> 03:47:30,239
going to put in a four

5699
03:47:30,239 --> 03:47:32,720
this is going to be fine but if you do

5700
03:47:32,720 --> 03:47:37,120
unsigned and value 4 and put in a minus

5701
03:47:37,120 --> 03:47:38,720
5 for example

5702
03:47:38,720 --> 03:47:40,479
this is going to give you a compiler

5703
03:47:40,479 --> 03:47:43,199
error because you save this is unsigned

5704
03:47:43,199 --> 03:47:45,520
and this really means that you want to

5705
03:47:45,520 --> 03:47:48,560
store in only positive numbers but you

5706
03:47:48,560 --> 03:47:51,120
are trying to put in a negative number

5707
03:47:51,120 --> 03:47:53,520
if you try to build this let's try this

5708
03:47:53,520 --> 03:47:55,199
we're going to run the task to build

5709
03:47:55,199 --> 03:47:58,080
with gcc we are going to get a compiler

5710
03:47:58,080 --> 03:48:02,000
arrow saying conversion from -5 to ant

5711
03:48:02,000 --> 03:48:03,600
this is not allowed you're going to get

5712
03:48:03,600 --> 03:48:05,760
a compiler arrow your program is not

5713
03:48:05,760 --> 03:48:08,239
going to compile so this is a compiler

5714
03:48:08,239 --> 03:48:10,880
error let's say this here and this is

5715
03:48:10,880 --> 03:48:13,120
really all i had to share about these

5716
03:48:13,120 --> 03:48:15,840
signed and unsigned modifiers

5717
03:48:15,840 --> 03:48:17,520
signed is going to mean that you can

5718
03:48:17,520 --> 03:48:19,600
store negative and positive numbers

5719
03:48:19,600 --> 03:48:22,160
unsigned is going to mean that you can

5720
03:48:22,160 --> 03:48:25,040
only put in positive numbers and if you

5721
03:48:25,040 --> 03:48:26,720
try to put in a negative number you're

5722
03:48:26,720 --> 03:48:29,439
going to get a compiler error now that

5723
03:48:29,439 --> 03:48:32,160
this is commented out if you try to run

5724
03:48:32,160 --> 03:48:34,720
the test to world with gcc

5725
03:48:34,720 --> 03:48:36,720
the world is going to be good and we

5726
03:48:36,720 --> 03:48:39,199
will be able to run our program

5727
03:48:39,199 --> 03:48:40,800
and it's going to do whatever it was

5728
03:48:40,800 --> 03:48:44,080
doing before as we see here we also saw

5729
03:48:44,080 --> 03:48:46,720
that we could use the short and

5730
03:48:46,720 --> 03:48:49,199
long modifiers and we're going to put a

5731
03:48:49,199 --> 03:48:51,040
piece of code here that is going to

5732
03:48:51,040 --> 03:48:53,199
allow us to play with them so i don't

5733
03:48:53,199 --> 03:48:56,080
want to type this and if you don't want

5734
03:48:56,080 --> 03:48:58,319
to type this as well you can get this

5735
03:48:58,319 --> 03:49:00,560
code from the resource section it's

5736
03:49:00,560 --> 03:49:03,040
going to be left you can open the link

5737
03:49:03,040 --> 03:49:05,120
use the code copy the code and paste it

5738
03:49:05,120 --> 03:49:07,040
in here and really play with it because

5739
03:49:07,040 --> 03:49:09,279
the point is really not to type all this

5740
03:49:09,279 --> 03:49:11,439
the point is to understand what these

5741
03:49:11,439 --> 03:49:13,279
modifiers do

5742
03:49:13,279 --> 03:49:15,279
to your variables what we are going to

5743
03:49:15,279 --> 03:49:17,199
do we're going to try to print them out

5744
03:49:17,199 --> 03:49:20,160
and print the size they actually have in

5745
03:49:20,160 --> 03:49:22,319
memory we're going to do this in four

5746
03:49:22,319 --> 03:49:24,399
groups we're going to do one for short

5747
03:49:24,399 --> 03:49:26,800
and long we're going to do one for ant

5748
03:49:26,800 --> 03:49:29,520
here we're going to do one for long and

5749
03:49:29,520 --> 03:49:31,359
we're going to do one for long long

5750
03:49:31,359 --> 03:49:33,600
these are things you can do and we're

5751
03:49:33,600 --> 03:49:35,600
going to see how much memory is actually

5752
03:49:35,600 --> 03:49:38,560
being used by all these variables we are

5753
03:49:38,560 --> 03:49:41,520
going to start with the first group here

5754
03:49:41,520 --> 03:49:43,840
so we're going to go down and print the

5755
03:49:43,840 --> 03:49:47,680
size is out and this may be really hard

5756
03:49:47,680 --> 03:49:50,239
to wrap your brain around but they are

5757
03:49:50,239 --> 03:49:51,840
plain old

5758
03:49:51,840 --> 03:49:53,840
see out statements that we have been

5759
03:49:53,840 --> 03:49:56,720
doing all along i am going to split this

5760
03:49:56,720 --> 03:49:59,040
on different lines so that you can

5761
03:49:59,040 --> 03:50:01,279
really say this so

5762
03:50:01,279 --> 03:50:04,640
we have an output statement for a short

5763
03:50:04,640 --> 03:50:07,279
var which is what we have here so we

5764
03:50:07,279 --> 03:50:09,520
expect this to take two bytes and all

5765
03:50:09,520 --> 03:50:11,279
these things are probably going to take

5766
03:50:11,279 --> 03:50:13,760
two bytes let's try and build the

5767
03:50:13,760 --> 03:50:16,399
program with gcc the bullet is going to

5768
03:50:16,399 --> 03:50:18,640
be successful we are going to run

5769
03:50:18,640 --> 03:50:20,640
rooster and you're going to see that

5770
03:50:20,640 --> 03:50:23,840
short end is two bytes signed short is

5771
03:50:23,840 --> 03:50:26,160
two bytes and everything is basically

5772
03:50:26,160 --> 03:50:27,359
two bytes

5773
03:50:27,359 --> 03:50:30,399
in this group here and we did guess

5774
03:50:30,399 --> 03:50:32,160
right the next thing we want to try out

5775
03:50:32,160 --> 03:50:35,199
is this group of ants so

5776
03:50:35,199 --> 03:50:37,199
we are going to go down and give

5777
03:50:37,199 --> 03:50:39,600
ourselves some breathing room

5778
03:50:39,600 --> 03:50:41,680
and we're going to paste this in and

5779
03:50:41,680 --> 03:50:43,680
we're going to separate these again so

5780
03:50:43,680 --> 03:50:45,840
that we can see what is really happening

5781
03:50:45,840 --> 03:50:48,800
here and i think this is really enough

5782
03:50:48,800 --> 03:50:51,520
so we're going to see the sizes for the

5783
03:50:51,520 --> 03:50:54,479
thanks we have in this group here and we

5784
03:50:54,479 --> 03:50:57,520
expect this to take four bytes so let's

5785
03:50:57,520 --> 03:51:00,560
try and run the world task to build with

5786
03:51:00,560 --> 03:51:03,040
gcc the world is going to be good we can

5787
03:51:03,040 --> 03:51:05,760
run the program like we usually do and

5788
03:51:05,760 --> 03:51:08,239
you're going to see that ant variable is

5789
03:51:08,239 --> 03:51:11,600
4 bytes and everything in that group is

5790
03:51:11,600 --> 03:51:15,439
4 bytes and this tells you that

5791
03:51:15,439 --> 03:51:19,680
regardless of the side and unside

5792
03:51:19,680 --> 03:51:22,479
modifiers you put here it's going to

5793
03:51:22,479 --> 03:51:25,279
really use the size of it here okay it's

5794
03:51:25,279 --> 03:51:27,840
going to take four bytes in memory let's

5795
03:51:27,840 --> 03:51:30,399
try this group here we are going to go

5796
03:51:30,399 --> 03:51:33,040
down and put in the code to print the

5797
03:51:33,040 --> 03:51:34,640
sizes for them

5798
03:51:34,640 --> 03:51:38,239
and this is what we should use

5799
03:51:38,239 --> 03:51:40,399
let's split this on different lines so

5800
03:51:40,399 --> 03:51:43,439
that it is easier on the eyes and again

5801
03:51:43,439 --> 03:51:44,960
if you don't really want to type this

5802
03:51:44,960 --> 03:51:46,960
you can get the code from the length

5803
03:51:46,960 --> 03:51:49,279
resource section you're going to find

5804
03:51:49,279 --> 03:51:51,520
the code here and you can copy and paste

5805
03:51:51,520 --> 03:51:53,680
and really play with us but it is

5806
03:51:53,680 --> 03:51:56,239
helpful to really type these things out

5807
03:51:56,239 --> 03:51:58,960
and really bring these things in muscle

5808
03:51:58,960 --> 03:52:00,960
memory because it's going to help okay

5809
03:52:00,960 --> 03:52:03,600
so we have this and we're going to try

5810
03:52:03,600 --> 03:52:06,960
and run the world task with gcc the

5811
03:52:06,960 --> 03:52:09,199
build is good we're going to go in here

5812
03:52:09,199 --> 03:52:10,720
and run rooster

5813
03:52:10,720 --> 03:52:13,279
and it is going to say long variable is

5814
03:52:13,279 --> 03:52:16,080
four bytes and everything in this group

5815
03:52:16,080 --> 03:52:19,279
is basically going to be four bytes

5816
03:52:19,279 --> 03:52:22,560
in here the last one is this long long

5817
03:52:22,560 --> 03:52:23,439
thing

5818
03:52:23,439 --> 03:52:25,600
it is going to really give you a huge

5819
03:52:25,600 --> 03:52:26,399
range

5820
03:52:26,399 --> 03:52:28,560
for your values you can store in the

5821
03:52:28,560 --> 03:52:31,520
variable but don't really trust my world

5822
03:52:31,520 --> 03:52:33,359
let's try this out so that you can see

5823
03:52:33,359 --> 03:52:35,680
for yourself we are going to go down and

5824
03:52:35,680 --> 03:52:38,000
really put this in so we're going to

5825
03:52:38,000 --> 03:52:40,720
give ourselves some breathing room

5826
03:52:40,720 --> 03:52:42,960
and paste the code in

5827
03:52:42,960 --> 03:52:45,120
so i am going to

5828
03:52:45,120 --> 03:52:47,439
bring this to the next line

5829
03:52:47,439 --> 03:52:50,399
and what we are really doing is printing

5830
03:52:50,399 --> 03:52:53,760
the sizes for the variables that we have

5831
03:52:53,760 --> 03:52:55,520
in this group here

5832
03:52:55,520 --> 03:52:57,120
let's build and see

5833
03:52:57,120 --> 03:52:59,680
if this passes the world

5834
03:52:59,680 --> 03:53:01,680
the world is going to be good

5835
03:53:01,680 --> 03:53:04,000
now we can run rooster

5836
03:53:04,000 --> 03:53:06,160
and we're going to see that long long is

5837
03:53:06,160 --> 03:53:09,199
eight bytes eight bytes gives us a

5838
03:53:09,199 --> 03:53:12,560
really huge range of values okay this is

5839
03:53:12,560 --> 03:53:14,160
really all we set out to do in this

5840
03:53:14,160 --> 03:53:16,080
lecture to learn about these integer

5841
03:53:16,080 --> 03:53:18,640
modifiers they modify the way your

5842
03:53:18,640 --> 03:53:20,880
integer variables behave for example we

5843
03:53:20,880 --> 03:53:23,359
can specify that we only want positive

5844
03:53:23,359 --> 03:53:26,000
numbers all that we want to both store

5845
03:53:26,000 --> 03:53:28,080
positive and negative numbers for that

5846
03:53:28,080 --> 03:53:30,720
you're going to use designed or unsigned

5847
03:53:30,720 --> 03:53:33,359
modifiers you can also shorten or

5848
03:53:33,359 --> 03:53:35,920
lengthen the range of values you can

5849
03:53:35,920 --> 03:53:38,319
store in your variable by using the

5850
03:53:38,319 --> 03:53:41,120
modifiers short and long and from the

5851
03:53:41,120 --> 03:53:43,920
output of a program here you can really

5852
03:53:43,920 --> 03:53:46,239
see all these effects here this is

5853
03:53:46,239 --> 03:53:48,319
really all we set out to do in this

5854
03:53:48,319 --> 03:53:50,560
lecture i hope you found it interesting

5855
03:53:50,560 --> 03:53:52,080
we are going to stop here in this

5856
03:53:52,080 --> 03:53:53,760
lecture in the next one we're going to

5857
03:53:53,760 --> 03:53:56,960
start and learn about fractional numbers

5858
03:53:56,960 --> 03:53:59,600
go ahead and finish up here and meet me

5859
03:53:59,600 --> 03:54:01,199
there in this lecture we're going to

5860
03:54:01,199 --> 03:54:04,399
learn about fractional numbers and as we

5861
03:54:04,399 --> 03:54:06,000
work with these numbers i want you to

5862
03:54:06,000 --> 03:54:08,239
keep in mind that any piece of data you

5863
03:54:08,239 --> 03:54:11,279
work with in your c plus program

5864
03:54:11,279 --> 03:54:13,760
is ultimately going to be stored in the

5865
03:54:13,760 --> 03:54:17,120
form of ones and zeros in memory

5866
03:54:17,120 --> 03:54:18,880
functional number are also called

5867
03:54:18,880 --> 03:54:22,080
floating types in technical terms they

5868
03:54:22,080 --> 03:54:24,479
are used to represent numbers with

5869
03:54:24,479 --> 03:54:27,520
fractional parts in c plus plus and many

5870
03:54:27,520 --> 03:54:30,160
other languages and we have three types

5871
03:54:30,160 --> 03:54:32,319
that we can use in c plus plus we have

5872
03:54:32,319 --> 03:54:33,279
float

5873
03:54:33,279 --> 03:54:35,920
double and long double and the main

5874
03:54:35,920 --> 03:54:39,040
difference is in the size they occupy in

5875
03:54:39,040 --> 03:54:41,920
memory a float takes four bytes a double

5876
03:54:41,920 --> 03:54:44,399
takes eight bytes and the long double

5877
03:54:44,399 --> 03:54:47,760
takes 12 bytes typically so as the size

5878
03:54:47,760 --> 03:54:50,000
goes up you can also notice that the

5879
03:54:50,000 --> 03:54:52,399
precision goes up so what is the

5880
03:54:52,399 --> 03:54:54,880
precision the precision is basically the

5881
03:54:54,880 --> 03:54:58,239
number of bits you can represent with

5882
03:54:58,239 --> 03:55:01,040
that type starting from the number in

5883
03:55:01,040 --> 03:55:03,040
front of the decimal point so if we look

5884
03:55:03,040 --> 03:55:05,359
at this number here we can try and

5885
03:55:05,359 --> 03:55:07,840
figure out its precision so we're going

5886
03:55:07,840 --> 03:55:13,920
to count 1 2 3 4 5 6 7 8 9 10 11 12. the

5887
03:55:13,920 --> 03:55:16,399
precision here is 12.

5888
03:55:16,399 --> 03:55:19,040
if we go back to our table

5889
03:55:19,040 --> 03:55:21,359
we're really not able to represent a

5890
03:55:21,359 --> 03:55:24,319
number like this with a float

5891
03:55:24,319 --> 03:55:26,399
the smallest thing we can use to

5892
03:55:26,399 --> 03:55:28,720
represent this number well

5893
03:55:28,720 --> 03:55:32,080
is a double because the precision is 15

5894
03:55:32,080 --> 03:55:34,319
and it is more than what we need for

5895
03:55:34,319 --> 03:55:36,479
this number which is 12. one thing you

5896
03:55:36,479 --> 03:55:38,560
should remember is that the number in

5897
03:55:38,560 --> 03:55:40,479
front of the decimal point is also

5898
03:55:40,479 --> 03:55:42,640
counted then when you are trying to

5899
03:55:42,640 --> 03:55:44,640
figure out the precision for your

5900
03:55:44,640 --> 03:55:48,000
floating point numbers in c plus plus so

5901
03:55:48,000 --> 03:55:50,800
here we have an example of how we can

5902
03:55:50,800 --> 03:55:53,359
declare and initialize floating point

5903
03:55:53,359 --> 03:55:56,160
numbers in our c plus plus program

5904
03:55:56,160 --> 03:55:58,960
number one is a really huge number so

5905
03:55:58,960 --> 03:56:01,120
you can guess that this is more than we

5906
03:56:01,120 --> 03:56:03,439
can handle with the float we're going to

5907
03:56:03,439 --> 03:56:06,640
see how this is handled by our compiler

5908
03:56:06,640 --> 03:56:10,800
a double has a precision of 15 so we

5909
03:56:10,800 --> 03:56:12,960
should expect to store more numbers than

5910
03:56:12,960 --> 03:56:15,600
we did in a float a long double should

5911
03:56:15,600 --> 03:56:18,399
be able to handle this without a problem

5912
03:56:18,399 --> 03:56:21,439
because if we go back to our table here

5913
03:56:21,439 --> 03:56:23,680
our long double here should be able to

5914
03:56:23,680 --> 03:56:26,960
handle this better than double but it is

5915
03:56:26,960 --> 03:56:29,279
possible that it is the same thing as

5916
03:56:29,279 --> 03:56:31,680
double depending on the compiler

5917
03:56:31,680 --> 03:56:33,920
implementation and if we try to print

5918
03:56:33,920 --> 03:56:35,600
out the sizes here we're going to see

5919
03:56:35,600 --> 03:56:37,760
what the compiler gives us we're going

5920
03:56:37,760 --> 03:56:40,080
to do this when we try this in visual

5921
03:56:40,080 --> 03:56:42,479
studio code okay and here we are trying

5922
03:56:42,479 --> 03:56:44,880
to print out the precision of these

5923
03:56:44,880 --> 03:56:49,840
numbers we can use a special setting on

5924
03:56:49,840 --> 03:56:53,199
our stream to control the maximum

5925
03:56:53,199 --> 03:56:55,359
precision that we can see here you see

5926
03:56:55,359 --> 03:56:57,439
that we are trying to show the precision

5927
03:56:57,439 --> 03:56:59,359
for each number there is a special

5928
03:56:59,359 --> 03:57:02,720
setting we can put on stdc out to make

5929
03:57:02,720 --> 03:57:04,880
it control the precision to a given

5930
03:57:04,880 --> 03:57:07,520
number here we are using 20 and we're

5931
03:57:07,520 --> 03:57:09,279
going to see that for number one this is

5932
03:57:09,279 --> 03:57:12,080
going to be seven digits for number two

5933
03:57:12,080 --> 03:57:14,479
it should be 15 digits or something

5934
03:57:14,479 --> 03:57:16,800
close to that the specifics are really

5935
03:57:16,800 --> 03:57:19,439
dependent on the compiler implementation

5936
03:57:19,439 --> 03:57:22,239
and for long double it should at least

5937
03:57:22,239 --> 03:57:24,960
be the same as double or even more in

5938
03:57:24,960 --> 03:57:27,520
some cases okay here we want to see that

5939
03:57:27,520 --> 03:57:30,319
we can also have narrowing errors

5940
03:57:30,319 --> 03:57:32,800
if we try to store something back in a

5941
03:57:32,800 --> 03:57:35,760
float and a float can't really handle it

5942
03:57:35,760 --> 03:57:38,399
here we have a number with a lot of

5943
03:57:38,399 --> 03:57:41,840
digits one two three four five six seven

5944
03:57:41,840 --> 03:57:44,640
eight nine and we know that the float

5945
03:57:44,640 --> 03:57:47,439
can only handle seven digits so

5946
03:57:47,439 --> 03:57:48,960
this is probably going to give us a

5947
03:57:48,960 --> 03:57:51,880
compiler error as we've seen for breast

5948
03:57:51,880 --> 03:57:54,800
initialization if we use functional

5949
03:57:54,800 --> 03:57:56,960
initialization this problem is not going

5950
03:57:56,960 --> 03:58:00,080
to be code at compile time so we're

5951
03:58:00,080 --> 03:58:02,399
going to end up with a chunked piece of

5952
03:58:02,399 --> 03:58:04,399
data and we're going to see this when we

5953
03:58:04,399 --> 03:58:06,880
play with this with visual studio code

5954
03:58:06,880 --> 03:58:09,040
and another format we can use with

5955
03:58:09,040 --> 03:58:11,920
floating points is that we can use

5956
03:58:11,920 --> 03:58:15,279
scientific notation and it is basically

5957
03:58:15,279 --> 03:58:18,479
a way we can use a power of 10

5958
03:58:18,479 --> 03:58:22,000
multiplier to multiply with our floating

5959
03:58:22,000 --> 03:58:24,479
point number so for example here number

5960
03:58:24,479 --> 03:58:28,160
5 is going to be this number 1 9 2 4 0 0

5961
03:58:28,160 --> 03:58:31,920
0 23 we can use a floating point

5962
03:58:31,920 --> 03:58:34,880
scientific notation to represent this

5963
03:58:34,880 --> 03:58:36,560
so what we're going to do we're going to

5964
03:58:36,560 --> 03:58:40,319
say 1.9 and we're going to multiply this

5965
03:58:40,319 --> 03:58:42,960
with 10 to the power of 8. this is what

5966
03:58:42,960 --> 03:58:47,760
this means this 8 here means to multiply

5967
03:58:47,760 --> 03:58:50,479
with 10 to the power of 8. and if we

5968
03:58:50,479 --> 03:58:52,880
multiply with that that basically means

5969
03:58:52,880 --> 03:58:55,840
moving the decimal point 8 digits to the

5970
03:58:55,840 --> 03:58:59,840
right so we can go one two three four

5971
03:58:59,840 --> 03:59:02,640
five six seven eight and it is going to

5972
03:59:02,640 --> 03:59:05,439
end at these three here and it is going

5973
03:59:05,439 --> 03:59:07,439
to be basically the same number number

5974
03:59:07,439 --> 03:59:09,920
seven is also another one and if we do

5975
03:59:09,920 --> 03:59:12,160
this we're going to pad with zeros after

5976
03:59:12,160 --> 03:59:14,800
these four and we're going to end up at

5977
03:59:14,800 --> 03:59:17,439
this same location as the three but it

5978
03:59:17,439 --> 03:59:18,960
is going to be a zero we're going to see

5979
03:59:18,960 --> 03:59:21,760
about that in a minute and number eight

5980
03:59:21,760 --> 03:59:24,160
is another floating point number and we

5981
03:59:24,160 --> 03:59:27,359
can use scientific notation to represent

5982
03:59:27,359 --> 03:59:30,560
it just like you see with number nine

5983
03:59:30,560 --> 03:59:32,160
we're basically going to have the same

5984
03:59:32,160 --> 03:59:34,479
thing when we have a minus in here it

5985
03:59:34,479 --> 03:59:37,120
means we're going to multiply with 10 to

5986
03:59:37,120 --> 03:59:40,319
the power of minus 11 and this is going

5987
03:59:40,319 --> 03:59:43,520
to give us a number below one thing zero

5988
03:59:43,520 --> 03:59:45,840
point zero zero seven or something like

5989
03:59:45,840 --> 03:59:48,479
that so we're going to go 11 digits

5990
03:59:48,479 --> 03:59:51,840
after the zero here and if we count one

5991
03:59:51,840 --> 03:59:57,600
two three four 5 6 7 8 9 10 11 and the

5992
03:59:57,600 --> 04:00:00,479
decimal point is going to go after three

5993
04:00:00,479 --> 04:00:02,319
and we're going to basically end up with

5994
04:00:02,319 --> 04:00:04,160
the same thing here we're going to play

5995
04:00:04,160 --> 04:00:05,520
with this in a minute and you're going

5996
04:00:05,520 --> 04:00:07,680
to see that all this makes sense and

5997
04:00:07,680 --> 04:00:09,920
don't forget that any piece of data we

5998
04:00:09,920 --> 04:00:12,160
store in a computer is going to be

5999
04:00:12,160 --> 04:00:15,600
ultimately represented by ones and zeros

6000
04:00:15,600 --> 04:00:18,319
in memory and for floating points we

6001
04:00:18,319 --> 04:00:20,720
don't use the number systems like we've

6002
04:00:20,720 --> 04:00:22,800
done for integers there is a special

6003
04:00:22,800 --> 04:00:25,680
system that is used to do that but it is

6004
04:00:25,680 --> 04:00:27,760
a little bit complicated to cover in a

6005
04:00:27,760 --> 04:00:29,920
course like this i am just going to

6006
04:00:29,920 --> 04:00:32,239
point you to it if you are interested

6007
04:00:32,239 --> 04:00:34,000
and when you are done with this course

6008
04:00:34,000 --> 04:00:36,319
you can come up and read on this the

6009
04:00:36,319 --> 04:00:38,399
main point is that any piece of data

6010
04:00:38,399 --> 04:00:40,560
that you represent in your c plus plus

6011
04:00:40,560 --> 04:00:43,120
program is going to be represented in

6012
04:00:43,120 --> 04:00:46,479
terms of ones and zeros in the memory of

6013
04:00:46,479 --> 04:00:48,399
your computer okay there are a few

6014
04:00:48,399 --> 04:00:50,720
things you can do with floating points

6015
04:00:50,720 --> 04:00:53,040
that you can't really do with integers

6016
04:00:53,040 --> 04:00:56,080
for example you can divide with zero if

6017
04:00:56,080 --> 04:00:58,239
you take a floating point number and

6018
04:00:58,239 --> 04:01:00,479
divide that with zero you're going to

6019
04:01:00,479 --> 04:01:03,279
get what we call infinity if the number

6020
04:01:03,279 --> 04:01:05,040
is positive you're going to get positive

6021
04:01:05,040 --> 04:01:06,800
infinity if the number is negative

6022
04:01:06,800 --> 04:01:09,199
you're going to get negative infinity

6023
04:01:09,199 --> 04:01:11,359
and you can take two floating point

6024
04:01:11,359 --> 04:01:14,239
numbers that are zeros and divide them

6025
04:01:14,239 --> 04:01:15,680
and what you're going to get really is

6026
04:01:15,680 --> 04:01:18,160
not a number it's something called nan

6027
04:01:18,160 --> 04:01:20,399
which stands for naughty number

6028
04:01:20,399 --> 04:01:23,120
and uh your program is going to not

6029
04:01:23,120 --> 04:01:25,600
crash but very few things you can't do

6030
04:01:25,600 --> 04:01:27,040
with these things for example you can't

6031
04:01:27,040 --> 04:01:29,040
add them up you shouldn't really do this

6032
04:01:29,040 --> 04:01:31,520
it's probably going to end up bad for

6033
04:01:31,520 --> 04:01:34,640
your program here we have a few examples

6034
04:01:34,640 --> 04:01:37,040
we have three numbers declared they are

6035
04:01:37,040 --> 04:01:39,359
doubles they must be occupying eight

6036
04:01:39,359 --> 04:01:42,560
bytes in memory number 10 is initialized

6037
04:01:42,560 --> 04:01:46,080
to 5.6 11 is initialized to zero because

6038
04:01:46,080 --> 04:01:48,880
we are using the braced initialization

6039
04:01:48,880 --> 04:01:50,880
and we have nothing in here

6040
04:01:50,880 --> 04:01:53,680
and infinity here is the result of

6041
04:01:53,680 --> 04:01:56,479
dividing a number by zero so it's going

6042
04:01:56,479 --> 04:01:59,359
to be positive infinity because number

6043
04:01:59,359 --> 04:02:01,920
10 is a positive number if you go down

6044
04:02:01,920 --> 04:02:04,160
we're going to print number 10 divided

6045
04:02:04,160 --> 04:02:06,479
by number 11 and we're going to say

6046
04:02:06,479 --> 04:02:08,640
yields we're going to put the result out

6047
04:02:08,640 --> 04:02:10,880
we're going to see that down here on the

6048
04:02:10,880 --> 04:02:12,560
second line you see that we are trying

6049
04:02:12,560 --> 04:02:14,720
to add something to infinity and this is

6050
04:02:14,720 --> 04:02:17,600
also going to yield infinity because

6051
04:02:17,600 --> 04:02:21,120
think of infinity as something super big

6052
04:02:21,120 --> 04:02:23,120
and if you add something small to

6053
04:02:23,120 --> 04:02:24,800
something big it's still going to be

6054
04:02:24,800 --> 04:02:26,640
something big down here you see that

6055
04:02:26,640 --> 04:02:29,199
result equals number 11 divided by

6056
04:02:29,199 --> 04:02:31,760
number 12 and these two are zeros so

6057
04:02:31,760 --> 04:02:33,520
we're going to end up with none and

6058
04:02:33,520 --> 04:02:35,520
that's what we're going to print in this

6059
04:02:35,520 --> 04:02:37,120
statement here

6060
04:02:37,120 --> 04:02:39,520
down to the bottom okay you should

6061
04:02:39,520 --> 04:02:41,600
really remember to put in the suffixes

6062
04:02:41,600 --> 04:02:44,000
when you are initializing your floating

6063
04:02:44,000 --> 04:02:46,880
point numbers otherwise the default is

6064
04:02:46,880 --> 04:02:49,040
going to be double this is what we mean

6065
04:02:49,040 --> 04:02:51,600
by this you see this floating number we

6066
04:02:51,600 --> 04:02:54,319
have a suffix that is f to mean that it

6067
04:02:54,319 --> 04:02:56,399
is a floating number if you don't put

6068
04:02:56,399 --> 04:02:58,640
that in this is going to be interpreted

6069
04:02:58,640 --> 04:03:00,880
as double and the compiler is going to

6070
04:03:00,880 --> 04:03:03,279
try and turn that into a float by

6071
04:03:03,279 --> 04:03:05,199
chopping off things that can't really

6072
04:03:05,199 --> 04:03:07,439
fit in a float so to really make it

6073
04:03:07,439 --> 04:03:09,359
clear that you are stirring in and

6074
04:03:09,359 --> 04:03:12,239
loading number please put this f suffix

6075
04:03:12,239 --> 04:03:13,920
here for double you don't need to put

6076
04:03:13,920 --> 04:03:16,880
anything because it is the default

6077
04:03:16,880 --> 04:03:19,520
assumed by the compiler but for a long

6078
04:03:19,520 --> 04:03:22,160
double you have to suffix this with l

6079
04:03:22,160 --> 04:03:24,560
just like this so that's what we really

6080
04:03:24,560 --> 04:03:26,319
mean here we have seen that the

6081
04:03:26,319 --> 04:03:29,120
precision for float isn't really enough

6082
04:03:29,120 --> 04:03:31,600
for many of the computations we might

6083
04:03:31,600 --> 04:03:33,840
want to do in our c plus plus

6084
04:03:33,840 --> 04:03:36,479
applications okay we have talked a lot

6085
04:03:36,479 --> 04:03:39,040
about floating point numbers let's head

6086
04:03:39,040 --> 04:03:41,359
to visual studio code and actually play

6087
04:03:41,359 --> 04:03:44,319
with them okay here we are in our folder

6088
04:03:44,319 --> 04:03:46,319
that is going to contain our project the

6089
04:03:46,319 --> 04:03:48,160
project is going to be called fractional

6090
04:03:48,160 --> 04:03:51,600
numbers so we're going to copy our files

6091
04:03:51,600 --> 04:03:53,279
go up a little bit

6092
04:03:53,279 --> 04:03:55,760
and put those in and i'm going to go up

6093
04:03:55,760 --> 04:03:58,160
again and open this in visual studio

6094
04:03:58,160 --> 04:04:00,000
code we're going to close whatever it is

6095
04:04:00,000 --> 04:04:02,720
we have opened now we're going to close

6096
04:04:02,720 --> 04:04:04,720
folder and we're going to open our

6097
04:04:04,720 --> 04:04:07,279
project in visual studio code and we're

6098
04:04:07,279 --> 04:04:09,199
going to do the usual and remove things

6099
04:04:09,199 --> 04:04:11,439
we don't need in here the first thing we

6100
04:04:11,439 --> 04:04:14,160
want to do is to store a few floats in

6101
04:04:14,160 --> 04:04:16,640
our program we're going to declare and

6102
04:04:16,640 --> 04:04:18,880
initialize a few floating point numbers

6103
04:04:18,880 --> 04:04:20,960
we have number one number two and number

6104
04:04:20,960 --> 04:04:23,680
three and we want to make it clear that

6105
04:04:23,680 --> 04:04:26,160
the sizes are what we expect we are

6106
04:04:26,160 --> 04:04:28,479
going to open a terminal window here and

6107
04:04:28,479 --> 04:04:31,120
we're going to build with gcc run the

6108
04:04:31,120 --> 04:04:34,000
task to weld with gcc the world is going

6109
04:04:34,000 --> 04:04:36,160
to be successful we're going to come to

6110
04:04:36,160 --> 04:04:37,920
our terminal click a little bit and

6111
04:04:37,920 --> 04:04:39,600
we're going to type dir we're going to

6112
04:04:39,600 --> 04:04:42,239
see that a program is in place if we run

6113
04:04:42,239 --> 04:04:44,479
it we are going to see that size of

6114
04:04:44,479 --> 04:04:48,399
float is 4 size of double is eight and

6115
04:04:48,399 --> 04:04:51,760
size of long double is 16. this is what

6116
04:04:51,760 --> 04:04:54,160
we expected another thing we can do is

6117
04:04:54,160 --> 04:04:57,040
try and play with the precision of these

6118
04:04:57,040 --> 04:04:59,600
numbers and see what we can really go

6119
04:04:59,600 --> 04:05:01,439
away with okay so we're going to

6120
04:05:01,439 --> 04:05:04,080
actually put in a piece of code to play

6121
04:05:04,080 --> 04:05:06,239
with this we're going to add a setting

6122
04:05:06,239 --> 04:05:09,279
to our sddc out stream so that we can

6123
04:05:09,279 --> 04:05:11,520
control the precision but for this to

6124
04:05:11,520 --> 04:05:14,000
work we need to bring in a library that

6125
04:05:14,000 --> 04:05:17,040
is called i o manip so we're going to

6126
04:05:17,040 --> 04:05:20,399
include that i o manip and how do i know

6127
04:05:20,399 --> 04:05:22,640
this i usually consult the c plus plus

6128
04:05:22,640 --> 04:05:25,600
standard library documentation and you

6129
04:05:25,600 --> 04:05:27,199
are not at the point where you can

6130
04:05:27,199 --> 04:05:29,600
really understand it right now so we're

6131
04:05:29,600 --> 04:05:32,720
going to be putting in these things here

6132
04:05:32,720 --> 04:05:35,040
and explaining them as we go and i made

6133
04:05:35,040 --> 04:05:38,319
the type here it is io manip and you see

6134
04:05:38,319 --> 04:05:39,120
that

6135
04:05:39,120 --> 04:05:41,120
now this is recognized our program

6136
04:05:41,120 --> 04:05:43,680
should compile so we're going to try and

6137
04:05:43,680 --> 04:05:45,520
weld it so that we can try this out

6138
04:05:45,520 --> 04:05:47,840
we're going to build with gcc the world

6139
04:05:47,840 --> 04:05:49,920
is going to go through we can run our

6140
04:05:49,920 --> 04:05:52,479
program we're going to do dur and clear

6141
04:05:52,479 --> 04:05:55,040
and rooster to run you see that things

6142
04:05:55,040 --> 04:05:57,840
start to go off at sex and if we count

6143
04:05:57,840 --> 04:06:01,120
what we have here it is one two three

6144
04:06:01,120 --> 04:06:03,520
four five six seven we can only

6145
04:06:03,520 --> 04:06:07,040
represent seven numbers accurately with

6146
04:06:07,040 --> 04:06:09,120
a float and after that we're just going

6147
04:06:09,120 --> 04:06:11,120
to have garbage because the computer

6148
04:06:11,120 --> 04:06:13,199
can't really make sense of whatever we

6149
04:06:13,199 --> 04:06:15,120
have after our

6150
04:06:15,120 --> 04:06:17,359
seven digits that we can legally

6151
04:06:17,359 --> 04:06:19,199
represent with the flood so the

6152
04:06:19,199 --> 04:06:21,359
precision for our floating point number

6153
04:06:21,359 --> 04:06:23,920
here is seven i really hope this makes

6154
04:06:23,920 --> 04:06:26,479
sense let's check out number two

6155
04:06:26,479 --> 04:06:29,279
we are using double so precision should

6156
04:06:29,279 --> 04:06:32,640
be around something like 15. so we are

6157
04:06:32,640 --> 04:06:35,279
putting in a number one through nine and

6158
04:06:35,279 --> 04:06:37,439
we are starting over zero one two three

6159
04:06:37,439 --> 04:06:40,479
four five up to zero again if we look at

6160
04:06:40,479 --> 04:06:43,439
what we have in the output here we have

6161
04:06:43,439 --> 04:06:45,600
one two three four five six seven eight

6162
04:06:45,600 --> 04:06:47,040
nine zero

6163
04:06:47,040 --> 04:06:48,720
one two three

6164
04:06:48,720 --> 04:06:52,000
four five six and here things start

6165
04:06:52,000 --> 04:06:54,880
falling off after our sixth year and if

6166
04:06:54,880 --> 04:06:59,760
we count we're going to have 1 2 3 4 5 6

6167
04:06:59,760 --> 04:07:07,040
7 8 9 10 11 12 13 14 15 16 17 digits

6168
04:07:07,040 --> 04:07:09,120
this is the precision we are having this

6169
04:07:09,120 --> 04:07:12,160
compiler for double 17 so it is

6170
04:07:12,160 --> 04:07:14,960
something around 15 and we should expect

6171
04:07:14,960 --> 04:07:17,439
to have something more than that or at

6172
04:07:17,439 --> 04:07:20,319
least the same thing as double with long

6173
04:07:20,319 --> 04:07:23,040
double so if we look at this you see

6174
04:07:23,040 --> 04:07:25,359
that it is one two three four five six

6175
04:07:25,359 --> 04:07:28,239
seven eight nine zero one two three four

6176
04:07:28,239 --> 04:07:32,239
five six seven eight nine we are able to

6177
04:07:32,239 --> 04:07:36,000
represent up to 20 and you can see that

6178
04:07:36,000 --> 04:07:38,159
long double leaves up to even the

6179
04:07:38,159 --> 04:07:41,680
precision of 20 that we have set with

6180
04:07:41,680 --> 04:07:44,239
std set precision here okay i really

6181
04:07:44,239 --> 04:07:46,479
hope now that you have an idea about

6182
04:07:46,479 --> 04:07:48,640
these precisions we have with our

6183
04:07:48,640 --> 04:07:51,680
floating point types in c plus plus

6184
04:07:51,680 --> 04:07:54,560
programs another thing i want you to see

6185
04:07:54,560 --> 04:07:55,359
is

6186
04:07:55,359 --> 04:07:58,239
what kind of narrowing errors we can get

6187
04:07:58,239 --> 04:08:01,199
if we try to initialize with something

6188
04:08:01,199 --> 04:08:03,439
that can't really be represented by a

6189
04:08:03,439 --> 04:08:05,760
floating point number and here we have a

6190
04:08:05,760 --> 04:08:08,319
float it is called number four and we

6191
04:08:08,319 --> 04:08:10,159
are trying to put in something that is

6192
04:08:10,159 --> 04:08:12,560
bigger than we can really fit in it has

6193
04:08:12,560 --> 04:08:15,520
more than seven digits so one two three

6194
04:08:15,520 --> 04:08:18,800
four five six seven eight nine it is

6195
04:08:18,800 --> 04:08:21,120
more than seven digits and we would

6196
04:08:21,120 --> 04:08:23,040
expect to have a problem with this

6197
04:08:23,040 --> 04:08:24,840
because we are using braced

6198
04:08:24,840 --> 04:08:27,920
initialization let's try and build this

6199
04:08:27,920 --> 04:08:30,720
with gcc we're going to do that and this

6200
04:08:30,720 --> 04:08:32,800
is going to work successfully so this is

6201
04:08:32,800 --> 04:08:35,760
going to silently chop off our number if

6202
04:08:35,760 --> 04:08:37,439
we try to print it out we're going to

6203
04:08:37,439 --> 04:08:40,960
say sddc out number four and we're going

6204
04:08:40,960 --> 04:08:43,120
to world again run the test tube world

6205
04:08:43,120 --> 04:08:45,760
so that our changes are taken into

6206
04:08:45,760 --> 04:08:47,920
effect i'm going to do dur and do

6207
04:08:47,920 --> 04:08:49,840
rooster and this is going to print our

6208
04:08:49,840 --> 04:08:52,000
number you're going to see that after

6209
04:08:52,000 --> 04:08:53,359
the zeros

6210
04:08:53,359 --> 04:08:55,199
we have junk our number has been

6211
04:08:55,199 --> 04:08:57,760
basically chopped off and this is junk

6212
04:08:57,760 --> 04:08:59,680
because we can't really represent this

6213
04:08:59,680 --> 04:09:02,000
with the double the 16 here has been

6214
04:09:02,000 --> 04:09:03,760
chopped off because we can't basically

6215
04:09:03,760 --> 04:09:05,840
represent this with the floating point

6216
04:09:05,840 --> 04:09:08,000
number if we change this to double this

6217
04:09:08,000 --> 04:09:10,239
is going to probably give us what we

6218
04:09:10,239 --> 04:09:13,279
expect so let's run again world with gcc

6219
04:09:13,279 --> 04:09:15,199
the world is going to be good if we run

6220
04:09:15,199 --> 04:09:17,760
the program it is going to show us the

6221
04:09:17,760 --> 04:09:19,840
same thing okay this is a really good

6222
04:09:19,840 --> 04:09:22,080
learning change why are we having the

6223
04:09:22,080 --> 04:09:24,239
same results as

6224
04:09:24,239 --> 04:09:27,439
before even if we changed the type to

6225
04:09:27,439 --> 04:09:29,920
double try to think about it the reason

6226
04:09:29,920 --> 04:09:34,000
is the suffix here is still saying f and

6227
04:09:34,000 --> 04:09:36,239
this is going to be stored as float in

6228
04:09:36,239 --> 04:09:38,720
memory so if we want this to really be

6229
04:09:38,720 --> 04:09:41,199
treated like a double we can take out

6230
04:09:41,199 --> 04:09:42,479
the float here

6231
04:09:42,479 --> 04:09:44,560
and if we build again and run the

6232
04:09:44,560 --> 04:09:46,479
application now you're going to see that

6233
04:09:46,479 --> 04:09:49,520
we see the 23 this is basically being

6234
04:09:49,520 --> 04:09:52,319
correctly stored as a double this is a

6235
04:09:52,319 --> 04:09:53,840
really good thing you should keep in

6236
04:09:53,840 --> 04:09:56,800
mind if you don't put in your suffixes

6237
04:09:56,800 --> 04:09:58,399
here the number is going to be

6238
04:09:58,399 --> 04:10:00,560
interpreted as double

6239
04:10:00,560 --> 04:10:03,439
by now i hope you see that if you really

6240
04:10:03,439 --> 04:10:06,399
try to put more than your floating point

6241
04:10:06,399 --> 04:10:07,920
can handle

6242
04:10:07,920 --> 04:10:09,920
the number is going to be chopped off

6243
04:10:09,920 --> 04:10:12,399
and only the precision that it can

6244
04:10:12,399 --> 04:10:14,640
handle is going to be stored in i hope

6245
04:10:14,640 --> 04:10:16,960
this makes sense and you see that the

6246
04:10:16,960 --> 04:10:19,279
behavior for numbers is really different

6247
04:10:19,279 --> 04:10:22,080
we got the compiler error when we try to

6248
04:10:22,080 --> 04:10:24,720
do narrowing conversion with integers

6249
04:10:24,720 --> 04:10:27,199
but now it is silently chopping off our

6250
04:10:27,199 --> 04:10:29,680
number if we try and use functional

6251
04:10:29,680 --> 04:10:31,520
notation i think we're going to get the

6252
04:10:31,520 --> 04:10:34,560
same result and change this back to a

6253
04:10:34,560 --> 04:10:37,520
float and uh use float here and if we

6254
04:10:37,520 --> 04:10:40,640
both again let's go to terminal run task

6255
04:10:40,640 --> 04:10:43,920
use gcc we're going to run this

6256
04:10:43,920 --> 04:10:46,239
let's run rooster and you see that we

6257
04:10:46,239 --> 04:10:49,279
get the same results our 23 is chopped

6258
04:10:49,279 --> 04:10:52,080
off here we can also use the assignment

6259
04:10:52,080 --> 04:10:54,080
notation here just like we did with

6260
04:10:54,080 --> 04:10:57,199
integers and this is going to do exactly

6261
04:10:57,199 --> 04:10:59,040
the same thing it is going to chop off

6262
04:10:59,040 --> 04:11:01,520
the 23 here and we're going to have some

6263
04:11:01,520 --> 04:11:04,479
garbage which is 16 in this case if we

6264
04:11:04,479 --> 04:11:06,319
weld the gun the world is going to go

6265
04:11:06,319 --> 04:11:08,800
through and if we run we're going to see

6266
04:11:08,800 --> 04:11:10,880
as it's in here okay narrowing

6267
04:11:10,880 --> 04:11:12,880
conversions are something you should be

6268
04:11:12,880 --> 04:11:15,439
aware of when storing your floating

6269
04:11:15,439 --> 04:11:17,279
point numbers and you should really

6270
04:11:17,279 --> 04:11:19,680
remember to put in your suffixes here

6271
04:11:19,680 --> 04:11:21,920
and other thing we have seen that we

6272
04:11:21,920 --> 04:11:24,159
should really play with is scientific

6273
04:11:24,159 --> 04:11:25,439
notation

6274
04:11:25,439 --> 04:11:27,359
as the comment here says what we have

6275
04:11:27,359 --> 04:11:31,199
seen so far in floating point numbers is

6276
04:11:31,199 --> 04:11:33,920
fixed notation it is what we have here

6277
04:11:33,920 --> 04:11:37,040
but we can also use scientific notation

6278
04:11:37,040 --> 04:11:39,199
which is exactly what we described in

6279
04:11:39,199 --> 04:11:41,680
the slides and what we have here for

6280
04:11:41,680 --> 04:11:45,600
example is e8 and it means that we are

6281
04:11:45,600 --> 04:11:48,399
going to multiply this number here

6282
04:11:48,399 --> 04:11:51,279
with 10 to the power of 8. if you go

6283
04:11:51,279 --> 04:11:53,680
down here we have number 9 so we have

6284
04:11:53,680 --> 04:11:56,479
3.498

6285
04:11:56,479 --> 04:12:00,000
and we have e minus 11 and what this is

6286
04:12:00,000 --> 04:12:02,880
going to do is multiply with 10 to the

6287
04:12:02,880 --> 04:12:05,840
power of minus 11. this is how i can

6288
04:12:05,840 --> 04:12:08,080
represent this here and we can print

6289
04:12:08,080 --> 04:12:10,000
these numbers out to really play with

6290
04:12:10,000 --> 04:12:12,239
them to make a difference with what we

6291
04:12:12,239 --> 04:12:14,560
have been doing before we're going to do

6292
04:12:14,560 --> 04:12:18,319
sddc out and put a dividing line here

6293
04:12:18,319 --> 04:12:20,159
this is one way we can do this so we're

6294
04:12:20,159 --> 04:12:22,560
going to do stdndl

6295
04:12:22,560 --> 04:12:24,399
we're going to weld this so we're going

6296
04:12:24,399 --> 04:12:27,520
to run the attached world with gcc 10

6297
04:12:27,520 --> 04:12:29,600
the world is going to go through if we

6298
04:12:29,600 --> 04:12:32,159
do rooster we're going to see that our

6299
04:12:32,159 --> 04:12:35,120
number here number five is what we

6300
04:12:35,120 --> 04:12:39,279
expect number six is the same thing but

6301
04:12:39,279 --> 04:12:42,399
we used scientific notation to do this

6302
04:12:42,399 --> 04:12:44,080
because we took this number and

6303
04:12:44,080 --> 04:12:46,880
multiplied by 10 to the power of eight

6304
04:12:46,880 --> 04:12:48,800
number seven should be almost the same

6305
04:12:48,800 --> 04:12:51,840
thing but the lower 23 here is going to

6306
04:12:51,840 --> 04:12:54,080
be chopped off because we haven't

6307
04:12:54,080 --> 04:12:56,239
specified it we're just multiplying with

6308
04:12:56,239 --> 04:12:58,560
10 to the power of 8 so that's why we

6309
04:12:58,560 --> 04:13:01,920
have 0 0 here i hope that makes sense

6310
04:13:01,920 --> 04:13:04,159
and if you look at number 8 you see that

6311
04:13:04,159 --> 04:13:06,159
we stored it like this without using

6312
04:13:06,159 --> 04:13:08,560
scientific notation we used fixed

6313
04:13:08,560 --> 04:13:11,120
notation but on the terminal it's going

6314
04:13:11,120 --> 04:13:13,920
to be printed out in scientific notation

6315
04:13:13,920 --> 04:13:15,920
and this may be pretty cool the main

6316
04:13:15,920 --> 04:13:19,520
usage for scientific notation is to make

6317
04:13:19,520 --> 04:13:22,479
sense of numbers that are really huge so

6318
04:13:22,479 --> 04:13:24,239
the way you interpret this you're going

6319
04:13:24,239 --> 04:13:25,359
to

6320
04:13:25,359 --> 04:13:27,840
move these numbers after the decimal

6321
04:13:27,840 --> 04:13:30,239
points with 0 in front and it's

6322
04:13:30,239 --> 04:13:32,000
basically going to be like this so if

6323
04:13:32,000 --> 04:13:33,920
you count the zeros you have here we're

6324
04:13:33,920 --> 04:13:36,399
going to have 1 2

6325
04:13:36,399 --> 04:13:42,239
3 4 5 6 7 8 9 10 and 11 is going to be

6326
04:13:42,239 --> 04:13:44,319
directly after three and you're going to

6327
04:13:44,319 --> 04:13:46,560
get the number here this is what we mean

6328
04:13:46,560 --> 04:13:49,760
and number nine was explicitly stored in

6329
04:13:49,760 --> 04:13:52,080
using scientific notation and you see

6330
04:13:52,080 --> 04:13:54,080
that we have the same thing you can play

6331
04:13:54,080 --> 04:13:56,239
with these things and really make sense

6332
04:13:56,239 --> 04:13:59,520
of them and again we didn't specify any

6333
04:13:59,520 --> 04:14:01,680
suffix here so these are going to be

6334
04:14:01,680 --> 04:14:04,319
interpreted as doubles but this is not a

6335
04:14:04,319 --> 04:14:06,640
problem because they are doubles here

6336
04:14:06,640 --> 04:14:08,640
okay we are making some progress with

6337
04:14:08,640 --> 04:14:11,120
this lecture which is a little lengthy

6338
04:14:11,120 --> 04:14:13,040
the last thing we want to do is to play

6339
04:14:13,040 --> 04:14:15,359
with infinity and nan

6340
04:14:15,359 --> 04:14:17,040
we're going to put a message here to say

6341
04:14:17,040 --> 04:14:18,960
what we want to do and we're going to

6342
04:14:18,960 --> 04:14:20,479
have number 10 which is going to be

6343
04:14:20,479 --> 04:14:22,319
positive we're going to have number 11

6344
04:14:22,319 --> 04:14:24,800
which is going to be zero number 12 is

6345
04:14:24,800 --> 04:14:26,560
also going to be zero

6346
04:14:26,560 --> 04:14:30,000
if we take 10 and divide that with 11

6347
04:14:30,000 --> 04:14:32,239
we're going to get infinity because we

6348
04:14:32,239 --> 04:14:35,359
are dividing a floating number with zero

6349
04:14:35,359 --> 04:14:37,040
if we try to print that out we're going

6350
04:14:37,040 --> 04:14:38,560
to get infinity

6351
04:14:38,560 --> 04:14:40,399
and we're going to get infinity for this

6352
04:14:40,399 --> 04:14:42,479
result here because we are trying to add

6353
04:14:42,479 --> 04:14:44,880
something small to infinity which is

6354
04:14:44,880 --> 04:14:47,199
something really big and if we all

6355
04:14:47,199 --> 04:14:49,279
trying to divide zero with zero in

6356
04:14:49,279 --> 04:14:50,479
floating point

6357
04:14:50,479 --> 04:14:52,080
we're going to get what is called

6358
04:14:52,080 --> 04:14:54,080
naughty number and if we print that out

6359
04:14:54,080 --> 04:14:55,920
we're going to see this in a minute

6360
04:14:55,920 --> 04:14:59,920
let's build this with gcc we're going to

6361
04:14:59,920 --> 04:15:02,319
weld successfully let's clear this out

6362
04:15:02,319 --> 04:15:05,439
so that we don't have noise in here and

6363
04:15:05,439 --> 04:15:07,600
we're going to run rooster and you see

6364
04:15:07,600 --> 04:15:11,199
here it says infinity and none which is

6365
04:15:11,199 --> 04:15:12,720
what we said here

6366
04:15:12,720 --> 04:15:14,720
and if we go down here it is saying

6367
04:15:14,720 --> 04:15:17,920
number 10 divided by number 11 and

6368
04:15:17,920 --> 04:15:20,720
number 11 is zero you see that here it's

6369
04:15:20,720 --> 04:15:23,760
going to yield infinity if we add five

6370
04:15:23,760 --> 04:15:26,640
to infinity we're going to get infinity

6371
04:15:26,640 --> 04:15:29,120
and if we try to divide a zero by a zero

6372
04:15:29,120 --> 04:15:31,600
we're going to get none which is really

6373
04:15:31,600 --> 04:15:33,199
a way to tell you that you're doing

6374
04:15:33,199 --> 04:15:34,960
something wrong you should really be

6375
04:15:34,960 --> 04:15:35,920
careful

6376
04:15:35,920 --> 04:15:37,600
one other thing i want you to see is

6377
04:15:37,600 --> 04:15:40,319
that if you turn this five into a minus

6378
04:15:40,319 --> 04:15:42,640
five and build again we're going to

6379
04:15:42,640 --> 04:15:45,279
build with gcc and we're going to run

6380
04:15:45,279 --> 04:15:46,960
this rooster

6381
04:15:46,960 --> 04:15:49,520
we're going to get minus infinity so if

6382
04:15:49,520 --> 04:15:52,239
you divide a positive number with zero

6383
04:15:52,239 --> 04:15:54,319
you're going to get positive infinity

6384
04:15:54,319 --> 04:15:56,479
and if you divide a negative number with

6385
04:15:56,479 --> 04:15:58,319
infinity you're going to get negative

6386
04:15:58,319 --> 04:16:00,800
infinity and this is what we see here

6387
04:16:00,800 --> 04:16:02,399
this is really all we set out to do in

6388
04:16:02,399 --> 04:16:03,920
this lecture i hope you found it

6389
04:16:03,920 --> 04:16:06,399
interesting and again the big message is

6390
04:16:06,399 --> 04:16:08,479
that any data type you're going to be

6391
04:16:08,479 --> 04:16:11,439
handling in your c plus plus program is

6392
04:16:11,439 --> 04:16:13,920
going to ultimately be stored as ones

6393
04:16:13,920 --> 04:16:16,000
and zeros in memory and we have learned

6394
04:16:16,000 --> 04:16:17,920
about floating point numbers float

6395
04:16:17,920 --> 04:16:20,080
double and long and they have these

6396
04:16:20,080 --> 04:16:22,080
properties you see here and you should

6397
04:16:22,080 --> 04:16:24,479
use them with this in mind otherwise

6398
04:16:24,479 --> 04:16:26,319
you're going to have problems with your

6399
04:16:26,319 --> 04:16:28,560
precision make sure you are using the

6400
04:16:28,560 --> 04:16:30,640
correct precision that you need in your

6401
04:16:30,640 --> 04:16:32,640
program we are going to stop here in

6402
04:16:32,640 --> 04:16:34,560
this lecture the next one we're going to

6403
04:16:34,560 --> 04:16:37,520
try and learn about booleans go ahead

6404
04:16:37,520 --> 04:16:40,159
and finish up here and meet me there in

6405
04:16:40,159 --> 04:16:41,840
this lecture we're going to learn about

6406
04:16:41,840 --> 04:16:44,880
booleans booleans are types that can

6407
04:16:44,880 --> 04:16:47,600
store two states in c plus plots it can

6408
04:16:47,600 --> 04:16:51,040
store either true or false and we can

6409
04:16:51,040 --> 04:16:53,359
use this to really do decisions in our

6410
04:16:53,359 --> 04:16:55,279
program if you look in the program we

6411
04:16:55,279 --> 04:16:57,680
have here we have two variables declared

6412
04:16:57,680 --> 04:16:59,840
the data type is bull

6413
04:16:59,840 --> 04:17:02,159
and one is called red light the other is

6414
04:17:02,159 --> 04:17:03,760
called green light

6415
04:17:03,760 --> 04:17:06,720
and we have true and false inside one

6416
04:17:06,720 --> 04:17:09,120
thing we can do in c plus plus is make

6417
04:17:09,120 --> 04:17:12,239
decisions we can say if the red light is

6418
04:17:12,239 --> 04:17:13,439
true we can

6419
04:17:13,439 --> 04:17:16,319
print a message that says stop and if

6420
04:17:16,319 --> 04:17:19,199
it's not red we can print a message that

6421
04:17:19,199 --> 04:17:21,600
says go through we can do that and

6422
04:17:21,600 --> 04:17:24,080
booleans are really used in this way to

6423
04:17:24,080 --> 04:17:26,399
make decisions in your c plus plus

6424
04:17:26,399 --> 04:17:29,040
program we haven't really learned about

6425
04:17:29,040 --> 04:17:31,760
if statements in this course but i am

6426
04:17:31,760 --> 04:17:33,920
throwing this in here to really drive

6427
04:17:33,920 --> 04:17:36,080
the point home that we can use this to

6428
04:17:36,080 --> 04:17:38,640
make decisions in our program down here

6429
04:17:38,640 --> 04:17:40,640
we have another way we can do this we

6430
04:17:40,640 --> 04:17:42,880
can actually use the variable itself

6431
04:17:42,880 --> 04:17:46,239
without checking if it is equal to true

6432
04:17:46,239 --> 04:17:48,479
or false and we are going to get the

6433
04:17:48,479 --> 04:17:50,960
same message the point here is that if

6434
04:17:50,960 --> 04:17:53,040
green light is true we're going to say

6435
04:17:53,040 --> 04:17:55,359
the light is green if it's not we're

6436
04:17:55,359 --> 04:17:57,279
going to say the light is not green you

6437
04:17:57,279 --> 04:17:59,600
can do something like this and again the

6438
04:17:59,600 --> 04:18:02,080
big point here is that booleans data

6439
04:18:02,080 --> 04:18:05,199
types are used to store two states true

6440
04:18:05,199 --> 04:18:07,760
or false in your c plus plus program

6441
04:18:07,760 --> 04:18:11,120
okay by default if you print a boolean

6442
04:18:11,120 --> 04:18:13,520
that has two in it you're going to get

6443
04:18:13,520 --> 04:18:15,680
true and this is what you see here and

6444
04:18:15,680 --> 04:18:18,640
if you print one that has zero in it

6445
04:18:18,640 --> 04:18:20,800
you're going to get false we can change

6446
04:18:20,800 --> 04:18:22,720
that with a special setting that we can

6447
04:18:22,720 --> 04:18:25,840
apply to our std out stream and you do

6448
04:18:25,840 --> 04:18:28,720
that like this with std bull alpha and

6449
04:18:28,720 --> 04:18:29,840
we're going to play with this in a

6450
04:18:29,840 --> 04:18:31,279
minute you're going to see

6451
04:18:31,279 --> 04:18:33,359
if we try to print with this setting

6452
04:18:33,359 --> 04:18:35,920
applied we're going to see true on false

6453
04:18:35,920 --> 04:18:38,880
and not c 0 and 1 like we did before

6454
04:18:38,880 --> 04:18:40,080
we're going to play with this in a

6455
04:18:40,080 --> 04:18:42,159
minute and you're going to see another

6456
04:18:42,159 --> 04:18:44,319
thing you should know is that booleans

6457
04:18:44,319 --> 04:18:45,680
occupy

6458
04:18:45,680 --> 04:18:48,720
8 bits in memory they take up an entire

6459
04:18:48,720 --> 04:18:50,800
bite so you may think that this is

6460
04:18:50,800 --> 04:18:53,520
wasteful and it is but with the amount

6461
04:18:53,520 --> 04:18:55,840
of memory that we have today this is

6462
04:18:55,840 --> 04:18:58,479
really not a big problem but if you are

6463
04:18:58,479 --> 04:19:00,960
working on a device where memory is

6464
04:19:00,960 --> 04:19:03,120
really a problem there are techniques

6465
04:19:03,120 --> 04:19:05,439
you can use to pack even more data in a

6466
04:19:05,439 --> 04:19:07,600
byte and we're going to learn about that

6467
04:19:07,600 --> 04:19:10,080
later in the course okay so this is

6468
04:19:10,080 --> 04:19:12,880
really all i have to say about booleans

6469
04:19:12,880 --> 04:19:14,960
we're going to go to visual studio code

6470
04:19:14,960 --> 04:19:17,680
and play with them in code okay here i

6471
04:19:17,680 --> 04:19:20,640
am in the folder for my project here i

6472
04:19:20,640 --> 04:19:22,560
am going to do the usual and copy the

6473
04:19:22,560 --> 04:19:23,760
files over

6474
04:19:23,760 --> 04:19:26,000
and i am going to go in my project on

6475
04:19:26,000 --> 04:19:28,800
booleans i am going to go up and open

6476
04:19:28,800 --> 04:19:31,040
this up in visual studio code i am going

6477
04:19:31,040 --> 04:19:33,520
to close the current folder open the new

6478
04:19:33,520 --> 04:19:35,920
one and browse to my project this is

6479
04:19:35,920 --> 04:19:38,319
going to open up in visual studio code

6480
04:19:38,319 --> 04:19:40,239
and i am going to close the welcome

6481
04:19:40,239 --> 04:19:42,560
screen here i don't need it anymore

6482
04:19:42,560 --> 04:19:45,279
so i'm going to remove what i don't need

6483
04:19:45,279 --> 04:19:48,000
and we are going to play with the exact

6484
04:19:48,000 --> 04:19:50,720
code that we had in the slides we're

6485
04:19:50,720 --> 04:19:52,880
going to declare two variables one is

6486
04:19:52,880 --> 04:19:54,880
going to be red light the other is going

6487
04:19:54,880 --> 04:19:56,800
to be green light they are going to be

6488
04:19:56,800 --> 04:19:59,199
booleans and in red light we're going to

6489
04:19:59,199 --> 04:20:02,159
store a true and story false in green

6490
04:20:02,159 --> 04:20:04,239
light and we can make a decision like

6491
04:20:04,239 --> 04:20:06,720
this so try to guess what we're going to

6492
04:20:06,720 --> 04:20:09,600
plant in this program we're going to try

6493
04:20:09,600 --> 04:20:12,640
and decide and say if the red light is

6494
04:20:12,640 --> 04:20:14,800
true we're going to print stop

6495
04:20:14,800 --> 04:20:16,800
if it's not true we're going to fall in

6496
04:20:16,800 --> 04:20:19,120
this block here and say

6497
04:20:19,120 --> 04:20:22,319
go through if we look at our program in

6498
04:20:22,319 --> 04:20:25,520
red light we have a true so this should

6499
04:20:25,520 --> 04:20:27,760
really win and we should get in this

6500
04:20:27,760 --> 04:20:30,319
block here i hope this makes sense so

6501
04:20:30,319 --> 04:20:32,479
let's try and build this program to see

6502
04:20:32,479 --> 04:20:34,800
that it actually works so we're going to

6503
04:20:34,800 --> 04:20:36,960
build with the gcc we're going to run

6504
04:20:36,960 --> 04:20:39,600
our program and our terminal just went

6505
04:20:39,600 --> 04:20:41,760
away we're going to create a new one no

6506
04:20:41,760 --> 04:20:43,120
big deal

6507
04:20:43,120 --> 04:20:46,800
and uh if we do dir we're going to see

6508
04:20:46,800 --> 04:20:48,560
rooster.exe

6509
04:20:48,560 --> 04:20:51,600
we run it it's going to say stop okay so

6510
04:20:51,600 --> 04:20:54,800
in red light we have true the test is

6511
04:20:54,800 --> 04:20:56,640
going to succeed here and we're going to

6512
04:20:56,640 --> 04:20:59,199
fall in this block and say stop i hope

6513
04:20:59,199 --> 04:21:01,520
this makes sense you can try to store a

6514
04:21:01,520 --> 04:21:03,120
false in here

6515
04:21:03,120 --> 04:21:06,800
and both again going to world with gcc

6516
04:21:06,800 --> 04:21:09,439
if we run this program now it's going to

6517
04:21:09,439 --> 04:21:12,159
say go through because red light is not

6518
04:21:12,159 --> 04:21:14,399
true anymore this is really what we mean

6519
04:21:14,399 --> 04:21:16,880
when we say that we can make decisions

6520
04:21:16,880 --> 04:21:19,840
based on booleans in our c plus plus

6521
04:21:19,840 --> 04:21:22,880
code we can also try another example

6522
04:21:22,880 --> 04:21:26,000
we're going to say if green light is

6523
04:21:26,000 --> 04:21:26,880
true

6524
04:21:26,880 --> 04:21:28,880
we're going to say the light is green if

6525
04:21:28,880 --> 04:21:30,560
it's not we're going to say the light is

6526
04:21:30,560 --> 04:21:32,399
not green and this is another form we

6527
04:21:32,399 --> 04:21:35,680
can use instead of typing the entire

6528
04:21:35,680 --> 04:21:36,560
thing

6529
04:21:36,560 --> 04:21:39,359
comparing red light to true here and

6530
04:21:39,359 --> 04:21:40,800
again we're going to learn about all

6531
04:21:40,800 --> 04:21:43,040
these comparisons here

6532
04:21:43,040 --> 04:21:45,760
it is just because i thought that

6533
04:21:45,760 --> 04:21:48,000
talking about bulls without showing

6534
04:21:48,000 --> 04:21:50,560
tests like this is really not going to

6535
04:21:50,560 --> 04:21:53,439
drive the point home for you so try to

6536
04:21:53,439 --> 04:21:55,520
understand this as simple tests you can

6537
04:21:55,520 --> 04:21:57,920
do in math if one value is true i am

6538
04:21:57,920 --> 04:21:59,920
going to do something if it's not true

6539
04:21:59,920 --> 04:22:01,840
i'm going to do something else this is

6540
04:22:01,840 --> 04:22:04,000
what we are doing here okay this program

6541
04:22:04,000 --> 04:22:06,159
here is going to check if the green

6542
04:22:06,159 --> 04:22:08,560
light is true so we're going to look

6543
04:22:08,560 --> 04:22:11,120
here green light is not true so we

6544
04:22:11,120 --> 04:22:14,159
should fall here and print this message

6545
04:22:14,159 --> 04:22:16,319
that the light is not green

6546
04:22:16,319 --> 04:22:18,560
let's build the program the world is

6547
04:22:18,560 --> 04:22:20,720
going to go through we're going to run

6548
04:22:20,720 --> 04:22:21,520
this

6549
04:22:21,520 --> 04:22:23,520
and you're going to see go through and

6550
04:22:23,520 --> 04:22:25,760
the light is not green this is what we

6551
04:22:25,760 --> 04:22:27,359
have here another thing we can actually

6552
04:22:27,359 --> 04:22:30,319
try to see is the amount of memory that

6553
04:22:30,319 --> 04:22:33,439
a boolean takes up so we can use sizeof

6554
04:22:33,439 --> 04:22:36,239
to do that we have seen this before if

6555
04:22:36,239 --> 04:22:39,040
we build with gcc we're going to go

6556
04:22:39,040 --> 04:22:39,920
through

6557
04:22:39,920 --> 04:22:42,000
and we can run our program to actually

6558
04:22:42,000 --> 04:22:43,840
this message and you're going to see

6559
04:22:43,840 --> 04:22:46,319
that bull is actually going to take up

6560
04:22:46,319 --> 04:22:48,640
one byte in memory this is what we saw

6561
04:22:48,640 --> 04:22:50,960
in the slides another thing that can be

6562
04:22:50,960 --> 04:22:53,760
really confusing is printing out boolean

6563
04:22:53,760 --> 04:22:56,640
values for example here we are trying to

6564
04:22:56,640 --> 04:22:59,439
print great light and green light let's

6565
04:22:59,439 --> 04:23:01,279
go up and actually change them a little

6566
04:23:01,279 --> 04:23:04,399
bit for example take green light here

6567
04:23:04,399 --> 04:23:06,080
and make it true

6568
04:23:06,080 --> 04:23:08,560
and we're going to go down again and

6569
04:23:08,560 --> 04:23:11,359
here we are trying to print them out red

6570
04:23:11,359 --> 04:23:13,680
light is going to print whatever value

6571
04:23:13,680 --> 04:23:15,920
we have stored then and green light is

6572
04:23:15,920 --> 04:23:17,520
going to store whatever value we have

6573
04:23:17,520 --> 04:23:19,920
stored in and again true is going to be

6574
04:23:19,920 --> 04:23:21,760
printed out as one

6575
04:23:21,760 --> 04:23:24,080
and false is going to be printed out as

6576
04:23:24,080 --> 04:23:26,640
a zero let's try and build this we're

6577
04:23:26,640 --> 04:23:29,840
going to build with our gcc compiler the

6578
04:23:29,840 --> 04:23:31,600
world is going to be good we're going to

6579
04:23:31,600 --> 04:23:33,680
run this and you're going to see that

6580
04:23:33,680 --> 04:23:36,640
red light is zero because we have a full

6581
04:23:36,640 --> 04:23:38,319
sun here

6582
04:23:38,319 --> 04:23:41,040
and green light is going to be one

6583
04:23:41,040 --> 04:23:44,720
because we haven't a true here if you

6584
04:23:44,720 --> 04:23:47,199
try to print out boolean variables

6585
04:23:47,199 --> 04:23:48,960
you're going to get one and zero by

6586
04:23:48,960 --> 04:23:51,600
default if you really want to see true

6587
04:23:51,600 --> 04:23:53,439
and false there is a special setting you

6588
04:23:53,439 --> 04:23:56,399
can apply to htdc out and you do that by

6589
04:23:56,399 --> 04:24:01,040
saying stdc out std bull

6590
04:24:01,040 --> 04:24:03,600
alpha and you do it like this

6591
04:24:03,600 --> 04:24:06,479
and if you try to print again we are

6592
04:24:06,479 --> 04:24:08,479
going to get true and false right now

6593
04:24:08,479 --> 04:24:10,800
okay let's try and print again and we're

6594
04:24:10,800 --> 04:24:13,840
going to work this with gcc and we're

6595
04:24:13,840 --> 04:24:15,279
going to run this

6596
04:24:15,279 --> 04:24:17,840
and now you see that we see red light is

6597
04:24:17,840 --> 04:24:20,399
false green light is true

6598
04:24:20,399 --> 04:24:22,640
this is really all i had to share about

6599
04:24:22,640 --> 04:24:25,760
booleans in this lecture i really hope

6600
04:24:25,760 --> 04:24:28,399
it drives the point home that booleans

6601
04:24:28,399 --> 04:24:30,880
are mostly used in making decisions in

6602
04:24:30,880 --> 04:24:32,640
your program and that's what you're

6603
04:24:32,640 --> 04:24:35,359
going to be mostly using them for and

6604
04:24:35,359 --> 04:24:37,520
another thing is that they take up one

6605
04:24:37,520 --> 04:24:40,479
bite in your memory we are going to stop

6606
04:24:40,479 --> 04:24:42,319
here in this lecture the next one we're

6607
04:24:42,319 --> 04:24:44,880
going to try and learn about characters

6608
04:24:44,880 --> 04:24:46,319
and text

6609
04:24:46,319 --> 04:24:48,720
go ahead and finish up here and meet me

6610
04:24:48,720 --> 04:24:50,479
there in this lecture we're going to

6611
04:24:50,479 --> 04:24:53,279
learn about characters and text and we

6612
04:24:53,279 --> 04:24:56,080
use a data type called car in c plus

6613
04:24:56,080 --> 04:24:58,479
plus to represent characters and this is

6614
04:24:58,479 --> 04:25:00,239
basically how you use it you store in

6615
04:25:00,239 --> 04:25:02,960
characters like abc and here you see

6616
04:25:02,960 --> 04:25:05,199
that we have a r r

6617
04:25:05,199 --> 04:25:08,319
o w and you put your characters in

6618
04:25:08,319 --> 04:25:10,560
single quotes like this to mean that

6619
04:25:10,560 --> 04:25:12,560
they are characters if you don't do that

6620
04:25:12,560 --> 04:25:14,239
you're going to get a compiler error

6621
04:25:14,239 --> 04:25:16,800
after you have your characters declared

6622
04:25:16,800 --> 04:25:19,760
and defined like this you can print them

6623
04:25:19,760 --> 04:25:22,560
out with stdc out and we're going to see

6624
04:25:22,560 --> 04:25:26,399
them on the terminal car occupies one

6625
04:25:26,399 --> 04:25:28,479
byte in memory so it's going to take up

6626
04:25:28,479 --> 04:25:31,279
eight bits okay so one thing we can do

6627
04:25:31,279 --> 04:25:35,760
is map each value in these 256 possible

6628
04:25:35,760 --> 04:25:38,319
values to a character and we can do

6629
04:25:38,319 --> 04:25:40,159
something like this for example we can

6630
04:25:40,159 --> 04:25:41,520
say that

6631
04:25:41,520 --> 04:25:44,800
33 represents the exclamation mark

6632
04:25:44,800 --> 04:25:47,840
48 represents the character 0 49

6633
04:25:47,840 --> 04:25:50,560
represents the character 1 50 represents

6634
04:25:50,560 --> 04:25:53,600
the character 2 and we can keep going up

6635
04:25:53,600 --> 04:25:56,720
and say for example 70 represents f 71

6636
04:25:56,720 --> 04:25:58,319
represents g

6637
04:25:58,319 --> 04:25:59,000
or

6638
04:25:59,000 --> 04:26:02,399
112 represents p you can really use a

6639
04:26:02,399 --> 04:26:05,159
mapping like this and come up with

6640
04:26:05,159 --> 04:26:07,840
representations of your characters in

6641
04:26:07,840 --> 04:26:10,000
memory and this is what we do you can

6642
04:26:10,000 --> 04:26:12,560
learn about this encoding and on the

6643
04:26:12,560 --> 04:26:15,120
link here this is a real thing and it is

6644
04:26:15,120 --> 04:26:18,720
called the ascii encoding that takes

6645
04:26:18,720 --> 04:26:21,600
characters and stores them in one byte

6646
04:26:21,600 --> 04:26:23,520
and the data type to store these

6647
04:26:23,520 --> 04:26:26,640
characters in c plus plus is car if this

6648
04:26:26,640 --> 04:26:28,720
doesn't make sense please bear with me

6649
04:26:28,720 --> 04:26:30,560
we're going to play with this in visual

6650
04:26:30,560 --> 04:26:32,800
studio code and it is most probably

6651
04:26:32,800 --> 04:26:35,279
going to make sense okay it is possible

6652
04:26:35,279 --> 04:26:38,960
to assign a valid ascii code to

6653
04:26:38,960 --> 04:26:41,680
a car variable and the corresponding

6654
04:26:41,680 --> 04:26:44,000
character will be stored in that piece

6655
04:26:44,000 --> 04:26:46,560
of memory so once you have that you can

6656
04:26:46,560 --> 04:26:48,479
choose to interpret that either as a

6657
04:26:48,479 --> 04:26:51,120
character or as a number that is

6658
04:26:51,120 --> 04:26:53,040
something like an integer this is what

6659
04:26:53,040 --> 04:26:55,680
we really mean if we declare a variable

6660
04:26:55,680 --> 04:26:59,199
called value which is of car type 65 is

6661
04:26:59,199 --> 04:27:02,239
going to be stored in memory but the c

6662
04:27:02,239 --> 04:27:04,800
plus plus program is going to interpret

6663
04:27:04,800 --> 04:27:07,840
this as a character if we go back to our

6664
04:27:07,840 --> 04:27:10,880
table and see what is represented by 65

6665
04:27:10,880 --> 04:27:12,239
this is what we're going to find we're

6666
04:27:12,239 --> 04:27:15,840
going to find that 65 represents a

6667
04:27:15,840 --> 04:27:18,080
and if we print this out by default it's

6668
04:27:18,080 --> 04:27:20,159
going to print a it's not going to print

6669
04:27:20,159 --> 04:27:22,800
65 but there is a way you can take this

6670
04:27:22,800 --> 04:27:26,000
character value and turn that into an

6671
04:27:26,000 --> 04:27:28,880
integer and print it out and you see

6672
04:27:28,880 --> 04:27:32,000
that here we are saying value and and we

6673
04:27:32,000 --> 04:27:34,159
are saying static cast

6674
04:27:34,159 --> 04:27:36,880
and and in the parents we have a value

6675
04:27:36,880 --> 04:27:38,960
this is basically a way to say we wanted

6676
04:27:38,960 --> 04:27:42,319
to take the value and interpret that as

6677
04:27:42,319 --> 04:27:44,080
an integer and we're going to learn a

6678
04:27:44,080 --> 04:27:46,399
little more about static cast later in

6679
04:27:46,399 --> 04:27:48,800
the course but it is basically a way to

6680
04:27:48,800 --> 04:27:51,199
transform between data types and in this

6681
04:27:51,199 --> 04:27:54,000
case we are trying to transform from car

6682
04:27:54,000 --> 04:27:56,399
to end and we're going to print this out

6683
04:27:56,399 --> 04:27:59,120
okay what we just described is the ascii

6684
04:27:59,120 --> 04:28:01,680
encoding a technique by which we can map

6685
04:28:01,680 --> 04:28:05,279
the first 128 numbers in

6686
04:28:05,279 --> 04:28:08,000
a byte two characters and use that to

6687
04:28:08,000 --> 04:28:10,000
represent characters this technique

6688
04:28:10,000 --> 04:28:13,040
doesn't work well if you have languages

6689
04:28:13,040 --> 04:28:15,680
like arabic japanese and chinese because

6690
04:28:15,680 --> 04:28:18,319
they are completely different beasts

6691
04:28:18,319 --> 04:28:19,680
there are better ways to represent

6692
04:28:19,680 --> 04:28:21,920
characters in your c plus program and

6693
04:28:21,920 --> 04:28:24,800
that's usually unicode but that's really

6694
04:28:24,800 --> 04:28:27,120
out of scope for a course like this so

6695
04:28:27,120 --> 04:28:29,199
i'm not going to describe that anymore

6696
04:28:29,199 --> 04:28:30,880
okay this is really all we need to learn

6697
04:28:30,880 --> 04:28:32,800
about characters we're going to head to

6698
04:28:32,800 --> 04:28:35,199
visual studio code and play with them

6699
04:28:35,199 --> 04:28:38,560
okay here i am in my working folder i am

6700
04:28:38,560 --> 04:28:40,640
going to go in my template project i am

6701
04:28:40,640 --> 04:28:43,120
going to copy things over i am going to

6702
04:28:43,120 --> 04:28:45,760
put that in my characters and text

6703
04:28:45,760 --> 04:28:48,560
project and i am going to go up and open

6704
04:28:48,560 --> 04:28:50,239
this up in visual studio code we're

6705
04:28:50,239 --> 04:28:52,080
going to close the welcome screen here

6706
04:28:52,080 --> 04:28:54,640
we're going to open up main cpp and

6707
04:28:54,640 --> 04:28:57,279
we're going to put in the code to play

6708
04:28:57,279 --> 04:28:59,600
with characters and text

6709
04:28:59,600 --> 04:29:02,000
the first thing we can do is declare

6710
04:29:02,000 --> 04:29:05,120
characters like this we can put in a r

6711
04:29:05,120 --> 04:29:08,159
r o w here and we're going to see this

6712
04:29:08,159 --> 04:29:10,800
printed out if we run this program we

6713
04:29:10,800 --> 04:29:12,960
are going to put in some code to play

6714
04:29:12,960 --> 04:29:14,560
with characters

6715
04:29:14,560 --> 04:29:17,439
we have a few variables declared that

6716
04:29:17,439 --> 04:29:19,760
are of car type

6717
04:29:19,760 --> 04:29:22,080
we go from character 1 through character

6718
04:29:22,080 --> 04:29:24,000
5 and these are the characters we are

6719
04:29:24,000 --> 04:29:25,840
storing and this is and this is the

6720
04:29:25,840 --> 04:29:27,760
format you're really going to use to

6721
04:29:27,760 --> 04:29:30,399
declare your characters after we have

6722
04:29:30,399 --> 04:29:33,199
them declared we can print them out like

6723
04:29:33,199 --> 04:29:36,239
we print any other variable and we can

6724
04:29:36,239 --> 04:29:38,239
try and compile this program and see

6725
04:29:38,239 --> 04:29:40,399
what we're going to get but before we do

6726
04:29:40,399 --> 04:29:42,560
that i would invite you to try and guess

6727
04:29:42,560 --> 04:29:44,960
so let's open our terminal

6728
04:29:44,960 --> 04:29:48,239
and we're going to build with our gcc

6729
04:29:48,239 --> 04:29:50,399
task we're going to world the build is

6730
04:29:50,399 --> 04:29:52,640
going to go through and if we run

6731
04:29:52,640 --> 04:29:54,720
rooster we're going to see that we are

6732
04:29:54,720 --> 04:29:56,159
printing out

6733
04:29:56,159 --> 04:30:00,239
a r o w we are storing our characters

6734
04:30:00,239 --> 04:30:02,960
and and we are able to print them out

6735
04:30:02,960 --> 04:30:04,640
this is really how you work with these

6736
04:30:04,640 --> 04:30:06,880
guys another thing i want you to see is

6737
04:30:06,880 --> 04:30:10,640
the size that a character occupies

6738
04:30:10,640 --> 04:30:13,760
in memory by that i mean card type it's

6739
04:30:13,760 --> 04:30:16,239
going to occupy one byte in memory and

6740
04:30:16,239 --> 04:30:19,560
that means that we can only have

6741
04:30:19,560 --> 04:30:23,040
256 different values that go between 0

6742
04:30:23,040 --> 04:30:26,800
and 255 if we have decided to store in

6743
04:30:26,800 --> 04:30:28,720
positive numbers we are using the

6744
04:30:28,720 --> 04:30:30,880
knowledge we learned from the integers

6745
04:30:30,880 --> 04:30:33,279
lecture if these calculations we are

6746
04:30:33,279 --> 04:30:35,680
doing here don't make sense please go

6747
04:30:35,680 --> 04:30:38,319
back and check that out so down here we

6748
04:30:38,319 --> 04:30:41,040
are declaring a character type the name

6749
04:30:41,040 --> 04:30:44,159
is value and we are putting in a 65. the

6750
04:30:44,159 --> 04:30:46,720
thing is if you try to print this value

6751
04:30:46,720 --> 04:30:48,960
here it's not going to print 65 it's

6752
04:30:48,960 --> 04:30:51,920
going to print a which is a character

6753
04:30:51,920 --> 04:30:54,960
representation of 65. if you remember

6754
04:30:54,960 --> 04:30:58,479
from our ascii table we had these

6755
04:30:58,479 --> 04:31:01,520
mappings between characters and integers

6756
04:31:01,520 --> 04:31:05,600
and 65 mapped to the character a

6757
04:31:05,600 --> 04:31:08,479
upper case so if we print this out this

6758
04:31:08,479 --> 04:31:10,800
is going to give us a but we have the

6759
04:31:10,800 --> 04:31:12,319
option to

6760
04:31:12,319 --> 04:31:14,960
interpret this as a number and we can

6761
04:31:14,960 --> 04:31:18,000
pass this through a static cast and it

6762
04:31:18,000 --> 04:31:20,239
is going to take a value turn this into

6763
04:31:20,239 --> 04:31:22,080
an integer and we're going to be

6764
04:31:22,080 --> 04:31:24,800
printing this integer on the console and

6765
04:31:24,800 --> 04:31:26,880
we're going to see it we're going to try

6766
04:31:26,880 --> 04:31:28,800
this out so we're going to run the task

6767
04:31:28,800 --> 04:31:31,439
to build with gcc the build is going to

6768
04:31:31,439 --> 04:31:34,399
go through we're going to run rooster

6769
04:31:34,399 --> 04:31:36,880
and you're going to see that value is a

6770
04:31:36,880 --> 04:31:39,040
for the first line here

6771
04:31:39,040 --> 04:31:42,800
and the value and is 65 because we

6772
04:31:42,800 --> 04:31:46,000
decided to interpret whatever is in this

6773
04:31:46,000 --> 04:31:48,720
value as an integer and not as a

6774
04:31:48,720 --> 04:31:51,359
character as it is done by default this

6775
04:31:51,359 --> 04:31:52,800
is really all we set out to do in this

6776
04:31:52,800 --> 04:31:55,120
lecture i hope you found it interesting

6777
04:31:55,120 --> 04:31:56,800
we are going to stop here in this

6778
04:31:56,800 --> 04:31:58,399
lecture in the next one we're going to

6779
04:31:58,399 --> 04:32:01,600
try and learn about the auto key world

6780
04:32:01,600 --> 04:32:03,279
in c plus plus

6781
04:32:03,279 --> 04:32:05,520
go ahead and finish up here and meet me

6782
04:32:05,520 --> 04:32:07,199
there in this lecture we're going to

6783
04:32:07,199 --> 04:32:10,239
learn about the auto keyword in c plus

6784
04:32:10,239 --> 04:32:11,279
plus

6785
04:32:11,279 --> 04:32:14,159
this is a keyword that is going to let

6786
04:32:14,159 --> 04:32:16,640
the compiler deduce the type for you and

6787
04:32:16,640 --> 04:32:18,800
this is going to come in handy when you

6788
04:32:18,800 --> 04:32:22,239
have longer type names that are really

6789
04:32:22,239 --> 04:32:24,800
hard to type we can't really give you an

6790
04:32:24,800 --> 04:32:27,359
example of that because that requires to

6791
04:32:27,359 --> 04:32:31,359
have a good number of concepts mastered

6792
04:32:31,359 --> 04:32:34,000
in clause plus but we are measuring this

6793
04:32:34,000 --> 04:32:35,920
here for completeness because we are

6794
04:32:35,920 --> 04:32:38,399
talking about variables and data types

6795
04:32:38,399 --> 04:32:40,560
so let's hear how we can use this here

6796
04:32:40,560 --> 04:32:42,800
we have an example where we are saying

6797
04:32:42,800 --> 04:32:46,239
autovar one and what we initialize this

6798
04:32:46,239 --> 04:32:49,199
with is an integer so the compiler is

6799
04:32:49,199 --> 04:32:51,920
really going to try and guess the type

6800
04:32:51,920 --> 04:32:54,080
of this thing and that's the type it's

6801
04:32:54,080 --> 04:32:56,560
going to assign to variable one this is

6802
04:32:56,560 --> 04:32:59,840
what ocho is really used for if we pass

6803
04:32:59,840 --> 04:33:01,439
a double

6804
04:33:01,439 --> 04:33:03,439
inside and it is a double because we

6805
04:33:03,439 --> 04:33:04,959
have no

6806
04:33:04,959 --> 04:33:06,639
suffix here

6807
04:33:06,639 --> 04:33:09,520
so it is going to deduce a double if we

6808
04:33:09,520 --> 04:33:12,160
pass a suffix of f it is going to

6809
04:33:12,160 --> 04:33:15,119
interpret this as a fluid if we pass l

6810
04:33:15,119 --> 04:33:17,359
it is going to interpret this as long

6811
04:33:17,359 --> 04:33:19,680
double and if we pass in a character

6812
04:33:19,680 --> 04:33:21,920
it's going to interpret this as a

6813
04:33:21,920 --> 04:33:24,160
character and this is really the essence

6814
04:33:24,160 --> 04:33:27,520
of what auto is used for it is used when

6815
04:33:27,520 --> 04:33:30,879
you don't really want to explicitly type

6816
04:33:30,879 --> 04:33:33,439
the type of your variable and you want

6817
04:33:33,439 --> 04:33:36,959
the compiler to fill in that for you or

6818
04:33:36,959 --> 04:33:38,799
it gets it for you down here you see

6819
04:33:38,799 --> 04:33:40,400
that we have a few examples with

6820
04:33:40,400 --> 04:33:43,119
integers so we can make this unsigned

6821
04:33:43,119 --> 04:33:45,439
lung through this suffixes and the

6822
04:33:45,439 --> 04:33:48,080
compiler is going to deduce the type

6823
04:33:48,080 --> 04:33:51,119
based on what we pass in our initializer

6824
04:33:51,119 --> 04:33:52,879
here down here you see that we have a

6825
04:33:52,879 --> 04:33:55,520
few examples with integers if we pass a

6826
04:33:55,520 --> 04:33:57,920
suffix of u this means that we are

6827
04:33:57,920 --> 04:34:01,039
storing an an unsigned integer so that's

6828
04:34:01,039 --> 04:34:03,439
what the compiler is going to deduce if

6829
04:34:03,439 --> 04:34:06,639
we pass ul it is going to be unsigned

6830
04:34:06,639 --> 04:34:09,359
long if we pass in ll this is going to

6831
04:34:09,359 --> 04:34:11,359
be long long and that's what the

6832
04:34:11,359 --> 04:34:13,600
compiler is going to deduce here you see

6833
04:34:13,600 --> 04:34:15,840
that we are trying to print the sizes of

6834
04:34:15,840 --> 04:34:19,199
these variables and we trying to

6835
04:34:19,199 --> 04:34:21,039
prove to ourselves

6836
04:34:21,039 --> 04:34:24,080
that the compiler deduced the right type

6837
04:34:24,080 --> 04:34:26,080
and we are going to go to visual studio

6838
04:34:26,080 --> 04:34:28,639
code and actually try this out

6839
04:34:28,639 --> 04:34:32,480
okay here i am in my working folder i am

6840
04:34:32,480 --> 04:34:34,719
going to open my template project i'm

6841
04:34:34,719 --> 04:34:36,240
going to copy that

6842
04:34:36,240 --> 04:34:37,840
and i'm going to

6843
04:34:37,840 --> 04:34:41,920
save my files in the auto project here

6844
04:34:41,920 --> 04:34:44,160
so i am going to go in and put in my

6845
04:34:44,160 --> 04:34:47,119
files i'm going to go up again and i am

6846
04:34:47,119 --> 04:34:49,680
going to close whatever it is i have in

6847
04:34:49,680 --> 04:34:51,279
visual studio code because we're going

6848
04:34:51,279 --> 04:34:53,600
to create a new project i am going to

6849
04:34:53,600 --> 04:34:55,680
open my new folder we're going to close

6850
04:34:55,680 --> 04:34:57,600
the welcome screen here and we're going

6851
04:34:57,600 --> 04:34:59,760
to remove whatever it is we don't need

6852
04:34:59,760 --> 04:35:01,600
for this project

6853
04:35:01,600 --> 04:35:03,920
and we are going to put in the code we

6854
04:35:03,920 --> 04:35:07,199
basically had in the slides i am pasting

6855
04:35:07,199 --> 04:35:10,080
this code in to save on some time

6856
04:35:10,080 --> 04:35:11,760
because i don't want you to see me type

6857
04:35:11,760 --> 04:35:13,520
these things we're going to save some

6858
04:35:13,520 --> 04:35:14,799
seconds here

6859
04:35:14,799 --> 04:35:17,520
so the first statement here declares a

6860
04:35:17,520 --> 04:35:20,561
variable var1 the type we don't really

6861
04:35:20,561 --> 04:35:22,639
know but we're going to let the compiler

6862
04:35:22,639 --> 04:35:24,320
deduce that for us

6863
04:35:24,320 --> 04:35:26,799
and we can try and actually hover over

6864
04:35:26,799 --> 04:35:28,480
this and we're going to see that the

6865
04:35:28,480 --> 04:35:30,959
compiler already deduced that this is an

6866
04:35:30,959 --> 04:35:33,920
integer if we go to vira 2 this is a

6867
04:35:33,920 --> 04:35:36,400
double if we go to var3 you see it's a

6868
04:35:36,400 --> 04:35:40,080
float if you go to var4 it's long double

6869
04:35:40,080 --> 04:35:42,320
if you go to wire 5 it's a character you

6870
04:35:42,320 --> 04:35:45,119
can see that visual studio code can even

6871
04:35:45,119 --> 04:35:47,760
see what the compiler is going to deduce

6872
04:35:47,760 --> 04:35:50,320
before we even compile the code this is

6873
04:35:50,320 --> 04:35:52,959
the beauty of visual studio code we're

6874
04:35:52,959 --> 04:35:55,119
going to look at virus 6 you're going to

6875
04:35:55,119 --> 04:35:57,600
see that it's going to be unsigned and

6876
04:35:57,600 --> 04:35:59,680
if we go to var 7 it's going to be

6877
04:35:59,680 --> 04:36:03,279
unsigned long if we go to var 8 it's

6878
04:36:03,279 --> 04:36:05,680
going to be long long this is really

6879
04:36:05,680 --> 04:36:07,920
cool and you can see that our types are

6880
04:36:07,920 --> 04:36:10,719
correctly deduced visuals video code was

6881
04:36:10,719 --> 04:36:13,680
really helpful in showing us these types

6882
04:36:13,680 --> 04:36:16,561
but we want to be sure by running this

6883
04:36:16,561 --> 04:36:19,520
piece of code and seeing whatever size

6884
04:36:19,520 --> 04:36:22,879
the deduced type is for example for var1

6885
04:36:22,879 --> 04:36:25,199
we guessed that it's going to deduce an

6886
04:36:25,199 --> 04:36:28,080
end so it better be a four

6887
04:36:28,080 --> 04:36:30,879
in size we're going to try and run this

6888
04:36:30,879 --> 04:36:33,439
we're going to open our terminal here

6889
04:36:33,439 --> 04:36:35,359
and we're going to go to terminal and

6890
04:36:35,359 --> 04:36:38,639
run task we're going to build with gcc

6891
04:36:38,639 --> 04:36:40,719
and by the way if you want you can build

6892
04:36:40,719 --> 04:36:43,760
with the compiler from microsoft by

6893
04:36:43,760 --> 04:36:46,000
coming to terminal here and choose it

6894
04:36:46,000 --> 04:36:49,520
with world with msvc but gcc is my

6895
04:36:49,520 --> 04:36:51,840
favorite compiler and i am going to use

6896
04:36:51,840 --> 04:36:55,039
it if i can so we're going to hit enter

6897
04:36:55,039 --> 04:36:58,359
and enter we're going to see that our

6898
04:36:58,359 --> 04:37:01,680
rooster.exe file is in place if we run

6899
04:37:01,680 --> 04:37:04,480
it we're going to see our sizes so var

6900
04:37:04,480 --> 04:37:07,680
one occupies four bytes in memory

6901
04:37:07,680 --> 04:37:11,199
var2 occupies for eight bytes in memory

6902
04:37:11,199 --> 04:37:13,039
because it is

6903
04:37:13,039 --> 04:37:15,840
double fire 3 occupies 3 bytes because

6904
04:37:15,840 --> 04:37:18,879
it is a float var4 occupies 16 bytes

6905
04:37:18,879 --> 04:37:20,959
because it is a long double

6906
04:37:20,959 --> 04:37:24,080
and var 5 better occupy 1 byte because

6907
04:37:24,080 --> 04:37:26,080
it is a character and we see the same

6908
04:37:26,080 --> 04:37:27,520
data for

6909
04:37:27,520 --> 04:37:30,959
vera 6 virus 7 and var 8 and this proves

6910
04:37:30,959 --> 04:37:33,840
that the auto keyword is really doing

6911
04:37:33,840 --> 04:37:36,879
its job it is deducing the types for our

6912
04:37:36,879 --> 04:37:40,080
variables without us explicitly

6913
04:37:40,080 --> 04:37:42,959
specifying the variable type we didn't

6914
04:37:42,959 --> 04:37:45,279
have to do something like and or double

6915
04:37:45,279 --> 04:37:47,680
or whatever we can let the compiler do

6916
04:37:47,680 --> 04:37:50,480
that for us and this will come in handy

6917
04:37:50,480 --> 04:37:53,039
many times this is really all we set out

6918
04:37:53,039 --> 04:37:54,719
to do in this lecture and i hope you

6919
04:37:54,719 --> 04:37:56,719
found it interesting in the next one

6920
04:37:56,719 --> 04:37:58,719
we're going to look at how we can do

6921
04:37:58,719 --> 04:38:01,359
assignments and assign data to our

6922
04:38:01,359 --> 04:38:04,320
variables in a unified way go ahead and

6923
04:38:04,320 --> 04:38:07,199
finish up here and we'd be there in this

6924
04:38:07,199 --> 04:38:08,879
lecture we're going to learn about

6925
04:38:08,879 --> 04:38:12,240
assignments and the basic idea i really

6926
04:38:12,240 --> 04:38:15,600
want to drive home here is that after a

6927
04:38:15,600 --> 04:38:18,320
variable is initialized like we've been

6928
04:38:18,320 --> 04:38:21,439
doing all along you can later assign a

6929
04:38:21,439 --> 04:38:24,561
new value to it for example here we have

6930
04:38:24,561 --> 04:38:27,039
our one declared it is an integer we can

6931
04:38:27,039 --> 04:38:28,719
print it out and it is going to print

6932
04:38:28,719 --> 04:38:31,600
one two three but later in the program

6933
04:38:31,600 --> 04:38:33,520
we can put in another value for example

6934
04:38:33,520 --> 04:38:36,080
here we are putting in a 55 and if we

6935
04:38:36,080 --> 04:38:39,760
print var1 it's going to be 55 this time

6936
04:38:39,760 --> 04:38:42,400
the same idea can be extended to doubles

6937
04:38:42,400 --> 04:38:44,799
you see here we are doing the same thing

6938
04:38:44,799 --> 04:38:46,719
booleans we are doing the same thing

6939
04:38:46,719 --> 04:38:49,760
here the state is declared force and we

6940
04:38:49,760 --> 04:38:51,760
are printing that and after we are

6941
04:38:51,760 --> 04:38:54,240
changing this to a true value and if we

6942
04:38:54,240 --> 04:38:56,879
print that it's going to be true one

6943
04:38:56,879 --> 04:38:58,320
thing you really need to be careful

6944
04:38:58,320 --> 04:39:01,119
about is if you are doing auto type

6945
04:39:01,119 --> 04:39:04,000
deduction the type is not very apparent

6946
04:39:04,000 --> 04:39:06,320
by looking at the declaration of the

6947
04:39:06,320 --> 04:39:08,480
variable here for example here by

6948
04:39:08,480 --> 04:39:12,400
looking at o2 var 3 we don't really know

6949
04:39:12,400 --> 04:39:15,199
what that is and it is very easy to try

6950
04:39:15,199 --> 04:39:17,439
and put in a value that is illegal for

6951
04:39:17,439 --> 04:39:20,719
example here we have deduced an unsigned

6952
04:39:20,719 --> 04:39:23,520
integer which is only going to store

6953
04:39:23,520 --> 04:39:26,000
positive numbers but we are putting in a

6954
04:39:26,000 --> 04:39:28,240
minus 22 and this is going to be a

6955
04:39:28,240 --> 04:39:30,080
disaster we're going to get a compiler

6956
04:39:30,080 --> 04:39:33,439
error and this is going to be bad so be

6957
04:39:33,439 --> 04:39:35,520
careful when you are doing a type

6958
04:39:35,520 --> 04:39:38,240
deduction in your assignments that you

6959
04:39:38,240 --> 04:39:40,638
do to your variables this is really all

6960
04:39:40,638 --> 04:39:43,040
we have to share in this lecture let's

6961
04:39:43,040 --> 04:39:45,520
hop over to visual studio and show you

6962
04:39:45,520 --> 04:39:48,718
this in action okay here i am in my

6963
04:39:48,718 --> 04:39:50,638
working folder the project we're going

6964
04:39:50,638 --> 04:39:52,718
to be working on is four nine here

6965
04:39:52,718 --> 04:39:55,120
assignments i am going to grab my

6966
04:39:55,120 --> 04:39:57,920
template files and put that in this

6967
04:39:57,920 --> 04:40:00,400
folder here and i am going to open this

6968
04:40:00,400 --> 04:40:02,878
up in visual studio code so let's close

6969
04:40:02,878 --> 04:40:05,840
whatever it is we have now

6970
04:40:05,840 --> 04:40:08,798
and open the folder and we're going to

6971
04:40:08,798 --> 04:40:10,878
close the welcome screen here we don't

6972
04:40:10,878 --> 04:40:13,280
want it and remove whatever we don't

6973
04:40:13,280 --> 04:40:16,000
want from this file here the first thing

6974
04:40:16,000 --> 04:40:18,638
we want to do is put in the code for our

6975
04:40:18,638 --> 04:40:21,840
integer variable var1 and show you that

6976
04:40:21,840 --> 04:40:22,958
you can

6977
04:40:22,958 --> 04:40:25,600
assign a new value to it after it was

6978
04:40:25,600 --> 04:40:27,920
initialized and if we run this code

6979
04:40:27,920 --> 04:40:31,680
we're going to see var1 to b123 and the

6980
04:40:31,680 --> 04:40:34,560
second statement is going to say var1

6981
04:40:34,560 --> 04:40:35,920
equals

6982
04:40:35,920 --> 04:40:38,400
55. that's what we're going to see let's

6983
04:40:38,400 --> 04:40:40,958
bring up our terminal and we are going

6984
04:40:40,958 --> 04:40:44,798
to run the task to build with gcc

6985
04:40:44,798 --> 04:40:48,400
and if we hop over here in the terminal

6986
04:40:48,400 --> 04:40:49,920
and do dir

6987
04:40:49,920 --> 04:40:52,638
we're going to see that our rooster.exe

6988
04:40:52,638 --> 04:40:55,840
file is in here if we run it we're going

6989
04:40:55,840 --> 04:40:59,040
to see var one one two three var 155

6990
04:40:59,040 --> 04:41:01,680
exactly what we expect we have stored in

6991
04:41:01,680 --> 04:41:05,280
a one two three at initialization using

6992
04:41:05,280 --> 04:41:08,320
braced initialization here but after

6993
04:41:08,320 --> 04:41:11,760
later on in our program we have decided

6994
04:41:11,760 --> 04:41:14,160
to put a different value in this

6995
04:41:14,160 --> 04:41:15,520
variable here

6996
04:41:15,520 --> 04:41:17,760
essentially reusing it to store

6997
04:41:17,760 --> 04:41:20,080
something else this is the basic idea

6998
04:41:20,080 --> 04:41:22,240
here we can do the same things with

6999
04:41:22,240 --> 04:41:24,480
doubles but before we do that let's put

7000
04:41:24,480 --> 04:41:27,600
in a separation line so that we can see

7001
04:41:27,600 --> 04:41:30,958
these vents clearly in the terminal and

7002
04:41:30,958 --> 04:41:32,718
we're going to go down and put in our

7003
04:41:32,718 --> 04:41:34,160
code for a double

7004
04:41:34,160 --> 04:41:37,280
so we have a double variable called var2

7005
04:41:37,280 --> 04:41:40,560
initially it has 44.50

7006
04:41:40,560 --> 04:41:43,040
in and then we're going to assign a new

7007
04:41:43,040 --> 04:41:46,480
value to it and that's going to be 99.99

7008
04:41:46,480 --> 04:41:48,320
if we print that out we're going to see

7009
04:41:48,320 --> 04:41:49,280
that

7010
04:41:49,280 --> 04:41:51,440
let's work and see this in action we're

7011
04:41:51,440 --> 04:41:54,000
going to build with gcc

7012
04:41:54,000 --> 04:41:56,000
if we

7013
04:41:56,000 --> 04:41:58,560
run the program now it's going to save

7014
04:41:58,560 --> 04:42:01,440
r1 is one two three four one fifty five

7015
04:42:01,440 --> 04:42:03,600
but we're also going to see that viral

7016
04:42:03,600 --> 04:42:06,878
two starts out 44.55

7017
04:42:06,878 --> 04:42:09,240
but after we put in the

7018
04:42:09,240 --> 04:42:12,000
99.99 it's going to show up here okay

7019
04:42:12,000 --> 04:42:15,120
let's put in another separation line

7020
04:42:15,120 --> 04:42:16,878
because we're going to need that in a

7021
04:42:16,878 --> 04:42:18,320
minute

7022
04:42:18,320 --> 04:42:21,040
we can do the same things with booleans

7023
04:42:21,040 --> 04:42:24,000
here we are using this as just an

7024
04:42:24,000 --> 04:42:26,560
example but this same concept

7025
04:42:26,560 --> 04:42:29,520
essentially extends to any other kind of

7026
04:42:29,520 --> 04:42:31,840
variable you're going to have in your c

7027
04:42:31,840 --> 04:42:34,560
plus plus code if you initialize it with

7028
04:42:34,560 --> 04:42:37,200
some value you have the option to change

7029
04:42:37,200 --> 04:42:40,638
that value later on in your program by

7030
04:42:40,638 --> 04:42:42,958
assigning that value to that variable

7031
04:42:42,958 --> 04:42:45,280
essentially what we are doing here the

7032
04:42:45,280 --> 04:42:47,600
variable state which is a bull

7033
04:42:47,600 --> 04:42:50,240
was initialized to false we're going to

7034
04:42:50,240 --> 04:42:52,480
print that out and notice that we have

7035
04:42:52,480 --> 04:42:54,878
this setting to allow us to see true or

7036
04:42:54,878 --> 04:42:57,200
false instead of ones and zeros we have

7037
04:42:57,200 --> 04:43:00,240
seen this in a few lectures back

7038
04:43:00,240 --> 04:43:02,958
and later on we are assigning true to

7039
04:43:02,958 --> 04:43:05,520
this state and we are printing that so

7040
04:43:05,520 --> 04:43:07,520
if we print these things out we're going

7041
04:43:07,520 --> 04:43:11,840
to see false and true for the state here

7042
04:43:11,840 --> 04:43:13,680
so let's build

7043
04:43:13,680 --> 04:43:16,000
we're going to use gcc

7044
04:43:16,000 --> 04:43:18,400
and the world is good if we run the

7045
04:43:18,400 --> 04:43:19,520
program

7046
04:43:19,520 --> 04:43:22,080
we're going to see false and true and it

7047
04:43:22,080 --> 04:43:24,480
is exactly what we expect again you

7048
04:43:24,480 --> 04:43:26,400
really need to be careful when you are

7049
04:43:26,400 --> 04:43:29,040
using auto type deduction because you

7050
04:43:29,040 --> 04:43:31,280
might have some serious problems if you

7051
04:43:31,280 --> 04:43:33,760
are not paying attention let's put in

7052
04:43:33,760 --> 04:43:36,240
the code so that we can play with it

7053
04:43:36,240 --> 04:43:39,120
here we have a variable called var 3 and

7054
04:43:39,120 --> 04:43:41,920
the type of it is not specified

7055
04:43:41,920 --> 04:43:44,320
explicitly we are letting the compiler

7056
04:43:44,320 --> 04:43:47,520
deduce this and because our initializer

7057
04:43:47,520 --> 04:43:50,480
here is an unsigned integer the compiler

7058
04:43:50,480 --> 04:43:53,040
is going to deduce that it is an

7059
04:43:53,040 --> 04:43:55,760
unsigned integer the problem will come

7060
04:43:55,760 --> 04:43:58,638
if you try to store in a negative number

7061
04:43:58,638 --> 04:44:00,638
the compiler is not going to give you a

7062
04:44:00,638 --> 04:44:03,200
compiler arrow it is going to silently

7063
04:44:03,200 --> 04:44:05,440
put in some garbage value

7064
04:44:05,440 --> 04:44:07,600
that we don't really want in there we

7065
04:44:07,600 --> 04:44:11,120
want a minus 22 and you can see that

7066
04:44:11,120 --> 04:44:13,520
this is what the compiler is turning our

7067
04:44:13,520 --> 04:44:16,878
value into we want a minus 22 in this

7068
04:44:16,878 --> 04:44:19,520
for three but if you hover over this

7069
04:44:19,520 --> 04:44:22,160
minus sign here in visual studio code

7070
04:44:22,160 --> 04:44:23,600
you're going to see that the value that

7071
04:44:23,600 --> 04:44:26,000
we have in is not what we put in we put

7072
04:44:26,000 --> 04:44:29,120
in a minus 22 and we are getting a

7073
04:44:29,120 --> 04:44:32,000
really large number close to 4 billion

7074
04:44:32,000 --> 04:44:34,240
so this is really something that can go

7075
04:44:34,240 --> 04:44:36,638
silently wrong in your code and you're

7076
04:44:36,638 --> 04:44:37,840
going to have

7077
04:44:37,840 --> 04:44:39,920
a hard time trying to figure out why

7078
04:44:39,920 --> 04:44:41,680
your code is not doing whatever it is

7079
04:44:41,680 --> 04:44:44,320
you want so be careful about this let's

7080
04:44:44,320 --> 04:44:46,320
try and weld this so we're going to

7081
04:44:46,320 --> 04:44:48,000
build with gcc

7082
04:44:48,000 --> 04:44:49,360
the world is going to be good you're

7083
04:44:49,360 --> 04:44:50,958
going to see that we're not even going

7084
04:44:50,958 --> 04:44:54,160
to get a compiler arrow if we run this

7085
04:44:54,160 --> 04:44:56,878
and we're going to see that viral 3 is

7086
04:44:56,878 --> 04:44:59,520
exactly what visual studio could guess

7087
04:44:59,520 --> 04:45:02,400
and it is not good it is this value here

7088
04:45:02,400 --> 04:45:04,718
and the problem is that the compiler is

7089
04:45:04,718 --> 04:45:07,520
silently putting in a garbage value and

7090
04:45:07,520 --> 04:45:10,638
not what we want here because virus 3 is

7091
04:45:10,638 --> 04:45:12,638
basically not capable of storing

7092
04:45:12,638 --> 04:45:14,638
negative numbers so the compiler is

7093
04:45:14,638 --> 04:45:16,638
going to do its best and put in a

7094
04:45:16,638 --> 04:45:18,958
garbage value and this is not what you

7095
04:45:18,958 --> 04:45:21,680
want and you need to be aware of this

7096
04:45:21,680 --> 04:45:23,200
this is really all we set out to do in

7097
04:45:23,200 --> 04:45:25,120
this lecture i hope you know about

7098
04:45:25,120 --> 04:45:28,000
assignments and be careful when you are

7099
04:45:28,000 --> 04:45:30,400
doing assignments on variables whose

7100
04:45:30,400 --> 04:45:33,600
types are deduced with auto and we're

7101
04:45:33,600 --> 04:45:35,200
going to stop here in this lecture in

7102
04:45:35,200 --> 04:45:36,638
the next one we're going to try and

7103
04:45:36,638 --> 04:45:39,520
recap what we saw in this chapter go

7104
04:45:39,520 --> 04:45:41,440
ahead and finish up here

7105
04:45:41,440 --> 04:45:43,600
and meet me there in this lecture we're

7106
04:45:43,600 --> 04:45:46,400
going to recap what we saw in this

7107
04:45:46,400 --> 04:45:48,878
chapter and this chapter was really all

7108
04:45:48,878 --> 04:45:52,000
about variables and data types we had a

7109
04:45:52,000 --> 04:45:54,000
chance to look at different types that

7110
04:45:54,000 --> 04:45:56,560
we can use in c plus plus we saw that we

7111
04:45:56,560 --> 04:45:58,798
have fundamental types we can use to

7112
04:45:58,798 --> 04:46:01,840
represent integers floating points

7113
04:46:01,840 --> 04:46:05,200
booleans and we also saw that we can do

7114
04:46:05,200 --> 04:46:08,160
type deduction with auto we had a chance

7115
04:46:08,160 --> 04:46:10,400
to make it clear that data is

7116
04:46:10,400 --> 04:46:13,440
represented in memory as zeros and ones

7117
04:46:13,440 --> 04:46:15,520
and that there are some kinds of

7118
04:46:15,520 --> 04:46:18,160
transformations we do on these pieces of

7119
04:46:18,160 --> 04:46:21,280
data to turn them into a form that is

7120
04:46:21,280 --> 04:46:24,638
easily usable and manipulable by humans

7121
04:46:24,638 --> 04:46:27,680
and we saw that for integral types or

7122
04:46:27,680 --> 04:46:30,320
integers we could do that through number

7123
04:46:30,320 --> 04:46:32,798
systems and we had a chance to look at a

7124
04:46:32,798 --> 04:46:35,760
few number systems like binary octal and

7125
04:46:35,760 --> 04:46:38,240
hexadecimal and we had a chance to play

7126
04:46:38,240 --> 04:46:41,360
with all these variable types in visual

7127
04:46:41,360 --> 04:46:44,320
studio code and see the nuances of how

7128
04:46:44,320 --> 04:46:46,718
you really work with them i would like

7129
04:46:46,718 --> 04:46:49,520
to welcome you in this new chapter and

7130
04:46:49,520 --> 04:46:51,440
this one we're going to be looking at

7131
04:46:51,440 --> 04:46:55,200
operations we can do on our data and

7132
04:46:55,200 --> 04:46:57,120
there is a bunch of them we can add

7133
04:46:57,120 --> 04:46:59,280
things up we can subtract numbers we can

7134
04:46:59,280 --> 04:47:01,360
divide numbers we're going to see all

7135
04:47:01,360 --> 04:47:04,400
kinds of crazy operations we can do

7136
04:47:04,400 --> 04:47:06,958
on the data all the variables that we

7137
04:47:06,958 --> 04:47:10,320
have in our c plus plus program we are

7138
04:47:10,320 --> 04:47:11,920
also going to have a chance to look at

7139
04:47:11,920 --> 04:47:14,240
how we can format stuff when we print

7140
04:47:14,240 --> 04:47:17,440
them out to stdc out and we are going to

7141
04:47:17,440 --> 04:47:20,000
be using some utilities from the c plus

7142
04:47:20,000 --> 04:47:22,160
plus standard library to do some

7143
04:47:22,160 --> 04:47:25,040
operations on our variables this is

7144
04:47:25,040 --> 04:47:27,200
going to be a fun chapter i can't wait

7145
04:47:27,200 --> 04:47:29,440
to get started let's go in the next

7146
04:47:29,440 --> 04:47:31,920
lecture and start doing this

7147
04:47:31,920 --> 04:47:33,280
in this lecture we're going to be

7148
04:47:33,280 --> 04:47:35,840
looking at some basic operations you can

7149
04:47:35,840 --> 04:47:36,718
do

7150
04:47:36,718 --> 04:47:39,680
on the data in your c plus plus program

7151
04:47:39,680 --> 04:47:41,520
and we are going to be specifically

7152
04:47:41,520 --> 04:47:44,240
looking at addition subtraction dividing

7153
04:47:44,240 --> 04:47:46,958
numbers the modulus operator and

7154
04:47:46,958 --> 04:47:49,600
multiplying stuff we have seen addition

7155
04:47:49,600 --> 04:47:50,560
before

7156
04:47:50,560 --> 04:47:53,280
here we have a simple example we have a

7157
04:47:53,280 --> 04:47:55,840
variable called sum and we are

7158
04:47:55,840 --> 04:47:58,638
initializing it with two numbers that we

7159
04:47:58,638 --> 04:48:00,878
are adding up number one and number two

7160
04:48:00,878 --> 04:48:02,798
this is something you can do in your c

7161
04:48:02,798 --> 04:48:05,760
plus bus program you can also do

7162
04:48:05,760 --> 04:48:07,600
some other things for example we have

7163
04:48:07,600 --> 04:48:10,240
another one called other sum and we are

7164
04:48:10,240 --> 04:48:12,878
adding up some other numbers and we are

7165
04:48:12,878 --> 04:48:15,600
going to collect the result into this

7166
04:48:15,600 --> 04:48:16,958
other sum

7167
04:48:16,958 --> 04:48:19,200
variable and we're going to print these

7168
04:48:19,200 --> 04:48:21,920
things out so that you can see them on

7169
04:48:21,920 --> 04:48:24,320
your command prompt this is how you can

7170
04:48:24,320 --> 04:48:25,920
do addition and we're going to have a

7171
04:48:25,920 --> 04:48:27,600
chance to play with this in visual

7172
04:48:27,600 --> 04:48:30,560
studio code in a minute we can also do

7173
04:48:30,560 --> 04:48:33,440
subtraction we can take a number and do

7174
04:48:33,440 --> 04:48:35,600
minus another number like we are doing

7175
04:48:35,600 --> 04:48:37,840
here we're going to store the results in

7176
04:48:37,840 --> 04:48:40,480
this div variable and we can do some

7177
04:48:40,480 --> 04:48:41,600
other things

7178
04:48:41,600 --> 04:48:44,638
and down here you see another example in

7179
04:48:44,638 --> 04:48:46,718
other diff here we're going to subtract

7180
04:48:46,718 --> 04:48:49,600
numbers and store the result in other

7181
04:48:49,600 --> 04:48:52,080
def and we are also going to print this

7182
04:48:52,080 --> 04:48:54,400
out you can also multiply stuff this is

7183
04:48:54,400 --> 04:48:56,240
how you can do this you use this

7184
04:48:56,240 --> 04:48:59,760
operator here it is the star operator

7185
04:48:59,760 --> 04:49:01,840
and this is an operator that many

7186
04:49:01,840 --> 04:49:03,760
programming languages use to do

7187
04:49:03,760 --> 04:49:06,878
multiplication you should get familiar

7188
04:49:06,878 --> 04:49:09,280
with this and again we print out the

7189
04:49:09,280 --> 04:49:11,440
result so that you can see that this is

7190
04:49:11,440 --> 04:49:15,120
actually working we can also do division

7191
04:49:15,120 --> 04:49:17,920
division for integers is a little tricky

7192
04:49:17,920 --> 04:49:19,840
if you are seeing this for the first

7193
04:49:19,840 --> 04:49:20,878
time

7194
04:49:20,878 --> 04:49:22,400
if we take for example

7195
04:49:22,400 --> 04:49:26,160
31 and divide that by 10

7196
04:49:26,160 --> 04:49:27,760
we're not going to get fractional

7197
04:49:27,760 --> 04:49:30,240
numbers c plus plus is going to try and

7198
04:49:30,240 --> 04:49:33,840
figure out how many times it can fit 10

7199
04:49:33,840 --> 04:49:37,440
in 31 and we are visualizing this here

7200
04:49:37,440 --> 04:49:41,440
so in 31 we can only fit 10 three times

7201
04:49:41,440 --> 04:49:44,240
so the result of 31 is going to be three

7202
04:49:44,240 --> 04:49:46,000
this is the meaning here

7203
04:49:46,000 --> 04:49:47,920
okay with integer division you're not

7204
04:49:47,920 --> 04:49:50,080
going to be getting fractional numbers

7205
04:49:50,080 --> 04:49:51,680
this is something you should really

7206
04:49:51,680 --> 04:49:54,798
understand we have another operator that

7207
04:49:54,798 --> 04:49:57,680
is called modulus operator and this

7208
04:49:57,680 --> 04:49:59,680
operator is represented by this

7209
04:49:59,680 --> 04:50:02,320
percentage symbol that we are doing here

7210
04:50:02,320 --> 04:50:04,480
and the result of this operation here is

7211
04:50:04,480 --> 04:50:06,878
going to be what remains

7212
04:50:06,878 --> 04:50:10,000
after you have done the division of 31

7213
04:50:10,000 --> 04:50:12,560
and 10. and here the result is going to

7214
04:50:12,560 --> 04:50:14,878
be one and you might be wondering why

7215
04:50:14,878 --> 04:50:16,958
this is useful it is going to be useful

7216
04:50:16,958 --> 04:50:18,480
in many applications

7217
04:50:18,480 --> 04:50:19,840
and i think we're going to have a chance

7218
04:50:19,840 --> 04:50:22,000
to play with this later in the course

7219
04:50:22,000 --> 04:50:24,080
but right now you just need to be aware

7220
04:50:24,080 --> 04:50:27,040
of this operation and what it does okay

7221
04:50:27,040 --> 04:50:28,560
these are the operations we're going to

7222
04:50:28,560 --> 04:50:30,878
be learning about and playing with in

7223
04:50:30,878 --> 04:50:33,680
this lecture let's head to visual studio

7224
04:50:33,680 --> 04:50:36,560
code and actually play with this okay

7225
04:50:36,560 --> 04:50:39,600
here we are in our working folder for

7226
04:50:39,600 --> 04:50:41,280
this chapter you see that i have

7227
04:50:41,280 --> 04:50:43,120
prepared all the lectures we're going to

7228
04:50:43,120 --> 04:50:46,400
do in this chapter and i have my c plus

7229
04:50:46,400 --> 04:50:49,360
20 template project in place i am going

7230
04:50:49,360 --> 04:50:52,320
to do what we have been doing all along

7231
04:50:52,320 --> 04:50:54,638
so i am going to take these files and

7232
04:50:54,638 --> 04:50:55,760
put them

7233
04:50:55,760 --> 04:50:58,000
in the current lecture which is basic

7234
04:50:58,000 --> 04:50:59,280
operations

7235
04:50:59,280 --> 04:51:02,240
and i am going to paste those in and i

7236
04:51:02,240 --> 04:51:04,160
am going to open this folder in visual

7237
04:51:04,160 --> 04:51:06,400
studio code so let's do that pretty

7238
04:51:06,400 --> 04:51:08,638
quick we are going to close the welcome

7239
04:51:08,638 --> 04:51:10,560
screen here and we are going to open our

7240
04:51:10,560 --> 04:51:14,240
main cpp file and we are going to remove

7241
04:51:14,240 --> 04:51:16,240
things we don't need here the first

7242
04:51:16,240 --> 04:51:18,240
thing we want to play with is addition

7243
04:51:18,240 --> 04:51:20,480
so we're going to say that and we're

7244
04:51:20,480 --> 04:51:23,280
going to declare two end variables we're

7245
04:51:23,280 --> 04:51:25,120
going to call this number one and we're

7246
04:51:25,120 --> 04:51:27,680
going to put in a two for example

7247
04:51:27,680 --> 04:51:30,718
and we're going to do a number two

7248
04:51:30,718 --> 04:51:32,798
and we're going to put in a seven why

7249
04:51:32,798 --> 04:51:35,600
not and what we can do we can say

7250
04:51:35,600 --> 04:51:39,440
result equals number one plus number two

7251
04:51:39,440 --> 04:51:41,200
and we're going to store the result of

7252
04:51:41,200 --> 04:51:44,000
this operation and the result variable

7253
04:51:44,000 --> 04:51:47,520
here so what we can do is say sddcl and

7254
04:51:47,520 --> 04:51:50,000
we're going to print the result we can

7255
04:51:50,000 --> 04:51:53,040
try and compile this and see the result

7256
04:51:53,040 --> 04:51:55,440
let's open our terminal here

7257
04:51:55,440 --> 04:51:58,480
and we're going to build with gcc as we

7258
04:51:58,480 --> 04:51:59,840
always do

7259
04:51:59,840 --> 04:52:02,000
the world is going to go through and if

7260
04:52:02,000 --> 04:52:04,320
we run rooster here we're going to see

7261
04:52:04,320 --> 04:52:08,160
that the result of our operation is 9.

7262
04:52:08,160 --> 04:52:10,480
so this is how you can do addition

7263
04:52:10,480 --> 04:52:13,360
you can also do subtraction and here we

7264
04:52:13,360 --> 04:52:15,200
know to declare a new variable we're

7265
04:52:15,200 --> 04:52:17,120
going to store the result

7266
04:52:17,120 --> 04:52:17,920
in

7267
04:52:17,920 --> 04:52:20,320
our result variable here so what we're

7268
04:52:20,320 --> 04:52:23,280
going to do here is say subtraction and

7269
04:52:23,280 --> 04:52:25,280
we're going to say result

7270
04:52:25,280 --> 04:52:28,878
equals for example let's take number two

7271
04:52:28,878 --> 04:52:31,600
minus number one this is the operation

7272
04:52:31,600 --> 04:52:34,320
we want to do this is number two what we

7273
04:52:34,320 --> 04:52:36,560
are going to be storing in this result

7274
04:52:36,560 --> 04:52:39,440
here is going to be a 5 because we are

7275
04:52:39,440 --> 04:52:42,878
taking 7 and subtracting 2. i hope this

7276
04:52:42,878 --> 04:52:46,480
makes sense so if we grab this line here

7277
04:52:46,480 --> 04:52:48,958
and paste it in here so that we save on

7278
04:52:48,958 --> 04:52:51,040
some typing time

7279
04:52:51,040 --> 04:52:53,200
and i try to build again

7280
04:52:53,200 --> 04:52:54,320
we're going to

7281
04:52:54,320 --> 04:52:57,600
run the world task with gcc

7282
04:52:57,600 --> 04:53:00,000
and we're going to run rooster again it

7283
04:53:00,000 --> 04:53:02,878
is going to say result is 5 because we

7284
04:53:02,878 --> 04:53:03,600
are

7285
04:53:03,600 --> 04:53:06,320
taking 7 minus two here the result is

7286
04:53:06,320 --> 04:53:09,200
going to be five we can also do a

7287
04:53:09,200 --> 04:53:11,840
subtraction operation that is going to

7288
04:53:11,840 --> 04:53:14,320
result in a negative number so for

7289
04:53:14,320 --> 04:53:18,080
example we can say result equals

7290
04:53:18,080 --> 04:53:20,878
number one minus number two

7291
04:53:20,878 --> 04:53:22,638
and this is going to give us a negative

7292
04:53:22,638 --> 04:53:24,638
number because two minus seven is going

7293
04:53:24,638 --> 04:53:27,200
to be minus five so

7294
04:53:27,200 --> 04:53:29,680
we're going to print that here i'm going

7295
04:53:29,680 --> 04:53:31,600
to paste this end because i still have

7296
04:53:31,600 --> 04:53:33,520
this on my clipboard

7297
04:53:33,520 --> 04:53:37,280
if i bolt with gcc and run my program

7298
04:53:37,280 --> 04:53:40,798
we're going to get -5 as a result of

7299
04:53:40,798 --> 04:53:43,040
this operation here this is how you can

7300
04:53:43,040 --> 04:53:45,040
do subtraction we can also do

7301
04:53:45,040 --> 04:53:47,520
multiplication so let's go down here and

7302
04:53:47,520 --> 04:53:50,480
say that and we're going to say result

7303
04:53:50,480 --> 04:53:53,760
equals number one multiplied by number

7304
04:53:53,760 --> 04:53:56,320
two and this is the operator we used to

7305
04:53:56,320 --> 04:53:58,320
do multiplication in programming

7306
04:53:58,320 --> 04:54:00,560
languages we're going to put in our

7307
04:54:00,560 --> 04:54:02,798
print statement here

7308
04:54:02,798 --> 04:54:05,920
and we're going to world with gcc

7309
04:54:05,920 --> 04:54:08,718
and if we run rooster now we're going to

7310
04:54:08,718 --> 04:54:12,000
get 14 because we are taking

7311
04:54:12,000 --> 04:54:14,798
2 and multiplying that with 7. this is

7312
04:54:14,798 --> 04:54:17,200
how you can do multiplication

7313
04:54:17,200 --> 04:54:20,000
so what happens if you take

7314
04:54:20,000 --> 04:54:22,718
seven and divide that with two try to

7315
04:54:22,718 --> 04:54:24,718
give this a guess based on what we saw

7316
04:54:24,718 --> 04:54:26,638
in the slides we're going to go down

7317
04:54:26,638 --> 04:54:28,878
here and do division and we're going to

7318
04:54:28,878 --> 04:54:32,400
say result equals number two divided by

7319
04:54:32,400 --> 04:54:34,480
number one and uh

7320
04:54:34,480 --> 04:54:36,638
we're going to try and print this out if

7321
04:54:36,638 --> 04:54:38,718
we build this the world is going to go

7322
04:54:38,718 --> 04:54:41,040
through and if we run this we're going

7323
04:54:41,040 --> 04:54:43,920
to see that result is three

7324
04:54:43,920 --> 04:54:45,920
so to really make sense of this let's

7325
04:54:45,920 --> 04:54:47,520
look at these numbers we are taking

7326
04:54:47,520 --> 04:54:49,680
number two and dividing that with number

7327
04:54:49,680 --> 04:54:51,760
one so it is seven

7328
04:54:51,760 --> 04:54:53,440
divided by two

7329
04:54:53,440 --> 04:54:55,840
and because we can't store fractional

7330
04:54:55,840 --> 04:54:58,878
numbers in an integer the fractional

7331
04:54:58,878 --> 04:55:01,040
part is going to be basically chopped

7332
04:55:01,040 --> 04:55:03,600
off and we're going to store a three

7333
04:55:03,600 --> 04:55:04,718
because

7334
04:55:04,718 --> 04:55:06,638
two can fit in seven

7335
04:55:06,638 --> 04:55:08,480
only three times i really hope this

7336
04:55:08,480 --> 04:55:10,320
makes sense the last operation we're

7337
04:55:10,320 --> 04:55:12,400
going to look at is modulus

7338
04:55:12,400 --> 04:55:15,200
and it is a way to capture the reminder

7339
04:55:15,200 --> 04:55:18,160
of a division operation so we're going

7340
04:55:18,160 --> 04:55:20,718
to do result to play with us

7341
04:55:20,718 --> 04:55:23,040
and we're going to say number two and

7342
04:55:23,040 --> 04:55:25,600
we're going to say modulus using the

7343
04:55:25,600 --> 04:55:27,920
percentage operator here and we're going

7344
04:55:27,920 --> 04:55:29,520
to say number one

7345
04:55:29,520 --> 04:55:31,840
and we're going to print the result of

7346
04:55:31,840 --> 04:55:33,680
this and uh

7347
04:55:33,680 --> 04:55:35,520
take a look at this here and try to

7348
04:55:35,520 --> 04:55:37,200
guess what we're going to be doing what

7349
04:55:37,200 --> 04:55:39,520
we're doing here is really

7350
04:55:39,520 --> 04:55:40,400
seven

7351
04:55:40,400 --> 04:55:41,920
modulus

7352
04:55:41,920 --> 04:55:43,200
two

7353
04:55:43,200 --> 04:55:45,440
and we're going to take seven divide

7354
04:55:45,440 --> 04:55:46,878
this by two

7355
04:55:46,878 --> 04:55:49,360
and the reminder of that is going to be

7356
04:55:49,360 --> 04:55:52,000
one and that's what we're going to store

7357
04:55:52,000 --> 04:55:54,560
in this results variable here and if we

7358
04:55:54,560 --> 04:55:57,520
print that we expect to get a one here

7359
04:55:57,520 --> 04:56:00,480
this is what modulus does let's build

7360
04:56:00,480 --> 04:56:03,440
and build with gcc the world is going to

7361
04:56:03,440 --> 04:56:06,080
go through if we run rooster here we're

7362
04:56:06,080 --> 04:56:08,718
going to get a one let's do what we used

7363
04:56:08,718 --> 04:56:10,878
in the slide so that this really makes

7364
04:56:10,878 --> 04:56:13,520
sense we're going to go down here and i

7365
04:56:13,520 --> 04:56:14,400
do

7366
04:56:14,400 --> 04:56:18,400
equals 31 modulus 10. this is what we

7367
04:56:18,400 --> 04:56:20,000
used in the slides

7368
04:56:20,000 --> 04:56:22,320
so we're going to print the result here

7369
04:56:22,320 --> 04:56:24,878
and here we are really asking

7370
04:56:24,878 --> 04:56:27,040
what is going to be the reminder if we

7371
04:56:27,040 --> 04:56:30,160
take 31 and divide that by 10 and that

7372
04:56:30,160 --> 04:56:32,080
reminder is going to be stored in this

7373
04:56:32,080 --> 04:56:34,320
research variable so here we're also

7374
04:56:34,320 --> 04:56:37,600
going to get a one so let's weld with

7375
04:56:37,600 --> 04:56:40,718
gcc and we're going to run the program

7376
04:56:40,718 --> 04:56:43,680
and we are also going to get a one down

7377
04:56:43,680 --> 04:56:46,878
here again the modulus operator can be

7378
04:56:46,878 --> 04:56:49,520
hard to understand for beginners but it

7379
04:56:49,520 --> 04:56:51,920
is really capturing the reminder of the

7380
04:56:51,920 --> 04:56:54,638
division again we can see that here we

7381
04:56:54,638 --> 04:56:58,240
are asking how many times can 10 fit in

7382
04:56:58,240 --> 04:57:01,040
31 and we visualize this here it can

7383
04:57:01,040 --> 04:57:04,160
only fit in three times and the reminder

7384
04:57:04,160 --> 04:57:06,080
is going to be this red thing you see

7385
04:57:06,080 --> 04:57:08,400
here it's going to be one and when we do

7386
04:57:08,400 --> 04:57:10,480
a modulus operation here we are

7387
04:57:10,480 --> 04:57:12,798
interested in that reminder and that's

7388
04:57:12,798 --> 04:57:14,638
what we're going to be storing in

7389
04:57:14,638 --> 04:57:16,638
whatever variable that is capturing the

7390
04:57:16,638 --> 04:57:20,240
result of this modules operation

7391
04:57:20,240 --> 04:57:22,878
and that's what we basically have here

7392
04:57:22,878 --> 04:57:24,480
and this is really all we set out to do

7393
04:57:24,480 --> 04:57:26,718
in this lecture now i hope you have a

7394
04:57:26,718 --> 04:57:28,638
good understanding of these operations

7395
04:57:28,638 --> 04:57:31,520
you can do on integers we have used

7396
04:57:31,520 --> 04:57:34,000
integers here but you can really do

7397
04:57:34,000 --> 04:57:37,040
these operations on numbers except for

7398
04:57:37,040 --> 04:57:39,360
the modulus operator which is really

7399
04:57:39,360 --> 04:57:42,320
going to make sense for integral types

7400
04:57:42,320 --> 04:57:43,040
so

7401
04:57:43,040 --> 04:57:45,760
you can't really do modulus on floating

7402
04:57:45,760 --> 04:57:48,240
points or fractional numbers that's not

7403
04:57:48,240 --> 04:57:50,160
going to make any sense at all we're

7404
04:57:50,160 --> 04:57:52,080
going to stop here in this lecture in

7405
04:57:52,080 --> 04:57:53,760
the next one we're going to learn about

7406
04:57:53,760 --> 04:57:56,480
precedence and associativity a very

7407
04:57:56,480 --> 04:57:59,120
important concept for your operations in

7408
04:57:59,120 --> 04:58:01,440
your c plus plus programs

7409
04:58:01,440 --> 04:58:02,878
in this lecture we're going to learn

7410
04:58:02,878 --> 04:58:05,600
about precedence and associativity so

7411
04:58:05,600 --> 04:58:07,600
what do we mean by precedence and

7412
04:58:07,600 --> 04:58:10,000
associativity really what we mean by

7413
04:58:10,000 --> 04:58:12,480
this is a set of rules that we can

7414
04:58:12,480 --> 04:58:13,520
follow

7415
04:58:13,520 --> 04:58:15,680
to know what to do

7416
04:58:15,680 --> 04:58:18,240
when we have multiple operators in the

7417
04:58:18,240 --> 04:58:19,760
same expression

7418
04:58:19,760 --> 04:58:22,240
like in the example we have here if they

7419
04:58:22,240 --> 04:58:24,798
tell you to evaluate the result of this

7420
04:58:24,798 --> 04:58:26,080
expression

7421
04:58:26,080 --> 04:58:28,560
if we don't have clear rules to follow

7422
04:58:28,560 --> 04:58:31,280
we might have multiple answers and we

7423
04:58:31,280 --> 04:58:33,600
want to know which one is right or wrong

7424
04:58:33,600 --> 04:58:36,638
for example one might want to do a and b

7425
04:58:36,638 --> 04:58:39,600
first and then do c and then do d but

7426
04:58:39,600 --> 04:58:43,360
one might want to do e minus f

7427
04:58:43,360 --> 04:58:46,240
and do b multiply by c and then do

7428
04:58:46,240 --> 04:58:48,320
things in different ways and get

7429
04:58:48,320 --> 04:58:49,920
different results

7430
04:58:49,920 --> 04:58:52,080
hopefully you are saying that this may

7431
04:58:52,080 --> 04:58:54,798
be a big problem what we get from

7432
04:58:54,798 --> 04:58:57,120
precedence and associativity is the

7433
04:58:57,120 --> 04:58:59,360
rules we can follow to know which

7434
04:58:59,360 --> 04:59:02,400
operator we have to do first for example

7435
04:59:02,400 --> 04:59:04,000
in c plus plus

7436
04:59:04,000 --> 04:59:07,440
the multiplication and division operator

7437
04:59:07,440 --> 04:59:10,000
have to be done before you do addition

7438
04:59:10,000 --> 04:59:12,718
and subtraction and if you want to

7439
04:59:12,718 --> 04:59:15,040
evaluate this expression here you're

7440
04:59:15,040 --> 04:59:18,000
going to have to do b and c first and

7441
04:59:18,000 --> 04:59:21,120
then do d and e once you have those

7442
04:59:21,120 --> 04:59:23,920
results then you can do addition and

7443
04:59:23,920 --> 04:59:26,560
subtraction but the question remains

7444
04:59:26,560 --> 04:59:27,680
still

7445
04:59:27,680 --> 04:59:30,798
what do we do first if we have only

7446
04:59:30,798 --> 04:59:32,798
addition and subtraction in an

7447
04:59:32,798 --> 04:59:35,440
expiration and we solve that problem

7448
04:59:35,440 --> 04:59:38,638
with associativity associativity defines

7449
04:59:38,638 --> 04:59:41,120
if you do the operations from the left

7450
04:59:41,120 --> 04:59:42,638
or from the right

7451
04:59:42,638 --> 04:59:44,638
and again these things might not make

7452
04:59:44,638 --> 04:59:47,040
sense yet we're going to do an example

7453
04:59:47,040 --> 04:59:49,600
and you're going to really see what is

7454
04:59:49,600 --> 04:59:50,958
meant by this

7455
04:59:50,958 --> 04:59:53,680
to summarize precedence tells you which

7456
04:59:53,680 --> 04:59:56,400
operation you can do first and

7457
04:59:56,400 --> 04:59:58,560
associativity is going to tell you in

7458
04:59:58,560 --> 05:00:00,400
which direction you're going to go from

7459
05:00:00,400 --> 05:00:02,480
the left or from the right and some

7460
05:00:02,480 --> 05:00:04,000
operators are going to be left

7461
05:00:04,000 --> 05:00:06,480
associative and that means that you're

7462
05:00:06,480 --> 05:00:08,798
going to start evaluating them from the

7463
05:00:08,798 --> 05:00:11,200
left some operations are going to be

7464
05:00:11,200 --> 05:00:13,360
right associative and you're going to

7465
05:00:13,360 --> 05:00:16,480
start evaluating them from the right and

7466
05:00:16,480 --> 05:00:18,638
i am not making these things up there is

7467
05:00:18,638 --> 05:00:20,798
actually a c plus plus operator

7468
05:00:20,798 --> 05:00:24,480
precedence table that you can consult to

7469
05:00:24,480 --> 05:00:26,400
know which operators

7470
05:00:26,400 --> 05:00:29,280
you should do first if you really are

7471
05:00:29,280 --> 05:00:31,760
evaluating this thing with your mind

7472
05:00:31,760 --> 05:00:33,680
okay for example if you look in this

7473
05:00:33,680 --> 05:00:35,920
table there are many operators we

7474
05:00:35,920 --> 05:00:37,840
haven't seen yet but that's not the

7475
05:00:37,840 --> 05:00:40,400
problem the most important thing here is

7476
05:00:40,400 --> 05:00:42,160
to know what precedence and

7477
05:00:42,160 --> 05:00:45,040
associativity are and when we get to

7478
05:00:45,040 --> 05:00:47,600
learn about these new operators you can

7479
05:00:47,600 --> 05:00:50,400
come here and know where they sit in

7480
05:00:50,400 --> 05:00:52,878
this precedence table for example we

7481
05:00:52,878 --> 05:00:56,320
know how to do addition multiplication

7482
05:00:56,320 --> 05:00:57,920
and modulus

7483
05:00:57,920 --> 05:01:00,160
we see that the precedence for

7484
05:01:00,160 --> 05:01:03,360
multiplication division and modulus

7485
05:01:03,360 --> 05:01:06,240
is higher than for addition and

7486
05:01:06,240 --> 05:01:07,520
subtraction

7487
05:01:07,520 --> 05:01:10,400
and we can use this in our operators to

7488
05:01:10,400 --> 05:01:11,360
know

7489
05:01:11,360 --> 05:01:13,920
which one is going to be evaluated by

7490
05:01:13,920 --> 05:01:16,798
our compiler first another thing i want

7491
05:01:16,798 --> 05:01:18,798
you to notice in this table is this

7492
05:01:18,798 --> 05:01:21,680
column here on associativity if you go

7493
05:01:21,680 --> 05:01:24,320
back to our familiar operators here

7494
05:01:24,320 --> 05:01:25,840
you're going to see that

7495
05:01:25,840 --> 05:01:28,958
these operators are left to right so you

7496
05:01:28,958 --> 05:01:31,920
should start evaluating things from left

7497
05:01:31,920 --> 05:01:35,200
to right but some operators have right

7498
05:01:35,200 --> 05:01:38,320
to left associativity and when we get to

7499
05:01:38,320 --> 05:01:40,320
these operators you will start doing

7500
05:01:40,320 --> 05:01:42,958
things from right to the left okay i

7501
05:01:42,958 --> 05:01:45,040
think it is time we went to visual

7502
05:01:45,040 --> 05:01:47,120
studio code and actually played with

7503
05:01:47,120 --> 05:01:49,920
this thanks here we are in visual studio

7504
05:01:49,920 --> 05:01:53,120
code we are in our working folder we are

7505
05:01:53,120 --> 05:01:55,200
going to grab our template projects

7506
05:01:55,200 --> 05:01:57,840
we're going to copy this and put that in

7507
05:01:57,840 --> 05:02:00,000
our lecture on precedence and

7508
05:02:00,000 --> 05:02:02,480
associativity we're going to put that in

7509
05:02:02,480 --> 05:02:05,280
here we are going to open this project

7510
05:02:05,280 --> 05:02:07,760
in visual studio code we are going to

7511
05:02:07,760 --> 05:02:09,920
get rid of things we don't need and

7512
05:02:09,920 --> 05:02:12,878
remove this here in the body and we are

7513
05:02:12,878 --> 05:02:15,920
going to put in our test code so that we

7514
05:02:15,920 --> 05:02:18,400
don't have to type this and save on time

7515
05:02:18,400 --> 05:02:21,600
we have a few variables here a through g

7516
05:02:21,600 --> 05:02:24,160
and we have an expression here or a

7517
05:02:24,160 --> 05:02:25,520
statement

7518
05:02:25,520 --> 05:02:28,320
that is combining multiplication

7519
05:02:28,320 --> 05:02:31,760
division addition and subtraction and we

7520
05:02:31,760 --> 05:02:34,000
have to figure out which operation we're

7521
05:02:34,000 --> 05:02:35,680
going to do first

7522
05:02:35,680 --> 05:02:38,320
i would challenge you to do this in your

7523
05:02:38,320 --> 05:02:40,480
mind and try to guess what the result is

7524
05:02:40,480 --> 05:02:43,680
going to be before we run this in our

7525
05:02:43,680 --> 05:02:46,400
compiler we're going to compile this

7526
05:02:46,400 --> 05:02:49,360
with gcc and we are going to open our

7527
05:02:49,360 --> 05:02:50,718
terminal here

7528
05:02:50,718 --> 05:02:53,200
and if we do durham we're going to see

7529
05:02:53,200 --> 05:02:55,840
that we have rooster.exe

7530
05:02:55,840 --> 05:02:58,160
if we run it we're going to see that the

7531
05:02:58,160 --> 05:03:01,120
result is 30. how did we come up with

7532
05:03:01,120 --> 05:03:03,760
that well the precedence and

7533
05:03:03,760 --> 05:03:06,000
associativity table says that

7534
05:03:06,000 --> 05:03:08,560
multiplication and division

7535
05:03:08,560 --> 05:03:10,798
have to be done first

7536
05:03:10,798 --> 05:03:14,000
before addition and subtraction we are

7537
05:03:14,000 --> 05:03:16,560
going to take b and c and multiply those

7538
05:03:16,560 --> 05:03:19,040
so b and c multiplied we're going to get

7539
05:03:19,040 --> 05:03:21,600
a 24 we're going to try and do this in

7540
05:03:21,600 --> 05:03:24,080
our brain d divided by a we're going to

7541
05:03:24,080 --> 05:03:25,040
do that

7542
05:03:25,040 --> 05:03:28,320
so d divided by e we're going to get a 3

7543
05:03:28,320 --> 05:03:31,040
so we're going to have a 3 here and

7544
05:03:31,040 --> 05:03:33,120
after we have this we're going to do

7545
05:03:33,120 --> 05:03:36,400
addition and subtraction so we're going

7546
05:03:36,400 --> 05:03:39,680
to take a and add that to the result of

7547
05:03:39,680 --> 05:03:42,480
b and c so we're going to say

7548
05:03:42,480 --> 05:03:46,638
6 plus 24 which is the result of b and c

7549
05:03:46,638 --> 05:03:48,718
we're going to minus the results of d

7550
05:03:48,718 --> 05:03:51,920
and e and we're going to do minus here i

7551
05:03:51,920 --> 05:03:53,760
hope you are following and then we're

7552
05:03:53,760 --> 05:03:56,798
going to minus f and plus g we're going

7553
05:03:56,798 --> 05:03:59,520
to minus f which is 2

7554
05:03:59,520 --> 05:04:01,600
and do a plus g

7555
05:04:01,600 --> 05:04:05,520
which is 5. okay so this is our

7556
05:04:05,520 --> 05:04:07,600
expression here and now that we have

7557
05:04:07,600 --> 05:04:09,440
this we have to think about how we're

7558
05:04:09,440 --> 05:04:11,600
going to do this we can try to do this

7559
05:04:11,600 --> 05:04:14,958
from the right do two plus five and then

7560
05:04:14,958 --> 05:04:18,400
do three minus two plus five and go from

7561
05:04:18,400 --> 05:04:21,440
right to left but our associativity

7562
05:04:21,440 --> 05:04:25,280
table says that addition and subtraction

7563
05:04:25,280 --> 05:04:28,000
have left to right associativity so we

7564
05:04:28,000 --> 05:04:30,560
will start from the left so we're going

7565
05:04:30,560 --> 05:04:34,080
to do 6 plus 24 we're going to get 30

7566
05:04:34,080 --> 05:04:36,560
we're going to minus 3 and we're going

7567
05:04:36,560 --> 05:04:38,798
to get 27 we're going to minus 2 we're

7568
05:04:38,798 --> 05:04:41,680
going to get 25 we're going to add 5

7569
05:04:41,680 --> 05:04:43,440
we're going to get 30. i hope you are

7570
05:04:43,440 --> 05:04:45,760
following and we are really following

7571
05:04:45,760 --> 05:04:48,480
the rules from our c plus plus operator

7572
05:04:48,480 --> 05:04:50,958
precedence table here okay so this is

7573
05:04:50,958 --> 05:04:53,920
really how you would use this precedence

7574
05:04:53,920 --> 05:04:56,240
and the search activity rules to

7575
05:04:56,240 --> 05:05:00,000
evaluate your expressions okay here i

7576
05:05:00,000 --> 05:05:03,600
have another example for you so try to

7577
05:05:03,600 --> 05:05:05,840
evaluate what we're going to get from

7578
05:05:05,840 --> 05:05:07,520
this expression here

7579
05:05:07,520 --> 05:05:10,718
we have a divided by b divided by c plus

7580
05:05:10,718 --> 05:05:13,440
d minus e plus f try to do this in your

7581
05:05:13,440 --> 05:05:15,680
brain and try to guess what we're going

7582
05:05:15,680 --> 05:05:18,560
to get from the compiler if we print

7583
05:05:18,560 --> 05:05:20,000
this out

7584
05:05:20,000 --> 05:05:22,798
we're going to put in our htdc out

7585
05:05:22,798 --> 05:05:24,798
statement here and we're going to try

7586
05:05:24,798 --> 05:05:28,400
and build this with gcc of course we're

7587
05:05:28,400 --> 05:05:30,240
going to run the rooster and you're

7588
05:05:30,240 --> 05:05:33,200
going to get a 24. so how did we come up

7589
05:05:33,200 --> 05:05:35,600
with that we're going to start by

7590
05:05:35,600 --> 05:05:39,600
division and multiplication and again

7591
05:05:39,600 --> 05:05:42,798
where do we start do we do b and c first

7592
05:05:42,798 --> 05:05:46,160
or do we do a and b first well we can

7593
05:05:46,160 --> 05:05:48,958
check our precedence table here

7594
05:05:48,958 --> 05:05:50,080
and we're going to check the

7595
05:05:50,080 --> 05:05:53,360
associativity of multiplication and

7596
05:05:53,360 --> 05:05:56,080
division we're going to go to this entry

7597
05:05:56,080 --> 05:05:59,280
here 13 and we see that it is left to

7598
05:05:59,280 --> 05:06:02,560
right associative these operations here

7599
05:06:02,560 --> 05:06:05,440
are left to right associative so what

7600
05:06:05,440 --> 05:06:06,878
we're going to do we're going to start

7601
05:06:06,878 --> 05:06:09,440
from left and go to right so we are

7602
05:06:09,440 --> 05:06:12,320
going to take a and divide by b if we

7603
05:06:12,320 --> 05:06:14,560
take a divided by b we're going to get a

7604
05:06:14,560 --> 05:06:17,680
2 so let's type that here then the

7605
05:06:17,680 --> 05:06:20,160
result of that is going to be multiplied

7606
05:06:20,160 --> 05:06:22,320
by c and if we go up we're going to see

7607
05:06:22,320 --> 05:06:24,560
that c is eight so we're going to

7608
05:06:24,560 --> 05:06:26,320
multiply by eight

7609
05:06:26,320 --> 05:06:29,440
and get six so we can replace this with

7610
05:06:29,440 --> 05:06:30,958
a 16

7611
05:06:30,958 --> 05:06:32,718
and we should be here

7612
05:06:32,718 --> 05:06:36,958
then we're going to add d d is nine then

7613
05:06:36,958 --> 05:06:38,400
we're going to subtract

7614
05:06:38,400 --> 05:06:39,440
e

7615
05:06:39,440 --> 05:06:40,798
which is

7616
05:06:40,798 --> 05:06:44,480
three then we're going to add f which is

7617
05:06:44,480 --> 05:06:47,280
a five so we have 16 plus nine this is

7618
05:06:47,280 --> 05:06:50,560
going to give us 25 minus three

7619
05:06:50,560 --> 05:06:52,718
okay by checking this out i see that i

7620
05:06:52,718 --> 05:06:54,240
made a mistake

7621
05:06:54,240 --> 05:06:55,680
f is not

7622
05:06:55,680 --> 05:06:58,638
five it is a two we have here

7623
05:06:58,638 --> 05:07:01,200
and if we do this from left to right

7624
05:07:01,200 --> 05:07:03,360
because addition and subtraction are

7625
05:07:03,360 --> 05:07:05,920
left associative we have to do them from

7626
05:07:05,920 --> 05:07:08,400
left to the right we're going to take 16

7627
05:07:08,400 --> 05:07:11,440
and add a 9 we're going to get at 25

7628
05:07:11,440 --> 05:07:14,718
minus 3 we're going to get 22 plus 2 we

7629
05:07:14,718 --> 05:07:17,200
are going to get 24 and that's what we

7630
05:07:17,200 --> 05:07:19,840
have here i really hope this makes sense

7631
05:07:19,840 --> 05:07:22,320
okay so we have seen how we can use this

7632
05:07:22,320 --> 05:07:24,000
precedence table

7633
05:07:24,000 --> 05:07:26,560
but sometimes you want to make it really

7634
05:07:26,560 --> 05:07:29,280
clear which operations should be done

7635
05:07:29,280 --> 05:07:30,240
first

7636
05:07:30,240 --> 05:07:33,120
and you can do that by using parentheses

7637
05:07:33,120 --> 05:07:36,000
around your expressions let's grab the

7638
05:07:36,000 --> 05:07:38,560
first expression here and do it again

7639
05:07:38,560 --> 05:07:40,320
we're going to copy it

7640
05:07:40,320 --> 05:07:41,920
and go down

7641
05:07:41,920 --> 05:07:44,400
and put that in place and we're going to

7642
05:07:44,400 --> 05:07:48,638
store the result in our result variable

7643
05:07:48,638 --> 05:07:51,120
and notice that we are reassigning these

7644
05:07:51,120 --> 05:07:53,680
things to the result variable so that we

7645
05:07:53,680 --> 05:07:55,680
don't have to declare another variable i

7646
05:07:55,680 --> 05:07:56,958
think this is

7647
05:07:56,958 --> 05:07:59,680
clean and that's what we're doing here

7648
05:07:59,680 --> 05:08:02,560
so what we can do here is make it clear

7649
05:08:02,560 --> 05:08:05,440
that we want multiplication done first

7650
05:08:05,440 --> 05:08:07,440
by using parenthesis

7651
05:08:07,440 --> 05:08:08,320
and

7652
05:08:08,320 --> 05:08:11,040
make it clear that we want the

7653
05:08:11,040 --> 05:08:13,360
division to be done first

7654
05:08:13,360 --> 05:08:15,360
and when you do this the compiler is

7655
05:08:15,360 --> 05:08:16,878
going to see that you want this

7656
05:08:16,878 --> 05:08:19,360
operation here done first and that's

7657
05:08:19,360 --> 05:08:22,560
what it is going to do and if we print

7658
05:08:22,560 --> 05:08:25,360
result again we're going to get exactly

7659
05:08:25,360 --> 05:08:28,958
the same thing we had before stdc out

7660
05:08:28,958 --> 05:08:30,480
result

7661
05:08:30,480 --> 05:08:32,878
and we're going to put result out and

7662
05:08:32,878 --> 05:08:35,040
let's make it clear that we are using

7663
05:08:35,040 --> 05:08:37,120
parents here to

7664
05:08:37,120 --> 05:08:39,440
signal which operation we want to be

7665
05:08:39,440 --> 05:08:42,958
done first we can compile this with gcc

7666
05:08:42,958 --> 05:08:45,680
we're going to run the task to

7667
05:08:45,680 --> 05:08:47,920
build with gcc

7668
05:08:47,920 --> 05:08:50,878
and if we run the program

7669
05:08:50,878 --> 05:08:53,680
we're going to see that the result is 30

7670
05:08:53,680 --> 05:08:56,878
exactly what we had before but now it is

7671
05:08:56,878 --> 05:08:59,200
very clear to the reader of this piece

7672
05:08:59,200 --> 05:09:02,560
of code that we want b and c done first

7673
05:09:02,560 --> 05:09:04,400
they don't have to go through the

7674
05:09:04,400 --> 05:09:06,718
precedence table to really try and

7675
05:09:06,718 --> 05:09:09,040
figure this out potentially wasting

7676
05:09:09,040 --> 05:09:11,040
precious time another thing you can do

7677
05:09:11,040 --> 05:09:14,320
with this is for example what if the

7678
05:09:14,320 --> 05:09:16,480
precedence table is not working

7679
05:09:16,480 --> 05:09:19,200
according to your needs for example you

7680
05:09:19,200 --> 05:09:21,360
really want a and b

7681
05:09:21,360 --> 05:09:23,840
done first you can specify this with

7682
05:09:23,840 --> 05:09:26,320
parents here and what this is basically

7683
05:09:26,320 --> 05:09:28,560
going to do is going to force the

7684
05:09:28,560 --> 05:09:31,280
compiler to do this first it's no longer

7685
05:09:31,280 --> 05:09:33,920
going to do b multiply by c and d

7686
05:09:33,920 --> 05:09:37,120
divided by e it's going to evaluate this

7687
05:09:37,120 --> 05:09:39,360
first then it's going to follow the

7688
05:09:39,360 --> 05:09:41,840
order in the precedence table that we

7689
05:09:41,840 --> 05:09:44,240
have seen before so try to guess what

7690
05:09:44,240 --> 05:09:46,480
we're going to get now and i am going to

7691
05:09:46,480 --> 05:09:48,718
run the code and we're going to

7692
05:09:48,718 --> 05:09:51,360
go through this together so let's run

7693
05:09:51,360 --> 05:09:54,480
task and we're going to run rooster now

7694
05:09:54,480 --> 05:09:57,520
you see that the result is 72. what is

7695
05:09:57,520 --> 05:10:00,160
happening here well let's go through

7696
05:10:00,160 --> 05:10:03,520
this line by line we are doing a plus b

7697
05:10:03,520 --> 05:10:05,520
which is a

7698
05:10:05,520 --> 05:10:08,000
9 so we're going to get a nine here

7699
05:10:08,000 --> 05:10:09,840
we're going to put that here as a

7700
05:10:09,840 --> 05:10:11,520
comment then we're going to multiply

7701
05:10:11,520 --> 05:10:13,120
that by c

7702
05:10:13,120 --> 05:10:16,718
so we're going to do 9 multiply by 8 and

7703
05:10:16,718 --> 05:10:20,160
that's going to yield a 72

7704
05:10:20,160 --> 05:10:23,440
and by that time we're going to be here

7705
05:10:23,440 --> 05:10:26,958
and we're going to do the division first

7706
05:10:26,958 --> 05:10:28,560
d by e

7707
05:10:28,560 --> 05:10:30,878
then we're going to take nine and divide

7708
05:10:30,878 --> 05:10:33,040
by three that's going to yield the three

7709
05:10:33,040 --> 05:10:35,120
so we're going to have a three here

7710
05:10:35,120 --> 05:10:36,718
minus 3

7711
05:10:36,718 --> 05:10:39,760
we're going to minus f which is a 2 and

7712
05:10:39,760 --> 05:10:42,798
we're going to do plus g which is a 5.

7713
05:10:42,798 --> 05:10:44,958
if we evaluate this

7714
05:10:44,958 --> 05:10:47,440
we're going to get 72 minus 3 which is

7715
05:10:47,440 --> 05:10:50,878
going to be 69 minus 2 it's going to be

7716
05:10:50,878 --> 05:10:54,958
67 plus 2 it's going to be 72 and that's

7717
05:10:54,958 --> 05:10:57,040
what we have here hopefully you can see

7718
05:10:57,040 --> 05:11:00,080
that using the parents not only can you

7719
05:11:00,080 --> 05:11:02,480
make it very clear which operation you

7720
05:11:02,480 --> 05:11:04,400
want to be done first you can also

7721
05:11:04,400 --> 05:11:07,680
define the rules that are prescribed by

7722
05:11:07,680 --> 05:11:10,080
the precedence tables that are defined

7723
05:11:10,080 --> 05:11:12,878
in c plus plus i hope this makes sense

7724
05:11:12,878 --> 05:11:14,400
and this is really all we set up to do

7725
05:11:14,400 --> 05:11:16,480
in this lecture to learn a little more

7726
05:11:16,480 --> 05:11:19,200
about precedence and associativity

7727
05:11:19,200 --> 05:11:22,000
and my advice to beginning programmers

7728
05:11:22,000 --> 05:11:24,958
is not to rely on the president's table

7729
05:11:24,958 --> 05:11:27,760
too much it is to try and make your

7730
05:11:27,760 --> 05:11:30,958
intent very clear using parenthesis and

7731
05:11:30,958 --> 05:11:32,560
anyone reading your code you want to

7732
05:11:32,560 --> 05:11:35,200
have to go check these rules in

7733
05:11:35,200 --> 05:11:37,680
the reference c plus plus documentation

7734
05:11:37,680 --> 05:11:39,840
they are going to directly understand

7735
05:11:39,840 --> 05:11:42,160
what your expression is going to do and

7736
05:11:42,160 --> 05:11:44,718
that's a good thing readability of your

7737
05:11:44,718 --> 05:11:46,718
code is really something you should

7738
05:11:46,718 --> 05:11:48,798
strive for this is really all we set out

7739
05:11:48,798 --> 05:11:50,878
to do in this lecture i hope you have a

7740
05:11:50,878 --> 05:11:54,080
better idea about precedence

7741
05:11:54,080 --> 05:11:56,560
and associativity we are going to stop

7742
05:11:56,560 --> 05:11:58,480
here in this lecture and the next one

7743
05:11:58,480 --> 05:12:00,000
we're going to learn about some cool

7744
05:12:00,000 --> 05:12:02,320
things we can do with addition and

7745
05:12:02,320 --> 05:12:03,840
subtraction

7746
05:12:03,840 --> 05:12:06,080
go ahead and finish up here and meet me

7747
05:12:06,080 --> 05:12:07,840
there in this lecture we're going to be

7748
05:12:07,840 --> 05:12:10,400
learning about prefix and postfix

7749
05:12:10,400 --> 05:12:13,120
addition and subtraction we have an

7750
05:12:13,120 --> 05:12:15,600
example here and it is a simple example

7751
05:12:15,600 --> 05:12:18,718
we've seen a lot of times by now we have

7752
05:12:18,718 --> 05:12:21,360
a variable value it is an integer and we

7753
05:12:21,360 --> 05:12:25,440
have a 5 inside we can add a 1 to it or

7754
05:12:25,440 --> 05:12:28,000
we can increment it by one this is

7755
05:12:28,000 --> 05:12:30,000
another term we use in programming

7756
05:12:30,000 --> 05:12:31,840
languages when we say we are

7757
05:12:31,840 --> 05:12:34,560
incrementing a value we are adding

7758
05:12:34,560 --> 05:12:36,798
something to it in this case we are

7759
05:12:36,798 --> 05:12:40,160
incrementing it by one and we are

7760
05:12:40,160 --> 05:12:42,560
basically going to store a six and this

7761
05:12:42,560 --> 05:12:45,040
value here so if we print this out we're

7762
05:12:45,040 --> 05:12:47,440
going to get a six here

7763
05:12:47,440 --> 05:12:49,600
this is what we would expect we are

7764
05:12:49,600 --> 05:12:51,840
resetting the value to five and that we

7765
05:12:51,840 --> 05:12:54,718
are going to minus one or decrement by

7766
05:12:54,718 --> 05:12:57,120
one and the result is going to be saved

7767
05:12:57,120 --> 05:13:00,400
in value again so the second stdc out

7768
05:13:00,400 --> 05:13:03,600
statement here is going to print a 4.

7769
05:13:03,600 --> 05:13:06,080
this is something you should expect

7770
05:13:06,080 --> 05:13:08,560
now another thing we can do in c plus

7771
05:13:08,560 --> 05:13:11,680
plus is do something like value plus

7772
05:13:11,680 --> 05:13:13,040
plus here

7773
05:13:13,040 --> 05:13:15,680
and what do we mean by that when you use

7774
05:13:15,680 --> 05:13:17,200
a postfix

7775
05:13:17,200 --> 05:13:19,360
increment operator like this

7776
05:13:19,360 --> 05:13:21,040
the first thing you should know is that

7777
05:13:21,040 --> 05:13:23,280
this is going to increment by one it's

7778
05:13:23,280 --> 05:13:25,120
not going to increment by any other

7779
05:13:25,120 --> 05:13:28,240
value c plus plus doesn't provide a way

7780
05:13:28,240 --> 05:13:30,718
for you to specify another number to

7781
05:13:30,718 --> 05:13:33,840
increment by so value plus plus here is

7782
05:13:33,840 --> 05:13:36,160
going to increment by one but another

7783
05:13:36,160 --> 05:13:37,600
thing you should know

7784
05:13:37,600 --> 05:13:39,840
is that it's not going to increment

7785
05:13:39,840 --> 05:13:41,920
directly what's going to happen here if

7786
05:13:41,920 --> 05:13:44,000
you look to the top here we have a value

7787
05:13:44,000 --> 05:13:47,920
5 when execution hits this stdcl

7788
05:13:47,920 --> 05:13:49,120
statement

7789
05:13:49,120 --> 05:13:52,160
we are going to grab the value here so

7790
05:13:52,160 --> 05:13:54,798
here we're going to really print a 5 but

7791
05:13:54,798 --> 05:13:57,600
as soon as this statement is done the

7792
05:13:57,600 --> 05:14:00,240
value is going to increment by one so

7793
05:14:00,240 --> 05:14:02,160
the next time somebody is going to use

7794
05:14:02,160 --> 05:14:04,718
this value here is he's going to find in

7795
05:14:04,718 --> 05:14:07,440
a 6 and that's what we have here so the

7796
05:14:07,440 --> 05:14:09,120
first one is going to print a five

7797
05:14:09,120 --> 05:14:11,440
because we're going to grab the value

7798
05:14:11,440 --> 05:14:14,878
in here as is but as soon as we have our

7799
05:14:14,878 --> 05:14:17,360
value this is going to increment by one

7800
05:14:17,360 --> 05:14:19,520
this is what we mean by this value plus

7801
05:14:19,520 --> 05:14:21,920
plus here and the second statement is

7802
05:14:21,920 --> 05:14:24,958
going to print sx because it is already

7803
05:14:24,958 --> 05:14:27,840
incremented and we call this postfix

7804
05:14:27,840 --> 05:14:30,958
increment because plus plus is after the

7805
05:14:30,958 --> 05:14:33,680
value here and this is really what this

7806
05:14:33,680 --> 05:14:36,240
operator does and sometimes it is going

7807
05:14:36,240 --> 05:14:38,320
to come in handy in your c plus plus

7808
05:14:38,320 --> 05:14:40,718
applications we can also do the same

7809
05:14:40,718 --> 05:14:43,440
thing with minus minus it is going to

7810
05:14:43,440 --> 05:14:45,600
grab whatever value we have in this

7811
05:14:45,600 --> 05:14:47,840
variable so we have in a five so that's

7812
05:14:47,840 --> 05:14:49,920
what we're going to print here

7813
05:14:49,920 --> 05:14:52,878
and the next statement is going to find

7814
05:14:52,878 --> 05:14:55,280
it already decremented by one because

7815
05:14:55,280 --> 05:14:57,360
after we have our five we're going to

7816
05:14:57,360 --> 05:14:59,280
decrement by one that's what we are

7817
05:14:59,280 --> 05:15:01,440
saying here and we're going to find the

7818
05:15:01,440 --> 05:15:05,360
nf4 because 5 decremented by 1 becomes a

7819
05:15:05,360 --> 05:15:08,400
4. i really hope this makes sense ok so

7820
05:15:08,400 --> 05:15:11,280
what we have seen here is postfix

7821
05:15:11,280 --> 05:15:14,240
increment and decrement but we can also

7822
05:15:14,240 --> 05:15:17,200
do a prefix version of this thing if you

7823
05:15:17,200 --> 05:15:19,200
look at the example we have here we have

7824
05:15:19,200 --> 05:15:20,320
a five

7825
05:15:20,320 --> 05:15:23,280
and we are saying plus plus value so

7826
05:15:23,280 --> 05:15:25,760
this is going to increment the value

7827
05:15:25,760 --> 05:15:28,958
directly so as soon as this statement is

7828
05:15:28,958 --> 05:15:31,520
executed the plus plus value statement

7829
05:15:31,520 --> 05:15:35,040
here we're going to have a 6 inside and

7830
05:15:35,040 --> 05:15:37,120
if we print it we're going to get a 6

7831
05:15:37,120 --> 05:15:39,040
and this is what you see here if we go

7832
05:15:39,040 --> 05:15:41,760
down we are resetting our value and we

7833
05:15:41,760 --> 05:15:42,958
are going to

7834
05:15:42,958 --> 05:15:45,760
prefix increment in place

7835
05:15:45,760 --> 05:15:48,400
so in here we are going to increment the

7836
05:15:48,400 --> 05:15:51,360
value before we actually print it here

7837
05:15:51,360 --> 05:15:54,080
and we are also going to get a six year

7838
05:15:54,080 --> 05:15:56,480
i hope this makes sense and if you have

7839
05:15:56,480 --> 05:15:58,878
any problem with this i think if we go

7840
05:15:58,878 --> 05:16:01,120
in visual studio code you're going to

7841
05:16:01,120 --> 05:16:02,718
have a better way to say this you're

7842
05:16:02,718 --> 05:16:04,400
going to see the code running and make

7843
05:16:04,400 --> 05:16:07,520
sense of it okay so i think that

7844
05:16:07,520 --> 05:16:09,360
now you understand why we're going to

7845
05:16:09,360 --> 05:16:11,920
have these numbers printed if we go down

7846
05:16:11,920 --> 05:16:13,440
we can do the same thing with

7847
05:16:13,440 --> 05:16:15,680
decrementing we have a value here it's

7848
05:16:15,680 --> 05:16:16,560
five

7849
05:16:16,560 --> 05:16:17,600
if we

7850
05:16:17,600 --> 05:16:20,160
prefix decrement it it's going to be a

7851
05:16:20,160 --> 05:16:22,560
four here and if we print it we're going

7852
05:16:22,560 --> 05:16:23,920
to get a four

7853
05:16:23,920 --> 05:16:25,680
if you go down here we are resetting

7854
05:16:25,680 --> 05:16:29,280
that to five and we are going to prefix

7855
05:16:29,280 --> 05:16:32,000
decrement in place and this is also

7856
05:16:32,000 --> 05:16:34,320
going to print a four because we have a

7857
05:16:34,320 --> 05:16:37,600
five here and if we decrement it by one

7858
05:16:37,600 --> 05:16:38,958
we're going to get a four and that's

7859
05:16:38,958 --> 05:16:41,200
what we're going to get here okay this

7860
05:16:41,200 --> 05:16:44,240
is really all these prefix and postfix

7861
05:16:44,240 --> 05:16:46,638
increment and decrement operators are

7862
05:16:46,638 --> 05:16:49,040
about we are going to go in visual

7863
05:16:49,040 --> 05:16:51,280
studio code and actually see this

7864
05:16:51,280 --> 05:16:54,160
running okay here we are in our working

7865
05:16:54,160 --> 05:16:56,000
directory we're going to do the usual

7866
05:16:56,000 --> 05:16:57,920
we're going to copy code from our

7867
05:16:57,920 --> 05:17:00,240
template project we're going to put that

7868
05:17:00,240 --> 05:17:02,560
in here we're going to go up and open

7869
05:17:02,560 --> 05:17:05,200
this up in visual studio code so we're

7870
05:17:05,200 --> 05:17:08,080
going to remove things we don't need and

7871
05:17:08,080 --> 05:17:09,680
we're going to remove this

7872
05:17:09,680 --> 05:17:11,840
and we are going to put in the code we

7873
05:17:11,840 --> 05:17:15,200
exactly saw in the slides here we have a

7874
05:17:15,200 --> 05:17:18,638
value it is an integer and it is five

7875
05:17:18,638 --> 05:17:20,798
if we increment it by one we're going to

7876
05:17:20,798 --> 05:17:24,320
get a six here okay and if we print it

7877
05:17:24,320 --> 05:17:26,160
that's what we're going to get we are

7878
05:17:26,160 --> 05:17:28,718
resetting this to five and if we

7879
05:17:28,718 --> 05:17:30,958
decrement it by one we're going to get a

7880
05:17:30,958 --> 05:17:32,400
four here

7881
05:17:32,400 --> 05:17:35,040
so if we run this piece of code we

7882
05:17:35,040 --> 05:17:37,840
should have a six here printed out

7883
05:17:37,840 --> 05:17:39,680
and a four

7884
05:17:39,680 --> 05:17:40,958
down here

7885
05:17:40,958 --> 05:17:43,920
we're going to bring up our terminal

7886
05:17:43,920 --> 05:17:47,120
and build this with gcc the weld is

7887
05:17:47,120 --> 05:17:48,560
going to go through

7888
05:17:48,560 --> 05:17:51,280
and if we run the program we're going to

7889
05:17:51,280 --> 05:17:54,638
get the value a6 and it is four and this

7890
05:17:54,638 --> 05:17:57,360
is really what we expect here okay now

7891
05:17:57,360 --> 05:17:59,200
that this is really clear we're going to

7892
05:17:59,200 --> 05:18:02,160
go down and play with post fix

7893
05:18:02,160 --> 05:18:04,718
increment and decrement

7894
05:18:04,718 --> 05:18:07,600
i am going to put in a separator here so

7895
05:18:07,600 --> 05:18:10,638
that we can clearly see in our terminal

7896
05:18:10,638 --> 05:18:13,760
here and we are going to put in our test

7897
05:18:13,760 --> 05:18:16,000
code that we are going to use

7898
05:18:16,000 --> 05:18:19,040
to play with this let's bring this down

7899
05:18:19,040 --> 05:18:20,798
a little bit so that you can see

7900
05:18:20,798 --> 05:18:23,680
everything we can remove these things we

7901
05:18:23,680 --> 05:18:26,320
don't need them anymore okay we are

7902
05:18:26,320 --> 05:18:28,000
going to take the value we had we're

7903
05:18:28,000 --> 05:18:29,840
going to

7904
05:18:29,840 --> 05:18:32,000
reset that to a five

7905
05:18:32,000 --> 05:18:34,958
and if we value plus plus here

7906
05:18:34,958 --> 05:18:37,120
this is going to be a five because we're

7907
05:18:37,120 --> 05:18:40,080
going to capture the value as is so here

7908
05:18:40,080 --> 05:18:41,920
we're going to get a five

7909
05:18:41,920 --> 05:18:44,160
but next time we get this value it's

7910
05:18:44,160 --> 05:18:46,320
going to already be a sex because we

7911
05:18:46,320 --> 05:18:49,680
increment immediately after capturing

7912
05:18:49,680 --> 05:18:52,080
the value here so here we're going to

7913
05:18:52,080 --> 05:18:55,520
get a 5 and here we're going to get a 6.

7914
05:18:55,520 --> 05:18:57,600
i hope this makes sense

7915
05:18:57,600 --> 05:19:00,560
and if we go down here we are resetting

7916
05:19:00,560 --> 05:19:03,200
our value to 5 before we do any

7917
05:19:03,200 --> 05:19:04,798
decrementation

7918
05:19:04,798 --> 05:19:07,600
we are going to capture the value as is

7919
05:19:07,600 --> 05:19:09,440
because we are doing post fixed

7920
05:19:09,440 --> 05:19:10,718
decrement

7921
05:19:10,718 --> 05:19:13,040
and here we are going to get a 5 because

7922
05:19:13,040 --> 05:19:15,840
we are capturing the value as s

7923
05:19:15,840 --> 05:19:18,080
but as soon as we capture our value

7924
05:19:18,080 --> 05:19:20,560
we're going to decrement it and the

7925
05:19:20,560 --> 05:19:22,958
other statement here is going to get a

7926
05:19:22,958 --> 05:19:25,680
decremented value and that's going to be

7927
05:19:25,680 --> 05:19:29,440
a 4. so here we're going to print 5 6 5

7928
05:19:29,440 --> 05:19:30,560
4.

7929
05:19:30,560 --> 05:19:34,718
let's try and build this with gcc

7930
05:19:34,718 --> 05:19:36,638
to see that we have no problems we have

7931
05:19:36,638 --> 05:19:39,360
no problems the world is good if we try

7932
05:19:39,360 --> 05:19:41,200
to run rooster now

7933
05:19:41,200 --> 05:19:44,638
we are going to get the

7934
05:19:44,638 --> 05:19:47,440
results we had before

7935
05:19:47,440 --> 05:19:51,040
but uh for this code we just put in here

7936
05:19:51,040 --> 05:19:53,200
the value is going to be a 5 and that's

7937
05:19:53,200 --> 05:19:55,040
what we have here

7938
05:19:55,040 --> 05:19:56,878
and we're going to get a 6 which is

7939
05:19:56,878 --> 05:19:58,638
coming from here

7940
05:19:58,638 --> 05:20:01,280
after we are going to decrement and we

7941
05:20:01,280 --> 05:20:03,760
are going to capture the value as is

7942
05:20:03,760 --> 05:20:06,480
we're going to get this 5 here and for

7943
05:20:06,480 --> 05:20:08,400
the last statement we're going to get a

7944
05:20:08,400 --> 05:20:11,520
4 because the value is already

7945
05:20:11,520 --> 05:20:14,240
decremented and that's the for we are

7946
05:20:14,240 --> 05:20:15,520
seeing here

7947
05:20:15,520 --> 05:20:18,240
i really hope this makes sense and this

7948
05:20:18,240 --> 05:20:19,600
really covers

7949
05:20:19,600 --> 05:20:22,320
the postfix increment and decrement

7950
05:20:22,320 --> 05:20:24,798
operators the last thing we want to see

7951
05:20:24,798 --> 05:20:28,240
in this lecture is that we can also do

7952
05:20:28,240 --> 05:20:31,680
prefix increment and decrementation

7953
05:20:31,680 --> 05:20:34,160
we're going to go down here and

7954
05:20:34,160 --> 05:20:35,840
set up a place where we're going to be

7955
05:20:35,840 --> 05:20:37,680
playing with this so we're going to say

7956
05:20:37,680 --> 05:20:39,440
prefix

7957
05:20:39,440 --> 05:20:41,360
and we are going to put in our code

7958
05:20:41,360 --> 05:20:43,440
because i don't want to type all this

7959
05:20:43,440 --> 05:20:46,320
that would waste your valuable time but

7960
05:20:46,320 --> 05:20:48,240
i do encourage you to type these things

7961
05:20:48,240 --> 05:20:49,680
out and really

7962
05:20:49,680 --> 05:20:51,920
drill them in your brain because that's

7963
05:20:51,920 --> 05:20:53,760
how you're going to learn okay let's

7964
05:20:53,760 --> 05:20:55,360
bring this down so that we can

7965
05:20:55,360 --> 05:20:58,320
understand this piece of code so we are

7966
05:20:58,320 --> 05:21:01,600
starting by resetting our value to 5 and

7967
05:21:01,600 --> 05:21:04,320
notice here that we do plus plus value

7968
05:21:04,320 --> 05:21:06,878
this is going to increment value right

7969
05:21:06,878 --> 05:21:08,958
away by this time the value is going to

7970
05:21:08,958 --> 05:21:12,240
be six and if we print it out here we're

7971
05:21:12,240 --> 05:21:14,558
going to have a six printed down we're

7972
05:21:14,558 --> 05:21:16,718
going to reset it to five and then we're

7973
05:21:16,718 --> 05:21:19,680
going to implement that in place this is

7974
05:21:19,680 --> 05:21:22,320
also going to be printing six and if you

7975
05:21:22,320 --> 05:21:23,920
go down we're going to do the same

7976
05:21:23,920 --> 05:21:25,840
version of the same thing but we are

7977
05:21:25,840 --> 05:21:27,680
going to be decrementing so we're going

7978
05:21:27,680 --> 05:21:30,000
to decrement the value that we just

7979
05:21:30,000 --> 05:21:31,280
reset here

7980
05:21:31,280 --> 05:21:33,280
here it's going to become a 4 and that's

7981
05:21:33,280 --> 05:21:35,600
what we're going to print and if we go

7982
05:21:35,600 --> 05:21:38,240
down here we reset it again to a 5 and

7983
05:21:38,240 --> 05:21:41,600
we prefix decrement it in place

7984
05:21:41,600 --> 05:21:44,878
so the 5 here is going to become a 4

7985
05:21:44,878 --> 05:21:46,638
in here and that's what we're going to

7986
05:21:46,638 --> 05:21:48,958
print out if we build and run that's

7987
05:21:48,958 --> 05:21:50,400
what we're going to get we're going to

7988
05:21:50,400 --> 05:21:53,200
run our task to build with gcc

7989
05:21:53,200 --> 05:21:56,400
the build is good and if we run our

7990
05:21:56,400 --> 05:22:00,000
rooster application the results for the

7991
05:22:00,000 --> 05:22:01,920
code we just put in here are just going

7992
05:22:01,920 --> 05:22:03,360
to show up here

7993
05:22:03,360 --> 05:22:05,840
and you see that we get a six six this

7994
05:22:05,840 --> 05:22:06,958
is six

7995
05:22:06,958 --> 05:22:09,600
the other six and for the last two

7996
05:22:09,600 --> 05:22:11,280
statements we're going to be getting

7997
05:22:11,280 --> 05:22:13,840
fours and that's what we have here i

7998
05:22:13,840 --> 05:22:15,680
really hope that now you have a better

7999
05:22:15,680 --> 05:22:18,638
idea of this prefix and postfix

8000
05:22:18,638 --> 05:22:21,520
increment and decrement operators and

8001
05:22:21,520 --> 05:22:24,080
you're going to make use of them when

8002
05:22:24,080 --> 05:22:26,160
they really helped you design your

8003
05:22:26,160 --> 05:22:28,480
applications better okay so these are

8004
05:22:28,480 --> 05:22:31,280
your tools use them when they make sense

8005
05:22:31,280 --> 05:22:33,040
another thing that i want to emphasize

8006
05:22:33,040 --> 05:22:35,200
here is that these operators only

8007
05:22:35,200 --> 05:22:38,558
increment or a decrement by one you

8008
05:22:38,558 --> 05:22:40,400
can't make them

8009
05:22:40,400 --> 05:22:43,200
do things in increments of five or seven

8010
05:22:43,200 --> 05:22:45,840
or ten they are going to work in

8011
05:22:45,840 --> 05:22:48,160
increments or decrements of one we are

8012
05:22:48,160 --> 05:22:50,000
going to see a way we can do that with

8013
05:22:50,000 --> 05:22:52,320
other operators in the last lecture but

8014
05:22:52,320 --> 05:22:55,120
these prefix and postfix operators can't

8015
05:22:55,120 --> 05:22:58,080
do that and another thing that some of

8016
05:22:58,080 --> 05:23:00,798
you might be wondering about is if we

8017
05:23:00,798 --> 05:23:03,440
have the same kind of operators with

8018
05:23:03,440 --> 05:23:06,080
multiplication or division and we don't

8019
05:23:06,080 --> 05:23:08,480
have those operators in c plus plus

8020
05:23:08,480 --> 05:23:10,000
maybe we're going to have them in the

8021
05:23:10,000 --> 05:23:12,240
future when they make sense but in the

8022
05:23:12,240 --> 05:23:14,798
current version of c plus plus we don't

8023
05:23:14,798 --> 05:23:16,638
have them we are going to stop here in

8024
05:23:16,638 --> 05:23:18,558
this lecture in the next one we're going

8025
05:23:18,558 --> 05:23:21,200
to learn about compound assignment

8026
05:23:21,200 --> 05:23:23,520
operators in this lecture we're going to

8027
05:23:23,520 --> 05:23:26,000
learn about compound assignment

8028
05:23:26,000 --> 05:23:27,360
operators

8029
05:23:27,360 --> 05:23:30,080
and these are operators that allow you

8030
05:23:30,080 --> 05:23:33,120
to do an arithmetic operation like

8031
05:23:33,120 --> 05:23:35,920
addition subtraction multiplication

8032
05:23:35,920 --> 05:23:39,360
division and modulus and assign the

8033
05:23:39,360 --> 05:23:43,040
result to a value in one go let's look

8034
05:23:43,040 --> 05:23:45,360
at an example here we have value here

8035
05:23:45,360 --> 05:23:48,160
which is 45 it is an integer and we're

8036
05:23:48,160 --> 05:23:49,920
going to print that out but if you go

8037
05:23:49,920 --> 05:23:54,080
down here we are doing value plus equal

8038
05:23:54,080 --> 05:23:56,400
five and if you look at the comment here

8039
05:23:56,400 --> 05:23:59,440
this is equivalent to if you did value

8040
05:23:59,440 --> 05:24:02,080
equals value plus five so what this is

8041
05:24:02,080 --> 05:24:03,920
going to do it's going to take whatever

8042
05:24:03,920 --> 05:24:06,320
value is in this value here it's going

8043
05:24:06,320 --> 05:24:08,480
to increment that by five so that's

8044
05:24:08,480 --> 05:24:10,798
going to become a 50 and we're going to

8045
05:24:10,798 --> 05:24:14,160
store that 50 results back in this

8046
05:24:14,160 --> 05:24:16,400
variable here so by this time if we

8047
05:24:16,400 --> 05:24:17,840
printed this out we're going to get a

8048
05:24:17,840 --> 05:24:20,320
50. again we're going to take the value

8049
05:24:20,320 --> 05:24:23,200
it is a 45 we're going to add a 5 it's

8050
05:24:23,200 --> 05:24:25,360
going to become a 50 and we're going to

8051
05:24:25,360 --> 05:24:28,718
store that result back in this value

8052
05:24:28,718 --> 05:24:31,600
variable here it's going to become 50

8053
05:24:31,600 --> 05:24:33,440
and if we print here we're going to get

8054
05:24:33,440 --> 05:24:36,480
a 50. this is the addition version of

8055
05:24:36,480 --> 05:24:39,520
the compound assignment operator we also

8056
05:24:39,520 --> 05:24:42,240
have a version for subtraction and we

8057
05:24:42,240 --> 05:24:44,400
have an example of that here so it's

8058
05:24:44,400 --> 05:24:46,638
going to take whatever value is in this

8059
05:24:46,638 --> 05:24:48,798
value variable it is going to find in a

8060
05:24:48,798 --> 05:24:51,920
50 we're going to subtract 5 we're going

8061
05:24:51,920 --> 05:24:54,480
to get a 45 and that's what we're going

8062
05:24:54,480 --> 05:24:56,878
to store in this value here

8063
05:24:56,878 --> 05:25:00,558
and by the time we hit this stdc out

8064
05:25:00,558 --> 05:25:03,200
statement we're going to print a 45.

8065
05:25:03,200 --> 05:25:05,120
again we have another version for the

8066
05:25:05,120 --> 05:25:07,280
multiplication here so that we can

8067
05:25:07,280 --> 05:25:09,680
really play with all these things

8068
05:25:09,680 --> 05:25:11,520
we're going to take whatever value is in

8069
05:25:11,520 --> 05:25:14,000
here we're going to multiply that by 2

8070
05:25:14,000 --> 05:25:16,878
here we're going to get a 90 and that's

8071
05:25:16,878 --> 05:25:18,638
what we're going to store back in this

8072
05:25:18,638 --> 05:25:20,958
value and if we print here we're going

8073
05:25:20,958 --> 05:25:22,718
to get a 90

8074
05:25:22,718 --> 05:25:24,638
printed out we're going to go down and

8075
05:25:24,638 --> 05:25:27,600
do a version for a division the value is

8076
05:25:27,600 --> 05:25:30,558
90 we're going to divide that by 30 and

8077
05:25:30,558 --> 05:25:32,958
we're going to store the result back in

8078
05:25:32,958 --> 05:25:36,080
value here and we're going to get a 30

8079
05:25:36,080 --> 05:25:38,878
stored in here and if we print out

8080
05:25:38,878 --> 05:25:41,040
that's what we're going to get here

8081
05:25:41,040 --> 05:25:43,520
we also have a modulus version of this

8082
05:25:43,520 --> 05:25:45,440
and it works really well

8083
05:25:45,440 --> 05:25:47,600
here we have unit 30 we're going to take

8084
05:25:47,600 --> 05:25:51,200
it and do modulus 11 and what is the

8085
05:25:51,200 --> 05:25:54,240
reminder of dividing 30

8086
05:25:54,240 --> 05:25:57,120
by 11. the reminder is going to be 8

8087
05:25:57,120 --> 05:25:58,240
because

8088
05:25:58,240 --> 05:26:02,320
11 can only fit in 30 two times and

8089
05:26:02,320 --> 05:26:04,000
we're going to be left with the knight

8090
05:26:04,000 --> 05:26:05,040
because

8091
05:26:05,040 --> 05:26:08,240
30 minus 22 is eight and that's what

8092
05:26:08,240 --> 05:26:10,400
we're going to store in the value here

8093
05:26:10,400 --> 05:26:12,558
and if we print out that's what we're

8094
05:26:12,558 --> 05:26:14,400
going to get again

8095
05:26:14,400 --> 05:26:16,320
if you have trouble understanding this

8096
05:26:16,320 --> 05:26:19,040
modulus operator here please go back in

8097
05:26:19,040 --> 05:26:21,200
a few lectures back we had a chance to

8098
05:26:21,200 --> 05:26:23,440
learn about it make sure you understand

8099
05:26:23,440 --> 05:26:25,760
it and then come back here and this is

8100
05:26:25,760 --> 05:26:27,440
all going to make sense

8101
05:26:27,440 --> 05:26:30,480
this is really all compound assignment

8102
05:26:30,480 --> 05:26:32,878
is all about we're going to head to

8103
05:26:32,878 --> 05:26:35,200
visual studio code and actually play

8104
05:26:35,200 --> 05:26:39,040
with us okay here we are in our working

8105
05:26:39,040 --> 05:26:41,520
directory we're going to copy our

8106
05:26:41,520 --> 05:26:44,798
template project as we always do

8107
05:26:44,798 --> 05:26:48,240
and we're going to put that in our

8108
05:26:48,240 --> 05:26:50,798
compound assignment operators

8109
05:26:50,798 --> 05:26:52,320
lecture here

8110
05:26:52,320 --> 05:26:54,558
we're going to come up and we are going

8111
05:26:54,558 --> 05:26:56,798
to open this folder in visual studio

8112
05:26:56,798 --> 05:26:58,878
code the project is going to show up in

8113
05:26:58,878 --> 05:27:01,280
here and we're going to open our main

8114
05:27:01,280 --> 05:27:04,718
cpp file and we are going to remove what

8115
05:27:04,718 --> 05:27:06,558
we don't need

8116
05:27:06,558 --> 05:27:08,718
we are going to put in our code so that

8117
05:27:08,718 --> 05:27:12,400
we can start exploring this we have a 45

8118
05:27:12,400 --> 05:27:14,400
and this variable here which is an

8119
05:27:14,400 --> 05:27:16,558
integer if we print it out we're going

8120
05:27:16,558 --> 05:27:18,160
to get a 45

8121
05:27:18,160 --> 05:27:19,920
and down here

8122
05:27:19,920 --> 05:27:23,280
we are doing a compound addition

8123
05:27:23,280 --> 05:27:25,440
so what we are doing here we're going to

8124
05:27:25,440 --> 05:27:28,400
grab whatever value is in this variable

8125
05:27:28,400 --> 05:27:30,480
we're going to add a five we're going to

8126
05:27:30,480 --> 05:27:32,480
get a 50 and that's what is going to be

8127
05:27:32,480 --> 05:27:34,240
stored in here

8128
05:27:34,240 --> 05:27:36,240
and if we print this out we're going to

8129
05:27:36,240 --> 05:27:40,638
get a 50. let's put in a terminal here

8130
05:27:40,638 --> 05:27:42,878
so that we can see this running and

8131
05:27:42,878 --> 05:27:45,040
we're going to run the task to build

8132
05:27:45,040 --> 05:27:48,400
with gcc as we always do here

8133
05:27:48,400 --> 05:27:50,840
and if we run our rooster

8134
05:27:50,840 --> 05:27:53,360
executable we're going to get the value

8135
05:27:53,360 --> 05:27:56,798
is 50 and that's what we expect here

8136
05:27:56,798 --> 05:27:58,718
okay this is the

8137
05:27:58,718 --> 05:28:01,520
addition version of our compound

8138
05:28:01,520 --> 05:28:04,400
assignment operator and it is really

8139
05:28:04,400 --> 05:28:07,760
equivalent to doing this in two steps

8140
05:28:07,760 --> 05:28:10,320
saying value equals value plus five

8141
05:28:10,320 --> 05:28:12,080
you're going to get the same result if

8142
05:28:12,080 --> 05:28:14,400
you do that here actually let's do this

8143
05:28:14,400 --> 05:28:17,360
so that you don't think that i am making

8144
05:28:17,360 --> 05:28:20,240
this up so let's comment this out and we

8145
05:28:20,240 --> 05:28:22,160
are going to say volume

8146
05:28:22,160 --> 05:28:25,920
equals value plus five and if we build

8147
05:28:25,920 --> 05:28:29,040
again run the gcc task

8148
05:28:29,040 --> 05:28:31,280
and run the application

8149
05:28:31,280 --> 05:28:33,600
we're going to see the same thing we can

8150
05:28:33,600 --> 05:28:37,040
also go down and run the subtraction

8151
05:28:37,040 --> 05:28:40,000
version of this example here here we are

8152
05:28:40,000 --> 05:28:42,000
taking the value that we have in here

8153
05:28:42,000 --> 05:28:43,600
which is a 50

8154
05:28:43,600 --> 05:28:45,680
we are subtracting 5 we're going to get

8155
05:28:45,680 --> 05:28:49,440
a 45 and 45 is what we're going to store

8156
05:28:49,440 --> 05:28:51,200
in this value here

8157
05:28:51,200 --> 05:28:53,040
that's what we're going to see if we

8158
05:28:53,040 --> 05:28:54,718
print this out so

8159
05:28:54,718 --> 05:28:57,840
let's run the test world with gcc

8160
05:28:57,840 --> 05:29:01,200
so that our changes are reflected in our

8161
05:29:01,200 --> 05:29:03,360
output we're going to run this and we're

8162
05:29:03,360 --> 05:29:06,558
going to get a 45 this is what we expect

8163
05:29:06,558 --> 05:29:08,798
we are going to go down and do a

8164
05:29:08,798 --> 05:29:11,360
multiplication version of this

8165
05:29:11,360 --> 05:29:14,240
here we have our compound assignment

8166
05:29:14,240 --> 05:29:16,718
statement we are taking whatever value

8167
05:29:16,718 --> 05:29:18,798
we have in here which is a 45 we're

8168
05:29:18,798 --> 05:29:21,520
going to multiply that by 2 and the

8169
05:29:21,520 --> 05:29:24,240
result of that is going to be 90 and

8170
05:29:24,240 --> 05:29:26,480
we're going to store that back in value

8171
05:29:26,480 --> 05:29:28,320
here and if we print value here we're

8172
05:29:28,320 --> 05:29:31,040
going to get a 19. let's build this run

8173
05:29:31,040 --> 05:29:33,840
the gcc task and we're going to run our

8174
05:29:33,840 --> 05:29:35,520
program and we're going to see that

8175
05:29:35,520 --> 05:29:37,760
we're going to see this 90 here we can

8176
05:29:37,760 --> 05:29:40,080
go down by a few lines and put in the

8177
05:29:40,080 --> 05:29:42,798
code to play with a division version of

8178
05:29:42,798 --> 05:29:43,600
this

8179
05:29:43,600 --> 05:29:46,000
again this is going to do really the

8180
05:29:46,000 --> 05:29:48,160
same thing only it's going to be doing

8181
05:29:48,160 --> 05:29:50,240
this for division we're going to take

8182
05:29:50,240 --> 05:29:52,160
whatever value we have in here which is

8183
05:29:52,160 --> 05:29:54,798
going to be a 90 we're going to divide

8184
05:29:54,798 --> 05:29:57,840
that by 3 we're going to get a 30 and

8185
05:29:57,840 --> 05:30:01,040
that 30 results is going to be stored

8186
05:30:01,040 --> 05:30:04,000
back in value here and if we print this

8187
05:30:04,000 --> 05:30:06,480
out that's what we're going to get

8188
05:30:06,480 --> 05:30:08,798
let's build again and the build is going

8189
05:30:08,798 --> 05:30:11,040
to go through if we run

8190
05:30:11,040 --> 05:30:13,680
our program we're going to get a 30. we

8191
05:30:13,680 --> 05:30:15,840
are going to go down by a few lines and

8192
05:30:15,840 --> 05:30:19,040
put in a modulus version of this we're

8193
05:30:19,040 --> 05:30:21,040
going to grab whatever value we have and

8194
05:30:21,040 --> 05:30:23,600
this variable here which is going to be

8195
05:30:23,600 --> 05:30:27,360
30 we're going to do modulus 11 on that

8196
05:30:27,360 --> 05:30:28,320
value

8197
05:30:28,320 --> 05:30:30,878
and that's going to be basically 30

8198
05:30:30,878 --> 05:30:33,760
modulus 11. the result of that is going

8199
05:30:33,760 --> 05:30:35,200
to be 8

8200
05:30:35,200 --> 05:30:37,760
and we're going to store that result in

8201
05:30:37,760 --> 05:30:40,638
value here and if we print that out

8202
05:30:40,638 --> 05:30:42,480
that's what we're going to see in this

8203
05:30:42,480 --> 05:30:45,600
output statement here we can build again

8204
05:30:45,600 --> 05:30:49,440
run with gcc and if we run our rooster

8205
05:30:49,440 --> 05:30:52,480
program we're going to get an 8 printed

8206
05:30:52,480 --> 05:30:55,040
out and this is really all

8207
05:30:55,040 --> 05:30:58,320
these compound assignments are about and

8208
05:30:58,320 --> 05:31:00,160
you might be asking

8209
05:31:00,160 --> 05:31:01,920
why go through the trouble to do

8210
05:31:01,920 --> 05:31:04,080
something like this if i can do this

8211
05:31:04,080 --> 05:31:06,480
like this well c plus plus gives you

8212
05:31:06,480 --> 05:31:08,718
different way to do things different

8213
05:31:08,718 --> 05:31:11,120
people have different preferences and

8214
05:31:11,120 --> 05:31:14,160
some people me included like to do

8215
05:31:14,160 --> 05:31:16,400
things this way because it is compact

8216
05:31:16,400 --> 05:31:18,480
and once you use this you're going to

8217
05:31:18,480 --> 05:31:20,160
get used to this you're not even going

8218
05:31:20,160 --> 05:31:22,638
to think about it in this lecture here i

8219
05:31:22,638 --> 05:31:25,280
just wanted you to be aware of this

8220
05:31:25,280 --> 05:31:27,760
possibility because you are definitely

8221
05:31:27,760 --> 05:31:30,798
going to see it in c plus plus code out

8222
05:31:30,798 --> 05:31:31,680
there

8223
05:31:31,680 --> 05:31:33,360
this is really all we set out to do in

8224
05:31:33,360 --> 05:31:34,958
this lecture i hope you found it

8225
05:31:34,958 --> 05:31:37,280
interesting we are going to stop here in

8226
05:31:37,280 --> 05:31:39,120
this lecture in the next one we're going

8227
05:31:39,120 --> 05:31:42,558
to learn about relational operators in c

8228
05:31:42,558 --> 05:31:44,638
plus plus in this lecture we're going to

8229
05:31:44,638 --> 05:31:47,760
learn about relational operators in c

8230
05:31:47,760 --> 05:31:49,920
plus plus and these are basically

8231
05:31:49,920 --> 05:31:53,280
operators you use to compare stuff let's

8232
05:31:53,280 --> 05:31:56,160
look at a piece of code here we have two

8233
05:31:56,160 --> 05:32:00,240
numbers one is 45 and another is 60 they

8234
05:32:00,240 --> 05:32:03,040
are stored in integer variables number

8235
05:32:03,040 --> 05:32:04,958
one and number two

8236
05:32:04,958 --> 05:32:06,718
we can print them out and we're going to

8237
05:32:06,718 --> 05:32:10,558
see them on the console or our terminal

8238
05:32:10,558 --> 05:32:13,200
and if we go down we can really compare

8239
05:32:13,200 --> 05:32:16,320
them we can use the less than operator

8240
05:32:16,320 --> 05:32:19,120
less than or equal operator

8241
05:32:19,120 --> 05:32:22,080
greater than greater or equal operator

8242
05:32:22,080 --> 05:32:24,958
we can check and see if two numbers are

8243
05:32:24,958 --> 05:32:27,840
equal by using two equal signs here be

8244
05:32:27,840 --> 05:32:30,080
careful about these two equal signs

8245
05:32:30,080 --> 05:32:32,320
because if you use one you're not going

8246
05:32:32,320 --> 05:32:34,798
to be comparing numbers you're going to

8247
05:32:34,798 --> 05:32:36,638
be taking the thing on the right and

8248
05:32:36,638 --> 05:32:39,360
assigning that to the thing on the left

8249
05:32:39,360 --> 05:32:41,600
so if you want to compare you're going

8250
05:32:41,600 --> 05:32:44,480
to have to type two equal signs another

8251
05:32:44,480 --> 05:32:47,280
operator we can use to compare stuff is

8252
05:32:47,280 --> 05:32:50,080
exclamation mark and equal which is

8253
05:32:50,080 --> 05:32:52,798
going to basically test if two numbers

8254
05:32:52,798 --> 05:32:54,000
are equal

8255
05:32:54,000 --> 05:32:56,400
and we're going to get the result one

8256
05:32:56,400 --> 05:32:59,120
thing you should notice here is that we

8257
05:32:59,120 --> 05:33:02,958
are wrapping our comparison expression

8258
05:33:02,958 --> 05:33:05,920
into parenthesis that's because if we

8259
05:33:05,920 --> 05:33:07,680
don't we're going to get a weird

8260
05:33:07,680 --> 05:33:10,160
compiler error that i am going to show

8261
05:33:10,160 --> 05:33:12,718
you when we get in visual studio code

8262
05:33:12,718 --> 05:33:15,040
but we don't have enough tools to really

8263
05:33:15,040 --> 05:33:17,040
understand this error

8264
05:33:17,040 --> 05:33:19,680
at this moment so what we are going to

8265
05:33:19,680 --> 05:33:22,160
do is avoid that problem by putting

8266
05:33:22,160 --> 05:33:24,878
parenthesis around our comparison

8267
05:33:24,878 --> 05:33:26,958
expression here we're going to go to

8268
05:33:26,958 --> 05:33:29,520
visual studio code and actually see this

8269
05:33:29,520 --> 05:33:32,958
in action here we are in our working

8270
05:33:32,958 --> 05:33:35,040
directory we're going to grab the code

8271
05:33:35,040 --> 05:33:37,280
from our template here and we're going

8272
05:33:37,280 --> 05:33:39,840
to put that in the current project which

8273
05:33:39,840 --> 05:33:40,840
is

8274
05:33:40,840 --> 05:33:42,958
relational operators we're going to go

8275
05:33:42,958 --> 05:33:46,000
in and put in our code and we are going

8276
05:33:46,000 --> 05:33:48,160
to open this up in visual studio code

8277
05:33:48,160 --> 05:33:50,160
we're going to get rid of things we

8278
05:33:50,160 --> 05:33:52,798
don't need here we are going to put in

8279
05:33:52,798 --> 05:33:55,040
our code so that we can explore these

8280
05:33:55,040 --> 05:33:57,760
things we have two variables in one we

8281
05:33:57,760 --> 05:34:00,878
have a 45 in another we have a 60 and

8282
05:34:00,878 --> 05:34:02,878
these are integers the name for these

8283
05:34:02,878 --> 05:34:05,840
variables are number one and number two

8284
05:34:05,840 --> 05:34:07,600
we're going to print them out and we're

8285
05:34:07,600 --> 05:34:10,240
going to see them on the console now we

8286
05:34:10,240 --> 05:34:11,920
are going to compare them

8287
05:34:11,920 --> 05:34:14,400
one thing i haven't told you yet is that

8288
05:34:14,400 --> 05:34:18,798
these comparison operators evaluate to

8289
05:34:18,798 --> 05:34:21,600
booleans in other words they are going

8290
05:34:21,600 --> 05:34:24,480
to return true all false if you look

8291
05:34:24,480 --> 05:34:25,760
down here

8292
05:34:25,760 --> 05:34:28,958
we want to know if number one is less

8293
05:34:28,958 --> 05:34:31,600
than number two and the result of that

8294
05:34:31,600 --> 05:34:33,760
is whether that's true or false and this

8295
05:34:33,760 --> 05:34:35,280
really makes sense

8296
05:34:35,280 --> 05:34:39,280
so because of that we are using std bull

8297
05:34:39,280 --> 05:34:42,798
alpha here to force sddc out to print

8298
05:34:42,798 --> 05:34:45,840
this boolean value here as a true or

8299
05:34:45,840 --> 05:34:48,718
false instead of a one or a zero and we

8300
05:34:48,718 --> 05:34:51,600
have seen this before so if we try to

8301
05:34:51,600 --> 05:34:54,718
build this and run this let's bring up a

8302
05:34:54,718 --> 05:34:56,638
terminal we can use

8303
05:34:56,638 --> 05:34:58,558
and we're going to run the test to build

8304
05:34:58,558 --> 05:35:02,160
with gcc if we go down here and run our

8305
05:35:02,160 --> 05:35:04,320
rooster program we're going to get our

8306
05:35:04,320 --> 05:35:07,760
two numbers 45 and six and we want to

8307
05:35:07,760 --> 05:35:10,480
know if number one is less than number

8308
05:35:10,480 --> 05:35:14,080
two and that's true 45 is less than 60

8309
05:35:14,080 --> 05:35:16,240
so the result of this expression is

8310
05:35:16,240 --> 05:35:18,638
going to be true now you know how to use

8311
05:35:18,638 --> 05:35:20,958
this operator one thing i want you to

8312
05:35:20,958 --> 05:35:23,440
see is what could happen

8313
05:35:23,440 --> 05:35:24,718
if you

8314
05:35:24,718 --> 05:35:27,680
didn't use this parenthesis around this

8315
05:35:27,680 --> 05:35:30,160
expression here let's try this out we're

8316
05:35:30,160 --> 05:35:32,160
going to remove this parenthesis and

8317
05:35:32,160 --> 05:35:34,718
we're going to try and world we're going

8318
05:35:34,718 --> 05:35:37,920
to run the task to world with gcc and

8319
05:35:37,920 --> 05:35:40,320
we're going to get a really weird error

8320
05:35:40,320 --> 05:35:41,760
because

8321
05:35:41,760 --> 05:35:43,840
the compiler is going to try and

8322
05:35:43,840 --> 05:35:47,120
evaluate this operator first if we go

8323
05:35:47,120 --> 05:35:49,760
back to our c plus plus operator

8324
05:35:49,760 --> 05:35:51,360
precedence table

8325
05:35:51,360 --> 05:35:53,920
and look at the operators we are trying

8326
05:35:53,920 --> 05:35:57,200
to use in the sddc out statement we're

8327
05:35:57,200 --> 05:35:59,360
going to see that the

8328
05:35:59,360 --> 05:36:02,240
operator to print fans on the console

8329
05:36:02,240 --> 05:36:05,680
has high precedence than our comparison

8330
05:36:05,680 --> 05:36:08,718
operators here so the precedence for our

8331
05:36:08,718 --> 05:36:11,680
operator to print things to sdd out is

8332
05:36:11,680 --> 05:36:15,200
11 so it is higher and the

8333
05:36:15,200 --> 05:36:18,240
precedence for our comparison operators

8334
05:36:18,240 --> 05:36:21,360
is nine and eight so the compiler is

8335
05:36:21,360 --> 05:36:23,920
going to try and do this operator first

8336
05:36:23,920 --> 05:36:26,000
if we come back in visual studio code

8337
05:36:26,000 --> 05:36:27,760
the compiler is going to try and think

8338
05:36:27,760 --> 05:36:30,320
that you are printing number one but

8339
05:36:30,320 --> 05:36:32,240
then again it's going to see this less

8340
05:36:32,240 --> 05:36:34,798
than sign and things are going to blow

8341
05:36:34,798 --> 05:36:37,120
up we don't really have enough tools to

8342
05:36:37,120 --> 05:36:39,200
understand what is going on right now

8343
05:36:39,200 --> 05:36:41,680
but i just don't want you to see this

8344
05:36:41,680 --> 05:36:46,080
arrow and show you a way to go around it

8345
05:36:46,080 --> 05:36:48,400
and move on with your life by comparing

8346
05:36:48,400 --> 05:36:51,280
stuff in your c plus plus programs if

8347
05:36:51,280 --> 05:36:53,360
you put parentheses around here the

8348
05:36:53,360 --> 05:36:55,200
problem is going to go away let's try

8349
05:36:55,200 --> 05:36:56,718
and build again

8350
05:36:56,718 --> 05:36:59,360
we're going to build with gcc

8351
05:36:59,360 --> 05:37:01,280
and everything is going to go back to

8352
05:37:01,280 --> 05:37:04,080
normal and we're going to see our output

8353
05:37:04,080 --> 05:37:07,600
if we run our rooster program here

8354
05:37:07,600 --> 05:37:10,000
this is how you can do this okay now

8355
05:37:10,000 --> 05:37:11,760
that we have a basic understanding of

8356
05:37:11,760 --> 05:37:14,638
this we can try the other operators and

8357
05:37:14,638 --> 05:37:17,760
it is going to be a walk in the park we

8358
05:37:17,760 --> 05:37:20,480
are going to go down here and put in our

8359
05:37:20,480 --> 05:37:24,400
remaining operators we can use less or

8360
05:37:24,400 --> 05:37:28,080
eco operator to test and see if number

8361
05:37:28,080 --> 05:37:31,120
one is less or equal to number two we

8362
05:37:31,120 --> 05:37:33,440
can use the greater than operator to

8363
05:37:33,440 --> 05:37:36,080
test and see if number one is greater

8364
05:37:36,080 --> 05:37:38,638
than number two we can use the greater

8365
05:37:38,638 --> 05:37:40,400
or equal operator

8366
05:37:40,400 --> 05:37:42,480
we can use the equal equal operator to

8367
05:37:42,480 --> 05:37:44,718
test that number one is equal to number

8368
05:37:44,718 --> 05:37:47,440
two and we can use this operator here

8369
05:37:47,440 --> 05:37:50,400
which is made up of the exclamation mark

8370
05:37:50,400 --> 05:37:53,600
and an equal sign to test and see

8371
05:37:53,600 --> 05:37:56,000
if two numbers are not equal

8372
05:37:56,000 --> 05:37:58,320
and all these operators are going to

8373
05:37:58,320 --> 05:38:00,718
evaluate to a boolean

8374
05:38:00,718 --> 05:38:03,520
basically saying if what you are testing

8375
05:38:03,520 --> 05:38:06,638
for is true or false and we can print

8376
05:38:06,638 --> 05:38:08,878
this out and notice that we have this

8377
05:38:08,878 --> 05:38:11,200
parenthesis around to avoid the problem

8378
05:38:11,200 --> 05:38:14,240
i just showed you a few minutes earlier

8379
05:38:14,240 --> 05:38:16,160
and if we run this we're going to see

8380
05:38:16,160 --> 05:38:17,920
the results

8381
05:38:17,920 --> 05:38:22,638
let's weld this with gcc as usual

8382
05:38:22,638 --> 05:38:24,958
we're going to run our program and

8383
05:38:24,958 --> 05:38:27,200
you're going to see that number one is

8384
05:38:27,200 --> 05:38:30,160
less than number two this is true

8385
05:38:30,160 --> 05:38:32,638
number one less or equal to number two

8386
05:38:32,638 --> 05:38:34,240
this is also true

8387
05:38:34,240 --> 05:38:37,600
number one greater than a number two 45

8388
05:38:37,600 --> 05:38:40,558
is not greater than 60 so this is false

8389
05:38:40,558 --> 05:38:43,200
it's not greater than equal so this is

8390
05:38:43,200 --> 05:38:44,718
also false

8391
05:38:44,718 --> 05:38:46,958
number one equals to number two this is

8392
05:38:46,958 --> 05:38:49,200
going to be false and uh the last

8393
05:38:49,200 --> 05:38:51,680
statement that is going to test and see

8394
05:38:51,680 --> 05:38:54,878
if number one is not equal to number two

8395
05:38:54,878 --> 05:38:57,680
is going to evaluate to true because

8396
05:38:57,680 --> 05:39:00,320
number one is not equal to number two if

8397
05:39:00,320 --> 05:39:02,638
this is not making sense yet please go

8398
05:39:02,638 --> 05:39:05,040
through it a couple of times and if you

8399
05:39:05,040 --> 05:39:07,920
have a problem please do ask me i will

8400
05:39:07,920 --> 05:39:10,320
do the best i can to help you out

8401
05:39:10,320 --> 05:39:12,320
another thing i want you to see before i

8402
05:39:12,320 --> 05:39:13,600
let you go

8403
05:39:13,600 --> 05:39:16,718
is that you can store the results of

8404
05:39:16,718 --> 05:39:20,320
these operators into a variable and use

8405
05:39:20,320 --> 05:39:22,638
that later in your program for example

8406
05:39:22,638 --> 05:39:24,638
here we can take our expression to

8407
05:39:24,638 --> 05:39:25,840
compare

8408
05:39:25,840 --> 05:39:29,200
number one and number two the result of

8409
05:39:29,200 --> 05:39:31,200
that is going to be installed in this

8410
05:39:31,200 --> 05:39:32,558
bold variable

8411
05:39:32,558 --> 05:39:35,040
and we can print it out later

8412
05:39:35,040 --> 05:39:36,400
like this

8413
05:39:36,400 --> 05:39:37,760
if we run this

8414
05:39:37,760 --> 05:39:40,400
we're going to build with gcc and we're

8415
05:39:40,400 --> 05:39:42,480
going to run the program

8416
05:39:42,480 --> 05:39:46,400
we're going to see that 45 equals to 60

8417
05:39:46,400 --> 05:39:49,520
is false and it is coming from this

8418
05:39:49,520 --> 05:39:51,840
statement here you can try and change

8419
05:39:51,840 --> 05:39:54,080
these numbers for example change this to

8420
05:39:54,080 --> 05:39:57,920
a 20 and see the results that we get and

8421
05:39:57,920 --> 05:40:00,400
you can try and run these in your mind

8422
05:40:00,400 --> 05:40:03,200
and see that they really make sense if

8423
05:40:03,200 --> 05:40:05,520
we run rooster now we're going to get to

8424
05:40:05,520 --> 05:40:07,520
different results because we are now

8425
05:40:07,520 --> 05:40:12,558
comparing 45 and 20 and here at the last

8426
05:40:12,558 --> 05:40:14,400
statement you see that they are not

8427
05:40:14,400 --> 05:40:16,558
equal if we put into equal numbers we're

8428
05:40:16,558 --> 05:40:19,840
going to get a true there let's try this

8429
05:40:19,840 --> 05:40:22,400
out we're going to run the task to build

8430
05:40:22,400 --> 05:40:25,920
with gcc and if we clear so that we get

8431
05:40:25,920 --> 05:40:29,120
rid of all this noise and run rooster

8432
05:40:29,120 --> 05:40:30,558
we're going to get

8433
05:40:30,558 --> 05:40:34,080
20 is equal to 20 and this is true this

8434
05:40:34,080 --> 05:40:35,680
is really all we set out to do in this

8435
05:40:35,680 --> 05:40:38,160
lecture i hope you have a better idea of

8436
05:40:38,160 --> 05:40:40,558
these relational operators in z plus

8437
05:40:40,558 --> 05:40:41,440
plus

8438
05:40:41,440 --> 05:40:43,760
we're going to stop here in this lecture

8439
05:40:43,760 --> 05:40:45,360
in the next lecture we're going to learn

8440
05:40:45,360 --> 05:40:48,798
about logical operators in c plus plus

8441
05:40:48,798 --> 05:40:51,200
go ahead and finish up here and meet me

8442
05:40:51,200 --> 05:40:53,120
there in this lecture we're going to

8443
05:40:53,120 --> 05:40:56,000
learn about logical operators these

8444
05:40:56,000 --> 05:40:59,360
operators will work on boolean operands

8445
05:40:59,360 --> 05:41:01,280
we're going to look at end first to

8446
05:41:01,280 --> 05:41:03,760
really make sense of how they work here

8447
05:41:03,760 --> 05:41:06,638
is a simple table we can use to try out

8448
05:41:06,638 --> 05:41:09,040
the end operation it is going to be

8449
05:41:09,040 --> 05:41:12,080
working on two operands a and b

8450
05:41:12,080 --> 05:41:14,798
and in the third column here we're going

8451
05:41:14,798 --> 05:41:18,000
to have the result so if a is false and

8452
05:41:18,000 --> 05:41:21,600
b is false and we do a and b

8453
05:41:21,600 --> 05:41:24,320
the result is going to be false if a is

8454
05:41:24,320 --> 05:41:27,280
false and b is true the result is going

8455
05:41:27,280 --> 05:41:31,120
to be false if a is true and b is false

8456
05:41:31,120 --> 05:41:34,160
the result is going to be false if a is

8457
05:41:34,160 --> 05:41:37,120
true and b is true the result is going

8458
05:41:37,120 --> 05:41:39,600
to be true the way you can think about

8459
05:41:39,600 --> 05:41:42,798
this and operator is that

8460
05:41:42,798 --> 05:41:47,040
if any of the operands is false the

8461
05:41:47,040 --> 05:41:49,440
result is going to be false and if you

8462
05:41:49,440 --> 05:41:52,000
really use this way of understanding

8463
05:41:52,000 --> 05:41:54,400
this it is going to be really easy and

8464
05:41:54,400 --> 05:41:56,400
the first line here we have a false so

8465
05:41:56,400 --> 05:41:58,638
the result is going to be false and the

8466
05:41:58,638 --> 05:42:00,320
second line we have a force it's going

8467
05:42:00,320 --> 05:42:02,718
to be force in the third line we have a

8468
05:42:02,718 --> 05:42:04,958
false the result is going to be false

8469
05:42:04,958 --> 05:42:08,000
but in the line number four here we

8470
05:42:08,000 --> 05:42:10,638
don't have a false a is true and b is

8471
05:42:10,638 --> 05:42:13,200
true so the result is going to be true

8472
05:42:13,200 --> 05:42:16,160
another operator we have is or

8473
05:42:16,160 --> 05:42:20,400
and it is going to evaluate to true

8474
05:42:20,400 --> 05:42:24,080
if any of the operands is true let's

8475
05:42:24,080 --> 05:42:26,400
look at the first line here a is false

8476
05:42:26,400 --> 05:42:29,440
and b is false so we don't have a true

8477
05:42:29,440 --> 05:42:31,600
the result is going to be false on the

8478
05:42:31,600 --> 05:42:33,440
second line we have a true the research

8479
05:42:33,440 --> 05:42:35,920
is going to be true on the third line we

8480
05:42:35,920 --> 05:42:37,840
have a true the research is going to be

8481
05:42:37,840 --> 05:42:41,120
true on line number four we have a true

8482
05:42:41,120 --> 05:42:43,600
the result is going to be true and you

8483
05:42:43,600 --> 05:42:45,920
don't really have to memorize these

8484
05:42:45,920 --> 05:42:49,040
tables if you use these operators long

8485
05:42:49,040 --> 05:42:51,200
enough these things are going to be

8486
05:42:51,200 --> 05:42:53,760
drilled in your memory if you have any

8487
05:42:53,760 --> 05:42:56,480
problem with these operators just look

8488
05:42:56,480 --> 05:42:58,638
up tables like this and you can find

8489
05:42:58,638 --> 05:43:00,798
whatever it is you need without really

8490
05:43:00,798 --> 05:43:03,680
memorizing these things another operator

8491
05:43:03,680 --> 05:43:06,320
is the not operator which is going to

8492
05:43:06,320 --> 05:43:09,360
negate whatever you give it so if a is

8493
05:43:09,360 --> 05:43:11,280
true and we negate that we're going to

8494
05:43:11,280 --> 05:43:14,320
get a false if a is false and when you

8495
05:43:14,320 --> 05:43:16,320
get to that we're going to get it true

8496
05:43:16,320 --> 05:43:19,440
and we use this exfoliation mark to say

8497
05:43:19,440 --> 05:43:21,680
that we are negating something if you go

8498
05:43:21,680 --> 05:43:25,760
back to or it is denoted by these two

8499
05:43:25,760 --> 05:43:29,040
vertical bars and the end operator is

8500
05:43:29,040 --> 05:43:31,920
denoted by these two ampersand

8501
05:43:31,920 --> 05:43:34,400
symbols here okay now that we know about

8502
05:43:34,400 --> 05:43:36,958
these logical tables for these logical

8503
05:43:36,958 --> 05:43:39,440
operators we can actually try to use

8504
05:43:39,440 --> 05:43:41,360
them in code

8505
05:43:41,360 --> 05:43:44,000
here we have three boolean variables we

8506
05:43:44,000 --> 05:43:45,520
have a b c

8507
05:43:45,520 --> 05:43:49,600
a is true b is false c is true we can

8508
05:43:49,600 --> 05:43:51,520
print them out and you see that we are

8509
05:43:51,520 --> 05:43:54,080
setting up sddc out to give us the

8510
05:43:54,080 --> 05:43:57,120
results in the format of true and false

8511
05:43:57,120 --> 05:43:59,360
instead of ones and zeros

8512
05:43:59,360 --> 05:44:01,680
and down here you see that we are trying

8513
05:44:01,680 --> 05:44:04,878
to use the and logical operator

8514
05:44:04,878 --> 05:44:08,958
down here you have a and b a and c and

8515
05:44:08,958 --> 05:44:11,440
we are doing this on three operators and

8516
05:44:11,440 --> 05:44:13,680
chaining these things up so we are

8517
05:44:13,680 --> 05:44:17,360
saying a and b and c and let's try and

8518
05:44:17,360 --> 05:44:19,520
do this in our mind to see that we

8519
05:44:19,520 --> 05:44:22,080
really understand this we have seen that

8520
05:44:22,080 --> 05:44:25,040
the end operator evaluates to true

8521
05:44:25,040 --> 05:44:27,920
when all operands are true another way

8522
05:44:27,920 --> 05:44:30,718
to say this is the end operator

8523
05:44:30,718 --> 05:44:33,280
evaluates to false if any of the

8524
05:44:33,280 --> 05:44:36,000
operands is false so we're going to end

8525
05:44:36,000 --> 05:44:39,360
a and b a is true b is false so the

8526
05:44:39,360 --> 05:44:41,600
result is going to be false because we

8527
05:44:41,600 --> 05:44:44,558
have a false in here a and c is going to

8528
05:44:44,558 --> 05:44:47,440
evaluate to true because a and c are

8529
05:44:47,440 --> 05:44:50,878
true a and b and c is going to evaluate

8530
05:44:50,878 --> 05:44:53,840
to false because we have a false in here

8531
05:44:53,840 --> 05:44:57,040
even if you have 1 000 tools and you end

8532
05:44:57,040 --> 05:44:59,760
that with one false that's going to be

8533
05:44:59,760 --> 05:45:03,040
dragged down to evaluate to false that's

8534
05:45:03,040 --> 05:45:05,680
what we are seeing here we can also do

8535
05:45:05,680 --> 05:45:08,878
all operations on these things and

8536
05:45:08,878 --> 05:45:11,840
this is going to give you a true if any

8537
05:45:11,840 --> 05:45:13,520
of the operands

8538
05:45:13,520 --> 05:45:16,958
is true we know that a is true and b is

8539
05:45:16,958 --> 05:45:19,120
false so this is going to evaluate to

8540
05:45:19,120 --> 05:45:21,920
true a and c is also going to evaluate

8541
05:45:21,920 --> 05:45:24,000
to true because a is true

8542
05:45:24,000 --> 05:45:26,480
a and b and c is going to evaluate the

8543
05:45:26,480 --> 05:45:29,760
true because a is true

8544
05:45:29,760 --> 05:45:31,840
so let's go back and see this these are

8545
05:45:31,840 --> 05:45:34,000
the values we're going to be using here

8546
05:45:34,000 --> 05:45:36,878
we can also try out the nut operator and

8547
05:45:36,878 --> 05:45:38,718
it is going to negate whatever we gave

8548
05:45:38,718 --> 05:45:41,200
it so if a is true we're going to get a

8549
05:45:41,200 --> 05:45:43,760
false b is false we're going to get it

8550
05:45:43,760 --> 05:45:46,400
true c is true we're going to get a

8551
05:45:46,400 --> 05:45:48,240
false another thing you can do is

8552
05:45:48,240 --> 05:45:51,840
combine this logical operators so we can

8553
05:45:51,840 --> 05:45:54,400
do something like a and b and all of

8554
05:45:54,400 --> 05:45:55,680
that with a c

8555
05:45:55,680 --> 05:45:57,840
and you should notice that we are

8556
05:45:57,840 --> 05:46:00,480
wrapping our expressions here in

8557
05:46:00,480 --> 05:46:02,718
parenthesis so that we don't have the

8558
05:46:02,718 --> 05:46:04,958
same problem we experienced and

8559
05:46:04,958 --> 05:46:07,360
explained in the last lecture and one

8560
05:46:07,360 --> 05:46:09,280
thing you should know is that for the

8561
05:46:09,280 --> 05:46:12,718
compiler to evaluate these things we are

8562
05:46:12,718 --> 05:46:15,200
going to follow the rules in our table

8563
05:46:15,200 --> 05:46:18,080
for precedence and associativity but we

8564
05:46:18,080 --> 05:46:20,080
used parentheses to really make this

8565
05:46:20,080 --> 05:46:23,680
easy to follow so we are going to end a

8566
05:46:23,680 --> 05:46:24,718
and b

8567
05:46:24,718 --> 05:46:26,798
and the result of that is going to be

8568
05:46:26,798 --> 05:46:29,760
ored with c and you can try and do this

8569
05:46:29,760 --> 05:46:31,280
in your mind and you're going to figure

8570
05:46:31,280 --> 05:46:33,360
this out but we're also going to go to

8571
05:46:33,360 --> 05:46:35,120
visual studio code in a minute and we're

8572
05:46:35,120 --> 05:46:37,680
going to see all these things in action

8573
05:46:37,680 --> 05:46:40,000
the last thing you can do is combine

8574
05:46:40,000 --> 05:46:43,040
logical and relational operators into

8575
05:46:43,040 --> 05:46:46,080
expressions for example here we have d e

8576
05:46:46,080 --> 05:46:48,878
and f they are integers and we can print

8577
05:46:48,878 --> 05:46:51,440
them out like we are doing here but we

8578
05:46:51,440 --> 05:46:53,040
can do something like

8579
05:46:53,040 --> 05:46:55,200
d greater than e

8580
05:46:55,200 --> 05:46:57,200
and we're going to end the result of

8581
05:46:57,200 --> 05:47:00,958
that with d greater than f

8582
05:47:00,958 --> 05:47:03,920
and we know that these relational

8583
05:47:03,920 --> 05:47:07,840
operators evaluate to booleans so we can

8584
05:47:07,840 --> 05:47:10,000
use these booleans with logical

8585
05:47:10,000 --> 05:47:12,718
operators like we have been doing all

8586
05:47:12,718 --> 05:47:15,360
along in this lecture so for example

8587
05:47:15,360 --> 05:47:17,760
let's evaluate the first one here in

8588
05:47:17,760 --> 05:47:20,558
mind so that you really see what this is

8589
05:47:20,558 --> 05:47:22,320
all about

8590
05:47:22,320 --> 05:47:27,680
d is 45 e is 20 so d greater than e is

8591
05:47:27,680 --> 05:47:29,600
going to evaluate to true

8592
05:47:29,600 --> 05:47:31,360
d greater than f

8593
05:47:31,360 --> 05:47:34,000
that's also going to evaluate to true so

8594
05:47:34,000 --> 05:47:35,760
true and true

8595
05:47:35,760 --> 05:47:37,760
that's going to evaluate to true and

8596
05:47:37,760 --> 05:47:39,760
this should print a true

8597
05:47:39,760 --> 05:47:41,440
on the terminal

8598
05:47:41,440 --> 05:47:43,600
we are going to go to visual studio code

8599
05:47:43,600 --> 05:47:46,000
and actually play with this thanks

8600
05:47:46,000 --> 05:47:48,080
okay here we are in our working

8601
05:47:48,080 --> 05:47:50,080
directory we're going to jump into our

8602
05:47:50,080 --> 05:47:52,638
template project and copy the files we

8603
05:47:52,638 --> 05:47:55,840
need and we're going to put them in our

8604
05:47:55,840 --> 05:47:58,558
lecture on logical operators we're going

8605
05:47:58,558 --> 05:48:00,558
to put that in here

8606
05:48:00,558 --> 05:48:02,638
we're going to open up this folder in

8607
05:48:02,638 --> 05:48:04,558
visual studio code and it is going to

8608
05:48:04,558 --> 05:48:06,798
show up here in visual studio code we're

8609
05:48:06,798 --> 05:48:08,958
going to get rid of what we don't need

8610
05:48:08,958 --> 05:48:10,958
and we are going to put in the code to

8611
05:48:10,958 --> 05:48:14,080
play with these things we have three

8612
05:48:14,080 --> 05:48:18,798
boolean variables a is true b is false c

8613
05:48:18,798 --> 05:48:20,080
is true

8614
05:48:20,080 --> 05:48:21,680
and we can print them out and we're

8615
05:48:21,680 --> 05:48:23,440
going to see their values and you see

8616
05:48:23,440 --> 05:48:26,718
the setup here so that sddc out is going

8617
05:48:26,718 --> 05:48:29,600
to show thanks in the format of true and

8618
05:48:29,600 --> 05:48:33,680
false and down here we are ending a few

8619
05:48:33,680 --> 05:48:36,958
values we are using the and operator and

8620
05:48:36,958 --> 05:48:39,920
it is denoted by these two ampersand

8621
05:48:39,920 --> 05:48:41,040
signs

8622
05:48:41,040 --> 05:48:41,760
so

8623
05:48:41,760 --> 05:48:45,920
a is true and b is false and c is true

8624
05:48:45,920 --> 05:48:48,878
a and b is going to evaluate

8625
05:48:48,878 --> 05:48:51,600
to false because we have a false in here

8626
05:48:51,600 --> 05:48:53,680
and again if this doesn't make sense

8627
05:48:53,680 --> 05:48:56,480
please do consult the tables for all

8628
05:48:56,480 --> 05:48:58,718
these logical operators and all these

8629
05:48:58,718 --> 05:49:00,400
things are going to make sense this is

8630
05:49:00,400 --> 05:49:02,718
going to evaluate to false because we

8631
05:49:02,718 --> 05:49:06,718
have a false in here and a and c we have

8632
05:49:06,718 --> 05:49:08,958
true and true so this is going to

8633
05:49:08,958 --> 05:49:11,440
evaluate to true and

8634
05:49:11,440 --> 05:49:14,558
a and b and c this is going to evaluate

8635
05:49:14,558 --> 05:49:16,798
to false because we have a false in here

8636
05:49:16,798 --> 05:49:19,760
remember as soon as you have a false in

8637
05:49:19,760 --> 05:49:23,200
your and logical operation you're going

8638
05:49:23,200 --> 05:49:26,240
to get a false in your result so we're

8639
05:49:26,240 --> 05:49:28,638
going to have a false here we can try

8640
05:49:28,638 --> 05:49:30,878
and compile this and see if this is

8641
05:49:30,878 --> 05:49:33,200
actually what we expect we're going to

8642
05:49:33,200 --> 05:49:35,120
bring up a terminal we're going to use

8643
05:49:35,120 --> 05:49:37,680
here and we're going to run the tasks to

8644
05:49:37,680 --> 05:49:39,600
build with gcc

8645
05:49:39,600 --> 05:49:43,040
and if we run our rooster program we're

8646
05:49:43,040 --> 05:49:46,558
going to see that a and b is false

8647
05:49:46,558 --> 05:49:48,480
this is what we expect

8648
05:49:48,480 --> 05:49:52,480
a and c is true this is what we expect

8649
05:49:52,480 --> 05:49:54,160
a and b and c

8650
05:49:54,160 --> 05:49:56,958
is false and this is what we expect

8651
05:49:56,958 --> 05:49:58,878
this is how you can really play with

8652
05:49:58,878 --> 05:50:02,000
your and logical operator if you want

8653
05:50:02,000 --> 05:50:04,718
you can change things up to really

8654
05:50:04,718 --> 05:50:07,680
try and see if they live up to your

8655
05:50:07,680 --> 05:50:09,200
expectations

8656
05:50:09,200 --> 05:50:12,240
now we have changed a to false let's try

8657
05:50:12,240 --> 05:50:15,520
and build again we build with gcc

8658
05:50:15,520 --> 05:50:18,480
and we're going to run our program

8659
05:50:18,480 --> 05:50:20,878
and we're going to get a and b is false

8660
05:50:20,878 --> 05:50:23,600
because they are all false a and b are

8661
05:50:23,600 --> 05:50:27,120
false so false and false evaluates to

8662
05:50:27,120 --> 05:50:28,080
false

8663
05:50:28,080 --> 05:50:31,840
a and c is false because a is false so

8664
05:50:31,840 --> 05:50:34,638
we're going to get a false as the result

8665
05:50:34,638 --> 05:50:37,200
a and b and c is also going to evaluate

8666
05:50:37,200 --> 05:50:40,400
to false okay we have this tension here

8667
05:50:40,400 --> 05:50:42,718
let's bring this back to what it was

8668
05:50:42,718 --> 05:50:45,440
before so a is going to be true b is

8669
05:50:45,440 --> 05:50:48,000
going to be false c is going to be true

8670
05:50:48,000 --> 05:50:50,480
and we're going to try and play with the

8671
05:50:50,480 --> 05:50:53,360
or operator we are going to go down and

8672
05:50:53,360 --> 05:50:57,200
put in code to actually play with this

8673
05:50:57,200 --> 05:50:59,440
and it is really nothing special we are

8674
05:50:59,440 --> 05:51:01,840
just using the or operator here which is

8675
05:51:01,840 --> 05:51:04,320
denoted by these two vertical

8676
05:51:04,320 --> 05:51:07,440
symbols and or is going to evaluate to

8677
05:51:07,440 --> 05:51:08,240
true

8678
05:51:08,240 --> 05:51:11,360
when at least one of the operands is

8679
05:51:11,360 --> 05:51:14,160
true okay so we have our values here a

8680
05:51:14,160 --> 05:51:17,760
is true b is false c is true a or b is

8681
05:51:17,760 --> 05:51:20,320
going to evaluate to true because a is

8682
05:51:20,320 --> 05:51:21,280
true

8683
05:51:21,280 --> 05:51:23,760
a or c is going to evaluate to true

8684
05:51:23,760 --> 05:51:25,520
because a is true

8685
05:51:25,520 --> 05:51:29,760
a or b or c is going to evaluate to true

8686
05:51:29,760 --> 05:51:32,240
because one of these things is true and

8687
05:51:32,240 --> 05:51:34,320
a is true here

8688
05:51:34,320 --> 05:51:36,558
we can try and run this we're going to

8689
05:51:36,558 --> 05:51:38,558
build this first

8690
05:51:38,558 --> 05:51:43,440
with gcc and if we run this

8691
05:51:43,440 --> 05:51:46,160
we're going to go down here and run

8692
05:51:46,160 --> 05:51:48,080
rooster again

8693
05:51:48,080 --> 05:51:49,840
and you're going to see that all these

8694
05:51:49,840 --> 05:51:52,400
things are true here because one of

8695
05:51:52,400 --> 05:51:55,520
these things is shown and as long as you

8696
05:51:55,520 --> 05:51:59,280
have one true operand your or operation

8697
05:51:59,280 --> 05:52:02,480
is going to evaluate to true and again

8698
05:52:02,480 --> 05:52:04,558
this is following the precedence and

8699
05:52:04,558 --> 05:52:07,200
associativity rules we have if we go

8700
05:52:07,200 --> 05:52:10,160
back to our table in our browser we're

8701
05:52:10,160 --> 05:52:13,280
going to try and look at logical or

8702
05:52:13,280 --> 05:52:14,320
it is

8703
05:52:14,320 --> 05:52:16,638
left associative so we're going to try

8704
05:52:16,638 --> 05:52:19,440
and evaluate this from left to right so

8705
05:52:19,440 --> 05:52:22,958
we're going to or a and b and the result

8706
05:52:22,958 --> 05:52:26,160
of this is going to be ord with c we

8707
05:52:26,160 --> 05:52:29,280
have also seen the not operator which is

8708
05:52:29,280 --> 05:52:32,480
denoted by the exclamation mark here and

8709
05:52:32,480 --> 05:52:34,878
what it is going to do is basically

8710
05:52:34,878 --> 05:52:37,360
flip off or negate whatever it is you

8711
05:52:37,360 --> 05:52:39,440
have if you have it true in your

8712
05:52:39,440 --> 05:52:42,240
variable the result is going to be false

8713
05:52:42,240 --> 05:52:44,320
if you have uniforms the result is going

8714
05:52:44,320 --> 05:52:45,440
to be true

8715
05:52:45,440 --> 05:52:49,040
and not a is going to be false because a

8716
05:52:49,040 --> 05:52:51,680
is true not b is going to be true

8717
05:52:51,680 --> 05:52:53,440
because b

8718
05:52:53,440 --> 05:52:56,320
is false and not c

8719
05:52:56,320 --> 05:52:59,280
is going to be false because c is true

8720
05:52:59,280 --> 05:53:01,920
as we can see here so let's run the

8721
05:53:01,920 --> 05:53:04,160
application and see if this is what we

8722
05:53:04,160 --> 05:53:05,440
expect

8723
05:53:05,440 --> 05:53:08,718
we're going to run and build with gcc

8724
05:53:08,718 --> 05:53:11,360
and we're going to run rooster and we're

8725
05:53:11,360 --> 05:53:14,878
going to see that note a is false not b

8726
05:53:14,878 --> 05:53:18,718
is true and not c is false and this is

8727
05:53:18,718 --> 05:53:21,120
what we expect we have also seen that we

8728
05:53:21,120 --> 05:53:24,080
can do combinations of these operators

8729
05:53:24,080 --> 05:53:26,400
so for example we can look at the

8730
05:53:26,400 --> 05:53:28,558
expression we have here

8731
05:53:28,558 --> 05:53:29,840
we're going to

8732
05:53:29,840 --> 05:53:33,440
take a and b this is going to evaluate

8733
05:53:33,440 --> 05:53:36,160
to false because b is false

8734
05:53:36,160 --> 05:53:38,320
we're going to negate this and we're

8735
05:53:38,320 --> 05:53:40,480
going to get a true and we're going to

8736
05:53:40,480 --> 05:53:42,160
order that with c

8737
05:53:42,160 --> 05:53:44,000
but because it's true

8738
05:53:44,000 --> 05:53:46,400
we know that the result of ordering this

8739
05:53:46,400 --> 05:53:48,878
with anything is going to be true so we

8740
05:53:48,878 --> 05:53:52,000
expect this expression here to evaluate

8741
05:53:52,000 --> 05:53:55,040
to true if we run this

8742
05:53:55,040 --> 05:53:57,200
we're going to see that this is going to

8743
05:53:57,200 --> 05:53:59,680
evaluate to true and it is what we

8744
05:53:59,680 --> 05:54:00,958
expect

8745
05:54:00,958 --> 05:54:02,558
the last thing we want to see in this

8746
05:54:02,558 --> 05:54:05,200
lecture is that we can combine

8747
05:54:05,200 --> 05:54:08,000
these logical operators with the

8748
05:54:08,000 --> 05:54:10,798
relational operators we have seen in the

8749
05:54:10,798 --> 05:54:13,440
last lecture we are going to put in a

8750
05:54:13,440 --> 05:54:16,878
piece of code to play with this this is

8751
05:54:16,878 --> 05:54:19,280
lengthy but you can play with this and

8752
05:54:19,280 --> 05:54:22,718
see what this is going to evaluate to to

8753
05:54:22,718 --> 05:54:24,638
start you off we are going to do the

8754
05:54:24,638 --> 05:54:28,558
first one together so it does test if d

8755
05:54:28,558 --> 05:54:31,200
is greater than e and if you look here

8756
05:54:31,200 --> 05:54:33,920
45 is greater than 20 so this is going

8757
05:54:33,920 --> 05:54:36,000
to evaluate to true

8758
05:54:36,000 --> 05:54:38,638
and we're going to enter that with d

8759
05:54:38,638 --> 05:54:40,718
greater than f

8760
05:54:40,718 --> 05:54:43,840
the result of this is going to be true

8761
05:54:43,840 --> 05:54:46,558
so we're going to be ending a true and a

8762
05:54:46,558 --> 05:54:48,958
true and the result of this is going to

8763
05:54:48,958 --> 05:54:51,360
be a true and again you notice that we

8764
05:54:51,360 --> 05:54:53,440
are wrapping this in parenthesis to

8765
05:54:53,440 --> 05:54:55,120
avoid problems

8766
05:54:55,120 --> 05:54:58,558
with the compiler being confused with

8767
05:54:58,558 --> 05:55:00,480
what we are trying to print this is

8768
05:55:00,480 --> 05:55:03,040
going to get rid of the otherwise ugly

8769
05:55:03,040 --> 05:55:05,440
problems we might have to deal with if

8770
05:55:05,440 --> 05:55:07,840
we didn't wrap this into parentheses

8771
05:55:07,840 --> 05:55:10,320
like this so we expect to see a true

8772
05:55:10,320 --> 05:55:13,040
here and we're going to weld

8773
05:55:13,040 --> 05:55:16,320
and run the task to build with gcc

8774
05:55:16,320 --> 05:55:19,040
and we're going to run rooster and if we

8775
05:55:19,040 --> 05:55:21,680
look at the first thing here this is

8776
05:55:21,680 --> 05:55:24,160
going to be true and you can try and do

8777
05:55:24,160 --> 05:55:26,558
the other ones in your mind as an

8778
05:55:26,558 --> 05:55:29,120
exercise and if you have a problem don't

8779
05:55:29,120 --> 05:55:31,680
hesitate to ask me i am going to do the

8780
05:55:31,680 --> 05:55:34,080
best i can to help you out

8781
05:55:34,080 --> 05:55:35,760
this is really all we set out to do in

8782
05:55:35,760 --> 05:55:37,920
this lecture i hope you have a better

8783
05:55:37,920 --> 05:55:41,040
understanding of these logical operators

8784
05:55:41,040 --> 05:55:43,360
again you don't have to really memorize

8785
05:55:43,360 --> 05:55:46,320
them all you have to do is consult the

8786
05:55:46,320 --> 05:55:48,558
tables and you're going to basically

8787
05:55:48,558 --> 05:55:51,280
know the result of your two operands

8788
05:55:51,280 --> 05:55:53,920
depending on the values you have inside

8789
05:55:53,920 --> 05:55:57,760
for and or and the not operator we are

8790
05:55:57,760 --> 05:56:00,000
going to stop here in this lecture in

8791
05:56:00,000 --> 05:56:01,520
the next one we're going to see how we

8792
05:56:01,520 --> 05:56:05,200
can format our output to make it really

8793
05:56:05,200 --> 05:56:08,080
look better go ahead and finish up here

8794
05:56:08,080 --> 05:56:10,320
and meet me there in this lecture we're

8795
05:56:10,320 --> 05:56:13,360
going to look at output formatting and c

8796
05:56:13,360 --> 05:56:15,760
plus and this is the way we can format

8797
05:56:15,760 --> 05:56:18,080
stuff we send it to the terminal through

8798
05:56:18,080 --> 05:56:21,520
sddc out and make them show up better as

8799
05:56:21,520 --> 05:56:24,080
an example let's say we have a table

8800
05:56:24,080 --> 05:56:27,440
here that has names and ages

8801
05:56:27,440 --> 05:56:30,240
and you see that they are cramped and

8802
05:56:30,240 --> 05:56:32,638
through output formatting we can take

8803
05:56:32,638 --> 05:56:35,600
this and turn this into this

8804
05:56:35,600 --> 05:56:38,000
and hopefully we agree that this is

8805
05:56:38,000 --> 05:56:38,878
better

8806
05:56:38,878 --> 05:56:41,360
there are a set of tools we can use in c

8807
05:56:41,360 --> 05:56:43,680
plus plus and those we're going to be

8808
05:56:43,680 --> 05:56:46,558
using in this lecture are going to be

8809
05:56:46,558 --> 05:56:49,520
coming from these two libraries ios and

8810
05:56:49,520 --> 05:56:53,040
io manip and there are a lot of things

8811
05:56:53,040 --> 05:56:56,638
in these two libraries here is a a set

8812
05:56:56,638 --> 05:57:00,400
of cards that show a lot of them we are

8813
05:57:00,400 --> 05:57:01,840
going to play with a lot of these in

8814
05:57:01,840 --> 05:57:03,840
this lecture so you don't have to worry

8815
05:57:03,840 --> 05:57:06,400
if some of them seem scary

8816
05:57:06,400 --> 05:57:08,798
right now before we start looking at

8817
05:57:08,798 --> 05:57:11,200
them i want to bring to your attention

8818
05:57:11,200 --> 05:57:13,440
that there is a piece of documentation

8819
05:57:13,440 --> 05:57:15,680
on these things the link is here the

8820
05:57:15,680 --> 05:57:17,480
website is called

8821
05:57:17,480 --> 05:57:19,040
cppreference.com

8822
05:57:19,040 --> 05:57:21,600
and you can open this up and look at

8823
05:57:21,600 --> 05:57:23,200
some of the things we're going to talk

8824
05:57:23,200 --> 05:57:25,680
about in this lecture okay the first one

8825
05:57:25,680 --> 05:57:29,440
we're going to look at is stdendl

8826
05:57:29,440 --> 05:57:31,840
this is not new we have been using it

8827
05:57:31,840 --> 05:57:34,400
all day long to print out a new line

8828
05:57:34,400 --> 05:57:38,000
character so that our htdcl statements

8829
05:57:38,000 --> 05:57:40,718
print things on different lines and if

8830
05:57:40,718 --> 05:57:43,280
we don't have this manipulator you see

8831
05:57:43,280 --> 05:57:46,240
here on the top we have hello and world

8832
05:57:46,240 --> 05:57:48,080
and if we print them out they are going

8833
05:57:48,080 --> 05:57:50,480
to show up on one line because we are

8834
05:57:50,480 --> 05:57:53,600
not separating the lines with std e and

8835
05:57:53,600 --> 05:57:56,638
dl down below here we have another way

8836
05:57:56,638 --> 05:57:59,760
we can do this we can post a backslash n

8837
05:57:59,760 --> 05:58:02,718
after our text and that's going to add a

8838
05:58:02,718 --> 05:58:06,320
new line character just like std endl

8839
05:58:06,320 --> 05:58:10,958
does okay stdndl and slash n in here

8840
05:58:10,958 --> 05:58:13,600
seemingly do the same thing

8841
05:58:13,600 --> 05:58:15,760
but they are different but we don't have

8842
05:58:15,760 --> 05:58:17,600
enough tools to really understand the

8843
05:58:17,600 --> 05:58:20,400
differences right now for now just think

8844
05:58:20,400 --> 05:58:23,360
of them as two things that do the same

8845
05:58:23,360 --> 05:58:26,320
thing they print out a new character

8846
05:58:26,320 --> 05:58:28,400
that allows your text to show up on

8847
05:58:28,400 --> 05:58:31,200
different lines like we have hello and

8848
05:58:31,200 --> 05:58:34,400
world here okay stdndl is the first

8849
05:58:34,400 --> 05:58:36,558
manipulator we're going to play with in

8850
05:58:36,558 --> 05:58:38,240
this lecture the next one we're going to

8851
05:58:38,240 --> 05:58:40,480
look at is sdd flush

8852
05:58:40,480 --> 05:58:43,040
and this is going to send whatever is in

8853
05:58:43,040 --> 05:58:46,160
the output buffer to the terminal

8854
05:58:46,160 --> 05:58:48,878
and what the heck is an output buffer

8855
05:58:48,878 --> 05:58:51,440
let's look at an example suppose we have

8856
05:58:51,440 --> 05:58:54,240
sddc out here and we want to print on

8857
05:58:54,240 --> 05:58:56,798
this terminal and the message we want to

8858
05:58:56,798 --> 05:59:00,400
print is hello world how are you so what

8859
05:59:00,400 --> 05:59:03,360
is going to happen if the sddc out

8860
05:59:03,360 --> 05:59:06,000
statement is executed things are not

8861
05:59:06,000 --> 05:59:07,760
going to be directly sent to the

8862
05:59:07,760 --> 05:59:10,400
terminal they are going to go into an

8863
05:59:10,400 --> 05:59:12,718
intermediary buffer you can think of

8864
05:59:12,718 --> 05:59:15,120
this as some kind of storage in which

8865
05:59:15,120 --> 05:59:18,320
data goes before it goes to the terminal

8866
05:59:18,320 --> 05:59:20,000
and this is what's going to happen we

8867
05:59:20,000 --> 05:59:21,920
print out hello hello is not going to go

8868
05:59:21,920 --> 05:59:23,760
to the terminal directly

8869
05:59:23,760 --> 05:59:25,760
we print out world

8870
05:59:25,760 --> 05:59:28,080
it's not going to go to the terminal we

8871
05:59:28,080 --> 05:59:30,320
print out how are you

8872
05:59:30,320 --> 05:59:32,320
it's not going to go to the terminal and

8873
05:59:32,320 --> 05:59:34,558
when the buffer is full

8874
05:59:34,558 --> 05:59:36,638
the data is going to be sent to the

8875
05:59:36,638 --> 05:59:39,920
terminal in one go and this may come in

8876
05:59:39,920 --> 05:59:42,878
handy in some situations so if you want

8877
05:59:42,878 --> 05:59:45,600
the data to go to the terminal directly

8878
05:59:45,600 --> 05:59:48,400
you're going to add an sdd flash

8879
05:59:48,400 --> 05:59:52,000
after your hddc out statement and we are

8880
05:59:52,000 --> 05:59:54,160
going to play with this in a minute in

8881
05:59:54,160 --> 05:59:55,760
visual studio code and you're going to

8882
05:59:55,760 --> 05:59:58,000
see how this works another manipulator

8883
05:59:58,000 --> 06:00:01,520
we have which is really cool is set with

8884
06:00:01,520 --> 06:00:05,680
and it is std set w here and what it

8885
06:00:05,680 --> 06:00:09,600
does it specifies a width for whatever

8886
06:00:09,600 --> 06:00:12,480
text you want to print here we have two

8887
06:00:12,480 --> 06:00:15,920
examples the first one is our table that

8888
06:00:15,920 --> 06:00:18,320
is not formatted well and you see we

8889
06:00:18,320 --> 06:00:20,320
just print out the data and it is going

8890
06:00:20,320 --> 06:00:23,680
to show up like we see here on the right

8891
06:00:23,680 --> 06:00:27,840
we can use std set with to set the width

8892
06:00:27,840 --> 06:00:30,480
of the text here and for example the

8893
06:00:30,480 --> 06:00:32,958
last name here is going to show up in a

8894
06:00:32,958 --> 06:00:36,480
field which is 10 characters white this

8895
06:00:36,480 --> 06:00:38,718
is what we mean here and we do the same

8896
06:00:38,718 --> 06:00:41,920
for the first name and the age and if we

8897
06:00:41,920 --> 06:00:43,040
do this

8898
06:00:43,040 --> 06:00:45,440
data is going to show up nicely as we

8899
06:00:45,440 --> 06:00:48,558
see here and again i hope we agreed that

8900
06:00:48,558 --> 06:00:51,120
what we have down below here is much

8901
06:00:51,120 --> 06:00:53,760
better than what we had here

8902
06:00:53,760 --> 06:00:56,878
which was not formatted with set width

8903
06:00:56,878 --> 06:00:59,120
and this is how you use this manipulator

8904
06:00:59,120 --> 06:01:01,120
here we can also use what we call

8905
06:01:01,120 --> 06:01:03,200
justification to control whether our

8906
06:01:03,200 --> 06:01:06,080
data shows up on the right or on the

8907
06:01:06,080 --> 06:01:06,958
left

8908
06:01:06,958 --> 06:01:10,080
in the width that is allocated to it for

8909
06:01:10,080 --> 06:01:11,840
example here the

8910
06:01:11,840 --> 06:01:14,878
justification is sdd right so the data

8911
06:01:14,878 --> 06:01:16,958
is going to show up to the right in its

8912
06:01:16,958 --> 06:01:19,840
respective cells we can also use what we

8913
06:01:19,840 --> 06:01:23,040
call internal justification by which if

8914
06:01:23,040 --> 06:01:25,760
we are showing a negative number the

8915
06:01:25,760 --> 06:01:28,240
sign is going to be left justified so it

8916
06:01:28,240 --> 06:01:30,638
is going to show up on the left but the

8917
06:01:30,638 --> 06:01:33,200
data is going to be right justified and

8918
06:01:33,200 --> 06:01:35,200
this may come in handy if you want to

8919
06:01:35,200 --> 06:01:37,600
display some tabular data

8920
06:01:37,600 --> 06:01:41,440
in your terminal we can also use std set

8921
06:01:41,440 --> 06:01:44,000
field to specify the field character in

8922
06:01:44,000 --> 06:01:47,040
our empty spaces for example here we set

8923
06:01:47,040 --> 06:01:49,680
the dash as a field character and the

8924
06:01:49,680 --> 06:01:52,878
result is what you see down below here

8925
06:01:52,878 --> 06:01:56,240
we have seen std ball alpha and its

8926
06:01:56,240 --> 06:01:58,320
effect is to force

8927
06:01:58,320 --> 06:02:02,480
stdc out to show boolean output in the

8928
06:02:02,480 --> 06:02:05,920
form of true and false if you don't put

8929
06:02:05,920 --> 06:02:08,480
this manipulator in you're going to see

8930
06:02:08,480 --> 06:02:11,440
those pieces of data as ones and zeros

8931
06:02:11,440 --> 06:02:12,878
so for example here we have two

8932
06:02:12,878 --> 06:02:15,440
variables condition and other condition

8933
06:02:15,440 --> 06:02:17,200
if we print them out they are going to

8934
06:02:17,200 --> 06:02:19,840
show up as one and zero we are going to

8935
06:02:19,840 --> 06:02:22,240
set our manipulator here so the data is

8936
06:02:22,240 --> 06:02:24,958
going to show up as true and false we

8937
06:02:24,958 --> 06:02:28,240
can disable this manipulator here with

8938
06:02:28,240 --> 06:02:31,600
std noble alpha and the data is going to

8939
06:02:31,600 --> 06:02:34,638
go back to be shown in the form of one

8940
06:02:34,638 --> 06:02:37,360
and zero this is what this manipulator

8941
06:02:37,360 --> 06:02:39,520
does we also have one to show the

8942
06:02:39,520 --> 06:02:42,320
positive sign for positive numbers

8943
06:02:42,320 --> 06:02:43,200
so

8944
06:02:43,200 --> 06:02:45,280
if we don't enable it the data here is

8945
06:02:45,280 --> 06:02:48,080
going to show up like this 34 and minus

8946
06:02:48,080 --> 06:02:50,878
45 you see that the minus sign is going

8947
06:02:50,878 --> 06:02:53,760
to be shown regardless of the setting

8948
06:02:53,760 --> 06:02:56,958
you have for this manipulator but if we

8949
06:02:56,958 --> 06:02:59,760
enable std show pose

8950
06:02:59,760 --> 06:03:02,160
we're going to show the positive number

8951
06:03:02,160 --> 06:03:04,320
and this may make sense for whatever

8952
06:03:04,320 --> 06:03:06,480
application you might be doing

8953
06:03:06,480 --> 06:03:09,520
we can disable this with std no show

8954
06:03:09,520 --> 06:03:12,320
posts and after we do this the data is

8955
06:03:12,320 --> 06:03:15,520
going to show up in its default format

8956
06:03:15,520 --> 06:03:17,840
that we have seen before this is how you

8957
06:03:17,840 --> 06:03:20,798
use std show posts we also have

8958
06:03:20,798 --> 06:03:23,120
manipulators to control

8959
06:03:23,120 --> 06:03:26,080
the base in which the data is shown and

8960
06:03:26,080 --> 06:03:28,798
we can show the data either in a decimal

8961
06:03:28,798 --> 06:03:31,760
in octo or in hexodecimal if you look at

8962
06:03:31,760 --> 06:03:34,080
the data here we have an integer which

8963
06:03:34,080 --> 06:03:35,920
is positive we have an integer which is

8964
06:03:35,920 --> 06:03:38,718
negative and we have a double variable

8965
06:03:38,718 --> 06:03:41,360
here and we have some data n for us to

8966
06:03:41,360 --> 06:03:43,040
play with we're going to show our

8967
06:03:43,040 --> 06:03:45,840
positive integer in these three bases

8968
06:03:45,840 --> 06:03:48,558
decimal hex and octo

8969
06:03:48,558 --> 06:03:51,200
and the result is what you see here and

8970
06:03:51,200 --> 06:03:53,520
this should be no surprise you already

8971
06:03:53,520 --> 06:03:54,480
know

8972
06:03:54,480 --> 06:03:57,680
these number systems and how they work

8973
06:03:57,680 --> 06:03:59,840
we can take the negative number and also

8974
06:03:59,840 --> 06:04:02,160
show it in different bases decimal

8975
06:04:02,160 --> 06:04:05,280
hexadecimal and octo and it is what you

8976
06:04:05,280 --> 06:04:08,400
have on the right here in our terminal

8977
06:04:08,400 --> 06:04:10,958
if we go down and try to show

8978
06:04:10,958 --> 06:04:14,320
a double or a floating point number in

8979
06:04:14,320 --> 06:04:17,040
these bases the result is not going to

8980
06:04:17,040 --> 06:04:20,160
change because these number systems have

8981
06:04:20,160 --> 06:04:22,958
no effect on floating point numbers if

8982
06:04:22,958 --> 06:04:25,360
you remember we have seen that floating

8983
06:04:25,360 --> 06:04:26,878
point numbers

8984
06:04:26,878 --> 06:04:29,520
are represented in memory following

8985
06:04:29,520 --> 06:04:32,320
another protocol that is really advanced

8986
06:04:32,320 --> 06:04:33,200
for

8987
06:04:33,200 --> 06:04:35,840
a course like this so we are just going

8988
06:04:35,840 --> 06:04:37,600
to use this but we're not going to try

8989
06:04:37,600 --> 06:04:39,840
and understand it because it is out of

8990
06:04:39,840 --> 06:04:42,480
scope for what we are doing here we can

8991
06:04:42,480 --> 06:04:45,440
also use std show base

8992
06:04:45,440 --> 06:04:48,718
to show the base of our output

8993
06:04:48,718 --> 06:04:50,878
so here we have a positive number which

8994
06:04:50,878 --> 06:04:54,638
is an integer and we can show it in

8995
06:04:54,638 --> 06:04:57,200
decimal hex and act and we're going to

8996
06:04:57,200 --> 06:05:00,080
see what we see here to the right but we

8997
06:05:00,080 --> 06:05:03,200
can choose to also show the base of

8998
06:05:03,200 --> 06:05:05,440
whatever it is we output if we want to

8999
06:05:05,440 --> 06:05:08,480
specify that the output is in decimal

9000
06:05:08,480 --> 06:05:11,040
we're going to say that here but we can

9001
06:05:11,040 --> 06:05:13,440
also decide to show the base and we

9002
06:05:13,440 --> 06:05:18,240
enable that with std show base like this

9003
06:05:18,240 --> 06:05:20,240
and if we do this we're going to see

9004
06:05:20,240 --> 06:05:22,160
decimal is not going to have anything in

9005
06:05:22,160 --> 06:05:25,840
front hex is going to have a 0x in front

9006
06:05:25,840 --> 06:05:29,280
oct is going to have a zero in front and

9007
06:05:29,280 --> 06:05:31,680
by this it is going to be very easy to

9008
06:05:31,680 --> 06:05:32,558
see

9009
06:05:32,558 --> 06:05:35,760
the base in which your data is displayed

9010
06:05:35,760 --> 06:05:38,160
we can also use std upper case for the

9011
06:05:38,160 --> 06:05:40,160
data we print out to be shown in

9012
06:05:40,160 --> 06:05:43,120
uppercase where it makes sense for

9013
06:05:43,120 --> 06:05:44,878
example here we are trying to print

9014
06:05:44,878 --> 06:05:47,520
numbers in hexadecimal here in the

9015
06:05:47,520 --> 06:05:50,320
middle so if we don't use uppercase

9016
06:05:50,320 --> 06:05:51,920
which is the default

9017
06:05:51,920 --> 06:05:53,840
the number is going to show up like this

9018
06:05:53,840 --> 06:05:57,760
you see a and f are lowercase but if we

9019
06:05:57,760 --> 06:06:00,080
enable uppercase we're going to see this

9020
06:06:00,080 --> 06:06:02,718
in uppercase and sometimes this is going

9021
06:06:02,718 --> 06:06:05,280
to be helpful for whatever application

9022
06:06:05,280 --> 06:06:08,400
you are using the sun we also have a few

9023
06:06:08,400 --> 06:06:10,638
manipulators to control how floating

9024
06:06:10,638 --> 06:06:13,440
point data is shown on the terminal and

9025
06:06:13,440 --> 06:06:16,160
the two of these are std scientific and

9026
06:06:16,160 --> 06:06:19,440
sdd fixed by default stdc out is going

9027
06:06:19,440 --> 06:06:20,878
to show

9028
06:06:20,878 --> 06:06:23,680
in scientific format where necessary and

9029
06:06:23,680 --> 06:06:26,558
it is going to use fixed by default so

9030
06:06:26,558 --> 06:06:28,240
what we have here

9031
06:06:28,240 --> 06:06:31,120
we have three variables abc

9032
06:06:31,120 --> 06:06:33,360
and if we just print them out they are

9033
06:06:33,360 --> 06:06:36,080
going to show up in this format here if

9034
06:06:36,080 --> 06:06:38,320
we use fixed we're going to force the

9035
06:06:38,320 --> 06:06:40,878
output to be in fixed format and you're

9036
06:06:40,878 --> 06:06:43,120
going to see that the third number in c

9037
06:06:43,120 --> 06:06:46,798
here is going to show up as 0.0 and a

9038
06:06:46,798 --> 06:06:49,840
few zeros after that because in the

9039
06:06:49,840 --> 06:06:52,080
precision that we have now we can't

9040
06:06:52,080 --> 06:06:55,440
really show a number that is as low as

9041
06:06:55,440 --> 06:06:57,840
we have here in c again we have seen

9042
06:06:57,840 --> 06:07:00,320
this scientific format this is

9043
06:07:00,320 --> 06:07:03,120
basically 1.34

9044
06:07:03,120 --> 06:07:06,080
multiplied by 10 to the power of minus

9045
06:07:06,080 --> 06:07:08,480
10 and this is a really really low

9046
06:07:08,480 --> 06:07:10,840
number so we're going to do

9047
06:07:10,840 --> 06:07:14,480
0.000 up to 10 and that's when this

9048
06:07:14,480 --> 06:07:16,798
decimal point is going to show so it's a

9049
06:07:16,798 --> 06:07:19,120
number that is really close to zero

9050
06:07:19,120 --> 06:07:21,760
that's why we are showing it like 0.0

9051
06:07:21,760 --> 06:07:24,638
here i hope this makes sense we can also

9052
06:07:24,638 --> 06:07:27,520
use scientific notation if we want that

9053
06:07:27,520 --> 06:07:30,320
and if we force scientific notation

9054
06:07:30,320 --> 06:07:32,000
everything is going to be shown in

9055
06:07:32,000 --> 06:07:34,878
scientific notation another thing that i

9056
06:07:34,878 --> 06:07:37,520
really want you to be aware of is that

9057
06:07:37,520 --> 06:07:40,958
there is no official way to set

9058
06:07:40,958 --> 06:07:41,760
the

9059
06:07:41,760 --> 06:07:45,600
floating point output to its defaults

9060
06:07:45,600 --> 06:07:48,080
and here is a hack i actually learned

9061
06:07:48,080 --> 06:07:50,558
about when i was making this course the

9062
06:07:50,558 --> 06:07:52,798
explanation of this is really out of

9063
06:07:52,798 --> 06:07:55,680
scope for this course but just use this

9064
06:07:55,680 --> 06:07:57,360
to set

9065
06:07:57,360 --> 06:08:00,480
the floating point output format to the

9066
06:08:00,480 --> 06:08:02,160
defaults and if you do this you're going

9067
06:08:02,160 --> 06:08:04,080
to get whatever we had

9068
06:08:04,080 --> 06:08:06,638
here with the defaults you're going to

9069
06:08:06,638 --> 06:08:08,558
see that it is the same things the next

9070
06:08:08,558 --> 06:08:10,958
thing we're going to look at is std set

9071
06:08:10,958 --> 06:08:13,360
precision which we have seen before and

9072
06:08:13,360 --> 06:08:16,160
this is going to set the precision

9073
06:08:16,160 --> 06:08:18,558
with which the data is going to show up

9074
06:08:18,558 --> 06:08:20,958
on the terminal if you use a precision

9075
06:08:20,958 --> 06:08:23,120
of 10 that's what you're going to get

9076
06:08:23,120 --> 06:08:26,000
here here you see that we have a double

9077
06:08:26,000 --> 06:08:29,440
number it is a number that has a lot of

9078
06:08:29,440 --> 06:08:32,000
numbers after the decimal point if we

9079
06:08:32,000 --> 06:08:33,760
show it by default it's going to show up

9080
06:08:33,760 --> 06:08:35,520
like this the precision is going to be

9081
06:08:35,520 --> 06:08:38,080
sex we can increase the precision to 10

9082
06:08:38,080 --> 06:08:41,440
to 20 and 50 and it is going to show up

9083
06:08:41,440 --> 06:08:43,680
at whatever precision that you specify

9084
06:08:43,680 --> 06:08:44,558
here

9085
06:08:44,558 --> 06:08:46,878
please know that this precision is going

9086
06:08:46,878 --> 06:08:49,520
to be limited by the type of this a

9087
06:08:49,520 --> 06:08:50,558
variable

9088
06:08:50,558 --> 06:08:52,878
if it is a floating point the precision

9089
06:08:52,878 --> 06:08:55,040
is going to be something like 7 we have

9090
06:08:55,040 --> 06:08:57,040
seen that if it is a double the

9091
06:08:57,040 --> 06:08:59,440
precision is going to basically double

9092
06:08:59,440 --> 06:09:02,480
to something like 15 and if you have a

9093
06:09:02,480 --> 06:09:04,958
long double the precision is going to be

9094
06:09:04,958 --> 06:09:07,280
something bigger than double but it

9095
06:09:07,280 --> 06:09:10,320
can't go below that of a double we have

9096
06:09:10,320 --> 06:09:12,958
seen this before we also have show point

9097
06:09:12,958 --> 06:09:15,040
which is going to force

9098
06:09:15,040 --> 06:09:17,600
showing the decimal point for floating

9099
06:09:17,600 --> 06:09:21,440
point values you see here we have a 12.0

9100
06:09:21,440 --> 06:09:23,280
this is the most important piece of data

9101
06:09:23,280 --> 06:09:24,558
we have here

9102
06:09:24,558 --> 06:09:27,360
if we don't do show point this is going

9103
06:09:27,360 --> 06:09:31,280
to show up as 12 in the output here but

9104
06:09:31,280 --> 06:09:34,558
we can use show point to force for the

9105
06:09:34,558 --> 06:09:36,798
decimal point to be shown and you see

9106
06:09:36,798 --> 06:09:37,638
that

9107
06:09:37,638 --> 06:09:41,760
12.00 here is shown another side effect

9108
06:09:41,760 --> 06:09:43,200
of this is that

9109
06:09:43,200 --> 06:09:45,440
show point is going to force the showing

9110
06:09:45,440 --> 06:09:48,160
of trailing zeros and it is what we see

9111
06:09:48,160 --> 06:09:51,360
here in d e and f we have seen a lot of

9112
06:09:51,360 --> 06:09:53,520
manipulators here is a table that is

9113
06:09:53,520 --> 06:09:55,680
going to show where many of these are

9114
06:09:55,680 --> 06:09:58,878
going to be living so if you need to use

9115
06:09:58,878 --> 06:10:01,520
set width this is going to be living

9116
06:10:01,520 --> 06:10:05,200
in the i o manip header and here we have

9117
06:10:05,200 --> 06:10:07,760
a few other ones so if you want to use a

9118
06:10:07,760 --> 06:10:10,080
few of these things these are the

9119
06:10:10,080 --> 06:10:12,320
libraries that you will need to include

9120
06:10:12,320 --> 06:10:14,878
with pound include as we have been

9121
06:10:14,878 --> 06:10:17,520
including i o stream and again the

9122
06:10:17,520 --> 06:10:19,920
documentation for these things is shown

9123
06:10:19,920 --> 06:10:20,600
at

9124
06:10:20,600 --> 06:10:23,520
cppreference.com this is the exact link

9125
06:10:23,520 --> 06:10:26,000
and you can check this out if it helps

9126
06:10:26,000 --> 06:10:26,958
out

9127
06:10:26,958 --> 06:10:28,798
now that we have an idea about these

9128
06:10:28,798 --> 06:10:30,638
things we're going to go in visual

9129
06:10:30,638 --> 06:10:33,440
studio code and actually see these in

9130
06:10:33,440 --> 06:10:36,400
action okay here we are in visual studio

9131
06:10:36,400 --> 06:10:37,920
code the project we're going to be

9132
06:10:37,920 --> 06:10:41,120
working on here is output formatting so

9133
06:10:41,120 --> 06:10:42,638
we're going to be

9134
06:10:42,638 --> 06:10:43,840
grabbing

9135
06:10:43,840 --> 06:10:45,920
our template files

9136
06:10:45,920 --> 06:10:49,120
and put those in our project here

9137
06:10:49,120 --> 06:10:51,280
and we're going to go up again and open

9138
06:10:51,280 --> 06:10:53,440
up this folder in visual studio code

9139
06:10:53,440 --> 06:10:55,200
let's do that we're going to close the

9140
06:10:55,200 --> 06:10:57,520
welcome screen here and we're going to

9141
06:10:57,520 --> 06:10:59,680
remove whatever it is we don't need

9142
06:10:59,680 --> 06:11:01,520
we're going to take this out

9143
06:11:01,520 --> 06:11:03,520
and we are going to put in the first

9144
06:11:03,520 --> 06:11:05,920
code we want to play with and this is

9145
06:11:05,920 --> 06:11:07,680
stdendl

9146
06:11:07,680 --> 06:11:09,200
you don't really need a lot of

9147
06:11:09,200 --> 06:11:11,360
explanations for this because we've used

9148
06:11:11,360 --> 06:11:13,120
this all along

9149
06:11:13,120 --> 06:11:14,718
if you don't put it out the data is

9150
06:11:14,718 --> 06:11:17,040
going to show up on one line and uh

9151
06:11:17,040 --> 06:11:19,280
you're going to have hello world on one

9152
06:11:19,280 --> 06:11:20,160
line

9153
06:11:20,160 --> 06:11:23,120
if we put stdndl like this we're going

9154
06:11:23,120 --> 06:11:25,040
to have the data show up on different

9155
06:11:25,040 --> 06:11:27,040
lines so we're going to have hello and

9156
06:11:27,040 --> 06:11:29,760
world on different lines and it is

9157
06:11:29,760 --> 06:11:33,120
possible to use a backslash n to achieve

9158
06:11:33,120 --> 06:11:35,920
the same thing but these work very

9159
06:11:35,920 --> 06:11:38,558
differently underground and we don't

9160
06:11:38,558 --> 06:11:40,400
have enough tools to really understand

9161
06:11:40,400 --> 06:11:43,440
the difference so for now just take this

9162
06:11:43,440 --> 06:11:45,920
as the truth and i know that there are

9163
06:11:45,920 --> 06:11:48,480
differences and the most important thing

9164
06:11:48,480 --> 06:11:50,878
is that you recognize these things if

9165
06:11:50,878 --> 06:11:53,760
you see them in code out there we are

9166
06:11:53,760 --> 06:11:56,718
going to bring up our terminum and build

9167
06:11:56,718 --> 06:11:59,280
this with our task that is going to

9168
06:11:59,280 --> 06:12:01,040
build with gcc

9169
06:12:01,040 --> 06:12:02,400
you're going to see that the world is

9170
06:12:02,400 --> 06:12:04,000
going to go through

9171
06:12:04,000 --> 06:12:06,638
and that we can run our rooster

9172
06:12:06,638 --> 06:12:09,840
binary to see the output you see that we

9173
06:12:09,840 --> 06:12:12,480
have hello world on one line

9174
06:12:12,480 --> 06:12:14,958
we have hello and world on different

9175
06:12:14,958 --> 06:12:17,120
lines and this is a result of these

9176
06:12:17,120 --> 06:12:19,558
events we have here you see we have

9177
06:12:19,558 --> 06:12:22,400
stdndl this is going to force

9178
06:12:22,400 --> 06:12:24,638
the terminal to go to the next line and

9179
06:12:24,638 --> 06:12:26,878
print world and after that we're going

9180
06:12:26,878 --> 06:12:29,200
to force the terminal to go to the next

9181
06:12:29,200 --> 06:12:31,680
line and that's where the next text is

9182
06:12:31,680 --> 06:12:34,080
going to show up after that we have

9183
06:12:34,080 --> 06:12:36,320
hello and world down here in the

9184
06:12:36,320 --> 06:12:39,760
terminal and it is the output generated

9185
06:12:39,760 --> 06:12:42,400
by the statements that we have in here

9186
06:12:42,400 --> 06:12:44,480
and you can see that it is going to

9187
06:12:44,480 --> 06:12:47,680
basically do the same thing as stdendl

9188
06:12:47,680 --> 06:12:50,240
but again they work very differently

9189
06:12:50,240 --> 06:12:52,878
under the hood okay so this is really

9190
06:12:52,878 --> 06:12:56,718
how std endl works and you get access to

9191
06:12:56,718 --> 06:12:59,520
it by including the i o stream

9192
06:12:59,520 --> 06:13:01,520
library here the next thing we're going

9193
06:13:01,520 --> 06:13:04,320
to play with is std flash

9194
06:13:04,320 --> 06:13:07,600
this is going to flash the output buffer

9195
06:13:07,600 --> 06:13:09,760
to its final destination and that's

9196
06:13:09,760 --> 06:13:10,878
going to be

9197
06:13:10,878 --> 06:13:13,920
the terminal in this case and if we add

9198
06:13:13,920 --> 06:13:16,160
that to our

9199
06:13:16,160 --> 06:13:18,798
stdcl statement like this

9200
06:13:18,798 --> 06:13:22,080
this is going to be directly sent to the

9201
06:13:22,080 --> 06:13:24,480
terminal and this may come in handy in

9202
06:13:24,480 --> 06:13:27,120
some applications if we run this we're

9203
06:13:27,120 --> 06:13:30,000
not going to really see a difference but

9204
06:13:30,000 --> 06:13:32,718
underground under the hood the data is

9205
06:13:32,718 --> 06:13:35,120
directly sent to the terminal and we had

9206
06:13:35,120 --> 06:13:37,280
the chance to explain this in the slides

9207
06:13:37,280 --> 06:13:40,638
earlier we can work this program and i

9208
06:13:40,638 --> 06:13:43,120
see it running the world is going to go

9209
06:13:43,120 --> 06:13:45,200
through if we run the rooster we're

9210
06:13:45,200 --> 06:13:47,200
going to see that this is a nice message

9211
06:13:47,200 --> 06:13:48,480
is sent

9212
06:13:48,480 --> 06:13:50,638
to the terminal the next thing we're

9213
06:13:50,638 --> 06:13:52,878
going to look at is set with i am going

9214
06:13:52,878 --> 06:13:54,958
to put in the code here because i don't

9215
06:13:54,958 --> 06:13:57,840
want to type all this and again you can

9216
06:13:57,840 --> 06:14:00,240
get the source code for this

9217
06:14:00,240 --> 06:14:03,280
in the results section of this lecture

9218
06:14:03,280 --> 06:14:04,958
you don't really have to type all these

9219
06:14:04,958 --> 06:14:06,878
things the most important thing is that

9220
06:14:06,878 --> 06:14:09,280
you really understand how they work okay

9221
06:14:09,280 --> 06:14:11,840
you see here we are going to use set

9222
06:14:11,840 --> 06:14:14,480
with but we haven't really included the

9223
06:14:14,480 --> 06:14:16,958
library that is going to give us access

9224
06:14:16,958 --> 06:14:18,638
to this and if you don't know which

9225
06:14:18,638 --> 06:14:20,718
library you will need to include to get

9226
06:14:20,718 --> 06:14:22,718
access to this well you can check the

9227
06:14:22,718 --> 06:14:25,680
documentation and to get access to the

9228
06:14:25,680 --> 06:14:28,000
documentation you might want to consult

9229
06:14:28,000 --> 06:14:30,480
your favorite search engine i am going

9230
06:14:30,480 --> 06:14:34,718
to go in google here and type in std

9231
06:14:34,718 --> 06:14:38,558
set w and i am going to search and this

9232
06:14:38,558 --> 06:14:40,480
is going to come up with a few entries i

9233
06:14:40,480 --> 06:14:42,520
am going to click on the one from

9234
06:14:42,520 --> 06:14:44,798
cppreference.com because this is

9235
06:14:44,798 --> 06:14:47,920
reliable in my opinion and if we open

9236
06:14:47,920 --> 06:14:49,840
this up we're going to see that to work

9237
06:14:49,840 --> 06:14:52,958
with us you need to include i o my net

9238
06:14:52,958 --> 06:14:55,360
so this is what we need to put in visual

9239
06:14:55,360 --> 06:14:57,840
studio code to get rid of this problem

9240
06:14:57,840 --> 06:15:00,638
let's do that i really wanted you to see

9241
06:15:00,638 --> 06:15:02,878
this process you can go through

9242
06:15:02,878 --> 06:15:05,520
to know what you need to include we're

9243
06:15:05,520 --> 06:15:07,760
going to put this in and hopefully the

9244
06:15:07,760 --> 06:15:10,240
arrow is going to go away and we can

9245
06:15:10,240 --> 06:15:13,200
focus on studying the effects of these

9246
06:15:13,200 --> 06:15:15,600
things here this is going to print and

9247
06:15:15,600 --> 06:15:17,680
formatted so the data is going to be

9248
06:15:17,680 --> 06:15:20,638
cropped close to each other but we can

9249
06:15:20,638 --> 06:15:23,840
format this using set width and if we

9250
06:15:23,840 --> 06:15:25,760
pass in a 10 here we are basically

9251
06:15:25,760 --> 06:15:28,958
saying last name is going to take the

9252
06:15:28,958 --> 06:15:31,920
width of 10 characters even if we don't

9253
06:15:31,920 --> 06:15:34,480
really have 10 characters in this so so

9254
06:15:34,480 --> 06:15:36,798
you're going to have spaces fill the

9255
06:15:36,798 --> 06:15:39,760
remaining spaces so that the data shows

9256
06:15:39,760 --> 06:15:42,558
up nicely this is really hard to say in

9257
06:15:42,558 --> 06:15:44,480
world so i am going to run this in a

9258
06:15:44,480 --> 06:15:46,400
minute so that you can see this but

9259
06:15:46,400 --> 06:15:48,798
before we run i want you to see that you

9260
06:15:48,798 --> 06:15:51,440
can also store the width information in

9261
06:15:51,440 --> 06:15:53,920
a variable like this and i use that

9262
06:15:53,920 --> 06:15:56,638
instead in your std statements the

9263
06:15:56,638 --> 06:15:59,360
benefit with that is that it is really

9264
06:15:59,360 --> 06:16:01,920
easy to change this with if you happen

9265
06:16:01,920 --> 06:16:04,480
to change your mind otherwise you would

9266
06:16:04,480 --> 06:16:06,718
have to change a lot of things and this

9267
06:16:06,718 --> 06:16:08,958
is really bad design i did this to show

9268
06:16:08,958 --> 06:16:11,360
you how you can use this but in real

9269
06:16:11,360 --> 06:16:14,000
code you are most probably going to

9270
06:16:14,000 --> 06:16:14,958
store

9271
06:16:14,958 --> 06:16:17,600
your weft information in a variable and

9272
06:16:17,600 --> 06:16:20,080
that way it's going to be really easy to

9273
06:16:20,080 --> 06:16:22,718
change and update if you happen to need

9274
06:16:22,718 --> 06:16:26,638
that we can build this program with gcc

9275
06:16:26,638 --> 06:16:28,958
and if we run it let's bring this up a

9276
06:16:28,958 --> 06:16:30,798
little bit we're going to have our data

9277
06:16:30,798 --> 06:16:32,718
that is unformatted and you see that it

9278
06:16:32,718 --> 06:16:35,600
is really ugly but down below here we

9279
06:16:35,600 --> 06:16:38,080
have our formatted table and it is

9280
06:16:38,080 --> 06:16:40,320
really nice we have last name first name

9281
06:16:40,320 --> 06:16:43,200
and age and it is easier to see these

9282
06:16:43,200 --> 06:16:45,360
things we're going to see that it is

9283
06:16:45,360 --> 06:16:46,718
possible to

9284
06:16:46,718 --> 06:16:49,120
force the data to show on the left or to

9285
06:16:49,120 --> 06:16:51,440
the right with justification and we're

9286
06:16:51,440 --> 06:16:53,920
going to look at code that does that

9287
06:16:53,920 --> 06:16:55,040
next

9288
06:16:55,040 --> 06:16:57,200
if we go down here and put in the next

9289
06:16:57,200 --> 06:16:59,360
piece of code we want to play with we're

9290
06:16:59,360 --> 06:17:01,680
going to see that data is right

9291
06:17:01,680 --> 06:17:03,840
justified by default but we have seen

9292
06:17:03,840 --> 06:17:06,480
this also you see that gray is cramped

9293
06:17:06,480 --> 06:17:08,718
to the right of the width of the cell

9294
06:17:08,718 --> 06:17:10,798
for the first name so data is right

9295
06:17:10,798 --> 06:17:13,200
justified by default and it is the same

9296
06:17:13,200 --> 06:17:14,000
here

9297
06:17:14,000 --> 06:17:15,040
if we

9298
06:17:15,040 --> 06:17:18,080
change the width of our

9299
06:17:18,080 --> 06:17:20,798
data here and trying to run we're going

9300
06:17:20,798 --> 06:17:23,280
to have a better visualization of that

9301
06:17:23,280 --> 06:17:25,200
so let's run a little bit we're going to

9302
06:17:25,200 --> 06:17:27,200
build the world is going to go through

9303
06:17:27,200 --> 06:17:29,360
and if we run this we're going to see

9304
06:17:29,360 --> 06:17:31,440
that data is going to show up to the

9305
06:17:31,440 --> 06:17:33,920
right gray is to the right woods is to

9306
06:17:33,920 --> 06:17:36,240
the right and this is the default

9307
06:17:36,240 --> 06:17:38,160
justification you get

9308
06:17:38,160 --> 06:17:40,878
when you set with like this you can also

9309
06:17:40,878 --> 06:17:43,680
cause for the data to be left justified

9310
06:17:43,680 --> 06:17:47,120
and you do that by coming here and

9311
06:17:47,120 --> 06:17:49,840
changing this to left you can do that

9312
06:17:49,840 --> 06:17:52,878
but let's keep this in here instead

9313
06:17:52,878 --> 06:17:55,120
for your reference and let's put in

9314
06:17:55,120 --> 06:17:57,120
another piece of code to justify the

9315
06:17:57,120 --> 06:18:00,160
data to the left okay let's go down and

9316
06:18:00,160 --> 06:18:02,558
do that we're going to justify the data

9317
06:18:02,558 --> 06:18:05,760
to the left and if we print this out the

9318
06:18:05,760 --> 06:18:08,320
data here gray should come to the left

9319
06:18:08,320 --> 06:18:10,798
and be aligned with the first name here

9320
06:18:10,798 --> 06:18:12,480
i hope this makes sense we're going to

9321
06:18:12,480 --> 06:18:16,160
run we build with gcc and if we run

9322
06:18:16,160 --> 06:18:19,760
rooster gray is going to be justified to

9323
06:18:19,760 --> 06:18:23,360
the left this is the meaning of std left

9324
06:18:23,360 --> 06:18:26,638
and std right that we just saw and know

9325
06:18:26,638 --> 06:18:29,280
that data is justified to the right by

9326
06:18:29,280 --> 06:18:31,840
default and it is important to keep the

9327
06:18:31,840 --> 06:18:33,680
defaults in your mind

9328
06:18:33,680 --> 06:18:35,920
data is going to be justified to the

9329
06:18:35,920 --> 06:18:38,480
right by default the next thing we can

9330
06:18:38,480 --> 06:18:41,440
do is to make our data internal

9331
06:18:41,440 --> 06:18:43,920
justified and what this is going to do

9332
06:18:43,920 --> 06:18:47,120
is make the sign left justified and the

9333
06:18:47,120 --> 06:18:50,000
data is going to be right justified and

9334
06:18:50,000 --> 06:18:52,000
the best way to save this is really to

9335
06:18:52,000 --> 06:18:53,520
see an example

9336
06:18:53,520 --> 06:18:55,920
so here we have the data it's a negative

9337
06:18:55,920 --> 06:18:58,638
floating point number the width is set

9338
06:18:58,638 --> 06:19:01,440
to 10 it's going to be right justified

9339
06:19:01,440 --> 06:19:03,760
but we are also going to set the

9340
06:19:03,760 --> 06:19:06,400
justification to internal and see the

9341
06:19:06,400 --> 06:19:07,440
difference

9342
06:19:07,440 --> 06:19:09,840
let's weld and run this we're going to

9343
06:19:09,840 --> 06:19:12,558
world with gcc and we are going to run

9344
06:19:12,558 --> 06:19:15,600
our rooster program and if we look at

9345
06:19:15,600 --> 06:19:18,798
the output here you see that if we have

9346
06:19:18,798 --> 06:19:20,798
right justification

9347
06:19:20,798 --> 06:19:23,680
the sign is going to go with the data

9348
06:19:23,680 --> 06:19:27,280
whereas if we do internal justification

9349
06:19:27,280 --> 06:19:29,040
the sign is going to go to the left and

9350
06:19:29,040 --> 06:19:31,680
the data is going to go to the right and

9351
06:19:31,680 --> 06:19:34,240
sometimes this is useful depending on

9352
06:19:34,240 --> 06:19:36,080
the application that you are welded

9353
06:19:36,080 --> 06:19:38,718
especially in applications where you

9354
06:19:38,718 --> 06:19:41,840
have to display tabular data on the

9355
06:19:41,840 --> 06:19:44,400
console or of the terminal we can also

9356
06:19:44,400 --> 06:19:47,280
specify the field character using set

9357
06:19:47,280 --> 06:19:48,320
field

9358
06:19:48,320 --> 06:19:50,958
and this is really how it works the data

9359
06:19:50,958 --> 06:19:53,360
is going to be left justified but we are

9360
06:19:53,360 --> 06:19:55,040
going to fill empty

9361
06:19:55,040 --> 06:19:58,878
spaces with a dash here and we can bring

9362
06:19:58,878 --> 06:20:01,120
this up so that you see the entire thing

9363
06:20:01,120 --> 06:20:02,798
but you don't really have to type this

9364
06:20:02,798 --> 06:20:05,360
out you can use the code i have provided

9365
06:20:05,360 --> 06:20:08,240
in the resources section of this lecture

9366
06:20:08,240 --> 06:20:10,638
you can just copy it paste it in here

9367
06:20:10,638 --> 06:20:12,798
and use it to play with these things

9368
06:20:12,798 --> 06:20:15,280
okay with this our empty spaces are

9369
06:20:15,280 --> 06:20:18,080
going to be filled with this dash

9370
06:20:18,080 --> 06:20:19,200
character

9371
06:20:19,200 --> 06:20:22,958
let's world and build with gcc we are

9372
06:20:22,958 --> 06:20:24,878
going to run this and you're going to

9373
06:20:24,878 --> 06:20:27,360
see that we have a field character here

9374
06:20:27,360 --> 06:20:29,200
and you can change this basically to

9375
06:20:29,200 --> 06:20:31,520
whatever you want if i want i can change

9376
06:20:31,520 --> 06:20:34,798
this to a star let's do that and i can

9377
06:20:34,798 --> 06:20:37,280
build again if i run this it's going to

9378
06:20:37,280 --> 06:20:39,360
be filled with stars right now the next

9379
06:20:39,360 --> 06:20:41,920
thing we're going to look at is std bull

9380
06:20:41,920 --> 06:20:44,958
alpha we have seen this before but what

9381
06:20:44,958 --> 06:20:46,958
it's really going to do is force the

9382
06:20:46,958 --> 06:20:49,680
output to be in the format of true and

9383
06:20:49,680 --> 06:20:50,558
false

9384
06:20:50,558 --> 06:20:52,958
and the default is in the form of one

9385
06:20:52,958 --> 06:20:56,478
and zero here we have a few variables

9386
06:20:56,478 --> 06:20:59,120
and that they are of bull type

9387
06:20:59,120 --> 06:21:02,478
the first set of stdcl statements here

9388
06:21:02,478 --> 06:21:04,400
is going to print in the format of one

9389
06:21:04,400 --> 06:21:07,360
and zero we are going to set the output

9390
06:21:07,360 --> 06:21:09,360
to both alpha and it is going to be in

9391
06:21:09,360 --> 06:21:12,320
the format of true and false and then we

9392
06:21:12,320 --> 06:21:14,958
can disable the bull alpha with this

9393
06:21:14,958 --> 06:21:18,400
setting here which says hdd no pull

9394
06:21:18,400 --> 06:21:21,760
alpha we can vote this and see the

9395
06:21:21,760 --> 06:21:24,320
effect of this so we're going to run

9396
06:21:24,320 --> 06:21:26,320
rooster again and you're going to see

9397
06:21:26,320 --> 06:21:29,440
that condition 1 0 condition true false

9398
06:21:29,440 --> 06:21:33,040
condition 1 0 we are able to modify how

9399
06:21:33,040 --> 06:21:36,080
our boolean data is displayed on the

9400
06:21:36,080 --> 06:21:39,280
console using these two settings here

9401
06:21:39,280 --> 06:21:41,760
use them if they make sense for your

9402
06:21:41,760 --> 06:21:43,440
application the next thing we're going

9403
06:21:43,440 --> 06:21:46,080
to look at is show pose and we're going

9404
06:21:46,080 --> 06:21:48,080
to just put in the data

9405
06:21:48,080 --> 06:21:50,558
we have two numbers positive number

9406
06:21:50,558 --> 06:21:52,718
which is 34 a negative number which is

9407
06:21:52,718 --> 06:21:56,240
minus 45 and we can decide if we want to

9408
06:21:56,240 --> 06:21:57,280
show

9409
06:21:57,280 --> 06:22:00,240
the plus sign for positive numbers by

9410
06:22:00,240 --> 06:22:02,400
default the plus sign is going to be

9411
06:22:02,400 --> 06:22:04,718
hidden it's not going to be shown if you

9412
06:22:04,718 --> 06:22:07,840
want it shown you can use the show pose

9413
06:22:07,840 --> 06:22:10,798
manipulator and if you want to disable

9414
06:22:10,798 --> 06:22:13,680
that when it was enabled you can use no

9415
06:22:13,680 --> 06:22:15,600
show pose and this is going to do what

9416
06:22:15,600 --> 06:22:19,040
you want we can build this again and if

9417
06:22:19,040 --> 06:22:20,958
we look at the output we're going to see

9418
06:22:20,958 --> 06:22:23,360
that post num doesn't have a plus sign

9419
06:22:23,360 --> 06:22:26,160
in front because by default the show

9420
06:22:26,160 --> 06:22:29,920
pause is disabled and we set the setting

9421
06:22:29,920 --> 06:22:31,920
here and we're going to see the plus

9422
06:22:31,920 --> 06:22:34,798
sign and if we disable that we're not

9423
06:22:34,798 --> 06:22:36,718
going to see the plus sign again this is

9424
06:22:36,718 --> 06:22:39,840
the effect of std show posts and std

9425
06:22:39,840 --> 06:22:42,878
neutral pose manipulators we can also

9426
06:22:42,878 --> 06:22:45,520
affect the base in which the data is

9427
06:22:45,520 --> 06:22:48,080
displayed on the terminal and we do this

9428
06:22:48,080 --> 06:22:51,280
by setting the output base system

9429
06:22:51,280 --> 06:22:55,440
we can set std deck to force the output

9430
06:22:55,440 --> 06:22:56,878
in decimal

9431
06:22:56,878 --> 06:22:59,360
std hex to force the output to be in

9432
06:22:59,360 --> 06:23:02,638
hexadecimal and std act to force the

9433
06:23:02,638 --> 06:23:06,798
output in octal and this is only to take

9434
06:23:06,798 --> 06:23:09,520
effect for integral types this is not

9435
06:23:09,520 --> 06:23:12,240
going to have effect for floating point

9436
06:23:12,240 --> 06:23:14,160
numbers for example here we have a few

9437
06:23:14,160 --> 06:23:16,240
variables a positive integer and

9438
06:23:16,240 --> 06:23:18,958
negative integer and a floating point

9439
06:23:18,958 --> 06:23:20,878
number which is the double

9440
06:23:20,878 --> 06:23:22,958
and we're going to try and print these

9441
06:23:22,958 --> 06:23:26,320
things in all these base systems we're

9442
06:23:26,320 --> 06:23:27,360
going to

9443
06:23:27,360 --> 06:23:29,440
print these things in the default format

9444
06:23:29,440 --> 06:23:31,280
we're going to see how they look we are

9445
06:23:31,280 --> 06:23:33,040
going to take the positive number and

9446
06:23:33,040 --> 06:23:36,000
show that in these different number

9447
06:23:36,000 --> 06:23:37,680
systems we're going to do the same for

9448
06:23:37,680 --> 06:23:39,600
the negative number and we're going to

9449
06:23:39,600 --> 06:23:40,798
show that

9450
06:23:40,798 --> 06:23:43,760
this doesn't have effect on floating

9451
06:23:43,760 --> 06:23:46,718
point numbers because these number

9452
06:23:46,718 --> 06:23:48,878
systems don't really work for floating

9453
06:23:48,878 --> 06:23:52,240
points we can run this and see the

9454
06:23:52,240 --> 06:23:54,798
output we are going to run the task that

9455
06:23:54,798 --> 06:23:57,360
is going to build with gcc and we're

9456
06:23:57,360 --> 06:24:00,240
going to clear and run rooster and what

9457
06:24:00,240 --> 06:24:03,040
we're going to see is that by default

9458
06:24:03,040 --> 06:24:04,798
positive number is going to be this

9459
06:24:04,798 --> 06:24:06,878
negative number is going to be this and

9460
06:24:06,878 --> 06:24:09,200
our double var is going to be this and

9461
06:24:09,200 --> 06:24:10,958
we are going to take the positive number

9462
06:24:10,958 --> 06:24:13,120
show it in different base systems in

9463
06:24:13,120 --> 06:24:15,200
decimal it's going to be like this in

9464
06:24:15,200 --> 06:24:18,000
hex it's going to be like this in act

9465
06:24:18,000 --> 06:24:20,638
it's going to be like this the negative

9466
06:24:20,638 --> 06:24:22,638
number is also going to be

9467
06:24:22,638 --> 06:24:25,120
in this format here so if we show it in

9468
06:24:25,120 --> 06:24:27,680
decimal it's going to be like this hex

9469
06:24:27,680 --> 06:24:29,920
it's going to be like this and octo it's

9470
06:24:29,920 --> 06:24:32,638
going to be like this you can see that

9471
06:24:32,638 --> 06:24:35,280
the double var which is a floating point

9472
06:24:35,280 --> 06:24:37,040
is not really affected it's going to be

9473
06:24:37,040 --> 06:24:39,840
showing in the same format regardless of

9474
06:24:39,840 --> 06:24:42,160
the base that we set here one thing you

9475
06:24:42,160 --> 06:24:44,798
should know is that this base setting

9476
06:24:44,798 --> 06:24:47,280
here is going to stick so here for

9477
06:24:47,280 --> 06:24:49,920
example you see that we have set output

9478
06:24:49,920 --> 06:24:51,200
to octo

9479
06:24:51,200 --> 06:24:53,280
so any other thing that we're going to

9480
06:24:53,280 --> 06:24:56,638
print out is going to be shown in octo

9481
06:24:56,638 --> 06:24:58,798
and we have to be sure that's what we

9482
06:24:58,798 --> 06:25:00,958
want if that's not what we want we will

9483
06:25:00,958 --> 06:25:02,400
have to reset

9484
06:25:02,400 --> 06:25:03,760
the output

9485
06:25:03,760 --> 06:25:06,000
number system and it's going to take

9486
06:25:06,000 --> 06:25:08,000
effect this is how you can use these

9487
06:25:08,000 --> 06:25:09,520
things to affect

9488
06:25:09,520 --> 06:25:12,160
different number systems for output in

9489
06:25:12,160 --> 06:25:14,878
your terminal we have seen that you can

9490
06:25:14,878 --> 06:25:17,040
also force things to show up in

9491
06:25:17,040 --> 06:25:19,520
uppercase if that's important for your

9492
06:25:19,520 --> 06:25:21,680
application for example here we have a

9493
06:25:21,680 --> 06:25:24,478
positive number if we show that in hex

9494
06:25:24,478 --> 06:25:26,000
this is going to contain a few

9495
06:25:26,000 --> 06:25:27,200
characters

9496
06:25:27,200 --> 06:25:30,478
and if we don't set uppercase

9497
06:25:30,478 --> 06:25:32,718
it is going to show up in lowercase and

9498
06:25:32,718 --> 06:25:34,878
if we want it in uppercase we can set

9499
06:25:34,878 --> 06:25:37,040
this setting and it is going to show up

9500
06:25:37,040 --> 06:25:40,080
in uppercase this may be helpful in some

9501
06:25:40,080 --> 06:25:42,320
applications and i just want you to be

9502
06:25:42,320 --> 06:25:44,718
aware of these things we're going to

9503
06:25:44,718 --> 06:25:48,638
world and run our application

9504
06:25:48,638 --> 06:25:50,240
we're going to see that

9505
06:25:50,240 --> 06:25:52,080
let's bring this up a little bit so that

9506
06:25:52,080 --> 06:25:55,520
we have some breathing room our positive

9507
06:25:55,520 --> 06:25:57,600
integer here is going to show up in

9508
06:25:57,600 --> 06:26:00,718
lowercase here in hex because this is

9509
06:26:00,718 --> 06:26:03,360
going to contain characters and if we

9510
06:26:03,360 --> 06:26:05,360
set uppercase you're going to see that

9511
06:26:05,360 --> 06:26:08,160
the characters are going to show up in

9512
06:26:08,160 --> 06:26:11,200
uppercase and this is the effect of this

9513
06:26:11,200 --> 06:26:13,680
setting here we can also affect how

9514
06:26:13,680 --> 06:26:15,600
floating point data

9515
06:26:15,600 --> 06:26:19,040
is printed out on the terminal

9516
06:26:19,040 --> 06:26:21,600
for example here we have a few variables

9517
06:26:21,600 --> 06:26:23,280
a b and c

9518
06:26:23,280 --> 06:26:25,760
and by default they are going to show up

9519
06:26:25,760 --> 06:26:28,558
with decimal points and use scientific

9520
06:26:28,558 --> 06:26:31,760
notation where necessary but we can

9521
06:26:31,760 --> 06:26:33,440
choose to use

9522
06:26:33,440 --> 06:26:35,920
fixed for example if that's what we need

9523
06:26:35,920 --> 06:26:39,040
in our application and the output is

9524
06:26:39,040 --> 06:26:41,680
going to be shown using fixed notation

9525
06:26:41,680 --> 06:26:44,080
with decimal points if we want we can

9526
06:26:44,080 --> 06:26:46,478
force the scientific format and we do it

9527
06:26:46,478 --> 06:26:49,440
like this and all output is going to be

9528
06:26:49,440 --> 06:26:52,320
in scientific format and we can disable

9529
06:26:52,320 --> 06:26:54,798
all these settings and reset this to the

9530
06:26:54,798 --> 06:26:56,080
defaults

9531
06:26:56,080 --> 06:26:59,440
with this piece of command here there is

9532
06:26:59,440 --> 06:27:01,440
no official way to

9533
06:27:01,440 --> 06:27:04,558
set floating point output to the

9534
06:27:04,558 --> 06:27:07,600
defaults and this is a hack i actually

9535
06:27:07,600 --> 06:27:09,760
learned about when i was preparing the

9536
06:27:09,760 --> 06:27:12,558
code for this course and the proper

9537
06:27:12,558 --> 06:27:15,280
explanations for this are really out of

9538
06:27:15,280 --> 06:27:17,760
scope for this course so if you want to

9539
06:27:17,760 --> 06:27:20,718
reset the floating point output format

9540
06:27:20,718 --> 06:27:23,600
to the default you're going to use this

9541
06:27:23,600 --> 06:27:25,840
but we don't really have enough tools to

9542
06:27:25,840 --> 06:27:29,200
understand this yet so just take it by

9543
06:27:29,200 --> 06:27:31,520
faith and you're going to see that if we

9544
06:27:31,520 --> 06:27:33,600
run this it's going to work let's try

9545
06:27:33,600 --> 06:27:36,320
and run this through the compiler and

9546
06:27:36,320 --> 06:27:38,400
that the world is going to go through if

9547
06:27:38,400 --> 06:27:40,638
we run this and i bring this up a little

9548
06:27:40,638 --> 06:27:43,120
bit so that we have a little bit of

9549
06:27:43,120 --> 06:27:45,040
breathing room we're going to see that

9550
06:27:45,040 --> 06:27:48,478
our double values are a b and c and

9551
06:27:48,478 --> 06:27:51,440
that's what we have in our code here and

9552
06:27:51,440 --> 06:27:53,200
by default it's not going to be able to

9553
06:27:53,200 --> 06:27:55,200
show these things because of the

9554
06:27:55,200 --> 06:27:57,920
precision limits so we're going to have

9555
06:27:57,920 --> 06:28:00,320
3.14159

9556
06:28:00,320 --> 06:28:02,478
it's going to go up to here and the rest

9557
06:28:02,478 --> 06:28:04,878
is going to be chopped off if we use

9558
06:28:04,878 --> 06:28:07,120
fixed formats you're going to see that

9559
06:28:07,120 --> 06:28:10,240
whatever we had in scientific format

9560
06:28:10,240 --> 06:28:13,200
it's going to show up in fixed format

9561
06:28:13,200 --> 06:28:15,600
and again this is a really low number

9562
06:28:15,600 --> 06:28:18,478
that's why we have 0.000

9563
06:28:18,478 --> 06:28:19,440
here

9564
06:28:19,440 --> 06:28:22,160
we can force the output to be scientific

9565
06:28:22,160 --> 06:28:23,840
as we did

9566
06:28:23,840 --> 06:28:25,360
right here

9567
06:28:25,360 --> 06:28:27,680
and all output is going to be in

9568
06:28:27,680 --> 06:28:29,440
scientific format

9569
06:28:29,440 --> 06:28:32,080
down below here we use our hack to set

9570
06:28:32,080 --> 06:28:33,120
to

9571
06:28:33,120 --> 06:28:35,760
the defaults and you see that it's going

9572
06:28:35,760 --> 06:28:39,040
to go back to the initial format that we

9573
06:28:39,040 --> 06:28:42,558
had before this is how you use std fixed

9574
06:28:42,558 --> 06:28:44,878
and std scientific

9575
06:28:44,878 --> 06:28:45,680
to

9576
06:28:45,680 --> 06:28:48,080
manipulate how your floating point

9577
06:28:48,080 --> 06:28:51,280
numbers are printed to the terminal we

9578
06:28:51,280 --> 06:28:53,600
have also seen that we can set the

9579
06:28:53,600 --> 06:28:57,680
precision of our output in the terminal

9580
06:28:57,680 --> 06:29:00,400
here we have a variable a it is of type

9581
06:29:00,400 --> 06:29:02,958
double as you can see in a visual studio

9582
06:29:02,958 --> 06:29:05,120
code here if you hover over a variable

9583
06:29:05,120 --> 06:29:07,360
you're going to be able to see its type

9584
06:29:07,360 --> 06:29:09,680
we can choose to see this in whatever

9585
06:29:09,680 --> 06:29:12,638
precision we want 6 is the default in

9586
06:29:12,638 --> 06:29:15,680
our case here but we can choose to set

9587
06:29:15,680 --> 06:29:18,958
the precision to 10 20 or whatever it is

9588
06:29:18,958 --> 06:29:20,798
really we want

9589
06:29:20,798 --> 06:29:22,638
please note that this is going to be

9590
06:29:22,638 --> 06:29:24,878
limited by the precision that your type

9591
06:29:24,878 --> 06:29:27,280
supports so for example we know that a

9592
06:29:27,280 --> 06:29:30,558
double has a precision of 15 and if we

9593
06:29:30,558 --> 06:29:33,440
have more than 15 digits in here the

9594
06:29:33,440 --> 06:29:35,760
rest is going to be garbage just be

9595
06:29:35,760 --> 06:29:38,000
aware of that we're going to try and

9596
06:29:38,000 --> 06:29:40,878
build this and we're going to use gcc as

9597
06:29:40,878 --> 06:29:44,320
usual and if we run this

9598
06:29:44,320 --> 06:29:46,160
we're going to get our numbers in

9599
06:29:46,160 --> 06:29:48,320
different precisions the first one is

9600
06:29:48,320 --> 06:29:50,400
using the default which is going to be

9601
06:29:50,400 --> 06:29:51,360
6.

9602
06:29:51,360 --> 06:29:53,120
if we use 10 we're going to get 10

9603
06:29:53,120 --> 06:29:54,958
digits if we use 20 we're going to get

9604
06:29:54,958 --> 06:29:57,760
20 digits but if we go over the

9605
06:29:57,760 --> 06:30:00,638
precision that our type here supports

9606
06:30:00,638 --> 06:30:02,958
we're going to get garbage i hope this

9607
06:30:02,958 --> 06:30:04,958
makes sense the last thing we're going

9608
06:30:04,958 --> 06:30:07,840
to see is show point and we have seen

9609
06:30:07,840 --> 06:30:08,718
that

9610
06:30:08,718 --> 06:30:11,200
this is used to force

9611
06:30:11,200 --> 06:30:13,680
outputting the decimal point let's say

9612
06:30:13,680 --> 06:30:16,798
that here and a good example for that is

9613
06:30:16,798 --> 06:30:18,320
this 12 here

9614
06:30:18,320 --> 06:30:19,840
if we print it out

9615
06:30:19,840 --> 06:30:22,798
here we're not going to get the decimal

9616
06:30:22,798 --> 06:30:25,840
point by default it's going to print 12

9617
06:30:25,840 --> 06:30:28,958
but if we go down and force output of

9618
06:30:28,958 --> 06:30:31,200
the decimal point here we're going to

9619
06:30:31,200 --> 06:30:34,718
get something like 12.0

9620
06:30:34,718 --> 06:30:37,360
and another effect of this is that it's

9621
06:30:37,360 --> 06:30:40,558
going to add trailing zeros to fill

9622
06:30:40,558 --> 06:30:43,120
whatever space is allocated for your

9623
06:30:43,120 --> 06:30:45,920
output variable in the terminal

9624
06:30:45,920 --> 06:30:48,160
let's try and run this so that we can

9625
06:30:48,160 --> 06:30:50,400
actually see this running we're going to

9626
06:30:50,400 --> 06:30:54,240
run our rooster executable and in the

9627
06:30:54,240 --> 06:30:56,958
first group here we don't have the

9628
06:30:56,958 --> 06:30:59,760
setting for show point and if you look

9629
06:30:59,760 --> 06:31:02,478
at the numbers that we had in our code

9630
06:31:02,478 --> 06:31:05,360
the first number is 34.1 and you see

9631
06:31:05,360 --> 06:31:07,440
that we are padding a lot of numbers

9632
06:31:07,440 --> 06:31:10,400
because we had set our precision to a

9633
06:31:10,400 --> 06:31:13,040
really big number in the last example

9634
06:31:13,040 --> 06:31:15,440
that we have run let's actually go there

9635
06:31:15,440 --> 06:31:16,798
and show you that that's why we're

9636
06:31:16,798 --> 06:31:19,040
seeing the precision of 20

9637
06:31:19,040 --> 06:31:21,680
it is really huge but no big deal we can

9638
06:31:21,680 --> 06:31:24,080
reset this to whatever we want if this

9639
06:31:24,080 --> 06:31:26,240
is too much for us

9640
06:31:26,240 --> 06:31:29,798
the important thing here is that we have

9641
06:31:29,798 --> 06:31:32,958
34.1 and that's what we are seeing and

9642
06:31:32,958 --> 06:31:36,520
if you go to our 12 here you see we have

9643
06:31:36,520 --> 06:31:40,958
12.0 but our output is not showing

9644
06:31:40,958 --> 06:31:43,280
the decimal point here if it is

9645
06:31:43,280 --> 06:31:45,280
important to show the decimal point we

9646
06:31:45,280 --> 06:31:48,638
can do std show point here and it is

9647
06:31:48,638 --> 06:31:50,718
going to show up this is really what is

9648
06:31:50,718 --> 06:31:53,440
important in this piece of code here and

9649
06:31:53,440 --> 06:31:54,878
this is really all we set out to do in

9650
06:31:54,878 --> 06:31:56,638
this lecture we had a chance to play

9651
06:31:56,638 --> 06:31:59,520
with a lot of these manipulators and the

9652
06:31:59,520 --> 06:32:01,280
best way to learn about these things is

9653
06:32:01,280 --> 06:32:04,160
really to try them out in code

9654
06:32:04,160 --> 06:32:06,320
and try to change a few things and see

9655
06:32:06,320 --> 06:32:09,520
how that affects the output you get in

9656
06:32:09,520 --> 06:32:11,920
the terminal and we had a chance to play

9657
06:32:11,920 --> 06:32:14,160
with many of these things in this

9658
06:32:14,160 --> 06:32:17,040
lecture there is a lot of these guys i

9659
06:32:17,040 --> 06:32:19,920
tried to make this lecture as extensive

9660
06:32:19,920 --> 06:32:22,878
as i can that's why it turned out to be

9661
06:32:22,878 --> 06:32:24,958
pretty long but once you've learned

9662
06:32:24,958 --> 06:32:27,120
about these fans and played with them in

9663
06:32:27,120 --> 06:32:29,680
code you're never going to forget them

9664
06:32:29,680 --> 06:32:32,718
one last point i want to emphasize again

9665
06:32:32,718 --> 06:32:36,320
is that the documentation is of utmost

9666
06:32:36,320 --> 06:32:39,040
importance it is really good to come

9667
06:32:39,040 --> 06:32:41,280
here and check things out for example if

9668
06:32:41,280 --> 06:32:43,760
we go to show point here we are going to

9669
06:32:43,760 --> 06:32:46,240
get a nice explanation of what this

9670
06:32:46,240 --> 06:32:48,958
manipulator does enables all disables

9671
06:32:48,958 --> 06:32:50,958
the unconditional inclusion of the

9672
06:32:50,958 --> 06:32:53,280
decimal point character and you can read

9673
06:32:53,280 --> 06:32:54,320
all this

9674
06:32:54,320 --> 06:32:56,558
and the nice thing is that if you go

9675
06:32:56,558 --> 06:32:58,638
down you're going to have a piece of

9676
06:32:58,638 --> 06:32:59,520
code

9677
06:32:59,520 --> 06:33:01,360
that you can use to really understand

9678
06:33:01,360 --> 06:33:03,520
whatever it is they are talking about

9679
06:33:03,520 --> 06:33:05,760
and this is priceless if you are

9680
06:33:05,760 --> 06:33:08,000
learning it is a good thing to be able

9681
06:33:08,000 --> 06:33:10,958
to use the documentation this is really

9682
06:33:10,958 --> 06:33:13,600
all we set out to do in this lecture it

9683
06:33:13,600 --> 06:33:16,320
turned out to be really long but i

9684
06:33:16,320 --> 06:33:18,400
really hope it was worth it for you

9685
06:33:18,400 --> 06:33:20,320
we're going to stop here in this lecture

9686
06:33:20,320 --> 06:33:21,520
in the next one we're going to learn

9687
06:33:21,520 --> 06:33:24,718
about numeric limits go ahead and finish

9688
06:33:24,718 --> 06:33:27,200
up here and meet me there in this

9689
06:33:27,200 --> 06:33:29,200
lecture we're going to be playing with a

9690
06:33:29,200 --> 06:33:31,920
few functions from this library

9691
06:33:31,920 --> 06:33:33,680
specifically we're going to be looking

9692
06:33:33,680 --> 06:33:36,240
at the minimum the maximum and the

9693
06:33:36,240 --> 06:33:38,000
lowest functions

9694
06:33:38,000 --> 06:33:40,400
and this is really how you use them you

9695
06:33:40,400 --> 06:33:43,520
can think of this t as a placeholder for

9696
06:33:43,520 --> 06:33:46,080
the type for which you want to know the

9697
06:33:46,080 --> 06:33:48,958
minimum the maximum and the lowest point

9698
06:33:48,958 --> 06:33:51,200
respectively i know this might be

9699
06:33:51,200 --> 06:33:53,440
cryptic to some of you so we're going to

9700
06:33:53,440 --> 06:33:56,320
look at a few specific examples here we

9701
06:33:56,320 --> 06:33:58,878
have a simple explanation of what these

9702
06:33:58,878 --> 06:34:00,558
functions mean

9703
06:34:00,558 --> 06:34:02,878
for floating point values

9704
06:34:02,878 --> 06:34:05,440
the minimum is going to represent the

9705
06:34:05,440 --> 06:34:07,760
smallest positive number

9706
06:34:07,760 --> 06:34:10,478
that is representable with that floating

9707
06:34:10,478 --> 06:34:12,638
point type the maximum is going to be

9708
06:34:12,638 --> 06:34:14,478
the maximum floating point number you

9709
06:34:14,478 --> 06:34:17,280
can represent and at the lowest number

9710
06:34:17,280 --> 06:34:20,080
is going to be the lowest negative

9711
06:34:20,080 --> 06:34:22,718
number you can represent with that type

9712
06:34:22,718 --> 06:34:24,240
things change a little bit when you

9713
06:34:24,240 --> 06:34:27,200
start dealing with integers and these

9714
06:34:27,200 --> 06:34:29,120
functions are going to look like this

9715
06:34:29,120 --> 06:34:31,280
the minimum is going to be the minimum

9716
06:34:31,280 --> 06:34:32,878
number you can represent with that

9717
06:34:32,878 --> 06:34:35,680
integer and lowest doesn't really mean

9718
06:34:35,680 --> 06:34:38,958
anything for integral types the maximum

9719
06:34:38,958 --> 06:34:41,040
is going to be the maximum number one

9720
06:34:41,040 --> 06:34:42,958
thing you have to keep in mind is that

9721
06:34:42,958 --> 06:34:45,520
the minimum may be negative

9722
06:34:45,520 --> 06:34:49,200
if you are using a signed integer if you

9723
06:34:49,200 --> 06:34:51,280
are using an unsigned integer for

9724
06:34:51,280 --> 06:34:53,760
example for short minimum is going to be

9725
06:34:53,760 --> 06:34:56,160
zero and the maximum is going to be the

9726
06:34:56,160 --> 06:34:59,280
maximum number representable with that

9727
06:34:59,280 --> 06:35:01,840
integer type here we are looking at

9728
06:35:01,840 --> 06:35:04,878
numbers for short and but the same story

9729
06:35:04,878 --> 06:35:07,760
applies to whatever integer type you are

9730
06:35:07,760 --> 06:35:10,000
using even if you happen to be using

9731
06:35:10,000 --> 06:35:13,600
long end or end without any modifier

9732
06:35:13,600 --> 06:35:15,680
remember that we had to do a lot of

9733
06:35:15,680 --> 06:35:19,440
things to get this range and it was

9734
06:35:19,440 --> 06:35:22,080
really hard to even do this for floating

9735
06:35:22,080 --> 06:35:26,400
point types so this library is helpful

9736
06:35:26,400 --> 06:35:28,240
in getting a sense of what we can

9737
06:35:28,240 --> 06:35:30,718
represent with the given type b8

9738
06:35:30,718 --> 06:35:33,440
floating point or integral let's head to

9739
06:35:33,440 --> 06:35:35,840
visual studio code and play with us here

9740
06:35:35,840 --> 06:35:38,878
we are in our working folder

9741
06:35:38,878 --> 06:35:40,798
we are going to copy code from our

9742
06:35:40,798 --> 06:35:42,638
template project

9743
06:35:42,638 --> 06:35:44,718
and we are going to go in the current

9744
06:35:44,718 --> 06:35:46,718
project which is numeric limits we're

9745
06:35:46,718 --> 06:35:49,520
going to go and put in our files

9746
06:35:49,520 --> 06:35:52,718
go up again and open this file up in

9747
06:35:52,718 --> 06:35:54,558
visual studio code we're going to close

9748
06:35:54,558 --> 06:35:57,440
this up open the main cpp file remove

9749
06:35:57,440 --> 06:35:59,840
whatever it is we don't need we are

9750
06:35:59,840 --> 06:36:02,240
going to include the limits library

9751
06:36:02,240 --> 06:36:04,000
remember this is the first thing we need

9752
06:36:04,000 --> 06:36:05,120
to do

9753
06:36:05,120 --> 06:36:09,040
if we want to play with these facilities

9754
06:36:09,040 --> 06:36:11,440
that we just looked at in the slides

9755
06:36:11,440 --> 06:36:13,760
and we are going to go down here and put

9756
06:36:13,760 --> 06:36:16,558
in the code we want to play with

9757
06:36:16,558 --> 06:36:19,280
and it is ridiculously simple

9758
06:36:19,280 --> 06:36:21,440
if you have watched the slides we just

9759
06:36:21,440 --> 06:36:23,680
did in a minute so what we're going to

9760
06:36:23,680 --> 06:36:25,360
be doing here we're going to be printing

9761
06:36:25,360 --> 06:36:28,000
out the range for each possible type we

9762
06:36:28,000 --> 06:36:30,160
want to play with here so we're going to

9763
06:36:30,160 --> 06:36:33,520
say the range for short and is from

9764
06:36:33,520 --> 06:36:35,920
and we're going to say std numeric

9765
06:36:35,920 --> 06:36:37,040
limits

9766
06:36:37,040 --> 06:36:39,520
short that's what we want to deal with

9767
06:36:39,520 --> 06:36:42,000
now and we're going to call the minimum

9768
06:36:42,000 --> 06:36:44,320
function this is going to give us

9769
06:36:44,320 --> 06:36:46,718
the minimum value we can represent with

9770
06:36:46,718 --> 06:36:49,520
short and we're going to say std numeric

9771
06:36:49,520 --> 06:36:51,200
limits and we're going to call the max

9772
06:36:51,200 --> 06:36:52,160
function

9773
06:36:52,160 --> 06:36:55,120
passing in the type for which we want to

9774
06:36:55,120 --> 06:36:56,798
get the range for

9775
06:36:56,798 --> 06:37:00,718
and the same story applies for

9776
06:37:00,718 --> 06:37:02,478
unsigned

9777
06:37:02,478 --> 06:37:03,840
short

9778
06:37:03,840 --> 06:37:05,680
you see that's the type we are using

9779
06:37:05,680 --> 06:37:08,798
here we are also going to play with ant

9780
06:37:08,798 --> 06:37:10,958
getting the range we're going to use

9781
06:37:10,958 --> 06:37:12,478
unsigned and

9782
06:37:12,478 --> 06:37:14,878
to see how these things behave we're

9783
06:37:14,878 --> 06:37:16,400
going to use long

9784
06:37:16,400 --> 06:37:18,798
and get to the range and we are also

9785
06:37:18,798 --> 06:37:21,840
going to be playing with floating point

9786
06:37:21,840 --> 06:37:24,080
types so we're going to compute the

9787
06:37:24,080 --> 06:37:26,878
range using the minimum function and the

9788
06:37:26,878 --> 06:37:29,440
maximum function and we are going to be

9789
06:37:29,440 --> 06:37:32,478
also using the lowest function to see

9790
06:37:32,478 --> 06:37:35,280
that this really is the same thing we

9791
06:37:35,280 --> 06:37:37,760
described in the slides we're going to

9792
06:37:37,760 --> 06:37:40,080
do this for double and long double and

9793
06:37:40,080 --> 06:37:41,840
see how these ranges

9794
06:37:41,840 --> 06:37:44,000
come up in this program what we're going

9795
06:37:44,000 --> 06:37:47,040
to do is open up a terminal here we are

9796
06:37:47,040 --> 06:37:50,240
going to run the task to build with gcc

9797
06:37:50,240 --> 06:37:52,638
and the build is going to be good

9798
06:37:52,638 --> 06:37:56,320
and we can go down and run rooster and

9799
06:37:56,320 --> 06:37:57,920
we're going to get our values here the

9800
06:37:57,920 --> 06:38:02,638
range for short and is from minus 32 768

9801
06:38:02,638 --> 06:38:04,120
up to 32

9802
06:38:04,120 --> 06:38:07,280
767 and you see that this is exactly the

9803
06:38:07,280 --> 06:38:09,440
same thing we saw in the lecture where

9804
06:38:09,440 --> 06:38:11,760
we talked about number systems we saw a

9805
06:38:11,760 --> 06:38:14,320
way you can do this manually by plugging

9806
06:38:14,320 --> 06:38:15,360
the

9807
06:38:15,360 --> 06:38:18,000
number of digits in some formula that we

9808
06:38:18,000 --> 06:38:20,160
came up you can go back and check that

9809
06:38:20,160 --> 06:38:22,320
out if you want we do the same for

9810
06:38:22,320 --> 06:38:25,040
unsigned short and and then we look at

9811
06:38:25,040 --> 06:38:27,280
floating point types we're going to

9812
06:38:27,280 --> 06:38:29,760
print the range for float

9813
06:38:29,760 --> 06:38:32,000
and if we use the

9814
06:38:32,000 --> 06:38:34,798
minimum function to get the start of the

9815
06:38:34,798 --> 06:38:37,600
range we're going to get the minimum

9816
06:38:37,600 --> 06:38:40,478
positive number we can represent with a

9817
06:38:40,478 --> 06:38:42,718
float if we use lowest we're going to

9818
06:38:42,718 --> 06:38:45,440
get the lowest minimum number and that

9819
06:38:45,440 --> 06:38:47,760
the maximum is going to be the same if

9820
06:38:47,760 --> 06:38:50,000
you think this is really small you have

9821
06:38:50,000 --> 06:38:52,638
the option to open up this folder in

9822
06:38:52,638 --> 06:38:56,478
file explorer and you can open a command

9823
06:38:56,478 --> 06:38:58,958
prompt or powershell window by hitting

9824
06:38:58,958 --> 06:39:01,520
shift and right clicking and choosing

9825
06:39:01,520 --> 06:39:04,320
this option here open powershell window

9826
06:39:04,320 --> 06:39:05,120
here

9827
06:39:05,120 --> 06:39:07,040
and you're going to get a bigger window

9828
06:39:07,040 --> 06:39:08,718
in which you can type things we're going

9829
06:39:08,718 --> 06:39:10,638
to run rooster and we're going to see

9830
06:39:10,638 --> 06:39:13,600
things in a much easier way here

9831
06:39:13,600 --> 06:39:15,920
this is an option you can use or you can

9832
06:39:15,920 --> 06:39:19,440
even use the integrated terminal inside

9833
06:39:19,440 --> 06:39:21,920
visual studio code here like we've been

9834
06:39:21,920 --> 06:39:24,320
doing all along there are a few other

9835
06:39:24,320 --> 06:39:27,360
facilities you can use in this library

9836
06:39:27,360 --> 06:39:32,240
of limits for example we can try and

9837
06:39:32,240 --> 06:39:34,798
print out if a number is signed or

9838
06:39:34,798 --> 06:39:37,680
unsigned or get the number of digits we

9839
06:39:37,680 --> 06:39:40,638
can represent in an integer type

9840
06:39:40,638 --> 06:39:42,878
these are a few examples i just chose

9841
06:39:42,878 --> 06:39:44,878
because they are easy to understand and

9842
06:39:44,878 --> 06:39:47,280
really helpful but you can find more

9843
06:39:47,280 --> 06:39:49,360
about this library

9844
06:39:49,360 --> 06:39:51,120
in the documentation

9845
06:39:51,120 --> 06:39:54,000
and if you come here at cppreference.com

9846
06:39:54,000 --> 06:39:56,558
the link is here you can really find all

9847
06:39:56,558 --> 06:39:59,040
about this library here this library

9848
06:39:59,040 --> 06:40:01,200
provides a standardized way to carry

9849
06:40:01,200 --> 06:40:04,000
various properties of arithmetic types

9850
06:40:04,000 --> 06:40:06,160
for example the largest possible value

9851
06:40:06,160 --> 06:40:08,878
of type and is this

9852
06:40:08,878 --> 06:40:10,638
and we have a bunch of things we can do

9853
06:40:10,638 --> 06:40:13,680
here don't be scared of by this template

9854
06:40:13,680 --> 06:40:14,558
thing

9855
06:40:14,558 --> 06:40:18,000
just think of them as placeholders for

9856
06:40:18,000 --> 06:40:19,920
the type for which you are trying to

9857
06:40:19,920 --> 06:40:22,478
query information for there are a few

9858
06:40:22,478 --> 06:40:24,718
functions you can call on these things

9859
06:40:24,718 --> 06:40:27,840
for example there is mean lowest max

9860
06:40:27,840 --> 06:40:29,840
that we just played with in visual

9861
06:40:29,840 --> 06:40:32,558
studio code but uh you can see that

9862
06:40:32,558 --> 06:40:34,638
there are a lot of things you can play

9863
06:40:34,638 --> 06:40:36,798
with especially if you have some math

9864
06:40:36,798 --> 06:40:38,958
background to understand all these

9865
06:40:38,958 --> 06:40:41,440
concepts here you can play with us and

9866
06:40:41,440 --> 06:40:44,160
see if it is helpful for whatever

9867
06:40:44,160 --> 06:40:46,160
application you are doing okay this is

9868
06:40:46,160 --> 06:40:47,520
really all we set out to do in this

9869
06:40:47,520 --> 06:40:49,920
lecture to learn a little bit about the

9870
06:40:49,920 --> 06:40:53,120
limits library it is helpful in

9871
06:40:53,120 --> 06:40:55,360
trying to understand the ranges for your

9872
06:40:55,360 --> 06:40:57,280
types if you happen to need these kinds

9873
06:40:57,280 --> 06:40:59,840
of things this is going to come in handy

9874
06:40:59,840 --> 06:41:01,680
we're going to stop here in this lecture

9875
06:41:01,680 --> 06:41:03,040
in the next one we're going to learn

9876
06:41:03,040 --> 06:41:06,240
about some math functions we can use in

9877
06:41:06,240 --> 06:41:09,680
c plus plus go ahead and finish up here

9878
06:41:09,680 --> 06:41:11,760
and meet me there in this lecture we're

9879
06:41:11,760 --> 06:41:14,400
going to learn about math functions and

9880
06:41:14,400 --> 06:41:16,718
these are functions that are built into

9881
06:41:16,718 --> 06:41:19,600
the z plus plus standard library that we

9882
06:41:19,600 --> 06:41:22,160
can use to do some math if you are doing

9883
06:41:22,160 --> 06:41:24,160
some math operations you're going to

9884
06:41:24,160 --> 06:41:25,760
find this helpful

9885
06:41:25,760 --> 06:41:30,000
they live in the c math library and if

9886
06:41:30,000 --> 06:41:31,440
you want to use them you're just going

9887
06:41:31,440 --> 06:41:33,280
to include that and you're going to have

9888
06:41:33,280 --> 06:41:35,360
access to them what you see here is a

9889
06:41:35,360 --> 06:41:37,760
simple summary of some of the things you

9890
06:41:37,760 --> 06:41:40,878
can use in these math functions you can

9891
06:41:40,878 --> 06:41:45,360
use std flower to round down or hdd seal

9892
06:41:45,360 --> 06:41:46,080
to

9893
06:41:46,080 --> 06:41:49,440
round up you can use the abs function to

9894
06:41:49,440 --> 06:41:51,840
compute the absolute value of a number

9895
06:41:51,840 --> 06:41:54,718
you can do trigonometry you can do the

9896
06:41:54,718 --> 06:41:57,920
cosine sign and things like that you can

9897
06:41:57,920 --> 06:42:00,080
compute the exponential of a number

9898
06:42:00,080 --> 06:42:01,760
you're going to see what this means in a

9899
06:42:01,760 --> 06:42:04,798
few lectures you can use std log and

9900
06:42:04,798 --> 06:42:07,200
again if you have some math background

9901
06:42:07,200 --> 06:42:09,200
these concepts are not going to be

9902
06:42:09,200 --> 06:42:11,440
foreign to you many of these functions

9903
06:42:11,440 --> 06:42:14,240
are documented here at cpp reference so

9904
06:42:14,240 --> 06:42:17,040
it might be worthwhile to go there and

9905
06:42:17,040 --> 06:42:19,440
check what functions are available there

9906
06:42:19,440 --> 06:42:21,280
here is an example of something you

9907
06:42:21,280 --> 06:42:23,520
might want to do for example you have a

9908
06:42:23,520 --> 06:42:25,920
variable it's called weight inside we

9909
06:42:25,920 --> 06:42:30,558
have a 7.7 and if you do std floor of

9910
06:42:30,558 --> 06:42:32,240
this variable this is going to be

9911
06:42:32,240 --> 06:42:35,200
rounded down to a 7. if you want to

9912
06:42:35,200 --> 06:42:37,680
round up you're going to use std seal

9913
06:42:37,680 --> 06:42:39,360
and you're going to get that and we're

9914
06:42:39,360 --> 06:42:41,280
going to see what this is going to give

9915
06:42:41,280 --> 06:42:44,160
us in a minute when we hit visual studio

9916
06:42:44,160 --> 06:42:46,400
code here is how you would use the

9917
06:42:46,400 --> 06:42:48,718
absolute value function you have a few

9918
06:42:48,718 --> 06:42:52,080
variables here and if you try to plug

9919
06:42:52,080 --> 06:42:54,798
them in this absolute value function

9920
06:42:54,798 --> 06:42:56,638
you're basically going to get the weight

9921
06:42:56,638 --> 06:43:00,320
of the number without any sign in front

9922
06:43:00,320 --> 06:43:02,878
of the number positive or negative the

9923
06:43:02,878 --> 06:43:04,798
absolute value is the weight of the

9924
06:43:04,798 --> 06:43:07,760
number without caring about the sign if

9925
06:43:07,760 --> 06:43:10,320
i may say it like that okay we also have

9926
06:43:10,320 --> 06:43:12,718
the x function which is going to compute

9927
06:43:12,718 --> 06:43:15,520
the exponential of a number this is a

9928
06:43:15,520 --> 06:43:17,520
math concept so if you don't have a

9929
06:43:17,520 --> 06:43:19,760
background in math this is going to be a

9930
06:43:19,760 --> 06:43:22,000
little hard to wrap your brains around

9931
06:43:22,000 --> 06:43:24,240
but in math we have this number which is

9932
06:43:24,240 --> 06:43:25,520
called e

9933
06:43:25,520 --> 06:43:30,478
and its value is approximately 2.7 18 28

9934
06:43:30,478 --> 06:43:32,558
like you see here the exponential

9935
06:43:32,558 --> 06:43:35,440
function is going to do what f x here is

9936
06:43:35,440 --> 06:43:38,400
doing it's going to take e and elevate

9937
06:43:38,400 --> 06:43:41,760
that to the power of x and for example

9938
06:43:41,760 --> 06:43:44,080
in our code here we're going to get the

9939
06:43:44,080 --> 06:43:46,878
exponential of 10 which is going to be e

9940
06:43:46,878 --> 06:43:49,680
elevated to the power of tan and we're

9941
06:43:49,680 --> 06:43:51,680
going to play with this in visual studio

9942
06:43:51,680 --> 06:43:53,200
code and you're going to see the value

9943
06:43:53,200 --> 06:43:55,680
of this we also have the power function

9944
06:43:55,680 --> 06:43:57,360
here which is going to take the first

9945
06:43:57,360 --> 06:43:59,840
parameter and elevate that to the power

9946
06:43:59,840 --> 06:44:01,680
of the second parameter

9947
06:44:01,680 --> 06:44:02,878
so

9948
06:44:02,878 --> 06:44:05,440
this is going to be 3 to the power of 4

9949
06:44:05,440 --> 06:44:08,080
and 9 to the power of 3 and we're going

9950
06:44:08,080 --> 06:44:10,400
to get the answer if we plug this into

9951
06:44:10,400 --> 06:44:13,520
visual studio code and we have look

9952
06:44:13,520 --> 06:44:16,080
functions which is basically the reverse

9953
06:44:16,080 --> 06:44:18,718
of the power function that we just

9954
06:44:18,718 --> 06:44:20,080
looked at

9955
06:44:20,080 --> 06:44:24,478
if you do log 8 in base 2 for example

9956
06:44:24,478 --> 06:44:27,360
it is like you are asking to which power

9957
06:44:27,360 --> 06:44:29,920
should i elevate 2

9958
06:44:29,920 --> 06:44:31,920
so that i get 8.

9959
06:44:31,920 --> 06:44:33,840
and the answer here is going to be a 3

9960
06:44:33,840 --> 06:44:36,478
of course but the catch is that the log

9961
06:44:36,478 --> 06:44:39,920
function by default works in base e

9962
06:44:39,920 --> 06:44:42,478
so what we are asking for example if we

9963
06:44:42,478 --> 06:44:46,200
say log 54.59

9964
06:44:46,400 --> 06:44:49,920
is to which power should we elevate e

9965
06:44:49,920 --> 06:44:52,638
to get this number in here and it is

9966
06:44:52,638 --> 06:44:54,240
going to be computed and you're going to

9967
06:44:54,240 --> 06:44:56,878
see this if you plug this into

9968
06:44:56,878 --> 06:44:59,280
visual studio code or you can try to use

9969
06:44:59,280 --> 06:45:01,760
one of the calculators available to you

9970
06:45:01,760 --> 06:45:03,360
and you're going to see that this makes

9971
06:45:03,360 --> 06:45:06,240
sense we also have a special function

9972
06:45:06,240 --> 06:45:08,160
that is going to do the same thing but

9973
06:45:08,160 --> 06:45:09,680
in base 10

9974
06:45:09,680 --> 06:45:11,600
and this is going to be easier to

9975
06:45:11,600 --> 06:45:14,000
understand for example here we are

9976
06:45:14,000 --> 06:45:16,160
computing log 10

9977
06:45:16,160 --> 06:45:17,200
so

9978
06:45:17,200 --> 06:45:19,680
what we are really saying is to which

9979
06:45:19,680 --> 06:45:22,320
power should we elevate 10

9980
06:45:22,320 --> 06:45:25,280
to get 10 000 and this is easy because

9981
06:45:25,280 --> 06:45:28,958
the answer is a 4 10 to the power of 4

9982
06:45:28,958 --> 06:45:32,638
is 10 000 i really hope this makes sense

9983
06:45:32,638 --> 06:45:35,440
we also have a square route function we

9984
06:45:35,440 --> 06:45:38,240
can use so square out of 81 is going to

9985
06:45:38,240 --> 06:45:39,360
be nine

9986
06:45:39,360 --> 06:45:42,240
we have a function called std round

9987
06:45:42,240 --> 06:45:43,840
which can round

9988
06:45:43,840 --> 06:45:46,958
and uh what it's going to do by default

9989
06:45:46,958 --> 06:45:49,200
halfway points are going to be rounded

9990
06:45:49,200 --> 06:45:52,320
away from zero so if you have a 2.5 it's

9991
06:45:52,320 --> 06:45:55,200
going to be rounded up to a 3 and if you

9992
06:45:55,200 --> 06:45:58,320
have 2.4 it's going to be rounded down

9993
06:45:58,320 --> 06:46:01,760
to a 2. we also have a host of functions

9994
06:46:01,760 --> 06:46:04,400
we can use in trigonometry we have a

9995
06:46:04,400 --> 06:46:06,478
sine function we have a cosine function

9996
06:46:06,478 --> 06:46:08,878
we have a tan function if you know these

9997
06:46:08,878 --> 06:46:11,200
concepts in math this is going to come

9998
06:46:11,200 --> 06:46:14,400
in really handy if you want to do this i

9999
06:46:14,400 --> 06:46:16,240
have to say that what we just talked

10000
06:46:16,240 --> 06:46:19,760
about is a small set of what we can do

10001
06:46:19,760 --> 06:46:23,120
with these functions here in c math and

10002
06:46:23,120 --> 06:46:26,798
uh we are here at cppreference.com

10003
06:46:26,798 --> 06:46:29,360
and we can see all these functions here

10004
06:46:29,360 --> 06:46:32,080
we can do reminder we can do f men and

10005
06:46:32,080 --> 06:46:34,478
if you want you can check this out in

10006
06:46:34,478 --> 06:46:37,200
the documentation for example if you go

10007
06:46:37,200 --> 06:46:40,400
to can here and click on it you are

10008
06:46:40,400 --> 06:46:42,478
going to get the description and

10009
06:46:42,478 --> 06:46:44,878
explanation of what this function does

10010
06:46:44,878 --> 06:46:46,160
and you're going to have a simple

10011
06:46:46,160 --> 06:46:49,120
example of how you can play with us okay

10012
06:46:49,120 --> 06:46:51,440
now i hope you have a better idea of

10013
06:46:51,440 --> 06:46:54,000
what we can do with these functions in

10014
06:46:54,000 --> 06:46:56,878
the cmat library we're going to head to

10015
06:46:56,878 --> 06:46:58,400
visual studio code

10016
06:46:58,400 --> 06:47:00,558
and play with some of these functions

10017
06:47:00,558 --> 06:47:03,120
here we are in visual studio code the

10018
06:47:03,120 --> 06:47:05,040
current project we're going to work on

10019
06:47:05,040 --> 06:47:07,360
is math functions we're going to copy

10020
06:47:07,360 --> 06:47:10,080
over our template files

10021
06:47:10,080 --> 06:47:12,958
and we're going to put them in our

10022
06:47:12,958 --> 06:47:15,680
directory here math functions

10023
06:47:15,680 --> 06:47:17,840
and we are going to open this up in

10024
06:47:17,840 --> 06:47:21,280
visual studio code and we are going to

10025
06:47:21,280 --> 06:47:23,760
remove whatever it is we don't need

10026
06:47:23,760 --> 06:47:26,400
and we are going to include our library

10027
06:47:26,400 --> 06:47:28,320
which is c math

10028
06:47:28,320 --> 06:47:30,798
and we are going to put in our code so

10029
06:47:30,798 --> 06:47:32,798
that we can play with us

10030
06:47:32,798 --> 06:47:35,120
and here we have a variable called

10031
06:47:35,120 --> 06:47:36,000
weight

10032
06:47:36,000 --> 06:47:38,160
and we're going to try and use a few

10033
06:47:38,160 --> 06:47:41,040
math functions on it so we can use sdd

10034
06:47:41,040 --> 06:47:43,360
floor to round down

10035
06:47:43,360 --> 06:47:46,718
and std seal to round up so weighted

10036
06:47:46,718 --> 06:47:49,360
rounded to floor is going to be printed

10037
06:47:49,360 --> 06:47:51,920
out and way to round it to seal is going

10038
06:47:51,920 --> 06:47:53,360
to be printed out

10039
06:47:53,360 --> 06:47:55,440
we're going to have a number here

10040
06:47:55,440 --> 06:47:57,440
in this savings variable it's going to

10041
06:47:57,440 --> 06:47:59,840
be a negative number and we're going to

10042
06:47:59,840 --> 06:48:02,240
try and compute the absolute value of

10043
06:48:02,240 --> 06:48:04,320
this we're going to see it printed out

10044
06:48:04,320 --> 06:48:06,478
another thing we're going to

10045
06:48:06,478 --> 06:48:09,760
compute is the exponential of the value

10046
06:48:09,760 --> 06:48:12,798
we're going to do stdx 10

10047
06:48:12,798 --> 06:48:15,520
and what this is going to do is going to

10048
06:48:15,520 --> 06:48:16,798
take e

10049
06:48:16,798 --> 06:48:19,600
and raise it to the power of 10 and

10050
06:48:19,600 --> 06:48:21,200
that's what we're going to get printed

10051
06:48:21,200 --> 06:48:23,120
here the other thing we want to do here

10052
06:48:23,120 --> 06:48:25,040
is compute the power of a number we're

10053
06:48:25,040 --> 06:48:26,958
going to take 3 and raise it to the

10054
06:48:26,958 --> 06:48:30,400
power of 4 and take 9 and raise it to

10055
06:48:30,400 --> 06:48:33,040
the power of 3 and we're going to see

10056
06:48:33,040 --> 06:48:35,680
what these things evaluate to we're

10057
06:48:35,680 --> 06:48:38,638
going to open up our terminal here and

10058
06:48:38,638 --> 06:48:40,958
we're going to run the task to build

10059
06:48:40,958 --> 06:48:43,920
with gcc the world is going to be good

10060
06:48:43,920 --> 06:48:46,240
and if we run rooster we're going to get

10061
06:48:46,240 --> 06:48:49,600
these things here so 7.7 rounded to

10062
06:48:49,600 --> 06:48:51,120
floor is going to be seven so we're

10063
06:48:51,120 --> 06:48:54,400
going to round down 7.7 rounded to sale

10064
06:48:54,400 --> 06:48:56,478
is going to be eight and that's what

10065
06:48:56,478 --> 06:48:59,600
we're going to get and the absolute

10066
06:48:59,600 --> 06:49:02,360
value of weight is going to be

10067
06:49:02,360 --> 06:49:06,000
7.7 because it is a positive number and

10068
06:49:06,000 --> 06:49:09,280
the absolute value of minus 5000 is

10069
06:49:09,280 --> 06:49:11,760
going to be 5 000. and again when you

10070
06:49:11,760 --> 06:49:14,878
compute the absolute value of something

10071
06:49:14,878 --> 06:49:17,920
you are interested in the weight of that

10072
06:49:17,920 --> 06:49:21,120
thing without considering the sign

10073
06:49:21,120 --> 06:49:23,760
without really worrying if it is

10074
06:49:23,760 --> 06:49:25,600
positive or negative you just want to

10075
06:49:25,600 --> 06:49:27,920
get the magnitude of a number that's

10076
06:49:27,920 --> 06:49:30,000
what we use in math to mean that

10077
06:49:30,000 --> 06:49:32,478
magnitude okay so if we go down we're

10078
06:49:32,478 --> 06:49:35,200
going to get the exponential of 10 is

10079
06:49:35,200 --> 06:49:36,478
exponential

10080
06:49:36,478 --> 06:49:38,718
and you're going to get that here and

10081
06:49:38,718 --> 06:49:42,080
again what this function does is take e

10082
06:49:42,080 --> 06:49:45,440
and raise it to the power of 10

10083
06:49:45,440 --> 06:49:47,680
and that's the answer here we can try

10084
06:49:47,680 --> 06:49:50,080
and prove this with a calculator so i am

10085
06:49:50,080 --> 06:49:52,160
going to open my windows calculator you

10086
06:49:52,160 --> 06:49:54,478
can use whatever calculator you have

10087
06:49:54,478 --> 06:49:55,840
access to

10088
06:49:55,840 --> 06:49:58,718
i am going to use a scientific

10089
06:49:58,718 --> 06:50:02,400
calculator here and you see that we can

10090
06:50:02,400 --> 06:50:04,718
hit e and we're going to get the value

10091
06:50:04,718 --> 06:50:07,360
of this e number in math here it is

10092
06:50:07,360 --> 06:50:11,200
simplified but if i take it and raise it

10093
06:50:11,200 --> 06:50:14,798
to the power of 10 the answer is going

10094
06:50:14,798 --> 06:50:18,360
to be 22.026

10095
06:50:19,280 --> 06:50:22,400
and if we look in our program we have 22

10096
06:50:22,400 --> 06:50:23,638
0

10097
06:50:23,638 --> 06:50:26,958
26.5 okay it is rounded up a little bit

10098
06:50:26,958 --> 06:50:29,840
but it is almost the same thing okay we

10099
06:50:29,840 --> 06:50:32,558
also want to play with log functions a

10100
06:50:32,558 --> 06:50:33,680
little bit

10101
06:50:33,680 --> 06:50:36,638
log is basically the reverse of the

10102
06:50:36,638 --> 06:50:38,400
power function

10103
06:50:38,400 --> 06:50:40,240
and we just talked about this in the

10104
06:50:40,240 --> 06:50:41,520
slides

10105
06:50:41,520 --> 06:50:42,558
but

10106
06:50:42,558 --> 06:50:45,360
if we do log 18 base 2 we are basically

10107
06:50:45,360 --> 06:50:48,240
asking to which power should we raise 2

10108
06:50:48,240 --> 06:50:50,000
to get an 8

10109
06:50:50,000 --> 06:50:52,080
and the answer to that is going to be

10110
06:50:52,080 --> 06:50:53,680
what this log

10111
06:50:53,680 --> 06:50:55,840
number in base number is going to

10112
06:50:55,840 --> 06:50:58,638
evaluate to the catch is that the log

10113
06:50:58,638 --> 06:51:02,080
function if you use it row like this it

10114
06:51:02,080 --> 06:51:05,200
is going to be using base e and we just

10115
06:51:05,200 --> 06:51:08,320
saw that e is 2 to the power of 7 or

10116
06:51:08,320 --> 06:51:09,680
something let's go back to our

10117
06:51:09,680 --> 06:51:12,558
calculator and see if we can see that

10118
06:51:12,558 --> 06:51:14,718
why not why try to guess when we have a

10119
06:51:14,718 --> 06:51:17,280
good calculator in our hands we are

10120
06:51:17,280 --> 06:51:20,080
using the scientific calculator so if we

10121
06:51:20,080 --> 06:51:22,400
hit e here

10122
06:51:22,400 --> 06:51:24,400
this is the value of e

10123
06:51:24,400 --> 06:51:25,440
okay so

10124
06:51:25,440 --> 06:51:27,040
when we do log

10125
06:51:27,040 --> 06:51:29,360
we are basically asking to which power

10126
06:51:29,360 --> 06:51:31,760
should we raise e

10127
06:51:31,760 --> 06:51:33,878
so that we can get this

10128
06:51:33,878 --> 06:51:36,000
54.59 and the answer is going to be

10129
06:51:36,000 --> 06:51:38,478
computed and printed out here

10130
06:51:38,478 --> 06:51:41,120
we have a version of this that is going

10131
06:51:41,120 --> 06:51:44,320
to use base 10 so if we use this

10132
06:51:44,320 --> 06:51:46,400
we are basically saying to which power

10133
06:51:46,400 --> 06:51:49,280
should we raise 10 to get 10 000 and the

10134
06:51:49,280 --> 06:51:51,360
answer is going to be printed out here

10135
06:51:51,360 --> 06:51:53,760
and it is going to be a four because

10136
06:51:53,760 --> 06:51:57,040
this is easy to do in your mind so let's

10137
06:51:57,040 --> 06:52:00,320
run this we're going to build the task

10138
06:52:00,320 --> 06:52:02,718
we are going to run the task to build

10139
06:52:02,718 --> 06:52:05,680
with gcc and we're going to run our

10140
06:52:05,680 --> 06:52:08,240
program and uh we're going to get our

10141
06:52:08,240 --> 06:52:10,840
output here to get

10142
06:52:10,840 --> 06:52:14,240
54.59 you would elevate e to the power

10143
06:52:14,240 --> 06:52:16,958
of this number here this is the answer

10144
06:52:16,958 --> 06:52:18,638
and if you want you can prove this with

10145
06:52:18,638 --> 06:52:20,718
your favorite calculator you're going to

10146
06:52:20,718 --> 06:52:22,878
get something close to this to get 10

10147
06:52:22,878 --> 06:52:25,040
000 you'd need to elevate 10 to the

10148
06:52:25,040 --> 06:52:27,360
power of 4. that's what we're going to

10149
06:52:27,360 --> 06:52:30,000
get in here let's print this out again

10150
06:52:30,000 --> 06:52:32,558
many mistakes sorry but i hope you get

10151
06:52:32,558 --> 06:52:35,600
the point if we build again so that we

10152
06:52:35,600 --> 06:52:38,638
can see things properly and run we're

10153
06:52:38,638 --> 06:52:40,958
going to get proper data and this is

10154
06:52:40,958 --> 06:52:42,958
really what we expected to get we have a

10155
06:52:42,958 --> 06:52:44,958
few more functions we can play with as

10156
06:52:44,958 --> 06:52:47,760
we saw in our slides

10157
06:52:47,760 --> 06:52:51,360
let's play with square root and the std

10158
06:52:51,360 --> 06:52:53,440
round function here we are going to get

10159
06:52:53,440 --> 06:52:56,000
the square root of 81 we're going to get

10160
06:52:56,000 --> 06:52:58,080
it printed down and we're going to see

10161
06:52:58,080 --> 06:53:01,440
what std round does it is going to

10162
06:53:01,440 --> 06:53:05,200
round away from zero if we are at half

10163
06:53:05,200 --> 06:53:08,558
point and if we are not at half point if

10164
06:53:08,558 --> 06:53:10,240
we are below that we're going to round

10165
06:53:10,240 --> 06:53:12,958
down if we are higher than that we're

10166
06:53:12,958 --> 06:53:14,798
going to round up we're going to run

10167
06:53:14,798 --> 06:53:16,958
this so that you can see this running

10168
06:53:16,958 --> 06:53:19,440
and we're going to call rooster and the

10169
06:53:19,440 --> 06:53:23,120
2.5 is rounded to 3. 2.4 is rounded to

10170
06:53:23,120 --> 06:53:26,478
2. 3.6 is rounded to 4. this is what we

10171
06:53:26,478 --> 06:53:30,160
expect and the square root of 81

10172
06:53:30,160 --> 06:53:32,878
is 9. this is really all we set out to

10173
06:53:32,878 --> 06:53:35,680
do in this lecture to play with a few of

10174
06:53:35,680 --> 06:53:37,760
these c math function

10175
06:53:37,760 --> 06:53:40,478
they are not really hard to use once you

10176
06:53:40,478 --> 06:53:43,680
have the basics of math nailed down and

10177
06:53:43,680 --> 06:53:46,080
again if you want to check the full list

10178
06:53:46,080 --> 06:53:48,320
of these functions please come to our

10179
06:53:48,320 --> 06:53:50,000
reference documentation here you're

10180
06:53:50,000 --> 06:53:52,240
going to find a lot of them

10181
06:53:52,240 --> 06:53:54,798
and if you want to see how to use one of

10182
06:53:54,798 --> 06:53:57,600
these for example if you click on log 10

10183
06:53:57,600 --> 06:53:59,440
here you're going to come here you're

10184
06:53:59,440 --> 06:54:00,958
going to get an explanation of the

10185
06:54:00,958 --> 06:54:03,120
function and even better you're going to

10186
06:54:03,120 --> 06:54:05,360
go down and get a nice piece of code you

10187
06:54:05,360 --> 06:54:08,000
can play with and really make sense of

10188
06:54:08,000 --> 06:54:09,760
what is happening in these functions

10189
06:54:09,760 --> 06:54:11,680
here this is really all we set out to do

10190
06:54:11,680 --> 06:54:13,200
in this lecture i hope you found it

10191
06:54:13,200 --> 06:54:15,360
interesting we are going to stop here in

10192
06:54:15,360 --> 06:54:17,280
this lecture the next one we're going to

10193
06:54:17,280 --> 06:54:21,040
learn about some weird integral types

10194
06:54:21,040 --> 06:54:23,440
go ahead and finish up here and meet me

10195
06:54:23,440 --> 06:54:25,200
there in this lecture we're going to

10196
06:54:25,200 --> 06:54:28,160
learn about some weird integral types

10197
06:54:28,160 --> 06:54:30,958
and what do i mean by this well if you

10198
06:54:30,958 --> 06:54:33,680
look here integral types less than 4

10199
06:54:33,680 --> 06:54:36,240
bytes in size don't support arithmetic

10200
06:54:36,240 --> 06:54:39,440
operations and these are operations like

10201
06:54:39,440 --> 06:54:41,680
addition subtraction multiplication

10202
06:54:41,680 --> 06:54:44,400
division you can do these operations on

10203
06:54:44,400 --> 06:54:45,760
those types

10204
06:54:45,760 --> 06:54:48,400
and here i have an example of some of

10205
06:54:48,400 --> 06:54:51,840
those types we have a car it is one byte

10206
06:54:51,840 --> 06:54:54,000
in size and short end

10207
06:54:54,000 --> 06:54:57,360
is two bytes in size on most processors

10208
06:54:57,360 --> 06:55:00,400
so you can't do arithmetic operations if

10209
06:55:00,400 --> 06:55:03,360
your integer value is stored in these

10210
06:55:03,360 --> 06:55:04,638
types

10211
06:55:04,638 --> 06:55:06,958
why is that well this has to do with

10212
06:55:06,958 --> 06:55:08,478
processor design

10213
06:55:08,478 --> 06:55:11,040
and they decided to choose and as the

10214
06:55:11,040 --> 06:55:12,798
smallest type

10215
06:55:12,798 --> 06:55:15,040
integral type for which they can do

10216
06:55:15,040 --> 06:55:17,680
these arithmetic operations but

10217
06:55:17,680 --> 06:55:19,760
compilers are really smart enough to

10218
06:55:19,760 --> 06:55:22,080
notice if you are trying to do

10219
06:55:22,080 --> 06:55:24,718
arithmetic operations on these types and

10220
06:55:24,718 --> 06:55:27,120
they are going to implicitly convert

10221
06:55:27,120 --> 06:55:28,320
from

10222
06:55:28,320 --> 06:55:30,958
these smaller types to end

10223
06:55:30,958 --> 06:55:32,400
and this is something you need to be

10224
06:55:32,400 --> 06:55:35,760
aware of if we look at this program here

10225
06:55:35,760 --> 06:55:39,200
for example we have var1 and var2 they

10226
06:55:39,200 --> 06:55:42,240
are stored in variables that are of type

10227
06:55:42,240 --> 06:55:43,600
short and

10228
06:55:43,600 --> 06:55:46,878
and we have var 3 var 4 which are stored

10229
06:55:46,878 --> 06:55:50,000
in a variable of type car we can try and

10230
06:55:50,000 --> 06:55:52,320
print the resizes and we're going to get

10231
06:55:52,320 --> 06:55:54,878
two two one one for these variables

10232
06:55:54,878 --> 06:55:57,200
because a short end

10233
06:55:57,200 --> 06:55:59,600
occupies two bytes in memory for my

10234
06:55:59,600 --> 06:56:02,240
computer here and the car occupies one

10235
06:56:02,240 --> 06:56:05,920
byte in memory but the catch is down

10236
06:56:05,920 --> 06:56:06,878
here

10237
06:56:06,878 --> 06:56:08,878
if you try to add them up

10238
06:56:08,878 --> 06:56:10,638
the result is not going to be the same

10239
06:56:10,638 --> 06:56:13,440
type as defense you added up and you

10240
06:56:13,440 --> 06:56:14,798
would expect

10241
06:56:14,798 --> 06:56:15,840
auto

10242
06:56:15,840 --> 06:56:19,040
to deduce to the same type as var one

10243
06:56:19,040 --> 06:56:20,400
and var2

10244
06:56:20,400 --> 06:56:22,798
and it's not resort is going to be an

10245
06:56:22,798 --> 06:56:26,000
integer because and is the smallest type

10246
06:56:26,000 --> 06:56:27,920
for which we can support these

10247
06:56:27,920 --> 06:56:30,638
arithmetic operations so if we print the

10248
06:56:30,638 --> 06:56:32,558
size of result one and reserved two

10249
06:56:32,558 --> 06:56:34,958
we're going to get four but this is the

10250
06:56:34,958 --> 06:56:37,200
behavior you're going to get and we need

10251
06:56:37,200 --> 06:56:39,760
to be aware of it the same behavior can

10252
06:56:39,760 --> 06:56:42,320
be observed on other operators that we

10253
06:56:42,320 --> 06:56:44,798
will have a chance to look at in a few

10254
06:56:44,798 --> 06:56:47,200
chapters ahead and these are called

10255
06:56:47,200 --> 06:56:49,360
shift operators you use them to shift

10256
06:56:49,360 --> 06:56:51,680
bets but i don't want to talk anymore

10257
06:56:51,680 --> 06:56:53,200
about them because we're going to have a

10258
06:56:53,200 --> 06:56:55,760
chance to learn about them in detail

10259
06:56:55,760 --> 06:56:58,400
okay now is time to head to visual

10260
06:56:58,400 --> 06:57:00,558
studio code and actually see this in

10261
06:57:00,558 --> 06:57:03,600
action here we are in our working

10262
06:57:03,600 --> 06:57:05,680
directory we are going to copy our

10263
06:57:05,680 --> 06:57:07,680
template project we're going to copy

10264
06:57:07,680 --> 06:57:08,558
this

10265
06:57:08,558 --> 06:57:12,638
quickly put that in our folder on weird

10266
06:57:12,638 --> 06:57:14,638
integral types this is our current

10267
06:57:14,638 --> 06:57:16,638
project here and we're going to open

10268
06:57:16,638 --> 06:57:18,638
this up in visual studio code we're

10269
06:57:18,638 --> 06:57:20,798
going to open this up and we're going to

10270
06:57:20,798 --> 06:57:23,520
open our main cpp file remove whatever

10271
06:57:23,520 --> 06:57:25,760
it is we don't need and we are going to

10272
06:57:25,760 --> 06:57:28,320
put in our code this must be very

10273
06:57:28,320 --> 06:57:30,558
familiar because it is what we just saw

10274
06:57:30,558 --> 06:57:31,920
in the slides

10275
06:57:31,920 --> 06:57:34,558
so what we are doing here we have four

10276
06:57:34,558 --> 06:57:36,798
variables var one and var two are short

10277
06:57:36,798 --> 06:57:39,520
and so these are going to take two bytes

10278
06:57:39,520 --> 06:57:43,040
in memory on my computer here and uh car

10279
06:57:43,040 --> 06:57:45,200
is going to take up one byte and we're

10280
06:57:45,200 --> 06:57:46,798
going to print their sizes we're going

10281
06:57:46,798 --> 06:57:48,878
to see them printed down and we are

10282
06:57:48,878 --> 06:57:51,360
adding things up here we are taking two

10283
06:57:51,360 --> 06:57:54,000
short end variables and adding them up

10284
06:57:54,000 --> 06:57:56,160
so what the compiler is going to do it's

10285
06:57:56,160 --> 06:57:58,080
going to take this turn it into an end

10286
06:57:58,080 --> 06:58:00,320
and then do addition and the result is

10287
06:58:00,320 --> 06:58:02,558
going to be an end the same story is

10288
06:58:02,558 --> 06:58:05,360
going to happen for reserved 2 here

10289
06:58:05,360 --> 06:58:09,520
var 3 is a car so it is one byte in

10290
06:58:09,520 --> 06:58:12,160
memory but the compiler can't really add

10291
06:58:12,160 --> 06:58:14,878
up integral types which are smaller than

10292
06:58:14,878 --> 06:58:17,280
four bytes in memory so what is going to

10293
06:58:17,280 --> 06:58:18,798
happen var three is going to be

10294
06:58:18,798 --> 06:58:22,160
transformed implicitly behind the scenes

10295
06:58:22,160 --> 06:58:24,878
to a net and var four is going to be

10296
06:58:24,878 --> 06:58:26,638
transformed to a net and then we're

10297
06:58:26,638 --> 06:58:28,798
going to add that up and we're going to

10298
06:58:28,798 --> 06:58:31,040
store that in a neat variable which is

10299
06:58:31,040 --> 06:58:32,478
resort here

10300
06:58:32,478 --> 06:58:34,080
if we print this up we're going to see

10301
06:58:34,080 --> 06:58:37,280
that size of result 1 and result 2 is a

10302
06:58:37,280 --> 06:58:40,400
4 and this is what we expect here and

10303
06:58:40,400 --> 06:58:42,558
this is a behavior you need to be aware

10304
06:58:42,558 --> 06:58:44,878
of because sometimes your application

10305
06:58:44,878 --> 06:58:47,600
logic is going to depend on the size of

10306
06:58:47,600 --> 06:58:50,080
data if that's the case you need to care

10307
06:58:50,080 --> 06:58:51,120
about this

10308
06:58:51,120 --> 06:58:52,638
and if you don't know this you're going

10309
06:58:52,638 --> 06:58:55,360
to be beaten by this and it is really

10310
06:58:55,360 --> 06:58:58,718
hard to find problems like this

10311
06:58:58,718 --> 06:59:01,040
so what we can do is open up our

10312
06:59:01,040 --> 06:59:03,600
terminal and we're going to build this

10313
06:59:03,600 --> 06:59:06,478
with gcc as we usually do and that we

10314
06:59:06,478 --> 06:59:09,040
can run our program rooster and we're

10315
06:59:09,040 --> 06:59:10,958
going to see that this is what we expect

10316
06:59:10,958 --> 06:59:14,478
var1 is two bytes in size var2 is two

10317
06:59:14,478 --> 06:59:16,798
bytes in size wire three and waterfall

10318
06:59:16,798 --> 06:59:19,680
are one byte in size but our result is

10319
06:59:19,680 --> 06:59:21,920
four bytes because the compiler

10320
06:59:21,920 --> 06:59:24,080
implicitly converted

10321
06:59:24,080 --> 06:59:27,280
our operands here to x to be able to

10322
06:59:27,280 --> 06:59:30,160
carry out this arithmetic operation this

10323
06:59:30,160 --> 06:59:31,600
is really all we setup to do in this

10324
06:59:31,600 --> 06:59:34,000
lecture i hope you found it interesting

10325
06:59:34,000 --> 06:59:35,360
we are going to stop here in this

10326
06:59:35,360 --> 06:59:37,520
lecture the next one we're going to try

10327
06:59:37,520 --> 06:59:41,240
and recap what we saw in the chapter

10328
06:59:41,240 --> 06:59:43,520
congratulations on hitting the end of

10329
06:59:43,520 --> 06:59:46,080
this chapter and this chapter was really

10330
06:59:46,080 --> 06:59:47,360
about

10331
06:59:47,360 --> 06:59:50,320
doing operations and manipulating the

10332
06:59:50,320 --> 06:59:53,040
data that you have stored in your

10333
06:59:53,040 --> 06:59:55,280
variables the first thing we saw was

10334
06:59:55,280 --> 06:59:57,920
that we could do arithmetic operations

10335
06:59:57,920 --> 06:59:59,920
on the data we can add things up

10336
06:59:59,920 --> 07:00:02,878
multiply divide we also saw the modulus

10337
07:00:02,878 --> 07:00:05,040
operator which may seem weird for

10338
07:00:05,040 --> 07:00:07,120
beginners but we had a chance to really

10339
07:00:07,120 --> 07:00:09,440
play with us after that we learned about

10340
07:00:09,440 --> 07:00:11,760
precedence and associativity we saw that

10341
07:00:11,760 --> 07:00:13,760
that's a set of rules

10342
07:00:13,760 --> 07:00:16,240
we have to follow to know which

10343
07:00:16,240 --> 07:00:18,558
operation to do first if we have

10344
07:00:18,558 --> 07:00:22,240
multiple operators in our expression we

10345
07:00:22,240 --> 07:00:24,718
also had a chance to learn about prefix

10346
07:00:24,718 --> 07:00:26,958
and postfix increment and decrement

10347
07:00:26,958 --> 07:00:29,360
operators we had a chance to do compound

10348
07:00:29,360 --> 07:00:32,478
assignments things like plus equal minus

10349
07:00:32,478 --> 07:00:35,600
equal multiply equal modulus equal now

10350
07:00:35,600 --> 07:00:37,840
these things must be making sense to you

10351
07:00:37,840 --> 07:00:39,920
we had a chance to look at how we could

10352
07:00:39,920 --> 07:00:42,160
compare things using relational

10353
07:00:42,160 --> 07:00:45,120
operators like greater than lesser than

10354
07:00:45,120 --> 07:00:47,840
and equal or not equal we also had a

10355
07:00:47,840 --> 07:00:50,240
chance to look at output formatting and

10356
07:00:50,240 --> 07:00:53,680
we saw a host of things we could do to

10357
07:00:53,680 --> 07:00:57,360
make data show up better with sddc out

10358
07:00:57,360 --> 07:00:59,280
after that we learned about numeric

10359
07:00:59,280 --> 07:01:02,080
limits and this is a cool way to know

10360
07:01:02,080 --> 07:01:04,478
the ranges for your data types but there

10361
07:01:04,478 --> 07:01:06,878
are a host of other properties you can

10362
07:01:06,878 --> 07:01:09,600
use in this limits library we learned a

10363
07:01:09,600 --> 07:01:11,600
little bit about math functions and we

10364
07:01:11,600 --> 07:01:13,840
played with things like the power of

10365
07:01:13,840 --> 07:01:16,798
something the exponential the few

10366
07:01:16,798 --> 07:01:18,798
rounding functions that we have in the

10367
07:01:18,798 --> 07:01:21,360
cmat library and now you must have a

10368
07:01:21,360 --> 07:01:24,160
good idea about these functions that you

10369
07:01:24,160 --> 07:01:26,400
can use to manipulate and do math on

10370
07:01:26,400 --> 07:01:29,040
your variables we ended the chapter by

10371
07:01:29,040 --> 07:01:32,240
looking at some weird integral types and

10372
07:01:32,240 --> 07:01:34,718
the main message in that lecture was

10373
07:01:34,718 --> 07:01:37,840
that you can't do arithmetic operations

10374
07:01:37,840 --> 07:01:41,040
on data types whose size is less than 4

10375
07:01:41,040 --> 07:01:43,440
bytes in memory if you try to do that

10376
07:01:43,440 --> 07:01:45,760
the compiler is going to insert

10377
07:01:45,760 --> 07:01:48,320
implicit conversions and if your

10378
07:01:48,320 --> 07:01:50,718
application depends on the size of

10379
07:01:50,718 --> 07:01:51,840
things

10380
07:01:51,840 --> 07:01:53,600
this is something you need to be careful

10381
07:01:53,600 --> 07:01:55,840
about otherwise you're going to have a

10382
07:01:55,840 --> 07:01:57,200
hard time

10383
07:01:57,200 --> 07:01:59,440
finding these problems i would like to

10384
07:01:59,440 --> 07:02:02,000
welcome you in this new chapter where

10385
07:02:02,000 --> 07:02:04,320
we're going to be learning about a new

10386
07:02:04,320 --> 07:02:06,718
way we can do things in c plus plus and

10387
07:02:06,718 --> 07:02:09,200
we're going to be doing conditional

10388
07:02:09,200 --> 07:02:11,600
programming in other words we're going

10389
07:02:11,600 --> 07:02:14,638
to be able to do different things

10390
07:02:14,638 --> 07:02:17,200
based on the conditions that we have set

10391
07:02:17,200 --> 07:02:19,360
up in our code just to give you an

10392
07:02:19,360 --> 07:02:21,360
example here we have a few variables

10393
07:02:21,360 --> 07:02:23,680
they are booleans and we have a few

10394
07:02:23,680 --> 07:02:26,558
initializers in there red is false green

10395
07:02:26,558 --> 07:02:29,040
is true yellow is false police stop is

10396
07:02:29,040 --> 07:02:31,040
true and we can do

10397
07:02:31,040 --> 07:02:33,760
different things based on discipline

10398
07:02:33,760 --> 07:02:35,600
conditions for example

10399
07:02:35,600 --> 07:02:38,558
if the light is red we may be

10400
07:02:38,558 --> 07:02:40,000
told to stop

10401
07:02:40,000 --> 07:02:42,320
if the light is yellow we might be told

10402
07:02:42,320 --> 07:02:44,958
to slow down if the light is green we

10403
07:02:44,958 --> 07:02:47,440
might be told to go and do whatever it

10404
07:02:47,440 --> 07:02:49,200
is we want to do so we're going to be

10405
07:02:49,200 --> 07:02:51,600
able to do these kinds of things and c

10406
07:02:51,600 --> 07:02:53,920
plus plus provides different constructs

10407
07:02:53,920 --> 07:02:56,478
to be able to do conditional programming

10408
07:02:56,478 --> 07:02:57,600
in uc

10409
07:02:57,600 --> 07:03:00,080
code we just have one of them in this

10410
07:03:00,080 --> 07:03:02,958
slide which is this if statement here

10411
07:03:02,958 --> 07:03:05,600
this if keyword allows you to do things

10412
07:03:05,600 --> 07:03:07,840
like this we have a few others we have

10413
07:03:07,840 --> 07:03:09,760
the else keyword we have the switch

10414
07:03:09,760 --> 07:03:12,558
keyword we also have a completely

10415
07:03:12,558 --> 07:03:15,600
separate operator that is called ternary

10416
07:03:15,600 --> 07:03:18,080
operator that allows you to do these

10417
07:03:18,080 --> 07:03:19,680
kinds of things and we're going to be

10418
07:03:19,680 --> 07:03:22,080
learning about all these things and more

10419
07:03:22,080 --> 07:03:24,000
in this chapter we are going to start

10420
07:03:24,000 --> 07:03:26,240
and learn about the if statement in the

10421
07:03:26,240 --> 07:03:27,520
next lecture

10422
07:03:27,520 --> 07:03:29,840
go ahead and finish up here and meet me

10423
07:03:29,840 --> 07:03:30,638
there

10424
07:03:30,638 --> 07:03:32,080
in this lecture we're going to learn

10425
07:03:32,080 --> 07:03:34,798
about the if statement and this is a

10426
07:03:34,798 --> 07:03:36,878
statement that is going to allow you to

10427
07:03:36,878 --> 07:03:39,680
do things based on some condition being

10428
07:03:39,680 --> 07:03:40,558
true

10429
07:03:40,558 --> 07:03:43,680
or false here is a simple code example

10430
07:03:43,680 --> 07:03:45,440
we have two variables number one and

10431
07:03:45,440 --> 07:03:46,558
number two

10432
07:03:46,558 --> 07:03:48,798
and we have a statement here that is

10433
07:03:48,798 --> 07:03:51,280
going to compare number one and number

10434
07:03:51,280 --> 07:03:53,680
two and we're going to store the result

10435
07:03:53,680 --> 07:03:56,478
in this boolean variable

10436
07:03:56,478 --> 07:03:58,320
that we have on the left then we're

10437
07:03:58,320 --> 07:04:01,040
going to do something based on the value

10438
07:04:01,040 --> 07:04:04,160
that we are storing in this result here

10439
07:04:04,160 --> 07:04:05,840
if the result in there is true we're

10440
07:04:05,840 --> 07:04:07,200
going to print

10441
07:04:07,200 --> 07:04:09,760
number one is less than number two if

10442
07:04:09,760 --> 07:04:11,600
the result is not true we're going to

10443
07:04:11,600 --> 07:04:14,478
say number one is not less than

10444
07:04:14,478 --> 07:04:17,520
number two and notice in the first if

10445
07:04:17,520 --> 07:04:20,240
close year we are testing for the case

10446
07:04:20,240 --> 07:04:23,280
where the result is true but sometimes

10447
07:04:23,280 --> 07:04:25,520
we need to do something when this

10448
07:04:25,520 --> 07:04:28,558
condition here is not true one way to do

10449
07:04:28,558 --> 07:04:31,040
that is to negate what we have here

10450
07:04:31,040 --> 07:04:34,160
inside the if parenthesis and test for

10451
07:04:34,160 --> 07:04:37,280
the reverse of whatever we have in here

10452
07:04:37,280 --> 07:04:39,600
if that is making any sense if you look

10453
07:04:39,600 --> 07:04:42,320
here we are testing for the case where

10454
07:04:42,320 --> 07:04:45,760
if not the result is a true and in other

10455
07:04:45,760 --> 07:04:47,760
words we are testing for the case where

10456
07:04:47,760 --> 07:04:50,000
the result here is false and we're going

10457
07:04:50,000 --> 07:04:52,878
to say number one is not less than

10458
07:04:52,878 --> 07:04:54,718
number two this is one way we can go

10459
07:04:54,718 --> 07:04:57,280
about this again the if statement is

10460
07:04:57,280 --> 07:04:59,600
used to do conditional programming this

10461
07:04:59,600 --> 07:05:01,840
is the syntax we use to do it in c plus

10462
07:05:01,840 --> 07:05:04,160
plus we say f we put a set of

10463
07:05:04,160 --> 07:05:06,958
parentheses and inside the parenthesis

10464
07:05:06,958 --> 07:05:10,000
we put the condition we want to test for

10465
07:05:10,000 --> 07:05:11,760
and after that we're going to have a

10466
07:05:11,760 --> 07:05:14,718
pair of curly braces and what we have

10467
07:05:14,718 --> 07:05:17,360
inside these curly braces is going to be

10468
07:05:17,360 --> 07:05:20,878
the body of our if statement and it is

10469
07:05:20,878 --> 07:05:22,958
basically going to be the code we want

10470
07:05:22,958 --> 07:05:26,558
to run if the test here is successful we

10471
07:05:26,558 --> 07:05:28,878
can also use an else clause to catch the

10472
07:05:28,878 --> 07:05:31,280
case where the test hasn't been

10473
07:05:31,280 --> 07:05:33,760
successful in this case we can say if

10474
07:05:33,760 --> 07:05:35,920
result equals true we're going to do

10475
07:05:35,920 --> 07:05:37,120
something

10476
07:05:37,120 --> 07:05:39,760
and else we're going to do something

10477
07:05:39,760 --> 07:05:42,240
else in other words if research is true

10478
07:05:42,240 --> 07:05:44,798
we're going to say is less than if it's

10479
07:05:44,798 --> 07:05:46,878
not true we're going to say is not less

10480
07:05:46,878 --> 07:05:49,360
than and this is a more compact way of

10481
07:05:49,360 --> 07:05:52,638
doing what we just did in the slide here

10482
07:05:52,638 --> 07:05:54,718
you can also directly use your

10483
07:05:54,718 --> 07:05:57,680
expression as a condition and the

10484
07:05:57,680 --> 07:06:00,558
requirement here is that the expression

10485
07:06:00,558 --> 07:06:03,360
evaluates to something that we can treat

10486
07:06:03,360 --> 07:06:05,680
like a boolean because the condition has

10487
07:06:05,680 --> 07:06:08,320
to be a boolean it has to be true or

10488
07:06:08,320 --> 07:06:10,478
false okay here is another simple

10489
07:06:10,478 --> 07:06:12,320
example we have seen this in the last

10490
07:06:12,320 --> 07:06:14,878
lecture we have a few variables

10491
07:06:14,878 --> 07:06:18,000
containing our conditions and we are

10492
07:06:18,000 --> 07:06:20,798
saying if the light is red for example

10493
07:06:20,798 --> 07:06:22,400
we're going to do something if it's

10494
07:06:22,400 --> 07:06:24,240
yellow we're going to do something if

10495
07:06:24,240 --> 07:06:26,400
it's green we're going to do something

10496
07:06:26,400 --> 07:06:29,440
we can also nest conditions for example

10497
07:06:29,440 --> 07:06:32,320
we can put our outer

10498
07:06:32,320 --> 07:06:34,878
if statement and inside that if

10499
07:06:34,878 --> 07:06:38,000
statement set up other if statements and

10500
07:06:38,000 --> 07:06:40,718
if our logic needs something like this

10501
07:06:40,718 --> 07:06:42,320
you can do this and you can take

10502
07:06:42,320 --> 07:06:44,400
advantage of this to achieve whatever it

10503
07:06:44,400 --> 07:06:46,718
is you want to do in this case if the

10504
07:06:46,718 --> 07:06:48,400
light is green we're going to

10505
07:06:48,400 --> 07:06:50,160
fall in here and we're going to do

10506
07:06:50,160 --> 07:06:52,000
another condition so if the light is

10507
07:06:52,000 --> 07:06:54,718
green and if the police officer has

10508
07:06:54,718 --> 07:06:57,040
stopped you you're going to stop and if

10509
07:06:57,040 --> 07:06:58,638
they haven't stopped you you're going to

10510
07:06:58,638 --> 07:07:00,718
go because the light is green and you

10511
07:07:00,718 --> 07:07:02,558
can do something like this

10512
07:07:02,558 --> 07:07:04,718
we can also use logical operators to

10513
07:07:04,718 --> 07:07:06,958
kind of achieve the same thing and we

10514
07:07:06,958 --> 07:07:09,920
say if the light is green and the police

10515
07:07:09,920 --> 07:07:11,600
officer hasn't stopped you you're going

10516
07:07:11,600 --> 07:07:14,320
to go else you're going to stop and you

10517
07:07:14,320 --> 07:07:16,320
can do something like this and you see

10518
07:07:16,320 --> 07:07:18,478
that you can combine the logical

10519
07:07:18,478 --> 07:07:21,360
operators we've learned about with the

10520
07:07:21,360 --> 07:07:23,360
conditional programming techniques we

10521
07:07:23,360 --> 07:07:25,520
are learning about here to do really

10522
07:07:25,520 --> 07:07:27,120
powerful stuff and we're going to be

10523
07:07:27,120 --> 07:07:29,520
doing this all over the place in the

10524
07:07:29,520 --> 07:07:31,760
course so we're going to head over to

10525
07:07:31,760 --> 07:07:34,240
visual studio code and play with us here

10526
07:07:34,240 --> 07:07:36,798
we are in our working directory we're

10527
07:07:36,798 --> 07:07:39,600
going to be working on if statements and

10528
07:07:39,600 --> 07:07:42,638
we're going to grab our template project

10529
07:07:42,638 --> 07:07:45,120
the template files i should say and

10530
07:07:45,120 --> 07:07:47,360
we're going to put them in here

10531
07:07:47,360 --> 07:07:49,120
and we're going to open this up in

10532
07:07:49,120 --> 07:07:51,600
visual studio code as we always do so

10533
07:07:51,600 --> 07:07:54,080
let's do that open folder and we should

10534
07:07:54,080 --> 07:07:57,200
fall in here and open our main cpp file

10535
07:07:57,200 --> 07:07:59,200
let's do the usual and remove what we

10536
07:07:59,200 --> 07:08:00,478
don't need

10537
07:08:00,478 --> 07:08:02,798
and we are going to put in our code so

10538
07:08:02,798 --> 07:08:04,798
that we can really play with us we have

10539
07:08:04,798 --> 07:08:07,040
two variables in here number one and

10540
07:08:07,040 --> 07:08:09,840
number two they are integers and we have

10541
07:08:09,840 --> 07:08:14,240
the values 55 and 60 inside we can do a

10542
07:08:14,240 --> 07:08:16,958
comparison between these two variables

10543
07:08:16,958 --> 07:08:18,958
and what this comparison is going to

10544
07:08:18,958 --> 07:08:22,000
yield is a boolean value that we're

10545
07:08:22,000 --> 07:08:24,558
going to store in our boolean variable

10546
07:08:24,558 --> 07:08:26,638
here which is called result

10547
07:08:26,638 --> 07:08:29,200
and what we can do is use this to do

10548
07:08:29,200 --> 07:08:31,360
some conditional programming so we're

10549
07:08:31,360 --> 07:08:33,280
going to say if the result is true we're

10550
07:08:33,280 --> 07:08:35,760
going to do something and if the result

10551
07:08:35,760 --> 07:08:38,080
is not true we're going to do something

10552
07:08:38,080 --> 07:08:40,558
else and this is how we say it this

10553
07:08:40,558 --> 07:08:43,440
syntax here may be confusing to new

10554
07:08:43,440 --> 07:08:47,040
students but try to think of it if not

10555
07:08:47,040 --> 07:08:49,520
research is true and that's really the

10556
07:08:49,520 --> 07:08:53,040
same thing as saying if result is false

10557
07:08:53,040 --> 07:08:55,040
try to stream this in your mind a little

10558
07:08:55,040 --> 07:08:56,240
bit and you really are going to

10559
07:08:56,240 --> 07:08:58,320
understand okay so now that you have

10560
07:08:58,320 --> 07:09:00,320
seen this piece of code

10561
07:09:00,320 --> 07:09:01,600
try to

10562
07:09:01,600 --> 07:09:03,600
guess what we're going to see if we run

10563
07:09:03,600 --> 07:09:05,280
this what are we going to see on the

10564
07:09:05,280 --> 07:09:07,920
console okay give it a try so we're

10565
07:09:07,920 --> 07:09:10,000
going to run this in visual studio code

10566
07:09:10,000 --> 07:09:12,320
let's open up a terminal first

10567
07:09:12,320 --> 07:09:14,958
and we're going to world with gcc as we

10568
07:09:14,958 --> 07:09:16,320
always do

10569
07:09:16,320 --> 07:09:17,840
we're going to bring this up a little

10570
07:09:17,840 --> 07:09:20,320
bit so that we have some breathing room

10571
07:09:20,320 --> 07:09:22,478
and we're going to run rooster let's see

10572
07:09:22,478 --> 07:09:24,320
what we have here we have reserved

10573
07:09:24,320 --> 07:09:27,280
equals true and that's coming from this

10574
07:09:27,280 --> 07:09:28,798
statement here

10575
07:09:28,798 --> 07:09:32,000
and we have freestanding if statement

10576
07:09:32,000 --> 07:09:34,080
which is coming from

10577
07:09:34,080 --> 07:09:36,878
here and we have our meat of this

10578
07:09:36,878 --> 07:09:39,440
program what we really are interested in

10579
07:09:39,440 --> 07:09:43,840
we have 55 is less than 60. so our test

10580
07:09:43,840 --> 07:09:47,120
here succeeded and we fell in this body

10581
07:09:47,120 --> 07:09:50,718
and executed this sddc out statement

10582
07:09:50,718 --> 07:09:52,958
that's why we're saying number one is

10583
07:09:52,958 --> 07:09:54,080
less than

10584
07:09:54,080 --> 07:09:56,878
number two and number one is 55 which is

10585
07:09:56,878 --> 07:10:00,240
what we see here and number two is 60

10586
07:10:00,240 --> 07:10:02,478
which is what we are seeing here

10587
07:10:02,478 --> 07:10:05,520
so what can we do to make

10588
07:10:05,520 --> 07:10:08,320
the second statement here execute you

10589
07:10:08,320 --> 07:10:11,040
know it is testing for the case where

10590
07:10:11,040 --> 07:10:13,520
not result is true so it's going to

10591
07:10:13,520 --> 07:10:16,160
exactly do the reverse of what this test

10592
07:10:16,160 --> 07:10:17,520
here is doing

10593
07:10:17,520 --> 07:10:19,680
and if this fails this one is going to

10594
07:10:19,680 --> 07:10:22,160
succeed which is what we have now so

10595
07:10:22,160 --> 07:10:23,760
what we can do to really play with this

10596
07:10:23,760 --> 07:10:26,718
we can go up and change for example

10597
07:10:26,718 --> 07:10:29,200
number one to 65

10598
07:10:29,200 --> 07:10:31,600
this is going to flip the order of these

10599
07:10:31,600 --> 07:10:34,160
numbers if i may say it like that and if

10600
07:10:34,160 --> 07:10:37,440
we run it we're going to build with gcc

10601
07:10:37,440 --> 07:10:39,040
and run this

10602
07:10:39,040 --> 07:10:42,240
we're going to see result is false so

10603
07:10:42,240 --> 07:10:45,200
result became false because number one

10604
07:10:45,200 --> 07:10:47,520
is not less than number two so this is

10605
07:10:47,520 --> 07:10:50,878
going to be false and the test here is

10606
07:10:50,878 --> 07:10:53,120
going to fail result is not true so

10607
07:10:53,120 --> 07:10:56,000
we're not going to go in here and look

10608
07:10:56,000 --> 07:10:59,040
at here if not result is true so

10609
07:10:59,040 --> 07:11:01,040
research is true is false

10610
07:11:01,040 --> 07:11:03,360
if we negate this this is going to

10611
07:11:03,360 --> 07:11:06,080
become true and this test here is going

10612
07:11:06,080 --> 07:11:08,478
to succeed and we are going to fall in

10613
07:11:08,478 --> 07:11:10,798
here take some time to really understand

10614
07:11:10,798 --> 07:11:13,040
this and if you have a problem ask me i

10615
07:11:13,040 --> 07:11:14,878
am going to do the best i can to help

10616
07:11:14,878 --> 07:11:17,200
you out but make sure you understand

10617
07:11:17,200 --> 07:11:19,680
this because this is really fundamental

10618
07:11:19,680 --> 07:11:22,000
in your journey as a software developer

10619
07:11:22,000 --> 07:11:24,878
not just in c plus plus any career as a

10620
07:11:24,878 --> 07:11:26,558
software developer you're going to need

10621
07:11:26,558 --> 07:11:28,718
to understand this okay what we're going

10622
07:11:28,718 --> 07:11:31,040
to do is comment out

10623
07:11:31,040 --> 07:11:32,718
what we just did here because we're

10624
07:11:32,718 --> 07:11:34,638
going to see another way to do this and

10625
07:11:34,638 --> 07:11:37,120
we don't want to have noise output in

10626
07:11:37,120 --> 07:11:39,440
our terminal this is going to just make

10627
07:11:39,440 --> 07:11:42,080
things hard for us to see so what we're

10628
07:11:42,080 --> 07:11:43,360
going to do

10629
07:11:43,360 --> 07:11:45,120
we're going to go down in here and put

10630
07:11:45,120 --> 07:11:47,600
in another piece of code and

10631
07:11:47,600 --> 07:11:49,920
the result was commented out we don't

10632
07:11:49,920 --> 07:11:51,360
want to comment that out so we're going

10633
07:11:51,360 --> 07:11:53,200
to take this out because this is our

10634
07:11:53,200 --> 07:11:55,600
condition we're going to grab it and put

10635
07:11:55,600 --> 07:11:58,400
that outside our comment section this is

10636
07:11:58,400 --> 07:12:00,718
going to do and if we go down again

10637
07:12:00,718 --> 07:12:02,958
we're going to click on this file icon

10638
07:12:02,958 --> 07:12:05,040
and uh give ourselves some more

10639
07:12:05,040 --> 07:12:06,798
breathing room here we don't really need

10640
07:12:06,798 --> 07:12:09,360
to see that main cpp file anyway

10641
07:12:09,360 --> 07:12:11,520
so if we come here we can use the else

10642
07:12:11,520 --> 07:12:12,478
clause

10643
07:12:12,478 --> 07:12:14,958
to test for the case where our condition

10644
07:12:14,958 --> 07:12:15,920
fails

10645
07:12:15,920 --> 07:12:18,160
and if you look here we are essentially

10646
07:12:18,160 --> 07:12:20,160
saying the same thing we are saying if

10647
07:12:20,160 --> 07:12:22,558
result equals true we're going to fall

10648
07:12:22,558 --> 07:12:25,520
in here and else we're going to fall in

10649
07:12:25,520 --> 07:12:27,840
here so we don't need to do the double

10650
07:12:27,840 --> 07:12:30,240
if statements that we just did

10651
07:12:30,240 --> 07:12:32,798
here and this is much more compact and

10652
07:12:32,798 --> 07:12:34,798
easy to read let's look again at the

10653
07:12:34,798 --> 07:12:37,040
numbers we have here number one is 65

10654
07:12:37,040 --> 07:12:39,760
number 2 is 60. this expression here is

10655
07:12:39,760 --> 07:12:43,360
going to be false because 65 is not less

10656
07:12:43,360 --> 07:12:45,840
than 60 we're going to have a false in

10657
07:12:45,840 --> 07:12:48,400
here and if we come down

10658
07:12:48,400 --> 07:12:50,160
result is going to be false this is

10659
07:12:50,160 --> 07:12:52,320
going to fail and we are going to fall

10660
07:12:52,320 --> 07:12:54,478
down here we're going to say

10661
07:12:54,478 --> 07:12:55,840
number one

10662
07:12:55,840 --> 07:12:59,840
or 65 is not less than 60 which is what

10663
07:12:59,840 --> 07:13:02,638
we have in our values so we're going to

10664
07:13:02,638 --> 07:13:04,958
build this again and we're going to run

10665
07:13:04,958 --> 07:13:06,878
rooster that's clear so that we have

10666
07:13:06,878 --> 07:13:08,478
some breathing room we're going to run

10667
07:13:08,478 --> 07:13:11,520
rooster and you're going to see that 65

10668
07:13:11,520 --> 07:13:13,200
is not less than

10669
07:13:13,200 --> 07:13:15,760
60 which is what we expect again if you

10670
07:13:15,760 --> 07:13:17,680
go up and change these numbers to

10671
07:13:17,680 --> 07:13:19,920
whatever you want try to change these

10672
07:13:19,920 --> 07:13:22,638
numbers to different values to see what

10673
07:13:22,638 --> 07:13:25,600
you get as output if we do this we're

10674
07:13:25,600 --> 07:13:27,280
going to see that number one is less

10675
07:13:27,280 --> 07:13:30,000
than 60 so this is going to be true

10676
07:13:30,000 --> 07:13:31,840
and we're going to have a true in this

10677
07:13:31,840 --> 07:13:34,558
result variable here if we go down

10678
07:13:34,558 --> 07:13:37,200
result is true this test condition here

10679
07:13:37,200 --> 07:13:39,360
is going to succeed and we are going to

10680
07:13:39,360 --> 07:13:42,160
fall in here let's click in our terminal

10681
07:13:42,160 --> 07:13:44,000
and hit enter we're going to run rooster

10682
07:13:44,000 --> 07:13:46,798
we're going to see 55 is less than 60

10683
07:13:46,798 --> 07:13:49,120
which is what we have here okay now i

10684
07:13:49,120 --> 07:13:51,200
hope you have a better idea of how you

10685
07:13:51,200 --> 07:13:54,160
can use the else close to make your if

10686
07:13:54,160 --> 07:13:56,160
statements really compact and this is

10687
07:13:56,160 --> 07:13:58,320
really cool okay another thing i want

10688
07:13:58,320 --> 07:14:00,400
you to see is that you can

10689
07:14:00,400 --> 07:14:03,200
not go through a variable like this and

10690
07:14:03,200 --> 07:14:05,760
use an expression as a condition

10691
07:14:05,760 --> 07:14:07,680
directly c plus plus allows you to do

10692
07:14:07,680 --> 07:14:09,280
this so what we're going to do we're

10693
07:14:09,280 --> 07:14:11,360
going to comment out what we just did

10694
07:14:11,360 --> 07:14:13,600
let's do that i'm going to use a block

10695
07:14:13,600 --> 07:14:15,600
comment i hope you know how to use this

10696
07:14:15,600 --> 07:14:16,558
already

10697
07:14:16,558 --> 07:14:18,478
and we're going to go down and put in

10698
07:14:18,478 --> 07:14:21,040
our code it is exactly the same thing

10699
07:14:21,040 --> 07:14:23,520
but we took the expression and put that

10700
07:14:23,520 --> 07:14:25,920
in the place of our condition variable

10701
07:14:25,920 --> 07:14:28,718
here because this is going to evaluate

10702
07:14:28,718 --> 07:14:31,120
to a boolean anyway so we can use this

10703
07:14:31,120 --> 07:14:33,440
as a condition and this is something

10704
07:14:33,440 --> 07:14:36,478
very legal to do in c plus plus so if we

10705
07:14:36,478 --> 07:14:38,160
run this we're going to see let's see

10706
07:14:38,160 --> 07:14:39,680
what we have in the numbers i have

10707
07:14:39,680 --> 07:14:40,878
forgotten

10708
07:14:40,878 --> 07:14:44,798
by now so 55 number one sixty number two

10709
07:14:44,798 --> 07:14:46,638
number one is less than number two this

10710
07:14:46,638 --> 07:14:48,320
is going to be true

10711
07:14:48,320 --> 07:14:51,040
so the test here is going to succeed and

10712
07:14:51,040 --> 07:14:52,558
we are going to fall in here that's what

10713
07:14:52,558 --> 07:14:55,120
we're going to say we're going to weld

10714
07:14:55,120 --> 07:14:57,520
with gcc as usual

10715
07:14:57,520 --> 07:15:01,280
and i'm going to clear and run rooster

10716
07:15:01,280 --> 07:15:02,798
and you're going to see that this is the

10717
07:15:02,798 --> 07:15:05,120
output we expect if we change up the

10718
07:15:05,120 --> 07:15:07,040
numbers again let's take this and make

10719
07:15:07,040 --> 07:15:10,718
it a 75 number one so number one

10720
07:15:10,718 --> 07:15:12,638
is less than number two is going to

10721
07:15:12,638 --> 07:15:15,600
evaluate to false the test here is going

10722
07:15:15,600 --> 07:15:18,478
to fail and we are going to fall in this

10723
07:15:18,478 --> 07:15:20,160
block here we're going to fall in the

10724
07:15:20,160 --> 07:15:23,520
else close of our test here we're going

10725
07:15:23,520 --> 07:15:24,478
to say

10726
07:15:24,478 --> 07:15:27,280
75 is not less than

10727
07:15:27,280 --> 07:15:29,600
55 is that what we have in there it's a

10728
07:15:29,600 --> 07:15:32,080
60 but this block here is going to

10729
07:15:32,080 --> 07:15:34,240
execute that's the most important thing

10730
07:15:34,240 --> 07:15:36,080
so we're going to run this and we're

10731
07:15:36,080 --> 07:15:39,360
going to try and clear and run rooster

10732
07:15:39,360 --> 07:15:41,520
we're going to get what we expect this

10733
07:15:41,520 --> 07:15:43,600
is one way we can do this and it is

10734
07:15:43,600 --> 07:15:46,000
really cool let's comment this out and

10735
07:15:46,000 --> 07:15:48,878
see another example and if we go down we

10736
07:15:48,878 --> 07:15:50,240
can see

10737
07:15:50,240 --> 07:15:52,958
the example we saw in the slides which

10738
07:15:52,958 --> 07:15:56,798
was using red green and

10739
07:15:56,798 --> 07:15:57,920
yellow

10740
07:15:57,920 --> 07:16:00,558
to simulate a traffic light

10741
07:16:00,558 --> 07:16:02,958
so what we really want to see here is

10742
07:16:02,958 --> 07:16:05,200
that we can nest stuff but before we do

10743
07:16:05,200 --> 07:16:06,718
that we need to

10744
07:16:06,718 --> 07:16:08,878
try and use these conditions because it

10745
07:16:08,878 --> 07:16:11,840
is just fun so if red is true meaning

10746
07:16:11,840 --> 07:16:14,718
that the red light is on we're going to

10747
07:16:14,718 --> 07:16:16,718
stop if yellow is true we're going to

10748
07:16:16,718 --> 07:16:19,040
slow down if green is true we're going

10749
07:16:19,040 --> 07:16:20,160
to go

10750
07:16:20,160 --> 07:16:23,040
and if we look at what we have here

10751
07:16:23,040 --> 07:16:26,240
red is false green is true false is true

10752
07:16:26,240 --> 07:16:28,638
and a police stop is true police stop is

10753
07:16:28,638 --> 07:16:30,878
not really being used so green is true

10754
07:16:30,878 --> 07:16:32,958
we're going to execute the green

10755
07:16:32,958 --> 07:16:35,200
statement here and we're going to say go

10756
07:16:35,200 --> 07:16:37,200
that's what we're going to say let's try

10757
07:16:37,200 --> 07:16:38,798
and run this

10758
07:16:38,798 --> 07:16:41,280
we're going to build with gcc

10759
07:16:41,280 --> 07:16:43,040
bring this up a little bit so that we

10760
07:16:43,040 --> 07:16:45,200
have some breathing room

10761
07:16:45,200 --> 07:16:47,360
and we're going to clear

10762
07:16:47,360 --> 07:16:49,920
and run rooster and you see that it is

10763
07:16:49,920 --> 07:16:50,878
saying

10764
07:16:50,878 --> 07:16:53,600
go here you can try and change these

10765
07:16:53,600 --> 07:16:56,240
boolean variables to different things

10766
07:16:56,240 --> 07:16:58,478
and see what is printed out here this is

10767
07:16:58,478 --> 07:17:00,958
a great way to learn but what we really

10768
07:17:00,958 --> 07:17:02,638
want to try here

10769
07:17:02,638 --> 07:17:05,200
is nested statements and let's go down

10770
07:17:05,200 --> 07:17:07,760
and do that okay again we don't want

10771
07:17:07,760 --> 07:17:09,920
what we have on top here to disturb us

10772
07:17:09,920 --> 07:17:11,600
so we're going to

10773
07:17:11,600 --> 07:17:14,398
comment this out and we are going to go

10774
07:17:14,398 --> 07:17:17,040
down and put in our code

10775
07:17:17,040 --> 07:17:20,160
for nested if statements

10776
07:17:20,160 --> 07:17:22,398
so what we're going to say

10777
07:17:22,398 --> 07:17:25,520
is if the light is green we should go

10778
07:17:25,520 --> 07:17:28,080
but the police officer has the right to

10779
07:17:28,080 --> 07:17:30,478
stop us even if the light is green at

10780
07:17:30,478 --> 07:17:32,638
least these are the laws in the country

10781
07:17:32,638 --> 07:17:34,878
where i leave so we have a variable

10782
07:17:34,878 --> 07:17:37,840
called police stop here so if they stop

10783
07:17:37,840 --> 07:17:40,000
you even if the light is green you're

10784
07:17:40,000 --> 07:17:41,840
going to stop and we're going to see

10785
07:17:41,840 --> 07:17:43,920
what we see here so if the light is

10786
07:17:43,920 --> 07:17:45,840
green we're going to fall in this body

10787
07:17:45,840 --> 07:17:49,040
again and we're going to run this inside

10788
07:17:49,040 --> 07:17:51,920
or nested if statement and if the

10789
07:17:51,920 --> 07:17:53,520
officer has stopped us we're going to

10790
07:17:53,520 --> 07:17:54,398
stop

10791
07:17:54,398 --> 07:17:56,000
if they haven't stopped us we're going

10792
07:17:56,000 --> 07:17:59,200
to go and go on our merry way this is

10793
07:17:59,200 --> 07:18:01,200
what we want to see here and again i

10794
07:18:01,200 --> 07:18:03,840
want you to stop for a moment try to run

10795
07:18:03,840 --> 07:18:06,638
this through your brain and try to come

10796
07:18:06,638 --> 07:18:09,040
up with the value we're going to see

10797
07:18:09,040 --> 07:18:11,440
when we run this in visual studio code

10798
07:18:11,440 --> 07:18:12,878
pause for a minute

10799
07:18:12,878 --> 07:18:15,040
we're going to run this

10800
07:18:15,040 --> 07:18:17,600
we're going to build with gcc

10801
07:18:17,600 --> 07:18:20,000
and we're going to run a program and you

10802
07:18:20,000 --> 07:18:22,718
see that police officer stops

10803
07:18:22,718 --> 07:18:23,920
stop

10804
07:18:23,920 --> 07:18:25,520
and why is that

10805
07:18:25,520 --> 07:18:28,638
the light is green okay so we we should

10806
07:18:28,638 --> 07:18:31,680
usually go but the police stop variable

10807
07:18:31,680 --> 07:18:34,878
here is also true so if we fall in here

10808
07:18:34,878 --> 07:18:37,040
this is going to execute and it is going

10809
07:18:37,040 --> 07:18:39,920
to succeed and we are going to say stop

10810
07:18:39,920 --> 07:18:42,558
and once this statement executes the

10811
07:18:42,558 --> 07:18:45,120
else statement is not going to execute

10812
07:18:45,120 --> 07:18:48,240
control is going to fall outside here

10813
07:18:48,240 --> 07:18:50,080
and we're going to keep doing whatever

10814
07:18:50,080 --> 07:18:53,200
we have outside this if statement here

10815
07:18:53,200 --> 07:18:56,160
this is really critical to understand if

10816
07:18:56,160 --> 07:18:57,120
one

10817
07:18:57,120 --> 07:19:00,320
block of a statement succeeds all the

10818
07:19:00,320 --> 07:19:03,040
others are not going to execute and try

10819
07:19:03,040 --> 07:19:05,680
to really understand this okay we have

10820
07:19:05,680 --> 07:19:07,680
seen this we can now comment this out

10821
07:19:07,680 --> 07:19:10,718
because we have something else i want to

10822
07:19:10,718 --> 07:19:11,760
show you

10823
07:19:11,760 --> 07:19:13,680
we're going to comment this out and

10824
07:19:13,680 --> 07:19:16,160
that's that you can combine the if

10825
07:19:16,160 --> 07:19:18,080
statements here or conditional

10826
07:19:18,080 --> 07:19:21,040
programming with the logical operators

10827
07:19:21,040 --> 07:19:23,440
we have learned about earlier in the

10828
07:19:23,440 --> 07:19:25,920
course and do really powerful stuff for

10829
07:19:25,920 --> 07:19:28,160
example here we can actually

10830
07:19:28,160 --> 07:19:31,200
not use this nested statement and do

10831
07:19:31,200 --> 07:19:33,600
this in one go like this and i think

10832
07:19:33,600 --> 07:19:35,920
this is much cleaner so we're going to

10833
07:19:35,920 --> 07:19:38,320
say if the light is green and the police

10834
07:19:38,320 --> 07:19:40,958
officer hasn't stopped us we're going to

10835
07:19:40,958 --> 07:19:43,440
go and if they have stopped us we're

10836
07:19:43,440 --> 07:19:44,958
going to stop and you're going to see

10837
07:19:44,958 --> 07:19:46,798
that we're going to get exactly the same

10838
07:19:46,798 --> 07:19:49,120
result that we had before but this is

10839
07:19:49,120 --> 07:19:51,200
really much more compact so we're going

10840
07:19:51,200 --> 07:19:53,840
to run and see the result of this and

10841
07:19:53,840 --> 07:19:56,718
we're going to clear clear

10842
07:19:56,718 --> 07:19:58,638
and run rooster you're going to see that

10843
07:19:58,638 --> 07:20:00,320
they're going to stop us and this is

10844
07:20:00,320 --> 07:20:02,478
really cool you can go

10845
07:20:02,478 --> 07:20:04,478
up again and change up these variables

10846
07:20:04,478 --> 07:20:07,200
to really anything you want and see what

10847
07:20:07,200 --> 07:20:09,120
you get trying to really understand what

10848
07:20:09,120 --> 07:20:12,320
is going on here it is not difficult and

10849
07:20:12,320 --> 07:20:14,958
the if statement is really fundamental

10850
07:20:14,958 --> 07:20:17,600
to any programming you're going to do so

10851
07:20:17,600 --> 07:20:19,120
this is really all we set up to do in

10852
07:20:19,120 --> 07:20:21,360
this lecture to learn about conditional

10853
07:20:21,360 --> 07:20:24,160
programming using the if statement it is

10854
07:20:24,160 --> 07:20:26,240
a powerful thing and you're going to see

10855
07:20:26,240 --> 07:20:29,360
it all over your software development

10856
07:20:29,360 --> 07:20:31,280
career so make sure you really

10857
07:20:31,280 --> 07:20:33,200
understand this but even if it's not

10858
07:20:33,200 --> 07:20:35,040
clear now we're going to have a chance

10859
07:20:35,040 --> 07:20:37,200
to do many examples and you're going to

10860
07:20:37,200 --> 07:20:40,000
really understand what this is all about

10861
07:20:40,000 --> 07:20:41,280
we are going to stop here in this

10862
07:20:41,280 --> 07:20:43,280
lecture the next one we're going to see

10863
07:20:43,280 --> 07:20:46,798
how we can use the else if close

10864
07:20:46,798 --> 07:20:49,120
go ahead and finish up here and meet me

10865
07:20:49,120 --> 07:20:50,878
there in this lecture we're going to

10866
07:20:50,878 --> 07:20:54,000
learn about the else if close that you

10867
07:20:54,000 --> 07:20:57,440
can attach to your if statement

10868
07:20:57,440 --> 07:20:59,440
and that's going to allow you to test

10869
07:20:59,440 --> 07:21:01,680
for several conditions in your if

10870
07:21:01,680 --> 07:21:02,798
statement

10871
07:21:02,798 --> 07:21:03,600
and

10872
07:21:03,600 --> 07:21:06,558
to really understand this suppose we are

10873
07:21:06,558 --> 07:21:09,600
building a drawing application and at

10874
07:21:09,600 --> 07:21:12,240
any given moment the user might be using

10875
07:21:12,240 --> 07:21:14,958
the pan or the marker or the eraser

10876
07:21:14,958 --> 07:21:17,040
already whatever tool that it is we

10877
07:21:17,040 --> 07:21:19,920
provide in our application

10878
07:21:19,920 --> 07:21:22,320
and if we want to draw

10879
07:21:22,320 --> 07:21:24,718
we need to know which tool is currently

10880
07:21:24,718 --> 07:21:27,360
selected by the user and we can do a

10881
07:21:27,360 --> 07:21:29,920
piece of logic like this we can have the

10882
07:21:29,920 --> 07:21:32,958
tool stored somewhere in our application

10883
07:21:32,958 --> 07:21:35,200
and when we get to the moment where we

10884
07:21:35,200 --> 07:21:36,878
want to do something for example when

10885
07:21:36,878 --> 07:21:38,878
the user clicks with the mouse and they

10886
07:21:38,878 --> 07:21:41,440
want to drag and start doing things then

10887
07:21:41,440 --> 07:21:44,000
we're going to test for the current tool

10888
07:21:44,000 --> 07:21:45,520
if the tool is the pan we're going to

10889
07:21:45,520 --> 07:21:47,920
use the settings for the pen if the tool

10890
07:21:47,920 --> 07:21:49,280
is the marker we're going to use the

10891
07:21:49,280 --> 07:21:51,040
settings of the marker and we're going

10892
07:21:51,040 --> 07:21:53,280
to keep doing this and select

10893
07:21:53,280 --> 07:21:56,240
one tool that is actually selected as

10894
07:21:56,240 --> 07:21:58,638
the current tool by the user and when

10895
07:21:58,638 --> 07:22:00,558
you do something like this only one

10896
07:22:00,558 --> 07:22:03,680
block in this whole chain of statements

10897
07:22:03,680 --> 07:22:06,638
is going to execute so for example if we

10898
07:22:06,638 --> 07:22:09,440
have the marker as the current tool the

10899
07:22:09,440 --> 07:22:11,520
code inside this block is going to

10900
07:22:11,520 --> 07:22:14,398
execute and say active tool is marker

10901
07:22:14,398 --> 07:22:17,280
but nothing else in this block is going

10902
07:22:17,280 --> 07:22:20,398
to execute after we run this statement

10903
07:22:20,398 --> 07:22:22,878
control is going to jump at the end of

10904
07:22:22,878 --> 07:22:25,680
this whole chain of if and else if

10905
07:22:25,680 --> 07:22:27,600
statements here i really hope you

10906
07:22:27,600 --> 07:22:29,920
understand this and uh this is really

10907
07:22:29,920 --> 07:22:31,920
powerful stuff for example

10908
07:22:31,920 --> 07:22:34,000
this is one of the applications i have

10909
07:22:34,000 --> 07:22:36,398
done in one of my advanced course about

10910
07:22:36,398 --> 07:22:39,040
qt and c plus qt is a framework that

10911
07:22:39,040 --> 07:22:40,478
allows you to do graphical user

10912
07:22:40,478 --> 07:22:42,478
interfaces like this and you can build

10913
07:22:42,478 --> 07:22:44,718
applications like this so what i did

10914
07:22:44,718 --> 07:22:47,920
here is i did the exact same thing that

10915
07:22:47,920 --> 07:22:50,398
we have here i had the chain of if and

10916
07:22:50,398 --> 07:22:53,600
else if statements and whatever tool

10917
07:22:53,600 --> 07:22:56,320
was selected as the current tool was

10918
07:22:56,320 --> 07:22:58,478
used to draw things on the canvas here

10919
07:22:58,478 --> 07:23:00,240
for example if the current tool was the

10920
07:23:00,240 --> 07:23:02,478
pen and the pen is this little pen tool

10921
07:23:02,478 --> 07:23:04,638
here if it is active we're going to draw

10922
07:23:04,638 --> 07:23:07,120
things like hello world here if we have

10923
07:23:07,120 --> 07:23:08,798
the star selected we're going to draw

10924
07:23:08,798 --> 07:23:11,040
stars if we have the rectangle selected

10925
07:23:11,040 --> 07:23:12,878
we're going to draw rectangles we could

10926
07:23:12,878 --> 07:23:15,120
do all kinds of crazy things using this

10927
07:23:15,120 --> 07:23:17,520
piece of logic here but it is powerful

10928
07:23:17,520 --> 07:23:19,520
stuff and you really have to make sure

10929
07:23:19,520 --> 07:23:21,680
you understand this so this is how the

10930
07:23:21,680 --> 07:23:24,080
else if clause can really help you the

10931
07:23:24,080 --> 07:23:26,240
main thing is to allow you to test for

10932
07:23:26,240 --> 07:23:28,398
several different conditions you could

10933
07:23:28,398 --> 07:23:30,718
do this with a lot of if statements but

10934
07:23:30,718 --> 07:23:32,398
that's not going to be really cool it's

10935
07:23:32,398 --> 07:23:34,878
going to be ugly and hard to read this

10936
07:23:34,878 --> 07:23:36,398
is what you should do

10937
07:23:36,398 --> 07:23:38,160
now that you have an idea about this

10938
07:23:38,160 --> 07:23:39,680
we're going to head to visual studio

10939
07:23:39,680 --> 07:23:41,840
code and actually see this in action

10940
07:23:41,840 --> 07:23:44,718
here we are in our working directory

10941
07:23:44,718 --> 07:23:47,040
we're going to grab our template project

10942
07:23:47,040 --> 07:23:49,200
pretty quick and we're going to use the

10943
07:23:49,200 --> 07:23:51,600
else if project here that's our current

10944
07:23:51,600 --> 07:23:54,240
project so we're going to do that and

10945
07:23:54,240 --> 07:23:56,718
open this up in visual studio code as we

10946
07:23:56,718 --> 07:23:58,638
always do we're going to open this up

10947
07:23:58,638 --> 07:24:01,280
we're going to open main cpp and we're

10948
07:24:01,280 --> 07:24:03,520
going to remove what we don't need

10949
07:24:03,520 --> 07:24:05,600
the first thing i am going to do is to

10950
07:24:05,600 --> 07:24:08,558
put in a set of variables that are going

10951
07:24:08,558 --> 07:24:10,878
to store our tools and we can do

10952
07:24:10,878 --> 07:24:12,478
something like this we have a variable

10953
07:24:12,478 --> 07:24:15,440
for pen marker eraser rectangle circle

10954
07:24:15,440 --> 07:24:17,920
and ellipse i have to say that this is

10955
07:24:17,920 --> 07:24:19,600
not the way to go about this we're going

10956
07:24:19,600 --> 07:24:21,280
to learn about another way we can do

10957
07:24:21,280 --> 07:24:23,360
this but that's going to be there in the

10958
07:24:23,360 --> 07:24:25,040
course when we have enough tools to

10959
07:24:25,040 --> 07:24:27,280
understand this for now we're just going

10960
07:24:27,280 --> 07:24:29,600
to be happy with this

10961
07:24:29,600 --> 07:24:32,558
okay 10 is going to represent the pan 20

10962
07:24:32,558 --> 07:24:34,558
is going to represent the marker 30 is

10963
07:24:34,558 --> 07:24:36,398
going to represent the razor and we can

10964
07:24:36,398 --> 07:24:38,240
go on until we hit ellipse which is

10965
07:24:38,240 --> 07:24:41,520
represented by 60. now if we go in main

10966
07:24:41,520 --> 07:24:43,760
and set up a variable and call it tool

10967
07:24:43,760 --> 07:24:46,320
for example and initialize it with

10968
07:24:46,320 --> 07:24:48,878
whatever tool we think that the user is

10969
07:24:48,878 --> 07:24:50,798
currently using for example we can use

10970
07:24:50,798 --> 07:24:53,760
circle and initialize this we can set up

10971
07:24:53,760 --> 07:24:57,200
a chain of s and else if statements to

10972
07:24:57,200 --> 07:24:59,600
do whatever it is we want to do when

10973
07:24:59,600 --> 07:25:01,920
this tool here is selected okay we're

10974
07:25:01,920 --> 07:25:04,320
going to go down and put in our code i

10975
07:25:04,320 --> 07:25:06,080
don't want to type all this so i'm going

10976
07:25:06,080 --> 07:25:08,320
to put this up here and if you want you

10977
07:25:08,320 --> 07:25:10,478
can copy the code from the

10978
07:25:10,478 --> 07:25:12,398
resource section the code is going to be

10979
07:25:12,398 --> 07:25:14,160
there you can copy it and paste it in

10980
07:25:14,160 --> 07:25:16,160
here and do things with that okay we

10981
07:25:16,160 --> 07:25:19,120
have a chain of if and else if close is

10982
07:25:19,120 --> 07:25:21,520
in here and the first one is going to

10983
07:25:21,520 --> 07:25:23,920
test and see if the tool is the pan and

10984
07:25:23,920 --> 07:25:26,080
notice that we are using double equal

10985
07:25:26,080 --> 07:25:28,638
signs here this is what you use to test

10986
07:25:28,638 --> 07:25:30,958
for equality you don't use one equal

10987
07:25:30,958 --> 07:25:33,280
sign you have to use two equal signs if

10988
07:25:33,280 --> 07:25:35,040
you use one equal sign that's going to

10989
07:25:35,040 --> 07:25:36,878
be an assignment and this is going to

10990
07:25:36,878 --> 07:25:38,878
always evaluate to true so you don't

10991
07:25:38,878 --> 07:25:41,200
want to do that again to test for

10992
07:25:41,200 --> 07:25:43,200
equality you're going to use double

10993
07:25:43,200 --> 07:25:45,760
equal signs in c plus plus so if the

10994
07:25:45,760 --> 07:25:47,280
current tool is the pen we're going to

10995
07:25:47,280 --> 07:25:49,760
say active tool span if the current tool

10996
07:25:49,760 --> 07:25:51,760
is marker we're going to say that so we

10997
07:25:51,760 --> 07:25:54,080
are basically going to do this for all

10998
07:25:54,080 --> 07:25:57,120
the tools that our application supports

10999
07:25:57,120 --> 07:25:59,600
so what do you think we'll see

11000
07:25:59,600 --> 07:26:01,680
when we run this the active tool is

11001
07:26:01,680 --> 07:26:02,638
circle

11002
07:26:02,638 --> 07:26:05,600
so we should print active tool is circle

11003
07:26:05,600 --> 07:26:06,478
here

11004
07:26:06,478 --> 07:26:08,558
let's try this out we're going to open

11005
07:26:08,558 --> 07:26:10,160
the terminal so that we can see the

11006
07:26:10,160 --> 07:26:12,478
output nicely and we're going to world

11007
07:26:12,478 --> 07:26:14,958
with gcc and the build is going to go

11008
07:26:14,958 --> 07:26:16,798
through if we run this we're going to

11009
07:26:16,798 --> 07:26:19,760
see active tool is circle you can go up

11010
07:26:19,760 --> 07:26:21,520
here and change the tool to rectangle

11011
07:26:21,520 --> 07:26:23,680
for example if you build again you're

11012
07:26:23,680 --> 07:26:26,000
going to see that the correct block of

11013
07:26:26,000 --> 07:26:27,840
code is going to be executed we're going

11014
07:26:27,840 --> 07:26:30,718
to clear and run rooster active tool is

11015
07:26:30,718 --> 07:26:33,280
rectangle if we try to put in something

11016
07:26:33,280 --> 07:26:35,360
that doesn't exist let's say let's put

11017
07:26:35,360 --> 07:26:36,478
in bird

11018
07:26:36,478 --> 07:26:39,280
just to mess with our compiler here

11019
07:26:39,280 --> 07:26:40,638
we're going to get a compiler error

11020
07:26:40,638 --> 07:26:43,520
because that type is not known by

11021
07:26:43,520 --> 07:26:45,840
our code here so we're going to get bird

11022
07:26:45,840 --> 07:26:47,760
was not declared in this scope we don't

11023
07:26:47,760 --> 07:26:49,760
know what it is you have to put in

11024
07:26:49,760 --> 07:26:52,478
whatever thing you have declared

11025
07:26:52,478 --> 07:26:55,680
beforehand here so if we put in a razor

11026
07:26:55,680 --> 07:26:58,558
for example we're going to weld with gcc

11027
07:26:58,558 --> 07:27:00,160
the world is going to go through going

11028
07:27:00,160 --> 07:27:02,558
to clear run rooster the tool is going

11029
07:27:02,558 --> 07:27:04,958
to be eraser and this is exactly what we

11030
07:27:04,958 --> 07:27:07,680
expect again the main message in this

11031
07:27:07,680 --> 07:27:10,398
lecture is that you can use this else if

11032
07:27:10,398 --> 07:27:12,558
close if you have several conditions

11033
07:27:12,558 --> 07:27:15,040
that you want to test for just like we

11034
07:27:15,040 --> 07:27:17,760
have here and again one of these blocks

11035
07:27:17,760 --> 07:27:20,558
is going to execute and once we hit the

11036
07:27:20,558 --> 07:27:23,120
end of this chain of if and else if

11037
07:27:23,120 --> 07:27:26,000
closes we're going to fall here and code

11038
07:27:26,000 --> 07:27:28,320
after that is going to execute so let's

11039
07:27:28,320 --> 07:27:30,398
say moving on so that you can really see

11040
07:27:30,398 --> 07:27:33,760
this here very clear moving on and if we

11041
07:27:33,760 --> 07:27:36,398
bolt this we're going to see only one

11042
07:27:36,398 --> 07:27:39,760
block from this whole chain and once one

11043
07:27:39,760 --> 07:27:42,398
block executes control is going to go

11044
07:27:42,398 --> 07:27:45,120
after all this chain and execute

11045
07:27:45,120 --> 07:27:47,040
whatever is after that so we're going to

11046
07:27:47,040 --> 07:27:50,240
say moving on after we print that the

11047
07:27:50,240 --> 07:27:52,878
active tool is eraser here i think we

11048
07:27:52,878 --> 07:27:55,440
have built this so let's

11049
07:27:55,440 --> 07:27:58,160
try and run this and you see active tool

11050
07:27:58,160 --> 07:28:01,680
is razer and moving on so after we print

11051
07:28:01,680 --> 07:28:04,798
the code from the eraser block we're not

11052
07:28:04,798 --> 07:28:07,360
going to execute rectangle or a circle

11053
07:28:07,360 --> 07:28:10,080
or ellipse it's going to jump at the end

11054
07:28:10,080 --> 07:28:12,398
of this whole block this is really

11055
07:28:12,398 --> 07:28:14,000
what i want to be

11056
07:28:14,000 --> 07:28:16,000
super clear and again make sure you

11057
07:28:16,000 --> 07:28:18,080
understand the syntax here the else if

11058
07:28:18,080 --> 07:28:20,478
statement is followed by a set of

11059
07:28:20,478 --> 07:28:23,360
parentheses and inside the parenthesis

11060
07:28:23,360 --> 07:28:25,760
we have the condition we want to test

11061
07:28:25,760 --> 07:28:28,638
for the condition has to evaluate to

11062
07:28:28,638 --> 07:28:31,120
boolean and after that we have the block

11063
07:28:31,120 --> 07:28:33,520
of code that we want to execute and this

11064
07:28:33,520 --> 07:28:35,840
is really all you have to do to get this

11065
07:28:35,840 --> 07:28:38,240
to work to your advantage

11066
07:28:38,240 --> 07:28:39,600
we are going to stop here in this

11067
07:28:39,600 --> 07:28:41,280
lecture in the next one we're going to

11068
07:28:41,280 --> 07:28:43,440
learn about switch

11069
07:28:43,440 --> 07:28:45,840
go ahead and finish up here and meet me

11070
07:28:45,840 --> 07:28:46,798
there

11071
07:28:46,798 --> 07:28:48,240
in this lecture we're going to learn

11072
07:28:48,240 --> 07:28:51,520
about the switch statement and this is

11073
07:28:51,520 --> 07:28:54,398
an alternative way to do what we did

11074
07:28:54,398 --> 07:28:56,958
with these else if clauses in the last

11075
07:28:56,958 --> 07:28:59,440
lecture basically testing for several

11076
07:28:59,440 --> 07:29:01,280
different conditions but it's going to

11077
07:29:01,280 --> 07:29:03,920
be in a much more compact way than what

11078
07:29:03,920 --> 07:29:06,000
we did in the last lecture we are going

11079
07:29:06,000 --> 07:29:08,398
to be using the exact same example we

11080
07:29:08,398 --> 07:29:10,558
did in the last lecture and we're going

11081
07:29:10,558 --> 07:29:12,798
to look at the switch statement and how

11082
07:29:12,798 --> 07:29:15,280
it works in c plus plus and this is how

11083
07:29:15,280 --> 07:29:17,760
it works we have our variable which is

11084
07:29:17,760 --> 07:29:20,000
going to store the current tool and

11085
07:29:20,000 --> 07:29:21,920
we're going to say switch

11086
07:29:21,920 --> 07:29:23,840
inside the parenthesis here we're going

11087
07:29:23,840 --> 07:29:24,558
to

11088
07:29:24,558 --> 07:29:26,478
pass the variable that we're going to be

11089
07:29:26,478 --> 07:29:29,200
basically switching on or testing the

11090
07:29:29,200 --> 07:29:30,798
conditions on

11091
07:29:30,798 --> 07:29:33,280
and inside the block we're going to be

11092
07:29:33,280 --> 07:29:36,160
basically testing for each case so we're

11093
07:29:36,160 --> 07:29:38,160
going to say if the current tool is the

11094
07:29:38,160 --> 07:29:40,160
pan we're going to say case pan we're

11095
07:29:40,160 --> 07:29:42,478
going to put a colon in here and we're

11096
07:29:42,478 --> 07:29:44,558
going to put the code we want to execute

11097
07:29:44,558 --> 07:29:46,000
for the case

11098
07:29:46,000 --> 07:29:48,398
where the current tool is the pan in

11099
07:29:48,398 --> 07:29:51,440
these curly braces here and one thing

11100
07:29:51,440 --> 07:29:53,520
you should notice from the start is this

11101
07:29:53,520 --> 07:29:55,440
break statement here

11102
07:29:55,440 --> 07:29:58,240
this is a statement that tells c plus

11103
07:29:58,240 --> 07:29:59,360
plus

11104
07:29:59,360 --> 07:30:02,718
that after we successfully execute a

11105
07:30:02,718 --> 07:30:05,280
block of code we're going to jump out of

11106
07:30:05,280 --> 07:30:07,760
this switch statement if you omit this

11107
07:30:07,760 --> 07:30:09,360
break statement

11108
07:30:09,360 --> 07:30:12,160
everything after the case that you just

11109
07:30:12,160 --> 07:30:14,638
executed is going to execute and that's

11110
07:30:14,638 --> 07:30:17,120
not probably going to be what you want

11111
07:30:17,120 --> 07:30:19,520
if this is not making sense yet please

11112
07:30:19,520 --> 07:30:21,680
bear with me you're going to see it run

11113
07:30:21,680 --> 07:30:23,600
in visual studio code and you are going

11114
07:30:23,600 --> 07:30:25,920
to understand so what you're going to do

11115
07:30:25,920 --> 07:30:27,520
you're going to put all the tools you

11116
07:30:27,520 --> 07:30:30,478
want to test for in separate cases you

11117
07:30:30,478 --> 07:30:33,680
see here we have marker and after that

11118
07:30:33,680 --> 07:30:36,558
you can put a default case that is going

11119
07:30:36,558 --> 07:30:39,200
to be matched when nothing has been

11120
07:30:39,200 --> 07:30:40,878
matched in whatever it is you have

11121
07:30:40,878 --> 07:30:44,320
tested for in this switch block here and

11122
07:30:44,320 --> 07:30:45,920
when we run this piece of code we're

11123
07:30:45,920 --> 07:30:47,920
going to get exactly the same results

11124
07:30:47,920 --> 07:30:50,240
that we had in the last lecture but

11125
07:30:50,240 --> 07:30:52,160
hopefully you can see that this is much

11126
07:30:52,160 --> 07:30:55,360
more compact than the series of else if

11127
07:30:55,360 --> 07:30:58,000
closes that we had in the last lecture

11128
07:30:58,000 --> 07:31:00,160
again the break statement is really

11129
07:31:00,160 --> 07:31:02,798
useful if you don't put it in c plus

11130
07:31:02,798 --> 07:31:04,958
plus is going to be confused and after

11131
07:31:04,958 --> 07:31:07,280
you hit your successful case

11132
07:31:07,280 --> 07:31:09,120
everything after that is going to be

11133
07:31:09,120 --> 07:31:11,520
executed so the break statement is

11134
07:31:11,520 --> 07:31:14,320
basically telling c plus plus if you hit

11135
07:31:14,320 --> 07:31:17,760
it after a successful case is

11136
07:31:17,760 --> 07:31:19,680
jump out of this switch block because

11137
07:31:19,680 --> 07:31:21,120
you are done you don't have to do

11138
07:31:21,120 --> 07:31:23,520
anything else in here and another thing

11139
07:31:23,520 --> 07:31:26,080
you should know is that the condition

11140
07:31:26,080 --> 07:31:27,840
which is what we have inside this

11141
07:31:27,840 --> 07:31:31,040
parenthesis here can only be an integer

11142
07:31:31,040 --> 07:31:33,840
or an enum so basically it can be ant

11143
07:31:33,840 --> 07:31:36,000
long unsigned or car

11144
07:31:36,000 --> 07:31:38,160
basically every integral type we have

11145
07:31:38,160 --> 07:31:40,798
seen before but it can't be another type

11146
07:31:40,798 --> 07:31:42,958
such as string because that doesn't

11147
07:31:42,958 --> 07:31:45,360
really make sense so be sure to keep

11148
07:31:45,360 --> 07:31:46,398
this in mind

11149
07:31:46,398 --> 07:31:48,478
now that you have an idea about this

11150
07:31:48,478 --> 07:31:50,958
switch statement let's head to visual

11151
07:31:50,958 --> 07:31:53,040
video code and actually see this in

11152
07:31:53,040 --> 07:31:56,320
action here we are in our working folder

11153
07:31:56,320 --> 07:31:58,080
the current project is going to be

11154
07:31:58,080 --> 07:31:59,840
switch so we're going to grab our

11155
07:31:59,840 --> 07:32:02,160
template files and we're going to bring

11156
07:32:02,160 --> 07:32:04,398
that in here i'm going to go up a little

11157
07:32:04,398 --> 07:32:07,120
bit and open this up in visual studio

11158
07:32:07,120 --> 07:32:09,600
code as we always do and we're going to

11159
07:32:09,600 --> 07:32:11,360
open up our main file we're going to get

11160
07:32:11,360 --> 07:32:13,840
rid of what we don't need we are going

11161
07:32:13,840 --> 07:32:16,478
to go outside the main function here and

11162
07:32:16,478 --> 07:32:18,558
put in our tools just like in the last

11163
07:32:18,558 --> 07:32:21,120
lecture we are using integers each one

11164
07:32:21,120 --> 07:32:24,638
is represented by 10 20 30 up to 60 and

11165
07:32:24,638 --> 07:32:26,878
these are the tools we have and i don't

11166
07:32:26,878 --> 07:32:28,638
think i explained this but we are

11167
07:32:28,638 --> 07:32:30,638
flagging them const because we don't

11168
07:32:30,638 --> 07:32:33,040
want them to be modifiable we have seen

11169
07:32:33,040 --> 07:32:36,320
about const earlier in the course we are

11170
07:32:36,320 --> 07:32:38,320
going to jump into main and set up our

11171
07:32:38,320 --> 07:32:40,478
variable it's going to be ant and we're

11172
07:32:40,478 --> 07:32:42,798
going to call it tool and we're going to

11173
07:32:42,798 --> 07:32:44,798
initialize this whatever tool we want

11174
07:32:44,798 --> 07:32:47,440
let's use eraser why not and then we're

11175
07:32:47,440 --> 07:32:49,360
going to put in our switch block we're

11176
07:32:49,360 --> 07:32:50,958
going to say switch

11177
07:32:50,958 --> 07:32:53,440
and if i type this you see that visual

11178
07:32:53,440 --> 07:32:55,280
studio code is going to give me

11179
07:32:55,280 --> 07:32:57,840
intelligence or suggestions on what

11180
07:32:57,840 --> 07:33:00,000
thing i could do one cool thing that

11181
07:33:00,000 --> 07:33:01,840
visual studio code does is give you

11182
07:33:01,840 --> 07:33:03,840
snippets to really help you type things

11183
07:33:03,840 --> 07:33:06,320
out so we can click on this and it is

11184
07:33:06,320 --> 07:33:09,360
going to auto complete a starter version

11185
07:33:09,360 --> 07:33:13,280
of our case and we can type in our

11186
07:33:13,280 --> 07:33:15,840
expression here which is going to be

11187
07:33:15,840 --> 07:33:18,080
what we're going to be switching over so

11188
07:33:18,080 --> 07:33:19,680
we're going to switch over the variable

11189
07:33:19,680 --> 07:33:22,398
tool here and we can put in our cases so

11190
07:33:22,398 --> 07:33:24,798
in our case we're going to start with

11191
07:33:24,798 --> 07:33:26,638
pan which is what we have here so we're

11192
07:33:26,638 --> 07:33:28,478
going to say case pan we're going to

11193
07:33:28,478 --> 07:33:30,638
remove all this

11194
07:33:30,638 --> 07:33:34,000
uh let's remove this and say pen

11195
07:33:34,000 --> 07:33:35,760
i'm going to put a column

11196
07:33:35,760 --> 07:33:37,600
and we're going to put

11197
07:33:37,600 --> 07:33:40,478
a block of code that is going to execute

11198
07:33:40,478 --> 07:33:42,638
when the current tool is the pen and

11199
07:33:42,638 --> 07:33:44,320
we're going to put that in here let's

11200
07:33:44,320 --> 07:33:45,600
bring this

11201
07:33:45,600 --> 07:33:47,920
to the right a little bit and inside the

11202
07:33:47,920 --> 07:33:51,760
block we can say sddc out active tool is

11203
07:33:51,760 --> 07:33:54,240
pan okay so after that we're going to

11204
07:33:54,240 --> 07:33:56,798
put this break statement if it's not

11205
07:33:56,798 --> 07:33:58,638
here we're going to have a problem

11206
07:33:58,638 --> 07:34:00,638
because when the current tool is the pan

11207
07:34:00,638 --> 07:34:03,200
and this code here executes every case

11208
07:34:03,200 --> 07:34:05,200
after that is going to execute and

11209
07:34:05,200 --> 07:34:06,718
that's not what we want we have to

11210
07:34:06,718 --> 07:34:08,798
remember to put this break statement

11211
07:34:08,798 --> 07:34:10,798
here okay so we're going to put in all

11212
07:34:10,798 --> 07:34:12,878
our other cases so we're going to copy

11213
07:34:12,878 --> 07:34:14,000
this

11214
07:34:14,000 --> 07:34:15,680
and look at the next one it's going to

11215
07:34:15,680 --> 07:34:18,398
be marker so we can go on the next line

11216
07:34:18,398 --> 07:34:20,320
and put in marker we're going to paste

11217
07:34:20,320 --> 07:34:22,718
this in we're going to say marker and

11218
07:34:22,718 --> 07:34:25,040
we're going to say active tool is marker

11219
07:34:25,040 --> 07:34:27,280
and we can keep doing the same thing

11220
07:34:27,280 --> 07:34:29,520
we're going to go download them and

11221
07:34:29,520 --> 07:34:32,000
paste this in the next one is going to

11222
07:34:32,000 --> 07:34:34,160
be eraser so let's do that we're going

11223
07:34:34,160 --> 07:34:36,240
to say eraser and we're going to say

11224
07:34:36,240 --> 07:34:38,718
current tool is razer and we're going to

11225
07:34:38,718 --> 07:34:40,478
go down again

11226
07:34:40,478 --> 07:34:42,718
i am doing this live because it really

11227
07:34:42,718 --> 07:34:46,000
is important for you to see me type this

11228
07:34:46,000 --> 07:34:47,840
otherwise you may be confused because

11229
07:34:47,840 --> 07:34:50,558
this is a slightly confusing construct

11230
07:34:50,558 --> 07:34:54,160
we have in c plus plus the next one is

11231
07:34:54,160 --> 07:34:56,638
rectangle so we're going to use that and

11232
07:34:56,638 --> 07:34:58,160
we're going to say current tool is

11233
07:34:58,160 --> 07:35:01,520
rectangle the next one is going to be

11234
07:35:01,520 --> 07:35:03,840
circle and ellipse so let's do that

11235
07:35:03,840 --> 07:35:05,440
we're going to put in circle we're going

11236
07:35:05,440 --> 07:35:08,320
to go down and paste this in and bring

11237
07:35:08,320 --> 07:35:10,000
this back a little bit

11238
07:35:10,000 --> 07:35:12,160
and i'm going to say circle and we're

11239
07:35:12,160 --> 07:35:15,440
going to go down and put the next one in

11240
07:35:15,440 --> 07:35:17,680
which is going to be ellipse and after

11241
07:35:17,680 --> 07:35:20,638
that notice that video studio code also

11242
07:35:20,638 --> 07:35:23,280
inserted a default block and this is a

11243
07:35:23,280 --> 07:35:26,080
block that is going to execute when none

11244
07:35:26,080 --> 07:35:27,840
of the cases here

11245
07:35:27,840 --> 07:35:29,200
is head

11246
07:35:29,200 --> 07:35:31,760
so this is really important so you can

11247
07:35:31,760 --> 07:35:34,320
also add a block of code

11248
07:35:34,320 --> 07:35:37,520
and say no match found okay so we want

11249
07:35:37,520 --> 07:35:39,360
to see this print out and we're going to

11250
07:35:39,360 --> 07:35:41,200
try this out in a minute

11251
07:35:41,200 --> 07:35:43,840
okay after we do this we should get this

11252
07:35:43,840 --> 07:35:46,478
to work and do whatever we were doing in

11253
07:35:46,478 --> 07:35:48,958
the last lecture so the current tool is

11254
07:35:48,958 --> 07:35:50,718
going to be razer

11255
07:35:50,718 --> 07:35:52,638
the block here is going to be matched so

11256
07:35:52,638 --> 07:35:54,798
code here is going to execute

11257
07:35:54,798 --> 07:35:56,398
after that we're going to meet this

11258
07:35:56,398 --> 07:35:59,440
break and what it's really saying is

11259
07:35:59,440 --> 07:36:01,600
you have done what you have to do jump

11260
07:36:01,600 --> 07:36:03,840
out of this switch block here and we're

11261
07:36:03,840 --> 07:36:05,360
going to go to the end of this switch

11262
07:36:05,360 --> 07:36:07,120
block and we're going to execute

11263
07:36:07,120 --> 07:36:09,520
whatever is after that so just like in

11264
07:36:09,520 --> 07:36:11,840
the last lecture we can say moving on

11265
07:36:11,840 --> 07:36:14,638
and if we execute the program as we have

11266
07:36:14,638 --> 07:36:15,920
it now

11267
07:36:15,920 --> 07:36:18,958
it's going to say active tool is razor

11268
07:36:18,958 --> 07:36:21,600
and it's going to print moving on

11269
07:36:21,600 --> 07:36:23,760
let's bring up the terminal so that we

11270
07:36:23,760 --> 07:36:25,840
can really see this and we're going to

11271
07:36:25,840 --> 07:36:28,398
build with gcc the world is going to be

11272
07:36:28,398 --> 07:36:31,520
good and if we run rooster let's clear a

11273
07:36:31,520 --> 07:36:33,600
bit we're going to see that active tool

11274
07:36:33,600 --> 07:36:36,240
is a razor and we are moving on this is

11275
07:36:36,240 --> 07:36:38,160
really cool and it is exactly the same

11276
07:36:38,160 --> 07:36:39,600
thing we had

11277
07:36:39,600 --> 07:36:42,798
in the last lecture but now we are using

11278
07:36:42,798 --> 07:36:45,680
a much cleaner construct which switch

11279
07:36:45,680 --> 07:36:48,160
provides okay we can try to change the

11280
07:36:48,160 --> 07:36:50,320
tool and see that this really works we

11281
07:36:50,320 --> 07:36:52,320
can put in circle

11282
07:36:52,320 --> 07:36:54,798
why not i'm going to build with gcc the

11283
07:36:54,798 --> 07:36:57,200
world is going to go through as you see

11284
07:36:57,200 --> 07:36:59,840
here and if we run rooster we're going

11285
07:36:59,840 --> 07:37:01,760
to see active tool a circle we are

11286
07:37:01,760 --> 07:37:03,600
moving on you can try and change this

11287
07:37:03,600 --> 07:37:06,160
however you want if we put in ellipse

11288
07:37:06,160 --> 07:37:08,160
and world again we're going to build

11289
07:37:08,160 --> 07:37:11,200
with gcc and if we run we're going to

11290
07:37:11,200 --> 07:37:14,718
get active tool is pan and moving on why

11291
07:37:14,718 --> 07:37:17,040
is that ellipse we are saying active

11292
07:37:17,040 --> 07:37:19,600
tool is pen we didn't change that so we

11293
07:37:19,600 --> 07:37:22,878
just code a really bad bag here so let's

11294
07:37:22,878 --> 07:37:25,280
fix this and we're going to build again

11295
07:37:25,280 --> 07:37:27,600
i'm glad i found this so we're going to

11296
07:37:27,600 --> 07:37:29,840
clear and rooster

11297
07:37:29,840 --> 07:37:31,600
and we're going to see active tool is

11298
07:37:31,600 --> 07:37:33,840
ellipse and we are moving on

11299
07:37:33,840 --> 07:37:36,478
okay so let's see what could happen

11300
07:37:36,478 --> 07:37:40,160
if you forgot your break statement after

11301
07:37:40,160 --> 07:37:43,120
your case here so the current tool is

11302
07:37:43,120 --> 07:37:44,478
ellipse

11303
07:37:44,478 --> 07:37:46,798
and it is the last thing we have in here

11304
07:37:46,798 --> 07:37:49,040
so it's not a good test case

11305
07:37:49,040 --> 07:37:51,040
what i am going to do

11306
07:37:51,040 --> 07:37:53,520
is make the current tool the pen or the

11307
07:37:53,520 --> 07:37:55,600
marker let's use marker that's going to

11308
07:37:55,600 --> 07:37:57,040
do

11309
07:37:57,040 --> 07:37:59,120
and i am going to remove the break

11310
07:37:59,120 --> 07:38:01,360
statement here

11311
07:38:01,360 --> 07:38:03,760
okay so and i am going to remove all the

11312
07:38:03,760 --> 07:38:07,120
bread statements we have until we hit

11313
07:38:07,120 --> 07:38:08,478
the

11314
07:38:08,478 --> 07:38:10,558
last default

11315
07:38:10,558 --> 07:38:11,600
case

11316
07:38:11,600 --> 07:38:13,360
so we're going to go down

11317
07:38:13,360 --> 07:38:16,000
and we're even going to remove that for

11318
07:38:16,000 --> 07:38:18,718
the default case here

11319
07:38:18,718 --> 07:38:20,958
and if we both we're going to build fine

11320
07:38:20,958 --> 07:38:22,558
you're going to see that the world was

11321
07:38:22,558 --> 07:38:25,040
good but if we run this try to guess

11322
07:38:25,040 --> 07:38:26,798
what we're going to get the current

11323
07:38:26,798 --> 07:38:29,680
stool is the marker so we should print

11324
07:38:29,680 --> 07:38:30,798
marker

11325
07:38:30,798 --> 07:38:34,080
and hit the end of the switch block and

11326
07:38:34,080 --> 07:38:37,280
do moving on but let's see what we get

11327
07:38:37,280 --> 07:38:39,600
did we build let's build again just to

11328
07:38:39,600 --> 07:38:42,558
be sure so we're going to run rooster

11329
07:38:42,558 --> 07:38:44,398
and notice what happens

11330
07:38:44,398 --> 07:38:46,798
active tool is marker active thought is

11331
07:38:46,798 --> 07:38:48,878
eraser active tool is rectangle we

11332
07:38:48,878 --> 07:38:50,000
basically

11333
07:38:50,000 --> 07:38:53,200
print every other case after the macro

11334
07:38:53,200 --> 07:38:54,798
case is head

11335
07:38:54,798 --> 07:38:57,440
and if we try to change this for example

11336
07:38:57,440 --> 07:39:00,000
not use marker and use eraser let's

11337
07:39:00,000 --> 07:39:01,760
change this you're going to see that

11338
07:39:01,760 --> 07:39:02,958
we're going to

11339
07:39:02,958 --> 07:39:05,520
match the eraser case

11340
07:39:05,520 --> 07:39:07,840
and everything after that is also going

11341
07:39:07,840 --> 07:39:10,080
to execute and it is not what you want

11342
07:39:10,080 --> 07:39:12,398
so let's clear and run rooster you're

11343
07:39:12,398 --> 07:39:14,398
going to see eraser rectangle circle

11344
07:39:14,398 --> 07:39:16,798
ellipse and no match found so you have

11345
07:39:16,798 --> 07:39:18,958
ready to remember to put in this brick

11346
07:39:18,958 --> 07:39:21,520
statement i am going to hit ctrl z a

11347
07:39:21,520 --> 07:39:24,240
couple of times and bring those in and i

11348
07:39:24,240 --> 07:39:26,558
think this is enough we have to hit

11349
07:39:26,558 --> 07:39:29,440
again so that marker also has it and if

11350
07:39:29,440 --> 07:39:31,360
we run now we're going to get what we

11351
07:39:31,360 --> 07:39:33,840
expect let's try to use an eraser again

11352
07:39:33,840 --> 07:39:36,558
and if we both again and clear and run

11353
07:39:36,558 --> 07:39:38,718
rooster we're going to see active tool

11354
07:39:38,718 --> 07:39:41,120
is razer and we are moving on

11355
07:39:41,120 --> 07:39:43,200
this is what we expect okay this is

11356
07:39:43,200 --> 07:39:45,440
really how you work with a switch

11357
07:39:45,440 --> 07:39:47,200
block you have to pass in your

11358
07:39:47,200 --> 07:39:50,000
expression or your test case and you

11359
07:39:50,000 --> 07:39:52,718
catch each case using this case syntax

11360
07:39:52,718 --> 07:39:55,520
here you say case you pass in whatever

11361
07:39:55,520 --> 07:39:57,200
it is you want to match and you put a

11362
07:39:57,200 --> 07:39:59,680
column and you put your code inside this

11363
07:39:59,680 --> 07:40:02,638
block here and remember after each case

11364
07:40:02,638 --> 07:40:05,440
you have to add this break otherwise

11365
07:40:05,440 --> 07:40:07,120
everything else after this is going to

11366
07:40:07,120 --> 07:40:09,600
execute and it is not going to be what

11367
07:40:09,600 --> 07:40:12,478
you want before i let you go i want to

11368
07:40:12,478 --> 07:40:14,240
show you that you can actually group

11369
07:40:14,240 --> 07:40:16,878
these case statements if this is what is

11370
07:40:16,878 --> 07:40:19,680
making sense for your application so for

11371
07:40:19,680 --> 07:40:21,200
example

11372
07:40:21,200 --> 07:40:22,080
for

11373
07:40:22,080 --> 07:40:25,520
rectangle circle and ellipse

11374
07:40:25,520 --> 07:40:27,760
this can be grouped into the group of

11375
07:40:27,760 --> 07:40:28,798
shapes

11376
07:40:28,798 --> 07:40:31,280
so we can actually say

11377
07:40:31,280 --> 07:40:33,440
case rectangle

11378
07:40:33,440 --> 07:40:36,478
and uh put them on different lines

11379
07:40:36,478 --> 07:40:39,760
something like this so let's delete this

11380
07:40:39,760 --> 07:40:41,920
and say case rectangle

11381
07:40:41,920 --> 07:40:43,680
and we're going to delete the other

11382
07:40:43,680 --> 07:40:44,878
things

11383
07:40:44,878 --> 07:40:46,080
and say

11384
07:40:46,080 --> 07:40:48,878
case circle just like this and we're

11385
07:40:48,878 --> 07:40:51,920
going to say drawing shape i think this

11386
07:40:51,920 --> 07:40:54,798
syntax is supported in c plus plus okay

11387
07:40:54,798 --> 07:40:57,760
so let's try in world

11388
07:40:57,760 --> 07:41:01,520
and uh we're going to world with gcc

11389
07:41:01,520 --> 07:41:03,920
and the world is going to be good so if

11390
07:41:03,920 --> 07:41:06,000
we have a razor which is what we have in

11391
07:41:06,000 --> 07:41:08,398
here we're going to say drawing shape

11392
07:41:08,398 --> 07:41:10,240
let's clear

11393
07:41:10,240 --> 07:41:12,240
and run rooster

11394
07:41:12,240 --> 07:41:14,000
you're going to see drawing shapes

11395
07:41:14,000 --> 07:41:17,040
moving on we have grouped different

11396
07:41:17,040 --> 07:41:21,040
cases and handles them with one block

11397
07:41:21,040 --> 07:41:23,280
and this may come in handy in some

11398
07:41:23,280 --> 07:41:24,878
situations

11399
07:41:24,878 --> 07:41:26,558
one thing you should keep in mind is

11400
07:41:26,558 --> 07:41:29,120
that there are limitations on what you

11401
07:41:29,120 --> 07:41:32,320
can use as an expression or a condition

11402
07:41:32,320 --> 07:41:34,558
in your switch statement and that has to

11403
07:41:34,558 --> 07:41:37,520
be an integer something like ant car

11404
07:41:37,520 --> 07:41:39,520
unsigned shorter things like that we

11405
07:41:39,520 --> 07:41:41,920
have seen all of these things but it can

11406
07:41:41,920 --> 07:41:44,718
also be an enum but enam is something we

11407
07:41:44,718 --> 07:41:46,398
haven't learned about yet we will learn

11408
07:41:46,398 --> 07:41:48,558
about it later when we have enough tools

11409
07:41:48,558 --> 07:41:50,878
to understand that but know about this

11410
07:41:50,878 --> 07:41:52,160
limitation

11411
07:41:52,160 --> 07:41:55,200
so if we can in our project in visual

11412
07:41:55,200 --> 07:41:58,000
studio code for example and say

11413
07:41:58,000 --> 07:42:00,878
std string name and say

11414
07:42:00,878 --> 07:42:03,600
john for example and use this as a

11415
07:42:03,600 --> 07:42:06,638
switch condition or expression we have

11416
07:42:06,638 --> 07:42:08,558
to include string for this to work so

11417
07:42:08,558 --> 07:42:10,080
let's go up

11418
07:42:10,080 --> 07:42:12,478
and include the string library we're

11419
07:42:12,478 --> 07:42:14,798
going to do string and if we go down

11420
07:42:14,798 --> 07:42:17,840
again and try to do switch and use name

11421
07:42:17,840 --> 07:42:20,320
as an expression and take out everything

11422
07:42:20,320 --> 07:42:22,638
we have in here and try to compile this

11423
07:42:22,638 --> 07:42:25,200
you see that the compiler is not happy

11424
07:42:25,200 --> 07:42:27,600
okay it's going to say expression must

11425
07:42:27,600 --> 07:42:30,878
have an integral or enum type so this is

11426
07:42:30,878 --> 07:42:32,478
not even going to compile this is a

11427
07:42:32,478 --> 07:42:34,638
limitation you have and you have to make

11428
07:42:34,638 --> 07:42:37,600
sure what you pass as a condition here

11429
07:42:37,600 --> 07:42:41,040
is an integer something like ant or car

11430
07:42:41,040 --> 07:42:43,520
or other integral types we have learnt

11431
07:42:43,520 --> 07:42:46,638
about in this course

11432
07:42:46,878 --> 07:42:48,558
this lecture we're going to learn about

11433
07:42:48,558 --> 07:42:51,280
ternary operators and this is an

11434
07:42:51,280 --> 07:42:54,878
alternative way to do tests with the if

11435
07:42:54,878 --> 07:42:56,160
statement

11436
07:42:56,160 --> 07:42:58,398
suppose here we have a variable called

11437
07:42:58,398 --> 07:43:01,280
max we have two variables called a and b

11438
07:43:01,280 --> 07:43:03,200
and we want to find the maximum between

11439
07:43:03,200 --> 07:43:04,718
these two things

11440
07:43:04,718 --> 07:43:07,840
one easy way we can do this is say if a

11441
07:43:07,840 --> 07:43:09,600
is greater than b we're going to store

11442
07:43:09,600 --> 07:43:12,878
the maximum in max else then b is going

11443
07:43:12,878 --> 07:43:14,478
to be the maximum and we're going to

11444
07:43:14,478 --> 07:43:17,200
store that in our maximum value and

11445
07:43:17,200 --> 07:43:18,878
we're going to print this out if we do

11446
07:43:18,878 --> 07:43:20,798
this we're going to get whatever is the

11447
07:43:20,798 --> 07:43:23,360
maximum between a and b to be printed

11448
07:43:23,360 --> 07:43:25,280
out on the console and this is going to

11449
07:43:25,280 --> 07:43:28,000
work really well but we can also use a

11450
07:43:28,000 --> 07:43:30,398
ternary expression and the ternary

11451
07:43:30,398 --> 07:43:32,240
expression looks like this

11452
07:43:32,240 --> 07:43:34,958
and it starts with a pair of parentheses

11453
07:43:34,958 --> 07:43:36,398
you're going to put your condition

11454
07:43:36,398 --> 07:43:38,320
inside the parenthesis you're going to

11455
07:43:38,320 --> 07:43:40,240
follow that with the question mark

11456
07:43:40,240 --> 07:43:42,478
you're going to put your option one and

11457
07:43:42,478 --> 07:43:44,080
after that you're going to put a column

11458
07:43:44,080 --> 07:43:46,718
and option two and because this is a

11459
07:43:46,718 --> 07:43:49,200
statement in c plus plus we're going to

11460
07:43:49,200 --> 07:43:52,558
end this with a semicolon here is an

11461
07:43:52,558 --> 07:43:54,798
equivalent version of that

11462
07:43:54,798 --> 07:43:57,840
using f as we have been doing all along

11463
07:43:57,840 --> 07:44:00,080
so we say if condition results equals

11464
07:44:00,080 --> 07:44:03,040
option one if condition is false result

11465
07:44:03,040 --> 07:44:05,040
is going to be equal to option two and

11466
07:44:05,040 --> 07:44:07,040
this is exactly the same thing we are

11467
07:44:07,040 --> 07:44:09,520
doing with our ternary expression here

11468
07:44:09,520 --> 07:44:11,280
if the condition is true we're going to

11469
07:44:11,280 --> 07:44:13,600
take option one and assign that to

11470
07:44:13,600 --> 07:44:15,760
result if it's false we're going to take

11471
07:44:15,760 --> 07:44:18,958
option two and assign that to resort so

11472
07:44:18,958 --> 07:44:21,360
this is really a syntactic sugar or a

11473
07:44:21,360 --> 07:44:24,160
shorthand for this thing here and it's

11474
07:44:24,160 --> 07:44:25,840
going to make your code shorter and

11475
07:44:25,840 --> 07:44:27,360
you're going to see this all over the

11476
07:44:27,360 --> 07:44:28,240
place

11477
07:44:28,240 --> 07:44:30,958
in c plus plus code out there so you

11478
07:44:30,958 --> 07:44:32,320
really need to be

11479
07:44:32,320 --> 07:44:35,600
familiar with this okay so here is our

11480
07:44:35,600 --> 07:44:38,320
example of computing the maximum you see

11481
07:44:38,320 --> 07:44:40,638
that we have the same variables max a

11482
07:44:40,638 --> 07:44:43,520
and b but we have a one liner that is

11483
07:44:43,520 --> 07:44:45,760
going to store the maximum in max and we

11484
07:44:45,760 --> 07:44:47,280
can print this out

11485
07:44:47,280 --> 07:44:49,680
and hopefully you can see that this is

11486
07:44:49,680 --> 07:44:52,638
shorter and better than this okay one

11487
07:44:52,638 --> 07:44:54,240
other thing you should know is that

11488
07:44:54,240 --> 07:44:57,520
option one and option two should be of

11489
07:44:57,520 --> 07:45:00,638
the same type or at least the types must

11490
07:45:00,638 --> 07:45:02,718
be convertible and if that fails you're

11491
07:45:02,718 --> 07:45:04,478
going to get a compiler error we can

11492
07:45:04,478 --> 07:45:06,798
also do ternary initialization here we

11493
07:45:06,798 --> 07:45:09,360
have a boolean called fast

11494
07:45:09,360 --> 07:45:12,320
we initialize this to false we can use

11495
07:45:12,320 --> 07:45:14,320
this to

11496
07:45:14,320 --> 07:45:16,878
initialize our speed variable here we

11497
07:45:16,878 --> 07:45:19,680
are basically saying if fast initialize

11498
07:45:19,680 --> 07:45:23,040
this with 300 if not fast

11499
07:45:23,040 --> 07:45:25,680
initialize this with 150

11500
07:45:25,680 --> 07:45:27,360
and we're going to print the speed here

11501
07:45:27,360 --> 07:45:29,440
and this is going to work and here you

11502
07:45:29,440 --> 07:45:31,760
see that i lied a little bit in my

11503
07:45:31,760 --> 07:45:34,240
explanation to make it really obvious

11504
07:45:34,240 --> 07:45:36,958
what we had in our ternary expression

11505
07:45:36,958 --> 07:45:39,200
you don't have to always wrap your

11506
07:45:39,200 --> 07:45:41,760
condition in parenthesis but it makes

11507
07:45:41,760 --> 07:45:44,160
the code much cleaner okay now that you

11508
07:45:44,160 --> 07:45:47,040
have an idea about distance it's time we

11509
07:45:47,040 --> 07:45:49,280
headed to visual studio code and

11510
07:45:49,280 --> 07:45:53,040
actually tried this and so for ourselves

11511
07:45:53,040 --> 07:45:56,000
okay here we are in our working folder

11512
07:45:56,000 --> 07:45:58,878
the current project is ternary operators

11513
07:45:58,878 --> 07:46:02,160
we're going to grab our template files

11514
07:46:02,160 --> 07:46:05,200
and put those where they belong it is in

11515
07:46:05,200 --> 07:46:08,080
this lecture here on ternary operators

11516
07:46:08,080 --> 07:46:09,760
and we're going to open this up in

11517
07:46:09,760 --> 07:46:12,558
visual studio code as we always do we're

11518
07:46:12,558 --> 07:46:14,638
going to open this and we're going to

11519
07:46:14,638 --> 07:46:17,280
open main cpp and take out whatever we

11520
07:46:17,280 --> 07:46:19,840
don't need we are going to go down and

11521
07:46:19,840 --> 07:46:22,718
put in our test code we basically have a

11522
07:46:22,718 --> 07:46:25,520
few variables let's kill these spaces so

11523
07:46:25,520 --> 07:46:28,478
that our code is not cluttered here and

11524
07:46:28,478 --> 07:46:31,360
we're going to print our maximum

11525
07:46:31,360 --> 07:46:33,440
and we're going to be using a regular if

11526
07:46:33,440 --> 07:46:36,320
we have three variables max a and b we

11527
07:46:36,320 --> 07:46:39,280
are saying if a is greater than b

11528
07:46:39,280 --> 07:46:43,200
we're going to store the maximum and max

11529
07:46:43,200 --> 07:46:45,360
otherwise we're going to store b

11530
07:46:45,360 --> 07:46:46,478
in max

11531
07:46:46,478 --> 07:46:48,398
and this is going to allow us to print

11532
07:46:48,398 --> 07:46:50,798
whatever is the maximum between 35 and

11533
07:46:50,798 --> 07:46:53,520
20. if we build this let's bring up a

11534
07:46:53,520 --> 07:46:54,958
terminal

11535
07:46:54,958 --> 07:46:57,760
and we are going to build with gcc as we

11536
07:46:57,760 --> 07:47:00,080
always do let's bring this up a little

11537
07:47:00,080 --> 07:47:02,160
bit and we're going to clear

11538
07:47:02,160 --> 07:47:04,160
and run rooster we're going to see that

11539
07:47:04,160 --> 07:47:07,280
the maximum is 35 if we put our maximum

11540
07:47:07,280 --> 07:47:08,478
in a beam

11541
07:47:08,478 --> 07:47:10,638
we're going to get the maximum steel so

11542
07:47:10,638 --> 07:47:12,240
we're going to run this out to build

11543
07:47:12,240 --> 07:47:14,638
with gcc

11544
07:47:14,638 --> 07:47:16,958
and we're going to run this clear

11545
07:47:16,958 --> 07:47:18,478
rooster

11546
07:47:18,478 --> 07:47:20,478
max is 200 so we're going to get the

11547
07:47:20,478 --> 07:47:23,680
maximum regardless of where it is stored

11548
07:47:23,680 --> 07:47:27,120
in a or b this is how our code works but

11549
07:47:27,120 --> 07:47:30,080
we can use ternary operators to do the

11550
07:47:30,080 --> 07:47:31,280
same thing

11551
07:47:31,280 --> 07:47:32,638
so what we're going to do here we're

11552
07:47:32,638 --> 07:47:35,200
going to comment out our if statement

11553
07:47:35,200 --> 07:47:36,320
and use

11554
07:47:36,320 --> 07:47:39,280
a ternary version so what we're going to

11555
07:47:39,280 --> 07:47:42,160
do we're going to say result equals

11556
07:47:42,160 --> 07:47:44,958
and we're going to say a greater than b

11557
07:47:44,958 --> 07:47:47,200
we're going to put a question mark to

11558
07:47:47,200 --> 07:47:48,320
signal

11559
07:47:48,320 --> 07:47:49,520
the

11560
07:47:49,520 --> 07:47:51,920
start of our two options option one is

11561
07:47:51,920 --> 07:47:54,638
going to be a because if a is greater

11562
07:47:54,638 --> 07:47:57,600
than b then a is going to be the maximum

11563
07:47:57,600 --> 07:48:00,638
so we're going to grab a here and if a

11564
07:48:00,638 --> 07:48:02,558
is not greater than b

11565
07:48:02,558 --> 07:48:04,558
then b must be the maximum so we're

11566
07:48:04,558 --> 07:48:06,638
going to put that as a second option

11567
07:48:06,638 --> 07:48:08,878
here this is what we mean with this

11568
07:48:08,878 --> 07:48:10,638
statement and we don't have a variable

11569
07:48:10,638 --> 07:48:12,638
called results that's why we have a

11570
07:48:12,638 --> 07:48:14,718
problem here we're going to put our

11571
07:48:14,718 --> 07:48:17,360
result in max and this should

11572
07:48:17,360 --> 07:48:19,040
solve this problem

11573
07:48:19,040 --> 07:48:22,000
you see the squiggly lines go away and

11574
07:48:22,000 --> 07:48:23,760
we can build this and we're going to get

11575
07:48:23,760 --> 07:48:26,478
exactly the same result so this is our

11576
07:48:26,478 --> 07:48:29,200
ternary operator if we build this it is

11577
07:48:29,200 --> 07:48:31,920
going to go through and if we run this

11578
07:48:31,920 --> 07:48:33,520
we're going to get exactly the same

11579
07:48:33,520 --> 07:48:36,798
result max is 200 and it is what we

11580
07:48:36,798 --> 07:48:39,440
expect okay so take some time and really

11581
07:48:39,440 --> 07:48:43,040
make yourself familiar with this syntax

11582
07:48:43,040 --> 07:48:44,878
it is really nothing complicated you

11583
07:48:44,878 --> 07:48:47,760
just have to make sure your brain is

11584
07:48:47,760 --> 07:48:49,840
aware of something like this and you're

11585
07:48:49,840 --> 07:48:51,600
going to recognize that everywhere you

11586
07:48:51,600 --> 07:48:54,320
see it in code out there okay we have

11587
07:48:54,320 --> 07:48:57,120
mentioned that you can't pass types that

11588
07:48:57,120 --> 07:48:59,680
are not compatible and the requirement

11589
07:48:59,680 --> 07:49:02,718
is that a and b be of the same type

11590
07:49:02,718 --> 07:49:05,680
or at least types you can do conversions

11591
07:49:05,680 --> 07:49:08,718
between so for example if we try to do

11592
07:49:08,718 --> 07:49:10,558
something like

11593
07:49:10,558 --> 07:49:13,200
pass a hello in here

11594
07:49:13,200 --> 07:49:17,040
we can't really turn a strength into a

11595
07:49:17,040 --> 07:49:19,360
integer and this is going to give us a

11596
07:49:19,360 --> 07:49:21,760
compiler error and let's look at the

11597
07:49:21,760 --> 07:49:23,760
error we see from visual studio code

11598
07:49:23,760 --> 07:49:26,558
operand types are incompatible and and

11599
07:49:26,558 --> 07:49:29,200
the const car are not compatible and

11600
07:49:29,200 --> 07:49:31,760
they have to be compatible if we ignore

11601
07:49:31,760 --> 07:49:33,520
this and go ahead and build we're going

11602
07:49:33,520 --> 07:49:36,478
to also see an error from the compiler

11603
07:49:36,478 --> 07:49:39,840
and it should be the same error so

11604
07:49:39,840 --> 07:49:41,520
operands to

11605
07:49:41,520 --> 07:49:43,760
question mark and column have different

11606
07:49:43,760 --> 07:49:46,000
types and and cost car

11607
07:49:46,000 --> 07:49:47,840
and they have to be

11608
07:49:47,840 --> 07:49:50,398
stands you can really compare so for

11609
07:49:50,398 --> 07:49:52,878
example we can take out this string here

11610
07:49:52,878 --> 07:49:55,680
and put in a floating point let's put in

11611
07:49:55,680 --> 07:49:59,120
a 22.5 and say that this is a fluid

11612
07:49:59,120 --> 07:50:00,638
you're going to see that the problem is

11613
07:50:00,638 --> 07:50:02,558
going to go away here let's wait for a

11614
07:50:02,558 --> 07:50:04,638
minute it's not going away we're going

11615
07:50:04,638 --> 07:50:06,638
to build anyway you see the world is

11616
07:50:06,638 --> 07:50:08,958
good we're going to clear

11617
07:50:08,958 --> 07:50:10,878
so that we don't have all this clutter

11618
07:50:10,878 --> 07:50:13,440
you see problems by the way and if we

11619
07:50:13,440 --> 07:50:15,840
both again let's try to do that the

11620
07:50:15,840 --> 07:50:17,520
builder is going to go through and if we

11621
07:50:17,520 --> 07:50:19,680
run this we're going to get

11622
07:50:19,680 --> 07:50:23,600
max is 22 because we are comparing a and

11623
07:50:23,600 --> 07:50:26,240
22 here and the compiler inserted an

11624
07:50:26,240 --> 07:50:28,240
implicit conversion from this floating

11625
07:50:28,240 --> 07:50:30,638
point to integer that's why we are

11626
07:50:30,638 --> 07:50:32,160
seeing this here

11627
07:50:32,160 --> 07:50:34,798
so what is the type that's the compiler

11628
07:50:34,798 --> 07:50:37,120
really used here okay to make it really

11629
07:50:37,120 --> 07:50:39,760
clear what is going on we're not going

11630
07:50:39,760 --> 07:50:40,878
to

11631
07:50:40,878 --> 07:50:44,878
use max here let's say auto max one

11632
07:50:44,878 --> 07:50:46,718
and see what the compiler is really

11633
07:50:46,718 --> 07:50:48,320
deducing to

11634
07:50:48,320 --> 07:50:50,878
so we're going to take this out

11635
07:50:50,878 --> 07:50:53,200
and by this we're going to see

11636
07:50:53,200 --> 07:50:56,160
what implicit conversion the compiler

11637
07:50:56,160 --> 07:50:58,638
really did here because what we had

11638
07:50:58,638 --> 07:51:00,718
before we were doing an assignment so

11639
07:51:00,718 --> 07:51:03,040
whatever was on the left was being

11640
07:51:03,040 --> 07:51:04,878
turned into an integer because we were

11641
07:51:04,878 --> 07:51:07,440
doing an implicit conversion from an

11642
07:51:07,440 --> 07:51:09,680
assignment so whatever is on the left is

11643
07:51:09,680 --> 07:51:12,080
turned into the type of whatever we have

11644
07:51:12,080 --> 07:51:14,160
on the left of the assignment i hope you

11645
07:51:14,160 --> 07:51:16,398
know this already but if we do things

11646
07:51:16,398 --> 07:51:18,798
like this we're going to deduce whatever

11647
07:51:18,798 --> 07:51:21,360
is on the left and assign that into max

11648
07:51:21,360 --> 07:51:23,200
one so we're going to do so we're going

11649
07:51:23,200 --> 07:51:24,958
to see the implicit conversion that the

11650
07:51:24,958 --> 07:51:27,360
compiler did in here and it is good to

11651
07:51:27,360 --> 07:51:29,680
be able to see things like that it is a

11652
07:51:29,680 --> 07:51:31,520
curiosity thing so

11653
07:51:31,520 --> 07:51:32,958
let's see what happens here we're going

11654
07:51:32,958 --> 07:51:36,000
to print max one and i'm going to world

11655
07:51:36,000 --> 07:51:39,360
with gcc this is going to go through

11656
07:51:39,360 --> 07:51:41,360
and we're going to see what is printed

11657
07:51:41,360 --> 07:51:43,280
so let's run rooster

11658
07:51:43,280 --> 07:51:44,478
and you're going to see that the

11659
07:51:44,478 --> 07:51:47,360
implicit conversion happened from end to

11660
07:51:47,360 --> 07:51:50,160
flood and we deduce the flood here in

11661
07:51:50,160 --> 07:51:52,558
max one so this is really interesting

11662
07:51:52,558 --> 07:51:54,878
one might have thought that we had a

11663
07:51:54,878 --> 07:51:56,798
conversion from float

11664
07:51:56,798 --> 07:51:59,280
to end but it was actually the reverse

11665
07:51:59,280 --> 07:52:01,440
and this is quite interesting this is

11666
07:52:01,440 --> 07:52:02,798
really all we set out to do in this

11667
07:52:02,798 --> 07:52:05,280
lecture i hope you found it interesting

11668
07:52:05,280 --> 07:52:07,440
again make sure you have this syntax

11669
07:52:07,440 --> 07:52:09,520
here drilled in your brain because

11670
07:52:09,520 --> 07:52:11,280
you're going to be seeing this a lot in

11671
07:52:11,280 --> 07:52:14,080
your career as a software developer not

11672
07:52:14,080 --> 07:52:16,478
only a c plus plus developer actually

11673
07:52:16,478 --> 07:52:18,558
and it is going to be helpful

11674
07:52:18,558 --> 07:52:20,120
for you to know this

11675
07:52:20,120 --> 07:52:22,398
congratulations on hitting the end of

11676
07:52:22,398 --> 07:52:24,798
this chapter this chapter was all about

11677
07:52:24,798 --> 07:52:26,878
flow control and we had the chance to

11678
07:52:26,878 --> 07:52:29,200
learn about many of the tools that c

11679
07:52:29,200 --> 07:52:32,000
plus plus provides to do conditional

11680
07:52:32,000 --> 07:52:34,000
programming and we were able to see all

11681
07:52:34,000 --> 07:52:35,920
kinds of crazy things we had the chance

11682
07:52:35,920 --> 07:52:38,240
to do things like if red is true we're

11683
07:52:38,240 --> 07:52:40,638
going to run the code inside if yellow

11684
07:52:40,638 --> 07:52:42,638
is true we're going to run code inside

11685
07:52:42,638 --> 07:52:44,478
if green is true we're going to run code

11686
07:52:44,478 --> 07:52:46,320
inside and you had a chance to play with

11687
07:52:46,320 --> 07:52:49,440
those things on many occasions we have

11688
07:52:49,440 --> 07:52:51,440
seen that the tools that c plus plus

11689
07:52:51,440 --> 07:52:53,600
provides really revolve around these

11690
07:52:53,600 --> 07:52:56,240
four things here we have if statements

11691
07:52:56,240 --> 07:52:58,478
we can do else closes

11692
07:52:58,478 --> 07:53:02,320
on this if statements we can do else if

11693
07:53:02,320 --> 07:53:05,120
to really do long chains of things where

11694
07:53:05,120 --> 07:53:07,360
we do different decisions to do things

11695
07:53:07,360 --> 07:53:10,080
in our applications we also saw that

11696
07:53:10,080 --> 07:53:12,320
switch is an option if you have several

11697
07:53:12,320 --> 07:53:14,398
decisions you can make in your

11698
07:53:14,398 --> 07:53:17,120
application and we saw that a ternary

11699
07:53:17,120 --> 07:53:20,080
operator can really be used to do

11700
07:53:20,080 --> 07:53:22,718
two decisions if you have two decisions

11701
07:53:22,718 --> 07:53:25,120
you're going to be able to reduce the

11702
07:53:25,120 --> 07:53:27,920
number of lines you used to do these

11703
07:53:27,920 --> 07:53:30,478
decisions with to one line and we had a

11704
07:53:30,478 --> 07:53:32,638
chance to really look at that in detail

11705
07:53:32,638 --> 07:53:35,520
in the lecture on ternary operators this

11706
07:53:35,520 --> 07:53:37,520
is really all i had to share in this

11707
07:53:37,520 --> 07:53:40,000
chapter i hope you found it interesting

11708
07:53:40,000 --> 07:53:41,440
we are going to stop here in this

11709
07:53:41,440 --> 07:53:43,200
lecture in the next chapter we're going

11710
07:53:43,200 --> 07:53:46,080
to start and learn about loops

11711
07:53:46,080 --> 07:53:48,398
go ahead and finish up here and meet me

11712
07:53:48,398 --> 07:53:50,638
there in this chapter we're going to be

11713
07:53:50,638 --> 07:53:53,360
learning about loops and this is a

11714
07:53:53,360 --> 07:53:56,080
construct that is provided by the c plus

11715
07:53:56,080 --> 07:53:58,638
plus programming language to allow you

11716
07:53:58,638 --> 07:54:03,360
to do repetitive tasks relatively easily

11717
07:54:03,360 --> 07:54:06,638
suppose we have a task to print a

11718
07:54:06,638 --> 07:54:08,320
message 10 times

11719
07:54:08,320 --> 07:54:10,878
we can go down and do it like this and

11720
07:54:10,878 --> 07:54:13,280
it is going to work but what if they try

11721
07:54:13,280 --> 07:54:14,398
and tell you

11722
07:54:14,398 --> 07:54:16,478
do this 100 times then you're going to

11723
07:54:16,478 --> 07:54:18,000
start scratching your head you're going

11724
07:54:18,000 --> 07:54:20,080
to type this 100 times and you're going

11725
07:54:20,080 --> 07:54:22,000
to run your program and it is going to

11726
07:54:22,000 --> 07:54:24,160
work then your manager comes up and they

11727
07:54:24,160 --> 07:54:26,558
say i want you to do this 10 000 times

11728
07:54:26,558 --> 07:54:28,798
or even 100 000 times and then you're

11729
07:54:28,798 --> 07:54:30,558
going to start pulling your hair or

11730
07:54:30,558 --> 07:54:32,718
running around breaking vents because

11731
07:54:32,718 --> 07:54:34,878
that's impossible to do not to worry

11732
07:54:34,878 --> 07:54:37,840
here c plus plus provides a way to do

11733
07:54:37,840 --> 07:54:40,000
this relatively easily and we're going

11734
07:54:40,000 --> 07:54:42,320
to be learning about ways we can do this

11735
07:54:42,320 --> 07:54:45,120
in our program in this chapter the

11736
07:54:45,120 --> 07:54:46,878
constructs we're going to be using are

11737
07:54:46,878 --> 07:54:49,520
these you see here there is a for loop a

11738
07:54:49,520 --> 07:54:51,760
range base for a loop a while loop and

11739
07:54:51,760 --> 07:54:54,398
do a while loop and we can make use of

11740
07:54:54,398 --> 07:54:57,840
these tools to not go crazy printing a

11741
07:54:57,840 --> 07:55:00,798
message one million times because that's

11742
07:55:00,798 --> 07:55:01,920
really bad

11743
07:55:01,920 --> 07:55:04,160
okay so that's what we are up against in

11744
07:55:04,160 --> 07:55:05,600
this chapter we're going to be learning

11745
07:55:05,600 --> 07:55:07,760
about these loop constructs and you're

11746
07:55:07,760 --> 07:55:09,840
going to find that they are really cool

11747
07:55:09,840 --> 07:55:12,160
for your application i am excited to be

11748
07:55:12,160 --> 07:55:14,320
teaching you this so let's get started

11749
07:55:14,320 --> 07:55:16,638
in the next lecture and learn about the

11750
07:55:16,638 --> 07:55:19,600
for loop go ahead and finish up here and

11751
07:55:19,600 --> 07:55:21,440
meet me there in this lecture we're

11752
07:55:21,440 --> 07:55:24,240
going to learn about four loops

11753
07:55:24,240 --> 07:55:26,558
for loops are one of the constructs we

11754
07:55:26,558 --> 07:55:29,120
have in c plus plus to do repetitive

11755
07:55:29,120 --> 07:55:31,440
tasks they allow us to do something like

11756
07:55:31,440 --> 07:55:33,520
this much more easily for example we

11757
07:55:33,520 --> 07:55:36,718
don't have to type stdc out of c plus

11758
07:55:36,718 --> 07:55:40,240
plus 10 times or 100 times we can do

11759
07:55:40,240 --> 07:55:42,398
this in less than five lines and you're

11760
07:55:42,398 --> 07:55:44,558
going to see how cool this is the syntax

11761
07:55:44,558 --> 07:55:47,680
for for loops looks like this and it may

11762
07:55:47,680 --> 07:55:50,398
look intimidating for first users but

11763
07:55:50,398 --> 07:55:53,200
we're going to break this down we have a

11764
07:55:53,200 --> 07:55:56,160
few parts in here the first part is the

11765
07:55:56,160 --> 07:55:58,638
iterator which is a variable that we're

11766
07:55:58,638 --> 07:56:01,440
going to be using to navigate through

11767
07:56:01,440 --> 07:56:03,520
the loop and that variable is this

11768
07:56:03,520 --> 07:56:06,558
unsigned int i here we are going to

11769
07:56:06,558 --> 07:56:09,440
initialize this to zero and the value we

11770
07:56:09,440 --> 07:56:12,478
initialize this with is going to be our

11771
07:56:12,478 --> 07:56:14,798
starting value and that's another key

11772
07:56:14,798 --> 07:56:17,360
point of any loop any loop is going to

11773
07:56:17,360 --> 07:56:19,600
have a starting point we are also going

11774
07:56:19,600 --> 07:56:22,160
to have a test which is going to control

11775
07:56:22,160 --> 07:56:25,200
when our loop ends for example this loop

11776
07:56:25,200 --> 07:56:27,680
is going to start with i equal to zero

11777
07:56:27,680 --> 07:56:30,398
it is going to keep doing stuff until

11778
07:56:30,398 --> 07:56:32,398
i is no longer

11779
07:56:32,398 --> 07:56:35,520
less than 10. as long as i is less than

11780
07:56:35,520 --> 07:56:37,360
10 it's going to keep doing whatever it

11781
07:56:37,360 --> 07:56:40,000
is we want to do and the first part of

11782
07:56:40,000 --> 07:56:43,280
the loop is this plus plus i thing here

11783
07:56:43,280 --> 07:56:45,280
and this is an incrementation part

11784
07:56:45,280 --> 07:56:46,798
that's how i'm going to call it for

11785
07:56:46,798 --> 07:56:49,200
simplicity but at least a part that

11786
07:56:49,200 --> 07:56:52,478
keeps changing our iterator to make our

11787
07:56:52,478 --> 07:56:55,040
loop move forward after these four

11788
07:56:55,040 --> 07:56:57,520
points we are going to have a pair of

11789
07:56:57,520 --> 07:57:00,558
curly braces and inside these curly

11790
07:57:00,558 --> 07:57:03,120
braces we're going to have the body of

11791
07:57:03,120 --> 07:57:05,040
our loop and this is the code we want to

11792
07:57:05,040 --> 07:57:08,240
execute multiple times and inside this

11793
07:57:08,240 --> 07:57:10,638
loop body we can really do all kinds of

11794
07:57:10,638 --> 07:57:12,240
crazy things you're going to see how

11795
07:57:12,240 --> 07:57:14,398
cool this is again we have a few parts

11796
07:57:14,398 --> 07:57:16,958
with our loop we have our iterator which

11797
07:57:16,958 --> 07:57:19,280
is this variable i here we're going to

11798
07:57:19,280 --> 07:57:21,760
be initializing this with a value that

11799
07:57:21,760 --> 07:57:24,398
denotes where we want our loop to start

11800
07:57:24,398 --> 07:57:26,558
we then have a test which is going to

11801
07:57:26,558 --> 07:57:28,958
control when the loop is going to end

11802
07:57:28,958 --> 07:57:30,638
we're going to have our incrementation

11803
07:57:30,638 --> 07:57:33,200
part which is going to allow our loop to

11804
07:57:33,200 --> 07:57:35,120
move forward and it's going to be doing

11805
07:57:35,120 --> 07:57:36,798
that through incrementation or

11806
07:57:36,798 --> 07:57:39,520
decrementation but to make explanation

11807
07:57:39,520 --> 07:57:41,440
easier here we're going to call this

11808
07:57:41,440 --> 07:57:44,638
part the incrementation part of the loop

11809
07:57:44,638 --> 07:57:46,320
after that we're going to have the body

11810
07:57:46,320 --> 07:57:48,398
of the loop and it's going to be within

11811
07:57:48,398 --> 07:57:50,878
this curly braces and it's going to be

11812
07:57:50,878 --> 07:57:53,440
whatever it is we want to execute inside

11813
07:57:53,440 --> 07:57:55,840
this loop okay these are the parts of a

11814
07:57:55,840 --> 07:57:57,920
loop and you need to keep this in mind

11815
07:57:57,920 --> 07:58:00,240
okay now that you know the main parts of

11816
07:58:00,240 --> 07:58:01,280
the loop

11817
07:58:01,280 --> 07:58:03,280
how does it really work let's go through

11818
07:58:03,280 --> 07:58:05,440
this and see how it's going to print i

11819
07:58:05,440 --> 07:58:08,320
love c plus plus 10 times so when this

11820
07:58:08,320 --> 07:58:10,478
code gets executed we're going to start

11821
07:58:10,478 --> 07:58:12,958
with i equal to 0 because that's what we

11822
07:58:12,958 --> 07:58:15,840
are initializing this value with

11823
07:58:15,840 --> 07:58:18,000
after the incrementation part we're

11824
07:58:18,000 --> 07:58:19,680
going to run the test

11825
07:58:19,680 --> 07:58:23,120
and the test is going to say is i is 0

11826
07:58:23,120 --> 07:58:25,440
less than 10 and that's going to be true

11827
07:58:25,440 --> 07:58:28,478
so if the test turns out to be true

11828
07:58:28,478 --> 07:58:30,478
we're going to jump into the loop body

11829
07:58:30,478 --> 07:58:32,798
and if it's false we're going to jump to

11830
07:58:32,798 --> 07:58:36,320
the end of the loop and execute whatever

11831
07:58:36,320 --> 07:58:39,440
is after our loop this is how it works

11832
07:58:39,440 --> 07:58:41,600
so if we jump in for the first time when

11833
07:58:41,600 --> 07:58:44,000
i is 0 we're going to print i love c

11834
07:58:44,000 --> 07:58:46,160
plus plus for the first time then after

11835
07:58:46,160 --> 07:58:48,080
the body is executed we're going to

11836
07:58:48,080 --> 07:58:50,478
execute the incrementation part

11837
07:58:50,478 --> 07:58:53,200
this is going to make i equal to 1 then

11838
07:58:53,200 --> 07:58:54,638
we're going to come back to the test

11839
07:58:54,638 --> 07:58:57,440
we're going to say is 1 less than 10

11840
07:58:57,440 --> 07:58:59,280
that's going to be true we're going to

11841
07:58:59,280 --> 07:59:01,760
come in the body and print i love c plus

11842
07:59:01,760 --> 07:59:04,080
plus for the second time after that the

11843
07:59:04,080 --> 07:59:05,680
incrementation part is going to run

11844
07:59:05,680 --> 07:59:08,878
we're going to have a 2 inside i here 2

11845
07:59:08,878 --> 07:59:11,360
is less than 10 this is going to be true

11846
07:59:11,360 --> 07:59:12,878
so we're going to follow him the body

11847
07:59:12,878 --> 07:59:15,120
again and print i love c plus plus for

11848
07:59:15,120 --> 07:59:17,520
the third time we're going to keep doing

11849
07:59:17,520 --> 07:59:20,718
this until we hit nine for example if we

11850
07:59:20,718 --> 07:59:22,798
increment and get a nine we're going to

11851
07:59:22,798 --> 07:59:25,920
form the test and say is nine less than

11852
07:59:25,920 --> 07:59:27,520
ten that's going to be true so we're

11853
07:59:27,520 --> 07:59:30,000
going to fall in here and print i love c

11854
07:59:30,000 --> 07:59:31,360
plus plus again

11855
07:59:31,360 --> 07:59:33,520
and after that we're going to run the

11856
07:59:33,520 --> 07:59:36,558
incrementation part again this time i is

11857
07:59:36,558 --> 07:59:38,878
going to become 10 we're going to do the

11858
07:59:38,878 --> 07:59:42,240
test 10 is not less than 10 so the test

11859
07:59:42,240 --> 07:59:43,680
is going to fail

11860
07:59:43,680 --> 07:59:46,080
and we're going to fall on the outside

11861
07:59:46,080 --> 07:59:48,878
of the loop here and by that time we'll

11862
07:59:48,878 --> 07:59:52,080
have printed i love c plus plus 10 times

11863
07:59:52,080 --> 07:59:54,398
and this is really how a loop works for

11864
07:59:54,398 --> 07:59:56,320
the first time we're going to run this

11865
07:59:56,320 --> 07:59:59,040
initializer part here to initialize our

11866
07:59:59,040 --> 08:00:01,520
iterator which is this value i

11867
08:00:01,520 --> 08:00:03,040
and then after that we're going to run

11868
08:00:03,040 --> 08:00:04,160
the test

11869
08:00:04,160 --> 08:00:06,240
if the test is good if it's successful

11870
08:00:06,240 --> 08:00:08,000
we're going to fall in the body we're

11871
08:00:08,000 --> 08:00:09,840
going to execute whatever code is in the

11872
08:00:09,840 --> 08:00:11,760
body and after that we're going to keep

11873
08:00:11,760 --> 08:00:14,240
doing the cycle increment test the body

11874
08:00:14,240 --> 08:00:16,320
increment test body

11875
08:00:16,320 --> 08:00:19,440
increment test body until

11876
08:00:19,440 --> 08:00:22,718
we hit a point where the test fails and

11877
08:00:22,718 --> 08:00:24,798
if the test fails we're going to fall

11878
08:00:24,798 --> 08:00:26,000
outside

11879
08:00:26,000 --> 08:00:28,398
this for loop here we're going to

11880
08:00:28,398 --> 08:00:31,440
execute whatever is after this closing

11881
08:00:31,440 --> 08:00:33,840
curly brace and this is how a loop works

11882
08:00:33,840 --> 08:00:35,920
i want you to go through this one more

11883
08:00:35,920 --> 08:00:38,798
time by printing i love c plus plus and

11884
08:00:38,798 --> 08:00:41,600
making sure that this is printed 10

11885
08:00:41,600 --> 08:00:42,478
times

11886
08:00:42,478 --> 08:00:44,320
and one thing you should have noticed

11887
08:00:44,320 --> 08:00:47,600
now is that we use this test to control

11888
08:00:47,600 --> 08:00:49,280
how many times the loop is going to

11889
08:00:49,280 --> 08:00:51,920
start for example if we wanted it to run

11890
08:00:51,920 --> 08:00:54,798
20 times we would start from zero and

11891
08:00:54,798 --> 08:00:57,760
and at 20. and you don't always have to

11892
08:00:57,760 --> 08:00:59,600
start from zero you can really start

11893
08:00:59,600 --> 08:01:01,520
from anywhere for example you can

11894
08:01:01,520 --> 08:01:04,958
initialize i with a value like 30 and

11895
08:01:04,958 --> 08:01:08,240
end when i is equal to 55. let's say

11896
08:01:08,240 --> 08:01:10,160
that as an example you can really do

11897
08:01:10,160 --> 08:01:13,120
anything the main important thing is to

11898
08:01:13,120 --> 08:01:15,440
understand how a loop works one thing i

11899
08:01:15,440 --> 08:01:18,160
want you to notice is that we are saying

11900
08:01:18,160 --> 08:01:20,240
unsigned int here

11901
08:01:20,240 --> 08:01:23,280
to declare our iterator

11902
08:01:23,280 --> 08:01:26,080
iterators are a common thing in c plus

11903
08:01:26,080 --> 08:01:29,440
plus code and they're not just used for

11904
08:01:29,440 --> 08:01:31,760
loops like we are doing it here there is

11905
08:01:31,760 --> 08:01:34,958
a type we use to do iterators and it

11906
08:01:34,958 --> 08:01:36,718
makes our code much more readable and

11907
08:01:36,718 --> 08:01:38,878
that's called size t

11908
08:01:38,878 --> 08:01:42,000
this event is a representation of some

11909
08:01:42,000 --> 08:01:45,120
unsigned and type in your c plus plus

11910
08:01:45,120 --> 08:01:46,798
compiler this is going to be different

11911
08:01:46,798 --> 08:01:48,878
from compiler to compiler but for

11912
08:01:48,878 --> 08:01:52,320
example on my system this is eight bytes

11913
08:01:52,320 --> 08:01:55,040
so it has quite a good range of values

11914
08:01:55,040 --> 08:01:57,520
you can put in there if we use size t

11915
08:01:57,520 --> 08:02:00,478
type to declare our i iterator here

11916
08:02:00,478 --> 08:02:02,080
we're going to say something like this

11917
08:02:02,080 --> 08:02:04,160
for size t i

11918
08:02:04,160 --> 08:02:05,920
we're going to put our curly braces

11919
08:02:05,920 --> 08:02:07,840
we're going to put a semicolon we're

11920
08:02:07,840 --> 08:02:09,840
going to put our test and we're going to

11921
08:02:09,840 --> 08:02:12,638
put our incrementation part and i think

11922
08:02:12,638 --> 08:02:15,040
i really emphasize this but the

11923
08:02:15,040 --> 08:02:17,360
parts of our loop inside this

11924
08:02:17,360 --> 08:02:20,958
parenthesis are separated by semicolons

11925
08:02:20,958 --> 08:02:23,280
like this so we have the iterator

11926
08:02:23,280 --> 08:02:25,680
declaration we have a semicolon we have

11927
08:02:25,680 --> 08:02:28,240
the test we have a semicolon and we put

11928
08:02:28,240 --> 08:02:30,478
our incrementation part and then we go

11929
08:02:30,478 --> 08:02:33,040
on and put our curlies and inside we can

11930
08:02:33,040 --> 08:02:35,360
do whatever it is we want to do

11931
08:02:35,360 --> 08:02:37,520
inside the loop so size t is something

11932
08:02:37,520 --> 08:02:39,520
you're going to see a lot make sure you

11933
08:02:39,520 --> 08:02:42,080
know what it means remember that it is a

11934
08:02:42,080 --> 08:02:45,840
representation of an unsigned and type

11935
08:02:45,840 --> 08:02:47,920
so it can only represent positive

11936
08:02:47,920 --> 08:02:50,558
numbers and it is used to represent

11937
08:02:50,558 --> 08:02:53,440
things like sizes in c plus plus thank

11938
08:02:53,440 --> 08:02:56,160
the number of students in a classroom

11939
08:02:56,160 --> 08:02:58,478
for example that can never be negative

11940
08:02:58,478 --> 08:03:00,958
think about the number of seats in a car

11941
08:03:00,958 --> 08:03:02,638
that's something that is always going to

11942
08:03:02,638 --> 08:03:05,520
be positive and it won't make sense for

11943
08:03:05,520 --> 08:03:08,000
that to be negative so for those kinds

11944
08:03:08,000 --> 08:03:11,360
of things we can use size t to represent

11945
08:03:11,360 --> 08:03:13,600
the size of those things and you're

11946
08:03:13,600 --> 08:03:15,280
going to see how this works in a minute

11947
08:03:15,280 --> 08:03:17,280
okay now that you have a pretty good

11948
08:03:17,280 --> 08:03:20,080
idea about how a loop works and the main

11949
08:03:20,080 --> 08:03:22,240
parts that make it up i want you to know

11950
08:03:22,240 --> 08:03:24,478
that you can also do all kinds of crazy

11951
08:03:24,478 --> 08:03:27,360
operations inside the body of your loop

11952
08:03:27,360 --> 08:03:30,000
for example here we are printing out the

11953
08:03:30,000 --> 08:03:32,798
current value of our iterator and we're

11954
08:03:32,798 --> 08:03:35,120
going to print the double that we can do

11955
08:03:35,120 --> 08:03:37,840
this we can also leave out the curly

11956
08:03:37,840 --> 08:03:40,638
braces and this is only valid if we have

11957
08:03:40,638 --> 08:03:43,040
one statement we want to run in the loop

11958
08:03:43,040 --> 08:03:45,120
so this is going to print this message

11959
08:03:45,120 --> 08:03:47,200
here five times because this loop is

11960
08:03:47,200 --> 08:03:49,840
going from zero all the way to four it

11961
08:03:49,840 --> 08:03:52,558
is going to stop when i stops being less

11962
08:03:52,558 --> 08:03:54,878
than five and this is going to be five

11963
08:03:54,878 --> 08:03:56,638
times if you go through this you're

11964
08:03:56,638 --> 08:03:58,240
going to see that this is going to print

11965
08:03:58,240 --> 08:04:00,398
five times you should also know that

11966
08:04:00,398 --> 08:04:03,040
this iterator that we are declaring like

11967
08:04:03,040 --> 08:04:06,160
this is going to be scoped inside the

11968
08:04:06,160 --> 08:04:08,878
body of the loop so you can only use it

11969
08:04:08,878 --> 08:04:11,520
inside these curly braces and if you try

11970
08:04:11,520 --> 08:04:15,040
to use it outside for example here after

11971
08:04:15,040 --> 08:04:17,680
the closing curly braces of the body of

11972
08:04:17,680 --> 08:04:19,280
the loop you're going to get a compiler

11973
08:04:19,280 --> 08:04:21,520
error again you can only use this

11974
08:04:21,520 --> 08:04:24,240
variable i which is our iterator

11975
08:04:24,240 --> 08:04:27,600
inside the curlies that mark the

11976
08:04:27,600 --> 08:04:30,478
start and the end of our loop body if

11977
08:04:30,478 --> 08:04:32,558
you want the iterator to be usable

11978
08:04:32,558 --> 08:04:35,760
outside the scope of the for loop you

11979
08:04:35,760 --> 08:04:37,280
can do something like this you can

11980
08:04:37,280 --> 08:04:40,240
declare your iterator outside the loop

11981
08:04:40,240 --> 08:04:41,840
and you can initialize that with

11982
08:04:41,840 --> 08:04:43,760
whatever you want and then you can set

11983
08:04:43,760 --> 08:04:46,478
up your loop like this you can say for j

11984
08:04:46,478 --> 08:04:49,040
and put and your test and your

11985
08:04:49,040 --> 08:04:51,520
incrementation part and inside do

11986
08:04:51,520 --> 08:04:52,958
whatever it is you want to do in the

11987
08:04:52,958 --> 08:04:55,520
body of the look if we do it like this

11988
08:04:55,520 --> 08:04:58,160
then j is going to be usable outside of

11989
08:04:58,160 --> 08:05:00,320
the loop and we're going to see its

11990
08:05:00,320 --> 08:05:02,798
value if we print it out like this so

11991
08:05:02,798 --> 08:05:04,878
this is also something you can do

11992
08:05:04,878 --> 08:05:08,558
you can even go all crazy and leave out

11993
08:05:08,558 --> 08:05:09,440
the

11994
08:05:09,440 --> 08:05:12,398
declaration part if you happen to have

11995
08:05:12,398 --> 08:05:13,280
the

11996
08:05:13,280 --> 08:05:16,478
iterator declared outside so if you do

11997
08:05:16,478 --> 08:05:18,240
something like this it is also going to

11998
08:05:18,240 --> 08:05:20,478
work okay the last thing i want you to

11999
08:05:20,478 --> 08:05:22,798
see before we head over to visual studio

12000
08:05:22,798 --> 08:05:25,120
code and actually try this out

12001
08:05:25,120 --> 08:05:27,840
is that it is a bad thing to hard code

12002
08:05:27,840 --> 08:05:29,840
your values in for example you see here

12003
08:05:29,840 --> 08:05:32,398
we are saying j less than 10

12004
08:05:32,398 --> 08:05:34,958
this is really bad design because every

12005
08:05:34,958 --> 08:05:37,280
time you need to change the number of

12006
08:05:37,280 --> 08:05:39,520
times that your loop is going to run

12007
08:05:39,520 --> 08:05:41,200
you're going to have to hunt for these

12008
08:05:41,200 --> 08:05:43,360
loops and change these values and this

12009
08:05:43,360 --> 08:05:45,920
may be in a lot of places in your code

12010
08:05:45,920 --> 08:05:48,478
so a good thing to do is to put the

12011
08:05:48,478 --> 08:05:51,040
value that controls how many times your

12012
08:05:51,040 --> 08:05:53,040
loop is going to run in a variable like

12013
08:05:53,040 --> 08:05:55,120
this we're going to store that value in

12014
08:05:55,120 --> 08:05:56,958
this count variable

12015
08:05:56,958 --> 08:05:59,360
notice that it is of size t because it

12016
08:05:59,360 --> 08:06:01,280
is a representation of the size of

12017
08:06:01,280 --> 08:06:03,360
things something we don't really want to

12018
08:06:03,360 --> 08:06:05,760
be negative and we're going to use this

12019
08:06:05,760 --> 08:06:09,280
in our test part of our for loop here

12020
08:06:09,280 --> 08:06:11,360
instead of saying j less than 10 we're

12021
08:06:11,360 --> 08:06:14,080
going to say j less than count and if we

12022
08:06:14,080 --> 08:06:16,798
want to change this we have one point of

12023
08:06:16,798 --> 08:06:19,280
control to go and change this value here

12024
08:06:19,280 --> 08:06:20,878
and this is really good design you

12025
08:06:20,878 --> 08:06:23,200
should do this okay we have talked a lot

12026
08:06:23,200 --> 08:06:25,760
about loops it is time we headed over to

12027
08:06:25,760 --> 08:06:28,320
visual studio code and actually tried

12028
08:06:28,320 --> 08:06:30,798
these things out here we are in visual

12029
08:06:30,798 --> 08:06:33,280
studio code the current project is for

12030
08:06:33,280 --> 08:06:35,360
loop here we're going to grab the code

12031
08:06:35,360 --> 08:06:37,920
from our template project

12032
08:06:37,920 --> 08:06:40,000
and we're going to put that in place

12033
08:06:40,000 --> 08:06:41,760
here

12034
08:06:41,760 --> 08:06:43,840
and we're going to open this in visual

12035
08:06:43,840 --> 08:06:46,958
studio code so let's do that pretty fast

12036
08:06:46,958 --> 08:06:48,958
for loop that's the current project we

12037
08:06:48,958 --> 08:06:51,440
selected and we opened this in visual

12038
08:06:51,440 --> 08:06:52,718
studio code

12039
08:06:52,718 --> 08:06:55,680
we're going to open up our main cpp file

12040
08:06:55,680 --> 08:06:58,160
which is going to show up here and we're

12041
08:06:58,160 --> 08:07:00,000
going to remove things we don't need

12042
08:07:00,000 --> 08:07:00,878
here

12043
08:07:00,878 --> 08:07:03,040
so let's remove that okay the first

12044
08:07:03,040 --> 08:07:05,360
thing i want you to do is the bad way to

12045
08:07:05,360 --> 08:07:06,718
do things

12046
08:07:06,718 --> 08:07:09,120
again if we want to print i love c plus

12047
08:07:09,120 --> 08:07:12,478
plus 10 times we can do it like this and

12048
08:07:12,478 --> 08:07:14,320
if we run the program it's going to work

12049
08:07:14,320 --> 08:07:16,558
but this is really bad design because

12050
08:07:16,558 --> 08:07:18,798
you would have to copy and paste this

12051
08:07:18,798 --> 08:07:20,798
for example a thousand times or even a

12052
08:07:20,798 --> 08:07:22,718
hundred thousand of times and that's

12053
08:07:22,718 --> 08:07:24,958
really bad so if we bring up our

12054
08:07:24,958 --> 08:07:26,398
terminal

12055
08:07:26,398 --> 08:07:31,040
and build with gcc like we always do

12056
08:07:31,920 --> 08:07:34,398
the build is going to go through you see

12057
08:07:34,398 --> 08:07:36,878
it's successful we're going to clear and

12058
08:07:36,878 --> 08:07:38,478
we're going to run rooster and it's

12059
08:07:38,478 --> 08:07:40,958
going to say lfc plus plus 10 times if

12060
08:07:40,958 --> 08:07:43,120
you count this it's going to be 10 times

12061
08:07:43,120 --> 08:07:45,120
because that's what we're doing here but

12062
08:07:45,120 --> 08:07:46,878
this is really bad design you don't want

12063
08:07:46,878 --> 08:07:49,040
to do something like this so we're going

12064
08:07:49,040 --> 08:07:50,958
to comment this out

12065
08:07:50,958 --> 08:07:53,600
and do this better using a for loop

12066
08:07:53,600 --> 08:07:55,680
let's say that this is the bad way and

12067
08:07:55,680 --> 08:07:57,440
we're going to use for loop which is the

12068
08:07:57,440 --> 08:07:59,360
good way sorry so we're going to start

12069
08:07:59,360 --> 08:08:01,840
by declaring our iterator so we're going

12070
08:08:01,840 --> 08:08:04,798
to say for we're going to say size t

12071
08:08:04,798 --> 08:08:06,798
let's use unsigned end to show you that

12072
08:08:06,798 --> 08:08:08,478
you can use that and we're going to say

12073
08:08:08,478 --> 08:08:10,558
i and we're going to initialize this

12074
08:08:10,558 --> 08:08:12,240
with a zero

12075
08:08:12,240 --> 08:08:14,798
and this is going to be the declaration

12076
08:08:14,798 --> 08:08:18,000
of our iterator this is the first part

12077
08:08:18,000 --> 08:08:20,320
we have in this parenthesis here we're

12078
08:08:20,320 --> 08:08:22,718
going to put in a semicolon and put in

12079
08:08:22,718 --> 08:08:25,120
the test we want the

12080
08:08:25,120 --> 08:08:27,360
loop to run ten times so it's going to

12081
08:08:27,360 --> 08:08:29,280
run from zero to nine we're going to

12082
08:08:29,280 --> 08:08:31,840
stop when i stops being

12083
08:08:31,840 --> 08:08:34,160
less than ten this is one way you can

12084
08:08:34,160 --> 08:08:36,638
understand this after we have our test

12085
08:08:36,638 --> 08:08:38,160
and we're going to put the

12086
08:08:38,160 --> 08:08:40,398
incrementation part which is going to

12087
08:08:40,398 --> 08:08:42,958
change the iterator to make the loop

12088
08:08:42,958 --> 08:08:45,040
move forward and we're going to do that

12089
08:08:45,040 --> 08:08:48,000
by incrementing our iterator after that

12090
08:08:48,000 --> 08:08:50,478
we're going to put a pair of curly

12091
08:08:50,478 --> 08:08:52,558
braces not angle brackets and we're

12092
08:08:52,558 --> 08:08:55,120
going to fall inside the body of the

12093
08:08:55,120 --> 08:08:57,840
loop this block here delimitated by the

12094
08:08:57,840 --> 08:09:00,638
curly braces is the body of the loop and

12095
08:09:00,638 --> 08:09:02,798
inside here we're going to put whatever

12096
08:09:02,798 --> 08:09:04,798
we want the loop to run so we can go

12097
08:09:04,798 --> 08:09:07,520
down here and say i love c plus plus 10

12098
08:09:07,520 --> 08:09:10,080
times let's say that but before we do

12099
08:09:10,080 --> 08:09:12,478
that let's say i so that we know the

12100
08:09:12,478 --> 08:09:15,040
current iteration where we are at

12101
08:09:15,040 --> 08:09:17,120
and we're going to put a column and say

12102
08:09:17,120 --> 08:09:20,000
i love c plus plus this is going to be

12103
08:09:20,000 --> 08:09:23,200
better to follow in the terminal i guess

12104
08:09:23,200 --> 08:09:25,680
and we're going to put in our

12105
08:09:25,680 --> 08:09:28,000
new line character

12106
08:09:28,000 --> 08:09:30,398
move to the new line

12107
08:09:30,398 --> 08:09:33,440
and we need to put our stream output

12108
08:09:33,440 --> 08:09:36,000
operator here for this to make sense to

12109
08:09:36,000 --> 08:09:38,798
the compiler and this is our loop now if

12110
08:09:38,798 --> 08:09:40,718
we run it we're going to see exactly the

12111
08:09:40,718 --> 08:09:42,478
same thing like this but we're going to

12112
08:09:42,478 --> 08:09:45,360
have these iterators prepended to the

12113
08:09:45,360 --> 08:09:47,600
message so that it becomes easy to

12114
08:09:47,600 --> 08:09:50,320
follow this and again how this is going

12115
08:09:50,320 --> 08:09:53,760
to work we are going to run our code to

12116
08:09:53,760 --> 08:09:56,718
declare and initialize the iterator

12117
08:09:56,718 --> 08:09:58,958
after that we're going to do the test we

12118
08:09:58,958 --> 08:10:01,760
are going to start with i zero so zero

12119
08:10:01,760 --> 08:10:03,760
is less than ten this is going to

12120
08:10:03,760 --> 08:10:05,760
succeed we are going to fall in the body

12121
08:10:05,760 --> 08:10:06,558
here

12122
08:10:06,558 --> 08:10:08,798
and after that we're going to

12123
08:10:08,798 --> 08:10:11,600
print sddc out i love c plus plus and

12124
08:10:11,600 --> 08:10:13,520
this is going to be zero we're going to

12125
08:10:13,520 --> 08:10:15,120
increment i

12126
08:10:15,120 --> 08:10:17,760
and we're going to do the test again

12127
08:10:17,760 --> 08:10:20,320
we're going to have to do is one less

12128
08:10:20,320 --> 08:10:21,920
than 10 the test is going to be

12129
08:10:21,920 --> 08:10:23,600
successful so we're going to fall in

12130
08:10:23,600 --> 08:10:26,160
here and we're going to print a one

12131
08:10:26,160 --> 08:10:27,120
and we're going to run the

12132
08:10:27,120 --> 08:10:29,360
incrementation part again we're going to

12133
08:10:29,360 --> 08:10:31,120
run the test and we're going to keep

12134
08:10:31,120 --> 08:10:32,798
doing this until we hit a point for

12135
08:10:32,798 --> 08:10:35,440
example when we increment this to be a

12136
08:10:35,440 --> 08:10:36,320
nine

12137
08:10:36,320 --> 08:10:37,920
and after that we're going to run the

12138
08:10:37,920 --> 08:10:39,920
test we're going to say is 9 less than

12139
08:10:39,920 --> 08:10:42,558
10 the test is going to be successful so

12140
08:10:42,558 --> 08:10:43,920
we're going to follow in here and we're

12141
08:10:43,920 --> 08:10:46,398
going to print nine

12142
08:10:46,398 --> 08:10:48,240
and after that we're going to increment

12143
08:10:48,240 --> 08:10:49,200
again we're going to run the

12144
08:10:49,200 --> 08:10:50,878
incrementation part and we're going to

12145
08:10:50,878 --> 08:10:53,600
make i 10 if we run the test we're going

12146
08:10:53,600 --> 08:10:56,958
to say is 10 less than 10 the test here

12147
08:10:56,958 --> 08:10:58,878
is going to fail we're going to stop

12148
08:10:58,878 --> 08:11:00,638
running the loop all together and we're

12149
08:11:00,638 --> 08:11:02,878
going to fall on the outside of the loop

12150
08:11:02,878 --> 08:11:05,920
and say loop done let's say that so that

12151
08:11:05,920 --> 08:11:08,160
we can see this on the terminal and this

12152
08:11:08,160 --> 08:11:10,638
is going to run and print i love c plus

12153
08:11:10,638 --> 08:11:13,760
plus 10 times and we expect i to go from

12154
08:11:13,760 --> 08:11:16,080
zero all the way to nine

12155
08:11:16,080 --> 08:11:18,240
try to run this in your mind

12156
08:11:18,240 --> 08:11:20,558
take a piece of paper try to

12157
08:11:20,558 --> 08:11:22,718
print this as you fall into the body of

12158
08:11:22,718 --> 08:11:24,240
the loop you're going to see that's

12159
08:11:24,240 --> 08:11:26,878
exactly what is happening here so what

12160
08:11:26,878 --> 08:11:28,878
we're going to do we're going to boil

12161
08:11:28,878 --> 08:11:31,920
this again so we're going to run the

12162
08:11:31,920 --> 08:11:33,360
task to

12163
08:11:33,360 --> 08:11:35,040
work with gcc

12164
08:11:35,040 --> 08:11:37,360
the world is good we're going to go down

12165
08:11:37,360 --> 08:11:40,718
and run this we're going to clear

12166
08:11:40,718 --> 08:11:42,160
and run rooster

12167
08:11:42,160 --> 08:11:43,520
and you're going to see that we have

12168
08:11:43,520 --> 08:11:45,760
zero i love c plus plus all the way to

12169
08:11:45,760 --> 08:11:48,638
nine i love c plus plus our loop is

12170
08:11:48,638 --> 08:11:51,040
working exactly the way we want okay so

12171
08:11:51,040 --> 08:11:53,200
this is the first step we are able to

12172
08:11:53,200 --> 08:11:55,520
run our code a lot of times without

12173
08:11:55,520 --> 08:11:57,840
really having to manually do things like

12174
08:11:57,840 --> 08:12:00,398
this and the benefit of this is that if

12175
08:12:00,398 --> 08:12:02,638
we want this to run for example 100

12176
08:12:02,638 --> 08:12:05,600
times all we have to do is change our

12177
08:12:05,600 --> 08:12:06,478
test

12178
08:12:06,478 --> 08:12:08,398
to go until i

12179
08:12:08,398 --> 08:12:11,040
is equal to 100 and we're going to stop

12180
08:12:11,040 --> 08:12:13,040
when i stops being

12181
08:12:13,040 --> 08:12:15,920
less than 100 and if we run this we're

12182
08:12:15,920 --> 08:12:17,040
going to see

12183
08:12:17,040 --> 08:12:20,478
the message from 0 all the way to 99 and

12184
08:12:20,478 --> 08:12:22,398
this is pretty cool the torso is going

12185
08:12:22,398 --> 08:12:25,280
to be 100 times so let's weld again to

12186
08:12:25,280 --> 08:12:27,440
show you how cold this is

12187
08:12:27,440 --> 08:12:29,200
we're going to run this task to weld

12188
08:12:29,200 --> 08:12:31,200
with gcc again

12189
08:12:31,200 --> 08:12:33,120
and we're going to clear

12190
08:12:33,120 --> 08:12:37,120
run rooster prepare to be amazed run and

12191
08:12:37,120 --> 08:12:39,440
it's going to run all the way to 99 we

12192
08:12:39,440 --> 08:12:42,638
can change this to even 1 000 or even 10

12193
08:12:42,638 --> 08:12:45,840
000 why not we're going to weld again

12194
08:12:45,840 --> 08:12:48,798
and we're going to be successful

12195
08:12:48,798 --> 08:12:50,478
and we're going to clear

12196
08:12:50,478 --> 08:12:52,878
and run rooster and this is going to go

12197
08:12:52,878 --> 08:12:54,718
all the way to 10 000 times we're going

12198
08:12:54,718 --> 08:12:56,478
to wait for this to get there

12199
08:12:56,478 --> 08:13:03,520
now 3 000 4 000 5000 6000 7000 8000

12200
08:13:03,520 --> 08:13:05,200
ten thousand it's going to go all the

12201
08:13:05,200 --> 08:13:07,600
way to nine thousand nine hundred ninety

12202
08:13:07,600 --> 08:13:09,760
nine and it is going to stop and the

12203
08:13:09,760 --> 08:13:12,240
total of times the loop run

12204
08:13:12,240 --> 08:13:15,520
was from zero all the way to

12205
08:13:15,520 --> 08:13:18,240
this storping number here okay now we

12206
08:13:18,240 --> 08:13:20,080
can see that our loop is really working

12207
08:13:20,080 --> 08:13:22,798
fine we don't have to do these hddc out

12208
08:13:22,798 --> 08:13:25,680
statements a crazy amount of times okay

12209
08:13:25,680 --> 08:13:28,080
and the benefit again is that

12210
08:13:28,080 --> 08:13:31,600
regardless of the number of times the

12211
08:13:31,600 --> 08:13:33,920
code here is going to run our loop is

12212
08:13:33,920 --> 08:13:36,000
going to stay relatively the same it's

12213
08:13:36,000 --> 08:13:38,638
just going to be one two three four

12214
08:13:38,638 --> 08:13:40,958
lines of code and this is really cool

12215
08:13:40,958 --> 08:13:43,280
okay so i think this now makes it very

12216
08:13:43,280 --> 08:13:45,840
clear how loops work so we're going to

12217
08:13:45,840 --> 08:13:47,680
comment this out and show you another

12218
08:13:47,680 --> 08:13:49,120
thing and we're going to show you that

12219
08:13:49,120 --> 08:13:51,600
you can use size t to actually

12220
08:13:51,600 --> 08:13:54,478
denote the type of your iterator

12221
08:13:54,478 --> 08:13:57,040
and it is easy to do that so we're going

12222
08:13:57,040 --> 08:14:00,080
to say use size t and for us to be able

12223
08:14:00,080 --> 08:14:02,718
to see all this here let's hit this file

12224
08:14:02,718 --> 08:14:05,200
icon here to close this pane and we're

12225
08:14:05,200 --> 08:14:06,638
going to have a better chance of seeing

12226
08:14:06,638 --> 08:14:09,520
our code here so what we want to do

12227
08:14:09,520 --> 08:14:11,040
we're going to declare a group we're

12228
08:14:11,040 --> 08:14:12,958
going to save for we're not going to say

12229
08:14:12,958 --> 08:14:15,760
our design and we're going to say size t

12230
08:14:15,760 --> 08:14:18,160
and this is going to be the type of our

12231
08:14:18,160 --> 08:14:20,000
iterator we're going to say i we're

12232
08:14:20,000 --> 08:14:22,398
going to initialize this with a zero

12233
08:14:22,398 --> 08:14:24,398
and we're going to put a semicolon like

12234
08:14:24,398 --> 08:14:26,320
we just did we're going to put in the

12235
08:14:26,320 --> 08:14:29,440
end test we're going to put in the test

12236
08:14:29,440 --> 08:14:32,478
so we're going to say i less than 10

12237
08:14:32,478 --> 08:14:34,080
no problem with us

12238
08:14:34,080 --> 08:14:36,798
and we are going to increment to put in

12239
08:14:36,798 --> 08:14:39,600
place our incrementation part we're

12240
08:14:39,600 --> 08:14:41,040
going to fall in the loop we're going to

12241
08:14:41,040 --> 08:14:43,600
say stdc out this is the code we want to

12242
08:14:43,600 --> 08:14:45,840
run so we're going to put in our

12243
08:14:45,840 --> 08:14:48,160
coverage value for the iterator and

12244
08:14:48,160 --> 08:14:50,320
we're going to say i love c plus plus

12245
08:14:50,320 --> 08:14:52,558
again and we're going to put in our new

12246
08:14:52,558 --> 08:14:55,280
line character and if we build and run

12247
08:14:55,280 --> 08:14:57,280
this it's going to work and run the same

12248
08:14:57,280 --> 08:14:59,760
so let's say loop done here

12249
08:14:59,760 --> 08:15:01,520
so that we know when it's done and we're

12250
08:15:01,520 --> 08:15:03,360
going to weld and run we're going to

12251
08:15:03,360 --> 08:15:05,600
world with gcc

12252
08:15:05,600 --> 08:15:07,760
the world is going to be good

12253
08:15:07,760 --> 08:15:09,440
and what we're going to do we're going

12254
08:15:09,440 --> 08:15:10,958
to clear

12255
08:15:10,958 --> 08:15:13,360
and run rooster and this is going to say

12256
08:15:13,360 --> 08:15:18,080
i love c plus plus 10 times from 0 to 9.

12257
08:15:18,080 --> 08:15:20,080
again the message here is that you can

12258
08:15:20,080 --> 08:15:23,120
use size t to represent the type of your

12259
08:15:23,120 --> 08:15:25,360
iterators and this is the type that is

12260
08:15:25,360 --> 08:15:27,600
even used in the c plus plus standard

12261
08:15:27,600 --> 08:15:30,240
library so this is going to be something

12262
08:15:30,240 --> 08:15:32,638
people expect from your code if you are

12263
08:15:32,638 --> 08:15:35,360
representing sizes in code that should

12264
08:15:35,360 --> 08:15:37,360
be compliant with the c plus plus

12265
08:15:37,360 --> 08:15:40,000
standard library nothing stops you from

12266
08:15:40,000 --> 08:15:42,798
using unsigned it like we do here but

12267
08:15:42,798 --> 08:15:43,920
we're just going to follow the

12268
08:15:43,920 --> 08:15:46,080
convention from the c plus plus standard

12269
08:15:46,080 --> 08:15:48,478
library and use this type here to

12270
08:15:48,478 --> 08:15:51,040
represent all sizes

12271
08:15:51,040 --> 08:15:53,200
and some of you might be wondering how

12272
08:15:53,200 --> 08:15:55,600
big is this thing we have the tools to

12273
08:15:55,600 --> 08:15:56,478
know

12274
08:15:56,478 --> 08:15:58,558
how big it is so let's do that pretty

12275
08:15:58,558 --> 08:16:01,200
fast so we're going to go down here

12276
08:16:01,200 --> 08:16:03,920
and say sddc out and we're going to say

12277
08:16:03,920 --> 08:16:05,520
size of

12278
08:16:05,520 --> 08:16:08,160
size t and we can print this out and

12279
08:16:08,160 --> 08:16:10,160
let's say what we are doing here so that

12280
08:16:10,160 --> 08:16:11,760
it is easy to

12281
08:16:11,760 --> 08:16:14,478
use this code as the reference and if we

12282
08:16:14,478 --> 08:16:17,040
print this out we're going to see

12283
08:16:17,040 --> 08:16:19,280
the size of this thing on the system

12284
08:16:19,280 --> 08:16:21,680
where this code here is going to run

12285
08:16:21,680 --> 08:16:23,360
so we're going to

12286
08:16:23,360 --> 08:16:26,478
build with gcc again

12287
08:16:26,478 --> 08:16:28,558
the bolt is going to be good we're going

12288
08:16:28,558 --> 08:16:31,600
to go here and clear and run rooster

12289
08:16:31,600 --> 08:16:33,280
you're going to see that it is eight

12290
08:16:33,280 --> 08:16:35,120
bytes on my system so you're going to

12291
08:16:35,120 --> 08:16:37,520
have quite a huge range of numbers you

12292
08:16:37,520 --> 08:16:39,840
can put in here because this is going to

12293
08:16:39,840 --> 08:16:41,760
only be positive

12294
08:16:41,760 --> 08:16:43,920
okay if you try to put in a negative

12295
08:16:43,920 --> 08:16:46,160
number you're going to get an underflow

12296
08:16:46,160 --> 08:16:48,398
and we have learned about overflow and

12297
08:16:48,398 --> 08:16:51,680
underfloor in the previous chapter

12298
08:16:51,680 --> 08:16:53,760
okay so let's comment this out and keep

12299
08:16:53,760 --> 08:16:56,478
learning more things about for loops

12300
08:16:56,478 --> 08:16:58,398
okay the next thing i really want you to

12301
08:16:58,398 --> 08:17:01,200
focus on and learn is the scope of the

12302
08:17:01,200 --> 08:17:03,520
iterator and we're going to grab our

12303
08:17:03,520 --> 08:17:05,440
code again here

12304
08:17:05,440 --> 08:17:07,600
so that we can use this

12305
08:17:07,600 --> 08:17:09,360
as a learning tool so we're going to go

12306
08:17:09,360 --> 08:17:12,718
down here and put that in

12307
08:17:12,718 --> 08:17:15,200
and what we're going to have let's move

12308
08:17:15,200 --> 08:17:17,680
this a little bit to the right i think

12309
08:17:17,680 --> 08:17:19,760
we can do something like this i am going

12310
08:17:19,760 --> 08:17:22,080
to select the entire thing here and hit

12311
08:17:22,080 --> 08:17:24,478
tab and it is going to be aligned with

12312
08:17:24,478 --> 08:17:26,558
whatever we have here

12313
08:17:26,558 --> 08:17:28,638
okay so we have our loop it is going to

12314
08:17:28,638 --> 08:17:30,638
run 10 times it's going to print i love

12315
08:17:30,638 --> 08:17:32,798
c plus from 0

12316
08:17:32,798 --> 08:17:34,160
to 9

12317
08:17:34,160 --> 08:17:34,958
but

12318
08:17:34,958 --> 08:17:37,680
what is the scope of this i think here

12319
08:17:37,680 --> 08:17:40,958
and the fact is it is scoped inside this

12320
08:17:40,958 --> 08:17:43,440
loop here you might have guessed that if

12321
08:17:43,440 --> 08:17:46,160
you try to use it outside the loop

12322
08:17:46,160 --> 08:17:47,680
you're going to get a compiler arrow

12323
08:17:47,680 --> 08:17:50,240
because it is only usable inside the

12324
08:17:50,240 --> 08:17:53,040
body of the you can also use it inside

12325
08:17:53,040 --> 08:17:55,840
the control part of the loop here but

12326
08:17:55,840 --> 08:17:58,398
you can't use it outside the loop so if

12327
08:17:58,398 --> 08:18:00,958
you try to print i here for example

12328
08:18:00,958 --> 08:18:02,638
you're going to get a compiler error so

12329
08:18:02,638 --> 08:18:04,798
let's try and do that and show you how

12330
08:18:04,798 --> 08:18:06,398
wrong this can be

12331
08:18:06,398 --> 08:18:10,398
so if we try to print i here let's say i

12332
08:18:10,398 --> 08:18:12,958
to make it clear what we want to print

12333
08:18:12,958 --> 08:18:14,478
if we try to do this we're going to get

12334
08:18:14,478 --> 08:18:17,440
a compiler error because i is not in

12335
08:18:17,440 --> 08:18:20,558
scope it is only in scope inside these

12336
08:18:20,558 --> 08:18:23,600
curly braces that show the body part of

12337
08:18:23,600 --> 08:18:25,680
our loop okay visual studio code is

12338
08:18:25,680 --> 08:18:27,200
showing the problem here it's saying

12339
08:18:27,200 --> 08:18:29,840
eyes undefined here so you shouldn't

12340
08:18:29,840 --> 08:18:32,240
really do this but if we move on and

12341
08:18:32,240 --> 08:18:34,080
ignore the message from visual studio

12342
08:18:34,080 --> 08:18:36,160
code and compile

12343
08:18:36,160 --> 08:18:37,760
we're going to get a compiler error and

12344
08:18:37,760 --> 08:18:39,040
it's going to say

12345
08:18:39,040 --> 08:18:41,360
i don't know what you're doing here i

12346
08:18:41,360 --> 08:18:44,240
was not declared in this scope where you

12347
08:18:44,240 --> 08:18:46,478
are using it and i think it's even going

12348
08:18:46,478 --> 08:18:48,240
to give me a line a number it's going to

12349
08:18:48,240 --> 08:18:51,440
tell me 46 that's where you are doing

12350
08:18:51,440 --> 08:18:53,680
something wrong and if we go in our code

12351
08:18:53,680 --> 08:18:55,840
we're going to see that this is the line

12352
08:18:55,840 --> 08:18:58,478
where we are making the mistake so i is

12353
08:18:58,478 --> 08:19:00,638
not in scope here we're going to comment

12354
08:19:00,638 --> 08:19:04,718
this out and say compiler error i is not

12355
08:19:04,718 --> 08:19:06,638
in scope that's what you're going to get

12356
08:19:06,638 --> 08:19:08,718
if you try to do this and the main

12357
08:19:08,718 --> 08:19:11,440
message is that if you declare your loop

12358
08:19:11,440 --> 08:19:14,318
like this ah is only going to be scoped

12359
08:19:14,318 --> 08:19:16,080
in the body of the loop and that's the

12360
08:19:16,080 --> 08:19:18,398
only place where you can mention its

12361
08:19:18,398 --> 08:19:20,638
name and use it if we comment this out

12362
08:19:20,638 --> 08:19:23,520
and world again the compiler error is

12363
08:19:23,520 --> 08:19:25,200
going to go away you're going to see

12364
08:19:25,200 --> 08:19:27,440
that the world is good let's clear so

12365
08:19:27,440 --> 08:19:30,318
that our output here is good

12366
08:19:30,318 --> 08:19:31,760
we're going to build again and show you

12367
08:19:31,760 --> 08:19:34,000
that the build is good and uh this is

12368
08:19:34,000 --> 08:19:36,478
really cool both finished successfully

12369
08:19:36,478 --> 08:19:39,200
okay this is one way we can set up our

12370
08:19:39,200 --> 08:19:42,160
loop but there is a way we can make our

12371
08:19:42,160 --> 08:19:45,600
iterator usable outside the body of the

12372
08:19:45,600 --> 08:19:46,878
loop and we're going to show you how you

12373
08:19:46,878 --> 08:19:49,280
can do that next so let's comment this

12374
08:19:49,280 --> 08:19:51,520
out and go down again

12375
08:19:51,520 --> 08:19:53,280
and we're going to grab the code because

12376
08:19:53,280 --> 08:19:55,760
we don't want to type all this again and

12377
08:19:55,760 --> 08:19:58,718
we're going to say iterator declared

12378
08:19:58,718 --> 08:20:01,680
outside the loop we're going to go down

12379
08:20:01,680 --> 08:20:04,080
and put in our code

12380
08:20:04,080 --> 08:20:07,280
and we're going to align this nicely

12381
08:20:07,280 --> 08:20:10,718
and we're going to take the iterator and

12382
08:20:10,718 --> 08:20:13,280
declare it on the outside of the loop so

12383
08:20:13,280 --> 08:20:15,520
we're going to say size t

12384
08:20:15,520 --> 08:20:17,680
and we're going to say i and initialize

12385
08:20:17,680 --> 08:20:19,440
this to 0

12386
08:20:19,440 --> 08:20:23,120
and we're going to say this very clearly

12387
08:20:23,120 --> 08:20:25,520
iterator

12388
08:20:25,520 --> 08:20:28,398
defined

12389
08:20:28,398 --> 08:20:30,240
outside

12390
08:20:30,240 --> 08:20:33,010
and we're going to say in our

12391
08:20:33,010 --> 08:20:34,160
[Music]

12392
08:20:34,160 --> 08:20:36,718
declaration part of the iterator we're

12393
08:20:36,718 --> 08:20:38,798
going to just say i and this is going to

12394
08:20:38,798 --> 08:20:41,520
work pretty fine if we build this you're

12395
08:20:41,520 --> 08:20:43,600
going to see that the world is good and

12396
08:20:43,600 --> 08:20:45,600
if we run this it's going to do the same

12397
08:20:45,600 --> 08:20:47,280
thing it's been doing it's going to

12398
08:20:47,280 --> 08:20:50,160
print i love c plus plus 10 times and if

12399
08:20:50,160 --> 08:20:52,798
you want i usable on the outside of the

12400
08:20:52,798 --> 08:20:55,040
loop now you can use it we can grab the

12401
08:20:55,040 --> 08:20:57,920
code here that was failing

12402
08:20:57,920 --> 08:21:01,280
in the last run of our code and put that

12403
08:21:01,280 --> 08:21:03,360
out here and we're going to align this a

12404
08:21:03,360 --> 08:21:05,040
little bit

12405
08:21:05,040 --> 08:21:07,360
and if we compile this the book is going

12406
08:21:07,360 --> 08:21:08,878
to be good

12407
08:21:08,878 --> 08:21:11,200
and if we try to run rooster we're going

12408
08:21:11,200 --> 08:21:13,920
to see i love c plus 10 times we're

12409
08:21:13,920 --> 08:21:15,600
going to say loop done and we're going

12410
08:21:15,600 --> 08:21:18,240
to print the value of i and you see that

12411
08:21:18,240 --> 08:21:20,398
if we do things like this i is going to

12412
08:21:20,398 --> 08:21:23,040
be usable on the outside of the loop

12413
08:21:23,040 --> 08:21:23,920
body

12414
08:21:23,920 --> 08:21:26,718
and sometimes these may come in handy

12415
08:21:26,718 --> 08:21:28,398
depending on the logic of the

12416
08:21:28,398 --> 08:21:30,718
application that you are designing just

12417
08:21:30,718 --> 08:21:33,040
know that this is something you can do

12418
08:21:33,040 --> 08:21:34,878
in your loops

12419
08:21:34,878 --> 08:21:38,318
okay you can go even crazier and leave

12420
08:21:38,318 --> 08:21:41,840
out this iterator declaration part in

12421
08:21:41,840 --> 08:21:44,000
your loop all together so you can remove

12422
08:21:44,000 --> 08:21:45,680
that and we're going to show you how you

12423
08:21:45,680 --> 08:21:47,520
can do that in a minute so let's comment

12424
08:21:47,520 --> 08:21:49,520
this out i don't want to remove code

12425
08:21:49,520 --> 08:21:51,200
because i want you to have this as a

12426
08:21:51,200 --> 08:21:53,120
reference if you need to look at this

12427
08:21:53,120 --> 08:21:56,080
later so we're going to say leave out

12428
08:21:56,080 --> 08:21:59,040
and what you can do is grab the code we

12429
08:21:59,040 --> 08:22:02,798
had before i'm going to grab it

12430
08:22:02,798 --> 08:22:05,040
and we're going to paste that in here

12431
08:22:05,040 --> 08:22:06,798
and what we're going to do is take out

12432
08:22:06,798 --> 08:22:08,958
this eye this can work and you may see

12433
08:22:08,958 --> 08:22:12,398
code like this out there in the wild so

12434
08:22:12,398 --> 08:22:14,080
we're going to run this task to build

12435
08:22:14,080 --> 08:22:17,040
with gcc the world is going to be good

12436
08:22:17,040 --> 08:22:19,440
and we're going to clear and run rooster

12437
08:22:19,440 --> 08:22:21,040
and it's going to do exactly the same

12438
08:22:21,040 --> 08:22:23,280
thing so this is one way you can set up

12439
08:22:23,280 --> 08:22:25,680
your loops okay the last thing we need

12440
08:22:25,680 --> 08:22:28,318
to see about loops is that

12441
08:22:28,318 --> 08:22:30,958
this test here is using a hard coded

12442
08:22:30,958 --> 08:22:33,280
value and if we needed to change this

12443
08:22:33,280 --> 08:22:35,360
loop to run for example for a thousand

12444
08:22:35,360 --> 08:22:38,000
times we would need to manually hunt for

12445
08:22:38,000 --> 08:22:40,318
this line of code change this and this

12446
08:22:40,318 --> 08:22:43,040
is really not good design so what is

12447
08:22:43,040 --> 08:22:45,360
recommended is to store this value in a

12448
08:22:45,360 --> 08:22:48,318
variable and test against that variable

12449
08:22:48,318 --> 08:22:50,080
name instead

12450
08:22:50,080 --> 08:22:52,558
let's comment this out and show you that

12451
08:22:52,558 --> 08:22:54,000
so we're going to

12452
08:22:54,000 --> 08:22:55,680
comment this out

12453
08:22:55,680 --> 08:22:58,958
and go down and copy this entire thing

12454
08:22:58,958 --> 08:23:00,718
i don't think i want to do my loops like

12455
08:23:00,718 --> 08:23:02,798
this because this is really unintuitive

12456
08:23:02,798 --> 08:23:06,080
most times so i am going to declare my

12457
08:23:06,080 --> 08:23:08,478
iterator inside and i'm going to copy

12458
08:23:08,478 --> 08:23:10,878
the code that does that here we're going

12459
08:23:10,878 --> 08:23:12,318
to go down

12460
08:23:12,318 --> 08:23:13,680
and say

12461
08:23:13,680 --> 08:23:16,478
don't hardcord values okay we're going

12462
08:23:16,478 --> 08:23:18,638
to say that it's really bad

12463
08:23:18,638 --> 08:23:20,318
and we're going to go down and show you

12464
08:23:20,318 --> 08:23:22,718
a better way to do things and again

12465
08:23:22,718 --> 08:23:25,440
right now we are hard coding in this

12466
08:23:25,440 --> 08:23:28,080
value but we can say const

12467
08:23:28,080 --> 08:23:30,318
size t

12468
08:23:30,318 --> 08:23:32,558
and we can call this value count for

12469
08:23:32,558 --> 08:23:34,478
example and we can initialize it with

12470
08:23:34,478 --> 08:23:36,638
whatever we want in this case we want to

12471
08:23:36,638 --> 08:23:39,760
control our loop to run 10 times so

12472
08:23:39,760 --> 08:23:42,160
we're going to put in a 10 and instead

12473
08:23:42,160 --> 08:23:44,478
of hard coding and this 10 we're going

12474
08:23:44,478 --> 08:23:46,478
to say count

12475
08:23:46,478 --> 08:23:47,440
okay

12476
08:23:47,440 --> 08:23:49,280
and if we build and run it the loop is

12477
08:23:49,280 --> 08:23:51,040
going to do exactly the same thing it's

12478
08:23:51,040 --> 08:23:53,280
going to print i love c plus plus 10

12479
08:23:53,280 --> 08:23:54,160
times

12480
08:23:54,160 --> 08:23:56,798
so let's do that

12481
08:23:56,798 --> 08:23:58,398
and run rooster

12482
08:23:58,398 --> 08:24:00,558
it's going to do the same thing but now

12483
08:24:00,558 --> 08:24:02,798
we have one point of control if we want

12484
08:24:02,798 --> 08:24:06,240
this to run for let's say 100 times we

12485
08:24:06,240 --> 08:24:09,200
can change the count value to 100 times

12486
08:24:09,200 --> 08:24:11,280
and if we both again that's how many

12487
08:24:11,280 --> 08:24:13,040
times the loop is going to run and this

12488
08:24:13,040 --> 08:24:15,520
is much cleaner so i do recommend you

12489
08:24:15,520 --> 08:24:16,558
store

12490
08:24:16,558 --> 08:24:18,318
the values you use in your loops in

12491
08:24:18,318 --> 08:24:20,080
variables like this and it's going to

12492
08:24:20,080 --> 08:24:22,798
make your code look better

12493
08:24:22,798 --> 08:24:25,520
so it's going to run 100 times and this

12494
08:24:25,520 --> 08:24:27,680
is exactly what we want

12495
08:24:27,680 --> 08:24:29,200
this is really all we set out to do in

12496
08:24:29,200 --> 08:24:30,718
this lecture i hope you found it

12497
08:24:30,718 --> 08:24:31,840
interesting

12498
08:24:31,840 --> 08:24:34,398
i am sorry that this lecture turned out

12499
08:24:34,398 --> 08:24:36,240
lengthy because we had a lot of things

12500
08:24:36,240 --> 08:24:39,360
to talk about but now i hope you really

12501
08:24:39,360 --> 08:24:41,600
know a lot of things about ways you can

12502
08:24:41,600 --> 08:24:44,080
use your for loops to make them do

12503
08:24:44,080 --> 08:24:46,478
things and again many loops that we're

12504
08:24:46,478 --> 08:24:48,318
going to use in our c plus plus code are

12505
08:24:48,318 --> 08:24:50,398
going to have five parts we're going to

12506
08:24:50,398 --> 08:24:52,318
have an iterator which is going to be a

12507
08:24:52,318 --> 08:24:55,200
variable we use to manipulate how a loop

12508
08:24:55,200 --> 08:24:57,120
moves forward and does things the

12509
08:24:57,120 --> 08:24:59,040
starting point is going to be where the

12510
08:24:59,040 --> 08:25:00,798
loop is going to start we're going to

12511
08:25:00,798 --> 08:25:02,398
have a test in place which is going to

12512
08:25:02,398 --> 08:25:04,398
control when the loop ends and we're

12513
08:25:04,398 --> 08:25:06,718
going to have the end point encoded in

12514
08:25:06,718 --> 08:25:08,240
that test we're going to have the

12515
08:25:08,240 --> 08:25:10,160
incrementation part of the loop which is

12516
08:25:10,160 --> 08:25:12,878
going to control how our loop moves

12517
08:25:12,878 --> 08:25:14,798
forward and we are going to set up a

12518
08:25:14,798 --> 08:25:18,000
pair of curly braces that are going to

12519
08:25:18,000 --> 08:25:20,958
contain the body of our loop in this

12520
08:25:20,958 --> 08:25:22,958
lecture we're going to learn about while

12521
08:25:22,958 --> 08:25:25,200
loops and this is another construct we

12522
08:25:25,200 --> 08:25:27,600
have in the c plus plus programming

12523
08:25:27,600 --> 08:25:29,680
language to allow us to do repetitive

12524
08:25:29,680 --> 08:25:32,558
tasks the syntax for a while loop looks

12525
08:25:32,558 --> 08:25:35,520
like this we have five parts in our loop

12526
08:25:35,520 --> 08:25:37,600
we have the iterator the starting point

12527
08:25:37,600 --> 08:25:40,000
the test the incrementation and the loop

12528
08:25:40,000 --> 08:25:41,840
body it's just going to be set up

12529
08:25:41,840 --> 08:25:45,280
differently for while loops the iterator

12530
08:25:45,280 --> 08:25:47,760
is declared on the outside and you see

12531
08:25:47,760 --> 08:25:49,760
here we have unsigned in i which is

12532
08:25:49,760 --> 08:25:52,240
exactly the same type of iterator we've

12533
08:25:52,240 --> 08:25:54,318
used in the last lecture but know that

12534
08:25:54,318 --> 08:25:56,798
you can also use size t here i am just

12535
08:25:56,798 --> 08:25:59,440
using unsigned and for this case after

12536
08:25:59,440 --> 08:26:02,718
you have your iterator declared you're

12537
08:26:02,718 --> 08:26:04,958
going to fall to this part here and say

12538
08:26:04,958 --> 08:26:08,080
while open a set of parentheses and

12539
08:26:08,080 --> 08:26:10,878
inside you're going to put in your test

12540
08:26:10,878 --> 08:26:12,798
after that you're going to open a pair

12541
08:26:12,798 --> 08:26:15,200
of curly braces and design them you're

12542
08:26:15,200 --> 08:26:17,920
going to put the body of your loop

12543
08:26:17,920 --> 08:26:19,360
and you're going to do whatever it is

12544
08:26:19,360 --> 08:26:22,478
you want to do in the loop in there and

12545
08:26:22,478 --> 08:26:24,398
after your code to do whatever it is you

12546
08:26:24,398 --> 08:26:26,718
want to do is executed you're going to

12547
08:26:26,718 --> 08:26:29,760
put in your incrementation part after

12548
08:26:29,760 --> 08:26:32,000
you code and that's what we have here

12549
08:26:32,000 --> 08:26:33,680
and this is the setup we're going to be

12550
08:26:33,680 --> 08:26:37,040
using for our while loops again

12551
08:26:37,040 --> 08:26:38,478
we have the

12552
08:26:38,478 --> 08:26:41,200
iterator declared on the outside and we

12553
08:26:41,200 --> 08:26:43,520
can initialize it with whatever it is we

12554
08:26:43,520 --> 08:26:44,798
want to

12555
08:26:44,798 --> 08:26:46,160
start with

12556
08:26:46,160 --> 08:26:48,080
then we're going to put in our test it's

12557
08:26:48,080 --> 08:26:50,160
going to be within this parenthesis and

12558
08:26:50,160 --> 08:26:52,318
after that we're going to set up a pair

12559
08:26:52,318 --> 08:26:54,798
of curly braces and inside them we're

12560
08:26:54,798 --> 08:26:56,558
going to put whatever code we want to

12561
08:26:56,558 --> 08:26:58,478
run in the loop and then we're going to

12562
08:26:58,478 --> 08:27:01,200
follow that with our incrementation part

12563
08:27:01,200 --> 08:27:03,040
and if we try to run this we're going to

12564
08:27:03,040 --> 08:27:05,120
run this line we're going to declare the

12565
08:27:05,120 --> 08:27:07,440
iterator i and it's going to start with

12566
08:27:07,440 --> 08:27:10,798
zero so the test is going to run and 0

12567
08:27:10,798 --> 08:27:12,558
is less than 10

12568
08:27:12,558 --> 08:27:14,398
and we're going to succeed and we're

12569
08:27:14,398 --> 08:27:16,000
going to run the body here we're going

12570
08:27:16,000 --> 08:27:18,478
to say i love c plus plus and after that

12571
08:27:18,478 --> 08:27:20,080
we're going to run the incrementation

12572
08:27:20,080 --> 08:27:22,798
part i is going to become one we're

12573
08:27:22,798 --> 08:27:25,520
going to run the test again so one is

12574
08:27:25,520 --> 08:27:27,200
less than 10 we're going to succeed

12575
08:27:27,200 --> 08:27:29,520
we're going to fall in print i love c

12576
08:27:29,520 --> 08:27:31,680
plus plus we're going to increment again

12577
08:27:31,680 --> 08:27:34,478
then we're going to have a 2 in i here

12578
08:27:34,478 --> 08:27:36,318
we're going to run the test again we're

12579
08:27:36,318 --> 08:27:38,638
going to say is 2 less than 10 that's

12580
08:27:38,638 --> 08:27:40,160
going to be true so we're going to be

12581
08:27:40,160 --> 08:27:42,478
successful we're going to fall in the

12582
08:27:42,478 --> 08:27:44,080
body of the loop we're going to

12583
08:27:44,080 --> 08:27:46,080
increment and get a three we're going to

12584
08:27:46,080 --> 08:27:48,878
test against our three value three is

12585
08:27:48,878 --> 08:27:50,478
less than ten we're going to succeed

12586
08:27:50,478 --> 08:27:53,200
we're going to print i love c plus plus

12587
08:27:53,200 --> 08:27:55,120
we're going to increment again we're

12588
08:27:55,120 --> 08:27:57,280
going to test again and we're going to

12589
08:27:57,280 --> 08:28:01,040
say is for less than count or 10 we're

12590
08:28:01,040 --> 08:28:02,558
going to be successful and we're going

12591
08:28:02,558 --> 08:28:04,798
to keep running until we increment and

12592
08:28:04,798 --> 08:28:07,360
get a 9. once we get a 9 we're going to

12593
08:28:07,360 --> 08:28:09,520
run the test again and we're going to

12594
08:28:09,520 --> 08:28:12,000
say is 9 less than 10 that's going to be

12595
08:28:12,000 --> 08:28:14,958
successful so we're going to fall inside

12596
08:28:14,958 --> 08:28:16,958
print i love c plus plus we're going to

12597
08:28:16,958 --> 08:28:18,958
increment and get a 10

12598
08:28:18,958 --> 08:28:20,958
and if we run the test again i'm going

12599
08:28:20,958 --> 08:28:23,920
to say is 10 less than 10 that's going

12600
08:28:23,920 --> 08:28:26,478
to fail and we are going to fall on the

12601
08:28:26,478 --> 08:28:27,920
outside of the loop and we're going to

12602
08:28:27,920 --> 08:28:30,318
run whatever code is on the outside here

12603
08:28:30,318 --> 08:28:32,718
this is really how a while loop works

12604
08:28:32,718 --> 08:28:34,718
and i hope you can see the similarities

12605
08:28:34,718 --> 08:28:36,878
between the for loop we have seen it is

12606
08:28:36,878 --> 08:28:38,878
really the same thing we just have

12607
08:28:38,878 --> 08:28:41,200
different syntaxes to do these things

12608
08:28:41,200 --> 08:28:42,878
okay if you look at these things we

12609
08:28:42,878 --> 08:28:44,240
already have the same pieces of

12610
08:28:44,240 --> 08:28:46,318
information it is just different

12611
08:28:46,318 --> 08:28:48,878
syntaxes that c plus plus provides to do

12612
08:28:48,878 --> 08:28:51,040
the same things and sometimes you're

12613
08:28:51,040 --> 08:28:53,280
going to find it convenient to use while

12614
08:28:53,280 --> 08:28:54,878
loops and sometimes you're going to find

12615
08:28:54,878 --> 08:28:57,440
it convenient to use for loops and

12616
08:28:57,440 --> 08:28:59,040
you're going to have to decide what

12617
08:28:59,040 --> 08:29:01,520
works better for whatever it is you are

12618
08:29:01,520 --> 08:29:03,600
working on for now we're going to head

12619
08:29:03,600 --> 08:29:05,840
over to visual studio code and try this

12620
08:29:05,840 --> 08:29:08,318
out okay here we are in visual studio

12621
08:29:08,318 --> 08:29:10,958
code the current project is while loop

12622
08:29:10,958 --> 08:29:13,520
we're going to grab our template files

12623
08:29:13,520 --> 08:29:15,280
and we're going to go in our project and

12624
08:29:15,280 --> 08:29:16,798
put those in

12625
08:29:16,798 --> 08:29:18,718
and we're going to open this in visual

12626
08:29:18,718 --> 08:29:21,680
studio code so let's do that

12627
08:29:21,680 --> 08:29:24,080
we're going to open the folder

12628
08:29:24,080 --> 08:29:26,000
and we're going to work on while loop

12629
08:29:26,000 --> 08:29:28,638
here we are going to open our main cpp

12630
08:29:28,638 --> 08:29:30,638
file pretty quick and we're going to get

12631
08:29:30,638 --> 08:29:33,200
rid of this and what we're going to do

12632
08:29:33,200 --> 08:29:35,520
is remove what we don't need and again

12633
08:29:35,520 --> 08:29:36,878
we're going to show you the bad way to

12634
08:29:36,878 --> 08:29:38,478
do things you don't really want to do

12635
08:29:38,478 --> 08:29:40,478
this manually we want to print i love c

12636
08:29:40,478 --> 08:29:42,318
plus plus 10 times

12637
08:29:42,318 --> 08:29:43,120
so

12638
08:29:43,120 --> 08:29:45,040
we're going to build let's bring up a

12639
08:29:45,040 --> 08:29:47,120
new terminal so that we can

12640
08:29:47,120 --> 08:29:49,920
use this when we run thanks and we are

12641
08:29:49,920 --> 08:29:52,558
going to world with gcc let's do that

12642
08:29:52,558 --> 08:29:55,040
pretty quick the world is good

12643
08:29:55,040 --> 08:29:57,680
so we can clear and run rooster and

12644
08:29:57,680 --> 08:29:59,520
we're going to have i love c plus

12645
08:29:59,520 --> 08:30:02,478
printed out 10 times so what we can do

12646
08:30:02,478 --> 08:30:05,840
is comment this out and use a while loop

12647
08:30:05,840 --> 08:30:08,080
like we want to do in this lecture here

12648
08:30:08,080 --> 08:30:11,040
and as we have seen with the slides

12649
08:30:11,040 --> 08:30:13,520
the first thing we need to do is declare

12650
08:30:13,520 --> 08:30:15,520
our iterator on the outside so we're

12651
08:30:15,520 --> 08:30:17,280
going to say size ti we're going to

12652
08:30:17,280 --> 08:30:19,280
initialize this with zero

12653
08:30:19,280 --> 08:30:21,360
and that's going to be our iterator

12654
08:30:21,360 --> 08:30:24,240
declaration and we're going to say while

12655
08:30:24,240 --> 08:30:26,558
i is less than the value where we want

12656
08:30:26,558 --> 08:30:28,798
to stop and again we don't want to hard

12657
08:30:28,798 --> 08:30:30,718
code these values and so what we're

12658
08:30:30,718 --> 08:30:32,398
going to say is really

12659
08:30:32,398 --> 08:30:35,200
const size t and we're going to call

12660
08:30:35,200 --> 08:30:38,080
this count and make it uppercase this is

12661
08:30:38,080 --> 08:30:40,160
a convention we use to declare constants

12662
08:30:40,160 --> 08:30:42,160
in c plus plus but you don't have to

12663
08:30:42,160 --> 08:30:43,840
make them uppercase it is just a

12664
08:30:43,840 --> 08:30:45,840
convention that is going to make your

12665
08:30:45,840 --> 08:30:48,478
code easier to read for other people so

12666
08:30:48,478 --> 08:30:50,000
we're going to

12667
08:30:50,000 --> 08:30:52,558
put a 10 in here because we want our

12668
08:30:52,558 --> 08:30:54,478
loop to run 10 times

12669
08:30:54,478 --> 08:30:56,798
and we're going to say y i

12670
08:30:56,798 --> 08:30:58,798
is less than count and we're going to

12671
08:30:58,798 --> 08:31:02,000
set up a pair of curly braces and they

12672
08:31:02,000 --> 08:31:03,920
are going to delimitate

12673
08:31:03,920 --> 08:31:07,200
the start and the end of the body of a

12674
08:31:07,200 --> 08:31:09,200
loop here and inside we're going to put

12675
08:31:09,200 --> 08:31:11,440
in whatever code we want the loop to run

12676
08:31:11,440 --> 08:31:14,638
multiple times and the code is now very

12677
08:31:14,638 --> 08:31:17,920
familiar we're going to say sddc out

12678
08:31:17,920 --> 08:31:19,680
and we're going to print the

12679
08:31:19,680 --> 08:31:22,160
current iteration and we're going to say

12680
08:31:22,160 --> 08:31:25,920
i love c plus plus sdd endl for our new

12681
08:31:25,920 --> 08:31:28,000
line character and after that we will

12682
08:31:28,000 --> 08:31:30,558
need to put in our own incrementation

12683
08:31:30,558 --> 08:31:32,718
part if you forget that you're going to

12684
08:31:32,718 --> 08:31:34,798
get something really bad happen we're

12685
08:31:34,798 --> 08:31:37,120
really going to look at that later in

12686
08:31:37,120 --> 08:31:40,240
the chapter but for now remember to put

12687
08:31:40,240 --> 08:31:42,718
the incrementation part and we're going

12688
08:31:42,718 --> 08:31:45,440
to say plus plus i this is really easy

12689
08:31:45,440 --> 08:31:47,440
and we're going to say that this is the

12690
08:31:47,440 --> 08:31:49,200
test

12691
08:31:49,200 --> 08:31:51,440
and this is going to do what we want but

12692
08:31:51,440 --> 08:31:54,160
let's go down here and say that loop is

12693
08:31:54,160 --> 08:31:56,318
done when it is done so we're going to

12694
08:31:56,318 --> 08:31:59,760
say loop done

12695
08:31:59,760 --> 08:32:03,440
and we're going to say stdendya

12696
08:32:03,440 --> 08:32:05,200
and before we run this we're going to go

12697
08:32:05,200 --> 08:32:07,440
through it and see how it is going to

12698
08:32:07,440 --> 08:32:10,558
work so let's click on this file icon

12699
08:32:10,558 --> 08:32:12,878
here to close this pane so that we have

12700
08:32:12,878 --> 08:32:15,280
some breathing room i am going to open a

12701
08:32:15,280 --> 08:32:17,760
notepad file we're going to use to see

12702
08:32:17,760 --> 08:32:20,398
these things really happen

12703
08:32:20,398 --> 08:32:22,318
when this loop runs we're going to

12704
08:32:22,318 --> 08:32:25,120
initialize the iterator here what we're

12705
08:32:25,120 --> 08:32:27,200
going to do is put in a 0 and we are

12706
08:32:27,200 --> 08:32:29,840
going to run the test to see if 0 is

12707
08:32:29,840 --> 08:32:31,840
less than 10 and the test is going to be

12708
08:32:31,840 --> 08:32:34,240
successful so we are going to fall in

12709
08:32:34,240 --> 08:32:35,920
here and say

12710
08:32:35,920 --> 08:32:38,558
0 i love c plus plus so let's say that

12711
08:32:38,558 --> 08:32:41,200
here to make this super clear inside the

12712
08:32:41,200 --> 08:32:42,798
loop we're going to print this message

12713
08:32:42,798 --> 08:32:45,200
zero i love c plus plus and after we

12714
08:32:45,200 --> 08:32:47,040
execute this line we're going to

12715
08:32:47,040 --> 08:32:49,840
increment i is going to become one we're

12716
08:32:49,840 --> 08:32:51,680
going to go up again and run the test

12717
08:32:51,680 --> 08:32:54,080
and we're going to say is 1

12718
08:32:54,080 --> 08:32:57,520
less than count or is 1 less than 10.

12719
08:32:57,520 --> 08:32:59,520
the test is going to be successful we're

12720
08:32:59,520 --> 08:33:01,360
going to run inside the loop and we're

12721
08:33:01,360 --> 08:33:03,920
going to print 1 i love c plus plus

12722
08:33:03,920 --> 08:33:05,200
that's what we're going to do here so

12723
08:33:05,200 --> 08:33:07,120
let's do that

12724
08:33:07,120 --> 08:33:08,718
and after we do that we're going to run

12725
08:33:08,718 --> 08:33:11,200
our incrementation part again

12726
08:33:11,200 --> 08:33:13,600
i is going to become two we are going to

12727
08:33:13,600 --> 08:33:15,680
run the test we're going to say is 2

12728
08:33:15,680 --> 08:33:17,920
less than 10 that's going to be true of

12729
08:33:17,920 --> 08:33:19,600
course and we're going to fall in the

12730
08:33:19,600 --> 08:33:22,718
body again and say two i love c plus

12731
08:33:22,718 --> 08:33:23,920
plus

12732
08:33:23,920 --> 08:33:25,840
so let's say that

12733
08:33:25,840 --> 08:33:27,280
we're going to increment and we're going

12734
08:33:27,280 --> 08:33:28,878
to get a three we're going to run the

12735
08:33:28,878 --> 08:33:30,398
test again the test is going to be

12736
08:33:30,398 --> 08:33:32,558
successful because three is less than

12737
08:33:32,558 --> 08:33:35,200
ten we are going to fall in here and say

12738
08:33:35,200 --> 08:33:38,000
three i love c plus plus okay so we can

12739
08:33:38,000 --> 08:33:40,240
really follow this

12740
08:33:40,240 --> 08:33:42,080
and we are going to increment to get a

12741
08:33:42,080 --> 08:33:44,718
four and the test is going to say is

12742
08:33:44,718 --> 08:33:47,120
four less than ten that's going to be

12743
08:33:47,120 --> 08:33:48,638
true so we're going to succeed and

12744
08:33:48,638 --> 08:33:50,478
following the body again and we're going

12745
08:33:50,478 --> 08:33:53,760
to say 4 i love z plus blocks

12746
08:33:53,760 --> 08:33:55,280
we're going to keep doing this and we're

12747
08:33:55,280 --> 08:33:56,638
going to increment again we're going to

12748
08:33:56,638 --> 08:33:59,120
get a 5. the test is going to run again

12749
08:33:59,120 --> 08:34:01,200
we're going to say is 5 less than 10

12750
08:34:01,200 --> 08:34:03,280
that's going to be true of course and

12751
08:34:03,280 --> 08:34:05,600
we're going to run the code to print

12752
08:34:05,600 --> 08:34:08,398
five i love c plus plus

12753
08:34:08,398 --> 08:34:10,080
we're going to increment again to get a

12754
08:34:10,080 --> 08:34:11,760
six

12755
08:34:11,760 --> 08:34:13,520
we're going to run the test we're going

12756
08:34:13,520 --> 08:34:16,000
to say is 6 less than 10 that's going to

12757
08:34:16,000 --> 08:34:18,160
be true of course again and we're going

12758
08:34:18,160 --> 08:34:21,280
to print sets i love c plus plus and

12759
08:34:21,280 --> 08:34:23,120
we're going to increment to get a 7

12760
08:34:23,120 --> 08:34:25,760
we're going to run the test our iterator

12761
08:34:25,760 --> 08:34:28,798
we're going to say is 7 less than count

12762
08:34:28,798 --> 08:34:30,878
that's going to be true we're going to

12763
08:34:30,878 --> 08:34:33,600
print the message again and say seven i

12764
08:34:33,600 --> 08:34:35,680
love c plus plus and we're going to

12765
08:34:35,680 --> 08:34:37,680
increment again to get an eight we're

12766
08:34:37,680 --> 08:34:39,360
going to say is eight less than and

12767
08:34:39,360 --> 08:34:40,318
count

12768
08:34:40,318 --> 08:34:41,840
that's going to be true we're going to

12769
08:34:41,840 --> 08:34:44,718
fall in the body and say eight i love c

12770
08:34:44,718 --> 08:34:47,200
plus plus we're going to increment to

12771
08:34:47,200 --> 08:34:48,798
get a nine

12772
08:34:48,798 --> 08:34:50,718
we're going to run the test against our

12773
08:34:50,718 --> 08:34:54,000
nine of course nine is less than ten so

12774
08:34:54,000 --> 08:34:55,680
that's going to be true we're going to

12775
08:34:55,680 --> 08:34:58,878
fall inside and we're going to say nine

12776
08:34:58,878 --> 08:35:00,398
i love c plus plus

12777
08:35:00,398 --> 08:35:02,080
and after that we're going to increment

12778
08:35:02,080 --> 08:35:04,240
again and we're going to get a 10.

12779
08:35:04,240 --> 08:35:06,160
now if we run the test we're going to

12780
08:35:06,160 --> 08:35:09,360
say is 10 less than 10 and that's going

12781
08:35:09,360 --> 08:35:12,000
to be false because 10 is not less than

12782
08:35:12,000 --> 08:35:15,360
10 and if the test here fails we're not

12783
08:35:15,360 --> 08:35:17,280
going to fall in the body of the loop

12784
08:35:17,280 --> 08:35:20,080
control is going to fall at the end of

12785
08:35:20,080 --> 08:35:22,240
the loop body and we're going to print

12786
08:35:22,240 --> 08:35:24,160
loop done that's what we're going to say

12787
08:35:24,160 --> 08:35:26,840
here we're going to say loop

12788
08:35:26,840 --> 08:35:31,360
done and our loop will have run 10 times

12789
08:35:31,360 --> 08:35:33,440
by the time we print this loop down

12790
08:35:33,440 --> 08:35:35,200
message here if you count here you see

12791
08:35:35,200 --> 08:35:37,440
that the loop is going to run 10 times

12792
08:35:37,440 --> 08:35:39,520
and it is going to say i love c plus

12793
08:35:39,520 --> 08:35:41,680
plus 10 times which is really what we

12794
08:35:41,680 --> 08:35:43,840
want okay i really had to show you this

12795
08:35:43,840 --> 08:35:46,000
manually so that you can really see what

12796
08:35:46,000 --> 08:35:48,478
is happening but now we can weld and run

12797
08:35:48,478 --> 08:35:50,878
this and let the computer do the heavy

12798
08:35:50,878 --> 08:35:53,200
duty of running this and showing us all

12799
08:35:53,200 --> 08:35:54,638
these messages

12800
08:35:54,638 --> 08:35:56,478
so the build is going to be successful

12801
08:35:56,478 --> 08:35:57,840
of course

12802
08:35:57,840 --> 08:35:59,680
we're going to run rooster and it's

12803
08:35:59,680 --> 08:36:01,520
going to exactly show the same thing we

12804
08:36:01,520 --> 08:36:05,680
just came up in our trusty notepad file

12805
08:36:05,680 --> 08:36:08,160
here you see it is the same thing but

12806
08:36:08,160 --> 08:36:10,240
the beauty is that we don't have to do

12807
08:36:10,240 --> 08:36:12,878
all these crazy computations again what

12808
08:36:12,878 --> 08:36:15,280
we can do is we can even change the

12809
08:36:15,280 --> 08:36:17,840
count to 100 so it is going to run for

12810
08:36:17,840 --> 08:36:19,440
100 times

12811
08:36:19,440 --> 08:36:21,440
that's pretty cool

12812
08:36:21,440 --> 08:36:22,958
so we can

12813
08:36:22,958 --> 08:36:25,840
clear and run rooster and is going to do

12814
08:36:25,840 --> 08:36:28,718
that 100 times and that's pretty fast

12815
08:36:28,718 --> 08:36:30,160
for computers

12816
08:36:30,160 --> 08:36:32,638
this is really all we had to share with

12817
08:36:32,638 --> 08:36:35,280
you in this lecture the main thing is to

12818
08:36:35,280 --> 08:36:37,840
learn about the syntax of a while loop

12819
08:36:37,840 --> 08:36:40,160
and again notice that we have these five

12820
08:36:40,160 --> 08:36:42,958
parts that make up our loop we have an

12821
08:36:42,958 --> 08:36:44,638
iterator we have the starting point we

12822
08:36:44,638 --> 08:36:46,878
have a test we have the incrementation

12823
08:36:46,878 --> 08:36:49,520
part and we have the loop body it is

12824
08:36:49,520 --> 08:36:52,000
just set up differently with a while

12825
08:36:52,000 --> 08:36:54,638
loop like we can see here in this

12826
08:36:54,638 --> 08:36:56,558
lecture we're going to learn about do

12827
08:36:56,558 --> 08:36:58,798
while loops and this is yet another

12828
08:36:58,798 --> 08:37:01,120
construct we have in c plus plus to do

12829
08:37:01,120 --> 08:37:03,040
repetitive tasks

12830
08:37:03,040 --> 08:37:05,520
let's look at the syntax here we have

12831
08:37:05,520 --> 08:37:08,558
our declaration of the iterator on the

12832
08:37:08,558 --> 08:37:10,638
outside and after that you're going to

12833
08:37:10,638 --> 08:37:13,440
say do you're going to put a pair of

12834
08:37:13,440 --> 08:37:15,760
curly braces like this you're going to

12835
08:37:15,760 --> 08:37:18,398
put whatever code it is you want to run

12836
08:37:18,398 --> 08:37:20,398
inside the loop and then you're going to

12837
08:37:20,398 --> 08:37:22,958
do your incrementation and after the

12838
08:37:22,958 --> 08:37:25,840
closing curly brace you're going to say

12839
08:37:25,840 --> 08:37:27,440
while and you're going to put in your

12840
08:37:27,440 --> 08:37:29,600
text this is really the structure again

12841
08:37:29,600 --> 08:37:32,318
notice that we have those five parts and

12842
08:37:32,318 --> 08:37:33,600
this is the

12843
08:37:33,600 --> 08:37:36,240
declaration of our iterator and we're

12844
08:37:36,240 --> 08:37:38,318
going to initialize this in place for

12845
08:37:38,318 --> 08:37:40,558
example if we want to do that

12846
08:37:40,558 --> 08:37:42,240
after that we're going to

12847
08:37:42,240 --> 08:37:44,718
fall in the body of the loop

12848
08:37:44,718 --> 08:37:46,558
and after that we're going to do the

12849
08:37:46,558 --> 08:37:48,798
incrementation after we run the code it

12850
08:37:48,798 --> 08:37:50,958
is we want to run in the body of the

12851
08:37:50,958 --> 08:37:53,440
loop and then we're going to do the test

12852
08:37:53,440 --> 08:37:56,798
later and the special thing about a do

12853
08:37:56,798 --> 08:38:00,478
while loop is that it is going to run

12854
08:38:00,478 --> 08:38:03,520
first and then you do the test last

12855
08:38:03,520 --> 08:38:05,200
this is really something you need to be

12856
08:38:05,200 --> 08:38:07,760
careful about make sure that when it

12857
08:38:07,760 --> 08:38:09,680
runs it is doing whatever it is you want

12858
08:38:09,680 --> 08:38:12,160
to do because the test is going to run

12859
08:38:12,160 --> 08:38:15,200
after your code has actually run and you

12860
08:38:15,200 --> 08:38:17,120
can tweak this to do whatever it is we

12861
08:38:17,120 --> 08:38:19,680
want it to do as we are going to see

12862
08:38:19,680 --> 08:38:21,840
when we hit visual studio code in a

12863
08:38:21,840 --> 08:38:24,000
minute okay again one thing you need to

12864
08:38:24,000 --> 08:38:26,798
keep in mind is that the do while loop

12865
08:38:26,798 --> 08:38:28,798
is going to run the body

12866
08:38:28,798 --> 08:38:31,600
of the loop and then do the check or the

12867
08:38:31,600 --> 08:38:34,240
test and that may come in handy in some

12868
08:38:34,240 --> 08:38:36,558
of the applications you'll be doing

12869
08:38:36,558 --> 08:38:38,718
within your career as a c plus plus

12870
08:38:38,718 --> 08:38:40,798
developer okay this is really the syntax

12871
08:38:40,798 --> 08:38:42,478
we're going to be using we're going to

12872
08:38:42,478 --> 08:38:44,878
head over to visual studio code and play

12873
08:38:44,878 --> 08:38:48,318
with us okay here we are in our working

12874
08:38:48,318 --> 08:38:50,318
folder the current project is going to

12875
08:38:50,318 --> 08:38:52,080
be do while loop

12876
08:38:52,080 --> 08:38:54,718
we're going to grab the template files

12877
08:38:54,718 --> 08:38:57,360
pretty fast and we are going to put them

12878
08:38:57,360 --> 08:39:00,000
in our current project let's open this

12879
08:39:00,000 --> 08:39:02,160
up and put them in there

12880
08:39:02,160 --> 08:39:04,638
and we are going to open this in visual

12881
08:39:04,638 --> 08:39:07,280
studio code do while loop is our project

12882
08:39:07,280 --> 08:39:09,520
we're going to open this and the main

12883
08:39:09,520 --> 08:39:12,478
cpp is opened up so let's remove

12884
08:39:12,478 --> 08:39:14,798
whatever it is we don't need and we are

12885
08:39:14,798 --> 08:39:16,958
going to show you the bad way to do

12886
08:39:16,958 --> 08:39:19,600
things the bad way to do things is

12887
08:39:19,600 --> 08:39:22,000
typing your code to do things manually

12888
08:39:22,000 --> 08:39:24,080
if you wanted them to be done multiple

12889
08:39:24,080 --> 08:39:26,318
times and this is something bad if we

12890
08:39:26,318 --> 08:39:28,240
bought this and run we're going to go

12891
08:39:28,240 --> 08:39:30,878
down and run this clear not

12892
08:39:30,878 --> 08:39:32,878
that's g brush we're going to run

12893
08:39:32,878 --> 08:39:34,000
rooster

12894
08:39:34,000 --> 08:39:35,840
and we're going to get i love c plus

12895
08:39:35,840 --> 08:39:37,760
plus 10 times and you don't want to do

12896
08:39:37,760 --> 08:39:40,240
something like this what we want in this

12897
08:39:40,240 --> 08:39:42,080
lecture is to use

12898
08:39:42,080 --> 08:39:45,120
do while loops to solve this problem

12899
08:39:45,120 --> 08:39:46,958
we're going to comment this out because

12900
08:39:46,958 --> 08:39:49,040
it is really bad

12901
08:39:49,040 --> 08:39:51,200
and we're going to go down and set up

12902
08:39:51,200 --> 08:39:53,840
our do while loop the first thing we

12903
08:39:53,840 --> 08:39:56,080
need to do is to set up the count

12904
08:39:56,080 --> 08:39:57,920
because we want to store this in some

12905
08:39:57,920 --> 08:39:59,600
variables so we're going to say const

12906
08:39:59,600 --> 08:40:00,478
and

12907
08:40:00,478 --> 08:40:01,840
count

12908
08:40:01,840 --> 08:40:03,360
and we're going to put in our value

12909
08:40:03,360 --> 08:40:05,280
let's put in a 10

12910
08:40:05,280 --> 08:40:08,958
not 190 we're going to say 10 times

12911
08:40:08,958 --> 08:40:11,360
and we're going to set up our iterator

12912
08:40:11,360 --> 08:40:14,558
we're going to say size t

12913
08:40:14,558 --> 08:40:16,558
and we're going to say i and initialize

12914
08:40:16,558 --> 08:40:18,958
this with our starting point we're going

12915
08:40:18,958 --> 08:40:20,638
to start from zero

12916
08:40:20,638 --> 08:40:24,080
and what we're going to do is say do

12917
08:40:24,080 --> 08:40:27,360
and put a pair of curly braces

12918
08:40:27,360 --> 08:40:30,318
and inside this pair of curly braces

12919
08:40:30,318 --> 08:40:31,840
we're going to put whatever it is we

12920
08:40:31,840 --> 08:40:33,120
want to do

12921
08:40:33,120 --> 08:40:35,600
multiple times so we want to print i

12922
08:40:35,600 --> 08:40:37,360
love c plus plus so that's what we're

12923
08:40:37,360 --> 08:40:38,958
going to say we're going to

12924
08:40:38,958 --> 08:40:41,440
put in the current iteration

12925
08:40:41,440 --> 08:40:43,200
and we're going to put a column and say

12926
08:40:43,200 --> 08:40:46,160
i love c plus plus

12927
08:40:46,160 --> 08:40:48,240
and then we're going to jump to the new

12928
08:40:48,240 --> 08:40:51,200
line with stdendl

12929
08:40:51,200 --> 08:40:53,600
and after that we don't want to forget

12930
08:40:53,600 --> 08:40:55,520
our incrementation part so we're going

12931
08:40:55,520 --> 08:40:57,680
to say plus plus i

12932
08:40:57,680 --> 08:40:59,680
and this is going to be

12933
08:40:59,680 --> 08:41:02,638
the part that moves our iterator to the

12934
08:41:02,638 --> 08:41:04,718
next step this is going to be the

12935
08:41:04,718 --> 08:41:07,040
incrementation and this is going to be

12936
08:41:07,040 --> 08:41:08,398
the iterator

12937
08:41:08,398 --> 08:41:11,040
declaration

12938
08:41:11,040 --> 08:41:14,240
and after the closing brace we need to

12939
08:41:14,240 --> 08:41:16,160
say our test

12940
08:41:16,160 --> 08:41:18,398
so we're going to say while and we're

12941
08:41:18,398 --> 08:41:19,920
going to put in our test here and we

12942
08:41:19,920 --> 08:41:22,718
want to keep doing this as long as i is

12943
08:41:22,718 --> 08:41:24,958
less than count of course

12944
08:41:24,958 --> 08:41:27,040
and we're going to put in our closing

12945
08:41:27,040 --> 08:41:28,718
semicolon here

12946
08:41:28,718 --> 08:41:31,920
now this code is going to run 10 times

12947
08:41:31,920 --> 08:41:34,318
but let's go through how it's going to

12948
08:41:34,318 --> 08:41:36,318
run so that you can really see

12949
08:41:36,318 --> 08:41:37,520
everything

12950
08:41:37,520 --> 08:41:40,240
that is happening here okay so when this

12951
08:41:40,240 --> 08:41:42,440
code here is run we're going to hit the

12952
08:41:42,440 --> 08:41:44,958
initialization line here we're going to

12953
08:41:44,958 --> 08:41:48,160
declare i and we're going to put in a 0.

12954
08:41:48,160 --> 08:41:50,558
we're going to say do and inside we're

12955
08:41:50,558 --> 08:41:52,878
going to print whatever we have in i and

12956
08:41:52,878 --> 08:41:55,520
say i love c plus plus so we're going to

12957
08:41:55,520 --> 08:41:58,558
say 0 because i is 0 at this point and

12958
08:41:58,558 --> 08:42:02,398
we're going to say i love c plus plus

12959
08:42:02,398 --> 08:42:04,478
and after that we're going to increment

12960
08:42:04,478 --> 08:42:07,680
i is going to become one

12961
08:42:07,680 --> 08:42:09,680
and we are going to do the test at this

12962
08:42:09,680 --> 08:42:10,478
time

12963
08:42:10,478 --> 08:42:12,878
we're going to say is one less than ten

12964
08:42:12,878 --> 08:42:14,798
that's going to be successful so we're

12965
08:42:14,798 --> 08:42:17,600
going to run the body again

12966
08:42:17,600 --> 08:42:20,318
and we're going to say 1 i love c plus

12967
08:42:20,318 --> 08:42:22,398
let's copy this and print this again so

12968
08:42:22,398 --> 08:42:24,398
that we don't have to type this all the

12969
08:42:24,398 --> 08:42:26,160
time we're going to say 1

12970
08:42:26,160 --> 08:42:28,638
i love c plus and after that we're going

12971
08:42:28,638 --> 08:42:31,120
to run the incrementation part again so

12972
08:42:31,120 --> 08:42:33,440
we're going to get a 2 inside i we're

12973
08:42:33,440 --> 08:42:36,398
going to test and say is 2 less than 10

12974
08:42:36,398 --> 08:42:38,160
that's going to be true so we're going

12975
08:42:38,160 --> 08:42:41,280
to run the body again and print 2 i love

12976
08:42:41,280 --> 08:42:43,440
c plus plus

12977
08:42:43,440 --> 08:42:45,440
and we're going to increment to get a

12978
08:42:45,440 --> 08:42:46,958
three in there

12979
08:42:46,958 --> 08:42:49,120
we're going to run the test against our

12980
08:42:49,120 --> 08:42:51,200
three is three less than ten that's

12981
08:42:51,200 --> 08:42:52,798
going to be true so we're going to fall

12982
08:42:52,798 --> 08:42:55,520
in the body again and print three

12983
08:42:55,520 --> 08:42:58,000
i love c plus plus let's do that we're

12984
08:42:58,000 --> 08:42:59,680
going to do the incrementation we're

12985
08:42:59,680 --> 08:43:02,240
going to get a 4 inside this i variable

12986
08:43:02,240 --> 08:43:04,398
here we're going to run the test we're

12987
08:43:04,398 --> 08:43:06,478
going to say is 4 less than 10 that's

12988
08:43:06,478 --> 08:43:08,398
going to be true of course we're going

12989
08:43:08,398 --> 08:43:11,520
to say four i love c plus plus when we

12990
08:43:11,520 --> 08:43:13,120
fall in the body again

12991
08:43:13,120 --> 08:43:14,718
we're going to do the implementation and

12992
08:43:14,718 --> 08:43:17,200
get a five we're going to do the test

12993
08:43:17,200 --> 08:43:19,120
it's five less than ten that's going to

12994
08:43:19,120 --> 08:43:21,280
be true so we're going to fall in the

12995
08:43:21,280 --> 08:43:24,160
body again and say five i love c plus

12996
08:43:24,160 --> 08:43:25,920
plus

12997
08:43:25,920 --> 08:43:27,280
let's say that

12998
08:43:27,280 --> 08:43:30,000
we're going to increment again

12999
08:43:30,000 --> 08:43:31,920
we're going to get a six the test is

13000
08:43:31,920 --> 08:43:34,878
going to run and we're going to say is

13001
08:43:34,878 --> 08:43:36,798
six less than ten

13002
08:43:36,798 --> 08:43:38,878
that's going to be true again then the

13003
08:43:38,878 --> 08:43:42,160
body is going to execute and say

13004
08:43:42,160 --> 08:43:44,478
6 i love c plus plus we're going to do

13005
08:43:44,478 --> 08:43:47,120
the incrementation and get a 7. we're

13006
08:43:47,120 --> 08:43:49,360
going to run the test against our 7 so

13007
08:43:49,360 --> 08:43:51,520
we're going to say is 7 less than 10

13008
08:43:51,520 --> 08:43:53,040
that's going to be true

13009
08:43:53,040 --> 08:43:55,360
we are going to fall in the body again

13010
08:43:55,360 --> 08:43:58,398
and say 7 i love c plus plus

13011
08:43:58,398 --> 08:44:00,478
we are going to do the incrementation we

13012
08:44:00,478 --> 08:44:03,120
are going to get 8 we're going to say is

13013
08:44:03,120 --> 08:44:06,000
8 less than 10 that's going to be true

13014
08:44:06,000 --> 08:44:08,000
we are going to fall in the body again

13015
08:44:08,000 --> 08:44:10,878
and say 8 i love c plus plus we're going

13016
08:44:10,878 --> 08:44:12,398
to do the incrementation we're going to

13017
08:44:12,398 --> 08:44:14,878
get a 9 and we're going to run the test

13018
08:44:14,878 --> 08:44:16,958
we're going to say is 9 less than 10

13019
08:44:16,958 --> 08:44:18,478
that's going to be true so we're going

13020
08:44:18,478 --> 08:44:21,760
to go inside and say 9 i love c plus

13021
08:44:21,760 --> 08:44:23,360
plus

13022
08:44:23,360 --> 08:44:25,040
and we're going to do the incrementation

13023
08:44:25,040 --> 08:44:27,680
again now we're going to get a 10 and

13024
08:44:27,680 --> 08:44:30,958
the test is going to say is 10 less than

13025
08:44:30,958 --> 08:44:31,760
10

13026
08:44:31,760 --> 08:44:33,680
and that's going to be false now the

13027
08:44:33,680 --> 08:44:35,520
test is going to fail

13028
08:44:35,520 --> 08:44:38,398
and we're going to fall after the while

13029
08:44:38,398 --> 08:44:40,878
loop here so if we had a statement here

13030
08:44:40,878 --> 08:44:44,160
that said stdc out loop done we would

13031
08:44:44,160 --> 08:44:46,478
print that we would go down here and say

13032
08:44:46,478 --> 08:44:48,798
loop done

13033
08:44:48,798 --> 08:44:50,398
and this is what we're going to get if

13034
08:44:50,398 --> 08:44:52,398
we run this program and again i

13035
08:44:52,398 --> 08:44:54,240
encourage you to try this out in your

13036
08:44:54,240 --> 08:44:56,798
mind print this in some file you have on

13037
08:44:56,798 --> 08:44:59,200
your computer or you can even use a

13038
08:44:59,200 --> 08:45:01,680
regular piece of paper but make sure you

13039
08:45:01,680 --> 08:45:04,000
understand the flow we go through to get

13040
08:45:04,000 --> 08:45:06,478
this code to run multiple times okay now

13041
08:45:06,478 --> 08:45:08,718
that we have done this we can work this

13042
08:45:08,718 --> 08:45:10,478
and let the computer

13043
08:45:10,478 --> 08:45:12,798
do the heavy work for us and run this

13044
08:45:12,798 --> 08:45:14,958
fence multiple times the world is going

13045
08:45:14,958 --> 08:45:16,958
to be good so what we're going to do

13046
08:45:16,958 --> 08:45:18,798
we're going to say clear

13047
08:45:18,798 --> 08:45:21,040
and run rooster and it's going to say

13048
08:45:21,040 --> 08:45:23,360
exactly what we expect i'll have c plus

13049
08:45:23,360 --> 08:45:25,760
10 times and then it's going to say

13050
08:45:25,760 --> 08:45:28,080
loop done okay one thing i want you to

13051
08:45:28,080 --> 08:45:29,040
see

13052
08:45:29,040 --> 08:45:32,958
is that the do while loop runs before it

13053
08:45:32,958 --> 08:45:35,920
does the test and this may cause crazy

13054
08:45:35,920 --> 08:45:38,398
things happening in your program if

13055
08:45:38,398 --> 08:45:40,080
you're really not careful

13056
08:45:40,080 --> 08:45:42,478
let's say that you wanted this program

13057
08:45:42,478 --> 08:45:44,958
not to run and initialize this thing

13058
08:45:44,958 --> 08:45:47,200
with a zero for the count so it's going

13059
08:45:47,200 --> 08:45:49,760
to run zero times but that's not going

13060
08:45:49,760 --> 08:45:51,840
to do what you expect with the do while

13061
08:45:51,840 --> 08:45:53,360
loop because

13062
08:45:53,360 --> 08:45:57,280
it runs things before it does the test

13063
08:45:57,280 --> 08:45:59,200
so if you run this program it's not

13064
08:45:59,200 --> 08:46:01,440
going to just say loop done it's going

13065
08:46:01,440 --> 08:46:03,760
to say i love c plus plus and have zero

13066
08:46:03,760 --> 08:46:06,080
value in here and it's going to say loop

13067
08:46:06,080 --> 08:46:07,600
done but

13068
08:46:07,600 --> 08:46:10,000
that's not going to be probably what you

13069
08:46:10,000 --> 08:46:12,558
intended by putting a zero in here you

13070
08:46:12,558 --> 08:46:15,280
put a zero in here if you want this code

13071
08:46:15,280 --> 08:46:17,840
to run zero times or the code in the

13072
08:46:17,840 --> 08:46:20,318
body not to run that's another way to

13073
08:46:20,318 --> 08:46:22,878
say that but in this case a do while

13074
08:46:22,878 --> 08:46:25,120
loop is not going to do what you expect

13075
08:46:25,120 --> 08:46:28,878
because it runs before it does the test

13076
08:46:28,878 --> 08:46:29,840
here

13077
08:46:29,840 --> 08:46:33,360
let's build this and show you this

13078
08:46:33,360 --> 08:46:35,520
so we're going to go through the world

13079
08:46:35,520 --> 08:46:38,240
is successful

13080
08:46:38,398 --> 08:46:40,798
and we are going to clear

13081
08:46:40,798 --> 08:46:42,558
and run rooster you're going to see that

13082
08:46:42,558 --> 08:46:44,718
it's saying zero i love c plus plus loop

13083
08:46:44,718 --> 08:46:47,920
done it is running even if we set our

13084
08:46:47,920 --> 08:46:51,040
count to zero here so be sure the do

13085
08:46:51,040 --> 08:46:53,520
while loop is doing what you want but if

13086
08:46:53,520 --> 08:46:55,360
you are careful about this

13087
08:46:55,360 --> 08:46:57,840
you're going to have no problems and if

13088
08:46:57,840 --> 08:47:00,240
you want the rope to actually not do

13089
08:47:00,240 --> 08:47:01,360
anything

13090
08:47:01,360 --> 08:47:03,840
when you have zero counting here you can

13091
08:47:03,840 --> 08:47:06,798
use the while loop or the full look like

13092
08:47:06,798 --> 08:47:08,398
we have seen before

13093
08:47:08,398 --> 08:47:10,638
i would like to welcome you in this new

13094
08:47:10,638 --> 08:47:11,600
chapter

13095
08:47:11,600 --> 08:47:13,680
where we're going to be learning about

13096
08:47:13,680 --> 08:47:17,520
arrays and arrays are a way to

13097
08:47:17,520 --> 08:47:19,840
set up collections in our c plus plus

13098
08:47:19,840 --> 08:47:22,318
program so far we have been working with

13099
08:47:22,318 --> 08:47:24,318
single variables for example you have a

13100
08:47:24,318 --> 08:47:26,878
bunch of integer variables you can even

13101
08:47:26,878 --> 08:47:30,478
have 10 or 20 variables of integer type

13102
08:47:30,478 --> 08:47:32,080
and that's going to be fine but

13103
08:47:32,080 --> 08:47:34,240
sometimes you don't want to manage all

13104
08:47:34,240 --> 08:47:37,680
these variables it is really desirable

13105
08:47:37,680 --> 08:47:40,718
to group all these variables into one

13106
08:47:40,718 --> 08:47:43,520
single unity and manage them as one

13107
08:47:43,520 --> 08:47:45,920
single entity and we can do something

13108
08:47:45,920 --> 08:47:48,478
like this group them together and give

13109
08:47:48,478 --> 08:47:50,958
them a name so that we can refer to them

13110
08:47:50,958 --> 08:47:52,798
or manipulate them

13111
08:47:52,798 --> 08:47:55,840
under this name here and c plus plus has

13112
08:47:55,840 --> 08:47:59,680
the array construct to help us do this

13113
08:47:59,680 --> 08:48:02,558
okay so again if you look in memory how

13114
08:48:02,558 --> 08:48:04,160
things are laid out you're going to have

13115
08:48:04,160 --> 08:48:06,318
a bunch of zeros and ones for example

13116
08:48:06,318 --> 08:48:09,840
here each red defend is a net it is four

13117
08:48:09,840 --> 08:48:12,398
bytes in size and it can be used to

13118
08:48:12,398 --> 08:48:15,120
represent a net so if we have a bunch of

13119
08:48:15,120 --> 08:48:17,280
events like this we might want to group

13120
08:48:17,280 --> 08:48:19,680
them together and give them a name and

13121
08:48:19,680 --> 08:48:22,478
manipulate them under this name this is

13122
08:48:22,478 --> 08:48:24,160
another way to look at what we just

13123
08:48:24,160 --> 08:48:27,200
talked about here and again arrays are a

13124
08:48:27,200 --> 08:48:29,520
way to do these kinds of things in c

13125
08:48:29,520 --> 08:48:31,920
plus plus and we're going to be learning

13126
08:48:31,920 --> 08:48:34,398
all about it in this chapter we are

13127
08:48:34,398 --> 08:48:36,478
going to stop here in this lecture and

13128
08:48:36,478 --> 08:48:38,240
we are going to start and look at how

13129
08:48:38,240 --> 08:48:40,878
you can declare and initialize an array

13130
08:48:40,878 --> 08:48:42,318
in the next lecture

13131
08:48:42,318 --> 08:48:44,240
go ahead and finish up here

13132
08:48:44,240 --> 08:48:46,318
and meet me there in this lecture we're

13133
08:48:46,318 --> 08:48:48,718
going to see how we can declare and use

13134
08:48:48,718 --> 08:48:52,160
arrays in our c plus plus program and

13135
08:48:52,160 --> 08:48:55,120
again arrays are a facility we have in

13136
08:48:55,120 --> 08:48:57,680
the c plus plus programming language to

13137
08:48:57,680 --> 08:49:00,558
group many variables together and

13138
08:49:00,558 --> 08:49:03,840
manipulate them as a single unit for

13139
08:49:03,840 --> 08:49:06,318
example here we have a bunch of integers

13140
08:49:06,318 --> 08:49:08,638
in memory each of these red things is

13141
08:49:08,638 --> 08:49:11,120
going to be four bytes in size so we can

13142
08:49:11,120 --> 08:49:13,360
think of it as an integer and we can

13143
08:49:13,360 --> 08:49:16,000
group them together and give them an a

13144
08:49:16,000 --> 08:49:18,398
we call them scores here and they are

13145
08:49:18,398 --> 08:49:21,440
going to be living under that scores

13146
08:49:21,440 --> 08:49:24,000
entity so if we want to

13147
08:49:24,000 --> 08:49:26,558
refer to each of these things z plus

13148
08:49:26,558 --> 08:49:29,440
plus provides an indexing system so we

13149
08:49:29,440 --> 08:49:32,558
cannot use angle brackets like this and

13150
08:49:32,558 --> 08:49:36,318
refer to the first of these integers as

13151
08:49:36,318 --> 08:49:39,040
zero so we can go from zero all the way

13152
08:49:39,040 --> 08:49:42,318
to nine here but your array can even be

13153
08:49:42,318 --> 08:49:44,558
bigger than this many times bigger than

13154
08:49:44,558 --> 08:49:46,478
this and we're going to see examples of

13155
08:49:46,478 --> 08:49:48,318
how we can do that but this is an

13156
08:49:48,318 --> 08:49:51,040
example of how you can take many

13157
08:49:51,040 --> 08:49:54,638
variables group them under one entity

13158
08:49:54,638 --> 08:49:56,718
give them a name and be able to

13159
08:49:56,718 --> 08:49:59,120
reference each of these events that are

13160
08:49:59,120 --> 08:50:01,760
under that entity and now that the idea

13161
08:50:01,760 --> 08:50:04,318
is pretty clear let's see how we can do

13162
08:50:04,318 --> 08:50:06,718
this in c plus plus the way to do that

13163
08:50:06,718 --> 08:50:09,200
is to say and you have to specify the

13164
08:50:09,200 --> 08:50:11,600
type of your collection you have to

13165
08:50:11,600 --> 08:50:13,520
specify the name after that and then

13166
08:50:13,520 --> 08:50:16,000
you're going to put a pair of angle

13167
08:50:16,000 --> 08:50:18,240
brackets like this and inside those

13168
08:50:18,240 --> 08:50:21,120
angle brackets you can specify the size

13169
08:50:21,120 --> 08:50:23,520
you want that collection to have or that

13170
08:50:23,520 --> 08:50:26,718
array to have and after this statement

13171
08:50:26,718 --> 08:50:29,120
is run we are basically going to have

13172
08:50:29,120 --> 08:50:30,558
something like this in memory we're

13173
08:50:30,558 --> 08:50:32,558
going to have 10 integers so if you

13174
08:50:32,558 --> 08:50:35,280
count here 0 all the way through 9

13175
08:50:35,280 --> 08:50:37,360
that's 10 integers they're going to be

13176
08:50:37,360 --> 08:50:39,840
grouped together under one logic entity

13177
08:50:39,840 --> 08:50:41,760
that logic entity is going to be called

13178
08:50:41,760 --> 08:50:44,638
scores and we can go through that name

13179
08:50:44,638 --> 08:50:47,440
to manipulate all these things that are

13180
08:50:47,440 --> 08:50:50,160
in this entity okay after your array is

13181
08:50:50,160 --> 08:50:52,398
declared and you have space for it in

13182
08:50:52,398 --> 08:50:54,638
memory basically something like this we

13183
08:50:54,638 --> 08:50:57,120
need a way to read data from at and

13184
08:50:57,120 --> 08:50:59,120
we're going to see how we can do that

13185
08:50:59,120 --> 08:51:01,360
and it is what we have here for example

13186
08:51:01,360 --> 08:51:03,360
if we want to print the first of these

13187
08:51:03,360 --> 08:51:05,600
elements we're going to say scores

13188
08:51:05,600 --> 08:51:08,080
angle brackets and specify the index of

13189
08:51:08,080 --> 08:51:11,280
the first element in that array or that

13190
08:51:11,280 --> 08:51:13,840
collection of integers that is called

13191
08:51:13,840 --> 08:51:16,160
scores okay one thing you should really

13192
08:51:16,160 --> 08:51:19,440
keep in mind is that arrays are indexed

13193
08:51:19,440 --> 08:51:21,840
from zero they don't start from one so

13194
08:51:21,840 --> 08:51:23,920
the first element is going to live at

13195
08:51:23,920 --> 08:51:26,080
index zero it's not going to live at

13196
08:51:26,080 --> 08:51:28,638
index one so here scores zero is going

13197
08:51:28,638 --> 08:51:30,958
to print the first element and scores

13198
08:51:30,958 --> 08:51:32,878
nine is going to print the last element

13199
08:51:32,878 --> 08:51:35,120
which happens to be the last in our

13200
08:51:35,120 --> 08:51:38,000
collection here of integers okay once

13201
08:51:38,000 --> 08:51:40,798
our array is declared it's not going to

13202
08:51:40,798 --> 08:51:42,958
have data in it there is going to be

13203
08:51:42,958 --> 08:51:45,440
data in but it's not going to be data

13204
08:51:45,440 --> 08:51:48,160
that we put in so we can think of this

13205
08:51:48,160 --> 08:51:51,120
data basically as garbage another thing

13206
08:51:51,120 --> 08:51:53,600
i wanted to bring to your attention is

13207
08:51:53,600 --> 08:51:54,478
that

13208
08:51:54,478 --> 08:51:58,398
your array has clear boundaries when we

13209
08:51:58,398 --> 08:52:00,558
declare an array like this notice that

13210
08:52:00,558 --> 08:52:04,558
we specify 10 as the size of our array

13211
08:52:04,558 --> 08:52:06,638
it's only going to have 10 elements

13212
08:52:06,638 --> 08:52:08,798
inside and you can see that we have from

13213
08:52:08,798 --> 08:52:11,520
index 0 all the way to 9 and inside we

13214
08:52:11,520 --> 08:52:13,760
have garbage data but we're going to fix

13215
08:52:13,760 --> 08:52:15,920
that in a minute what i want you to see

13216
08:52:15,920 --> 08:52:18,318
here is that you can to try and read

13217
08:52:18,318 --> 08:52:20,958
outside the bounds of your array

13218
08:52:20,958 --> 08:52:23,280
c plus plus is funny in that it allows

13219
08:52:23,280 --> 08:52:25,360
you to do that but if you do that you're

13220
08:52:25,360 --> 08:52:27,280
going to get weird problems for example

13221
08:52:27,280 --> 08:52:29,760
your program would crash or do something

13222
08:52:29,760 --> 08:52:31,680
really bad so you shouldn't really do

13223
08:52:31,680 --> 08:52:35,200
this be aware of the boundaries of your

13224
08:52:35,200 --> 08:52:37,760
array if you try to read the data from

13225
08:52:37,760 --> 08:52:40,080
the outside of your balance you may read

13226
08:52:40,080 --> 08:52:42,798
garbage data you may even cause failure

13227
08:52:42,798 --> 08:52:44,718
of the operating system because you

13228
08:52:44,718 --> 08:52:46,958
don't really know whose memory you're

13229
08:52:46,958 --> 08:52:49,200
reading it's not going to be memory that

13230
08:52:49,200 --> 08:52:51,840
is allocated to your program so array

13231
08:52:51,840 --> 08:52:53,360
boundaries are something you need to

13232
08:52:53,360 --> 08:52:56,160
keep in mind when working with arrays

13233
08:52:56,160 --> 08:52:58,638
okay we just saw that we could read data

13234
08:52:58,638 --> 08:53:00,958
from the array using this angle bracket

13235
08:53:00,958 --> 08:53:03,920
syntax we can even do that through the

13236
08:53:03,920 --> 08:53:05,360
loops and

13237
08:53:05,360 --> 08:53:07,200
read all the elements in the array and

13238
08:53:07,200 --> 08:53:09,200
this is how we could do that and you can

13239
08:53:09,200 --> 08:53:11,040
see that the loops we learned about in

13240
08:53:11,040 --> 08:53:12,398
the last chapter

13241
08:53:12,398 --> 08:53:14,318
are starting to come in handy okay we

13242
08:53:14,318 --> 08:53:16,878
have seen how we can read data from the

13243
08:53:16,878 --> 08:53:17,920
array

13244
08:53:17,920 --> 08:53:20,160
but what if we want to put something

13245
08:53:20,160 --> 08:53:22,558
back in what if we want to write our own

13246
08:53:22,558 --> 08:53:25,840
data in an array well the syntax is

13247
08:53:25,840 --> 08:53:28,000
pretty much what you would expect we

13248
08:53:28,000 --> 08:53:30,558
also use this angle bracket syntax but

13249
08:53:30,558 --> 08:53:33,680
we're going to assign data to that

13250
08:53:33,680 --> 08:53:35,680
element in the array for example if we

13251
08:53:35,680 --> 08:53:38,558
wanted to assign data to the first

13252
08:53:38,558 --> 08:53:41,280
element in our array we're going to say

13253
08:53:41,280 --> 08:53:42,318
scores

13254
08:53:42,318 --> 08:53:44,398
angle brackets 0 and we're going to

13255
08:53:44,398 --> 08:53:47,360
assign a 20 in it and we can assign a 21

13256
08:53:47,360 --> 08:53:51,520
into the element at index 1 and the 22

13257
08:53:51,520 --> 08:53:54,798
in the element at index 2 and if we do

13258
08:53:54,798 --> 08:53:56,240
that we're going to have something like

13259
08:53:56,240 --> 08:53:59,040
this in our array so index 0 we have a

13260
08:53:59,040 --> 08:54:02,160
20 index 1 we have a 21 index 2 we have

13261
08:54:02,160 --> 08:54:05,520
a 22 and the rest is still garbage

13262
08:54:05,520 --> 08:54:08,000
because we didn't put in our data we can

13263
08:54:08,000 --> 08:54:10,318
also write data in a loop for example

13264
08:54:10,318 --> 08:54:13,440
here we have our array declared

13265
08:54:13,440 --> 08:54:15,520
and we're going to loop around putting

13266
08:54:15,520 --> 08:54:18,398
data at different indexes notice that

13267
08:54:18,398 --> 08:54:20,478
the index is going to be the current

13268
08:54:20,478 --> 08:54:23,280
iteration we are at so this is a common

13269
08:54:23,280 --> 08:54:25,680
way to do things in c plus plus and you

13270
08:54:25,680 --> 08:54:27,840
need to be familiar with this and after

13271
08:54:27,840 --> 08:54:30,398
we put in the data we can read that back

13272
08:54:30,398 --> 08:54:32,798
and make sure that it is the actual data

13273
08:54:32,798 --> 08:54:34,718
that we put in and we're going to have a

13274
08:54:34,718 --> 08:54:36,240
chance to play with this in visual

13275
08:54:36,240 --> 08:54:38,638
studio code in a minute so don't worry

13276
08:54:38,638 --> 08:54:40,798
if some of these things don't make sense

13277
08:54:40,798 --> 08:54:43,280
yet but again the main thing here is

13278
08:54:43,280 --> 08:54:45,680
this angle bracket syntax we can use

13279
08:54:45,680 --> 08:54:49,040
that to either write data in the element

13280
08:54:49,040 --> 08:54:51,600
of the array or read data from the

13281
08:54:51,600 --> 08:54:53,280
element of the array and this is the

13282
08:54:53,280 --> 08:54:56,558
syntax here scores angle brackets i okay

13283
08:54:56,558 --> 08:54:59,840
so far our array has been declared and

13284
08:54:59,840 --> 08:55:01,920
we didn't really put in data and there

13285
08:55:01,920 --> 08:55:04,398
was junk data inside but there's a way

13286
08:55:04,398 --> 08:55:07,520
you can declare an array and put data in

13287
08:55:07,520 --> 08:55:10,240
in one single statement and this is how

13288
08:55:10,240 --> 08:55:12,160
you would do it here we have another

13289
08:55:12,160 --> 08:55:14,240
array it's going to be grouping double

13290
08:55:14,240 --> 08:55:15,440
variables

13291
08:55:15,440 --> 08:55:17,440
we call the array salaries and we

13292
08:55:17,440 --> 08:55:19,840
specify that it's going to be

13293
08:55:19,840 --> 08:55:23,280
of size five and we can put these

13294
08:55:23,280 --> 08:55:27,360
elements in a comma separated list using

13295
08:55:27,360 --> 08:55:29,520
braced initialization like this and it

13296
08:55:29,520 --> 08:55:31,440
is going to work if we try to print it

13297
08:55:31,440 --> 08:55:32,958
out we're going to see these elements

13298
08:55:32,958 --> 08:55:35,120
here and you see that we can read this

13299
08:55:35,120 --> 08:55:36,798
using the same syntax we've learned

13300
08:55:36,798 --> 08:55:40,240
about salaries we say the array name we

13301
08:55:40,240 --> 08:55:42,318
do angle brackets and inside we put the

13302
08:55:42,318 --> 08:55:44,878
index of the element we are reading from

13303
08:55:44,878 --> 08:55:47,680
and this index is coming from our loop

13304
08:55:47,680 --> 08:55:49,840
here and it is going to work you're

13305
08:55:49,840 --> 08:55:51,840
going to get this element printed out

13306
08:55:51,840 --> 08:55:54,080
this is pretty cool when initializing

13307
08:55:54,080 --> 08:55:55,600
your array

13308
08:55:55,600 --> 08:55:57,360
you can leave out elements for example

13309
08:55:57,360 --> 08:56:00,080
here we have a neat array it is called

13310
08:56:00,080 --> 08:56:03,040
families it's going to be of size 5 but

13311
08:56:03,040 --> 08:56:05,440
we are just putting in three elements

13312
08:56:05,440 --> 08:56:08,080
the rest are going to be initialized to

13313
08:56:08,080 --> 08:56:10,558
zero when we do things like this and

13314
08:56:10,558 --> 08:56:12,398
this is something you need to be aware

13315
08:56:12,398 --> 08:56:14,478
of and we are going to try this out in

13316
08:56:14,478 --> 08:56:16,080
visual studio code and you're going to

13317
08:56:16,080 --> 08:56:18,240
see that this is actually true it is

13318
08:56:18,240 --> 08:56:21,280
possible to also omit the size when you

13319
08:56:21,280 --> 08:56:23,360
are declaring your array and the

13320
08:56:23,360 --> 08:56:25,600
compiler is going to deduce the size

13321
08:56:25,600 --> 08:56:28,000
from the elements that you initialize

13322
08:56:28,000 --> 08:56:30,638
your array with for example here we have

13323
08:56:30,638 --> 08:56:33,360
in one two three four five six elements

13324
08:56:33,360 --> 08:56:35,920
this array is going to have a size of

13325
08:56:35,920 --> 08:56:38,000
six and if we print elements we're going

13326
08:56:38,000 --> 08:56:40,080
to get those printed out notice here

13327
08:56:40,080 --> 08:56:43,520
that we are using a ranged base for loop

13328
08:56:43,520 --> 08:56:44,958
and

13329
08:56:44,958 --> 08:56:46,798
hopefully you can see that it is easier

13330
08:56:46,798 --> 08:56:49,280
to read data from a collection like this

13331
08:56:49,280 --> 08:56:51,440
using a ranged base for loop because we

13332
08:56:51,440 --> 08:56:53,840
don't have to set up an iterator

13333
08:56:53,840 --> 08:56:55,920
initialize it to do the test do the

13334
08:56:55,920 --> 08:56:58,000
incrementation we can just read the

13335
08:56:58,000 --> 08:57:01,280
value and use it and be on our merry way

13336
08:57:01,280 --> 08:57:03,360
this is pretty cool it is possible to

13337
08:57:03,360 --> 08:57:06,318
also declare your array constant and

13338
08:57:06,318 --> 08:57:08,080
when you do that you won't be able to

13339
08:57:08,080 --> 08:57:10,478
modify elements of that array

13340
08:57:10,478 --> 08:57:12,478
that's what it means if you make it

13341
08:57:12,478 --> 08:57:14,878
constant you basically want it to stay

13342
08:57:14,878 --> 08:57:17,280
constant and you don't want to allow

13343
08:57:17,280 --> 08:57:19,760
modifications of your array and we're

13344
08:57:19,760 --> 08:57:21,440
going to see this in a minute when we

13345
08:57:21,440 --> 08:57:23,760
get in visual studio code the last thing

13346
08:57:23,760 --> 08:57:25,280
i want you to see is that you can

13347
08:57:25,280 --> 08:57:27,760
actually do operations on the data that

13348
08:57:27,760 --> 08:57:30,398
you have stored in an array for example

13349
08:57:30,398 --> 08:57:32,240
here we can sum the elements up and

13350
08:57:32,240 --> 08:57:34,798
store the result back in our variable

13351
08:57:34,798 --> 08:57:36,798
sum and this is something you would do

13352
08:57:36,798 --> 08:57:39,920
and it might come in handy in many times

13353
08:57:39,920 --> 08:57:42,318
okay one thing i want you to see before

13354
08:57:42,318 --> 08:57:44,398
we head over to visual studio code and

13355
08:57:44,398 --> 08:57:47,600
play with us is that arrays store

13356
08:57:47,600 --> 08:57:49,920
elements of the same type

13357
08:57:49,920 --> 08:57:53,600
repeat after me arrays store elements of

13358
08:57:53,600 --> 08:57:56,160
the same type you can't try and store

13359
08:57:56,160 --> 08:57:58,478
variables of different types in an array

13360
08:57:58,478 --> 08:58:00,080
i don't even know how you would actually

13361
08:58:00,080 --> 08:58:02,878
declare that and if you try and store a

13362
08:58:02,878 --> 08:58:04,318
different type

13363
08:58:04,318 --> 08:58:06,798
than the type that was declared for the

13364
08:58:06,798 --> 08:58:08,878
array you're going to get a compiler

13365
08:58:08,878 --> 08:58:10,318
error so this is something you should

13366
08:58:10,318 --> 08:58:13,680
keep in mind but it makes sense because

13367
08:58:13,680 --> 08:58:15,440
when you declare an array you're going

13368
08:58:15,440 --> 08:58:18,958
to be given a bunch of bytes in memory

13369
08:58:18,958 --> 08:58:20,478
and those bytes are going to be

13370
08:58:20,478 --> 08:58:23,840
collections of data that is of the same

13371
08:58:23,840 --> 08:58:26,160
type for example here we have a bunch of

13372
08:58:26,160 --> 08:58:28,638
integers again each of these red events

13373
08:58:28,638 --> 08:58:31,360
is an integer and if you try to put in

13374
08:58:31,360 --> 08:58:34,240
something that is smaller or bigger than

13375
08:58:34,240 --> 08:58:36,558
an edge then the compiler is going to be

13376
08:58:36,558 --> 08:58:38,958
confused that as to how to read these

13377
08:58:38,958 --> 08:58:42,240
text so for arrays to work the types

13378
08:58:42,240 --> 08:58:44,798
that you store in the array have to be

13379
08:58:44,798 --> 08:58:47,600
the same and they need to be consistent

13380
08:58:47,600 --> 08:58:49,360
this is something you should know and if

13381
08:58:49,360 --> 08:58:51,600
you try to break this rule you're going

13382
08:58:51,600 --> 08:58:53,440
to get a compiler error

13383
08:58:53,440 --> 08:58:55,600
now that you know about arrays we're

13384
08:58:55,600 --> 08:58:57,840
going to head over to visual studio code

13385
08:58:57,840 --> 08:58:59,680
and play with them a little bit okay

13386
08:58:59,680 --> 08:59:02,718
here we are in our working folder the

13387
08:59:02,718 --> 08:59:04,958
current chapter is raised the current

13388
08:59:04,958 --> 08:59:07,840
project is declaring and using arrays

13389
08:59:07,840 --> 08:59:10,798
we're going to grab our template code

13390
08:59:10,798 --> 08:59:12,958
and we're going to copy and move the

13391
08:59:12,958 --> 08:59:14,478
files over

13392
08:59:14,478 --> 08:59:16,558
and we're going to open this thing up in

13393
08:59:16,558 --> 08:59:18,318
visual studio code pretty quick we're

13394
08:59:18,318 --> 08:59:20,958
going to open up the main cpp file and

13395
08:59:20,958 --> 08:59:23,520
remove things we don't need

13396
08:59:23,520 --> 08:59:24,718
and we're going to see how we can

13397
08:59:24,718 --> 08:59:28,398
declare an array of ants

13398
08:59:28,398 --> 08:59:30,478
okay the way you do that you say the

13399
08:59:30,478 --> 08:59:33,520
name of the arrays and you put these

13400
08:59:33,520 --> 08:59:36,160
angle brackets and specify the size of

13401
08:59:36,160 --> 08:59:38,638
your array if you want you can put a

13402
08:59:38,638 --> 08:59:40,240
space in here it's really not going to

13403
08:59:40,240 --> 08:59:42,000
make a difference and you're going to

13404
08:59:42,000 --> 08:59:44,878
put a semicolon at the end the moment

13405
08:59:44,878 --> 08:59:47,600
this line executes we're going to have

13406
08:59:47,600 --> 08:59:50,398
the space for 10 integers allocated to

13407
08:59:50,398 --> 08:59:52,798
us in memory and that space is going to

13408
08:59:52,798 --> 08:59:54,638
be called scores and we're going to be

13409
08:59:54,638 --> 08:59:57,040
able to read data from it or even write

13410
08:59:57,040 --> 08:59:59,840
data back into it for now let's see how

13411
08:59:59,840 --> 09:00:01,920
we can read the data and it is really

13412
09:00:01,920 --> 09:00:03,920
simple we're going to use this angle

13413
09:00:03,920 --> 09:00:05,920
bracket syntax that we just saw in the

13414
09:00:05,920 --> 09:00:08,318
slides so if we want to read the first

13415
09:00:08,318 --> 09:00:10,080
element we can say

13416
09:00:10,080 --> 09:00:12,798
sddc out we want to print it out and

13417
09:00:12,798 --> 09:00:14,878
we're going to say scores

13418
09:00:14,878 --> 09:00:17,200
specify the index we want to read from

13419
09:00:17,200 --> 09:00:19,040
so we say zero

13420
09:00:19,040 --> 09:00:22,080
and we're going to say std endl to move

13421
09:00:22,080 --> 09:00:24,240
to the next line if you have this typed

13422
09:00:24,240 --> 09:00:25,680
out you're going to see that this is

13423
09:00:25,680 --> 09:00:27,920
going to work and it is going to print

13424
09:00:27,920 --> 09:00:31,120
whatever is stored in the first element

13425
09:00:31,120 --> 09:00:33,680
in this array here and again i want you

13426
09:00:33,680 --> 09:00:36,878
to keep in mind the memory structure of

13427
09:00:36,878 --> 09:00:38,718
your data when you are working with

13428
09:00:38,718 --> 09:00:40,718
arrays so what we're going to print

13429
09:00:40,718 --> 09:00:44,558
right now is whatever junk data is in

13430
09:00:44,558 --> 09:00:47,120
this first element here okay in here

13431
09:00:47,120 --> 09:00:48,558
we're going to say that we haven't

13432
09:00:48,558 --> 09:00:50,798
jumped yet

13433
09:00:50,798 --> 09:00:53,520
and let's bring up a terminal

13434
09:00:53,520 --> 09:00:55,520
so that we can play with us and we're

13435
09:00:55,520 --> 09:00:58,160
going to build this with gcc as we

13436
09:00:58,160 --> 09:00:59,520
always do

13437
09:00:59,520 --> 09:01:01,520
the build is going to be good

13438
09:01:01,520 --> 09:01:03,680
and we're going to clear

13439
09:01:03,680 --> 09:01:06,478
and run rooster you see that this is the

13440
09:01:06,478 --> 09:01:08,718
junk value we have in here we don't have

13441
09:01:08,718 --> 09:01:09,600
any

13442
09:01:09,600 --> 09:01:12,638
useful data in here it's just junk data

13443
09:01:12,638 --> 09:01:15,040
because we didn't initialize this array

13444
09:01:15,040 --> 09:01:17,600
we can also read the element at location

13445
09:01:17,600 --> 09:01:19,520
two and see what we have in there when

13446
09:01:19,520 --> 09:01:22,318
you run the program i'm not even sure if

13447
09:01:22,318 --> 09:01:23,840
it is guaranteed that you're going to

13448
09:01:23,840 --> 09:01:26,240
get the same data if you run the program

13449
09:01:26,240 --> 09:01:28,558
multiple times but we don't really care

13450
09:01:28,558 --> 09:01:31,360
we know that it is junk data so we can't

13451
09:01:31,360 --> 09:01:33,360
use this in our program

13452
09:01:33,360 --> 09:01:35,520
what we're going to do is run this

13453
09:01:35,520 --> 09:01:38,318
and see the value for the element at

13454
09:01:38,318 --> 09:01:39,840
index one

13455
09:01:39,840 --> 09:01:42,958
let's build with gcc

13456
09:01:42,958 --> 09:01:44,798
the world is going to be good we're

13457
09:01:44,798 --> 09:01:46,718
going to clear

13458
09:01:46,718 --> 09:01:48,638
and we're going to run rooster and

13459
09:01:48,638 --> 09:01:50,398
you're going to see that at index 1 we

13460
09:01:50,398 --> 09:01:51,840
have a zero end

13461
09:01:51,840 --> 09:01:52,878
but

13462
09:01:52,878 --> 09:01:55,120
doing it manually like this is really

13463
09:01:55,120 --> 09:01:58,080
time consuming and it is possible to

13464
09:01:58,080 --> 09:02:00,398
actually do this in a loop

13465
09:02:00,398 --> 09:02:02,878
we know the size of this array so it's a

13466
09:02:02,878 --> 09:02:06,478
10. and we can loop around 10 times

13467
09:02:06,478 --> 09:02:09,600
pretend each element at each iteration

13468
09:02:09,600 --> 09:02:11,040
and the way we do that we're going to

13469
09:02:11,040 --> 09:02:13,200
read with that loop and we're going to

13470
09:02:13,200 --> 09:02:14,878
say for

13471
09:02:14,878 --> 09:02:16,558
okay size t

13472
09:02:16,558 --> 09:02:18,878
and we're going to start from index to

13473
09:02:18,878 --> 09:02:20,878
zero this is really important because

13474
09:02:20,878 --> 09:02:23,760
arrays are indexed from zero they don't

13475
09:02:23,760 --> 09:02:25,680
start from one again this is something

13476
09:02:25,680 --> 09:02:27,840
you need to drill in your brain

13477
09:02:27,840 --> 09:02:29,680
and we're going to put in our test case

13478
09:02:29,680 --> 09:02:32,240
we're going to say i less than 10

13479
09:02:32,240 --> 09:02:34,958
because we want to go from 0 through 9

13480
09:02:34,958 --> 09:02:37,440
and we are going to increment our

13481
09:02:37,440 --> 09:02:40,000
iterator after we do that we're going to

13482
09:02:40,000 --> 09:02:41,200
have to

13483
09:02:41,200 --> 09:02:44,080
jump into the body of the loop and we

13484
09:02:44,080 --> 09:02:46,160
didn't name our iterator that's why

13485
09:02:46,160 --> 09:02:48,160
we're having this squiggly line here

13486
09:02:48,160 --> 09:02:50,080
let's do that pretty quick we're going

13487
09:02:50,080 --> 09:02:53,520
to jump into the body of our loop and we

13488
09:02:53,520 --> 09:02:55,840
are going to say sddc out

13489
09:02:55,840 --> 09:02:58,160
and we're going to say scores

13490
09:02:58,160 --> 09:03:00,160
and we need to be careful about how we

13491
09:03:00,160 --> 09:03:02,478
format this because i is not something

13492
09:03:02,478 --> 09:03:04,638
we have we're going to be getting that

13493
09:03:04,638 --> 09:03:06,718
from our iterator here so we're going to

13494
09:03:06,718 --> 09:03:08,558
print it like this and this is going to

13495
09:03:08,558 --> 09:03:10,718
work no big deal

13496
09:03:10,718 --> 09:03:12,840
and we're going to say

13497
09:03:12,840 --> 09:03:15,920
squares and we're going to say i that's

13498
09:03:15,920 --> 09:03:18,478
going to be our index that we want to

13499
09:03:18,478 --> 09:03:20,160
print the data for

13500
09:03:20,160 --> 09:03:23,520
and we're going to say stdendl

13501
09:03:23,520 --> 09:03:25,840
and uh because we don't want this to

13502
09:03:25,840 --> 09:03:27,040
confuse us

13503
09:03:27,040 --> 09:03:29,440
we're going to comment that out

13504
09:03:29,440 --> 09:03:32,718
and we're going to go up and make sure

13505
09:03:32,718 --> 09:03:35,680
our comment is nice and neat

13506
09:03:35,680 --> 09:03:37,440
and we're going to try and run this and

13507
09:03:37,440 --> 09:03:39,280
what do you expect to see

13508
09:03:39,280 --> 09:03:42,318
well we don't have any real data in here

13509
09:03:42,318 --> 09:03:44,240
we're going to have some junk data so it

13510
09:03:44,240 --> 09:03:46,638
could really be anything we get printed

13511
09:03:46,638 --> 09:03:50,000
here so let's build with gcc and we're

13512
09:03:50,000 --> 09:03:52,240
going to give ourselves some breathing

13513
09:03:52,240 --> 09:03:54,398
room we're going to go down and clear

13514
09:03:54,398 --> 09:03:57,360
and run rooster and you see that um this

13515
09:03:57,360 --> 09:03:59,680
is really some junk data and if we run

13516
09:03:59,680 --> 09:04:01,840
it again let's see that we get the same

13517
09:04:01,840 --> 09:04:03,040
output

13518
09:04:03,040 --> 09:04:05,280
it is the same data in here if we want

13519
09:04:05,280 --> 09:04:08,240
to have in some reliable data we need to

13520
09:04:08,240 --> 09:04:10,478
write in our own data and we're going to

13521
09:04:10,478 --> 09:04:12,080
see how we can do that we're going to

13522
09:04:12,080 --> 09:04:16,398
see how we can write data into an array

13523
09:04:16,398 --> 09:04:19,280
and the syntax is really simple so the

13524
09:04:19,280 --> 09:04:20,798
way you do that

13525
09:04:20,798 --> 09:04:22,638
you just say the index for which you

13526
09:04:22,638 --> 09:04:26,318
want to write data in and you say scores

13527
09:04:26,318 --> 09:04:29,440
and you specify the index let's say zero

13528
09:04:29,440 --> 09:04:31,840
and i'm going to put in a 20 for example

13529
09:04:31,840 --> 09:04:33,760
this is how you do this

13530
09:04:33,760 --> 09:04:36,240
you say 20 let's say scores

13531
09:04:36,240 --> 09:04:38,398
we're going to grab the index one the

13532
09:04:38,398 --> 09:04:40,478
first element and we're going to put in

13533
09:04:40,478 --> 09:04:42,798
a 21 why not

13534
09:04:42,798 --> 09:04:44,878
and we're going to say scores we're

13535
09:04:44,878 --> 09:04:47,520
going to say 2 for index 2 and we're

13536
09:04:47,520 --> 09:04:49,920
going to put in a 22

13537
09:04:49,920 --> 09:04:53,360
why not and after we do this we can

13538
09:04:53,360 --> 09:04:55,680
print this out or read data with the

13539
09:04:55,680 --> 09:04:57,920
loop and make sure that the data we did

13540
09:04:57,920 --> 09:05:00,240
writing is actually n

13541
09:05:00,240 --> 09:05:02,000
so we're going to copy this

13542
09:05:02,000 --> 09:05:04,000
and comment this out because we don't

13543
09:05:04,000 --> 09:05:06,958
want this to confuse us on the console

13544
09:05:06,958 --> 09:05:08,638
and we're going to do that we're going

13545
09:05:08,638 --> 09:05:12,160
to come down here and print the data out

13546
09:05:12,160 --> 09:05:14,398
let's say what we're doing here and if

13547
09:05:14,398 --> 09:05:17,120
we build this we expect to see

13548
09:05:17,120 --> 09:05:20,160
that at index 0 1 and 2 we have the

13549
09:05:20,160 --> 09:05:23,440
values 20 21 and 22.

13550
09:05:23,440 --> 09:05:25,120
let's build and see we're going to run

13551
09:05:25,120 --> 09:05:27,920
the test to build with gcc

13552
09:05:27,920 --> 09:05:29,360
the build is going to go through we're

13553
09:05:29,360 --> 09:05:32,000
going to clear and run the rooster

13554
09:05:32,000 --> 09:05:35,680
and look at this score is a 0 20 score

13555
09:05:35,680 --> 09:05:38,878
is 1 21 score is 2 22

13556
09:05:38,878 --> 09:05:41,520
and our data is actually getting gain

13557
09:05:41,520 --> 09:05:43,280
now we're going to see that we can also

13558
09:05:43,280 --> 09:05:45,440
write the data using the loop to make it

13559
09:05:45,440 --> 09:05:48,478
really easy without us manually doing

13560
09:05:48,478 --> 09:05:49,920
things like this

13561
09:05:49,920 --> 09:05:52,240
for that we're going to copy what we

13562
09:05:52,240 --> 09:05:54,638
have here to print data out

13563
09:05:54,638 --> 09:05:56,478
and we're going to comment what we had

13564
09:05:56,478 --> 09:05:57,600
out here

13565
09:05:57,600 --> 09:05:59,440
so let's comment this out and we're

13566
09:05:59,440 --> 09:06:01,120
going to go down

13567
09:06:01,120 --> 09:06:03,520
and uh print the data again we're going

13568
09:06:03,520 --> 09:06:06,240
to put in the code here and before we

13569
09:06:06,240 --> 09:06:08,238
print the data we're going to put data

13570
09:06:08,238 --> 09:06:08,960
in

13571
09:06:08,960 --> 09:06:11,122
with the loop so the loop is basically

13572
09:06:11,122 --> 09:06:12,398
going to be the same thing we're going

13573
09:06:12,398 --> 09:06:14,000
to say size

13574
09:06:14,000 --> 09:06:16,398
ti we're going to initialize this we're

13575
09:06:16,398 --> 09:06:18,640
going to say i less than 10 because we

13576
09:06:18,640 --> 09:06:20,800
want to loop 10 times we're going to

13577
09:06:20,800 --> 09:06:22,078
increment

13578
09:06:22,078 --> 09:06:23,598
and we're going to fall in the body of

13579
09:06:23,598 --> 09:06:26,078
the loop what we're going to do is write

13580
09:06:26,078 --> 09:06:28,000
data at the index of the current

13581
09:06:28,000 --> 09:06:30,320
iteration i should say so what we're

13582
09:06:30,320 --> 09:06:32,480
going to do we're going to say scores i

13583
09:06:32,480 --> 09:06:34,960
and we can really put in anything for

13584
09:06:34,960 --> 09:06:37,840
now let's say we want to put an i

13585
09:06:37,840 --> 09:06:40,320
multiplied by 10 so we're going to take

13586
09:06:40,320 --> 09:06:43,598
the current index multiply it by 10 and

13587
09:06:43,598 --> 09:06:45,758
we're going to store that in the index

13588
09:06:45,758 --> 09:06:47,840
at the current iteration this is what we

13589
09:06:47,840 --> 09:06:49,122
are doing here

13590
09:06:49,122 --> 09:06:51,122
and if we print this out try to think

13591
09:06:51,122 --> 09:06:53,122
about what we're going to get here

13592
09:06:53,122 --> 09:06:54,160
so

13593
09:06:54,160 --> 09:06:56,878
at index 0 let's put in a 0 to be super

13594
09:06:56,878 --> 09:06:59,040
clear here that we are starting from

13595
09:06:59,040 --> 09:07:01,598
index 0. at index 0 we're going to take

13596
09:07:01,598 --> 09:07:03,598
0 and multiply that with the 10 so we're

13597
09:07:03,598 --> 09:07:07,122
going to store 0 at index 0. the loop is

13598
09:07:07,122 --> 09:07:08,878
going to run again at index 1 we're

13599
09:07:08,878 --> 09:07:10,960
going to take a 1 multiply with 10 we're

13600
09:07:10,960 --> 09:07:13,278
going to get it 10 at index 2 we're

13601
09:07:13,278 --> 09:07:16,160
going to multiply 2 with a 10 and store

13602
09:07:16,160 --> 09:07:19,040
a 20 at index 2 and we're going to keep

13603
09:07:19,040 --> 09:07:21,438
going and basically have 0

13604
09:07:21,438 --> 09:07:24,640
10 20 all the way to 90 stored in our

13605
09:07:24,640 --> 09:07:26,480
array here so if we print it out we

13606
09:07:26,480 --> 09:07:29,918
expect to see 0 10 20 all the way to 90.

13607
09:07:29,918 --> 09:07:32,000
let's weld and see that that's actually

13608
09:07:32,000 --> 09:07:34,878
what we have in our array we're going to

13609
09:07:34,878 --> 09:07:37,200
work successfully let's clear and run

13610
09:07:37,200 --> 09:07:39,758
rooster and you see that this is exactly

13611
09:07:39,758 --> 09:07:42,558
the same thing we have in our array how

13612
09:07:42,558 --> 09:07:44,800
cool is that okay another thing i want

13613
09:07:44,800 --> 09:07:47,438
you to see is that we can declare and

13614
09:07:47,438 --> 09:07:49,680
initialize an array

13615
09:07:49,680 --> 09:07:52,000
in place but before we do that let's say

13616
09:07:52,000 --> 09:07:54,078
what we were doing here we were trying

13617
09:07:54,078 --> 09:07:56,078
to write data in a loop and we're going

13618
09:07:56,078 --> 09:07:58,160
to comment this out because we don't

13619
09:07:58,160 --> 09:08:01,360
want a lot of confusing output

13620
09:08:01,360 --> 09:08:03,520
in our console and we're going to go

13621
09:08:03,520 --> 09:08:05,680
down and put in the data because i don't

13622
09:08:05,680 --> 09:08:07,598
want to type all these thanks

13623
09:08:07,598 --> 09:08:09,840
so we can declare and initialize an

13624
09:08:09,840 --> 09:08:13,278
array in place and the way we do that

13625
09:08:13,278 --> 09:08:15,758
the array is going to store doubles now

13626
09:08:15,758 --> 09:08:17,680
we can really declare an array of

13627
09:08:17,680 --> 09:08:20,000
anything but so far we have seen that we

13628
09:08:20,000 --> 09:08:22,320
can do that for ant now let's try a

13629
09:08:22,320 --> 09:08:23,918
little bit and show you that you can do

13630
09:08:23,918 --> 09:08:26,320
the same thing for double times so we

13631
09:08:26,320 --> 09:08:28,800
can declare an array of double types the

13632
09:08:28,800 --> 09:08:31,040
size is going to be five and we're going

13633
09:08:31,040 --> 09:08:33,360
to initialize that with this data here

13634
09:08:33,360 --> 09:08:35,278
so at index zero we're going to have a

13635
09:08:35,278 --> 09:08:41,758
12.7 index one a 7.5 index 2 a 13.2

13636
09:08:41,758 --> 09:08:43,122
index 3

13637
09:08:43,122 --> 09:08:47,598
an 8.1 and index 4 and 9.3 and that's

13638
09:08:47,598 --> 09:08:49,520
what we're going to have if we print

13639
09:08:49,520 --> 09:08:51,438
this out here we have a simple loop to

13640
09:08:51,438 --> 09:08:53,122
print it out and it's going to basically

13641
09:08:53,122 --> 09:08:54,680
say salary 0

13642
09:08:54,680 --> 09:08:57,360
12.7 and it's going to go all the way to

13643
09:08:57,360 --> 09:09:01,360
salary 4 and print a 9.3 and this is

13644
09:09:01,360 --> 09:09:02,800
something you can do

13645
09:09:02,800 --> 09:09:04,878
if it makes sense for whatever you are

13646
09:09:04,878 --> 09:09:07,840
designing with c plus plus we're going

13647
09:09:07,840 --> 09:09:10,480
to build this with gcc

13648
09:09:10,480 --> 09:09:13,200
let's clear and run and you see that

13649
09:09:13,200 --> 09:09:16,238
this is exactly what we expect okay now

13650
09:09:16,238 --> 09:09:18,640
this is super clear the next thing we're

13651
09:09:18,640 --> 09:09:20,800
going to see is that if you don't

13652
09:09:20,800 --> 09:09:24,078
initialize all the elements in the array

13653
09:09:24,078 --> 09:09:26,320
those you leave out are going to be

13654
09:09:26,320 --> 09:09:28,558
initialized to zero and we are going to

13655
09:09:28,558 --> 09:09:31,438
put in a piece of code to play with that

13656
09:09:31,438 --> 09:09:33,360
so here we have an array it's a net

13657
09:09:33,360 --> 09:09:35,520
array it's going to be called families

13658
09:09:35,520 --> 09:09:38,160
and the size is going to be five but we

13659
09:09:38,160 --> 09:09:41,360
are only initializing three elements and

13660
09:09:41,360 --> 09:09:43,200
these elements are going to be elements

13661
09:09:43,200 --> 09:09:47,200
on the front so elements at index 3 and

13662
09:09:47,200 --> 09:09:49,680
4 are going to be left out and they are

13663
09:09:49,680 --> 09:09:52,480
going to be initialized to 0 by the

13664
09:09:52,480 --> 09:09:54,800
compiler so if we print this out we

13665
09:09:54,800 --> 09:09:58,960
expect to get 12 7 5 and 0 0 at

13666
09:09:58,960 --> 09:10:01,520
different indexes in this array here

13667
09:10:01,520 --> 09:10:03,040
let's build this

13668
09:10:03,040 --> 09:10:04,960
with gcc

13669
09:10:04,960 --> 09:10:07,278
we're going to clear because the build

13670
09:10:07,278 --> 09:10:08,800
is successful

13671
09:10:08,800 --> 09:10:11,040
and we're going to run this

13672
09:10:11,040 --> 09:10:13,040
this is exactly what we expect we have a

13673
09:10:13,040 --> 09:10:16,398
12 a 7 and 5 and the last two elements

13674
09:10:16,398 --> 09:10:18,960
are initialized to zero and this may

13675
09:10:18,960 --> 09:10:21,438
come in handy sometimes okay let's

13676
09:10:21,438 --> 09:10:23,438
comment this out another thing we want

13677
09:10:23,438 --> 09:10:26,238
to see is that we can actually

13678
09:10:26,238 --> 09:10:29,278
omit the size when we are declaring our

13679
09:10:29,278 --> 09:10:30,320
array

13680
09:10:30,320 --> 09:10:33,040
and initializing it so here is a simple

13681
09:10:33,040 --> 09:10:35,278
example we have an inter array called

13682
09:10:35,278 --> 09:10:38,398
class sizes we don't specify the size

13683
09:10:38,398 --> 09:10:41,360
but we initialize it and the compiler is

13684
09:10:41,360 --> 09:10:44,000
going to deduce the size of this array

13685
09:10:44,000 --> 09:10:46,718
from the elements we put in here so if

13686
09:10:46,718 --> 09:10:49,122
we put in two elements so it's going to

13687
09:10:49,122 --> 09:10:51,520
be of size 2 if we put in 10 elements

13688
09:10:51,520 --> 09:10:54,238
it's going to be of size 10 and this is

13689
09:10:54,238 --> 09:10:56,960
how this works but if you do something

13690
09:10:56,960 --> 09:10:59,200
like this and not to initialize the

13691
09:10:59,200 --> 09:11:02,398
array let's take this out for example

13692
09:11:02,398 --> 09:11:03,918
you're going to get a compiler error

13693
09:11:03,918 --> 09:11:06,320
because the compiler now doesn't know

13694
09:11:06,320 --> 09:11:08,320
which size it's going to give to this

13695
09:11:08,320 --> 09:11:10,960
array so be sure to

13696
09:11:10,960 --> 09:11:12,238
either

13697
09:11:12,238 --> 09:11:15,122
put in the size or initialize your array

13698
09:11:15,122 --> 09:11:17,360
like this and it is going to work in

13699
09:11:17,360 --> 09:11:19,278
this case we're going to have six

13700
09:11:19,278 --> 09:11:21,758
elements and and you see that a range

13701
09:11:21,758 --> 09:11:23,918
based for loop is going to come in handy

13702
09:11:23,918 --> 09:11:26,320
here because we don't really know the

13703
09:11:26,320 --> 09:11:28,558
size of this array if somebody comes and

13704
09:11:28,558 --> 09:11:31,598
adds another element let's say 23

13705
09:11:31,598 --> 09:11:33,758
the size is going to change and if we

13706
09:11:33,758 --> 09:11:36,558
hard to code the size in our full loop

13707
09:11:36,558 --> 09:11:38,960
the code is going to break but a range

13708
09:11:38,960 --> 09:11:41,680
based for loop is going to use whatever

13709
09:11:41,680 --> 09:11:43,598
size this already has so we're going to

13710
09:11:43,598 --> 09:11:45,360
try and build this we're going to build

13711
09:11:45,360 --> 09:11:47,918
with gcc as usual

13712
09:11:47,918 --> 09:11:49,680
and the world is going to go through if

13713
09:11:49,680 --> 09:11:51,840
we run rooster we're going to get the

13714
09:11:51,840 --> 09:11:56,160
elements we have 10 12 15 11 18 17 23 if

13715
09:11:56,160 --> 09:11:58,000
we add a new element this is going to

13716
09:11:58,000 --> 09:11:58,960
work

13717
09:11:58,960 --> 09:12:00,960
you see that we don't need to modify the

13718
09:12:00,960 --> 09:12:02,320
loop here to

13719
09:12:02,320 --> 09:12:04,640
put in the new size and this is really

13720
09:12:04,640 --> 09:12:06,960
cool i like this about range based for

13721
09:12:06,960 --> 09:12:09,040
loops we're going to build again

13722
09:12:09,040 --> 09:12:11,040
and we're going to clear

13723
09:12:11,040 --> 09:12:12,558
run the rooster and this is going to

13724
09:12:12,558 --> 09:12:15,122
give us exactly the data we have in the

13725
09:12:15,122 --> 09:12:17,520
array so this is one way you can do

13726
09:12:17,520 --> 09:12:19,840
things another thing we saw is that you

13727
09:12:19,840 --> 09:12:22,558
can't modify const arrays

13728
09:12:22,558 --> 09:12:25,040
so let's do an example here for example

13729
09:12:25,040 --> 09:12:27,360
we're going to grab this thing and uh

13730
09:12:27,360 --> 09:12:30,320
put an array declared down here we're

13731
09:12:30,320 --> 09:12:32,718
going to copy that and use that here and

13732
09:12:32,718 --> 09:12:34,800
we're going to make this cost

13733
09:12:34,800 --> 09:12:37,520
let's give it a name let's say

13734
09:12:37,520 --> 09:12:39,680
birds for example for example we want to

13735
09:12:39,680 --> 09:12:40,558
keep

13736
09:12:40,558 --> 09:12:42,398
track of

13737
09:12:42,398 --> 09:12:44,960
lines of birds or whatever this is just

13738
09:12:44,960 --> 09:12:46,640
an example to show you that you can't

13739
09:12:46,640 --> 09:12:49,438
modify this array so if you try to do

13740
09:12:49,438 --> 09:12:51,840
something like birds

13741
09:12:51,840 --> 09:12:54,718
and index 2 for example and you want to

13742
09:12:54,718 --> 09:12:57,520
change this to an 8

13743
09:12:57,520 --> 09:12:59,758
the compiler is going to complain you

13744
09:12:59,758 --> 09:13:01,758
see that visual studio code is

13745
09:13:01,758 --> 09:13:03,438
complaining already

13746
09:13:03,438 --> 09:13:06,160
expiration must be a modifiable value so

13747
09:13:06,160 --> 09:13:09,360
it is saying that the array stores const

13748
09:13:09,360 --> 09:13:12,398
elements so you can't modify elements of

13749
09:13:12,398 --> 09:13:14,878
this array okay so this is something you

13750
09:13:14,878 --> 09:13:16,800
can do if you don't want people to be

13751
09:13:16,800 --> 09:13:20,398
able to modify data in your array and

13752
09:13:20,398 --> 09:13:22,718
the last thing i'm going to show you is

13753
09:13:22,718 --> 09:13:26,078
that you can do operations on the data

13754
09:13:26,078 --> 09:13:27,598
in an array

13755
09:13:27,598 --> 09:13:30,238
so let's bring up our scores array again

13756
09:13:30,238 --> 09:13:31,918
so we're going to go up and copy it

13757
09:13:31,918 --> 09:13:34,078
because the code is using there so let's

13758
09:13:34,078 --> 09:13:37,520
put in our own scores array

13759
09:13:37,520 --> 09:13:39,520
it's going to be pretty fast and we're

13760
09:13:39,520 --> 09:13:41,200
going to say that it is an array with

13761
09:13:41,200 --> 09:13:42,718
this angle brackets we're going to

13762
09:13:42,718 --> 09:13:44,800
initialize this let's put in a bunch of

13763
09:13:44,800 --> 09:13:47,520
values and what we can do is sum these

13764
09:13:47,520 --> 09:13:49,520
things up we're going to store our

13765
09:13:49,520 --> 09:13:52,078
results in the sum variable and we're

13766
09:13:52,078 --> 09:13:54,480
going to loop around with a ranged based

13767
09:13:54,480 --> 09:13:56,800
for loop because we don't really know

13768
09:13:56,800 --> 09:13:58,718
the size of this array it can change any

13769
09:13:58,718 --> 09:14:02,238
time with however many elements and a

13770
09:14:02,238 --> 09:14:04,558
range based for loop is really cool in

13771
09:14:04,558 --> 09:14:06,398
that we don't have to keep track of the

13772
09:14:06,398 --> 09:14:07,918
size of ourselves

13773
09:14:07,918 --> 09:14:10,800
so we're going to go in here

13774
09:14:10,800 --> 09:14:12,640
and get each element

13775
09:14:12,640 --> 09:14:14,718
and add that to some

13776
09:14:14,718 --> 09:14:17,122
so for example for the first time sum is

13777
09:14:17,122 --> 09:14:18,800
going to be 0 because that's what we

13778
09:14:18,800 --> 09:14:20,640
initialize it with we're going to get

13779
09:14:20,640 --> 09:14:23,598
into this loop here the first element is

13780
09:14:23,598 --> 09:14:25,520
going to be 2 we're going to add that to

13781
09:14:25,520 --> 09:14:28,480
0 and get 2 we're going to add a 5 we're

13782
09:14:28,480 --> 09:14:29,918
going to get a 7 we're going to keep

13783
09:14:29,918 --> 09:14:33,122
adding this element and at the end sum

13784
09:14:33,122 --> 09:14:35,758
is going to contain the sum of all these

13785
09:14:35,758 --> 09:14:37,918
elements in the array here and this is

13786
09:14:37,918 --> 09:14:40,398
one cool way you can sum up the elements

13787
09:14:40,398 --> 09:14:43,040
in your array so if we run this we're

13788
09:14:43,040 --> 09:14:44,800
going to get the sun printed out let's

13789
09:14:44,800 --> 09:14:46,960
do that pretty quick we're going to run

13790
09:14:46,960 --> 09:14:50,000
this has to build with gcc and we have

13791
09:14:50,000 --> 09:14:52,320
ourselves a compiler error

13792
09:14:52,320 --> 09:14:54,960
what is happening here it's going to say

13793
09:14:54,960 --> 09:14:58,238
redeclaration of scores where did we

13794
09:14:58,238 --> 09:15:00,640
declare scores before let's go up and

13795
09:15:00,640 --> 09:15:03,122
make sure it is not declared somewhere

13796
09:15:03,122 --> 09:15:05,040
and it is declared here

13797
09:15:05,040 --> 09:15:07,438
so we want to comment this out

13798
09:15:07,438 --> 09:15:09,598
come back to our code so that we can see

13799
09:15:09,598 --> 09:15:10,320
it

13800
09:15:10,320 --> 09:15:14,160
and we're going to build again with gcc

13801
09:15:14,160 --> 09:15:16,078
and now the world is going through we're

13802
09:15:16,078 --> 09:15:17,278
going to clear

13803
09:15:17,278 --> 09:15:19,122
and if we run rooster

13804
09:15:19,122 --> 09:15:20,160
score

13805
09:15:20,160 --> 09:15:23,758
sum is 37 and if you sum these things up

13806
09:15:23,758 --> 09:15:26,640
i'm sure you get 37. this is really all

13807
09:15:26,640 --> 09:15:28,398
we set out to do in this lecture i hope

13808
09:15:28,398 --> 09:15:30,398
you have a better idea of how you can

13809
09:15:30,398 --> 09:15:33,680
declare your arrays put data in read

13810
09:15:33,680 --> 09:15:36,320
data out of those arrays make them const

13811
09:15:36,320 --> 09:15:38,800
or even do all kinds of operations on

13812
09:15:38,800 --> 09:15:40,718
them and this was really what this

13813
09:15:40,718 --> 09:15:42,718
lecture was all about

13814
09:15:42,718 --> 09:15:44,160
we are going to stop here in this

13815
09:15:44,160 --> 09:15:46,000
lecture in the next one we're going to

13816
09:15:46,000 --> 09:15:48,398
see a cool way we can use to get the

13817
09:15:48,398 --> 09:15:50,640
size of an array

13818
09:15:50,640 --> 09:15:52,480
go ahead and finish up here

13819
09:15:52,480 --> 09:15:54,718
and meet me there in this lecture we're

13820
09:15:54,718 --> 09:15:56,718
going to see a way we can query for the

13821
09:15:56,718 --> 09:15:58,398
size of an array

13822
09:15:58,398 --> 09:16:00,718
at runtime if you remember in the last

13823
09:16:00,718 --> 09:16:02,800
lecture we had an example like this

13824
09:16:02,800 --> 09:16:05,278
showing how we can declare an array and

13825
09:16:05,278 --> 09:16:08,000
initialize it in a single statement like

13826
09:16:08,000 --> 09:16:08,800
this

13827
09:16:08,800 --> 09:16:11,680
but the problem we had with this is that

13828
09:16:11,680 --> 09:16:14,800
if we tried to print the array using a

13829
09:16:14,800 --> 09:16:17,040
for loop for example we would have to

13830
09:16:17,040 --> 09:16:19,680
use the size and the size of this array

13831
09:16:19,680 --> 09:16:22,000
may change if somebody decides to add

13832
09:16:22,000 --> 09:16:24,078
elements or remove elements then the

13833
09:16:24,078 --> 09:16:26,398
size is going to be irrelevant c plus

13834
09:16:26,398 --> 09:16:29,200
plus provides a way we can query for the

13835
09:16:29,200 --> 09:16:31,918
size of an array at runtime and we're

13836
09:16:31,918 --> 09:16:34,480
going to get the real size accounting

13837
09:16:34,480 --> 09:16:36,878
for the current number of elements that

13838
09:16:36,878 --> 09:16:39,360
we have in the array and for that we use

13839
09:16:39,360 --> 09:16:42,320
the std size function

13840
09:16:42,320 --> 09:16:44,558
this is a function that comes with the c

13841
09:16:44,558 --> 09:16:46,238
plus plus standard library so you're

13842
09:16:46,238 --> 09:16:48,480
going to have it already if you have a

13843
09:16:48,480 --> 09:16:50,800
compliant compiler if you see here you

13844
09:16:50,800 --> 09:16:54,000
see that it was introduced in c plus 17

13845
09:16:54,000 --> 09:16:56,000
and it is a cool addition we can use it

13846
09:16:56,000 --> 09:16:58,320
to make our code easier to work with if

13847
09:16:58,320 --> 09:16:59,840
you look here we have a simple loop

13848
09:16:59,840 --> 09:17:02,000
which is going to print data out it is

13849
09:17:02,000 --> 09:17:04,320
going to loop starting from zero all the

13850
09:17:04,320 --> 09:17:06,878
way to the size of the array you see

13851
09:17:06,878 --> 09:17:09,598
that we use this to control when this

13852
09:17:09,598 --> 09:17:12,000
loop is going to end we then put in our

13853
09:17:12,000 --> 09:17:14,078
incrementation part and then we jump

13854
09:17:14,078 --> 09:17:16,238
into the body of the loop and print the

13855
09:17:16,238 --> 09:17:18,320
current element in the loop and if we do

13856
09:17:18,320 --> 09:17:19,680
things like this we're going to be able

13857
09:17:19,680 --> 09:17:22,238
to print all elements in the array

13858
09:17:22,238 --> 09:17:24,960
regardless of the number we initialize

13859
09:17:24,960 --> 09:17:27,680
it with okay so this is one way and it

13860
09:17:27,680 --> 09:17:30,558
was introduced in c plus plus 17. but

13861
09:17:30,558 --> 09:17:32,718
some of you must be asking

13862
09:17:32,718 --> 09:17:35,200
how did we do things before z plus plus

13863
09:17:35,200 --> 09:17:36,398
17

13864
09:17:36,398 --> 09:17:39,598
well we had to kind of do a hack to get

13865
09:17:39,598 --> 09:17:42,160
something like this we use the size of

13866
09:17:42,160 --> 09:17:44,718
operator we have seen a lot of times

13867
09:17:44,718 --> 09:17:45,680
right now

13868
09:17:45,680 --> 09:17:47,520
and the way you use this

13869
09:17:47,520 --> 09:17:50,960
if you do size of and passing the array

13870
09:17:50,960 --> 09:17:52,960
you're going to get the entire size of

13871
09:17:52,960 --> 09:17:56,238
the array so if we take that and divide

13872
09:17:56,238 --> 09:17:58,960
that with the size of a single element

13873
09:17:58,960 --> 09:18:00,960
in the array we're going to get the

13874
09:18:00,960 --> 09:18:03,200
number of elements of the array and this

13875
09:18:03,200 --> 09:18:05,278
is really what we are doing here we are

13876
09:18:05,278 --> 09:18:07,680
setting up a count variable and we are

13877
09:18:07,680 --> 09:18:09,918
taking the size of the array and

13878
09:18:09,918 --> 09:18:12,480
dividing that with the size of a single

13879
09:18:12,480 --> 09:18:14,800
element in the array and we are just

13880
09:18:14,800 --> 09:18:17,040
grabbing the first element because you

13881
09:18:17,040 --> 09:18:19,598
can really use any element here and once

13882
09:18:19,598 --> 09:18:22,078
we have this we can use this count to do

13883
09:18:22,078 --> 09:18:24,078
a loop like this and it is working

13884
09:18:24,078 --> 09:18:25,122
pretty well

13885
09:18:25,122 --> 09:18:27,598
please remember that you don't have to

13886
09:18:27,598 --> 09:18:29,360
go through this craziness we're doing

13887
09:18:29,360 --> 09:18:32,480
here you don't even have to use std size

13888
09:18:32,480 --> 09:18:35,520
because you can use a ranged base for

13889
09:18:35,520 --> 09:18:37,840
loop and get access to the elements you

13890
09:18:37,840 --> 09:18:39,438
have in the array and it is going to

13891
09:18:39,438 --> 09:18:41,598
work pretty well now that you have an

13892
09:18:41,598 --> 09:18:44,000
idea about this let's head to visual

13893
09:18:44,000 --> 09:18:46,718
studio code and actually play with us

13894
09:18:46,718 --> 09:18:49,680
okay so here we are in our working

13895
09:18:49,680 --> 09:18:52,000
folder we are going to be working on

13896
09:18:52,000 --> 09:18:54,558
this project size of an array we're

13897
09:18:54,558 --> 09:18:56,558
going to grab our template project we're

13898
09:18:56,558 --> 09:18:59,122
going to copy the files and put them in

13899
09:18:59,122 --> 09:19:00,238
place

13900
09:19:00,238 --> 09:19:01,758
and we're going to open this up in

13901
09:19:01,758 --> 09:19:03,918
visual studio code let's do that it's

13902
09:19:03,918 --> 09:19:05,840
going to open up in visual studio code

13903
09:19:05,840 --> 09:19:08,078
and we're going to try and

13904
09:19:08,078 --> 09:19:10,238
clean it up a little bit and we are

13905
09:19:10,238 --> 09:19:12,800
going to declare an array if we want to

13906
09:19:12,800 --> 09:19:14,480
print this thing

13907
09:19:14,480 --> 09:19:16,640
we need to know how many times we're

13908
09:19:16,640 --> 09:19:19,360
going to loop and print elements in here

13909
09:19:19,360 --> 09:19:21,596
so one thing you might want to do is to

13910
09:19:21,596 --> 09:19:24,320
say okay we have 10 elements in here so

13911
09:19:24,320 --> 09:19:26,640
i'm going to loop for 10 times you might

13912
09:19:26,640 --> 09:19:28,720
think this is going to work and it is

13913
09:19:28,720 --> 09:19:30,480
going to work if we

13914
09:19:30,480 --> 09:19:32,400
bring up a terminal

13915
09:19:32,400 --> 09:19:35,840
and build this with gcc like we usually

13916
09:19:35,840 --> 09:19:36,960
do

13917
09:19:36,960 --> 09:19:39,596
and uh clear

13918
09:19:39,596 --> 09:19:42,160
and run rooster we are going to get our

13919
09:19:42,160 --> 09:19:44,240
numbers this is what we have in the

13920
09:19:44,240 --> 09:19:46,160
array from one to ten

13921
09:19:46,160 --> 09:19:49,360
but what if somebody comes and changes

13922
09:19:49,360 --> 09:19:51,200
the elements we have in here let's add

13923
09:19:51,200 --> 09:19:54,080
an 11 and a 12.

13924
09:19:54,080 --> 09:19:54,960
and

13925
09:19:54,960 --> 09:19:57,040
the moment we change this we will need

13926
09:19:57,040 --> 09:19:59,520
to come and change the size in here and

13927
09:19:59,520 --> 09:20:01,840
this loop here might be buried somewhere

13928
09:20:01,840 --> 09:20:04,720
deep in your project and it might not be

13929
09:20:04,720 --> 09:20:08,320
as easy as it is now to see that we also

13930
09:20:08,320 --> 09:20:10,880
need to change this this may be a really

13931
09:20:10,880 --> 09:20:14,400
big source of hard to debug problems so

13932
09:20:14,400 --> 09:20:17,680
what we really need is a way to get the

13933
09:20:17,680 --> 09:20:21,276
size of the array at runtime and be able

13934
09:20:21,276 --> 09:20:23,756
to dynamically query for that size and

13935
09:20:23,756 --> 09:20:26,080
use it in our program and that's exactly

13936
09:20:26,080 --> 09:20:30,080
what std size provides so we're going to

13937
09:20:30,080 --> 09:20:32,080
say end count

13938
09:20:32,080 --> 09:20:34,400
and we're going to put in a value let's

13939
09:20:34,400 --> 09:20:36,400
use a braced initializer so we're going

13940
09:20:36,400 --> 09:20:38,800
to say std size

13941
09:20:38,800 --> 09:20:40,480
and we're going to pass the array we

13942
09:20:40,480 --> 09:20:42,640
want to get the size for

13943
09:20:42,640 --> 09:20:44,400
and if we do this we're going to get

13944
09:20:44,400 --> 09:20:46,000
this size here

13945
09:20:46,000 --> 09:20:48,320
and we're going to be looping for this

13946
09:20:48,320 --> 09:20:50,320
number of times so we're going to test

13947
09:20:50,320 --> 09:20:53,840
for i is less than the count here

13948
09:20:53,840 --> 09:20:56,160
and now it doesn't matter how many

13949
09:20:56,160 --> 09:20:58,000
elements we have in here we're going to

13950
09:20:58,000 --> 09:21:00,480
get them at run time we need to only

13951
09:21:00,480 --> 09:21:03,120
update this initializer here so what we

13952
09:21:03,120 --> 09:21:04,880
can do is

13953
09:21:04,880 --> 09:21:07,756
weld with gcc again now

13954
09:21:07,756 --> 09:21:09,756
we're going to come here

13955
09:21:09,756 --> 09:21:12,400
and run rooster and we're going to get

13956
09:21:12,400 --> 09:21:14,160
the numbers here you see that we get all

13957
09:21:14,160 --> 09:21:17,276
the elements if we take out a few of

13958
09:21:17,276 --> 09:21:19,596
these elements let's take out a few of

13959
09:21:19,596 --> 09:21:22,080
these let's leave it up to seven or

13960
09:21:22,080 --> 09:21:22,960
eight

13961
09:21:22,960 --> 09:21:25,596
let's build again and we are going to

13962
09:21:25,596 --> 09:21:28,000
clear and run rooster we're going to get

13963
09:21:28,000 --> 09:21:30,400
however many elements we have in there

13964
09:21:30,400 --> 09:21:33,200
and this is pretty cool again you might

13965
09:21:33,200 --> 09:21:35,840
ask how did we do things before c plus

13966
09:21:35,840 --> 09:21:39,916
plus 17 because std size was introduced

13967
09:21:39,916 --> 09:21:42,960
in c plus plus 17 let's say that here

13968
09:21:42,960 --> 09:21:46,240
before that we had to get the size of

13969
09:21:46,240 --> 09:21:49,756
the entire array and divide that with

13970
09:21:49,756 --> 09:21:52,480
the size of each element in the array

13971
09:21:52,480 --> 09:21:55,120
and we could use the size of operator to

13972
09:21:55,120 --> 09:21:58,400
do that so before we do any of that we

13973
09:21:58,400 --> 09:22:00,960
want to play with the size of method to

13974
09:22:00,960 --> 09:22:02,800
really show you what it does

13975
09:22:02,800 --> 09:22:05,520
so what we're going to do is say sdd the

13976
09:22:05,520 --> 09:22:08,480
out size of

13977
09:22:08,480 --> 09:22:11,120
scores the entire array and we're going

13978
09:22:11,120 --> 09:22:13,120
to print that and we're going to say

13979
09:22:13,120 --> 09:22:15,436
sddcl

13980
09:22:15,436 --> 09:22:17,200
size of

13981
09:22:17,200 --> 09:22:20,840
you know one element let's say

13982
09:22:20,840 --> 09:22:24,480
scores and use the first element this is

13983
09:22:24,480 --> 09:22:27,200
the easiest thing we can find here but

13984
09:22:27,200 --> 09:22:29,040
you can use any element so we're going

13985
09:22:29,040 --> 09:22:31,360
to say size of here and we're going to

13986
09:22:31,360 --> 09:22:34,560
say scores and grab the first element

13987
09:22:34,560 --> 09:22:36,880
which is at index 0 and we're going to

13988
09:22:36,880 --> 09:22:39,360
print its size if we build and run this

13989
09:22:39,360 --> 09:22:40,880
program

13990
09:22:40,880 --> 09:22:43,520
we're going to build and run

13991
09:22:43,520 --> 09:22:46,400
and the world is good we can clear now

13992
09:22:46,400 --> 09:22:48,560
and run rooster you're going to see that

13993
09:22:48,560 --> 09:22:51,596
we're going to get size of scores is 32

13994
09:22:51,596 --> 09:22:54,640
the entire array the size of one element

13995
09:22:54,640 --> 09:22:56,560
is four because we are storing in

13996
09:22:56,560 --> 09:23:00,080
integers and i want you to see that 32

13997
09:23:00,080 --> 09:23:03,120
is four times eight because we have an

13998
09:23:03,120 --> 09:23:05,436
eight elements so it's going to give you

13999
09:23:05,436 --> 09:23:08,320
the combined size of all of the elements

14000
09:23:08,320 --> 09:23:11,200
that we have in here if you do size of

14001
09:23:11,200 --> 09:23:12,560
an array

14002
09:23:12,560 --> 09:23:14,880
but if you do size of a single element

14003
09:23:14,880 --> 09:23:16,640
you're going to get the size of a single

14004
09:23:16,640 --> 09:23:19,200
element so c plus plus developers were

14005
09:23:19,200 --> 09:23:21,596
clever enough to see this

14006
09:23:21,596 --> 09:23:23,756
and see that we could use this

14007
09:23:23,756 --> 09:23:25,596
information and get the count of

14008
09:23:25,596 --> 09:23:28,240
elements inside so we can do something

14009
09:23:28,240 --> 09:23:30,240
like ant account

14010
09:23:30,240 --> 09:23:32,960
and we're going to assign a value to

14011
09:23:32,960 --> 09:23:33,756
this

14012
09:23:33,756 --> 09:23:36,240
in our braced initializer so we're going

14013
09:23:36,240 --> 09:23:37,840
to say size

14014
09:23:37,840 --> 09:23:38,880
of

14015
09:23:38,880 --> 09:23:41,040
we're going to say scores

14016
09:23:41,040 --> 09:23:43,756
and we're going to divide that with size

14017
09:23:43,756 --> 09:23:46,720
of and i'm going to grab scores we can

14018
09:23:46,720 --> 09:23:49,120
really use any element in the array but

14019
09:23:49,120 --> 09:23:51,680
we're going to grab the one at index 0

14020
09:23:51,680 --> 09:23:53,360
and now we're going to get the count

14021
09:23:53,360 --> 09:23:55,840
stored in our account variable without

14022
09:23:55,840 --> 09:23:59,520
using std size and we can uncomment our

14023
09:23:59,520 --> 09:24:00,880
array here

14024
09:24:00,880 --> 09:24:03,520
or the code to print the array and if we

14025
09:24:03,520 --> 09:24:05,360
run now it is going to work exactly the

14026
09:24:05,360 --> 09:24:07,680
same thing regardless of the amount of

14027
09:24:07,680 --> 09:24:10,320
elements you have in here let's put a

14028
09:24:10,320 --> 09:24:13,916
few numbers randomly and if we will then

14029
09:24:13,916 --> 09:24:16,640
run we are going to clear and run

14030
09:24:16,640 --> 09:24:18,720
rooster and we're going to get all the

14031
09:24:18,720 --> 09:24:20,640
elements here and

14032
09:24:20,640 --> 09:24:22,480
you can really use any of these

14033
09:24:22,480 --> 09:24:24,720
techniques just choose what you feel

14034
09:24:24,720 --> 09:24:27,840
works better for you okay we are going

14035
09:24:27,840 --> 09:24:30,080
through all this trouble to set up an

14036
09:24:30,080 --> 09:24:32,240
iterator we're going to do the test

14037
09:24:32,240 --> 09:24:34,160
we're going to increment this is really

14038
09:24:34,160 --> 09:24:37,596
too much work to try and get data from a

14039
09:24:37,596 --> 09:24:40,320
collection like an array so what we can

14040
09:24:40,320 --> 09:24:43,520
do instead is comment out all this hard

14041
09:24:43,520 --> 09:24:44,800
work here

14042
09:24:44,800 --> 09:24:47,436
and we can use a ranged based for loop

14043
09:24:47,436 --> 09:24:49,200
as we have seen before and it is

14044
09:24:49,200 --> 09:24:52,240
ridiculously easy and convenient to work

14045
09:24:52,240 --> 09:24:55,200
with so what you can do is say for

14046
09:24:55,200 --> 09:24:57,436
auto i we're going to do

14047
09:24:57,436 --> 09:24:59,756
type deduction on whatever it is we have

14048
09:24:59,756 --> 09:25:02,160
stored in our array so we're going to

14049
09:25:02,160 --> 09:25:04,400
put a column and say scores

14050
09:25:04,400 --> 09:25:07,120
and we're going to print out the element

14051
09:25:07,120 --> 09:25:10,720
so let's do that we're going to print

14052
09:25:10,720 --> 09:25:14,000
stdcl and here we're going to say value

14053
09:25:14,000 --> 09:25:16,480
let's say value in the array and we're

14054
09:25:16,480 --> 09:25:17,756
going to say

14055
09:25:17,756 --> 09:25:20,000
i and this is going to print all the

14056
09:25:20,000 --> 09:25:22,560
elements and we can work with the values

14057
09:25:22,560 --> 09:25:25,120
inside if we want that but you see that

14058
09:25:25,120 --> 09:25:27,520
we have lost the information

14059
09:25:27,520 --> 09:25:29,840
on the indexes so if you really need the

14060
09:25:29,840 --> 09:25:32,320
indexes you will need to go through

14061
09:25:32,320 --> 09:25:34,800
something like this and if you just need

14062
09:25:34,800 --> 09:25:38,160
the values in the array ranged based for

14063
09:25:38,160 --> 09:25:40,080
loops are going to be really cool let's

14064
09:25:40,080 --> 09:25:42,320
say range base for loop and if we boiled

14065
09:25:42,320 --> 09:25:44,320
and run this it's going to work pretty

14066
09:25:44,320 --> 09:25:45,200
well

14067
09:25:45,200 --> 09:25:47,840
so the world is going to go through

14068
09:25:47,840 --> 09:25:50,480
let's bring this up so that we have some

14069
09:25:50,480 --> 09:25:53,120
breathing room we're going to clear

14070
09:25:53,120 --> 09:25:55,120
and run rooster

14071
09:25:55,120 --> 09:25:56,800
and we're going to get our elements

14072
09:25:56,800 --> 09:25:58,720
printed out here and you see that it is

14073
09:25:58,720 --> 09:26:01,120
the exact same thing we have in scores

14074
09:26:01,120 --> 09:26:01,916
here

14075
09:26:01,916 --> 09:26:03,840
so this is really all we set out to do

14076
09:26:03,840 --> 09:26:05,840
in this lecture i just wanted you to be

14077
09:26:05,840 --> 09:26:08,800
aware of the sdd size

14078
09:26:08,800 --> 09:26:11,276
facility that we have in the c plus plus

14079
09:26:11,276 --> 09:26:13,360
standard library if you don't want to

14080
09:26:13,360 --> 09:26:16,000
use it for any reason you can also go in

14081
09:26:16,000 --> 09:26:18,560
and do the division we did here to get

14082
09:26:18,560 --> 09:26:21,840
the count of elements in the array

14083
09:26:21,840 --> 09:26:24,800
and uh do your best to try and use

14084
09:26:24,800 --> 09:26:27,120
ranged basis for loops because they make

14085
09:26:27,120 --> 09:26:30,160
it easier and cleaner to get data from a

14086
09:26:30,160 --> 09:26:32,800
collection like we are doing here with

14087
09:26:32,800 --> 09:26:35,520
an array we are going to stop here in

14088
09:26:35,520 --> 09:26:37,120
this lecture and the next one we're

14089
09:26:37,120 --> 09:26:39,520
going to see how we can work with arrays

14090
09:26:39,520 --> 09:26:41,276
of characters

14091
09:26:41,276 --> 09:26:43,596
go ahead and finish up here and meet me

14092
09:26:43,596 --> 09:26:45,120
there

14093
09:26:45,120 --> 09:26:47,120
in this lecture we're going to work on

14094
09:26:47,120 --> 09:26:49,520
array of characters and show how special

14095
09:26:49,520 --> 09:26:50,480
they are

14096
09:26:50,480 --> 09:26:53,120
you can declare an array of characters

14097
09:26:53,120 --> 09:26:55,276
just like any other array so here we

14098
09:26:55,276 --> 09:26:56,400
have

14099
09:26:56,400 --> 09:26:58,640
an array called message it stores

14100
09:26:58,640 --> 09:27:01,360
elements of type character the size is

14101
09:27:01,360 --> 09:27:04,240
five and we initialize it with a bunch

14102
09:27:04,240 --> 09:27:05,520
of characters

14103
09:27:05,520 --> 09:27:07,756
if we want to print it out we can look

14104
09:27:07,756 --> 09:27:10,640
like we loop through any other array in

14105
09:27:10,640 --> 09:27:12,480
this case we're going to be using a

14106
09:27:12,480 --> 09:27:15,520
ranged base for loop we say for auto c

14107
09:27:15,520 --> 09:27:17,276
we pass the message and then we're going

14108
09:27:17,276 --> 09:27:19,596
to be printing each character in the

14109
09:27:19,596 --> 09:27:21,680
message and if we do this we're going to

14110
09:27:21,680 --> 09:27:24,000
see hello printed out on the console we

14111
09:27:24,000 --> 09:27:27,040
can also modify elements in our array

14112
09:27:27,040 --> 09:27:29,200
for example we can say message1 and

14113
09:27:29,200 --> 09:27:31,596
change the e here to an a

14114
09:27:31,596 --> 09:27:33,840
and if we print out we should see hello

14115
09:27:33,840 --> 09:27:36,000
printed out on the console nothing

14116
09:27:36,000 --> 09:27:38,880
really special so far the cool thing you

14117
09:27:38,880 --> 09:27:41,596
can do with character arrays

14118
09:27:41,596 --> 09:27:43,276
is that you can print them to the

14119
09:27:43,276 --> 09:27:45,596
console directly without even doing the

14120
09:27:45,596 --> 09:27:47,596
loop you can do something like this you

14121
09:27:47,596 --> 09:27:50,160
can do sddc out you say whatever you

14122
09:27:50,160 --> 09:27:52,240
want to do in quotes here and you're

14123
09:27:52,240 --> 09:27:54,640
going to print the message but sometimes

14124
09:27:54,640 --> 09:27:57,596
this one to do what you expect because

14125
09:27:57,596 --> 09:28:01,276
only proper c strings can be printed on

14126
09:28:01,276 --> 09:28:04,560
the console and what makes up a proper c

14127
09:28:04,560 --> 09:28:07,840
string a proper c string has this thing

14128
09:28:07,840 --> 09:28:10,480
you see on the end here this backslash

14129
09:28:10,480 --> 09:28:11,436
zero

14130
09:28:11,436 --> 09:28:14,400
is called a null termination string and

14131
09:28:14,400 --> 09:28:16,480
it is what is going to tell c plus plus

14132
09:28:16,480 --> 09:28:19,040
that we have hit the end of the string

14133
09:28:19,040 --> 09:28:21,276
and we are going to stop printing it if

14134
09:28:21,276 --> 09:28:24,240
we are printing with things like stdcl

14135
09:28:24,240 --> 09:28:26,800
so this is really important to be in

14136
09:28:26,800 --> 09:28:29,360
your strength if it's not there it may

14137
09:28:29,360 --> 09:28:31,520
work but sometimes it's also going to

14138
09:28:31,520 --> 09:28:34,240
print some garbage characters after this

14139
09:28:34,240 --> 09:28:37,596
because what tells sddc out that we have

14140
09:28:37,596 --> 09:28:39,840
reached the end of the string is this

14141
09:28:39,840 --> 09:28:42,320
backslash zero here if it's not there

14142
09:28:42,320 --> 09:28:44,240
it's going to keep printing until it

14143
09:28:44,240 --> 09:28:46,480
sees one and then you're going to

14144
09:28:46,480 --> 09:28:48,720
probably have some garbage characters

14145
09:28:48,720 --> 09:28:51,120
added to your string and that's not what

14146
09:28:51,120 --> 09:28:53,040
you want so to have your strengths

14147
09:28:53,040 --> 09:28:56,080
printed out correctly be sure to have in

14148
09:28:56,080 --> 09:28:58,720
this null termination character here and

14149
09:28:58,720 --> 09:29:00,400
if we print it out we're going to get it

14150
09:29:00,400 --> 09:29:02,000
and we're going to see the size printed

14151
09:29:02,000 --> 09:29:05,120
out properly if we do things like this

14152
09:29:05,120 --> 09:29:07,840
but it is possible to get to this auto

14153
09:29:07,840 --> 09:29:10,000
field for us if you look here we have a

14154
09:29:10,000 --> 09:29:12,960
character array called message2 inside

14155
09:29:12,960 --> 09:29:15,680
we have said that we need six elements

14156
09:29:15,680 --> 09:29:18,400
and we say hello so we have one two

14157
09:29:18,400 --> 09:29:20,880
three four five elements and the

14158
09:29:20,880 --> 09:29:24,000
elements we don't initialize properly is

14159
09:29:24,000 --> 09:29:26,640
going to be initialized with a zero

14160
09:29:26,640 --> 09:29:28,960
version of a character and that happens

14161
09:29:28,960 --> 09:29:31,756
to be the null terminator of the null

14162
09:29:31,756 --> 09:29:34,320
termination character so this is going

14163
09:29:34,320 --> 09:29:36,000
to print correctly and we're going to

14164
09:29:36,000 --> 09:29:37,596
have the

14165
09:29:37,596 --> 09:29:40,720
backslash n appended to this for us by

14166
09:29:40,720 --> 09:29:42,960
the compiler but be sure you understand

14167
09:29:42,960 --> 09:29:45,756
the difference between this and this

14168
09:29:45,756 --> 09:29:48,240
here we have specified the size to be a

14169
09:29:48,240 --> 09:29:50,960
5 and we are putting in five elements so

14170
09:29:50,960 --> 09:29:53,360
we have no null character appended to

14171
09:29:53,360 --> 09:29:55,596
this string but here we have said that

14172
09:29:55,596 --> 09:29:58,400
we can put in six elements and we have

14173
09:29:58,400 --> 09:30:01,680
only put five and the compiler is going

14174
09:30:01,680 --> 09:30:05,120
to autofill then the null terminating

14175
09:30:05,120 --> 09:30:07,200
character these two things are different

14176
09:30:07,200 --> 09:30:08,560
and make sure you understand the

14177
09:30:08,560 --> 09:30:11,040
difference okay so now take a look at

14178
09:30:11,040 --> 09:30:13,436
what we have here we have a strand we

14179
09:30:13,436 --> 09:30:15,916
didn't specify the size and we just

14180
09:30:15,916 --> 09:30:18,640
initialize it with hello someone might

14181
09:30:18,640 --> 09:30:20,640
think ah this is also going to autofill

14182
09:30:20,640 --> 09:30:23,040
but it's not because the compiler is

14183
09:30:23,040 --> 09:30:25,756
going to deduce the size of this array

14184
09:30:25,756 --> 09:30:28,240
using what you initialize it with and

14185
09:30:28,240 --> 09:30:30,560
you didn't put in a null character so

14186
09:30:30,560 --> 09:30:32,080
it's not going to be accounted for

14187
09:30:32,080 --> 09:30:34,240
you're only going to have this here and

14188
09:30:34,240 --> 09:30:36,480
if you print this out you may get

14189
09:30:36,480 --> 09:30:38,560
garbage characters appended to your

14190
09:30:38,560 --> 09:30:40,800
string here so be careful but it is

14191
09:30:40,800 --> 09:30:44,000
possible to do literal c strings and

14192
09:30:44,000 --> 09:30:47,040
only say hello like this in quotes and

14193
09:30:47,040 --> 09:30:49,276
you're going to get the null terminating

14194
09:30:49,276 --> 09:30:52,480
character appended to your string here

14195
09:30:52,480 --> 09:30:54,320
so if we print this this is going to

14196
09:30:54,320 --> 09:30:56,720
pretty nicely and this is the

14197
09:30:56,720 --> 09:30:58,960
recommended way to initialize your

14198
09:30:58,960 --> 09:31:01,680
character arrays if you want to put in

14199
09:31:01,680 --> 09:31:04,880
string data like this you have to use

14200
09:31:04,880 --> 09:31:06,960
double quotes and the cool thing about

14201
09:31:06,960 --> 09:31:09,360
this is that you can even put in

14202
09:31:09,360 --> 09:31:11,520
spaces between words like this it is

14203
09:31:11,520 --> 09:31:13,916
going to work this really looks like how

14204
09:31:13,916 --> 09:31:16,640
you would like to type text and store

14205
09:31:16,640 --> 09:31:19,596
that in your character arrays and we're

14206
09:31:19,596 --> 09:31:21,360
going to be using this a lot in the

14207
09:31:21,360 --> 09:31:23,120
course again i want to bring to your

14208
09:31:23,120 --> 09:31:25,520
attention that character arrays are

14209
09:31:25,520 --> 09:31:26,640
special

14210
09:31:26,640 --> 09:31:29,276
in that you can directly print them on

14211
09:31:29,276 --> 09:31:30,480
the console

14212
09:31:30,480 --> 09:31:32,240
like we are doing here you see this is a

14213
09:31:32,240 --> 09:31:35,436
character array and we are saying stdc

14214
09:31:35,436 --> 09:31:38,080
out message for you can't do this with

14215
09:31:38,080 --> 09:31:40,880
other arrays and this is really all i

14216
09:31:40,880 --> 09:31:43,840
had to share about character arrays so

14217
09:31:43,840 --> 09:31:45,840
what we're going to do next is head to

14218
09:31:45,840 --> 09:31:48,160
visual studio code and play with us okay

14219
09:31:48,160 --> 09:31:51,276
here we are in our working directory the

14220
09:31:51,276 --> 09:31:54,400
current project is arrays of characters

14221
09:31:54,400 --> 09:31:57,360
we're going to grab our template project

14222
09:31:57,360 --> 09:31:59,276
and we're going to copy the files

14223
09:31:59,276 --> 09:32:01,916
bring them in here

14224
09:32:01,916 --> 09:32:04,720
and we are going to open our folder

14225
09:32:04,720 --> 09:32:06,880
we're going to open the main cpp file

14226
09:32:06,880 --> 09:32:08,560
and we're going to get rid of what we

14227
09:32:08,560 --> 09:32:10,640
don't need here let's put in some

14228
09:32:10,640 --> 09:32:12,480
startup code so that we can start

14229
09:32:12,480 --> 09:32:14,400
playing with this without typing this

14230
09:32:14,400 --> 09:32:16,720
too much so we're going to declare an

14231
09:32:16,720 --> 09:32:18,960
array of characters it's going to be

14232
09:32:18,960 --> 09:32:20,880
called message the size is going to be

14233
09:32:20,880 --> 09:32:22,800
five and we're going to fill it with

14234
09:32:22,800 --> 09:32:25,040
characters like this so if we do this we

14235
09:32:25,040 --> 09:32:27,756
might want to print it like we print any

14236
09:32:27,756 --> 09:32:30,400
other array we're going to use loops and

14237
09:32:30,400 --> 09:32:32,720
in this case we chose to use

14238
09:32:32,720 --> 09:32:35,200
a range base for loop so we take a toast

14239
09:32:35,200 --> 09:32:37,120
c c for character

14240
09:32:37,120 --> 09:32:39,276
in message and we're going to print out

14241
09:32:39,276 --> 09:32:41,276
each character notice that we're not

14242
09:32:41,276 --> 09:32:44,880
adding std endl here because we want the

14243
09:32:44,880 --> 09:32:47,360
characters printed close to each other

14244
09:32:47,360 --> 09:32:49,916
so that we can read this easily and

14245
09:32:49,916 --> 09:32:51,840
after this we will need to go to the

14246
09:32:51,840 --> 09:32:53,520
next line so that the next thing we

14247
09:32:53,520 --> 09:32:55,840
print doesn't disturb us so we're going

14248
09:32:55,840 --> 09:32:59,916
to say sddc out std endl and if we do

14249
09:32:59,916 --> 09:33:01,916
this we're going to see hello printed

14250
09:33:01,916 --> 09:33:04,400
out on the console but we had to do too

14251
09:33:04,400 --> 09:33:07,040
much work to print something simple

14252
09:33:07,040 --> 09:33:09,360
like hello but let's do this we are

14253
09:33:09,360 --> 09:33:10,320
learning

14254
09:33:10,320 --> 09:33:12,800
so we're going to bring up our terminal

14255
09:33:12,800 --> 09:33:15,360
and we're going to build with gcc let's

14256
09:33:15,360 --> 09:33:16,960
do that

14257
09:33:16,960 --> 09:33:19,040
the world is going to go through and

14258
09:33:19,040 --> 09:33:20,400
we're going to clear

14259
09:33:20,400 --> 09:33:22,480
and run rooster you're going to see that

14260
09:33:22,480 --> 09:33:24,240
it's going to say message is hello and

14261
09:33:24,240 --> 09:33:26,080
this is what we expect and this is

14262
09:33:26,080 --> 09:33:28,480
really how you would declare an array of

14263
09:33:28,480 --> 09:33:30,560
characters and initialize it with

14264
09:33:30,560 --> 09:33:32,480
whatever it is you want to initialize it

14265
09:33:32,480 --> 09:33:34,720
with but you notice that it's really not

14266
09:33:34,720 --> 09:33:37,916
convenient to put data in here if you

14267
09:33:37,916 --> 09:33:40,960
want to store a message for example for

14268
09:33:40,960 --> 09:33:43,840
someone you don't want to do this thing

14269
09:33:43,840 --> 09:33:45,520
you see here it's really ugly it's

14270
09:33:45,520 --> 09:33:48,000
convenient and nobody would definitely

14271
09:33:48,000 --> 09:33:50,880
use your program if you required your

14272
09:33:50,880 --> 09:33:53,200
users to type things like this so we

14273
09:33:53,200 --> 09:33:55,596
need to change this and we will but

14274
09:33:55,596 --> 09:33:57,756
before we get there let's also see that

14275
09:33:57,756 --> 09:34:00,640
we can change characters in our array so

14276
09:34:00,640 --> 09:34:03,520
if you look here this e here is at index

14277
09:34:03,520 --> 09:34:07,120
two so what we can say is a message and

14278
09:34:07,120 --> 09:34:10,080
uh we're going to target the element on

14279
09:34:10,080 --> 09:34:11,040
index

14280
09:34:11,040 --> 09:34:13,680
two oh it's index one

14281
09:34:13,680 --> 09:34:16,240
let's use that so this is index zero the

14282
09:34:16,240 --> 09:34:19,360
h and the e is at index one let's make

14283
09:34:19,360 --> 09:34:21,520
sure we get this straight and we're

14284
09:34:21,520 --> 09:34:23,596
going to store in an a

14285
09:34:23,596 --> 09:34:27,120
in quotes remember characters are

14286
09:34:27,120 --> 09:34:29,840
surrounded by single quotes like this

14287
09:34:29,840 --> 09:34:32,720
once we do this and we try to print the

14288
09:34:32,720 --> 09:34:35,680
array out again using our

14289
09:34:35,680 --> 09:34:37,520
technique here we're going to copy the

14290
09:34:37,520 --> 09:34:39,520
code and we're going to paste it down

14291
09:34:39,520 --> 09:34:40,320
here

14292
09:34:40,320 --> 09:34:42,800
just to do this simply

14293
09:34:42,800 --> 09:34:45,436
and if we do this we're going to see the

14294
09:34:45,436 --> 09:34:48,880
message printed out here to be hello

14295
09:34:48,880 --> 09:34:50,800
and the second message is going to be

14296
09:34:50,800 --> 09:34:53,040
hello with an a

14297
09:34:53,040 --> 09:34:56,160
because we changed the second element

14298
09:34:56,160 --> 09:34:58,800
to an a it's no longer an e so that's

14299
09:34:58,800 --> 09:35:00,960
what we expect we're going to run the

14300
09:35:00,960 --> 09:35:03,840
test to build with gcc and we're going

14301
09:35:03,840 --> 09:35:06,080
to bring this up and clear and we're

14302
09:35:06,080 --> 09:35:07,916
going to run rooster you see that we

14303
09:35:07,916 --> 09:35:11,120
have message hello and message hello and

14304
09:35:11,120 --> 09:35:13,596
we are able to print things successfully

14305
09:35:13,596 --> 09:35:16,000
this is really cool but we are doing too

14306
09:35:16,000 --> 09:35:18,800
much work really to print something on

14307
09:35:18,800 --> 09:35:20,640
the console and there should be an

14308
09:35:20,640 --> 09:35:23,276
easier way to do this and there is so

14309
09:35:23,276 --> 09:35:25,520
what we're going to do is comment this

14310
09:35:25,520 --> 09:35:28,080
out because we don't want noise output

14311
09:35:28,080 --> 09:35:30,240
in the console when we try to do

14312
09:35:30,240 --> 09:35:31,756
something else

14313
09:35:31,756 --> 09:35:34,160
so what we're going to do is comment out

14314
09:35:34,160 --> 09:35:35,840
all we've done so far we're going to

14315
09:35:35,840 --> 09:35:38,240
leave in our message here and we're

14316
09:35:38,240 --> 09:35:40,560
going to try and print it directly on

14317
09:35:40,560 --> 09:35:44,000
the console so we can say sddcl

14318
09:35:44,000 --> 09:35:46,160
and say message

14319
09:35:46,160 --> 09:35:48,720
and we're going to print out the message

14320
09:35:48,720 --> 09:35:51,520
and take a moment and look at this

14321
09:35:51,520 --> 09:35:54,480
and try to compile this it is going to

14322
09:35:54,480 --> 09:35:56,560
go through it is going to compile

14323
09:35:56,560 --> 09:35:58,720
because c plus plus

14324
09:35:58,720 --> 09:36:01,756
supports printing character arrays like

14325
09:36:01,756 --> 09:36:02,560
this

14326
09:36:02,560 --> 09:36:03,916
but uh

14327
09:36:03,916 --> 09:36:05,756
in most times this is not going to do

14328
09:36:05,756 --> 09:36:09,120
what you expect let's try and run this

14329
09:36:09,120 --> 09:36:11,360
and see what we get

14330
09:36:11,360 --> 09:36:13,200
we're going to run rooster

14331
09:36:13,200 --> 09:36:14,800
and you see that

14332
09:36:14,800 --> 09:36:17,276
we're lucky to get something that really

14333
09:36:17,276 --> 09:36:19,120
isn't what we expect

14334
09:36:19,120 --> 09:36:21,360
it's pretty hello and you see that we

14335
09:36:21,360 --> 09:36:23,520
have a bunch of other things and the

14336
09:36:23,520 --> 09:36:25,840
reason is what we have discussed in

14337
09:36:25,840 --> 09:36:28,880
these slides for character arrays like

14338
09:36:28,880 --> 09:36:31,436
this to be printed out properly

14339
09:36:31,436 --> 09:36:34,400
on the console they need to be null

14340
09:36:34,400 --> 09:36:36,880
terminated in other words they need to

14341
09:36:36,880 --> 09:36:39,360
have the null character which is a

14342
09:36:39,360 --> 09:36:42,240
backslash zero appended to the string

14343
09:36:42,240 --> 09:36:45,680
for sddc out to know that it has reached

14344
09:36:45,680 --> 09:36:47,756
the end of the string so this is what

14345
09:36:47,756 --> 09:36:51,276
makes your character strings legal

14346
09:36:51,276 --> 09:36:52,720
now you see that we are getting a

14347
09:36:52,720 --> 09:36:55,360
compiler error because we have overflown

14348
09:36:55,360 --> 09:36:57,840
the size of the array i think that's the

14349
09:36:57,840 --> 09:36:59,840
message too many initializer values and

14350
09:36:59,840 --> 09:37:02,240
this is exactly what we have done

14351
09:37:02,240 --> 09:37:05,120
now we can try and change this guy to a

14352
09:37:05,120 --> 09:37:07,840
six to say that we have six elements in

14353
09:37:07,840 --> 09:37:08,640
here

14354
09:37:08,640 --> 09:37:11,120
this wiggly line should go away and if

14355
09:37:11,120 --> 09:37:13,276
we try to build and run

14356
09:37:13,276 --> 09:37:15,840
we're going to build with gcc

14357
09:37:15,840 --> 09:37:18,480
let's bring this up a little bit and

14358
09:37:18,480 --> 09:37:20,080
we're going to clear

14359
09:37:20,080 --> 09:37:22,400
and run rooster now

14360
09:37:22,400 --> 09:37:24,000
and you see that now we have hello

14361
09:37:24,000 --> 09:37:26,720
printed out correctly if we turn this

14362
09:37:26,720 --> 09:37:29,360
back to five elements

14363
09:37:29,360 --> 09:37:33,120
and take out the null terminator

14364
09:37:33,120 --> 09:37:35,276
we're going to try and build again and

14365
09:37:35,276 --> 09:37:37,840
we're going to clear and run rooster

14366
09:37:37,840 --> 09:37:39,120
you're going to see that we get the

14367
09:37:39,120 --> 09:37:41,756
garbage back so for your strings to be

14368
09:37:41,756 --> 09:37:44,560
printed out correctly they need to be

14369
09:37:44,560 --> 09:37:48,000
now terminated that's why it is not safe

14370
09:37:48,000 --> 09:37:50,640
to prank something like this

14371
09:37:50,640 --> 09:37:53,596
when your character array is not now

14372
09:37:53,596 --> 09:37:55,276
terminated i really want you to

14373
09:37:55,276 --> 09:37:58,000
understand this so in c plus plus we

14374
09:37:58,000 --> 09:38:00,960
have a proper name for these strings

14375
09:38:00,960 --> 09:38:03,436
that are null terminated a null

14376
09:38:03,436 --> 09:38:05,756
terminated string is called the c string

14377
09:38:05,756 --> 09:38:07,916
because these things come from the c

14378
09:38:07,916 --> 09:38:09,756
programming language okay and we're

14379
09:38:09,756 --> 09:38:11,916
going to see a few ways we can set up c

14380
09:38:11,916 --> 09:38:15,360
strings now and the first one is to say

14381
09:38:15,360 --> 09:38:18,480
car we can call this message one

14382
09:38:18,480 --> 09:38:20,080
and it's going to be an array of

14383
09:38:20,080 --> 09:38:22,240
characters and we're going to initialize

14384
09:38:22,240 --> 09:38:24,400
this with hello let's copy this because

14385
09:38:24,400 --> 09:38:26,720
i don't want to type all these

14386
09:38:26,720 --> 09:38:29,756
things here so let's copy this

14387
09:38:29,756 --> 09:38:31,916
and initialize this properly notice that

14388
09:38:31,916 --> 09:38:33,916
we didn't specify the size so the

14389
09:38:33,916 --> 09:38:36,160
compiler is going to get the size from

14390
09:38:36,160 --> 09:38:38,640
however many elements we put in here and

14391
09:38:38,640 --> 09:38:41,120
we're going to put in our null

14392
09:38:41,120 --> 09:38:43,360
terminator here and if we print this

14393
09:38:43,360 --> 09:38:46,160
this is going to work and we are going

14394
09:38:46,160 --> 09:38:48,240
to comment this out and i'm going to say

14395
09:38:48,240 --> 09:38:50,880
that this will give you garbage okay if

14396
09:38:50,880 --> 09:38:52,160
we come down here we're going to see

14397
09:38:52,160 --> 09:38:55,040
that we have a car array it is called

14398
09:38:55,040 --> 09:38:57,916
message1 and we have initialized it with

14399
09:38:57,916 --> 09:39:00,720
data we have hello and we have a null

14400
09:39:00,720 --> 09:39:03,120
terminator here and the compiler is

14401
09:39:03,120 --> 09:39:04,800
going to deduce the size so this is

14402
09:39:04,800 --> 09:39:07,200
going to be a proper c string and we

14403
09:39:07,200 --> 09:39:09,200
will print it correctly

14404
09:39:09,200 --> 09:39:11,756
let's try and weld this the board is

14405
09:39:11,756 --> 09:39:14,160
going to go through if we clear and run

14406
09:39:14,160 --> 09:39:15,680
rooster we're going to get our message

14407
09:39:15,680 --> 09:39:18,640
here and this is one way we can set up a

14408
09:39:18,640 --> 09:39:21,756
proper c string the second way is to

14409
09:39:21,756 --> 09:39:25,680
actually not putting the null terminator

14410
09:39:25,680 --> 09:39:28,560
but let the compiler add that in for you

14411
09:39:28,560 --> 09:39:30,160
and the way we can do that we can say

14412
09:39:30,160 --> 09:39:33,200
car message to and we're going to say

14413
09:39:33,200 --> 09:39:37,276
this array is of size 6. let's say that

14414
09:39:37,276 --> 09:39:39,120
we're going to put in a six

14415
09:39:39,120 --> 09:39:41,276
and a fix how we end things here we're

14416
09:39:41,276 --> 09:39:43,276
going to put in our code

14417
09:39:43,276 --> 09:39:46,080
and end this with a semicolon now what

14418
09:39:46,080 --> 09:39:48,000
is going to happen is the compiler is

14419
09:39:48,000 --> 09:39:50,160
going to see that this array is of size

14420
09:39:50,160 --> 09:39:53,200
6 but we are putting in five elements so

14421
09:39:53,200 --> 09:39:55,520
the remaining slots are going to be auto

14422
09:39:55,520 --> 09:39:58,480
filled and it is going to be using

14423
09:39:58,480 --> 09:40:01,276
null terminators to autofill this then

14424
09:40:01,276 --> 09:40:03,520
if we try to print the size here we're

14425
09:40:03,520 --> 09:40:05,840
going to get a

14426
09:40:05,840 --> 09:40:09,276
because the null terminator is added in

14427
09:40:09,276 --> 09:40:12,240
by the compiler let's try and print the

14428
09:40:12,240 --> 09:40:14,960
sizes here actually so that you can see

14429
09:40:14,960 --> 09:40:17,520
these things so we're going to say size

14430
09:40:17,520 --> 09:40:19,436
and we're going to say that size of

14431
09:40:19,436 --> 09:40:21,756
message one and we're going to put in a

14432
09:40:21,756 --> 09:40:24,720
new line character and this should be

14433
09:40:24,720 --> 09:40:27,200
what we expect so what we're going to do

14434
09:40:27,200 --> 09:40:28,960
we're going to copy this

14435
09:40:28,960 --> 09:40:30,960
and i put that down here because we're

14436
09:40:30,960 --> 09:40:32,480
going to be doing the same thing for

14437
09:40:32,480 --> 09:40:34,320
message to so we're going to say message

14438
09:40:34,320 --> 09:40:36,320
to let's select this

14439
09:40:36,320 --> 09:40:38,800
and i say size of message to and do

14440
09:40:38,800 --> 09:40:40,640
signs of message too so what we're going

14441
09:40:40,640 --> 09:40:43,200
to see is a message 1 and message 2

14442
09:40:43,200 --> 09:40:45,680
printing out and we expect to see a size

14443
09:40:45,680 --> 09:40:48,400
of 6 because both of these guys have six

14444
09:40:48,400 --> 09:40:51,200
elements inside so we're going to run

14445
09:40:51,200 --> 09:40:54,240
the task to build with gcc

14446
09:40:54,240 --> 09:40:56,800
and bring this up clear

14447
09:40:56,800 --> 09:40:58,080
rooster

14448
09:40:58,080 --> 09:41:00,720
and this is exactly what we expect

14449
09:41:00,720 --> 09:41:03,436
message one is hello the size is six

14450
09:41:03,436 --> 09:41:05,840
message two is hello and the size is six

14451
09:41:05,840 --> 09:41:07,916
and these are a few ways you can declare

14452
09:41:07,916 --> 09:41:10,160
your character arrays and initialize

14453
09:41:10,160 --> 09:41:12,960
them with proper data that is going to

14454
09:41:12,960 --> 09:41:16,400
print correctly with stdc out make sure

14455
09:41:16,400 --> 09:41:18,960
you don't do something like we did here

14456
09:41:18,960 --> 09:41:21,840
by printing message here because it is

14457
09:41:21,840 --> 09:41:24,160
not null terminated this is going to

14458
09:41:24,160 --> 09:41:27,120
give you a lot of problems again i want

14459
09:41:27,120 --> 09:41:29,200
to make it really clear

14460
09:41:29,200 --> 09:41:32,800
that message three here is not a proper

14461
09:41:32,800 --> 09:41:35,596
c string because the compiler is going

14462
09:41:35,596 --> 09:41:37,756
to deduce however many elements we have

14463
09:41:37,756 --> 09:41:40,400
in here and this thing is going to be of

14464
09:41:40,400 --> 09:41:42,240
size five

14465
09:41:42,240 --> 09:41:43,840
and we're not going to have a null

14466
09:41:43,840 --> 09:41:45,680
terminator and if we print it out we're

14467
09:41:45,680 --> 09:41:47,756
going to get some garbage so let's try

14468
09:41:47,756 --> 09:41:50,240
and copy this so that we are consistent

14469
09:41:50,240 --> 09:41:51,040
with

14470
09:41:51,040 --> 09:41:53,916
what we've done above here and if we

14471
09:41:53,916 --> 09:41:56,640
compile with gcc

14472
09:41:56,640 --> 09:41:58,960
we are going to compile successfully but

14473
09:41:58,960 --> 09:42:01,916
we may get weird things if we print out

14474
09:42:01,916 --> 09:42:04,320
message three like we do here and you're

14475
09:42:04,320 --> 09:42:06,160
going to see that the size is five

14476
09:42:06,160 --> 09:42:09,040
because we only have five elements in

14477
09:42:09,040 --> 09:42:13,200
here so let's clear and run rooster and

14478
09:42:13,200 --> 09:42:14,880
you're going to see that

14479
09:42:14,880 --> 09:42:17,120
we have hello for message one we have

14480
09:42:17,120 --> 09:42:19,520
hello for message two but for message

14481
09:42:19,520 --> 09:42:22,560
three we have things we don't expect

14482
09:42:22,560 --> 09:42:24,720
because it's going to keep printing and

14483
09:42:24,720 --> 09:42:26,640
it's going to go overbound and it's

14484
09:42:26,640 --> 09:42:29,520
going to stop when it hits the first

14485
09:42:29,520 --> 09:42:32,320
no terminating character

14486
09:42:32,320 --> 09:42:34,800
like what we have in here okay so this

14487
09:42:34,800 --> 09:42:37,436
is not safe don't do it make sure your

14488
09:42:37,436 --> 09:42:39,276
strengths are null

14489
09:42:39,276 --> 09:42:42,320
it if you intend to print them with sddc

14490
09:42:42,320 --> 09:42:44,800
out like this okay so working with

14491
09:42:44,800 --> 09:42:46,800
character arrays like this to print

14492
09:42:46,800 --> 09:42:48,640
messages and do all kinds of crazy

14493
09:42:48,640 --> 09:42:51,120
things is nice but it really isn't

14494
09:42:51,120 --> 09:42:53,436
convenient as i said before

14495
09:42:53,436 --> 09:42:55,840
you wouldn't expect your users to type

14496
09:42:55,840 --> 09:42:58,720
characters like this by surrounding them

14497
09:42:58,720 --> 09:43:01,436
with single quotes this is really ugly

14498
09:43:01,436 --> 09:43:04,480
and it is painful to do if you want to

14499
09:43:04,480 --> 09:43:07,436
do some productive work so c plus plus

14500
09:43:07,436 --> 09:43:10,240
allows you to use what we call string

14501
09:43:10,240 --> 09:43:11,916
literals and we're going to see an

14502
09:43:11,916 --> 09:43:13,436
example of that

14503
09:43:13,436 --> 09:43:15,040
down below we're going to say string

14504
09:43:15,040 --> 09:43:18,400
literals and uh what we can do is car

14505
09:43:18,400 --> 09:43:21,756
message for it's going to be an array as

14506
09:43:21,756 --> 09:43:22,880
usual

14507
09:43:22,880 --> 09:43:25,200
and we can initialize it

14508
09:43:25,200 --> 09:43:27,916
with a string that is surrounded by

14509
09:43:27,916 --> 09:43:30,400
double quotes and what this is going to

14510
09:43:30,400 --> 09:43:32,240
tell c plus plus

14511
09:43:32,240 --> 09:43:35,120
is you know take these things break it

14512
09:43:35,120 --> 09:43:38,400
into characters and store this in this

14513
09:43:38,400 --> 09:43:41,840
array here and make sure you properly

14514
09:43:41,840 --> 09:43:44,880
now terminate this string here so if we

14515
09:43:44,880 --> 09:43:47,520
print the size of message four we're not

14516
09:43:47,520 --> 09:43:50,000
going to get five we're going to get six

14517
09:43:50,000 --> 09:43:52,000
because c plus plus is going to see

14518
09:43:52,000 --> 09:43:54,320
these double quotes and know that we

14519
09:43:54,320 --> 09:43:56,320
intend for these things to be properly

14520
09:43:56,320 --> 09:43:58,880
null terminated and it's going to add a

14521
09:43:58,880 --> 09:44:02,400
null terminator so let's try and print

14522
09:44:02,400 --> 09:44:05,200
this out so that we really are sure and

14523
09:44:05,200 --> 09:44:08,160
we're going to weld this with gcc as we

14524
09:44:08,160 --> 09:44:09,360
always do

14525
09:44:09,360 --> 09:44:11,360
the world is going to go through let's

14526
09:44:11,360 --> 09:44:13,520
go up and clear and we're going to run

14527
09:44:13,520 --> 09:44:14,640
rooster

14528
09:44:14,640 --> 09:44:17,200
and you see that message 4 is hello

14529
09:44:17,200 --> 09:44:20,320
and the size is indeed a sex

14530
09:44:20,320 --> 09:44:22,960
so this is one way we have to do things

14531
09:44:22,960 --> 09:44:25,200
and we can even put spaces

14532
09:44:25,200 --> 09:44:27,916
and do all kinds of crazy things and

14533
09:44:27,916 --> 09:44:30,560
it's really cool and if we try to build

14534
09:44:30,560 --> 09:44:32,320
this we're going to get the proper

14535
09:44:32,320 --> 09:44:34,400
message printed out you see the world is

14536
09:44:34,400 --> 09:44:38,080
good if we clear and run rooster we're

14537
09:44:38,080 --> 09:44:40,240
going to see hello world how are you

14538
09:44:40,240 --> 09:44:42,720
doing and this is really cool so from

14539
09:44:42,720 --> 09:44:45,680
now on if we need to store a string in

14540
09:44:45,680 --> 09:44:47,756
our program this is how we're going to

14541
09:44:47,756 --> 09:44:49,520
do it because this is much more

14542
09:44:49,520 --> 09:44:52,160
civilized and it is how you would really

14543
09:44:52,160 --> 09:44:54,400
like to type characters in your program

14544
09:44:54,400 --> 09:44:57,276
i have said that character arrays are

14545
09:44:57,276 --> 09:44:59,596
really special because you can directly

14546
09:44:59,596 --> 09:45:03,680
print them out with stdc out like this i

14547
09:45:03,680 --> 09:45:05,360
want to prove this so we're going to try

14548
09:45:05,360 --> 09:45:07,436
and declare another array so we're going

14549
09:45:07,436 --> 09:45:09,756
to call this numbers

14550
09:45:09,756 --> 09:45:11,596
and we're going to make this an array

14551
09:45:11,596 --> 09:45:14,080
and we're going to initialize with one

14552
09:45:14,080 --> 09:45:17,596
two three four five this is going to do

14553
09:45:17,596 --> 09:45:19,596
and we're going to put our closing

14554
09:45:19,596 --> 09:45:21,436
semicolon and we're going to try and

14555
09:45:21,436 --> 09:45:24,880
print this out i'm going to say std

14556
09:45:24,880 --> 09:45:27,120
see out and say numbers

14557
09:45:27,120 --> 09:45:29,360
let's see what we get

14558
09:45:29,360 --> 09:45:31,276
let's try and compile this and see what

14559
09:45:31,276 --> 09:45:33,680
we get it is not actually going to give

14560
09:45:33,680 --> 09:45:36,160
us a compiler error but it's not going

14561
09:45:36,160 --> 09:45:38,080
to print what we expect and let's put a

14562
09:45:38,080 --> 09:45:39,840
message here so that we know that it is

14563
09:45:39,840 --> 09:45:42,400
this thing we are seeing here so we're

14564
09:45:42,400 --> 09:45:44,560
going to say numbers and we're going to

14565
09:45:44,560 --> 09:45:47,120
put a column here

14566
09:45:47,120 --> 09:45:49,756
and we're going to weld this

14567
09:45:49,756 --> 09:45:52,480
with gcc

14568
09:45:52,480 --> 09:45:54,880
and we're going to clear

14569
09:45:54,880 --> 09:45:57,916
and if a run rooster look out for the

14570
09:45:57,916 --> 09:46:00,240
output that says numbers here so let's

14571
09:46:00,240 --> 09:46:02,560
run rooster it's not a one two three

14572
09:46:02,560 --> 09:46:05,040
four five it's something we don't really

14573
09:46:05,040 --> 09:46:05,840
know

14574
09:46:05,840 --> 09:46:08,000
and we will get to understand what is

14575
09:46:08,000 --> 09:46:09,436
happening here

14576
09:46:09,436 --> 09:46:12,160
in the next chapter for now note that

14577
09:46:12,160 --> 09:46:14,960
you can't directly print arrays other

14578
09:46:14,960 --> 09:46:17,520
than those of characters if you try to

14579
09:46:17,520 --> 09:46:19,120
do that you're going to get weird

14580
09:46:19,120 --> 09:46:21,120
numbers printed out and we're going to

14581
09:46:21,120 --> 09:46:23,276
understand why this is

14582
09:46:23,276 --> 09:46:25,756
the next chapter so let's say that here

14583
09:46:25,756 --> 09:46:27,596
okay this is really all we set out to do

14584
09:46:27,596 --> 09:46:29,360
in this lecture i hope you found it

14585
09:46:29,360 --> 09:46:32,240
interesting character arrays have a few

14586
09:46:32,240 --> 09:46:34,480
things you need to be careful about and

14587
09:46:34,480 --> 09:46:37,120
we try to cover those in this lecture we

14588
09:46:37,120 --> 09:46:39,040
are going to stop here in this lecture

14589
09:46:39,040 --> 09:46:40,880
and the next one we're going to try and

14590
09:46:40,880 --> 09:46:43,680
look at array bounds

14591
09:46:43,680 --> 09:46:46,000
go ahead and finish up here and meet me

14592
09:46:46,000 --> 09:46:48,320
there in this lecture we're going to

14593
09:46:48,320 --> 09:46:50,960
look at what could happen if you try to

14594
09:46:50,960 --> 09:46:53,680
manipulate data out of the bounds of

14595
09:46:53,680 --> 09:46:56,480
your array we have seen that when you

14596
09:46:56,480 --> 09:46:59,680
allocate space for an array the computer

14597
09:46:59,680 --> 09:47:01,520
is going to give you a bunch of memory

14598
09:47:01,520 --> 09:47:03,916
locations you can use to store your data

14599
09:47:03,916 --> 09:47:06,240
and it's going to be of the size that

14600
09:47:06,240 --> 09:47:08,640
you have specified or that is deduced by

14601
09:47:08,640 --> 09:47:11,360
the compiler so here is an example of an

14602
09:47:11,360 --> 09:47:13,360
array that is going to store seven

14603
09:47:13,360 --> 09:47:16,000
elements and we have green slots for

14604
09:47:16,000 --> 09:47:18,000
these elements and these are the

14605
09:47:18,000 --> 09:47:21,200
locations we are allowed to manipulate

14606
09:47:21,200 --> 09:47:23,916
in our c plus plus program if we try to

14607
09:47:23,916 --> 09:47:26,160
go overbound for example if we try to

14608
09:47:26,160 --> 09:47:29,520
modify something before our array or

14609
09:47:29,520 --> 09:47:31,520
after our array

14610
09:47:31,520 --> 09:47:33,360
it might be a memory location that is

14611
09:47:33,360 --> 09:47:35,840
owned by another program it might be a

14612
09:47:35,840 --> 09:47:38,000
memory location that is even being used

14613
09:47:38,000 --> 09:47:40,640
by the operating system so bad things

14614
09:47:40,640 --> 09:47:44,000
can really happen if you try to use data

14615
09:47:44,000 --> 09:47:47,200
that is outside the bounds of your array

14616
09:47:47,200 --> 09:47:49,120
let's try to look at a simple example

14617
09:47:49,120 --> 09:47:50,640
here here we have an array called

14618
09:47:50,640 --> 09:47:54,000
numbers we have 10 slots inside so we

14619
09:47:54,000 --> 09:47:57,520
are only allowed to modify the memory

14620
09:47:57,520 --> 09:48:00,400
locations for these 10 numbers and if we

14621
09:48:00,400 --> 09:48:03,120
try to access something outside the

14622
09:48:03,120 --> 09:48:05,520
bounds of this array something might

14623
09:48:05,520 --> 09:48:07,916
happen but some people say that c plus

14624
09:48:07,916 --> 09:48:10,480
plus is really funny because it should

14625
09:48:10,480 --> 09:48:12,320
be stopping you from doing something

14626
09:48:12,320 --> 09:48:14,480
like this but c plus plus allows you to

14627
09:48:14,480 --> 09:48:17,360
do this if you look at code here we have

14628
09:48:17,360 --> 09:48:20,240
an array we have 10 elements n so the

14629
09:48:20,240 --> 09:48:23,120
valid indexes we can really use are from

14630
09:48:23,120 --> 09:48:26,320
0 to 9. but if we try and access

14631
09:48:26,320 --> 09:48:29,200
something at index 12 the code is going

14632
09:48:29,200 --> 09:48:31,276
to compile and if we run it we're going

14633
09:48:31,276 --> 09:48:33,200
to get something printed out but that's

14634
09:48:33,200 --> 09:48:35,360
something this is going to give you

14635
09:48:35,360 --> 09:48:37,916
garbage data or you might be even trying

14636
09:48:37,916 --> 09:48:40,640
to read some restricted memory and your

14637
09:48:40,640 --> 09:48:42,240
program is going to terminate

14638
09:48:42,240 --> 09:48:44,720
immediately and we're going to say that

14639
09:48:44,720 --> 09:48:47,840
it has crashed if you try to write over

14640
09:48:47,840 --> 09:48:50,080
bounce the compiler is also going to

14641
09:48:50,080 --> 09:48:52,960
allow it but you don't own the memory so

14642
09:48:52,960 --> 09:48:55,040
other programs might come and change

14643
09:48:55,040 --> 09:48:57,360
that memory location and if you try to

14644
09:48:57,360 --> 09:48:58,960
read from it again you're not going to

14645
09:48:58,960 --> 09:49:00,960
get what you expect another thing that

14646
09:49:00,960 --> 09:49:03,436
could happen is that you try and modify

14647
09:49:03,436 --> 09:49:06,320
data that is owned by other programs and

14648
09:49:06,320 --> 09:49:09,596
you might imagine how bad that really is

14649
09:49:09,596 --> 09:49:12,800
so the message here is don't go over

14650
09:49:12,800 --> 09:49:14,800
your array balance and you're going to

14651
09:49:14,800 --> 09:49:17,596
be playing in the safe zone let's head

14652
09:49:17,596 --> 09:49:20,000
over to visual studio code and play with

14653
09:49:20,000 --> 09:49:22,720
us a little bit here we are in our

14654
09:49:22,720 --> 09:49:25,436
working directory the current project is

14655
09:49:25,436 --> 09:49:27,520
array balance we're going to grab the

14656
09:49:27,520 --> 09:49:29,436
template files

14657
09:49:29,436 --> 09:49:30,960
and we're going to

14658
09:49:30,960 --> 09:49:33,276
put them in place

14659
09:49:33,276 --> 09:49:34,640
and we're going to open this up in

14660
09:49:34,640 --> 09:49:36,640
visual studio code we are going to

14661
09:49:36,640 --> 09:49:40,240
declare an array and try to read beyond

14662
09:49:40,240 --> 09:49:43,436
the legal bounds of our array so let's

14663
09:49:43,436 --> 09:49:46,320
try and bring up a terminal here and we

14664
09:49:46,320 --> 09:49:48,800
are going to build this with gcc the

14665
09:49:48,800 --> 09:49:50,640
world is going to go through you're not

14666
09:49:50,640 --> 09:49:53,436
going to get a compiler error but if we

14667
09:49:53,436 --> 09:49:55,520
run this we can really get anything and

14668
09:49:55,520 --> 09:49:58,080
you see we have a number we don't really

14669
09:49:58,080 --> 09:50:01,040
know what it means and this means that

14670
09:50:01,040 --> 09:50:02,720
you have read

14671
09:50:02,720 --> 09:50:05,436
out of the legal bounds of your array

14672
09:50:05,436 --> 09:50:07,276
and c plus plus

14673
09:50:07,276 --> 09:50:09,756
allows you to do this and the reason

14674
09:50:09,756 --> 09:50:13,120
they do this is because they expect you

14675
09:50:13,120 --> 09:50:15,680
the developer to know what you're doing

14676
09:50:15,680 --> 09:50:17,840
when you try manipulating things like

14677
09:50:17,840 --> 09:50:20,640
ray and now you know this and be careful

14678
09:50:20,640 --> 09:50:22,560
when you are working with arrays like

14679
09:50:22,560 --> 09:50:25,040
this so don't go overbound that's the

14680
09:50:25,040 --> 09:50:28,480
message we may also try to modify data

14681
09:50:28,480 --> 09:50:31,680
beyond balance so let's go down and put

14682
09:50:31,680 --> 09:50:34,000
in the code to modify thanks and i have

14683
09:50:34,000 --> 09:50:36,960
put a clear message here as a comment to

14684
09:50:36,960 --> 09:50:38,560
let you know that this is really

14685
09:50:38,560 --> 09:50:40,800
something you should be very very

14686
09:50:40,800 --> 09:50:42,640
careful about so we're going to try and

14687
09:50:42,640 --> 09:50:44,880
change that number to 1000 and we're

14688
09:50:44,880 --> 09:50:46,400
going to try and print it out and see

14689
09:50:46,400 --> 09:50:49,520
what we get but this memory location at

14690
09:50:49,520 --> 09:50:51,040
index 12

14691
09:50:51,040 --> 09:50:53,596
is not something we own so other

14692
09:50:53,596 --> 09:50:55,916
programs might come and write to this

14693
09:50:55,916 --> 09:50:58,400
location and if we try to read from it

14694
09:50:58,400 --> 09:51:01,120
again we might not get what we put in

14695
09:51:01,120 --> 09:51:03,520
here even worse this memory location

14696
09:51:03,520 --> 09:51:06,240
might be owned by other programs and if

14697
09:51:06,240 --> 09:51:08,080
they read they're going to get what they

14698
09:51:08,080 --> 09:51:10,640
didn't put in they're going to get what

14699
09:51:10,640 --> 09:51:13,120
you put in and this is something bad we

14700
09:51:13,120 --> 09:51:15,436
might try and really go crazy with us

14701
09:51:15,436 --> 09:51:17,520
let's put in a really huge number and

14702
09:51:17,520 --> 09:51:19,680
see that we can do that

14703
09:51:19,680 --> 09:51:21,520
this is a good way to learn by the way

14704
09:51:21,520 --> 09:51:23,040
it's going to compile

14705
09:51:23,040 --> 09:51:25,596
and let's try and print what we have in

14706
09:51:25,596 --> 09:51:28,480
there and we're going to say

14707
09:51:28,480 --> 09:51:30,560
this location here

14708
09:51:30,560 --> 09:51:32,720
and that's what we're going to say here

14709
09:51:32,720 --> 09:51:34,880
and we're going to build again the world

14710
09:51:34,880 --> 09:51:36,480
is going to go through you see that we

14711
09:51:36,480 --> 09:51:39,040
are doing something really crazy our

14712
09:51:39,040 --> 09:51:41,916
array has 10 elements but we are trying

14713
09:51:41,916 --> 09:51:44,560
to modify something

14714
09:51:44,560 --> 09:51:48,480
1 million memory locations away and uh

14715
09:51:48,480 --> 09:51:50,640
this is really crazy and c plus plus

14716
09:51:50,640 --> 09:51:52,400
allows you to do this

14717
09:51:52,400 --> 09:51:54,720
so let's clear and run did we world

14718
09:51:54,720 --> 09:51:58,240
let's make sure we have world so let's

14719
09:51:58,240 --> 09:52:00,320
build with gcc

14720
09:52:00,320 --> 09:52:02,160
and clear

14721
09:52:02,160 --> 09:52:04,720
and run rooster our program is crashing

14722
09:52:04,720 --> 09:52:06,240
because we are trying to access

14723
09:52:06,240 --> 09:52:07,756
something

14724
09:52:07,756 --> 09:52:09,596
that isn't really ours and you see it

14725
09:52:09,596 --> 09:52:10,960
has crashed

14726
09:52:10,960 --> 09:52:13,120
okay for example if we have something

14727
09:52:13,120 --> 09:52:16,160
printed out after this let's say std

14728
09:52:16,160 --> 09:52:18,160
program

14729
09:52:18,160 --> 09:52:19,916
and then so that you can see it is

14730
09:52:19,916 --> 09:52:21,680
really crashing

14731
09:52:21,680 --> 09:52:23,916
and say stdndl

14732
09:52:23,916 --> 09:52:26,400
this statement here is not going to

14733
09:52:26,400 --> 09:52:29,040
print because once we hit this location

14734
09:52:29,040 --> 09:52:31,276
we're going to try and modify this and

14735
09:52:31,276 --> 09:52:33,120
the program is not going to be able to

14736
09:52:33,120 --> 09:52:34,480
do that it's going to crash the

14737
09:52:34,480 --> 09:52:36,160
operating system is going to notice that

14738
09:52:36,160 --> 09:52:38,560
we are trying to do something crazy and

14739
09:52:38,560 --> 09:52:40,880
it's going to say this program is really

14740
09:52:40,880 --> 09:52:43,200
crazy it doesn't know what it's doing i

14741
09:52:43,200 --> 09:52:44,880
am going to kill it and it is going to

14742
09:52:44,880 --> 09:52:47,040
stop that's basically what is happening

14743
09:52:47,040 --> 09:52:50,880
here so let's weld again with gcc

14744
09:52:50,880 --> 09:52:53,200
and we're going to clear

14745
09:52:53,200 --> 09:52:55,120
let's clear

14746
09:52:55,120 --> 09:52:57,680
and run rooster you see that it's going

14747
09:52:57,680 --> 09:52:59,520
to try and do this it's going to try and

14748
09:52:59,520 --> 09:53:01,756
put a value in here the program is going

14749
09:53:01,756 --> 09:53:04,400
to end here and this is really bad

14750
09:53:04,400 --> 09:53:06,320
because memory locations you have

14751
09:53:06,320 --> 09:53:09,040
allocated for before here are not

14752
09:53:09,040 --> 09:53:11,360
properly released and returned to the

14753
09:53:11,360 --> 09:53:13,520
operating system and this is something

14754
09:53:13,520 --> 09:53:16,400
really bad so the message is

14755
09:53:16,400 --> 09:53:19,520
don't go overbound make sure you are

14756
09:53:19,520 --> 09:53:22,560
working within the legal boundaries of

14757
09:53:22,560 --> 09:53:25,520
your array welcome to this new chapter

14758
09:53:25,520 --> 09:53:27,436
and we are going to be talking about

14759
09:53:27,436 --> 09:53:29,680
pointers pointers are one of the

14760
09:53:29,680 --> 09:53:32,240
important topics in c plus plus and they

14761
09:53:32,240 --> 09:53:34,480
allow you to do some of the things very

14762
09:53:34,480 --> 09:53:36,720
conveniently and we're going to be

14763
09:53:36,720 --> 09:53:38,960
learning about all those tricky things

14764
09:53:38,960 --> 09:53:41,200
you can do with them in this chapter but

14765
09:53:41,200 --> 09:53:43,200
now i want you to have a basic

14766
09:53:43,200 --> 09:53:45,436
understanding of what a pointer really

14767
09:53:45,436 --> 09:53:46,240
is

14768
09:53:46,240 --> 09:53:47,916
so far we have been working with

14769
09:53:47,916 --> 09:53:50,000
variables like this we set up a variable

14770
09:53:50,000 --> 09:53:52,400
in our c plus plus code we get to a

14771
09:53:52,400 --> 09:53:54,480
point where we put a value inside that

14772
09:53:54,480 --> 09:53:56,880
variable and we could use it for example

14773
09:53:56,880 --> 09:54:00,000
we could print it out on stdc out or we

14774
09:54:00,000 --> 09:54:02,000
could even store a value or assign

14775
09:54:02,000 --> 09:54:04,240
another value to the variable we've been

14776
09:54:04,240 --> 09:54:06,800
doing that quite a lot but there is a

14777
09:54:06,800 --> 09:54:08,640
point we haven't really been talking

14778
09:54:08,640 --> 09:54:11,276
about those variables have an address in

14779
09:54:11,276 --> 09:54:13,840
memory and here for example you see that

14780
09:54:13,840 --> 09:54:15,200
our var

14781
09:54:15,200 --> 09:54:17,756
is stored at location one zero zero

14782
09:54:17,756 --> 09:54:19,756
eight of course this is a simple example

14783
09:54:19,756 --> 09:54:21,120
i came up with

14784
09:54:21,120 --> 09:54:24,080
but i hope it drives the point home all

14785
09:54:24,080 --> 09:54:26,320
the variables you use in your code have

14786
09:54:26,320 --> 09:54:28,720
some kind of address in memory

14787
09:54:28,720 --> 09:54:31,756
and we can grab that address and store

14788
09:54:31,756 --> 09:54:34,400
that in a special kind of variable which

14789
09:54:34,400 --> 09:54:36,800
is really a pointer so we can say that a

14790
09:54:36,800 --> 09:54:37,840
pointer

14791
09:54:37,840 --> 09:54:40,240
is a special kind of variable

14792
09:54:40,240 --> 09:54:43,436
that stores addresses of other variables

14793
09:54:43,436 --> 09:54:45,276
make sure you really understand this

14794
09:54:45,276 --> 09:54:47,680
here we have p var so it is a pointer

14795
09:54:47,680 --> 09:54:50,880
its type is end pointer and we denote

14796
09:54:50,880 --> 09:54:54,400
pointer using this star symbol after our

14797
09:54:54,400 --> 09:54:56,480
type if you see something like this

14798
09:54:56,480 --> 09:54:58,160
you're going to know that this type is a

14799
09:54:58,160 --> 09:55:00,720
pointer to end its name is going to be p

14800
09:55:00,720 --> 09:55:02,560
var because it's a variable

14801
09:55:02,560 --> 09:55:04,960
and its value is going to be the address

14802
09:55:04,960 --> 09:55:06,640
of another variable you see it is

14803
09:55:06,640 --> 09:55:10,240
storing 1 0 0 8 which happens to be the

14804
09:55:10,240 --> 09:55:13,596
address of our var here in memory

14805
09:55:13,596 --> 09:55:15,596
pointers and variables we've been

14806
09:55:15,596 --> 09:55:17,596
talking about can work hand in hand and

14807
09:55:17,596 --> 09:55:19,596
we're going to be seeing how this is

14808
09:55:19,596 --> 09:55:21,436
done in the next few lectures in the

14809
09:55:21,436 --> 09:55:24,400
chapter but the basic idea is really the

14810
09:55:24,400 --> 09:55:26,960
same here you see that we have a pointer

14811
09:55:26,960 --> 09:55:29,120
to it but you can have a pointer ready

14812
09:55:29,120 --> 09:55:30,960
to anything in your code you can have a

14813
09:55:30,960 --> 09:55:33,436
pointer to car you can have a pointer to

14814
09:55:33,436 --> 09:55:35,840
double you can have a pointer to float

14815
09:55:35,840 --> 09:55:39,120
even pointers to custom types we haven't

14816
09:55:39,120 --> 09:55:40,880
really talked about now but we will

14817
09:55:40,880 --> 09:55:42,880
learn about them later in the course

14818
09:55:42,880 --> 09:55:45,520
again a pointer is a special type of

14819
09:55:45,520 --> 09:55:48,640
variable in your c plus program that is

14820
09:55:48,640 --> 09:55:51,120
going to store addresses to other

14821
09:55:51,120 --> 09:55:54,000
variables that's what it really is and

14822
09:55:54,000 --> 09:55:55,680
we're going to start and see how you can

14823
09:55:55,680 --> 09:55:58,080
declare initialize and use them in your

14824
09:55:58,080 --> 09:56:00,800
code starting in the next lecture

14825
09:56:00,800 --> 09:56:03,120
go ahead and finish up here and meet me

14826
09:56:03,120 --> 09:56:04,000
there

14827
09:56:04,000 --> 09:56:05,596
in this lecture we're going to see how

14828
09:56:05,596 --> 09:56:08,720
we can declare and use pointers in our c

14829
09:56:08,720 --> 09:56:10,880
plus plus code in the last lecture we

14830
09:56:10,880 --> 09:56:13,436
say that a pointer is a special kind of

14831
09:56:13,436 --> 09:56:14,480
variable

14832
09:56:14,480 --> 09:56:17,120
that can store addresses to other

14833
09:56:17,120 --> 09:56:20,000
variables in our c plus plus code and we

14834
09:56:20,000 --> 09:56:22,080
have seen a slide like this to drive the

14835
09:56:22,080 --> 09:56:24,160
point home now we're going to see how we

14836
09:56:24,160 --> 09:56:27,040
can actually use pointers in our code

14837
09:56:27,040 --> 09:56:29,596
here is a simple example of how you can

14838
09:56:29,596 --> 09:56:32,000
declare a pointer variable in your c

14839
09:56:32,000 --> 09:56:34,560
plus plus code you say ent you put a

14840
09:56:34,560 --> 09:56:36,960
star after the type

14841
09:56:36,960 --> 09:56:39,520
to mean that this variable is not a

14842
09:56:39,520 --> 09:56:41,680
regular variable like we have seen

14843
09:56:41,680 --> 09:56:45,360
before it is a special kind of variable

14844
09:56:45,360 --> 09:56:47,120
that is going to store

14845
09:56:47,120 --> 09:56:49,520
addresses to other variables and here i

14846
09:56:49,520 --> 09:56:51,596
have to say that you have to be really

14847
09:56:51,596 --> 09:56:54,960
careful and only store addresses to

14848
09:56:54,960 --> 09:56:57,596
value the types of variable

14849
09:56:57,596 --> 09:57:00,000
in your pointers for example this is a

14850
09:57:00,000 --> 09:57:02,640
pointer to end it can only store an

14851
09:57:02,640 --> 09:57:05,596
address of a variable of type and for

14852
09:57:05,596 --> 09:57:08,240
other types if you try and put in their

14853
09:57:08,240 --> 09:57:10,320
addresses in here you're going to get a

14854
09:57:10,320 --> 09:57:12,560
compiler error down here you see we have

14855
09:57:12,560 --> 09:57:14,960
another example and it's called p

14856
09:57:14,960 --> 09:57:17,120
fractional number because it's a double

14857
09:57:17,120 --> 09:57:19,520
and you see that our pointers here are

14858
09:57:19,520 --> 09:57:22,960
initialized using braced initializers

14859
09:57:22,960 --> 09:57:24,640
and this is going to initialize the

14860
09:57:24,640 --> 09:57:28,000
pointers with a special address that

14861
09:57:28,000 --> 09:57:30,080
really denotes that these pointers are

14862
09:57:30,080 --> 09:57:32,560
not pointing to anything yet okay you

14863
09:57:32,560 --> 09:57:35,916
can also say that explicitly and put now

14864
09:57:35,916 --> 09:57:38,400
ptr inside and this is going to mean

14865
09:57:38,400 --> 09:57:41,040
that these pointers are not pointing

14866
09:57:41,040 --> 09:57:43,276
anywhere you can't really use the values

14867
09:57:43,276 --> 09:57:46,160
at the addresses where they point this

14868
09:57:46,160 --> 09:57:48,800
is the message here don't use pointers

14869
09:57:48,800 --> 09:57:51,756
that contain null pointer all pointers

14870
09:57:51,756 --> 09:57:54,240
on a given system are going to have the

14871
09:57:54,240 --> 09:57:56,800
same size for example if you have a

14872
09:57:56,800 --> 09:57:59,436
pointer to end and the pointer to double

14873
09:57:59,436 --> 09:58:01,040
they are going to be the same size

14874
09:58:01,040 --> 09:58:03,596
because they really store the same thing

14875
09:58:03,596 --> 09:58:06,240
they store addresses to variables and

14876
09:58:06,240 --> 09:58:08,880
addresses to different variables even if

14877
09:58:08,880 --> 09:58:10,800
they happen to be of the same type on

14878
09:58:10,800 --> 09:58:13,520
the same system are of the same size

14879
09:58:13,520 --> 09:58:15,840
that's why all the pointers you're going

14880
09:58:15,840 --> 09:58:17,520
to use in your code are going to have

14881
09:58:17,520 --> 09:58:19,276
the same size and this is something you

14882
09:58:19,276 --> 09:58:21,520
should keep in mind and here is a simple

14883
09:58:21,520 --> 09:58:23,680
example to really play with that we have

14884
09:58:23,680 --> 09:58:26,800
a size of it printed out we have a size

14885
09:58:26,800 --> 09:58:28,960
of our pointers printed out and we're

14886
09:58:28,960 --> 09:58:30,720
going to compare these things when we

14887
09:58:30,720 --> 09:58:32,640
get to visual studio code in a minute

14888
09:58:32,640 --> 09:58:33,756
and you're going to see that all

14889
09:58:33,756 --> 09:58:36,480
pointers are of the same size a question

14890
09:58:36,480 --> 09:58:39,200
i get from many people is if the

14891
09:58:39,200 --> 09:58:42,080
position of this star symbol

14892
09:58:42,080 --> 09:58:44,320
really matters and i have to break it to

14893
09:58:44,320 --> 09:58:47,276
you it doesn't but i prefer to put it on

14894
09:58:47,276 --> 09:58:49,276
the left some people prefer to put it on

14895
09:58:49,276 --> 09:58:51,680
the right but definitely don't put it in

14896
09:58:51,680 --> 09:58:53,680
the middle i've never seen anybody do

14897
09:58:53,680 --> 09:58:55,756
this but it's going to work it's going

14898
09:58:55,756 --> 09:58:58,560
to be legal c plus plus code another

14899
09:58:58,560 --> 09:59:00,240
thing i see people do which is really

14900
09:59:00,240 --> 09:59:03,120
confusing is to declare your pointers on

14901
09:59:03,120 --> 09:59:05,680
the same line and do a comma like this

14902
09:59:05,680 --> 09:59:08,400
this is really going to be confusing and

14903
09:59:08,400 --> 09:59:11,596
now i want you to guess and see what is

14904
09:59:11,596 --> 09:59:15,120
happening here is either it var a

14905
09:59:15,120 --> 09:59:17,916
pointer or it's a regular end i want you

14906
09:59:17,916 --> 09:59:19,520
to keep this in mind i'm not going to

14907
09:59:19,520 --> 09:59:21,520
tell you we're going to try this out

14908
09:59:21,520 --> 09:59:23,596
actually in visual studio code and we're

14909
09:59:23,596 --> 09:59:25,680
going to figure this out together but

14910
09:59:25,680 --> 09:59:27,680
now i want you to try and think about it

14911
09:59:27,680 --> 09:59:29,276
we're going to leave this question

14912
09:59:29,276 --> 09:59:31,276
unanswered and we're going to answer it

14913
09:59:31,276 --> 09:59:33,680
in a little while but for now

14914
09:59:33,680 --> 09:59:35,756
don't really do this because it's

14915
09:59:35,756 --> 09:59:37,840
confusing and it's going to make your

14916
09:59:37,840 --> 09:59:40,160
code less readable if you have to do

14917
09:59:40,160 --> 09:59:42,000
something like this make sure you just

14918
09:59:42,000 --> 09:59:44,160
put them on different lines and it's not

14919
09:59:44,160 --> 09:59:46,480
going to be confusing for example if you

14920
09:59:46,480 --> 09:59:48,320
look down here you're going to know that

14921
09:59:48,320 --> 09:59:50,480
p number seven is a pointer other

14922
09:59:50,480 --> 09:59:52,960
interval is a regular end and there is

14923
09:59:52,960 --> 09:59:55,756
no room for confusion this time use code

14924
09:59:55,756 --> 09:59:57,840
like this and don't put things on the

14925
09:59:57,840 --> 10:00:00,800
same line like we have on top here okay

14926
10:00:00,800 --> 10:00:02,960
now we have seen that we can declare and

14927
10:00:02,960 --> 10:00:06,320
initialize pointers with null pointer

14928
10:00:06,320 --> 10:00:09,276
now is the time to see how we can put

14929
10:00:09,276 --> 10:00:12,000
actual data in those pointer variables

14930
10:00:12,000 --> 10:00:13,916
here we have a variable which is called

14931
10:00:13,916 --> 10:00:17,120
into var it is of type and and its value

14932
10:00:17,120 --> 10:00:18,560
is a 43

14933
10:00:18,560 --> 10:00:20,880
we can also set up another pointer

14934
10:00:20,880 --> 10:00:23,040
variable end pointer

14935
10:00:23,040 --> 10:00:25,276
its name is p

14936
10:00:25,276 --> 10:00:28,560
underscore int and we can initialize it

14937
10:00:28,560 --> 10:00:31,680
with the address of another variable and

14938
10:00:31,680 --> 10:00:34,000
here is a new operator we haven't seen

14939
10:00:34,000 --> 10:00:37,120
before this ampersand variable here

14940
10:00:37,120 --> 10:00:39,596
really means the address of this ant

14941
10:00:39,596 --> 10:00:41,360
variable that's what we mean here so

14942
10:00:41,360 --> 10:00:43,596
we're going to initialize this p end

14943
10:00:43,596 --> 10:00:46,320
variable with the address of enter

14944
10:00:46,320 --> 10:00:48,560
variable and this is how we do it

14945
10:00:48,560 --> 10:00:50,720
if we go down here we print antivirus

14946
10:00:50,720 --> 10:00:52,240
we're going to get the value printed

14947
10:00:52,240 --> 10:00:55,276
down if we print the pointer directly

14948
10:00:55,276 --> 10:00:57,200
we're going to get the address of this

14949
10:00:57,200 --> 10:00:59,520
little guy printed out on the console

14950
10:00:59,520 --> 10:01:01,596
and we're going to see it okay so this

14951
10:01:01,596 --> 10:01:03,680
is how you can store things in your

14952
10:01:03,680 --> 10:01:05,520
pointer variables and what you have to

14953
10:01:05,520 --> 10:01:08,080
store and has to be an address of

14954
10:01:08,080 --> 10:01:09,436
another variable

14955
10:01:09,436 --> 10:01:10,800
down here you see we have another

14956
10:01:10,800 --> 10:01:13,120
variable called into r1 inside we have a

14957
10:01:13,120 --> 10:01:16,560
65 and if you go down here you see that

14958
10:01:16,560 --> 10:01:19,200
we are storing something else

14959
10:01:19,200 --> 10:01:21,916
in our point of variable here we had in

14960
10:01:21,916 --> 10:01:24,400
the address of into var now we are

14961
10:01:24,400 --> 10:01:27,436
putting in the address of into var1

14962
10:01:27,436 --> 10:01:29,916
using an assignment operator and this is

14963
10:01:29,916 --> 10:01:32,080
something you can definitely do it's

14964
10:01:32,080 --> 10:01:34,640
legal c plus plus it's going to work if

14965
10:01:34,640 --> 10:01:36,400
we print it out we're going to get a

14966
10:01:36,400 --> 10:01:38,640
different address printed out this is

14967
10:01:38,640 --> 10:01:41,200
how you can store values in your pointer

14968
10:01:41,200 --> 10:01:44,160
variables again you can't cross a sign

14969
10:01:44,160 --> 10:01:46,800
before different pointer types here we

14970
10:01:46,800 --> 10:01:48,840
have an eight pointer which is called

14971
10:01:48,840 --> 10:01:51,360
pn1 and we have a double variable it's

14972
10:01:51,360 --> 10:01:53,756
called double var we can't take the

14973
10:01:53,756 --> 10:01:56,880
address of double var and store that in

14974
10:01:56,880 --> 10:01:59,200
pnt1 this is going to be a compiler

14975
10:01:59,200 --> 10:02:01,916
error the variables whose addresses you

14976
10:02:01,916 --> 10:02:05,680
store in payment 1 have to be of type

14977
10:02:05,680 --> 10:02:07,840
and again the basic idea is that a

14978
10:02:07,840 --> 10:02:10,560
pointer is really a special kind of

14979
10:02:10,560 --> 10:02:12,960
variable that is going to store

14980
10:02:12,960 --> 10:02:15,840
addresses to other variables and if your

14981
10:02:15,840 --> 10:02:18,480
pointer is a pointer to end

14982
10:02:18,480 --> 10:02:20,720
the variables whose addresses you can

14983
10:02:20,720 --> 10:02:23,756
store in this pointer to end can only be

14984
10:02:23,756 --> 10:02:26,400
ends if you try and put in doubles

14985
10:02:26,400 --> 10:02:27,596
you're going to be in trouble you're

14986
10:02:27,596 --> 10:02:29,520
going to get a compiler error and it's

14987
10:02:29,520 --> 10:02:31,520
not going to work now we're going to

14988
10:02:31,520 --> 10:02:33,596
head over to visual studio code and

14989
10:02:33,596 --> 10:02:36,240
actually play with these things here we

14990
10:02:36,240 --> 10:02:39,360
are in our working directory the current

14991
10:02:39,360 --> 10:02:41,756
chapter is pointers the current lecture

14992
10:02:41,756 --> 10:02:43,916
is declaring and using pointers we're

14993
10:02:43,916 --> 10:02:46,160
going to grab our template files and put

14994
10:02:46,160 --> 10:02:48,000
them in place

14995
10:02:48,000 --> 10:02:51,120
so put them in our project here and

14996
10:02:51,120 --> 10:02:52,720
we're going to open this in visual

14997
10:02:52,720 --> 10:02:54,400
studio code the first thing we're going

14998
10:02:54,400 --> 10:02:56,560
to see is how we can declare

14999
10:02:56,560 --> 10:02:58,800
and initialize pointers and we're going

15000
10:02:58,800 --> 10:03:00,800
to use a pointer to end as a first

15001
10:03:00,800 --> 10:03:02,720
example we're going to set up an inch

15002
10:03:02,720 --> 10:03:05,200
pointer and we say in store we're going

15003
10:03:05,200 --> 10:03:06,480
to give it a name we're going to call

15004
10:03:06,480 --> 10:03:09,200
this p number and you can leave it like

15005
10:03:09,200 --> 10:03:11,840
this uninitialized but it is really

15006
10:03:11,840 --> 10:03:14,160
advised to always initialize your

15007
10:03:14,160 --> 10:03:16,560
pointers so we're going to do that with

15008
10:03:16,560 --> 10:03:19,276
a brist initializer which is going to do

15009
10:03:19,276 --> 10:03:21,840
that for us this is going to implicitly

15010
10:03:21,840 --> 10:03:24,240
initialize it with zero equivalent of

15011
10:03:24,240 --> 10:03:26,400
pointers and that happens to be null

15012
10:03:26,400 --> 10:03:29,680
pointer so we'll initialize okay so this

15013
10:03:29,680 --> 10:03:31,360
is what we're going to initialize with

15014
10:03:31,360 --> 10:03:32,080
no

15015
10:03:32,080 --> 10:03:34,720
pointer we say no ptr

15016
10:03:34,720 --> 10:03:37,436
and this is how you should do things you

15017
10:03:37,436 --> 10:03:39,680
can also do a pointer to double why not

15018
10:03:39,680 --> 10:03:41,520
let's do double pointer and we're going

15019
10:03:41,520 --> 10:03:44,080
to say fractional number pointer to

15020
10:03:44,080 --> 10:03:45,916
fractional number and we can also

15021
10:03:45,916 --> 10:03:48,960
initialize this with null pointer

15022
10:03:48,960 --> 10:03:50,400
implicitly

15023
10:03:50,400 --> 10:03:51,276
and

15024
10:03:51,276 --> 10:03:53,200
once you do this the program is going to

15025
10:03:53,200 --> 10:03:57,120
be legal if we try to world at with gcc

15026
10:03:57,120 --> 10:03:59,276
like we always do the build is going to

15027
10:03:59,276 --> 10:04:01,436
be good but we don't really have any

15028
10:04:01,436 --> 10:04:03,680
useful thing we can see

15029
10:04:03,680 --> 10:04:05,596
if we run this program we are just

15030
10:04:05,596 --> 10:04:07,680
getting started we will get to see

15031
10:04:07,680 --> 10:04:10,720
things later for now just understand

15032
10:04:10,720 --> 10:04:13,680
that p number is a variable we have in

15033
10:04:13,680 --> 10:04:16,400
our code this variable can only store

15034
10:04:16,400 --> 10:04:19,360
addresses to other variables that happen

15035
10:04:19,360 --> 10:04:22,800
to be of type and if you try and store

15036
10:04:22,800 --> 10:04:25,436
in an address of a variable which is of

15037
10:04:25,436 --> 10:04:27,916
type double for example or flute you're

15038
10:04:27,916 --> 10:04:29,200
going to get a compiler error you

15039
10:04:29,200 --> 10:04:31,436
shouldn't do that the same for p

15040
10:04:31,436 --> 10:04:34,080
fractional number it can only store

15041
10:04:34,080 --> 10:04:36,880
addresses to other variables which

15042
10:04:36,880 --> 10:04:39,596
happen to be of type double keep this in

15043
10:04:39,596 --> 10:04:41,436
mind we can also

15044
10:04:41,436 --> 10:04:44,320
explicitly initialize with no pointer so

15045
10:04:44,320 --> 10:04:47,120
we can say end pointer and say p number

15046
10:04:47,120 --> 10:04:49,200
one why not and we're going to

15047
10:04:49,200 --> 10:04:51,520
explicitly use no

15048
10:04:51,520 --> 10:04:53,756
ptr like this and this is going to work

15049
10:04:53,756 --> 10:04:56,480
as well you can also say

15050
10:04:56,480 --> 10:04:59,756
p fractional number and say

15051
10:04:59,756 --> 10:05:03,436
one why not and say now pqr this is

15052
10:05:03,436 --> 10:05:05,120
going to work this is something you can

15053
10:05:05,120 --> 10:05:06,720
do you're going to see that if we

15054
10:05:06,720 --> 10:05:08,720
compile this the compiler is going to be

15055
10:05:08,720 --> 10:05:11,756
happy with this the world is good okay

15056
10:05:11,756 --> 10:05:13,360
now you know how you can declare and

15057
10:05:13,360 --> 10:05:15,360
initialize your pointers now we want to

15058
10:05:15,360 --> 10:05:16,080
see

15059
10:05:16,080 --> 10:05:18,880
that pointers to different variables are

15060
10:05:18,880 --> 10:05:21,120
actually of the same size

15061
10:05:21,120 --> 10:05:23,596
on whatever system you are working on

15062
10:05:23,596 --> 10:05:25,840
it's not consistent across operating

15063
10:05:25,840 --> 10:05:28,480
systems or riffing systems but it is

15064
10:05:28,480 --> 10:05:31,360
guaranteed to be of the same size on the

15065
10:05:31,360 --> 10:05:32,560
same machine

15066
10:05:32,560 --> 10:05:34,880
i am going to go down and put in a piece

15067
10:05:34,880 --> 10:05:36,800
of code that is going to show us all

15068
10:05:36,800 --> 10:05:39,040
these things on the console and i am

15069
10:05:39,040 --> 10:05:41,276
going to click on this file icon here

15070
10:05:41,276 --> 10:05:43,040
and give ourselves

15071
10:05:43,040 --> 10:05:45,040
some breathing room so that we can see

15072
10:05:45,040 --> 10:05:46,960
the entire thing here if you look here

15073
10:05:46,960 --> 10:05:48,960
we are printing the size of ant we know

15074
10:05:48,960 --> 10:05:51,596
that this is going to be a four

15075
10:05:51,596 --> 10:05:53,520
size of double this is going to be an

15076
10:05:53,520 --> 10:05:55,916
eight on our system here but we don't

15077
10:05:55,916 --> 10:05:58,240
know what the size of a double pointer

15078
10:05:58,240 --> 10:06:00,800
is or the size of an end pointer and

15079
10:06:00,800 --> 10:06:03,120
we're going to see that in a minute here

15080
10:06:03,120 --> 10:06:04,960
you see that we are also using the

15081
10:06:04,960 --> 10:06:06,880
pointer variables immediately this is

15082
10:06:06,880 --> 10:06:08,960
something you can do you see that visual

15083
10:06:08,960 --> 10:06:11,276
studio code is not complaining and we

15084
10:06:11,276 --> 10:06:14,800
can go on top here and boulder with gcc

15085
10:06:14,800 --> 10:06:16,400
let's do that

15086
10:06:16,400 --> 10:06:19,360
the world is going to be good now we can

15087
10:06:19,360 --> 10:06:21,680
open up a terminal and actually run this

15088
10:06:21,680 --> 10:06:23,520
program here we're going to clear if we

15089
10:06:23,520 --> 10:06:24,800
do there

15090
10:06:24,800 --> 10:06:26,480
we're going to see that

15091
10:06:26,480 --> 10:06:27,756
in

15092
10:06:27,756 --> 10:06:29,916
our directory here so you see that we

15093
10:06:29,916 --> 10:06:32,240
have rooster.exe

15094
10:06:32,240 --> 10:06:34,240
and we can run this and it's going to

15095
10:06:34,240 --> 10:06:35,520
say

15096
10:06:35,520 --> 10:06:38,640
sizeofant is four size of double is

15097
10:06:38,640 --> 10:06:39,680
eight

15098
10:06:39,680 --> 10:06:43,360
this is expected but pointer types are

15099
10:06:43,360 --> 10:06:47,120
of size 8 on my system they occupy 8

15100
10:06:47,120 --> 10:06:49,916
bytes in memory so it doesn't matter the

15101
10:06:49,916 --> 10:06:52,400
type we are pointing to a pointer to it

15102
10:06:52,400 --> 10:06:55,436
is always going to be 8 bytes in memory

15103
10:06:55,436 --> 10:06:57,756
this is something you should really know

15104
10:06:57,756 --> 10:06:59,756
and keep in your mind another thing we

15105
10:06:59,756 --> 10:07:01,916
have said that i want to play with right

15106
10:07:01,916 --> 10:07:02,960
now

15107
10:07:02,960 --> 10:07:05,276
is the location of the star symbol some

15108
10:07:05,276 --> 10:07:07,040
people say you should put it on the left

15109
10:07:07,040 --> 10:07:08,640
some people say you should put it to the

15110
10:07:08,640 --> 10:07:11,360
right i don't really think any of these

15111
10:07:11,360 --> 10:07:13,520
dense matters i prefer to put it to the

15112
10:07:13,520 --> 10:07:15,360
left but if you put it to the right it's

15113
10:07:15,360 --> 10:07:17,840
also possible it's going to work you see

15114
10:07:17,840 --> 10:07:19,436
that even if you put it in the middle

15115
10:07:19,436 --> 10:07:21,360
here which is really crazy the compiler

15116
10:07:21,360 --> 10:07:23,756
is going to take this we can run the

15117
10:07:23,756 --> 10:07:25,520
task to build this to make sure the

15118
10:07:25,520 --> 10:07:27,120
compiler is really happy and you see

15119
10:07:27,120 --> 10:07:29,040
that there's no problem the compiler is

15120
10:07:29,040 --> 10:07:31,200
going to accept this and we are going to

15121
10:07:31,200 --> 10:07:34,000
build successfully if you put your

15122
10:07:34,000 --> 10:07:36,480
declaration on a single line like this

15123
10:07:36,480 --> 10:07:39,200
what is other ant var going to be is it

15124
10:07:39,200 --> 10:07:41,436
going to be a regular end variable is it

15125
10:07:41,436 --> 10:07:43,756
going to be a pointer to end

15126
10:07:43,756 --> 10:07:45,756
we don't really know now and i don't

15127
10:07:45,756 --> 10:07:47,680
want to tell you we're going to find out

15128
10:07:47,680 --> 10:07:49,436
together so what we're going to do we're

15129
10:07:49,436 --> 10:07:52,080
going to print the size of these things

15130
10:07:52,080 --> 10:07:54,000
i am going to go down here and put in

15131
10:07:54,000 --> 10:07:56,320
the code and come back in a minute here

15132
10:07:56,320 --> 10:07:59,200
is our code typed out and we're going to

15133
10:07:59,200 --> 10:08:01,840
see the size of these things what we're

15134
10:08:01,840 --> 10:08:04,240
going to do is run the task to build

15135
10:08:04,240 --> 10:08:07,520
with gcc as we always do let's clear

15136
10:08:07,520 --> 10:08:08,800
properly

15137
10:08:08,800 --> 10:08:10,720
and run rooster

15138
10:08:10,720 --> 10:08:14,640
and you see size of p number five is

15139
10:08:14,640 --> 10:08:15,596
eight

15140
10:08:15,596 --> 10:08:17,756
because it's a pointer size of either

15141
10:08:17,756 --> 10:08:20,880
end is four and the same applies to the

15142
10:08:20,880 --> 10:08:22,640
second line here

15143
10:08:22,640 --> 10:08:24,640
so from this we can tell that other

15144
10:08:24,640 --> 10:08:28,000
interval and other ant versus x are not

15145
10:08:28,000 --> 10:08:30,640
pointers they are regular integers and

15146
10:08:30,640 --> 10:08:34,560
this can be really confusing so to avoid

15147
10:08:34,560 --> 10:08:37,520
this confusion i would advise not to

15148
10:08:37,520 --> 10:08:38,560
declare

15149
10:08:38,560 --> 10:08:40,480
your thanks when you have pointers

15150
10:08:40,480 --> 10:08:42,240
inside like this because that's going to

15151
10:08:42,240 --> 10:08:44,560
be really confusing what you can do is

15152
10:08:44,560 --> 10:08:46,560
put them on separate lines and do

15153
10:08:46,560 --> 10:08:49,040
something like this so here it is very

15154
10:08:49,040 --> 10:08:51,596
clear that p number seven is a pointer

15155
10:08:51,596 --> 10:08:54,000
other eight var seven is a regular it

15156
10:08:54,000 --> 10:08:55,916
variable and there is no room for

15157
10:08:55,916 --> 10:08:58,960
confusion with this way of doing that so

15158
10:08:58,960 --> 10:09:00,640
make sure you put things on separate

15159
10:09:00,640 --> 10:09:02,480
lines like this and you're going to be

15160
10:09:02,480 --> 10:09:05,200
fine now what i want you to see is that

15161
10:09:05,200 --> 10:09:07,436
we can actually store data in all

15162
10:09:07,436 --> 10:09:10,240
pointers i mean valid data that is not

15163
10:09:10,240 --> 10:09:12,400
null pointer in this case we're going to

15164
10:09:12,400 --> 10:09:14,720
set up a variable a regular end variable

15165
10:09:14,720 --> 10:09:17,276
it's going to store a 43 inside and

15166
10:09:17,276 --> 10:09:19,200
we're going to set up another pointer

15167
10:09:19,200 --> 10:09:22,240
and initialize that with the address of

15168
10:09:22,240 --> 10:09:24,640
this it variable and this is going to

15169
10:09:24,640 --> 10:09:27,360
work properly what we can do now

15170
10:09:27,360 --> 10:09:29,200
is print the interval we're going to

15171
10:09:29,200 --> 10:09:31,360
print it out if we try to print the

15172
10:09:31,360 --> 10:09:33,520
pointer we're going to get the address

15173
10:09:33,520 --> 10:09:36,480
of this into var in memory and this is

15174
10:09:36,480 --> 10:09:38,560
something you need to see with your eyes

15175
10:09:38,560 --> 10:09:40,400
this is the first time we are printing

15176
10:09:40,400 --> 10:09:42,640
out an address that is stored in a

15177
10:09:42,640 --> 10:09:44,720
pointer and we're going to see that on

15178
10:09:44,720 --> 10:09:46,880
the console here what i am going to do

15179
10:09:46,880 --> 10:09:49,200
before we build and run this i am going

15180
10:09:49,200 --> 10:09:50,880
to comment out everything we've done

15181
10:09:50,880 --> 10:09:53,120
before because our console is now

15182
10:09:53,120 --> 10:09:54,320
cluttered

15183
10:09:54,320 --> 10:09:58,960
so let's come and comment out everything

15184
10:09:58,960 --> 10:10:01,520
and let's go down again now if we print

15185
10:10:01,520 --> 10:10:03,360
we're going to see these two statements

15186
10:10:03,360 --> 10:10:07,120
and that's going to be easier to follow

15187
10:10:07,120 --> 10:10:09,596
on the console here the build is good so

15188
10:10:09,596 --> 10:10:11,200
we are cool

15189
10:10:11,200 --> 10:10:13,276
let's run rooster

15190
10:10:13,276 --> 10:10:16,080
and the var is 43 and its address in

15191
10:10:16,080 --> 10:10:18,720
memory is this number here it is in

15192
10:10:18,720 --> 10:10:21,360
hexadecimal so this is the address in

15193
10:10:21,360 --> 10:10:24,400
memory and we can print that out and see

15194
10:10:24,400 --> 10:10:26,640
what it is okay so this is really cool

15195
10:10:26,640 --> 10:10:29,120
but we can also change what is stored in

15196
10:10:29,120 --> 10:10:31,276
our pointer here for example we can set

15197
10:10:31,276 --> 10:10:34,240
up another variable call it into our one

15198
10:10:34,240 --> 10:10:37,756
and uh change pnt which is a pointer to

15199
10:10:37,756 --> 10:10:40,320
contain the address of this new variable

15200
10:10:40,320 --> 10:10:42,880
and we can do that now if we print

15201
10:10:42,880 --> 10:10:44,880
payment we're going to see that it

15202
10:10:44,880 --> 10:10:46,800
contains a different address and we can

15203
10:10:46,800 --> 10:10:48,240
do that

15204
10:10:48,240 --> 10:10:51,276
so let's build with gcc again

15205
10:10:51,276 --> 10:10:53,276
we're going to go down and clear and run

15206
10:10:53,276 --> 10:10:55,360
rooster and we're going to see that now

15207
10:10:55,360 --> 10:10:57,520
we have a different address the one we

15208
10:10:57,520 --> 10:11:01,756
had ended in d e4 now we end in de0

15209
10:11:01,756 --> 10:11:04,240
these are different addresses and we are

15210
10:11:04,240 --> 10:11:06,560
storing different things in our pointer

15211
10:11:06,560 --> 10:11:08,240
this is really cool you can do something

15212
10:11:08,240 --> 10:11:10,560
like this and the next thing we want to

15213
10:11:10,560 --> 10:11:14,000
see now is that we can't cross a sign

15214
10:11:14,000 --> 10:11:16,960
between pointers of different types and

15215
10:11:16,960 --> 10:11:19,276
what i mean here is that for example if

15216
10:11:19,276 --> 10:11:21,840
we have two variables here one is a

15217
10:11:21,840 --> 10:11:24,480
pointer to end it is initialized with no

15218
10:11:24,480 --> 10:11:26,640
pointer and we have another variable

15219
10:11:26,640 --> 10:11:28,560
which is a double var it's going to be

15220
10:11:28,560 --> 10:11:30,000
of type double

15221
10:11:30,000 --> 10:11:33,916
and we can't do something like payment

15222
10:11:33,916 --> 10:11:37,360
equals address of double bar you can't

15223
10:11:37,360 --> 10:11:38,960
do something like this if you do it

15224
10:11:38,960 --> 10:11:40,880
you're going to get a compiler error and

15225
10:11:40,880 --> 10:11:43,436
you see that we have squiggly lines

15226
10:11:43,436 --> 10:11:45,360
in visual studio code this is a good

15227
10:11:45,360 --> 10:11:47,596
indication that something might be wrong

15228
10:11:47,596 --> 10:11:49,916
if we open the problems tab we're going

15229
10:11:49,916 --> 10:11:52,560
to say a value of double pointer cannot

15230
10:11:52,560 --> 10:11:54,800
be assigned to an entity of type 8

15231
10:11:54,800 --> 10:11:57,840
pointer so this is not something you can

15232
10:11:57,840 --> 10:11:59,436
do if you do this you're going to get a

15233
10:11:59,436 --> 10:12:02,560
compiler error be aware of this visual

15234
10:12:02,560 --> 10:12:05,276
studio code has warned us enough but we

15235
10:12:05,276 --> 10:12:07,436
can also try and get

15236
10:12:07,436 --> 10:12:10,240
a clear compiler error by building this

15237
10:12:10,240 --> 10:12:12,720
with gcc and we're going to get

15238
10:12:12,720 --> 10:12:14,880
basically the same thing you can't

15239
10:12:14,880 --> 10:12:16,800
cross-assign between pointers of

15240
10:12:16,800 --> 10:12:20,240
different types we are trying to assign

15241
10:12:20,240 --> 10:12:22,000
a double address

15242
10:12:22,000 --> 10:12:24,240
into a pointer to enter and this is not

15243
10:12:24,240 --> 10:12:26,640
going to work so let's comment this out

15244
10:12:26,640 --> 10:12:28,320
because we don't want this compiler

15245
10:12:28,320 --> 10:12:31,200
error now you know this and before we

15246
10:12:31,200 --> 10:12:33,436
close this lecture i want to mention

15247
10:12:33,436 --> 10:12:36,240
what is called the referencing and that

15248
10:12:36,240 --> 10:12:39,520
is the act of reading something

15249
10:12:39,520 --> 10:12:41,680
through a pointer so if we have an

15250
10:12:41,680 --> 10:12:43,680
address in a pointer we can go through

15251
10:12:43,680 --> 10:12:46,480
that address and actually read the value

15252
10:12:46,480 --> 10:12:48,800
contained in that address and we can do

15253
10:12:48,800 --> 10:12:51,040
something like this so if we have for

15254
10:12:51,040 --> 10:12:54,160
example an end pointer let's call it p

15255
10:12:54,160 --> 10:12:57,276
and two do we have a variable like this

15256
10:12:57,276 --> 10:12:59,436
so let's say we initialize this with

15257
10:12:59,436 --> 10:13:02,480
nodepointer and we have an end

15258
10:13:02,480 --> 10:13:06,400
variable and this is a 56 for example

15259
10:13:06,400 --> 10:13:09,436
and we do something like we do say

15260
10:13:09,436 --> 10:13:12,400
pnt2 we're going to make it contain the

15261
10:13:12,400 --> 10:13:14,560
address of int data this is something

15262
10:13:14,560 --> 10:13:16,960
you know you can do now now we want to

15263
10:13:16,960 --> 10:13:19,680
go through pm to 2 to read what is

15264
10:13:19,680 --> 10:13:23,200
contained in interdata because pn 2

15265
10:13:23,200 --> 10:13:26,400
contains the address of our integer here

15266
10:13:26,400 --> 10:13:29,916
so what we can do we can do stdc out and

15267
10:13:29,916 --> 10:13:32,560
say value and the syntax we use in c

15268
10:13:32,560 --> 10:13:35,040
plus plus is like this we say store and

15269
10:13:35,040 --> 10:13:37,120
we say our pointer variable we're going

15270
10:13:37,120 --> 10:13:40,160
to say pnt2 and now if we run we're

15271
10:13:40,160 --> 10:13:42,640
going to get the value here printed out

15272
10:13:42,640 --> 10:13:44,560
okay now if we try to build we're going

15273
10:13:44,560 --> 10:13:48,320
to build fine let's try with gcc

15274
10:13:48,320 --> 10:13:49,840
the world is good

15275
10:13:49,840 --> 10:13:51,200
we can clear

15276
10:13:51,200 --> 10:13:53,520
so that the arrows from

15277
10:13:53,520 --> 10:13:56,800
a previous run are cleared out

15278
10:13:56,800 --> 10:13:59,680
you see the bullet is good we can now

15279
10:13:59,680 --> 10:14:01,200
run rooster

15280
10:14:01,200 --> 10:14:03,520
and we're going to see that value is 56

15281
10:14:03,520 --> 10:14:05,120
we are successfully

15282
10:14:05,120 --> 10:14:07,680
reading the value stored in the address

15283
10:14:07,680 --> 10:14:10,240
pointed to by our pointer here and this

15284
10:14:10,240 --> 10:14:12,960
is the syntax used and this is called

15285
10:14:12,960 --> 10:14:14,800
the referencing a pointer we are

15286
10:14:14,800 --> 10:14:17,436
basically reading something stored in

15287
10:14:17,436 --> 10:14:19,360
the address of a pointer this is what we

15288
10:14:19,360 --> 10:14:21,520
mean here this is really all we set out

15289
10:14:21,520 --> 10:14:23,276
to do in this lecture the lecture turned

15290
10:14:23,276 --> 10:14:26,400
out to be lengthy but we had a lot of

15291
10:14:26,400 --> 10:14:29,200
ground to cover and now i hope you have

15292
10:14:29,200 --> 10:14:31,680
a good grasp on how to declare

15293
10:14:31,680 --> 10:14:34,480
initialize and use your pointers to do

15294
10:14:34,480 --> 10:14:36,560
all kinds of crazy things

15295
10:14:36,560 --> 10:14:38,240
we are going to stop here in this

15296
10:14:38,240 --> 10:14:40,160
lecture in the next one we're going to

15297
10:14:40,160 --> 10:14:42,480
learn a little more about pointer to

15298
10:14:42,480 --> 10:14:45,040
character types because they are also

15299
10:14:45,040 --> 10:14:46,160
special

15300
10:14:46,160 --> 10:14:48,480
go ahead and finish up here and meet me

15301
10:14:48,480 --> 10:14:50,560
there in this lecture we're going to

15302
10:14:50,560 --> 10:14:53,596
explore pointer to characters

15303
10:14:53,596 --> 10:14:55,756
and you can declare a pointer to a

15304
10:14:55,756 --> 10:14:58,160
character just like this we have car

15305
10:14:58,160 --> 10:14:59,200
pointer

15306
10:14:59,200 --> 10:15:02,080
and we say p carvar to give it a

15307
10:15:02,080 --> 10:15:04,240
variable name we initialize this with a

15308
10:15:04,240 --> 10:15:06,880
null pointer and after that we set up a

15309
10:15:06,880 --> 10:15:09,360
character variable and it is called

15310
10:15:09,360 --> 10:15:12,880
corvar and we store in an a in uppercase

15311
10:15:12,880 --> 10:15:16,400
a after that we take the address of car

15312
10:15:16,400 --> 10:15:19,276
of r and assign that to our pointer

15313
10:15:19,276 --> 10:15:21,680
variable this is how we store data in a

15314
10:15:21,680 --> 10:15:23,916
pointer and we can go through this

15315
10:15:23,916 --> 10:15:26,720
pointer to access data in this character

15316
10:15:26,720 --> 10:15:28,880
variable if we do something like this

15317
10:15:28,880 --> 10:15:30,880
we're going to print a down here we

15318
10:15:30,880 --> 10:15:33,360
declare another variable we store in a c

15319
10:15:33,360 --> 10:15:34,880
and we

15320
10:15:34,880 --> 10:15:37,756
assign the address of this new character

15321
10:15:37,756 --> 10:15:40,480
variable to our pointer variable and if

15322
10:15:40,480 --> 10:15:42,960
we print this again we're going to get a

15323
10:15:42,960 --> 10:15:45,040
c printed out this is really what we

15324
10:15:45,040 --> 10:15:46,720
have done in the last lecture we are

15325
10:15:46,720 --> 10:15:48,720
just extending that to character

15326
10:15:48,720 --> 10:15:51,120
pointers but with character pointers you

15327
10:15:51,120 --> 10:15:53,520
can do something really special what you

15328
10:15:53,520 --> 10:15:55,200
can do that is special you can

15329
10:15:55,200 --> 10:15:58,000
initialize that with a string literal

15330
10:15:58,000 --> 10:16:00,160
something like hello world which is

15331
10:16:00,160 --> 10:16:03,040
wrapped in quotes like this when you do

15332
10:16:03,040 --> 10:16:05,040
something like this the string here is

15333
10:16:05,040 --> 10:16:07,840
going to be expanded into a character

15334
10:16:07,840 --> 10:16:11,040
array and the first character of our

15335
10:16:11,040 --> 10:16:14,080
array is going to be pointed to by p

15336
10:16:14,080 --> 10:16:16,800
message here this is what we mean i

15337
10:16:16,800 --> 10:16:18,880
realize i might be throwing a lot of

15338
10:16:18,880 --> 10:16:21,436
things at you right now i am mixing up

15339
10:16:21,436 --> 10:16:23,756
arrays and pointers but they have a

15340
10:16:23,756 --> 10:16:25,916
really strong relationship and we're

15341
10:16:25,916 --> 10:16:28,000
going to learn about that in detail in a

15342
10:16:28,000 --> 10:16:30,640
few lectures ahead but for now

15343
10:16:30,640 --> 10:16:33,200
think of it like this this hello world

15344
10:16:33,200 --> 10:16:34,880
string is going to be turned into a

15345
10:16:34,880 --> 10:16:37,596
character array and the p message is

15346
10:16:37,596 --> 10:16:40,240
going to point to the first character

15347
10:16:40,240 --> 10:16:42,400
in this array here this is what is going

15348
10:16:42,400 --> 10:16:44,400
to happen and this is going to give us

15349
10:16:44,400 --> 10:16:46,480
the flexibility of treating our

15350
10:16:46,480 --> 10:16:49,840
strengths as character pointers and this

15351
10:16:49,840 --> 10:16:51,756
is going to come in handy at many

15352
10:16:51,756 --> 10:16:52,960
occasions

15353
10:16:52,960 --> 10:16:54,800
one thing i should tell you though is

15354
10:16:54,800 --> 10:16:57,200
that some compilers will refuse to

15355
10:16:57,200 --> 10:17:00,080
compile this code for example visual

15356
10:17:00,080 --> 10:17:02,560
studio 19 that i have installed on my

15357
10:17:02,560 --> 10:17:04,720
computer right now is going to refuse to

15358
10:17:04,720 --> 10:17:07,200
compile this code and the reason is the

15359
10:17:07,200 --> 10:17:09,360
compiler is going to expand this

15360
10:17:09,360 --> 10:17:11,120
strength into

15361
10:17:11,120 --> 10:17:14,960
a character array of const car

15362
10:17:14,960 --> 10:17:17,756
and here what we are using to point to

15363
10:17:17,756 --> 10:17:20,560
that is not a cost car pointer

15364
10:17:20,560 --> 10:17:23,756
so this pointer here can be used to try

15365
10:17:23,756 --> 10:17:27,040
and modify data into an array of cost

15366
10:17:27,040 --> 10:17:29,120
cars and that's going to be disastrous

15367
10:17:29,120 --> 10:17:31,360
because if you try to modify that

15368
10:17:31,360 --> 10:17:33,200
that's going to fail and that's not

15369
10:17:33,200 --> 10:17:35,200
going to be good so some compilers are

15370
10:17:35,200 --> 10:17:37,756
going to try and protect you from this

15371
10:17:37,756 --> 10:17:41,276
and force you to use pointers that are

15372
10:17:41,276 --> 10:17:43,756
qualified with cost to really mean that

15373
10:17:43,756 --> 10:17:46,320
they are closed car pointers and to get

15374
10:17:46,320 --> 10:17:48,240
the code to work we will have to do that

15375
10:17:48,240 --> 10:17:49,840
and i will show you how we do that in

15376
10:17:49,840 --> 10:17:52,000
visual studio code but i have to tell

15377
10:17:52,000 --> 10:17:54,320
you this in case you just want to jump

15378
10:17:54,320 --> 10:17:56,640
ahead and try this code out if you get a

15379
10:17:56,640 --> 10:17:58,640
compiler error that's going to be the

15380
10:17:58,640 --> 10:18:00,480
reason now that we have our strength

15381
10:18:00,480 --> 10:18:02,400
stored in memory we can really print it

15382
10:18:02,400 --> 10:18:04,800
out like this if you print p message

15383
10:18:04,800 --> 10:18:06,400
you're going to get this ring printed

15384
10:18:06,400 --> 10:18:09,040
out but i want to give you a question

15385
10:18:09,040 --> 10:18:09,916
here

15386
10:18:09,916 --> 10:18:12,720
what do you think we will get if we

15387
10:18:12,720 --> 10:18:14,960
dereference p message

15388
10:18:14,960 --> 10:18:16,720
try to think about this

15389
10:18:16,720 --> 10:18:19,120
i told you that the compiler is going to

15390
10:18:19,120 --> 10:18:21,840
expand this hello world string into an

15391
10:18:21,840 --> 10:18:25,120
array of characters or to be specific an

15392
10:18:25,120 --> 10:18:27,436
array of const cards

15393
10:18:27,436 --> 10:18:30,080
and p message is going to be pointing to

15394
10:18:30,080 --> 10:18:31,680
the first character

15395
10:18:31,680 --> 10:18:33,360
in that array

15396
10:18:33,360 --> 10:18:36,480
so if we dereference p message we're

15397
10:18:36,480 --> 10:18:38,480
going to get that character printed out

15398
10:18:38,480 --> 10:18:40,960
in this case we will get an h and that's

15399
10:18:40,960 --> 10:18:42,640
what is going to happen here but

15400
10:18:42,640 --> 10:18:45,756
character pointers are special in that

15401
10:18:45,756 --> 10:18:48,400
if you print them out directory the

15402
10:18:48,400 --> 10:18:51,120
compiler is going to do its magic and

15403
10:18:51,120 --> 10:18:53,840
make it possible to print out the entire

15404
10:18:53,840 --> 10:18:56,640
string that is stored in p message here

15405
10:18:56,640 --> 10:18:58,800
that's how character pointers are

15406
10:18:58,800 --> 10:19:00,800
special and you really need to be aware

15407
10:19:00,800 --> 10:19:02,640
of this because this is going to come in

15408
10:19:02,640 --> 10:19:06,400
handy many times just to emphasize that

15409
10:19:06,400 --> 10:19:08,640
this is going to be expanded into an

15410
10:19:08,640 --> 10:19:11,520
array of constant characters if we try

15411
10:19:11,520 --> 10:19:12,800
to modify

15412
10:19:12,800 --> 10:19:15,200
something inside p message here for

15413
10:19:15,200 --> 10:19:18,400
example we try to change the h into a b

15414
10:19:18,400 --> 10:19:20,880
we can try to do that because p message

15415
10:19:20,880 --> 10:19:23,436
is pointing to the first character so we

15416
10:19:23,436 --> 10:19:26,320
can try to dereference and assign a new

15417
10:19:26,320 --> 10:19:28,960
value and if we do that we're going to

15418
10:19:28,960 --> 10:19:31,200
get a compiler arrow or even worse we

15419
10:19:31,200 --> 10:19:34,080
might get a crash at run time so this is

15420
10:19:34,080 --> 10:19:36,400
something you shouldn't really do and

15421
10:19:36,400 --> 10:19:38,160
you should really flag

15422
10:19:38,160 --> 10:19:41,040
your p message here as the cost card

15423
10:19:41,040 --> 10:19:43,120
pointer and that's going to prevent you

15424
10:19:43,120 --> 10:19:45,040
from doing things like this which may

15425
10:19:45,040 --> 10:19:47,520
turn out to be very bad but most

15426
10:19:47,520 --> 10:19:50,320
compilers are going to even prevent you

15427
10:19:50,320 --> 10:19:52,960
from compiling this thing in modern

15428
10:19:52,960 --> 10:19:55,360
times for example if you are using a

15429
10:19:55,360 --> 10:19:57,120
very recent version

15430
10:19:57,120 --> 10:19:59,680
of visual studio you're going to get a

15431
10:19:59,680 --> 10:20:02,640
compiler error but i don't believe gcc

15432
10:20:02,640 --> 10:20:04,960
is going to give us a compiler error so

15433
10:20:04,960 --> 10:20:07,276
we will have to try this out and see how

15434
10:20:07,276 --> 10:20:10,240
it behaves but the message is if you

15435
10:20:10,240 --> 10:20:12,400
have to do something like this make sure

15436
10:20:12,400 --> 10:20:15,040
you use the cost car pointer and you're

15437
10:20:15,040 --> 10:20:17,200
going to be playing on the safe side

15438
10:20:17,200 --> 10:20:19,596
okay now i think you know enough about

15439
10:20:19,596 --> 10:20:21,916
character pointers what if we want our

15440
10:20:21,916 --> 10:20:24,800
users to be able to change this string

15441
10:20:24,800 --> 10:20:26,560
and make it be something else for

15442
10:20:26,560 --> 10:20:28,880
example change the first character here

15443
10:20:28,880 --> 10:20:31,680
into a b well in that case don't use

15444
10:20:31,680 --> 10:20:34,720
character pointers use regular arrays

15445
10:20:34,720 --> 10:20:37,436
like we have seen before so you can set

15446
10:20:37,436 --> 10:20:40,080
up an array like this it's going to be a

15447
10:20:40,080 --> 10:20:43,360
character array and you can initialize

15448
10:20:43,360 --> 10:20:45,916
it with the string literal and this is

15449
10:20:45,916 --> 10:20:47,680
going to allow you to modify things

15450
10:20:47,680 --> 10:20:50,160
inside so if we do something like this

15451
10:20:50,160 --> 10:20:52,880
we will get the message printed out and

15452
10:20:52,880 --> 10:20:54,400
the message is going to be tailored

15453
10:20:54,400 --> 10:20:57,276
because we changed the edge to be

15454
10:20:57,276 --> 10:21:00,320
a t and this is going to work so this is

15455
10:21:00,320 --> 10:21:02,480
something you really need to be aware of

15456
10:21:02,480 --> 10:21:05,200
but character pointers are very helpful

15457
10:21:05,200 --> 10:21:07,756
in many cases and in most cases you just

15458
10:21:07,756 --> 10:21:09,840
want to store the string and print it

15459
10:21:09,840 --> 10:21:12,000
out you're not interested in changing it

15460
10:21:12,000 --> 10:21:13,756
so that's why this is going to come in

15461
10:21:13,756 --> 10:21:17,040
handy in a lot of occasions now that you

15462
10:21:17,040 --> 10:21:18,400
know this we're going to head over to

15463
10:21:18,400 --> 10:21:20,720
visual studio code and actually try this

15464
10:21:20,720 --> 10:21:23,840
out okay here we are in our working

15465
10:21:23,840 --> 10:21:26,320
folder the current project is pointer to

15466
10:21:26,320 --> 10:21:29,520
car that's what we are exploring here so

15467
10:21:29,520 --> 10:21:31,276
we're going to grab our template files

15468
10:21:31,276 --> 10:21:34,080
and put them in place and we are going

15469
10:21:34,080 --> 10:21:36,560
to open this thing into visual studio

15470
10:21:36,560 --> 10:21:38,800
code and we're going to jump into here

15471
10:21:38,800 --> 10:21:42,320
and set up our first const car pointer

15472
10:21:42,320 --> 10:21:44,720
let's do a car pointer to see how this

15473
10:21:44,720 --> 10:21:46,800
thing behaves we're going to call this

15474
10:21:46,800 --> 10:21:48,960
message and we're going to initialize

15475
10:21:48,960 --> 10:21:52,240
this with our trusty message here hello

15476
10:21:52,240 --> 10:21:54,080
world okay once you do something like

15477
10:21:54,080 --> 10:21:56,560
this your string is going to be referred

15478
10:21:56,560 --> 10:21:57,276
to

15479
10:21:57,276 --> 10:21:59,680
by message let's try and compile this

15480
10:21:59,680 --> 10:22:02,720
and see that gcc is happy we can compile

15481
10:22:02,720 --> 10:22:04,640
with gcc

15482
10:22:04,640 --> 10:22:06,880
and uh it's going to tell us we can't

15483
10:22:06,880 --> 10:22:09,436
really do that and this is really good

15484
10:22:09,436 --> 10:22:11,680
for base converting a string to constant

15485
10:22:11,680 --> 10:22:14,400
card pointer so what we are doing really

15486
10:22:14,400 --> 10:22:19,040
is making an array of const characters

15487
10:22:19,040 --> 10:22:22,560
and refer to it as a car pointer and

15488
10:22:22,560 --> 10:22:24,320
this is not going to work this is a good

15489
10:22:24,320 --> 10:22:26,640
thing so you can't really do this and

15490
10:22:26,640 --> 10:22:28,560
this is a good thing

15491
10:22:28,560 --> 10:22:32,320
and let's try and see if visual studio

15492
10:22:32,320 --> 10:22:34,320
can actually do this we're going to

15493
10:22:34,320 --> 10:22:37,276
build with msvc in this case let's do

15494
10:22:37,276 --> 10:22:40,080
read to rooster before we do that we can

15495
10:22:40,080 --> 10:22:43,040
right click to add and say delete

15496
10:22:43,040 --> 10:22:45,436
let's click to it first

15497
10:22:45,436 --> 10:22:48,240
make sure it is selected and hit delete

15498
10:22:48,240 --> 10:22:49,596
to remove it

15499
10:22:49,596 --> 10:22:52,000
move to recycle bin in this case

15500
10:22:52,000 --> 10:22:53,840
now we're going to clear here let's

15501
10:22:53,840 --> 10:22:56,640
bring up our terminal again

15502
10:22:56,640 --> 10:22:58,960
and we're going to clear

15503
10:22:58,960 --> 10:23:02,320
and we're going to build with gcc

15504
10:23:02,320 --> 10:23:05,200
we're going to choose the msvc compiler

15505
10:23:05,200 --> 10:23:08,320
if you're trying to build this

15506
10:23:08,320 --> 10:23:10,080
world finish it

15507
10:23:10,080 --> 10:23:12,960
with errors and the error is going to be

15508
10:23:12,960 --> 10:23:15,360
basically the same thing this line here

15509
10:23:15,360 --> 10:23:17,756
won't work what we can do is make this

15510
10:23:17,756 --> 10:23:20,560
cost and make it super clear

15511
10:23:20,560 --> 10:23:23,596
that message here is going to point to

15512
10:23:23,596 --> 10:23:26,080
an array of const car

15513
10:23:26,080 --> 10:23:27,680
if we try to build again i think we're

15514
10:23:27,680 --> 10:23:30,640
going to be good now so let's try and do

15515
10:23:30,640 --> 10:23:31,756
that

15516
10:23:31,756 --> 10:23:35,360
we're going to build with msvc this time

15517
10:23:35,360 --> 10:23:38,240
and world finished successfully

15518
10:23:38,240 --> 10:23:40,240
now this is really cool and we can print

15519
10:23:40,240 --> 10:23:42,960
this out we can say sddc out

15520
10:23:42,960 --> 10:23:44,960
message

15521
10:23:44,960 --> 10:23:48,880
and we're going to say message

15522
10:23:49,360 --> 10:23:51,040
and this is going to work

15523
10:23:51,040 --> 10:23:53,200
let's go back to gcc because that's my

15524
10:23:53,200 --> 10:23:55,120
favorite compiler and you see that the

15525
10:23:55,120 --> 10:23:57,040
compiler from visual studio is going to

15526
10:23:57,040 --> 10:23:59,120
clutter our folder here with a lot of

15527
10:23:59,120 --> 10:24:00,240
files

15528
10:24:00,240 --> 10:24:02,480
we don't want that what i'm going to do

15529
10:24:02,480 --> 10:24:04,320
i'm going to select all this collector

15530
10:24:04,320 --> 10:24:06,880
here and remove that and i'm going to

15531
10:24:06,880 --> 10:24:09,360
hit delete with the right click

15532
10:24:09,360 --> 10:24:11,120
and it's going to go away

15533
10:24:11,120 --> 10:24:14,160
we're going to go back to gcc and use it

15534
10:24:14,160 --> 10:24:16,640
and build with gcc

15535
10:24:16,640 --> 10:24:18,240
the build is going to go through because

15536
10:24:18,240 --> 10:24:21,436
we qualified our character pointer with

15537
10:24:21,436 --> 10:24:24,080
cost here and everything is going to be

15538
10:24:24,080 --> 10:24:25,756
good be sure

15539
10:24:25,756 --> 10:24:28,480
you know what is happening here because

15540
10:24:28,480 --> 10:24:31,040
this kind of problems can be really hard

15541
10:24:31,040 --> 10:24:33,596
to solve okay now that we have this we

15542
10:24:33,596 --> 10:24:35,756
can try and change something inside but

15543
10:24:35,756 --> 10:24:37,756
the compiler is not going to allow it so

15544
10:24:37,756 --> 10:24:40,080
if we try and do something like this is

15545
10:24:40,080 --> 10:24:43,040
not going to work because message is a

15546
10:24:43,040 --> 10:24:45,756
pointer to closed car

15547
10:24:45,756 --> 10:24:47,680
and we can't go through this pointer to

15548
10:24:47,680 --> 10:24:50,480
modify something so we're going to get a

15549
10:24:50,480 --> 10:24:52,160
compiler arrow this is something you

15550
10:24:52,160 --> 10:24:55,680
should know but we can add the reference

15551
10:24:55,680 --> 10:24:58,000
this pointer and print something that is

15552
10:24:58,000 --> 10:25:00,320
inside and i want you to guess again and

15553
10:25:00,320 --> 10:25:02,080
see that you can come up with what is

15554
10:25:02,080 --> 10:25:03,680
going to be printed if with the

15555
10:25:03,680 --> 10:25:06,640
reference message and print out when we

15556
10:25:06,640 --> 10:25:09,436
run this program if we have this thing

15557
10:25:09,436 --> 10:25:11,276
printed out here again we are the

15558
10:25:11,276 --> 10:25:13,276
referencing the pointer

15559
10:25:13,276 --> 10:25:16,160
and printing whatever result we get from

15560
10:25:16,160 --> 10:25:19,916
that remember that this string literal

15561
10:25:19,916 --> 10:25:23,040
is going to be turned into an array of

15562
10:25:23,040 --> 10:25:25,916
const cars and the first element of that

15563
10:25:25,916 --> 10:25:28,320
array is going to be pointed to

15564
10:25:28,320 --> 10:25:32,240
by this message car pointer here so if

15565
10:25:32,240 --> 10:25:35,436
we dereference this thing we should get

15566
10:25:35,436 --> 10:25:37,756
the h here printed out that's what i

15567
10:25:37,756 --> 10:25:39,436
think we should get

15568
10:25:39,436 --> 10:25:41,200
let's try and bolt

15569
10:25:41,200 --> 10:25:43,436
with gcc of course

15570
10:25:43,436 --> 10:25:45,596
the bolt is going to be good let's clear

15571
10:25:45,596 --> 10:25:47,436
and run rooster

15572
10:25:47,436 --> 10:25:50,560
see that message is h this is exactly

15573
10:25:50,560 --> 10:25:52,640
what we expect here now that we have

15574
10:25:52,640 --> 10:25:54,080
this working

15575
10:25:54,080 --> 10:25:57,436
what if we really want this thing here

15576
10:25:57,436 --> 10:25:59,756
to work what if we wanted to allow our

15577
10:25:59,756 --> 10:26:01,680
users to go through

15578
10:26:01,680 --> 10:26:04,320
this message thing and modify what is

15579
10:26:04,320 --> 10:26:06,160
stored inside because sometimes that's

15580
10:26:06,160 --> 10:26:07,276
going to be

15581
10:26:07,276 --> 10:26:10,000
useful okay we wanted to allow our users

15582
10:26:10,000 --> 10:26:11,916
to modify this trend if you want to do

15583
10:26:11,916 --> 10:26:15,680
that you can use row character arrays

15584
10:26:15,680 --> 10:26:17,680
and the way we do that we can say car

15585
10:26:17,680 --> 10:26:20,880
message one and we can make it an array

15586
10:26:20,880 --> 10:26:23,360
and initialize that with hello world and

15587
10:26:23,360 --> 10:26:25,276
once we do this we can go through the

15588
10:26:25,276 --> 10:26:28,400
angle bracket syntax and modify the

15589
10:26:28,400 --> 10:26:31,276
first character or whatever character we

15590
10:26:31,276 --> 10:26:33,200
really want to modify in this string

15591
10:26:33,200 --> 10:26:36,240
here in this case we are going to target

15592
10:26:36,240 --> 10:26:38,240
the first so we're going to say message

15593
10:26:38,240 --> 10:26:42,240
1 and we're going to grab the index 0

15594
10:26:42,240 --> 10:26:43,916
because that's going to be the first

15595
10:26:43,916 --> 10:26:46,240
character here and we're going to assign

15596
10:26:46,240 --> 10:26:48,800
a new character let's say

15597
10:26:48,800 --> 10:26:51,840
b like we just said and if we print this

15598
10:26:51,840 --> 10:26:56,080
out say message one and uh put that out

15599
10:26:56,080 --> 10:26:58,000
we're going to see what comes out if we

15600
10:26:58,000 --> 10:26:59,680
run this program we're going to build

15601
10:26:59,680 --> 10:27:01,120
with gcc

15602
10:27:01,120 --> 10:27:03,436
so let's do that

15603
10:27:03,436 --> 10:27:06,800
the world is good so we're good here

15604
10:27:06,800 --> 10:27:08,640
if we're on we're going to get below

15605
10:27:08,640 --> 10:27:11,040
printed down and we have successfully

15606
10:27:11,040 --> 10:27:13,680
changed this thing here so if you don't

15607
10:27:13,680 --> 10:27:15,596
want to allow modifications to your

15608
10:27:15,596 --> 10:27:18,640
strength use this thing here if you want

15609
10:27:18,640 --> 10:27:21,200
to allow modification to your strength

15610
10:27:21,200 --> 10:27:23,596
use this syntax here and this is really

15611
10:27:23,596 --> 10:27:25,520
all we had to say

15612
10:27:25,520 --> 10:27:27,596
in this lecture in this lecture we're

15613
10:27:27,596 --> 10:27:31,120
going to revisit our idea of a c plus

15614
10:27:31,120 --> 10:27:32,560
plus program

15615
10:27:32,560 --> 10:27:34,960
memory map we have seen that the c plus

15616
10:27:34,960 --> 10:27:37,120
plus development workflow really goes

15617
10:27:37,120 --> 10:27:39,276
like this we have a program typed out in

15618
10:27:39,276 --> 10:27:41,520
our ide we pass that through the

15619
10:27:41,520 --> 10:27:44,320
compiler and we get a binary executable

15620
10:27:44,320 --> 10:27:47,276
which is a binary representation of the

15621
10:27:47,276 --> 10:27:50,320
code we have in our c plus plus program

15622
10:27:50,320 --> 10:27:52,960
you can then run that program on an

15623
10:27:52,960 --> 10:27:55,200
operating system for example here i am

15624
10:27:55,200 --> 10:27:58,480
on windows if i double click on my dot

15625
10:27:58,480 --> 10:28:01,360
exe file for example our applications

15626
10:28:01,360 --> 10:28:02,596
are called

15627
10:28:02,596 --> 10:28:05,520
rooster.exe you've seen me run this a

15628
10:28:05,520 --> 10:28:07,360
thousand times by now

15629
10:28:07,360 --> 10:28:09,596
if we double click this program is going

15630
10:28:09,596 --> 10:28:12,800
to be loaded in our computer memory and

15631
10:28:12,800 --> 10:28:15,680
by memory i mean random access memory

15632
10:28:15,680 --> 10:28:17,756
the memory that is going to be actively

15633
10:28:17,756 --> 10:28:19,840
running things when they happen in your

15634
10:28:19,840 --> 10:28:22,240
computer is different from the hard

15635
10:28:22,240 --> 10:28:23,120
drive

15636
10:28:23,120 --> 10:28:25,436
storage that can also be called memory

15637
10:28:25,436 --> 10:28:27,276
and this can throw off a lot of

15638
10:28:27,276 --> 10:28:30,080
beginners we are talking about ram here

15639
10:28:30,080 --> 10:28:32,240
when we mean memory random access memory

15640
10:28:32,240 --> 10:28:34,480
to be exact if you double click on your

15641
10:28:34,480 --> 10:28:36,880
program or open it on the terminal like

15642
10:28:36,880 --> 10:28:39,276
we've been doing the program is going to

15643
10:28:39,276 --> 10:28:41,680
be loaded in memory and it's going to be

15644
10:28:41,680 --> 10:28:44,880
stored in a special section of memory

15645
10:28:44,880 --> 10:28:47,520
called program area and so far we have

15646
10:28:47,520 --> 10:28:50,160
been thinking that our program is really

15647
10:28:50,160 --> 10:28:53,436
loaded in real memory on our computer

15648
10:28:53,436 --> 10:28:57,276
but that's not the case it is an idea of

15649
10:28:57,276 --> 10:28:59,840
the memory that the program thinks it

15650
10:28:59,840 --> 10:29:02,480
has but it's not the real thing and i am

15651
10:29:02,480 --> 10:29:04,880
going to explain but before we explain

15652
10:29:04,880 --> 10:29:07,680
let me elaborate on the reason why this

15653
10:29:07,680 --> 10:29:10,000
is done if we have many programs and

15654
10:29:10,000 --> 10:29:12,320
each program is going to use real memory

15655
10:29:12,320 --> 10:29:15,436
on our computer we could quickly run out

15656
10:29:15,436 --> 10:29:17,040
of memory because there are many

15657
10:29:17,040 --> 10:29:19,276
programs you might even have hundreds or

15658
10:29:19,276 --> 10:29:20,960
thousands of programs running on your

15659
10:29:20,960 --> 10:29:22,960
computer you may never have enough

15660
10:29:22,960 --> 10:29:26,080
memory to run them all if real memory

15661
10:29:26,080 --> 10:29:28,240
was used by each program

15662
10:29:28,240 --> 10:29:30,400
so the idea was born

15663
10:29:30,400 --> 10:29:31,120
to

15664
10:29:31,120 --> 10:29:34,400
create what is called virtual memory and

15665
10:29:34,400 --> 10:29:36,640
it is a trick that pulls your program

15666
10:29:36,640 --> 10:29:39,120
into thinking it is the only program

15667
10:29:39,120 --> 10:29:41,916
running on your operating systems and it

15668
10:29:41,916 --> 10:29:44,960
owns or the address space or all the

15669
10:29:44,960 --> 10:29:46,720
memory on your computer that's what your

15670
10:29:46,720 --> 10:29:49,680
program thanks and the view that your

15671
10:29:49,680 --> 10:29:52,880
program has of that memory is called a

15672
10:29:52,880 --> 10:29:55,840
memory map each program is abstracted

15673
10:29:55,840 --> 10:29:58,000
into what we call a process you can

15674
10:29:58,000 --> 10:30:00,160
think of rooster.exe

15675
10:30:00,160 --> 10:30:03,360
that we have been welding as a process

15676
10:30:03,360 --> 10:30:05,596
on the system and each process has

15677
10:30:05,596 --> 10:30:08,640
access to the memory range between 0 and

15678
10:30:08,640 --> 10:30:11,436
2 to the power of n where n is the

15679
10:30:11,436 --> 10:30:14,560
number of bits that your operating

15680
10:30:14,560 --> 10:30:17,240
system supports for example i am on a

15681
10:30:17,240 --> 10:30:20,560
64-bit operating system so the range for

15682
10:30:20,560 --> 10:30:23,200
my memory is going to be between 0 and 2

15683
10:30:23,200 --> 10:30:25,916
to the power of 64. and that's a lot of

15684
10:30:25,916 --> 10:30:28,320
memory my program is going to think that

15685
10:30:28,320 --> 10:30:31,276
it owns all that all and it can never

15686
10:30:31,276 --> 10:30:32,880
run out it's going to do whatever it

15687
10:30:32,880 --> 10:30:35,520
wants if you are on a 32-bit system

15688
10:30:35,520 --> 10:30:37,436
that's going to be between 0 and 2 to

15689
10:30:37,436 --> 10:30:39,916
the power of 32 and that's going to be

15690
10:30:39,916 --> 10:30:42,640
your virtual memory the amount of memory

15691
10:30:42,640 --> 10:30:45,596
that your program fans that it owns and

15692
10:30:45,596 --> 10:30:47,680
it happens to be the entirety of your

15693
10:30:47,680 --> 10:30:50,080
ram that you have on your system each

15694
10:30:50,080 --> 10:30:52,720
program basically thinks that it owns

15695
10:30:52,720 --> 10:30:55,276
the entire memory and it can do whatever

15696
10:30:55,276 --> 10:30:58,000
it wants okay so we have the rio memory

15697
10:30:58,000 --> 10:31:00,160
which is random access memory and we

15698
10:31:00,160 --> 10:31:02,720
have virtual memory which is going to be

15699
10:31:02,720 --> 10:31:06,000
between 0 and 2 to the power of n okay

15700
10:31:06,000 --> 10:31:09,680
so now we're going to update on the idea

15701
10:31:09,680 --> 10:31:12,240
of the program execution model because

15702
10:31:12,240 --> 10:31:14,240
now we know more we know about virtual

15703
10:31:14,240 --> 10:31:16,800
memory here is our c plus program it's

15704
10:31:16,800 --> 10:31:18,800
going to go through the compiler and we

15705
10:31:18,800 --> 10:31:21,200
are going to generate a binary file

15706
10:31:21,200 --> 10:31:23,916
which is going to be a representation of

15707
10:31:23,916 --> 10:31:25,916
how things are going to be laid out in

15708
10:31:25,916 --> 10:31:27,916
memory in our program

15709
10:31:27,916 --> 10:31:30,800
and if we run the program

15710
10:31:30,800 --> 10:31:33,200
it is going to go through a section of

15711
10:31:33,200 --> 10:31:36,720
the cpu called memory management unit or

15712
10:31:36,720 --> 10:31:40,800
mmu for short so that mmu is going to be

15713
10:31:40,800 --> 10:31:43,276
basically transforming between the

15714
10:31:43,276 --> 10:31:47,200
memory map of each process and the radio

15715
10:31:47,200 --> 10:31:49,756
memory layout that we have in ram what

15716
10:31:49,756 --> 10:31:51,840
the memory management unit does is

15717
10:31:51,840 --> 10:31:54,320
really transform between the

15718
10:31:54,320 --> 10:31:56,640
representation we have in the memory map

15719
10:31:56,640 --> 10:31:58,800
and the real thing we have in ram the

15720
10:31:58,800 --> 10:32:00,720
entire program is not loaded in real

15721
10:32:00,720 --> 10:32:02,480
memory by the cpu

15722
10:32:02,480 --> 10:32:05,120
only parts of the program that are

15723
10:32:05,120 --> 10:32:07,436
really going to be used soon unloaded in

15724
10:32:07,436 --> 10:32:09,360
memory and this is going to make

15725
10:32:09,360 --> 10:32:12,240
effective use of the memory parts that

15726
10:32:12,240 --> 10:32:14,400
are not likely to be used are going to

15727
10:32:14,400 --> 10:32:17,040
be discarded from memory and stored on

15728
10:32:17,040 --> 10:32:18,720
the hard drive instead and this is

15729
10:32:18,720 --> 10:32:21,520
really cool please note that the real

15730
10:32:21,520 --> 10:32:23,120
way these things are done is really

15731
10:32:23,120 --> 10:32:26,000
complicated but it is buried down into

15732
10:32:26,000 --> 10:32:28,480
the logic of the cpu and whatever you

15733
10:32:28,480 --> 10:32:30,080
don't really need to worry about this as

15734
10:32:30,080 --> 10:32:32,480
a super plus programmer but there are a

15735
10:32:32,480 --> 10:32:34,320
few things you need to know as we are

15736
10:32:34,320 --> 10:32:36,880
about to see in this lecture so memory

15737
10:32:36,880 --> 10:32:39,840
management unit helps out in mapping

15738
10:32:39,840 --> 10:32:40,960
between

15739
10:32:40,960 --> 10:32:42,880
the memory map you have in your program

15740
10:32:42,880 --> 10:32:46,160
basically the idea that your program has

15741
10:32:46,160 --> 10:32:49,120
of memory and the real thing

15742
10:32:49,120 --> 10:32:51,916
that we have in memory okay here is a

15743
10:32:51,916 --> 10:32:53,756
slide that is going to drive this home

15744
10:32:53,756 --> 10:32:56,560
we have a few programs with their own

15745
10:32:56,560 --> 10:32:59,120
separate memory maps we have program one

15746
10:32:59,120 --> 10:33:00,320
through four

15747
10:33:00,320 --> 10:33:02,480
if we execute them they are going to go

15748
10:33:02,480 --> 10:33:05,360
through the memory management unit and

15749
10:33:05,360 --> 10:33:07,276
the memory management unit is going to

15750
10:33:07,276 --> 10:33:10,160
assign them sections on the real

15751
10:33:10,160 --> 10:33:12,000
ram that we have in our computer and

15752
10:33:12,000 --> 10:33:14,800
they are going to be using that section

15753
10:33:14,800 --> 10:33:17,360
on the real random access memory that we

15754
10:33:17,360 --> 10:33:19,436
have on our computer the thing is your

15755
10:33:19,436 --> 10:33:22,320
program is going to really think it owns

15756
10:33:22,320 --> 10:33:23,916
the entire thing

15757
10:33:23,916 --> 10:33:26,080
but it's not just going to be using a

15758
10:33:26,080 --> 10:33:28,240
part of it and the memory management

15759
10:33:28,240 --> 10:33:30,800
unit is going to be transforming between

15760
10:33:30,800 --> 10:33:33,596
the idea that your program has and the

15761
10:33:33,596 --> 10:33:36,320
real memory that we have on our computer

15762
10:33:36,320 --> 10:33:39,040
and the memory map is a standard format

15763
10:33:39,040 --> 10:33:41,840
that is defined by the operating system

15764
10:33:41,840 --> 10:33:43,916
this is why for example you can't take

15765
10:33:43,916 --> 10:33:46,960
an executable that was set up on windows

15766
10:33:46,960 --> 10:33:49,436
and directly run it on linux this is an

15767
10:33:49,436 --> 10:33:52,160
operating system thing the memory map or

15768
10:33:52,160 --> 10:33:55,200
the structure of your program is defined

15769
10:33:55,200 --> 10:33:57,520
by the operating system that is going to

15770
10:33:57,520 --> 10:34:01,200
be running that program so all program

15771
10:34:01,200 --> 10:34:03,360
written for an operating system must

15772
10:34:03,360 --> 10:34:05,916
conform to the memory map that is

15773
10:34:05,916 --> 10:34:08,640
defined by that operating system so all

15774
10:34:08,640 --> 10:34:11,040
programs on windows if you had a way to

15775
10:34:11,040 --> 10:34:13,436
go in and look at the memory map they

15776
10:34:13,436 --> 10:34:15,360
are going to be pretty similar so we

15777
10:34:15,360 --> 10:34:17,436
have been talking about the memory map

15778
10:34:17,436 --> 10:34:18,160
but

15779
10:34:18,160 --> 10:34:20,080
what does it look like

15780
10:34:20,080 --> 10:34:22,720
well here is a slide that is going to

15781
10:34:22,720 --> 10:34:25,040
try and clear that out so we're going to

15782
10:34:25,040 --> 10:34:27,276
have a bunch of memory locations from 0

15783
10:34:27,276 --> 10:34:29,916
all the way to 2 to the power of m

15784
10:34:29,916 --> 10:34:32,080
and the memory map is really divided

15785
10:34:32,080 --> 10:34:34,720
into a lot of parts for example we have

15786
10:34:34,720 --> 10:34:36,320
the text section we have the data

15787
10:34:36,320 --> 10:34:38,080
section we have the heap stack and

15788
10:34:38,080 --> 10:34:39,040
system

15789
10:34:39,040 --> 10:34:41,120
and this is one view you can have on

15790
10:34:41,120 --> 10:34:43,360
this there are a few different versions

15791
10:34:43,360 --> 10:34:45,120
of this slide that you're going to see

15792
10:34:45,120 --> 10:34:47,120
on the internet but what is really

15793
10:34:47,120 --> 10:34:50,640
important is stack and hip for our

15794
10:34:50,640 --> 10:34:53,276
purposes here stack is what is going to

15795
10:34:53,276 --> 10:34:56,480
store our local variables thank the a

15796
10:34:56,480 --> 10:34:59,360
that we have here in main bc thanks we

15797
10:34:59,360 --> 10:35:01,680
had inside functions those things are

15798
10:35:01,680 --> 10:35:05,120
stored inside the stack section of our

15799
10:35:05,120 --> 10:35:06,400
memory map

15800
10:35:06,400 --> 10:35:08,880
besides the stack we also have the hip

15801
10:35:08,880 --> 10:35:10,880
which is going to be the location where

15802
10:35:10,880 --> 10:35:13,596
we get additional memory we can use to

15803
10:35:13,596 --> 10:35:16,080
make things better for our program we

15804
10:35:16,080 --> 10:35:17,840
also have the text section which is

15805
10:35:17,840 --> 10:35:20,400
going to load the actual binary of our

15806
10:35:20,400 --> 10:35:23,120
program so that the cpu can execute it

15807
10:35:23,120 --> 10:35:24,880
but we're not going to worry too much

15808
10:35:24,880 --> 10:35:26,560
about this section in this course

15809
10:35:26,560 --> 10:35:28,880
because it is out of scope for

15810
10:35:28,880 --> 10:35:31,040
what we are trying to do here we are

15811
10:35:31,040 --> 10:35:33,840
going to focus on stack and hip because

15812
10:35:33,840 --> 10:35:35,520
hip is actually going to be very

15813
10:35:35,520 --> 10:35:38,480
important from the next lecture when we

15814
10:35:38,480 --> 10:35:41,200
start talking about dynamic memory hip

15815
10:35:41,200 --> 10:35:43,120
is going to be additional memory that

15816
10:35:43,120 --> 10:35:45,276
you can use in your program if you run

15817
10:35:45,276 --> 10:35:47,360
out of stack memory and we're going to

15818
10:35:47,360 --> 10:35:49,436
see a few other reasons why you might

15819
10:35:49,436 --> 10:35:51,916
want to use this as we progress in this

15820
10:35:51,916 --> 10:35:54,240
chapter so our memory map is going to

15821
10:35:54,240 --> 10:35:57,436
have a lot of parts but the parts that

15822
10:35:57,436 --> 10:35:59,916
we really care about in this course are

15823
10:35:59,916 --> 10:36:02,480
stack and heap this is really all we set

15824
10:36:02,480 --> 10:36:04,000
out to do in this lecture i hope you

15825
10:36:04,000 --> 10:36:06,480
have a better idea of the memory map and

15826
10:36:06,480 --> 10:36:09,200
how this really works we introduced

15827
10:36:09,200 --> 10:36:11,596
another view that you can have on how

15828
10:36:11,596 --> 10:36:14,800
your c plus plus program is executed and

15829
10:36:14,800 --> 10:36:16,720
i hope you have a better idea of the

15830
10:36:16,720 --> 10:36:18,800
memory system and we are going to start

15831
10:36:18,800 --> 10:36:21,436
and see how you can work with dynamic

15832
10:36:21,436 --> 10:36:23,840
memory allocation which is going to

15833
10:36:23,840 --> 10:36:25,520
really use the heap

15834
10:36:25,520 --> 10:36:27,596
starting in the next lecture

15835
10:36:27,596 --> 10:36:30,000
go ahead and finish up here and meet me

15836
10:36:30,000 --> 10:36:30,880
there

15837
10:36:30,880 --> 10:36:32,800
in this lecture we're going to start and

15838
10:36:32,800 --> 10:36:36,080
learn about dynamic memory allocation

15839
10:36:36,080 --> 10:36:38,480
and this is a technique we can use to

15840
10:36:38,480 --> 10:36:42,080
start using hip storage that we have in

15841
10:36:42,080 --> 10:36:44,400
the memory map of our c plus plus

15842
10:36:44,400 --> 10:36:46,480
program we can use that to get

15843
10:36:46,480 --> 10:36:48,560
additional memory we can use and do

15844
10:36:48,560 --> 10:36:51,840
stuff if stack memory isn't enough for

15845
10:36:51,840 --> 10:36:54,080
our purposes this is how we have been

15846
10:36:54,080 --> 10:36:56,080
using pointers so far for example we

15847
10:36:56,080 --> 10:36:58,320
have a variable we set up a pointer and

15848
10:36:58,320 --> 10:37:00,960
we store the address of the variable n

15849
10:37:00,960 --> 10:37:03,840
so we can go ahead and use this pointer

15850
10:37:03,840 --> 10:37:06,480
to manipulate the variable or do all

15851
10:37:06,480 --> 10:37:08,880
kinds of crazy things if you go down

15852
10:37:08,880 --> 10:37:11,756
here we have a pointer p number one

15853
10:37:11,756 --> 10:37:14,400
and we have a number one variable and we

15854
10:37:14,400 --> 10:37:16,640
can store the address of number one into

15855
10:37:16,640 --> 10:37:18,720
this pointer it's really the same thing

15856
10:37:18,720 --> 10:37:21,520
like we have on top here but the pointer

15857
10:37:21,520 --> 10:37:24,800
is not initialized at declaration here

15858
10:37:24,800 --> 10:37:26,400
and you have to make sure you put

15859
10:37:26,400 --> 10:37:28,480
invalid data and one thing i haven't

15860
10:37:28,480 --> 10:37:30,960
really stressed enough is that it is

15861
10:37:30,960 --> 10:37:32,320
really bad

15862
10:37:32,320 --> 10:37:34,800
really bad to try and use a pointer that

15863
10:37:34,800 --> 10:37:37,360
is not initialized for example here we

15864
10:37:37,360 --> 10:37:39,916
have p number two which is a pointer it

15865
10:37:39,916 --> 10:37:43,200
is not initialized it contains junk

15866
10:37:43,200 --> 10:37:47,200
and we try and write into it okay so try

15867
10:37:47,200 --> 10:37:49,276
to think about what we really are doing

15868
10:37:49,276 --> 10:37:51,120
here this is a pointer that we have set

15869
10:37:51,120 --> 10:37:54,160
up we haven't really initialized that so

15870
10:37:54,160 --> 10:37:56,480
it's going to contain whatever address

15871
10:37:56,480 --> 10:37:58,800
is possible it can contain an address

15872
10:37:58,800 --> 10:38:00,800
that is used by another program it may

15873
10:38:00,800 --> 10:38:02,640
contain an address that is being used by

15874
10:38:02,640 --> 10:38:04,800
the operating system it's not your

15875
10:38:04,800 --> 10:38:07,680
address to mess with and here we are

15876
10:38:07,680 --> 10:38:09,520
actually trying to mess with that by

15877
10:38:09,520 --> 10:38:13,276
storing in a 55 so this is going to

15878
10:38:13,276 --> 10:38:16,080
cause the crash possibly or even

15879
10:38:16,080 --> 10:38:18,560
corrupt data that is being used by other

15880
10:38:18,560 --> 10:38:21,276
people so don't do this another thing is

15881
10:38:21,276 --> 10:38:23,436
to try and use a pointer that is

15882
10:38:23,436 --> 10:38:25,916
initialized to know for example here we

15883
10:38:25,916 --> 10:38:29,200
have a pointer p number three and it is

15884
10:38:29,200 --> 10:38:31,360
braced initialized this is going to

15885
10:38:31,360 --> 10:38:34,000
initialize it to null pointer but we are

15886
10:38:34,000 --> 10:38:37,276
trying and storing in a value here so

15887
10:38:37,276 --> 10:38:39,360
this is also going to be bad it's not

15888
10:38:39,360 --> 10:38:40,960
granted what you're going to get

15889
10:38:40,960 --> 10:38:43,120
actually c plus doesn't give you any

15890
10:38:43,120 --> 10:38:45,120
guarantees this is called undefined

15891
10:38:45,120 --> 10:38:47,200
behavior so you're going to get a crash

15892
10:38:47,200 --> 10:38:50,160
and don't do it as a good practice the

15893
10:38:50,160 --> 10:38:51,916
first thing you should do is initialize

15894
10:38:51,916 --> 10:38:53,200
your pointers

15895
10:38:53,200 --> 10:38:55,520
before you use them you can initialize

15896
10:38:55,520 --> 10:38:58,800
them with no pointer and make sure that

15897
10:38:58,800 --> 10:39:00,000
you are

15898
10:39:00,000 --> 10:39:02,720
modifying valid addresses into those

15899
10:39:02,720 --> 10:39:04,400
pointers if you don't know what is in a

15900
10:39:04,400 --> 10:39:06,960
pointer don't use that pointer because

15901
10:39:06,960 --> 10:39:09,520
bad things can happen okay rule number

15902
10:39:09,520 --> 10:39:12,080
one don't try to use a pointer that you

15903
10:39:12,080 --> 10:39:13,680
didn't initialize

15904
10:39:13,680 --> 10:39:16,720
rule number two don't try to work with a

15905
10:39:16,720 --> 10:39:19,436
pointer that is pointing to no ptr

15906
10:39:19,436 --> 10:39:21,120
that's going to give you bad things you

15907
10:39:21,120 --> 10:39:23,276
don't want to really deal with okay so

15908
10:39:23,276 --> 10:39:26,080
far we have been using memory that lives

15909
10:39:26,080 --> 10:39:28,880
on the stack section of our memory map

15910
10:39:28,880 --> 10:39:30,800
we were using variables that we have

15911
10:39:30,800 --> 10:39:32,960
declared in the main function we were

15912
10:39:32,960 --> 10:39:34,640
using the variables that we have

15913
10:39:34,640 --> 10:39:37,200
declared inside some functions and

15914
10:39:37,200 --> 10:39:39,756
that's all stuff that live on the stack

15915
10:39:39,756 --> 10:39:41,520
now we want to see how we can use the

15916
10:39:41,520 --> 10:39:44,240
hip okay let's take a closer look at our

15917
10:39:44,240 --> 10:39:46,800
memory map we have the stack we have the

15918
10:39:46,800 --> 10:39:47,596
heap

15919
10:39:47,596 --> 10:39:49,436
and the differences between these two

15920
10:39:49,436 --> 10:39:50,880
guys are

15921
10:39:50,880 --> 10:39:52,480
laid out here

15922
10:39:52,480 --> 10:39:55,756
the stack memory is finite so you don't

15923
10:39:55,756 --> 10:39:58,720
have infinite memory but the same is

15924
10:39:58,720 --> 10:40:00,960
true for the heap but hip is additional

15925
10:40:00,960 --> 10:40:03,200
memory that you can use if you don't

15926
10:40:03,200 --> 10:40:05,680
want to run out of stock memory for a

15927
10:40:05,680 --> 10:40:08,400
stack memory the developer isn't in full

15928
10:40:08,400 --> 10:40:11,680
control of the memory lifetime so if you

15929
10:40:11,680 --> 10:40:13,680
declare something on the stack for

15930
10:40:13,680 --> 10:40:16,480
example if you say int var1 and you

15931
10:40:16,480 --> 10:40:19,520
initialize that to 23 you don't control

15932
10:40:19,520 --> 10:40:22,000
when that variable is wiped out of

15933
10:40:22,000 --> 10:40:24,320
memory the variable is going to be

15934
10:40:24,320 --> 10:40:26,800
killed when the scope in which it was

15935
10:40:26,800 --> 10:40:29,840
declared is going to run out

15936
10:40:29,840 --> 10:40:32,560
and you developer don't really say when

15937
10:40:32,560 --> 10:40:34,720
the variable dies and sometimes you

15938
10:40:34,720 --> 10:40:36,480
really want to control

15939
10:40:36,480 --> 10:40:38,240
when your variable dies so this is a

15940
10:40:38,240 --> 10:40:40,880
limitation we have with the stack memory

15941
10:40:40,880 --> 10:40:42,960
okay so for stack memory lifetime is

15942
10:40:42,960 --> 10:40:44,720
controlled by the scope mechanism we

15943
10:40:44,720 --> 10:40:47,916
just say that for heap the developer is

15944
10:40:47,916 --> 10:40:50,720
in full control of when the variable

15945
10:40:50,720 --> 10:40:53,520
comes to life and when the variable dies

15946
10:40:53,520 --> 10:40:55,200
and this is a benefit you might have

15947
10:40:55,200 --> 10:40:57,756
with heap storage and you might want to

15948
10:40:57,756 --> 10:40:59,276
use this and we're going to see how we

15949
10:40:59,276 --> 10:41:01,840
can use that in the next few lectures

15950
10:41:01,840 --> 10:41:03,436
okay so make sure you understand the

15951
10:41:03,436 --> 10:41:05,756
difference between stack and hip here if

15952
10:41:05,756 --> 10:41:07,436
you look at the example here we have a

15953
10:41:07,436 --> 10:41:10,240
variable which is called locoscope var

15954
10:41:10,240 --> 10:41:13,276
it is stored within this block delimited

15955
10:41:13,276 --> 10:41:16,000
by the curly braces and the variable is

15956
10:41:16,000 --> 10:41:17,756
going to come to life when this

15957
10:41:17,756 --> 10:41:20,720
statement is executed but it is going to

15958
10:41:20,720 --> 10:41:21,520
die

15959
10:41:21,520 --> 10:41:24,640
when we hit the closing curly brace here

15960
10:41:24,640 --> 10:41:26,640
so the lifetime of this variable is

15961
10:41:26,640 --> 10:41:29,840
controlled by the scope mechanism but it

15962
10:41:29,840 --> 10:41:33,116
is possible to use dynamic memory or use

15963
10:41:33,116 --> 10:41:34,720
memory on the heap and we're going to

15964
10:41:34,720 --> 10:41:37,116
see a syntax you can use to do that the

15965
10:41:37,116 --> 10:41:38,880
first thing we want to do it to set up

15966
10:41:38,880 --> 10:41:41,116
employer that is going to be pointing to

15967
10:41:41,116 --> 10:41:44,240
that heap allocated memory the way you

15968
10:41:44,240 --> 10:41:45,840
do that you set up a pointer here we

15969
10:41:45,840 --> 10:41:48,640
have p number four we initialize it with

15970
10:41:48,640 --> 10:41:50,160
no ptr

15971
10:41:50,160 --> 10:41:52,880
but what we do to allocate memory is the

15972
10:41:52,880 --> 10:41:54,960
second statement here we say p number

15973
10:41:54,960 --> 10:41:58,240
four and we say new end

15974
10:41:58,240 --> 10:42:00,400
the moment this statement is going to be

15975
10:42:00,400 --> 10:42:03,040
executed the operating system is going

15976
10:42:03,040 --> 10:42:06,080
to allocate a piece of memory on the

15977
10:42:06,080 --> 10:42:07,840
heap the memory is going to be large

15978
10:42:07,840 --> 10:42:10,000
enough to accommodate for an integer so

15979
10:42:10,000 --> 10:42:12,160
it's going to be four bytes long

15980
10:42:12,160 --> 10:42:14,320
and it is your memory now your program

15981
10:42:14,320 --> 10:42:16,880
can use it to do whatever it wants and

15982
10:42:16,880 --> 10:42:19,116
no other program on the system can use

15983
10:42:19,116 --> 10:42:21,520
this piece of memory so it is going to

15984
10:42:21,520 --> 10:42:25,276
be yours until you explicitly return

15985
10:42:25,276 --> 10:42:27,520
this piece of memory to the system and

15986
10:42:27,520 --> 10:42:29,040
we're going to see how you can do that

15987
10:42:29,040 --> 10:42:31,436
in a minute once this memory is yours

15988
10:42:31,436 --> 10:42:33,436
you can use it you see here we already

15989
10:42:33,436 --> 10:42:35,200
referencing the memory and the story

15990
10:42:35,200 --> 10:42:37,680
again is 77 and if we're trying to print

15991
10:42:37,680 --> 10:42:39,680
this 77 we're going to get it printed

15992
10:42:39,680 --> 10:42:41,916
out okay this is how you can use dynamic

15993
10:42:41,916 --> 10:42:44,480
memory and when you do this

15994
10:42:44,480 --> 10:42:47,596
things are not being stored on the stack

15995
10:42:47,596 --> 10:42:49,756
things are being stored on the heap i

15996
10:42:49,756 --> 10:42:51,360
really hope you understand this because

15997
10:42:51,360 --> 10:42:54,640
it is very important okay so here is our

15998
10:42:54,640 --> 10:42:58,000
view of stack and heap so if you use new

15999
10:42:58,000 --> 10:43:00,560
to allocate for memory stuff are going

16000
10:43:00,560 --> 10:43:03,840
to be stored in this hip section here of

16001
10:43:03,840 --> 10:43:06,160
your memory map here is another example

16002
10:43:06,160 --> 10:43:08,880
to try and understand the lifetime of

16003
10:43:08,880 --> 10:43:11,840
our variables docovar again is limited

16004
10:43:11,840 --> 10:43:13,756
to this scope it is going to come into

16005
10:43:13,756 --> 10:43:15,756
life when this statement here is

16006
10:43:15,756 --> 10:43:19,040
executed and it is going to die when we

16007
10:43:19,040 --> 10:43:21,520
run out of this scope here so if you try

16008
10:43:21,520 --> 10:43:24,320
executing code out of this scope locovar

16009
10:43:24,320 --> 10:43:26,480
is no longer going to be available you

16010
10:43:26,480 --> 10:43:29,360
can't use it but that's not the case for

16011
10:43:29,360 --> 10:43:33,116
locro ptr var because this is a pointer

16012
10:43:33,116 --> 10:43:35,040
it lives on the heap

16013
10:43:35,040 --> 10:43:38,160
and if you go out of this scope the

16014
10:43:38,160 --> 10:43:40,720
memory is still going to be yours if you

16015
10:43:40,720 --> 10:43:42,800
have a way you can access it and use it

16016
10:43:42,800 --> 10:43:44,960
you're going to be able to use it and it

16017
10:43:44,960 --> 10:43:48,320
is going to be yours until you decide to

16018
10:43:48,320 --> 10:43:50,960
return it to the operating system so we

16019
10:43:50,960 --> 10:43:52,880
have been talking about returning the

16020
10:43:52,880 --> 10:43:54,560
memory to the system

16021
10:43:54,560 --> 10:43:57,756
how do we do it well you use the delete

16022
10:43:57,756 --> 10:44:00,400
keyword in c plus plus here we have our

16023
10:44:00,400 --> 10:44:03,200
memory which is allocated using new and

16024
10:44:03,200 --> 10:44:05,520
so the operating system is going to give

16025
10:44:05,520 --> 10:44:07,840
us a new piece of memory it is going to

16026
10:44:07,840 --> 10:44:09,436
be four bytes because we're going to

16027
10:44:09,436 --> 10:44:11,596
store in an integer and we are going to

16028
10:44:11,596 --> 10:44:14,000
be pointing to that memory through p

16029
10:44:14,000 --> 10:44:16,320
number four here we can use this memory

16030
10:44:16,320 --> 10:44:18,160
however we want through the referencing

16031
10:44:18,160 --> 10:44:20,320
and do all kinds of crazy things and

16032
10:44:20,320 --> 10:44:22,480
when we are done with this memory we are

16033
10:44:22,480 --> 10:44:24,640
going to say delete p number four and

16034
10:44:24,640 --> 10:44:26,400
this statement is going to return the

16035
10:44:26,400 --> 10:44:28,080
memory to the operating system the

16036
10:44:28,080 --> 10:44:30,720
memory is no longer going to be hours

16037
10:44:30,720 --> 10:44:33,276
after this statement and a good thing to

16038
10:44:33,276 --> 10:44:35,916
do after you release your memory is to

16039
10:44:35,916 --> 10:44:37,680
reset it to

16040
10:44:37,680 --> 10:44:40,640
no ptr so that other people know that

16041
10:44:40,640 --> 10:44:43,360
you don't really have any valid data in

16042
10:44:43,360 --> 10:44:46,560
that memory because if you try to use a

16043
10:44:46,560 --> 10:44:47,840
deleted

16044
10:44:47,840 --> 10:44:50,080
memory section bad things are going to

16045
10:44:50,080 --> 10:44:51,596
happen that's not going to be your

16046
10:44:51,596 --> 10:44:53,680
memory we're going to fall into the same

16047
10:44:53,680 --> 10:44:55,520
problem of trying to use an

16048
10:44:55,520 --> 10:44:58,160
uninitialized piece of memory don't do

16049
10:44:58,160 --> 10:45:01,200
that so whenever you release memory also

16050
10:45:01,200 --> 10:45:04,240
reset it to no ptr to play it safe we

16051
10:45:04,240 --> 10:45:06,640
can also initialize our pointers with

16052
10:45:06,640 --> 10:45:09,360
dynamic memory when we declare them and

16053
10:45:09,360 --> 10:45:11,276
this is how you can do it we say p

16054
10:45:11,276 --> 10:45:14,080
number five and we initialize that with

16055
10:45:14,080 --> 10:45:15,916
new and this is going to give us a new

16056
10:45:15,916 --> 10:45:18,640
piece of memory on the heap and it is

16057
10:45:18,640 --> 10:45:21,040
going to be pointed to by p number five

16058
10:45:21,040 --> 10:45:23,436
we get the same thing here but uh here

16059
10:45:23,436 --> 10:45:25,840
we are just pointing in new values and p

16060
10:45:25,840 --> 10:45:27,276
number six and p

16061
10:45:27,276 --> 10:45:29,840
number seven the memory locations on the

16062
10:45:29,840 --> 10:45:32,320
heap are going to be containing 22 and

16063
10:45:32,320 --> 10:45:35,756
23 for p number six and p number seven

16064
10:45:35,756 --> 10:45:38,000
and here we have a few examples of how

16065
10:45:38,000 --> 10:45:40,400
we can print the contents of these

16066
10:45:40,400 --> 10:45:43,436
memory locations on htdc out

16067
10:45:43,436 --> 10:45:46,480
and after you are done using your hip

16068
10:45:46,480 --> 10:45:49,200
memory you're going to release it using

16069
10:45:49,200 --> 10:45:51,360
the delete keyword and you are going to

16070
10:45:51,360 --> 10:45:54,320
reset that to no ptr to really play it

16071
10:45:54,320 --> 10:45:57,040
safe this is how you should use dynamic

16072
10:45:57,040 --> 10:46:00,080
memory allocated on the heap another

16073
10:46:00,080 --> 10:46:02,560
thing you should know is that it is

16074
10:46:02,560 --> 10:46:05,916
really bad to call delete twice on a

16075
10:46:05,916 --> 10:46:08,080
pointer so here we have a memory

16076
10:46:08,080 --> 10:46:10,160
location that we allocate on the heap we

16077
10:46:10,160 --> 10:46:12,560
stored this in a pointer and

16078
10:46:12,560 --> 10:46:15,840
we are trying to use it here in sddc

16079
10:46:15,840 --> 10:46:18,160
outputting whatever is inside

16080
10:46:18,160 --> 10:46:20,240
and if we delete it for the first time

16081
10:46:20,240 --> 10:46:21,756
that's going to be cool it is going to

16082
10:46:21,756 --> 10:46:23,916
be returned to the system but if you try

16083
10:46:23,916 --> 10:46:26,320
to delete it for the second time you're

16084
10:46:26,320 --> 10:46:28,640
going to get a crash don't do this this

16085
10:46:28,640 --> 10:46:31,200
is really bad okay now that we have a

16086
10:46:31,200 --> 10:46:34,320
slightly clearer idea about pointers and

16087
10:46:34,320 --> 10:46:36,960
dynamic memory allocation i think it is

16088
10:46:36,960 --> 10:46:38,960
time we went to visual studio code and

16089
10:46:38,960 --> 10:46:40,960
actually played with a few of these

16090
10:46:40,960 --> 10:46:44,000
concepts here we are in our working

16091
10:46:44,000 --> 10:46:46,400
directory the current project is dynamic

16092
10:46:46,400 --> 10:46:48,480
memory allocation we're going to grab

16093
10:46:48,480 --> 10:46:50,640
our template files and we're going to

16094
10:46:50,640 --> 10:46:52,960
put them in place dynamic memory

16095
10:46:52,960 --> 10:46:55,276
allocation let's do that and we're going

16096
10:46:55,276 --> 10:46:57,520
to open this in visual studio code the

16097
10:46:57,520 --> 10:46:59,360
first thing we're going to do is review

16098
10:46:59,360 --> 10:47:02,080
how we have been using players so far

16099
10:47:02,080 --> 10:47:04,080
we have been using them like this we had

16100
10:47:04,080 --> 10:47:06,560
a variable stored somewhere on the stack

16101
10:47:06,560 --> 10:47:09,200
again this is the stack memory that we

16102
10:47:09,200 --> 10:47:11,840
are using here and we

16103
10:47:11,840 --> 10:47:14,080
stored addresses of some variables you

16104
10:47:14,080 --> 10:47:16,080
know pointers something like this and we

16105
10:47:16,080 --> 10:47:17,360
could go through the pointer to

16106
10:47:17,360 --> 10:47:19,360
manipulate that memory location for

16107
10:47:19,360 --> 10:47:20,320
example

16108
10:47:20,320 --> 10:47:22,240
we can print the address of that memory

16109
10:47:22,240 --> 10:47:24,400
we can even the reference and print the

16110
10:47:24,400 --> 10:47:26,000
value in here

16111
10:47:26,000 --> 10:47:29,360
by doing something like we do here and

16112
10:47:29,360 --> 10:47:31,360
we are not printing here so let's say

16113
10:47:31,360 --> 10:47:33,596
that and say p number we can do

16114
10:47:33,596 --> 10:47:35,360
something like this and we have been

16115
10:47:35,360 --> 10:47:38,880
doing this quite a lot so far we can

16116
10:47:38,880 --> 10:47:40,720
also have a piece of memory that is

16117
10:47:40,720 --> 10:47:43,520
uninitialized and we store the address

16118
10:47:43,520 --> 10:47:46,080
of some variable in that piece of memory

16119
10:47:46,080 --> 10:47:47,916
and we can do the same thing for example

16120
10:47:47,916 --> 10:47:49,520
if we print p number one we're going to

16121
10:47:49,520 --> 10:47:52,480
get the value 12 printed out here and we

16122
10:47:52,480 --> 10:47:54,400
could run this so let's try and do that

16123
10:47:54,400 --> 10:47:56,640
we're going to bring up a terminal first

16124
10:47:56,640 --> 10:47:58,720
and close this pane so that we have some

16125
10:47:58,720 --> 10:48:01,276
breathing room and we are going to build

16126
10:48:01,276 --> 10:48:04,320
with gcc like we always do

16127
10:48:04,320 --> 10:48:06,640
we're going to build successfully going

16128
10:48:06,640 --> 10:48:08,720
to clear and run rooster and we're going

16129
10:48:08,720 --> 10:48:10,640
to see that we have these things printed

16130
10:48:10,640 --> 10:48:13,040
out here the variable we have in here is

16131
10:48:13,040 --> 10:48:14,960
22 so we're going to get that if we

16132
10:48:14,960 --> 10:48:17,040
print the variable directly

16133
10:48:17,040 --> 10:48:18,720
if we print pointer we're going to get

16134
10:48:18,720 --> 10:48:20,880
the address printed out we can also go

16135
10:48:20,880 --> 10:48:23,276
through the address of operator to print

16136
10:48:23,276 --> 10:48:26,320
the address of this variable here but we

16137
10:48:26,320 --> 10:48:28,480
can also print our value through the

16138
10:48:28,480 --> 10:48:31,116
referencing our pointer and we can get

16139
10:48:31,116 --> 10:48:33,200
access to it here down here we have a

16140
10:48:33,200 --> 10:48:35,520
pointer that is not initialized so it

16141
10:48:35,520 --> 10:48:37,520
will contain a junk address that you

16142
10:48:37,520 --> 10:48:39,756
shouldn't really use but we're not going

16143
10:48:39,756 --> 10:48:41,596
to do that because we're going to store

16144
10:48:41,596 --> 10:48:44,480
in the address of number one here and we

16145
10:48:44,480 --> 10:48:47,200
can manipulate the value here through

16146
10:48:47,200 --> 10:48:50,080
the pointer using the the reference

16147
10:48:50,080 --> 10:48:52,320
operator here and if we print this p

16148
10:48:52,320 --> 10:48:54,800
number one we're going to get 12 printed

16149
10:48:54,800 --> 10:48:57,200
out this is pretty cool okay so this is

16150
10:48:57,200 --> 10:49:00,640
how we have been using pointers so far

16151
10:49:00,640 --> 10:49:02,320
let's comment this out because we're

16152
10:49:02,320 --> 10:49:04,240
going to see some other things okay

16153
10:49:04,240 --> 10:49:06,640
before we really look at how dynamic

16154
10:49:06,640 --> 10:49:08,800
memory works we are going to show you a

16155
10:49:08,800 --> 10:49:11,680
few bad things you need to be aware of

16156
10:49:11,680 --> 10:49:13,916
so let's put in a piece of code for us

16157
10:49:13,916 --> 10:49:15,276
to play with

16158
10:49:15,276 --> 10:49:18,360
and here we are saying that writing into

16159
10:49:18,360 --> 10:49:21,520
uninitialized memory is really bad so

16160
10:49:21,520 --> 10:49:23,276
here we have a pointer it is

16161
10:49:23,276 --> 10:49:25,840
uninitialized and we are trying and

16162
10:49:25,840 --> 10:49:28,240
directly right into it through the

16163
10:49:28,240 --> 10:49:30,560
reference and this is going to be bad

16164
10:49:30,560 --> 10:49:31,756
you see that

16165
10:49:31,756 --> 10:49:34,240
visual studio code is not complaining it

16166
10:49:34,240 --> 10:49:36,480
thinks that we know what we are doing

16167
10:49:36,480 --> 10:49:39,116
here and it's not going to warn us but

16168
10:49:39,116 --> 10:49:41,200
this pointer could really be pointing

16169
10:49:41,200 --> 10:49:43,840
anywhere including operating system

16170
10:49:43,840 --> 10:49:46,080
specific memory and here you may be

16171
10:49:46,080 --> 10:49:47,360
trying to

16172
10:49:47,360 --> 10:49:50,080
modify things that your operating system

16173
10:49:50,080 --> 10:49:53,040
is going to need so clearly the

16174
10:49:53,040 --> 10:49:54,720
operating system is not going to be

16175
10:49:54,720 --> 10:49:57,276
happy about this and the bad things can

16176
10:49:57,276 --> 10:49:59,040
happen to this program

16177
10:49:59,040 --> 10:50:01,040
so now we have this memory location

16178
10:50:01,040 --> 10:50:03,116
we're going to try and write into it and

16179
10:50:03,116 --> 10:50:04,720
we're going to see what happens if we

16180
10:50:04,720 --> 10:50:07,040
run this program for now let's try and

16181
10:50:07,040 --> 10:50:08,640
take this little section here and

16182
10:50:08,640 --> 10:50:10,560
comment it out

16183
10:50:10,560 --> 10:50:13,756
and we want to see what happens on the

16184
10:50:13,756 --> 10:50:16,160
program here the code here that we might

16185
10:50:16,160 --> 10:50:17,756
want to run

16186
10:50:17,756 --> 10:50:20,800
let's try and build it with gcc we're

16187
10:50:20,800 --> 10:50:23,200
going to run the task to do that

16188
10:50:23,200 --> 10:50:24,720
the build is going to be good you see

16189
10:50:24,720 --> 10:50:26,720
that we don't even get a compiler error

16190
10:50:26,720 --> 10:50:28,960
and if we're trying to run rooster you

16191
10:50:28,960 --> 10:50:30,640
see that the program is going to try and

16192
10:50:30,640 --> 10:50:32,560
run you know the operating system is

16193
10:50:32,560 --> 10:50:34,640
going to say this guy doesn't know what

16194
10:50:34,640 --> 10:50:37,116
they are doing and i am going to close

16195
10:50:37,116 --> 10:50:39,596
them you see that it's not even

16196
10:50:39,596 --> 10:50:40,640
running

16197
10:50:40,640 --> 10:50:43,520
this statement here let's go on top here

16198
10:50:43,520 --> 10:50:46,080
and put in an sddc out statement so that

16199
10:50:46,080 --> 10:50:47,680
we can really see

16200
10:50:47,680 --> 10:50:50,160
where this program is failing

16201
10:50:50,160 --> 10:50:52,800
let's say that stdc out

16202
10:50:52,800 --> 10:50:54,960
writing in the 55

16203
10:50:54,960 --> 10:50:56,640
okay so this is what we have we have a

16204
10:50:56,640 --> 10:50:58,800
few statements other than and we want to

16205
10:50:58,800 --> 10:51:01,360
see if we actually get to run these two

16206
10:51:01,360 --> 10:51:03,116
things to see

16207
10:51:03,116 --> 10:51:06,000
where the program is actually failing

16208
10:51:06,000 --> 10:51:09,596
we are going to build it again with gcc

16209
10:51:09,596 --> 10:51:11,596
and we are going to clear

16210
10:51:11,596 --> 10:51:13,680
and run rooster you see that it's going

16211
10:51:13,680 --> 10:51:17,040
to say writing in a 55 but this

16212
10:51:17,040 --> 10:51:18,960
statement here is going to fail because

16213
10:51:18,960 --> 10:51:22,160
we are trying to ride into memory that

16214
10:51:22,160 --> 10:51:24,560
is not ours and the operating system is

16215
10:51:24,560 --> 10:51:27,040
going to stop us so our program is

16216
10:51:27,040 --> 10:51:30,000
crashing and it is terminating before it

16217
10:51:30,000 --> 10:51:32,560
even runs the things that are down here

16218
10:51:32,560 --> 10:51:34,880
hopefully you can see how bad this is

16219
10:51:34,880 --> 10:51:36,800
you have designed your program to do

16220
10:51:36,800 --> 10:51:39,360
things but it is going to stop

16221
10:51:39,360 --> 10:51:41,756
without having done any of the other

16222
10:51:41,756 --> 10:51:44,080
things that you have designed below so

16223
10:51:44,080 --> 10:51:46,720
this is really bad and another bad thing

16224
10:51:46,720 --> 10:51:47,916
is that

16225
10:51:47,916 --> 10:51:50,480
you might have allocated some dynamic

16226
10:51:50,480 --> 10:51:53,436
memory beforehand and your program is

16227
10:51:53,436 --> 10:51:56,640
going to end before it even releases

16228
10:51:56,640 --> 10:51:58,880
that memory properly and returns that to

16229
10:51:58,880 --> 10:52:01,436
the operating system so this is bad you

16230
10:52:01,436 --> 10:52:04,000
don't want crashes in your programs and

16231
10:52:04,000 --> 10:52:07,200
don't ever try and use and reference

16232
10:52:07,200 --> 10:52:10,400
memory that you haven't initialized this

16233
10:52:10,400 --> 10:52:12,320
is one bad thing we're going to comment

16234
10:52:12,320 --> 10:52:15,360
this out i hope you really know how bad

16235
10:52:15,360 --> 10:52:18,080
this is and we're going to go down again

16236
10:52:18,080 --> 10:52:21,916
and uncomment what we have done here

16237
10:52:21,916 --> 10:52:23,840
and uh it's going to be another bad

16238
10:52:23,840 --> 10:52:26,080
thing because we are trying to write

16239
10:52:26,080 --> 10:52:27,756
into memory

16240
10:52:27,756 --> 10:52:30,400
initialized to null pqr okay here we

16241
10:52:30,400 --> 10:52:32,240
have a pointer this is called p number

16242
10:52:32,240 --> 10:52:36,160
three and it is initialized with no ptr

16243
10:52:36,160 --> 10:52:38,720
you can think of ptr as an address that

16244
10:52:38,720 --> 10:52:42,400
says i don't have any valid thing in me

16245
10:52:42,400 --> 10:52:44,480
don't use me that's what no ptr is

16246
10:52:44,480 --> 10:52:46,160
saying so we have the pointer

16247
10:52:46,160 --> 10:52:48,880
initialized to ptr but we are trying to

16248
10:52:48,880 --> 10:52:51,596
store something in here and you can

16249
10:52:51,596 --> 10:52:54,880
imagine how bad this is this is memory

16250
10:52:54,880 --> 10:52:56,960
that isn't really valid the memory

16251
10:52:56,960 --> 10:52:58,720
itself is saying i don't contain

16252
10:52:58,720 --> 10:53:00,960
anything valid don't try to use me and

16253
10:53:00,960 --> 10:53:02,720
if you try to use it bad things are

16254
10:53:02,720 --> 10:53:05,040
going to happen so if we try and compile

16255
10:53:05,040 --> 10:53:07,040
this program it is going to compile the

16256
10:53:07,040 --> 10:53:08,880
compiler is not going to stop us to do

16257
10:53:08,880 --> 10:53:10,480
something like this

16258
10:53:10,480 --> 10:53:12,320
and these are some things you need to be

16259
10:53:12,320 --> 10:53:14,720
aware of in c plus plus but if we try to

16260
10:53:14,720 --> 10:53:16,480
run it you're going to see that we are

16261
10:53:16,480 --> 10:53:18,880
also going to get a crash again let's

16262
10:53:18,880 --> 10:53:21,040
try and put a statement in front of this

16263
10:53:21,040 --> 10:53:24,000
failing line and uh below this line i

16264
10:53:24,000 --> 10:53:25,276
can say

16265
10:53:25,276 --> 10:53:27,880
done writing and i can do

16266
10:53:27,880 --> 10:53:30,320
stdndl here

16267
10:53:30,320 --> 10:53:32,240
and both of the programs so that we can

16268
10:53:32,240 --> 10:53:35,680
see which std statements run and which

16269
10:53:35,680 --> 10:53:39,040
dot after our program crashes so we're

16270
10:53:39,040 --> 10:53:40,960
going to clear the world is good and run

16271
10:53:40,960 --> 10:53:42,240
rooster you're going to see it's going

16272
10:53:42,240 --> 10:53:44,640
to say what it's doing it's going to try

16273
10:53:44,640 --> 10:53:46,720
and fail and the operating system is

16274
10:53:46,720 --> 10:53:48,640
going to kill this program because it is

16275
10:53:48,640 --> 10:53:50,640
crazy it is doing what it shouldn't

16276
10:53:50,640 --> 10:53:53,200
really be doing so this is something bad

16277
10:53:53,200 --> 10:53:55,756
don't do it be aware of this thing okay

16278
10:53:55,756 --> 10:53:57,040
we're going to comment this out and

16279
10:53:57,040 --> 10:54:00,000
actually look at how we can dynamically

16280
10:54:00,000 --> 10:54:02,560
allocate memory from the heap and we're

16281
10:54:02,560 --> 10:54:04,240
going to put in a piece of code to play

16282
10:54:04,240 --> 10:54:05,360
with that

16283
10:54:05,360 --> 10:54:07,040
it's not really complicated we have a

16284
10:54:07,040 --> 10:54:09,840
pointer we initialize it with no pointer

16285
10:54:09,840 --> 10:54:12,160
to say that this pointer doesn't point

16286
10:54:12,160 --> 10:54:15,200
to anywhere valid don't use it and we

16287
10:54:15,200 --> 10:54:16,080
are

16288
10:54:16,080 --> 10:54:19,520
calling new and when we do this the

16289
10:54:19,520 --> 10:54:21,520
operating system is going to give us a

16290
10:54:21,520 --> 10:54:23,840
new piece of memory on the heap

16291
10:54:23,840 --> 10:54:25,520
this piece of memory is going to have

16292
10:54:25,520 --> 10:54:27,520
the size enough to contain it so it's

16293
10:54:27,520 --> 10:54:29,680
going to be four bytes in memory and we

16294
10:54:29,680 --> 10:54:31,680
are going to be pointing to that piece

16295
10:54:31,680 --> 10:54:34,320
of memory using p number four here this

16296
10:54:34,320 --> 10:54:36,160
is what we are trying to say here the

16297
10:54:36,160 --> 10:54:38,320
moment we do this we own this piece of

16298
10:54:38,320 --> 10:54:40,640
memory and nobody else on the operating

16299
10:54:40,640 --> 10:54:42,480
system can use it so that's something

16300
10:54:42,480 --> 10:54:44,720
you should know once you have it you can

16301
10:54:44,720 --> 10:54:46,880
manipulate it through the pointer here

16302
10:54:46,880 --> 10:54:48,480
so here we can go through the the

16303
10:54:48,480 --> 10:54:51,916
reference operator and store in 77 and

16304
10:54:51,916 --> 10:54:53,596
if we print it out we're going to get

16305
10:54:53,596 --> 10:54:55,916
that printed out here okay this is

16306
10:54:55,916 --> 10:54:57,680
really cool this is the first time we

16307
10:54:57,680 --> 10:55:00,480
use hip memory and i am excited about

16308
10:55:00,480 --> 10:55:02,320
showing you this thanks we're going to

16309
10:55:02,320 --> 10:55:04,800
try and build this program and the build

16310
10:55:04,800 --> 10:55:06,880
is going to be good and we are going to

16311
10:55:06,880 --> 10:55:08,080
clear this

16312
10:55:08,080 --> 10:55:11,200
and if we run rooster we should see a 77

16313
10:55:11,200 --> 10:55:13,520
pretty down let's do that

16314
10:55:13,520 --> 10:55:16,960
i'm going to get our 77 but this 77 is

16315
10:55:16,960 --> 10:55:19,756
stored on the heap now it is not stored

16316
10:55:19,756 --> 10:55:21,840
on the stack and this is really

16317
10:55:21,840 --> 10:55:24,800
really cool we can control when this

16318
10:55:24,800 --> 10:55:27,116
variable comes alive by allocating

16319
10:55:27,116 --> 10:55:29,756
memory on the heap and we exactly

16320
10:55:29,756 --> 10:55:32,640
control when this variable dies

16321
10:55:32,640 --> 10:55:34,320
if we want and we're going to see how we

16322
10:55:34,320 --> 10:55:36,800
can kill this variable from memory but

16323
10:55:36,800 --> 10:55:39,040
for now just take a moment and

16324
10:55:39,040 --> 10:55:41,436
appreciate how good it is to be able to

16325
10:55:41,436 --> 10:55:43,596
allocate stuff on the heap it is really

16326
10:55:43,596 --> 10:55:46,080
cool now that you have used the memory

16327
10:55:46,080 --> 10:55:48,640
it is really time to return it to the

16328
10:55:48,640 --> 10:55:50,800
system because we have no more use for

16329
10:55:50,800 --> 10:55:52,640
it the way you release memory to the

16330
10:55:52,640 --> 10:55:56,720
system is to call the delete keyword

16331
10:55:56,720 --> 10:55:58,880
and say the pointer pointing to the

16332
10:55:58,880 --> 10:56:01,436
memory that you are trying to release to

16333
10:56:01,436 --> 10:56:03,200
the system so we're going to say p

16334
10:56:03,200 --> 10:56:05,680
number four here let's bring this down a

16335
10:56:05,680 --> 10:56:07,276
little bit so that you can see the

16336
10:56:07,276 --> 10:56:09,840
entire story so we have a pointer here

16337
10:56:09,840 --> 10:56:11,916
and it is pointing to dynamically

16338
10:56:11,916 --> 10:56:13,916
allocated memory from the heap this

16339
10:56:13,916 --> 10:56:15,916
memory is four bytes

16340
10:56:15,916 --> 10:56:18,560
large because it stores an integer

16341
10:56:18,560 --> 10:56:21,840
we have it dynamically allocated we use

16342
10:56:21,840 --> 10:56:24,400
it here and it is time to return it to

16343
10:56:24,400 --> 10:56:26,720
the operating system okay i hope this is

16344
10:56:26,720 --> 10:56:28,880
clear the moment you call the delete

16345
10:56:28,880 --> 10:56:30,320
keyword

16346
10:56:30,320 --> 10:56:32,720
now the memory is going to be containing

16347
10:56:32,720 --> 10:56:34,880
some junk and you don't want to really

16348
10:56:34,880 --> 10:56:37,200
use that anymore if you try to use it

16349
10:56:37,200 --> 10:56:39,116
it's not your memory you're going to run

16350
10:56:39,116 --> 10:56:41,116
into trouble so for example after we

16351
10:56:41,116 --> 10:56:43,040
delete this memory if we try to use it

16352
10:56:43,040 --> 10:56:45,360
i'm going to show you here i think i can

16353
10:56:45,360 --> 10:56:48,720
let's say p number four and um storing

16354
10:56:48,720 --> 10:56:50,960
something notice that we are using the

16355
10:56:50,960 --> 10:56:53,200
the reference operator and let's try and

16356
10:56:53,200 --> 10:56:55,520
put in a 45 why not

16357
10:56:55,520 --> 10:56:58,080
so let's build this with gcc as we

16358
10:56:58,080 --> 10:57:00,400
always do it is going to world compiler

16359
10:57:00,400 --> 10:57:02,000
is not going to stop you from doing

16360
10:57:02,000 --> 10:57:03,916
something like this

16361
10:57:03,916 --> 10:57:05,596
writing into memory that you have

16362
10:57:05,596 --> 10:57:06,400
already

16363
10:57:06,400 --> 10:57:08,800
released to the system but we're going

16364
10:57:08,800 --> 10:57:12,000
to see what happens so run rooster and

16365
10:57:12,000 --> 10:57:14,080
it is going to say done writing but you

16366
10:57:14,080 --> 10:57:17,276
see that the program has really crashed

16367
10:57:17,276 --> 10:57:20,400
because here we are trying to write into

16368
10:57:20,400 --> 10:57:22,560
memory that we don't really own and this

16369
10:57:22,560 --> 10:57:25,520
is bad don't do this so the moment you

16370
10:57:25,520 --> 10:57:27,916
delete the memory or the moment you

16371
10:57:27,916 --> 10:57:29,596
return the memory to the operating

16372
10:57:29,596 --> 10:57:32,400
system it is good practice to reset that

16373
10:57:32,400 --> 10:57:35,040
memory to no ptr so we're going to say p

16374
10:57:35,040 --> 10:57:36,880
number four and

16375
10:57:36,880 --> 10:57:40,640
make sure it contains no ptor

16376
10:57:40,640 --> 10:57:42,800
at least when we do this other people

16377
10:57:42,800 --> 10:57:45,200
have a chance to check and see that

16378
10:57:45,200 --> 10:57:47,436
that's valid memory before they use it

16379
10:57:47,436 --> 10:57:49,756
that's the use of resetting your memory

16380
10:57:49,756 --> 10:57:51,916
here so this is something you should do

16381
10:57:51,916 --> 10:57:54,400
again the flow to use dynamic memory is

16382
10:57:54,400 --> 10:57:56,400
really simple you set up a pointer that

16383
10:57:56,400 --> 10:57:58,720
is going to point to your memory

16384
10:57:58,720 --> 10:57:59,916
you're going to

16385
10:57:59,916 --> 10:58:02,400
allocate the memory from the heap using

16386
10:58:02,400 --> 10:58:04,800
the new operator you're going to specify

16387
10:58:04,800 --> 10:58:07,436
the type you want to allocate memory for

16388
10:58:07,436 --> 10:58:08,960
the operating system is going to give

16389
10:58:08,960 --> 10:58:10,400
you that memory and you're going to be

16390
10:58:10,400 --> 10:58:12,000
pointing to that memory with your

16391
10:58:12,000 --> 10:58:14,320
pointer you are going to manipulate that

16392
10:58:14,320 --> 10:58:16,720
memory using your pointer and doing all

16393
10:58:16,720 --> 10:58:19,116
kinds of crazy things and after you are

16394
10:58:19,116 --> 10:58:20,640
done with that memory you're going to

16395
10:58:20,640 --> 10:58:23,596
release it to the operating system and

16396
10:58:23,596 --> 10:58:24,640
please

16397
10:58:24,640 --> 10:58:27,040
please remember to reset your pointers

16398
10:58:27,040 --> 10:58:29,916
after you have deleted them like this

16399
10:58:29,916 --> 10:58:31,840
that's going to make your life a whole

16400
10:58:31,840 --> 10:58:34,560
lot easier and other developers are

16401
10:58:34,560 --> 10:58:36,640
going to thank you for doing this

16402
10:58:36,640 --> 10:58:38,640
when they get to use your code because

16403
10:58:38,640 --> 10:58:40,960
your code is going to be much safer to

16404
10:58:40,960 --> 10:58:43,040
work with okay let's comment this out

16405
10:58:43,040 --> 10:58:45,520
and show you another example of what

16406
10:58:45,520 --> 10:58:47,840
cool things you can do with dynamic heap

16407
10:58:47,840 --> 10:58:49,916
memory we're going to go down and put in

16408
10:58:49,916 --> 10:58:51,520
a piece of code and show you that you

16409
10:58:51,520 --> 10:58:52,880
can actually

16410
10:58:52,880 --> 10:58:55,520
dynamically initialize your pointers at

16411
10:58:55,520 --> 10:58:57,916
declaration this is something you can do

16412
10:58:57,916 --> 10:59:00,000
the first one is not initialized so it's

16413
10:59:00,000 --> 10:59:02,080
going to contain junk volume p number

16414
10:59:02,080 --> 10:59:03,756
five if we try to print it we're going

16415
10:59:03,756 --> 10:59:06,320
to get some junk address print it out p

16416
10:59:06,320 --> 10:59:08,400
number six we're going to dereference it

16417
10:59:08,400 --> 10:59:10,320
and print the value inside so we're

16418
10:59:10,320 --> 10:59:12,240
going to see that and we can do the same

16419
10:59:12,240 --> 10:59:14,160
thing for p number six and p number

16420
10:59:14,160 --> 10:59:16,160
seven after we are done using the

16421
10:59:16,160 --> 10:59:18,400
pointers we are going to release the

16422
10:59:18,400 --> 10:59:20,320
memory here and notice that we are

16423
10:59:20,320 --> 10:59:22,480
resetting the pointers to no pointer to

16424
10:59:22,480 --> 10:59:24,240
say that they don't really contain

16425
10:59:24,240 --> 10:59:27,040
anything useful don't use them make sure

16426
10:59:27,040 --> 10:59:29,040
you have something valid and before you

16427
10:59:29,040 --> 10:59:31,040
use them this is the meaning here if

16428
10:59:31,040 --> 10:59:32,720
you're trying to run the program you can

16429
10:59:32,720 --> 10:59:34,640
guess what we're going to see so try and

16430
10:59:34,640 --> 10:59:36,800
guess and we're going to build we're

16431
10:59:36,800 --> 10:59:38,880
going to weld successfully going to

16432
10:59:38,880 --> 10:59:39,680
clear

16433
10:59:39,680 --> 10:59:42,080
clear not clear and we're going to run

16434
10:59:42,080 --> 10:59:44,000
rooster and we're going to see that p

16435
10:59:44,000 --> 10:59:46,640
number five contains some junk address

16436
10:59:46,640 --> 10:59:49,040
okay and if we try to dereference that

16437
10:59:49,040 --> 10:59:51,520
we're going to get a junk value this is

16438
10:59:51,520 --> 10:59:54,000
really not useful don't use this value

16439
10:59:54,000 --> 10:59:56,480
because you didn't put this value in in

16440
10:59:56,480 --> 10:59:58,400
the first place you're going to see that

16441
10:59:58,400 --> 11:00:00,400
p number 6 is going to point to some

16442
11:00:00,400 --> 11:00:02,400
other address but we're going to have a

16443
11:00:02,400 --> 11:00:05,680
valid value inside because we have put

16444
11:00:05,680 --> 11:00:09,040
that n at initialization here the same

16445
11:00:09,040 --> 11:00:10,960
is true for p number seven it's going to

16446
11:00:10,960 --> 11:00:13,116
point to some address and we're going to

16447
11:00:13,116 --> 11:00:17,040
have 23 and because we put in our 23.

16448
11:00:17,040 --> 11:00:18,480
this is how you really use these

16449
11:00:18,480 --> 11:00:20,320
pointers another thing i want you to

16450
11:00:20,320 --> 11:00:23,360
know is that even if we have called

16451
11:00:23,360 --> 11:00:26,480
delete and reset these pointers they are

16452
11:00:26,480 --> 11:00:28,880
still available for use in our program

16453
11:00:28,880 --> 11:00:30,800
so if we want we can reuse these

16454
11:00:30,800 --> 11:00:32,960
pointers so for example p number five we

16455
11:00:32,960 --> 11:00:34,800
can take it

16456
11:00:34,800 --> 11:00:36,960
and use it to allocate new memory so we

16457
11:00:36,960 --> 11:00:38,720
can say new and

16458
11:00:38,720 --> 11:00:42,000
and uh store an 81 why not

16459
11:00:42,000 --> 11:00:44,400
okay so we can go down here and use that

16460
11:00:44,400 --> 11:00:46,400
this is going to be valid c plus plus

16461
11:00:46,400 --> 11:00:47,680
code

16462
11:00:47,680 --> 11:00:49,840
okay take a moment and look at it it is

16463
11:00:49,840 --> 11:00:52,880
p number five not p number

16464
11:00:52,880 --> 11:00:54,560
and the visual studio code is going to

16465
11:00:54,560 --> 11:00:56,400
take this because it is valid c plus

16466
11:00:56,400 --> 11:00:59,276
plus code the memory has been returned

16467
11:00:59,276 --> 11:01:01,756
to the operating system and the pointer

16468
11:01:01,756 --> 11:01:04,560
has been reset to no ptr but we can

16469
11:01:04,560 --> 11:01:06,800
reuse this end pointer to allocate new

16470
11:01:06,800 --> 11:01:09,040
memory so we are allocating new memory

16471
11:01:09,040 --> 11:01:11,520
on the heap the memory is going to be

16472
11:01:11,520 --> 11:01:14,320
four bytes because it is

16473
11:01:14,320 --> 11:01:16,720
going to contain an integer and we are

16474
11:01:16,720 --> 11:01:18,400
using this pointer

16475
11:01:18,400 --> 11:01:20,560
to point to that new memory so this

16476
11:01:20,560 --> 11:01:22,880
pointer is being reused it was pointing

16477
11:01:22,880 --> 11:01:23,596
to

16478
11:01:23,596 --> 11:01:25,840
the memory that we allocated here which

16479
11:01:25,840 --> 11:01:28,560
was uninitialized and we are using that

16480
11:01:28,560 --> 11:01:30,240
to point to new

16481
11:01:30,240 --> 11:01:32,240
memory location on the hip i really want

16482
11:01:32,240 --> 11:01:35,200
you to understand these things because

16483
11:01:35,200 --> 11:01:37,916
many beginners get them wrong and it is

16484
11:01:37,916 --> 11:01:40,160
hard to correct these things in your

16485
11:01:40,160 --> 11:01:43,116
mind once you have a wrong idea about

16486
11:01:43,116 --> 11:01:45,276
them in the first place so make sure you

16487
11:01:45,276 --> 11:01:47,276
understand this so if we print this

16488
11:01:47,276 --> 11:01:50,240
we're going to get the 81 printed out

16489
11:01:50,240 --> 11:01:51,276
but

16490
11:01:51,276 --> 11:01:53,680
we have allocated new memory we have to

16491
11:01:53,680 --> 11:01:55,756
remember to release it again so we have

16492
11:01:55,756 --> 11:01:58,160
to come and say delete

16493
11:01:58,160 --> 11:02:01,276
p number five and we need to reset it to

16494
11:02:01,276 --> 11:02:03,040
no pointer

16495
11:02:03,040 --> 11:02:04,800
and we're going to do that

16496
11:02:04,800 --> 11:02:05,916
right here

16497
11:02:05,916 --> 11:02:07,840
once we do this we're going to be

16498
11:02:07,840 --> 11:02:09,680
playing it safe let's try and run and

16499
11:02:09,680 --> 11:02:12,240
see that we see the at1 printed out

16500
11:02:12,240 --> 11:02:14,160
we're going to build with gcc the world

16501
11:02:14,160 --> 11:02:16,000
is going to go through

16502
11:02:16,000 --> 11:02:18,320
and we are going to clear and run

16503
11:02:18,320 --> 11:02:21,200
rooster and you see that we see our 81

16504
11:02:21,200 --> 11:02:23,840
and we don't have any crazy crash for

16505
11:02:23,840 --> 11:02:25,680
example to prove that we don't have a

16506
11:02:25,680 --> 11:02:28,560
crash we can say that our program is

16507
11:02:28,560 --> 11:02:30,640
ending well

16508
11:02:30,640 --> 11:02:32,480
is ending well

16509
11:02:32,480 --> 11:02:33,436
and uh

16510
11:02:33,436 --> 11:02:34,960
we're going to know

16511
11:02:34,960 --> 11:02:37,840
if the program has actually reached the

16512
11:02:37,840 --> 11:02:40,880
end before it dies we're going to build

16513
11:02:40,880 --> 11:02:42,480
again

16514
11:02:42,480 --> 11:02:44,080
with gcc

16515
11:02:44,080 --> 11:02:46,960
and we're going to clear

16516
11:02:46,960 --> 11:02:49,436
and run rooster and you're going to see

16517
11:02:49,436 --> 11:02:51,596
that the program is ending well

16518
11:02:51,596 --> 11:02:53,360
the other thing i want you to see is

16519
11:02:53,360 --> 11:02:57,436
that it is really bad to call delete

16520
11:02:57,436 --> 11:03:01,360
twice on a pointer again it is really

16521
11:03:01,360 --> 11:03:04,800
bad to call delete twice on a pointer

16522
11:03:04,800 --> 11:03:06,560
don't do that okay we're going to see an

16523
11:03:06,560 --> 11:03:08,560
example of that here

16524
11:03:08,560 --> 11:03:10,160
so we're going to allocate new memory

16525
11:03:10,160 --> 11:03:12,240
using p number five why not so we're

16526
11:03:12,240 --> 11:03:14,560
going to say p number five and we're

16527
11:03:14,560 --> 11:03:17,276
going to say new and going to allocate

16528
11:03:17,276 --> 11:03:18,800
new memory on the heap and we're going

16529
11:03:18,800 --> 11:03:22,240
to store in a 99 in that memory we can

16530
11:03:22,240 --> 11:03:24,720
print out the 99 so we're going to say

16531
11:03:24,720 --> 11:03:26,960
and after we are done using this memory

16532
11:03:26,960 --> 11:03:28,960
we are a good c plus plus citizen so

16533
11:03:28,960 --> 11:03:31,520
we're going to call delete

16534
11:03:31,520 --> 11:03:33,756
and say p number five

16535
11:03:33,756 --> 11:03:35,840
okay this is good it is going to work if

16536
11:03:35,840 --> 11:03:38,240
we will then run we're going to get what

16537
11:03:38,240 --> 11:03:42,160
we expect we should get a 99 printed out

16538
11:03:42,160 --> 11:03:45,680
last in our program before it ends and

16539
11:03:45,680 --> 11:03:47,916
we see that printed out here program

16540
11:03:47,916 --> 11:03:49,916
ending well this is really cool

16541
11:03:49,916 --> 11:03:53,596
but if we try to call delete twice

16542
11:03:53,596 --> 11:03:56,080
and say p number five again

16543
11:03:56,080 --> 11:03:57,596
and try to boil you see that the

16544
11:03:57,596 --> 11:03:59,520
compiler is not going to stop us because

16545
11:03:59,520 --> 11:04:00,800
it thanks

16546
11:04:00,800 --> 11:04:02,720
we know what we are doing

16547
11:04:02,720 --> 11:04:04,240
so this is something you need to be

16548
11:04:04,240 --> 11:04:06,720
aware of in c plus plus if we run this

16549
11:04:06,720 --> 11:04:07,840
program

16550
11:04:07,840 --> 11:04:09,756
you're going to see ah the program is

16551
11:04:09,756 --> 11:04:11,840
not going to end well the c plus plus

16552
11:04:11,840 --> 11:04:14,320
runtime or the operating system is going

16553
11:04:14,320 --> 11:04:16,160
to get here and see uh this guy is

16554
11:04:16,160 --> 11:04:18,400
trying to release memory twice and i

16555
11:04:18,400 --> 11:04:20,560
don't do that this is a bad program i am

16556
11:04:20,560 --> 11:04:22,160
going to kill it and it is going to be

16557
11:04:22,160 --> 11:04:24,640
killed the bad thing again is that

16558
11:04:24,640 --> 11:04:27,116
anything you have in your program after

16559
11:04:27,116 --> 11:04:29,680
these lines is not going to run because

16560
11:04:29,680 --> 11:04:31,840
the operating system is going to kill

16561
11:04:31,840 --> 11:04:34,640
your program at this line here so if you

16562
11:04:34,640 --> 11:04:37,200
had memory allocated that you planned to

16563
11:04:37,200 --> 11:04:39,840
release later on in your program your

16564
11:04:39,840 --> 11:04:41,436
memory is not going to be released

16565
11:04:41,436 --> 11:04:43,436
because those statements to release the

16566
11:04:43,436 --> 11:04:45,916
memory will never be run this is where

16567
11:04:45,916 --> 11:04:47,916
the program is going to be killed the

16568
11:04:47,916 --> 11:04:49,596
operating system is going to see that

16569
11:04:49,596 --> 11:04:52,160
you are a rug program and it is going to

16570
11:04:52,160 --> 11:04:55,200
kill the program so don't delete your

16571
11:04:55,200 --> 11:04:57,276
memory twice this is something you

16572
11:04:57,276 --> 11:04:59,116
should really watch out for and you

16573
11:04:59,116 --> 11:05:01,116
might think uh-huh i know this why would

16574
11:05:01,116 --> 11:05:03,596
i call delete twice in a single line

16575
11:05:03,596 --> 11:05:06,080
here well you may not do it like this

16576
11:05:06,080 --> 11:05:08,640
but your program might have multiple

16577
11:05:08,640 --> 11:05:09,756
files

16578
11:05:09,756 --> 11:05:11,596
where you have pointers pointing to the

16579
11:05:11,596 --> 11:05:13,680
same memory and if you try to delete

16580
11:05:13,680 --> 11:05:15,840
that memory twice you're going to get

16581
11:05:15,840 --> 11:05:17,840
this error and this is really good so

16582
11:05:17,840 --> 11:05:19,680
watch out for these kinds of things and

16583
11:05:19,680 --> 11:05:21,116
we're going to see different ways you

16584
11:05:21,116 --> 11:05:22,080
can

16585
11:05:22,080 --> 11:05:24,960
use to really make sure you are doing

16586
11:05:24,960 --> 11:05:26,960
things right in c plus plus this is

16587
11:05:26,960 --> 11:05:28,400
really all we set out to do in this

16588
11:05:28,400 --> 11:05:31,276
lecture giving you first-hand practice

16589
11:05:31,276 --> 11:05:34,800
on how to do dynamic memory allocation i

16590
11:05:34,800 --> 11:05:37,040
hope you found this useful we are going

16591
11:05:37,040 --> 11:05:38,800
to stop here in this lecture and the

16592
11:05:38,800 --> 11:05:40,560
next one we're going to learn about

16593
11:05:40,560 --> 11:05:42,240
dangling pointers

16594
11:05:42,240 --> 11:05:44,720
go ahead and finish up here and we'd be

16595
11:05:44,720 --> 11:05:46,800
there in this lecture we're going to

16596
11:05:46,800 --> 11:05:49,040
focus on dangling pointers and show you

16597
11:05:49,040 --> 11:05:51,360
how they can be bad a dangling pointer

16598
11:05:51,360 --> 11:05:54,160
is a pointer that is pointing to a valid

16599
11:05:54,160 --> 11:05:56,160
address and we have seen a few examples

16600
11:05:56,160 --> 11:05:58,160
of this already but in this lecture

16601
11:05:58,160 --> 11:06:00,160
we're going to focus on that and show

16602
11:06:00,160 --> 11:06:02,320
you common solutions we can apply to

16603
11:06:02,320 --> 11:06:04,800
these problems here and download

16604
11:06:04,800 --> 11:06:06,960
pointers are really bad they are going

16605
11:06:06,960 --> 11:06:09,040
to lead you programs to undefined

16606
11:06:09,040 --> 11:06:11,680
behavior and we have seen that that can

16607
11:06:11,680 --> 11:06:13,276
crush your program

16608
11:06:13,276 --> 11:06:16,240
many times there are three kinds of

16609
11:06:16,240 --> 11:06:17,916
dangling pointers we're going to look at

16610
11:06:17,916 --> 11:06:19,916
in this lecture the first one is a

16611
11:06:19,916 --> 11:06:22,400
pointer that is not initialized the

16612
11:06:22,400 --> 11:06:25,360
second one is a deleted pointer and the

16613
11:06:25,360 --> 11:06:28,000
third case may come if you have multiple

16614
11:06:28,000 --> 11:06:29,916
pointers pointing to the same memory

16615
11:06:29,916 --> 11:06:32,880
location and let's look at these cases

16616
11:06:32,880 --> 11:06:35,200
one by one here we have an example of a

16617
11:06:35,200 --> 11:06:37,840
pointer that is not properly initialized

16618
11:06:37,840 --> 11:06:40,160
this is p number five it is a pointer to

16619
11:06:40,160 --> 11:06:40,960
end

16620
11:06:40,960 --> 11:06:42,720
and it is not initialized it doesn't

16621
11:06:42,720 --> 11:06:44,880
really point anywhere and it is going to

16622
11:06:44,880 --> 11:06:47,276
contain junk address if we try to

16623
11:06:47,276 --> 11:06:49,040
dereference it we're going to get bad

16624
11:06:49,040 --> 11:06:51,360
things to happen because we don't really

16625
11:06:51,360 --> 11:06:54,240
know which address is stored in there

16626
11:06:54,240 --> 11:06:56,160
and putting something in there might

16627
11:06:56,160 --> 11:06:58,880
lead to a crash so this is something you

16628
11:06:58,880 --> 11:07:01,116
need to watch out for the second kind of

16629
11:07:01,116 --> 11:07:03,276
dangling pointer that can really lead

16630
11:07:03,276 --> 11:07:06,240
you to bad places is a deleted pointer

16631
11:07:06,240 --> 11:07:09,276
here is a pointer p number one it is

16632
11:07:09,276 --> 11:07:12,080
initialized with dynamic memory and we

16633
11:07:12,080 --> 11:07:14,080
can use it for example here we are

16634
11:07:14,080 --> 11:07:16,240
dereferencing the pointer and printing

16635
11:07:16,240 --> 11:07:18,720
the value inside and deleting the

16636
11:07:18,720 --> 11:07:21,276
pointer after we delete the pointer

16637
11:07:21,276 --> 11:07:23,840
don't really use it before you properly

16638
11:07:23,840 --> 11:07:26,320
initialize it with some kind of memory

16639
11:07:26,320 --> 11:07:28,800
if we try to do that this is going to be

16640
11:07:28,800 --> 11:07:31,276
undefined behavior and your program

16641
11:07:31,276 --> 11:07:33,756
might crash so make sure you don't do

16642
11:07:33,756 --> 11:07:36,080
something like this another case is if

16643
11:07:36,080 --> 11:07:38,080
you have multiple pointers pointing to

16644
11:07:38,080 --> 11:07:40,880
the same address and here is a simple

16645
11:07:40,880 --> 11:07:43,520
example to drive the point home we have

16646
11:07:43,520 --> 11:07:46,160
pointer three which is pointing to

16647
11:07:46,160 --> 11:07:49,200
dynamic memory here we are using new ant

16648
11:07:49,200 --> 11:07:52,560
in our braced initializer and we are

16649
11:07:52,560 --> 11:07:55,360
putting value 83 in that pointer

16650
11:07:55,360 --> 11:07:56,480
location

16651
11:07:56,480 --> 11:07:58,640
and here we set up another pointer p

16652
11:07:58,640 --> 11:08:01,436
number four and we initialize that with

16653
11:08:01,436 --> 11:08:03,680
another pointer and if we print these

16654
11:08:03,680 --> 11:08:05,200
things out we're going to get that they

16655
11:08:05,200 --> 11:08:07,276
contain the same address and they

16656
11:08:07,276 --> 11:08:08,800
contain the same value we're going to

16657
11:08:08,800 --> 11:08:09,840
see that

16658
11:08:09,840 --> 11:08:12,560
if we delete p number three

16659
11:08:12,560 --> 11:08:15,040
and try to use p number four later we're

16660
11:08:15,040 --> 11:08:16,960
going to get problems because this

16661
11:08:16,960 --> 11:08:19,360
memory has been deleted by p number

16662
11:08:19,360 --> 11:08:20,320
three

16663
11:08:20,320 --> 11:08:22,800
but p number four is still pointing to

16664
11:08:22,800 --> 11:08:24,800
that and if it tries to use that it's

16665
11:08:24,800 --> 11:08:27,360
going to be deleted memory basically and

16666
11:08:27,360 --> 11:08:29,200
we're going to get undefined behavior so

16667
11:08:29,200 --> 11:08:32,480
be sure you know these problems and try

16668
11:08:32,480 --> 11:08:34,880
to avoid them in your programs okay

16669
11:08:34,880 --> 11:08:37,360
these are problems but how do we solve

16670
11:08:37,360 --> 11:08:40,240
them well there are a few solutions one

16671
11:08:40,240 --> 11:08:42,400
is to always initialize your pointers

16672
11:08:42,400 --> 11:08:44,640
the moment you declare a pointer make

16673
11:08:44,640 --> 11:08:46,960
sure it is initialized if you don't know

16674
11:08:46,960 --> 11:08:48,800
what you can initialize that pointer

16675
11:08:48,800 --> 11:08:51,360
with put in null pointer first and then

16676
11:08:51,360 --> 11:08:53,200
you're going to put in an address later

16677
11:08:53,200 --> 11:08:56,000
when you have a clear idea of which

16678
11:08:56,000 --> 11:08:57,916
address you can store in the second

16679
11:08:57,916 --> 11:09:00,720
solution is to reset your pointers to

16680
11:09:00,720 --> 11:09:04,240
now ptr after you delete the memory

16681
11:09:04,240 --> 11:09:06,000
that's the second thing you should do

16682
11:09:06,000 --> 11:09:08,320
every time you call delete that's going

16683
11:09:08,320 --> 11:09:10,400
to give other developers or even

16684
11:09:10,400 --> 11:09:12,880
yourself a chance to check and see if

16685
11:09:12,880 --> 11:09:14,480
that memory location

16686
11:09:14,480 --> 11:09:16,960
contains a valid address before you do

16687
11:09:16,960 --> 11:09:19,436
that and for multiple pointers pointing

16688
11:09:19,436 --> 11:09:22,080
to the same address you have to choose

16689
11:09:22,080 --> 11:09:24,960
and make one pointer the master of the

16690
11:09:24,960 --> 11:09:26,960
controller of the memory

16691
11:09:26,960 --> 11:09:29,116
and all pointers are basically going to

16692
11:09:29,116 --> 11:09:32,080
be slaves which can't release the memory

16693
11:09:32,080 --> 11:09:34,400
but they can read and do something with

16694
11:09:34,400 --> 11:09:36,240
that memory that they don't have the

16695
11:09:36,240 --> 11:09:39,276
task of releasing that memory and here

16696
11:09:39,276 --> 11:09:41,200
is how you can apply solution one for

16697
11:09:41,200 --> 11:09:43,756
example we have pointer number five and

16698
11:09:43,756 --> 11:09:45,840
we're going to brace initialize it this

16699
11:09:45,840 --> 11:09:48,640
is going to initialize it to

16700
11:09:48,640 --> 11:09:50,800
null pointer the other thing you can do

16701
11:09:50,800 --> 11:09:53,276
is initialize the pointer with dynamic

16702
11:09:53,276 --> 11:09:55,276
memory like we are doing here with p

16703
11:09:55,276 --> 11:09:57,436
number six and this is going to put in

16704
11:09:57,436 --> 11:09:59,360
the value and we are going to be playing

16705
11:09:59,360 --> 11:10:00,880
on the safe side

16706
11:10:00,880 --> 11:10:03,520
now if your pointers are initialized

16707
11:10:03,520 --> 11:10:05,436
developers have a chance to check your

16708
11:10:05,436 --> 11:10:08,560
pointers against no ptr to see that they

16709
11:10:08,560 --> 11:10:11,596
contain something valid before they use

16710
11:10:11,596 --> 11:10:13,916
it and if they see that it contains no

16711
11:10:13,916 --> 11:10:16,400
ptr they are not going to try and use it

16712
11:10:16,400 --> 11:10:19,040
and this is going to be very safe for

16713
11:10:19,040 --> 11:10:21,916
the second problem with deleted pointers

16714
11:10:21,916 --> 11:10:24,400
we are going to reset our pointers after

16715
11:10:24,400 --> 11:10:26,160
we call delete for example here we have

16716
11:10:26,160 --> 11:10:28,480
pin number seven initialized with

16717
11:10:28,480 --> 11:10:31,756
dynamic memory and 82 is stored in we

16718
11:10:31,756 --> 11:10:33,916
can print it out all do things with it

16719
11:10:33,916 --> 11:10:35,840
when we delete the memory we're going to

16720
11:10:35,840 --> 11:10:38,480
reset it to null p2r so that other

16721
11:10:38,480 --> 11:10:40,800
developers or even ourselves can check

16722
11:10:40,800 --> 11:10:43,596
this memory against no ptr and if it's

16723
11:10:43,596 --> 11:10:46,800
different from no ptr we can use it if

16724
11:10:46,800 --> 11:10:48,800
it's equal to no ptr we're going to

16725
11:10:48,800 --> 11:10:50,560
leave it alone and do something else

16726
11:10:50,560 --> 11:10:53,116
this is going to be very safe if you

16727
11:10:53,116 --> 11:10:55,040
have multiple pointers pointing to the

16728
11:10:55,040 --> 11:10:56,880
same address like we have here then

16729
11:10:56,880 --> 11:10:58,720
you're going to have to decide which

16730
11:10:58,720 --> 11:11:01,116
pointer is the master pointer and other

16731
11:11:01,116 --> 11:11:03,200
pointers are going to be

16732
11:11:03,200 --> 11:11:06,480
slave pointers and before use

16733
11:11:06,480 --> 11:11:08,160
all the other pointers are going to

16734
11:11:08,160 --> 11:11:10,800
check against the master pointer and see

16735
11:11:10,800 --> 11:11:13,116
that it contains valid memory because

16736
11:11:13,116 --> 11:11:15,276
the master pointer has the task of

16737
11:11:15,276 --> 11:11:17,436
deleting this memory let's go through

16738
11:11:17,436 --> 11:11:19,276
this and see how this could work in

16739
11:11:19,276 --> 11:11:20,720
practice

16740
11:11:20,720 --> 11:11:23,680
so p number five is our master pointer

16741
11:11:23,680 --> 11:11:26,240
we are setting p number five and

16742
11:11:26,240 --> 11:11:29,360
initializing it with p number eight we

16743
11:11:29,360 --> 11:11:31,360
are creating things using p number eight

16744
11:11:31,360 --> 11:11:33,360
we can either use p number eight or pin

16745
11:11:33,360 --> 11:11:35,360
urban eye this is going to work but

16746
11:11:35,360 --> 11:11:37,916
before we use the memory location we're

16747
11:11:37,916 --> 11:11:40,080
going to check against the master

16748
11:11:40,080 --> 11:11:42,320
pointer if the master pointer contains

16749
11:11:42,320 --> 11:11:44,240
no ptr we're not going to use this

16750
11:11:44,240 --> 11:11:46,720
memory if the master pointer doesn't

16751
11:11:46,720 --> 11:11:49,276
contain now ptr we're going to use this

16752
11:11:49,276 --> 11:11:51,116
memory here okay if you go down you see

16753
11:11:51,116 --> 11:11:53,276
that the master pointer is going to be

16754
11:11:53,276 --> 11:11:55,200
releasing the memory and if we try to

16755
11:11:55,200 --> 11:11:58,160
use that memory after it was deleted

16756
11:11:58,160 --> 11:11:59,840
we're going to see that it contains now

16757
11:11:59,840 --> 11:12:02,160
ptr and we're not going to be using it

16758
11:12:02,160 --> 11:12:04,320
this is something cool and it is really

16759
11:12:04,320 --> 11:12:06,800
easy to implement this safety guidelines

16760
11:12:06,800 --> 11:12:08,960
in your programs now that you know about

16761
11:12:08,960 --> 11:12:10,640
this we're going to go to visual studio

16762
11:12:10,640 --> 11:12:13,116
code and show you this in action okay

16763
11:12:13,116 --> 11:12:16,160
here we are in our working directory the

16764
11:12:16,160 --> 11:12:18,880
current project is dangling pointers so

16765
11:12:18,880 --> 11:12:21,116
we're going to grab our template files

16766
11:12:21,116 --> 11:12:24,720
pretty quick and put that in our project

16767
11:12:24,720 --> 11:12:26,240
and we're going to open this in visual

16768
11:12:26,240 --> 11:12:29,200
studio code we are going to look at the

16769
11:12:29,200 --> 11:12:31,520
first case of a dangling pointer and

16770
11:12:31,520 --> 11:12:33,116
this is a pointer that is not

16771
11:12:33,116 --> 11:12:36,400
initialized properly like p number here

16772
11:12:36,400 --> 11:12:38,240
if we try to reference it we're going to

16773
11:12:38,240 --> 11:12:40,560
get something bad to happen

16774
11:12:40,560 --> 11:12:43,040
so let's see that and let's go down and

16775
11:12:43,040 --> 11:12:45,756
say that program is ending well just to

16776
11:12:45,756 --> 11:12:47,680
know that we didn't get a crash because

16777
11:12:47,680 --> 11:12:49,596
a crash is basically going to terminate

16778
11:12:49,596 --> 11:12:52,320
your program on the offending line

16779
11:12:52,320 --> 11:12:54,400
that's what it's going to do so if the

16780
11:12:54,400 --> 11:12:55,520
program

16781
11:12:55,520 --> 11:12:57,756
works well and ends well we're going to

16782
11:12:57,756 --> 11:12:59,360
print this line here

16783
11:12:59,360 --> 11:13:01,520
let's bring in

16784
11:13:01,520 --> 11:13:04,240
gcc to build this program and let's open

16785
11:13:04,240 --> 11:13:06,480
a terminal so that we can

16786
11:13:06,480 --> 11:13:08,000
run it we're going to clear the world

16787
11:13:08,000 --> 11:13:09,436
was good

16788
11:13:09,436 --> 11:13:11,520
and we're going to run rooster

16789
11:13:11,520 --> 11:13:14,800
you see that the program didn't end well

16790
11:13:14,800 --> 11:13:17,520
it crashed and it crashed because we are

16791
11:13:17,520 --> 11:13:18,960
trying to use

16792
11:13:18,960 --> 11:13:21,520
uninitialized memory when the operating

16793
11:13:21,520 --> 11:13:23,276
system is going to try and run this

16794
11:13:23,276 --> 11:13:25,200
thing it's going to see ah this guy is

16795
11:13:25,200 --> 11:13:27,756
trying to modify memory that doesn't

16796
11:13:27,756 --> 11:13:29,756
really belong to him it is a road

16797
11:13:29,756 --> 11:13:31,840
program i am going to kill it and it is

16798
11:13:31,840 --> 11:13:34,400
going to be terminated on this line here

16799
11:13:34,400 --> 11:13:35,840
this is really bad

16800
11:13:35,840 --> 11:13:37,200
you should avoid these kinds of

16801
11:13:37,200 --> 11:13:40,080
situations so don't do this we are going

16802
11:13:40,080 --> 11:13:41,840
to comment this out and show you another

16803
11:13:41,840 --> 11:13:44,400
offending event we can do in our program

16804
11:13:44,400 --> 11:13:47,596
and that is using a deleted pointer if

16805
11:13:47,596 --> 11:13:48,800
you do that you're going to get

16806
11:13:48,800 --> 11:13:51,040
something bad in your programs

16807
11:13:51,040 --> 11:13:53,916
so here we have a small example we have

16808
11:13:53,916 --> 11:13:57,276
a pointer to end we initialize this with

16809
11:13:57,276 --> 11:13:59,360
a dynamic piece of memory and we're

16810
11:13:59,360 --> 11:14:01,520
going to store in a 67

16811
11:14:01,520 --> 11:14:03,276
and we can print this out this is going

16812
11:14:03,276 --> 11:14:04,880
to work pretty well

16813
11:14:04,880 --> 11:14:05,680
but

16814
11:14:05,680 --> 11:14:07,680
we delete the memory down here and we

16815
11:14:07,680 --> 11:14:10,320
try to use it after we have deleted the

16816
11:14:10,320 --> 11:14:12,640
memory so the operating system is not

16817
11:14:12,640 --> 11:14:14,480
going to be happy about this because

16818
11:14:14,480 --> 11:14:17,200
once the memory is deleted it is no

16819
11:14:17,200 --> 11:14:20,320
longer our memory so we have no business

16820
11:14:20,320 --> 11:14:22,320
the referencing pointer one and trying

16821
11:14:22,320 --> 11:14:24,720
to use that here and we're going to get

16822
11:14:24,720 --> 11:14:26,000
a crush

16823
11:14:26,000 --> 11:14:27,680
and this is something you should avoid

16824
11:14:27,680 --> 11:14:30,400
so let's try and build this and show you

16825
11:14:30,400 --> 11:14:33,276
this in action we are going to clear

16826
11:14:33,276 --> 11:14:35,276
and run rooster

16827
11:14:35,276 --> 11:14:37,116
and you're going to see that program is

16828
11:14:37,116 --> 11:14:39,756
ending well but in some cases it might

16829
11:14:39,756 --> 11:14:42,640
crash and hopefully this shows you the

16830
11:14:42,640 --> 11:14:43,840
danger

16831
11:14:43,840 --> 11:14:46,720
that these things might put you into

16832
11:14:46,720 --> 11:14:49,040
sometimes your program is going to seem

16833
11:14:49,040 --> 11:14:51,756
working fine but sometimes when this

16834
11:14:51,756 --> 11:14:54,160
memory that we are pointing to in p

16835
11:14:54,160 --> 11:14:56,480
number one here is being used to do

16836
11:14:56,480 --> 11:14:58,000
something really important by the

16837
11:14:58,000 --> 11:15:00,400
operating system you are going to get a

16838
11:15:00,400 --> 11:15:02,720
crash so you're not guaranteed to get

16839
11:15:02,720 --> 11:15:05,276
the same behavior every time you run

16840
11:15:05,276 --> 11:15:07,360
your program some of you might be saying

16841
11:15:07,360 --> 11:15:09,916
aha the program is working here daniel

16842
11:15:09,916 --> 11:15:13,276
why are you making this such a big deal

16843
11:15:13,276 --> 11:15:15,916
well it is a big deal because you are

16844
11:15:15,916 --> 11:15:18,240
not guaranteed to get the same results

16845
11:15:18,240 --> 11:15:21,436
every time you run this program so be

16846
11:15:21,436 --> 11:15:24,000
sure you really avoid these kinds of

16847
11:15:24,000 --> 11:15:26,000
situations let's try and clear and run

16848
11:15:26,000 --> 11:15:27,596
the program again hopefully we're going

16849
11:15:27,596 --> 11:15:30,640
to see it crash but we're not okay so

16850
11:15:30,640 --> 11:15:33,200
let's clear and rebuild again

16851
11:15:33,200 --> 11:15:35,116
and see that we have a better luck that

16852
11:15:35,116 --> 11:15:36,720
time

16853
11:15:36,720 --> 11:15:38,400
that's clear

16854
11:15:38,400 --> 11:15:41,040
and run rooster it is going to end well

16855
11:15:41,040 --> 11:15:43,116
but you notice that we are trying to use

16856
11:15:43,116 --> 11:15:45,596
a piece of memory that has already been

16857
11:15:45,596 --> 11:15:48,480
deleted and this is bad don't do this

16858
11:15:48,480 --> 11:15:51,040
make sure you don't do something like

16859
11:15:51,040 --> 11:15:52,640
this we're going to comment this out

16860
11:15:52,640 --> 11:15:55,200
again and show you another offending

16861
11:15:55,200 --> 11:15:57,916
thing we can do with our programs and

16862
11:15:57,916 --> 11:16:00,160
bad things might happen if you try to

16863
11:16:00,160 --> 11:16:02,880
have multiple pointers played into the

16864
11:16:02,880 --> 11:16:04,640
same address and that's what we have

16865
11:16:04,640 --> 11:16:07,040
here we have p number three and p number

16866
11:16:07,040 --> 11:16:09,596
four here p number three is allocating

16867
11:16:09,596 --> 11:16:12,080
new space and it is pointing to it we

16868
11:16:12,080 --> 11:16:15,680
have an 83 inside and a p number four is

16869
11:16:15,680 --> 11:16:17,840
initialized with p number three we can

16870
11:16:17,840 --> 11:16:20,320
do that so these two pointers are

16871
11:16:20,320 --> 11:16:23,436
basically pointing to the same memory

16872
11:16:23,436 --> 11:16:24,720
location

16873
11:16:24,720 --> 11:16:27,040
let's run this and show you that

16874
11:16:27,040 --> 11:16:28,960
we're going to comment out this delete

16875
11:16:28,960 --> 11:16:32,080
statement here and run the program first

16876
11:16:32,080 --> 11:16:34,480
to really prove that they are pointing

16877
11:16:34,480 --> 11:16:36,720
to the same addresses and they contain

16878
11:16:36,720 --> 11:16:40,080
the same values let's build and run

16879
11:16:40,080 --> 11:16:43,200
we're going to use gcc for that

16880
11:16:43,200 --> 11:16:45,200
and we're going to clear and run rooster

16881
11:16:45,200 --> 11:16:46,720
and you see that

16882
11:16:46,720 --> 11:16:48,960
p number three the address is this and

16883
11:16:48,960 --> 11:16:51,276
it contains an 83 p number four contains

16884
11:16:51,276 --> 11:16:52,800
the same thanks

16885
11:16:52,800 --> 11:16:55,200
so let's see what happens if we try to

16886
11:16:55,200 --> 11:16:58,480
delete using p number three

16887
11:16:58,480 --> 11:17:01,520
and using p number four later to try and

16888
11:17:01,520 --> 11:17:03,360
read stuff this is what we are doing

16889
11:17:03,360 --> 11:17:04,160
here

16890
11:17:04,160 --> 11:17:06,400
and we're going to see if the program

16891
11:17:06,400 --> 11:17:08,800
actually gets to end well

16892
11:17:08,800 --> 11:17:10,480
we're going to build again the world is

16893
11:17:10,480 --> 11:17:12,560
going to be good let's bring this up and

16894
11:17:12,560 --> 11:17:14,880
clear and run rooster

16895
11:17:14,880 --> 11:17:16,560
and you're going to see that the program

16896
11:17:16,560 --> 11:17:18,480
is also going to end well

16897
11:17:18,480 --> 11:17:21,116
but we are using a deleted piece of

16898
11:17:21,116 --> 11:17:23,596
memory here and anything can really

16899
11:17:23,596 --> 11:17:26,240
happen okay so you might get garbage you

16900
11:17:26,240 --> 11:17:28,480
might have really any piece of junk

16901
11:17:28,480 --> 11:17:32,160
inside or you might get a crush in some

16902
11:17:32,160 --> 11:17:34,720
extreme cases so this is really bad

16903
11:17:34,720 --> 11:17:37,436
don't do it don't try to use a piece of

16904
11:17:37,436 --> 11:17:40,080
memory that you have already deleted

16905
11:17:40,080 --> 11:17:42,320
through a pointer and these are problems

16906
11:17:42,320 --> 11:17:44,320
you might run into in your programs if

16907
11:17:44,320 --> 11:17:47,116
you try to use dynamic memory allocation

16908
11:17:47,116 --> 11:17:49,756
let's look at how we can solve them

16909
11:17:49,756 --> 11:17:51,040
and the

16910
11:17:51,040 --> 11:17:52,400
ultimate advice

16911
11:17:52,400 --> 11:17:53,680
is to

16912
11:17:53,680 --> 11:17:56,080
make sure you put a little ptr in a

16913
11:17:56,080 --> 11:17:58,960
pointer if you don't know what that

16914
11:17:58,960 --> 11:18:01,116
pointer is actually stored at okay let's

16915
11:18:01,116 --> 11:18:03,520
go down and look at solution one

16916
11:18:03,520 --> 11:18:05,360
solution one is to initialize your

16917
11:18:05,360 --> 11:18:08,240
pointer to no pointer every time if you

16918
11:18:08,240 --> 11:18:10,160
don't have a value you can put in use

16919
11:18:10,160 --> 11:18:12,720
null ptr that's what we are using here

16920
11:18:12,720 --> 11:18:15,360
implicitly but we can explicitly put

16921
11:18:15,360 --> 11:18:18,080
that end because it is good and before

16922
11:18:18,080 --> 11:18:20,640
you use a pointer you have to check and

16923
11:18:20,640 --> 11:18:23,436
see if it doesn't contain null pointer

16924
11:18:23,436 --> 11:18:26,000
this is how we do it if pointer six is

16925
11:18:26,000 --> 11:18:28,160
different from null pointer we're going

16926
11:18:28,160 --> 11:18:30,640
to use it if it is equal to no pointer

16927
11:18:30,640 --> 11:18:31,916
we're not going to use it and we're

16928
11:18:31,916 --> 11:18:34,160
going to be playing on the safe side and

16929
11:18:34,160 --> 11:18:35,680
you're going to see that the program is

16930
11:18:35,680 --> 11:18:38,160
going to end well here if we have a null

16931
11:18:38,160 --> 11:18:41,360
ptr inside we can say

16932
11:18:41,360 --> 11:18:42,720
else here

16933
11:18:42,720 --> 11:18:44,400
and say

16934
11:18:44,400 --> 11:18:47,360
invalid address okay and that the user

16935
11:18:47,360 --> 11:18:49,756
is going to know that they are trying to

16936
11:18:49,756 --> 11:18:52,320
do something really bad so let's try and

16937
11:18:52,320 --> 11:18:54,800
check against p number five

16938
11:18:54,800 --> 11:18:57,756
so let's go and store a null pointer in

16939
11:18:57,756 --> 11:19:00,800
p number six to really try this out and

16940
11:19:00,800 --> 11:19:02,880
show you that we're going to get this

16941
11:19:02,880 --> 11:19:05,200
warning if we're trying to use it

16942
11:19:05,200 --> 11:19:07,756
and we're going to build with gcc and

16943
11:19:07,756 --> 11:19:10,240
we're going to clear and run rooster

16944
11:19:10,240 --> 11:19:12,320
you're going to see that invalid address

16945
11:19:12,320 --> 11:19:14,640
and the program is going to end well

16946
11:19:14,640 --> 11:19:17,680
and if we try to put this statement

16947
11:19:17,680 --> 11:19:19,680
somewhere where we're not shaking

16948
11:19:19,680 --> 11:19:21,520
against

16949
11:19:21,520 --> 11:19:23,916
no pointer we are going to get a crash

16950
11:19:23,916 --> 11:19:26,080
so let's comment this out so that it's

16951
11:19:26,080 --> 11:19:29,116
clear what it is we are running here

16952
11:19:29,116 --> 11:19:30,640
so if we run this we're going to get a

16953
11:19:30,640 --> 11:19:32,720
crash we have seen that but let's show

16954
11:19:32,720 --> 11:19:34,240
this again

16955
11:19:34,240 --> 11:19:37,200
and really highlight that we are solving

16956
11:19:37,200 --> 11:19:39,596
the problem here if we run rooster the

16957
11:19:39,596 --> 11:19:41,520
program is going to crash because we are

16958
11:19:41,520 --> 11:19:43,160
trying to use

16959
11:19:43,160 --> 11:19:44,800
uninitialized

16960
11:19:44,800 --> 11:19:48,000
memory but if we try and check against

16961
11:19:48,000 --> 11:19:50,880
no ptr like we are doing here let's do

16962
11:19:50,880 --> 11:19:52,800
that we're going to be playing on the

16963
11:19:52,800 --> 11:19:54,800
safe side because it's going to tell us

16964
11:19:54,800 --> 11:19:56,960
invalid address and we're not going to

16965
11:19:56,960 --> 11:19:59,360
get a crush and the program is going to

16966
11:19:59,360 --> 11:20:01,200
end well this is really cool so let's

16967
11:20:01,200 --> 11:20:02,720
try and do that again we're going to

16968
11:20:02,720 --> 11:20:05,116
world

16969
11:20:05,436 --> 11:20:07,200
the world is going to be good we can

16970
11:20:07,200 --> 11:20:10,000
clear and run rooster and the program is

16971
11:20:10,000 --> 11:20:13,520
going to end well okay so if we have a

16972
11:20:13,520 --> 11:20:15,840
value inside we're going to get that so

16973
11:20:15,840 --> 11:20:18,320
let's put that n and say new ant and put

16974
11:20:18,320 --> 11:20:21,116
in an 87 for example it doesn't really

16975
11:20:21,116 --> 11:20:23,040
matter what we put in

16976
11:20:23,040 --> 11:20:24,800
so we're going to build again the work

16977
11:20:24,800 --> 11:20:26,880
is going to be good and we can run

16978
11:20:26,880 --> 11:20:29,200
rooster and you see that we are getting

16979
11:20:29,200 --> 11:20:31,916
a value here if we are not storing no

16980
11:20:31,916 --> 11:20:34,640
ptlr in p number six and you can do the

16981
11:20:34,640 --> 11:20:37,360
same checks against p number five but i

16982
11:20:37,360 --> 11:20:40,240
think this is really enough so this is

16983
11:20:40,240 --> 11:20:43,840
one way you can avoid dangling pointers

16984
11:20:43,840 --> 11:20:45,596
the next thing we're going to look at is

16985
11:20:45,596 --> 11:20:48,240
if we are using a deleted pointer and

16986
11:20:48,240 --> 11:20:50,480
again the solution is to set a pointer

16987
11:20:50,480 --> 11:20:52,880
to no ptr

16988
11:20:52,880 --> 11:20:55,596
after we delete it here we have p number

16989
11:20:55,596 --> 11:20:59,040
seven it has 82 inside we are using it

16990
11:20:59,040 --> 11:21:01,116
here and printing stuff out we're going

16991
11:21:01,116 --> 11:21:03,360
to delete it after we are done using it

16992
11:21:03,360 --> 11:21:05,276
and after that

16993
11:21:05,276 --> 11:21:07,840
the first thing we do is to reset it to

16994
11:21:07,840 --> 11:21:11,116
no ptr when we do that other people or

16995
11:21:11,116 --> 11:21:13,360
even ourselves have a chance to check it

16996
11:21:13,360 --> 11:21:15,916
against no ptr and we're going to know

16997
11:21:15,916 --> 11:21:18,320
that it doesn't contain anything

16998
11:21:18,320 --> 11:21:19,360
useful

16999
11:21:19,360 --> 11:21:21,680
for our program and if we do something

17000
11:21:21,680 --> 11:21:23,116
like this

17001
11:21:23,116 --> 11:21:25,116
we're not going to run into all these

17002
11:21:25,116 --> 11:21:27,276
weird problems

17003
11:21:27,276 --> 11:21:28,880
and our program is going to have

17004
11:21:28,880 --> 11:21:30,800
consistent behavior

17005
11:21:30,800 --> 11:21:32,960
across different runs and this is really

17006
11:21:32,960 --> 11:21:34,640
cool so we're going to run this we're

17007
11:21:34,640 --> 11:21:36,880
going to get things printed out and the

17008
11:21:36,880 --> 11:21:39,756
program is going to end well because

17009
11:21:39,756 --> 11:21:43,680
right now we are checking against no ptr

17010
11:21:43,680 --> 11:21:45,916
we can even be explicit in showing the

17011
11:21:45,916 --> 11:21:48,720
warning here we can say invalid memory

17012
11:21:48,720 --> 11:21:51,756
access and if you run this program

17013
11:21:51,756 --> 11:21:53,276
you're going to really know this so

17014
11:21:53,276 --> 11:21:55,276
let's finish this up and we're going to

17015
11:21:55,276 --> 11:21:57,840
bolt and the bulk is going to be good if

17016
11:21:57,840 --> 11:21:59,840
we run this and run rooster we're going

17017
11:21:59,840 --> 11:22:02,000
to know that we are doing any valid

17018
11:22:02,000 --> 11:22:04,800
memory access after we have deleted the

17019
11:22:04,800 --> 11:22:06,480
pointer and this is going to save you

17020
11:22:06,480 --> 11:22:09,276
from possible crashes that you might

17021
11:22:09,276 --> 11:22:11,916
experience if you don't do this so this

17022
11:22:11,916 --> 11:22:14,400
is a second solution you might want to

17023
11:22:14,400 --> 11:22:16,400
implement in your programs

17024
11:22:16,400 --> 11:22:18,400
and i'm going to comment it out and show

17025
11:22:18,400 --> 11:22:20,800
you how you can get away from the

17026
11:22:20,800 --> 11:22:23,436
problem of when you have

17027
11:22:23,436 --> 11:22:25,680
multiple pointers pointing to the same

17028
11:22:25,680 --> 11:22:27,840
address we are going to go down and put

17029
11:22:27,840 --> 11:22:29,916
in the code it is what you have seen in

17030
11:22:29,916 --> 11:22:32,560
the slides and it is really nothing new

17031
11:22:32,560 --> 11:22:34,960
so we have pointer eight and pointer

17032
11:22:34,960 --> 11:22:37,276
nine here and p number eight here is

17033
11:22:37,276 --> 11:22:38,720
pointing to

17034
11:22:38,720 --> 11:22:40,560
dynamic memory

17035
11:22:40,560 --> 11:22:43,840
and the value inside is 382

17036
11:22:43,840 --> 11:22:45,840
p number nine is initialized with

17037
11:22:45,840 --> 11:22:48,080
whatever we have in p number eight so

17038
11:22:48,080 --> 11:22:49,360
they are going to be pointing to the

17039
11:22:49,360 --> 11:22:52,640
same addresses here but we have made p

17040
11:22:52,640 --> 11:22:55,116
number eight the master pointer so it is

17041
11:22:55,116 --> 11:22:57,040
the only pointer that is going to be

17042
11:22:57,040 --> 11:22:59,680
able to delete this memory location even

17043
11:22:59,680 --> 11:23:01,520
if we have multiple pointers pointing to

17044
11:23:01,520 --> 11:23:02,640
that

17045
11:23:02,640 --> 11:23:04,640
okay so every time we want to use this

17046
11:23:04,640 --> 11:23:07,360
memory we have the option to check

17047
11:23:07,360 --> 11:23:09,596
against the master pointer and see that

17048
11:23:09,596 --> 11:23:12,640
we have some valid data inside if it is

17049
11:23:12,640 --> 11:23:14,720
no pointer we're not going to use that

17050
11:23:14,720 --> 11:23:16,640
and we're going to be playing on the

17051
11:23:16,640 --> 11:23:18,720
safe side this is really what we are

17052
11:23:18,720 --> 11:23:20,560
doing here if we run this we're going to

17053
11:23:20,560 --> 11:23:22,240
see that the program is going to end

17054
11:23:22,240 --> 11:23:23,360
well

17055
11:23:23,360 --> 11:23:25,276
the world is going to be good and if we

17056
11:23:25,276 --> 11:23:26,720
run rooster we're going to see that we

17057
11:23:26,720 --> 11:23:28,480
get things printed out we're going to go

17058
11:23:28,480 --> 11:23:29,916
through p number eight we're going to

17059
11:23:29,916 --> 11:23:31,680
print stuff we're going to go through p

17060
11:23:31,680 --> 11:23:33,596
number nine we're going to print stuff

17061
11:23:33,596 --> 11:23:36,400
and if we try to use the pointer

17062
11:23:36,400 --> 11:23:38,320
after the

17063
11:23:38,320 --> 11:23:40,480
memory has been deleted we're going to

17064
11:23:40,480 --> 11:23:42,880
get a clear warning that we are trying

17065
11:23:42,880 --> 11:23:45,116
to do something really bad and this is

17066
11:23:45,116 --> 11:23:48,160
really what you should aim for in your c

17067
11:23:48,160 --> 11:23:50,880
plus plus programs that use dynamic

17068
11:23:50,880 --> 11:23:53,436
memory allocation and pointers

17069
11:23:53,436 --> 11:23:55,040
this is really all we set out to do in

17070
11:23:55,040 --> 11:23:56,960
this lecture i hope you know how you can

17071
11:23:56,960 --> 11:23:58,880
avoid these problems with dangling

17072
11:23:58,880 --> 11:24:00,960
pointers we are going to stop here in

17073
11:24:00,960 --> 11:24:02,720
this lecture the next lecture we're

17074
11:24:02,720 --> 11:24:05,040
going to see what can happen

17075
11:24:05,040 --> 11:24:07,360
if this new operator

17076
11:24:07,360 --> 11:24:09,436
fails to give you the memory that you

17077
11:24:09,436 --> 11:24:11,596
want to allocate on the heap and that's

17078
11:24:11,596 --> 11:24:14,240
possible go ahead and finish up here

17079
11:24:14,240 --> 11:24:16,400
and meet me there in this lecture we're

17080
11:24:16,400 --> 11:24:20,000
going to explore what happens when new

17081
11:24:20,000 --> 11:24:22,400
fails in the last lecture we saw that we

17082
11:24:22,400 --> 11:24:25,040
could use the new operator to allocate

17083
11:24:25,040 --> 11:24:28,000
for new memory on the heap and use that

17084
11:24:28,000 --> 11:24:30,880
to do stuff and in most cases the new

17085
11:24:30,880 --> 11:24:33,276
operator is going to succeed but in some

17086
11:24:33,276 --> 11:24:36,400
rare cases it is going to fail and when

17087
11:24:36,400 --> 11:24:38,400
you don't do anything about that failure

17088
11:24:38,400 --> 11:24:40,640
your program is just going to crash and

17089
11:24:40,640 --> 11:24:42,800
you might want to do something about

17090
11:24:42,800 --> 11:24:45,756
that i have to say that it is very rare

17091
11:24:45,756 --> 11:24:48,080
for new to fail in practice so you're

17092
11:24:48,080 --> 11:24:50,880
going to see a lot of code out there

17093
11:24:50,880 --> 11:24:53,360
that just uses the new operator it

17094
11:24:53,360 --> 11:24:55,756
doesn't really care about

17095
11:24:55,756 --> 11:24:58,480
checking if the operation actually

17096
11:24:58,480 --> 11:25:01,200
failed or succeeded so this is a very

17097
11:25:01,200 --> 11:25:03,520
rare case but if you need to handle it

17098
11:25:03,520 --> 11:25:05,200
we're going to see how you can do that

17099
11:25:05,200 --> 11:25:08,000
in this lecture here is a simple example

17100
11:25:08,000 --> 11:25:10,880
that is going to try and force the new

17101
11:25:10,880 --> 11:25:12,560
operator to fail

17102
11:25:12,560 --> 11:25:14,640
in the first segment here we are using

17103
11:25:14,640 --> 11:25:17,360
the new operator but we are using a

17104
11:25:17,360 --> 11:25:20,640
syntax that is going to try and allocate

17105
11:25:20,640 --> 11:25:23,756
a lot of integers in one go you see that

17106
11:25:23,756 --> 11:25:25,756
it is an array but we haven't really

17107
11:25:25,756 --> 11:25:27,680
seen how we can use an array like this

17108
11:25:27,680 --> 11:25:30,640
so just think of this code as a piece of

17109
11:25:30,640 --> 11:25:33,200
code that is going to allocate a lot of

17110
11:25:33,200 --> 11:25:35,596
integers in one go and we're going to

17111
11:25:35,596 --> 11:25:38,240
try and make this fail

17112
11:25:38,240 --> 11:25:40,400
i have to say that this may give you an

17113
11:25:40,400 --> 11:25:42,720
error on some compilers saying that you

17114
11:25:42,720 --> 11:25:45,040
are exceeding the array size if that's

17115
11:25:45,040 --> 11:25:46,800
the case no problem we're going to find

17116
11:25:46,800 --> 11:25:49,040
another way to get this new operator to

17117
11:25:49,040 --> 11:25:51,116
fail we are going to put a thing like

17118
11:25:51,116 --> 11:25:52,960
this in a loop and we're going to loop a

17119
11:25:52,960 --> 11:25:56,240
lot of times enough to exhaust the heap

17120
11:25:56,240 --> 11:25:59,116
that is allocated to our program here

17121
11:25:59,116 --> 11:26:00,480
and when that happens you're going to

17122
11:26:00,480 --> 11:26:02,400
see that the program is going to crash

17123
11:26:02,400 --> 11:26:05,840
and it is bad so new can fail and if you

17124
11:26:05,840 --> 11:26:08,720
need to play on the server side you're

17125
11:26:08,720 --> 11:26:09,680
going to

17126
11:26:09,680 --> 11:26:12,480
handle that problem and we have two ways

17127
11:26:12,480 --> 11:26:15,040
we can handle this problem we can go

17128
11:26:15,040 --> 11:26:17,596
through the exception mechanism this is

17129
11:26:17,596 --> 11:26:20,720
a built-in way we have in c plus plus to

17130
11:26:20,720 --> 11:26:23,116
check for arrows and handle them we can

17131
11:26:23,116 --> 11:26:26,480
also use the std no throw setting

17132
11:26:26,480 --> 11:26:29,520
in our new operator and force it not to

17133
11:26:29,520 --> 11:26:31,680
throw an exception and it's going to

17134
11:26:31,680 --> 11:26:33,916
give us no pointer if the allocation

17135
11:26:33,916 --> 11:26:36,320
fails i know this might sound cryptic

17136
11:26:36,320 --> 11:26:37,916
right now but we're going to see an

17137
11:26:37,916 --> 11:26:39,680
example shortly and you're going to

17138
11:26:39,680 --> 11:26:41,916
understand this let's look at how we can

17139
11:26:41,916 --> 11:26:43,756
use the exception mechanism the

17140
11:26:43,756 --> 11:26:46,400
exception mechanism is there in c plus

17141
11:26:46,400 --> 11:26:49,040
plus to let you handle problems when

17142
11:26:49,040 --> 11:26:51,840
they arise and the way you use that you

17143
11:26:51,840 --> 11:26:54,480
wrap code that is potentially going to

17144
11:26:54,480 --> 11:26:56,160
give you problems

17145
11:26:56,160 --> 11:26:59,276
and try and catch blocks you see here

17146
11:26:59,276 --> 11:27:01,916
inside the loop we are saying try

17147
11:27:01,916 --> 11:27:04,400
and inside the tri blocks we have the

17148
11:27:04,400 --> 11:27:06,800
code that could fail we have our new

17149
11:27:06,800 --> 11:27:07,916
operator

17150
11:27:07,916 --> 11:27:10,880
and in the catch block you see we have a

17151
11:27:10,880 --> 11:27:13,360
catch block here we're going to

17152
11:27:13,360 --> 11:27:15,916
say that we have a problem

17153
11:27:15,916 --> 11:27:17,520
and we have a way of catching the

17154
11:27:17,520 --> 11:27:19,520
problem and if you look at this thing we

17155
11:27:19,520 --> 11:27:22,880
have in this parenthesis after catch we

17156
11:27:22,880 --> 11:27:26,800
have an ex variable and we can ask it

17157
11:27:26,800 --> 11:27:29,276
what kind of problem happened

17158
11:27:29,276 --> 11:27:31,520
leading to this exception happening in

17159
11:27:31,520 --> 11:27:33,596
our code you can think of this like this

17160
11:27:33,596 --> 11:27:35,840
i realize we haven't really talked about

17161
11:27:35,840 --> 11:27:38,160
exceptions we are going to talk about

17162
11:27:38,160 --> 11:27:39,916
them later in the course when we have

17163
11:27:39,916 --> 11:27:41,680
enough tools to really understand what

17164
11:27:41,680 --> 11:27:43,756
is happening but now

17165
11:27:43,756 --> 11:27:46,720
think of them as a tool to handle

17166
11:27:46,720 --> 11:27:49,276
when the new operator fails and you're

17167
11:27:49,276 --> 11:27:51,200
not going to crash your program your

17168
11:27:51,200 --> 11:27:53,360
program will keep running it will go

17169
11:27:53,360 --> 11:27:55,840
through the end but the new operation

17170
11:27:55,840 --> 11:27:58,400
that you wanted to do here will fail and

17171
11:27:58,400 --> 11:28:00,160
you will be able to catch that and this

17172
11:28:00,160 --> 11:28:02,240
is a good thing if you don't want to use

17173
11:28:02,240 --> 11:28:04,800
exceptions you can use the std no throw

17174
11:28:04,800 --> 11:28:06,160
option

17175
11:28:06,160 --> 11:28:08,240
and this is a new version of the new

17176
11:28:08,240 --> 11:28:11,436
operator you can use to tell the c plus

17177
11:28:11,436 --> 11:28:13,840
plus system to not throw an exception

17178
11:28:13,840 --> 11:28:16,160
when the operation fails it is just

17179
11:28:16,160 --> 11:28:18,080
going to return no pointer and you can

17180
11:28:18,080 --> 11:28:19,756
check for that and know that memory

17181
11:28:19,756 --> 11:28:22,560
allocation actually failed this is what

17182
11:28:22,560 --> 11:28:23,840
we're going to talk about in this

17183
11:28:23,840 --> 11:28:25,680
lecture i hope you have an idea about

17184
11:28:25,680 --> 11:28:27,520
this we're going to head over to visual

17185
11:28:27,520 --> 11:28:29,916
studio code and actually try this in

17186
11:28:29,916 --> 11:28:32,960
action okay here we are in our working

17187
11:28:32,960 --> 11:28:35,200
directory the current project is when

17188
11:28:35,200 --> 11:28:36,400
new fails

17189
11:28:36,400 --> 11:28:38,880
we are going to grab our template files

17190
11:28:38,880 --> 11:28:41,436
like we always do and we're going to put

17191
11:28:41,436 --> 11:28:44,560
them in place so when new fails that's

17192
11:28:44,560 --> 11:28:46,720
the lecture so we're going to do that

17193
11:28:46,720 --> 11:28:49,200
and open this in visual studio code

17194
11:28:49,200 --> 11:28:51,436
pretty quick and we are going to try and

17195
11:28:51,436 --> 11:28:54,240
allocate a large piece of memory in one

17196
11:28:54,240 --> 11:28:56,320
go so the way you do that we can do say

17197
11:28:56,320 --> 11:28:57,596
end pointer

17198
11:28:57,596 --> 11:28:59,520
let's call this data it really doesn't

17199
11:28:59,520 --> 11:29:02,480
matter and we're going to say new and

17200
11:29:02,480 --> 11:29:04,240
and we're going to say that we want a

17201
11:29:04,240 --> 11:29:05,916
huge amount of events

17202
11:29:05,916 --> 11:29:08,480
let's try and do that and we're going to

17203
11:29:08,480 --> 11:29:11,116
go down and say program

17204
11:29:11,116 --> 11:29:13,200
ending well to make sure

17205
11:29:13,200 --> 11:29:16,960
we know when we are ending this program

17206
11:29:16,960 --> 11:29:19,520
properly so let's try and compile this

17207
11:29:19,520 --> 11:29:21,756
we're going to bring up the terminal and

17208
11:29:21,756 --> 11:29:24,800
we are going to weld with gcc as we

17209
11:29:24,800 --> 11:29:26,800
always do and the build is going to be

17210
11:29:26,800 --> 11:29:29,040
good let's try and increase this number

17211
11:29:29,040 --> 11:29:31,680
and push it to a really big number and

17212
11:29:31,680 --> 11:29:33,116
you see that we

17213
11:29:33,116 --> 11:29:36,320
have made visual studio code mad here

17214
11:29:36,320 --> 11:29:38,720
array is too large so they can't really

17215
11:29:38,720 --> 11:29:39,840
allow us

17216
11:29:39,840 --> 11:29:40,800
to do

17217
11:29:40,800 --> 11:29:43,200
a really large array in here okay so

17218
11:29:43,200 --> 11:29:45,520
let's bring this down a little bit

17219
11:29:45,520 --> 11:29:47,520
and if we're trying to compile the

17220
11:29:47,520 --> 11:29:49,596
bullet is going to be good and if we run

17221
11:29:49,596 --> 11:29:53,116
rooster you see that the program

17222
11:29:53,116 --> 11:29:56,800
is going to not end well okay so this is

17223
11:29:56,800 --> 11:29:59,116
really a case where new fails we can't

17224
11:29:59,116 --> 11:30:01,520
really allocate this much

17225
11:30:01,520 --> 11:30:04,160
on the heap storage that is allocated to

17226
11:30:04,160 --> 11:30:06,720
this program here remember when we

17227
11:30:06,720 --> 11:30:09,596
revisited the memory map idea we saw

17228
11:30:09,596 --> 11:30:11,436
that each program is going to have its

17229
11:30:11,436 --> 11:30:13,596
own memory map the memory map is going

17230
11:30:13,596 --> 11:30:15,436
to have a lot of sections inside we have

17231
11:30:15,436 --> 11:30:17,756
the stack we have the heap our hip is

17232
11:30:17,756 --> 11:30:20,240
not infinite so we can run out and we

17233
11:30:20,240 --> 11:30:22,240
just ran out with this allocation that

17234
11:30:22,240 --> 11:30:25,040
we did here and our program is going to

17235
11:30:25,040 --> 11:30:26,960
terminate immediately you see that it is

17236
11:30:26,960 --> 11:30:28,480
not ending well

17237
11:30:28,480 --> 11:30:30,400
if this is not working for whatever

17238
11:30:30,400 --> 11:30:33,436
compiler you are using we can go and do

17239
11:30:33,436 --> 11:30:35,680
this through a loop so what we can do we

17240
11:30:35,680 --> 11:30:36,400
can

17241
11:30:36,400 --> 11:30:38,640
comment this out and we can really loop

17242
11:30:38,640 --> 11:30:40,960
many many times enough to exhaust the

17243
11:30:40,960 --> 11:30:44,240
memory that is allocated for this

17244
11:30:44,240 --> 11:30:46,960
process here rooster.exe

17245
11:30:46,960 --> 11:30:49,040
in the memory map in the hip section

17246
11:30:49,040 --> 11:30:52,320
that's what i mean and if we do this at

17247
11:30:52,320 --> 11:30:54,640
some point the program is going to fail

17248
11:30:54,640 --> 11:30:56,400
and we're going to get the same problem

17249
11:30:56,400 --> 11:30:58,720
here so let's build again

17250
11:30:58,720 --> 11:31:01,756
we're going to build with gcc

17251
11:31:01,756 --> 11:31:04,000
and we are going to clear and run

17252
11:31:04,000 --> 11:31:05,520
rooster and we're going to see it's

17253
11:31:05,520 --> 11:31:07,116
going to loop loop loop and it's going

17254
11:31:07,116 --> 11:31:09,276
to fail we're going to see

17255
11:31:09,276 --> 11:31:11,276
the failure in a minute and we need to

17256
11:31:11,276 --> 11:31:13,680
find a way to solve this problem we have

17257
11:31:13,680 --> 11:31:15,840
seen that we have two options let's

17258
11:31:15,840 --> 11:31:17,360
comment this out

17259
11:31:17,360 --> 11:31:19,840
and uh look at those solutions here the

17260
11:31:19,840 --> 11:31:21,756
first option is to go through the

17261
11:31:21,756 --> 11:31:24,160
exception mechanism we can also use the

17262
11:31:24,160 --> 11:31:27,040
std no throw option we're going to try

17263
11:31:27,040 --> 11:31:29,756
the exception mechanism first and uh

17264
11:31:29,756 --> 11:31:31,360
what we do

17265
11:31:31,360 --> 11:31:34,880
is wrap possibly offending code in try

17266
11:31:34,880 --> 11:31:38,080
and catch blocks and we're going to say

17267
11:31:38,080 --> 11:31:40,480
try here and put a block and we're going

17268
11:31:40,480 --> 11:31:41,520
to say

17269
11:31:41,520 --> 11:31:44,160
catch and we're going to say std

17270
11:31:44,160 --> 11:31:46,560
exception and we're going to put an

17271
11:31:46,560 --> 11:31:49,276
ampersand symbol here just use this like

17272
11:31:49,276 --> 11:31:51,200
this and we're going to get a chance to

17273
11:31:51,200 --> 11:31:53,596
really explain these things when we have

17274
11:31:53,596 --> 11:31:56,000
enough tools to understand this for now

17275
11:31:56,000 --> 11:31:58,800
think of this as if i have code that is

17276
11:31:58,800 --> 11:32:01,040
potentially going to fail

17277
11:32:01,040 --> 11:32:03,200
like the new operator here i am going to

17278
11:32:03,200 --> 11:32:05,520
put that in the try block

17279
11:32:05,520 --> 11:32:08,000
and if something goes wrong we're going

17280
11:32:08,000 --> 11:32:10,800
to get the error in the catch block this

17281
11:32:10,800 --> 11:32:12,960
is the way we do these things here so

17282
11:32:12,960 --> 11:32:16,000
for example i can take my loop here

17283
11:32:16,000 --> 11:32:17,520
and copy it

17284
11:32:17,520 --> 11:32:20,640
and put that down below here

17285
11:32:20,640 --> 11:32:21,520
okay

17286
11:32:21,520 --> 11:32:24,400
and i know that this line of code could

17287
11:32:24,400 --> 11:32:26,160
fail okay

17288
11:32:26,160 --> 11:32:28,960
so i am going to wrap that inside try

17289
11:32:28,960 --> 11:32:31,116
and catch blocks so i am going to grab

17290
11:32:31,116 --> 11:32:32,160
that

17291
11:32:32,160 --> 11:32:35,116
and put that in my loop

17292
11:32:35,116 --> 11:32:37,520
let's do that and align this a little

17293
11:32:37,520 --> 11:32:38,640
bit

17294
11:32:38,640 --> 11:32:41,596
and we are going to take the potentially

17295
11:32:41,596 --> 11:32:43,436
offensive code

17296
11:32:43,436 --> 11:32:45,596
and put that

17297
11:32:45,596 --> 11:32:48,880
in the try block and when the operator

17298
11:32:48,880 --> 11:32:50,240
here fails

17299
11:32:50,240 --> 11:32:51,840
something goes wrong and we're going to

17300
11:32:51,840 --> 11:32:53,756
catch the problem in the catch block

17301
11:32:53,756 --> 11:32:56,400
this is what we mean here again we don't

17302
11:32:56,400 --> 11:32:58,720
have enough tools to understand why we

17303
11:32:58,720 --> 11:33:00,320
are doing this thing here what is the

17304
11:33:00,320 --> 11:33:02,640
meaning of this ampersand symbol we're

17305
11:33:02,640 --> 11:33:04,240
going to learn about that later in the

17306
11:33:04,240 --> 11:33:06,480
course but for now we want to put

17307
11:33:06,480 --> 11:33:09,520
together something good enough for this

17308
11:33:09,520 --> 11:33:13,200
program not to crash like it was doing

17309
11:33:13,200 --> 11:33:14,800
right here okay we're going to catch the

17310
11:33:14,800 --> 11:33:17,840
arrow and say something went wrong

17311
11:33:17,840 --> 11:33:19,360
and we're going to print out what

17312
11:33:19,360 --> 11:33:21,200
actually went wrong we're going to say

17313
11:33:21,200 --> 11:33:23,520
ex and we can call

17314
11:33:23,520 --> 11:33:26,400
a function called what on this

17315
11:33:26,400 --> 11:33:28,840
and we can say sdd

17316
11:33:28,840 --> 11:33:30,640
endl

17317
11:33:30,640 --> 11:33:33,360
let's hide this pen here because we want

17318
11:33:33,360 --> 11:33:36,080
to see clearly what is happening here

17319
11:33:36,080 --> 11:33:38,720
this is how you can prevent your program

17320
11:33:38,720 --> 11:33:40,800
from crashing and it is going to end

17321
11:33:40,800 --> 11:33:42,840
well because now we have handled the

17322
11:33:42,840 --> 11:33:45,916
problem and that we haven't caused a

17323
11:33:45,916 --> 11:33:46,960
crash

17324
11:33:46,960 --> 11:33:49,360
like we were doing down here now we're

17325
11:33:49,360 --> 11:33:51,436
going to try and build this code let's

17326
11:33:51,436 --> 11:33:53,520
bring it up a little bit so that it is

17327
11:33:53,520 --> 11:33:55,596
not messy here

17328
11:33:55,596 --> 11:33:57,756
and we're going to weld with gcc the

17329
11:33:57,756 --> 11:33:59,756
bolt is going to be good and we're going

17330
11:33:59,756 --> 11:34:02,560
to clear and run rooster and it is going

17331
11:34:02,560 --> 11:34:04,160
to do its thing it's going to keep

17332
11:34:04,160 --> 11:34:06,320
looping around

17333
11:34:06,320 --> 11:34:08,160
and it's going to say something went bad

17334
11:34:08,160 --> 11:34:09,520
it's going to hit a point where all

17335
11:34:09,520 --> 11:34:11,756
these allocations are going to fail and

17336
11:34:11,756 --> 11:34:13,756
if we really wait for it it is going to

17337
11:34:13,756 --> 11:34:15,596
end and we're going to see that it's

17338
11:34:15,596 --> 11:34:16,960
going to end well

17339
11:34:16,960 --> 11:34:19,680
let's try and hit ctrl c and terminate

17340
11:34:19,680 --> 11:34:21,200
it because we don't want to wait for

17341
11:34:21,200 --> 11:34:22,800
this amount of time

17342
11:34:22,800 --> 11:34:24,480
and let's bring that

17343
11:34:24,480 --> 11:34:27,040
down to 100 and increase this number

17344
11:34:27,040 --> 11:34:27,916
here

17345
11:34:27,916 --> 11:34:30,480
let's see if that actually works so

17346
11:34:30,480 --> 11:34:32,400
we're going to boil for now we just want

17347
11:34:32,400 --> 11:34:34,320
to see that the program is not really

17348
11:34:34,320 --> 11:34:35,680
crushing

17349
11:34:35,680 --> 11:34:38,000
so we're going to run rooster and you

17350
11:34:38,000 --> 11:34:38,960
see that

17351
11:34:38,960 --> 11:34:41,200
it's going to keep running and at some

17352
11:34:41,200 --> 11:34:42,320
point

17353
11:34:42,320 --> 11:34:44,160
it's going to fail to allocate memory

17354
11:34:44,160 --> 11:34:45,756
and it's going to say something went

17355
11:34:45,756 --> 11:34:48,000
wrong but if you keep going down you're

17356
11:34:48,000 --> 11:34:50,240
going to see that the program is ending

17357
11:34:50,240 --> 11:34:51,116
well

17358
11:34:51,116 --> 11:34:53,680
so what is happening here is that

17359
11:34:53,680 --> 11:34:56,160
the new operator actually failed

17360
11:34:56,160 --> 11:34:59,040
but we code the problem and could handle

17361
11:34:59,040 --> 11:35:02,160
it in here so what is called handling

17362
11:35:02,160 --> 11:35:03,360
the problem

17363
11:35:03,360 --> 11:35:04,880
you're going to handle it in whatever

17364
11:35:04,880 --> 11:35:07,200
makes sense in your program if we were

17365
11:35:07,200 --> 11:35:09,680
for example trying to set up a color in

17366
11:35:09,680 --> 11:35:10,640
some

17367
11:35:10,640 --> 11:35:13,116
widgets in your application and the

17368
11:35:13,116 --> 11:35:15,360
color fails and you fail to set up the

17369
11:35:15,360 --> 11:35:17,360
color you may show your user interface

17370
11:35:17,360 --> 11:35:19,680
in black and white and keep running your

17371
11:35:19,680 --> 11:35:21,840
program instead of getting it crashed

17372
11:35:21,840 --> 11:35:24,080
this is just a way to show you

17373
11:35:24,080 --> 11:35:26,000
that you can handle stuff

17374
11:35:26,000 --> 11:35:28,800
when new fails this is one way we can

17375
11:35:28,800 --> 11:35:30,240
solve the problem so we're going to look

17376
11:35:30,240 --> 11:35:31,916
at the second way

17377
11:35:31,916 --> 11:35:34,640
the exception mechanism is the first

17378
11:35:34,640 --> 11:35:36,240
so we're going to comment this out

17379
11:35:36,240 --> 11:35:38,560
because we're going to see another way

17380
11:35:38,560 --> 11:35:40,960
and let's do that we can also use the

17381
11:35:40,960 --> 11:35:44,640
std no throw setting on our new operator

17382
11:35:44,640 --> 11:35:46,160
when we are

17383
11:35:46,160 --> 11:35:48,640
allocating for new memory so we're going

17384
11:35:48,640 --> 11:35:51,276
to do that and we're going to bring up

17385
11:35:51,276 --> 11:35:52,640
our loop here

17386
11:35:52,640 --> 11:35:54,640
we're going to reuse that for this here

17387
11:35:54,640 --> 11:35:56,240
we're not going to be using the

17388
11:35:56,240 --> 11:35:58,160
exception mechanism so we're going to do

17389
11:35:58,160 --> 11:36:00,400
something like this get rid of the try

17390
11:36:00,400 --> 11:36:02,720
and catch block but we're going to still

17391
11:36:02,720 --> 11:36:04,480
be in a loop here

17392
11:36:04,480 --> 11:36:07,040
so what we can do is pass the new

17393
11:36:07,040 --> 11:36:10,400
operator a parameter and say std no

17394
11:36:10,400 --> 11:36:14,080
throw and when we do this if new fails

17395
11:36:14,080 --> 11:36:16,640
we are going to get no pointer stored in

17396
11:36:16,640 --> 11:36:18,640
data here so we can check this against

17397
11:36:18,640 --> 11:36:20,560
the null pointer we can say

17398
11:36:20,560 --> 11:36:21,840
f

17399
11:36:21,840 --> 11:36:25,520
data is different from null pointer

17400
11:36:25,520 --> 11:36:27,840
and we can do whatever we want to do we

17401
11:36:27,840 --> 11:36:29,680
can do that and say

17402
11:36:29,680 --> 11:36:32,400
sddc out

17403
11:36:32,400 --> 11:36:34,160
get it allocated and we can try and

17404
11:36:34,160 --> 11:36:35,916
compile this program

17405
11:36:35,916 --> 11:36:38,080
so what we're going to do is run this

17406
11:36:38,080 --> 11:36:42,160
through our compiler through gcc

17407
11:36:42,160 --> 11:36:43,520
and you're going to see that the world

17408
11:36:43,520 --> 11:36:45,756
is going to be good and you see that

17409
11:36:45,756 --> 11:36:47,596
visual studio code was giving us a

17410
11:36:47,596 --> 11:36:49,436
squiggly line because it can't really

17411
11:36:49,436 --> 11:36:51,436
understand this but this is going to go

17412
11:36:51,436 --> 11:36:53,596
through the compiler and it is going to

17413
11:36:53,596 --> 11:36:56,320
work exactly how we expect

17414
11:36:56,320 --> 11:36:59,040
so let's try and run this program

17415
11:36:59,040 --> 11:37:00,720
we're going to ignore visual studio code

17416
11:37:00,720 --> 11:37:02,480
for now because the world was good we

17417
11:37:02,480 --> 11:37:05,436
could build with gcc and we saw that

17418
11:37:05,436 --> 11:37:08,640
this was welding successfully so we can

17419
11:37:08,640 --> 11:37:10,080
clear

17420
11:37:10,080 --> 11:37:12,560
let's clear properly and run rooster and

17421
11:37:12,560 --> 11:37:14,720
it's going to say data allocated a few

17422
11:37:14,720 --> 11:37:16,560
other times and the program is going to

17423
11:37:16,560 --> 11:37:18,880
end you see that the program is not

17424
11:37:18,880 --> 11:37:21,040
crashing because we are also handling

17425
11:37:21,040 --> 11:37:23,360
the problem but we are going through a

17426
11:37:23,360 --> 11:37:25,520
new mechanism to do that and that's

17427
11:37:25,520 --> 11:37:28,640
using the std no throw option with our

17428
11:37:28,640 --> 11:37:31,116
new operator here this is really all we

17429
11:37:31,116 --> 11:37:32,960
set out to do in this lecture i hope it

17430
11:37:32,960 --> 11:37:35,840
is very clear that the new operator can

17431
11:37:35,840 --> 11:37:38,560
fail and you have a couple of options at

17432
11:37:38,560 --> 11:37:41,116
your hands to handle things when new

17433
11:37:41,116 --> 11:37:43,200
fails you can either go through the

17434
11:37:43,200 --> 11:37:45,200
exception mechanism by using try and

17435
11:37:45,200 --> 11:37:47,756
catch blocks like we did here or you can

17436
11:37:47,756 --> 11:37:51,436
use the std no throw option we are going

17437
11:37:51,436 --> 11:37:53,596
to stop here in this lecture and the

17438
11:37:53,596 --> 11:37:55,680
next one we are going to learn about no

17439
11:37:55,680 --> 11:37:57,840
pointer safety

17440
11:37:57,840 --> 11:38:00,240
go ahead and finish up here and meet me

17441
11:38:00,240 --> 11:38:02,320
there in this lecture we're going to

17442
11:38:02,320 --> 11:38:05,520
explore the concept called null pointer

17443
11:38:05,520 --> 11:38:07,916
safety and this is a series of measures

17444
11:38:07,916 --> 11:38:10,400
you take to make sure that when you are

17445
11:38:10,400 --> 11:38:13,200
using a pointer it contains a valid

17446
11:38:13,200 --> 11:38:15,040
address if you don't have a valid

17447
11:38:15,040 --> 11:38:17,040
address inside you don't use that

17448
11:38:17,040 --> 11:38:19,436
pointer and we do that through a series

17449
11:38:19,436 --> 11:38:21,680
of checks we can do against the null

17450
11:38:21,680 --> 11:38:23,360
pointer for example here we have a

17451
11:38:23,360 --> 11:38:25,916
pointer that is initialized to null

17452
11:38:25,916 --> 11:38:26,880
pointer

17453
11:38:26,880 --> 11:38:30,400
implicitly through braced initializers

17454
11:38:30,400 --> 11:38:33,916
and what we can do is check if p number

17455
11:38:33,916 --> 11:38:35,436
doesn't contain

17456
11:38:35,436 --> 11:38:36,960
null pointer and this is how we say it

17457
11:38:36,960 --> 11:38:39,916
in c plus and if it contains no pointer

17458
11:38:39,916 --> 11:38:41,360
we're not going to use it we're going to

17459
11:38:41,360 --> 11:38:44,160
say it points to an invalid address this

17460
11:38:44,160 --> 11:38:46,400
is something you can do it is simple in

17461
11:38:46,400 --> 11:38:49,200
nature but it is going to save you lots

17462
11:38:49,200 --> 11:38:51,596
of trouble this is one version we can do

17463
11:38:51,596 --> 11:38:54,240
this on but we can also directly plug in

17464
11:38:54,240 --> 11:38:57,276
p number and use it like this if it

17465
11:38:57,276 --> 11:38:58,960
contains no pointer we're going to get

17466
11:38:58,960 --> 11:39:00,880
the message printed out that we have an

17467
11:39:00,880 --> 11:39:04,000
invalid address if we have something

17468
11:39:04,000 --> 11:39:05,596
other than no pointer we're going to

17469
11:39:05,596 --> 11:39:07,520
have a valid address and we can do

17470
11:39:07,520 --> 11:39:09,040
something with that this is going to

17471
11:39:09,040 --> 11:39:11,596
work because a pointer can also be

17472
11:39:11,596 --> 11:39:14,080
implicitly converted into a boolean

17473
11:39:14,080 --> 11:39:17,200
expression that our if statement expects

17474
11:39:17,200 --> 11:39:19,436
here and it is going to work exactly how

17475
11:39:19,436 --> 11:39:21,360
we want here so we're going to see this

17476
11:39:21,360 --> 11:39:23,436
in a minute when we hit visual studio

17477
11:39:23,436 --> 11:39:25,680
code before we do that though i want you

17478
11:39:25,680 --> 11:39:28,960
to be aware that you can call

17479
11:39:28,960 --> 11:39:31,360
delete on a pointer containing no

17480
11:39:31,360 --> 11:39:33,596
pointer without doing the check here it

17481
11:39:33,596 --> 11:39:35,520
is going to be okay we have seen many

17482
11:39:35,520 --> 11:39:37,520
rules about pointers and many students

17483
11:39:37,520 --> 11:39:40,000
will develop an intuition that you have

17484
11:39:40,000 --> 11:39:42,400
to check for no pointer before you do

17485
11:39:42,400 --> 11:39:44,560
anything on your pointer and they even

17486
11:39:44,560 --> 11:39:46,880
do that before they call delete i have

17487
11:39:46,880 --> 11:39:48,960
to break it to you that it is safe to

17488
11:39:48,960 --> 11:39:51,116
call delete on a pointer that contains

17489
11:39:51,116 --> 11:39:53,756
null pointer so you don't need to do

17490
11:39:53,756 --> 11:39:55,680
something like we have here say and

17491
11:39:55,680 --> 11:39:57,756
check if p number one and then delete p

17492
11:39:57,756 --> 11:40:00,000
number one and reset that to low pointer

17493
11:40:00,000 --> 11:40:02,160
this is really overkill you can call

17494
11:40:02,160 --> 11:40:04,160
delete on the pointer and it is going to

17495
11:40:04,160 --> 11:40:06,720
be fine even if it contains no pointer

17496
11:40:06,720 --> 11:40:08,480
now we're going to go to visual studio

17497
11:40:08,480 --> 11:40:10,880
code and see these things in action here

17498
11:40:10,880 --> 11:40:13,756
we are in our working directory the

17499
11:40:13,756 --> 11:40:16,560
current project is no pointer safety

17500
11:40:16,560 --> 11:40:18,880
we're going to grab our template project

17501
11:40:18,880 --> 11:40:20,560
and we're going to put that in the

17502
11:40:20,560 --> 11:40:23,436
current project that we are interested

17503
11:40:23,436 --> 11:40:24,160
in

17504
11:40:24,160 --> 11:40:26,320
and we are going to open this in visual

17505
11:40:26,320 --> 11:40:28,800
studio code open folder and we are going

17506
11:40:28,800 --> 11:40:31,436
to put in a verbose no pointer check

17507
11:40:31,436 --> 11:40:33,680
what we are doing here is nothing new we

17508
11:40:33,680 --> 11:40:35,840
have a pointer called p number it is a

17509
11:40:35,840 --> 11:40:39,116
pointer to ant and it is initialized to

17510
11:40:39,116 --> 11:40:41,840
null pointer through implicit

17511
11:40:41,840 --> 11:40:44,360
initialization here using braced

17512
11:40:44,360 --> 11:40:47,040
initialization and we are checking to

17513
11:40:47,040 --> 11:40:49,276
see if it contains null pointer if it

17514
11:40:49,276 --> 11:40:50,080
does

17515
11:40:50,080 --> 11:40:51,520
we're going to say it contains an

17516
11:40:51,520 --> 11:40:53,360
invalid address if it doesn't we're

17517
11:40:53,360 --> 11:40:55,596
going to say that it has a valid address

17518
11:40:55,596 --> 11:40:57,520
and you see that we are using a negation

17519
11:40:57,520 --> 11:40:59,756
here you can do this however you want if

17520
11:40:59,756 --> 11:41:01,436
we try to build this

17521
11:41:01,436 --> 11:41:04,560
with gcc let's see what we get

17522
11:41:04,560 --> 11:41:07,040
the vote is going to go through

17523
11:41:07,040 --> 11:41:09,436
and if we run rooster we're going to see

17524
11:41:09,436 --> 11:41:12,080
that p number points to an invalid

17525
11:41:12,080 --> 11:41:14,400
address because it contains

17526
11:41:14,400 --> 11:41:17,276
null pointer but if we try and set up a

17527
11:41:17,276 --> 11:41:19,680
new variable for example and say p

17528
11:41:19,680 --> 11:41:21,436
number

17529
11:41:21,436 --> 11:41:23,680
and let's use dynamic memory we have

17530
11:41:23,680 --> 11:41:26,320
learnt about that and initialize that

17531
11:41:26,320 --> 11:41:28,720
with a 7 for example and when it points

17532
11:41:28,720 --> 11:41:30,400
to a valid address we're going to print

17533
11:41:30,400 --> 11:41:32,400
whatever is in there we know how to do

17534
11:41:32,400 --> 11:41:35,520
that so we can say p number and we're

17535
11:41:35,520 --> 11:41:37,520
going to print whatever is inside and

17536
11:41:37,520 --> 11:41:40,480
say p number through the reference end

17537
11:41:40,480 --> 11:41:43,200
and we're going to say stdndl now the

17538
11:41:43,200 --> 11:41:45,436
pointer is not going to contain

17539
11:41:45,436 --> 11:41:47,916
no pointer because it contains the

17540
11:41:47,916 --> 11:41:48,960
address

17541
11:41:48,960 --> 11:41:51,436
of the memory that was allocated on the

17542
11:41:51,436 --> 11:41:52,640
hip here

17543
11:41:52,640 --> 11:41:55,276
but once we do that we have to remember

17544
11:41:55,276 --> 11:41:57,840
to release this memory so please

17545
11:41:57,840 --> 11:41:59,756
remember to release your memory after

17546
11:41:59,756 --> 11:42:01,840
you are done using it so we're going to

17547
11:42:01,840 --> 11:42:04,960
say delete p number after that and we

17548
11:42:04,960 --> 11:42:07,360
need to reset it to no pointer in this

17549
11:42:07,360 --> 11:42:10,000
case it really is useless because nobody

17550
11:42:10,000 --> 11:42:11,520
is going to be using this pointer

17551
11:42:11,520 --> 11:42:14,800
anymore the program is about to end but

17552
11:42:14,800 --> 11:42:17,520
it is a good practice to do this even in

17553
11:42:17,520 --> 11:42:20,400
this case because once this way of doing

17554
11:42:20,400 --> 11:42:23,680
events is burnt into your memory it has

17555
11:42:23,680 --> 11:42:25,596
become your habit you're going to be

17556
11:42:25,596 --> 11:42:28,400
writing cipher c plus plus code now

17557
11:42:28,400 --> 11:42:30,080
we're going to try and run this so we're

17558
11:42:30,080 --> 11:42:31,756
going to build again the bold is going

17559
11:42:31,756 --> 11:42:34,400
to go through and it is going to say

17560
11:42:34,400 --> 11:42:35,436
that

17561
11:42:35,436 --> 11:42:37,360
we have a valid address in memory which

17562
11:42:37,360 --> 11:42:40,160
is this guy and what is inside is a

17563
11:42:40,160 --> 11:42:42,960
seven and now we are writing cipher c

17564
11:42:42,960 --> 11:42:45,756
plus plus code through null pointer

17565
11:42:45,756 --> 11:42:48,160
safety here we can also do a direct

17566
11:42:48,160 --> 11:42:51,040
check using p number without checking if

17567
11:42:51,040 --> 11:42:53,116
it is equal to null pointer because this

17568
11:42:53,116 --> 11:42:55,916
is verbose but it is something you will

17569
11:42:55,916 --> 11:42:57,916
see in practice you can also do

17570
11:42:57,916 --> 11:42:59,916
something like this and say if p number

17571
11:42:59,916 --> 11:43:01,596
and you're going to get exactly the same

17572
11:43:01,596 --> 11:43:04,400
thing so if we have some valid

17573
11:43:04,400 --> 11:43:06,800
address inside we're going to print

17574
11:43:06,800 --> 11:43:09,436
that let's print the same thing as

17575
11:43:09,436 --> 11:43:10,400
in the

17576
11:43:10,400 --> 11:43:12,160
previous code here

17577
11:43:12,160 --> 11:43:13,840
and if we build and run we're going to

17578
11:43:13,840 --> 11:43:16,480
get exactly the same thing

17579
11:43:16,480 --> 11:43:18,160
okay so that's

17580
11:43:18,160 --> 11:43:20,320
clear because the world is good let's

17581
11:43:20,320 --> 11:43:22,240
clear and run rooster you see that we

17582
11:43:22,240 --> 11:43:25,276
get exactly the same thing and if we

17583
11:43:25,276 --> 11:43:27,916
didn't initialize this guy with the new

17584
11:43:27,916 --> 11:43:30,240
dynamic piece of memory we're going to

17585
11:43:30,240 --> 11:43:32,720
get that the memory is invalid the

17586
11:43:32,720 --> 11:43:34,240
address we have in the pointer is going

17587
11:43:34,240 --> 11:43:36,080
to be invalid and we're going to print

17588
11:43:36,080 --> 11:43:38,240
that out through our code here

17589
11:43:38,240 --> 11:43:41,116
run rooster invalid address

17590
11:43:41,116 --> 11:43:43,276
okay the last thing i want you to see is

17591
11:43:43,276 --> 11:43:46,720
that it is okay to call delete

17592
11:43:46,720 --> 11:43:48,800
on a null pointer and we're going to say

17593
11:43:48,800 --> 11:43:50,800
that here so we're going to go down here

17594
11:43:50,800 --> 11:43:52,960
and put in a piece of code we are

17595
11:43:52,960 --> 11:43:55,360
setting up a new pointer p number one

17596
11:43:55,360 --> 11:43:58,160
initialized with no pointer if we call

17597
11:43:58,160 --> 11:44:00,080
delete on it this is going to work

17598
11:44:00,080 --> 11:44:01,916
really well and you're not going to get

17599
11:44:01,916 --> 11:44:04,240
a crush or anything this is valid c plus

17600
11:44:04,240 --> 11:44:06,560
plus code so if we're trying to compile

17601
11:44:06,560 --> 11:44:09,520
this it is going to work fine and you

17602
11:44:09,520 --> 11:44:11,916
don't really have to

17603
11:44:11,916 --> 11:44:14,640
do a no pointer check before you delete

17604
11:44:14,640 --> 11:44:16,960
like this because that's overkill you

17605
11:44:16,960 --> 11:44:19,596
see that the program both successfully

17606
11:44:19,596 --> 11:44:21,360
and we can clear and run it and we're

17607
11:44:21,360 --> 11:44:23,040
going to get exactly the same things we

17608
11:44:23,040 --> 11:44:25,520
had before so some people are going to

17609
11:44:25,520 --> 11:44:27,680
do something like

17610
11:44:27,680 --> 11:44:29,596
they're going to check for no pointer

17611
11:44:29,596 --> 11:44:31,756
and they're going to say if p number one

17612
11:44:31,756 --> 11:44:34,480
for example is not equal to no pointer

17613
11:44:34,480 --> 11:44:36,160
and they're going to say something like

17614
11:44:36,160 --> 11:44:38,080
delete here and they're going to do

17615
11:44:38,080 --> 11:44:39,436
something like this

17616
11:44:39,436 --> 11:44:41,436
and this is going to work but it is

17617
11:44:41,436 --> 11:44:43,116
really overkill you don't need to do

17618
11:44:43,116 --> 11:44:46,240
this test because it is safe to call

17619
11:44:46,240 --> 11:44:49,276
delete on a pointer even if it contains

17620
11:44:49,276 --> 11:44:51,756
no pointer in the first place so you

17621
11:44:51,756 --> 11:44:53,916
don't need to do things like this this

17622
11:44:53,916 --> 11:44:56,400
is going to work just fine don't be

17623
11:44:56,400 --> 11:44:59,276
afraid to call delete on a pointer

17624
11:44:59,276 --> 11:45:02,480
because it might contain null pointer

17625
11:45:02,480 --> 11:45:04,880
this is really all we mean by null

17626
11:45:04,880 --> 11:45:06,960
pointer safety and i hope i gave you a

17627
11:45:06,960 --> 11:45:09,520
few examples to make this pretty clear

17628
11:45:09,520 --> 11:45:11,040
we are going to stop here in this

17629
11:45:11,040 --> 11:45:12,560
lecture the next one we're going to

17630
11:45:12,560 --> 11:45:15,276
learn about memory licks

17631
11:45:15,276 --> 11:45:17,756
go ahead and finish up here and meet me

17632
11:45:17,756 --> 11:45:19,596
there in this lecture we're going to

17633
11:45:19,596 --> 11:45:21,840
learn about memory leaks

17634
11:45:21,840 --> 11:45:24,880
and a memory leak is when you have lost

17635
11:45:24,880 --> 11:45:28,000
access to a piece of memory that was

17636
11:45:28,000 --> 11:45:30,640
dynamically allocated to your program

17637
11:45:30,640 --> 11:45:32,960
you basically lose the pointer that was

17638
11:45:32,960 --> 11:45:35,116
pointing to that dynamically allocated

17639
11:45:35,116 --> 11:45:37,200
piece of memory here we have a few

17640
11:45:37,200 --> 11:45:39,040
examples of that for example here we

17641
11:45:39,040 --> 11:45:41,276
have p number which contains a

17642
11:45:41,276 --> 11:45:43,520
dynamically allocated piece of memory

17643
11:45:43,520 --> 11:45:44,960
which is going to contain an integer

17644
11:45:44,960 --> 11:45:47,360
it's going to be 4 byte the value inside

17645
11:45:47,360 --> 11:45:50,640
is going to be a 67. this p number is

17646
11:45:50,640 --> 11:45:53,520
our only key to manipulate that memory

17647
11:45:53,520 --> 11:45:55,756
and it is the key through which we even

17648
11:45:55,756 --> 11:45:58,640
go to release that memory and return

17649
11:45:58,640 --> 11:46:01,360
that to the operating system but notice

17650
11:46:01,360 --> 11:46:02,960
what we do down here

17651
11:46:02,960 --> 11:46:06,000
we are setting up a new number variable

17652
11:46:06,000 --> 11:46:08,400
it is an integer and it is allocated on

17653
11:46:08,400 --> 11:46:09,916
the stack because this is a local

17654
11:46:09,916 --> 11:46:11,916
variable it's not a pointer it's not

17655
11:46:11,916 --> 11:46:15,116
dynamically allocated and we take the

17656
11:46:15,116 --> 11:46:17,916
address of number and assign that to our

17657
11:46:17,916 --> 11:46:20,400
pointer the moment we do that

17658
11:46:20,400 --> 11:46:23,596
we have no way to release the memory

17659
11:46:23,596 --> 11:46:26,080
that was allocated to p number in the

17660
11:46:26,080 --> 11:46:27,276
first place

17661
11:46:27,276 --> 11:46:29,680
and if we do that the operating system

17662
11:46:29,680 --> 11:46:31,756
is going to think that this memory is

17663
11:46:31,756 --> 11:46:34,880
ours but we don't have a way to release

17664
11:46:34,880 --> 11:46:37,116
this memory anymore because the pointer

17665
11:46:37,116 --> 11:46:38,240
that was

17666
11:46:38,240 --> 11:46:41,116
helping us access this memory has been

17667
11:46:41,116 --> 11:46:43,520
repurposed to point to this number

17668
11:46:43,520 --> 11:46:45,840
variable here i hope you see that

17669
11:46:45,840 --> 11:46:47,756
and the memory leak is something like

17670
11:46:47,756 --> 11:46:49,840
this when you lose the pointer that

17671
11:46:49,840 --> 11:46:52,400
would otherwise be used to release the

17672
11:46:52,400 --> 11:46:54,480
memory and your program is basically

17673
11:46:54,480 --> 11:46:56,640
going to keep using this memory and the

17674
11:46:56,640 --> 11:46:58,720
operating system is not going to have a

17675
11:46:58,720 --> 11:47:01,200
way to reclaim this memory so it is

17676
11:47:01,200 --> 11:47:03,756
useless so you are no longer using this

17677
11:47:03,756 --> 11:47:05,436
memory because you can't access it and

17678
11:47:05,436 --> 11:47:07,436
do things with it and the operating

17679
11:47:07,436 --> 11:47:09,596
system can't use it either because it

17680
11:47:09,596 --> 11:47:11,840
fences your memory hopefully you can see

17681
11:47:11,840 --> 11:47:14,320
that this is a really bad situation and

17682
11:47:14,320 --> 11:47:16,720
you should avoid these things in your

17683
11:47:16,720 --> 11:47:19,840
application so do avoid memory leaks

17684
11:47:19,840 --> 11:47:21,200
like a plague

17685
11:47:21,200 --> 11:47:23,200
this is one situation in which we can

17686
11:47:23,200 --> 11:47:25,756
have a memory leak here is another

17687
11:47:25,756 --> 11:47:28,400
example where we have double allocation

17688
11:47:28,400 --> 11:47:30,640
we have a pointer p number one it is

17689
11:47:30,640 --> 11:47:33,200
pointing to dynamically allocated memory

17690
11:47:33,200 --> 11:47:37,040
again and the value inside is a 55.

17691
11:47:37,040 --> 11:47:39,276
if we use this pointer to allocate new

17692
11:47:39,276 --> 11:47:41,596
memory the first memory that we were

17693
11:47:41,596 --> 11:47:43,840
pointing to is going to be leaked

17694
11:47:43,840 --> 11:47:46,720
again it is the same thing we have lost

17695
11:47:46,720 --> 11:47:49,756
access to the first memory now we are

17696
11:47:49,756 --> 11:47:52,560
pointing to the second dynamic

17697
11:47:52,560 --> 11:47:54,880
memory that was allocated to contain the

17698
11:47:54,880 --> 11:47:58,000
44 here and again this is a memory leak

17699
11:47:58,000 --> 11:47:59,916
your program has lost access to the

17700
11:47:59,916 --> 11:48:03,200
memory containing 55 here and the

17701
11:48:03,200 --> 11:48:05,520
operating system also thinks that you

17702
11:48:05,520 --> 11:48:08,480
are using this memory because you didn't

17703
11:48:08,480 --> 11:48:11,200
explicitly return it to the operating

17704
11:48:11,200 --> 11:48:14,880
system through the delete operator again

17705
11:48:14,880 --> 11:48:17,756
memory leaks are bad do avoid them in

17706
11:48:17,756 --> 11:48:20,160
your programs here is another simple

17707
11:48:20,160 --> 11:48:22,160
example of a case where you might have a

17708
11:48:22,160 --> 11:48:24,800
memory leak you go in a nested scope

17709
11:48:24,800 --> 11:48:27,200
like this and allocate a new piece of

17710
11:48:27,200 --> 11:48:29,840
memory dynamically of course and point

17711
11:48:29,840 --> 11:48:32,720
to that through p number two here but p

17712
11:48:32,720 --> 11:48:34,000
number two

17713
11:48:34,000 --> 11:48:36,800
itself is a pointer and it is a local

17714
11:48:36,800 --> 11:48:39,520
variable nested in this scope

17715
11:48:39,520 --> 11:48:41,756
when this scope ends p number two is

17716
11:48:41,756 --> 11:48:44,320
going to die but the dynamic memory

17717
11:48:44,320 --> 11:48:46,640
itself is not going to die you just lost

17718
11:48:46,640 --> 11:48:48,720
access to it and you can't access it

17719
11:48:48,720 --> 11:48:50,960
again this is a memory leak and you

17720
11:48:50,960 --> 11:48:53,276
should avoid this in your programs

17721
11:48:53,276 --> 11:48:56,080
memory leaks are really bad and in

17722
11:48:56,080 --> 11:48:58,560
extreme cases they might even lead to

17723
11:48:58,560 --> 11:49:01,200
your program crashing if your program

17724
11:49:01,200 --> 11:49:03,596
keeps running for an extended period of

17725
11:49:03,596 --> 11:49:06,400
time think of programs like those

17726
11:49:06,400 --> 11:49:08,800
running in servers for example they can

17727
11:49:08,800 --> 11:49:10,880
even run for three months without

17728
11:49:10,880 --> 11:49:14,000
stopping and if your program is

17729
11:49:14,000 --> 11:49:16,400
increasingly leaking memory the

17730
11:49:16,400 --> 11:49:18,160
operating system is going to think that

17731
11:49:18,160 --> 11:49:20,400
you are taking too much hip memory it's

17732
11:49:20,400 --> 11:49:22,640
going to terminate your program like we

17733
11:49:22,640 --> 11:49:23,520
saw

17734
11:49:23,520 --> 11:49:26,000
in the lecture where we learned on

17735
11:49:26,000 --> 11:49:28,480
conditions where the new operator failed

17736
11:49:28,480 --> 11:49:31,436
so if you allocate too much memory then

17737
11:49:31,436 --> 11:49:33,840
your program can really take the next

17738
11:49:33,840 --> 11:49:35,436
operations you're going to do with new

17739
11:49:35,436 --> 11:49:37,200
are going to fail and your program is

17740
11:49:37,200 --> 11:49:39,756
going to terminate the message here is

17741
11:49:39,756 --> 11:49:41,840
memory leaks are bad you should avoid

17742
11:49:41,840 --> 11:49:44,240
them in your programs and whenever you

17743
11:49:44,240 --> 11:49:46,000
think that you're no longer using a

17744
11:49:46,000 --> 11:49:48,560
piece of memory make sure you delete it

17745
11:49:48,560 --> 11:49:50,720
and return it to the operating system

17746
11:49:50,720 --> 11:49:53,276
you're going to be writing much safer c

17747
11:49:53,276 --> 11:49:55,200
plus plus code we're going to head over

17748
11:49:55,200 --> 11:49:57,520
to visual studio code and actually try

17749
11:49:57,520 --> 11:50:00,560
this here we are in our working

17750
11:50:00,560 --> 11:50:02,880
directory the current project is memory

17751
11:50:02,880 --> 11:50:05,040
leaks we're going to bring in our

17752
11:50:05,040 --> 11:50:06,880
template files

17753
11:50:06,880 --> 11:50:08,960
and we're going to put them in place in

17754
11:50:08,960 --> 11:50:12,080
the lecture on memory leaks and we are

17755
11:50:12,080 --> 11:50:14,240
going to open this in visual studio code

17756
11:50:14,240 --> 11:50:15,916
we are going to clean this up a little

17757
11:50:15,916 --> 11:50:18,320
bit bring this up here we have a

17758
11:50:18,320 --> 11:50:20,240
variable called p number it is a pointer

17759
11:50:20,240 --> 11:50:22,880
to end and we initialize that with the

17760
11:50:22,880 --> 11:50:25,756
address of a piece of memory that is

17761
11:50:25,756 --> 11:50:28,480
allocated dynamically on the heap we

17762
11:50:28,480 --> 11:50:31,916
store a 67 inside and here down you see

17763
11:50:31,916 --> 11:50:34,160
we set up another variable on the stack

17764
11:50:34,160 --> 11:50:37,116
again this says a stack variable

17765
11:50:37,116 --> 11:50:39,116
it lives on the stack it's not on the

17766
11:50:39,116 --> 11:50:41,116
heap and we text the address of this

17767
11:50:41,116 --> 11:50:43,116
thing and assign that to our pointer

17768
11:50:43,116 --> 11:50:45,436
here the moment we do that we have no

17769
11:50:45,436 --> 11:50:47,756
more way we can access this dynamic

17770
11:50:47,756 --> 11:50:50,320
memory and we have leaked it and this is

17771
11:50:50,320 --> 11:50:52,640
really bad the thing is this program is

17772
11:50:52,640 --> 11:50:54,000
going to compile

17773
11:50:54,000 --> 11:50:56,160
i don't think compilers have a way to

17774
11:50:56,160 --> 11:50:58,400
stop you from making mistakes like this

17775
11:50:58,400 --> 11:51:00,160
so you really have to be careful and

17776
11:51:00,160 --> 11:51:02,080
make sure that you are not leaking

17777
11:51:02,080 --> 11:51:04,880
memory in your program so if we run this

17778
11:51:04,880 --> 11:51:06,640
program it's going to run it's going to

17779
11:51:06,640 --> 11:51:08,560
run and finish let's say that it is

17780
11:51:08,560 --> 11:51:11,680
ending well okay so we're going to build

17781
11:51:11,680 --> 11:51:14,560
and see this run the build is good so we

17782
11:51:14,560 --> 11:51:16,560
can clear and run rooster and we're

17783
11:51:16,560 --> 11:51:18,560
going to see that the program is ending

17784
11:51:18,560 --> 11:51:20,720
well but we are

17785
11:51:20,720 --> 11:51:22,880
leaking memory here because the

17786
11:51:22,880 --> 11:51:24,880
dynamically piece of memory that we

17787
11:51:24,880 --> 11:51:26,560
allocated here

17788
11:51:26,560 --> 11:51:29,276
wasn't released to the system and when

17789
11:51:29,276 --> 11:51:32,160
we did this assignment here we just lost

17790
11:51:32,160 --> 11:51:34,560
access to it so the operating system is

17791
11:51:34,560 --> 11:51:36,400
going to thank this memory belongs to

17792
11:51:36,400 --> 11:51:39,436
this program that is ours here but your

17793
11:51:39,436 --> 11:51:41,756
program is either not going to be using

17794
11:51:41,756 --> 11:51:44,240
this piece of memory because we have

17795
11:51:44,240 --> 11:51:46,320
just lost the key

17796
11:51:46,320 --> 11:51:48,160
that would allow us to go and do

17797
11:51:48,160 --> 11:51:50,800
something useful with this memory here

17798
11:51:50,800 --> 11:51:52,480
so this is something bad and you should

17799
11:51:52,480 --> 11:51:55,200
avoid it the second example of memory

17800
11:51:55,200 --> 11:51:57,680
leaks is when you do double allocation

17801
11:51:57,680 --> 11:51:59,916
on a pointer for example here we have

17802
11:51:59,916 --> 11:52:02,160
pin number one again and we are going to

17803
11:52:02,160 --> 11:52:04,080
make this point to

17804
11:52:04,080 --> 11:52:05,596
an address

17805
11:52:05,596 --> 11:52:09,116
of a piece of memory that was allocated

17806
11:52:09,116 --> 11:52:12,160
dynamically on the heap the value inside

17807
11:52:12,160 --> 11:52:15,116
is going to be 55 but we are using this

17808
11:52:15,116 --> 11:52:18,960
pointer again to make it point to a new

17809
11:52:18,960 --> 11:52:22,000
piece of memory containing the address

17810
11:52:22,000 --> 11:52:25,116
of the newly allocated piece of memory

17811
11:52:25,116 --> 11:52:27,680
on the stack on the heap i mean and this

17812
11:52:27,680 --> 11:52:29,680
is really bad because again once we do

17813
11:52:29,680 --> 11:52:32,320
this we lose access to this memory here

17814
11:52:32,320 --> 11:52:33,916
and it is linked

17815
11:52:33,916 --> 11:52:35,596
the program here is not going to have

17816
11:52:35,596 --> 11:52:37,596
access to it and the operating system is

17817
11:52:37,596 --> 11:52:40,320
going to thank we own this memory and it

17818
11:52:40,320 --> 11:52:43,276
is going to be bad and uh down here

17819
11:52:43,276 --> 11:52:45,436
maybe you can go and say delete number

17820
11:52:45,436 --> 11:52:48,000
one p number one but this is not going

17821
11:52:48,000 --> 11:52:50,480
to release the memory here it is going

17822
11:52:50,480 --> 11:52:53,116
to release the memory here with the 44

17823
11:52:53,116 --> 11:52:55,436
and the memory containing 55 here is

17824
11:52:55,436 --> 11:52:58,160
going to be leaked let's be good c plus

17825
11:52:58,160 --> 11:53:00,720
plus citizens and reset our pointers

17826
11:53:00,720 --> 11:53:02,880
after we delete so we're going to say p

17827
11:53:02,880 --> 11:53:05,756
number one equals no pointer and we are

17828
11:53:05,756 --> 11:53:08,160
going to be playing it safe here and

17829
11:53:08,160 --> 11:53:10,960
again we just lift memory here and it is

17830
11:53:10,960 --> 11:53:12,400
something you should avoid in your

17831
11:53:12,400 --> 11:53:15,200
programs if you run this program it is

17832
11:53:15,200 --> 11:53:18,400
going to run just fine so let's see that

17833
11:53:18,400 --> 11:53:20,160
because i don't want to leave you with

17834
11:53:20,160 --> 11:53:22,960
programs containing errors

17835
11:53:22,960 --> 11:53:25,040
if i run rooster again it's going to end

17836
11:53:25,040 --> 11:53:27,680
well but it is going to be leaking

17837
11:53:27,680 --> 11:53:28,960
memory here

17838
11:53:28,960 --> 11:53:31,756
so we don't want to leak memory avoid

17839
11:53:31,756 --> 11:53:33,916
this like a plague we're going to

17840
11:53:33,916 --> 11:53:35,520
comment this out

17841
11:53:35,520 --> 11:53:37,200
and show you that you can also leak

17842
11:53:37,200 --> 11:53:40,000
memory when you have some nested scopes

17843
11:53:40,000 --> 11:53:42,320
in your programs okay let's go down here

17844
11:53:42,320 --> 11:53:44,800
and put that in and here is a simple

17845
11:53:44,800 --> 11:53:47,360
example we have a nested scope nested

17846
11:53:47,360 --> 11:53:49,840
inside the main function and inside the

17847
11:53:49,840 --> 11:53:52,160
scope here we are setting up a new

17848
11:53:52,160 --> 11:53:53,276
pointer

17849
11:53:53,276 --> 11:53:55,276
and it is going to be pointing to

17850
11:53:55,276 --> 11:53:57,840
dynamically allocated memory and that

17851
11:53:57,840 --> 11:54:00,320
memory is going to contain a 57.

17852
11:54:00,320 --> 11:54:02,400
the only key we have to this dynamic

17853
11:54:02,400 --> 11:54:05,596
memory is this p number two pointer here

17854
11:54:05,596 --> 11:54:08,240
but this p number two pointer lives on

17855
11:54:08,240 --> 11:54:11,276
the stack itself so when the scope here

17856
11:54:11,276 --> 11:54:13,200
is going to end p number two is no

17857
11:54:13,200 --> 11:54:15,756
longer going to be accessible and the

17858
11:54:15,756 --> 11:54:17,756
memory is going to be linked if you

17859
11:54:17,756 --> 11:54:20,000
really want to play it safe you can go

17860
11:54:20,000 --> 11:54:22,080
do whatever you want with the dynamic

17861
11:54:22,080 --> 11:54:24,480
memory and when you are done with that

17862
11:54:24,480 --> 11:54:26,800
you can delete that piece of memory here

17863
11:54:26,800 --> 11:54:28,800
while you still have access to p number

17864
11:54:28,800 --> 11:54:30,400
two but if you don't

17865
11:54:30,400 --> 11:54:31,756
delete here

17866
11:54:31,756 --> 11:54:34,240
in the scope where this thing was

17867
11:54:34,240 --> 11:54:35,596
declared

17868
11:54:35,596 --> 11:54:38,080
if you hit the end of this scope you're

17869
11:54:38,080 --> 11:54:40,320
going to lose access to this pointer and

17870
11:54:40,320 --> 11:54:42,480
you will be losing access to this

17871
11:54:42,480 --> 11:54:44,400
dynamic piece of memory

17872
11:54:44,400 --> 11:54:46,080
and you're going to be leaking memory

17873
11:54:46,080 --> 11:54:48,560
because you're not deleting it even if

17874
11:54:48,560 --> 11:54:50,320
you want to delete it you won't be able

17875
11:54:50,320 --> 11:54:52,720
to do that because you don't have a key

17876
11:54:52,720 --> 11:54:54,160
that is going to lead you to that

17877
11:54:54,160 --> 11:54:56,480
dynamic memory so if we try and do

17878
11:54:56,480 --> 11:54:59,040
delete p number two here this is not

17879
11:54:59,040 --> 11:55:01,040
going to compile because we don't have

17880
11:55:01,040 --> 11:55:03,520
access to p number two p number two is

17881
11:55:03,520 --> 11:55:06,640
scoped inside this nested scope here

17882
11:55:06,640 --> 11:55:09,756
this is what i mean so be sure you are

17883
11:55:09,756 --> 11:55:12,960
aware of this memory leak problem the

17884
11:55:12,960 --> 11:55:15,916
cases we have seen here are really

17885
11:55:15,916 --> 11:55:17,596
extensive enough to give you an

17886
11:55:17,596 --> 11:55:20,880
intuition on how this is bad and you're

17887
11:55:20,880 --> 11:55:23,200
going to be avoiding this new programs

17888
11:55:23,200 --> 11:55:24,960
and you're going to be on your way to

17889
11:55:24,960 --> 11:55:28,000
become a better c plus plus developer

17890
11:55:28,000 --> 11:55:29,520
this is really all we set out to do in

17891
11:55:29,520 --> 11:55:31,436
this lecture to learn about memory leads

17892
11:55:31,436 --> 11:55:33,756
show you a few examples of them i hope

17893
11:55:33,756 --> 11:55:36,000
now you understand them we are going to

17894
11:55:36,000 --> 11:55:37,680
stop here in this lecture and the next

17895
11:55:37,680 --> 11:55:38,960
one we're going to learn about

17896
11:55:38,960 --> 11:55:42,080
dynamically allocated arrays

17897
11:55:42,080 --> 11:55:44,480
go ahead and finish up here and meet me

17898
11:55:44,480 --> 11:55:45,360
there

17899
11:55:45,360 --> 11:55:47,360
in this lecture we're going to look at

17900
11:55:47,360 --> 11:55:51,040
dynamic arrays and these are arrays you

17901
11:55:51,040 --> 11:55:53,840
can allocate on the heap and they're not

17902
11:55:53,840 --> 11:55:55,840
going to be stored on the stack like we

17903
11:55:55,840 --> 11:55:57,436
have seen before the arrays we have

17904
11:55:57,436 --> 11:56:00,320
learned about so far have been living on

17905
11:56:00,320 --> 11:56:03,040
the stack we want to see how we can

17906
11:56:03,040 --> 11:56:05,436
allocate arrays on the heap if we happen

17907
11:56:05,436 --> 11:56:08,400
to need that in our applications arrays

17908
11:56:08,400 --> 11:56:10,800
are allocated on the hip with the new

17909
11:56:10,800 --> 11:56:13,116
operator we can also use the sdd no

17910
11:56:13,116 --> 11:56:16,720
throw version of the new operator if we

17911
11:56:16,720 --> 11:56:19,116
don't want exceptions in our c plus plus

17912
11:56:19,116 --> 11:56:21,916
programs here is a simple example of how

17913
11:56:21,916 --> 11:56:23,840
you can do that we have a pointer called

17914
11:56:23,840 --> 11:56:25,596
p salaries it's going to be a pointer to

17915
11:56:25,596 --> 11:56:28,320
double and it is going to contain the

17916
11:56:28,320 --> 11:56:31,360
address to the dynamic memory that we

17917
11:56:31,360 --> 11:56:33,040
allocate on the heap which is going to

17918
11:56:33,040 --> 11:56:35,040
contain an array

17919
11:56:35,040 --> 11:56:38,400
of doubles of this size here okay this

17920
11:56:38,400 --> 11:56:40,160
is an array that is going to be

17921
11:56:40,160 --> 11:56:42,720
initialized with junk values because we

17922
11:56:42,720 --> 11:56:45,040
are not initializing that

17923
11:56:45,040 --> 11:56:47,116
explicitly so this is something you need

17924
11:56:47,116 --> 11:56:49,360
to be aware of okay p students is also

17925
11:56:49,360 --> 11:56:52,720
going to be containing the address of an

17926
11:56:52,720 --> 11:56:54,960
array that is going to be allocated on

17927
11:56:54,960 --> 11:56:57,916
the heap we are using the sdd nothro

17928
11:56:57,916 --> 11:57:00,400
version of the new operator because in

17929
11:57:00,400 --> 11:57:02,400
this case for example we might not want

17930
11:57:02,400 --> 11:57:04,480
exceptions and we're going to say that

17931
11:57:04,480 --> 11:57:06,000
it is an array of events it's going to

17932
11:57:06,000 --> 11:57:09,116
be this size but we are using breast

17933
11:57:09,116 --> 11:57:11,680
initializer so this is going to be

17934
11:57:11,680 --> 11:57:13,680
initialized to zero

17935
11:57:13,680 --> 11:57:15,436
all the values inside are going to be

17936
11:57:15,436 --> 11:57:17,360
initialized to zero this is what we mean

17937
11:57:17,360 --> 11:57:20,400
here we also have a p scores array we

17938
11:57:20,400 --> 11:57:22,800
are using the std no throw version of

17939
11:57:22,800 --> 11:57:25,436
new and it is going to be this size and

17940
11:57:25,436 --> 11:57:28,320
initialized with one two three four five

17941
11:57:28,320 --> 11:57:29,436
okay if

17942
11:57:29,436 --> 11:57:31,596
the array is bigger than five the

17943
11:57:31,596 --> 11:57:33,200
remaining slots are going to be

17944
11:57:33,200 --> 11:57:35,916
initialized with zeros just like we saw

17945
11:57:35,916 --> 11:57:37,840
with the arrays we have learned about

17946
11:57:37,840 --> 11:57:40,160
previously that we're stored on the

17947
11:57:40,160 --> 11:57:41,840
stack this is really how you work with

17948
11:57:41,840 --> 11:57:44,000
these things and i hope it is super

17949
11:57:44,000 --> 11:57:46,800
clear again we are calling the new

17950
11:57:46,800 --> 11:57:47,916
operator

17951
11:57:47,916 --> 11:57:50,720
this is going to allocate however memory

17952
11:57:50,720 --> 11:57:53,360
space is needed to store these things on

17953
11:57:53,360 --> 11:57:55,680
the heap so if this array is going to

17954
11:57:55,680 --> 11:57:57,916
contain 10 elements we're going to

17955
11:57:57,916 --> 11:58:00,240
allocate enough space to contain 10

17956
11:58:00,240 --> 11:58:02,400
double elements on the heap and we're

17957
11:58:02,400 --> 11:58:04,880
going to be pointing to that with the p

17958
11:58:04,880 --> 11:58:06,480
salaries pointer that's what we mean

17959
11:58:06,480 --> 11:58:09,276
here once you have your dynamic array

17960
11:58:09,276 --> 11:58:11,916
allocated on the hip you can try to do

17961
11:58:11,916 --> 11:58:13,596
things with it for example we can try

17962
11:58:13,596 --> 11:58:15,276
and loop through the squirrels and print

17963
11:58:15,276 --> 11:58:18,000
them out here you see that we are using

17964
11:58:18,000 --> 11:58:21,360
the angle bracket syntax and the

17965
11:58:21,360 --> 11:58:23,756
pointer arithmetic syntax it is going to

17966
11:58:23,756 --> 11:58:25,360
work equally well you can choose

17967
11:58:25,360 --> 11:58:27,596
whatever you want but i just wanted you

17968
11:58:27,596 --> 11:58:29,680
to see that you can use both versions

17969
11:58:29,680 --> 11:58:31,680
here the next logical thing to think

17970
11:58:31,680 --> 11:58:34,000
about when you talk about dynamic memory

17971
11:58:34,000 --> 11:58:36,640
allocation is how you release the memory

17972
11:58:36,640 --> 11:58:38,800
to the operating system when you're no

17973
11:58:38,800 --> 11:58:41,040
longer using it and this is the syntax

17974
11:58:41,040 --> 11:58:43,596
to do it with arrays you say delete you

17975
11:58:43,596 --> 11:58:45,436
put angle brackets and you say the

17976
11:58:45,436 --> 11:58:48,240
pointer that was used to allocate that

17977
11:58:48,240 --> 11:58:50,640
memory in the first place and after you

17978
11:58:50,640 --> 11:58:52,640
do that you have to remember to reset

17979
11:58:52,640 --> 11:58:54,640
the pointer to null pointer because you

17980
11:58:54,640 --> 11:58:57,596
are a good c plus plus citizen and this

17981
11:58:57,596 --> 11:58:59,436
is really all we had to say in this

17982
11:58:59,436 --> 11:59:01,200
lecture this is how you dynamically

17983
11:59:01,200 --> 11:59:04,480
allocate a raise on the hip before we

17984
11:59:04,480 --> 11:59:06,640
head over to visual studio code and play

17985
11:59:06,640 --> 11:59:08,960
with this though i want you to keep in

17986
11:59:08,960 --> 11:59:11,840
your mind that arrays you allocate

17987
11:59:11,840 --> 11:59:14,160
dynamically on the heap are very

17988
11:59:14,160 --> 11:59:16,560
different from the arrays that we have

17989
11:59:16,560 --> 11:59:18,480
learned about before and that's because

17990
11:59:18,480 --> 11:59:21,360
they don't work with std size and they

17991
11:59:21,360 --> 11:59:24,640
don't work for range based for loops

17992
11:59:24,640 --> 11:59:26,400
and that the reason for all these

17993
11:59:26,400 --> 11:59:28,480
limitations is that when you do

17994
11:59:28,480 --> 11:59:30,640
something like this the array really

17995
11:59:30,640 --> 11:59:34,000
decays into a pointer and it loses

17996
11:59:34,000 --> 11:59:36,800
information that would otherwise be used

17997
11:59:36,800 --> 11:59:39,276
to deduce the size that is used by sdd

17998
11:59:39,276 --> 11:59:41,840
size and there are other things that are

17999
11:59:41,840 --> 11:59:44,640
used by the range base for loop that

18000
11:59:44,640 --> 11:59:46,960
they lose when you store and refer to

18001
11:59:46,960 --> 11:59:48,960
them using a pointer like this that's

18002
11:59:48,960 --> 11:59:51,520
why we have this limitation keep this in

18003
11:59:51,520 --> 11:59:53,840
mind if you are using a dynamically

18004
11:59:53,840 --> 11:59:56,240
allocated array on the heap you're going

18005
11:59:56,240 --> 11:59:58,480
to be using other techniques to deduce

18006
11:59:58,480 --> 12:00:01,040
its size and it is not going to work

18007
12:00:01,040 --> 12:00:03,200
with a range base for loop so we will

18008
12:00:03,200 --> 12:00:05,916
have to use other kinds of loops that we

18009
12:00:05,916 --> 12:00:08,000
have learned about in this course and it

18010
12:00:08,000 --> 12:00:09,840
is going to work pretty well

18011
12:00:09,840 --> 12:00:11,916
this is really all i had to share in

18012
12:00:11,916 --> 12:00:14,240
this lecture now i think it's time we

18013
12:00:14,240 --> 12:00:16,720
went to visual studio code and actually

18014
12:00:16,720 --> 12:00:18,640
tried this out

18015
12:00:18,640 --> 12:00:21,520
here we are in our working folder the

18016
12:00:21,520 --> 12:00:24,320
current project is dynamically allocated

18017
12:00:24,320 --> 12:00:25,436
arrays

18018
12:00:25,436 --> 12:00:27,756
we are going to grab our template files

18019
12:00:27,756 --> 12:00:29,680
and put them in place

18020
12:00:29,680 --> 12:00:31,436
and we're going to put that in the

18021
12:00:31,436 --> 12:00:34,240
current project and open this in visual

18022
12:00:34,240 --> 12:00:36,960
studio code like we always do and we are

18023
12:00:36,960 --> 12:00:39,360
going to go down and put in some starter

18024
12:00:39,360 --> 12:00:41,596
code we can play with here we're going

18025
12:00:41,596 --> 12:00:43,756
to click on this

18026
12:00:43,756 --> 12:00:46,480
file icon to remove this pane

18027
12:00:46,480 --> 12:00:48,880
and we're going to try and show the code

18028
12:00:48,880 --> 12:00:50,560
here and again you see that visual

18029
12:00:50,560 --> 12:00:53,116
studio code is freaking out when it sees

18030
12:00:53,116 --> 12:00:55,360
the std no throw version of the new

18031
12:00:55,360 --> 12:00:57,520
operator here but it is going to work

18032
12:00:57,520 --> 12:00:59,916
when we hit the compiler okay so we are

18033
12:00:59,916 --> 12:01:02,800
allocating three arrays on the heap

18034
12:01:02,800 --> 12:01:04,880
dynamically and we are going to be

18035
12:01:04,880 --> 12:01:07,756
storing the addresses to these arrays

18036
12:01:07,756 --> 12:01:10,240
and these pointers for example p

18037
12:01:10,240 --> 12:01:12,640
salaries is going to store the address

18038
12:01:12,640 --> 12:01:14,560
to this dynamic array which is going to

18039
12:01:14,560 --> 12:01:16,400
be leaving on the heap and it is going

18040
12:01:16,400 --> 12:01:18,560
to be the same case for p students here

18041
12:01:18,560 --> 12:01:20,880
and p scores i don't think there is much

18042
12:01:20,880 --> 12:01:23,360
to explain here because we have already

18043
12:01:23,360 --> 12:01:25,040
learned about arrays we know about the

18044
12:01:25,040 --> 12:01:27,680
size of an array we know that it is a

18045
12:01:27,680 --> 12:01:29,916
piece of contiguous memory location that

18046
12:01:29,916 --> 12:01:32,000
is going to be storing variables of the

18047
12:01:32,000 --> 12:01:33,520
same type this is really what we're

18048
12:01:33,520 --> 12:01:34,720
going to have

18049
12:01:34,720 --> 12:01:36,720
so let's try and compile this and see

18050
12:01:36,720 --> 12:01:39,520
that it actually goes through our gcc

18051
12:01:39,520 --> 12:01:42,240
compiler and it is going to work fine

18052
12:01:42,240 --> 12:01:44,080
and another thing you should notice is

18053
12:01:44,080 --> 12:01:46,720
that this is really compiling even if

18054
12:01:46,720 --> 12:01:49,360
what we are using to store the size of

18055
12:01:49,360 --> 12:01:52,640
the array is not const remember for

18056
12:01:52,640 --> 12:01:55,040
stack arrays or static arrays that we

18057
12:01:55,040 --> 12:01:56,560
had on the stack

18058
12:01:56,560 --> 12:01:58,720
we had to make sure this guy here is

18059
12:01:58,720 --> 12:01:59,756
const

18060
12:01:59,756 --> 12:02:02,000
okay that was

18061
12:02:02,000 --> 12:02:04,480
a requirement and if you didn't fulfill

18062
12:02:04,480 --> 12:02:07,276
that your code wouldn't compile now you

18063
12:02:07,276 --> 12:02:09,916
see that with dynamic arrays the code is

18064
12:02:09,916 --> 12:02:12,480
actually compiling even if it's not cost

18065
12:02:12,480 --> 12:02:14,160
and this is something you should be

18066
12:02:14,160 --> 12:02:16,960
aware of let's build this again i just

18067
12:02:16,960 --> 12:02:19,436
messed up my things here

18068
12:02:19,436 --> 12:02:22,320
and the world is good if we go down and

18069
12:02:22,320 --> 12:02:23,756
run it we're not going to see anything

18070
12:02:23,756 --> 12:02:26,400
really because we're not having any

18071
12:02:26,400 --> 12:02:28,640
output in this program but this is how

18072
12:02:28,640 --> 12:02:30,160
you can allocate

18073
12:02:30,160 --> 12:02:33,680
space for a dynamic array on the heap

18074
12:02:33,680 --> 12:02:36,320
now let's try and print some of the data

18075
12:02:36,320 --> 12:02:38,560
in this course here let's go down here

18076
12:02:38,560 --> 12:02:41,360
and actually do that we are going to do

18077
12:02:41,360 --> 12:02:43,520
a no pointer check because we want to

18078
12:02:43,520 --> 12:02:45,276
make sure that memory was actually

18079
12:02:45,276 --> 12:02:48,000
allocated for the p scores array

18080
12:02:48,000 --> 12:02:50,160
and after we do that we're going to loop

18081
12:02:50,160 --> 12:02:52,480
for size times

18082
12:02:52,480 --> 12:02:54,080
and we're going to be printing whatever

18083
12:02:54,080 --> 12:02:56,880
element is at each iteration the index

18084
12:02:56,880 --> 12:02:59,040
at each iteration and you see that we

18085
12:02:59,040 --> 12:03:01,436
can either use the angle brackets

18086
12:03:01,436 --> 12:03:04,640
notation or the pointer arithmetic

18087
12:03:04,640 --> 12:03:06,560
notation it is going to work equally

18088
12:03:06,560 --> 12:03:07,360
well

18089
12:03:07,360 --> 12:03:08,960
if we built this

18090
12:03:08,960 --> 12:03:10,800
let's bring up our terminal we haven't

18091
12:03:10,800 --> 12:03:13,596
opened one and let's go down and clear

18092
12:03:13,596 --> 12:03:15,360
and run rooster

18093
12:03:15,360 --> 12:03:16,800
you're going to see that

18094
12:03:16,800 --> 12:03:18,960
successfully allocated

18095
12:03:18,960 --> 12:03:20,640
memory for scores

18096
12:03:20,640 --> 12:03:22,880
and we're going to be printing the data

18097
12:03:22,880 --> 12:03:25,756
first using the angle brackets notation

18098
12:03:25,756 --> 12:03:28,000
second using pointer arithmetic and you

18099
12:03:28,000 --> 12:03:30,800
see that it is working pretty well

18100
12:03:30,800 --> 12:03:32,880
one thing you should have noticed now is

18101
12:03:32,880 --> 12:03:34,480
that we haven't actually

18102
12:03:34,480 --> 12:03:36,160
released the memory that we have

18103
12:03:36,160 --> 12:03:37,840
allocated here and this is something

18104
12:03:37,840 --> 12:03:39,756
really bad so we're going to see how we

18105
12:03:39,756 --> 12:03:42,240
can do that we have allocated space for

18106
12:03:42,240 --> 12:03:45,436
salaries p students and scores so let's

18107
12:03:45,436 --> 12:03:47,276
go down and do that and we're going to

18108
12:03:47,276 --> 12:03:48,960
say delete

18109
12:03:48,960 --> 12:03:50,720
and we're going to have angular brackets

18110
12:03:50,720 --> 12:03:53,520
because this is an array we are

18111
12:03:53,520 --> 12:03:56,480
releasing memory for or to be exact a

18112
12:03:56,480 --> 12:03:59,360
dynamic array which was allocated on the

18113
12:03:59,360 --> 12:04:01,916
heap so we're going to say p

18114
12:04:01,916 --> 12:04:03,680
salaries

18115
12:04:03,680 --> 12:04:06,640
and we're going to reset that pointer

18116
12:04:06,640 --> 12:04:09,360
to no pointer because we are good c plus

18117
12:04:09,360 --> 12:04:11,840
plus citizens so we're going to do that

18118
12:04:11,840 --> 12:04:13,916
no pointer and we're going to do the

18119
12:04:13,916 --> 12:04:15,916
same thing delete

18120
12:04:15,916 --> 12:04:17,680
we are deleting

18121
12:04:17,680 --> 12:04:20,320
space for a dynamic array so the angle

18122
12:04:20,320 --> 12:04:21,520
brackets here

18123
12:04:21,520 --> 12:04:24,400
the square brackets i should say and we

18124
12:04:24,400 --> 12:04:27,916
are going to delete p students i think

18125
12:04:27,916 --> 12:04:30,800
yes so we're going to say p student

18126
12:04:30,800 --> 12:04:32,960
and we're going to say p students and

18127
12:04:32,960 --> 12:04:35,520
we're going to reset this to no pointer

18128
12:04:35,520 --> 12:04:37,116
and we're going to do the same for p

18129
12:04:37,116 --> 12:04:38,880
scores

18130
12:04:38,880 --> 12:04:42,160
let's grab this here that's what we want

18131
12:04:42,160 --> 12:04:44,080
no that's not what we want we're going

18132
12:04:44,080 --> 12:04:46,480
to say delete and say square brackets

18133
12:04:46,480 --> 12:04:48,000
ourselves and we're going to say p

18134
12:04:48,000 --> 12:04:50,720
scores and we're going to release that

18135
12:04:50,720 --> 12:04:52,960
and say p scores

18136
12:04:52,960 --> 12:04:56,080
and reset this to null pointer now we

18137
12:04:56,080 --> 12:04:57,916
are really playing it safe and our

18138
12:04:57,916 --> 12:05:00,320
program is going to release the memory

18139
12:05:00,320 --> 12:05:02,480
that we allocated in these three

18140
12:05:02,480 --> 12:05:03,840
statements here

18141
12:05:03,840 --> 12:05:05,680
if we build the program it is going to

18142
12:05:05,680 --> 12:05:07,436
go through well so we're going to build

18143
12:05:07,436 --> 12:05:10,240
with gcc

18144
12:05:10,240 --> 12:05:13,040
and we are going to clear

18145
12:05:13,040 --> 12:05:15,916
and run rooster and it is going to run

18146
12:05:15,916 --> 12:05:17,680
pretty well you see that for peace

18147
12:05:17,680 --> 12:05:18,720
corpse

18148
12:05:18,720 --> 12:05:22,160
we initialized the first five elements

18149
12:05:22,160 --> 12:05:24,160
and the remaining elements were

18150
12:05:24,160 --> 12:05:25,520
initialized

18151
12:05:25,520 --> 12:05:28,080
implicitly by the compiler to zero and

18152
12:05:28,080 --> 12:05:29,756
you can see that here i don't think i

18153
12:05:29,756 --> 12:05:32,000
explained this but this is my chance to

18154
12:05:32,000 --> 12:05:33,680
explain this i hope you understand the

18155
12:05:33,680 --> 12:05:35,916
next thing i wanted to explore before we

18156
12:05:35,916 --> 12:05:37,596
close this video is the difference

18157
12:05:37,596 --> 12:05:40,080
between static arrays and dynamic arrays

18158
12:05:40,080 --> 12:05:42,480
a static array is an array you allocate

18159
12:05:42,480 --> 12:05:44,320
on the stack like we have been doing

18160
12:05:44,320 --> 12:05:47,276
before and you do it using a syntax like

18161
12:05:47,276 --> 12:05:49,840
let's say scores why not and it is going

18162
12:05:49,840 --> 12:05:51,840
to be an array that says it is going to

18163
12:05:51,840 --> 12:05:54,080
contain 10 elements

18164
12:05:54,080 --> 12:05:56,080
and we are going to put in our values in

18165
12:05:56,080 --> 12:05:57,840
the format that we know

18166
12:05:57,840 --> 12:06:00,080
and we're going to go all the way to 10

18167
12:06:00,080 --> 12:06:01,840
let's put in a 10 here and we're going

18168
12:06:01,840 --> 12:06:04,400
to end this with a semicolon

18169
12:06:04,400 --> 12:06:06,640
this array is cool and you can loop

18170
12:06:06,640 --> 12:06:08,400
through it you can do all kinds of crazy

18171
12:06:08,400 --> 12:06:10,480
things with it but i am going to

18172
12:06:10,480 --> 12:06:13,200
emphasize two differences we have with

18173
12:06:13,200 --> 12:06:15,680
dynamic arrays one is that this guy is

18174
12:06:15,680 --> 12:06:17,520
going to work with sdd size so we're

18175
12:06:17,520 --> 12:06:19,436
going to say the out

18176
12:06:19,436 --> 12:06:21,360
okay this is going to work if we compile

18177
12:06:21,360 --> 12:06:22,720
this

18178
12:06:22,720 --> 12:06:25,436
we're going to get a good world at least

18179
12:06:25,436 --> 12:06:27,680
i hope yes the world is good and if we

18180
12:06:27,680 --> 12:06:30,240
run rooster

18181
12:06:30,240 --> 12:06:32,480
we're going to get scores the size is

18182
12:06:32,480 --> 12:06:33,436
10.

18183
12:06:33,436 --> 12:06:35,436
the other thing is that you can use a

18184
12:06:35,436 --> 12:06:37,520
range based for loop to loop through

18185
12:06:37,520 --> 12:06:40,240
this guy here so for example we can say

18186
12:06:40,240 --> 12:06:41,360
for

18187
12:06:41,360 --> 12:06:45,116
auto score s for score in scores

18188
12:06:45,116 --> 12:06:47,916
and it is going to work so let's go down

18189
12:06:47,916 --> 12:06:50,000
and say what we are doing here or we can

18190
12:06:50,000 --> 12:06:52,960
even say a single line to separate fence

18191
12:06:52,960 --> 12:06:55,360
here i don't want to be confused so i am

18192
12:06:55,360 --> 12:06:57,436
going to do something like this so that

18193
12:06:57,436 --> 12:07:00,000
i know where my output here is going to

18194
12:07:00,000 --> 12:07:01,276
start

18195
12:07:01,276 --> 12:07:03,840
so i am going to build this

18196
12:07:03,840 --> 12:07:07,200
with gcc of course the world is going to

18197
12:07:07,200 --> 12:07:08,880
go through

18198
12:07:08,880 --> 12:07:10,640
and if i clear

18199
12:07:10,640 --> 12:07:12,320
and run rooster

18200
12:07:12,320 --> 12:07:14,480
i am going to see that the size is 10

18201
12:07:14,480 --> 12:07:17,360
and i am going to print my elements here

18202
12:07:17,360 --> 12:07:21,040
with a range based for loop

18203
12:07:21,040 --> 12:07:23,200
okay let's see how these things behave

18204
12:07:23,200 --> 12:07:25,436
when we use a dynamic array we are going

18205
12:07:25,436 --> 12:07:28,720
to set up a similar array but on the hip

18206
12:07:28,720 --> 12:07:31,436
which is going to leave on the hip this

18207
12:07:31,436 --> 12:07:33,520
array here is the static array in that

18208
12:07:33,520 --> 12:07:35,360
it is going to live on the stack you

18209
12:07:35,360 --> 12:07:37,360
have to be aware of these differences

18210
12:07:37,360 --> 12:07:38,960
okay we're going to do another one which

18211
12:07:38,960 --> 12:07:40,640
is going to leave on the heap and the

18212
12:07:40,640 --> 12:07:43,040
way we do that we say end pointer let's

18213
12:07:43,040 --> 12:07:45,360
say p scores one to make sure this is

18214
12:07:45,360 --> 12:07:47,436
different from p squares that we have on

18215
12:07:47,436 --> 12:07:49,116
top here and we're going to have 10

18216
12:07:49,116 --> 12:07:51,276
elements inside and we can even

18217
12:07:51,276 --> 12:07:53,840
initialize this guy exactly like we are

18218
12:07:53,840 --> 12:07:56,560
doing here but the data is not going to

18219
12:07:56,560 --> 12:07:58,640
leave on the stack the data is going to

18220
12:07:58,640 --> 12:08:00,160
leave on the heap

18221
12:08:00,160 --> 12:08:02,960
if we do something like this first let's

18222
12:08:02,960 --> 12:08:04,720
make sure that the code compiles we're

18223
12:08:04,720 --> 12:08:06,800
going to try and run this

18224
12:08:06,800 --> 12:08:08,320
through gcc

18225
12:08:08,320 --> 12:08:10,640
and watch the compiler output here the

18226
12:08:10,640 --> 12:08:12,960
bolt is good so this is valid c plus

18227
12:08:12,960 --> 12:08:14,400
plus code

18228
12:08:14,400 --> 12:08:17,596
we can try and use hdd size on that and

18229
12:08:17,596 --> 12:08:21,040
we're going to go down and do that

18230
12:08:21,360 --> 12:08:24,080
and if we do that we're going to say p

18231
12:08:24,080 --> 12:08:26,560
scores size

18232
12:08:26,560 --> 12:08:29,596
one size and say p scores if we try to

18233
12:08:29,596 --> 12:08:31,436
pass this pointer here you're going to

18234
12:08:31,436 --> 12:08:33,520
see that visual studio code is going to

18235
12:08:33,520 --> 12:08:36,240
freak out because this won't work

18236
12:08:36,240 --> 12:08:37,436
the

18237
12:08:37,436 --> 12:08:40,880
array here has decayed into a pointer

18238
12:08:40,880 --> 12:08:43,680
when we refer to it using a row pointer

18239
12:08:43,680 --> 12:08:46,000
like this so we can't really use it

18240
12:08:46,000 --> 12:08:48,800
inside std size

18241
12:08:48,800 --> 12:08:50,480
so if we look at this we're going to get

18242
12:08:50,480 --> 12:08:53,040
a weird compiler error but this is going

18243
12:08:53,040 --> 12:08:54,880
to be the problem here

18244
12:08:54,880 --> 12:08:57,200
okay so you can't do this with dynamic

18245
12:08:57,200 --> 12:09:00,160
arrays this is one limitation the other

18246
12:09:00,160 --> 12:09:03,040
is that you can't use dynamic arrays

18247
12:09:03,040 --> 12:09:06,160
like we are using a range based for loop

18248
12:09:06,160 --> 12:09:09,680
here so if we grab this loop and try to

18249
12:09:09,680 --> 12:09:12,720
work with it on p scores for example

18250
12:09:12,720 --> 12:09:14,960
this is something somebody might want to

18251
12:09:14,960 --> 12:09:15,680
do

18252
12:09:15,680 --> 12:09:16,680
let's say

18253
12:09:16,680 --> 12:09:19,596
pscores1 okay and try to print something

18254
12:09:19,596 --> 12:09:21,040
inside you're going to see that this is

18255
12:09:21,040 --> 12:09:23,040
not going to work the compiler visuals

18256
12:09:23,040 --> 12:09:25,596
video code is not going to like it first

18257
12:09:25,596 --> 12:09:29,840
and if we try and run this through gcc

18258
12:09:29,840 --> 12:09:31,840
we're also going to get a weird compiler

18259
12:09:31,840 --> 12:09:34,000
arrow and the problem is going to be

18260
12:09:34,000 --> 12:09:37,040
that p scores is really not an array it

18261
12:09:37,040 --> 12:09:39,276
is just a pointer that is pointing to

18262
12:09:39,276 --> 12:09:42,000
some location in memory that's all it is

18263
12:09:42,000 --> 12:09:44,480
and it doesn't have information that

18264
12:09:44,480 --> 12:09:46,720
could be used otherwise to loop through

18265
12:09:46,720 --> 12:09:47,756
elements

18266
12:09:47,756 --> 12:09:52,000
like we can do for a real static array

18267
12:09:52,000 --> 12:09:54,800
that is leaving on the stack again let's

18268
12:09:54,800 --> 12:09:57,360
be super clear here and say that this

18269
12:09:57,360 --> 12:09:59,916
array is going to leave

18270
12:09:59,916 --> 12:10:02,000
on the heap you have to understand these

18271
12:10:02,000 --> 12:10:04,080
things but this is really not a big

18272
12:10:04,080 --> 12:10:06,880
limitation because you can store the

18273
12:10:06,880 --> 12:10:09,116
size of this guy in some variable and

18274
12:10:09,116 --> 12:10:11,360
refer to it if you need that and you can

18275
12:10:11,360 --> 12:10:13,436
loop through the array exactly like we

18276
12:10:13,436 --> 12:10:15,840
did here using size and it is going to

18277
12:10:15,840 --> 12:10:18,480
work pretty well so don't be afraid to

18278
12:10:18,480 --> 12:10:20,880
store your arrays on the heap if that's

18279
12:10:20,880 --> 12:10:23,200
what you need in your application it is

18280
12:10:23,200 --> 12:10:25,116
going to work pretty well you just have

18281
12:10:25,116 --> 12:10:28,080
to be aware of some limitations that

18282
12:10:28,080 --> 12:10:31,840
come with doing things this way here

18283
12:10:31,840 --> 12:10:33,596
this is really all we set out to do in

18284
12:10:33,596 --> 12:10:35,360
this lecture i hope you have a better

18285
12:10:35,360 --> 12:10:38,560
idea about dynamic arrays you set them

18286
12:10:38,560 --> 12:10:40,960
up like this the size here doesn't have

18287
12:10:40,960 --> 12:10:43,360
to be cost like we have with static

18288
12:10:43,360 --> 12:10:45,840
arrays and they have a few differences

18289
12:10:45,840 --> 12:10:48,480
compared to static arrays that were

18290
12:10:48,480 --> 12:10:51,756
stored on the stack and that std size

18291
12:10:51,756 --> 12:10:53,756
doesn't work for them and they don't

18292
12:10:53,756 --> 12:10:57,200
work with range based for loops other

18293
12:10:57,200 --> 12:10:59,916
than that dynamic arrays are ridiculed

18294
12:10:59,916 --> 12:11:02,480
and you should use them when that helps

18295
12:11:02,480 --> 12:11:04,640
whatever it is you are designing

18296
12:11:04,640 --> 12:11:07,276
welcome to this new chapter where we are

18297
12:11:07,276 --> 12:11:10,320
going to be talking about references

18298
12:11:10,320 --> 12:11:12,480
references are a way you can set up

18299
12:11:12,480 --> 12:11:15,680
alliances for your variables and have

18300
12:11:15,680 --> 12:11:18,240
other variable names you can go through

18301
12:11:18,240 --> 12:11:21,116
to modify that same variable for example

18302
12:11:21,116 --> 12:11:23,436
here we have a variable called var it is

18303
12:11:23,436 --> 12:11:25,840
an integer it leaves at this address

18304
12:11:25,840 --> 12:11:29,436
here and the value inside is 33.

18305
12:11:29,436 --> 12:11:32,560
if we set up another alliance to it as

18306
12:11:32,560 --> 12:11:35,596
var elias we can go through this var

18307
12:11:35,596 --> 12:11:38,880
elias variable and use it in pretty much

18308
12:11:38,880 --> 12:11:40,640
the same way we use the original

18309
12:11:40,640 --> 12:11:42,560
valuable and this is going to come in

18310
12:11:42,560 --> 12:11:45,840
handy in many situations as we are about

18311
12:11:45,840 --> 12:11:48,320
to see in this chapter we are going to

18312
12:11:48,320 --> 12:11:50,320
start in the next lecture and see how we

18313
12:11:50,320 --> 12:11:52,400
can declare initialize and use

18314
12:11:52,400 --> 12:11:54,400
references in our c plus plus

18315
12:11:54,400 --> 12:11:55,680
applications

18316
12:11:55,680 --> 12:11:58,000
go ahead and finish up here and meet me

18317
12:11:58,000 --> 12:11:59,916
there in this lecture we're going to see

18318
12:11:59,916 --> 12:12:02,720
how we can declare and use references in

18319
12:12:02,720 --> 12:12:05,916
our c plus application again a reference

18320
12:12:05,916 --> 12:12:09,040
is an elias variable that you can use to

18321
12:12:09,040 --> 12:12:11,520
reference an original variable and use

18322
12:12:11,520 --> 12:12:13,680
that reference in pretty much the same

18323
12:12:13,680 --> 12:12:16,800
way you use the original variable let's

18324
12:12:16,800 --> 12:12:19,276
see how that can work in c plus plus

18325
12:12:19,276 --> 12:12:21,520
here is a simple example we have two

18326
12:12:21,520 --> 12:12:24,720
variables one is an integer we have 45 n

18327
12:12:24,720 --> 12:12:28,160
the other is a double we have 33.65

18328
12:12:28,160 --> 12:12:28,960
n

18329
12:12:28,960 --> 12:12:31,200
we want to set up references to this

18330
12:12:31,200 --> 12:12:33,756
variable and the syntax is ridiculously

18331
12:12:33,756 --> 12:12:34,720
easy

18332
12:12:34,720 --> 12:12:37,040
for the edge value its reference is

18333
12:12:37,040 --> 12:12:39,840
going to be something like ant ampersand

18334
12:12:39,840 --> 12:12:42,640
you put the ampersand symbol you say the

18335
12:12:42,640 --> 12:12:45,040
name of the reference and you initialize

18336
12:12:45,040 --> 12:12:48,080
this with the value in the variable that

18337
12:12:48,080 --> 12:12:50,240
you want this to reference so reference

18338
12:12:50,240 --> 12:12:52,400
to h value is going to be referencing

18339
12:12:52,400 --> 12:12:54,960
our integer here and we can use this

18340
12:12:54,960 --> 12:12:58,880
name to reference this variable here and

18341
12:12:58,880 --> 12:13:00,800
it is going to be like we are using the

18342
12:13:00,800 --> 12:13:03,276
original variable which is interval here

18343
12:13:03,276 --> 12:13:04,640
we're going to see how this works in a

18344
12:13:04,640 --> 12:13:06,640
minute we can do the same using

18345
12:13:06,640 --> 12:13:09,200
assignment initialization and down here

18346
12:13:09,200 --> 12:13:11,116
you see that we have an example for the

18347
12:13:11,116 --> 12:13:13,436
double value and we have a reference to

18348
12:13:13,436 --> 12:13:15,680
it once we have these references we can

18349
12:13:15,680 --> 12:13:17,680
use them like we use

18350
12:13:17,680 --> 12:13:19,436
the original variables for example if

18351
12:13:19,436 --> 12:13:20,960
you come here you see we are printing

18352
12:13:20,960 --> 12:13:23,116
stuff out if we print any value we're

18353
12:13:23,116 --> 12:13:25,276
going to get the value printed out if we

18354
12:13:25,276 --> 12:13:26,720
print double value we're going to get

18355
12:13:26,720 --> 12:13:28,880
the value printed out we can also print

18356
12:13:28,880 --> 12:13:30,240
through references you're going to see

18357
12:13:30,240 --> 12:13:32,080
that they are going to print exactly the

18358
12:13:32,080 --> 12:13:34,720
same value as we have in the original

18359
12:13:34,720 --> 12:13:36,000
variables

18360
12:13:36,000 --> 12:13:38,560
but the interesting thing is going to be

18361
12:13:38,560 --> 12:13:39,360
that

18362
12:13:39,360 --> 12:13:41,520
if you print the addresses through the

18363
12:13:41,520 --> 12:13:44,640
original values and print the addresses

18364
12:13:44,640 --> 12:13:46,560
through the references you're going to

18365
12:13:46,560 --> 12:13:49,040
get the same addresses printed out which

18366
12:13:49,040 --> 12:13:51,680
is really going to say this to variable

18367
12:13:51,680 --> 12:13:55,116
names are almost exactly the same thing

18368
12:13:55,116 --> 12:13:57,360
in c plus plus and this is really cool

18369
12:13:57,360 --> 12:14:00,000
you can use the reference as if you are

18370
12:14:00,000 --> 12:14:02,640
using the original variable name in your

18371
12:14:02,640 --> 12:14:05,116
c plus plus code we're even going to try

18372
12:14:05,116 --> 12:14:06,880
and go through the sizes and print them

18373
12:14:06,880 --> 12:14:08,080
out and you're going to see that they

18374
12:14:08,080 --> 12:14:10,400
are going to be exactly the same thing

18375
12:14:10,400 --> 12:14:12,240
and we are going to see how important

18376
12:14:12,240 --> 12:14:15,040
this can become in c plus plus code as

18377
12:14:15,040 --> 12:14:16,960
we go through this chapter okay now that

18378
12:14:16,960 --> 12:14:19,436
we have the reference declared we can go

18379
12:14:19,436 --> 12:14:21,916
through that and modify the value and if

18380
12:14:21,916 --> 12:14:24,160
we do that the changes are going to be

18381
12:14:24,160 --> 12:14:27,116
reflected in the original variables and

18382
12:14:27,116 --> 12:14:29,116
if we print stuff like this again we're

18383
12:14:29,116 --> 12:14:31,040
going to see that the changes are going

18384
12:14:31,040 --> 12:14:33,360
to be reflected in the original

18385
12:14:33,360 --> 12:14:36,080
variables okay if you modify the

18386
12:14:36,080 --> 12:14:38,640
original variable the changes are also

18387
12:14:38,640 --> 12:14:41,116
going to be reflected in our references

18388
12:14:41,116 --> 12:14:43,276
and this is exactly what we would expect

18389
12:14:43,276 --> 12:14:45,360
from our references okay so this is

18390
12:14:45,360 --> 12:14:47,276
really all there is about references

18391
12:14:47,276 --> 12:14:49,840
they are alliances to your variables and

18392
12:14:49,840 --> 12:14:51,756
you can use them pretty much the same

18393
12:14:51,756 --> 12:14:54,160
way you use your variables let's head

18394
12:14:54,160 --> 12:14:56,640
over to visual studio code and see some

18395
12:14:56,640 --> 12:14:59,520
of these things in action here we are in

18396
12:14:59,520 --> 12:15:02,080
our working directory the chapter is

18397
12:15:02,080 --> 12:15:04,640
references and the lecture is declaring

18398
12:15:04,640 --> 12:15:06,880
and using references we are going to

18399
12:15:06,880 --> 12:15:09,596
grab our template files here

18400
12:15:09,596 --> 12:15:12,080
and we're going to put them in place and

18401
12:15:12,080 --> 12:15:14,240
we are going to open this in visual

18402
12:15:14,240 --> 12:15:16,400
studio code we are going to set up a new

18403
12:15:16,400 --> 12:15:19,276
variable let's call this data or it's

18404
12:15:19,276 --> 12:15:21,520
data this is going to be much more

18405
12:15:21,520 --> 12:15:23,276
descriptive and we're going to

18406
12:15:23,276 --> 12:15:26,560
initialize this with a 33 why not and

18407
12:15:26,560 --> 12:15:28,560
we're going to do a double and say

18408
12:15:28,560 --> 12:15:31,360
double data and we're going to put in a

18409
12:15:31,360 --> 12:15:32,960
55 in

18410
12:15:32,960 --> 12:15:34,800
and we're going to set up references to

18411
12:15:34,800 --> 12:15:36,800
these variables

18412
12:15:36,800 --> 12:15:39,680
and again a reference is an elias that

18413
12:15:39,680 --> 12:15:41,840
you can use in pretty much the same way

18414
12:15:41,840 --> 12:15:44,000
you use the original variable so we're

18415
12:15:44,000 --> 12:15:46,240
going to set up a reference to int data

18416
12:15:46,240 --> 12:15:47,596
we're going to say

18417
12:15:47,596 --> 12:15:49,200
and

18418
12:15:49,200 --> 12:15:51,596
reference mean reference by putting the

18419
12:15:51,596 --> 12:15:54,560
ampersand symbol here and we're going to

18420
12:15:54,560 --> 12:15:55,756
say rough

18421
12:15:55,756 --> 12:15:56,880
and

18422
12:15:56,880 --> 12:16:00,240
yeah and you initialize that

18423
12:16:00,240 --> 12:16:03,436
with the variable name you want this

18424
12:16:03,436 --> 12:16:05,680
reference to reference

18425
12:16:05,680 --> 12:16:07,840
and uh here we want to reference into

18426
12:16:07,840 --> 12:16:10,480
data so we're going to pass in into data

18427
12:16:10,480 --> 12:16:12,800
and this is going to be it our reference

18428
12:16:12,800 --> 12:16:14,560
is declared we can do the same for

18429
12:16:14,560 --> 12:16:16,800
double data so let's do that

18430
12:16:16,800 --> 12:16:18,400
double and we're going to say it's a

18431
12:16:18,400 --> 12:16:20,480
reference we're going to say rough

18432
12:16:20,480 --> 12:16:22,720
double data and we're going to reference

18433
12:16:22,720 --> 12:16:25,596
devo data here so let's do that okay

18434
12:16:25,596 --> 12:16:28,000
let's bring up our terminal and see if

18435
12:16:28,000 --> 12:16:29,680
we can compile this code here we're

18436
12:16:29,680 --> 12:16:32,480
going to compile with gcc like we always

18437
12:16:32,480 --> 12:16:35,360
do and let's close this then on the left

18438
12:16:35,360 --> 12:16:37,756
because it takes up

18439
12:16:37,756 --> 12:16:40,800
some of the space here the world is good

18440
12:16:40,800 --> 12:16:43,200
so this syntax is valid c plus plus

18441
12:16:43,200 --> 12:16:44,400
syntax

18442
12:16:44,400 --> 12:16:47,756
so what we can do is read values from

18443
12:16:47,756 --> 12:16:49,680
all these things and show you that they

18444
12:16:49,680 --> 12:16:51,756
really are the same things so we're

18445
12:16:51,756 --> 12:16:54,000
going to print stuff out and i am going

18446
12:16:54,000 --> 12:16:56,240
to put here some code and i am going to

18447
12:16:56,240 --> 12:16:58,560
come back when i have typed this i don't

18448
12:16:58,560 --> 12:17:01,116
want you to suffer watching me type

18449
12:17:01,116 --> 12:17:03,680
these things okay here i have the code

18450
12:17:03,680 --> 12:17:05,756
type down and you see that i am just

18451
12:17:05,756 --> 12:17:08,400
going to print dana through the original

18452
12:17:08,400 --> 12:17:10,400
variables i am going to print the actual

18453
12:17:10,400 --> 12:17:12,480
data and print the address of the

18454
12:17:12,480 --> 12:17:15,116
variable and do the same for the debo

18455
12:17:15,116 --> 12:17:17,680
data which is of type double

18456
12:17:17,680 --> 12:17:20,000
how convenient and we're going to print

18457
12:17:20,000 --> 12:17:21,360
references we're going to print the

18458
12:17:21,360 --> 12:17:23,200
reference and the address of the

18459
12:17:23,200 --> 12:17:25,200
reference and we're going to do the same

18460
12:17:25,200 --> 12:17:28,560
thing for our ref devil data here let's

18461
12:17:28,560 --> 12:17:31,916
try and build this with gcc

18462
12:17:31,916 --> 12:17:33,840
so we're going to run the task to do

18463
12:17:33,840 --> 12:17:35,276
that

18464
12:17:35,276 --> 12:17:37,596
and we are going to clear the book is

18465
12:17:37,596 --> 12:17:40,480
good and run rooster if we run rooster

18466
12:17:40,480 --> 12:17:43,040
you see that let's put a separate end

18467
12:17:43,040 --> 12:17:44,800
line here so that we see the entire

18468
12:17:44,800 --> 12:17:45,916
thing so

18469
12:17:45,916 --> 12:17:49,040
i really like to see my fans easily

18470
12:17:49,040 --> 12:17:51,276
so let's do that and build again okay

18471
12:17:51,276 --> 12:17:53,276
the build is good we can clear and run

18472
12:17:53,276 --> 12:17:55,520
rooster now and we're going to see the

18473
12:17:55,520 --> 12:17:59,360
original data and data is 33 the address

18474
12:17:59,360 --> 12:18:02,400
is this guy here we have demo data the

18475
12:18:02,400 --> 12:18:05,276
value is 55 and this is the address if

18476
12:18:05,276 --> 12:18:07,040
we look at our references we have

18477
12:18:07,040 --> 12:18:09,116
exactly the same thing the addresses are

18478
12:18:09,116 --> 12:18:11,596
even the same it really is like we are

18479
12:18:11,596 --> 12:18:13,360
using the original variable and this is

18480
12:18:13,360 --> 12:18:16,080
really cool it can allow you to pass

18481
12:18:16,080 --> 12:18:18,720
data around much easily

18482
12:18:18,720 --> 12:18:21,040
using references and whatever you are

18483
12:18:21,040 --> 12:18:23,360
using when you have sent this data for

18484
12:18:23,360 --> 12:18:25,276
example to some other file or some other

18485
12:18:25,276 --> 12:18:27,360
function you're going to be

18486
12:18:27,360 --> 12:18:29,680
affecting the same data okay so you're

18487
12:18:29,680 --> 12:18:31,756
not going to be making copies and we're

18488
12:18:31,756 --> 12:18:33,916
going to see how cold this can be

18489
12:18:33,916 --> 12:18:36,000
especially when we get to working with

18490
12:18:36,000 --> 12:18:38,640
functions this is going to be super cool

18491
12:18:38,640 --> 12:18:40,800
okay now we have seen that the

18492
12:18:40,800 --> 12:18:43,520
references are really referencing the

18493
12:18:43,520 --> 12:18:46,400
original values let's try and modify the

18494
12:18:46,400 --> 12:18:48,080
data through

18495
12:18:48,080 --> 12:18:50,080
the original values and see that the

18496
12:18:50,080 --> 12:18:51,436
references are going to pick up the

18497
12:18:51,436 --> 12:18:53,436
changes let's do that we're going to

18498
12:18:53,436 --> 12:18:56,436
take 80 data and change that to

18499
12:18:56,436 --> 12:18:58,960
111 and we're going to take the apple

18500
12:18:58,960 --> 12:19:03,360
data and change that to 67.2

18501
12:19:03,360 --> 12:19:05,200
why not and after we do this we're going

18502
12:19:05,200 --> 12:19:07,436
to print data again so we're going to

18503
12:19:07,436 --> 12:19:10,160
grab the code here

18504
12:19:10,160 --> 12:19:11,520
and

18505
12:19:11,520 --> 12:19:13,596
use that again here and we should see

18506
12:19:13,596 --> 12:19:15,916
the same changes applied

18507
12:19:15,916 --> 12:19:18,720
so we're going to weld with dcc the bolt

18508
12:19:18,720 --> 12:19:20,320
is going to be good

18509
12:19:20,320 --> 12:19:23,276
as you see here and if we clear and run

18510
12:19:23,276 --> 12:19:24,640
rooster

18511
12:19:24,640 --> 12:19:26,880
we are going to see that

18512
12:19:26,880 --> 12:19:30,320
the value is 55 let's put a separation

18513
12:19:30,320 --> 12:19:33,200
line in here this is cramped and it is

18514
12:19:33,200 --> 12:19:35,276
really hard to see what is happening

18515
12:19:35,276 --> 12:19:39,916
here so i am going to put an std endl in

18516
12:19:39,916 --> 12:19:43,596
here and weld again so let's do that and

18517
12:19:43,596 --> 12:19:46,000
the book is good so we can clear and run

18518
12:19:46,000 --> 12:19:48,400
rooster again and now we see things

18519
12:19:48,400 --> 12:19:50,800
separated out and it is easier on the

18520
12:19:50,800 --> 12:19:53,596
eye here we have empty data to b33 and

18521
12:19:53,596 --> 12:19:56,320
the depot data is 55 and we are going to

18522
12:19:56,320 --> 12:19:58,080
print our references which are going to

18523
12:19:58,080 --> 12:20:00,080
pick up the same things because a

18524
12:20:00,080 --> 12:20:02,880
reference is really analyzed to

18525
12:20:02,880 --> 12:20:05,116
the original variables but if you go

18526
12:20:05,116 --> 12:20:06,640
down you're going to see that the data

18527
12:20:06,640 --> 12:20:08,720
has actually changed and together has

18528
12:20:08,720 --> 12:20:10,800
changed to 111

18529
12:20:10,800 --> 12:20:14,560
and nabodana has changed to 67.2

18530
12:20:14,560 --> 12:20:16,560
and the interesting thing is that the

18531
12:20:16,560 --> 12:20:18,800
references have also picked up those

18532
12:20:18,800 --> 12:20:20,720
changes because they really are

18533
12:20:20,720 --> 12:20:22,640
referencing the same things in memory

18534
12:20:22,640 --> 12:20:24,240
it's like we are using the original

18535
12:20:24,240 --> 12:20:26,800
variable to

18536
12:20:26,800 --> 12:20:29,200
read these things like we are doing with

18537
12:20:29,200 --> 12:20:31,116
references here and this is really cool

18538
12:20:31,116 --> 12:20:33,040
here we have used the original variables

18539
12:20:33,040 --> 12:20:35,360
to modify data but we can also modify

18540
12:20:35,360 --> 12:20:37,116
the data through references and the

18541
12:20:37,116 --> 12:20:38,960
original variables are going to pick up

18542
12:20:38,960 --> 12:20:40,960
those changes so let's do that we're

18543
12:20:40,960 --> 12:20:43,360
going to say ref data and we're going to

18544
12:20:43,360 --> 12:20:45,040
change this to

18545
12:20:45,040 --> 12:20:47,680
12 for example

18546
12:20:47,680 --> 12:20:50,560
and let's use

18547
12:20:50,840 --> 12:20:53,680
1014 or 12. this is going to do we're

18548
12:20:53,680 --> 12:20:57,040
going to do ref double data and put in

18549
12:20:57,040 --> 12:21:00,960
another large number let's say 1000.45

18550
12:21:00,960 --> 12:21:02,880
why not and we're going to print the

18551
12:21:02,880 --> 12:21:04,840
data again so we're going to grab

18552
12:21:04,840 --> 12:21:08,560
this and print stuff out again so we're

18553
12:21:08,560 --> 12:21:10,720
going to go down and put in the code to

18554
12:21:10,720 --> 12:21:12,320
print stuff and you see it's going to

18555
12:21:12,320 --> 12:21:14,080
use the original variables and the

18556
12:21:14,080 --> 12:21:16,800
references and we should see the changes

18557
12:21:16,800 --> 12:21:19,116
reflected in our terminal here

18558
12:21:19,116 --> 12:21:20,560
so let's do that

18559
12:21:20,560 --> 12:21:23,520
and we're going to weld with gcc as we

18560
12:21:23,520 --> 12:21:24,640
always do

18561
12:21:24,640 --> 12:21:26,320
the bullet is going to be cool we're

18562
12:21:26,320 --> 12:21:28,640
going to clear and run rooster we're

18563
12:21:28,640 --> 12:21:31,916
going to see that we have 33 and 55 the

18564
12:21:31,916 --> 12:21:33,680
references are going to pick that up

18565
12:21:33,680 --> 12:21:35,596
that's what we have here we're going to

18566
12:21:35,596 --> 12:21:36,680
put in

18567
12:21:36,680 --> 12:21:39,596
111 and 67 through the original

18568
12:21:39,596 --> 12:21:41,520
variables and the references are going

18569
12:21:41,520 --> 12:21:43,596
to be picking that up and we're going to

18570
12:21:43,596 --> 12:21:46,320
use references and modify data you see

18571
12:21:46,320 --> 12:21:48,800
that the original variables are also

18572
12:21:48,800 --> 12:21:51,116
picking that up because we are really

18573
12:21:51,116 --> 12:21:53,436
modifying data in the same memory

18574
12:21:53,436 --> 12:21:55,680
location that's why these changes are

18575
12:21:55,680 --> 12:21:57,840
being shared between references and the

18576
12:21:57,840 --> 12:22:00,000
original variables and this is really

18577
12:22:00,000 --> 12:22:01,596
all we set out to do in this lecture to

18578
12:22:01,596 --> 12:22:03,680
show you how you can set up a reference

18579
12:22:03,680 --> 12:22:06,400
and prove that the changes we do either

18580
12:22:06,400 --> 12:22:09,040
through original data or references are

18581
12:22:09,040 --> 12:22:11,276
reflected between these two guys meaning

18582
12:22:11,276 --> 12:22:13,596
references and the original

18583
12:22:13,596 --> 12:22:14,880
variables

18584
12:22:14,880 --> 12:22:16,480
we are going to stop here in this

18585
12:22:16,480 --> 12:22:18,000
lecture in the next one we're going to

18586
12:22:18,000 --> 12:22:20,560
do a comparison between pointers and

18587
12:22:20,560 --> 12:22:23,360
references because they seem to be doing

18588
12:22:23,360 --> 12:22:25,116
quite the same thing

18589
12:22:25,116 --> 12:22:27,040
go ahead and finish up here

18590
12:22:27,040 --> 12:22:29,360
and meet me there and this lecture we're

18591
12:22:29,360 --> 12:22:32,080
going to be looking at the similarities

18592
12:22:32,080 --> 12:22:34,240
and the differences between references

18593
12:22:34,240 --> 12:22:36,640
and pointers okay we know that a pointer

18594
12:22:36,640 --> 12:22:38,480
is really something that is going to

18595
12:22:38,480 --> 12:22:40,880
store the address of the variable and we

18596
12:22:40,880 --> 12:22:43,276
can go through that pointer and modify

18597
12:22:43,276 --> 12:22:45,596
the original variable or really do

18598
12:22:45,596 --> 12:22:47,596
things with that but in the last lecture

18599
12:22:47,596 --> 12:22:49,680
we saw that we could also do the same

18600
12:22:49,680 --> 12:22:52,560
thing with references so why have these

18601
12:22:52,560 --> 12:22:54,880
two mechanisms in place

18602
12:22:54,880 --> 12:22:56,720
and what are the differences between

18603
12:22:56,720 --> 12:22:59,840
them here is a simple slide that i put

18604
12:22:59,840 --> 12:23:02,160
together to put the important points

18605
12:23:02,160 --> 12:23:04,880
about references and pointers together

18606
12:23:04,880 --> 12:23:06,560
the first thing is that if you use

18607
12:23:06,560 --> 12:23:08,880
references you are not going to go

18608
12:23:08,880 --> 12:23:11,520
through the star symbol to the reference

18609
12:23:11,520 --> 12:23:12,960
and get to the value you are

18610
12:23:12,960 --> 12:23:15,436
manipulating so that's going to really

18611
12:23:15,436 --> 12:23:17,436
feel like you are using the original

18612
12:23:17,436 --> 12:23:19,840
variable but with pointers you are going

18613
12:23:19,840 --> 12:23:21,596
to go through the referencing so that's

18614
12:23:21,596 --> 12:23:23,116
the first difference

18615
12:23:23,116 --> 12:23:25,200
another thing about references is that

18616
12:23:25,200 --> 12:23:27,916
you can't change them to reference

18617
12:23:27,916 --> 12:23:30,400
something else later but with pointers

18618
12:23:30,400 --> 12:23:31,916
we saw that we could do that we can

18619
12:23:31,916 --> 12:23:34,640
change a pointer to point somewhere else

18620
12:23:34,640 --> 12:23:37,276
if it happens to be a non-const pointer

18621
12:23:37,276 --> 12:23:39,520
the other thing is that for references

18622
12:23:39,520 --> 12:23:41,756
you have to initialize them at

18623
12:23:41,756 --> 12:23:43,680
declaration you can't declare a

18624
12:23:43,680 --> 12:23:46,160
reference and not initialize that if you

18625
12:23:46,160 --> 12:23:47,596
do that you're going to get a compiler

18626
12:23:47,596 --> 12:23:49,040
error and we're going to see that in a

18627
12:23:49,040 --> 12:23:52,400
minute but for pointers you can declare

18628
12:23:52,400 --> 12:23:54,560
a pointer and not initialize it and it

18629
12:23:54,560 --> 12:23:57,040
is going to just contain a junk address

18630
12:23:57,040 --> 12:23:59,596
and if you try to use that uninitialized

18631
12:23:59,596 --> 12:24:01,840
you are going to be setting yourself up

18632
12:24:01,840 --> 12:24:04,000
for trouble so we saw that so these are

18633
12:24:04,000 --> 12:24:06,080
the main differences between pointers

18634
12:24:06,080 --> 12:24:08,480
and references and now we are just going

18635
12:24:08,480 --> 12:24:11,520
to be looking at how these translate in

18636
12:24:11,520 --> 12:24:14,000
code here is a simple example we have a

18637
12:24:14,000 --> 12:24:15,756
variable called double value which

18638
12:24:15,756 --> 12:24:17,916
happens to be double and we have a

18639
12:24:17,916 --> 12:24:20,640
reference to it and a pointer to it so

18640
12:24:20,640 --> 12:24:22,880
you already know these concepts

18641
12:24:22,880 --> 12:24:25,680
now if we want to read the value in here

18642
12:24:25,680 --> 12:24:27,916
through our pointer and references we're

18643
12:24:27,916 --> 12:24:30,560
going to be using two different syntaxes

18644
12:24:30,560 --> 12:24:32,800
if we go through the reference we can

18645
12:24:32,800 --> 12:24:35,116
use this reference variable name

18646
12:24:35,116 --> 12:24:38,080
directly and read the value or change it

18647
12:24:38,080 --> 12:24:39,916
and we can do something like

18648
12:24:39,916 --> 12:24:42,400
ref double value to print that out this

18649
12:24:42,400 --> 12:24:44,640
is going to work but if we want to go

18650
12:24:44,640 --> 12:24:47,200
through the pointer we will have to go

18651
12:24:47,200 --> 12:24:49,276
through the referencing and this is

18652
12:24:49,276 --> 12:24:50,400
really bad

18653
12:24:50,400 --> 12:24:52,400
you know sometimes people don't like

18654
12:24:52,400 --> 12:24:55,116
this syntax they think that it is not

18655
12:24:55,116 --> 12:24:57,840
direct enough so they prefer to use

18656
12:24:57,840 --> 12:25:00,160
references to do these kinds of things

18657
12:25:00,160 --> 12:25:02,320
but pointers are still important as we

18658
12:25:02,320 --> 12:25:04,240
will see later as we progress in the

18659
12:25:04,240 --> 12:25:06,720
course so this is one difference with

18660
12:25:06,720 --> 12:25:08,560
references you don't have to go through

18661
12:25:08,560 --> 12:25:11,040
the dereferencing mechanism to use this

18662
12:25:11,040 --> 12:25:13,360
star here to print stuff or even

18663
12:25:13,360 --> 12:25:15,840
manipulate the data inside you just use

18664
12:25:15,840 --> 12:25:17,360
the variable name and it is going to

18665
12:25:17,360 --> 12:25:19,916
work with pointers you have to reference

18666
12:25:19,916 --> 12:25:21,520
because if you don't the reference

18667
12:25:21,520 --> 12:25:23,116
you're going to be referring to the

18668
12:25:23,116 --> 12:25:25,756
address stored in this pointer this is

18669
12:25:25,756 --> 12:25:28,080
the first difference and we see that the

18670
12:25:28,080 --> 12:25:30,880
same applies if we are trying to

18671
12:25:30,880 --> 12:25:33,916
write data into our variable if we go

18672
12:25:33,916 --> 12:25:35,596
through the pointer we will have to

18673
12:25:35,596 --> 12:25:37,840
dereference and use this dollar symbol

18674
12:25:37,840 --> 12:25:39,116
in front here

18675
12:25:39,116 --> 12:25:41,116
if we are using a reference we can do

18676
12:25:41,116 --> 12:25:44,080
that directly as if we are modifying the

18677
12:25:44,080 --> 12:25:46,800
original variable so this syntax is much

18678
12:25:46,800 --> 12:25:48,640
more readable the other difference is

18679
12:25:48,640 --> 12:25:51,200
that we can't make a reference

18680
12:25:51,200 --> 12:25:53,276
reference something else but we can

18681
12:25:53,276 --> 12:25:55,040
change a pointer to point to something

18682
12:25:55,040 --> 12:25:57,680
else let's look at an example here we

18683
12:25:57,680 --> 12:25:59,596
have ref double value which is a

18684
12:25:59,596 --> 12:26:01,680
reference to double value

18685
12:26:01,680 --> 12:26:02,960
and here

18686
12:26:02,960 --> 12:26:05,520
we are doing an assignment to this thing

18687
12:26:05,520 --> 12:26:07,840
here we are saying either double value

18688
12:26:07,840 --> 12:26:09,520
and assigning that

18689
12:26:09,520 --> 12:26:12,560
to our reference but what we are doing

18690
12:26:12,560 --> 12:26:15,040
here is not making ref double value

18691
12:26:15,040 --> 12:26:17,596
reference this other variable we are

18692
12:26:17,596 --> 12:26:19,680
just grabbing the value in other double

18693
12:26:19,680 --> 12:26:21,596
value and assigning that to our

18694
12:26:21,596 --> 12:26:24,320
reference and the value in either double

18695
12:26:24,320 --> 12:26:26,720
value is going to be reflected in the

18696
12:26:26,720 --> 12:26:29,040
original value here so this is what we

18697
12:26:29,040 --> 12:26:31,916
are doing we are not reassigning to our

18698
12:26:31,916 --> 12:26:33,916
reference to make it reference something

18699
12:26:33,916 --> 12:26:36,240
else we are assigning the value to the

18700
12:26:36,240 --> 12:26:38,800
reference as it is now and it is going

18701
12:26:38,800 --> 12:26:40,640
to be still referencing the same

18702
12:26:40,640 --> 12:26:43,040
variable in memory if you print out the

18703
12:26:43,040 --> 12:26:44,400
address in memory you're going to see

18704
12:26:44,400 --> 12:26:46,880
that the address of the reference here

18705
12:26:46,880 --> 12:26:48,880
hasn't changed so this is something you

18706
12:26:48,880 --> 12:26:50,800
should keep in mind but we know that a

18707
12:26:50,800 --> 12:26:52,880
pointer can point somewhere else if we

18708
12:26:52,880 --> 12:26:54,720
have a pointer here for example p double

18709
12:26:54,720 --> 12:26:57,756
value we can reassign it another address

18710
12:26:57,756 --> 12:27:00,560
and make it point to that new address so

18711
12:27:00,560 --> 12:27:02,240
in this regard we can think of

18712
12:27:02,240 --> 12:27:05,040
references as cost pointers because cost

18713
12:27:05,040 --> 12:27:07,840
pointers can't also be made to point

18714
12:27:07,840 --> 12:27:09,596
somewhere else and if you're trying to

18715
12:27:09,596 --> 12:27:11,916
do that for example here we have a cost

18716
12:27:11,916 --> 12:27:15,756
pointer it is called cost p double value

18717
12:27:15,756 --> 12:27:17,520
and if we try and make it point

18718
12:27:17,520 --> 12:27:19,520
somewhere else through this assignment

18719
12:27:19,520 --> 12:27:21,596
here we're going to get a compiler error

18720
12:27:21,596 --> 12:27:24,160
okay so this is really all in terms of

18721
12:27:24,160 --> 12:27:26,240
the comparisons that we had to make

18722
12:27:26,240 --> 12:27:28,400
between references and pointers now

18723
12:27:28,400 --> 12:27:30,000
we're going to head over to visual

18724
12:27:30,000 --> 12:27:32,160
studio code and see how these things

18725
12:27:32,160 --> 12:27:35,360
work in real code so here we are in our

18726
12:27:35,360 --> 12:27:37,840
working folder the current project is

18727
12:27:37,840 --> 12:27:40,400
comparing pointers and references we are

18728
12:27:40,400 --> 12:27:43,200
going to grab our template files and put

18729
12:27:43,200 --> 12:27:44,800
them in place

18730
12:27:44,800 --> 12:27:47,520
and we are going to open this project in

18731
12:27:47,520 --> 12:27:50,400
visual studio code like we always do we

18732
12:27:50,400 --> 12:27:52,160
are going to go down and put in some

18733
12:27:52,160 --> 12:27:54,720
starter code and let's align this a

18734
12:27:54,720 --> 12:27:56,080
little better

18735
12:27:56,080 --> 12:27:58,480
so and we can close this pane so that we

18736
12:27:58,480 --> 12:28:00,720
have some breathing room here we have a

18737
12:28:00,720 --> 12:28:03,116
variable of double type and we set up a

18738
12:28:03,116 --> 12:28:05,360
reference to it and a pointer to it this

18739
12:28:05,360 --> 12:28:07,116
is how we do this thanks you already

18740
12:28:07,116 --> 12:28:08,160
know this

18741
12:28:08,160 --> 12:28:11,200
and we can try and read through

18742
12:28:11,200 --> 12:28:12,880
the original variable through the

18743
12:28:12,880 --> 12:28:15,596
reference and through the pointer and

18744
12:28:15,596 --> 12:28:18,960
see how these syntaxes differ and how

18745
12:28:18,960 --> 12:28:21,520
one might be better than the other for

18746
12:28:21,520 --> 12:28:24,480
example if we look at how we are using

18747
12:28:24,480 --> 12:28:26,320
the reference it's really like we are

18748
12:28:26,320 --> 12:28:28,400
using the original value here we don't

18749
12:28:28,400 --> 12:28:30,800
have to do reference if we try to print

18750
12:28:30,800 --> 12:28:32,560
the pointer directly like this without

18751
12:28:32,560 --> 12:28:34,800
the referencing this is going to print

18752
12:28:34,800 --> 12:28:37,840
the actual address stored in this

18753
12:28:37,840 --> 12:28:40,160
pointer it's not going to print the

18754
12:28:40,160 --> 12:28:43,436
actual value stored in the address

18755
12:28:43,436 --> 12:28:45,360
pointed to by this pointer i really want

18756
12:28:45,360 --> 12:28:47,840
this to be clear so this is the syntax

18757
12:28:47,840 --> 12:28:50,080
we can use for reading stuff either

18758
12:28:50,080 --> 12:28:52,320
through references or pointers we can

18759
12:28:52,320 --> 12:28:54,640
also use these syntaxes to write stuff

18760
12:28:54,640 --> 12:28:56,960
into our variables for example here we

18761
12:28:56,960 --> 12:28:58,800
can go through the pointer and we have

18762
12:28:58,800 --> 12:29:01,116
to the reference and we can go through

18763
12:29:01,116 --> 12:29:03,200
the reference to really do the same

18764
12:29:03,200 --> 12:29:04,800
thing and we're going to see that our

18765
12:29:04,800 --> 12:29:07,040
syntaxes here are going to pick up the

18766
12:29:07,040 --> 12:29:08,080
changes

18767
12:29:08,080 --> 12:29:10,720
regardless of whether we write through

18768
12:29:10,720 --> 12:29:13,756
pointer or a reference because all these

18769
12:29:13,756 --> 12:29:15,040
things really are going to be

18770
12:29:15,040 --> 12:29:18,480
referencing the same location in memory

18771
12:29:18,480 --> 12:29:21,756
let's try and bring up a terminal here

18772
12:29:21,756 --> 12:29:24,560
and we are going to world with gcc let's

18773
12:29:24,560 --> 12:29:26,800
do that the build is going to be good

18774
12:29:26,800 --> 12:29:29,436
and we're going to clear and run rooster

18775
12:29:29,436 --> 12:29:31,200
and you're going to see that at first

18776
12:29:31,200 --> 12:29:33,436
we're going to have a 12

18777
12:29:33,436 --> 12:29:35,200
point 34 in

18778
12:29:35,200 --> 12:29:37,040
that's going to be the value we can get

18779
12:29:37,040 --> 12:29:39,596
it through original value the reference

18780
12:29:39,596 --> 12:29:42,160
or the pointer through the referencing

18781
12:29:42,160 --> 12:29:44,800
and the address is this one here

18782
12:29:44,800 --> 12:29:46,320
if we change the value through the

18783
12:29:46,320 --> 12:29:48,240
pointer we're going to see the changes

18784
12:29:48,240 --> 12:29:50,400
reflected here and if we change the

18785
12:29:50,400 --> 12:29:52,160
value through the reference we're going

18786
12:29:52,160 --> 12:29:54,240
to see the changes reflected in here so

18787
12:29:54,240 --> 12:29:56,560
this is how you can use pointers and

18788
12:29:56,560 --> 12:29:59,040
references to do these things here and

18789
12:29:59,040 --> 12:30:00,720
you can really choose what makes sense

18790
12:30:00,720 --> 12:30:02,560
for your application they mostly do the

18791
12:30:02,560 --> 12:30:04,880
same things but some people say that the

18792
12:30:04,880 --> 12:30:07,360
syntax to the reference the pointer here

18793
12:30:07,360 --> 12:30:09,596
is really ugly that's why most people

18794
12:30:09,596 --> 12:30:11,840
prefer to use references like this but

18795
12:30:11,840 --> 12:30:14,320
references have other benefits as well

18796
12:30:14,320 --> 12:30:16,640
as we're going to see as we progress in

18797
12:30:16,640 --> 12:30:18,320
the course another thing i want you to

18798
12:30:18,320 --> 12:30:20,240
see is that you can't change a reference

18799
12:30:20,240 --> 12:30:22,960
to reference something else in memory

18800
12:30:22,960 --> 12:30:24,720
for example here we have our reference

18801
12:30:24,720 --> 12:30:27,756
which is ref double value if we try and

18802
12:30:27,756 --> 12:30:30,160
make it reference something else

18803
12:30:30,160 --> 12:30:31,916
we're not going to get that result let's

18804
12:30:31,916 --> 12:30:33,840
go down and try to do that

18805
12:30:33,840 --> 12:30:35,436
so we're going to set up another double

18806
12:30:35,436 --> 12:30:38,800
variable so if we try to

18807
12:30:38,800 --> 12:30:41,916
make our ref double value reference this

18808
12:30:41,916 --> 12:30:42,880
guy

18809
12:30:42,880 --> 12:30:45,436
the syntax that comes to mind is saying

18810
12:30:45,436 --> 12:30:46,880
ref

18811
12:30:46,880 --> 12:30:50,480
double value and assign that the some

18812
12:30:50,480 --> 12:30:51,360
other

18813
12:30:51,360 --> 12:30:53,520
double value here now let's see what

18814
12:30:53,520 --> 12:30:55,680
happens if we do that we're going to try

18815
12:30:55,680 --> 12:30:58,480
and print whatever we have in memory

18816
12:30:58,480 --> 12:31:00,320
using the

18817
12:31:00,320 --> 12:31:04,000
ref double value here let's grab this

18818
12:31:04,000 --> 12:31:06,480
and go down here and say that we are

18819
12:31:06,480 --> 12:31:08,800
changing the reference making the

18820
12:31:08,800 --> 12:31:11,040
reference reference something else let's

18821
12:31:11,040 --> 12:31:13,436
say that so if we try to build this

18822
12:31:13,436 --> 12:31:15,756
let's see what we get we're going to run

18823
12:31:15,756 --> 12:31:18,240
and build with gcc

18824
12:31:18,240 --> 12:31:20,720
and we're going to try and run this

18825
12:31:20,720 --> 12:31:22,800
clear not clear and we're going to run

18826
12:31:22,800 --> 12:31:24,080
rooster

18827
12:31:24,080 --> 12:31:25,680
we're going to see that

18828
12:31:25,680 --> 12:31:31,640
the last line of output here say 78.45

18829
12:31:31,756 --> 12:31:35,116
but the address is still the same so we

18830
12:31:35,116 --> 12:31:38,000
are still referencing the same memory

18831
12:31:38,000 --> 12:31:40,480
with our reference and what we just did

18832
12:31:40,480 --> 12:31:43,360
here was just grab the value in some

18833
12:31:43,360 --> 12:31:45,116
other double value

18834
12:31:45,116 --> 12:31:46,960
and assign that in here but the

18835
12:31:46,960 --> 12:31:49,916
reference is referencing the same memory

18836
12:31:49,916 --> 12:31:52,240
location it's been referencing so in c

18837
12:31:52,240 --> 12:31:55,200
plus plus you don't have a way you can

18838
12:31:55,200 --> 12:31:56,320
go through

18839
12:31:56,320 --> 12:31:58,800
to make a reference reference something

18840
12:31:58,800 --> 12:32:01,360
else the only chance you have to make it

18841
12:32:01,360 --> 12:32:03,360
reference something is through

18842
12:32:03,360 --> 12:32:06,720
declaration here and that's the reason

18843
12:32:06,720 --> 12:32:09,436
you can't declare a reference and not

18844
12:32:09,436 --> 12:32:10,960
initialize it if you do that you're

18845
12:32:10,960 --> 12:32:13,040
going to get a compiler error so let's

18846
12:32:13,040 --> 12:32:14,400
try and do something like this we're

18847
12:32:14,400 --> 12:32:16,880
going to take out this double value and

18848
12:32:16,880 --> 12:32:18,240
the moment we do this you're going to

18849
12:32:18,240 --> 12:32:20,080
see that visual studio code is going to

18850
12:32:20,080 --> 12:32:22,640
be unhappy you see the squiggly line and

18851
12:32:22,640 --> 12:32:24,880
it is going to say initial value of

18852
12:32:24,880 --> 12:32:27,436
reference to non-cos must be an l value

18853
12:32:27,436 --> 12:32:29,116
so what is that

18854
12:32:29,116 --> 12:32:31,596
okay if we take out the initialization

18855
12:32:31,596 --> 12:32:33,680
altogether it's going to give us a

18856
12:32:33,680 --> 12:32:35,840
better error i think reference variable

18857
12:32:35,840 --> 12:32:38,800
requires an initializer so every time

18858
12:32:38,800 --> 12:32:41,436
you declare a reference you have to

18859
12:32:41,436 --> 12:32:44,640
initialize it and we should do like we

18860
12:32:44,640 --> 12:32:46,960
just did before here and we're going to

18861
12:32:46,960 --> 12:32:49,116
be fine again you can't declare a

18862
12:32:49,116 --> 12:32:51,756
reference and not initialize it if you

18863
12:32:51,756 --> 12:32:53,276
do that you're going to get a compiler

18864
12:32:53,276 --> 12:32:56,080
error and the reason is that

18865
12:32:56,080 --> 12:32:58,240
this is the only shot you get to make

18866
12:32:58,240 --> 12:33:00,880
your reference reference something else

18867
12:33:00,880 --> 12:33:02,560
okay if there was a way for you to

18868
12:33:02,560 --> 12:33:05,840
bypass this and let the compiler compile

18869
12:33:05,840 --> 12:33:08,000
this you would never get another chance

18870
12:33:08,000 --> 12:33:09,916
to make this guy actually reference

18871
12:33:09,916 --> 12:33:12,080
something and it would really be a

18872
12:33:12,080 --> 12:33:14,320
useless reference so make sure you

18873
12:33:14,320 --> 12:33:16,320
understand this you can't make a

18874
12:33:16,320 --> 12:33:19,116
reference reference something else and

18875
12:33:19,116 --> 12:33:21,276
if you try to do something through a

18876
12:33:21,276 --> 12:33:23,116
syntax like this

18877
12:33:23,116 --> 12:33:24,960
you're going to be assigning the value

18878
12:33:24,960 --> 12:33:27,756
of whatever variable you have to the

18879
12:33:27,756 --> 12:33:29,436
reference you're not going to be making

18880
12:33:29,436 --> 12:33:31,916
the reference referencing something else

18881
12:33:31,916 --> 12:33:33,360
the reference is going to keep

18882
12:33:33,360 --> 12:33:35,596
referencing the same variable in memory

18883
12:33:35,596 --> 12:33:37,916
as we have seen here so let's say what

18884
12:33:37,916 --> 12:33:39,916
we were trying to do here but we know

18885
12:33:39,916 --> 12:33:42,400
that we can make pointers reference

18886
12:33:42,400 --> 12:33:44,720
something else so here we have a pointer

18887
12:33:44,720 --> 12:33:45,596
again

18888
12:33:45,596 --> 12:33:47,756
this pointer called the p double value

18889
12:33:47,756 --> 12:33:50,000
and it has the address of double value

18890
12:33:50,000 --> 12:33:51,040
inside

18891
12:33:51,040 --> 12:33:53,916
but we can set up another variable

18892
12:33:53,916 --> 12:33:57,276
okay so we can make that reference this

18893
12:33:57,276 --> 12:33:58,960
other variable here and let's do that

18894
12:33:58,960 --> 12:34:00,480
you're going to see that our pointer now

18895
12:34:00,480 --> 12:34:02,320
is going to be containing another

18896
12:34:02,320 --> 12:34:04,960
address so what we can do

18897
12:34:04,960 --> 12:34:07,436
is say p double value

18898
12:34:07,436 --> 12:34:09,360
which is our new pointer and we're going

18899
12:34:09,360 --> 12:34:10,880
to assign it

18900
12:34:10,880 --> 12:34:15,040
the address of some other double value

18901
12:34:15,040 --> 12:34:19,596
and if we print the data now and go down

18902
12:34:19,596 --> 12:34:22,240
we are going to say make the pointer

18903
12:34:22,240 --> 12:34:24,240
point to something else that's what we

18904
12:34:24,240 --> 12:34:26,480
are doing here and we're going to say

18905
12:34:26,480 --> 12:34:29,116
the same thing here through a comma and

18906
12:34:29,116 --> 12:34:31,040
if we print this try to guess what we're

18907
12:34:31,040 --> 12:34:32,400
going to get

18908
12:34:32,400 --> 12:34:34,240
the pointer is going to contain a

18909
12:34:34,240 --> 12:34:36,720
completely new address because we can do

18910
12:34:36,720 --> 12:34:38,400
that we can make it point

18911
12:34:38,400 --> 12:34:40,560
to somewhere else

18912
12:34:40,560 --> 12:34:42,480
let's run rooster

18913
12:34:42,480 --> 12:34:44,960
and we're going to see our data here

18914
12:34:44,960 --> 12:34:48,560
let's make sure we see the entire fan

18915
12:34:48,560 --> 12:34:51,520
okay i think this is the data we have

18916
12:34:51,520 --> 12:34:53,436
let's go up again

18917
12:34:53,436 --> 12:34:56,000
there's no harm in that so we have our

18918
12:34:56,000 --> 12:34:58,640
fence that we have seen before but what

18919
12:34:58,640 --> 12:35:01,840
is going to be important here is that pw

18920
12:35:01,840 --> 12:35:05,040
value now contains a new address

18921
12:35:05,040 --> 12:35:07,916
okay so this is really important and you

18922
12:35:07,916 --> 12:35:10,240
have to understand that so we made the

18923
12:35:10,240 --> 12:35:12,160
pointer successfully point to something

18924
12:35:12,160 --> 12:35:14,960
else and if we change the data in the

18925
12:35:14,960 --> 12:35:16,160
pointer now

18926
12:35:16,160 --> 12:35:18,560
we're not going to be affecting the data

18927
12:35:18,560 --> 12:35:20,880
we have in here in double value we're

18928
12:35:20,880 --> 12:35:23,360
going to be affecting the data we have

18929
12:35:23,360 --> 12:35:25,756
and some other double value here let's

18930
12:35:25,756 --> 12:35:27,436
do that we're going to change the data

18931
12:35:27,436 --> 12:35:28,960
through the pointer so we're going to

18932
12:35:28,960 --> 12:35:31,200
say p double value and we're going to

18933
12:35:31,200 --> 12:35:32,560
change this to

18934
12:35:32,560 --> 12:35:35,200
555

18935
12:35:35,200 --> 12:35:37,520
and now we can print the data and see

18936
12:35:37,520 --> 12:35:39,916
that things have changed in memory and

18937
12:35:39,916 --> 12:35:42,000
we can print this to see the differences

18938
12:35:42,000 --> 12:35:44,720
here but before we do that let's also

18939
12:35:44,720 --> 12:35:46,880
print the address of the original

18940
12:35:46,880 --> 12:35:49,116
variable and the address because for now

18941
12:35:49,116 --> 12:35:52,240
we are just printing only the address

18942
12:35:52,240 --> 12:35:54,160
through the pointer so what we can do

18943
12:35:54,160 --> 12:35:58,080
here is grab htdc out and say

18944
12:35:58,080 --> 12:36:00,320
address of double volume and we're going

18945
12:36:00,320 --> 12:36:03,116
to put that out through htdc out here

18946
12:36:03,116 --> 12:36:04,880
we're going to do that and we're going

18947
12:36:04,880 --> 12:36:07,276
to print the address of the reference

18948
12:36:07,276 --> 12:36:08,960
why not

18949
12:36:08,960 --> 12:36:11,680
ref double value and we're going to put

18950
12:36:11,680 --> 12:36:13,520
that out as well i'm going to say

18951
12:36:13,520 --> 12:36:15,276
address of ref

18952
12:36:15,276 --> 12:36:16,480
double value

18953
12:36:16,480 --> 12:36:19,200
and we're going to say std endn and

18954
12:36:19,200 --> 12:36:21,360
after that we are going to grab the

18955
12:36:21,360 --> 12:36:24,160
entire thing here and print it out after

18956
12:36:24,160 --> 12:36:27,436
we modify the value in the pointer

18957
12:36:27,436 --> 12:36:29,360
i hope this is going to show thanks in a

18958
12:36:29,360 --> 12:36:30,640
much more

18959
12:36:30,640 --> 12:36:33,040
clear way so we're going to weld this

18960
12:36:33,040 --> 12:36:36,480
with gcc let's do that the build is good

18961
12:36:36,480 --> 12:36:39,276
so let's clear and run rooster and what

18962
12:36:39,276 --> 12:36:41,360
you're going to see is that

18963
12:36:41,360 --> 12:36:42,400
now

18964
12:36:42,400 --> 12:36:45,360
the original variable is living at

18965
12:36:45,360 --> 12:36:47,520
address here

18966
12:36:47,520 --> 12:36:49,436
which we can see in our reference but

18967
12:36:49,436 --> 12:36:51,436
the pointer now is pointing to something

18968
12:36:51,436 --> 12:36:52,320
else

18969
12:36:52,320 --> 12:36:54,480
no wonder that the changes we did

18970
12:36:54,480 --> 12:36:56,080
through the pointer are not being

18971
12:36:56,080 --> 12:36:58,160
reflected in our double value because

18972
12:36:58,160 --> 12:37:00,240
these two variables now

18973
12:37:00,240 --> 12:37:03,436
are living in different memory locations

18974
12:37:03,436 --> 12:37:05,520
i really hope you see that and this is

18975
12:37:05,520 --> 12:37:08,240
really all we had to share in terms

18976
12:37:08,240 --> 12:37:10,240
of the differences between pointers and

18977
12:37:10,240 --> 12:37:12,640
references i hope you have a clear

18978
12:37:12,640 --> 12:37:15,520
picture of what these two things are and

18979
12:37:15,520 --> 12:37:16,720
we are going to stop here in this

18980
12:37:16,720 --> 12:37:18,880
lecture this one we're going to see how

18981
12:37:18,880 --> 12:37:21,520
the const key world works with

18982
12:37:21,520 --> 12:37:22,956
references

18983
12:37:22,956 --> 12:37:25,200
go ahead and finish up here and meet me

18984
12:37:25,200 --> 12:37:27,116
there in this lecture we're going to see

18985
12:37:27,116 --> 12:37:30,160
how the const key world can be used with

18986
12:37:30,160 --> 12:37:31,436
references

18987
12:37:31,436 --> 12:37:34,000
and again the idea is to set up an alias

18988
12:37:34,000 --> 12:37:37,520
to a variable and make it const so that

18989
12:37:37,520 --> 12:37:40,080
we can't go through it to modify the

18990
12:37:40,080 --> 12:37:42,480
original variable this is the syntax we

18991
12:37:42,480 --> 12:37:44,800
used to set up a non-const reference

18992
12:37:44,800 --> 12:37:47,040
that we have seen so far so for example

18993
12:37:47,040 --> 12:37:50,080
we can say int age put in a value 27 in

18994
12:37:50,080 --> 12:37:52,956
this case and set up a reference to age

18995
12:37:52,956 --> 12:37:54,880
and initialize that

18996
12:37:54,880 --> 12:37:57,360
with the age variable once we do this

18997
12:37:57,360 --> 12:37:59,916
riff edge can be used to modify

18998
12:37:59,916 --> 12:38:02,240
this edge variable here and whatever is

18999
12:38:02,240 --> 12:38:05,116
inside for example we can go through ref

19000
12:38:05,116 --> 12:38:08,160
age to increment the age and if we print

19001
12:38:08,160 --> 12:38:10,400
the edge now we should get a 28 printed

19002
12:38:10,400 --> 12:38:12,956
out because this reference is going to

19003
12:38:12,956 --> 12:38:15,680
change these two things at the same time

19004
12:38:15,680 --> 12:38:18,160
or another way to say this these two

19005
12:38:18,160 --> 12:38:20,880
things age and ref age are referencing

19006
12:38:20,880 --> 12:38:22,720
the same memory

19007
12:38:22,720 --> 12:38:25,116
in your computer so if you change one

19008
12:38:25,116 --> 12:38:27,040
the other is going to pick up the change

19009
12:38:27,040 --> 12:38:28,880
we can also set up accounts reference

19010
12:38:28,880 --> 12:38:31,436
and the syntax is ridiculously easy you

19011
12:38:31,436 --> 12:38:34,080
say constant reference like this and

19012
12:38:34,080 --> 12:38:36,956
your reference is suddenly caused and

19013
12:38:36,956 --> 12:38:39,436
you can't go through it to modify the

19014
12:38:39,436 --> 12:38:40,880
original variable

19015
12:38:40,880 --> 12:38:42,640
if you need something like this in your

19016
12:38:42,640 --> 12:38:44,560
application this is how you do it you

19017
12:38:44,560 --> 12:38:46,480
can also duplicate the behavior with

19018
12:38:46,480 --> 12:38:48,560
count references with pointers and for

19019
12:38:48,560 --> 12:38:51,200
that we can use a construct like const

19020
12:38:51,200 --> 12:38:53,680
end pointer cost this is going to set up

19021
12:38:53,680 --> 12:38:56,400
a cost pointer to cost which we can't

19022
12:38:56,400 --> 12:38:58,320
use to modify the value that we are

19023
12:38:58,320 --> 12:38:59,520
pointing to

19024
12:38:59,520 --> 12:39:02,160
but it can't also be used to point to

19025
12:39:02,160 --> 12:39:04,240
something else so this is going to

19026
12:39:04,240 --> 12:39:06,000
simulate the behavior we have with

19027
12:39:06,000 --> 12:39:08,160
references and you can do that if you

19028
12:39:08,160 --> 12:39:10,400
want and please know that we have no

19029
12:39:10,400 --> 12:39:13,436
such thing as constant reference cost

19030
12:39:13,436 --> 12:39:15,360
this is going to give you a compiler

19031
12:39:15,360 --> 12:39:17,756
error because we have no such concept in

19032
12:39:17,756 --> 12:39:20,800
c plus plus and my head is hurting right

19033
12:39:20,800 --> 12:39:23,200
now trying to think about what this

19034
12:39:23,200 --> 12:39:25,520
would even mean and another thing i want

19035
12:39:25,520 --> 12:39:27,680
to make clear before we head over to

19036
12:39:27,680 --> 12:39:30,320
vg's video code and play with us is that

19037
12:39:30,320 --> 12:39:32,880
the const key world is going to apply to

19038
12:39:32,880 --> 12:39:34,560
the variable name

19039
12:39:34,560 --> 12:39:37,276
that you apply it to for example here we

19040
12:39:37,276 --> 12:39:39,200
have cost reference age which is going

19041
12:39:39,200 --> 12:39:42,400
to be a const reference but this doesn't

19042
12:39:42,400 --> 12:39:44,880
mean that the edge variable here has to

19043
12:39:44,880 --> 12:39:46,240
be cost

19044
12:39:46,240 --> 12:39:48,560
okay it can be cost or it may not be

19045
12:39:48,560 --> 12:39:51,116
cost but the cost here applies to this

19046
12:39:51,116 --> 12:39:53,840
variable name constraint age and we

19047
12:39:53,840 --> 12:39:55,916
can't go through this variable name and

19048
12:39:55,916 --> 12:39:58,080
modify the age if you're trying to do

19049
12:39:58,080 --> 12:40:00,320
that we're going to get a compiler error

19050
12:40:00,320 --> 12:40:02,400
now we can head over to visual studio

19051
12:40:02,400 --> 12:40:05,840
code and play with us here we are in our

19052
12:40:05,840 --> 12:40:08,640
working directory the current project is

19053
12:40:08,640 --> 12:40:11,360
reference and cost we're going to grab

19054
12:40:11,360 --> 12:40:14,080
our template files pretty quick let's do

19055
12:40:14,080 --> 12:40:14,880
that

19056
12:40:14,880 --> 12:40:17,756
and we're going to put them in place

19057
12:40:17,756 --> 12:40:20,000
and we are going to open this in visual

19058
12:40:20,000 --> 12:40:22,560
studio code we are going to review the

19059
12:40:22,560 --> 12:40:24,956
references we have seen so far in this

19060
12:40:24,956 --> 12:40:27,276
little example here we have the edge

19061
12:40:27,276 --> 12:40:30,320
variable it has a 27 inside and it is a

19062
12:40:30,320 --> 12:40:33,040
net and we have a reference to it

19063
12:40:33,040 --> 12:40:35,680
and this reference is not const so we

19064
12:40:35,680 --> 12:40:37,756
can go through this reference modify the

19065
12:40:37,756 --> 12:40:40,400
age and if we do that this is going to

19066
12:40:40,400 --> 12:40:42,160
work and if we print the edge here we're

19067
12:40:42,160 --> 12:40:45,116
going to see that it has turned into a

19068
12:40:45,116 --> 12:40:48,480
28 and we can try and print this through

19069
12:40:48,480 --> 12:40:50,720
the terminal so that you can see this

19070
12:40:50,720 --> 12:40:53,116
for yourself so let's run the task to

19071
12:40:53,116 --> 12:40:55,116
build with gcc

19072
12:40:55,116 --> 12:40:57,116
we are going to clear

19073
12:40:57,116 --> 12:40:59,756
and run rooster

19074
12:40:59,756 --> 12:41:01,200
and if we do that you're going to see

19075
12:41:01,200 --> 12:41:04,400
edge is 27 now it is 28 and we have

19076
12:41:04,400 --> 12:41:06,956
successfully modified data through our

19077
12:41:06,956 --> 12:41:08,320
reference here

19078
12:41:08,320 --> 12:41:10,560
but if we change this reference to be

19079
12:41:10,560 --> 12:41:12,480
const we won't be able to do that

19080
12:41:12,480 --> 12:41:14,640
anymore so let's try and make it a const

19081
12:41:14,640 --> 12:41:15,680
reference

19082
12:41:15,680 --> 12:41:17,680
if we do that we're going to get a

19083
12:41:17,680 --> 12:41:19,756
compiler error if we try to do something

19084
12:41:19,756 --> 12:41:22,240
like this because this is now a const

19085
12:41:22,240 --> 12:41:24,240
reference we can't go through it to

19086
12:41:24,240 --> 12:41:26,240
modify our data here and we're going to

19087
12:41:26,240 --> 12:41:28,160
get a compiler error here we have visual

19088
12:41:28,160 --> 12:41:30,956
studio called complaining here but if we

19089
12:41:30,956 --> 12:41:34,480
ignore that and go through the compiler

19090
12:41:34,480 --> 12:41:36,000
we're going to see that we get the same

19091
12:41:36,000 --> 12:41:38,560
compiler error we can't implement a read

19092
12:41:38,560 --> 12:41:41,040
only reference which is this ref age

19093
12:41:41,040 --> 12:41:43,436
here so this is what a cost reference

19094
12:41:43,436 --> 12:41:45,436
really is you can't go through it to

19095
12:41:45,436 --> 12:41:48,320
modify the data that is being referenced

19096
12:41:48,320 --> 12:41:49,916
and another thing i want you to really

19097
12:41:49,916 --> 12:41:52,240
understand is that this const keyword

19098
12:41:52,240 --> 12:41:55,040
here has nothing to do with the original

19099
12:41:55,040 --> 12:41:57,276
variable this is a constant reference we

19100
12:41:57,276 --> 12:41:59,360
can't go through it to modify the edge

19101
12:41:59,360 --> 12:42:02,720
variable but this doesn't matter if age

19102
12:42:02,720 --> 12:42:04,880
is either const or not const the

19103
12:42:04,880 --> 12:42:08,320
constants here applies to this variable

19104
12:42:08,320 --> 12:42:11,436
name here so this cost h may be cost if

19105
12:42:11,436 --> 12:42:13,200
it's cost it's going to work equally

19106
12:42:13,200 --> 12:42:14,956
well and we're going to still get a

19107
12:42:14,956 --> 12:42:17,360
compiler error here if it's not cost

19108
12:42:17,360 --> 12:42:19,436
it's going to be the same the cost we

19109
12:42:19,436 --> 12:42:22,480
have on our reference applies to this

19110
12:42:22,480 --> 12:42:24,400
reference variable name here this is

19111
12:42:24,400 --> 12:42:26,956
what i want you to understand okay this

19112
12:42:26,956 --> 12:42:29,840
is what a cost reference really is

19113
12:42:29,840 --> 12:42:32,480
another thing we want you to see

19114
12:42:32,480 --> 12:42:34,160
is that we can simulate the same

19115
12:42:34,160 --> 12:42:35,276
behavior

19116
12:42:35,276 --> 12:42:37,840
with pointers so let's set up a const

19117
12:42:37,840 --> 12:42:40,400
pointer to const on this edge here and

19118
12:42:40,400 --> 12:42:41,756
we're going to see that we can have the

19119
12:42:41,756 --> 12:42:43,680
same behavior but for that we're going

19120
12:42:43,680 --> 12:42:45,756
to have to comment this out because we

19121
12:42:45,756 --> 12:42:48,080
don't want noise output and we're going

19122
12:42:48,080 --> 12:42:50,880
to go on top here and comment this out

19123
12:42:50,880 --> 12:42:53,360
and say what we are intending to do we

19124
12:42:53,360 --> 12:42:56,640
can say that we are simulating reference

19125
12:42:56,640 --> 12:42:58,640
behavior with pointers and the way we're

19126
12:42:58,640 --> 12:42:59,916
going to do that we're going to say

19127
12:42:59,916 --> 12:43:02,880
const and pointer cost and we're going

19128
12:43:02,880 --> 12:43:04,480
to say ph

19129
12:43:04,480 --> 12:43:06,480
and we're going to initialize this with

19130
12:43:06,480 --> 12:43:09,116
our age variable or the address of our

19131
12:43:09,116 --> 12:43:12,480
age to be super clear okay so we have

19132
12:43:12,480 --> 12:43:15,200
our pointer set up let's try and go

19133
12:43:15,200 --> 12:43:17,436
through it and modify the age let's see

19134
12:43:17,436 --> 12:43:19,756
what happens we the reference because

19135
12:43:19,756 --> 12:43:21,756
this is a pointer and we're going to say

19136
12:43:21,756 --> 12:43:25,520
ph and say plus plus or even change this

19137
12:43:25,520 --> 12:43:28,560
to another age let's say 45 and if we do

19138
12:43:28,560 --> 12:43:29,680
this we're going to get the same

19139
12:43:29,680 --> 12:43:33,360
compiler error so if we build this

19140
12:43:33,360 --> 12:43:36,880
let's clear here clear not clear

19141
12:43:36,880 --> 12:43:38,560
and above again we're going to get

19142
12:43:38,560 --> 12:43:40,880
another compiler error saying that we

19143
12:43:40,880 --> 12:43:43,360
can't modify something that is read only

19144
12:43:43,360 --> 12:43:46,160
assignment of read only location this

19145
12:43:46,160 --> 12:43:50,400
pointer can't be used to modify the data

19146
12:43:50,400 --> 12:43:53,840
in this age location here so this is the

19147
12:43:53,840 --> 12:43:56,560
same behavior with references because

19148
12:43:56,560 --> 12:43:58,956
the reference by default can't be made

19149
12:43:58,956 --> 12:44:01,756
to point somewhere else we had to make

19150
12:44:01,756 --> 12:44:04,640
this pointer also a const pointer

19151
12:44:04,640 --> 12:44:07,040
preventing us from making it point to

19152
12:44:07,040 --> 12:44:08,956
other locations so this is how you can

19153
12:44:08,956 --> 12:44:12,400
simulate references with pointers and

19154
12:44:12,400 --> 12:44:14,240
this is really all we set out to do in

19155
12:44:14,240 --> 12:44:15,680
this lecture i hope you found it

19156
12:44:15,680 --> 12:44:16,880
interesting

19157
12:44:16,880 --> 12:44:19,520
the main idea was to let you know how

19158
12:44:19,520 --> 12:44:21,840
you can work with cost references and

19159
12:44:21,840 --> 12:44:23,360
once you have your const reference you

19160
12:44:23,360 --> 12:44:25,520
can't go through it to modify the

19161
12:44:25,520 --> 12:44:27,756
original data if you do that you're

19162
12:44:27,756 --> 12:44:29,596
going to get a compiler error

19163
12:44:29,596 --> 12:44:31,360
welcome to this new chapter where we

19164
12:44:31,360 --> 12:44:34,880
will be doing cool stuff with text data

19165
12:44:34,880 --> 12:44:36,720
we have seen that we can model a

19166
12:44:36,720 --> 12:44:39,276
character array and store in a bunch of

19167
12:44:39,276 --> 12:44:41,596
characters and we could for example call

19168
12:44:41,596 --> 12:44:43,436
this character array message and

19169
12:44:43,436 --> 12:44:45,756
manipulate it in memory in this

19170
12:44:45,756 --> 12:44:47,840
structure we will see that this is

19171
12:44:47,840 --> 12:44:50,560
actually the way text data is stored in

19172
12:44:50,560 --> 12:44:52,880
c plus plus and we have a lot of

19173
12:44:52,880 --> 12:44:55,116
facilities built on top of this

19174
12:44:55,116 --> 12:44:57,840
character already construct to make it

19175
12:44:57,840 --> 12:45:01,040
easy to work with text data we will see

19176
12:45:01,040 --> 12:45:03,200
that we can use character arrays to

19177
12:45:03,200 --> 12:45:05,840
model c strings which are a facility we

19178
12:45:05,840 --> 12:45:09,680
use in c plus plus to handle text data

19179
12:45:09,680 --> 12:45:12,080
and we will see that there are a few

19180
12:45:12,080 --> 12:45:13,916
built-in facilities we can use to

19181
12:45:13,916 --> 12:45:16,080
manipulate that we can get the length of

19182
12:45:16,080 --> 12:45:18,080
a string we can concatenate strings and

19183
12:45:18,080 --> 12:45:20,480
put them together we can copy strings we

19184
12:45:20,480 --> 12:45:22,956
can search for data inside strings we

19185
12:45:22,956 --> 12:45:25,200
can do all kinds of crazy things but we

19186
12:45:25,200 --> 12:45:27,680
will see that c strings are not that

19187
12:45:27,680 --> 12:45:30,320
easy or convenient to work with for

19188
12:45:30,320 --> 12:45:32,800
example you need to keep track of how

19189
12:45:32,800 --> 12:45:35,520
big the string is in memory you need to

19190
12:45:35,520 --> 12:45:38,160
also remember to make sure it ends

19191
12:45:38,160 --> 12:45:39,916
correctly and we will see the details

19192
12:45:39,916 --> 12:45:42,320
about that in this chapter long story

19193
12:45:42,320 --> 12:45:44,800
short c strings are not safe or

19194
12:45:44,800 --> 12:45:47,360
convenient to work with in c plus plus

19195
12:45:47,360 --> 12:45:50,000
and c plus plus provide another type

19196
12:45:50,000 --> 12:45:52,640
that really builds on top of character

19197
12:45:52,640 --> 12:45:55,520
arrays but it gives us an easier

19198
12:45:55,520 --> 12:45:58,160
interface to work with and we can just

19199
12:45:58,160 --> 12:46:00,480
focus on storing in the data and doing

19200
12:46:00,480 --> 12:46:03,520
stuff with it in our c plus programs and

19201
12:46:03,520 --> 12:46:05,200
the big idea about what we're going to

19202
12:46:05,200 --> 12:46:08,000
be doing in this chapter is learn about

19203
12:46:08,000 --> 12:46:10,720
the facilities we have in c plus plus to

19204
12:46:10,720 --> 12:46:13,436
handle text data in our c plus plus

19205
12:46:13,436 --> 12:46:15,520
programs in the next lecture we're going

19206
12:46:15,520 --> 12:46:17,360
to start and show you how you can

19207
12:46:17,360 --> 12:46:18,400
manipulate

19208
12:46:18,400 --> 12:46:20,560
individual characters in a character

19209
12:46:20,560 --> 12:46:21,520
array

19210
12:46:21,520 --> 12:46:23,756
go ahead and finish up here and meet me

19211
12:46:23,756 --> 12:46:24,720
there

19212
12:46:24,720 --> 12:46:25,916
in this lecture we're going to be

19213
12:46:25,916 --> 12:46:28,240
learning about some facilities in the c

19214
12:46:28,240 --> 12:46:30,560
plus plus standard library

19215
12:46:30,560 --> 12:46:33,916
that can help us manipulate characters

19216
12:46:33,916 --> 12:46:35,916
and here are a few things you might want

19217
12:46:35,916 --> 12:46:38,320
to do with those facilities for example

19218
12:46:38,320 --> 12:46:40,880
you might want to know if a character is

19219
12:46:40,880 --> 12:46:43,596
alphanumeric or if it's a number or a

19220
12:46:43,596 --> 12:46:45,916
character you might want to know if it

19221
12:46:45,916 --> 12:46:48,160
is alphabetic you might want to know if

19222
12:46:48,160 --> 12:46:50,560
it's a blank character you might want to

19223
12:46:50,560 --> 12:46:52,640
know if it's a lowercase or uppercase

19224
12:46:52,640 --> 12:46:54,400
character depending on what you want to

19225
12:46:54,400 --> 12:46:56,800
do in your application of course there

19226
12:46:56,800 --> 12:46:58,800
are facilities to check if characters

19227
12:46:58,800 --> 12:47:01,840
are digits there are even those that

19228
12:47:01,840 --> 12:47:04,160
help us you know transform characters

19229
12:47:04,160 --> 12:47:06,480
make them lowercase or uppercase and

19230
12:47:06,480 --> 12:47:07,840
we're going to see

19231
12:47:07,840 --> 12:47:10,000
these examples here all of these are

19232
12:47:10,000 --> 12:47:11,880
documented at

19233
12:47:11,880 --> 12:47:14,240
cppreference.com so you can go there and

19234
12:47:14,240 --> 12:47:17,116
find the documentation here is the same

19235
12:47:17,116 --> 12:47:19,840
link opened in my browser you see that

19236
12:47:19,840 --> 12:47:23,360
they leave in the cc type library so you

19237
12:47:23,360 --> 12:47:25,276
need this included if you want to use

19238
12:47:25,276 --> 12:47:27,756
them and you see that there is quite a

19239
12:47:27,756 --> 12:47:30,160
bunch of them we are going to cover just

19240
12:47:30,160 --> 12:47:32,560
a section of them and i will leave you

19241
12:47:32,560 --> 12:47:34,880
to use the documentation if you need to

19242
12:47:34,880 --> 12:47:37,276
use any more of these guys our first

19243
12:47:37,276 --> 12:47:39,360
example here is going to help us check

19244
12:47:39,360 --> 12:47:42,400
if a character is alpha numeric and the

19245
12:47:42,400 --> 12:47:44,080
function we're going to use from the c

19246
12:47:44,080 --> 12:47:48,160
plus plus standard library is std is l

19247
12:47:48,160 --> 12:47:48,956
num

19248
12:47:48,956 --> 12:47:51,840
and you just pass it a parameter of a

19249
12:47:51,840 --> 12:47:54,400
character and it's going to tell you if

19250
12:47:54,400 --> 12:47:57,276
a character is either alphanumeric or if

19251
12:47:57,276 --> 12:47:59,200
it's not if it is alphanumeric you're

19252
12:47:59,200 --> 12:48:00,880
going to get a value that is different

19253
12:48:00,880 --> 12:48:02,956
from zero which can be treated like a

19254
12:48:02,956 --> 12:48:04,956
true if it's not you're going to get a

19255
12:48:04,956 --> 12:48:07,276
value that you can treat like a zero and

19256
12:48:07,276 --> 12:48:09,756
how do i know this well we can check the

19257
12:48:09,756 --> 12:48:12,560
documentation so if i come back to our

19258
12:48:12,560 --> 12:48:13,840
link here

19259
12:48:13,840 --> 12:48:16,640
and there is a function here is i'll num

19260
12:48:16,640 --> 12:48:19,680
i can open it in another tab and it is

19261
12:48:19,680 --> 12:48:21,520
going to tell me what this function does

19262
12:48:21,520 --> 12:48:23,596
checks if the given character that you

19263
12:48:23,596 --> 12:48:26,276
pass as a parameter here is an

19264
12:48:26,276 --> 12:48:29,040
alphanumeric character as classified by

19265
12:48:29,040 --> 12:48:30,880
the current siluca

19266
12:48:30,880 --> 12:48:31,756
so

19267
12:48:31,756 --> 12:48:34,000
it's going to tell us if the character

19268
12:48:34,000 --> 12:48:34,956
is

19269
12:48:34,956 --> 12:48:37,360
alphanumeric or not you give it a

19270
12:48:37,360 --> 12:48:40,160
character and what you get from it is

19271
12:48:40,160 --> 12:48:42,160
the return value here it's going to

19272
12:48:42,160 --> 12:48:44,800
return a non-zero value if the character

19273
12:48:44,800 --> 12:48:47,916
is alpha numeric so this non-zero value

19274
12:48:47,916 --> 12:48:49,756
which is an integer because that's what

19275
12:48:49,756 --> 12:48:51,840
we get out of this function is going to

19276
12:48:51,840 --> 12:48:53,840
be treated like a true

19277
12:48:53,840 --> 12:48:56,160
and if this character here is not alpha

19278
12:48:56,160 --> 12:48:58,640
numeric we're going to get zero that we

19279
12:48:58,640 --> 12:49:00,480
can treat like a false this is really

19280
12:49:00,480 --> 12:49:01,916
cool and if you go down here you're

19281
12:49:01,916 --> 12:49:03,840
going to find a few examples i don't

19282
12:49:03,840 --> 12:49:06,000
want you to worry about this c local

19283
12:49:06,000 --> 12:49:06,880
thing

19284
12:49:06,880 --> 12:49:08,560
it is a

19285
12:49:08,560 --> 12:49:10,956
setting that allows you to

19286
12:49:10,956 --> 12:49:12,800
say more about the meaning of the

19287
12:49:12,800 --> 12:49:14,480
characters that you are storing in

19288
12:49:14,480 --> 12:49:16,240
memory but for now we're just going to

19289
12:49:16,240 --> 12:49:18,956
be happy with the defaults and use this

19290
12:49:18,956 --> 12:49:21,200
function as is it is going to work

19291
12:49:21,200 --> 12:49:23,596
enough well okay here is our function

19292
12:49:23,596 --> 12:49:26,640
again so here c is alphanumeric we

19293
12:49:26,640 --> 12:49:28,720
expect to get a value

19294
12:49:28,720 --> 12:49:30,720
different from zero because c is

19295
12:49:30,720 --> 12:49:33,116
alphanumeric and the second example here

19296
12:49:33,116 --> 12:49:35,756
is not alphanumeric so we expect to get

19297
12:49:35,756 --> 12:49:38,400
a value that is equal to zero and we can

19298
12:49:38,400 --> 12:49:40,720
use the return of this function

19299
12:49:40,720 --> 12:49:42,880
in a test for example we can say a

19300
12:49:42,880 --> 12:49:44,720
character we put in a star here it is

19301
12:49:44,720 --> 12:49:48,720
called input car and we say f is al num

19302
12:49:48,720 --> 12:49:50,800
and we pass this character we're going

19303
12:49:50,800 --> 12:49:52,800
to print out this character is alpha

19304
12:49:52,800 --> 12:49:54,956
numeric if it's not we're going to print

19305
12:49:54,956 --> 12:49:57,200
is not alpha numeric you can do that and

19306
12:49:57,200 --> 12:49:59,680
you can do all kinds of crazy tests in

19307
12:49:59,680 --> 12:50:02,400
your c plus plus applications here is

19308
12:50:02,400 --> 12:50:04,720
another example that we can use to know

19309
12:50:04,720 --> 12:50:08,400
if the character is alphabetic so it's

19310
12:50:08,400 --> 12:50:11,040
going to return a value different from

19311
12:50:11,040 --> 12:50:14,160
zero if the character is a an alphabet

19312
12:50:14,160 --> 12:50:16,956
character a through z that's going to

19313
12:50:16,956 --> 12:50:19,520
return something different from zero and

19314
12:50:19,520 --> 12:50:21,520
if we pass something that is not for

19315
12:50:21,520 --> 12:50:22,720
example

19316
12:50:22,720 --> 12:50:25,436
this second line here or the seven at

19317
12:50:25,436 --> 12:50:27,596
the third line here we're going to get a

19318
12:50:27,596 --> 12:50:29,916
value equal to zero because that's not

19319
12:50:29,916 --> 12:50:32,160
alphabetic we have another facility to

19320
12:50:32,160 --> 12:50:34,720
help check if a character is a black

19321
12:50:34,720 --> 12:50:37,040
character and we see an example that

19322
12:50:37,040 --> 12:50:39,040
here we have a character array called

19323
12:50:39,040 --> 12:50:41,116
message we have a couple of blanks

19324
12:50:41,116 --> 12:50:44,560
inside and we can hunt for them using

19325
12:50:44,560 --> 12:50:47,596
the ease blank facility from the c plus

19326
12:50:47,596 --> 12:50:49,680
plus standard library here we have a

19327
12:50:49,680 --> 12:50:51,756
variable that is going to keep track of

19328
12:50:51,756 --> 12:50:54,640
how many black characters are in here it

19329
12:50:54,640 --> 12:50:56,240
is initialized to zero and we're going

19330
12:50:56,240 --> 12:50:58,640
to loop around okay and we're going to

19331
12:50:58,640 --> 12:51:02,400
look by the amount equal to the size of

19332
12:51:02,400 --> 12:51:04,720
the message array here we can use std

19333
12:51:04,720 --> 12:51:07,200
size again because this is a row array

19334
12:51:07,200 --> 12:51:09,916
it is a static array and we can use sdd

19335
12:51:09,916 --> 12:51:11,756
size it is going to give us how many

19336
12:51:11,756 --> 12:51:13,916
characters we have in this array you

19337
12:51:13,916 --> 12:51:16,320
already know this and if we get inside

19338
12:51:16,320 --> 12:51:19,040
we are going to try and check and see if

19339
12:51:19,040 --> 12:51:20,800
the current character

19340
12:51:20,800 --> 12:51:23,520
is a blank if it is we're going to print

19341
12:51:23,520 --> 12:51:26,320
that out and we're going to increment

19342
12:51:26,320 --> 12:51:29,840
our blank account by the time this loop

19343
12:51:29,840 --> 12:51:32,240
is done we will have printed out a lot

19344
12:51:32,240 --> 12:51:34,880
of blank characters if we happen to

19345
12:51:34,880 --> 12:51:37,596
have them in our message and at the end

19346
12:51:37,596 --> 12:51:39,436
we're going to say in total we found

19347
12:51:39,436 --> 12:51:41,680
however many blank characters this is

19348
12:51:41,680 --> 12:51:43,040
what we're going to see

19349
12:51:43,040 --> 12:51:45,360
if we run this program and hopefully you

19350
12:51:45,360 --> 12:51:47,116
can see how useful

19351
12:51:47,116 --> 12:51:49,276
this can be in text processing

19352
12:51:49,276 --> 12:51:52,240
applications if that happens to be what

19353
12:51:52,240 --> 12:51:54,320
you are working on we're going to run

19354
12:51:54,320 --> 12:51:56,480
this example in visual studio code in a

19355
12:51:56,480 --> 12:51:58,480
minute here is another example that we

19356
12:51:58,480 --> 12:52:00,400
can use to check if a character is

19357
12:52:00,400 --> 12:52:02,320
uppercase or

19358
12:52:02,320 --> 12:52:04,956
lowercase we have an array of characters

19359
12:52:04,956 --> 12:52:07,596
here inside we have some text

19360
12:52:07,596 --> 12:52:10,240
and we have a few variables to keep

19361
12:52:10,240 --> 12:52:12,956
track of how many characters are

19362
12:52:12,956 --> 12:52:15,680
lowercase or uppercase we're going to

19363
12:52:15,680 --> 12:52:17,596
set up a loop which is going to be a

19364
12:52:17,596 --> 12:52:20,400
range based for loop and we know that

19365
12:52:20,400 --> 12:52:22,956
through std is lower

19366
12:52:22,956 --> 12:52:25,276
we're going to increment the lowercase

19367
12:52:25,276 --> 12:52:27,276
count if it is uppercase we're going to

19368
12:52:27,276 --> 12:52:29,040
increment the uppercase count this is

19369
12:52:29,040 --> 12:52:30,640
how we can do this

19370
12:52:30,640 --> 12:52:32,880
and we are going to print that

19371
12:52:32,880 --> 12:52:35,116
information when the loop here is done

19372
12:52:35,116 --> 12:52:37,436
okay we still have a few examples ahead

19373
12:52:37,436 --> 12:52:38,956
the current one is going to check if a

19374
12:52:38,956 --> 12:52:40,800
character is a digit if you want to do

19375
12:52:40,800 --> 12:52:43,276
that you can use this and we have a

19376
12:52:43,276 --> 12:52:45,520
character array here and we're going to

19377
12:52:45,520 --> 12:52:49,520
have for digits inside this message here

19378
12:52:49,520 --> 12:52:51,596
so we're going to do basically the same

19379
12:52:51,596 --> 12:52:53,520
thing we're going to set up a variable

19380
12:52:53,520 --> 12:52:56,400
that is going to keep track of how many

19381
12:52:56,400 --> 12:52:59,116
digits we have in this message we are

19382
12:52:59,116 --> 12:53:01,276
going to loop around using a range based

19383
12:53:01,276 --> 12:53:03,596
for loop we're going to check if the

19384
12:53:03,596 --> 12:53:05,680
current character is a digit and we're

19385
12:53:05,680 --> 12:53:06,880
going to

19386
12:53:06,880 --> 12:53:08,480
increment

19387
12:53:08,480 --> 12:53:10,640
our variable here if it happens to be

19388
12:53:10,640 --> 12:53:12,880
the case and at the end we're going to

19389
12:53:12,880 --> 12:53:16,080
say how many digits we found in our

19390
12:53:16,080 --> 12:53:18,640
message here it is this simple the last

19391
12:53:18,640 --> 12:53:20,640
example we're going to look at is to

19392
12:53:20,640 --> 12:53:23,840
help us turn a character into lowercase

19393
12:53:23,840 --> 12:53:26,320
or uppercase and here is an example that

19394
12:53:26,320 --> 12:53:28,880
is going to help us play with us we're

19395
12:53:28,880 --> 12:53:30,480
going to have a

19396
12:53:30,480 --> 12:53:33,040
character array called home the feeling

19397
12:53:33,040 --> 12:53:35,276
of belonging and we will set up a

19398
12:53:35,276 --> 12:53:38,080
destination character array

19399
12:53:38,080 --> 12:53:40,160
that we're going to store whatever we

19400
12:53:40,160 --> 12:53:41,916
want to set up in

19401
12:53:41,916 --> 12:53:43,436
here you see a loop that is going to

19402
12:53:43,436 --> 12:53:47,116
turn our message here into uppercase

19403
12:53:47,116 --> 12:53:49,596
and you see we're going to loop around

19404
12:53:49,596 --> 12:53:52,000
by this amount the size of original

19405
12:53:52,000 --> 12:53:52,956
strength

19406
12:53:52,956 --> 12:53:55,360
and we're going to be grabbing each

19407
12:53:55,360 --> 12:53:57,916
character at each iteration

19408
12:53:57,916 --> 12:54:00,720
and turning that to uppercase this is

19409
12:54:00,720 --> 12:54:04,080
what std to upper function does the

19410
12:54:04,080 --> 12:54:06,640
result of that is going to be stored in

19411
12:54:06,640 --> 12:54:09,200
our destination string and by the time

19412
12:54:09,200 --> 12:54:11,520
we are done here original string is

19413
12:54:11,520 --> 12:54:14,400
going to be however it was but uppercase

19414
12:54:14,400 --> 12:54:16,956
string is going to be stored in our

19415
12:54:16,956 --> 12:54:19,360
destination array and if we print it out

19416
12:54:19,360 --> 12:54:21,840
we should see this thing printed in

19417
12:54:21,840 --> 12:54:24,240
uppercase we can basically do the same

19418
12:54:24,240 --> 12:54:27,520
thing and turn the string into lowercase

19419
12:54:27,520 --> 12:54:29,680
and our destination string is going to

19420
12:54:29,680 --> 12:54:31,596
be now lowercase and you're going to see

19421
12:54:31,596 --> 12:54:34,000
that this works out pretty well

19422
12:54:34,000 --> 12:54:36,956
now that you have a basic understanding

19423
12:54:36,956 --> 12:54:39,116
about how these things work we're going

19424
12:54:39,116 --> 12:54:41,520
to head over to vg studio code and play

19425
12:54:41,520 --> 12:54:44,480
with us okay here we are in our working

19426
12:54:44,480 --> 12:54:46,240
directory the current project is

19427
12:54:46,240 --> 12:54:48,320
character manipulation

19428
12:54:48,320 --> 12:54:50,800
we are going to grab our template files

19429
12:54:50,800 --> 12:54:53,040
like we always do and we're going to put

19430
12:54:53,040 --> 12:54:55,200
this in place and we're going to open

19431
12:54:55,200 --> 12:54:57,840
this in visual studio code pretty quick

19432
12:54:57,840 --> 12:54:59,840
and we are going to go down and put in

19433
12:54:59,840 --> 12:55:02,160
our first example this example is going

19434
12:55:02,160 --> 12:55:06,240
to be using the std is al num facility

19435
12:55:06,240 --> 12:55:08,160
and this is going to be checking if the

19436
12:55:08,160 --> 12:55:10,000
character is alpha numeric we're going

19437
12:55:10,000 --> 12:55:12,240
to see what we get from this if we print

19438
12:55:12,240 --> 12:55:14,800
this out we're going to check if c the

19439
12:55:14,800 --> 12:55:17,040
character c is alphanumeric we're going

19440
12:55:17,040 --> 12:55:18,880
to see what we get and we're going to

19441
12:55:18,880 --> 12:55:21,276
check if this character here i don't

19442
12:55:21,276 --> 12:55:23,756
know how to pronounce it i'm sorry

19443
12:55:23,756 --> 12:55:25,596
we're going to check if it is

19444
12:55:25,596 --> 12:55:27,596
alpha numeric we're going to see that

19445
12:55:27,596 --> 12:55:29,680
and we're going to use this in at

19446
12:55:29,680 --> 12:55:31,680
condition we're going to check and see

19447
12:55:31,680 --> 12:55:34,000
if our star character here is

19448
12:55:34,000 --> 12:55:35,756
alphanumeric and we're going to print

19449
12:55:35,756 --> 12:55:37,436
that out we're going to say it is alpha

19450
12:55:37,436 --> 12:55:39,520
numeric or it is not from the

19451
12:55:39,520 --> 12:55:41,756
documentation we know that this thing

19452
12:55:41,756 --> 12:55:44,240
lives in the cctype

19453
12:55:44,240 --> 12:55:46,720
library so we may want to include that

19454
12:55:46,720 --> 12:55:49,116
but it is possible that it is coming

19455
12:55:49,116 --> 12:55:51,520
from iostream here that's why we don't

19456
12:55:51,520 --> 12:55:52,640
see

19457
12:55:52,640 --> 12:55:54,640
visual studio code complaining here as

19458
12:55:54,640 --> 12:55:56,880
an example if we try and comment out

19459
12:55:56,880 --> 12:55:58,480
this include here

19460
12:55:58,480 --> 12:56:00,560
you're going to see that

19461
12:56:00,560 --> 12:56:02,880
this is not going to make sense anymore

19462
12:56:02,880 --> 12:56:06,000
okay so the include needed to use these

19463
12:56:06,000 --> 12:56:09,360
guys here is coming from io stream okay

19464
12:56:09,360 --> 12:56:11,840
so we're not going to include that here

19465
12:56:11,840 --> 12:56:15,756
we are going to open up a terminal

19466
12:56:15,756 --> 12:56:18,800
and build this with gcc and you're going

19467
12:56:18,800 --> 12:56:20,720
to see that the block is good if we go

19468
12:56:20,720 --> 12:56:23,756
down and clear let's clear properly and

19469
12:56:23,756 --> 12:56:26,240
run rooster we're going to see that c is

19470
12:56:26,240 --> 12:56:28,640
alphanumeric because we have a one the

19471
12:56:28,640 --> 12:56:30,956
one can be treated like a true and the

19472
12:56:30,956 --> 12:56:33,040
character here is not alphanumeric

19473
12:56:33,040 --> 12:56:35,680
because the result is zero

19474
12:56:35,680 --> 12:56:37,840
and you see that the star here is also

19475
12:56:37,840 --> 12:56:40,480
not alpha numeric and we know this

19476
12:56:40,480 --> 12:56:42,800
through our test here and you see that

19477
12:56:42,800 --> 12:56:44,956
we can do things like this

19478
12:56:44,956 --> 12:56:47,756
with this facility here if you want to

19479
12:56:47,756 --> 12:56:50,640
get true or false from this function you

19480
12:56:50,640 --> 12:56:53,680
can turn this into booleans using static

19481
12:56:53,680 --> 12:56:55,756
cast but we're not going to do that here

19482
12:56:55,756 --> 12:56:58,240
you already know that we can comment

19483
12:56:58,240 --> 12:57:00,320
this out for now and look at another

19484
12:57:00,320 --> 12:57:02,560
facility from the

19485
12:57:02,560 --> 12:57:05,436
cctype library there are many of these

19486
12:57:05,436 --> 12:57:07,116
we're going to look at quite a few of

19487
12:57:07,116 --> 12:57:09,520
them we're going to comment this out and

19488
12:57:09,520 --> 12:57:12,400
go down and put in a code here and this

19489
12:57:12,400 --> 12:57:14,560
is going to check if a character is

19490
12:57:14,560 --> 12:57:17,040
alphabetic so if it is an alphabet

19491
12:57:17,040 --> 12:57:18,080
character

19492
12:57:18,080 --> 12:57:21,116
a from z lowercase and uppercase

19493
12:57:21,116 --> 12:57:23,680
c is alphabetic the character here is

19494
12:57:23,680 --> 12:57:26,400
not alphabetic and seven here is not

19495
12:57:26,400 --> 12:57:29,436
alphabetic so for the first one here

19496
12:57:29,436 --> 12:57:31,680
we're going to get something

19497
12:57:31,680 --> 12:57:34,720
not equal to zero we should get a one

19498
12:57:34,720 --> 12:57:37,840
that's what they use in most cases for

19499
12:57:37,840 --> 12:57:39,360
this we're going to get a zero the

19500
12:57:39,360 --> 12:57:41,276
second one and for the third one we're

19501
12:57:41,276 --> 12:57:43,596
going to also get a zero this is what we

19502
12:57:43,596 --> 12:57:44,640
expect

19503
12:57:44,640 --> 12:57:47,756
we are going to build with gcc of course

19504
12:57:47,756 --> 12:57:50,240
and we are going to clear and run

19505
12:57:50,240 --> 12:57:51,436
rooster

19506
12:57:51,436 --> 12:57:53,596
and we're going to get that c is

19507
12:57:53,596 --> 12:57:56,720
alphabetic this guy is not alphabetic

19508
12:57:56,720 --> 12:57:59,596
and seven is not alphabetic if we change

19509
12:57:59,596 --> 12:58:01,680
this c to uh

19510
12:58:01,680 --> 12:58:03,840
e for example lowercase

19511
12:58:03,840 --> 12:58:05,520
and both again you're going to see that

19512
12:58:05,520 --> 12:58:07,116
the results are going to be what we

19513
12:58:07,116 --> 12:58:09,680
expect e is alphabetic

19514
12:58:09,680 --> 12:58:12,240
let's clear and run rooster this is

19515
12:58:12,240 --> 12:58:14,400
going to be exactly what we expect but

19516
12:58:14,400 --> 12:58:16,800
you see that it is not a one and this is

19517
12:58:16,800 --> 12:58:19,596
not guaranteed to always give you a one

19518
12:58:19,596 --> 12:58:21,756
it is guaranteed to give you something

19519
12:58:21,756 --> 12:58:24,400
different from zero if the character is

19520
12:58:24,400 --> 12:58:27,916
alphabetic and zero if not and we can

19521
12:58:27,916 --> 12:58:30,160
use this guy here in a test

19522
12:58:30,160 --> 12:58:31,596
for example

19523
12:58:31,596 --> 12:58:35,596
we can say f sdd is alpha and if we're

19524
12:58:35,596 --> 12:58:37,840
boiled the both is going to be good and

19525
12:58:37,840 --> 12:58:40,080
we're going to clear and run rooster and

19526
12:58:40,080 --> 12:58:42,880
you see e is alphabetic i should put a

19527
12:58:42,880 --> 12:58:45,276
space here i do encourage you to change

19528
12:58:45,276 --> 12:58:47,360
these characters up and see what you get

19529
12:58:47,360 --> 12:58:49,436
here and see how you can use this that's

19530
12:58:49,436 --> 12:58:52,320
in tests that's the best way to learn

19531
12:58:52,320 --> 12:58:54,240
okay before we continue i do encourage

19532
12:58:54,240 --> 12:58:56,720
you to try and run these methods through

19533
12:58:56,720 --> 12:58:58,956
different compilers for example here we

19534
12:58:58,956 --> 12:59:01,916
also have an msvc compiler from

19535
12:59:01,916 --> 12:59:04,240
microsoft setup so we can use that and

19536
12:59:04,240 --> 12:59:06,800
try to build this thing here but before

19537
12:59:06,800 --> 12:59:09,916
we do that let's bring up our pen here

19538
12:59:09,916 --> 12:59:11,400
and remove

19539
12:59:11,400 --> 12:59:14,240
rooster.exe here because

19540
12:59:14,240 --> 12:59:16,956
we don't want to override it we're going

19541
12:59:16,956 --> 12:59:19,756
to select it and do delete

19542
12:59:19,756 --> 12:59:22,240
and i am going to remove this and move

19543
12:59:22,240 --> 12:59:24,480
that to the recycle bin

19544
12:59:24,480 --> 12:59:26,640
and i am going to clear whatever i have

19545
12:59:26,640 --> 12:59:28,560
here on the terminal

19546
12:59:28,560 --> 12:59:30,956
and i am going to go there i am going to

19547
12:59:30,956 --> 12:59:32,640
choose run task

19548
12:59:32,640 --> 12:59:35,596
and i am going to choose world with msvc

19549
12:59:35,596 --> 12:59:37,040
here

19550
12:59:37,040 --> 12:59:39,200
i am going to use that it is going to

19551
12:59:39,200 --> 12:59:41,520
build my thang you see the output here

19552
12:59:41,520 --> 12:59:44,480
and we have rooster.exe here

19553
12:59:44,480 --> 12:59:46,800
and it should say that the world is good

19554
12:59:46,800 --> 12:59:49,680
in a minute world finished successfully

19555
12:59:49,680 --> 12:59:51,520
microsoft is going to give us a lot of

19556
12:59:51,520 --> 12:59:54,400
output here but no problem the build is

19557
12:59:54,400 --> 12:59:55,200
good

19558
12:59:55,200 --> 12:59:56,880
if we go in

19559
12:59:56,880 --> 12:59:58,880
we can actually check

19560
12:59:58,880 --> 13:00:01,200
and see what we have

19561
13:00:01,200 --> 13:00:02,640
in our folder here you're going to see

19562
13:00:02,640 --> 13:00:05,200
that we have these files one of them is

19563
13:00:05,200 --> 13:00:07,436
rooster.exe

19564
13:00:07,436 --> 13:00:10,000
if we run it we are going to get the

19565
13:00:10,000 --> 13:00:11,840
outputs that we expect and you see that

19566
13:00:11,840 --> 13:00:14,400
it is exactly the same thing we got

19567
13:00:14,400 --> 13:00:16,400
with gcc

19568
13:00:16,400 --> 13:00:17,840
i am telling you to try and use

19569
13:00:17,840 --> 13:00:19,756
different compilers because some

19570
13:00:19,756 --> 13:00:23,116
compilers are going to flat some of the

19571
13:00:23,116 --> 13:00:25,756
facilities from cctype

19572
13:00:25,756 --> 13:00:29,276
or those that start with c as unsafe

19573
13:00:29,276 --> 13:00:31,200
because there are some tanks that can

19574
13:00:31,200 --> 13:00:33,200
really throw you off about them and

19575
13:00:33,200 --> 13:00:34,800
we're going to learn about them in this

19576
13:00:34,800 --> 13:00:37,040
chapter as we move forward just know

19577
13:00:37,040 --> 13:00:38,800
that it is a good idea to try these

19578
13:00:38,800 --> 13:00:41,276
things on different compilers and see

19579
13:00:41,276 --> 13:00:43,200
the errors you get and make yourself

19580
13:00:43,200 --> 13:00:45,596
familiar with those things

19581
13:00:45,596 --> 13:00:47,200
for now we're going to move on and we

19582
13:00:47,200 --> 13:00:48,880
are going to keep using

19583
13:00:48,880 --> 13:00:51,840
gcc because that's my favorite compiler

19584
13:00:51,840 --> 13:00:53,680
you can use whatever compiler you want

19585
13:00:53,680 --> 13:00:55,436
the next example is going to check if

19586
13:00:55,436 --> 13:00:58,000
the character is blank let's close this

19587
13:00:58,000 --> 13:00:58,880
thing

19588
13:00:58,880 --> 13:01:00,720
and clear

19589
13:01:00,720 --> 13:01:03,756
and give ourselves some breathing room

19590
13:01:03,756 --> 13:01:05,276
we're going to bring this down a little

19591
13:01:05,276 --> 13:01:06,800
bit and we're going to check if the

19592
13:01:06,800 --> 13:01:09,116
character is blank the facility for that

19593
13:01:09,116 --> 13:01:11,596
is std is blank

19594
13:01:11,596 --> 13:01:13,360
and if it's a blank character we're

19595
13:01:13,360 --> 13:01:15,040
going to get something different than

19596
13:01:15,040 --> 13:01:17,276
zero and we can use that in a test like

19597
13:01:17,276 --> 13:01:19,436
this and if it's not a black we're going

19598
13:01:19,436 --> 13:01:21,840
to get something equal to zero and this

19599
13:01:21,840 --> 13:01:24,000
test here is going to fail so what this

19600
13:01:24,000 --> 13:01:25,360
example here is going to do it's going

19601
13:01:25,360 --> 13:01:27,436
to count how many blank characters we

19602
13:01:27,436 --> 13:01:28,880
have in this

19603
13:01:28,880 --> 13:01:31,200
message here and we're going to print

19604
13:01:31,200 --> 13:01:33,040
the counter of that on the console using

19605
13:01:33,040 --> 13:01:34,956
this line here so let's go through this

19606
13:01:34,956 --> 13:01:36,400
loop and see what it does the first

19607
13:01:36,400 --> 13:01:39,436
thing we do is initialize blank count to

19608
13:01:39,436 --> 13:01:41,756
0 and we are using an integer and

19609
13:01:41,756 --> 13:01:44,560
because this is a count i think blank

19610
13:01:44,560 --> 13:01:47,200
count is of wrong type because it can be

19611
13:01:47,200 --> 13:01:50,320
negative so to really be safe in our

19612
13:01:50,320 --> 13:01:52,000
program here we should make this

19613
13:01:52,000 --> 13:01:54,800
unsigned or even use size t

19614
13:01:54,800 --> 13:01:58,080
this is better okay so let's use size

19615
13:01:58,080 --> 13:01:59,040
t

19616
13:01:59,040 --> 13:02:01,916
because this is a size and size t is a

19617
13:02:01,916 --> 13:02:04,956
good type to keep track of sizes in your

19618
13:02:04,956 --> 13:02:07,520
c plus plus programs so make sure you

19619
13:02:07,520 --> 13:02:09,360
size t here

19620
13:02:09,360 --> 13:02:11,436
and what we're going to do

19621
13:02:11,436 --> 13:02:13,520
is go in the loop at each iteration

19622
13:02:13,520 --> 13:02:15,756
we're going to check if each character

19623
13:02:15,756 --> 13:02:17,680
at each iteration is a blank if it is

19624
13:02:17,680 --> 13:02:19,756
we're going to fall in here and say that

19625
13:02:19,756 --> 13:02:22,956
we found a blank character at this index

19626
13:02:22,956 --> 13:02:24,880
in our array here

19627
13:02:24,880 --> 13:02:26,800
and we're going to increment our blank

19628
13:02:26,800 --> 13:02:28,956
account and by the time this loop is

19629
13:02:28,956 --> 13:02:30,720
done we're going to have the blank

19630
13:02:30,720 --> 13:02:32,800
account stored in this blank account

19631
13:02:32,800 --> 13:02:34,640
variable and we're going to print that

19632
13:02:34,640 --> 13:02:36,400
out it is this simple

19633
13:02:36,400 --> 13:02:39,840
now we can build with gcc let's do that

19634
13:02:39,840 --> 13:02:42,400
we're going to world with our gcc

19635
13:02:42,400 --> 13:02:43,840
compiler

19636
13:02:43,840 --> 13:02:45,916
and the world is going to be good can

19637
13:02:45,916 --> 13:02:47,200
clear

19638
13:02:47,200 --> 13:02:48,800
and run rooster

19639
13:02:48,800 --> 13:02:50,880
and you're going to see that

19640
13:02:50,880 --> 13:02:52,800
it's going to say we found a blank

19641
13:02:52,800 --> 13:02:54,956
character at index 5

19642
13:02:54,956 --> 13:02:59,596
12 20 24 31 35 39 and 42

19643
13:02:59,596 --> 13:03:01,840
and in total we have found nine blank

19644
13:03:01,840 --> 13:03:04,400
characters do we have that many let's

19645
13:03:04,400 --> 13:03:08,240
count so one one blank character

19646
13:03:08,240 --> 13:03:11,040
we have two here we have three we have

19647
13:03:11,040 --> 13:03:12,000
four

19648
13:03:12,000 --> 13:03:13,596
we have five

19649
13:03:13,596 --> 13:03:14,640
here

19650
13:03:14,640 --> 13:03:16,320
we have six

19651
13:03:16,320 --> 13:03:17,200
seven

19652
13:03:17,200 --> 13:03:18,956
eight and nine if you count you're going

19653
13:03:18,956 --> 13:03:21,040
to find that we have them and the first

19654
13:03:21,040 --> 13:03:25,040
one is at index five so index zero is h

19655
13:03:25,040 --> 13:03:27,596
one two three four the first one is at

19656
13:03:27,596 --> 13:03:30,400
index five and this is doing exactly

19657
13:03:30,400 --> 13:03:33,040
what we want we can go down and check if

19658
13:03:33,040 --> 13:03:36,320
a character is uppercase or lowercase we

19659
13:03:36,320 --> 13:03:39,436
can do that through an example like this

19660
13:03:39,436 --> 13:03:41,756
and the facility is going to be std

19661
13:03:41,756 --> 13:03:44,880
lower and std is upper we have a message

19662
13:03:44,880 --> 13:03:46,160
here

19663
13:03:46,160 --> 13:03:48,080
we're going to loop around using a range

19664
13:03:48,080 --> 13:03:50,000
based for loop and we're going to check

19665
13:03:50,000 --> 13:03:52,720
if each character is either lowercase or

19666
13:03:52,720 --> 13:03:53,916
uppercase

19667
13:03:53,916 --> 13:03:55,916
and if the test is good we're going to

19668
13:03:55,916 --> 13:03:57,596
jump in the loop and we're going to

19669
13:03:57,596 --> 13:04:00,080
increment lowercase count which are a

19670
13:04:00,080 --> 13:04:03,116
few variables to keep track of how many

19671
13:04:03,116 --> 13:04:05,040
uppercase and lowercase characters we

19672
13:04:05,040 --> 13:04:07,436
have in here and again these variables

19673
13:04:07,436 --> 13:04:09,436
are going to store counts so it is

19674
13:04:09,436 --> 13:04:10,560
better

19675
13:04:10,560 --> 13:04:13,840
to use a size t or some unsigned integer

19676
13:04:13,840 --> 13:04:16,080
type but now we're going to use size t

19677
13:04:16,080 --> 13:04:18,480
because it is good so we're going to

19678
13:04:18,480 --> 13:04:20,320
keep this stored in here and we're going

19679
13:04:20,320 --> 13:04:22,480
to build this and see what we get

19680
13:04:22,480 --> 13:04:26,000
before we run we want to clear

19681
13:04:26,000 --> 13:04:29,680
and we are going to build with gcc

19682
13:04:29,680 --> 13:04:31,840
the bolt is going to be good we're going

19683
13:04:31,840 --> 13:04:34,080
to clear and run rooster

19684
13:04:34,080 --> 13:04:36,800
and you see that the original strand is

19685
13:04:36,800 --> 13:04:38,720
this guy here what we're going to do

19686
13:04:38,720 --> 13:04:40,400
we're going to print whatever character

19687
13:04:40,400 --> 13:04:42,640
we are at i'm going to put a space in

19688
13:04:42,640 --> 13:04:45,360
front of that and we're going to see

19689
13:04:45,360 --> 13:04:48,400
increment this is the output why do we

19690
13:04:48,400 --> 13:04:50,640
have this method here because we are

19691
13:04:50,640 --> 13:04:52,400
printing out

19692
13:04:52,400 --> 13:04:55,116
each character and we are not printing

19693
13:04:55,116 --> 13:04:57,596
the upper case ones we are printing

19694
13:04:57,596 --> 13:05:00,400
lowercase ones that's why you see

19695
13:05:00,400 --> 13:05:02,400
this guy here this is really interesting

19696
13:05:02,400 --> 13:05:04,640
you can keep this in if you want i am

19697
13:05:04,640 --> 13:05:06,800
going to keep this on the important

19698
13:05:06,800 --> 13:05:09,436
message is that we found lowercase

19699
13:05:09,436 --> 13:05:11,756
characters and uppercase characters and

19700
13:05:11,756 --> 13:05:14,240
we have five uppercase characters if we

19701
13:05:14,240 --> 13:05:16,080
go in and count we're going to find that

19702
13:05:16,080 --> 13:05:18,240
we have t here one

19703
13:05:18,240 --> 13:05:22,160
two and three and four and five five

19704
13:05:22,160 --> 13:05:24,320
uppercase characters and if you count

19705
13:05:24,320 --> 13:05:26,720
the lowercase characters one by one i am

19706
13:05:26,720 --> 13:05:29,360
sure that you're going to get a 47 like

19707
13:05:29,360 --> 13:05:30,800
we did here we're going to comment this

19708
13:05:30,800 --> 13:05:33,360
out because this was just an example

19709
13:05:33,360 --> 13:05:35,596
i am leaving this in here so that you

19710
13:05:35,596 --> 13:05:37,756
can use this as a reference if you want

19711
13:05:37,756 --> 13:05:40,240
we can also check if a character is a

19712
13:05:40,240 --> 13:05:41,916
digit

19713
13:05:41,916 --> 13:05:44,956
and we're going to use std is digit to

19714
13:05:44,956 --> 13:05:46,720
check that the return type is going to

19715
13:05:46,720 --> 13:05:48,560
be different from zero

19716
13:05:48,560 --> 13:05:51,116
if the test succeeds if it fails we're

19717
13:05:51,116 --> 13:05:52,880
going to get a zero and we can use that

19718
13:05:52,880 --> 13:05:55,916
like this so we have a message here

19719
13:05:55,916 --> 13:05:58,800
stored in the character array called

19720
13:05:58,800 --> 13:06:00,000
statement

19721
13:06:00,000 --> 13:06:02,160
and we're going to loop around checking

19722
13:06:02,160 --> 13:06:04,800
if each character we are at is actually

19723
13:06:04,800 --> 13:06:06,720
a digit or not if it's a digit we're

19724
13:06:06,720 --> 13:06:08,320
going to say found a digit i'm going to

19725
13:06:08,320 --> 13:06:10,160
say whatever digit we found and we're

19726
13:06:10,160 --> 13:06:12,400
going to increment the digits count and

19727
13:06:12,400 --> 13:06:14,320
we're going to store that information in

19728
13:06:14,320 --> 13:06:17,276
this digit count variable here we don't

19729
13:06:17,276 --> 13:06:19,200
want to make it an end so we're going to

19730
13:06:19,200 --> 13:06:21,436
make it a size t

19731
13:06:21,436 --> 13:06:23,040
and we're going to build and run this

19732
13:06:23,040 --> 13:06:24,080
program

19733
13:06:24,080 --> 13:06:26,956
and see how many digits we found you

19734
13:06:26,956 --> 13:06:28,800
know it is this number here i'm not

19735
13:06:28,800 --> 13:06:30,160
going to say it

19736
13:06:30,160 --> 13:06:32,400
we're going to let our program figure

19737
13:06:32,400 --> 13:06:34,840
this out so rooster and we're going to

19738
13:06:34,840 --> 13:06:38,560
find two two and one so we found three

19739
13:06:38,560 --> 13:06:40,880
digits and it is exactly what we expect

19740
13:06:40,880 --> 13:06:41,916
here

19741
13:06:41,916 --> 13:06:43,840
we're going to comment this out and show

19742
13:06:43,840 --> 13:06:46,320
you another example and in the last

19743
13:06:46,320 --> 13:06:48,000
example we're going to be showing you

19744
13:06:48,000 --> 13:06:49,756
that you can change the case of a

19745
13:06:49,756 --> 13:06:52,320
character if it's lowercase make it

19746
13:06:52,320 --> 13:06:54,400
uppercase if it's uppercase make it

19747
13:06:54,400 --> 13:06:56,480
lowercase and you can do things like

19748
13:06:56,480 --> 13:06:59,520
that we have a message here stored in

19749
13:06:59,520 --> 13:07:02,720
our character array called original str

19750
13:07:02,720 --> 13:07:04,640
we set up another array which is going

19751
13:07:04,640 --> 13:07:08,160
to store our message that is transformed

19752
13:07:08,160 --> 13:07:10,000
and we're going to loop around turning

19753
13:07:10,000 --> 13:07:12,800
everything we come across uppercase

19754
13:07:12,800 --> 13:07:14,880
the way we do that we're going to say

19755
13:07:14,880 --> 13:07:17,116
std to upper

19756
13:07:17,116 --> 13:07:19,116
and we're going to pass in the character

19757
13:07:19,116 --> 13:07:21,200
that we want to turn to uppercase if we

19758
13:07:21,200 --> 13:07:23,520
do that we're going to get an uppercase

19759
13:07:23,520 --> 13:07:26,000
character out of that and we're going to

19760
13:07:26,000 --> 13:07:28,800
store that in our destination

19761
13:07:28,800 --> 13:07:31,200
array at this index here it is this

19762
13:07:31,200 --> 13:07:33,040
simple after that we're going to print

19763
13:07:33,040 --> 13:07:35,520
the original strand and the uppercase

19764
13:07:35,520 --> 13:07:37,680
string we should get that printed out

19765
13:07:37,680 --> 13:07:39,520
because it is stored

19766
13:07:39,520 --> 13:07:42,160
in destination string here

19767
13:07:42,160 --> 13:07:43,840
and we're going to do the reverse and

19768
13:07:43,840 --> 13:07:46,560
turn that back into lowercase

19769
13:07:46,560 --> 13:07:47,840
we're going to grab the original

19770
13:07:47,840 --> 13:07:50,560
strength loop over it and at each

19771
13:07:50,560 --> 13:07:52,480
iteration we're going to get whatever we

19772
13:07:52,480 --> 13:07:53,436
have

19773
13:07:53,436 --> 13:07:56,160
and turn that to uppercase to lowercase

19774
13:07:56,160 --> 13:07:57,436
i should say

19775
13:07:57,436 --> 13:07:59,756
and the result of that is going to be

19776
13:07:59,756 --> 13:08:02,880
stored back in our destination strand so

19777
13:08:02,880 --> 13:08:04,640
we're going to overwrite whatever we

19778
13:08:04,640 --> 13:08:07,436
have in our destination string here and

19779
13:08:07,436 --> 13:08:08,956
after that we're going to branch the

19780
13:08:08,956 --> 13:08:11,040
lowercase string and we should get that

19781
13:08:11,040 --> 13:08:12,720
printed out this is how the example

19782
13:08:12,720 --> 13:08:14,880
works and if you have any problem

19783
13:08:14,880 --> 13:08:17,360
understanding this i am always around

19784
13:08:17,360 --> 13:08:20,160
please do ask i will do the best i can

19785
13:08:20,160 --> 13:08:22,800
to help you out for now we are going to

19786
13:08:22,800 --> 13:08:24,240
build this

19787
13:08:24,240 --> 13:08:26,800
with gcc the builder is going to be good

19788
13:08:26,800 --> 13:08:28,320
we're going to clear and we're going to

19789
13:08:28,320 --> 13:08:31,116
run booster and we're going to see that

19790
13:08:31,116 --> 13:08:33,276
the message is here it is turned

19791
13:08:33,276 --> 13:08:35,520
uppercase it is turned lower case and

19792
13:08:35,520 --> 13:08:38,080
this is how you can do these things here

19793
13:08:38,080 --> 13:08:41,200
so we have looked at a few of this

19794
13:08:41,200 --> 13:08:43,520
facilities from cctime i don't really

19795
13:08:43,520 --> 13:08:45,756
want to look at all of them because that

19796
13:08:45,756 --> 13:08:48,800
would be really boring i hope you have

19797
13:08:48,800 --> 13:08:50,956
an idea about how they work and if you

19798
13:08:50,956 --> 13:08:52,560
want to look at all of them all you have

19799
13:08:52,560 --> 13:08:55,200
to do is come to the documentation here

19800
13:08:55,200 --> 13:08:56,800
choose one

19801
13:08:56,800 --> 13:08:59,360
open it up and look at the documentation

19802
13:08:59,360 --> 13:09:01,360
and in most cases they are going to have

19803
13:09:01,360 --> 13:09:04,000
examples down here that you can look at

19804
13:09:04,000 --> 13:09:05,360
and play with

19805
13:09:05,360 --> 13:09:06,880
for now we are going to stop here in

19806
13:09:06,880 --> 13:09:08,640
this lecture this is really all we set

19807
13:09:08,640 --> 13:09:11,276
out to do to play with many of these

19808
13:09:11,276 --> 13:09:14,080
facilities from the cctype library in

19809
13:09:14,080 --> 13:09:15,680
the next lecture we're going to look at

19810
13:09:15,680 --> 13:09:18,400
how we can manipulate c strings and by

19811
13:09:18,400 --> 13:09:20,720
that we mean concatenating them or

19812
13:09:20,720 --> 13:09:23,116
putting them together copying them out

19813
13:09:23,116 --> 13:09:25,840
and doing all kinds of crazy things

19814
13:09:25,840 --> 13:09:28,160
go ahead and finish up here and meet me

19815
13:09:28,160 --> 13:09:29,040
there

19816
13:09:29,040 --> 13:09:30,560
in this lecture we're going to look at

19817
13:09:30,560 --> 13:09:33,116
the facilities from the c plus plus

19818
13:09:33,116 --> 13:09:36,080
standard library to play with c strings

19819
13:09:36,080 --> 13:09:38,160
all of these are going to be leaving in

19820
13:09:38,160 --> 13:09:40,560
the c string library you can go and

19821
13:09:40,560 --> 13:09:42,956
check it out at cpp reference and we're

19822
13:09:42,956 --> 13:09:44,400
going to start and look at a few

19823
13:09:44,400 --> 13:09:47,116
examples of some of the things we can do

19824
13:09:47,116 --> 13:09:49,596
with this library i mean c string the

19825
13:09:49,596 --> 13:09:51,436
first thing we're going to look at is an

19826
13:09:51,436 --> 13:09:53,756
example of how we can check the length

19827
13:09:53,756 --> 13:09:56,560
of a strength here we have a character

19828
13:09:56,560 --> 13:09:58,720
array called message one it is a

19829
13:09:58,720 --> 13:10:01,040
character array and you see that we made

19830
13:10:01,040 --> 13:10:04,800
it const we also have another array that

19831
13:10:04,800 --> 13:10:07,360
is pointed to by pointer you know that

19832
13:10:07,360 --> 13:10:09,200
if we do things like this this array is

19833
13:10:09,200 --> 13:10:11,520
going to decay into a pointer and there

19834
13:10:11,520 --> 13:10:13,360
are a few things we can do with that for

19835
13:10:13,360 --> 13:10:16,480
example we can't use it with std size

19836
13:10:16,480 --> 13:10:19,276
and we can't use a range based for loop

19837
13:10:19,276 --> 13:10:21,916
to loop through this message to thank

19838
13:10:21,916 --> 13:10:22,720
you

19839
13:10:22,720 --> 13:10:23,520
but

19840
13:10:23,520 --> 13:10:26,480
sdr then is going to help us check the

19841
13:10:26,480 --> 13:10:28,956
length of this thing here so we can use

19842
13:10:28,956 --> 13:10:33,436
it for example if we do hdd sdr lam

19843
13:10:33,436 --> 13:10:34,800
message one we're going to get the

19844
13:10:34,800 --> 13:10:36,720
number of characters

19845
13:10:36,720 --> 13:10:38,000
in this

19846
13:10:38,000 --> 13:10:40,400
string here this is not going to count

19847
13:10:40,400 --> 13:10:42,560
the null character though so the null

19848
13:10:42,560 --> 13:10:44,880
character that is implicitly added in by

19849
13:10:44,880 --> 13:10:46,880
the compiler is not going to be counted

19850
13:10:46,880 --> 13:10:48,080
in here you're going to see this in a

19851
13:10:48,080 --> 13:10:50,480
minute when we hit visual studio code to

19852
13:10:50,480 --> 13:10:52,956
play with this thanks but this facility

19853
13:10:52,956 --> 13:10:55,840
can work regardless of whether you are

19854
13:10:55,840 --> 13:10:58,320
using a row array like this or even for

19855
13:10:58,320 --> 13:11:00,800
pointers like this and it is really cool

19856
13:11:00,800 --> 13:11:02,720
so we can use it like this we're going

19857
13:11:02,720 --> 13:11:05,116
to get it printed out please note that

19858
13:11:05,116 --> 13:11:08,320
we can also use the size of operator to

19859
13:11:08,320 --> 13:11:10,400
get the same thing so it is going to

19860
13:11:10,400 --> 13:11:13,436
work almost the same way but the size of

19861
13:11:13,436 --> 13:11:15,360
operator is going to include the null

19862
13:11:15,360 --> 13:11:17,840
character you need to be aware of this

19863
13:11:17,840 --> 13:11:20,640
the good thing about str lan here is

19864
13:11:20,640 --> 13:11:23,040
that it still works for a decade arrays

19865
13:11:23,040 --> 13:11:25,596
so if we use it on message 2 we're going

19866
13:11:25,596 --> 13:11:26,480
to get

19867
13:11:26,480 --> 13:11:28,400
the correct output we're going to get

19868
13:11:28,400 --> 13:11:30,480
the number of characters in here which

19869
13:11:30,480 --> 13:11:31,680
is really cool

19870
13:11:31,680 --> 13:11:34,400
and we can also try and print out the

19871
13:11:34,400 --> 13:11:35,680
size of

19872
13:11:35,680 --> 13:11:37,520
message two but here we're going to get

19873
13:11:37,520 --> 13:11:39,916
the size of a pointer printed out okay

19874
13:11:39,916 --> 13:11:43,360
that's how hdr lan works it lets you

19875
13:11:43,360 --> 13:11:45,756
evaluate the length of a strand here is

19876
13:11:45,756 --> 13:11:49,360
another example and it is str cmp or

19877
13:11:49,360 --> 13:11:51,596
string compare it is used to compare

19878
13:11:51,596 --> 13:11:53,276
strings what you're going to do with

19879
13:11:53,276 --> 13:11:56,160
this facility is give it two strands c

19880
13:11:56,160 --> 13:11:58,480
strands we should be exact

19881
13:11:58,480 --> 13:12:02,240
and one is this guy here l h ace or left

19882
13:12:02,240 --> 13:12:04,240
hand string i think that's what this

19883
13:12:04,240 --> 13:12:06,640
stands for and we're going to give it a

19884
13:12:06,640 --> 13:12:08,800
right hand strand and by the way these

19885
13:12:08,800 --> 13:12:11,276
signatures are copied straight from the

19886
13:12:11,276 --> 13:12:13,436
documentation so that we can look at

19887
13:12:13,436 --> 13:12:15,840
this in one slide to make it really easy

19888
13:12:15,840 --> 13:12:17,916
to follow this is going to return a

19889
13:12:17,916 --> 13:12:20,880
negative value if the first guy happens

19890
13:12:20,880 --> 13:12:22,640
to come before

19891
13:12:22,640 --> 13:12:26,000
the second guy in lexicographical order

19892
13:12:26,000 --> 13:12:28,160
so it is something like a comes in front

19893
13:12:28,160 --> 13:12:30,720
of b c comes in front of d or something

19894
13:12:30,720 --> 13:12:33,200
like that if the two strands are equal

19895
13:12:33,200 --> 13:12:34,956
it is going to return

19896
13:12:34,956 --> 13:12:37,040
zero and it's going to return a positive

19897
13:12:37,040 --> 13:12:38,000
value

19898
13:12:38,000 --> 13:12:40,400
if the first guy appears after the

19899
13:12:40,400 --> 13:12:41,840
second guy

19900
13:12:41,840 --> 13:12:43,680
okay and we're going to try it out we

19901
13:12:43,680 --> 13:12:46,240
have two strings alabama and la bama

19902
13:12:46,240 --> 13:12:48,560
here and they are stored in character

19903
13:12:48,560 --> 13:12:50,880
arrays that are pointed to by these two

19904
13:12:50,880 --> 13:12:52,956
pointers string data one and string data

19905
13:12:52,956 --> 13:12:55,200
two and we can do something like this

19906
13:12:55,200 --> 13:12:56,880
below here so we're going to print

19907
13:12:56,880 --> 13:12:58,080
something out

19908
13:12:58,080 --> 13:13:00,240
and we're going to say std string

19909
13:13:00,240 --> 13:13:02,080
compare and we're going to pass in the

19910
13:13:02,080 --> 13:13:04,320
first string and the second string for

19911
13:13:04,320 --> 13:13:06,320
now i want you to pause a little bit and

19912
13:13:06,320 --> 13:13:07,756
try to guess what we're going to get

19913
13:13:07,756 --> 13:13:09,200
printed out here

19914
13:13:09,200 --> 13:13:11,276
the first string is alabama the second

19915
13:13:11,276 --> 13:13:14,240
one is blah blah so the first one comes

19916
13:13:14,240 --> 13:13:16,160
in front of the second

19917
13:13:16,160 --> 13:13:18,080
and we see that we're going to get a

19918
13:13:18,080 --> 13:13:21,116
negative value if the first guy comes in

19919
13:13:21,116 --> 13:13:23,756
front of the second guy so alabama comes

19920
13:13:23,756 --> 13:13:25,916
in front of blabama

19921
13:13:25,916 --> 13:13:27,840
and we would expect to get something

19922
13:13:27,840 --> 13:13:30,160
negative from this thing we are doing

19923
13:13:30,160 --> 13:13:31,520
here

19924
13:13:31,520 --> 13:13:33,360
and again if we try and change them up a

19925
13:13:33,360 --> 13:13:35,276
little bit you see that alabama still

19926
13:13:35,276 --> 13:13:38,240
comes before a la bomb

19927
13:13:38,240 --> 13:13:39,916
so we're going to get a negative value

19928
13:13:39,916 --> 13:13:41,596
pointed out and we can change these

19929
13:13:41,596 --> 13:13:43,520
things up to see what we get it is

19930
13:13:43,520 --> 13:13:46,000
really simple if you know how to use

19931
13:13:46,000 --> 13:13:48,000
them we can also use another version of

19932
13:13:48,000 --> 13:13:50,000
string compare which is going to let us

19933
13:13:50,000 --> 13:13:52,240
specify the number of characters that we

19934
13:13:52,240 --> 13:13:54,160
want to compare

19935
13:13:54,160 --> 13:13:57,116
we can specify that we want to compare n

19936
13:13:57,116 --> 13:13:58,956
characters in this case it is three

19937
13:13:58,956 --> 13:14:01,436
characters and it is going to compare a

19938
13:14:01,436 --> 13:14:04,320
section of the strings that you specify

19939
13:14:04,320 --> 13:14:07,040
as a first and second parameter here so

19940
13:14:07,040 --> 13:14:09,116
for example if we change string that i

19941
13:14:09,116 --> 13:14:12,320
want to be a a i a and string data two

19942
13:14:12,320 --> 13:14:16,000
to b a a a n c a and we are comparing

19943
13:14:16,000 --> 13:14:17,680
three characters in here so we are

19944
13:14:17,680 --> 13:14:20,560
comparing aaa to aaa we're going to see

19945
13:14:20,560 --> 13:14:22,240
that they are equal and we're going to

19946
13:14:22,240 --> 13:14:24,640
get a 0 printed out here you're going to

19947
13:14:24,640 --> 13:14:26,720
see that this is exactly the case when

19948
13:14:26,720 --> 13:14:28,800
we get to play with us in visual studio

19949
13:14:28,800 --> 13:14:30,320
code in a minute

19950
13:14:30,320 --> 13:14:32,800
we have a facility that we can use to

19951
13:14:32,800 --> 13:14:34,720
search in a string and search for a

19952
13:14:34,720 --> 13:14:37,840
character the facility for that is sdr

19953
13:14:37,840 --> 13:14:40,956
chr and it is going to find the first

19954
13:14:40,956 --> 13:14:43,520
occurrence of a character in a string

19955
13:14:43,520 --> 13:14:45,596
and the documentation for this is right

19956
13:14:45,596 --> 13:14:46,480
here

19957
13:14:46,480 --> 13:14:49,040
and please note that this example is

19958
13:14:49,040 --> 13:14:50,560
actually copied

19959
13:14:50,560 --> 13:14:52,880
straight from the documentation

19960
13:14:52,880 --> 13:14:55,360
okay so we have a message here

19961
13:14:55,360 --> 13:14:57,276
it is a character array and it is

19962
13:14:57,276 --> 13:15:00,160
pointed to by a const car pointer called

19963
13:15:00,160 --> 13:15:02,640
hdr and we have a target character that

19964
13:15:02,640 --> 13:15:04,240
we are looking for

19965
13:15:04,240 --> 13:15:06,640
and the result is going to be stored in

19966
13:15:06,640 --> 13:15:09,916
the result character array here and we

19967
13:15:09,916 --> 13:15:12,160
have a variable called iterations that

19968
13:15:12,160 --> 13:15:14,080
is going to keep track of how many

19969
13:15:14,080 --> 13:15:16,720
iterations we did to find our target

19970
13:15:16,720 --> 13:15:19,276
here the way this guy works it is going

19971
13:15:19,276 --> 13:15:22,720
to return a pointer to what you find

19972
13:15:22,720 --> 13:15:24,880
if it is found for example in here if we

19973
13:15:24,880 --> 13:15:28,080
find this first t this function here or

19974
13:15:28,080 --> 13:15:29,680
this facility is going to return a

19975
13:15:29,680 --> 13:15:32,240
pointer to this first t here

19976
13:15:32,240 --> 13:15:34,480
if it doesn't find what we want it is

19977
13:15:34,480 --> 13:15:36,400
going to return a null pointer that's

19978
13:15:36,400 --> 13:15:38,480
how it works and you can see that in the

19979
13:15:38,480 --> 13:15:40,720
documentation here we are going to take

19980
13:15:40,720 --> 13:15:42,956
advantage of how it works in this while

19981
13:15:42,956 --> 13:15:44,956
loop here and the way you use this

19982
13:15:44,956 --> 13:15:46,880
facility you give it the strength you

19983
13:15:46,880 --> 13:15:49,040
want to search in and you give it the

19984
13:15:49,040 --> 13:15:51,680
character that you are looking for so if

19985
13:15:51,680 --> 13:15:53,680
we look at how it works in the while

19986
13:15:53,680 --> 13:15:55,596
loop here we are going to call the

19987
13:15:55,596 --> 13:15:56,400
function

19988
13:15:56,400 --> 13:15:58,720
and we are going to store the result in

19989
13:15:58,720 --> 13:16:01,596
our character pointer here and if we go

19990
13:16:01,596 --> 13:16:03,916
inside we're going to hit the first

19991
13:16:03,916 --> 13:16:06,240
character here at the first iteration so

19992
13:16:06,240 --> 13:16:08,480
we're going to find this t here and when

19993
13:16:08,480 --> 13:16:10,320
we find it the result of this is going

19994
13:16:10,320 --> 13:16:12,880
to be stored back in result here

19995
13:16:12,880 --> 13:16:15,116
i hope this makes sense so we're going

19996
13:16:15,116 --> 13:16:17,436
to find it we're going to print it and

19997
13:16:17,436 --> 13:16:19,436
we're going to increment result to make

19998
13:16:19,436 --> 13:16:21,596
it point to the next character this is

19999
13:16:21,596 --> 13:16:24,880
pointer arithmetic in action here

20000
13:16:24,880 --> 13:16:26,560
and after we do that we're going to

20001
13:16:26,560 --> 13:16:28,400
increment the iterations so we should

20002
13:16:28,400 --> 13:16:30,720
have one iteration by now and we're

20003
13:16:30,720 --> 13:16:33,116
going to jump into the loop again so the

20004
13:16:33,116 --> 13:16:34,880
string we search in is going to be

20005
13:16:34,880 --> 13:16:37,276
starting from r here

20006
13:16:37,276 --> 13:16:39,436
so we're going to try and find

20007
13:16:39,436 --> 13:16:42,240
an uppercase tn and it is going to find

20008
13:16:42,240 --> 13:16:45,360
this uppercase t here so it is going to

20009
13:16:45,360 --> 13:16:48,320
point to it and the pointer to this t

20010
13:16:48,320 --> 13:16:50,240
is going to be stored in this result

20011
13:16:50,240 --> 13:16:52,560
here okay and we're going to jump into

20012
13:16:52,560 --> 13:16:54,560
our body here we're going to say that we

20013
13:16:54,560 --> 13:16:57,276
found this t we're going to print it out

20014
13:16:57,276 --> 13:16:59,360
and we're going to increment results if

20015
13:16:59,360 --> 13:17:01,756
we increment reserved now research is

20016
13:17:01,756 --> 13:17:04,720
going to be pointing to the h here

20017
13:17:04,720 --> 13:17:06,480
okay and we're going to

20018
13:17:06,480 --> 13:17:08,800
say how many iterations we did to find

20019
13:17:08,800 --> 13:17:11,276
our thing we will have printed out the t

20020
13:17:11,276 --> 13:17:13,276
that we have found and we're going to

20021
13:17:13,276 --> 13:17:15,040
jump to the next iteration which is

20022
13:17:15,040 --> 13:17:17,200
going to be searching for t

20023
13:17:17,200 --> 13:17:19,116
in the reminder of the string here it's

20024
13:17:19,116 --> 13:17:20,640
not going to find it of course it's

20025
13:17:20,640 --> 13:17:22,956
going to return no pointer and the test

20026
13:17:22,956 --> 13:17:24,880
here is going to fail and we're going to

20027
13:17:24,880 --> 13:17:27,040
fall down here and say how many

20028
13:17:27,040 --> 13:17:29,436
iterations we found i realize this

20029
13:17:29,436 --> 13:17:31,840
example can be really confusing i am

20030
13:17:31,840 --> 13:17:34,080
going to try and explain it again when

20031
13:17:34,080 --> 13:17:36,720
we hit visual studio code for now note

20032
13:17:36,720 --> 13:17:39,520
that this facility can help you find

20033
13:17:39,520 --> 13:17:41,360
characters in a string that's the

20034
13:17:41,360 --> 13:17:43,200
message here there is also another

20035
13:17:43,200 --> 13:17:45,680
function that helps you find the last

20036
13:17:45,680 --> 13:17:48,560
occurrence of a character in a string

20037
13:17:48,560 --> 13:17:50,240
for example here we have a character

20038
13:17:50,240 --> 13:17:51,200
input

20039
13:17:51,200 --> 13:17:54,560
it is a path to a file on some limit

20040
13:17:54,560 --> 13:17:56,640
system or mac system

20041
13:17:56,640 --> 13:17:59,840
and we have an output character pointer

20042
13:17:59,840 --> 13:18:01,756
which is going to store the pointer to

20043
13:18:01,756 --> 13:18:04,560
the character that we found okay if we

20044
13:18:04,560 --> 13:18:06,080
find the character we're going to store

20045
13:18:06,080 --> 13:18:08,240
in the pointer to that character if we

20046
13:18:08,240 --> 13:18:10,240
don't find it we're going to return no

20047
13:18:10,240 --> 13:18:12,320
pointer i think that's how this thing

20048
13:18:12,320 --> 13:18:13,276
works

20049
13:18:13,276 --> 13:18:15,520
so what we really want here

20050
13:18:15,520 --> 13:18:18,640
is to hunt for the file name in this

20051
13:18:18,640 --> 13:18:20,956
path here and this is really interesting

20052
13:18:20,956 --> 13:18:23,436
so we're going to search for the

20053
13:18:23,436 --> 13:18:26,080
backslash the last one and this string

20054
13:18:26,080 --> 13:18:28,560
here and it is going to find this guy

20055
13:18:28,560 --> 13:18:30,640
here because that's the last occurrence

20056
13:18:30,640 --> 13:18:32,320
of the backslash

20057
13:18:32,320 --> 13:18:34,880
in our input string here once we find it

20058
13:18:34,880 --> 13:18:37,276
we're going to get a pointer to this guy

20059
13:18:37,276 --> 13:18:39,840
stored in the output character pointer

20060
13:18:39,840 --> 13:18:41,756
here and we're going to print it out

20061
13:18:41,756 --> 13:18:43,116
what we're going to do we're going to

20062
13:18:43,116 --> 13:18:45,436
use pointer arithmetic to move this

20063
13:18:45,436 --> 13:18:47,276
pointer to the next guy because that's

20064
13:18:47,276 --> 13:18:49,360
what we really want we want to print

20065
13:18:49,360 --> 13:18:51,360
starting from the edge here and that's

20066
13:18:51,360 --> 13:18:52,800
what we're going to get when we print

20067
13:18:52,800 --> 13:18:53,916
this out

20068
13:18:53,916 --> 13:18:56,080
now that we have looked at all these

20069
13:18:56,080 --> 13:18:58,320
examples i think it is time we headed to

20070
13:18:58,320 --> 13:19:00,480
visual studio code and actually played

20071
13:19:00,480 --> 13:19:02,956
with them okay here we are in our

20072
13:19:02,956 --> 13:19:05,680
working folder the current project is c

20073
13:19:05,680 --> 13:19:07,916
string manipulation that's what we're

20074
13:19:07,916 --> 13:19:10,000
going to work on we're going to copy our

20075
13:19:10,000 --> 13:19:12,080
template files and we're going to put

20076
13:19:12,080 --> 13:19:14,480
that in place

20077
13:19:14,480 --> 13:19:16,400
and we're going to open this in visual

20078
13:19:16,400 --> 13:19:19,116
studio code pretty quick let's include c

20079
13:19:19,116 --> 13:19:20,720
string because that's what we're going

20080
13:19:20,720 --> 13:19:22,800
to be using many of the things we're

20081
13:19:22,800 --> 13:19:24,640
going to be playing with in this lecture

20082
13:19:24,640 --> 13:19:26,800
are documented in this piece of

20083
13:19:26,800 --> 13:19:29,040
documentation here so you can come here

20084
13:19:29,040 --> 13:19:31,360
and get more details than we could even

20085
13:19:31,360 --> 13:19:33,596
cover in a course like this let's bring

20086
13:19:33,596 --> 13:19:35,200
this up a little bit and we're going to

20087
13:19:35,200 --> 13:19:37,520
go in our main function and put in the

20088
13:19:37,520 --> 13:19:40,320
first piece of code we can play with the

20089
13:19:40,320 --> 13:19:43,116
str land facility is going to find the

20090
13:19:43,116 --> 13:19:45,520
length of the strength and it's going to

20091
13:19:45,520 --> 13:19:48,080
work regardless of whether you are using

20092
13:19:48,080 --> 13:19:50,880
a row array like this or even if you are

20093
13:19:50,880 --> 13:19:52,800
using the character pointer to point to

20094
13:19:52,800 --> 13:19:55,116
your array and this is pretty cool so

20095
13:19:55,116 --> 13:19:57,436
here we have strlen message one we're

20096
13:19:57,436 --> 13:19:58,640
going to print that out we're going to

20097
13:19:58,640 --> 13:20:00,320
print how many characters we have in

20098
13:20:00,320 --> 13:20:01,680
this guy here

20099
13:20:01,680 --> 13:20:03,916
we're going to also use the size of

20100
13:20:03,916 --> 13:20:06,160
operator to try and compare these things

20101
13:20:06,160 --> 13:20:08,560
but please know that the null character

20102
13:20:08,560 --> 13:20:10,240
is going to be included if you use

20103
13:20:10,240 --> 13:20:13,116
sizeof here on a row array

20104
13:20:13,116 --> 13:20:16,320
this is very important to know

20105
13:20:16,320 --> 13:20:19,360
but one interesting thing about hdr lan

20106
13:20:19,360 --> 13:20:21,596
is that it is also going to work if you

20107
13:20:21,596 --> 13:20:23,680
are storing your array

20108
13:20:23,680 --> 13:20:25,680
and something that is pointed to by

20109
13:20:25,680 --> 13:20:28,880
pointer so even decayed pointers

20110
13:20:28,880 --> 13:20:30,640
are going to be usable here and this is

20111
13:20:30,640 --> 13:20:33,436
pretty cool so we can also try and print

20112
13:20:33,436 --> 13:20:35,360
the size of message 2 which is pointed

20113
13:20:35,360 --> 13:20:37,840
to by a row pointer and we're going to

20114
13:20:37,840 --> 13:20:39,520
see what we get but we know that we're

20115
13:20:39,520 --> 13:20:41,200
going to get the size of a pointer

20116
13:20:41,200 --> 13:20:43,680
because that's what it really is message

20117
13:20:43,680 --> 13:20:46,000
two here is just a pointer okay let's

20118
13:20:46,000 --> 13:20:48,160
close this on the left

20119
13:20:48,160 --> 13:20:50,000
and we are going to bring up our

20120
13:20:50,000 --> 13:20:51,520
terminal

20121
13:20:51,520 --> 13:20:54,160
and i try and build this with gcc we're

20122
13:20:54,160 --> 13:20:55,916
going to do that so we're going to use

20123
13:20:55,916 --> 13:20:57,596
gcc to build this

20124
13:20:57,596 --> 13:20:59,520
the world is going to go through

20125
13:20:59,520 --> 13:21:01,596
and we're going to clear and run rooster

20126
13:21:01,596 --> 13:21:02,560
again

20127
13:21:02,560 --> 13:21:04,160
and this is going to give us what we

20128
13:21:04,160 --> 13:21:07,756
want sqr lan message 1 is 16

20129
13:21:07,756 --> 13:21:10,720
size of message 1 is 17 because sizeof

20130
13:21:10,720 --> 13:21:12,320
is also going to count

20131
13:21:12,320 --> 13:21:16,320
the null character htrlen message2 you

20132
13:21:16,320 --> 13:21:18,400
see that it works even if

20133
13:21:18,400 --> 13:21:21,040
we have a decayed array

20134
13:21:21,040 --> 13:21:23,916
that is pointed to by a pointer and this

20135
13:21:23,916 --> 13:21:26,160
is really useful if you happen to need

20136
13:21:26,160 --> 13:21:28,640
the size of an array like this you can

20137
13:21:28,640 --> 13:21:30,800
use hdr then and you're going to get the

20138
13:21:30,800 --> 13:21:33,916
size of data in there but know that the

20139
13:21:33,916 --> 13:21:36,160
null terminating character is not

20140
13:21:36,160 --> 13:21:39,680
counted if you use hdr ln here and size

20141
13:21:39,680 --> 13:21:42,160
of message 2 is going to be 8 because

20142
13:21:42,160 --> 13:21:44,400
that's the size of a pointer on our

20143
13:21:44,400 --> 13:21:47,276
system here so know that this guy is

20144
13:21:47,276 --> 13:21:48,640
just a pointer

20145
13:21:48,640 --> 13:21:51,200
okay that's the message here

20146
13:21:51,200 --> 13:21:52,880
we are going to comment this out the

20147
13:21:52,880 --> 13:21:55,080
next thing we're going to look at is

20148
13:21:55,080 --> 13:21:57,756
strcmp which can be used to compare

20149
13:21:57,756 --> 13:21:59,040
strengths

20150
13:21:59,040 --> 13:22:01,840
so it works exactly like we say it's

20151
13:22:01,840 --> 13:22:04,000
going to return something negative if

20152
13:22:04,000 --> 13:22:06,720
the first string happens to come in

20153
13:22:06,720 --> 13:22:08,956
front of the second string in

20154
13:22:08,956 --> 13:22:10,480
lexicographical

20155
13:22:10,480 --> 13:22:13,480
order

20156
13:22:25,360 --> 13:22:26,956
for example here we have a few variables

20157
13:22:26,956 --> 13:22:29,596
we have alabama and blabama there are

20158
13:22:29,596 --> 13:22:31,680
strengths pointed to by

20159
13:22:31,680 --> 13:22:32,956
pointers

20160
13:22:32,956 --> 13:22:34,640
so they are c strings

20161
13:22:34,640 --> 13:22:37,436
and we have a couple of other strings

20162
13:22:37,436 --> 13:22:40,240
stored in row arrays like this and by

20163
13:22:40,240 --> 13:22:42,080
doing this i want to prove that this

20164
13:22:42,080 --> 13:22:44,480
facility is going to work regardless of

20165
13:22:44,480 --> 13:22:46,880
how your array or your c string is

20166
13:22:46,880 --> 13:22:50,160
stored so we're going to use that here

20167
13:22:50,160 --> 13:22:51,840
for our

20168
13:22:51,840 --> 13:22:54,480
c string pointer 2 by pointers

20169
13:22:54,480 --> 13:22:56,240
we're going to try and compare whatever

20170
13:22:56,240 --> 13:22:58,320
is in a string data one

20171
13:22:58,320 --> 13:23:01,200
with string data two string data one has

20172
13:23:01,200 --> 13:23:04,320
alabama string data two has blah blah so

20173
13:23:04,320 --> 13:23:06,400
if we compare these guys we expect to

20174
13:23:06,400 --> 13:23:09,436
get a negative value out of this thing

20175
13:23:09,436 --> 13:23:10,720
here

20176
13:23:10,720 --> 13:23:12,480
strcmp

20177
13:23:12,480 --> 13:23:16,160
because alabama comes in front of

20178
13:23:16,160 --> 13:23:19,520
blabama in our alphabet so a is in front

20179
13:23:19,520 --> 13:23:21,596
of b so we're going to get a negative

20180
13:23:21,596 --> 13:23:23,916
value out of this and we expect to get

20181
13:23:23,916 --> 13:23:25,680
the same thing in the second example

20182
13:23:25,680 --> 13:23:27,840
here which is going to be using what we

20183
13:23:27,840 --> 13:23:30,400
store in our row array

20184
13:23:30,400 --> 13:23:32,640
so make sure you understand this and

20185
13:23:32,640 --> 13:23:34,560
we're going to try and build this to see

20186
13:23:34,560 --> 13:23:38,240
that it passes through our gcc compiler

20187
13:23:38,240 --> 13:23:39,916
the buzz is good

20188
13:23:39,916 --> 13:23:42,000
so we're going to clear

20189
13:23:42,000 --> 13:23:44,080
and run rooster and you're going to see

20190
13:23:44,080 --> 13:23:46,000
that we get a negative one

20191
13:23:46,000 --> 13:23:47,756
i want you to play with this thanks and

20192
13:23:47,756 --> 13:23:50,720
try and change for example the 8 with c

20193
13:23:50,720 --> 13:23:52,640
and see what you get

20194
13:23:52,640 --> 13:23:54,560
okay we're going to try and build but

20195
13:23:54,560 --> 13:23:56,880
before we do try to expect to see what

20196
13:23:56,880 --> 13:23:59,596
you get c comes after blah blah

20197
13:23:59,596 --> 13:24:01,360
so

20198
13:24:01,360 --> 13:24:03,916
if we look at this description here we

20199
13:24:03,916 --> 13:24:06,480
should get a positive value because

20200
13:24:06,480 --> 13:24:08,800
the first guy comes after

20201
13:24:08,800 --> 13:24:11,596
the second guy in lexicographical order

20202
13:24:11,596 --> 13:24:13,840
so we should get a positive value

20203
13:24:13,840 --> 13:24:17,040
for the first thing that we print here

20204
13:24:17,040 --> 13:24:19,040
okay let's weld and see if that's the

20205
13:24:19,040 --> 13:24:21,520
case we're going to build successfully

20206
13:24:21,520 --> 13:24:24,080
we're going to clear and run rooster and

20207
13:24:24,080 --> 13:24:26,400
you see that the first guy prints a one

20208
13:24:26,400 --> 13:24:27,520
because

20209
13:24:27,520 --> 13:24:30,560
cla gamma comes before blah blah

20210
13:24:30,560 --> 13:24:32,480
and the second one is going to

20211
13:24:32,480 --> 13:24:35,276
still be a negative one because we still

20212
13:24:35,276 --> 13:24:36,080
have

20213
13:24:36,080 --> 13:24:38,080
whatever we had before in there okay

20214
13:24:38,080 --> 13:24:40,240
this is how you work with this thanks

20215
13:24:40,240 --> 13:24:42,800
let's turn this back to alabama

20216
13:24:42,800 --> 13:24:45,360
so that we are not confused

20217
13:24:45,360 --> 13:24:47,116
and we're going to keep

20218
13:24:47,116 --> 13:24:50,160
working on this and the next piece of

20219
13:24:50,160 --> 13:24:51,916
code we are going to try and modify

20220
13:24:51,916 --> 13:24:54,000
whatever is stored in string data 1 and

20221
13:24:54,000 --> 13:24:56,956
string data 2 and print the comparisons

20222
13:24:56,956 --> 13:24:58,000
out

20223
13:24:58,000 --> 13:25:00,640
for example we have alabama and album

20224
13:25:00,640 --> 13:25:02,800
and by the way we are able to modify

20225
13:25:02,800 --> 13:25:04,160
that

20226
13:25:04,160 --> 13:25:07,360
because it is a pointer to a strength

20227
13:25:07,360 --> 13:25:09,200
and notice that this is not the

20228
13:25:09,200 --> 13:25:11,360
conspirator so we can really change

20229
13:25:11,360 --> 13:25:13,200
where this guy is pointing and that's

20230
13:25:13,200 --> 13:25:15,436
what we are doing here but we can't do

20231
13:25:15,436 --> 13:25:17,916
that with string data 3 and string data

20232
13:25:17,916 --> 13:25:20,880
4 because these are arrays and remember

20233
13:25:20,880 --> 13:25:23,360
you can't change where an array points

20234
13:25:23,360 --> 13:25:25,916
so this is going to compile nice but if

20235
13:25:25,916 --> 13:25:28,240
we try and do the same thing with string

20236
13:25:28,240 --> 13:25:30,720
data 3 and string data four

20237
13:25:30,720 --> 13:25:31,916
let's do that you're going to get a

20238
13:25:31,916 --> 13:25:33,436
compiler error

20239
13:25:33,436 --> 13:25:35,360
so we're going to put this guy here and

20240
13:25:35,360 --> 13:25:37,360
say three

20241
13:25:37,360 --> 13:25:39,116
and four

20242
13:25:39,116 --> 13:25:41,200
and we should see visual studio code

20243
13:25:41,200 --> 13:25:43,436
complaining here because this is not

20244
13:25:43,436 --> 13:25:45,360
allowed you're not allowed to make an

20245
13:25:45,360 --> 13:25:46,320
array

20246
13:25:46,320 --> 13:25:48,560
point to another location and this is

20247
13:25:48,560 --> 13:25:50,000
just another

20248
13:25:50,000 --> 13:25:52,640
character array or cost character array

20249
13:25:52,640 --> 13:25:55,436
in memory that we want this pointers to

20250
13:25:55,436 --> 13:25:57,200
point to or this array to point to and

20251
13:25:57,200 --> 13:25:59,040
this is not possible so we're going to

20252
13:25:59,040 --> 13:26:00,880
get a compiler error if we do this this

20253
13:26:00,880 --> 13:26:03,116
is something i wanted you to know that's

20254
13:26:03,116 --> 13:26:05,680
why i set up this example here so if we

20255
13:26:05,680 --> 13:26:07,756
run this we're going to see the first

20256
13:26:07,756 --> 13:26:10,560
line of output here

20257
13:26:10,560 --> 13:26:14,640
or i think i should comment that out

20258
13:26:14,640 --> 13:26:16,720
or let's not comment it out now if we

20259
13:26:16,720 --> 13:26:18,320
run this program we're going to get the

20260
13:26:18,320 --> 13:26:21,360
output for obama and alabama printed out

20261
13:26:21,360 --> 13:26:24,640
and alabama comes after alabama so we

20262
13:26:24,640 --> 13:26:27,116
expect to get a negative one because the

20263
13:26:27,116 --> 13:26:28,956
first guy here comes in front of the

20264
13:26:28,956 --> 13:26:30,400
second guy so we're going to get a

20265
13:26:30,400 --> 13:26:31,680
negative one

20266
13:26:31,680 --> 13:26:32,956
out of

20267
13:26:32,956 --> 13:26:34,240
the

20268
13:26:34,240 --> 13:26:36,640
thing we are doing here let's try in

20269
13:26:36,640 --> 13:26:39,200
world with gcc

20270
13:26:39,200 --> 13:26:41,200
the builder is going to be good so we're

20271
13:26:41,200 --> 13:26:43,596
going to clear and run rooster and we're

20272
13:26:43,596 --> 13:26:45,276
going to see that we have a negative one

20273
13:26:45,276 --> 13:26:49,276
here alabama comes in front of a lab

20274
13:26:49,276 --> 13:26:51,520
so this is cool so we can try and put in

20275
13:26:51,520 --> 13:26:53,436
many other examples for you to play with

20276
13:26:53,436 --> 13:26:55,040
i am going to do that because i don't

20277
13:26:55,040 --> 13:26:56,880
want to type all this thanks and we're

20278
13:26:56,880 --> 13:26:58,400
going to print the results out for

20279
13:26:58,400 --> 13:27:00,720
example we put in india and france we

20280
13:27:00,720 --> 13:27:02,800
put in kigali and kigali and we're going

20281
13:27:02,800 --> 13:27:04,956
to get things printed out here so let's

20282
13:27:04,956 --> 13:27:08,160
build this so that we don't waste time

20283
13:27:08,160 --> 13:27:10,000
we're going to clear and we're going to

20284
13:27:10,000 --> 13:27:11,436
run rooster

20285
13:27:11,436 --> 13:27:13,276
and we're going to see that we get these

20286
13:27:13,276 --> 13:27:15,680
things here alakama comes after alabama

20287
13:27:15,680 --> 13:27:17,520
so we get a one

20288
13:27:17,520 --> 13:27:20,720
india comes after france we get a one

20289
13:27:20,720 --> 13:27:23,200
shigari comes together with kigali and

20290
13:27:23,200 --> 13:27:24,880
we get a zero you can try and put in

20291
13:27:24,880 --> 13:27:27,276
whatever you want these are just a few

20292
13:27:27,276 --> 13:27:30,080
examples for you to play with and by now

20293
13:27:30,080 --> 13:27:31,840
i hope you really understand how this

20294
13:27:31,840 --> 13:27:34,400
function works or this facility works so

20295
13:27:34,400 --> 13:27:37,040
we're going to comment it out whatever

20296
13:27:37,040 --> 13:27:38,320
we did here

20297
13:27:38,320 --> 13:27:40,400
so we're going to comment all this out

20298
13:27:40,400 --> 13:27:42,640
so that we don't have noise output in

20299
13:27:42,640 --> 13:27:44,956
whatever we want to do next and what we

20300
13:27:44,956 --> 13:27:47,116
want to look at next is this function

20301
13:27:47,116 --> 13:27:49,116
here which is going to compare

20302
13:27:49,116 --> 13:27:51,596
strings in the same ways but we're going

20303
13:27:51,596 --> 13:27:54,480
to tell it to compare however many

20304
13:27:54,480 --> 13:27:56,080
characters in the string and you see

20305
13:27:56,080 --> 13:27:58,080
that my string here has been commented

20306
13:27:58,080 --> 13:28:01,276
up i can quickly take it and bring it

20307
13:28:01,276 --> 13:28:03,520
down here let's do that i can't find

20308
13:28:03,520 --> 13:28:04,640
that

20309
13:28:04,640 --> 13:28:08,400
let's find that and copy it down

20310
13:28:08,400 --> 13:28:10,400
and we're going to find them here so i'm

20311
13:28:10,400 --> 13:28:12,080
going to find this

20312
13:28:12,080 --> 13:28:13,916
and bring that down here so that i can

20313
13:28:13,916 --> 13:28:16,320
compare these things so let's come down

20314
13:28:16,320 --> 13:28:19,116
here and print and put in our

20315
13:28:19,116 --> 13:28:20,956
declarations for this strengths and you

20316
13:28:20,956 --> 13:28:23,520
see that visual studio code is happy now

20317
13:28:23,520 --> 13:28:25,756
so what we're going to do is compare a

20318
13:28:25,756 --> 13:28:28,956
set of characters in these strings here

20319
13:28:28,956 --> 13:28:31,200
okay so we're going to compare any

20320
13:28:31,200 --> 13:28:32,880
characters in our strengths so we're

20321
13:28:32,880 --> 13:28:36,480
going to compare allah to blah here and

20322
13:28:36,480 --> 13:28:38,320
allah is going to come in front of black

20323
13:28:38,320 --> 13:28:39,756
so we're going to have a negative one

20324
13:28:39,756 --> 13:28:42,240
printed out here but if we change the

20325
13:28:42,240 --> 13:28:46,080
strengths to aaa and aaa here and

20326
13:28:46,080 --> 13:28:48,640
compare the first three characters we're

20327
13:28:48,640 --> 13:28:50,560
going to get a zero printed out because

20328
13:28:50,560 --> 13:28:53,276
the first three characters are equal and

20329
13:28:53,276 --> 13:28:55,116
again the special thing about this

20330
13:28:55,116 --> 13:28:56,956
function is that it allows you to

20331
13:28:56,956 --> 13:28:58,160
specify

20332
13:28:58,160 --> 13:29:00,720
a number of characters you want compared

20333
13:29:00,720 --> 13:29:03,040
in these two strings so you can say i

20334
13:29:03,040 --> 13:29:04,880
want to compare three strands you can

20335
13:29:04,880 --> 13:29:06,720
say i want to compare four strings or

20336
13:29:06,720 --> 13:29:07,756
five

20337
13:29:07,756 --> 13:29:09,680
just make sure that you don't go over

20338
13:29:09,680 --> 13:29:12,000
the size of the string and if you do

20339
13:29:12,000 --> 13:29:13,596
that it's not going to make sense what

20340
13:29:13,596 --> 13:29:15,840
you are trying to do here if we go down

20341
13:29:15,840 --> 13:29:17,520
here we're going to change n to 5 and

20342
13:29:17,520 --> 13:29:19,520
we're going to be comparing all these

20343
13:29:19,520 --> 13:29:21,360
things in here and we're going to get

20344
13:29:21,360 --> 13:29:22,320
that

20345
13:29:22,320 --> 13:29:24,640
the first one comes in front of the

20346
13:29:24,640 --> 13:29:28,560
second one because i comes in front of n

20347
13:29:28,560 --> 13:29:32,000
in our alphabet if we change the data to

20348
13:29:32,000 --> 13:29:33,680
o here and n

20349
13:29:33,680 --> 13:29:35,916
o is going to come after n and we're

20350
13:29:35,916 --> 13:29:38,480
going to get a positive number printed

20351
13:29:38,480 --> 13:29:40,956
out here we're going to try and run this

20352
13:29:40,956 --> 13:29:45,116
so let's run the task to build with jcc

20353
13:29:45,116 --> 13:29:47,200
the bullet is going to be good and we're

20354
13:29:47,200 --> 13:29:49,840
going to clear and run rooster

20355
13:29:49,840 --> 13:29:51,680
and we're going to see that alabama

20356
13:29:51,680 --> 13:29:55,276
comes in front of blabama because we are

20357
13:29:55,276 --> 13:29:58,480
comparing the first three characters

20358
13:29:58,480 --> 13:30:01,276
if we have aaa in here and we compare

20359
13:30:01,276 --> 13:30:02,720
the three characters you're going to see

20360
13:30:02,720 --> 13:30:04,880
that they are equal we get a zero

20361
13:30:04,880 --> 13:30:06,560
if we change i

20362
13:30:06,560 --> 13:30:09,040
and n here we're going to get a negative

20363
13:30:09,040 --> 13:30:11,916
one because i comes in front of n

20364
13:30:11,916 --> 13:30:14,720
if we use o here and n we're going to

20365
13:30:14,720 --> 13:30:17,596
get a one because o comes after n this

20366
13:30:17,596 --> 13:30:19,916
is really simple to understand now that

20367
13:30:19,916 --> 13:30:22,160
we know how to use the first version of

20368
13:30:22,160 --> 13:30:24,640
string compare this version is just

20369
13:30:24,640 --> 13:30:27,436
going to allow us to specify how many

20370
13:30:27,436 --> 13:30:29,360
characters in the string we want

20371
13:30:29,360 --> 13:30:31,756
compared so we're going to comment this

20372
13:30:31,756 --> 13:30:34,720
out and we are going to go down and do

20373
13:30:34,720 --> 13:30:37,840
another example that allows us to search

20374
13:30:37,840 --> 13:30:40,240
for a character in a string

20375
13:30:40,240 --> 13:30:43,680
and the method we use to do that is std

20376
13:30:43,680 --> 13:30:45,040
str

20377
13:30:45,040 --> 13:30:46,560
chr

20378
13:30:46,560 --> 13:30:48,480
so this guy is going to find whatever

20379
13:30:48,480 --> 13:30:50,956
target you want to find and if it finds

20380
13:30:50,956 --> 13:30:52,880
that it's going to return you a pointer

20381
13:30:52,880 --> 13:30:55,596
to dot's target if it doesn't find it

20382
13:30:55,596 --> 13:30:58,080
it's going to return you no pointer so

20383
13:30:58,080 --> 13:31:00,560
we set up an array here and we store

20384
13:31:00,560 --> 13:31:03,756
that in a location that is pointed to by

20385
13:31:03,756 --> 13:31:06,480
the pointer to character here and we say

20386
13:31:06,480 --> 13:31:08,320
whatever target we are looking for in

20387
13:31:08,320 --> 13:31:11,360
this case we want to find this t here

20388
13:31:11,360 --> 13:31:13,596
we are going to set up another character

20389
13:31:13,596 --> 13:31:16,080
array that is going to store our results

20390
13:31:16,080 --> 13:31:17,756
the result is really going to be a

20391
13:31:17,756 --> 13:31:19,520
pointer which is going to be pointing to

20392
13:31:19,520 --> 13:31:22,240
something valid if we find the target

20393
13:31:22,240 --> 13:31:24,080
and it's going to be no equator if we

20394
13:31:24,080 --> 13:31:26,160
didn't find the target and we set up

20395
13:31:26,160 --> 13:31:28,000
another variable which is going to store

20396
13:31:28,000 --> 13:31:30,160
how many iterations we did we should

20397
13:31:30,160 --> 13:31:32,480
really make this an unsigned integer or

20398
13:31:32,480 --> 13:31:35,116
size t so let's make that here and we're

20399
13:31:35,116 --> 13:31:37,200
going to loop here so the first time

20400
13:31:37,200 --> 13:31:38,800
we'll open here we're going to call this

20401
13:31:38,800 --> 13:31:40,956
guy we're going to say i want to find a

20402
13:31:40,956 --> 13:31:41,916
t

20403
13:31:41,916 --> 13:31:43,680
and result here and the result is going

20404
13:31:43,680 --> 13:31:45,520
to be pointing to this line here because

20405
13:31:45,520 --> 13:31:47,916
we did the assignment here so it's going

20406
13:31:47,916 --> 13:31:49,840
to go and try to find the t it's going

20407
13:31:49,840 --> 13:31:52,880
to find the guy here at the first index

20408
13:31:52,880 --> 13:31:55,680
and the test here is going to succeed

20409
13:31:55,680 --> 13:31:57,680
when it succeeds it's not going to be

20410
13:31:57,680 --> 13:31:59,520
equal to no pointer it's going to be

20411
13:31:59,520 --> 13:32:01,596
pointing to a valid pointer

20412
13:32:01,596 --> 13:32:04,880
and it's going to succeed and return the

20413
13:32:04,880 --> 13:32:07,756
pointer to be stored in resort after

20414
13:32:07,756 --> 13:32:09,436
this guide returns the pointer is going

20415
13:32:09,436 --> 13:32:11,520
to be stored in the result here and

20416
13:32:11,520 --> 13:32:13,040
that's going to be a pointer to this

20417
13:32:13,040 --> 13:32:15,040
team and we're going to jump in the body

20418
13:32:15,040 --> 13:32:16,880
here i really want you to understand how

20419
13:32:16,880 --> 13:32:18,640
this thing is going to work

20420
13:32:18,640 --> 13:32:20,080
once we get to the body we're going to

20421
13:32:20,080 --> 13:32:22,240
say uh-huh we found our target that's

20422
13:32:22,240 --> 13:32:24,880
going to be our t print it out and it's

20423
13:32:24,880 --> 13:32:26,956
going to start at this location

20424
13:32:26,956 --> 13:32:29,116
okay and we're going to print starting

20425
13:32:29,116 --> 13:32:32,080
from the t here because that's what our

20426
13:32:32,080 --> 13:32:34,880
result here is pointing to after we do

20427
13:32:34,880 --> 13:32:36,720
that we're going to increment the result

20428
13:32:36,720 --> 13:32:39,200
to make it point to the next character

20429
13:32:39,200 --> 13:32:41,360
if we do that with pointer arithmetic

20430
13:32:41,360 --> 13:32:43,436
now we're going to be pointing to the r

20431
13:32:43,436 --> 13:32:44,400
in here

20432
13:32:44,400 --> 13:32:46,720
i hope this makes sense and we're going

20433
13:32:46,720 --> 13:32:48,480
to increment our iterations so we're

20434
13:32:48,480 --> 13:32:51,200
going to say we have done one iteration

20435
13:32:51,200 --> 13:32:52,640
and we're going to try and run this

20436
13:32:52,640 --> 13:32:55,116
again and by the time we get in here

20437
13:32:55,116 --> 13:32:58,320
we're going to have this string here in

20438
13:32:58,320 --> 13:33:00,956
which we are searching for a t

20439
13:33:00,956 --> 13:33:03,436
and it is going to be found starting at

20440
13:33:03,436 --> 13:33:06,320
this second t here there here

20441
13:33:06,320 --> 13:33:08,480
and it's going to find it

20442
13:33:08,480 --> 13:33:11,756
it's going to store the pointer to it to

20443
13:33:11,756 --> 13:33:14,560
resort here or i should say the search

20444
13:33:14,560 --> 13:33:16,160
is going to be successful so we're going

20445
13:33:16,160 --> 13:33:18,720
to find the pointer to this t

20446
13:33:18,720 --> 13:33:21,436
and return it from this function here

20447
13:33:21,436 --> 13:33:23,276
and the pointer is going to be stored in

20448
13:33:23,276 --> 13:33:24,640
our result

20449
13:33:24,640 --> 13:33:26,800
pointer here we're going to jump in the

20450
13:33:26,800 --> 13:33:29,200
body and we're going to print we found

20451
13:33:29,200 --> 13:33:31,040
the target starting at this t we're

20452
13:33:31,040 --> 13:33:33,680
going to print that out and stdc out is

20453
13:33:33,680 --> 13:33:35,756
going to print until it meets an old

20454
13:33:35,756 --> 13:33:37,360
character so we're going to print this

20455
13:33:37,360 --> 13:33:39,276
thing through the end and we're going to

20456
13:33:39,276 --> 13:33:42,080
put a slash n which is going to move us

20457
13:33:42,080 --> 13:33:43,680
to the next line after we do that we're

20458
13:33:43,680 --> 13:33:45,916
going to increment result

20459
13:33:45,916 --> 13:33:48,640
and uh result now is going to point to

20460
13:33:48,640 --> 13:33:50,400
the h here

20461
13:33:50,400 --> 13:33:52,480
and we're going to increment iterations

20462
13:33:52,480 --> 13:33:54,480
now we're going to have done two

20463
13:33:54,480 --> 13:33:57,040
iterations by now and we're going to run

20464
13:33:57,040 --> 13:33:59,200
the loop again this time the loop is

20465
13:33:59,200 --> 13:34:01,520
going to fail because starting from here

20466
13:34:01,520 --> 13:34:03,200
we don't have a t

20467
13:34:03,200 --> 13:34:04,720
and that this function is going to

20468
13:34:04,720 --> 13:34:07,756
return no pointer and this test here is

20469
13:34:07,756 --> 13:34:09,840
going to fail okay we are going to

20470
13:34:09,840 --> 13:34:12,240
return no pointer no pointer is not

20471
13:34:12,240 --> 13:34:14,240
going to be different from no pointer so

20472
13:34:14,240 --> 13:34:16,320
this is going to fail and we're going to

20473
13:34:16,320 --> 13:34:18,080
fall down here and say how many

20474
13:34:18,080 --> 13:34:20,000
iterations we're going to find so in

20475
13:34:20,000 --> 13:34:22,240
total we're going to do two iterations

20476
13:34:22,240 --> 13:34:24,560
and we are going to find two t's and

20477
13:34:24,560 --> 13:34:26,080
we're going to print whatever we find

20478
13:34:26,080 --> 13:34:28,080
here make sure you really understand

20479
13:34:28,080 --> 13:34:28,880
this

20480
13:34:28,880 --> 13:34:31,520
and i put in this example on purpose

20481
13:34:31,520 --> 13:34:34,400
because it is a little complicated but

20482
13:34:34,400 --> 13:34:36,880
it is going to really bring your game up

20483
13:34:36,880 --> 13:34:39,520
in how you use these functions from the

20484
13:34:39,520 --> 13:34:41,680
c plus plus standard library and you

20485
13:34:41,680 --> 13:34:43,916
really need to know this if you have any

20486
13:34:43,916 --> 13:34:45,436
problem with this

20487
13:34:45,436 --> 13:34:47,520
be sure to ask me i will do the best i

20488
13:34:47,520 --> 13:34:49,116
can to help you out so we're going to

20489
13:34:49,116 --> 13:34:51,116
build this and run this we're going to

20490
13:34:51,116 --> 13:34:53,916
build with gcc as always and we are

20491
13:34:53,916 --> 13:34:56,160
going to clear and run rooster and

20492
13:34:56,160 --> 13:34:57,680
you're going to see that we are looking

20493
13:34:57,680 --> 13:34:58,720
for t

20494
13:34:58,720 --> 13:35:01,116
we are going to say we found t starting

20495
13:35:01,116 --> 13:35:04,320
at the t here so we're going to say try

20496
13:35:04,320 --> 13:35:06,480
okay we're going to print all the

20497
13:35:06,480 --> 13:35:08,480
message out and the second iteration is

20498
13:35:08,480 --> 13:35:10,080
going to find t

20499
13:35:10,080 --> 13:35:12,560
starting at this location here and we're

20500
13:35:12,560 --> 13:35:14,880
going to do two iterations in total

20501
13:35:14,880 --> 13:35:16,400
we're going to comment this out and

20502
13:35:16,400 --> 13:35:18,640
again if you don't understand this

20503
13:35:18,640 --> 13:35:20,800
please go through it again and if you

20504
13:35:20,800 --> 13:35:23,200
still don't understand be sure to ask me

20505
13:35:23,200 --> 13:35:25,040
i am going to do the best i can to help

20506
13:35:25,040 --> 13:35:28,720
you out and some of you might be asking

20507
13:35:28,720 --> 13:35:30,956
why did we go through the trouble to

20508
13:35:30,956 --> 13:35:34,080
store this guy in a result

20509
13:35:34,080 --> 13:35:36,560
why don't we use htr

20510
13:35:36,560 --> 13:35:38,560
in the first place in here

20511
13:35:38,560 --> 13:35:40,880
and the explanation i can come up with

20512
13:35:40,880 --> 13:35:43,680
is that you don't really want to modify

20513
13:35:43,680 --> 13:35:45,360
this guy here because somebody is going

20514
13:35:45,360 --> 13:35:47,200
to look at this thing and say

20515
13:35:47,200 --> 13:35:50,240
this is the message i have in sdr here

20516
13:35:50,240 --> 13:35:52,320
but if you try and modify this in the

20517
13:35:52,320 --> 13:35:53,916
loop it's going to be messed up because

20518
13:35:53,916 --> 13:35:55,520
you're going to be incrementing it and

20519
13:35:55,520 --> 13:35:57,436
doing all kinds of crazy things on it so

20520
13:35:57,436 --> 13:36:00,080
you don't really want to modify this so

20521
13:36:00,080 --> 13:36:02,956
a better way to even do this is to mark

20522
13:36:02,956 --> 13:36:05,436
this as a const pointer and we know how

20523
13:36:05,436 --> 13:36:08,000
to do that so we can say cost here and

20524
13:36:08,000 --> 13:36:10,560
if you even try to increment htr

20525
13:36:10,560 --> 13:36:12,720
somewhere you're going to get a compiler

20526
13:36:12,720 --> 13:36:13,680
error

20527
13:36:13,680 --> 13:36:16,080
so let's make sure we see that for

20528
13:36:16,080 --> 13:36:19,200
example we try and do plus plus sdr

20529
13:36:19,200 --> 13:36:20,560
we're going to get a compiler error

20530
13:36:20,560 --> 13:36:22,956
because this is a const pointer by now

20531
13:36:22,956 --> 13:36:25,200
and this is much safer

20532
13:36:25,200 --> 13:36:26,400
okay

20533
13:36:26,400 --> 13:36:28,080
we're going to comment this out and show

20534
13:36:28,080 --> 13:36:31,200
you something that might throw off many

20535
13:36:31,200 --> 13:36:32,880
of you guys so we're going to comment

20536
13:36:32,880 --> 13:36:35,756
this out and i am going to bring that in

20537
13:36:35,756 --> 13:36:38,000
okay let's go down here

20538
13:36:38,000 --> 13:36:39,840
and we are going to do basically the

20539
13:36:39,840 --> 13:36:41,116
same thing

20540
13:36:41,116 --> 13:36:43,200
but we will try

20541
13:36:43,200 --> 13:36:46,720
and use str in the first place here

20542
13:36:46,720 --> 13:36:48,240
okay this is how we're going to do this

20543
13:36:48,240 --> 13:36:50,240
we're going to have our string we're

20544
13:36:50,240 --> 13:36:51,680
going to have our target we're going to

20545
13:36:51,680 --> 13:36:53,596
have our result here which is equal to

20546
13:36:53,596 --> 13:36:56,320
null pointer and we have our iterations

20547
13:36:56,320 --> 13:36:58,160
which is an integer let's make this a

20548
13:36:58,160 --> 13:37:00,240
size t and what we're going to do in

20549
13:37:00,240 --> 13:37:03,916
here we're going to use htr to search

20550
13:37:03,916 --> 13:37:06,240
okay and we're going to basically do the

20551
13:37:06,240 --> 13:37:08,320
same checks we're going to jump in here

20552
13:37:08,320 --> 13:37:10,800
and say we found the target starting at

20553
13:37:10,800 --> 13:37:13,756
result and we're going to increment hdr

20554
13:37:13,756 --> 13:37:16,800
here because it is not a constrainer now

20555
13:37:16,800 --> 13:37:18,800
try to go through this thing here and

20556
13:37:18,800 --> 13:37:21,596
see how many times you're going to loop

20557
13:37:21,596 --> 13:37:24,956
okay go through it and when you are done

20558
13:37:24,956 --> 13:37:26,956
we're going to try and run this we're

20559
13:37:26,956 --> 13:37:28,880
going to build with gcc the build is

20560
13:37:28,880 --> 13:37:31,840
going to be good we are going to clear

20561
13:37:31,840 --> 13:37:34,720
and run rooster and you see that this

20562
13:37:34,720 --> 13:37:37,200
guy is going to look 25 times

20563
13:37:37,200 --> 13:37:39,596
and this is crazy why is this happening

20564
13:37:39,596 --> 13:37:41,436
why is this happening

20565
13:37:41,436 --> 13:37:44,640
what we really are doing here we are not

20566
13:37:44,640 --> 13:37:48,240
assigning the result in this trend that

20567
13:37:48,240 --> 13:37:49,916
we are searching at

20568
13:37:49,916 --> 13:37:51,596
okay let's try and go through this a

20569
13:37:51,596 --> 13:37:53,756
couple of times so the first time we're

20570
13:37:53,756 --> 13:37:56,240
going to do our search okay so we're

20571
13:37:56,240 --> 13:37:58,480
going to search in sdr

20572
13:37:58,480 --> 13:38:01,276
and if we find our target we're going to

20573
13:38:01,276 --> 13:38:03,916
return the pointer to the target

20574
13:38:03,916 --> 13:38:05,116
if we don't find it we're going to

20575
13:38:05,116 --> 13:38:07,040
return a null pointer the first time

20576
13:38:07,040 --> 13:38:09,200
we're going to find this t here okay and

20577
13:38:09,200 --> 13:38:10,640
we're going to return a pointer to it

20578
13:38:10,640 --> 13:38:13,040
and store that in result

20579
13:38:13,040 --> 13:38:15,436
okay so after we do this we're going to

20580
13:38:15,436 --> 13:38:17,360
fall in our body here

20581
13:38:17,360 --> 13:38:19,040
and we're going to say we found t

20582
13:38:19,040 --> 13:38:21,276
starting at this location here that's

20583
13:38:21,276 --> 13:38:23,116
going to work and we're going to

20584
13:38:23,116 --> 13:38:27,040
implement str okay notice that we're not

20585
13:38:27,040 --> 13:38:29,200
incrementing result here

20586
13:38:29,200 --> 13:38:31,916
if we increment sdr it's going to point

20587
13:38:31,916 --> 13:38:34,480
to the next character which is r here

20588
13:38:34,480 --> 13:38:35,596
okay

20589
13:38:35,596 --> 13:38:36,880
and we're going to increment our

20590
13:38:36,880 --> 13:38:38,320
iterations and we're going to start in

20591
13:38:38,320 --> 13:38:39,436
loop again

20592
13:38:39,436 --> 13:38:41,436
we're going to search in here

20593
13:38:41,436 --> 13:38:43,116
and we're going to be searching from

20594
13:38:43,116 --> 13:38:44,800
this location here

20595
13:38:44,800 --> 13:38:46,560
and we're going to find the t starting

20596
13:38:46,560 --> 13:38:48,480
at this location we are going to find

20597
13:38:48,480 --> 13:38:50,640
this t here and we're going to

20598
13:38:50,640 --> 13:38:53,200
return that and store that in reserved

20599
13:38:53,200 --> 13:38:55,360
but the problem is that what we are

20600
13:38:55,360 --> 13:38:58,160
incrementing here but the problem here

20601
13:38:58,160 --> 13:39:00,560
is that we are incrementing one by one

20602
13:39:00,560 --> 13:39:03,680
we are not jumping to this t here and we

20603
13:39:03,680 --> 13:39:06,000
had a way to jump to this t

20604
13:39:06,000 --> 13:39:09,200
by assigning the result into the same

20605
13:39:09,200 --> 13:39:11,040
variable that we are searching in okay

20606
13:39:11,040 --> 13:39:13,680
so this is going to loop 25 times and it

20607
13:39:13,680 --> 13:39:16,400
is not really good and some of you might

20608
13:39:16,400 --> 13:39:18,320
try to set up something like this and it

20609
13:39:18,320 --> 13:39:20,720
is really not going to be good try to go

20610
13:39:20,720 --> 13:39:22,000
through this and you're going to see the

20611
13:39:22,000 --> 13:39:25,520
reason why it is looping 25 times okay i

20612
13:39:25,520 --> 13:39:27,276
wanted you to see this don't do

20613
13:39:27,276 --> 13:39:28,956
something like this and we are going to

20614
13:39:28,956 --> 13:39:30,480
comment this out the next thing we're

20615
13:39:30,480 --> 13:39:32,880
going to see is how we can find the last

20616
13:39:32,880 --> 13:39:35,040
occurrence of the character and this is

20617
13:39:35,040 --> 13:39:37,040
a really cool example i like it it is

20618
13:39:37,040 --> 13:39:39,756
going to do something very practical we

20619
13:39:39,756 --> 13:39:41,680
are going to take a path which is going

20620
13:39:41,680 --> 13:39:43,756
to be an array basically stored in this

20621
13:39:43,756 --> 13:39:46,240
input array and we're going to strip off

20622
13:39:46,240 --> 13:39:47,756
all the things we don't need and we're

20623
13:39:47,756 --> 13:39:50,400
going to hunt down for the file name

20624
13:39:50,400 --> 13:39:53,040
from a full path and this can be useful

20625
13:39:53,040 --> 13:39:55,520
in whatever application you are doing so

20626
13:39:55,520 --> 13:39:57,436
we are going to hunt for the last

20627
13:39:57,436 --> 13:40:00,160
occurrence of a backslash character

20628
13:40:00,160 --> 13:40:03,116
using the str or

20629
13:40:03,116 --> 13:40:06,080
chr facility in the ziploc squad

20630
13:40:06,080 --> 13:40:08,080
standard library and you can find the

20631
13:40:08,080 --> 13:40:09,916
documentation on this guy here i'm not

20632
13:40:09,916 --> 13:40:11,436
going to go there you should really

20633
13:40:11,436 --> 13:40:13,756
practice to go there and read what these

20634
13:40:13,756 --> 13:40:16,160
things do that's why i am living in the

20635
13:40:16,160 --> 13:40:18,000
lens to the documentation you should go

20636
13:40:18,000 --> 13:40:20,000
there and read and if you have a problem

20637
13:40:20,000 --> 13:40:22,320
you can ask me i will do the best i can

20638
13:40:22,320 --> 13:40:24,000
to help you out

20639
13:40:24,000 --> 13:40:26,160
so this line here is going to hunt for

20640
13:40:26,160 --> 13:40:27,276
the last

20641
13:40:27,276 --> 13:40:29,276
backslash it's going to find this guy

20642
13:40:29,276 --> 13:40:31,116
here and we're going to store a pointer

20643
13:40:31,116 --> 13:40:33,680
to that in our output character pointer

20644
13:40:33,680 --> 13:40:35,756
here after we do that we're going to say

20645
13:40:35,756 --> 13:40:38,400
if we found something useful if this is

20646
13:40:38,400 --> 13:40:40,560
not no pointer we're going to print that

20647
13:40:40,560 --> 13:40:42,880
out but we don't want to print starting

20648
13:40:42,880 --> 13:40:44,880
from the backslash we are going to use

20649
13:40:44,880 --> 13:40:47,040
pointer arithmetic and move to the next

20650
13:40:47,040 --> 13:40:49,200
character which is going to be this h

20651
13:40:49,200 --> 13:40:51,360
here so if we print this out we're going

20652
13:40:51,360 --> 13:40:54,080
to have hello cpp printed out because

20653
13:40:54,080 --> 13:40:56,800
sddc out is going to print until it

20654
13:40:56,800 --> 13:40:57,680
meets

20655
13:40:57,680 --> 13:41:00,320
the last now character and that's going

20656
13:41:00,320 --> 13:41:03,040
to be after the last p here because this

20657
13:41:03,040 --> 13:41:05,680
is a c string let's roll here okay we're

20658
13:41:05,680 --> 13:41:07,276
going to build this the build is going

20659
13:41:07,276 --> 13:41:09,756
to be good we're going to clear

20660
13:41:09,756 --> 13:41:11,436
and run rooster and you're going to see

20661
13:41:11,436 --> 13:41:13,756
that we have hello cpp

20662
13:41:13,756 --> 13:41:15,916
printed out here okay this is really all

20663
13:41:15,916 --> 13:41:17,596
we set out to do in this lecture i

20664
13:41:17,596 --> 13:41:19,596
apologize that it turned out to be

20665
13:41:19,596 --> 13:41:22,000
lengthy these things can take long to

20666
13:41:22,000 --> 13:41:24,160
explain and i really wanted you guys to

20667
13:41:24,160 --> 13:41:27,520
have as many explanations as i could

20668
13:41:27,520 --> 13:41:28,720
come up with

20669
13:41:28,720 --> 13:41:30,240
we are going to stop here in this

20670
13:41:30,240 --> 13:41:31,916
lecture the next one we're going to see

20671
13:41:31,916 --> 13:41:34,880
how we can copy and concatenate

20672
13:41:34,880 --> 13:41:38,080
c strings using the facilities from c

20673
13:41:38,080 --> 13:41:41,040
string here go ahead and finish up here

20674
13:41:41,040 --> 13:41:42,560
and meet me there

20675
13:41:42,560 --> 13:41:44,720
in this lecture we're going to look at

20676
13:41:44,720 --> 13:41:47,436
a few more facilities from the c string

20677
13:41:47,436 --> 13:41:50,240
library and those are going to allow us

20678
13:41:50,240 --> 13:41:53,116
to concatenate and copy strings over the

20679
13:41:53,116 --> 13:41:54,956
documentation for what we're going to be

20680
13:41:54,956 --> 13:41:57,116
talking about can be found here if you

20681
13:41:57,116 --> 13:41:58,880
go there you're going to fall on this

20682
13:41:58,880 --> 13:42:00,640
link here and you're going to

20683
13:42:00,640 --> 13:42:03,436
find that c string was originally in the

20684
13:42:03,436 --> 13:42:07,040
c standard library as string dot h but

20685
13:42:07,040 --> 13:42:10,160
in c plus plus we can use it like this

20686
13:42:10,160 --> 13:42:11,756
we have a couple of functions we can

20687
13:42:11,756 --> 13:42:14,720
copy stuff we can concatenate we can get

20688
13:42:14,720 --> 13:42:17,040
the string length we have seen this but

20689
13:42:17,040 --> 13:42:18,956
now we're going to look at things that

20690
13:42:18,956 --> 13:42:21,756
allow us to copy and concatenate stuff

20691
13:42:21,756 --> 13:42:22,640
because

20692
13:42:22,640 --> 13:42:24,720
that's something you may want to do a

20693
13:42:24,720 --> 13:42:26,240
lot the first example we're going to

20694
13:42:26,240 --> 13:42:27,560
look at is

20695
13:42:27,560 --> 13:42:30,560
stdstr cat which is going to allow you

20696
13:42:30,560 --> 13:42:32,400
to join strengths

20697
13:42:32,400 --> 13:42:34,160
again you can browse to the

20698
13:42:34,160 --> 13:42:36,080
documentation here and see more about

20699
13:42:36,080 --> 13:42:38,480
this facility here and you're going to

20700
13:42:38,480 --> 13:42:40,640
see all about it for now we're just

20701
13:42:40,640 --> 13:42:42,000
going to play with it we're going to set

20702
13:42:42,000 --> 13:42:44,560
up two arrays one is going to be called

20703
13:42:44,560 --> 13:42:45,520
dest

20704
13:42:45,520 --> 13:42:47,840
it's going to contain hello the other is

20705
13:42:47,840 --> 13:42:49,276
going to be source here and it's going

20706
13:42:49,276 --> 13:42:51,596
to contain worlds notice that these are

20707
13:42:51,596 --> 13:42:54,480
row static arrays that are stored on the

20708
13:42:54,480 --> 13:42:55,436
snap

20709
13:42:55,436 --> 13:42:57,756
and uh that's how we set them up here

20710
13:42:57,756 --> 13:42:59,916
okay so we can concatenate strengths

20711
13:42:59,916 --> 13:43:02,160
using the syntax like this we're going

20712
13:43:02,160 --> 13:43:04,956
to say hdd hdr cache we're going to say

20713
13:43:04,956 --> 13:43:07,116
the destination string and we're going

20714
13:43:07,116 --> 13:43:09,276
to say the source string we want to copy

20715
13:43:09,276 --> 13:43:11,360
from okay so after we do this the

20716
13:43:11,360 --> 13:43:13,680
destination is going to contain

20717
13:43:13,680 --> 13:43:16,956
these two strings joined together and

20718
13:43:16,956 --> 13:43:19,596
before you do this you have to be sure

20719
13:43:19,596 --> 13:43:22,000
that your destination strength is big

20720
13:43:22,000 --> 13:43:24,560
enough and this is a problem because you

20721
13:43:24,560 --> 13:43:26,480
have to really keep track of your

20722
13:43:26,480 --> 13:43:29,116
destination strength and it is easy to

20723
13:43:29,116 --> 13:43:31,680
put in many more characters that can

20724
13:43:31,680 --> 13:43:34,160
really fit in the destinations rank

20725
13:43:34,160 --> 13:43:36,000
that's the reason many of these

20726
13:43:36,000 --> 13:43:38,480
functions here are considered unsafe by

20727
13:43:38,480 --> 13:43:40,560
many compilers i don't think you can

20728
13:43:40,560 --> 13:43:42,560
compile this on visual studio it's going

20729
13:43:42,560 --> 13:43:45,040
to stop you from doing this because of

20730
13:43:45,040 --> 13:43:46,160
this

20731
13:43:46,160 --> 13:43:47,116
way

20732
13:43:47,116 --> 13:43:48,880
you have to keep track of things

20733
13:43:48,880 --> 13:43:51,276
yourself but i am just showing you so

20734
13:43:51,276 --> 13:43:53,680
that you know how to avoid these

20735
13:43:53,680 --> 13:43:55,436
problems if you happen to be on a

20736
13:43:55,436 --> 13:43:57,596
compiler that doesn't protect you from

20737
13:43:57,596 --> 13:43:59,596
this so we're going to append goodbye

20738
13:43:59,596 --> 13:44:02,480
world to whatever is in dust and down

20739
13:44:02,480 --> 13:44:04,240
here if we print this we're going to

20740
13:44:04,240 --> 13:44:06,720
have hello world goodbye world printed

20741
13:44:06,720 --> 13:44:08,480
out we are going to play with this in a

20742
13:44:08,480 --> 13:44:10,240
visual studio code in a minute don't

20743
13:44:10,240 --> 13:44:13,116
worry if any of this doesn't make sense

20744
13:44:13,116 --> 13:44:15,116
yet here is another example of how we

20745
13:44:15,116 --> 13:44:18,640
can join strengths through strcat

20746
13:44:18,640 --> 13:44:20,956
we have two strengths and we set them up

20747
13:44:20,956 --> 13:44:22,956
with a simple characters like this you

20748
13:44:22,956 --> 13:44:25,756
can do this and put in your own now

20749
13:44:25,756 --> 13:44:28,000
terminating character this is a legal c

20750
13:44:28,000 --> 13:44:30,320
plus plus could and notice that this

20751
13:44:30,320 --> 13:44:32,560
array is a dynamic array it's going to

20752
13:44:32,560 --> 13:44:34,560
leave on the hip because of this new

20753
13:44:34,560 --> 13:44:37,200
operator here we also have a source

20754
13:44:37,200 --> 13:44:39,116
array which is also going to leave on

20755
13:44:39,116 --> 13:44:42,000
the hip it is 30 characters long so it

20756
13:44:42,000 --> 13:44:44,400
is really long and we're going to try

20757
13:44:44,400 --> 13:44:46,640
and concatenate stance here but before

20758
13:44:46,640 --> 13:44:48,080
we do that we're going to check their

20759
13:44:48,080 --> 13:44:50,080
length we're going to print them out and

20760
13:44:50,080 --> 13:44:52,240
we are going to concatenate the syntax

20761
13:44:52,240 --> 13:44:55,040
is the same you are going to say hdr cat

20762
13:44:55,040 --> 13:44:57,436
you're going to specify your destination

20763
13:44:57,436 --> 13:44:58,800
and your source you're going to be

20764
13:44:58,800 --> 13:45:01,436
copying stuff from and you are going to

20765
13:45:01,436 --> 13:45:03,840
store the result in destination here

20766
13:45:03,840 --> 13:45:05,360
what this is going to do it's going to

20767
13:45:05,360 --> 13:45:08,160
grab whatever is in source and copy it

20768
13:45:08,160 --> 13:45:09,840
so it's going to copy the entire thing

20769
13:45:09,840 --> 13:45:11,916
here from source and it's going to

20770
13:45:11,916 --> 13:45:13,680
append that to whatever we have in

20771
13:45:13,680 --> 13:45:17,276
destination starting from the last null

20772
13:45:17,276 --> 13:45:19,116
character here so it's going to

20773
13:45:19,116 --> 13:45:21,520
overwrite from this null character and

20774
13:45:21,520 --> 13:45:23,916
it's going to basically copy everything

20775
13:45:23,916 --> 13:45:26,400
and the destination here and if we print

20776
13:45:26,400 --> 13:45:28,080
whatever we have in destination here

20777
13:45:28,080 --> 13:45:30,240
we're going to have firelord

20778
13:45:30,240 --> 13:45:32,160
the phoenix kind of printed out and

20779
13:45:32,160 --> 13:45:33,520
you're going to see that this is going

20780
13:45:33,520 --> 13:45:36,080
to be the case when we hit visual studio

20781
13:45:36,080 --> 13:45:37,840
code in a minute you can also use a

20782
13:45:37,840 --> 13:45:40,720
version of the sdr cat version that is

20783
13:45:40,720 --> 13:45:42,800
going to allow you to specify

20784
13:45:42,800 --> 13:45:45,756
how many characters you want to

20785
13:45:45,756 --> 13:45:48,240
concatenate from the source string in

20786
13:45:48,240 --> 13:45:50,000
this case we have destination which is

20787
13:45:50,000 --> 13:45:51,840
hello and we have source which is there

20788
13:45:51,840 --> 13:45:53,596
is a bird

20789
13:45:53,596 --> 13:45:55,040
on my window

20790
13:45:55,040 --> 13:45:58,320
and down here you see that we do hdr and

20791
13:45:58,320 --> 13:46:00,400
cat we save the destination we save the

20792
13:46:00,400 --> 13:46:03,040
source and we say how many characters we

20793
13:46:03,040 --> 13:46:06,320
want copied from the source here and we

20794
13:46:06,320 --> 13:46:08,480
say six characters so we are going to

20795
13:46:08,480 --> 13:46:10,080
count from the source we're going to say

20796
13:46:10,080 --> 13:46:12,560
one two three four five six we're going

20797
13:46:12,560 --> 13:46:14,880
to grab this their string with this

20798
13:46:14,880 --> 13:46:17,116
space here and we're going to append

20799
13:46:17,116 --> 13:46:18,956
that to the source and that's what we're

20800
13:46:18,956 --> 13:46:21,520
going to get in here we're going to say

20801
13:46:21,520 --> 13:46:24,080
hello space and there and that's what

20802
13:46:24,080 --> 13:46:26,240
we're going to have printed out here if

20803
13:46:26,240 --> 13:46:29,276
we print dust we can also copy stuff and

20804
13:46:29,276 --> 13:46:32,240
the str cpy function here is going to do

20805
13:46:32,240 --> 13:46:34,160
that and here we have an example that is

20806
13:46:34,160 --> 13:46:37,680
going to try and drive this home for you

20807
13:46:37,680 --> 13:46:39,520
we have a source strength which is c

20808
13:46:39,520 --> 13:46:41,756
plus plus is a multi-purpose programming

20809
13:46:41,756 --> 13:46:44,000
language okay guest three here is going

20810
13:46:44,000 --> 13:46:46,080
to be the same length as the source we

20811
13:46:46,080 --> 13:46:48,720
made sure of that in here because we're

20812
13:46:48,720 --> 13:46:50,880
going to grab the length of the source

20813
13:46:50,880 --> 13:46:53,436
strength please remember that sdrlam is

20814
13:46:53,436 --> 13:46:54,880
not going to count

20815
13:46:54,880 --> 13:46:57,436
the null character that's why we are

20816
13:46:57,436 --> 13:46:59,680
adding a one here to account for the

20817
13:46:59,680 --> 13:47:01,916
noun terminating character here okay

20818
13:47:01,916 --> 13:47:03,680
after that we're going to jump down here

20819
13:47:03,680 --> 13:47:07,916
and say htr cpy dest 3 and source 3 we

20820
13:47:07,916 --> 13:47:10,320
are basically going to be copying from

20821
13:47:10,320 --> 13:47:12,400
source and pasting

20822
13:47:12,400 --> 13:47:14,160
in destination here that's what we are

20823
13:47:14,160 --> 13:47:16,480
doing if we print destination we're

20824
13:47:16,480 --> 13:47:17,916
going to see that now it's going to

20825
13:47:17,916 --> 13:47:20,800
contain whatever we had in source and

20826
13:47:20,800 --> 13:47:22,720
this is how you can use these methods

20827
13:47:22,720 --> 13:47:25,040
here we also have a version

20828
13:47:25,040 --> 13:47:27,276
with which we can specify how many

20829
13:47:27,276 --> 13:47:29,116
characters we want copied from the

20830
13:47:29,116 --> 13:47:31,520
source here we have a source string

20831
13:47:31,520 --> 13:47:33,756
which is hello we have a destination

20832
13:47:33,756 --> 13:47:36,480
string which is zest 4 and we are going

20833
13:47:36,480 --> 13:47:38,320
to copy stuff we're going to copy from

20834
13:47:38,320 --> 13:47:40,480
the source we're going to paste in the

20835
13:47:40,480 --> 13:47:42,560
destination and we are just going to

20836
13:47:42,560 --> 13:47:45,520
copy five characters what this is going

20837
13:47:45,520 --> 13:47:48,080
to do is copy everything from the source

20838
13:47:48,080 --> 13:47:51,276
and paste in our destination and it is

20839
13:47:51,276 --> 13:47:54,160
going to override whatever we have in

20840
13:47:54,160 --> 13:47:57,040
the starting indexes in destination here

20841
13:47:57,040 --> 13:47:59,840
so we're going to have a b c d e here

20842
13:47:59,840 --> 13:48:02,956
replaced by hello and if we print this

20843
13:48:02,956 --> 13:48:05,680
here we're going to have hello f printed

20844
13:48:05,680 --> 13:48:08,080
out this is how these things work and if

20845
13:48:08,080 --> 13:48:10,320
you wonder how i know how these things

20846
13:48:10,320 --> 13:48:12,640
work i just come and read the

20847
13:48:12,640 --> 13:48:15,360
documentation here for example htr and

20848
13:48:15,360 --> 13:48:17,680
cpy here if we click on it we are going

20849
13:48:17,680 --> 13:48:19,520
to get the documentation this is going

20850
13:48:19,520 --> 13:48:22,240
to say copies at most count characters

20851
13:48:22,240 --> 13:48:23,916
of the byte string

20852
13:48:23,916 --> 13:48:26,480
source including the null terminating

20853
13:48:26,480 --> 13:48:28,800
character to the character array pointed

20854
13:48:28,800 --> 13:48:30,880
to by desk that's what it does we have

20855
13:48:30,880 --> 13:48:33,040
the destination we have the source and

20856
13:48:33,040 --> 13:48:34,720
we have how many characters we want

20857
13:48:34,720 --> 13:48:36,720
copied and they say a few things you

20858
13:48:36,720 --> 13:48:38,800
need to be careful about this guy here

20859
13:48:38,800 --> 13:48:41,596
one thing that you usually care about is

20860
13:48:41,596 --> 13:48:43,436
the return value you see that the return

20861
13:48:43,436 --> 13:48:45,596
value is going to be the destination

20862
13:48:45,596 --> 13:48:47,756
strength so if you want this pointer you

20863
13:48:47,756 --> 13:48:50,080
can use it and you can go down and look

20864
13:48:50,080 --> 13:48:52,800
at a few examples here and play with

20865
13:48:52,800 --> 13:48:55,276
them to really drive the point home okay

20866
13:48:55,276 --> 13:48:57,276
now that you have an idea about how

20867
13:48:57,276 --> 13:48:59,436
these guys work we are going to head

20868
13:48:59,436 --> 13:49:02,000
over to visual studio code and play with

20869
13:49:02,000 --> 13:49:02,880
them

20870
13:49:02,880 --> 13:49:05,276
right away okay here we are in our

20871
13:49:05,276 --> 13:49:08,320
working folder the current project is c

20872
13:49:08,320 --> 13:49:10,560
string concatenation and copy that's

20873
13:49:10,560 --> 13:49:12,400
what we are doing here we're going to

20874
13:49:12,400 --> 13:49:15,360
copy our template files and uh jump to

20875
13:49:15,360 --> 13:49:18,160
our current project and put them in

20876
13:49:18,160 --> 13:49:20,800
place we're going to open this in visual

20877
13:49:20,800 --> 13:49:22,880
studio code pretty quick we are going to

20878
13:49:22,880 --> 13:49:24,640
include c string because that's what

20879
13:49:24,640 --> 13:49:26,400
we're going to be using here we are

20880
13:49:26,400 --> 13:49:28,400
going to bring this up a little bit and

20881
13:49:28,400 --> 13:49:30,560
we are going to put in our first example

20882
13:49:30,560 --> 13:49:32,800
here we have two strengths

20883
13:49:32,800 --> 13:49:35,200
destination and source and you see that

20884
13:49:35,200 --> 13:49:37,520
we tried and made sure that they are

20885
13:49:37,520 --> 13:49:39,916
large enough to contain however many

20886
13:49:39,916 --> 13:49:42,080
characters we want to put in

20887
13:49:42,080 --> 13:49:44,640
and they are row arrays stored on the

20888
13:49:44,640 --> 13:49:47,756
stack because they are set up like this

20889
13:49:47,756 --> 13:49:49,200
and again you can check out the

20890
13:49:49,200 --> 13:49:51,200
documentation here if you want to know

20891
13:49:51,200 --> 13:49:53,360
how this function works and we are going

20892
13:49:53,360 --> 13:49:57,756
to call strcat here to concatenate the

20893
13:49:57,756 --> 13:50:00,560
source to our destination here so if we

20894
13:50:00,560 --> 13:50:02,756
do this we're going to have world here

20895
13:50:02,756 --> 13:50:05,756
concatenated to what we have in hello

20896
13:50:05,756 --> 13:50:07,916
here and we're going to have hello world

20897
13:50:07,916 --> 13:50:10,480
in place for example if we try and print

20898
13:50:10,480 --> 13:50:13,756
this out i'm going to try and do that

20899
13:50:13,756 --> 13:50:16,160
after we do the first concatenation here

20900
13:50:16,160 --> 13:50:18,320
let's do that that's going to be better

20901
13:50:18,320 --> 13:50:20,880
to show you how these things work okay

20902
13:50:20,880 --> 13:50:23,116
after the first function here runs we're

20903
13:50:23,116 --> 13:50:26,400
going to have source concatenated to

20904
13:50:26,400 --> 13:50:28,640
destination here so what we're going to

20905
13:50:28,640 --> 13:50:30,880
have is hello world stored in

20906
13:50:30,880 --> 13:50:32,560
destination here the second

20907
13:50:32,560 --> 13:50:34,720
concatenation here is going to append

20908
13:50:34,720 --> 13:50:37,360
goodbye world to whatever we have in

20909
13:50:37,360 --> 13:50:39,436
destination here so what we're going to

20910
13:50:39,436 --> 13:50:42,560
have printed down is if we print that of

20911
13:50:42,560 --> 13:50:44,956
course is hello world and goodbye world

20912
13:50:44,956 --> 13:50:46,400
okay we're going to have this written

20913
13:50:46,400 --> 13:50:49,040
down let's try and run this and actually

20914
13:50:49,040 --> 13:50:51,520
make sure that that's the case and then

20915
13:50:51,520 --> 13:50:53,520
we're going to see how this function can

20916
13:50:53,520 --> 13:50:56,160
be unsafe for some compilers we're going

20917
13:50:56,160 --> 13:50:58,240
to build this with gcc you see that it's

20918
13:50:58,240 --> 13:51:00,240
going to go through

20919
13:51:00,240 --> 13:51:01,840
and if we run this we're going to have

20920
13:51:01,840 --> 13:51:04,320
hello world hello world goodbye world

20921
13:51:04,320 --> 13:51:06,880
printed out this is what we expect and

20922
13:51:06,880 --> 13:51:07,756
again

20923
13:51:07,756 --> 13:51:10,240
this function here sdr cat is going to

20924
13:51:10,240 --> 13:51:12,480
have whatever you have in source and it

20925
13:51:12,480 --> 13:51:14,640
is going to append that to whatever you

20926
13:51:14,640 --> 13:51:17,200
have in destination and for this to work

20927
13:51:17,200 --> 13:51:19,360
you have to be sure that the destination

20928
13:51:19,360 --> 13:51:22,640
is modifiable for example if it was an

20929
13:51:22,640 --> 13:51:25,276
array of cost core let's do that and

20930
13:51:25,276 --> 13:51:27,040
show you the compiler error we should

20931
13:51:27,040 --> 13:51:29,680
get a compiler error because now

20932
13:51:29,680 --> 13:51:32,320
destination is not modifiable it is an

20933
13:51:32,320 --> 13:51:34,956
array of cost characters and we can't

20934
13:51:34,956 --> 13:51:37,596
modify it so be sure

20935
13:51:37,596 --> 13:51:40,560
the destination array is modifiable and

20936
13:51:40,560 --> 13:51:42,720
in this case it is okay please note that

20937
13:51:42,720 --> 13:51:44,480
some of these functions can be treated

20938
13:51:44,480 --> 13:51:47,680
as unsafe by some compilers but i tried

20939
13:51:47,680 --> 13:51:50,720
this out on both on gcc and the compiler

20940
13:51:50,720 --> 13:51:52,956
from microsoft and they work pretty well

20941
13:51:52,956 --> 13:51:54,956
so you can try them out here to prove

20942
13:51:54,956 --> 13:51:57,360
that let's go and try and build with the

20943
13:51:57,360 --> 13:51:59,916
compiler from microsoft we have it

20944
13:51:59,916 --> 13:52:01,276
set up here

20945
13:52:01,276 --> 13:52:02,956
so we're going to run the task to build

20946
13:52:02,956 --> 13:52:05,596
with msvc here

20947
13:52:05,596 --> 13:52:06,880
and you're going to see that the world

20948
13:52:06,880 --> 13:52:08,880
is going to be good the world finished

20949
13:52:08,880 --> 13:52:11,040
successfully and if we go and we're

20950
13:52:11,040 --> 13:52:12,560
going to clear

20951
13:52:12,560 --> 13:52:14,160
and run rooster you're going to see that

20952
13:52:14,160 --> 13:52:16,400
it is going to do exactly the same thing

20953
13:52:16,400 --> 13:52:18,160
but some compilers might give you

20954
13:52:18,160 --> 13:52:20,080
warnings or errors if you try to do

20955
13:52:20,080 --> 13:52:22,480
something like this and the reason is

20956
13:52:22,480 --> 13:52:24,160
you really have to be careful using

20957
13:52:24,160 --> 13:52:26,720
these functions because if for example

20958
13:52:26,720 --> 13:52:29,276
destination array is not large enough

20959
13:52:29,276 --> 13:52:32,000
you may do some crazy things running

20960
13:52:32,000 --> 13:52:33,840
over the balance of your array and it

20961
13:52:33,840 --> 13:52:36,480
can be really bad for example if we try

20962
13:52:36,480 --> 13:52:38,480
and make destination array here for

20963
13:52:38,480 --> 13:52:41,040
example a size of three it is possible

20964
13:52:41,040 --> 13:52:43,680
to do that and you see that we get a

20965
13:52:43,680 --> 13:52:46,800
warning from visual studio code and if

20966
13:52:46,800 --> 13:52:49,436
we try and build this with gcc let's try

20967
13:52:49,436 --> 13:52:51,520
and remove the garbage we have from

20968
13:52:51,520 --> 13:52:54,000
visual studio first now that this is

20969
13:52:54,000 --> 13:52:58,080
clean we can uh try and build with gcc

20970
13:52:58,080 --> 13:53:00,000
let's do that our compiler we're going

20971
13:53:00,000 --> 13:53:02,560
to choose gcc and you're going to see

20972
13:53:02,560 --> 13:53:03,840
that it's going to give you an error

20973
13:53:03,840 --> 13:53:05,756
it's going to actually protect us from

20974
13:53:05,756 --> 13:53:08,160
doing something like this but in some

20975
13:53:08,160 --> 13:53:10,160
cases some compilers are not going to

20976
13:53:10,160 --> 13:53:12,400
stop you from doing this but any

20977
13:53:12,400 --> 13:53:15,276
compiler that really respects itself

20978
13:53:15,276 --> 13:53:17,680
it's going to have these safety checks

20979
13:53:17,680 --> 13:53:19,360
in and it's going to protect you from

20980
13:53:19,360 --> 13:53:21,360
doing something crazy like this okay

20981
13:53:21,360 --> 13:53:23,680
this is how you can do concatenation

20982
13:53:23,680 --> 13:53:27,840
using hdr cat like we did here let's try

20983
13:53:27,840 --> 13:53:29,436
and weld and see that now we are

20984
13:53:29,436 --> 13:53:31,276
building fine because i don't like these

20985
13:53:31,276 --> 13:53:33,756
red lines here the world is good and we

20986
13:53:33,756 --> 13:53:36,000
are all fine now i am going to comment

20987
13:53:36,000 --> 13:53:37,276
this out

20988
13:53:37,276 --> 13:53:38,800
and we're going to see another example

20989
13:53:38,800 --> 13:53:41,436
of how we can concatenate stuff we are

20990
13:53:41,436 --> 13:53:43,276
going to go down here let's bring this

20991
13:53:43,276 --> 13:53:45,596
down and hide this

20992
13:53:45,596 --> 13:53:47,840
and we are going to put in our simple

20993
13:53:47,840 --> 13:53:49,916
example exactly the same thing we saw in

20994
13:53:49,916 --> 13:53:52,240
the slides we have two

20995
13:53:52,240 --> 13:53:55,116
character arrays they are dynamic arrays

20996
13:53:55,116 --> 13:53:57,756
but we initialize them with characters

20997
13:53:57,756 --> 13:54:00,000
like this and we make sure to put in our

20998
13:54:00,000 --> 13:54:00,880
null

20999
13:54:00,880 --> 13:54:03,200
terminator we have our source strength

21000
13:54:03,200 --> 13:54:05,276
which is going to say the

21001
13:54:05,276 --> 13:54:07,436
femix king and it's going to have a

21002
13:54:07,436 --> 13:54:08,956
terminator here

21003
13:54:08,956 --> 13:54:10,320
and what we're going to do we're going

21004
13:54:10,320 --> 13:54:13,276
to take soros and concatenate that to

21005
13:54:13,276 --> 13:54:15,520
our destination so what is really going

21006
13:54:15,520 --> 13:54:17,680
to happen we are going to overwrite the

21007
13:54:17,680 --> 13:54:19,680
null terminator here and we're going to

21008
13:54:19,680 --> 13:54:22,640
start pasting in things from source here

21009
13:54:22,640 --> 13:54:24,956
so after the concatenation is done what

21010
13:54:24,956 --> 13:54:27,360
we are doing here we are concatenating

21011
13:54:27,360 --> 13:54:29,596
source one to test one

21012
13:54:29,596 --> 13:54:32,400
we are going to have fire lord the

21013
13:54:32,400 --> 13:54:35,360
phoenix kang stored in our destination

21014
13:54:35,360 --> 13:54:36,480
string here

21015
13:54:36,480 --> 13:54:39,756
and notice that we made sure that

21016
13:54:39,756 --> 13:54:42,320
large enough to contain our characters

21017
13:54:42,320 --> 13:54:44,240
here and if we print it out we're going

21018
13:54:44,240 --> 13:54:46,880
to have the thing printed out we can try

21019
13:54:46,880 --> 13:54:49,596
and weld with gcc that's going to go

21020
13:54:49,596 --> 13:54:51,756
through let's bring this up the bulb is

21021
13:54:51,756 --> 13:54:52,640
good

21022
13:54:52,640 --> 13:54:54,800
if you go down here the build is good

21023
13:54:54,800 --> 13:54:57,596
we're going to clear and run rooster

21024
13:54:57,596 --> 13:54:59,276
okay this is the output here you see

21025
13:54:59,276 --> 13:55:01,840
that the destination is eight characters

21026
13:55:01,840 --> 13:55:05,276
long if we count one two three four five

21027
13:55:05,276 --> 13:55:08,080
six seven eight remember sdrl lan

21028
13:55:08,080 --> 13:55:10,320
doesn't count the null character so this

21029
13:55:10,320 --> 13:55:12,400
is what we expect eight characters the

21030
13:55:12,400 --> 13:55:14,560
source is going to be 17 characters if

21031
13:55:14,560 --> 13:55:16,000
you count all this that's what you're

21032
13:55:16,000 --> 13:55:17,200
going to get

21033
13:55:17,200 --> 13:55:19,840
and if we concatenate them now this

21034
13:55:19,840 --> 13:55:21,596
donation is going to be

21035
13:55:21,596 --> 13:55:24,000
25 characters long

21036
13:55:24,000 --> 13:55:26,956
in the eyes of hdr land and you see that

21037
13:55:26,956 --> 13:55:28,880
we print the destination and it is

21038
13:55:28,880 --> 13:55:31,596
exactly what we expect fire lord the

21039
13:55:31,596 --> 13:55:34,000
phoenix gang okay we're going to comment

21040
13:55:34,000 --> 13:55:35,596
this out i just wanted you to see an

21041
13:55:35,596 --> 13:55:37,596
example of this and the one thing i

21042
13:55:37,596 --> 13:55:40,400
really want to stress in this example

21043
13:55:40,400 --> 13:55:42,800
is that strcat is going to start

21044
13:55:42,800 --> 13:55:45,916
overriding whatever is in dust starting

21045
13:55:45,916 --> 13:55:49,756
at the last null character okay so this

21046
13:55:49,756 --> 13:55:52,240
guy is going to be overridden by the

21047
13:55:52,240 --> 13:55:54,160
comma here and we're going to start and

21048
13:55:54,160 --> 13:55:55,840
putting stuff and that's what we're

21049
13:55:55,840 --> 13:55:58,080
going to see here let's comment this out

21050
13:55:58,080 --> 13:56:00,160
because we want to move on and show you

21051
13:56:00,160 --> 13:56:02,240
a few other examples okay the next thing

21052
13:56:02,240 --> 13:56:04,640
we're going to look at is a new version

21053
13:56:04,640 --> 13:56:08,400
of str cat that allows you to specify

21054
13:56:08,400 --> 13:56:09,916
how many characters you want

21055
13:56:09,916 --> 13:56:11,436
concatenated

21056
13:56:11,436 --> 13:56:13,756
from source for example here we have two

21057
13:56:13,756 --> 13:56:16,640
strengths destination and source and

21058
13:56:16,640 --> 13:56:19,756
here we are basically saying i want to

21059
13:56:19,756 --> 13:56:22,880
concatenate six characters from source

21060
13:56:22,880 --> 13:56:24,640
and put them at the end of the

21061
13:56:24,640 --> 13:56:26,800
destination here and what it's going to

21062
13:56:26,800 --> 13:56:30,800
do it's going to grab one two three four

21063
13:56:30,800 --> 13:56:33,040
five six it's going to grab this entire

21064
13:56:33,040 --> 13:56:35,040
thing and it's going to append that to

21065
13:56:35,040 --> 13:56:37,200
hello and we're going to have hello

21066
13:56:37,200 --> 13:56:40,160
there stored in the destination and the

21067
13:56:40,160 --> 13:56:42,480
return value is going to be a pointer to

21068
13:56:42,480 --> 13:56:44,956
destination 2. and how do i know the

21069
13:56:44,956 --> 13:56:47,360
return value well i know that from the

21070
13:56:47,360 --> 13:56:50,080
documentation if you go in your favorite

21071
13:56:50,080 --> 13:56:51,880
search engine and do

21072
13:56:51,880 --> 13:56:54,956
stdstr and cat and you're going to see a

21073
13:56:54,956 --> 13:56:57,116
link here if you click on it from cpp

21074
13:56:57,116 --> 13:56:58,640
reference it's going to give you

21075
13:56:58,640 --> 13:57:00,160
everything you need to know about this

21076
13:57:00,160 --> 13:57:02,640
function here it's going to append

21077
13:57:02,640 --> 13:57:05,916
source to destination and and count

21078
13:57:05,916 --> 13:57:07,756
characters are going to be copied so the

21079
13:57:07,756 --> 13:57:09,520
third parameter here is going to be how

21080
13:57:09,520 --> 13:57:11,916
many characters you want copied and

21081
13:57:11,916 --> 13:57:14,560
pasted into our destination

21082
13:57:14,560 --> 13:57:16,640
and the return value is going to be dest

21083
13:57:16,640 --> 13:57:18,320
okay if we try this out we're going to

21084
13:57:18,320 --> 13:57:20,480
see hello there printed out we're going

21085
13:57:20,480 --> 13:57:22,160
to print it out directly and we're going

21086
13:57:22,160 --> 13:57:24,240
to print that out

21087
13:57:24,240 --> 13:57:26,956
using the destination pointer that is

21088
13:57:26,956 --> 13:57:29,040
going to be returned from this guy here

21089
13:57:29,040 --> 13:57:30,956
so if we try and build this we're going

21090
13:57:30,956 --> 13:57:33,436
to build with gcc the bullet is going to

21091
13:57:33,436 --> 13:57:35,756
be good we're going to clear and run

21092
13:57:35,756 --> 13:57:37,040
rooster and you're going to see that we

21093
13:57:37,040 --> 13:57:39,436
have hello there twice here and this is

21094
13:57:39,436 --> 13:57:41,436
exactly what we expect

21095
13:57:41,436 --> 13:57:43,436
we are going to comment this out and we

21096
13:57:43,436 --> 13:57:48,000
are going to go down and look at sdr cpi

21097
13:57:48,000 --> 13:57:51,040
i should say sdr cpy which is going to

21098
13:57:51,040 --> 13:57:53,596
copy stuff from the source and paste

21099
13:57:53,596 --> 13:57:57,040
those in the destination and one thing

21100
13:57:57,040 --> 13:57:59,200
you should know is that the copy is

21101
13:57:59,200 --> 13:58:01,276
going to happen starting from the start

21102
13:58:01,276 --> 13:58:03,596
of the destination array here we have

21103
13:58:03,596 --> 13:58:06,000
two arrays one is called source three

21104
13:58:06,000 --> 13:58:08,560
the other is called destination three

21105
13:58:08,560 --> 13:58:11,116
destination 3 is set up on the heap

21106
13:58:11,116 --> 13:58:12,880
using the new operator so it is a

21107
13:58:12,880 --> 13:58:15,276
dynamic array and you see that we make

21108
13:58:15,276 --> 13:58:17,520
sure that it is the same size as the

21109
13:58:17,520 --> 13:58:18,640
source

21110
13:58:18,640 --> 13:58:21,276
we are using sdr lan to figure out how

21111
13:58:21,276 --> 13:58:23,436
many characters we have in here

21112
13:58:23,436 --> 13:58:26,160
and remember that sdr land doesn't

21113
13:58:26,160 --> 13:58:28,240
account for the null character so we are

21114
13:58:28,240 --> 13:58:30,720
adding one to account for the null

21115
13:58:30,720 --> 13:58:32,640
character that's what we are doing here

21116
13:58:32,640 --> 13:58:34,560
and after that we are going to do std

21117
13:58:34,560 --> 13:58:38,160
str cpy and what that is going to do is

21118
13:58:38,160 --> 13:58:41,276
copy stuff from source to destination

21119
13:58:41,276 --> 13:58:42,956
character by character so we are

21120
13:58:42,956 --> 13:58:46,160
basically going to have this guy pasted

21121
13:58:46,160 --> 13:58:48,640
into destination here and if we print

21122
13:58:48,640 --> 13:58:50,000
things out we're going to see that

21123
13:58:50,000 --> 13:58:52,720
destination contains the same thing as

21124
13:58:52,720 --> 13:58:55,596
source here if we built this with gcc

21125
13:58:55,596 --> 13:58:57,200
let's do that the build is going to be

21126
13:58:57,200 --> 13:58:58,800
good we can clear

21127
13:58:58,800 --> 13:59:00,880
and run rooster and you're going to see

21128
13:59:00,880 --> 13:59:03,200
that the destination has exactly the

21129
13:59:03,200 --> 13:59:05,276
same thing we had in the source and if

21130
13:59:05,276 --> 13:59:08,160
you need to copy stuff from arrays sdr

21131
13:59:08,160 --> 13:59:11,200
cpui is going to be very helpful

21132
13:59:11,200 --> 13:59:13,040
we are going to comment this out because

21133
13:59:13,040 --> 13:59:15,116
we still have a few things we want to

21134
13:59:15,116 --> 13:59:15,916
see

21135
13:59:15,916 --> 13:59:18,880
so let's comment this out we are going

21136
13:59:18,880 --> 13:59:20,956
to go down and see that we can also use

21137
13:59:20,956 --> 13:59:23,596
a another version that allows us to

21138
13:59:23,596 --> 13:59:25,916
specify how many characters we want

21139
13:59:25,916 --> 13:59:28,240
copied from the source okay in this

21140
13:59:28,240 --> 13:59:31,680
example here we are using std str and

21141
13:59:31,680 --> 13:59:34,560
cpy and this n here means that we can

21142
13:59:34,560 --> 13:59:38,080
specify the count of characters we do

21143
13:59:38,080 --> 13:59:39,116
whatever

21144
13:59:39,116 --> 13:59:41,360
the current function is doing here okay

21145
13:59:41,360 --> 13:59:43,916
so we are specifying i want five

21146
13:59:43,916 --> 13:59:46,800
characters copied from source and i want

21147
13:59:46,800 --> 13:59:49,276
those pasted into destination here

21148
13:59:49,276 --> 13:59:51,436
that's what we are saying here and the

21149
13:59:51,436 --> 13:59:53,276
source is going to contain hello

21150
13:59:53,276 --> 13:59:54,800
destination is going to contain the

21151
13:59:54,800 --> 13:59:57,276
world and the copy is going to happen

21152
13:59:57,276 --> 14:00:00,240
starting at the first index here so

21153
14:00:00,240 --> 14:00:02,080
we're going to have hello override

21154
14:00:02,080 --> 14:00:05,436
whatever we have in a b c d e because

21155
14:00:05,436 --> 14:00:07,916
that's five characters here and the dust

21156
14:00:07,916 --> 14:00:10,640
is going to contain hello f if we print

21157
14:00:10,640 --> 14:00:12,956
it out let's build this and see if

21158
14:00:12,956 --> 14:00:14,480
that's what we're going to get we're

21159
14:00:14,480 --> 14:00:16,400
going to build with gcc the build is

21160
14:00:16,400 --> 14:00:17,840
going to go through

21161
14:00:17,840 --> 14:00:20,080
we are going to clear and run rooster

21162
14:00:20,080 --> 14:00:22,000
and you see that that's exactly what we

21163
14:00:22,000 --> 14:00:23,116
have here

21164
14:00:23,116 --> 14:00:25,360
okay this is how these methods work

21165
14:00:25,360 --> 14:00:27,040
there are many more functions you can

21166
14:00:27,040 --> 14:00:27,916
use

21167
14:00:27,916 --> 14:00:30,400
from the c string library and again if

21168
14:00:30,400 --> 14:00:32,080
you want to see

21169
14:00:32,080 --> 14:00:34,480
a list of them all you can go through

21170
14:00:34,480 --> 14:00:36,320
your

21171
14:00:36,320 --> 14:00:38,880
favorite search engine and search for c

21172
14:00:38,880 --> 14:00:40,080
string

21173
14:00:40,080 --> 14:00:43,040
and we can specify cpp reference here

21174
14:00:43,040 --> 14:00:45,436
let's try and do that okay we can find a

21175
14:00:45,436 --> 14:00:47,840
link to that we can click on that and

21176
14:00:47,840 --> 14:00:49,680
it's going to open up and show us many

21177
14:00:49,680 --> 14:00:52,000
more functions we can use and if you

21178
14:00:52,000 --> 14:00:53,840
need to know about a special function

21179
14:00:53,840 --> 14:00:55,916
you can click on it and see what it does

21180
14:00:55,916 --> 14:00:57,520
and if you go down you're going to find

21181
14:00:57,520 --> 14:00:59,840
even an example of how you can use it

21182
14:00:59,840 --> 14:01:01,436
for now we are going to stop here in

21183
14:01:01,436 --> 14:01:03,040
this lecture and this is actually going

21184
14:01:03,040 --> 14:01:05,360
to be the last lecture we see on c

21185
14:01:05,360 --> 14:01:07,116
strings the next one we're going to

21186
14:01:07,116 --> 14:01:10,160
start and look at std strength which is

21187
14:01:10,160 --> 14:01:12,640
a compound type that makes working with

21188
14:01:12,640 --> 14:01:13,680
strengths

21189
14:01:13,680 --> 14:01:16,320
very easy in c plus plus

21190
14:01:16,320 --> 14:01:18,720
go ahead and finish up here and meet me

21191
14:01:18,720 --> 14:01:20,560
there in this lecture we're going to

21192
14:01:20,560 --> 14:01:23,360
start and learn about hdd strength which

21193
14:01:23,360 --> 14:01:25,436
is a type that is going to make it super

21194
14:01:25,436 --> 14:01:28,240
easy to work with string data we have

21195
14:01:28,240 --> 14:01:30,080
seen many ways we can work with

21196
14:01:30,080 --> 14:01:32,640
character arrays by now we can use row

21197
14:01:32,640 --> 14:01:35,200
rays we can point to them with pointers

21198
14:01:35,200 --> 14:01:37,596
we can even allocate arrays on the hip

21199
14:01:37,596 --> 14:01:40,640
but all these character arrays had a few

21200
14:01:40,640 --> 14:01:43,756
problems that are really a pain in the

21201
14:01:43,756 --> 14:01:46,400
neck to deal with on a daily basis

21202
14:01:46,400 --> 14:01:48,480
one of those problems was that you had

21203
14:01:48,480 --> 14:01:50,320
to keep the size in check you have to

21204
14:01:50,320 --> 14:01:51,756
know how many

21205
14:01:51,756 --> 14:01:54,640
elements you have in the character array

21206
14:01:54,640 --> 14:01:57,680
and that was defining the bounds that

21207
14:01:57,680 --> 14:02:00,320
you can work in if you go over bounds we

21208
14:02:00,320 --> 14:02:02,720
have seen that that can cause crashes of

21209
14:02:02,720 --> 14:02:04,956
your program and you don't want that

21210
14:02:04,956 --> 14:02:07,276
another problem was that we had 3d to

21211
14:02:07,276 --> 14:02:09,436
remember to keep track of the null

21212
14:02:09,436 --> 14:02:11,916
character if we don't have it in place

21213
14:02:11,916 --> 14:02:13,680
we're going to have problems when our

21214
14:02:13,680 --> 14:02:16,080
string is printed out and it's really

21215
14:02:16,080 --> 14:02:18,400
annoying to always have to think about

21216
14:02:18,400 --> 14:02:21,040
these little details when all you really

21217
14:02:21,040 --> 14:02:24,400
want is to store a strand so c plus plus

21218
14:02:24,400 --> 14:02:27,520
offers a high level type that we can use

21219
14:02:27,520 --> 14:02:29,756
and it is going to hide all these little

21220
14:02:29,756 --> 14:02:32,800
details underground and all we have to

21221
14:02:32,800 --> 14:02:35,276
do is put in our string and use it and

21222
14:02:35,276 --> 14:02:37,276
we can be on our merry way and do

21223
14:02:37,276 --> 14:02:39,436
whatever we want to do with string data

21224
14:02:39,436 --> 14:02:41,520
in our c plus plus application so that's

21225
14:02:41,520 --> 14:02:42,640
what we're going to do we're going to

21226
14:02:42,640 --> 14:02:44,956
have a type that is going to wrap on top

21227
14:02:44,956 --> 14:02:47,680
of the ugly array computations we have

21228
14:02:47,680 --> 14:02:50,400
been doing on character arrays we're

21229
14:02:50,400 --> 14:02:52,640
going to call that std string and we're

21230
14:02:52,640 --> 14:02:54,956
going to be able to do many of the

21231
14:02:54,956 --> 14:02:57,756
things we were doing with c strings but

21232
14:02:57,756 --> 14:02:59,916
in a much better way we can concatenate

21233
14:02:59,916 --> 14:03:01,916
we can search we can copy we can do all

21234
14:03:01,916 --> 14:03:04,000
kinds of crazy things really but it's

21235
14:03:04,000 --> 14:03:06,240
going to be in a way that you don't have

21236
14:03:06,240 --> 14:03:08,080
to worry about these little details

21237
14:03:08,080 --> 14:03:10,480
about array bounds the null character

21238
14:03:10,480 --> 14:03:12,956
you're going to just use it for what you

21239
14:03:12,956 --> 14:03:16,000
want which is storing character or text

21240
14:03:16,000 --> 14:03:17,596
data okay so that's what we're going to

21241
14:03:17,596 --> 14:03:19,276
be doing in the next few lectures we're

21242
14:03:19,276 --> 14:03:21,276
going to be learning about std string

21243
14:03:21,276 --> 14:03:22,956
and how you can use it in your c plus

21244
14:03:22,956 --> 14:03:25,040
plus applications and it's going to make

21245
14:03:25,040 --> 14:03:27,596
your life a whole lot easier we are

21246
14:03:27,596 --> 14:03:29,436
going to stop here in this lecture the

21247
14:03:29,436 --> 14:03:30,880
next one we're going to see how you can

21248
14:03:30,880 --> 14:03:34,160
declare initialize and use std strength

21249
14:03:34,160 --> 14:03:36,320
in your c plus plus application go ahead

21250
14:03:36,320 --> 14:03:39,276
and finish up here and meet me there and

21251
14:03:39,276 --> 14:03:40,640
this lecture we're going to see how you

21252
14:03:40,640 --> 14:03:43,436
can declare and use hdd strength in your

21253
14:03:43,436 --> 14:03:45,520
c plus plus applications

21254
14:03:45,520 --> 14:03:47,436
std strength is a type that is going to

21255
14:03:47,436 --> 14:03:49,520
wrap on top of arrays and give us a

21256
14:03:49,520 --> 14:03:51,360
really nice interface

21257
14:03:51,360 --> 14:03:53,116
that we can use to

21258
14:03:53,116 --> 14:03:55,840
store string data without having to deal

21259
14:03:55,840 --> 14:03:58,080
with the ugly little details like

21260
14:03:58,080 --> 14:04:00,480
keeping track of array bound remembering

21261
14:04:00,480 --> 14:04:02,480
to keep in check the null character and

21262
14:04:02,480 --> 14:04:04,720
things like that to use std strength you

21263
14:04:04,720 --> 14:04:07,040
will need to include the string library

21264
14:04:07,040 --> 14:04:09,040
and after you do this you can declare

21265
14:04:09,040 --> 14:04:11,916
and use your strings just like this here

21266
14:04:11,916 --> 14:04:14,480
we have a series of examples just to get

21267
14:04:14,480 --> 14:04:16,640
you started on this you declare your

21268
14:04:16,640 --> 14:04:18,320
strengths just like you declare any

21269
14:04:18,320 --> 14:04:20,400
other time you specify the type on the

21270
14:04:20,400 --> 14:04:22,400
left the type is going to be std

21271
14:04:22,400 --> 14:04:24,720
strength by the way you'll have to

21272
14:04:24,720 --> 14:04:26,956
remember to use std column column like

21273
14:04:26,956 --> 14:04:28,800
this and we will have a chance to

21274
14:04:28,800 --> 14:04:32,080
explain why in a few chapters ahead but

21275
14:04:32,080 --> 14:04:34,320
for now we're just going to think of std

21276
14:04:34,320 --> 14:04:37,116
strength as a type so we declare a

21277
14:04:37,116 --> 14:04:39,680
string type we call it full name and we

21278
14:04:39,680 --> 14:04:41,840
can leave it like this uninitialized and

21279
14:04:41,840 --> 14:04:43,916
it is going to be an empty strand we can

21280
14:04:43,916 --> 14:04:46,320
also put in our string and initialize

21281
14:04:46,320 --> 14:04:48,720
that with a string literal and it is

21282
14:04:48,720 --> 14:04:51,200
going to work another way of doing this

21283
14:04:51,200 --> 14:04:53,360
is initializing a string with another

21284
14:04:53,360 --> 14:04:55,360
string which we are doing down here you

21285
14:04:55,360 --> 14:04:57,200
can also set up another string and

21286
14:04:57,200 --> 14:04:59,680
initialize it with part of another

21287
14:04:59,680 --> 14:05:02,000
string literal so for example message

21288
14:05:02,000 --> 14:05:04,160
here is going to be hello and it's only

21289
14:05:04,160 --> 14:05:06,480
going to grab five characters from this

21290
14:05:06,480 --> 14:05:08,000
string literal this is something you

21291
14:05:08,000 --> 14:05:09,436
might want to do

21292
14:05:09,436 --> 14:05:10,956
if it makes sense for whatever

21293
14:05:10,956 --> 14:05:12,956
application you are doing here we can

21294
14:05:12,956 --> 14:05:15,436
also initialize our strength with

21295
14:05:15,436 --> 14:05:18,160
multiple copies of one character and

21296
14:05:18,160 --> 14:05:20,640
this is the syntax to do it you say

21297
14:05:20,640 --> 14:05:22,240
the name of your variable you say

21298
14:05:22,240 --> 14:05:23,840
however many times you want the

21299
14:05:23,840 --> 14:05:25,916
character repeated and you say which

21300
14:05:25,916 --> 14:05:28,560
character it is just like this we can

21301
14:05:28,560 --> 14:05:31,596
also initialize a string with part of

21302
14:05:31,596 --> 14:05:34,160
another existing string so for example

21303
14:05:34,160 --> 14:05:36,720
here we have saying hello and it is

21304
14:05:36,720 --> 14:05:39,200
initialized with part of what we have in

21305
14:05:39,200 --> 14:05:41,520
greeting here so we're going to start at

21306
14:05:41,520 --> 14:05:44,000
index 6 which is going to be

21307
14:05:44,000 --> 14:05:48,640
0 1 2 3 4 5 6 on the w here and we're

21308
14:05:48,640 --> 14:05:51,200
going to grab five characters so one two

21309
14:05:51,200 --> 14:05:53,116
three four five and that's what we're

21310
14:05:53,116 --> 14:05:54,956
going to use to initialize this saying

21311
14:05:54,956 --> 14:05:56,956
hello here and if we print it out we're

21312
14:05:56,956 --> 14:05:59,436
going to see that this is going to be

21313
14:05:59,436 --> 14:06:01,520
exactly the case so hopefully you can

21314
14:06:01,520 --> 14:06:03,436
see that it is easier you don't have to

21315
14:06:03,436 --> 14:06:05,040
use pointers you don't have to use

21316
14:06:05,040 --> 14:06:08,000
arrays and the best part is std strength

21317
14:06:08,000 --> 14:06:10,560
can grow automatically if you happen to

21318
14:06:10,560 --> 14:06:12,880
store in more characters than you

21319
14:06:12,880 --> 14:06:15,276
initialized it with in the first place

21320
14:06:15,276 --> 14:06:16,956
and that's pretty cool so now we're

21321
14:06:16,956 --> 14:06:19,040
going to head over to visual studio code

21322
14:06:19,040 --> 14:06:20,956
and play with us so that you can see for

21323
14:06:20,956 --> 14:06:23,756
yourself okay here we are in our working

21324
14:06:23,756 --> 14:06:26,320
folder the current project is declaring

21325
14:06:26,320 --> 14:06:28,560
and using std strength which is what we

21326
14:06:28,560 --> 14:06:30,400
are doing here we're going to grab our

21327
14:06:30,400 --> 14:06:32,320
template files pretty quick and we're

21328
14:06:32,320 --> 14:06:34,240
going to go and store in the files and

21329
14:06:34,240 --> 14:06:36,480
we're going to open the folder and we're

21330
14:06:36,480 --> 14:06:38,880
going to include the strength library

21331
14:06:38,880 --> 14:06:41,596
let's do that okay this is how we do it

21332
14:06:41,596 --> 14:06:44,400
and now that we have it included in our

21333
14:06:44,400 --> 14:06:47,200
project we can start declaring and using

21334
14:06:47,200 --> 14:06:48,720
std string

21335
14:06:48,720 --> 14:06:51,276
types in our c plus plus program we are

21336
14:06:51,276 --> 14:06:53,040
going to go down and put in the code to

21337
14:06:53,040 --> 14:06:55,116
play with this a little bit so you can

21338
14:06:55,116 --> 14:06:57,520
declare an empty string like this and

21339
14:06:57,520 --> 14:06:59,680
it's not going to have anything inside

21340
14:06:59,680 --> 14:07:02,000
you can declare a string and put in a

21341
14:07:02,000 --> 14:07:04,800
string literal like we are doing here

21342
14:07:04,800 --> 14:07:07,596
and std string knows how to handle this

21343
14:07:07,596 --> 14:07:09,520
so it's going to store it inside using a

21344
14:07:09,520 --> 14:07:12,080
character array but we don't have to

21345
14:07:12,080 --> 14:07:14,080
really worry about that character array

21346
14:07:14,080 --> 14:07:16,640
is going to work we're just going to use

21347
14:07:16,640 --> 14:07:20,800
std string here we can set up a string

21348
14:07:20,800 --> 14:07:23,436
using another string in our initializer

21349
14:07:23,436 --> 14:07:26,160
like this we can also use

21350
14:07:26,160 --> 14:07:28,080
part of a literal to initialize the

21351
14:07:28,080 --> 14:07:29,756
string so for example

21352
14:07:29,756 --> 14:07:31,520
this string literal here we're going to

21353
14:07:31,520 --> 14:07:33,520
grab part of it and we're going to grab

21354
14:07:33,520 --> 14:07:35,520
five characters and use those to

21355
14:07:35,520 --> 14:07:38,480
initialize our message std string here

21356
14:07:38,480 --> 14:07:40,800
and this is pretty cool we can also use

21357
14:07:40,800 --> 14:07:42,560
multiple characters to initialize a

21358
14:07:42,560 --> 14:07:44,560
string like this we say however many

21359
14:07:44,560 --> 14:07:46,480
copies we want of this character in this

21360
14:07:46,480 --> 14:07:48,160
string here and it is going to be

21361
14:07:48,160 --> 14:07:50,400
exactly what we want so it's going to be

21362
14:07:50,400 --> 14:07:51,680
four e's

21363
14:07:51,680 --> 14:07:54,240
in this weird message string

21364
14:07:54,240 --> 14:07:56,320
and we can initialize the string with

21365
14:07:56,320 --> 14:07:58,480
part of another string and this is

21366
14:07:58,480 --> 14:08:01,040
really cool and it may come in handy in

21367
14:08:01,040 --> 14:08:03,520
many applications so for example here

21368
14:08:03,520 --> 14:08:06,320
saying hello is going to contain

21369
14:08:06,320 --> 14:08:08,880
world here and we are saying that this

21370
14:08:08,880 --> 14:08:10,800
is what we want by saying we want to

21371
14:08:10,800 --> 14:08:13,680
start at index six in this string here

21372
14:08:13,680 --> 14:08:17,200
so if we go zero one two three four five

21373
14:08:17,200 --> 14:08:20,400
six this is going to be our character at

21374
14:08:20,400 --> 14:08:22,720
index six and from this index we're

21375
14:08:22,720 --> 14:08:24,320
going to grab five characters so we're

21376
14:08:24,320 --> 14:08:27,116
going to count one two three four five

21377
14:08:27,116 --> 14:08:29,360
and that's going to be what's stored in

21378
14:08:29,360 --> 14:08:31,520
this string here and if you don't

21379
14:08:31,520 --> 14:08:33,360
believe me we can print all these things

21380
14:08:33,360 --> 14:08:35,040
out and they are going to be exactly

21381
14:08:35,040 --> 14:08:37,360
what we expect and by this you can even

21382
14:08:37,360 --> 14:08:39,596
see that we can print std strengths

21383
14:08:39,596 --> 14:08:41,840
using sddc out

21384
14:08:41,840 --> 14:08:44,080
very conveniently like this and this is

21385
14:08:44,080 --> 14:08:46,240
very cool okay so we can try and weld

21386
14:08:46,240 --> 14:08:49,200
this with gcc the build is going to go

21387
14:08:49,200 --> 14:08:50,560
through so we're going to bring up a

21388
14:08:50,560 --> 14:08:52,720
terminal so that we can run this and

21389
14:08:52,720 --> 14:08:55,840
we're going to clear and let's see what

21390
14:08:55,840 --> 14:08:57,276
we see when we

21391
14:08:57,276 --> 14:09:00,080
run rooster here so we're going to print

21392
14:09:00,080 --> 14:09:02,560
the full name the full name is empty

21393
14:09:02,560 --> 14:09:04,400
okay so we're not going to see anything

21394
14:09:04,400 --> 14:09:06,240
because it is empty we're going to see

21395
14:09:06,240 --> 14:09:08,800
planet planet is this thing we have in

21396
14:09:08,800 --> 14:09:11,680
here planet where the sky is blue so

21397
14:09:11,680 --> 14:09:14,480
this is what we expect we can say

21398
14:09:14,480 --> 14:09:17,200
preferred planet and put in the text for

21399
14:09:17,200 --> 14:09:19,200
the planet here so we're going to get

21400
14:09:19,200 --> 14:09:20,800
the same thing here

21401
14:09:20,800 --> 14:09:23,200
and if we have a message and say hello

21402
14:09:23,200 --> 14:09:24,956
there and grab the

21403
14:09:24,956 --> 14:09:27,436
first characters in this string literal

21404
14:09:27,436 --> 14:09:29,276
message is going to say hello which is

21405
14:09:29,276 --> 14:09:31,680
what we are saying here let's go down

21406
14:09:31,680 --> 14:09:33,200
and look at where the message is going

21407
14:09:33,200 --> 14:09:35,520
to be for ease which is what we have

21408
14:09:35,520 --> 14:09:39,040
here and we can initialize saying hello

21409
14:09:39,040 --> 14:09:41,520
with part of what we have in greeting

21410
14:09:41,520 --> 14:09:44,560
and we have targeted this word string

21411
14:09:44,560 --> 14:09:46,720
here and it is what we see here and this

21412
14:09:46,720 --> 14:09:49,200
is pretty cool the good thing about hdd

21413
14:09:49,200 --> 14:09:51,520
string however is that you can

21414
14:09:51,520 --> 14:09:53,596
store in more characters than we

21415
14:09:53,596 --> 14:09:57,200
initialize this guy with so for example

21416
14:09:57,200 --> 14:09:59,520
here we have this message here but we

21417
14:09:59,520 --> 14:10:00,640
can say

21418
14:10:00,640 --> 14:10:02,800
planet let's go down here and say it

21419
14:10:02,800 --> 14:10:05,116
we're going to change std string at run

21420
14:10:05,116 --> 14:10:07,360
time so we're going to say planet and

21421
14:10:07,360 --> 14:10:08,880
we're going to assign something to it

21422
14:10:08,880 --> 14:10:10,720
we're going to put in whatever was in

21423
14:10:10,720 --> 14:10:12,800
there first and we're going to paste

21424
14:10:12,800 --> 14:10:14,880
that in multiple times let's do three

21425
14:10:14,880 --> 14:10:16,956
times i think that's going to be enough

21426
14:10:16,956 --> 14:10:19,596
or we can even bring this back so that

21427
14:10:19,596 --> 14:10:21,840
we see the entire thing here doesn't

21428
14:10:21,840 --> 14:10:24,160
really matter all we want is for this

21429
14:10:24,160 --> 14:10:27,276
thing to be larger than it was initially

21430
14:10:27,276 --> 14:10:28,560
declared

21431
14:10:28,560 --> 14:10:31,040
in a planet here so we're going to

21432
14:10:31,040 --> 14:10:33,040
remove these quotes because they are

21433
14:10:33,040 --> 14:10:35,520
making things ugly for us and now it's

21434
14:10:35,520 --> 14:10:37,436
going to be a valid strength let's wait

21435
14:10:37,436 --> 14:10:40,880
for visual studio code to realize that

21436
14:10:40,880 --> 14:10:42,800
and it's going to remove these squiggly

21437
14:10:42,800 --> 14:10:45,200
lines now we are good std string is

21438
14:10:45,200 --> 14:10:47,756
automatically going to take care of the

21439
14:10:47,756 --> 14:10:48,720
logic

21440
14:10:48,720 --> 14:10:51,360
to make this string grow we don't have

21441
14:10:51,360 --> 14:10:53,436
to worry about that and if we print

21442
14:10:53,436 --> 14:10:55,116
planet now we're going to see the same

21443
14:10:55,116 --> 14:10:57,596
details and taken care of okay this is

21444
14:10:57,596 --> 14:11:00,320
really cool and it makes it super easy

21445
14:11:00,320 --> 14:11:01,756
to work with

21446
14:11:01,756 --> 14:11:04,560
text and string data like you see here

21447
14:11:04,560 --> 14:11:07,200
so let's build again so that our changes

21448
14:11:07,200 --> 14:11:08,320
are

21449
14:11:08,320 --> 14:11:10,640
reflected in our output we're going to

21450
14:11:10,640 --> 14:11:13,200
clear and run rooster and we're going to

21451
14:11:13,200 --> 14:11:15,840
see that planet is now really large okay

21452
14:11:15,840 --> 14:11:17,116
we can change

21453
14:11:17,116 --> 14:11:19,200
this thing the size of this thing at

21454
14:11:19,200 --> 14:11:21,360
runtime and this is something we

21455
14:11:21,360 --> 14:11:23,520
couldn't do with arrays so for example

21456
14:11:23,520 --> 14:11:25,840
if we go down here and use a row array

21457
14:11:25,840 --> 14:11:28,560
to do something like this this code is

21458
14:11:28,560 --> 14:11:30,640
going to run but try to think about what

21459
14:11:30,640 --> 14:11:32,480
is really happening here we have an

21460
14:11:32,480 --> 14:11:35,360
array which contains this text here

21461
14:11:35,360 --> 14:11:38,160
and it is pointed to by this cost card

21462
14:11:38,160 --> 14:11:40,560
pointer that we have if we try and do an

21463
14:11:40,560 --> 14:11:42,800
assignment like this this is really

21464
14:11:42,800 --> 14:11:46,080
going to be to make it point to another

21465
14:11:46,080 --> 14:11:49,040
character array in memory and this piece

21466
14:11:49,040 --> 14:11:50,880
of memory here is basically going to be

21467
14:11:50,880 --> 14:11:54,560
wasted because we think we have our

21468
14:11:54,560 --> 14:11:57,360
planet strength in here

21469
14:11:57,360 --> 14:11:59,916
this is not the case with std strength

21470
14:11:59,916 --> 14:12:01,840
because std strength when we do

21471
14:12:01,840 --> 14:12:04,240
something like this the initial memory

21472
14:12:04,240 --> 14:12:06,560
that was allocated to store

21473
14:12:06,560 --> 14:12:08,720
planet here is going to be returned to

21474
14:12:08,720 --> 14:12:11,596
the operand system and a new memory is

21475
14:12:11,596 --> 14:12:13,756
going to be allocated to contain this

21476
14:12:13,756 --> 14:12:16,320
new thing so the waste we're doing here

21477
14:12:16,320 --> 14:12:19,360
by just leaving this in memory and not

21478
14:12:19,360 --> 14:12:21,756
using it is not being done here so if we

21479
14:12:21,756 --> 14:12:23,360
try to print we're going to get the same

21480
14:12:23,360 --> 14:12:26,240
output but inside and how our memory is

21481
14:12:26,240 --> 14:12:29,840
managed hdd string is better in that the

21482
14:12:29,840 --> 14:12:32,160
memory that was used to initialize this

21483
14:12:32,160 --> 14:12:34,880
guy is not wasted out

21484
14:12:34,880 --> 14:12:37,040
here with array what we really are doing

21485
14:12:37,040 --> 14:12:39,200
is just make this planet pointer point

21486
14:12:39,200 --> 14:12:42,080
to another string and leaving this to be

21487
14:12:42,080 --> 14:12:43,756
wasted in memory this is what we are

21488
14:12:43,756 --> 14:12:46,080
doing here and we can avoid that with

21489
14:12:46,080 --> 14:12:47,756
std strength

21490
14:12:47,756 --> 14:12:49,276
in this lecture we're going to learn

21491
14:12:49,276 --> 14:12:52,400
about the one definition rule and this

21492
14:12:52,400 --> 14:12:55,520
is a rule that says definitions can't

21493
14:12:55,520 --> 14:12:58,800
show up more than once in your entire c

21494
14:12:58,800 --> 14:13:01,840
plus plus program or in some cases a

21495
14:13:01,840 --> 14:13:04,240
definition can show up more than once in

21496
14:13:04,240 --> 14:13:06,560
a translation unit we are going to look

21497
14:13:06,560 --> 14:13:08,720
at the one definition rule in the

21498
14:13:08,720 --> 14:13:10,956
context of freestanding variables

21499
14:13:10,956 --> 14:13:13,916
functions classes member functions and

21500
14:13:13,916 --> 14:13:17,116
static members in our classes in most

21501
14:13:17,116 --> 14:13:19,596
cases a definition can't really show up

21502
14:13:19,596 --> 14:13:22,240
more than once in your entire c-plus

21503
14:13:22,240 --> 14:13:24,956
plus program but we have exceptions to

21504
14:13:24,956 --> 14:13:27,680
this rule and the exception is for

21505
14:13:27,680 --> 14:13:30,320
classes a definition for a class can

21506
14:13:30,320 --> 14:13:34,000
show up in multiple translation unit and

21507
14:13:34,000 --> 14:13:35,360
the reason is

21508
14:13:35,360 --> 14:13:37,360
we need to create objects of those

21509
14:13:37,360 --> 14:13:39,916
classes so each translation unit really

21510
14:13:39,916 --> 14:13:42,240
needs to see the definition for the

21511
14:13:42,240 --> 14:13:45,116
class and we are going to try and make

21512
14:13:45,116 --> 14:13:47,840
this super clear with examples once we

21513
14:13:47,840 --> 14:13:50,400
hit visual studio code okay so it is

21514
14:13:50,400 --> 14:13:52,640
time to head over to visual studio code

21515
14:13:52,640 --> 14:13:55,276
and shed some more light on the one

21516
14:13:55,276 --> 14:13:57,840
definition rule here we are in our

21517
14:13:57,840 --> 14:13:59,840
working folder the current project is

21518
14:13:59,840 --> 14:14:01,916
one definition rule we're going to grab

21519
14:14:01,916 --> 14:14:04,880
our template files like we always do

21520
14:14:04,880 --> 14:14:06,640
we're going to put them in place and

21521
14:14:06,640 --> 14:14:08,480
we're going to open this little guy in

21522
14:14:08,480 --> 14:14:10,400
visual studio code let's do that i'm

21523
14:14:10,400 --> 14:14:12,000
going to drag and drop and we're going

21524
14:14:12,000 --> 14:14:13,756
to have our main cpp file here we're

21525
14:14:13,756 --> 14:14:15,596
going to clean it up that's what we

21526
14:14:15,596 --> 14:14:17,520
always do

21527
14:14:17,520 --> 14:14:20,240
and now we want to explore the one

21528
14:14:20,240 --> 14:14:22,080
definition rule in the context of

21529
14:14:22,080 --> 14:14:24,640
variables so we have a freestanding

21530
14:14:24,640 --> 14:14:27,040
variable here

21531
14:14:27,040 --> 14:14:28,800
and that's going to be the same variable

21532
14:14:28,800 --> 14:14:30,720
we had in the last lecture we're going

21533
14:14:30,720 --> 14:14:33,116
to initialize this and this is really

21534
14:14:33,116 --> 14:14:36,080
good we can use it we can go in main and

21535
14:14:36,080 --> 14:14:38,000
use it however we want we can print the

21536
14:14:38,000 --> 14:14:39,116
way

21537
14:14:39,116 --> 14:14:41,360
and if we won't run this program it is

21538
14:14:41,360 --> 14:14:43,916
going to work but the one definition

21539
14:14:43,916 --> 14:14:46,956
rule says we can't have more than one

21540
14:14:46,956 --> 14:14:50,160
definition for anything and for this

21541
14:14:50,160 --> 14:14:52,080
variable here we have seen that this is

21542
14:14:52,080 --> 14:14:54,320
both a declaration

21543
14:14:54,320 --> 14:14:57,040
and a definition so we can't have more

21544
14:14:57,040 --> 14:14:59,596
than one definition for the weight name

21545
14:14:59,596 --> 14:15:02,160
here for example if we try and grab it

21546
14:15:02,160 --> 14:15:04,480
and copy and paste it here so we're

21547
14:15:04,480 --> 14:15:06,240
going to try and build this program

21548
14:15:06,240 --> 14:15:08,560
we're going to use gcc

21549
14:15:08,560 --> 14:15:09,756
we're going to see that we have a

21550
14:15:09,756 --> 14:15:12,116
problem and the problem is going to say

21551
14:15:12,116 --> 14:15:13,756
redefinition

21552
14:15:13,756 --> 14:15:16,320
of double weight and it is not going to

21553
14:15:16,320 --> 14:15:18,400
help even if you take this and put that

21554
14:15:18,400 --> 14:15:20,640
in another file so let's create another

21555
14:15:20,640 --> 14:15:22,320
file to really show you that we're going

21556
14:15:22,320 --> 14:15:26,160
to call it some other file that cpp and

21557
14:15:26,160 --> 14:15:29,200
we're going to grab our redefinition

21558
14:15:29,200 --> 14:15:31,436
and move that there

21559
14:15:31,436 --> 14:15:33,756
and you're going to see that if we try

21560
14:15:33,756 --> 14:15:35,756
and build this program

21561
14:15:35,756 --> 14:15:37,040
we're going to get the same problem

21562
14:15:37,040 --> 14:15:39,200
we're going to have redefinition so

21563
14:15:39,200 --> 14:15:40,880
we're going to see

21564
14:15:40,880 --> 14:15:42,640
what is the problem here the compiler

21565
14:15:42,640 --> 14:15:44,640
error is a little bit different but it

21566
14:15:44,640 --> 14:15:47,596
is going to say multiple definitions of

21567
14:15:47,596 --> 14:15:48,400
weight

21568
14:15:48,400 --> 14:15:50,640
and it's going to say one is defined in

21569
14:15:50,640 --> 14:15:53,916
the main cpp file so this is a linker

21570
14:15:53,916 --> 14:15:56,400
error this was caught by the laker

21571
14:15:56,400 --> 14:15:58,880
because the redefinition is showing up

21572
14:15:58,880 --> 14:16:01,520
in multiple files so the linker was

21573
14:16:01,520 --> 14:16:03,756
linking this program and it needed to

21574
14:16:03,756 --> 14:16:06,000
see a definition for weight and it had

21575
14:16:06,000 --> 14:16:09,040
seen one definition in the main cpp file

21576
14:16:09,040 --> 14:16:10,956
and it has seen another definition and

21577
14:16:10,956 --> 14:16:13,276
some other file and this is a problem

21578
14:16:13,276 --> 14:16:15,040
the linker doesn't know which one to

21579
14:16:15,040 --> 14:16:17,276
choose so it's going to throw an error

21580
14:16:17,276 --> 14:16:19,200
and you can't really have multiple

21581
14:16:19,200 --> 14:16:21,596
definitions for a variable in your c

21582
14:16:21,596 --> 14:16:23,840
plus plus program and this is the one

21583
14:16:23,840 --> 14:16:26,560
definition rule and the context of

21584
14:16:26,560 --> 14:16:28,560
freestanding variables like the weight

21585
14:16:28,560 --> 14:16:31,436
here but this is the same in the context

21586
14:16:31,436 --> 14:16:34,320
of functions if we go down and put up

21587
14:16:34,320 --> 14:16:36,640
our add function here we're going to say

21588
14:16:36,640 --> 14:16:37,596
double

21589
14:16:37,596 --> 14:16:38,400
a

21590
14:16:38,400 --> 14:16:40,956
and double b here and we're going to put

21591
14:16:40,956 --> 14:16:43,756
the definition below the main cpp file

21592
14:16:43,756 --> 14:16:45,276
let's grab this

21593
14:16:45,276 --> 14:16:48,160
we can copy this and put this in the

21594
14:16:48,160 --> 14:16:49,916
code here i'm going to remove this

21595
14:16:49,916 --> 14:16:51,436
little thing we don't want it we're

21596
14:16:51,436 --> 14:16:53,436
going to put in our body and we're going

21597
14:16:53,436 --> 14:16:56,160
to return a plus b here okay so this is

21598
14:16:56,160 --> 14:16:58,720
our function it is working we can take

21599
14:16:58,720 --> 14:17:00,956
out what we had here because it has

21600
14:17:00,956 --> 14:17:03,276
served its purpose you can say double

21601
14:17:03,276 --> 14:17:05,756
result and we're going to add up 10 and

21602
14:17:05,756 --> 14:17:08,240
20 like we did in the last lecture

21603
14:17:08,240 --> 14:17:10,956
no problem and we can try and print out

21604
14:17:10,956 --> 14:17:12,720
our results here

21605
14:17:12,720 --> 14:17:14,560
if we build and run this program it is

21606
14:17:14,560 --> 14:17:16,640
going to work without a problem because

21607
14:17:16,640 --> 14:17:19,756
we only have one definition for the add

21608
14:17:19,756 --> 14:17:20,720
function

21609
14:17:20,720 --> 14:17:23,520
what is the problem here we have weight

21610
14:17:23,520 --> 14:17:25,756
defined multiple times we're going to

21611
14:17:25,756 --> 14:17:27,520
comment out one the definition for

21612
14:17:27,520 --> 14:17:28,956
weight

21613
14:17:28,956 --> 14:17:31,360
and we're going to build again

21614
14:17:31,360 --> 14:17:33,116
now the build is good and we can run

21615
14:17:33,116 --> 14:17:35,360
this program we can

21616
14:17:35,360 --> 14:17:37,520
kill our terminal here and bring up

21617
14:17:37,520 --> 14:17:39,520
another one and run rooster you're going

21618
14:17:39,520 --> 14:17:42,400
to see that the result is 30 and the

21619
14:17:42,400 --> 14:17:45,200
program is working just fine but if we

21620
14:17:45,200 --> 14:17:47,360
set up another definition for add even

21621
14:17:47,360 --> 14:17:50,800
if we put this in the same file

21622
14:17:50,800 --> 14:17:52,800
we're going to get a problem because we

21623
14:17:52,800 --> 14:17:55,596
are violating the one definition rule

21624
14:17:55,596 --> 14:17:57,116
let's run again

21625
14:17:57,116 --> 14:17:58,480
you're going to see the problem here

21626
14:17:58,480 --> 14:18:00,320
we're going to see redefinition

21627
14:18:00,320 --> 14:18:02,720
redefinition of the add function this is

21628
14:18:02,720 --> 14:18:04,560
not allowed your program is not going to

21629
14:18:04,560 --> 14:18:07,200
compile we see the compiler error here

21630
14:18:07,200 --> 14:18:08,956
even if you put the definition in

21631
14:18:08,956 --> 14:18:11,200
another file that's not going to help

21632
14:18:11,200 --> 14:18:13,360
we're going to take this and put this in

21633
14:18:13,360 --> 14:18:15,756
our some other file

21634
14:18:15,756 --> 14:18:19,436
and try to compile the program

21635
14:18:20,400 --> 14:18:22,320
we're going to get a linker error and it

21636
14:18:22,320 --> 14:18:24,320
is going to say multiple definition of

21637
14:18:24,320 --> 14:18:27,116
the add function and this is not allowed

21638
14:18:27,116 --> 14:18:29,436
this is a linker error in this time if

21639
14:18:29,436 --> 14:18:31,680
we comment out one definition let's do

21640
14:18:31,680 --> 14:18:33,596
that we're going to comment out the one

21641
14:18:33,596 --> 14:18:35,680
in the main function this is going to

21642
14:18:35,680 --> 14:18:38,800
work and we want to be violating the one

21643
14:18:38,800 --> 14:18:41,360
definition rule so this is good the

21644
14:18:41,360 --> 14:18:43,436
world is good we can clear

21645
14:18:43,436 --> 14:18:45,360
and run rooster we're going to see our

21646
14:18:45,360 --> 14:18:48,000
result here so the one definition rule

21647
14:18:48,000 --> 14:18:50,560
says you can't have multiple definitions

21648
14:18:50,560 --> 14:18:51,360
for

21649
14:18:51,360 --> 14:18:54,240
freestanding variables or even functions

21650
14:18:54,240 --> 14:18:55,840
and reserve that if you do that you're

21651
14:18:55,840 --> 14:18:58,080
going to get a compiler error let's look

21652
14:18:58,080 --> 14:19:00,400
at this in the context of classes we're

21653
14:19:00,400 --> 14:19:01,840
going to do a class we're going to say

21654
14:19:01,840 --> 14:19:04,080
struct and we're going to call this

21655
14:19:04,080 --> 14:19:06,640
point like we always do

21656
14:19:06,640 --> 14:19:08,880
mostly we're going to call this point

21657
14:19:08,880 --> 14:19:10,480
and we're going to put in a few member

21658
14:19:10,480 --> 14:19:13,200
variables one is going to be mx the

21659
14:19:13,200 --> 14:19:15,436
other is going to be m y

21660
14:19:15,436 --> 14:19:17,520
and this is going to be our definition

21661
14:19:17,520 --> 14:19:18,320
here

21662
14:19:18,320 --> 14:19:20,480
but what you're going to see

21663
14:19:20,480 --> 14:19:23,116
is that it is possible to have multiple

21664
14:19:23,116 --> 14:19:26,080
definitions for classes for example if

21665
14:19:26,080 --> 14:19:28,480
we take this and

21666
14:19:28,480 --> 14:19:30,800
have a copy of this in another file

21667
14:19:30,800 --> 14:19:32,320
we're going to do that we're going to

21668
14:19:32,320 --> 14:19:34,880
declare this structure here

21669
14:19:34,880 --> 14:19:36,840
and we're going to try and build this

21670
14:19:36,840 --> 14:19:39,276
program you're going to see that it is

21671
14:19:39,276 --> 14:19:41,200
working we have multiple definitions of

21672
14:19:41,200 --> 14:19:44,080
these guys we can go in main for example

21673
14:19:44,080 --> 14:19:46,080
and say point

21674
14:19:46,080 --> 14:19:47,200
p1

21675
14:19:47,200 --> 14:19:49,116
and we can up weld and see that the

21676
14:19:49,116 --> 14:19:51,360
program is going to work okay so if you

21677
14:19:51,360 --> 14:19:54,320
go in here for example and try to print

21678
14:19:54,320 --> 14:19:56,160
sdd cl

21679
14:19:56,160 --> 14:19:58,560
p1 and the print x we're going to do

21680
14:19:58,560 --> 14:20:01,116
that we're going to say p1 mx we're

21681
14:20:01,116 --> 14:20:03,040
going to be able to use this because

21682
14:20:03,040 --> 14:20:05,360
this is a struct the member variables

21683
14:20:05,360 --> 14:20:08,000
are public by default we can do this

21684
14:20:08,000 --> 14:20:09,520
and we can say

21685
14:20:09,520 --> 14:20:11,916
p1 y

21686
14:20:11,916 --> 14:20:13,116
is

21687
14:20:13,116 --> 14:20:16,800
p1y my let's do that and we can say

21688
14:20:16,800 --> 14:20:20,400
stdndl what is the problem here we need

21689
14:20:20,400 --> 14:20:23,840
to put our output stream operator

21690
14:20:23,840 --> 14:20:25,596
i think now the compiler is going to be

21691
14:20:25,596 --> 14:20:26,560
happy

21692
14:20:26,560 --> 14:20:27,916
and therefore world

21693
14:20:27,916 --> 14:20:30,400
we're going to use gcc

21694
14:20:30,400 --> 14:20:31,916
we're going to see that if we run the

21695
14:20:31,916 --> 14:20:34,000
program we're going to see our things

21696
14:20:34,000 --> 14:20:36,160
here and we have some junk values inside

21697
14:20:36,160 --> 14:20:38,400
because these things are not initialized

21698
14:20:38,400 --> 14:20:40,800
but if we initialize them to zero using

21699
14:20:40,800 --> 14:20:43,116
the braced initialization here

21700
14:20:43,116 --> 14:20:45,276
we're going to build again

21701
14:20:45,276 --> 14:20:47,840
and we should see zero inside so let's

21702
14:20:47,840 --> 14:20:51,360
clear and run rooster now we have 0 in x

21703
14:20:51,360 --> 14:20:53,680
and y for our object here this is

21704
14:20:53,680 --> 14:20:55,596
working fine and we have multiple

21705
14:20:55,596 --> 14:20:58,640
definitions for our class but the

21706
14:20:58,640 --> 14:21:01,200
definitions can't show up in a single

21707
14:21:01,200 --> 14:21:03,916
translation unit for example if we took

21708
14:21:03,916 --> 14:21:06,000
this definition here

21709
14:21:06,000 --> 14:21:08,480
and brought that back in main and put

21710
14:21:08,480 --> 14:21:10,160
that just below

21711
14:21:10,160 --> 14:21:13,200
our structure here if we try to weld the

21712
14:21:13,200 --> 14:21:15,040
compiler is going to complain because

21713
14:21:15,040 --> 14:21:17,756
now we have multiple definitions for the

21714
14:21:17,756 --> 14:21:20,880
same class in the same translation unit

21715
14:21:20,880 --> 14:21:22,320
for classes

21716
14:21:22,320 --> 14:21:24,800
we can have multiple definitions but the

21717
14:21:24,800 --> 14:21:27,756
definitions have to show up in different

21718
14:21:27,756 --> 14:21:29,680
translation units and that's what i want

21719
14:21:29,680 --> 14:21:31,436
you to see here so we have a

21720
14:21:31,436 --> 14:21:34,240
redefinition of our point struct and it

21721
14:21:34,240 --> 14:21:36,320
is not good it is going to violate the

21722
14:21:36,320 --> 14:21:38,640
one definition rule okay now that you

21723
14:21:38,640 --> 14:21:40,800
have seen this we also want to see this

21724
14:21:40,800 --> 14:21:43,040
in the context of a class

21725
14:21:43,040 --> 14:21:45,116
that also has some static member

21726
14:21:45,116 --> 14:21:47,040
variables we're going to take this out

21727
14:21:47,040 --> 14:21:49,200
because we have already seen this and

21728
14:21:49,200 --> 14:21:51,840
we're going to bring in our person class

21729
14:21:51,840 --> 14:21:54,080
like we used in the last lecture we're

21730
14:21:54,080 --> 14:21:56,240
going to add in a new header file it's

21731
14:21:56,240 --> 14:21:59,040
going to be called person

21732
14:21:59,040 --> 14:22:00,320
dot h

21733
14:22:00,320 --> 14:22:02,880
and we're going to jump into

21734
14:22:02,880 --> 14:22:06,240
what did we do is this folder let's

21735
14:22:06,240 --> 14:22:09,360
remove this we didn't want a folder

21736
14:22:09,360 --> 14:22:11,436
we're going to delete this folder we

21737
14:22:11,436 --> 14:22:13,360
don't want it

21738
14:22:13,360 --> 14:22:15,520
and we're going to just add a file

21739
14:22:15,520 --> 14:22:18,880
called person.h

21740
14:22:18,880 --> 14:22:20,560
that's all file here and we're going to

21741
14:22:20,560 --> 14:22:22,640
put in the content the content is going

21742
14:22:22,640 --> 14:22:24,480
to be our personal class let's close

21743
14:22:24,480 --> 14:22:26,720
this so that you can see more of this

21744
14:22:26,720 --> 14:22:29,596
class here okay so we have our person

21745
14:22:29,596 --> 14:22:32,080
class here we have our include card we

21746
14:22:32,080 --> 14:22:34,720
have our person class definition we have

21747
14:22:34,720 --> 14:22:36,480
a constructor and we have a printer

21748
14:22:36,480 --> 14:22:37,916
phone function we have our member

21749
14:22:37,916 --> 14:22:40,080
variables and down below here you see

21750
14:22:40,080 --> 14:22:42,320
that we have a static variable which is

21751
14:22:42,320 --> 14:22:44,480
person account we need to put in the

21752
14:22:44,480 --> 14:22:47,040
definition for these guys so let's go

21753
14:22:47,040 --> 14:22:49,520
down and do that we're going to put in

21754
14:22:49,520 --> 14:22:51,520
the definition for the person

21755
14:22:51,520 --> 14:22:53,520
constructor we're going to go on top

21756
14:22:53,520 --> 14:22:56,560
here and include our person header file

21757
14:22:56,560 --> 14:22:58,240
and we're going to put in place our

21758
14:22:58,240 --> 14:23:00,160
constructor we can go down and do that

21759
14:23:00,160 --> 14:23:03,040
we can say person and say person

21760
14:23:03,040 --> 14:23:04,956
that's going to be our constructor we're

21761
14:23:04,956 --> 14:23:07,436
going to go back to the class and grab

21762
14:23:07,436 --> 14:23:09,596
the parameters because i don't want to

21763
14:23:09,596 --> 14:23:11,680
type all these lengths

21764
14:23:11,680 --> 14:23:13,680
so let's do that we're going to put them

21765
14:23:13,680 --> 14:23:14,800
in

21766
14:23:14,800 --> 14:23:17,436
we are going to put in our initializer

21767
14:23:17,436 --> 14:23:19,840
list i think we should also delete a

21768
14:23:19,840 --> 14:23:22,160
parenthesis here we're going to go down

21769
14:23:22,160 --> 14:23:24,400
and put in our initializer list we're

21770
14:23:24,400 --> 14:23:26,240
going to say full name we're going to

21771
14:23:26,240 --> 14:23:28,720
initialize this with name param

21772
14:23:28,720 --> 14:23:32,240
and we're going to also put in our age

21773
14:23:32,240 --> 14:23:34,000
and we're going to initialize this with

21774
14:23:34,000 --> 14:23:36,080
edge param the parameter we have from

21775
14:23:36,080 --> 14:23:39,040
the function and this is going to be all

21776
14:23:39,040 --> 14:23:41,916
inside the body we're going to implement

21777
14:23:41,916 --> 14:23:43,680
the static variable we're going to say

21778
14:23:43,680 --> 14:23:46,160
increment person count okay now select

21779
14:23:46,160 --> 14:23:48,800
that here and this is going to be good

21780
14:23:48,800 --> 14:23:51,360
we also need to initialize our static

21781
14:23:51,360 --> 14:23:52,956
variables so we're going to say ends

21782
14:23:52,956 --> 14:23:56,160
person person account let's do person

21783
14:23:56,160 --> 14:23:58,160
account and we're going to initialize

21784
14:23:58,160 --> 14:24:00,240
this to maybe eight like we did in the

21785
14:24:00,240 --> 14:24:03,436
last lecture and this should be all we

21786
14:24:03,436 --> 14:24:05,916
need here so if we build and run this

21787
14:24:05,916 --> 14:24:08,480
program i think it's going to run

21788
14:24:08,480 --> 14:24:10,800
let's select the main function here

21789
14:24:10,800 --> 14:24:12,640
and what problem do we have here let's

21790
14:24:12,640 --> 14:24:14,400
build and see we're going to let the

21791
14:24:14,400 --> 14:24:16,800
compiler figure this out

21792
14:24:16,800 --> 14:24:18,240
we're going to see that the world is

21793
14:24:18,240 --> 14:24:20,640
good and we can create person objects

21794
14:24:20,640 --> 14:24:22,480
and really use them in our program so

21795
14:24:22,480 --> 14:24:24,640
let's come down here and delete whatever

21796
14:24:24,640 --> 14:24:27,276
we had we're going to include the person

21797
14:24:27,276 --> 14:24:28,800
and we're going to go down here and

21798
14:24:28,800 --> 14:24:30,240
create a person object we're going to

21799
14:24:30,240 --> 14:24:32,160
say person

21800
14:24:32,160 --> 14:24:34,560
p1 and we're going to specify the name

21801
14:24:34,560 --> 14:24:37,040
to be jon snow why not

21802
14:24:37,040 --> 14:24:39,360
and we're going to say that they are

21803
14:24:39,360 --> 14:24:41,116
35 why not

21804
14:24:41,116 --> 14:24:42,956
and we can preach information about this

21805
14:24:42,956 --> 14:24:45,756
person we can say person principle and

21806
14:24:45,756 --> 14:24:48,000
if we try to build this program let's

21807
14:24:48,000 --> 14:24:50,000
use gcc to do that

21808
14:24:50,000 --> 14:24:52,160
the world is going to be good as you see

21809
14:24:52,160 --> 14:24:54,480
down here we can clear

21810
14:24:54,480 --> 14:24:56,320
and run rooster we're going to see jon

21811
14:24:56,320 --> 14:24:58,080
snow he is

21812
14:24:58,080 --> 14:25:00,560
35 years old so this is working just

21813
14:25:00,560 --> 14:25:02,956
fine but we can't have

21814
14:25:02,956 --> 14:25:06,400
multiple definitions for the same class

21815
14:25:06,400 --> 14:25:09,200
in the same translation unit here for

21816
14:25:09,200 --> 14:25:11,040
example if we come in the main function

21817
14:25:11,040 --> 14:25:13,680
notice we are including a person so this

21818
14:25:13,680 --> 14:25:15,840
is bringing in the definition for a

21819
14:25:15,840 --> 14:25:19,200
person we have in our person.h here if

21820
14:25:19,200 --> 14:25:21,276
we also try to declare another class

21821
14:25:21,276 --> 14:25:22,800
called person

21822
14:25:22,800 --> 14:25:25,916
even if we don't put anything in the

21823
14:25:25,916 --> 14:25:28,400
compiler is going to complain because we

21824
14:25:28,400 --> 14:25:31,040
have two definitions for the same name

21825
14:25:31,040 --> 14:25:34,720
which is person here if we try to build

21826
14:25:34,720 --> 14:25:36,320
i think we are going to get a compiler

21827
14:25:36,320 --> 14:25:38,480
error saying that we have a definition

21828
14:25:38,480 --> 14:25:41,040
you see we have a redefinition of person

21829
14:25:41,040 --> 14:25:42,880
so this is not allowed we can't really

21830
14:25:42,880 --> 14:25:45,360
do this but notice that this person

21831
14:25:45,360 --> 14:25:48,720
class is included both in some other

21832
14:25:48,720 --> 14:25:50,800
file which is a separate translation

21833
14:25:50,800 --> 14:25:54,160
unit and main we have it included here

21834
14:25:54,160 --> 14:25:56,320
so it is really in a separate

21835
14:25:56,320 --> 14:25:58,956
translation unit we have the definition

21836
14:25:58,956 --> 14:26:01,116
for the class in separate translation

21837
14:26:01,116 --> 14:26:03,520
units and that's not a problem but if

21838
14:26:03,520 --> 14:26:05,680
you try and put the same definition

21839
14:26:05,680 --> 14:26:09,040
multiple times in a single translation

21840
14:26:09,040 --> 14:26:10,956
unit you're going to get a problem and

21841
14:26:10,956 --> 14:26:13,360
you need to be aware of that what i want

21842
14:26:13,360 --> 14:26:16,080
you to see right here is that you can't

21843
14:26:16,080 --> 14:26:18,560
also have multiple definitions

21844
14:26:18,560 --> 14:26:22,400
for your static variables and the member

21845
14:26:22,400 --> 14:26:25,596
functions of your class for example if

21846
14:26:25,596 --> 14:26:28,160
we grab what we have here

21847
14:26:28,160 --> 14:26:30,560
and also put that in our main function

21848
14:26:30,560 --> 14:26:32,880
we can do that why not we're going to

21849
14:26:32,880 --> 14:26:35,116
come in our main function here and we're

21850
14:26:35,116 --> 14:26:37,596
going to put the same definitions here

21851
14:26:37,596 --> 14:26:39,040
now we're going to have a problem

21852
14:26:39,040 --> 14:26:40,956
because the linker is going to see two

21853
14:26:40,956 --> 14:26:43,680
definitions for the static variable and

21854
14:26:43,680 --> 14:26:45,680
the constructor for a person here and

21855
14:26:45,680 --> 14:26:47,276
this is going to be a problem you can't

21856
14:26:47,276 --> 14:26:49,840
really do that if we build we're going

21857
14:26:49,840 --> 14:26:50,956
to see

21858
14:26:50,956 --> 14:26:53,040
a problem we're going to see

21859
14:26:53,040 --> 14:26:55,436
that the problem is

21860
14:26:55,436 --> 14:26:57,200
we have multiple definitions for the

21861
14:26:57,200 --> 14:26:59,756
constructor and we have multiple

21862
14:26:59,756 --> 14:27:02,480
definitions for person account and this

21863
14:27:02,480 --> 14:27:04,560
is not allowed you can't really do that

21864
14:27:04,560 --> 14:27:07,200
you can either remove the one from some

21865
14:27:07,200 --> 14:27:09,840
other file.cpp for example if we comment

21866
14:27:09,840 --> 14:27:11,116
this out

21867
14:27:11,116 --> 14:27:13,916
let's do that we can come on top here

21868
14:27:13,916 --> 14:27:16,160
and comment this out and try to build

21869
14:27:16,160 --> 14:27:18,400
the program now the program is going to

21870
14:27:18,400 --> 14:27:20,720
work because we have one definition for

21871
14:27:20,720 --> 14:27:22,800
these guys you see the world is good we

21872
14:27:22,800 --> 14:27:25,360
can even run the program to show you

21873
14:27:25,360 --> 14:27:28,000
that it works or we can remove the one

21874
14:27:28,000 --> 14:27:31,116
in the main cpp file and we can leave

21875
14:27:31,116 --> 14:27:33,680
this alive so let's go back in the cpp

21876
14:27:33,680 --> 14:27:36,560
file the main cpp file i should say and

21877
14:27:36,560 --> 14:27:38,640
remove this and if we work we're going

21878
14:27:38,640 --> 14:27:40,800
to see that this is going to work and

21879
14:27:40,800 --> 14:27:42,480
that we are

21880
14:27:42,480 --> 14:27:45,276
compliant with what the c plus plus

21881
14:27:45,276 --> 14:27:49,040
standard expects us to do in our c plus

21882
14:27:49,040 --> 14:27:50,720
plus programs if we're around we're

21883
14:27:50,720 --> 14:27:52,480
going to see that this is going to work

21884
14:27:52,480 --> 14:27:54,400
and this is really cool this is really

21885
14:27:54,400 --> 14:27:56,956
all i wanted you to see in this lecture

21886
14:27:56,956 --> 14:27:59,276
the one definition rule which says that

21887
14:27:59,276 --> 14:28:02,880
you can't have multiple definitions for

21888
14:28:02,880 --> 14:28:06,080
the same name in your entire c plus plus

21889
14:28:06,080 --> 14:28:09,360
program but for classes we can violate

21890
14:28:09,360 --> 14:28:12,240
this rule a little bit and make the same

21891
14:28:12,240 --> 14:28:14,800
definition show up in multiple

21892
14:28:14,800 --> 14:28:17,276
translation units we are going to stop

21893
14:28:17,276 --> 14:28:19,276
here in this lecture in the next one

21894
14:28:19,276 --> 14:28:22,000
we're going to learn about linkage

21895
14:28:22,000 --> 14:28:24,320
go ahead and finish up here and make me

21896
14:28:24,320 --> 14:28:25,360
there

21897
14:28:25,360 --> 14:28:26,800
in this lecture we're going to learn

21898
14:28:26,800 --> 14:28:29,520
about functions a function is a reusable

21899
14:28:29,520 --> 14:28:31,756
piece of code that you can use multiple

21900
14:28:31,756 --> 14:28:35,436
times to do different things it can take

21901
14:28:35,436 --> 14:28:38,400
input and once it has input it can do

21902
14:28:38,400 --> 14:28:40,880
some processing and when the processing

21903
14:28:40,880 --> 14:28:43,756
is done the function can optionally give

21904
14:28:43,756 --> 14:28:46,080
you a result you can think of a function

21905
14:28:46,080 --> 14:28:48,480
as a machine which can take input and

21906
14:28:48,480 --> 14:28:50,956
give you some output when you give input

21907
14:28:50,956 --> 14:28:52,480
to the machine the machine is going to

21908
14:28:52,480 --> 14:28:54,800
do some processing and then it's going

21909
14:28:54,800 --> 14:28:57,520
to give you the output and the output is

21910
14:28:57,520 --> 14:28:59,680
going to be dependent on the input that

21911
14:28:59,680 --> 14:29:01,596
you gave to the machine this is really

21912
14:29:01,596 --> 14:29:04,240
how a function works in c plus plus and

21913
14:29:04,240 --> 14:29:06,400
once you have the machine set up you can

21914
14:29:06,400 --> 14:29:09,116
really reuse it however many times you

21915
14:29:09,116 --> 14:29:11,276
want let's look at how a function looks

21916
14:29:11,276 --> 14:29:13,680
in c plus plus the syntax is this you

21917
14:29:13,680 --> 14:29:16,240
first specify the return type which may

21918
14:29:16,240 --> 14:29:18,880
be and double or whatever after that

21919
14:29:18,880 --> 14:29:20,720
you're going to specify the function

21920
14:29:20,720 --> 14:29:21,680
name

21921
14:29:21,680 --> 14:29:23,520
and after that you're going to have a

21922
14:29:23,520 --> 14:29:25,756
pair of parentheses inside this

21923
14:29:25,756 --> 14:29:27,276
parenthesis you're going to have your

21924
14:29:27,276 --> 14:29:29,520
parameters which is going to be a comma

21925
14:29:29,520 --> 14:29:32,320
separated list of things you pass to the

21926
14:29:32,320 --> 14:29:35,436
function and after all these parameters

21927
14:29:35,436 --> 14:29:37,756
you're going to have a pair of curly

21928
14:29:37,756 --> 14:29:40,640
braces and inside those curly braces

21929
14:29:40,640 --> 14:29:42,320
we're going to have the body of the

21930
14:29:42,320 --> 14:29:44,320
function we're going to be doing our

21931
14:29:44,320 --> 14:29:46,640
processing in the body and when the

21932
14:29:46,640 --> 14:29:49,680
processing is done we can get the result

21933
14:29:49,680 --> 14:29:52,480
of the function through this return

21934
14:29:52,480 --> 14:29:55,040
mechanism here so if we want to get

21935
14:29:55,040 --> 14:29:57,200
something out of the function we have to

21936
14:29:57,200 --> 14:29:59,520
return that thing and it is going to be

21937
14:29:59,520 --> 14:30:03,116
visible to whoever used this function

21938
14:30:03,116 --> 14:30:05,436
here is a simple example of a function

21939
14:30:05,436 --> 14:30:08,480
with no input and output the syntax is

21940
14:30:08,480 --> 14:30:10,720
going to be this void means that this

21941
14:30:10,720 --> 14:30:12,800
function is not going to return anything

21942
14:30:12,800 --> 14:30:15,276
and you notice that our pair of

21943
14:30:15,276 --> 14:30:18,480
parentheses is empty because we have no

21944
14:30:18,480 --> 14:30:21,276
input in this function we have our curly

21945
14:30:21,276 --> 14:30:24,000
braces and inside these curly braces is

21946
14:30:24,000 --> 14:30:25,840
going to be the body of this function

21947
14:30:25,840 --> 14:30:28,160
it's going to do some processing and

21948
14:30:28,160 --> 14:30:30,720
when processing is done we return out of

21949
14:30:30,720 --> 14:30:33,116
this function now remember that i said

21950
14:30:33,116 --> 14:30:34,956
that this function doesn't return

21951
14:30:34,956 --> 14:30:39,116
anything because it is of void type here

21952
14:30:39,116 --> 14:30:41,116
but we can return and i'm going to show

21953
14:30:41,116 --> 14:30:43,680
you the exact syntax of how you can do

21954
14:30:43,680 --> 14:30:46,080
that okay so we can have many functions

21955
14:30:46,080 --> 14:30:48,400
in c plus plus but each function has to

21956
14:30:48,400 --> 14:30:50,560
be unique otherwise you're going to have

21957
14:30:50,560 --> 14:30:53,040
problems in your c plus plus programs a

21958
14:30:53,040 --> 14:30:55,756
function is going to be unique based on

21959
14:30:55,756 --> 14:30:58,080
its signature and the signature is

21960
14:30:58,080 --> 14:31:00,000
really a function name

21961
14:31:00,000 --> 14:31:02,640
plus the function parameters if we go

21962
14:31:02,640 --> 14:31:05,200
back to our example here and try to

21963
14:31:05,200 --> 14:31:06,956
figure out the signature of this

21964
14:31:06,956 --> 14:31:10,000
function it's going to be function name

21965
14:31:10,000 --> 14:31:12,560
and plus the parameters and you see that

21966
14:31:12,560 --> 14:31:15,276
we have no parameters in here so this

21967
14:31:15,276 --> 14:31:18,400
signature is going to uniquely identify

21968
14:31:18,400 --> 14:31:21,520
this function in our c plus plus program

21969
14:31:21,520 --> 14:31:23,436
if we set up another function that has

21970
14:31:23,436 --> 14:31:25,680
this same function name and doesn't take

21971
14:31:25,680 --> 14:31:27,436
any parameter we're going to have

21972
14:31:27,436 --> 14:31:30,160
problems even if we happen to have a

21973
14:31:30,160 --> 14:31:33,200
different return value for the function

21974
14:31:33,200 --> 14:31:35,360
and don't worry if this is not making

21975
14:31:35,360 --> 14:31:38,160
sense yet we will see a lot of examples

21976
14:31:38,160 --> 14:31:40,320
and i am sure by the time we are done

21977
14:31:40,320 --> 14:31:42,560
with this lecture you will be a master

21978
14:31:42,560 --> 14:31:45,040
at using functions okay now that we have

21979
14:31:45,040 --> 14:31:47,436
seen how we can declare or define a

21980
14:31:47,436 --> 14:31:49,520
function in c plus plus let's see how we

21981
14:31:49,520 --> 14:31:51,200
can use the function

21982
14:31:51,200 --> 14:31:53,200
and when you call a function in most

21983
14:31:53,200 --> 14:31:55,520
cases you will want to get something out

21984
14:31:55,520 --> 14:31:58,480
of that function so suppose here result

21985
14:31:58,480 --> 14:32:00,640
var is a variable that is going to catch

21986
14:32:00,640 --> 14:32:02,320
the result of the function

21987
14:32:02,320 --> 14:32:03,680
and we're going to call the function

21988
14:32:03,680 --> 14:32:05,680
with the syntax like this we're going to

21989
14:32:05,680 --> 14:32:08,160
say the function name we're going to put

21990
14:32:08,160 --> 14:32:11,200
our pair of parentheses here and we are

21991
14:32:11,200 --> 14:32:13,680
going to pass in the arguments or of the

21992
14:32:13,680 --> 14:32:16,560
values of our parameters this is the

21993
14:32:16,560 --> 14:32:18,800
syntax it is going to call the function

21994
14:32:18,800 --> 14:32:20,480
and the result of the function is going

21995
14:32:20,480 --> 14:32:24,160
to be assigned to this result var

21996
14:32:24,160 --> 14:32:26,800
variable of hours here is how you can

21997
14:32:26,800 --> 14:32:28,956
call a function that doesn't take any

21998
14:32:28,956 --> 14:32:31,040
parameter the parameter list is

21999
14:32:31,040 --> 14:32:33,360
basically going to be empty and now

22000
14:32:33,360 --> 14:32:35,436
we're going to look at a few examples of

22001
14:32:35,436 --> 14:32:38,240
how you can really declare functions in

22002
14:32:38,240 --> 14:32:40,480
your c plus plus program for example

22003
14:32:40,480 --> 14:32:43,200
here we have a function called into bar

22004
14:32:43,200 --> 14:32:45,360
it doesn't return anything so we can't

22005
14:32:45,360 --> 14:32:47,596
catch the result of this function and

22006
14:32:47,596 --> 14:32:50,160
it's going to have one input in the form

22007
14:32:50,160 --> 14:32:53,116
of an integer so the parameter is called

22008
14:32:53,116 --> 14:32:56,080
h here it's an integer and inside the

22009
14:32:56,080 --> 14:32:58,720
function we are going to test if

22010
14:32:58,720 --> 14:33:02,080
somebody is old enough to enter a bar so

22011
14:33:02,080 --> 14:33:04,320
we do a test to see if the age is

22012
14:33:04,320 --> 14:33:06,640
greater than 18 if it is we're going to

22013
14:33:06,640 --> 14:33:10,560
tell them please proceed f the h is not

22014
14:33:10,560 --> 14:33:12,480
greater than 18 we're going to tell them

22015
14:33:12,480 --> 14:33:15,040
you cannot enter this is an example of a

22016
14:33:15,040 --> 14:33:16,956
function you can set up in your c plus

22017
14:33:16,956 --> 14:33:19,276
plus programs here is another function

22018
14:33:19,276 --> 14:33:21,040
that is going to compute the maximum

22019
14:33:21,040 --> 14:33:23,596
between two numbers it is going to give

22020
14:33:23,596 --> 14:33:26,240
us a result so the return value is an

22021
14:33:26,240 --> 14:33:29,200
integer here the function name is max

22022
14:33:29,200 --> 14:33:31,200
and we're going to put in our list of

22023
14:33:31,200 --> 14:33:33,840
parameters and again these are the

22024
14:33:33,840 --> 14:33:36,720
parameters when you are defining your

22025
14:33:36,720 --> 14:33:37,756
function

22026
14:33:37,756 --> 14:33:40,320
this comma separated list of things we

22027
14:33:40,320 --> 14:33:42,956
have in this parenthesis are called

22028
14:33:42,956 --> 14:33:45,040
parameters and when you call the

22029
14:33:45,040 --> 14:33:47,840
function the values that you pass in the

22030
14:33:47,840 --> 14:33:50,320
places of these parameters are called

22031
14:33:50,320 --> 14:33:53,040
arguments so these are a few terms that

22032
14:33:53,040 --> 14:33:55,276
can really throw you off and i just want

22033
14:33:55,276 --> 14:33:58,000
you to be super clear about these things

22034
14:33:58,000 --> 14:33:59,596
once we have the signature of the

22035
14:33:59,596 --> 14:34:01,840
function set up we jump in the body and

22036
14:34:01,840 --> 14:34:03,680
we do whatever we want this function to

22037
14:34:03,680 --> 14:34:06,240
do so we're going to say if a is greater

22038
14:34:06,240 --> 14:34:08,640
than b then a must be the maximum we're

22039
14:34:08,640 --> 14:34:11,680
going to send it that back to whoever

22040
14:34:11,680 --> 14:34:14,000
called this function or in other words

22041
14:34:14,000 --> 14:34:15,840
we're going to return a

22042
14:34:15,840 --> 14:34:18,880
and if a is not greater than b then b

22043
14:34:18,880 --> 14:34:20,796
must be the maximum and we're going to

22044
14:34:20,796 --> 14:34:22,796
return it that's what we're saying here

22045
14:34:22,796 --> 14:34:24,880
here is another example of a function

22046
14:34:24,880 --> 14:34:27,680
that doesn't have any output and doesn't

22047
14:34:27,680 --> 14:34:30,320
take any input it doesn't return

22048
14:34:30,320 --> 14:34:33,360
anything because the return type is void

22049
14:34:33,360 --> 14:34:35,680
and it doesn't take any input because

22050
14:34:35,680 --> 14:34:38,720
the parameter list here is empty and the

22051
14:34:38,720 --> 14:34:40,640
body of the function we're just going to

22052
14:34:40,640 --> 14:34:43,360
greet somebody and tell them hello there

22053
14:34:43,360 --> 14:34:44,956
and we're going to return out of the

22054
14:34:44,956 --> 14:34:48,000
function notice that for avoid function

22055
14:34:48,000 --> 14:34:50,956
we can either omit the return statement

22056
14:34:50,956 --> 14:34:53,520
here or we can just put it in like this

22057
14:34:53,520 --> 14:34:55,916
say return and the semicolon and

22058
14:34:55,916 --> 14:34:58,080
whatever c plus plus compiler you are

22059
14:34:58,080 --> 14:35:01,040
using is going to accept this as valid c

22060
14:35:01,040 --> 14:35:02,480
plus plus syntax

22061
14:35:02,480 --> 14:35:04,640
here is another example of a function

22062
14:35:04,640 --> 14:35:07,756
that returns something but doesn't take

22063
14:35:07,756 --> 14:35:10,000
any input the return value is going to

22064
14:35:10,000 --> 14:35:12,956
be an integer but we don't need to pass

22065
14:35:12,956 --> 14:35:14,880
something to this function when we call

22066
14:35:14,880 --> 14:35:17,276
it it's just going to give us output we

22067
14:35:17,276 --> 14:35:20,240
can call it and get our lucky number and

22068
14:35:20,240 --> 14:35:22,880
use that however we want in our c plus

22069
14:35:22,880 --> 14:35:25,436
plus application i think we have seen a

22070
14:35:25,436 --> 14:35:27,680
lot of examples of how we can set up

22071
14:35:27,680 --> 14:35:30,320
functions now let's see how we can call

22072
14:35:30,320 --> 14:35:32,796
these functions here is a simple c plus

22073
14:35:32,796 --> 14:35:34,796
plus program in the main function we

22074
14:35:34,796 --> 14:35:37,276
just set up a few variables a value b

22075
14:35:37,276 --> 14:35:40,400
value a and b here and we use those

22076
14:35:40,400 --> 14:35:42,956
variables to call functions remember we

22077
14:35:42,956 --> 14:35:45,360
set up an inter bar function the

22078
14:35:45,360 --> 14:35:47,436
function looked like this and it was

22079
14:35:47,436 --> 14:35:50,400
testing to see if somebody's age was

22080
14:35:50,400 --> 14:35:52,796
greater than 18. if the age is greater

22081
14:35:52,796 --> 14:35:55,756
than 18 they are going to enter the bar

22082
14:35:55,756 --> 14:35:58,320
if the edge is not greater than 18 we

22083
14:35:58,320 --> 14:36:01,116
won't let them end the function takes

22084
14:36:01,116 --> 14:36:03,680
input but it doesn't return anything so

22085
14:36:03,680 --> 14:36:05,680
we can call this function like we do

22086
14:36:05,680 --> 14:36:07,840
here and say into bar

22087
14:36:07,840 --> 14:36:09,756
and you notice that we're not catching

22088
14:36:09,756 --> 14:36:11,520
something out of this function we're

22089
14:36:11,520 --> 14:36:13,596
just going to call it and we're going to

22090
14:36:13,596 --> 14:36:16,880
give it input which is 22 here and the

22091
14:36:16,880 --> 14:36:18,640
function is going to do its thing so

22092
14:36:18,640 --> 14:36:21,916
it's going to let us in because our age

22093
14:36:21,916 --> 14:36:24,880
is greater than 18. down here you see we

22094
14:36:24,880 --> 14:36:28,400
are calling the max function here we are

22095
14:36:28,400 --> 14:36:31,680
giving it two inputs a value and b value

22096
14:36:31,680 --> 14:36:34,000
and it's going to return something and

22097
14:36:34,000 --> 14:36:36,080
the return value of this function is

22098
14:36:36,080 --> 14:36:38,720
going to be used to initialize this

22099
14:36:38,720 --> 14:36:41,680
maximum number variable here this is

22100
14:36:41,680 --> 14:36:44,240
what we are doing if we go down we see

22101
14:36:44,240 --> 14:36:46,160
that we can call the maximum function

22102
14:36:46,160 --> 14:36:49,436
directly and use its return value in an

22103
14:36:49,436 --> 14:36:52,160
sddc out statement here and this is

22104
14:36:52,160 --> 14:36:54,480
going to print out the maximum between a

22105
14:36:54,480 --> 14:36:55,360
and b

22106
14:36:55,360 --> 14:36:57,040
and down here you see we have the

22107
14:36:57,040 --> 14:36:59,276
function say hello which is going to

22108
14:36:59,276 --> 14:37:01,436
just greet somebody and not return

22109
14:37:01,436 --> 14:37:03,840
anything here is another example of how

22110
14:37:03,840 --> 14:37:05,596
you can call the lucky number you say

22111
14:37:05,596 --> 14:37:07,360
lucky number you pass a pair of

22112
14:37:07,360 --> 14:37:08,480
parentheses

22113
14:37:08,480 --> 14:37:10,160
and this is going to return the lucky

22114
14:37:10,160 --> 14:37:13,840
number and print it out in this htdc out

22115
14:37:13,840 --> 14:37:16,880
statement here down here we set up a few

22116
14:37:16,880 --> 14:37:19,840
variables a and b and we are going to

22117
14:37:19,840 --> 14:37:22,320
use them to call the maximum functions

22118
14:37:22,320 --> 14:37:25,116
you see we call max a b or we can even

22119
14:37:25,116 --> 14:37:28,560
pass in number literals like we are

22120
14:37:28,560 --> 14:37:30,640
doing down here

22121
14:37:30,640 --> 14:37:32,400
one thing i want you to be careful about

22122
14:37:32,400 --> 14:37:34,480
is implicit conversions that might

22123
14:37:34,480 --> 14:37:36,080
happen when you are calling you

22124
14:37:36,080 --> 14:37:37,276
functions

22125
14:37:37,276 --> 14:37:39,756
suppose we have a minimum function like

22126
14:37:39,756 --> 14:37:42,080
we see here which is going to be taking

22127
14:37:42,080 --> 14:37:45,596
in integer parameters but here we are

22128
14:37:45,596 --> 14:37:48,320
calling the function with f and g

22129
14:37:48,320 --> 14:37:51,436
which happen to be of double type like

22130
14:37:51,436 --> 14:37:54,080
we see on top here so what is going to

22131
14:37:54,080 --> 14:37:55,840
happen is the compiler is going to

22132
14:37:55,840 --> 14:37:58,240
notice that what you are passing in is

22133
14:37:58,240 --> 14:38:00,640
not really what the function takes but

22134
14:38:00,640 --> 14:38:03,360
the compiler knows that it can insert a

22135
14:38:03,360 --> 14:38:06,880
transformation from double to integer

22136
14:38:06,880 --> 14:38:09,040
and it is going to do that without your

22137
14:38:09,040 --> 14:38:11,756
involvement so be really careful about

22138
14:38:11,756 --> 14:38:14,240
implicit conversions and make sure they

22139
14:38:14,240 --> 14:38:16,956
are working to your advantage otherwise

22140
14:38:16,956 --> 14:38:18,640
you're going to have really hard to

22141
14:38:18,640 --> 14:38:21,200
debug problems in your c plus plus

22142
14:38:21,200 --> 14:38:22,560
programs

22143
14:38:22,560 --> 14:38:24,400
one other thing i want you to be aware

22144
14:38:24,400 --> 14:38:26,640
of is that if we have a function set up

22145
14:38:26,640 --> 14:38:29,360
like this this function is going to be

22146
14:38:29,360 --> 14:38:33,200
taking parameters as copies so if you

22147
14:38:33,200 --> 14:38:35,756
have two variables for example c and d

22148
14:38:35,756 --> 14:38:37,276
and you call this function with those

22149
14:38:37,276 --> 14:38:39,436
two variables you're not going to be

22150
14:38:39,436 --> 14:38:41,680
manipulating those two variables what

22151
14:38:41,680 --> 14:38:44,160
you will be working with inside the body

22152
14:38:44,160 --> 14:38:46,956
of this function are going to be copies

22153
14:38:46,956 --> 14:38:48,720
of the parameters that you passed in

22154
14:38:48,720 --> 14:38:51,040
here so if for example you happen to

22155
14:38:51,040 --> 14:38:53,200
increment either of the parameters for

22156
14:38:53,200 --> 14:38:55,680
example here we increment a and we

22157
14:38:55,680 --> 14:38:56,956
increment b

22158
14:38:56,956 --> 14:38:59,200
the changes we make here inside the body

22159
14:38:59,200 --> 14:39:01,116
of the function are just going to be

22160
14:39:01,116 --> 14:39:03,436
affecting copies we have inside the

22161
14:39:03,436 --> 14:39:05,756
function here and these copies are going

22162
14:39:05,756 --> 14:39:08,796
to die the moment we hit the end of this

22163
14:39:08,796 --> 14:39:10,400
function here this is something i want

22164
14:39:10,400 --> 14:39:12,560
you to be aware of and we will play with

22165
14:39:12,560 --> 14:39:15,200
that in more detail when we hit visual

22166
14:39:15,200 --> 14:39:17,680
studio code in a minute here is a simple

22167
14:39:17,680 --> 14:39:19,276
example of how you can call that

22168
14:39:19,276 --> 14:39:22,640
function we have two variables h and i

22169
14:39:22,640 --> 14:39:25,520
and we are going to print them out after

22170
14:39:25,520 --> 14:39:27,200
that we're going to call the function

22171
14:39:27,200 --> 14:39:30,400
we're going to store the result back in

22172
14:39:30,400 --> 14:39:33,040
mult results but the important thing is

22173
14:39:33,040 --> 14:39:35,200
that we call the function here with h

22174
14:39:35,200 --> 14:39:36,240
and i

22175
14:39:36,240 --> 14:39:38,160
remember in the body of the function we

22176
14:39:38,160 --> 14:39:41,680
are incrementing h and i as arguments

22177
14:39:41,680 --> 14:39:44,720
but the changes we do inside of the body

22178
14:39:44,720 --> 14:39:46,880
of the function are not going to be

22179
14:39:46,880 --> 14:39:50,080
visible when the function returns if we

22180
14:39:50,080 --> 14:39:52,400
print h and i here we're just going to

22181
14:39:52,400 --> 14:39:55,276
see the same thing we saw before we call

22182
14:39:55,276 --> 14:39:56,400
the function

22183
14:39:56,400 --> 14:39:58,400
i realize this is a lot of information

22184
14:39:58,400 --> 14:40:00,796
to take in now we are going to head over

22185
14:40:00,796 --> 14:40:03,040
to visual studio code and actually play

22186
14:40:03,040 --> 14:40:05,200
with us step by step

22187
14:40:05,200 --> 14:40:07,840
okay here we are in our working

22188
14:40:07,840 --> 14:40:10,480
directory the chapter is on functions

22189
14:40:10,480 --> 14:40:12,880
the current lecture is first hand on

22190
14:40:12,880 --> 14:40:15,360
functions we are going to grab our

22191
14:40:15,360 --> 14:40:18,000
template files like we always do we're

22192
14:40:18,000 --> 14:40:19,756
going to put this on

22193
14:40:19,756 --> 14:40:21,680
and we are going to open this in visual

22194
14:40:21,680 --> 14:40:25,520
studio code let's open the folder

22195
14:40:25,520 --> 14:40:27,596
and we are going to go in the correct

22196
14:40:27,596 --> 14:40:28,720
chapter

22197
14:40:28,720 --> 14:40:31,276
and choose first hand on functions here

22198
14:40:31,276 --> 14:40:33,756
this is what we want to open and we are

22199
14:40:33,756 --> 14:40:36,720
going to open our main cpp file and

22200
14:40:36,720 --> 14:40:39,200
clean it up a little bit

22201
14:40:39,200 --> 14:40:41,040
and the first thing we want to do is to

22202
14:40:41,040 --> 14:40:42,796
set up a function that takes a single

22203
14:40:42,796 --> 14:40:45,680
parameter and doesn't give back any

22204
14:40:45,680 --> 14:40:48,080
result so the function is going to be

22205
14:40:48,080 --> 14:40:50,480
interbore we have seen that the function

22206
14:40:50,480 --> 14:40:52,480
is not going to return anything so it's

22207
14:40:52,480 --> 14:40:54,560
going to be void its return type is

22208
14:40:54,560 --> 14:40:56,320
going to be void the name of the

22209
14:40:56,320 --> 14:40:59,116
function is going to be interbar and

22210
14:40:59,116 --> 14:41:00,796
what we want to pass in here is a

22211
14:41:00,796 --> 14:41:02,796
variable to represent the age of

22212
14:41:02,796 --> 14:41:05,360
somebody and we know that the age can

22213
14:41:05,360 --> 14:41:08,240
really not be negative so it is

22214
14:41:08,240 --> 14:41:11,680
advised to at least use an unsigned

22215
14:41:11,680 --> 14:41:13,596
integer type so we're going to use

22216
14:41:13,596 --> 14:41:16,320
unsigned end and the parameter name is

22217
14:41:16,320 --> 14:41:18,320
going to be called age

22218
14:41:18,320 --> 14:41:20,560
once we have our parameter list we're

22219
14:41:20,560 --> 14:41:22,880
going to put in the function body and

22220
14:41:22,880 --> 14:41:24,720
remember the function body is going to

22221
14:41:24,720 --> 14:41:26,796
leave within these two

22222
14:41:26,796 --> 14:41:28,880
curly braces

22223
14:41:28,880 --> 14:41:31,116
now this is a valid c plus plus function

22224
14:41:31,116 --> 14:41:33,116
it's not going to return anything it's

22225
14:41:33,116 --> 14:41:34,796
going to take a single parameter whose

22226
14:41:34,796 --> 14:41:37,680
type is unsigned and its name is

22227
14:41:37,680 --> 14:41:40,240
interbar we can get inside the function

22228
14:41:40,240 --> 14:41:42,160
and actually do whatever it is we want

22229
14:41:42,160 --> 14:41:44,956
to do so once we go in we're going to

22230
14:41:44,956 --> 14:41:47,520
test and see if the age is greater than

22231
14:41:47,520 --> 14:41:50,480
18 do something if the age is not

22232
14:41:50,480 --> 14:41:52,000
greater than 18 we're going to do

22233
14:41:52,000 --> 14:41:53,520
something else let's do that we're going

22234
14:41:53,520 --> 14:41:54,720
to say if

22235
14:41:54,720 --> 14:41:57,680
age is greater than 18 we're going to

22236
14:41:57,680 --> 14:41:59,840
tell them the age and tell them that

22237
14:41:59,840 --> 14:42:03,360
they can actually go in this is logical

22238
14:42:03,360 --> 14:42:05,596
and we're going to say else and in the

22239
14:42:05,596 --> 14:42:08,320
body of this else block

22240
14:42:08,320 --> 14:42:10,240
we're going to say something else

22241
14:42:10,240 --> 14:42:12,400
we're going to tell them sorry you are

22242
14:42:12,400 --> 14:42:14,320
too young for this and we are going to

22243
14:42:14,320 --> 14:42:16,880
get out of this block here and this is

22244
14:42:16,880 --> 14:42:19,360
really our function again let's try to

22245
14:42:19,360 --> 14:42:21,680
analyze the syntax here we have the

22246
14:42:21,680 --> 14:42:24,720
return type this is required in c plus

22247
14:42:24,720 --> 14:42:26,640
plus if you don't put it in you're going

22248
14:42:26,640 --> 14:42:29,200
to get a compiler error because you

22249
14:42:29,200 --> 14:42:31,116
can't have a function without a return

22250
14:42:31,116 --> 14:42:33,436
type in c plus plus you notice that we

22251
14:42:33,436 --> 14:42:35,276
have our squiggly lines here visual

22252
14:42:35,276 --> 14:42:37,520
studio code is not happy so we're going

22253
14:42:37,520 --> 14:42:40,000
to tell it the return type we're going

22254
14:42:40,000 --> 14:42:42,880
to save the function name after that

22255
14:42:42,880 --> 14:42:44,560
and after the function name we're going

22256
14:42:44,560 --> 14:42:47,360
to pass the parameters we can have any

22257
14:42:47,360 --> 14:42:49,916
number of parameters or inputs to the

22258
14:42:49,916 --> 14:42:52,400
function but in this case we just have

22259
14:42:52,400 --> 14:42:54,160
one because it is enough for our

22260
14:42:54,160 --> 14:42:56,796
purposes after that we have the body and

22261
14:42:56,796 --> 14:42:58,796
inside the body we do whatever it is we

22262
14:42:58,796 --> 14:43:01,360
want to do in this function here because

22263
14:43:01,360 --> 14:43:03,840
this function returns void we don't

22264
14:43:03,840 --> 14:43:06,560
really need to explicitly return from

22265
14:43:06,560 --> 14:43:08,796
this function here but this is an

22266
14:43:08,796 --> 14:43:11,520
exception only for functions that return

22267
14:43:11,520 --> 14:43:14,000
void for other return types you will

22268
14:43:14,000 --> 14:43:16,640
have to put in the return statement but

22269
14:43:16,640 --> 14:43:18,720
even for void functions you can put the

22270
14:43:18,720 --> 14:43:20,880
return statement if you want and you can

22271
14:43:20,880 --> 14:43:24,080
do that like this say return

22272
14:43:24,080 --> 14:43:25,520
and you're going to put a semicolon

22273
14:43:25,520 --> 14:43:28,080
after this this is also valid c plus

22274
14:43:28,080 --> 14:43:30,956
plus syntax okay now we have declared

22275
14:43:30,956 --> 14:43:33,116
the function it is a valid c plus plus

22276
14:43:33,116 --> 14:43:35,276
functions let's try and call it we're

22277
14:43:35,276 --> 14:43:37,116
going to go down in main because that's

22278
14:43:37,116 --> 14:43:38,560
where we want to be calling our

22279
14:43:38,560 --> 14:43:41,680
functions for now and we are going to

22280
14:43:41,680 --> 14:43:44,080
say interbar we're going to call the

22281
14:43:44,080 --> 14:43:46,000
function and you use the function name

22282
14:43:46,000 --> 14:43:48,320
to call it and you're going to put in a

22283
14:43:48,320 --> 14:43:51,596
pair of parentheses and pass an argument

22284
14:43:51,596 --> 14:43:54,000
to the function again what you pass to

22285
14:43:54,000 --> 14:43:55,436
the function when you call it it's

22286
14:43:55,436 --> 14:43:57,596
called an argument but what you pass

22287
14:43:57,596 --> 14:43:58,956
through the function when you are

22288
14:43:58,956 --> 14:44:01,520
defining it like we did here that's a

22289
14:44:01,520 --> 14:44:02,640
parameter

22290
14:44:02,640 --> 14:44:04,720
okay so function parameters when

22291
14:44:04,720 --> 14:44:07,116
declaring functions and when you are

22292
14:44:07,116 --> 14:44:09,116
calling the function what you pass are

22293
14:44:09,116 --> 14:44:10,480
function

22294
14:44:10,480 --> 14:44:12,880
arguments and now we need to pass in

22295
14:44:12,880 --> 14:44:15,596
some age to this function and let's say

22296
14:44:15,596 --> 14:44:18,160
22 and if we do that this is going to be

22297
14:44:18,160 --> 14:44:21,520
a valid c plus plus program

22298
14:44:21,520 --> 14:44:23,436
notice that we have this squiggly line

22299
14:44:23,436 --> 14:44:26,720
it is because we forgot a semicolon here

22300
14:44:26,720 --> 14:44:27,680
because

22301
14:44:27,680 --> 14:44:30,880
c plus plus requires to have a semicolon

22302
14:44:30,880 --> 14:44:33,840
after each statement and now we have a

22303
14:44:33,840 --> 14:44:37,116
valid c plus program that is declaring a

22304
14:44:37,116 --> 14:44:39,436
function and calling a function down

22305
14:44:39,436 --> 14:44:42,320
here in main we can try to build it

22306
14:44:42,320 --> 14:44:44,880
let's use gcc to do that the world is

22307
14:44:44,880 --> 14:44:46,720
going to be good you see world finished

22308
14:44:46,720 --> 14:44:49,116
successfully and we can bring up a

22309
14:44:49,116 --> 14:44:51,116
terminal and actually try to run this

22310
14:44:51,116 --> 14:44:53,200
function here let's clear and run

22311
14:44:53,200 --> 14:44:55,360
rooster because our program is going to

22312
14:44:55,360 --> 14:44:57,360
be called rooster like we have been

22313
14:44:57,360 --> 14:44:59,840
doing all along and at the output is

22314
14:44:59,840 --> 14:45:02,560
going to be you are 22

22315
14:45:02,560 --> 14:45:05,360
please proceed notice that we have this

22316
14:45:05,360 --> 14:45:08,240
function defined once but we can call it

22317
14:45:08,240 --> 14:45:10,320
multiple times so for example if you go

22318
14:45:10,320 --> 14:45:12,560
down here and say into bar

22319
14:45:12,560 --> 14:45:15,436
and we give it 15 as the age

22320
14:45:15,436 --> 14:45:18,000
and we try and build again let's build

22321
14:45:18,000 --> 14:45:19,596
with gcc

22322
14:45:19,596 --> 14:45:21,520
the builder is going to be good we can

22323
14:45:21,520 --> 14:45:24,240
clear and run rooster now it's going to

22324
14:45:24,240 --> 14:45:27,200
say you are 15 please proceed why is

22325
14:45:27,200 --> 14:45:28,480
that

22326
14:45:28,480 --> 14:45:30,796
what are we really doing here uh if age

22327
14:45:30,796 --> 14:45:32,880
is greater than 10 we say 10 here we

22328
14:45:32,880 --> 14:45:36,080
should say 18. sorry for this we're

22329
14:45:36,080 --> 14:45:38,880
going to weld again

22330
14:45:38,880 --> 14:45:42,160
and now it should behave accordingly so

22331
14:45:42,160 --> 14:45:43,916
let's say rooster here

22332
14:45:43,916 --> 14:45:46,796
you are 22 please proceed you are too

22333
14:45:46,796 --> 14:45:49,116
young for this no offense because the

22334
14:45:49,116 --> 14:45:52,160
age is 15 here you can keep calling this

22335
14:45:52,160 --> 14:45:53,916
function and you're going to see things

22336
14:45:53,916 --> 14:45:55,680
printing out you can even call this

22337
14:45:55,680 --> 14:45:57,520
function in the loop i can't really

22338
14:45:57,520 --> 14:45:59,596
resist so let's do that we're going to

22339
14:45:59,596 --> 14:46:03,040
say for size t

22340
14:46:03,040 --> 14:46:06,560
i and say start from 0 for example or 1

22341
14:46:06,560 --> 14:46:07,680
why not

22342
14:46:07,680 --> 14:46:10,320
and we are going to say while i is less

22343
14:46:10,320 --> 14:46:11,200
than

22344
14:46:11,200 --> 14:46:12,840
10 or

22345
14:46:12,840 --> 14:46:15,596
20. we're going to increment uh you

22346
14:46:15,596 --> 14:46:18,000
already know how to use loops so we're

22347
14:46:18,000 --> 14:46:20,320
going to be using this as an example

22348
14:46:20,320 --> 14:46:21,680
and we can

22349
14:46:21,680 --> 14:46:23,916
comment out all these guys in front

22350
14:46:23,916 --> 14:46:25,756
because we don't want them to print

22351
14:46:25,756 --> 14:46:27,436
stuff by now

22352
14:46:27,436 --> 14:46:29,520
and what we're going to do is call the

22353
14:46:29,520 --> 14:46:31,916
function with whatever iteration we are

22354
14:46:31,916 --> 14:46:32,880
at

22355
14:46:32,880 --> 14:46:35,360
notice that we have a size t here and

22356
14:46:35,360 --> 14:46:37,840
the function is going to be taken

22357
14:46:37,840 --> 14:46:40,080
an unsigned integer so we're going to

22358
14:46:40,080 --> 14:46:43,840
have implicit conversions from size t

22359
14:46:43,840 --> 14:46:47,680
to end or if we really want this to not

22360
14:46:47,680 --> 14:46:50,720
cause any problems we can change the

22361
14:46:50,720 --> 14:46:53,200
type of our parameter to be size t this

22362
14:46:53,200 --> 14:46:56,400
is also valid c plus plus code let's say

22363
14:46:56,400 --> 14:46:58,880
size t properly

22364
14:46:58,880 --> 14:47:01,200
and if we go down here

22365
14:47:01,200 --> 14:47:02,880
we're going to say

22366
14:47:02,880 --> 14:47:04,320
enter bar

22367
14:47:04,320 --> 14:47:06,640
and we're going to pass an i

22368
14:47:06,640 --> 14:47:08,080
watch what is going to happen this is

22369
14:47:08,080 --> 14:47:09,200
going to loop

22370
14:47:09,200 --> 14:47:12,000
from 1 all the way to 19 and it's going

22371
14:47:12,000 --> 14:47:14,320
to be calling this function with

22372
14:47:14,320 --> 14:47:16,880
whatever iteration we might be at so

22373
14:47:16,880 --> 14:47:19,276
it's going to look from 1 all the way to

22374
14:47:19,276 --> 14:47:21,680
18 and it's going to

22375
14:47:21,680 --> 14:47:23,916
tell us we are too young for this but

22376
14:47:23,916 --> 14:47:26,000
for 19 it's going to let us in because

22377
14:47:26,000 --> 14:47:29,596
we will be old enough to enter a bar

22378
14:47:29,596 --> 14:47:31,276
let's try this i think it's going to be

22379
14:47:31,276 --> 14:47:34,560
fun we're going to weld with gcc

22380
14:47:34,560 --> 14:47:36,320
and we're going to clear

22381
14:47:36,320 --> 14:47:38,956
and run rooster ah sorry you're too

22382
14:47:38,956 --> 14:47:40,720
young for this you too young with us and

22383
14:47:40,720 --> 14:47:42,880
that once we hit 19 it's going to tell

22384
14:47:42,880 --> 14:47:45,116
us we are young enough to enter a bar

22385
14:47:45,116 --> 14:47:47,200
and we're going to go and and have as

22386
14:47:47,200 --> 14:47:50,080
much fun as we want so this is really

22387
14:47:50,080 --> 14:47:53,040
how you can declare a function remember

22388
14:47:53,040 --> 14:47:56,000
a function is uniquely identified by its

22389
14:47:56,000 --> 14:47:58,640
signature and the signature is really

22390
14:47:58,640 --> 14:48:00,720
the name of the function and the

22391
14:48:00,720 --> 14:48:02,880
parameters that you have in here okay

22392
14:48:02,880 --> 14:48:04,240
once you have the function declared

22393
14:48:04,240 --> 14:48:05,596
you're going to do whatever you want in

22394
14:48:05,596 --> 14:48:07,840
the body you are going to optionally

22395
14:48:07,840 --> 14:48:10,160
return something from the function and

22396
14:48:10,160 --> 14:48:13,360
once the function is declared or set up

22397
14:48:13,360 --> 14:48:15,276
you can go in main and call it and do

22398
14:48:15,276 --> 14:48:17,840
whatever it is you want with it okay now

22399
14:48:17,840 --> 14:48:20,400
i think we are mature enough to try out

22400
14:48:20,400 --> 14:48:22,640
a few other functions let's go down and

22401
14:48:22,640 --> 14:48:24,160
put in another function which is going

22402
14:48:24,160 --> 14:48:26,400
to compute the maximum of two numbers

22403
14:48:26,400 --> 14:48:28,000
the signature of this function is going

22404
14:48:28,000 --> 14:48:30,000
to be its name here and the parameters

22405
14:48:30,000 --> 14:48:32,560
notice that we are taking two parameters

22406
14:48:32,560 --> 14:48:34,400
because we want to be computing the

22407
14:48:34,400 --> 14:48:37,116
maximum between two numbers and this

22408
14:48:37,116 --> 14:48:38,880
function is going to return something we

22409
14:48:38,880 --> 14:48:40,796
want to get the maximum out of the

22410
14:48:40,796 --> 14:48:43,200
function and use it to do something else

22411
14:48:43,200 --> 14:48:44,560
when we call it

22412
14:48:44,560 --> 14:48:46,320
so this is the declaration of the

22413
14:48:46,320 --> 14:48:48,240
function once we hit the body of the

22414
14:48:48,240 --> 14:48:49,840
function we are going to compute the

22415
14:48:49,840 --> 14:48:52,240
maximum we're going to say if a is

22416
14:48:52,240 --> 14:48:54,560
greater than b then a must be our

22417
14:48:54,560 --> 14:48:56,956
maximum so we're going to return that

22418
14:48:56,956 --> 14:48:59,840
and if a is not greater than b then b

22419
14:48:59,840 --> 14:49:01,520
must be the maximum we're going to

22420
14:49:01,520 --> 14:49:04,160
return b as our maximum here this is

22421
14:49:04,160 --> 14:49:06,240
what the function is doing we can go in

22422
14:49:06,240 --> 14:49:08,560
main and call it let's go down and

22423
14:49:08,560 --> 14:49:10,560
comment this out because we don't want

22424
14:49:10,560 --> 14:49:13,360
noise output from these guys so calling

22425
14:49:13,360 --> 14:49:15,756
interbore that's what we were doing now

22426
14:49:15,756 --> 14:49:17,916
we are calling max so we're going to go

22427
14:49:17,916 --> 14:49:20,560
down and set up a variable call it

22428
14:49:20,560 --> 14:49:23,116
result why not and we're going to

22429
14:49:23,116 --> 14:49:26,560
compute the maximum between 10 and 20

22430
14:49:26,560 --> 14:49:28,956
why not okay so let's see what we get

22431
14:49:28,956 --> 14:49:30,480
and we're going to print the maximum

22432
14:49:30,480 --> 14:49:32,560
this time we're going to say

22433
14:49:32,560 --> 14:49:36,480
max as resort okay now if we build this

22434
14:49:36,480 --> 14:49:38,400
program and run it try to guess what

22435
14:49:38,400 --> 14:49:39,916
we're going to get we're going to call

22436
14:49:39,916 --> 14:49:41,596
the maximum function

22437
14:49:41,596 --> 14:49:44,640
and what we pass in here are arguments

22438
14:49:44,640 --> 14:49:47,360
again we are not passing parameters here

22439
14:49:47,360 --> 14:49:50,400
we are going to pass in 10 and 20 as our

22440
14:49:50,400 --> 14:49:52,956
arguments and when we call the function

22441
14:49:52,956 --> 14:49:55,040
control is going to jump to the body of

22442
14:49:55,040 --> 14:49:56,796
the function and we are going to fall

22443
14:49:56,796 --> 14:49:58,956
inside here the arguments we're going to

22444
14:49:58,956 --> 14:50:01,200
pass in are just going to be copied in

22445
14:50:01,200 --> 14:50:03,756
the function and we will have them

22446
14:50:03,756 --> 14:50:05,680
through these names a and b so we're

22447
14:50:05,680 --> 14:50:07,436
going to test and see if the first

22448
14:50:07,436 --> 14:50:09,916
parameter is greater than the second in

22449
14:50:09,916 --> 14:50:11,916
this case the first parameter is not

22450
14:50:11,916 --> 14:50:13,840
greater than the second because the

22451
14:50:13,840 --> 14:50:16,000
first one is 10 the second is a 20.

22452
14:50:16,000 --> 14:50:18,640
let's go down and see that and the test

22453
14:50:18,640 --> 14:50:20,480
here is going to fail and we're going to

22454
14:50:20,480 --> 14:50:23,596
run whatever is in the else block here

22455
14:50:23,596 --> 14:50:25,840
and we are going to return b as our

22456
14:50:25,840 --> 14:50:28,000
maximum when we return b

22457
14:50:28,000 --> 14:50:30,400
b is going to basically be the result of

22458
14:50:30,400 --> 14:50:32,080
this expression here

22459
14:50:32,080 --> 14:50:34,240
and that result is going to be assigned

22460
14:50:34,240 --> 14:50:36,000
to our research variable and we're going

22461
14:50:36,000 --> 14:50:38,480
to print it out with this sddc out

22462
14:50:38,480 --> 14:50:40,880
statement here so let's try and build

22463
14:50:40,880 --> 14:50:43,436
this we're going to build with gcc again

22464
14:50:43,436 --> 14:50:45,116
the world is going to be good we're

22465
14:50:45,116 --> 14:50:47,520
going to clear and run rooster you see

22466
14:50:47,520 --> 14:50:50,240
that maximum is 20. if we try and change

22467
14:50:50,240 --> 14:50:51,840
this for example make the first

22468
14:50:51,840 --> 14:50:55,680
parameter 100 and both again

22469
14:50:55,680 --> 14:50:58,320
let's see what maximum we get

22470
14:50:58,320 --> 14:51:00,240
going to clear and run rooster we're

22471
14:51:00,240 --> 14:51:02,956
going to say that maximum is 100 and

22472
14:51:02,956 --> 14:51:04,956
again you can call this function however

22473
14:51:04,956 --> 14:51:07,200
many times you want for example we can

22474
14:51:07,200 --> 14:51:10,320
call it again and say result equals

22475
14:51:10,320 --> 14:51:13,116
max using two variables that we have

22476
14:51:13,116 --> 14:51:15,040
let's say x and y

22477
14:51:15,040 --> 14:51:17,116
and go on top and declare these two

22478
14:51:17,116 --> 14:51:19,276
variables why not we're going to say and

22479
14:51:19,276 --> 14:51:22,956
x and we're going to put in it 22

22480
14:51:22,956 --> 14:51:26,080
and we're going to say end y and put in

22481
14:51:26,080 --> 14:51:27,916
a 44 right now

22482
14:51:27,916 --> 14:51:30,240
and now if we print the result we're

22483
14:51:30,240 --> 14:51:32,560
going to get 44 because that's the

22484
14:51:32,560 --> 14:51:35,840
maximum that was assigned back to our

22485
14:51:35,840 --> 14:51:38,480
research variable here let's weld again

22486
14:51:38,480 --> 14:51:40,160
we're going to run the task to build

22487
14:51:40,160 --> 14:51:42,720
with gcc

22488
14:51:42,720 --> 14:51:45,116
you can clear and run rooster you see

22489
14:51:45,116 --> 14:51:47,916
max is 44 and this is really how you can

22490
14:51:47,916 --> 14:51:50,640
declare and use a maximum function like

22491
14:51:50,640 --> 14:51:51,436
this

22492
14:51:51,436 --> 14:51:52,956
we're going to comment this out because

22493
14:51:52,956 --> 14:51:55,520
we have a few more functions we want to

22494
14:51:55,520 --> 14:51:58,000
try out let's go on top and put in

22495
14:51:58,000 --> 14:52:00,320
another function and again notice that

22496
14:52:00,320 --> 14:52:02,796
we are declaring functions

22497
14:52:02,796 --> 14:52:05,276
before the main function here this is a

22498
14:52:05,276 --> 14:52:07,680
requirement of a c plus plus compiler

22499
14:52:07,680 --> 14:52:10,720
because before you use the function the

22500
14:52:10,720 --> 14:52:13,360
function must be declared somewhere so

22501
14:52:13,360 --> 14:52:16,080
we need to go before the main function

22502
14:52:16,080 --> 14:52:18,560
and declare our functions here the

22503
14:52:18,560 --> 14:52:20,320
function we're going to do now is say

22504
14:52:20,320 --> 14:52:22,320
hello here it's not going to take any

22505
14:52:22,320 --> 14:52:24,480
input and it's not going to give us any

22506
14:52:24,480 --> 14:52:27,040
output it's just going to say hello and

22507
14:52:27,040 --> 14:52:29,756
die off we can go down and call it this

22508
14:52:29,756 --> 14:52:32,160
is going to be super easy calling hello

22509
14:52:32,160 --> 14:52:35,040
and we're going to call it say hello see

22510
14:52:35,040 --> 14:52:37,520
that even visual studio code knows about

22511
14:52:37,520 --> 14:52:39,840
this function we can call it like this

22512
14:52:39,840 --> 14:52:41,596
it's going to be activated so we're

22513
14:52:41,596 --> 14:52:43,040
going to hit the body of the function

22514
14:52:43,040 --> 14:52:45,116
we're going to say hello there and the

22515
14:52:45,116 --> 14:52:47,680
function is going to return or die off

22516
14:52:47,680 --> 14:52:49,520
please know that you could omit this

22517
14:52:49,520 --> 14:52:51,680
return statement for functions that

22518
14:52:51,680 --> 14:52:54,080
return void so if we comment this guy

22519
14:52:54,080 --> 14:52:55,680
out the function is going to work

22520
14:52:55,680 --> 14:52:57,840
equally well you can use this however

22521
14:52:57,840 --> 14:53:00,160
you want now we're just going to build

22522
14:53:00,160 --> 14:53:03,840
with gcc and see this function run

22523
14:53:03,840 --> 14:53:05,436
the build is good we're going to run

22524
14:53:05,436 --> 14:53:08,320
rooster and it is saying hello there

22525
14:53:08,320 --> 14:53:10,796
let's go down and look at another

22526
14:53:10,796 --> 14:53:12,080
example here

22527
14:53:12,080 --> 14:53:14,640
the next function is going to be lucky

22528
14:53:14,640 --> 14:53:17,116
number it's not going to take any input

22529
14:53:17,116 --> 14:53:19,276
but it is going to give us an output in

22530
14:53:19,276 --> 14:53:22,080
the form of an integer so we can call it

22531
14:53:22,080 --> 14:53:24,400
let's go down and comment out saying

22532
14:53:24,400 --> 14:53:27,116
hello here and say that we want to call

22533
14:53:27,116 --> 14:53:28,400
lucky number

22534
14:53:28,400 --> 14:53:30,480
and we can go down and set up a variable

22535
14:53:30,480 --> 14:53:32,400
let's do that we're going to say int

22536
14:53:32,400 --> 14:53:33,680
result

22537
14:53:33,680 --> 14:53:34,880
and we

22538
14:53:34,880 --> 14:53:37,276
are going to brace initialize this guy

22539
14:53:37,276 --> 14:53:39,596
so it's going to be initialized to zero

22540
14:53:39,596 --> 14:53:42,796
and we're going to say result

22541
14:53:42,796 --> 14:53:45,360
equals lucky number and we're going to

22542
14:53:45,360 --> 14:53:48,160
take the result returned by our lucky

22543
14:53:48,160 --> 14:53:50,880
number function and assign that to the

22544
14:53:50,880 --> 14:53:52,720
result variable and we can print it out

22545
14:53:52,720 --> 14:53:56,000
if we want so we can say sddc out and

22546
14:53:56,000 --> 14:53:59,116
say result

22547
14:53:59,116 --> 14:54:01,916
and we're going to put that out here say

22548
14:54:01,916 --> 14:54:04,480
result

22549
14:54:05,360 --> 14:54:08,000
and if we build and run this program

22550
14:54:08,000 --> 14:54:10,320
we're going to get this guy printed out

22551
14:54:10,320 --> 14:54:12,796
we should see a 99 because that's what

22552
14:54:12,796 --> 14:54:15,520
we are returning from our function here

22553
14:54:15,520 --> 14:54:18,400
and resort is 99 as you see in the

22554
14:54:18,400 --> 14:54:20,720
output here so this is really how you

22555
14:54:20,720 --> 14:54:22,480
can declare

22556
14:54:22,480 --> 14:54:24,560
your functions a function has a unique

22557
14:54:24,560 --> 14:54:26,796
signature so for example into bar here

22558
14:54:26,796 --> 14:54:28,956
has this particular name

22559
14:54:28,956 --> 14:54:31,596
and these parameters here

22560
14:54:31,596 --> 14:54:34,560
if you go down mats has its own name and

22561
14:54:34,560 --> 14:54:37,596
the parameters that it takes in if you

22562
14:54:37,596 --> 14:54:40,080
go down say hello and lucky number are

22563
14:54:40,080 --> 14:54:42,796
different in their own ways if you try

22564
14:54:42,796 --> 14:54:44,956
and set up another function that has the

22565
14:54:44,956 --> 14:54:48,160
same signature as max here your compiler

22566
14:54:48,160 --> 14:54:49,916
is going to freak out let's try and do

22567
14:54:49,916 --> 14:54:51,116
that we're going to set up another

22568
14:54:51,116 --> 14:54:52,796
function it's going to have a void

22569
14:54:52,796 --> 14:54:54,720
return type we're going to call it max

22570
14:54:54,720 --> 14:54:56,640
because we want to match this signature

22571
14:54:56,640 --> 14:54:57,520
here

22572
14:54:57,520 --> 14:54:58,956
and we're going to give it two

22573
14:54:58,956 --> 14:55:02,720
parameters into a and it b

22574
14:55:02,720 --> 14:55:04,320
and we can do whatever we want in this

22575
14:55:04,320 --> 14:55:06,080
function notice that we have a squiggly

22576
14:55:06,080 --> 14:55:09,360
line if we open our problems tab here

22577
14:55:09,360 --> 14:55:11,276
you're going to see that visual studio

22578
14:55:11,276 --> 14:55:13,200
code has a few problems with this

22579
14:55:13,200 --> 14:55:16,320
because we are setting up a function

22580
14:55:16,320 --> 14:55:19,116
with the same signature twice let's try

22581
14:55:19,116 --> 14:55:21,200
and different make this a net and see

22582
14:55:21,200 --> 14:55:23,436
what we get right now we don't seem to

22583
14:55:23,436 --> 14:55:25,680
have a problem but if we get to run this

22584
14:55:25,680 --> 14:55:28,720
program we're going to have problems

22585
14:55:28,720 --> 14:55:30,880
let's go down and actually activate the

22586
14:55:30,880 --> 14:55:33,040
code to call the max function to really

22587
14:55:33,040 --> 14:55:34,400
show you this

22588
14:55:34,400 --> 14:55:36,480
because you need to know so we're going

22589
14:55:36,480 --> 14:55:38,796
to comment out calling lucky number and

22590
14:55:38,796 --> 14:55:41,040
we want to call max we're going to

22591
14:55:41,040 --> 14:55:43,520
activate the code to call max

22592
14:55:43,520 --> 14:55:46,640
and we are going to build this with gcc

22593
14:55:46,640 --> 14:55:48,240
notice what we're going to see uh-huh we

22594
14:55:48,240 --> 14:55:50,240
have problems here we have a compiler

22595
14:55:50,240 --> 14:55:53,436
error saying re definition of int max

22596
14:55:53,436 --> 14:55:54,796
and ant

22597
14:55:54,796 --> 14:55:55,680
and

22598
14:55:55,680 --> 14:55:58,720
one might think what if i name my

22599
14:55:58,720 --> 14:56:01,040
parameters differently here for example

22600
14:56:01,040 --> 14:56:02,796
i call this guy

22601
14:56:02,796 --> 14:56:04,080
c

22602
14:56:04,080 --> 14:56:06,400
and this other guy d

22603
14:56:06,400 --> 14:56:07,756
let's do that

22604
14:56:07,756 --> 14:56:09,840
using different names like this is not

22605
14:56:09,840 --> 14:56:11,756
going to solve your troubles because if

22606
14:56:11,756 --> 14:56:14,240
we try and uh bold again we're going to

22607
14:56:14,240 --> 14:56:16,640
get the same compiler error this is not

22608
14:56:16,640 --> 14:56:18,560
going to change your thing we don't have

22609
14:56:18,560 --> 14:56:20,880
enough tools to really understand this

22610
14:56:20,880 --> 14:56:23,520
problem but know that you can't have two

22611
14:56:23,520 --> 14:56:24,720
functions

22612
14:56:24,720 --> 14:56:27,276
with the exact same signature in a

22613
14:56:27,276 --> 14:56:29,436
single c plus plus program and we're

22614
14:56:29,436 --> 14:56:31,680
going to learn more about this later but

22615
14:56:31,680 --> 14:56:34,400
note that the signature of a function

22616
14:56:34,400 --> 14:56:37,040
must be unique to it throughout your

22617
14:56:37,040 --> 14:56:40,160
entire c-plus program if you remember

22618
14:56:40,160 --> 14:56:41,756
this simple rule you're not going to

22619
14:56:41,756 --> 14:56:44,560
have many problems so let's try and weld

22620
14:56:44,560 --> 14:56:46,796
again to make sure we have no more

22621
14:56:46,796 --> 14:56:48,480
problems in here

22622
14:56:48,480 --> 14:56:50,796
the bolt is good and we can run the

22623
14:56:50,796 --> 14:56:53,276
program to see our maximum printed out

22624
14:56:53,276 --> 14:56:56,640
so let's do that clear

22625
14:56:56,840 --> 14:57:00,796
rooster and max is 44 it is exactly what

22626
14:57:00,796 --> 14:57:02,160
we expect

22627
14:57:02,160 --> 14:57:04,080
the last thing i want to do in this

22628
14:57:04,080 --> 14:57:06,480
lecture is make it super clear in your

22629
14:57:06,480 --> 14:57:09,360
mind that what we pass to functions we

22630
14:57:09,360 --> 14:57:11,680
have been setting up so far

22631
14:57:11,680 --> 14:57:15,596
are copies so let's go on top and set up

22632
14:57:15,596 --> 14:57:17,840
a simple function the function is going

22633
14:57:17,840 --> 14:57:20,560
to increment and multiply it returns a

22634
14:57:20,560 --> 14:57:22,956
double type the name of the function is

22635
14:57:22,956 --> 14:57:25,200
increment and multiply and it is going

22636
14:57:25,200 --> 14:57:27,680
to take two parameters and a double a

22637
14:57:27,680 --> 14:57:29,040
and a double b

22638
14:57:29,040 --> 14:57:30,956
once we hit the body of the function

22639
14:57:30,956 --> 14:57:34,240
we're going to increment a and b

22640
14:57:34,240 --> 14:57:36,160
the arguments that were passed to the

22641
14:57:36,160 --> 14:57:38,000
function and we're going to multiply

22642
14:57:38,000 --> 14:57:39,756
them and we're going to store the result

22643
14:57:39,756 --> 14:57:42,720
of that in a reserved variable the

22644
14:57:42,720 --> 14:57:44,240
result variable is what we're going to

22645
14:57:44,240 --> 14:57:46,560
return to the function and whoever

22646
14:57:46,560 --> 14:57:48,320
called this function is going to use

22647
14:57:48,320 --> 14:57:50,880
that to do whatever they want what we

22648
14:57:50,880 --> 14:57:53,276
really want to see is that the changes

22649
14:57:53,276 --> 14:57:55,916
we do inside the function are not going

22650
14:57:55,916 --> 14:57:59,360
to be visible to the arguments that we

22651
14:57:59,360 --> 14:58:01,680
pass to this function here to really

22652
14:58:01,680 --> 14:58:04,240
make this super clear let's go down in

22653
14:58:04,240 --> 14:58:06,160
main and set up a few variables we're

22654
14:58:06,160 --> 14:58:08,880
going to have a double h and the double

22655
14:58:08,880 --> 14:58:11,116
i the values are going to be three and

22656
14:58:11,116 --> 14:58:13,436
four we're going to print them out and

22657
14:58:13,436 --> 14:58:15,276
we're going to call our increment

22658
14:58:15,276 --> 14:58:17,840
multiply function notice that we pass h

22659
14:58:17,840 --> 14:58:18,956
and the i

22660
14:58:18,956 --> 14:58:21,116
to the function and the result of the

22661
14:58:21,116 --> 14:58:24,320
function is going to be stored in uh the

22662
14:58:24,320 --> 14:58:27,200
anc mult resort variable here but the

22663
14:58:27,200 --> 14:58:29,116
return value is really not important

22664
14:58:29,116 --> 14:58:30,720
what we want to see

22665
14:58:30,720 --> 14:58:34,000
is if the changes we do to the arguments

22666
14:58:34,000 --> 14:58:36,080
are going to be visible on the outside

22667
14:58:36,080 --> 14:58:38,880
of the function here so remember we have

22668
14:58:38,880 --> 14:58:40,720
h and i here we pass them to the

22669
14:58:40,720 --> 14:58:42,956
function once we hit the inside of the

22670
14:58:42,956 --> 14:58:44,160
function

22671
14:58:44,160 --> 14:58:46,796
we're going to increment a and b

22672
14:58:46,796 --> 14:58:48,320
and we are going to return from the

22673
14:58:48,320 --> 14:58:50,796
function so let's see

22674
14:58:50,796 --> 14:58:55,276
if a which was a 3 and b which was a 4

22675
14:58:55,276 --> 14:58:57,840
have been incremented to 4 and 5. that's

22676
14:58:57,840 --> 14:58:59,756
what we want to see so we're going to

22677
14:58:59,756 --> 14:59:02,796
boil this and run this so let's use gcc

22678
14:59:02,796 --> 14:59:05,596
to do that the bulk is going to be good

22679
14:59:05,596 --> 14:59:07,276
we're going to clear

22680
14:59:07,276 --> 14:59:09,116
and run rooster

22681
14:59:09,116 --> 14:59:11,200
and notice what we have here let's go

22682
14:59:11,200 --> 14:59:14,160
down and look at the variables again

22683
14:59:14,160 --> 14:59:18,480
we set up h to contain a 3 so before we

22684
14:59:18,480 --> 14:59:20,000
increment h

22685
14:59:20,000 --> 14:59:22,320
and i are four

22686
14:59:22,320 --> 14:59:23,916
okay so that's what we're going to print

22687
14:59:23,916 --> 14:59:26,080
here once we hit the inside of the

22688
14:59:26,080 --> 14:59:27,040
function

22689
14:59:27,040 --> 14:59:29,200
we are going to say what we have inside

22690
14:59:29,200 --> 14:59:31,200
the function before we do the operation

22691
14:59:31,200 --> 14:59:33,916
before the increment again a and b are

22692
14:59:33,916 --> 14:59:36,640
four so these are copies we have inside

22693
14:59:36,640 --> 14:59:37,916
we're going to

22694
14:59:37,916 --> 14:59:40,160
do the increment and after we have the

22695
14:59:40,160 --> 14:59:43,276
increment a and b are going to be four

22696
14:59:43,276 --> 14:59:45,200
but once we hit the outside of the

22697
14:59:45,200 --> 14:59:47,040
function

22698
14:59:47,040 --> 14:59:48,560
and a print

22699
14:59:48,560 --> 14:59:50,320
with this guy here we're going to see

22700
14:59:50,320 --> 14:59:52,560
that h and i

22701
14:59:52,560 --> 14:59:55,040
are still three and four so

22702
14:59:55,040 --> 14:59:58,080
we didn't really affect h and i when we

22703
14:59:58,080 --> 15:00:01,116
did this increment here what we affected

22704
15:00:01,116 --> 15:00:04,560
are copies that were passed to a and b

22705
15:00:04,560 --> 15:00:05,360
here

22706
15:00:05,360 --> 15:00:07,200
and this is something you need to know

22707
15:00:07,200 --> 15:00:08,720
because some people will think that

22708
15:00:08,720 --> 15:00:10,560
because i pass

22709
15:00:10,560 --> 15:00:14,796
h and i in my argument list here i can

22710
15:00:14,796 --> 15:00:16,880
manipulate h and i what you are

22711
15:00:16,880 --> 15:00:19,596
manipulating are copies that were made

22712
15:00:19,596 --> 15:00:22,640
by the compiler to pass the arguments to

22713
15:00:22,640 --> 15:00:24,560
the function here this is something you

22714
15:00:24,560 --> 15:00:26,480
need to keep in mind and we will learn

22715
15:00:26,480 --> 15:00:28,640
more about this but i wanted you to

22716
15:00:28,640 --> 15:00:31,200
learn this firsthand and this is really

22717
15:00:31,200 --> 15:00:33,200
all we set out to do in this lecture i

22718
15:00:33,200 --> 15:00:35,276
hope you have a better understanding of

22719
15:00:35,276 --> 15:00:37,436
what a function is and what you can do

22720
15:00:37,436 --> 15:00:39,436
with it in c plus plus we are going to

22721
15:00:39,436 --> 15:00:41,360
stop here in this lecture in the next

22722
15:00:41,360 --> 15:00:43,040
one we're going to learn a little more

22723
15:00:43,040 --> 15:00:45,916
about function declarations and function

22724
15:00:45,916 --> 15:00:47,360
definitions

22725
15:00:47,360 --> 15:00:49,680
go ahead and finish up here and meet me

22726
15:00:49,680 --> 15:00:51,680
there in this lecture we're going to

22727
15:00:51,680 --> 15:00:54,000
learn about function declarations and

22728
15:00:54,000 --> 15:00:57,040
function definitions the motivation for

22729
15:00:57,040 --> 15:00:58,720
the topic we're going to be talking

22730
15:00:58,720 --> 15:01:01,680
about here is that sometimes you really

22731
15:01:01,680 --> 15:01:05,116
want to separate a function header from

22732
15:01:05,116 --> 15:01:07,116
its implementation because you don't

22733
15:01:07,116 --> 15:01:10,080
want to expose all the details about how

22734
15:01:10,080 --> 15:01:12,080
you do stuff let's look at the simple

22735
15:01:12,080 --> 15:01:14,560
example in the last lecture we declared

22736
15:01:14,560 --> 15:01:16,480
a max function which was computing the

22737
15:01:16,480 --> 15:01:18,956
maximum between two numbers the output

22738
15:01:18,956 --> 15:01:20,560
was an integer so that's what we

22739
15:01:20,560 --> 15:01:22,720
returned the name of the function was

22740
15:01:22,720 --> 15:01:25,596
max and we had two parameters into a and

22741
15:01:25,596 --> 15:01:27,756
and b but what we did in the last

22742
15:01:27,756 --> 15:01:31,040
lecture was crop the entire function

22743
15:01:31,040 --> 15:01:32,080
body

22744
15:01:32,080 --> 15:01:34,400
in front of main but sometimes people

22745
15:01:34,400 --> 15:01:36,480
don't want to really see the details of

22746
15:01:36,480 --> 15:01:39,200
how you do stuff they just want to know

22747
15:01:39,200 --> 15:01:41,276
a summary of what your function does

22748
15:01:41,276 --> 15:01:43,200
what we can get out of the function and

22749
15:01:43,200 --> 15:01:45,756
what we need to give to the function for

22750
15:01:45,756 --> 15:01:48,000
it to do its job and that's what we're

22751
15:01:48,000 --> 15:01:49,916
going to see in this lecture if you look

22752
15:01:49,916 --> 15:01:52,560
here we have the function header in

22753
15:01:52,560 --> 15:01:54,240
front of the main function and the

22754
15:01:54,240 --> 15:01:56,796
function header is made up of its return

22755
15:01:56,796 --> 15:01:59,116
type the name of the function and the

22756
15:01:59,116 --> 15:02:01,520
list of the parameters and after that

22757
15:02:01,520 --> 15:02:03,520
we're going to put a semicolon this is

22758
15:02:03,520 --> 15:02:06,956
called a function header or a prototype

22759
15:02:06,956 --> 15:02:09,116
and when we do that the compiler is

22760
15:02:09,116 --> 15:02:10,880
going to be happy and it's going to work

22761
15:02:10,880 --> 15:02:13,596
with us to compile our program but when

22762
15:02:13,596 --> 15:02:16,400
we get to link our program to really put

22763
15:02:16,400 --> 15:02:18,956
it together and make one binary the

22764
15:02:18,956 --> 15:02:20,640
definition of the function is going to

22765
15:02:20,640 --> 15:02:23,116
be needed and if you look after main

22766
15:02:23,116 --> 15:02:25,360
here what we have is a function

22767
15:02:25,360 --> 15:02:27,596
definition if you look closely you see

22768
15:02:27,596 --> 15:02:30,000
that it is exactly the same thing we had

22769
15:02:30,000 --> 15:02:32,880
in the last lecture we have our header

22770
15:02:32,880 --> 15:02:34,880
information we don't have a semicolon

22771
15:02:34,880 --> 15:02:37,916
after our parameter list but we have a

22772
15:02:37,916 --> 15:02:41,360
pair of curly braces and inside these

22773
15:02:41,360 --> 15:02:44,400
curly braces we have the body of our

22774
15:02:44,400 --> 15:02:45,436
function

22775
15:02:45,436 --> 15:02:46,480
now

22776
15:02:46,480 --> 15:02:48,320
it is really easy to look at this

22777
15:02:48,320 --> 15:02:50,480
program because we don't have to look at

22778
15:02:50,480 --> 15:02:52,560
all these details about how this

22779
15:02:52,560 --> 15:02:54,956
function works we can get

22780
15:02:54,956 --> 15:02:57,360
first-hand information on how we can use

22781
15:02:57,360 --> 15:02:59,840
this function and that is what most

22782
15:02:59,840 --> 15:03:01,680
people are going to be interested in

22783
15:03:01,680 --> 15:03:03,680
about your function they want to really

22784
15:03:03,680 --> 15:03:06,160
want to go in and see how you do stuff

22785
15:03:06,160 --> 15:03:08,320
they will want to use your function to

22786
15:03:08,320 --> 15:03:10,320
get the output and use it to do whatever

22787
15:03:10,320 --> 15:03:12,720
it is they want to do if you look here

22788
15:03:12,720 --> 15:03:15,116
in the body of the main function we have

22789
15:03:15,116 --> 15:03:17,276
two variables a and b and we use them to

22790
15:03:17,276 --> 15:03:19,436
call the maximum function we can also

22791
15:03:19,436 --> 15:03:21,916
set up a minimum function which works in

22792
15:03:21,916 --> 15:03:24,560
the similar way and we call another

22793
15:03:24,560 --> 15:03:26,480
function called increment which is going

22794
15:03:26,480 --> 15:03:28,796
to increment and multiply whatever

22795
15:03:28,796 --> 15:03:31,040
arguments we pass to this function so

22796
15:03:31,040 --> 15:03:33,520
the main idea here is that we can split

22797
15:03:33,520 --> 15:03:36,400
our function in two parts one is going

22798
15:03:36,400 --> 15:03:37,840
to be the function header which is

22799
15:03:37,840 --> 15:03:39,040
really going to be the function

22800
15:03:39,040 --> 15:03:41,756
declaration and the other is going to be

22801
15:03:41,756 --> 15:03:44,400
the function body with all the details

22802
15:03:44,400 --> 15:03:46,160
about how the function works and that's

22803
15:03:46,160 --> 15:03:48,640
going to be our function definition and

22804
15:03:48,640 --> 15:03:50,560
once we have these two things in place

22805
15:03:50,560 --> 15:03:52,400
we can call the function in our main

22806
15:03:52,400 --> 15:03:54,320
function and do whatever we want with

22807
15:03:54,320 --> 15:03:56,640
that okay now it should be super clear

22808
15:03:56,640 --> 15:03:59,040
that we can separate our function in two

22809
15:03:59,040 --> 15:04:01,680
parts declaration and definition and

22810
15:04:01,680 --> 15:04:03,756
sometimes the declaration part is also

22811
15:04:03,756 --> 15:04:05,916
called a prototype that's a prototype of

22812
15:04:05,916 --> 15:04:08,160
a function and it is made up of the

22813
15:04:08,160 --> 15:04:09,520
return type

22814
15:04:09,520 --> 15:04:11,756
together with the function name together

22815
15:04:11,756 --> 15:04:13,520
with the parameters and after that

22816
15:04:13,520 --> 15:04:15,596
you're going to add a semicolon to make

22817
15:04:15,596 --> 15:04:18,956
it valid c plus syntax and another thing

22818
15:04:18,956 --> 15:04:21,200
you should know is that the prototype

22819
15:04:21,200 --> 15:04:24,000
needs to come before wherever it is

22820
15:04:24,000 --> 15:04:25,756
called if you're trying to call a

22821
15:04:25,756 --> 15:04:29,276
function before its prototype is seen in

22822
15:04:29,276 --> 15:04:31,680
your c plus plus program you're going to

22823
15:04:31,680 --> 15:04:33,756
get a compiler error and now you might

22824
15:04:33,756 --> 15:04:37,276
be asking but why did our programs in

22825
15:04:37,276 --> 15:04:39,840
the last lecture work we didn't split

22826
15:04:39,840 --> 15:04:42,400
things up and our program was working

22827
15:04:42,400 --> 15:04:43,276
fine

22828
15:04:43,276 --> 15:04:44,080
well

22829
15:04:44,080 --> 15:04:46,640
if you put a function definition in

22830
15:04:46,640 --> 15:04:49,116
front of the main function that function

22831
15:04:49,116 --> 15:04:51,436
definition is also going to double as a

22832
15:04:51,436 --> 15:04:54,160
function declaration that's why the code

22833
15:04:54,160 --> 15:04:56,796
in the last lecture worked okay now that

22834
15:04:56,796 --> 15:04:58,880
you have an idea about what a function

22835
15:04:58,880 --> 15:05:01,040
declaration and the function definition

22836
15:05:01,040 --> 15:05:03,520
is let's head over to visual studio code

22837
15:05:03,520 --> 15:05:06,560
and play with us okay here we are in our

22838
15:05:06,560 --> 15:05:08,796
working folder the current project is

22839
15:05:08,796 --> 15:05:11,680
function declarations and definitions we

22840
15:05:11,680 --> 15:05:14,000
are going to grab our templates files

22841
15:05:14,000 --> 15:05:16,160
like we always do

22842
15:05:16,160 --> 15:05:18,480
we're going to put them in place

22843
15:05:18,480 --> 15:05:20,796
and we are going to open this guy in

22844
15:05:20,796 --> 15:05:24,000
visual studio code let's do that

22845
15:05:24,000 --> 15:05:25,756
we open this up

22846
15:05:25,756 --> 15:05:28,560
and we are going to open our main cpp

22847
15:05:28,560 --> 15:05:31,840
file clean it up a little bit and let's

22848
15:05:31,840 --> 15:05:33,680
close this pane so that we have some

22849
15:05:33,680 --> 15:05:35,360
breathing space the first thing we're

22850
15:05:35,360 --> 15:05:37,596
going to do is set up a maximum function

22851
15:05:37,596 --> 15:05:39,116
you already know how to do that we're

22852
15:05:39,116 --> 15:05:41,360
going to specify the return type

22853
15:05:41,360 --> 15:05:43,200
we are going to specify the function

22854
15:05:43,200 --> 15:05:44,956
name and the parameters we're going to

22855
15:05:44,956 --> 15:05:47,756
take in it a and into b and we're going

22856
15:05:47,756 --> 15:05:50,000
to go in and do whatever we need to

22857
15:05:50,000 --> 15:05:52,000
compute the maximum between these two

22858
15:05:52,000 --> 15:05:54,560
guys we're going to say if a is greater

22859
15:05:54,560 --> 15:05:55,596
than b

22860
15:05:55,596 --> 15:05:56,480
then

22861
15:05:56,480 --> 15:05:59,040
a must be the maximum so we're going to

22862
15:05:59,040 --> 15:06:00,480
return that

22863
15:06:00,480 --> 15:06:03,436
else we are going to return

22864
15:06:03,436 --> 15:06:04,796
b

22865
15:06:04,796 --> 15:06:06,720
okay this is the function and it is

22866
15:06:06,720 --> 15:06:09,116
really simple we can go down in main and

22867
15:06:09,116 --> 15:06:11,756
use it so let's say ant

22868
15:06:11,756 --> 15:06:14,880
x and i put in a five for example

22869
15:06:14,880 --> 15:06:16,480
and let's say

22870
15:06:16,480 --> 15:06:20,480
y and put in a two or a three put in

22871
15:06:20,480 --> 15:06:21,680
whatever you want

22872
15:06:21,680 --> 15:06:24,240
and then we're going to set up the

22873
15:06:24,240 --> 15:06:25,840
research variable

22874
15:06:25,840 --> 15:06:27,756
which is going to catch the maximum i

22875
15:06:27,756 --> 15:06:29,756
think we can do that and what we're

22876
15:06:29,756 --> 15:06:32,080
going to assign to this is whatever is

22877
15:06:32,080 --> 15:06:34,400
returned from our function call so we're

22878
15:06:34,400 --> 15:06:36,480
going to call this function with x and y

22879
15:06:36,480 --> 15:06:37,840
so we're going to be computing the

22880
15:06:37,840 --> 15:06:39,360
maximum between

22881
15:06:39,360 --> 15:06:42,000
5 and 2 here the maximum is going to be

22882
15:06:42,000 --> 15:06:44,320
stored in this result variable and we're

22883
15:06:44,320 --> 15:06:45,916
going to print it out so we're going to

22884
15:06:45,916 --> 15:06:47,680
say std

22885
15:06:47,680 --> 15:06:50,880
see out and i'm going to say max

22886
15:06:50,880 --> 15:06:54,720
as result this is going to do

22887
15:06:54,720 --> 15:06:57,116
okay let's try and build this and make

22888
15:06:57,116 --> 15:06:59,276
sure it actually works

22889
15:06:59,276 --> 15:07:01,520
this is nothing new so far it is

22890
15:07:01,520 --> 15:07:03,596
everything we have done in the last

22891
15:07:03,596 --> 15:07:05,596
lecture

22892
15:07:05,596 --> 15:07:08,000
now the world is good we can clear and

22893
15:07:08,000 --> 15:07:09,680
run rooster we're going to get the

22894
15:07:09,680 --> 15:07:12,080
maximum as a five here and if we try to

22895
15:07:12,080 --> 15:07:15,116
change this things for example make y 12

22896
15:07:15,116 --> 15:07:16,796
and world again

22897
15:07:16,796 --> 15:07:19,276
we're going to use gcc

22898
15:07:19,276 --> 15:07:21,520
and we are going to clear these thanks

22899
15:07:21,520 --> 15:07:24,240
and run rooster we should get max equals

22900
15:07:24,240 --> 15:07:25,276
12.

22901
15:07:25,276 --> 15:07:28,880
this is all fine and dandy but sometimes

22902
15:07:28,880 --> 15:07:31,756
we don't really want to have the details

22903
15:07:31,756 --> 15:07:35,116
about how our function works shown in

22904
15:07:35,116 --> 15:07:37,596
front of the main function here and we

22905
15:07:37,596 --> 15:07:40,480
can split our function in two parts a

22906
15:07:40,480 --> 15:07:43,040
declaration and a definition the

22907
15:07:43,040 --> 15:07:44,720
declaration is really going to be the

22908
15:07:44,720 --> 15:07:47,040
header part of the function and that's

22909
15:07:47,040 --> 15:07:49,040
going to be the return value the name of

22910
15:07:49,040 --> 15:07:51,680
the function and the parameter list but

22911
15:07:51,680 --> 15:07:54,240
to make it a valid declaration we have

22912
15:07:54,240 --> 15:07:56,956
to put a semicolon after this so this is

22913
15:07:56,956 --> 15:07:58,320
our function

22914
15:07:58,320 --> 15:07:59,756
declaration

22915
15:07:59,756 --> 15:08:04,320
sometimes it is also called a prototype

22916
15:08:04,480 --> 15:08:06,320
and please make sure you understand the

22917
15:08:06,320 --> 15:08:09,040
difference between a prototype and a

22918
15:08:09,040 --> 15:08:11,276
signature in the last lecture we saw

22919
15:08:11,276 --> 15:08:14,320
that the signature was only made of the

22920
15:08:14,320 --> 15:08:16,400
name of the function and the parameter

22921
15:08:16,400 --> 15:08:20,000
list but the return value was not part

22922
15:08:20,000 --> 15:08:21,916
of the function signature but the

22923
15:08:21,916 --> 15:08:24,560
prototype includes all these guys so

22924
15:08:24,560 --> 15:08:27,756
signature doesn't include

22925
15:08:27,756 --> 15:08:30,160
return type

22926
15:08:30,160 --> 15:08:32,880
okay so now that we have our function

22927
15:08:32,880 --> 15:08:36,880
declaration setup we need to put in

22928
15:08:36,880 --> 15:08:38,956
a function definition because if you try

22929
15:08:38,956 --> 15:08:42,080
to compile this program and link it

22930
15:08:42,080 --> 15:08:44,480
you are going to get problems let's try

22931
15:08:44,480 --> 15:08:45,840
and do that before we put in the

22932
15:08:45,840 --> 15:08:47,040
definition

22933
15:08:47,040 --> 15:08:49,840
we can weld with gcc we are learning so

22934
15:08:49,840 --> 15:08:50,956
we don't

22935
15:08:50,956 --> 15:08:52,880
have to fear breaking things a little

22936
15:08:52,880 --> 15:08:53,840
bit

22937
15:08:53,840 --> 15:08:58,400
let's clear and try to build with gcc

22938
15:08:58,400 --> 15:09:00,640
and you're going to see ah we have a

22939
15:09:00,640 --> 15:09:03,116
problem here and what kind of problem we

22940
15:09:03,116 --> 15:09:05,756
have the c plus plus compiler is going

22941
15:09:05,756 --> 15:09:08,720
to compile this program but when we hit

22942
15:09:08,720 --> 15:09:10,320
the link stage

22943
15:09:10,320 --> 15:09:12,240
i realize i haven't really talked about

22944
15:09:12,240 --> 15:09:14,640
this in more detail but we will do in

22945
15:09:14,640 --> 15:09:17,596
this lecture but the main problem here

22946
15:09:17,596 --> 15:09:20,000
is that we don't have the definition of

22947
15:09:20,000 --> 15:09:22,720
this function in place and the compiler

22948
15:09:22,720 --> 15:09:24,480
is going to search for it and not find

22949
15:09:24,480 --> 15:09:26,720
it and you see that it is saying

22950
15:09:26,720 --> 15:09:29,276
undefined reference to max

22951
15:09:29,276 --> 15:09:31,916
okay so it has seen the declaration of

22952
15:09:31,916 --> 15:09:33,116
the function

22953
15:09:33,116 --> 15:09:35,596
but it doesn't know how the function

22954
15:09:35,596 --> 15:09:37,360
does its job because we don't have a

22955
15:09:37,360 --> 15:09:39,916
function body in here so to really make

22956
15:09:39,916 --> 15:09:42,796
this code work exactly as we want we

22957
15:09:42,796 --> 15:09:45,040
need to put in a definition and the

22958
15:09:45,040 --> 15:09:47,276
definition can show up anywhere in your

22959
15:09:47,276 --> 15:09:49,436
c plus plus program in this case we're

22960
15:09:49,436 --> 15:09:50,796
going to put that

22961
15:09:50,796 --> 15:09:52,956
after the main function and the

22962
15:09:52,956 --> 15:09:55,040
definition is really

22963
15:09:55,040 --> 15:09:57,756
what we have been using so far as our

22964
15:09:57,756 --> 15:10:00,080
function definition in the last lecture

22965
15:10:00,080 --> 15:10:02,640
but notice that it has the body

22966
15:10:02,640 --> 15:10:05,680
information and now when the compiler

22967
15:10:05,680 --> 15:10:08,400
tries to compile this program it will

22968
15:10:08,400 --> 15:10:11,200
know how the maximum function is

22969
15:10:11,200 --> 15:10:13,436
computing its maximum because we have

22970
15:10:13,436 --> 15:10:15,436
all that information in here so let's

22971
15:10:15,436 --> 15:10:17,680
say that this is our function definition

22972
15:10:17,680 --> 15:10:21,200
and shows up after main in this case and

22973
15:10:21,200 --> 15:10:23,916
we can try and build this and see if the

22974
15:10:23,916 --> 15:10:25,756
work is good now you see the world is

22975
15:10:25,756 --> 15:10:26,560
good

22976
15:10:26,560 --> 15:10:29,116
and if we try to run it we're going to

22977
15:10:29,116 --> 15:10:32,160
get our maximum exactly like we did when

22978
15:10:32,160 --> 15:10:33,360
we had

22979
15:10:33,360 --> 15:10:35,840
the declaration and the definition

22980
15:10:35,840 --> 15:10:38,160
cramped up before main here but

22981
15:10:38,160 --> 15:10:39,916
hopefully now you can see that our

22982
15:10:39,916 --> 15:10:42,480
program is much cleaner because when you

22983
15:10:42,480 --> 15:10:44,640
look at this you know that we have a

22984
15:10:44,640 --> 15:10:46,640
function called max it's going to take

22985
15:10:46,640 --> 15:10:48,720
two parameters it's going to return

22986
15:10:48,720 --> 15:10:51,200
something and it is called mats so it

22987
15:10:51,200 --> 15:10:53,200
must be computing the maximum of these

22988
15:10:53,200 --> 15:10:56,240
two guys but we don't really care how

22989
15:10:56,240 --> 15:10:58,080
this function does its job how it

22990
15:10:58,080 --> 15:11:00,240
computes the maximum here and this is

22991
15:11:00,240 --> 15:11:02,720
the main message here we can split a

22992
15:11:02,720 --> 15:11:05,840
function in two parts a declaration and

22993
15:11:05,840 --> 15:11:08,400
a definition okay just to play around we

22994
15:11:08,400 --> 15:11:11,040
can also set up a minimum function

22995
15:11:11,040 --> 15:11:13,360
before we do that let's set up its

22996
15:11:13,360 --> 15:11:15,680
definition down here we're just going to

22997
15:11:15,680 --> 15:11:18,320
copy the maximum and adapt it

22998
15:11:18,320 --> 15:11:20,640
we're going to put a copy of that guy

22999
15:11:20,640 --> 15:11:23,916
here we're going to call it men

23000
15:11:23,916 --> 15:11:25,596
it's going to take two parameters it's

23001
15:11:25,596 --> 15:11:27,916
going to return an end but what we test

23002
15:11:27,916 --> 15:11:31,276
for is if a is less than b if a is less

23003
15:11:31,276 --> 15:11:33,756
than b then a is a minimum

23004
15:11:33,756 --> 15:11:36,796
if a is not less than b then b must be

23005
15:11:36,796 --> 15:11:38,796
our minimum and we can put the

23006
15:11:38,796 --> 15:11:40,880
declaration of this function on top here

23007
15:11:40,880 --> 15:11:43,520
so let's go there and say men

23008
15:11:43,520 --> 15:11:47,040
and say end a and end b

23009
15:11:47,040 --> 15:11:48,880
and now we can change the call here to

23010
15:11:48,880 --> 15:11:50,880
say mean and it is going to compute the

23011
15:11:50,880 --> 15:11:53,276
minimum why not let's do that we're

23012
15:11:53,276 --> 15:11:55,200
going to say min here and we're going to

23013
15:11:55,200 --> 15:11:57,596
grab whatever is the minimum between x

23014
15:11:57,596 --> 15:11:59,116
and y here and that's what we're going

23015
15:11:59,116 --> 15:12:01,840
to have in this result variable here

23016
15:12:01,840 --> 15:12:04,080
let's do that we're going to try and use

23017
15:12:04,080 --> 15:12:05,596
this

23018
15:12:05,596 --> 15:12:07,360
the build is good

23019
15:12:07,360 --> 15:12:09,520
so we're going to clear and run rooster

23020
15:12:09,520 --> 15:12:11,756
now the minimum is five we are calling

23021
15:12:11,756 --> 15:12:13,596
our minimum function

23022
15:12:13,596 --> 15:12:15,680
in the last lecture we also set up a

23023
15:12:15,680 --> 15:12:17,916
function to increment and multiply let's

23024
15:12:17,916 --> 15:12:19,756
try and do the same thing

23025
15:12:19,756 --> 15:12:22,560
but split that into a declaration and

23026
15:12:22,560 --> 15:12:24,320
the definition just to practice a little

23027
15:12:24,320 --> 15:12:26,956
more we're going to call this and

23028
15:12:26,956 --> 15:12:30,400
malt and it's going to take a and b in

23029
15:12:30,400 --> 15:12:32,796
and inside and we're not going to put

23030
15:12:32,796 --> 15:12:34,796
the body on top here we're going to put

23031
15:12:34,796 --> 15:12:37,520
the body down with the other definitions

23032
15:12:37,520 --> 15:12:39,436
that we have for all these other

23033
15:12:39,436 --> 15:12:42,080
functions for max and mean here so we're

23034
15:12:42,080 --> 15:12:43,596
going to put in our body it's really

23035
15:12:43,596 --> 15:12:45,680
simple so we're going to put a body

23036
15:12:45,680 --> 15:12:48,080
inside this curly braces

23037
15:12:48,080 --> 15:12:50,560
and we are going to return

23038
15:12:50,560 --> 15:12:51,840
plus a

23039
15:12:51,840 --> 15:12:53,840
we're going to increment a

23040
15:12:53,840 --> 15:12:56,560
and we're going to multiply that with an

23041
15:12:56,560 --> 15:12:58,240
increment of b

23042
15:12:58,240 --> 15:13:00,000
and we're going to return that i think

23043
15:13:00,000 --> 15:13:01,916
this is going to be valid c plus plus

23044
15:13:01,916 --> 15:13:04,160
syntax and if we try to call this

23045
15:13:04,160 --> 15:13:06,560
function in main let's do that say in

23046
15:13:06,560 --> 15:13:09,360
mult and we're going to pass an x and y

23047
15:13:09,360 --> 15:13:11,596
the program is going to just work fine

23048
15:13:11,596 --> 15:13:14,560
we're going to grab the result and store

23049
15:13:14,560 --> 15:13:15,360
that

23050
15:13:15,360 --> 15:13:18,640
in our variable let's do that

23051
15:13:18,640 --> 15:13:21,040
and we can print the result

23052
15:13:21,040 --> 15:13:23,680
and we're going to say result here this

23053
15:13:23,680 --> 15:13:25,840
is going to do

23054
15:13:25,840 --> 15:13:28,240
and if we build and run this program

23055
15:13:28,240 --> 15:13:30,080
we're going to see the output here let's

23056
15:13:30,080 --> 15:13:33,200
see what we get

23057
15:13:33,200 --> 15:13:36,080
the results is going to be 78 because if

23058
15:13:36,080 --> 15:13:38,956
we increment a 5 it becomes a 6.

23059
15:13:38,956 --> 15:13:42,080
if we increment y we're going to get 13

23060
15:13:42,080 --> 15:13:46,160
13 times 6 should be 78 let's be sure

23061
15:13:46,160 --> 15:13:48,720
we're going to bring up the calculator

23062
15:13:48,720 --> 15:13:51,116
let's do that so that you know that i am

23063
15:13:51,116 --> 15:13:54,000
not making these things up 78. so our

23064
15:13:54,000 --> 15:13:56,720
program is really working like it should

23065
15:13:56,720 --> 15:13:58,640
and this is the main message here we can

23066
15:13:58,640 --> 15:14:00,796
really split up functions into a

23067
15:14:00,796 --> 15:14:02,320
declaration

23068
15:14:02,320 --> 15:14:04,640
and a definition and that's going to

23069
15:14:04,640 --> 15:14:07,116
make our programs much easier to work

23070
15:14:07,116 --> 15:14:08,796
with and read

23071
15:14:08,796 --> 15:14:10,720
one thing you should know is that the

23072
15:14:10,720 --> 15:14:13,276
names of the variables aren't really

23073
15:14:13,276 --> 15:14:15,756
important in function declarations like

23074
15:14:15,756 --> 15:14:16,560
this

23075
15:14:16,560 --> 15:14:18,880
so for example we can take out the a and

23076
15:14:18,880 --> 15:14:19,916
b here

23077
15:14:19,916 --> 15:14:22,240
or we can take out all the variable

23078
15:14:22,240 --> 15:14:25,436
names in our function declarations let's

23079
15:14:25,436 --> 15:14:27,276
do that

23080
15:14:27,276 --> 15:14:29,360
and you might think is this program

23081
15:14:29,360 --> 15:14:32,320
going to compile well i hate to break it

23082
15:14:32,320 --> 15:14:34,720
to you but it is going to compile so

23083
15:14:34,720 --> 15:14:37,200
let's weld with gcc

23084
15:14:37,200 --> 15:14:38,560
you're going to see that the both is

23085
15:14:38,560 --> 15:14:41,916
good so the function header or

23086
15:14:41,916 --> 15:14:44,560
declaration doesn't really care about

23087
15:14:44,560 --> 15:14:46,080
the variable names

23088
15:14:46,080 --> 15:14:48,240
in the definitions we care about these

23089
15:14:48,240 --> 15:14:50,240
variable names because we are going to

23090
15:14:50,240 --> 15:14:52,880
be using them in the bodies but if you

23091
15:14:52,880 --> 15:14:55,040
want you can leave them out in your

23092
15:14:55,040 --> 15:14:58,720
function declarations but i like to keep

23093
15:14:58,720 --> 15:15:00,880
them in place because i like my

23094
15:15:00,880 --> 15:15:03,360
functions to be self-documented if

23095
15:15:03,360 --> 15:15:05,360
somebody looks at this they will know

23096
15:15:05,360 --> 15:15:07,756
the variable name here but if you really

23097
15:15:07,756 --> 15:15:09,596
want you can leave the variable names

23098
15:15:09,596 --> 15:15:12,320
out and it is going to work pretty well

23099
15:15:12,320 --> 15:15:13,840
this is really always enough to do in

23100
15:15:13,840 --> 15:15:15,200
this lecture i hope you found it

23101
15:15:15,200 --> 15:15:17,436
interesting we are going to stop here in

23102
15:15:17,436 --> 15:15:19,276
this lecture in the next one we are

23103
15:15:19,276 --> 15:15:20,956
going to see how we can split our

23104
15:15:20,956 --> 15:15:24,000
programs in multiple files now that we

23105
15:15:24,000 --> 15:15:26,160
know how to split into declaration and

23106
15:15:26,160 --> 15:15:27,436
definition

23107
15:15:27,436 --> 15:15:29,756
go ahead and finish up here and meet me

23108
15:15:29,756 --> 15:15:31,436
there

23109
15:15:31,436 --> 15:15:33,680
in this lecture we're going to revisit

23110
15:15:33,680 --> 15:15:36,080
our c plus plus program compilation

23111
15:15:36,080 --> 15:15:38,720
model along the way we are also going to

23112
15:15:38,720 --> 15:15:40,880
see how we can work with functions

23113
15:15:40,880 --> 15:15:43,040
across multiple files

23114
15:15:43,040 --> 15:15:45,436
if you remember our compilation model

23115
15:15:45,436 --> 15:15:47,520
looked something like this you have seen

23116
15:15:47,520 --> 15:15:50,796
this slide a lot of times by now what it

23117
15:15:50,796 --> 15:15:53,040
describes is what happens when we

23118
15:15:53,040 --> 15:15:55,520
compile our program the moment we run

23119
15:15:55,520 --> 15:15:58,400
the compilation command our c plus

23120
15:15:58,400 --> 15:16:01,040
program which lives in the main cpp file

23121
15:16:01,040 --> 15:16:03,360
by now is going to be passed through the

23122
15:16:03,360 --> 15:16:05,276
compiler the compiler is going to

23123
15:16:05,276 --> 15:16:07,200
process it and it is going to come up

23124
15:16:07,200 --> 15:16:10,000
with a binary executable that is mostly

23125
15:16:10,000 --> 15:16:12,320
called rooster in this course and when

23126
15:16:12,320 --> 15:16:15,276
we execute this rooster file or binary

23127
15:16:15,276 --> 15:16:17,520
file we're going to get the program to

23128
15:16:17,520 --> 15:16:20,080
run the program is going to be executed

23129
15:16:20,080 --> 15:16:22,240
instruction by instruction when it is

23130
15:16:22,240 --> 15:16:24,956
loaded by the operating system and we

23131
15:16:24,956 --> 15:16:26,796
are mostly going to see the output of

23132
15:16:26,796 --> 15:16:29,040
that program on the terminal in this

23133
15:16:29,040 --> 15:16:31,596
course this is the compilation model we

23134
15:16:31,596 --> 15:16:35,116
know but now what we want to do is zoom

23135
15:16:35,116 --> 15:16:38,320
in on this compilation part here and see

23136
15:16:38,320 --> 15:16:40,956
what really happens under the hood

23137
15:16:40,956 --> 15:16:43,276
we are going to suppose that we have a

23138
15:16:43,276 --> 15:16:46,240
program which is made of a lot of source

23139
15:16:46,240 --> 15:16:48,560
files as we have here on the left

23140
15:16:48,560 --> 15:16:51,360
suppose we have two three or five source

23141
15:16:51,360 --> 15:16:54,160
files unlike what we have so far which

23142
15:16:54,160 --> 15:16:57,040
is one file the main cpp file when you

23143
15:16:57,040 --> 15:16:58,796
compile such a program you're going to

23144
15:16:58,796 --> 15:17:00,840
go through a stage called

23145
15:17:00,840 --> 15:17:03,360
pre-processing and what this is going to

23146
15:17:03,360 --> 15:17:04,160
do

23147
15:17:04,160 --> 15:17:07,040
it's going to look for your include

23148
15:17:07,040 --> 15:17:08,160
statement

23149
15:17:08,160 --> 15:17:10,400
and it is going to take whatever file

23150
15:17:10,400 --> 15:17:12,880
you are including and it is going to

23151
15:17:12,880 --> 15:17:15,436
paste that in place so for example here

23152
15:17:15,436 --> 15:17:18,160
you see we have an include io stream

23153
15:17:18,160 --> 15:17:19,360
statement

23154
15:17:19,360 --> 15:17:23,436
when the pre-processing stage is run

23155
15:17:23,436 --> 15:17:25,756
this includes statement is going to be

23156
15:17:25,756 --> 15:17:28,880
replaced with whatever we have in this

23157
15:17:28,880 --> 15:17:32,160
io stream file here so this is going to

23158
15:17:32,160 --> 15:17:34,240
be wiped out and we're going to put in

23159
15:17:34,240 --> 15:17:38,240
the content that we have in io stream in

23160
15:17:38,240 --> 15:17:40,320
this exact place where we have the

23161
15:17:40,320 --> 15:17:42,956
include statement i hope this is clear

23162
15:17:42,956 --> 15:17:45,040
so when we go through preprocessing

23163
15:17:45,040 --> 15:17:46,796
we're going to have

23164
15:17:46,796 --> 15:17:49,520
a version of our source files

23165
15:17:49,520 --> 15:17:52,720
with the included parts put in our

23166
15:17:52,720 --> 15:17:54,640
source files we're basically going to go

23167
15:17:54,640 --> 15:17:56,720
copy everything in that file that we

23168
15:17:56,720 --> 15:17:59,840
include and we're going to paste inside

23169
15:17:59,840 --> 15:18:02,796
our new files here that we're going to

23170
15:18:02,796 --> 15:18:05,916
be referring to as translation units by

23171
15:18:05,916 --> 15:18:08,560
now these are translation units in a c

23172
15:18:08,560 --> 15:18:11,276
plus plus program

23173
15:18:11,276 --> 15:18:13,436
once you have this translation unit then

23174
15:18:13,436 --> 15:18:14,956
you're going to compile them they are

23175
15:18:14,956 --> 15:18:16,880
going to go through the compiler the

23176
15:18:16,880 --> 15:18:19,116
compiler is going to generate what we

23177
15:18:19,116 --> 15:18:22,640
call an object file and this is a binary

23178
15:18:22,640 --> 15:18:25,596
representation of the content you have

23179
15:18:25,596 --> 15:18:28,080
in your translation unit so each

23180
15:18:28,080 --> 15:18:30,400
translation unit is going to generate

23181
15:18:30,400 --> 15:18:33,520
one object file and for example if you

23182
15:18:33,520 --> 15:18:36,480
had 20 translation units in your program

23183
15:18:36,480 --> 15:18:39,040
you're going to have 20 object files

23184
15:18:39,040 --> 15:18:41,200
once we have object files they are going

23185
15:18:41,200 --> 15:18:43,200
to be processed by what we call the

23186
15:18:43,200 --> 15:18:44,320
linker

23187
15:18:44,320 --> 15:18:46,320
and the linker is going to stitch them

23188
15:18:46,320 --> 15:18:49,756
together and have one single binary file

23189
15:18:49,756 --> 15:18:52,160
out of all these object files so we're

23190
15:18:52,160 --> 15:18:53,916
going to have something like this and

23191
15:18:53,916 --> 15:18:56,320
this is basically going to be our binary

23192
15:18:56,320 --> 15:18:59,360
that we can run on our target operating

23193
15:18:59,360 --> 15:19:01,596
system so by now you see that our

23194
15:19:01,596 --> 15:19:03,680
compilation model has expanded to

23195
15:19:03,680 --> 15:19:05,756
contain three phases we have

23196
15:19:05,756 --> 15:19:09,040
pre-processing compilation and linking

23197
15:19:09,040 --> 15:19:11,360
now you might be asking why am i showing

23198
15:19:11,360 --> 15:19:14,080
you this now well it is going to matter

23199
15:19:14,080 --> 15:19:15,436
because we're going to split to a

23200
15:19:15,436 --> 15:19:18,560
program across multiple files some of

23201
15:19:18,560 --> 15:19:20,720
those files are going to matter on the

23202
15:19:20,720 --> 15:19:23,200
compilation phase and some of those

23203
15:19:23,200 --> 15:19:25,276
files are going to matter on the linking

23204
15:19:25,276 --> 15:19:28,080
stage so we really need to make a clear

23205
15:19:28,080 --> 15:19:30,160
distinction between the compilation and

23206
15:19:30,160 --> 15:19:32,640
linking here okay this should be a more

23207
15:19:32,640 --> 15:19:35,916
complete compilation model to go by for

23208
15:19:35,916 --> 15:19:37,756
now now that we know about this

23209
15:19:37,756 --> 15:19:40,000
compilation model we can look at how we

23210
15:19:40,000 --> 15:19:42,240
can split our program across multiple

23211
15:19:42,240 --> 15:19:44,400
files suppose we have three functions

23212
15:19:44,400 --> 15:19:46,400
one we can use to get the maximum of two

23213
15:19:46,400 --> 15:19:49,436
numbers called max a function called men

23214
15:19:49,436 --> 15:19:51,436
we can use to get the minimum between

23215
15:19:51,436 --> 15:19:53,916
two numbers and a function we can use to

23216
15:19:53,916 --> 15:19:56,480
increment and multiply like we have seen

23217
15:19:56,480 --> 15:19:57,916
in the last lecture now the two

23218
15:19:57,916 --> 15:19:59,680
functions maths and men are going to

23219
15:19:59,680 --> 15:20:02,640
live in their own file and that file is

23220
15:20:02,640 --> 15:20:04,480
going to be split in two files we're

23221
15:20:04,480 --> 15:20:06,956
going to have a header file and a cpp

23222
15:20:06,956 --> 15:20:08,880
file which is going to contain the

23223
15:20:08,880 --> 15:20:10,956
implementation in the header what we're

23224
15:20:10,956 --> 15:20:13,436
going to have is just a prototype and we

23225
15:20:13,436 --> 15:20:15,520
are going to set up our code in a way

23226
15:20:15,520 --> 15:20:18,240
that our anchor mult function here is

23227
15:20:18,240 --> 15:20:20,640
going to live in zone file we're going

23228
15:20:20,640 --> 15:20:22,560
to split that in two files so we're

23229
15:20:22,560 --> 15:20:24,160
going to have a header file called

23230
15:20:24,160 --> 15:20:25,680
operations.h

23231
15:20:25,680 --> 15:20:26,640
and we're going to have an

23232
15:20:26,640 --> 15:20:28,160
implementation file called

23233
15:20:28,160 --> 15:20:30,080
operations.cpp

23234
15:20:30,080 --> 15:20:31,276
which is going to contain the

23235
15:20:31,276 --> 15:20:33,436
implementation of this function here

23236
15:20:33,436 --> 15:20:35,520
when we hit the main file what we're

23237
15:20:35,520 --> 15:20:37,276
going to do is nothing special we're

23238
15:20:37,276 --> 15:20:40,000
just going to include the headers and we

23239
15:20:40,000 --> 15:20:42,000
are going to use these functions like we

23240
15:20:42,000 --> 15:20:44,240
have been using them all along if you

23241
15:20:44,240 --> 15:20:45,756
look on the first line here we are

23242
15:20:45,756 --> 15:20:48,080
calling max on the second line we are

23243
15:20:48,080 --> 15:20:50,796
calling men and on the third line here

23244
15:20:50,796 --> 15:20:53,840
we are calling incur mult to do whatever

23245
15:20:53,840 --> 15:20:56,400
it does okay when you start splitting

23246
15:20:56,400 --> 15:20:58,400
your functions between the definitions

23247
15:20:58,400 --> 15:21:01,436
and the declarations remember the one

23248
15:21:01,436 --> 15:21:04,240
definition rule and this says that you

23249
15:21:04,240 --> 15:21:07,200
can't have a function defined

23250
15:21:07,200 --> 15:21:10,000
multiple times in your entire c-plus

23251
15:21:10,000 --> 15:21:12,080
class application if you do that the

23252
15:21:12,080 --> 15:21:14,240
lincoln stage is going to find those two

23253
15:21:14,240 --> 15:21:16,560
functions and it's going to

23254
15:21:16,560 --> 15:21:18,796
not know which one you really want to

23255
15:21:18,796 --> 15:21:20,880
use and you're going to get a linker

23256
15:21:20,880 --> 15:21:22,240
error we're going to see that when we

23257
15:21:22,240 --> 15:21:24,560
hit visual studio code in a minute

23258
15:21:24,560 --> 15:21:26,480
another thing is that you know that your

23259
15:21:26,480 --> 15:21:29,040
definition can really leave anywhere in

23260
15:21:29,040 --> 15:21:30,160
your code

23261
15:21:30,160 --> 15:21:32,720
the linker is smart enough to parse your

23262
15:21:32,720 --> 15:21:35,200
entire project looking for

23263
15:21:35,200 --> 15:21:37,596
the definition for whatever function

23264
15:21:37,596 --> 15:21:40,400
it's found in your source code and it's

23265
15:21:40,400 --> 15:21:42,720
going to keep looking until it finishes

23266
15:21:42,720 --> 15:21:45,520
looking in all translation units and

23267
15:21:45,520 --> 15:21:47,756
when it doesn't find the definition it's

23268
15:21:47,756 --> 15:21:49,840
going to give you a link error which is

23269
15:21:49,840 --> 15:21:51,756
probably going to say undefined

23270
15:21:51,756 --> 15:21:53,596
reference to something and we're going

23271
15:21:53,596 --> 15:21:55,840
to see an example of this in a minute

23272
15:21:55,840 --> 15:21:57,680
okay now that you know about this

23273
15:21:57,680 --> 15:21:59,916
updated compilation model and you have

23274
15:21:59,916 --> 15:22:03,200
an idea that we can split our functions

23275
15:22:03,200 --> 15:22:05,360
across multiple files we're going to

23276
15:22:05,360 --> 15:22:07,200
head over to visual studio code and play

23277
15:22:07,200 --> 15:22:08,160
with us

23278
15:22:08,160 --> 15:22:11,436
okay here we are in our working folder

23279
15:22:11,436 --> 15:22:14,240
the current project is multiple files

23280
15:22:14,240 --> 15:22:16,400
here we're going to grab our template

23281
15:22:16,400 --> 15:22:18,880
files let's copy that

23282
15:22:18,880 --> 15:22:22,240
and put that in the project of interest

23283
15:22:22,240 --> 15:22:23,840
and we're going to open this in visual

23284
15:22:23,840 --> 15:22:25,916
studio code let's do that we're going to

23285
15:22:25,916 --> 15:22:28,160
open the folder i'm going to choose the

23286
15:22:28,160 --> 15:22:30,000
project and open it

23287
15:22:30,000 --> 15:22:32,796
and we are going to open up the main cpp

23288
15:22:32,796 --> 15:22:34,320
file here

23289
15:22:34,320 --> 15:22:36,956
and clean it up a little bit we are

23290
15:22:36,956 --> 15:22:39,116
going to set up a max function and

23291
15:22:39,116 --> 15:22:41,276
remember the function has to show up

23292
15:22:41,276 --> 15:22:44,080
before it is used somewhere

23293
15:22:44,080 --> 15:22:47,116
and uh we are going to split this into a

23294
15:22:47,116 --> 15:22:49,680
definition and a declaration i think we

23295
15:22:49,680 --> 15:22:51,916
already know how to do that so let's do

23296
15:22:51,916 --> 15:22:53,276
that we're going to

23297
15:22:53,276 --> 15:22:55,520
put a definition down here and we're

23298
15:22:55,520 --> 15:22:58,240
going to change what we have on top here

23299
15:22:58,240 --> 15:23:01,276
into a declaration let's say that to be

23300
15:23:01,276 --> 15:23:03,840
super clear and what we have down here

23301
15:23:03,840 --> 15:23:05,916
is a definition and we can call this

23302
15:23:05,916 --> 15:23:07,520
function we're going to set up the

23303
15:23:07,520 --> 15:23:09,916
variable which is going to store our max

23304
15:23:09,916 --> 15:23:11,276
for example

23305
15:23:11,276 --> 15:23:13,680
and we're going to assign whatever we

23306
15:23:13,680 --> 15:23:15,360
get from the function

23307
15:23:15,360 --> 15:23:17,680
to max here so we want to find the

23308
15:23:17,680 --> 15:23:22,080
maximum between 34 and 56 for example

23309
15:23:22,080 --> 15:23:23,840
and we're going to print this out i'm

23310
15:23:23,840 --> 15:23:26,880
going to say max is the maximum

23311
15:23:26,880 --> 15:23:29,436
and if we boil and run this program

23312
15:23:29,436 --> 15:23:31,596
let's use gcc to do that we have a

23313
15:23:31,596 --> 15:23:34,320
compiler error here what is that we need

23314
15:23:34,320 --> 15:23:36,560
a semicolon not a column here

23315
15:23:36,560 --> 15:23:38,480
i think the squiggly line is now going

23316
15:23:38,480 --> 15:23:41,360
to go away and our things are named the

23317
15:23:41,360 --> 15:23:43,200
same way the compiler is not going to

23318
15:23:43,200 --> 15:23:45,436
like it let's bring up a terminal so

23319
15:23:45,436 --> 15:23:48,480
that we see our problems tab expression

23320
15:23:48,480 --> 15:23:50,640
preceding parentheses or parallel must

23321
15:23:50,640 --> 15:23:51,680
have

23322
15:23:51,680 --> 15:23:54,240
ah okay the problem here is that these

23323
15:23:54,240 --> 15:23:57,116
two guys max and max are called

23324
15:23:57,116 --> 15:23:59,200
the same and this is going to confuse

23325
15:23:59,200 --> 15:24:01,276
the compiler a little bit so what we're

23326
15:24:01,276 --> 15:24:04,320
going to do is call this maximum

23327
15:24:04,320 --> 15:24:06,480
no big deal here

23328
15:24:06,480 --> 15:24:09,436
and we're going to do maximum here

23329
15:24:09,436 --> 15:24:11,916
and the compiler is going to be happy

23330
15:24:11,916 --> 15:24:14,840
now we can compile and i've built this

23331
15:24:14,840 --> 15:24:18,080
program world is good and if we run it

23332
15:24:18,080 --> 15:24:21,436
we should get our maximum printed out

23333
15:24:21,436 --> 15:24:24,640
let's see that the maximum is 56

23334
15:24:24,640 --> 15:24:29,436
and if we change 34 here to be 134

23335
15:24:29,436 --> 15:24:31,596
and both again we should grab that as

23336
15:24:31,596 --> 15:24:34,160
the maximum let's see if that's the case

23337
15:24:34,160 --> 15:24:35,116
here

23338
15:24:35,116 --> 15:24:38,796
run the program the maximum is 134.

23339
15:24:38,796 --> 15:24:41,840
so this is working exactly as we want

23340
15:24:41,840 --> 15:24:44,560
the next thing we want to do is to split

23341
15:24:44,560 --> 15:24:47,040
this function across multiple files so

23342
15:24:47,040 --> 15:24:48,560
we're going to set up two different

23343
15:24:48,560 --> 15:24:51,116
files one is going to be a header file

23344
15:24:51,116 --> 15:24:53,436
the other is going to be a cpp file and

23345
15:24:53,436 --> 15:24:55,680
you have to follow this structure in c

23346
15:24:55,680 --> 15:24:57,520
plus so we're going to go on the left

23347
15:24:57,520 --> 15:25:00,240
here and add a new file in visual studio

23348
15:25:00,240 --> 15:25:02,720
code you can click on this little icon

23349
15:25:02,720 --> 15:25:05,520
that says new file to create a new file

23350
15:25:05,520 --> 15:25:06,720
once you do that you're going to be

23351
15:25:06,720 --> 15:25:08,796
given this little window in which we can

23352
15:25:08,796 --> 15:25:10,956
type the name of the file we're going to

23353
15:25:10,956 --> 15:25:14,560
call this compare

23354
15:25:14,560 --> 15:25:17,520
dot h it's going to be our header file

23355
15:25:17,520 --> 15:25:19,040
and we're going to add another one which

23356
15:25:19,040 --> 15:25:22,400
is going to say compare that cpp okay

23357
15:25:22,400 --> 15:25:24,480
our two files are going to be compare

23358
15:25:24,480 --> 15:25:27,276
that h and compare that cpp

23359
15:25:27,276 --> 15:25:29,596
and they are going to contain

23360
15:25:29,596 --> 15:25:32,080
our functions to compare stuff so we're

23361
15:25:32,080 --> 15:25:34,560
going to have in a function called max

23362
15:25:34,560 --> 15:25:37,040
and another function called men for

23363
15:25:37,040 --> 15:25:39,436
computing the minimum let's go there and

23364
15:25:39,436 --> 15:25:41,596
actually do that we're going to move our

23365
15:25:41,596 --> 15:25:44,796
declaration in the header file

23366
15:25:44,796 --> 15:25:46,640
so your declarations are going to be

23367
15:25:46,640 --> 15:25:48,880
leaving in header files and we're going

23368
15:25:48,880 --> 15:25:51,916
to grab our definition and move that

23369
15:25:51,916 --> 15:25:54,360
in another file called

23370
15:25:54,360 --> 15:25:57,276
compare.cpp so i'm just going to cut it

23371
15:25:57,276 --> 15:26:01,360
out and paste that and compare cpp here

23372
15:26:01,360 --> 15:26:02,956
once we do that we're going to go back

23373
15:26:02,956 --> 15:26:04,000
in main

23374
15:26:04,000 --> 15:26:06,480
and see that we have a problem now

23375
15:26:06,480 --> 15:26:08,956
the main function doesn't know what this

23376
15:26:08,956 --> 15:26:10,796
max function is because it's not

23377
15:26:10,796 --> 15:26:12,880
declared anymore and if we're trying to

23378
15:26:12,880 --> 15:26:14,480
compile our program we're basically

23379
15:26:14,480 --> 15:26:16,796
going to get the same error we see here

23380
15:26:16,796 --> 15:26:19,596
and visual studio code identifier max is

23381
15:26:19,596 --> 15:26:22,000
undefined because it doesn't know what

23382
15:26:22,000 --> 15:26:24,480
this function is if we ignore this and

23383
15:26:24,480 --> 15:26:26,560
try to weld let's do that we are

23384
15:26:26,560 --> 15:26:29,116
learning so no big deal here we're going

23385
15:26:29,116 --> 15:26:30,956
to get an even

23386
15:26:30,956 --> 15:26:34,240
much weirder error but the message is

23387
15:26:34,240 --> 15:26:36,320
going to be the same maths was not

23388
15:26:36,320 --> 15:26:39,116
declared in the scope so the compiler

23389
15:26:39,116 --> 15:26:41,116
doesn't know what to do with whatever we

23390
15:26:41,116 --> 15:26:43,680
typed here but there is a way in c plus

23391
15:26:43,680 --> 15:26:45,756
plus we can solve this problem by

23392
15:26:45,756 --> 15:26:49,116
including the header that contains our

23393
15:26:49,116 --> 15:26:51,520
declaration for the function that we are

23394
15:26:51,520 --> 15:26:53,756
using here we can go back in main and do

23395
15:26:53,756 --> 15:26:55,916
that and we're going to say include and

23396
15:26:55,916 --> 15:26:59,200
we're going to say compare

23397
15:26:59,200 --> 15:27:00,720
that h

23398
15:27:00,720 --> 15:27:02,720
that's going to bring in our header and

23399
15:27:02,720 --> 15:27:04,080
if you wait a minute you're going to see

23400
15:27:04,080 --> 15:27:05,680
that the squiggly line is going to go

23401
15:27:05,680 --> 15:27:09,756
away so what happened the preprocessor

23402
15:27:09,756 --> 15:27:12,796
is going to come in and copy whatever we

23403
15:27:12,796 --> 15:27:15,520
have inside compare.h it's basically

23404
15:27:15,520 --> 15:27:18,320
going to go and compare that age copy

23405
15:27:18,320 --> 15:27:21,200
everything we have in here and come back

23406
15:27:21,200 --> 15:27:24,080
in main and paste all that in the place

23407
15:27:24,080 --> 15:27:27,116
where we have the include directive here

23408
15:27:27,116 --> 15:27:30,240
this is called an include directive or

23409
15:27:30,240 --> 15:27:33,360
an include preprocessor directive this

23410
15:27:33,360 --> 15:27:35,436
is what the preprocessor is going to do

23411
15:27:35,436 --> 15:27:37,916
here and now if we try to build this

23412
15:27:37,916 --> 15:27:40,000
program let's try to do that we should

23413
15:27:40,000 --> 15:27:43,276
be fine world finished successfully and

23414
15:27:43,276 --> 15:27:45,596
we can run our program to see the

23415
15:27:45,596 --> 15:27:48,160
maximum printed out let's run rooster

23416
15:27:48,160 --> 15:27:51,520
maximum is 134 now everything is working

23417
15:27:51,520 --> 15:27:53,596
let's add another function here because

23418
15:27:53,596 --> 15:27:55,360
just having one function is really

23419
15:27:55,360 --> 15:27:57,276
boring so we're going to put in a main

23420
15:27:57,276 --> 15:27:59,916
function it's going to type into a and

23421
15:27:59,916 --> 15:28:01,040
into b

23422
15:28:01,040 --> 15:28:03,200
and we're going to go in the cpp file

23423
15:28:03,200 --> 15:28:05,680
and put in another definition for the

23424
15:28:05,680 --> 15:28:07,520
minimum function here we're going to

23425
15:28:07,520 --> 15:28:10,160
call this man

23426
15:28:10,160 --> 15:28:13,116
let's do that

23427
15:28:13,520 --> 15:28:15,756
let's call this man and we're going to

23428
15:28:15,756 --> 15:28:18,400
test for a is less than b this is going

23429
15:28:18,400 --> 15:28:21,276
to give us a minimum and now if we go

23430
15:28:21,276 --> 15:28:24,400
back in main cpp we will be able to use

23431
15:28:24,400 --> 15:28:26,400
our minimum function because it is

23432
15:28:26,400 --> 15:28:30,320
protein also by this preprocessor

23433
15:28:30,320 --> 15:28:33,200
directive we have here so we can go down

23434
15:28:33,200 --> 15:28:35,680
and say end minimum and we're going to

23435
15:28:35,680 --> 15:28:36,796
say man

23436
15:28:36,796 --> 15:28:38,360
and let's grab

23437
15:28:38,360 --> 15:28:40,000
146

23438
15:28:40,000 --> 15:28:42,956
and 23 why not and we're going to print

23439
15:28:42,956 --> 15:28:44,880
the minimum here and we're going to

23440
15:28:44,880 --> 15:28:47,520
build this with gcc

23441
15:28:47,520 --> 15:28:49,680
the bullet is going to be good if we run

23442
15:28:49,680 --> 15:28:52,160
this we should see both the maximum and

23443
15:28:52,160 --> 15:28:54,560
the minimum from these calls we make

23444
15:28:54,560 --> 15:28:55,840
here

23445
15:28:55,840 --> 15:28:57,840
okay by now you should have an idea

23446
15:28:57,840 --> 15:29:01,276
about how to split your functions across

23447
15:29:01,276 --> 15:29:03,840
multiple files you should also know that

23448
15:29:03,840 --> 15:29:07,116
you will have to include whatever header

23449
15:29:07,116 --> 15:29:09,520
contains the declarations for the

23450
15:29:09,520 --> 15:29:11,916
functions that you want to use another

23451
15:29:11,916 --> 15:29:14,400
thing i want you to see is that the

23452
15:29:14,400 --> 15:29:16,956
definitions for your functions don't

23453
15:29:16,956 --> 15:29:20,640
have to live in a file that is named the

23454
15:29:20,640 --> 15:29:23,596
same as the header file for example here

23455
15:29:23,596 --> 15:29:25,596
our header file is called compare and

23456
15:29:25,596 --> 15:29:27,116
the comparison tpp contains our

23457
15:29:27,116 --> 15:29:29,840
definitions but the definitions don't

23458
15:29:29,840 --> 15:29:32,400
have to live here they can really live

23459
15:29:32,400 --> 15:29:35,276
in any translation unit that you have in

23460
15:29:35,276 --> 15:29:37,596
your c plus plus program

23461
15:29:37,596 --> 15:29:39,916
and our c plus plus programs the

23462
15:29:39,916 --> 15:29:42,796
translation unit is mostly equivalent to

23463
15:29:42,796 --> 15:29:45,840
a cpp file so let's set up another file

23464
15:29:45,840 --> 15:29:47,436
and show you that we can move this

23465
15:29:47,436 --> 15:29:49,360
definition there and the program is

23466
15:29:49,360 --> 15:29:51,200
going to keep working we're going to add

23467
15:29:51,200 --> 15:29:53,916
another cpp file and call it some

23468
15:29:53,916 --> 15:29:55,680
other file

23469
15:29:55,680 --> 15:29:58,320
that cpp it has to be a cpp file because

23470
15:29:58,320 --> 15:29:59,360
it's going to contain the

23471
15:29:59,360 --> 15:30:02,000
implementations and let's take the

23472
15:30:02,000 --> 15:30:03,840
implementations for example let's take

23473
15:30:03,840 --> 15:30:06,320
them all put them in another file why

23474
15:30:06,320 --> 15:30:07,200
not

23475
15:30:07,200 --> 15:30:09,596
we're going to grab all these guys here

23476
15:30:09,596 --> 15:30:12,080
let's catch them out and put them in

23477
15:30:12,080 --> 15:30:14,160
some other file

23478
15:30:14,160 --> 15:30:16,400
and i'm going to build this and see that

23479
15:30:16,400 --> 15:30:18,640
it works it should

23480
15:30:18,640 --> 15:30:21,116
because the linker is smart enough to go

23481
15:30:21,116 --> 15:30:23,276
find these definitions

23482
15:30:23,276 --> 15:30:25,840
and whatever translation units that we

23483
15:30:25,840 --> 15:30:28,956
have set up in our project here and you

23484
15:30:28,956 --> 15:30:31,436
see the world is good we can upload this

23485
15:30:31,436 --> 15:30:33,200
we can run this i should say and we're

23486
15:30:33,200 --> 15:30:35,360
going to have our output here we can

23487
15:30:35,360 --> 15:30:38,720
even take one of these guys let it leave

23488
15:30:38,720 --> 15:30:40,680
in our

23489
15:30:40,680 --> 15:30:42,956
compare.cpp file for example let's take

23490
15:30:42,956 --> 15:30:45,040
the minimum function here

23491
15:30:45,040 --> 15:30:46,840
and we're going to bring that

23492
15:30:46,840 --> 15:30:49,916
back and we're going to work notice that

23493
15:30:49,916 --> 15:30:50,796
now

23494
15:30:50,796 --> 15:30:54,000
our maximum function is living in some

23495
15:30:54,000 --> 15:30:56,720
other file and that the minimum function

23496
15:30:56,720 --> 15:30:59,200
definition is leaving and compare that

23497
15:30:59,200 --> 15:31:02,080
cpp but if we will this is going to work

23498
15:31:02,080 --> 15:31:04,400
again the linker is

23499
15:31:04,400 --> 15:31:07,040
going to parse all the translation units

23500
15:31:07,040 --> 15:31:08,796
looking for whatever

23501
15:31:08,796 --> 15:31:11,680
definition it needs to find and in this

23502
15:31:11,680 --> 15:31:14,000
case it will be looking for the maximum

23503
15:31:14,000 --> 15:31:17,116
here and it's going to find that in some

23504
15:31:17,116 --> 15:31:19,916
other file and for the

23505
15:31:19,916 --> 15:31:21,756
minimum function here it's going to be

23506
15:31:21,756 --> 15:31:24,000
looking and compare and it is going to

23507
15:31:24,000 --> 15:31:26,000
find it and the world is going to be

23508
15:31:26,000 --> 15:31:28,480
good and we can run the program again

23509
15:31:28,480 --> 15:31:31,520
and see our output here

23510
15:31:31,520 --> 15:31:34,240
one thing i really need to point out is

23511
15:31:34,240 --> 15:31:37,116
that if the definition is not available

23512
15:31:37,116 --> 15:31:39,596
let's say the minimum function here is

23513
15:31:39,596 --> 15:31:42,160
not there we can comment it out to hide

23514
15:31:42,160 --> 15:31:44,560
it to the compiler or hide it from the

23515
15:31:44,560 --> 15:31:45,916
compiler

23516
15:31:45,916 --> 15:31:48,160
and if we try to vote now

23517
15:31:48,160 --> 15:31:50,796
we will get a linker error let's try to

23518
15:31:50,796 --> 15:31:53,040
build with gcc

23519
15:31:53,040 --> 15:31:55,916
uh-huh world finished with errol's the

23520
15:31:55,916 --> 15:31:58,240
terminal process terminated with execute

23521
15:31:58,240 --> 15:32:02,000
code -1 but the main message here is

23522
15:32:02,000 --> 15:32:05,040
that we have an undefined reference to

23523
15:32:05,040 --> 15:32:08,000
min and and so when we compile the

23524
15:32:08,000 --> 15:32:10,320
compiler is going to be happy with the

23525
15:32:10,320 --> 15:32:13,796
declarations that it has found in our

23526
15:32:13,796 --> 15:32:16,640
compare.h file if we go there we see

23527
15:32:16,640 --> 15:32:19,520
that we have a declaration for max and

23528
15:32:19,520 --> 15:32:21,840
the declaration for man the compiler is

23529
15:32:21,840 --> 15:32:23,436
going to be happy it's going to compile

23530
15:32:23,436 --> 15:32:26,000
our code and when the compiler compiles

23531
15:32:26,000 --> 15:32:28,720
it's going to generate object files and

23532
15:32:28,720 --> 15:32:31,040
it will hand the job over to the linker

23533
15:32:31,040 --> 15:32:33,596
to stitch all those little object files

23534
15:32:33,596 --> 15:32:36,560
together to have one single binary file

23535
15:32:36,560 --> 15:32:38,640
once the linker tries to do that it's

23536
15:32:38,640 --> 15:32:40,560
going to look at main because that's

23537
15:32:40,560 --> 15:32:42,796
where it's mostly going to start from

23538
15:32:42,796 --> 15:32:44,640
and it's going to see uh-huh main is

23539
15:32:44,640 --> 15:32:47,116
calling minimum here where is the

23540
15:32:47,116 --> 15:32:49,200
definition for the minimum function it's

23541
15:32:49,200 --> 15:32:51,276
going to parse every single translation

23542
15:32:51,276 --> 15:32:54,000
unit in the project it's going to come

23543
15:32:54,000 --> 15:32:55,840
here and compare that cpp it's not going

23544
15:32:55,840 --> 15:32:57,200
to find it it's going to look in

23545
15:32:57,200 --> 15:32:59,520
main.cpp it's not going to find it it's

23546
15:32:59,520 --> 15:33:01,200
going to look in some other file it's

23547
15:33:01,200 --> 15:33:03,520
not going to find the definition and the

23548
15:33:03,520 --> 15:33:05,116
linker is going to say

23549
15:33:05,116 --> 15:33:07,040
i didn't find my definition for the

23550
15:33:07,040 --> 15:33:09,436
minimum function so i'm going to throw a

23551
15:33:09,436 --> 15:33:11,916
linker error and you the developer

23552
15:33:11,916 --> 15:33:14,560
you're going to fix this problem and

23553
15:33:14,560 --> 15:33:16,240
you're going to see this error here and

23554
15:33:16,240 --> 15:33:20,000
again this is a linker error gcc doesn't

23555
15:33:20,000 --> 15:33:21,040
give you

23556
15:33:21,040 --> 15:33:23,596
more visible stuff to show you that this

23557
15:33:23,596 --> 15:33:25,680
is a linker error but what you should

23558
15:33:25,680 --> 15:33:30,000
look for is ld returned 1 here because

23559
15:33:30,000 --> 15:33:33,916
ld is the linker that gcc uses so this

23560
15:33:33,916 --> 15:33:35,360
is a linker error

23561
15:33:35,360 --> 15:33:37,276
i think i should show you how a linker

23562
15:33:37,276 --> 15:33:39,840
error looks if you are using a microsoft

23563
15:33:39,840 --> 15:33:42,400
compiler so we're going to build again

23564
15:33:42,400 --> 15:33:46,080
but now we're going to build with msvc

23565
15:33:46,080 --> 15:33:47,840
if you don't have visual studio that's

23566
15:33:47,840 --> 15:33:50,560
not a problem you can keep using gcc but

23567
15:33:50,560 --> 15:33:52,956
i just want you to see how different

23568
15:33:52,956 --> 15:33:56,240
compilers handle these arrows i have the

23569
15:33:56,240 --> 15:33:57,840
luxury to do that because i am

23570
15:33:57,840 --> 15:33:59,520
developing this course on a windows

23571
15:33:59,520 --> 15:34:02,560
machine and i have a microsoft compiler

23572
15:34:02,560 --> 15:34:04,956
handy that we can use directly from

23573
15:34:04,956 --> 15:34:07,360
visual studio code here so i am going to

23574
15:34:07,360 --> 15:34:09,116
choose this compiler

23575
15:34:09,116 --> 15:34:10,560
and you're going to see that it is going

23576
15:34:10,560 --> 15:34:12,880
to start welding it is building

23577
15:34:12,880 --> 15:34:15,680
and it is going to fail and throw a link

23578
15:34:15,680 --> 15:34:18,880
arrow also so you see here some other

23579
15:34:18,880 --> 15:34:22,080
object file okay

23580
15:34:22,080 --> 15:34:22,880
when

23581
15:34:22,880 --> 15:34:25,360
this object file was being taken and

23582
15:34:25,360 --> 15:34:27,756
stitched together with other object

23583
15:34:27,756 --> 15:34:30,640
files to put together a binary it didn't

23584
15:34:30,640 --> 15:34:32,880
find the definition for the minimum

23585
15:34:32,880 --> 15:34:34,480
function and it is going to throw a

23586
15:34:34,480 --> 15:34:36,880
linker error and in visual studio you're

23587
15:34:36,880 --> 15:34:39,680
going to have a problem like this l and

23588
15:34:39,680 --> 15:34:40,880
k

23589
15:34:40,880 --> 15:34:42,720
and it's going to give whatever version

23590
15:34:42,720 --> 15:34:44,880
of the compiler you are using but down

23591
15:34:44,880 --> 15:34:47,436
here you see unresolved external symbol

23592
15:34:47,436 --> 15:34:51,116
this is how visual studio says it and

23593
15:34:51,116 --> 15:34:53,040
it's basically going to be

23594
15:34:53,040 --> 15:34:55,360
an undefined reference to something this

23595
15:34:55,360 --> 15:34:57,916
is just visual studio's compiler's way

23596
15:34:57,916 --> 15:35:00,240
to say this and again it's going to say

23597
15:35:00,240 --> 15:35:02,160
this is a linker error here

23598
15:35:02,160 --> 15:35:04,320
it is basically the same error we saw

23599
15:35:04,320 --> 15:35:06,720
when we were using gcc in a minute video

23600
15:35:06,720 --> 15:35:09,040
studio the compiler from microsoft is

23601
15:35:09,040 --> 15:35:11,276
also going to put a lot of junk in our

23602
15:35:11,276 --> 15:35:13,200
folder here so let's remove all these

23603
15:35:13,200 --> 15:35:17,200
things i'm going to select them all

23604
15:35:17,200 --> 15:35:20,160
and i hate to delete here

23605
15:35:20,160 --> 15:35:22,160
and they are going to go to my recycle

23606
15:35:22,160 --> 15:35:24,720
bin and we have another one here we

23607
15:35:24,720 --> 15:35:28,080
should remove let's remove it

23608
15:35:28,080 --> 15:35:30,596
and now we should go back in some other

23609
15:35:30,596 --> 15:35:33,520
file.cpp or compare.cpp that's where we

23610
15:35:33,520 --> 15:35:35,840
have a minimum function we can activate

23611
15:35:35,840 --> 15:35:38,400
it and if we're both now the world

23612
15:35:38,400 --> 15:35:40,240
should be good because the linker is

23613
15:35:40,240 --> 15:35:42,720
going to find this definition here

23614
15:35:42,720 --> 15:35:45,520
okay let's build with gcc because that's

23615
15:35:45,520 --> 15:35:47,840
my favorite compiler

23616
15:35:47,840 --> 15:35:49,916
now you see that the world is good we

23617
15:35:49,916 --> 15:35:52,400
can clear and run rooster and our

23618
15:35:52,400 --> 15:35:54,956
program is going to work as it should

23619
15:35:54,956 --> 15:35:57,520
this is really how you can split your

23620
15:35:57,520 --> 15:36:00,400
functions across multiple files the

23621
15:36:00,400 --> 15:36:01,916
headers are going to contain the

23622
15:36:01,916 --> 15:36:04,480
declarations the cpp files are going to

23623
15:36:04,480 --> 15:36:07,040
contain the definitions your definitions

23624
15:36:07,040 --> 15:36:08,796
can really leave anywhere it's going to

23625
15:36:08,796 --> 15:36:11,916
be a matter of what works better for

23626
15:36:11,916 --> 15:36:14,720
your project but for organizational

23627
15:36:14,720 --> 15:36:17,360
purposes your cpp files are going to be

23628
15:36:17,360 --> 15:36:18,956
basically like this you're going to have

23629
15:36:18,956 --> 15:36:21,756
some declarations in the header like

23630
15:36:21,756 --> 15:36:23,276
compare.h

23631
15:36:23,276 --> 15:36:26,240
and in a corresponding cpp file you're

23632
15:36:26,240 --> 15:36:28,640
going to have and the definitions for

23633
15:36:28,640 --> 15:36:30,480
whatever declarations you have in the

23634
15:36:30,480 --> 15:36:32,720
header but you don't have to do it this

23635
15:36:32,720 --> 15:36:34,480
way if it makes sense for your

23636
15:36:34,480 --> 15:36:36,640
definition to show up somewhere else

23637
15:36:36,640 --> 15:36:38,640
please go ahead and do that c plus plus

23638
15:36:38,640 --> 15:36:40,640
is going to accept that this is really

23639
15:36:40,640 --> 15:36:43,200
all we set out to do in this lecture but

23640
15:36:43,200 --> 15:36:45,520
before we go i'm going to give you a

23641
15:36:45,520 --> 15:36:47,756
chance to set up another function

23642
15:36:47,756 --> 15:36:51,200
suppose we have a function called

23643
15:36:51,200 --> 15:36:54,400
anchor malt and we're going to have the

23644
15:36:54,400 --> 15:36:56,320
function set up in here we're going to

23645
15:36:56,320 --> 15:36:58,000
return

23646
15:36:58,000 --> 15:36:59,840
a plus plus

23647
15:36:59,840 --> 15:37:01,520
we already know how to do these things

23648
15:37:01,520 --> 15:37:03,276
we've used this example a couple of

23649
15:37:03,276 --> 15:37:07,596
times by now plus plus b

23650
15:37:07,596 --> 15:37:09,756
and that's what we're going to return

23651
15:37:09,756 --> 15:37:12,796
now your job is to split this function

23652
15:37:12,796 --> 15:37:14,080
into

23653
15:37:14,080 --> 15:37:16,796
a declaration and a definition and put

23654
15:37:16,796 --> 15:37:19,040
those in two separate files one is going

23655
15:37:19,040 --> 15:37:21,756
to be called operations.h and the other

23656
15:37:21,756 --> 15:37:23,320
is going to be called

23657
15:37:23,320 --> 15:37:26,720
operations.cpp pause the video go ahead

23658
15:37:26,720 --> 15:37:28,560
set up your project like that and call

23659
15:37:28,560 --> 15:37:31,520
that function in main cpp and see if you

23660
15:37:31,520 --> 15:37:33,840
can pull that together okay post the

23661
15:37:33,840 --> 15:37:35,916
video do that and once you are done come

23662
15:37:35,916 --> 15:37:37,916
back again and see how i do this so

23663
15:37:37,916 --> 15:37:39,916
we're going to set up a new file called

23664
15:37:39,916 --> 15:37:42,720
operations here

23665
15:37:42,720 --> 15:37:45,680
it's going to be a header file dot h and

23666
15:37:45,680 --> 15:37:47,360
we're going to add another file called

23667
15:37:47,360 --> 15:37:50,320
operations.cpp

23668
15:37:50,320 --> 15:37:52,956
that's going to be our cpp file which is

23669
15:37:52,956 --> 15:37:56,240
going to contain our definitions we're

23670
15:37:56,240 --> 15:37:58,480
going to go back in main and grab the

23671
15:37:58,480 --> 15:38:01,116
entire function here we don't want it in

23672
15:38:01,116 --> 15:38:03,756
main so we're going to go in

23673
15:38:03,756 --> 15:38:05,916
the header here

23674
15:38:05,916 --> 15:38:08,480
we should go in the operations header

23675
15:38:08,480 --> 15:38:10,400
that's where we want this

23676
15:38:10,400 --> 15:38:12,720
and we're going to put in our definition

23677
15:38:12,720 --> 15:38:13,756
and we're going to put in our

23678
15:38:13,756 --> 15:38:15,756
declaration the declaration doesn't have

23679
15:38:15,756 --> 15:38:17,680
a body so we're just going to put a

23680
15:38:17,680 --> 15:38:19,596
semicolon at the end here you already

23681
15:38:19,596 --> 15:38:21,916
know this we're going to go in the cpp

23682
15:38:21,916 --> 15:38:24,160
file and put in our definition

23683
15:38:24,160 --> 15:38:26,560
this is going to work and to be able to

23684
15:38:26,560 --> 15:38:28,160
use this function

23685
15:38:28,160 --> 15:38:30,640
we will need to include the

23686
15:38:30,640 --> 15:38:33,360
corresponding header here why is this

23687
15:38:33,360 --> 15:38:34,796
file called

23688
15:38:34,796 --> 15:38:37,200
uh it's called ccp

23689
15:38:37,200 --> 15:38:40,160
it's cpp we're going to rename it

23690
15:38:40,160 --> 15:38:44,640
and we're going to change this to cpp

23691
15:38:44,640 --> 15:38:47,200
now we should be fine we should have our

23692
15:38:47,200 --> 15:38:48,640
thanks colored

23693
15:38:48,640 --> 15:38:51,596
properly and uh to use this function we

23694
15:38:51,596 --> 15:38:53,756
will need to include the corresponding

23695
15:38:53,756 --> 15:38:56,320
header which is operations.h

23696
15:38:56,320 --> 15:38:58,480
let's do that we're going to go in main

23697
15:38:58,480 --> 15:39:02,000
and go down and include

23698
15:39:03,276 --> 15:39:06,080
operations

23699
15:39:06,400 --> 15:39:09,200
dot h this is going to work

23700
15:39:09,200 --> 15:39:11,840
and notice that the way we include our

23701
15:39:11,840 --> 15:39:14,400
own headers is different from the way we

23702
15:39:14,400 --> 15:39:15,436
include

23703
15:39:15,436 --> 15:39:18,480
the libraries or headers that come with

23704
15:39:18,480 --> 15:39:20,956
the c plus plus standard library this is

23705
15:39:20,956 --> 15:39:22,720
a conversion that is used by many

23706
15:39:22,720 --> 15:39:25,040
compilers this is how we will have to do

23707
15:39:25,040 --> 15:39:27,596
things please remember this if you are

23708
15:39:27,596 --> 15:39:29,840
including your own header please put

23709
15:39:29,840 --> 15:39:30,720
that

23710
15:39:30,720 --> 15:39:33,680
in the quotes like we do here if you are

23711
15:39:33,680 --> 15:39:36,160
including a standard library header

23712
15:39:36,160 --> 15:39:38,956
please use angle brackets like this now

23713
15:39:38,956 --> 15:39:40,400
that we have this

23714
15:39:40,400 --> 15:39:42,400
included we can go down here and say

23715
15:39:42,400 --> 15:39:43,756
result

23716
15:39:43,756 --> 15:39:45,436
we're going to set up two variables x

23717
15:39:45,436 --> 15:39:46,400
and y

23718
15:39:46,400 --> 15:39:49,916
why not we're going to have a 4 here

23719
15:39:49,916 --> 15:39:53,040
and we're going to have a y which is a

23720
15:39:53,040 --> 15:39:55,520
five let's do that and we're going to

23721
15:39:55,520 --> 15:39:57,756
have an integer to store our results

23722
15:39:57,756 --> 15:40:00,640
it's going to say anchor mount and it's

23723
15:40:00,640 --> 15:40:04,000
going to do the operations on x

23724
15:40:04,000 --> 15:40:06,160
and y let's do that and we're going to

23725
15:40:06,160 --> 15:40:08,880
print the results here so we're going to

23726
15:40:08,880 --> 15:40:11,756
say result

23727
15:40:12,320 --> 15:40:14,720
and it's going to be whatever we have in

23728
15:40:14,720 --> 15:40:17,756
that variable

23729
15:40:18,080 --> 15:40:19,916
okay if we build this program it is

23730
15:40:19,916 --> 15:40:22,480
going to work we're going to use gcc to

23731
15:40:22,480 --> 15:40:25,360
world the world is good if we run it we

23732
15:40:25,360 --> 15:40:27,200
should

23733
15:40:27,200 --> 15:40:30,160
see our output here going to run rooster

23734
15:40:30,160 --> 15:40:32,956
and the result is 24 because

23735
15:40:32,956 --> 15:40:34,956
okay if we increment x we're going to

23736
15:40:34,956 --> 15:40:36,640
get a 5

23737
15:40:36,640 --> 15:40:38,640
and if we increment a 5 we're going to

23738
15:40:38,640 --> 15:40:40,320
get a 6.

23739
15:40:40,320 --> 15:40:42,560
if we multiply these guys we should get

23740
15:40:42,560 --> 15:40:45,436
a 30 and that's not what we have here so

23741
15:40:45,436 --> 15:40:47,756
what is happening let's look at our

23742
15:40:47,756 --> 15:40:49,276
definition here

23743
15:40:49,276 --> 15:40:52,240
ah we said a plus plus

23744
15:40:52,240 --> 15:40:54,320
we should say plus plus a

23745
15:40:54,320 --> 15:40:57,520
because we want to increment immediately

23746
15:40:57,520 --> 15:40:59,276
okay let's build again

23747
15:40:59,276 --> 15:41:00,880
we are going to

23748
15:41:00,880 --> 15:41:02,560
well successfully

23749
15:41:02,560 --> 15:41:04,320
and we are going to clear and run

23750
15:41:04,320 --> 15:41:06,956
rooster now we have the result that we

23751
15:41:06,956 --> 15:41:09,276
expect let's go back in main and look at

23752
15:41:09,276 --> 15:41:11,360
our program this is what we are using

23753
15:41:11,360 --> 15:41:14,480
here and this is the output we expect

23754
15:41:14,480 --> 15:41:16,320
this is really all we set out to do in

23755
15:41:16,320 --> 15:41:18,720
this lecture showing you how you can

23756
15:41:18,720 --> 15:41:21,360
set up your project to split

23757
15:41:21,360 --> 15:41:24,160
functions across multiple files this is

23758
15:41:24,160 --> 15:41:26,240
really good if you want to organize your

23759
15:41:26,240 --> 15:41:28,640
project for example somebody who comes

23760
15:41:28,640 --> 15:41:30,796
to the header here is not going to be

23761
15:41:30,796 --> 15:41:32,560
bothered by looking at all the

23762
15:41:32,560 --> 15:41:34,720
definitions and the details of how we

23763
15:41:34,720 --> 15:41:38,240
compute this maximum and minimum and we

23764
15:41:38,240 --> 15:41:40,880
have the flexibility now to move our

23765
15:41:40,880 --> 15:41:43,436
headers in some other file because we

23766
15:41:43,436 --> 15:41:45,840
really want to keep the main function or

23767
15:41:45,840 --> 15:41:48,796
the main file here really clean we don't

23768
15:41:48,796 --> 15:41:50,956
want all those definitions to show up

23769
15:41:50,956 --> 15:41:53,200
here because it is possible for your

23770
15:41:53,200 --> 15:41:55,916
project to contain hundreds or even

23771
15:41:55,916 --> 15:41:58,160
thousands of definitions if you make all

23772
15:41:58,160 --> 15:42:00,796
those declarations show up in the main

23773
15:42:00,796 --> 15:42:03,436
cpp file here that's going to be really

23774
15:42:03,436 --> 15:42:06,400
hard to follow and work with now we have

23775
15:42:06,400 --> 15:42:09,040
the flexibility to split those guys

23776
15:42:09,040 --> 15:42:11,520
across multiple files and we can even

23777
15:42:11,520 --> 15:42:14,320
use lots of headers if that is what is

23778
15:42:14,320 --> 15:42:16,560
going to work for our project this is

23779
15:42:16,560 --> 15:42:18,000
really all we set out to do in this

23780
15:42:18,000 --> 15:42:20,080
lecture i hope you found it interesting

23781
15:42:20,080 --> 15:42:22,320
we are going to stop here in this one in

23782
15:42:22,320 --> 15:42:23,840
the next one we're going to see how we

23783
15:42:23,840 --> 15:42:26,840
can pass parameters to functions by

23784
15:42:26,840 --> 15:42:29,840
value go ahead and finish up here and

23785
15:42:29,840 --> 15:42:31,116
meet me there

23786
15:42:31,116 --> 15:42:32,720
in this lecture we're going to see what

23787
15:42:32,720 --> 15:42:35,436
is meant by passing parameters to a

23788
15:42:35,436 --> 15:42:37,916
function by value and we're going to

23789
15:42:37,916 --> 15:42:40,080
look at an example of that here we have

23790
15:42:40,080 --> 15:42:42,160
a simple function called say age it's

23791
15:42:42,160 --> 15:42:43,840
going to take one parameter which is an

23792
15:42:43,840 --> 15:42:46,560
integer called age and in the body of

23793
15:42:46,560 --> 15:42:49,680
the function we are printing out the age

23794
15:42:49,680 --> 15:42:52,080
after incrementing it suppose this is

23795
15:42:52,080 --> 15:42:53,520
something useful

23796
15:42:53,520 --> 15:42:56,080
for your program the function is split

23797
15:42:56,080 --> 15:42:58,560
into declaration and definition we have

23798
15:42:58,560 --> 15:43:01,756
a declaration on top here and we have

23799
15:43:01,756 --> 15:43:04,880
our definition below the main function

23800
15:43:04,880 --> 15:43:06,796
in the main function we will attempt to

23801
15:43:06,796 --> 15:43:08,796
use this function we're going to call it

23802
15:43:08,796 --> 15:43:11,360
down here and we're going to pass a

23803
15:43:11,360 --> 15:43:14,080
local variable which is called age as

23804
15:43:14,080 --> 15:43:17,276
our age when we do that we expect this

23805
15:43:17,276 --> 15:43:19,916
to print you are 24 years old because

23806
15:43:19,916 --> 15:43:21,840
we're going to increment the age and

23807
15:43:21,840 --> 15:43:23,756
we're going to say hello you are 24

23808
15:43:23,756 --> 15:43:25,680
years old this is what this program is

23809
15:43:25,680 --> 15:43:28,880
going to do but we want to keep track

23810
15:43:28,880 --> 15:43:31,916
of how the outside variable here is

23811
15:43:31,916 --> 15:43:34,560
going to change and the age we have

23812
15:43:34,560 --> 15:43:37,200
passed as a parameter here because this

23813
15:43:37,200 --> 15:43:39,916
edge we pass as a parameter is not going

23814
15:43:39,916 --> 15:43:42,796
to be the same as the age we have on top

23815
15:43:42,796 --> 15:43:45,116
here what we pass here as a parameter is

23816
15:43:45,116 --> 15:43:47,680
going to be a copy of the actual

23817
15:43:47,680 --> 15:43:50,080
variable that we passed here and this

23818
15:43:50,080 --> 15:43:52,640
mechanism is called passing a parameter

23819
15:43:52,640 --> 15:43:55,116
by value and what you really pass is

23820
15:43:55,116 --> 15:43:57,756
going to be copy and what you work on

23821
15:43:57,756 --> 15:43:59,916
inside the body of the function is not

23822
15:43:59,916 --> 15:44:02,000
going to be the original stuff you

23823
15:44:02,000 --> 15:44:04,560
passed as an argument to the function so

23824
15:44:04,560 --> 15:44:06,560
we're going to try and prove that here

23825
15:44:06,560 --> 15:44:08,320
we're going to print the age before we

23826
15:44:08,320 --> 15:44:10,160
call the function we're going to print

23827
15:44:10,160 --> 15:44:12,640
the age after we call the function and

23828
15:44:12,640 --> 15:44:14,720
what we print here is going to be the

23829
15:44:14,720 --> 15:44:17,436
outside variable because here we are in

23830
15:44:17,436 --> 15:44:18,560
the scope

23831
15:44:18,560 --> 15:44:20,400
of the main function

23832
15:44:20,400 --> 15:44:23,200
inside the say edge function what we're

23833
15:44:23,200 --> 15:44:26,240
going to be modifying is a locker copy

23834
15:44:26,240 --> 15:44:28,720
so we expect the edge here to stay the

23835
15:44:28,720 --> 15:44:32,000
same before and after the function call

23836
15:44:32,000 --> 15:44:33,756
so the way this is going to work when

23837
15:44:33,756 --> 15:44:36,560
control has this function here it's like

23838
15:44:36,560 --> 15:44:38,320
we're going to have a situation like we

23839
15:44:38,320 --> 15:44:40,956
have here on the left we're going to set

23840
15:44:40,956 --> 15:44:43,680
up local copies in the function that are

23841
15:44:43,680 --> 15:44:46,560
going to contain whatever was passed as

23842
15:44:46,560 --> 15:44:49,276
an argument to this function and this

23843
15:44:49,276 --> 15:44:51,680
edge here was passed as an argument to a

23844
15:44:51,680 --> 15:44:53,756
function so we're going to have a local

23845
15:44:53,756 --> 15:44:56,080
copy of this h and we're going to store

23846
15:44:56,080 --> 15:44:57,756
it and it is what we're going to be

23847
15:44:57,756 --> 15:45:00,640
manipulating in our program when the

23848
15:45:00,640 --> 15:45:03,040
function goes out of scope the local

23849
15:45:03,040 --> 15:45:05,360
copy is going to die and the outside

23850
15:45:05,360 --> 15:45:07,040
variable we have here is basically going

23851
15:45:07,040 --> 15:45:09,596
to be unaffected let's head over to

23852
15:45:09,596 --> 15:45:11,916
visual studio code and show you this in

23853
15:45:11,916 --> 15:45:13,116
action

23854
15:45:13,116 --> 15:45:15,916
okay here we are in our working folder

23855
15:45:15,916 --> 15:45:18,160
the current project is passed by value

23856
15:45:18,160 --> 15:45:20,640
we're going to grab our template files

23857
15:45:20,640 --> 15:45:22,880
and we're going to put them in place in

23858
15:45:22,880 --> 15:45:25,596
the correct project and we're going to

23859
15:45:25,596 --> 15:45:28,080
open this up in visual studio code let's

23860
15:45:28,080 --> 15:45:30,000
do that we're going to open the folder

23861
15:45:30,000 --> 15:45:33,040
that contains the project pass by value

23862
15:45:33,040 --> 15:45:36,400
let's do that we are going to open it up

23863
15:45:36,400 --> 15:45:39,520
and i'm going to go in the file and

23864
15:45:39,520 --> 15:45:42,080
clean it up a little bit and we are

23865
15:45:42,080 --> 15:45:44,080
going to set up a function it's going to

23866
15:45:44,080 --> 15:45:46,000
not return anything

23867
15:45:46,000 --> 15:45:49,040
and it's going to say age

23868
15:45:49,040 --> 15:45:50,720
and it's going to take an integer which

23869
15:45:50,720 --> 15:45:52,880
is going to be our age

23870
15:45:52,880 --> 15:45:55,040
and inside we're going to increment our

23871
15:45:55,040 --> 15:45:57,200
h i think this is what we saw in the

23872
15:45:57,200 --> 15:45:59,596
slides and we're going to say however

23873
15:45:59,596 --> 15:46:01,596
many years you are old we're going to

23874
15:46:01,596 --> 15:46:02,880
say hello

23875
15:46:02,880 --> 15:46:04,480
you are

23876
15:46:04,480 --> 15:46:07,596
age old and we can set up a variable and

23877
15:46:07,596 --> 15:46:09,360
the main function we're going to call it

23878
15:46:09,360 --> 15:46:10,560
h

23879
15:46:10,560 --> 15:46:14,240
and it is going to contain 23 as our age

23880
15:46:14,240 --> 15:46:15,916
we're going to say age and we're going

23881
15:46:15,916 --> 15:46:19,040
to pass in our age here we can do that

23882
15:46:19,040 --> 15:46:20,720
if we're trying to run this program

23883
15:46:20,720 --> 15:46:22,796
let's try to do that we're going to

23884
15:46:22,796 --> 15:46:25,916
build with gcc and we are going to bring

23885
15:46:25,916 --> 15:46:28,080
in a terminal we can use to run this

23886
15:46:28,080 --> 15:46:30,080
program easily from

23887
15:46:30,080 --> 15:46:32,000
visual studio code here let's run

23888
15:46:32,000 --> 15:46:33,596
booster we're going to say hello you are

23889
15:46:33,596 --> 15:46:36,080
24 years old and this is what we expect

23890
15:46:36,080 --> 15:46:38,320
because when this function is called

23891
15:46:38,320 --> 15:46:39,840
we're going to increment the age then

23892
15:46:39,840 --> 15:46:42,480
we're going to say the age but we want

23893
15:46:42,480 --> 15:46:43,520
to see

23894
15:46:43,520 --> 15:46:46,796
what happens to the outside edge ear

23895
15:46:46,796 --> 15:46:49,200
if we modify the inside edge that we

23896
15:46:49,200 --> 15:46:51,276
have on this function here that was

23897
15:46:51,276 --> 15:46:53,680
passed as an argument and again what you

23898
15:46:53,680 --> 15:46:55,436
pass when you are declaring your

23899
15:46:55,436 --> 15:46:57,596
function is the parameter and what you

23900
15:46:57,596 --> 15:46:59,520
pass when you are calling the function

23901
15:46:59,520 --> 15:47:01,916
is called an argument in c plus plus

23902
15:47:01,916 --> 15:47:04,000
please remember this okay what we pass

23903
15:47:04,000 --> 15:47:06,480
as an argument is our anti-age variable

23904
15:47:06,480 --> 15:47:09,680
which is local to the main function

23905
15:47:09,680 --> 15:47:11,200
and we're going to see what happens to

23906
15:47:11,200 --> 15:47:14,320
it let's print the age

23907
15:47:14,320 --> 15:47:17,360
and say age before call

23908
15:47:17,360 --> 15:47:19,276
i think this is descriptive enough and

23909
15:47:19,276 --> 15:47:21,040
we're going to print that and we're

23910
15:47:21,040 --> 15:47:23,596
going to go after the function is called

23911
15:47:23,596 --> 15:47:25,680
we're going to say the same thing but

23912
15:47:25,680 --> 15:47:28,000
we're going to say after call

23913
15:47:28,000 --> 15:47:28,796
and

23914
15:47:28,796 --> 15:47:30,796
by after we mean after we call the

23915
15:47:30,796 --> 15:47:32,796
function say h here i think this is

23916
15:47:32,796 --> 15:47:34,720
descriptive enough and we're going to

23917
15:47:34,720 --> 15:47:37,520
see that if incrementing the local

23918
15:47:37,520 --> 15:47:40,080
variable to the function here affects

23919
15:47:40,080 --> 15:47:42,160
the variable that we have and the scope

23920
15:47:42,160 --> 15:47:45,040
of the main function okay so let's see

23921
15:47:45,040 --> 15:47:47,756
that we're going to build with gcc as

23922
15:47:47,756 --> 15:47:50,240
always

23923
15:47:50,240 --> 15:47:52,720
and the wealth is good so let's clear

23924
15:47:52,720 --> 15:47:54,880
and run rooster you're going to see that

23925
15:47:54,880 --> 15:47:57,840
before the call we have 23 and after the

23926
15:47:57,840 --> 15:48:00,560
call we have 23 we didn't change the

23927
15:48:00,560 --> 15:48:02,000
second call

23928
15:48:02,000 --> 15:48:04,240
this is a classical copy paste error

23929
15:48:04,240 --> 15:48:06,240
we're going to change that

23930
15:48:06,240 --> 15:48:08,720
for our program to really be descriptive

23931
15:48:08,720 --> 15:48:10,080
enough

23932
15:48:10,080 --> 15:48:12,320
okay the world is good we can clear and

23933
15:48:12,320 --> 15:48:15,116
run rooster and now we have before call

23934
15:48:15,116 --> 15:48:18,880
23 after call age is 23 it wasn't

23935
15:48:18,880 --> 15:48:22,000
changed by what we have inside here and

23936
15:48:22,000 --> 15:48:24,240
we can even go further and look at the

23937
15:48:24,240 --> 15:48:26,560
memory addresses of these guys

23938
15:48:26,560 --> 15:48:29,596
here we can try and print the address of

23939
15:48:29,596 --> 15:48:31,916
the age variable let's let's do that

23940
15:48:31,916 --> 15:48:34,160
we're going to say

23941
15:48:34,160 --> 15:48:36,400
address of age

23942
15:48:36,400 --> 15:48:39,040
and put that out here we're going to say

23943
15:48:39,040 --> 15:48:41,040
address of age

23944
15:48:41,040 --> 15:48:43,200
no big deal here we can close the pane

23945
15:48:43,200 --> 15:48:46,480
on the left here because it is taking up

23946
15:48:46,480 --> 15:48:48,796
valuable space and we're going to go to

23947
15:48:48,796 --> 15:48:50,956
the second statement and put in the

23948
15:48:50,956 --> 15:48:53,040
address of age

23949
15:48:53,040 --> 15:48:54,720
and we're going to print that out we can

23950
15:48:54,720 --> 15:48:56,480
do that now we know

23951
15:48:56,480 --> 15:48:59,040
the address of operator

23952
15:48:59,040 --> 15:49:00,796
okay we can do that

23953
15:49:00,796 --> 15:49:03,200
and when we hit the body of our function

23954
15:49:03,200 --> 15:49:04,956
here we can also print the address of

23955
15:49:04,956 --> 15:49:06,080
age

23956
15:49:06,080 --> 15:49:07,756
no big deal

23957
15:49:07,756 --> 15:49:09,756
so we can say

23958
15:49:09,756 --> 15:49:12,640
address of age let's do that here and

23959
15:49:12,640 --> 15:49:15,436
we're going to print the address of the

23960
15:49:15,436 --> 15:49:17,840
local edge variable here which was

23961
15:49:17,840 --> 15:49:20,880
passed as a parameter here okay now we

23962
15:49:20,880 --> 15:49:23,520
can build our program and watch those

23963
15:49:23,520 --> 15:49:27,520
addresses we're going to build with gcc

23964
15:49:27,520 --> 15:49:29,680
the world is good we can clear

23965
15:49:29,680 --> 15:49:31,276
and run a rooster

23966
15:49:31,276 --> 15:49:33,840
now you see that the outside variable is

23967
15:49:33,840 --> 15:49:36,480
going to leave at an address that ends

23968
15:49:36,480 --> 15:49:38,000
in dec

23969
15:49:38,000 --> 15:49:39,840
and the local variable is going to leave

23970
15:49:39,840 --> 15:49:43,276
at an address that ends in dc0 so this

23971
15:49:43,276 --> 15:49:46,080
is a completely new memory location that

23972
15:49:46,080 --> 15:49:48,400
we are using and it is just going to

23973
15:49:48,400 --> 15:49:51,916
contain a copy of what we passed as a

23974
15:49:51,916 --> 15:49:54,000
parameter here and the compiler is going

23975
15:49:54,000 --> 15:49:56,240
to take care of setting up this copy

23976
15:49:56,240 --> 15:49:58,956
variable and have it available for use

23977
15:49:58,956 --> 15:50:00,560
in the local function here we don't have

23978
15:50:00,560 --> 15:50:02,796
to worry about that but we have to be

23979
15:50:02,796 --> 15:50:06,080
aware that what we are working on and

23980
15:50:06,080 --> 15:50:08,956
the same age function here is a copy

23981
15:50:08,956 --> 15:50:11,200
it's not the original value this is

23982
15:50:11,200 --> 15:50:12,640
really all we set out to do in this

23983
15:50:12,640 --> 15:50:15,520
lecture making you aware of the call by

23984
15:50:15,520 --> 15:50:18,560
value mechanism and the main message is

23985
15:50:18,560 --> 15:50:21,200
that what you are working on in the body

23986
15:50:21,200 --> 15:50:23,436
of your function when it is called is

23987
15:50:23,436 --> 15:50:25,916
going to be a copy of what you have

23988
15:50:25,916 --> 15:50:29,116
passed as an argument when your function

23989
15:50:29,116 --> 15:50:30,796
was called here

23990
15:50:30,796 --> 15:50:32,320
in this lecture we're going to see how

23991
15:50:32,320 --> 15:50:35,116
we can pass parameters to functions by

23992
15:50:35,116 --> 15:50:37,360
pointer this is going to allow us to

23993
15:50:37,360 --> 15:50:39,276
avoid the copies that we were

23994
15:50:39,276 --> 15:50:41,596
experiencing when we were passing

23995
15:50:41,596 --> 15:50:45,116
parameters by value like we have seen in

23996
15:50:45,116 --> 15:50:47,756
the last few lectures here is a simple

23997
15:50:47,756 --> 15:50:50,240
example showing the syntax we can use to

23998
15:50:50,240 --> 15:50:52,400
pass parameters by pointer

23999
15:50:52,400 --> 15:50:54,720
on top here we have our function

24000
15:50:54,720 --> 15:50:57,436
declaration and down here we have our

24001
15:50:57,436 --> 15:50:59,840
function definition and you see that the

24002
15:50:59,840 --> 15:51:02,080
syntax is the same we are passing by

24003
15:51:02,080 --> 15:51:04,640
pointer and by pointer and the

24004
15:51:04,640 --> 15:51:07,200
definition here and another thing you

24005
15:51:07,200 --> 15:51:09,200
should be careful about is that when you

24006
15:51:09,200 --> 15:51:12,000
call a function that passes by pointer

24007
15:51:12,000 --> 15:51:14,640
you have to give it an address and

24008
15:51:14,640 --> 15:51:16,560
that's what we are doing here so we are

24009
15:51:16,560 --> 15:51:20,160
passing the address of our age variable

24010
15:51:20,160 --> 15:51:22,400
which is going to be passed by pointer

24011
15:51:22,400 --> 15:51:24,720
when we pass by pointer we want to be

24012
15:51:24,720 --> 15:51:28,640
modifying a copy inside the body of our

24013
15:51:28,640 --> 15:51:31,360
function if you look here we are

24014
15:51:31,360 --> 15:51:34,320
incrementing the edge variable but we

24015
15:51:34,320 --> 15:51:36,956
are doing this through the referencing

24016
15:51:36,956 --> 15:51:39,040
so when we pass a pointer here the

24017
15:51:39,040 --> 15:51:41,276
pointer is going to contain the address

24018
15:51:41,276 --> 15:51:42,880
of this guy

24019
15:51:42,880 --> 15:51:45,596
and in the body of the function the

24020
15:51:45,596 --> 15:51:48,080
pointer we will have this edge pointer

24021
15:51:48,080 --> 15:51:51,436
is going to be pointing to the original

24022
15:51:51,436 --> 15:51:54,320
variable here okay so this edge pointer

24023
15:51:54,320 --> 15:51:56,320
is going to be pointing to the original

24024
15:51:56,320 --> 15:51:57,596
edge variable

24025
15:51:57,596 --> 15:52:00,160
when we dereference it and modify the

24026
15:52:00,160 --> 15:52:02,160
variable we're going to be affecting the

24027
15:52:02,160 --> 15:52:03,840
original variable i really hope this

24028
15:52:03,840 --> 15:52:05,916
makes sense and this is really what

24029
15:52:05,916 --> 15:52:08,400
passing by pointer is all about you

24030
15:52:08,400 --> 15:52:10,240
declare your functions by passing in

24031
15:52:10,240 --> 15:52:12,560
pointers like this and in the definition

24032
15:52:12,560 --> 15:52:14,796
you do the same and when you call the

24033
15:52:14,796 --> 15:52:17,436
function you need to pass in an address

24034
15:52:17,436 --> 15:52:19,756
of the variable because that's what we

24035
15:52:19,756 --> 15:52:21,840
store in a pointer here and this is

24036
15:52:21,840 --> 15:52:23,916
going to work if we try to run this

24037
15:52:23,916 --> 15:52:26,720
example here we're going to print 23

24038
15:52:26,720 --> 15:52:29,436
because that's the original value we are

24039
15:52:29,436 --> 15:52:31,360
going to call the say age we are going

24040
15:52:31,360 --> 15:52:33,436
to increment and this is going to change

24041
15:52:33,436 --> 15:52:35,520
the original value if we print here

24042
15:52:35,520 --> 15:52:38,956
we're going to get 24 and when this

24043
15:52:38,956 --> 15:52:41,276
function terminates we're going to hit

24044
15:52:41,276 --> 15:52:43,040
this statement here and we're going to

24045
15:52:43,040 --> 15:52:46,240
print 24 this is what we're going to see

24046
15:52:46,240 --> 15:52:48,400
when we get to run this program here and

24047
15:52:48,400 --> 15:52:50,000
this is really all there is about

24048
15:52:50,000 --> 15:52:52,560
passing by pointer we are going to head

24049
15:52:52,560 --> 15:52:54,956
over to visual studio code and play with

24050
15:52:54,956 --> 15:52:58,480
us a little more okay here we are in our

24051
15:52:58,480 --> 15:53:00,796
working folder the current project is

24052
15:53:00,796 --> 15:53:03,200
passed by pointer we are going to grab

24053
15:53:03,200 --> 15:53:05,520
our template files here

24054
15:53:05,520 --> 15:53:07,276
and we're going to put them in the

24055
15:53:07,276 --> 15:53:11,116
current project which is pass by pointer

24056
15:53:11,116 --> 15:53:12,880
we are going to open this in visual

24057
15:53:12,880 --> 15:53:14,880
studio code pretty quick we're going to

24058
15:53:14,880 --> 15:53:18,080
choose that pass by pointer we open this

24059
15:53:18,080 --> 15:53:20,796
and our main cpp file should show up

24060
15:53:20,796 --> 15:53:21,596
here

24061
15:53:21,596 --> 15:53:25,276
we're going to clean it up a little bit

24062
15:53:25,276 --> 15:53:27,520
we are actually going to grab the code

24063
15:53:27,520 --> 15:53:29,756
from the last lecture and put that in

24064
15:53:29,756 --> 15:53:32,480
here and that's going to be our starting

24065
15:53:32,480 --> 15:53:34,796
point let's close the left pane here so

24066
15:53:34,796 --> 15:53:37,116
that we have some breathing space the

24067
15:53:37,116 --> 15:53:39,840
function here say h is going to pass by

24068
15:53:39,840 --> 15:53:42,320
pointer so we should take out this cost

24069
15:53:42,320 --> 15:53:43,436
here

24070
15:53:43,436 --> 15:53:46,080
and uh have a pointer here like we had

24071
15:53:46,080 --> 15:53:48,796
in the slides we're going to do the same

24072
15:53:48,796 --> 15:53:50,160
in our

24073
15:53:50,160 --> 15:53:52,400
definition here if we go down we're

24074
15:53:52,400 --> 15:53:54,080
going to do that we're going to pass by

24075
15:53:54,080 --> 15:53:56,400
pointer and we are going to uncomment

24076
15:53:56,400 --> 15:53:59,360
the line that increments our age here

24077
15:53:59,360 --> 15:54:01,200
okay after we do that you see that we

24078
15:54:01,200 --> 15:54:03,520
have a squiggly line at this line that

24079
15:54:03,520 --> 15:54:06,880
calls the say age function what we need

24080
15:54:06,880 --> 15:54:09,756
to do is to pass it the address of the

24081
15:54:09,756 --> 15:54:12,320
edge variable here like we saw in the

24082
15:54:12,320 --> 15:54:14,480
slide so this is the syntax we have to

24083
15:54:14,480 --> 15:54:15,520
follow

24084
15:54:15,520 --> 15:54:17,520
once we do this this program is going to

24085
15:54:17,520 --> 15:54:19,916
be valid and if we run it here we're

24086
15:54:19,916 --> 15:54:22,400
going to print 23 because that's the

24087
15:54:22,400 --> 15:54:24,400
value we have in here we're going to

24088
15:54:24,400 --> 15:54:26,720
call the say age function we are going

24089
15:54:26,720 --> 15:54:29,596
to increment age and here we forgot to

24090
15:54:29,596 --> 15:54:32,720
do our dereferencing so what we need to

24091
15:54:32,720 --> 15:54:35,680
do here is to dereference the age and

24092
15:54:35,680 --> 15:54:38,160
increment it this is going to increment

24093
15:54:38,160 --> 15:54:40,240
the original variable here and we're

24094
15:54:40,240 --> 15:54:42,640
going to be accessing this through the

24095
15:54:42,640 --> 15:54:45,520
the referencing operator of our pointer

24096
15:54:45,520 --> 15:54:48,000
here if we hit this line and the

24097
15:54:48,000 --> 15:54:50,640
function here we're going to print 24

24098
15:54:50,640 --> 15:54:52,796
because the value has been

24099
15:54:52,796 --> 15:54:56,400
incremented through this statement here

24100
15:54:56,400 --> 15:54:58,400
and after the function call we're going

24101
15:54:58,400 --> 15:55:02,000
to hit this statement here on line 10

24102
15:55:02,000 --> 15:55:04,320
and it is going to print 24. this is

24103
15:55:04,320 --> 15:55:05,680
what we expect

24104
15:55:05,680 --> 15:55:07,360
take a moment to make sure you really

24105
15:55:07,360 --> 15:55:09,360
understand this the things you need to

24106
15:55:09,360 --> 15:55:12,400
be careful about is the syntax we use to

24107
15:55:12,400 --> 15:55:15,200
declare the function here we say that we

24108
15:55:15,200 --> 15:55:17,276
are passing by pointer because of this

24109
15:55:17,276 --> 15:55:19,840
little star here and we have the same

24110
15:55:19,840 --> 15:55:21,916
thing when we hit the definition of the

24111
15:55:21,916 --> 15:55:24,240
function we have this little star so we

24112
15:55:24,240 --> 15:55:26,320
are passing by pointer another thing you

24113
15:55:26,320 --> 15:55:28,796
should remember is to pass the address

24114
15:55:28,796 --> 15:55:31,276
of a variable when you call the function

24115
15:55:31,276 --> 15:55:33,916
like we do here and please remember to

24116
15:55:33,916 --> 15:55:36,720
use the the reference operator whenever

24117
15:55:36,720 --> 15:55:39,840
you want to modify whatever variable is

24118
15:55:39,840 --> 15:55:42,080
leaving at the address that you passed

24119
15:55:42,080 --> 15:55:44,080
in here so that's why we are the

24120
15:55:44,080 --> 15:55:46,480
reference in here through the star

24121
15:55:46,480 --> 15:55:48,956
operator like we are doing here this is

24122
15:55:48,956 --> 15:55:51,116
really all you need to be careful about

24123
15:55:51,116 --> 15:55:53,116
so we are going to try and run this

24124
15:55:53,116 --> 15:55:54,720
program let's do that we're going to

24125
15:55:54,720 --> 15:55:57,916
build with gcc

24126
15:55:58,240 --> 15:56:00,000
the boiler is going to go through we

24127
15:56:00,000 --> 15:56:02,720
need to bring in a terminal

24128
15:56:02,720 --> 15:56:05,200
so that we can run this program and

24129
15:56:05,200 --> 15:56:09,916
again we expect to see a 23 24 and 24

24130
15:56:09,916 --> 15:56:11,436
here print it out

24131
15:56:11,436 --> 15:56:13,520
so let's run rooster

24132
15:56:13,520 --> 15:56:17,040
okay here is our output before we call

24133
15:56:17,040 --> 15:56:19,680
the say age function the age is 23 the

24134
15:56:19,680 --> 15:56:23,200
address is dec when we hit the function

24135
15:56:23,200 --> 15:56:25,680
we are saying hello you are

24136
15:56:25,680 --> 15:56:29,116
uh years old so here we should have the

24137
15:56:29,116 --> 15:56:32,080
reference to access something inside the

24138
15:56:32,080 --> 15:56:34,640
variable here so we should say you are

24139
15:56:34,640 --> 15:56:37,276
age old we need to dereference this guy

24140
15:56:37,276 --> 15:56:39,200
because now it is a pointer i forgot

24141
15:56:39,200 --> 15:56:41,840
that i really am sorry but we are

24142
15:56:41,840 --> 15:56:43,200
learning so

24143
15:56:43,200 --> 15:56:45,200
this is a good learning chance for you

24144
15:56:45,200 --> 15:56:47,276
not to make the same mistake as i am

24145
15:56:47,276 --> 15:56:50,160
making here so let's try and build again

24146
15:56:50,160 --> 15:56:52,796
we should see the correct output we are

24147
15:56:52,796 --> 15:56:54,400
going to clear

24148
15:56:54,400 --> 15:56:57,840
and run rooster now we see that before

24149
15:56:57,840 --> 15:56:58,880
the call

24150
15:56:58,880 --> 15:57:01,756
ages 23 when we call the function h

24151
15:57:01,756 --> 15:57:04,796
becomes 24 because we just incremented

24152
15:57:04,796 --> 15:57:07,596
through our reference operator and after

24153
15:57:07,596 --> 15:57:09,200
the function call the edge is going to

24154
15:57:09,200 --> 15:57:10,480
be 24

24155
15:57:10,480 --> 15:57:12,956
because we have modified the original

24156
15:57:12,956 --> 15:57:15,276
variable here through our the

24157
15:57:15,276 --> 15:57:18,000
referencing of the pointer here this is

24158
15:57:18,000 --> 15:57:20,160
really all there is about passing by

24159
15:57:20,160 --> 15:57:22,320
pointer this is the syntax you have to

24160
15:57:22,320 --> 15:57:24,480
pass a pointer in the declaration you

24161
15:57:24,480 --> 15:57:26,560
have to pass a pointer in the function

24162
15:57:26,560 --> 15:57:28,400
definition and when you call the

24163
15:57:28,400 --> 15:57:31,436
function you have to use the address of

24164
15:57:31,436 --> 15:57:33,360
the variable and pass that as an

24165
15:57:33,360 --> 15:57:35,520
argument to the function and whenever

24166
15:57:35,520 --> 15:57:37,840
you need to use the past parameter

24167
15:57:37,840 --> 15:57:39,276
you're going to go through the the

24168
15:57:39,276 --> 15:57:42,480
reference operator like we did here

24169
15:57:42,480 --> 15:57:45,756
and here in the body of our function

24170
15:57:45,756 --> 15:57:46,720
here

24171
15:57:46,720 --> 15:57:48,240
in this lecture we're going to see how

24172
15:57:48,240 --> 15:57:51,436
we can pass parameters to a function by

24173
15:57:51,436 --> 15:57:52,560
reference

24174
15:57:52,560 --> 15:57:54,560
and this is another technique we can use

24175
15:57:54,560 --> 15:57:57,276
to avoid passing by value which is going

24176
15:57:57,276 --> 15:57:59,680
to create a copy and the syntax is

24177
15:57:59,680 --> 15:58:01,916
really simple if you look at the

24178
15:58:01,916 --> 15:58:03,916
declaration here you're going to see

24179
15:58:03,916 --> 15:58:07,116
that we say and reference and again if

24180
15:58:07,116 --> 15:58:09,276
we hit the definition we're going to say

24181
15:58:09,276 --> 15:58:11,520
into reference as you see here

24182
15:58:11,520 --> 15:58:13,520
when we call the function we don't have

24183
15:58:13,520 --> 15:58:16,160
to pass the address of operator we just

24184
15:58:16,160 --> 15:58:17,680
passed the variable because this is

24185
15:58:17,680 --> 15:58:20,160
going to be treated as a reference by

24186
15:58:20,160 --> 15:58:22,720
the compiler and in the body of the

24187
15:58:22,720 --> 15:58:25,040
function we don't have to go through

24188
15:58:25,040 --> 15:58:27,680
ugly the referencing like we did with

24189
15:58:27,680 --> 15:58:30,080
pointers and hopefully you can see that

24190
15:58:30,080 --> 15:58:33,116
if you want to avoid copies passing by

24191
15:58:33,116 --> 15:58:35,360
references is much cleaner you don't

24192
15:58:35,360 --> 15:58:37,840
have to use the address of operator when

24193
15:58:37,840 --> 15:58:40,560
you call the function like we do here

24194
15:58:40,560 --> 15:58:42,640
and you don't have to go through the

24195
15:58:42,640 --> 15:58:45,436
reference and to access and modify your

24196
15:58:45,436 --> 15:58:48,160
variables and the modification we do

24197
15:58:48,160 --> 15:58:51,040
here by incrementing age is going to be

24198
15:58:51,040 --> 15:58:54,080
seen on the outside because we are going

24199
15:58:54,080 --> 15:58:56,320
through a reference and the reference is

24200
15:58:56,320 --> 15:58:59,276
a true alliance to the variable that the

24201
15:58:59,276 --> 15:59:01,520
reference is referencing so by

24202
15:59:01,520 --> 15:59:03,680
incrementing the edge here and the body

24203
15:59:03,680 --> 15:59:05,680
of the function the change is going to

24204
15:59:05,680 --> 15:59:08,956
be seen after the function call before

24205
15:59:08,956 --> 15:59:11,520
the function here we're going to get 23

24206
15:59:11,520 --> 15:59:12,956
in the body of the function we're going

24207
15:59:12,956 --> 15:59:15,360
to get 24 because we just incremented

24208
15:59:15,360 --> 15:59:17,916
the function and after the function call

24209
15:59:17,916 --> 15:59:20,720
we're going to get a 24 because the

24210
15:59:20,720 --> 15:59:23,596
change was propagated to the original

24211
15:59:23,596 --> 15:59:26,240
variable and the reason is because we

24212
15:59:26,240 --> 15:59:28,560
are going through a reference here

24213
15:59:28,560 --> 15:59:30,720
let's head to visual studio code and

24214
15:59:30,720 --> 15:59:33,200
actually play with us a little more okay

24215
15:59:33,200 --> 15:59:35,276
here we are in visual studio code the

24216
15:59:35,276 --> 15:59:37,916
current project is passed by reference

24217
15:59:37,916 --> 15:59:41,200
1710 here so we're going to grab our

24218
15:59:41,200 --> 15:59:44,320
template files and put them in place

24219
15:59:44,320 --> 15:59:45,840
1710

24220
15:59:45,840 --> 15:59:48,240
let's do that and we are going to open

24221
15:59:48,240 --> 15:59:50,400
this in visual studio code pretty quick

24222
15:59:50,400 --> 15:59:52,956
let's do that the main cpp file is going

24223
15:59:52,956 --> 15:59:55,520
to show up here again we are going to

24224
15:59:55,520 --> 15:59:57,680
grab the code from the last lecture and

24225
15:59:57,680 --> 16:00:00,320
use that as a starting point and we're

24226
16:00:00,320 --> 16:00:02,720
going to be modifying the signature of

24227
16:00:02,720 --> 16:00:05,040
our function here so what we want to do

24228
16:00:05,040 --> 16:00:07,276
is to pass by reference we're going to

24229
16:00:07,276 --> 16:00:09,596
say enter reference here you already

24230
16:00:09,596 --> 16:00:12,640
know references from a previous chapter

24231
16:00:12,640 --> 16:00:14,796
and we are going to hit the definition

24232
16:00:14,796 --> 16:00:17,680
here and do the same thing so let's say

24233
16:00:17,680 --> 16:00:19,756
and reference

24234
16:00:19,756 --> 16:00:21,116
age

24235
16:00:21,116 --> 16:00:23,040
and when we call the function we don't

24236
16:00:23,040 --> 16:00:25,436
need to pass the address of operator

24237
16:00:25,436 --> 16:00:27,360
because this is a reference we can use

24238
16:00:27,360 --> 16:00:29,756
it right away the compiler is going to

24239
16:00:29,756 --> 16:00:31,916
know that this is going to be a

24240
16:00:31,916 --> 16:00:33,916
reference to the original variable that

24241
16:00:33,916 --> 16:00:35,276
we passed here

24242
16:00:35,276 --> 16:00:37,520
and in the body of the function let's

24243
16:00:37,520 --> 16:00:39,520
take out this last line here we don't

24244
16:00:39,520 --> 16:00:42,400
need it and in the body when we want to

24245
16:00:42,400 --> 16:00:43,596
modify

24246
16:00:43,596 --> 16:00:46,000
the reference we can do that right away

24247
16:00:46,000 --> 16:00:48,080
without the referencing so we can just

24248
16:00:48,080 --> 16:00:51,596
say plus plus h here and the changes are

24249
16:00:51,596 --> 16:00:53,596
going to be propagated to the original

24250
16:00:53,596 --> 16:00:56,080
variable here because we are going

24251
16:00:56,080 --> 16:00:58,400
through a reference let's go down and

24252
16:00:58,400 --> 16:01:00,400
modify this because this is a reference

24253
16:01:00,400 --> 16:01:02,480
we can use it right away

24254
16:01:02,480 --> 16:01:05,840
and we can close this left pane here so

24255
16:01:05,840 --> 16:01:08,956
that we have some more breathing space

24256
16:01:08,956 --> 16:01:11,116
and you see that visual studio code is

24257
16:01:11,116 --> 16:01:14,080
no longer giving us any squiggly lines

24258
16:01:14,080 --> 16:01:17,200
so this must be valid c plus plus code

24259
16:01:17,200 --> 16:01:19,840
again notice the syntaxes we are using

24260
16:01:19,840 --> 16:01:23,520
here we are passing a reference in our

24261
16:01:23,520 --> 16:01:26,320
declaration we are passing a reference

24262
16:01:26,320 --> 16:01:28,796
in our function definition here when we

24263
16:01:28,796 --> 16:01:30,720
call the function we don't need to do

24264
16:01:30,720 --> 16:01:33,200
any address of operator we pass the

24265
16:01:33,200 --> 16:01:34,956
variable as is

24266
16:01:34,956 --> 16:01:36,880
and in the body of the function we don't

24267
16:01:36,880 --> 16:01:39,040
have to do any dereferencing we can

24268
16:01:39,040 --> 16:01:40,720
increment right away

24269
16:01:40,720 --> 16:01:43,200
or modify the variable however we want

24270
16:01:43,200 --> 16:01:45,360
the changes are going to be propagated

24271
16:01:45,360 --> 16:01:47,916
to the original variable because we are

24272
16:01:47,916 --> 16:01:49,200
passing a reference so the

24273
16:01:49,200 --> 16:01:51,360
incrementation here is also going to

24274
16:01:51,360 --> 16:01:54,160
affect the original variable that was

24275
16:01:54,160 --> 16:01:56,480
declared in the main function here let's

24276
16:01:56,480 --> 16:01:59,436
take this out and down here if we need

24277
16:01:59,436 --> 16:02:01,116
to use our variable we're going to just

24278
16:02:01,116 --> 16:02:03,040
use it right away we don't need any

24279
16:02:03,040 --> 16:02:06,000
referencing and if we print the address

24280
16:02:06,000 --> 16:02:08,400
of age here we're going to see the same

24281
16:02:08,400 --> 16:02:10,400
address we see on the outside because

24282
16:02:10,400 --> 16:02:12,720
this is a true alias it's going to be

24283
16:02:12,720 --> 16:02:15,040
referencing the same variable that we

24284
16:02:15,040 --> 16:02:17,520
have in main here okay now that you have

24285
16:02:17,520 --> 16:02:19,916
a better idea about this we are going to

24286
16:02:19,916 --> 16:02:22,000
try and build this we're going to use

24287
16:02:22,000 --> 16:02:24,880
gcc as always you can see that the build

24288
16:02:24,880 --> 16:02:25,916
is good

24289
16:02:25,916 --> 16:02:28,880
if we bring up a terminal to try and run

24290
16:02:28,880 --> 16:02:30,720
this program

24291
16:02:30,720 --> 16:02:33,116
we can clear and run rooster

24292
16:02:33,116 --> 16:02:35,276
we're going to see that before we call

24293
16:02:35,276 --> 16:02:38,320
the function the h is 23 but the address

24294
16:02:38,320 --> 16:02:40,240
ends in dec

24295
16:02:40,240 --> 16:02:42,956
when we hit the function the edge is 24

24296
16:02:42,956 --> 16:02:46,160
because we just incremented that here

24297
16:02:46,160 --> 16:02:48,240
but notice that the address of the

24298
16:02:48,240 --> 16:02:51,116
variable is the same as on the outside

24299
16:02:51,116 --> 16:02:53,756
so we are modifying the same variable

24300
16:02:53,756 --> 16:02:56,640
and when the function is done the edge

24301
16:02:56,640 --> 16:02:59,520
is still going to be 24 because we just

24302
16:02:59,520 --> 16:03:02,480
modified the original variable through a

24303
16:03:02,480 --> 16:03:04,796
reference here okay this is the effect

24304
16:03:04,796 --> 16:03:07,360
of passing by reference you can use a

24305
16:03:07,360 --> 16:03:10,000
claim syntax to modify the original

24306
16:03:10,000 --> 16:03:12,880
variable in your functions and this is

24307
16:03:12,880 --> 16:03:15,840
going to avoid copies like we have seen

24308
16:03:15,840 --> 16:03:18,400
when we were passing parameters by value

24309
16:03:18,400 --> 16:03:21,200
a few lectures back i would like to

24310
16:03:21,200 --> 16:03:23,596
welcome you in this new chapter where we

24311
16:03:23,596 --> 16:03:26,796
will be focusing on how to get data out

24312
16:03:26,796 --> 16:03:29,116
of functions again the model of the

24313
16:03:29,116 --> 16:03:31,756
function is really what you see here it

24314
16:03:31,756 --> 16:03:34,400
is like a machine and you can give input

24315
16:03:34,400 --> 16:03:36,956
to that machine and you expect to get

24316
16:03:36,956 --> 16:03:39,276
something out of that machine this

24317
16:03:39,276 --> 16:03:41,680
chapter is going to focus on this part

24318
16:03:41,680 --> 16:03:42,400
here

24319
16:03:42,400 --> 16:03:43,916
and we're going to see the different

24320
16:03:43,916 --> 16:03:46,240
facilities offered by the c plus plus

24321
16:03:46,240 --> 16:03:49,116
programming language to get output from

24322
16:03:49,116 --> 16:03:51,276
functions and we are going to start in

24323
16:03:51,276 --> 16:03:53,680
the next lecture and see how we can use

24324
16:03:53,680 --> 16:03:56,640
input and output parameters go ahead and

24325
16:03:56,640 --> 16:03:59,276
finish up here and meet me there in this

24326
16:03:59,276 --> 16:04:00,796
lecture we're going to see how we can

24327
16:04:00,796 --> 16:04:03,840
use function parameters to get data out

24328
16:04:03,840 --> 16:04:05,276
of the function

24329
16:04:05,276 --> 16:04:07,360
here is a simple example and we have

24330
16:04:07,360 --> 16:04:10,796
three functions here we have max str

24331
16:04:10,796 --> 16:04:13,680
max and and max double and you notice

24332
16:04:13,680 --> 16:04:16,000
that we have three parameters for each

24333
16:04:16,000 --> 16:04:17,840
of these functions the first two

24334
16:04:17,840 --> 16:04:19,916
parameters are going to be input they

24335
16:04:19,916 --> 16:04:22,560
are going to get data and the function

24336
16:04:22,560 --> 16:04:24,880
and the third one is going to be the

24337
16:04:24,880 --> 16:04:27,756
output parameter and it is going to get

24338
16:04:27,756 --> 16:04:29,756
data out of the function

24339
16:04:29,756 --> 16:04:33,040
let's focus on max hdr here and really

24340
16:04:33,040 --> 16:04:35,756
drive the point home the key idea here

24341
16:04:35,756 --> 16:04:38,560
is that for the third parameter

24342
16:04:38,560 --> 16:04:42,080
we are using a modifiable reference and

24343
16:04:42,080 --> 16:04:44,640
if we use a reference the changes we do

24344
16:04:44,640 --> 16:04:46,880
inside the function are also going to be

24345
16:04:46,880 --> 16:04:50,880
visible on the outside and we explicitly

24346
16:04:50,880 --> 16:04:53,520
left out the const that we have on the

24347
16:04:53,520 --> 16:04:55,596
other parameters because we want to be

24348
16:04:55,596 --> 16:04:57,360
able to modify

24349
16:04:57,360 --> 16:05:00,400
the output variable here inside the

24350
16:05:00,400 --> 16:05:02,480
function if we marked the third

24351
16:05:02,480 --> 16:05:04,720
parameter as const we would get a

24352
16:05:04,720 --> 16:05:06,560
compiler error if we're trying to do

24353
16:05:06,560 --> 16:05:09,040
something like this and assign something

24354
16:05:09,040 --> 16:05:11,596
to the output parameter here so the main

24355
16:05:11,596 --> 16:05:13,520
purpose of this function is to compute

24356
16:05:13,520 --> 16:05:16,000
the maximum between these two strings we

24357
16:05:16,000 --> 16:05:18,640
are going to say if input 1 is greater

24358
16:05:18,640 --> 16:05:20,480
than input 2

24359
16:05:20,480 --> 16:05:23,520
then input 1 is going to be our maximum

24360
16:05:23,520 --> 16:05:26,240
and we are going to store that in our

24361
16:05:26,240 --> 16:05:29,360
output parameter here if input 1 is not

24362
16:05:29,360 --> 16:05:32,400
greater than input 2 then input 2 is our

24363
16:05:32,400 --> 16:05:34,796
maximum we're going to store that in our

24364
16:05:34,796 --> 16:05:38,320
output and whoever has access to input 2

24365
16:05:38,320 --> 16:05:40,480
outside the function is going to see the

24366
16:05:40,480 --> 16:05:42,640
changes that we are making in the body

24367
16:05:42,640 --> 16:05:44,400
of the function this is really the

24368
16:05:44,400 --> 16:05:46,240
technique we can use

24369
16:05:46,240 --> 16:05:46,956
to

24370
16:05:46,956 --> 16:05:49,276
send output from the function and make

24371
16:05:49,276 --> 16:05:50,640
it visible

24372
16:05:50,640 --> 16:05:53,200
when the function has returned and again

24373
16:05:53,200 --> 16:05:55,276
the key idea is that we set up the

24374
16:05:55,276 --> 16:05:57,916
function in a way that the changes we do

24375
16:05:57,916 --> 16:05:59,680
inside the function are going to be

24376
16:05:59,680 --> 16:06:02,000
visible on the outside and we are able

24377
16:06:02,000 --> 16:06:04,796
to do that because output here is a

24378
16:06:04,796 --> 16:06:07,276
reference this is really key we have

24379
16:06:07,276 --> 16:06:09,840
used references here but we can set up

24380
16:06:09,840 --> 16:06:12,240
the same thing using pointers because we

24381
16:06:12,240 --> 16:06:14,956
have seen that with pointers we can also

24382
16:06:14,956 --> 16:06:17,436
make our changes inside the function

24383
16:06:17,436 --> 16:06:19,916
visible to the outside the two other

24384
16:06:19,916 --> 16:06:22,400
examples here are really extensions of

24385
16:06:22,400 --> 16:06:24,320
the same thing we have two input

24386
16:06:24,320 --> 16:06:27,276
variables input 1 and input 2

24387
16:06:27,276 --> 16:06:28,400
and

24388
16:06:28,400 --> 16:06:30,640
output is going to store the output from

24389
16:06:30,640 --> 16:06:33,200
the function you notice that output is a

24390
16:06:33,200 --> 16:06:35,360
reference and because of this the

24391
16:06:35,360 --> 16:06:37,520
changes we do in here are going to be

24392
16:06:37,520 --> 16:06:40,640
visible when this function has returned

24393
16:06:40,640 --> 16:06:43,200
and we do exactly the same thing on max

24394
16:06:43,200 --> 16:06:44,400
double here

24395
16:06:44,400 --> 16:06:46,560
but you see that it is using a pointer

24396
16:06:46,560 --> 16:06:48,880
okay i really wanted you to see this so

24397
16:06:48,880 --> 16:06:50,796
inside we're going to try and figure out

24398
16:06:50,796 --> 16:06:54,080
who is the maximum and if input 1 is the

24399
16:06:54,080 --> 16:06:56,560
maximum we're going to write that in our

24400
16:06:56,560 --> 16:06:58,956
output variable here and you notice that

24401
16:06:58,956 --> 16:07:01,200
we are the referencing here because this

24402
16:07:01,200 --> 16:07:04,720
guy is a pointer and if input 2 is our

24403
16:07:04,720 --> 16:07:07,360
maximum we're going to write that in our

24404
16:07:07,360 --> 16:07:09,436
output variable here one thing i don't

24405
16:07:09,436 --> 16:07:12,240
think i explained here is that we have a

24406
16:07:12,240 --> 16:07:15,680
cost std string reference here for maxed

24407
16:07:15,680 --> 16:07:19,040
hdr and the reason is that the input

24408
16:07:19,040 --> 16:07:21,200
variables aren't really meant to be

24409
16:07:21,200 --> 16:07:23,436
changed that's why we market them as

24410
16:07:23,436 --> 16:07:26,080
cost and if you want to modify them in

24411
16:07:26,080 --> 16:07:28,400
some way you can take the const away and

24412
16:07:28,400 --> 16:07:30,240
it is going to work okay this is really

24413
16:07:30,240 --> 16:07:32,640
the big idea we are playing with in this

24414
16:07:32,640 --> 16:07:35,360
lecture using function parameters as a

24415
16:07:35,360 --> 16:07:38,480
way to output data from the function and

24416
16:07:38,480 --> 16:07:40,720
here are a few ideas you should keep in

24417
16:07:40,720 --> 16:07:43,200
mind output parameters should be passed

24418
16:07:43,200 --> 16:07:45,360
in such a way that you can modify the

24419
16:07:45,360 --> 16:07:48,000
arguments from the inside the functions

24420
16:07:48,000 --> 16:07:50,000
and we have seen that we have two ways

24421
16:07:50,000 --> 16:07:51,436
to do that we could either use

24422
16:07:51,436 --> 16:07:54,080
references or even use pointers but

24423
16:07:54,080 --> 16:07:56,796
references are what you should prefer in

24424
16:07:56,796 --> 16:07:59,360
modern c plus plus input parameters

24425
16:07:59,360 --> 16:08:01,840
shouldn't be modified they are meant to

24426
16:08:01,840 --> 16:08:04,560
just get data in the function and that's

24427
16:08:04,560 --> 16:08:06,480
why in most cases you're going to see

24428
16:08:06,480 --> 16:08:08,956
that they are marked const okay now that

24429
16:08:08,956 --> 16:08:11,116
we have seen all these ideas i think it

24430
16:08:11,116 --> 16:08:13,116
is time we headed over to visual studio

24431
16:08:13,116 --> 16:08:15,200
code and actually played with them okay

24432
16:08:15,200 --> 16:08:17,840
here we are in our working folder the

24433
16:08:17,840 --> 16:08:20,160
current project is input and output

24434
16:08:20,160 --> 16:08:22,400
parameters we are going to grab our

24435
16:08:22,400 --> 16:08:24,880
template files like we always do we're

24436
16:08:24,880 --> 16:08:27,276
going to put them in place and we are

24437
16:08:27,276 --> 16:08:29,276
going to open this guy in visual studio

24438
16:08:29,276 --> 16:08:31,200
code we're going to just drag it and

24439
16:08:31,200 --> 16:08:33,840
drop on top of visual studio code here

24440
16:08:33,840 --> 16:08:35,840
and it is going to open up we have our

24441
16:08:35,840 --> 16:08:37,916
main function here we can close the pane

24442
16:08:37,916 --> 16:08:40,880
here and clean the file up a little bit

24443
16:08:40,880 --> 16:08:42,560
we're going to remove what we don't need

24444
16:08:42,560 --> 16:08:45,596
here and we're going to have a bare main

24445
16:08:45,596 --> 16:08:47,520
function we can play with here the first

24446
16:08:47,520 --> 16:08:49,840
thing we're going to do is to put in our

24447
16:08:49,840 --> 16:08:52,720
max str function it is nothing special

24448
16:08:52,720 --> 16:08:55,756
we just have two input parameters and

24449
16:08:55,756 --> 16:08:58,480
one output parameter the output

24450
16:08:58,480 --> 16:09:00,480
parameter is going to be what we use to

24451
16:09:00,480 --> 16:09:03,116
get output outside the function and

24452
16:09:03,116 --> 16:09:04,796
inside we're just going to compute the

24453
16:09:04,796 --> 16:09:07,200
maximum if input 1 is the maximum we're

24454
16:09:07,200 --> 16:09:09,200
going to write that in our output

24455
16:09:09,200 --> 16:09:11,916
parameter if input 2 happens to be our

24456
16:09:11,916 --> 16:09:14,160
maximum we're going to write that in our

24457
16:09:14,160 --> 16:09:16,880
output parameter because our output

24458
16:09:16,880 --> 16:09:19,360
parameter is a reference the changes we

24459
16:09:19,360 --> 16:09:21,360
make inside the function are going to be

24460
16:09:21,360 --> 16:09:24,240
visible on the outside because we will

24461
16:09:24,240 --> 16:09:27,116
be working on the original variable

24462
16:09:27,116 --> 16:09:29,596
through the reference which is really a

24463
16:09:29,596 --> 16:09:32,080
true alias here okay now that we have

24464
16:09:32,080 --> 16:09:33,756
the function set up like this we can

24465
16:09:33,756 --> 16:09:36,560
head in the main function and try it out

24466
16:09:36,560 --> 16:09:38,640
we're going to set up three variables of

24467
16:09:38,640 --> 16:09:40,640
type std strand i think we should

24468
16:09:40,640 --> 16:09:43,040
include the string library here let's do

24469
16:09:43,040 --> 16:09:45,276
that and we're going to have an out

24470
16:09:45,276 --> 16:09:48,240
string which is going to be our output

24471
16:09:48,240 --> 16:09:51,360
variable and we have two input strings

24472
16:09:51,360 --> 16:09:53,916
one is initialized with alabama the

24473
16:09:53,916 --> 16:09:56,796
other is initialized with bell view and

24474
16:09:56,796 --> 16:10:00,240
we're going to call our max sdr function

24475
16:10:00,240 --> 16:10:02,080
here you notice that it's not going to

24476
16:10:02,080 --> 16:10:04,560
be using the return mechanism we're

24477
16:10:04,560 --> 16:10:06,880
going to be grabbing the output from

24478
16:10:06,880 --> 16:10:10,000
this function using an output parameter

24479
16:10:10,000 --> 16:10:13,276
which is going to be our out hdr

24480
16:10:13,276 --> 16:10:15,276
variable here okay once the function is

24481
16:10:15,276 --> 16:10:17,040
done we're going to have the maximum

24482
16:10:17,040 --> 16:10:21,040
stored in our out sdr variable here and

24483
16:10:21,040 --> 16:10:22,880
we can print it out now that we have

24484
16:10:22,880 --> 16:10:25,276
this setup we can actually try and build

24485
16:10:25,276 --> 16:10:27,360
this we're going to use gcc let's do

24486
16:10:27,360 --> 16:10:29,680
that the build is good we can bring up a

24487
16:10:29,680 --> 16:10:32,640
terminal and clear and run rooster now

24488
16:10:32,640 --> 16:10:34,400
you see that the maximum is going to be

24489
16:10:34,400 --> 16:10:38,000
bell view let's try and change this to

24490
16:10:38,000 --> 16:10:39,840
casablanca why not and we're going to

24491
16:10:39,840 --> 16:10:41,596
see that the maximum now is going to be

24492
16:10:41,596 --> 16:10:44,240
casablanca and our function is going to

24493
16:10:44,240 --> 16:10:47,276
be smart enough to store the maximum in

24494
16:10:47,276 --> 16:10:50,080
this output variable here let's build

24495
16:10:50,080 --> 16:10:51,916
again the world is going to be good

24496
16:10:51,916 --> 16:10:54,160
going to clear and run rooster now the

24497
16:10:54,160 --> 16:10:56,560
maximum is casablanca hopefully you

24498
16:10:56,560 --> 16:10:59,276
understand that we are able to make the

24499
16:10:59,276 --> 16:11:02,160
changes in the function processed

24500
16:11:02,160 --> 16:11:06,000
because our output parameter here is

24501
16:11:06,000 --> 16:11:08,400
passed by reference this is a true

24502
16:11:08,400 --> 16:11:10,720
reference and any change we do to the

24503
16:11:10,720 --> 16:11:13,200
output parameter here is going to be

24504
16:11:13,200 --> 16:11:16,160
visible in whatever variable you passed

24505
16:11:16,160 --> 16:11:19,200
as an argument for this third argument

24506
16:11:19,200 --> 16:11:21,436
here this is what is making this work

24507
16:11:21,436 --> 16:11:23,040
now that this is working we're going to

24508
16:11:23,040 --> 16:11:24,480
comment this out

24509
16:11:24,480 --> 16:11:25,360
and

24510
16:11:25,360 --> 16:11:28,320
put in another example for you to play

24511
16:11:28,320 --> 16:11:29,756
with the next function we're going to

24512
16:11:29,756 --> 16:11:32,160
play with is going to be max and as you

24513
16:11:32,160 --> 16:11:35,520
see here and it is very similar to our

24514
16:11:35,520 --> 16:11:39,116
max hdr but you notice that our inputs

24515
16:11:39,116 --> 16:11:42,000
are no longer references because we

24516
16:11:42,000 --> 16:11:44,720
don't really mind copying fundamental

24517
16:11:44,720 --> 16:11:47,116
types in c plus plus they are small in

24518
16:11:47,116 --> 16:11:49,756
memory so copying them is really cheap

24519
16:11:49,756 --> 16:11:52,160
we can pass them by value and this is

24520
16:11:52,160 --> 16:11:54,956
not going to be so wasteful in our

24521
16:11:54,956 --> 16:11:57,360
program but the first parameter must be

24522
16:11:57,360 --> 16:11:59,840
passed by reference because we want to

24523
16:11:59,840 --> 16:12:02,796
use it as an output parameter and we're

24524
16:12:02,796 --> 16:12:04,956
going to use it to get output from the

24525
16:12:04,956 --> 16:12:06,796
function and the way we're going to do

24526
16:12:06,796 --> 16:12:08,400
that we're going to write whatever

24527
16:12:08,400 --> 16:12:11,040
variable is the maximum in our output

24528
16:12:11,040 --> 16:12:13,276
parameter and the changes are going to

24529
16:12:13,276 --> 16:12:15,360
be visible on the outside now we are

24530
16:12:15,360 --> 16:12:17,756
going to head over in our main function

24531
16:12:17,756 --> 16:12:19,756
set up a few variables and play with us

24532
16:12:19,756 --> 16:12:22,400
so we're going to say and out and this

24533
16:12:22,400 --> 16:12:25,040
is going to be our output variable and

24534
16:12:25,040 --> 16:12:27,680
we're going to say input one let's say

24535
16:12:27,680 --> 16:12:29,436
in one and we're going to initialize

24536
16:12:29,436 --> 16:12:32,320
this with a 45 why not and we're going

24537
16:12:32,320 --> 16:12:34,480
to say ent in two and we're going to

24538
16:12:34,480 --> 16:12:37,276
initialize this with 23 why not now that

24539
16:12:37,276 --> 16:12:39,360
we have this we're going to say max and

24540
16:12:39,360 --> 16:12:41,116
and we're going to put in our input

24541
16:12:41,116 --> 16:12:44,000
we're going to say n1 and n2 then we're

24542
16:12:44,000 --> 16:12:46,956
going to say out and as our output

24543
16:12:46,956 --> 16:12:49,116
variable now that we have this we can

24544
16:12:49,116 --> 16:12:51,200
actually print out whatever number is

24545
16:12:51,200 --> 16:12:53,596
the maximum through an output statement

24546
16:12:53,596 --> 16:12:55,360
like this really simple we're going to

24547
16:12:55,360 --> 16:12:58,000
say max and and we're going to say out

24548
16:12:58,000 --> 16:13:00,240
to end that's where it is going to be

24549
16:13:00,240 --> 16:13:02,320
stored and we are able to do this

24550
16:13:02,320 --> 16:13:05,116
because again the third parameter here

24551
16:13:05,116 --> 16:13:08,160
is passed by reference and any change we

24552
16:13:08,160 --> 16:13:10,560
do and the function here is going to

24553
16:13:10,560 --> 16:13:13,756
stack even when the function here has

24554
16:13:13,756 --> 16:13:16,000
returned and we're going to have that

24555
16:13:16,000 --> 16:13:18,720
stored in our third parameter here and

24556
16:13:18,720 --> 16:13:20,480
this is a really common technique

24557
16:13:20,480 --> 16:13:23,596
especially in code that has to interface

24558
16:13:23,596 --> 16:13:27,276
with c code out there from c plus plus

24559
16:13:27,276 --> 16:13:29,360
and you really need to be aware of this

24560
16:13:29,360 --> 16:13:31,436
now if we run this program we're going

24561
16:13:31,436 --> 16:13:33,916
to see our maximum printed out and it is

24562
16:13:33,916 --> 16:13:36,480
going to be stored in our out variable

24563
16:13:36,480 --> 16:13:38,480
here let's do that we're going to use

24564
16:13:38,480 --> 16:13:40,796
gcc to world the world is good you can

24565
16:13:40,796 --> 16:13:42,956
clear and run rooster and you're going

24566
16:13:42,956 --> 16:13:45,596
to see that the maximum is 45 if we

24567
16:13:45,596 --> 16:13:49,040
change and store our maximum in into

24568
16:13:49,040 --> 16:13:51,840
here and for example let's make this a

24569
16:13:51,840 --> 16:13:54,640
723

24570
16:13:54,640 --> 16:13:57,116
let's build it in to take the changes

24571
16:13:57,116 --> 16:13:59,240
into account in our

24572
16:13:59,240 --> 16:14:01,840
rooster.xe binary we're going to clear

24573
16:14:01,840 --> 16:14:03,680
and run rooster and you're going to see

24574
16:14:03,680 --> 16:14:06,000
that that's the maximum here we are able

24575
16:14:06,000 --> 16:14:08,400
to grab whatever is the maximum from

24576
16:14:08,400 --> 16:14:11,276
these two input parameters and store

24577
16:14:11,276 --> 16:14:13,916
that in our output parameter here

24578
16:14:13,916 --> 16:14:17,360
because we are passing that third guy as

24579
16:14:17,360 --> 16:14:19,916
a reference this is really important we

24580
16:14:19,916 --> 16:14:21,916
have seen that we can use references to

24581
16:14:21,916 --> 16:14:24,956
make changes we do in the function stick

24582
16:14:24,956 --> 16:14:28,240
and be visible in outside variables but

24583
16:14:28,240 --> 16:14:30,160
we can also use pointers and i am going

24584
16:14:30,160 --> 16:14:32,240
to show you an example of how we can do

24585
16:14:32,240 --> 16:14:33,840
that first we're going to comment this

24586
16:14:33,840 --> 16:14:36,400
out because we don't want noise output

24587
16:14:36,400 --> 16:14:38,956
in our program and we are going to go on

24588
16:14:38,956 --> 16:14:41,840
top and set up a max double function

24589
16:14:41,840 --> 16:14:45,680
which is going to grab our output using

24590
16:14:45,680 --> 16:14:48,000
pointers the name of the function is max

24591
16:14:48,000 --> 16:14:50,400
double it's not going to return anything

24592
16:14:50,400 --> 16:14:52,400
and it is going to take two input

24593
16:14:52,400 --> 16:14:55,916
parameters input 1 and input 2 and it is

24594
16:14:55,916 --> 16:14:58,320
going to tell us whichever of these 2 is

24595
16:14:58,320 --> 16:15:00,720
the maximum the maximum is going to be

24596
16:15:00,720 --> 16:15:03,596
stored in our output parameter but we

24597
16:15:03,596 --> 16:15:05,840
are using pointers to make these changes

24598
16:15:05,840 --> 16:15:08,400
inside the body of the function stick

24599
16:15:08,400 --> 16:15:10,720
and be visible on the outside of the

24600
16:15:10,720 --> 16:15:12,240
function so we are going to the

24601
16:15:12,240 --> 16:15:14,080
reference here because the third guy

24602
16:15:14,080 --> 16:15:15,916
here is a pointer and we're going to

24603
16:15:15,916 --> 16:15:18,240
store in whichever is the maximum and

24604
16:15:18,240 --> 16:15:20,560
when the function returns the maximum is

24605
16:15:20,560 --> 16:15:22,880
going to be visible on the outside so

24606
16:15:22,880 --> 16:15:24,880
let's go down and try this out we're

24607
16:15:24,880 --> 16:15:26,956
going to say double out double and we're

24608
16:15:26,956 --> 16:15:28,080
going to

24609
16:15:28,080 --> 16:15:30,400
set up our input here we're going to say

24610
16:15:30,400 --> 16:15:32,400
in double one and we're going to make

24611
16:15:32,400 --> 16:15:33,240
this

24612
16:15:33,240 --> 16:15:36,240
45.8 why not and we're going to do a

24613
16:15:36,240 --> 16:15:39,596
second input parameter and int we should

24614
16:15:39,596 --> 16:15:43,040
say n not end sorry for this in double

24615
16:15:43,040 --> 16:15:45,200
for input double so we're going to say

24616
16:15:45,200 --> 16:15:47,360
double 2 and we're going to initialize

24617
16:15:47,360 --> 16:15:50,000
this with 6.9

24618
16:15:50,000 --> 16:15:51,840
for example we can really put in

24619
16:15:51,840 --> 16:15:54,000
anything now that we have this we can

24620
16:15:54,000 --> 16:15:56,320
call our max double function let's do

24621
16:15:56,320 --> 16:15:58,080
that going to say max double we're going

24622
16:15:58,080 --> 16:16:01,680
to say in double one and in double two

24623
16:16:01,680 --> 16:16:03,596
let's do that and we're going to have

24624
16:16:03,596 --> 16:16:07,276
out double as our output parameter and

24625
16:16:07,276 --> 16:16:09,040
uh because it's a pointer we need to

24626
16:16:09,040 --> 16:16:12,000
pass this guy as an address so we're

24627
16:16:12,000 --> 16:16:14,640
going to say address of how to double

24628
16:16:14,640 --> 16:16:16,560
here that's how we're going to be able

24629
16:16:16,560 --> 16:16:19,040
to manipulate that inside the function

24630
16:16:19,040 --> 16:16:21,520
here once we do this we are going to

24631
16:16:21,520 --> 16:16:24,880
have our maximum stored and out double

24632
16:16:24,880 --> 16:16:26,720
and we can print that out so we're going

24633
16:16:26,720 --> 16:16:29,680
to say stdcl max double and we're going

24634
16:16:29,680 --> 16:16:32,000
to say mac and we're going to say out to

24635
16:16:32,000 --> 16:16:36,320
double std e and el and if we weld why

24636
16:16:36,320 --> 16:16:38,240
do we have a squiggly line here we don't

24637
16:16:38,240 --> 16:16:40,956
have a semicolon at the end of our

24638
16:16:40,956 --> 16:16:42,560
function called here so we're going to

24639
16:16:42,560 --> 16:16:45,276
build with gcc as always you're going to

24640
16:16:45,276 --> 16:16:47,360
see that the world is good we can clear

24641
16:16:47,360 --> 16:16:51,436
and run rooster max is 45.8

24642
16:16:51,436 --> 16:16:54,320
if we change and store our maximum and

24643
16:16:54,320 --> 16:16:57,116
in double to here we can change this guy

24644
16:16:57,116 --> 16:16:58,796
to 76.9

24645
16:16:58,796 --> 16:17:01,116
we're going to build and see that we are

24646
16:17:01,116 --> 16:17:04,080
actually grabbing the maximum regardless

24647
16:17:04,080 --> 16:17:06,240
of the variable in which it is stored if

24648
16:17:06,240 --> 16:17:08,080
we run rooster we're going to have our

24649
16:17:08,080 --> 16:17:11,116
maximum and this is working exactly as

24650
16:17:11,116 --> 16:17:12,956
we want this is really all we set out to

24651
16:17:12,956 --> 16:17:14,560
do in this lecture showing you how you

24652
16:17:14,560 --> 16:17:18,240
can use references to use parameters as

24653
16:17:18,240 --> 16:17:21,520
output channels for data to get outside

24654
16:17:21,520 --> 16:17:24,880
of the function and be used in variables

24655
16:17:24,880 --> 16:17:27,436
that are outside the function here i

24656
16:17:27,436 --> 16:17:29,436
really hope this makes sense and this is

24657
16:17:29,436 --> 16:17:31,276
a technique you need to be aware of

24658
16:17:31,276 --> 16:17:32,880
we're going to see other techniques to

24659
16:17:32,880 --> 16:17:35,680
do the same thing and uh starting in the

24660
16:17:35,680 --> 16:17:37,200
next lecture we're going to see how we

24661
16:17:37,200 --> 16:17:39,840
can return from functions for now i hope

24662
16:17:39,840 --> 16:17:42,320
you found this lecture interesting we

24663
16:17:42,320 --> 16:17:44,160
are going to stop here in this one in

24664
16:17:44,160 --> 16:17:45,436
the next one we're going to see how we

24665
16:17:45,436 --> 16:17:48,796
can use the return mechanism to get data

24666
16:17:48,796 --> 16:17:51,680
outside our function go ahead and finish

24667
16:17:51,680 --> 16:17:54,240
up here and make me there

24668
16:17:54,240 --> 16:17:55,680
in this lecture we're going to see how

24669
16:17:55,680 --> 16:17:58,560
we can get data outside of a function

24670
16:17:58,560 --> 16:18:01,756
through the return mechanism and this is

24671
16:18:01,756 --> 16:18:04,400
going to be an alternative to the way we

24672
16:18:04,400 --> 16:18:06,400
have been doing things in the last

24673
16:18:06,400 --> 16:18:08,640
lecture where we used function

24674
16:18:08,640 --> 16:18:12,080
parameters as channels to get data

24675
16:18:12,080 --> 16:18:14,000
outside the function

24676
16:18:14,000 --> 16:18:16,240
let's look at the simple example of how

24677
16:18:16,240 --> 16:18:17,756
this is done here we have a simple

24678
16:18:17,756 --> 16:18:19,596
function called sum the function is

24679
16:18:19,596 --> 16:18:21,596
going to return end

24680
16:18:21,596 --> 16:18:24,000
and it is going to sum up two parameters

24681
16:18:24,000 --> 16:18:27,116
that we pass to at nta and end b

24682
16:18:27,116 --> 16:18:28,720
if we get inside the function we're

24683
16:18:28,720 --> 16:18:30,240
going to do something really simple

24684
16:18:30,240 --> 16:18:31,680
we're going to set up a new variable

24685
16:18:31,680 --> 16:18:33,360
which is local to the function we're

24686
16:18:33,360 --> 16:18:35,040
going to call that reserved it's going

24687
16:18:35,040 --> 16:18:37,040
to be the same type as our input

24688
16:18:37,040 --> 16:18:39,276
parameters and we're going to add up a

24689
16:18:39,276 --> 16:18:41,756
and b and store the results back in our

24690
16:18:41,756 --> 16:18:43,680
result variable here

24691
16:18:43,680 --> 16:18:45,756
once we have this we're going to return

24692
16:18:45,756 --> 16:18:49,436
this for this variable to be visible by

24693
16:18:49,436 --> 16:18:52,080
whoever called this function here one

24694
16:18:52,080 --> 16:18:53,840
thing you should know is that this

24695
16:18:53,840 --> 16:18:57,596
variable is local to this function here

24696
16:18:57,596 --> 16:19:00,480
and it will be destroyed the moment we

24697
16:19:00,480 --> 16:19:02,880
hit the end of the function here and the

24698
16:19:02,880 --> 16:19:04,640
function terminates

24699
16:19:04,640 --> 16:19:06,640
so if we go in main here we're going to

24700
16:19:06,640 --> 16:19:08,560
try and see an example of how we can

24701
16:19:08,560 --> 16:19:11,116
call this function we have two variables

24702
16:19:11,116 --> 16:19:14,400
a and b and we have a new result

24703
16:19:14,400 --> 16:19:16,796
variable set up in the main function

24704
16:19:16,796 --> 16:19:19,200
please note that this variable is very

24705
16:19:19,200 --> 16:19:21,436
different from the variable we have and

24706
16:19:21,436 --> 16:19:22,400
the

24707
16:19:22,400 --> 16:19:24,880
sum function here because they live in

24708
16:19:24,880 --> 16:19:27,360
different scopes okay we are calling our

24709
16:19:27,360 --> 16:19:30,160
sum function here and we are passing it

24710
16:19:30,160 --> 16:19:33,520
two arguments in the form of a and b

24711
16:19:33,520 --> 16:19:35,596
here the function is going to compute

24712
16:19:35,596 --> 16:19:37,916
our sum and it's going to return it and

24713
16:19:37,916 --> 16:19:40,320
we're going to store that back in our

24714
16:19:40,320 --> 16:19:42,880
local variable to the main function here

24715
16:19:42,880 --> 16:19:45,436
the result variable here again is local

24716
16:19:45,436 --> 16:19:47,756
to this main function okay once we call

24717
16:19:47,756 --> 16:19:49,276
this function we're going to have our

24718
16:19:49,276 --> 16:19:52,080
results stored in here and if we print

24719
16:19:52,080 --> 16:19:53,756
like we do here we're going to see it

24720
16:19:53,756 --> 16:19:55,916
printed out on the console in this case

24721
16:19:55,916 --> 16:19:59,520
it's going to print 50 because 34 adding

24722
16:19:59,520 --> 16:20:02,480
16 that's going to be 50. but one thing

24723
16:20:02,480 --> 16:20:04,480
i want you to know is that this is going

24724
16:20:04,480 --> 16:20:06,956
to return by value and what we mean by

24725
16:20:06,956 --> 16:20:08,956
this is that we're going to copy

24726
16:20:08,956 --> 16:20:12,160
whatever we return here and store a copy

24727
16:20:12,160 --> 16:20:15,116
of that in this result variable that we

24728
16:20:15,116 --> 16:20:17,276
have in the main function and we're

24729
16:20:17,276 --> 16:20:18,956
going to prove this

24730
16:20:18,956 --> 16:20:21,916
notice the stdc out statement we have

24731
16:20:21,916 --> 16:20:25,520
here this is going to print the address

24732
16:20:25,520 --> 16:20:27,520
of this local variable and once the

24733
16:20:27,520 --> 16:20:29,756
function terminates we're going to try

24734
16:20:29,756 --> 16:20:32,080
and print the address of this resort

24735
16:20:32,080 --> 16:20:34,640
variable in the local scope of the main

24736
16:20:34,640 --> 16:20:36,640
function and we're going to see two

24737
16:20:36,640 --> 16:20:38,880
different addresses and hopefully this

24738
16:20:38,880 --> 16:20:41,436
is going to prove that we are returning

24739
16:20:41,436 --> 16:20:43,756
a copy it's not the original variable

24740
16:20:43,756 --> 16:20:46,320
that we have in the sum function here

24741
16:20:46,320 --> 16:20:48,560
that we are returning okay hopefully

24742
16:20:48,560 --> 16:20:50,640
this drives the point home that we can

24743
16:20:50,640 --> 16:20:53,276
use the return mechanism to get data

24744
16:20:53,276 --> 16:20:55,200
outside the function and we're going to

24745
16:20:55,200 --> 16:20:58,720
grab the result in our result variable

24746
16:20:58,720 --> 16:21:00,720
here and we're going to use it however

24747
16:21:00,720 --> 16:21:02,720
we wanted the main function

24748
16:21:02,720 --> 16:21:06,000
but things don't always work like this

24749
16:21:06,000 --> 16:21:08,000
sometimes the compiler is going to

24750
16:21:08,000 --> 16:21:10,080
insert optimizations

24751
16:21:10,080 --> 16:21:12,560
and not really returned by value but

24752
16:21:12,560 --> 16:21:15,520
returning by value is the default but if

24753
16:21:15,520 --> 16:21:18,000
the compiler notices that it can do

24754
16:21:18,000 --> 16:21:20,480
things better it is going to optimize

24755
16:21:20,480 --> 16:21:23,360
your returns by value to return by

24756
16:21:23,360 --> 16:21:25,520
reference and you're not going to make a

24757
16:21:25,520 --> 16:21:28,480
copy but you're going to somehow reuse

24758
16:21:28,480 --> 16:21:30,796
the local variable in the main function

24759
16:21:30,796 --> 16:21:33,040
let's look at a simple example to really

24760
16:21:33,040 --> 16:21:35,360
drive this home we have a function here

24761
16:21:35,360 --> 16:21:37,436
which is going to add strength it is

24762
16:21:37,436 --> 16:21:39,436
going to basically concatenate them

24763
16:21:39,436 --> 16:21:41,756
using the plus operator here and you

24764
16:21:41,756 --> 16:21:43,596
notice that inside the function here

24765
16:21:43,596 --> 16:21:45,040
we're going to set up a local variable

24766
16:21:45,040 --> 16:21:47,916
which is going to store our concatenated

24767
16:21:47,916 --> 16:21:49,360
string here

24768
16:21:49,360 --> 16:21:51,680
and we're going to print the address of

24769
16:21:51,680 --> 16:21:53,596
the local string after that we're going

24770
16:21:53,596 --> 16:21:55,680
to return the strength so that it is

24771
16:21:55,680 --> 16:21:58,640
usable by whoever calls this function

24772
16:21:58,640 --> 16:22:00,720
let's go in main and see how we can use

24773
16:22:00,720 --> 16:22:03,360
this function here we are setting up a

24774
16:22:03,360 --> 16:22:05,916
variable called sdr result which is

24775
16:22:05,916 --> 16:22:08,720
going to store our result strength we

24776
16:22:08,720 --> 16:22:10,640
are saying add strings here we are

24777
16:22:10,640 --> 16:22:13,040
calling our function and we are passing

24778
16:22:13,040 --> 16:22:16,080
in two strings hello and world and we

24779
16:22:16,080 --> 16:22:18,400
want to concatenate these guys this is

24780
16:22:18,400 --> 16:22:20,480
going to give us our result and if we

24781
16:22:20,480 --> 16:22:21,916
print it out we're going to get hello

24782
16:22:21,916 --> 16:22:24,480
world printed out but the main message

24783
16:22:24,480 --> 16:22:28,000
here is that the address of the outside

24784
16:22:28,000 --> 16:22:30,720
string here is going to be the same as

24785
16:22:30,720 --> 16:22:33,680
the address we have on the inside here

24786
16:22:33,680 --> 16:22:35,360
and this is going to mean that the

24787
16:22:35,360 --> 16:22:37,436
compiler has actually

24788
16:22:37,436 --> 16:22:39,116
done some magic

24789
16:22:39,116 --> 16:22:42,400
to return the local variable because it

24790
16:22:42,400 --> 16:22:44,880
has seen that we could really be wasting

24791
16:22:44,880 --> 16:22:47,436
this guy here inside the function when

24792
16:22:47,436 --> 16:22:49,756
the function returns this string result

24793
16:22:49,756 --> 16:22:52,320
here is going to die off but the

24794
16:22:52,320 --> 16:22:54,880
compiler knows that we can reuse that

24795
16:22:54,880 --> 16:22:57,436
and avoid the work of copying this

24796
16:22:57,436 --> 16:23:00,160
string which might be really large

24797
16:23:00,160 --> 16:23:02,160
suppose this string has a thousand

24798
16:23:02,160 --> 16:23:04,640
characters inside and copying it would

24799
16:23:04,640 --> 16:23:07,276
be a waste so the compiler is not going

24800
16:23:07,276 --> 16:23:10,000
to return by value which is the default

24801
16:23:10,000 --> 16:23:12,400
it is going to do some kind of return by

24802
16:23:12,400 --> 16:23:14,956
reference but it's really not a return

24803
16:23:14,956 --> 16:23:16,796
by reference because this is a local

24804
16:23:16,796 --> 16:23:18,640
variable we can't really have a

24805
16:23:18,640 --> 16:23:20,320
reference to a local variable to a

24806
16:23:20,320 --> 16:23:22,240
function that would be really bad

24807
16:23:22,240 --> 16:23:24,560
because we might be able to modify it

24808
16:23:24,560 --> 16:23:27,040
when the variable is actually dead after

24809
16:23:27,040 --> 16:23:29,360
the function has returned so it is a

24810
16:23:29,360 --> 16:23:31,756
magic that the compiler is doing to save

24811
16:23:31,756 --> 16:23:34,320
you from unnecessary copies but you

24812
16:23:34,320 --> 16:23:36,400
should be aware of this and not make

24813
16:23:36,400 --> 16:23:39,520
your code rely on returning by value

24814
16:23:39,520 --> 16:23:41,360
okay now that we know this we're going

24815
16:23:41,360 --> 16:23:43,276
to head over to visual studio code and

24816
16:23:43,276 --> 16:23:46,560
actually play with us here we are in our

24817
16:23:46,560 --> 16:23:48,796
working folder the current project is

24818
16:23:48,796 --> 16:23:51,596
returning from functions by value we're

24819
16:23:51,596 --> 16:23:54,000
going to grab our template files pretty

24820
16:23:54,000 --> 16:23:56,160
quick we're going to copy them let's do

24821
16:23:56,160 --> 16:23:58,400
that and we're going to put them in the

24822
16:23:58,400 --> 16:24:00,956
current lecture or project

24823
16:24:00,956 --> 16:24:03,360
and we're going to open this guy up in

24824
16:24:03,360 --> 16:24:05,596
visual studio code pretty quick let's do

24825
16:24:05,596 --> 16:24:06,560
that

24826
16:24:06,560 --> 16:24:09,436
now we have our main cpp file here we

24827
16:24:09,436 --> 16:24:11,916
can clean it up a little bit

24828
16:24:11,916 --> 16:24:14,000
and close the left pane here because we

24829
16:24:14,000 --> 16:24:15,520
don't need it the first thing we're

24830
16:24:15,520 --> 16:24:17,436
going to do is to put in our function

24831
16:24:17,436 --> 16:24:19,520
which is going to compute the sum of two

24832
16:24:19,520 --> 16:24:22,796
integers and return as the sum of these

24833
16:24:22,796 --> 16:24:24,956
two guys inside the function we're going

24834
16:24:24,956 --> 16:24:27,200
to set up a result variable which is

24835
16:24:27,200 --> 16:24:29,116
going to store the sum and we're going

24836
16:24:29,116 --> 16:24:31,040
to return it and it is going to be

24837
16:24:31,040 --> 16:24:33,276
visible to whoever has called this

24838
16:24:33,276 --> 16:24:35,276
function here again i am going to

24839
16:24:35,276 --> 16:24:37,436
emphasize that this is going to return

24840
16:24:37,436 --> 16:24:40,320
by value so what we return is really

24841
16:24:40,320 --> 16:24:43,596
going to be a copy of this variable here

24842
16:24:43,596 --> 16:24:45,276
and we're going to prove that by

24843
16:24:45,276 --> 16:24:47,756
printing the address of this variable

24844
16:24:47,756 --> 16:24:50,640
inside and outside the function here so

24845
16:24:50,640 --> 16:24:52,320
we're going to set up two variables in

24846
16:24:52,320 --> 16:24:54,560
main we're going to say and x let's call

24847
16:24:54,560 --> 16:24:57,520
our input parameters x and y we're going

24848
16:24:57,520 --> 16:25:00,240
to put in a five and the second guy is

24849
16:25:00,240 --> 16:25:02,560
going to be a y and it's going to store

24850
16:25:02,560 --> 16:25:05,116
an n9 why not after that we're going to

24851
16:25:05,116 --> 16:25:07,040
set up a variable which is going to

24852
16:25:07,040 --> 16:25:09,916
store the results let's call this result

24853
16:25:09,916 --> 16:25:12,400
why not and we're going to say some x

24854
16:25:12,400 --> 16:25:14,796
and y okay we are passing these guys by

24855
16:25:14,796 --> 16:25:17,276
value because we don't really care about

24856
16:25:17,276 --> 16:25:20,160
copying and and it is a fundamental type

24857
16:25:20,160 --> 16:25:22,880
it is really small in memory so it's

24858
16:25:22,880 --> 16:25:25,520
going to be very cheap to copy it's not

24859
16:25:25,520 --> 16:25:28,080
going to hurt the performance of our

24860
16:25:28,080 --> 16:25:31,436
application but what we want to do now

24861
16:25:31,436 --> 16:25:33,276
is to print

24862
16:25:33,276 --> 16:25:37,040
the address of the reserved variable in

24863
16:25:37,040 --> 16:25:39,520
the main function here and see that it

24864
16:25:39,520 --> 16:25:41,756
is the same as the

24865
16:25:41,756 --> 16:25:44,320
address of the variable we have inside

24866
16:25:44,320 --> 16:25:46,000
here another thing you should watch out

24867
16:25:46,000 --> 16:25:48,400
for is that we are able to get data

24868
16:25:48,400 --> 16:25:50,880
outside the function here the sum was a

24869
16:25:50,880 --> 16:25:53,840
local variable but we are able to get it

24870
16:25:53,840 --> 16:25:56,560
out of the function through the return

24871
16:25:56,560 --> 16:25:59,200
mechanism here okay before we go ahead

24872
16:25:59,200 --> 16:26:01,680
and run this program we're going to fix

24873
16:26:01,680 --> 16:26:04,240
the statement here we forgot to change

24874
16:26:04,240 --> 16:26:07,116
this to say out to mean that it is

24875
16:26:07,116 --> 16:26:09,276
outside the function here that's the

24876
16:26:09,276 --> 16:26:12,320
meaning we're going to build with gcc

24877
16:26:12,320 --> 16:26:14,640
the world is good we can clear and run

24878
16:26:14,640 --> 16:26:16,560
rooster now we're going to see that

24879
16:26:16,560 --> 16:26:19,840
inside the function the address of the

24880
16:26:19,840 --> 16:26:22,000
result variable here

24881
16:26:22,000 --> 16:26:24,240
ends in dac

24882
16:26:24,240 --> 16:26:27,116
and outside the function when we hit

24883
16:26:27,116 --> 16:26:29,040
the end of the function here we're going

24884
16:26:29,040 --> 16:26:32,400
to see that the address ends in de4 so

24885
16:26:32,400 --> 16:26:35,520
this proves that the local variable

24886
16:26:35,520 --> 16:26:38,000
inside the function and the outside

24887
16:26:38,000 --> 16:26:40,640
variable here in the main function

24888
16:26:40,640 --> 16:26:42,880
leaving two different memory addresses

24889
16:26:42,880 --> 16:26:44,956
there are two different variables and

24890
16:26:44,956 --> 16:26:47,596
the return mechanism here is just going

24891
16:26:47,596 --> 16:26:50,320
to copy whatever we have in the local

24892
16:26:50,320 --> 16:26:52,640
variable and make it available on the

24893
16:26:52,640 --> 16:26:56,000
outside here so that we can assign it to

24894
16:26:56,000 --> 16:26:58,080
the reserved variable in our main

24895
16:26:58,080 --> 16:27:00,240
function here this is how the return

24896
16:27:00,240 --> 16:27:02,796
mechanism is working and it is going to

24897
16:27:02,796 --> 16:27:05,520
be returning by value by default it is

24898
16:27:05,520 --> 16:27:07,360
going to be making copies this is the

24899
16:27:07,360 --> 16:27:09,840
message here now that we know this i

24900
16:27:09,840 --> 16:27:11,360
want to show you that there are

24901
16:27:11,360 --> 16:27:13,756
exceptions to that rule

24902
16:27:13,756 --> 16:27:15,756
if you return by value like this you

24903
16:27:15,756 --> 16:27:18,560
won't be really always using separate

24904
16:27:18,560 --> 16:27:21,436
memory addresses for the inside and the

24905
16:27:21,436 --> 16:27:23,200
outside here and we're going to prove

24906
16:27:23,200 --> 16:27:25,200
that with a function that is going to

24907
16:27:25,200 --> 16:27:26,956
add up two strings

24908
16:27:26,956 --> 16:27:29,276
let's comment what we have out because

24909
16:27:29,276 --> 16:27:31,680
we don't want this to confuse us so

24910
16:27:31,680 --> 16:27:34,000
we're going to bring this inside our

24911
16:27:34,000 --> 16:27:36,240
block comment here and we are going to

24912
16:27:36,240 --> 16:27:38,880
go below our sum function here and set

24913
16:27:38,880 --> 16:27:40,880
up a new function which is going to be

24914
16:27:40,880 --> 16:27:43,840
called add strands it is going to return

24915
16:27:43,840 --> 16:27:46,720
a string by value okay it is by value

24916
16:27:46,720 --> 16:27:49,040
because this return type here is not

24917
16:27:49,040 --> 16:27:51,200
qualified with anything like a pointer

24918
16:27:51,200 --> 16:27:53,360
or a reference so by default it is going

24919
16:27:53,360 --> 16:27:56,160
to be by value and inside you see we are

24920
16:27:56,160 --> 16:27:58,400
doing the exact same thing we did in the

24921
16:27:58,400 --> 16:28:01,040
sum function here we are adding up two

24922
16:28:01,040 --> 16:28:03,360
strands we are storing the results in a

24923
16:28:03,360 --> 16:28:06,240
local variable and we are returning that

24924
16:28:06,240 --> 16:28:08,240
but if we run this program you're going

24925
16:28:08,240 --> 16:28:11,680
to see that the address on the inside is

24926
16:28:11,680 --> 16:28:14,080
going to be the same as the address on

24927
16:28:14,080 --> 16:28:16,880
the outside so let's set up something

24928
16:28:16,880 --> 16:28:18,560
that we can play with here we're going

24929
16:28:18,560 --> 16:28:20,480
to go down in the main function and set

24930
16:28:20,480 --> 16:28:22,320
up a few variables we're going to say

24931
16:28:22,320 --> 16:28:24,840
hdd strand we're going to say

24932
16:28:24,840 --> 16:28:28,080
nstr1 and we're going to store in hello

24933
16:28:28,080 --> 16:28:30,720
let's do that and we're going to say std

24934
16:28:30,720 --> 16:28:31,756
strength

24935
16:28:31,756 --> 16:28:33,756
and str2

24936
16:28:33,756 --> 16:28:36,320
and we're going to store and world by

24937
16:28:36,320 --> 16:28:38,480
now you know what i am trying to do here

24938
16:28:38,480 --> 16:28:40,796
i am trying to say hello world okay once

24939
16:28:40,796 --> 16:28:42,796
we have this we're going to set up a

24940
16:28:42,796 --> 16:28:45,756
resort strike so we're going to say std

24941
16:28:45,756 --> 16:28:48,956
strength and i say result str and we're

24942
16:28:48,956 --> 16:28:51,436
going to say add sdr and we're going to

24943
16:28:51,436 --> 16:28:52,840
add up

24944
16:28:52,840 --> 16:28:57,520
nstr1 and in str2 this is how we do this

24945
16:28:57,520 --> 16:28:59,200
and after we do this we're going to

24946
16:28:59,200 --> 16:29:02,080
print out the address of the variable

24947
16:29:02,080 --> 16:29:04,400
here so let's do that and it is going to

24948
16:29:04,400 --> 16:29:08,880
be the address of result hdr let's say

24949
16:29:08,880 --> 16:29:11,840
that here and we also need to print the

24950
16:29:11,840 --> 16:29:14,720
actual result of this operation here so

24951
16:29:14,720 --> 16:29:17,520
let's do that we're going to say sddc

24952
16:29:17,520 --> 16:29:20,640
out result sdr we're going to print the

24953
16:29:20,640 --> 16:29:21,596
actual

24954
16:29:21,596 --> 16:29:24,160
strength i don't think we did that on

24955
16:29:24,160 --> 16:29:25,200
our

24956
16:29:25,200 --> 16:29:28,240
sum function here but we can quickly go

24957
16:29:28,240 --> 16:29:30,720
there and prove that to you so let's

24958
16:29:30,720 --> 16:29:33,116
comment this out sorry for this this is

24959
16:29:33,116 --> 16:29:35,200
going to be confusing but i don't want

24960
16:29:35,200 --> 16:29:36,880
to leave you with

24961
16:29:36,880 --> 16:29:38,720
unexplained thanks

24962
16:29:38,720 --> 16:29:40,796
so we're going to see that if we print

24963
16:29:40,796 --> 16:29:42,320
this out we're going to get the sum

24964
16:29:42,320 --> 16:29:45,520
which is 14 printed out let's do that

24965
16:29:45,520 --> 16:29:47,040
pretty quick we're going to go down and

24966
16:29:47,040 --> 16:29:50,480
say sddcl and say result and we're going

24967
16:29:50,480 --> 16:29:52,720
to say result and we're going to build

24968
16:29:52,720 --> 16:29:55,840
it pretty quick with the gcc and if we

24969
16:29:55,840 --> 16:29:58,000
clear and run the rooster we're going to

24970
16:29:58,000 --> 16:30:00,480
see the result which is 14 here and you

24971
16:30:00,480 --> 16:30:02,240
can change these guys up to really play

24972
16:30:02,240 --> 16:30:04,796
with us for example if we make this 15

24973
16:30:04,796 --> 16:30:07,436
and put in a 9 we're going to get a 24

24974
16:30:07,436 --> 16:30:09,520
printed out let's build again

24975
16:30:09,520 --> 16:30:11,360
just to have fun with this and we're

24976
16:30:11,360 --> 16:30:13,596
going to clear and run rooster we're

24977
16:30:13,596 --> 16:30:15,840
going to get a 24 here now we can

24978
16:30:15,840 --> 16:30:18,320
comment this back i am happy i have

24979
16:30:18,320 --> 16:30:20,956
showed you this and we can uncomment our

24980
16:30:20,956 --> 16:30:24,480
string code here and uh build and run it

24981
16:30:24,480 --> 16:30:27,116
so we're going to build with gcc the

24982
16:30:27,116 --> 16:30:29,436
build is good we can clear and run

24983
16:30:29,436 --> 16:30:32,560
rooster and again what we want to see

24984
16:30:32,560 --> 16:30:34,480
is that the compiler is going to

24985
16:30:34,480 --> 16:30:36,720
optimize this out it is not going to

24986
16:30:36,720 --> 16:30:39,916
return by value like we had was the sum

24987
16:30:39,916 --> 16:30:42,480
function where we had the address on the

24988
16:30:42,480 --> 16:30:44,880
inside different from the address on the

24989
16:30:44,880 --> 16:30:48,240
outside you see here that inside ah we

24990
16:30:48,240 --> 16:30:50,560
forgot again to change this guy to out

24991
16:30:50,560 --> 16:30:52,880
uh sorry for this so we're going to make

24992
16:30:52,880 --> 16:30:54,880
this guy out and we're going to build

24993
16:30:54,880 --> 16:30:56,956
again and we're going to clear

24994
16:30:56,956 --> 16:30:59,680
clear and run rooster now we're going to

24995
16:30:59,680 --> 16:31:03,840
see that inside the address ends in d30

24996
16:31:03,840 --> 16:31:07,916
and outside the address ends in d30 this

24997
16:31:07,916 --> 16:31:10,160
can be really confusing because we said

24998
16:31:10,160 --> 16:31:12,636
we want to return by value by not

24999
16:31:12,636 --> 16:31:15,200
decorating our return type with a

25000
16:31:15,200 --> 16:31:17,520
pointer or a reference or something like

25001
16:31:17,520 --> 16:31:19,436
that it is going to be returning by

25002
16:31:19,436 --> 16:31:21,840
value and if you return by value you're

25003
16:31:21,840 --> 16:31:23,916
going to make copies and if we made the

25004
16:31:23,916 --> 16:31:27,040
copies the address on the inside and the

25005
16:31:27,040 --> 16:31:29,040
address on the outside should be

25006
16:31:29,040 --> 16:31:31,200
different but they are the same the

25007
16:31:31,200 --> 16:31:32,956
reason is the compiler is going to

25008
16:31:32,956 --> 16:31:35,200
notice that you are trying to copy

25009
16:31:35,200 --> 16:31:36,400
strands

25010
16:31:36,400 --> 16:31:38,560
and it is going to see that the variable

25011
16:31:38,560 --> 16:31:40,400
here which is inside the function is

25012
16:31:40,400 --> 16:31:42,720
going to be wasted when the function

25013
16:31:42,720 --> 16:31:43,756
returns

25014
16:31:43,756 --> 16:31:45,680
by default this should be really

25015
16:31:45,680 --> 16:31:48,796
destroyed and you should copy

25016
16:31:48,796 --> 16:31:50,720
because you are returning by value but

25017
16:31:50,720 --> 16:31:52,480
the compiler is going to insert an

25018
16:31:52,480 --> 16:31:55,360
optimization to do some magic and make

25019
16:31:55,360 --> 16:31:57,360
it look like you are returning by

25020
16:31:57,360 --> 16:31:59,520
reference and it is really not going to

25021
16:31:59,520 --> 16:32:01,916
make a copy so it is going to reuse the

25022
16:32:01,916 --> 16:32:04,480
address on the inside and hopefully this

25023
16:32:04,480 --> 16:32:06,160
is going to prove this to you the

25024
16:32:06,160 --> 16:32:08,636
message here is that you shouldn't rely

25025
16:32:08,636 --> 16:32:10,480
on your functions

25026
16:32:10,480 --> 16:32:12,720
returning by value because if the

25027
16:32:12,720 --> 16:32:15,040
compiler sees that it can do a better

25028
16:32:15,040 --> 16:32:17,756
job than you it is going to optimize

25029
16:32:17,756 --> 16:32:20,000
your return by value to return by

25030
16:32:20,000 --> 16:32:22,720
reference and you're going to not be

25031
16:32:22,720 --> 16:32:25,276
making copies so don't make your code

25032
16:32:25,276 --> 16:32:28,636
rely on returning by value and making

25033
16:32:28,636 --> 16:32:31,240
copies and you should be aware of these

25034
16:32:31,240 --> 16:32:34,320
optimizations that the compiler can do

25035
16:32:34,320 --> 16:32:37,276
behind your back i would like to welcome

25036
16:32:37,276 --> 16:32:39,916
you in this new chapter where we will be

25037
16:32:39,916 --> 16:32:42,320
learning about function overloading

25038
16:32:42,320 --> 16:32:44,636
function overloading is a mechanism we

25039
16:32:44,636 --> 16:32:46,636
have in c plus plus

25040
16:32:46,636 --> 16:32:49,200
to have multiple copies of the same

25041
16:32:49,200 --> 16:32:52,636
function but taking different parameters

25042
16:32:52,636 --> 16:32:54,160
for example here you see that we have

25043
16:32:54,160 --> 16:32:56,000
different functions but all these

25044
16:32:56,000 --> 16:32:58,720
functions have the same function name

25045
16:32:58,720 --> 16:33:01,596
and these are said to be different

25046
16:33:01,596 --> 16:33:04,400
overloads of the same function there are

25047
16:33:04,400 --> 16:33:06,560
a couple of rules you need to be aware

25048
16:33:06,560 --> 16:33:08,636
of to be able to set up your overalls

25049
16:33:08,636 --> 16:33:10,480
correctly and get them to work and

25050
16:33:10,480 --> 16:33:11,840
that's what we're going to be learning

25051
16:33:11,840 --> 16:33:14,720
about in detail in this chapter but now

25052
16:33:14,720 --> 16:33:16,956
i just want you to see the flexibility

25053
16:33:16,956 --> 16:33:19,276
you can get with function overloading

25054
16:33:19,276 --> 16:33:21,200
for example here if we have a few

25055
16:33:21,200 --> 16:33:24,400
variables in our program we can call the

25056
16:33:24,400 --> 16:33:27,040
max function and the compiler is going

25057
16:33:27,040 --> 16:33:29,680
to select the most fitting overloading

25058
16:33:29,680 --> 16:33:32,080
here so for example if we call our

25059
16:33:32,080 --> 16:33:35,040
function with integer arguments the

25060
16:33:35,040 --> 16:33:37,040
compiler is going to choose this

25061
16:33:37,040 --> 16:33:39,840
overload here if we call a function with

25062
16:33:39,840 --> 16:33:42,560
std string arguments the compiler is

25063
16:33:42,560 --> 16:33:45,520
going to choose this overload here and

25064
16:33:45,520 --> 16:33:47,276
we don't really need to concern

25065
16:33:47,276 --> 16:33:48,796
ourselves

25066
16:33:48,796 --> 16:33:50,720
with making sure we have the correct

25067
16:33:50,720 --> 16:33:52,480
arguments the compiler is going to

25068
16:33:52,480 --> 16:33:54,636
choose the correct function overload for

25069
16:33:54,636 --> 16:33:56,796
us and it is going to call it and it's

25070
16:33:56,796 --> 16:33:58,796
going to be very flexible to call these

25071
16:33:58,796 --> 16:34:01,436
functions from our c plus plus code this

25072
16:34:01,436 --> 16:34:04,160
is how function overload can be really

25073
16:34:04,160 --> 16:34:06,636
useful we are going to stop here in this

25074
16:34:06,636 --> 16:34:08,320
lecture in the next one we're going to

25075
16:34:08,320 --> 16:34:10,560
learn about how you can set up function

25076
16:34:10,560 --> 16:34:13,520
overloads based on different function

25077
16:34:13,520 --> 16:34:14,796
parameters

25078
16:34:14,796 --> 16:34:17,200
go ahead and finish up here and meet me

25079
16:34:17,200 --> 16:34:19,360
there in this lecture we're going to see

25080
16:34:19,360 --> 16:34:22,480
how we can overload functions based on

25081
16:34:22,480 --> 16:34:24,956
the parameters that we pass to the

25082
16:34:24,956 --> 16:34:27,436
function when we are declaring it or

25083
16:34:27,436 --> 16:34:29,840
defining it and here is a simple example

25084
16:34:29,840 --> 16:34:32,080
to drive the point home here we have a

25085
16:34:32,080 --> 16:34:34,320
function called max

25086
16:34:34,320 --> 16:34:36,320
and this is the name

25087
16:34:36,320 --> 16:34:38,880
it is taking two parameters which are of

25088
16:34:38,880 --> 16:34:40,636
type and here

25089
16:34:40,636 --> 16:34:43,756
and by overloading this function we will

25090
16:34:43,756 --> 16:34:46,320
have to use the same name as this

25091
16:34:46,320 --> 16:34:48,956
function here so the differences really

25092
16:34:48,956 --> 16:34:51,360
will be in the parameters that we pass

25093
16:34:51,360 --> 16:34:54,320
to the function because the return type

25094
16:34:54,320 --> 16:34:55,276
isn't

25095
16:34:55,276 --> 16:34:58,480
involved in defining the signature of

25096
16:34:58,480 --> 16:35:00,480
the function so if we try to set up

25097
16:35:00,480 --> 16:35:02,720
another function called max here which

25098
16:35:02,720 --> 16:35:04,560
takes the exact

25099
16:35:04,560 --> 16:35:07,840
same parameters as our max on top here

25100
16:35:07,840 --> 16:35:09,520
the difference is only going to be in

25101
16:35:09,520 --> 16:35:11,680
the return type the compiler is not

25102
16:35:11,680 --> 16:35:13,596
going to allow us to do this because the

25103
16:35:13,596 --> 16:35:17,116
return type isn't really significant

25104
16:35:17,116 --> 16:35:19,756
in making two functions different okay

25105
16:35:19,756 --> 16:35:21,360
the only way we have to set up a

25106
16:35:21,360 --> 16:35:24,400
function which is legal in c plus plus

25107
16:35:24,400 --> 16:35:27,276
is to change something about the

25108
16:35:27,276 --> 16:35:29,680
parameters that we have here we can

25109
16:35:29,680 --> 16:35:31,436
change the types like you see here for

25110
16:35:31,436 --> 16:35:33,916
example we change the types to b double

25111
16:35:33,916 --> 16:35:36,000
if the types are different we might even

25112
16:35:36,000 --> 16:35:38,160
change the order of the parameters you

25113
16:35:38,160 --> 16:35:40,080
just have to make sure the parameter

25114
16:35:40,080 --> 16:35:43,520
list is different in one way or another

25115
16:35:43,520 --> 16:35:45,040
that's how you're going to get this

25116
16:35:45,040 --> 16:35:48,080
function to run with the same names here

25117
16:35:48,080 --> 16:35:49,916
and if we manage to set up multiple

25118
16:35:49,916 --> 16:35:52,320
functions with the same name in c plus

25119
16:35:52,320 --> 16:35:54,560
plus these functions are going to be

25120
16:35:54,560 --> 16:35:56,956
called overloads of each other okay if

25121
16:35:56,956 --> 16:35:59,040
we go down here we have another overload

25122
16:35:59,040 --> 16:36:01,680
for the max function this overload is

25123
16:36:01,680 --> 16:36:03,756
going to take two parameters and the

25124
16:36:03,756 --> 16:36:05,680
parameters are going to be of type

25125
16:36:05,680 --> 16:36:08,240
string view they are different from what

25126
16:36:08,240 --> 16:36:10,636
we have on top here which is ant so this

25127
16:36:10,636 --> 16:36:13,916
is a legal overload for this max

25128
16:36:13,916 --> 16:36:16,320
function here and we can use it okay we

25129
16:36:16,320 --> 16:36:18,480
really have a few ways we can make our

25130
16:36:18,480 --> 16:36:21,276
function overloads by now we can change

25131
16:36:21,276 --> 16:36:23,916
the order of the parameter we can change

25132
16:36:23,916 --> 16:36:26,080
the number of the parameters or even we

25133
16:36:26,080 --> 16:36:28,560
can change the types of the parameters

25134
16:36:28,560 --> 16:36:31,680
again function overloads are a mechanism

25135
16:36:31,680 --> 16:36:34,160
we have in c plus plus to set up

25136
16:36:34,160 --> 16:36:36,880
multiple functions with the same name to

25137
16:36:36,880 --> 16:36:39,520
make our code easier to work with okay

25138
16:36:39,520 --> 16:36:41,200
now that you know that let's look at a

25139
16:36:41,200 --> 16:36:43,756
simple example of how we can call our

25140
16:36:43,756 --> 16:36:45,840
overloads we have a few variables

25141
16:36:45,840 --> 16:36:48,080
declared here we have ant variables we

25142
16:36:48,080 --> 16:36:50,636
have double variables and we have std

25143
16:36:50,636 --> 16:36:52,560
string view variables

25144
16:36:52,560 --> 16:36:54,796
and if you go down here we are calling

25145
16:36:54,796 --> 16:36:57,756
our max function passing in integers so

25146
16:36:57,756 --> 16:37:00,080
the overload that takes integers for

25147
16:37:00,080 --> 16:37:02,000
this max function is going to be called

25148
16:37:02,000 --> 16:37:05,116
here down here we are passing in integer

25149
16:37:05,116 --> 16:37:07,116
literals so this is going to call the

25150
16:37:07,116 --> 16:37:10,000
int overload down here we are calling

25151
16:37:10,000 --> 16:37:12,480
the function with double parameters or

25152
16:37:12,480 --> 16:37:15,040
arguments so this is going to call our

25153
16:37:15,040 --> 16:37:17,276
double overload for the match function

25154
16:37:17,276 --> 16:37:20,320
here and down here we are passing in our

25155
16:37:20,320 --> 16:37:22,880
string view parameters and this is going

25156
16:37:22,880 --> 16:37:25,840
to call the overload that takes string

25157
16:37:25,840 --> 16:37:28,480
view parameters and the last guy here is

25158
16:37:28,480 --> 16:37:29,916
going to take

25159
16:37:29,916 --> 16:37:33,040
two string literals string literals can

25160
16:37:33,040 --> 16:37:37,200
implicitly convert to std string view so

25161
16:37:37,200 --> 16:37:40,796
our std string view overload for the max

25162
16:37:40,796 --> 16:37:43,360
function here is going to be called

25163
16:37:43,360 --> 16:37:44,636
now that we know this we're going to

25164
16:37:44,636 --> 16:37:46,880
head over to visual studio code and play

25165
16:37:46,880 --> 16:37:49,116
with this a little more okay here we are

25166
16:37:49,116 --> 16:37:51,680
in our working folder the current

25167
16:37:51,680 --> 16:37:54,720
project is overloading with different

25168
16:37:54,720 --> 16:37:57,756
parameters here we're going to grab our

25169
16:37:57,756 --> 16:38:00,240
template files like we always do we're

25170
16:38:00,240 --> 16:38:02,240
going to put them in place

25171
16:38:02,240 --> 16:38:04,160
and we are going to open this guy in

25172
16:38:04,160 --> 16:38:06,320
visual studio code by dragging and

25173
16:38:06,320 --> 16:38:08,720
dropping on top of visual studio code

25174
16:38:08,720 --> 16:38:10,880
here this is going to open our project

25175
16:38:10,880 --> 16:38:12,720
here we're going to click on our main

25176
16:38:12,720 --> 16:38:15,680
cpp file and open it we're going to

25177
16:38:15,680 --> 16:38:18,000
clean it up a little bit and close the

25178
16:38:18,000 --> 16:38:20,636
left pane here we are going to go on top

25179
16:38:20,636 --> 16:38:23,520
here and put in our first max function

25180
16:38:23,520 --> 16:38:26,240
here the return type is and in this case

25181
16:38:26,240 --> 16:38:28,636
it is going to take two parameters and

25182
16:38:28,636 --> 16:38:30,796
it is going to return whichever number

25183
16:38:30,796 --> 16:38:33,200
is the maximum and we are taking

25184
16:38:33,200 --> 16:38:35,756
parameters in by value and returning by

25185
16:38:35,756 --> 16:38:38,160
value here nothing special we can go in

25186
16:38:38,160 --> 16:38:39,840
main and call this function and you

25187
16:38:39,840 --> 16:38:41,360
already know how to do that i don't

25188
16:38:41,360 --> 16:38:43,276
think i really need to do that

25189
16:38:43,276 --> 16:38:46,240
but now what we really are interested in

25190
16:38:46,240 --> 16:38:49,040
is being able to set up different

25191
16:38:49,040 --> 16:38:51,680
functions with the same function name

25192
16:38:51,680 --> 16:38:54,240
like we have here because if for example

25193
16:38:54,240 --> 16:38:56,720
you take this function and put that down

25194
16:38:56,720 --> 16:38:58,796
below we're going to make a copy of it

25195
16:38:58,796 --> 16:39:01,520
and only change the return type if we

25196
16:39:01,520 --> 16:39:03,596
try to compile this program you see that

25197
16:39:03,596 --> 16:39:06,560
even visual studio code is unhappy now

25198
16:39:06,560 --> 16:39:08,880
if we bring up a terminal it is going to

25199
16:39:08,880 --> 16:39:11,596
tell us cannot overload function

25200
16:39:11,596 --> 16:39:14,956
distinguished by the return type alone

25201
16:39:14,956 --> 16:39:17,520
so again the message is super clear here

25202
16:39:17,520 --> 16:39:20,320
the return type is not enough to make

25203
16:39:20,320 --> 16:39:22,560
two functions different because the

25204
16:39:22,560 --> 16:39:26,560
return type isn't involved in making the

25205
16:39:26,560 --> 16:39:28,880
signature unique what makes the

25206
16:39:28,880 --> 16:39:30,880
signature unique is either the function

25207
16:39:30,880 --> 16:39:33,756
name or the parameters that you pass to

25208
16:39:33,756 --> 16:39:36,080
the function here so we're going to make

25209
16:39:36,080 --> 16:39:38,480
this return type back a double and we're

25210
16:39:38,480 --> 16:39:40,160
going to figure out a way to make these

25211
16:39:40,160 --> 16:39:42,720
two functions different but have the

25212
16:39:42,720 --> 16:39:44,400
same name here because sometimes you

25213
16:39:44,400 --> 16:39:45,680
really want this

25214
16:39:45,680 --> 16:39:47,680
one way we have to do this is to change

25215
16:39:47,680 --> 16:39:49,756
the types of the parameters that we pass

25216
16:39:49,756 --> 16:39:51,520
in here so we're going to make them

25217
16:39:51,520 --> 16:39:53,040
double and we're going to make them

25218
16:39:53,040 --> 16:39:55,116
double here and this is going to be

25219
16:39:55,116 --> 16:39:58,000
valid c plus plus could these two

25220
16:39:58,000 --> 16:40:00,400
functions are different even if they

25221
16:40:00,400 --> 16:40:02,636
have the same name here they are two

25222
16:40:02,636 --> 16:40:04,560
different functions because they take

25223
16:40:04,560 --> 16:40:06,880
different parameters so if you try to

25224
16:40:06,880 --> 16:40:08,956
call this function with

25225
16:40:08,956 --> 16:40:11,596
integers this one is going to be called

25226
16:40:11,596 --> 16:40:14,080
which takes integers n if you call it

25227
16:40:14,080 --> 16:40:16,240
with double arguments this guy here is

25228
16:40:16,240 --> 16:40:17,916
going to be called let's try and prove

25229
16:40:17,916 --> 16:40:20,400
this so we're going to go inside and say

25230
16:40:20,400 --> 16:40:24,080
stdc out and overload called i think

25231
16:40:24,080 --> 16:40:26,000
this is enough and we're going to go in

25232
16:40:26,000 --> 16:40:28,636
the double function here and say sddc

25233
16:40:28,636 --> 16:40:31,116
out double overload cool

25234
16:40:31,116 --> 16:40:33,200
okay once we have this we also have to

25235
16:40:33,200 --> 16:40:35,840
change the return type here to double

25236
16:40:35,840 --> 16:40:37,276
because it's going to make things a

25237
16:40:37,276 --> 16:40:39,840
little bit consistent here but now we

25238
16:40:39,840 --> 16:40:43,040
want to go in our main function here

25239
16:40:43,040 --> 16:40:44,880
and set up a few variables we're going

25240
16:40:44,880 --> 16:40:46,796
to say and x and we're going to make

25241
16:40:46,796 --> 16:40:48,880
this a four and we're going to say into

25242
16:40:48,880 --> 16:40:51,200
y and we're going to make this a nine

25243
16:40:51,200 --> 16:40:52,320
why not

25244
16:40:52,320 --> 16:40:54,400
we're going to set up also double

25245
16:40:54,400 --> 16:40:57,520
variables let's say double a

25246
16:40:57,520 --> 16:40:59,436
and say five

25247
16:40:59,436 --> 16:41:02,560
point four to make it a double variable

25248
16:41:02,560 --> 16:41:04,636
and we're going to say double

25249
16:41:04,636 --> 16:41:08,480
b and put in 7.4

25250
16:41:08,480 --> 16:41:09,680
why not

25251
16:41:09,680 --> 16:41:11,596
now we are going to call max we're going

25252
16:41:11,596 --> 16:41:15,200
to say auto result and say max and

25253
16:41:15,200 --> 16:41:17,680
passing x and y

25254
16:41:17,680 --> 16:41:19,436
what do you think we're going to return

25255
16:41:19,436 --> 16:41:22,320
here so what we really are interested in

25256
16:41:22,320 --> 16:41:24,636
is the return type of the result

25257
16:41:24,636 --> 16:41:26,796
variable here and the compiler is going

25258
16:41:26,796 --> 16:41:29,360
to deduce whatever is returned by this

25259
16:41:29,360 --> 16:41:31,916
function if we call the function with x

25260
16:41:31,916 --> 16:41:34,480
and y x and y are integers so the

25261
16:41:34,480 --> 16:41:36,080
compiler is going to search for a

25262
16:41:36,080 --> 16:41:38,240
function that takes integers and it's

25263
16:41:38,240 --> 16:41:39,840
going to find this guy here and that's

25264
16:41:39,840 --> 16:41:41,756
what it's going to be called

25265
16:41:41,756 --> 16:41:44,400
let's weld and run this program we are

25266
16:41:44,400 --> 16:41:46,636
not interested in looking at the output

25267
16:41:46,636 --> 16:41:49,916
here we're just going to see this std

25268
16:41:49,916 --> 16:41:52,480
out statement here print whatever

25269
16:41:52,480 --> 16:41:55,040
function was called okay we expect the

25270
16:41:55,040 --> 16:41:56,636
end one to be called so we're going to

25271
16:41:56,636 --> 16:41:59,360
see ant overload called on the terminal

25272
16:41:59,360 --> 16:42:02,400
here when we run this program so let's

25273
16:42:02,400 --> 16:42:04,400
do that we're going to build with gcc

25274
16:42:04,400 --> 16:42:07,276
like we always do the world is good so

25275
16:42:07,276 --> 16:42:09,840
we can clear and run rooster

25276
16:42:09,840 --> 16:42:12,320
we're going to see int overload called

25277
16:42:12,320 --> 16:42:14,796
okay so this proves that

25278
16:42:14,796 --> 16:42:16,720
we can set up two functions with the

25279
16:42:16,720 --> 16:42:19,200
same name and make them different only

25280
16:42:19,200 --> 16:42:22,320
in the parameters that they take and the

25281
16:42:22,320 --> 16:42:24,796
differences may be either in the types

25282
16:42:24,796 --> 16:42:27,200
of the parameter like we are doing here

25283
16:42:27,200 --> 16:42:29,680
they may also be in the order of the

25284
16:42:29,680 --> 16:42:31,916
parameters and we're going to see an

25285
16:42:31,916 --> 16:42:34,160
example of that in a minute but before

25286
16:42:34,160 --> 16:42:36,560
we do that we also need to try this with

25287
16:42:36,560 --> 16:42:38,880
a and b and show you that the double one

25288
16:42:38,880 --> 16:42:41,116
is going to be called because we are

25289
16:42:41,116 --> 16:42:43,756
passing in double arguments here so

25290
16:42:43,756 --> 16:42:45,756
let's build again the bullet is good we

25291
16:42:45,756 --> 16:42:48,796
can clear and run rooster this is going

25292
16:42:48,796 --> 16:42:51,916
to call our double overload hopefully

25293
16:42:51,916 --> 16:42:54,400
this really drives the point home

25294
16:42:54,400 --> 16:42:56,720
that we can set up multiple overloads

25295
16:42:56,720 --> 16:42:59,276
for the same function name and again the

25296
16:42:59,276 --> 16:43:00,720
differences are going to be in the

25297
16:43:00,720 --> 16:43:03,040
parameters that we pass here we have

25298
16:43:03,040 --> 16:43:06,000
been able to pass different types for

25299
16:43:06,000 --> 16:43:08,480
the parameters and this was a vehicle c

25300
16:43:08,480 --> 16:43:10,956
plus plus code but we can also set up

25301
16:43:10,956 --> 16:43:14,000
another overload just by changing the

25302
16:43:14,000 --> 16:43:17,040
types and the order of the parameters

25303
16:43:17,040 --> 16:43:18,636
let's do that we're going to make the

25304
16:43:18,636 --> 16:43:21,360
first parameter here and and once we do

25305
16:43:21,360 --> 16:43:23,596
that this is different from any of the

25306
16:43:23,596 --> 16:43:26,480
overloads we've had so this is a valid

25307
16:43:26,480 --> 16:43:29,200
overload for this max function here this

25308
16:43:29,200 --> 16:43:31,436
is going to work we can even change the

25309
16:43:31,436 --> 16:43:33,680
order of these two guys and it is also

25310
16:43:33,680 --> 16:43:34,880
going to be

25311
16:43:34,880 --> 16:43:37,276
a valid overload let's put in another

25312
16:43:37,276 --> 16:43:39,200
variant of this guy

25313
16:43:39,200 --> 16:43:40,956
and we're going to change the first

25314
16:43:40,956 --> 16:43:43,040
parameter to double and the second one

25315
16:43:43,040 --> 16:43:46,240
to end and now we have four overloads

25316
16:43:46,240 --> 16:43:48,636
for the max function and again the

25317
16:43:48,636 --> 16:43:51,116
message here is that you just have to

25318
16:43:51,116 --> 16:43:54,080
make sure the parameters are different

25319
16:43:54,080 --> 16:43:56,636
in some way and your overload is going

25320
16:43:56,636 --> 16:43:59,040
to be valid and again i'm not telling

25321
16:43:59,040 --> 16:44:00,720
you to set up functions like this

25322
16:44:00,720 --> 16:44:02,400
because in this case this is really

25323
16:44:02,400 --> 16:44:05,116
useless but i am trying to expose this

25324
16:44:05,116 --> 16:44:07,520
facility to you so that you can use it

25325
16:44:07,520 --> 16:44:10,560
to your advantage if it makes sense for

25326
16:44:10,560 --> 16:44:12,480
whatever application you are designing

25327
16:44:12,480 --> 16:44:15,360
here so let's go down and put in

25328
16:44:15,360 --> 16:44:18,320
meaningful output i think we can come in

25329
16:44:18,320 --> 16:44:20,080
here and say the parameters that we are

25330
16:44:20,080 --> 16:44:22,956
passing in here so we can say and double

25331
16:44:22,956 --> 16:44:25,200
overload called and if we go down here

25332
16:44:25,200 --> 16:44:28,000
you can take this out and say double and

25333
16:44:28,000 --> 16:44:30,636
overload called and to get any of these

25334
16:44:30,636 --> 16:44:32,720
guys to be called we have to pass the

25335
16:44:32,720 --> 16:44:35,200
parameters or of the arguments in this

25336
16:44:35,200 --> 16:44:36,160
order

25337
16:44:36,160 --> 16:44:39,840
so if we pass in an end which is x x is

25338
16:44:39,840 --> 16:44:42,480
in it and we pass in a double which is a

25339
16:44:42,480 --> 16:44:44,720
b here this is going to call our

25340
16:44:44,720 --> 16:44:47,520
overload which takes the first argument

25341
16:44:47,520 --> 16:44:50,000
to be an integer and the second argument

25342
16:44:50,000 --> 16:44:51,276
to be double

25343
16:44:51,276 --> 16:44:53,276
let's prove that we're going to

25344
16:44:53,276 --> 16:44:55,756
build with the gcc the bolt is good so

25345
16:44:55,756 --> 16:44:57,840
we can clear and we can run rooster and

25346
16:44:57,840 --> 16:45:00,720
we see ant double called because x is an

25347
16:45:00,720 --> 16:45:01,520
end

25348
16:45:01,520 --> 16:45:04,720
and b is a double if we flip these guys

25349
16:45:04,720 --> 16:45:07,596
let's say b and x then we're going to

25350
16:45:07,596 --> 16:45:09,916
have the overload that takes the first

25351
16:45:09,916 --> 16:45:12,796
argument of double type and the second

25352
16:45:12,796 --> 16:45:15,116
argument of into type to be called and

25353
16:45:15,116 --> 16:45:17,116
that's this guy here and we're going to

25354
16:45:17,116 --> 16:45:19,840
see this message printed out on the

25355
16:45:19,840 --> 16:45:22,480
terminal here let's build with gcc to

25356
16:45:22,480 --> 16:45:24,240
really prove this so we're going to do

25357
16:45:24,240 --> 16:45:25,040
that

25358
16:45:25,040 --> 16:45:27,436
the bullet is good we can clear and run

25359
16:45:27,436 --> 16:45:28,400
rooster

25360
16:45:28,400 --> 16:45:30,720
and the double end overload called

25361
16:45:30,720 --> 16:45:32,480
hopefully you can really see that you

25362
16:45:32,480 --> 16:45:35,596
can set up all kinds of crazy overloads

25363
16:45:35,596 --> 16:45:38,000
for your functions the next thing i want

25364
16:45:38,000 --> 16:45:39,680
you to see is that we can even change

25365
16:45:39,680 --> 16:45:42,240
the number of the parameters for example

25366
16:45:42,240 --> 16:45:44,636
here we can set up another guy here and

25367
16:45:44,636 --> 16:45:47,276
i call it max it is going to be exactly

25368
16:45:47,276 --> 16:45:49,840
like the one on top here for the first

25369
16:45:49,840 --> 16:45:52,796
two parameters but let's add a third

25370
16:45:52,796 --> 16:45:56,240
parameter maybe make it an end and say c

25371
16:45:56,240 --> 16:45:57,840
and this is going to be

25372
16:45:57,840 --> 16:46:00,400
a valid overload for the max function

25373
16:46:00,400 --> 16:46:02,560
here so we're going to say double and

25374
16:46:02,560 --> 16:46:04,000
because it takes

25375
16:46:04,000 --> 16:46:06,720
three parameters i won't go into the

25376
16:46:06,720 --> 16:46:08,796
details of how we can compute the

25377
16:46:08,796 --> 16:46:11,360
maximum between these three guys what i

25378
16:46:11,360 --> 16:46:13,436
really am interested in is showing you

25379
16:46:13,436 --> 16:46:15,756
that you can set up overloads here so

25380
16:46:15,756 --> 16:46:17,436
for this case we are just going to

25381
16:46:17,436 --> 16:46:20,480
return let's just say a this is going to

25382
16:46:20,480 --> 16:46:23,596
work but this is a valid overload for

25383
16:46:23,596 --> 16:46:25,200
the match function and it is going to

25384
16:46:25,200 --> 16:46:27,840
compile so let's draw and do that we're

25385
16:46:27,840 --> 16:46:30,160
going to pass and a double a net and the

25386
16:46:30,160 --> 16:46:32,636
net so we're going to pass in b which is

25387
16:46:32,636 --> 16:46:34,880
a double and x and y

25388
16:46:34,880 --> 16:46:36,400
let's see what is called here we can

25389
16:46:36,400 --> 16:46:39,360
compile with gcc the border is good we

25390
16:46:39,360 --> 16:46:41,520
can clear and please

25391
16:46:41,520 --> 16:46:43,276
try to come up with what is going to be

25392
16:46:43,276 --> 16:46:44,880
printed out here what is going to be

25393
16:46:44,880 --> 16:46:47,116
printed okay now that you have guessed

25394
16:46:47,116 --> 16:46:48,636
we're going to run and we're going to

25395
16:46:48,636 --> 16:46:50,880
see double and ant because this is going

25396
16:46:50,880 --> 16:46:53,596
to call this overload again you can

25397
16:46:53,596 --> 16:46:56,320
overload based on the differences in the

25398
16:46:56,320 --> 16:46:58,796
types of the parameters that you pass

25399
16:46:58,796 --> 16:47:00,480
you can change the order of the

25400
16:47:00,480 --> 16:47:03,276
parameters like we are doing here double

25401
16:47:03,276 --> 16:47:06,480
end and end double or you can even

25402
16:47:06,480 --> 16:47:08,636
change the number of the parameters

25403
16:47:08,636 --> 16:47:11,276
using these techniques you can make sure

25404
16:47:11,276 --> 16:47:13,756
that your overloads are different in

25405
16:47:13,756 --> 16:47:14,880
some way

25406
16:47:14,880 --> 16:47:16,956
before i close this lecture i'm going to

25407
16:47:16,956 --> 16:47:18,720
show you that you can also use another

25408
16:47:18,720 --> 16:47:20,400
overload that takes

25409
16:47:20,400 --> 16:47:22,720
string view parameters let's go down

25410
16:47:22,720 --> 16:47:24,956
here and put that in

25411
16:47:24,956 --> 16:47:26,880
again the name of the function is max

25412
16:47:26,880 --> 16:47:29,276
the return type isn't really meaningful

25413
16:47:29,276 --> 16:47:31,040
in making sure two functions are

25414
16:47:31,040 --> 16:47:33,276
different but watch the parameters we

25415
16:47:33,276 --> 16:47:36,240
pass here the types are string view

25416
16:47:36,240 --> 16:47:38,560
and we have a and b here and we are

25417
16:47:38,560 --> 16:47:40,880
going to compute the maximum so if we go

25418
16:47:40,880 --> 16:47:44,636
down here and say max and pass n hello

25419
16:47:44,636 --> 16:47:46,880
and world the compiler is going to try

25420
16:47:46,880 --> 16:47:49,756
and look for a function that takes two

25421
16:47:49,756 --> 16:47:51,680
character array parameters it's not

25422
16:47:51,680 --> 16:47:53,360
going to find it because we don't have

25423
16:47:53,360 --> 16:47:55,840
that guy in here but it's going to see

25424
16:47:55,840 --> 16:47:57,840
which function can

25425
16:47:57,840 --> 16:48:01,040
take something i can come up with

25426
16:48:01,040 --> 16:48:03,116
through implicit conversions and the

25427
16:48:03,116 --> 16:48:04,720
compiler is going to see that it can

25428
16:48:04,720 --> 16:48:06,480
really convert from

25429
16:48:06,480 --> 16:48:09,916
a string literal to a string view type

25430
16:48:09,916 --> 16:48:12,160
and it is going to insert an implicit

25431
16:48:12,160 --> 16:48:13,840
conversion from

25432
16:48:13,840 --> 16:48:16,636
string literal to string view and this

25433
16:48:16,636 --> 16:48:18,880
function here is going to be called so

25434
16:48:18,880 --> 16:48:21,200
we're going to put in a an output

25435
16:48:21,200 --> 16:48:23,436
statement here we're going to say

25436
16:48:23,436 --> 16:48:27,840
string view string view overload called

25437
16:48:27,840 --> 16:48:30,480
and if we try and run this program let's

25438
16:48:30,480 --> 16:48:32,880
build with gcc make sure that the build

25439
16:48:32,880 --> 16:48:33,916
is good

25440
16:48:33,916 --> 16:48:36,480
the world is good so we can clear and

25441
16:48:36,480 --> 16:48:38,956
run rooster this is going to show string

25442
16:48:38,956 --> 16:48:41,680
view string view overload called we are

25443
16:48:41,680 --> 16:48:44,160
able to call this guy here and again the

25444
16:48:44,160 --> 16:48:46,480
message is that we really have a lot of

25445
16:48:46,480 --> 16:48:49,040
flexibility in how we can set up

25446
16:48:49,040 --> 16:48:52,400
overloads for a function in c plus plus

25447
16:48:52,400 --> 16:48:55,436
and please use this facility at your

25448
16:48:55,436 --> 16:48:57,916
advantage if this makes things better

25449
16:48:57,916 --> 16:48:59,596
for whatever application you are

25450
16:48:59,596 --> 16:49:02,240
designing i would like to welcome you in

25451
16:49:02,240 --> 16:49:04,160
this new chapter where we're going to be

25452
16:49:04,160 --> 16:49:06,796
learning about lambda functions lambda

25453
16:49:06,796 --> 16:49:09,596
functions are a mechanism we have in c

25454
16:49:09,596 --> 16:49:12,796
plus plus to set up anonymous functions

25455
16:49:12,796 --> 16:49:15,040
once we have anonymous function set up

25456
16:49:15,040 --> 16:49:17,116
we can do all kinds of crazy things with

25457
16:49:17,116 --> 16:49:19,916
them for example we can give them names

25458
16:49:19,916 --> 16:49:22,636
and code them multiple times or we can

25459
16:49:22,636 --> 16:49:25,040
even call them directly without even

25460
16:49:25,040 --> 16:49:27,360
giving them a name i realize this can be

25461
16:49:27,360 --> 16:49:29,520
really cryptic so we're going to head

25462
16:49:29,520 --> 16:49:31,840
over to the next lecture and see how we

25463
16:49:31,840 --> 16:49:35,596
can declare and use our lambda functions

25464
16:49:35,596 --> 16:49:37,520
go ahead and finish up here

25465
16:49:37,520 --> 16:49:39,520
and meet me there in this lecture we're

25466
16:49:39,520 --> 16:49:42,000
going to see how we can declare and use

25467
16:49:42,000 --> 16:49:44,880
our lambda functions and again lambda

25468
16:49:44,880 --> 16:49:47,680
functions are a mechanism we have in c

25469
16:49:47,680 --> 16:49:51,040
plus plus to set up anonymous functions

25470
16:49:51,040 --> 16:49:53,360
and an anonymous function is a function

25471
16:49:53,360 --> 16:49:55,520
without a name we're going to see how we

25472
16:49:55,520 --> 16:49:57,680
can set up an anonymous function

25473
16:49:57,680 --> 16:49:59,916
optionally give it a name and call it or

25474
16:49:59,916 --> 16:50:02,000
we can even call it directly without

25475
16:50:02,000 --> 16:50:04,320
giving that a name let's see how we can

25476
16:50:04,320 --> 16:50:06,636
do that before we talk about anything

25477
16:50:06,636 --> 16:50:08,400
about lambda functions we're going to

25478
16:50:08,400 --> 16:50:09,840
first to see

25479
16:50:09,840 --> 16:50:12,880
the lambda function signature and there

25480
16:50:12,880 --> 16:50:15,116
is a special syntax you have to follow

25481
16:50:15,116 --> 16:50:16,880
if you want to set up a lambda function

25482
16:50:16,880 --> 16:50:18,796
in c plus plus the first thing you have

25483
16:50:18,796 --> 16:50:21,200
to put in place is angle brackets like

25484
16:50:21,200 --> 16:50:24,160
this and that's going to be your capture

25485
16:50:24,160 --> 16:50:26,480
list we are not going to talk anymore

25486
16:50:26,480 --> 16:50:27,916
about this we're going to have a chance

25487
16:50:27,916 --> 16:50:30,560
to talk about this in detail after your

25488
16:50:30,560 --> 16:50:32,480
capture list which is going to leave in

25489
16:50:32,480 --> 16:50:35,040
this pair of angle brackets you're going

25490
16:50:35,040 --> 16:50:37,596
to have the parameters to your lambda

25491
16:50:37,596 --> 16:50:39,916
functions and this is where you can pass

25492
16:50:39,916 --> 16:50:41,840
arguments if you want to call your

25493
16:50:41,840 --> 16:50:43,916
lambda function after that you're going

25494
16:50:43,916 --> 16:50:46,956
to have a return type for your lambda

25495
16:50:46,956 --> 16:50:49,436
function but you don't have to put this

25496
16:50:49,436 --> 16:50:52,240
in explicitly you can live this out and

25497
16:50:52,240 --> 16:50:53,916
the compiler is going to deduce your

25498
16:50:53,916 --> 16:50:56,400
return type by itself

25499
16:50:56,400 --> 16:50:58,480
after all these things you have to put

25500
16:50:58,480 --> 16:51:01,916
in a pair of curly braces and inside

25501
16:51:01,916 --> 16:51:03,916
these curly braces we're going to have

25502
16:51:03,916 --> 16:51:06,400
our function body and we can do whatever

25503
16:51:06,400 --> 16:51:09,040
we want our lambda function to do in

25504
16:51:09,040 --> 16:51:11,116
this function body here after this you

25505
16:51:11,116 --> 16:51:12,880
will have to remember to put your

25506
16:51:12,880 --> 16:51:15,680
semicolon to make whatever statements

25507
16:51:15,680 --> 16:51:17,040
contain

25508
16:51:17,040 --> 16:51:19,276
this along the function to be valid and

25509
16:51:19,276 --> 16:51:21,360
this is the syntax you have to follow

25510
16:51:21,360 --> 16:51:23,840
here we have a simple example so we have

25511
16:51:23,840 --> 16:51:26,320
our lambda function we want to say hello

25512
16:51:26,320 --> 16:51:28,796
to the console this is what we have in

25513
16:51:28,796 --> 16:51:30,796
the body of the lambda function but

25514
16:51:30,796 --> 16:51:32,956
notice that we have our capture list

25515
16:51:32,956 --> 16:51:34,880
which is going to be

25516
16:51:34,880 --> 16:51:37,756
delimited by these angle brackets we

25517
16:51:37,756 --> 16:51:40,000
have our parameter list which is going

25518
16:51:40,000 --> 16:51:42,080
to be empty in this moment because this

25519
16:51:42,080 --> 16:51:43,756
lambda function doesn't take any

25520
16:51:43,756 --> 16:51:46,560
parameter and we have our body which is

25521
16:51:46,560 --> 16:51:48,400
going to leave within

25522
16:51:48,400 --> 16:51:51,520
these two curly braces and after that we

25523
16:51:51,520 --> 16:51:54,636
have our semicolon to make this a valid

25524
16:51:54,636 --> 16:51:57,520
c plus plus statement if we try and put

25525
16:51:57,520 --> 16:51:59,680
this thing in our c plus plus source

25526
16:51:59,680 --> 16:52:00,400
code

25527
16:52:00,400 --> 16:52:02,400
this is going to be a valid lambda

25528
16:52:02,400 --> 16:52:04,880
function but it isn't really useful by

25529
16:52:04,880 --> 16:52:07,436
now because we can't call it one way we

25530
16:52:07,436 --> 16:52:09,596
have to call it is to give it a name and

25531
16:52:09,596 --> 16:52:12,400
we can give it a name by assigning our

25532
16:52:12,400 --> 16:52:15,276
lambda function to a variable like we

25533
16:52:15,276 --> 16:52:17,520
see here once we have our lambda

25534
16:52:17,520 --> 16:52:20,320
function declared like this this entire

25535
16:52:20,320 --> 16:52:22,720
thing is going to be our lambda function

25536
16:52:22,720 --> 16:52:25,520
type we can take this and assign that to

25537
16:52:25,520 --> 16:52:28,000
a variable which is going to deduce the

25538
16:52:28,000 --> 16:52:28,880
type

25539
16:52:28,880 --> 16:52:31,200
using auto type deduction here this is

25540
16:52:31,200 --> 16:52:32,720
what we are doing

25541
16:52:32,720 --> 16:52:35,276
once this thing has a name then we can

25542
16:52:35,276 --> 16:52:38,560
call it with the syntax we have here and

25543
16:52:38,560 --> 16:52:40,720
if we run this code now it is going to

25544
16:52:40,720 --> 16:52:43,276
print hello world to the console i

25545
16:52:43,276 --> 16:52:45,360
realize this syntax can be really

25546
16:52:45,360 --> 16:52:48,880
cryptic but if you try to remember this

25547
16:52:48,880 --> 16:52:50,480
you're going to find that lambda

25548
16:52:50,480 --> 16:52:53,040
functions are really cool and later in

25549
16:52:53,040 --> 16:52:54,796
the course we will see that they really

25550
16:52:54,796 --> 16:52:57,520
make a lot of things easier in c plus

25551
16:52:57,520 --> 16:53:00,160
plus so try to remember the syntax here

25552
16:53:00,160 --> 16:53:02,160
and everything is going to flow from

25553
16:53:02,160 --> 16:53:04,796
here again the syntax is to have the

25554
16:53:04,796 --> 16:53:06,796
capture list which is going to be the

25555
16:53:06,796 --> 16:53:08,880
first thing the second thing is going to

25556
16:53:08,880 --> 16:53:11,200
be the parameters the third thing is

25557
16:53:11,200 --> 16:53:13,040
going to be the return type which is

25558
16:53:13,040 --> 16:53:14,720
optional you can leave this out and the

25559
16:53:14,720 --> 16:53:16,880
compiler is going to deduce this and

25560
16:53:16,880 --> 16:53:18,240
after this you're going to have your

25561
16:53:18,240 --> 16:53:21,756
pair of curly braces and the body of our

25562
16:53:21,756 --> 16:53:24,240
lambda function is going to leave within

25563
16:53:24,240 --> 16:53:26,720
these curly braces this is the syntax

25564
16:53:26,720 --> 16:53:28,560
you need to remember okay we have seen

25565
16:53:28,560 --> 16:53:30,956
that we can give a name to our lambda

25566
16:53:30,956 --> 16:53:33,436
function and call it but it is also

25567
16:53:33,436 --> 16:53:36,000
possible to call our lambda function

25568
16:53:36,000 --> 16:53:39,200
directly without giving it a name and we

25569
16:53:39,200 --> 16:53:42,240
do that by appending a pair of curly

25570
16:53:42,240 --> 16:53:45,276
braces to the lambda function definition

25571
16:53:45,276 --> 16:53:47,200
here so we have a lambda function we

25572
16:53:47,200 --> 16:53:49,200
have our curly braces and we have our

25573
16:53:49,200 --> 16:53:52,320
parameter list we have our body here and

25574
16:53:52,320 --> 16:53:55,520
after the closing curly brace we're

25575
16:53:55,520 --> 16:53:57,756
going to add a pair of parentheses to

25576
16:53:57,756 --> 16:54:00,080
call this lambda function and because

25577
16:54:00,080 --> 16:54:02,480
this lambda function takes no parameter

25578
16:54:02,480 --> 16:54:04,480
we're not going to put any argument

25579
16:54:04,480 --> 16:54:06,796
within our parenthesis here and this is

25580
16:54:06,796 --> 16:54:09,276
going to call our lambda function don't

25581
16:54:09,276 --> 16:54:11,116
worry if you find this confusing we're

25582
16:54:11,116 --> 16:54:12,880
going to head over to visual studio code

25583
16:54:12,880 --> 16:54:14,720
in a minute and all of this is going to

25584
16:54:14,720 --> 16:54:17,200
make sense okay so far we haven't really

25585
16:54:17,200 --> 16:54:19,916
seen that we can pass parameters to our

25586
16:54:19,916 --> 16:54:22,320
lambda function here is a simple example

25587
16:54:22,320 --> 16:54:24,880
that takes parameters this is a lambda

25588
16:54:24,880 --> 16:54:27,116
function because it follows the syntax

25589
16:54:27,116 --> 16:54:29,276
for lambda functions we have

25590
16:54:29,276 --> 16:54:31,756
our capture list we have our parameter

25591
16:54:31,756 --> 16:54:34,560
list we have our curly braces and the

25592
16:54:34,560 --> 16:54:36,720
body is going to live inside these guys

25593
16:54:36,720 --> 16:54:38,956
and we are calling this lambda function

25594
16:54:38,956 --> 16:54:41,756
directly with this parameter list the

25595
16:54:41,756 --> 16:54:43,200
lambda function is going to take two

25596
16:54:43,200 --> 16:54:45,756
parameters of double type we're going to

25597
16:54:45,756 --> 16:54:48,400
print out the sum of these two numbers

25598
16:54:48,400 --> 16:54:50,080
and that we are going to call this

25599
16:54:50,080 --> 16:54:52,080
lambda function directly notice that we

25600
16:54:52,080 --> 16:54:55,040
are passing in our arguments

25601
16:54:55,040 --> 16:54:56,000
as

25602
16:54:56,000 --> 16:54:57,596
double

25603
16:54:57,596 --> 16:55:00,160
literals okay this is how you can set up

25604
16:55:00,160 --> 16:55:02,796
a lambda function that takes parameters

25605
16:55:02,796 --> 16:55:04,796
and call it directly another thing we

25606
16:55:04,796 --> 16:55:07,436
can do is make our lambda function

25607
16:55:07,436 --> 16:55:09,436
return something and that's really

25608
16:55:09,436 --> 16:55:11,116
simple we're going to set up the lambda

25609
16:55:11,116 --> 16:55:12,880
function like this so it's going to take

25610
16:55:12,880 --> 16:55:15,200
two parameters a and b

25611
16:55:15,200 --> 16:55:17,596
and here you see that we are returning a

25612
16:55:17,596 --> 16:55:20,000
plus b and we can do that the lambda

25613
16:55:20,000 --> 16:55:21,840
function is now going to return

25614
16:55:21,840 --> 16:55:24,636
something and this entire thing we have

25615
16:55:24,636 --> 16:55:28,080
here is going to be a lambda expression

25616
16:55:28,080 --> 16:55:29,596
the lambda function is going to be

25617
16:55:29,596 --> 16:55:31,916
called it is going to return something

25618
16:55:31,916 --> 16:55:34,240
and what the lambda function returns is

25619
16:55:34,240 --> 16:55:36,480
going to be assigned to this result

25620
16:55:36,480 --> 16:55:38,636
variable here and if we print it we're

25621
16:55:38,636 --> 16:55:40,796
going to get the sum of whatever pass in

25622
16:55:40,796 --> 16:55:42,956
here printed out on the console and

25623
16:55:42,956 --> 16:55:45,116
you're going to see it printed out on

25624
16:55:45,116 --> 16:55:47,680
the terminal it is also possible to put

25625
16:55:47,680 --> 16:55:50,240
your lambda function directly in an

25626
16:55:50,240 --> 16:55:52,880
output statement i realize this can be

25627
16:55:52,880 --> 16:55:56,000
really confusing but please look at this

25628
16:55:56,000 --> 16:55:59,200
entire lambda function is same here

25629
16:55:59,200 --> 16:56:02,160
as a single value because this is a

25630
16:56:02,160 --> 16:56:04,240
lambda function that is going to return

25631
16:56:04,240 --> 16:56:06,720
something and what is returned by this

25632
16:56:06,720 --> 16:56:09,040
lambda function is going to be printed

25633
16:56:09,040 --> 16:56:11,436
as our result here

25634
16:56:11,436 --> 16:56:14,160
again i realize this may be confusing to

25635
16:56:14,160 --> 16:56:16,400
many of you guys we are going to head

25636
16:56:16,400 --> 16:56:18,240
over to visual studio code in a minute

25637
16:56:18,240 --> 16:56:19,840
and we're going to see this and you're

25638
16:56:19,840 --> 16:56:21,680
going to really understand okay the last

25639
16:56:21,680 --> 16:56:23,276
thing we're going to look at is that we

25640
16:56:23,276 --> 16:56:26,636
can specify a return type to our lambda

25641
16:56:26,636 --> 16:56:29,436
function and the syntax to do this is to

25642
16:56:29,436 --> 16:56:30,956
do a dash

25643
16:56:30,956 --> 16:56:34,160
a greater than symbol and put your type

25644
16:56:34,160 --> 16:56:36,956
after that and when you do that now this

25645
16:56:36,956 --> 16:56:39,200
lambda function is going to be forced to

25646
16:56:39,200 --> 16:56:42,796
return double type even if you pass it

25647
16:56:42,796 --> 16:56:45,360
to parameters that are not of double

25648
16:56:45,360 --> 16:56:47,436
type we are going to add them up and the

25649
16:56:47,436 --> 16:56:49,680
return type is going to be implicitly

25650
16:56:49,680 --> 16:56:51,680
converted to double and that's what

25651
16:56:51,680 --> 16:56:53,360
we're going to return and we can print

25652
16:56:53,360 --> 16:56:55,596
it out on the console and we're going to

25653
16:56:55,596 --> 16:56:57,840
see an example of this in a minute when

25654
16:56:57,840 --> 16:57:00,560
we hit visual studio code in fact this

25655
16:57:00,560 --> 16:57:02,560
is really all i had to share with you in

25656
16:57:02,560 --> 16:57:04,956
the slides i realized many of these

25657
16:57:04,956 --> 16:57:07,520
things may be confusing we are going to

25658
16:57:07,520 --> 16:57:09,840
head over to visual studio code and play

25659
16:57:09,840 --> 16:57:12,160
with these things step by step and i am

25660
16:57:12,160 --> 16:57:14,000
sure you're going to understand here we

25661
16:57:14,000 --> 16:57:17,116
are in our working directory the current

25662
16:57:17,116 --> 16:57:19,680
project is declaring and using lambda

25663
16:57:19,680 --> 16:57:21,680
functions we're going to grab our

25664
16:57:21,680 --> 16:57:24,160
template files and put them in place

25665
16:57:24,160 --> 16:57:26,240
let's do that and we're going to grab

25666
16:57:26,240 --> 16:57:29,116
our folder here and drag and drop it in

25667
16:57:29,116 --> 16:57:30,880
visual studio code and this is going to

25668
16:57:30,880 --> 16:57:33,040
open it it is opened here we have our

25669
16:57:33,040 --> 16:57:36,000
main cpp file opened we can close the

25670
16:57:36,000 --> 16:57:38,320
left pane here because we don't want it

25671
16:57:38,320 --> 16:57:40,480
anymore and we can clean up our function

25672
16:57:40,480 --> 16:57:42,320
here and the first thing we're going to

25673
16:57:42,320 --> 16:57:45,276
do is to put in the syntax for a lambda

25674
16:57:45,276 --> 16:57:48,240
function here and use it as a reference

25675
16:57:48,240 --> 16:57:50,160
as we learn about this i think this is

25676
16:57:50,160 --> 16:57:52,320
going to make things a little easier so

25677
16:57:52,320 --> 16:57:54,080
the first thing we want to do is to

25678
16:57:54,080 --> 16:57:56,560
declare a lambda function and the first

25679
16:57:56,560 --> 16:57:58,400
thing we need to put in is a capture

25680
16:57:58,400 --> 16:58:00,796
list a capture list is going to be in

25681
16:58:00,796 --> 16:58:03,200
globe in this angle bracket so this is

25682
16:58:03,200 --> 16:58:05,680
our empty capture list and after this

25683
16:58:05,680 --> 16:58:07,756
we're going to put in a parameter list

25684
16:58:07,756 --> 16:58:10,000
which is going to leave inside this

25685
16:58:10,000 --> 16:58:12,240
parenthesis here after that we're going

25686
16:58:12,240 --> 16:58:13,520
to put in

25687
16:58:13,520 --> 16:58:15,756
an optional return type for now we're

25688
16:58:15,756 --> 16:58:17,520
going to ignore this and after that

25689
16:58:17,520 --> 16:58:20,000
we're going to put in our pair of curly

25690
16:58:20,000 --> 16:58:22,956
braces and inside this pair of curly

25691
16:58:22,956 --> 16:58:26,320
braces is where the body of our lambda

25692
16:58:26,320 --> 16:58:28,480
function is going to leave so inside

25693
16:58:28,480 --> 16:58:30,240
here we can do whatever we want in the

25694
16:58:30,240 --> 16:58:32,240
body of this lambda function for example

25695
16:58:32,240 --> 16:58:35,040
we can say hello world which is

25696
16:58:35,040 --> 16:58:37,276
the logical thing to do at this point so

25697
16:58:37,276 --> 16:58:39,436
we're going to say hello world here and

25698
16:58:39,436 --> 16:58:41,276
we're going to put in our new line

25699
16:58:41,276 --> 16:58:44,320
character with endl okay now we have a

25700
16:58:44,320 --> 16:58:47,116
lambda function declared but we have to

25701
16:58:47,116 --> 16:58:50,160
put in a closing semicolon because this

25702
16:58:50,160 --> 16:58:52,796
is a c plus plus statement okay now we

25703
16:58:52,796 --> 16:58:55,436
have our lambda function declared and

25704
16:58:55,436 --> 16:58:58,000
this is valid c plus plus code if we're

25705
16:58:58,000 --> 16:58:59,596
trying to compile this program you're

25706
16:58:59,596 --> 16:59:01,520
going to see that it is going to compile

25707
16:59:01,520 --> 16:59:04,240
fine cape world finished successfully

25708
16:59:04,240 --> 16:59:06,400
and if we try to run it it is not going

25709
16:59:06,400 --> 16:59:09,596
to do a thing because we are declaring

25710
16:59:09,596 --> 16:59:11,840
the lambda function here but we're not

25711
16:59:11,840 --> 16:59:14,400
calling it to get it to do things

25712
16:59:14,400 --> 16:59:16,400
so let's bring up a terminal and show

25713
16:59:16,400 --> 16:59:18,720
you that if we run this program it is

25714
16:59:18,720 --> 16:59:21,200
not going to do anything so let's do

25715
16:59:21,200 --> 16:59:23,276
clear and run rooster you're going to

25716
16:59:23,276 --> 16:59:24,636
see that it's not going to print

25717
16:59:24,636 --> 16:59:27,116
anything and we can even go down here

25718
16:59:27,116 --> 16:59:30,880
and put in a closing stdc out statement

25719
16:59:30,880 --> 16:59:33,116
saying it done to me that we are hitting

25720
16:59:33,116 --> 16:59:35,116
the end of the function here without

25721
16:59:35,116 --> 16:59:38,000
doing anything so if we vote again the

25722
16:59:38,000 --> 16:59:40,240
vote is going to be good we can clear

25723
16:59:40,240 --> 16:59:42,480
and we're going to run rooster you see

25724
16:59:42,480 --> 16:59:44,560
we are printing done we are hitting the

25725
16:59:44,560 --> 16:59:46,880
end of the function here and are we not

25726
16:59:46,880 --> 16:59:49,916
seeing hello world so this function here

25727
16:59:49,916 --> 16:59:52,880
or this lambda function here to be exact

25728
16:59:52,880 --> 16:59:55,360
is not being called one way we have to

25729
16:59:55,360 --> 16:59:57,436
call it is to give it a name

25730
16:59:57,436 --> 16:59:59,436
and we have seen that to give it a name

25731
16:59:59,436 --> 17:00:02,480
we have to assign the entire lambda

25732
17:00:02,480 --> 17:00:04,636
function thing we have here to a

25733
17:00:04,636 --> 17:00:06,480
variable and we're going to use auto

25734
17:00:06,480 --> 17:00:08,240
type deduction here so we're going to

25735
17:00:08,240 --> 17:00:10,956
say auto func and we're going to assign

25736
17:00:10,956 --> 17:00:14,320
our lambda function here to this

25737
17:00:14,320 --> 17:00:16,080
variable and this is going to be

25738
17:00:16,080 --> 17:00:18,880
basically a handle we have in our

25739
17:00:18,880 --> 17:00:21,520
program here to the lambda function and

25740
17:00:21,520 --> 17:00:24,000
we can use this handle to do things with

25741
17:00:24,000 --> 17:00:26,320
the lambda function but by now i want

25742
17:00:26,320 --> 17:00:28,160
you to see that even if we run the

25743
17:00:28,160 --> 17:00:31,040
program now it is not going to do

25744
17:00:31,040 --> 17:00:33,276
anything because we're still not calling

25745
17:00:33,276 --> 17:00:35,596
the lambda function here let's show you

25746
17:00:35,596 --> 17:00:37,520
that we're going to world again and the

25747
17:00:37,520 --> 17:00:39,360
world is going to be good no problem we

25748
17:00:39,360 --> 17:00:42,240
can clear and run rooster still not

25749
17:00:42,240 --> 17:00:44,000
hello world because we're not calling

25750
17:00:44,000 --> 17:00:46,636
our lambda function to call our lambda

25751
17:00:46,636 --> 17:00:49,436
function we have to use our handle here

25752
17:00:49,436 --> 17:00:53,200
which is this variable and use regular

25753
17:00:53,200 --> 17:00:55,916
function called syntax so we can go down

25754
17:00:55,916 --> 17:00:58,560
here and say func and we can put in our

25755
17:00:58,560 --> 17:01:00,956
parenthesis we're not putting in any

25756
17:01:00,956 --> 17:01:02,956
parameter because this lambda here

25757
17:01:02,956 --> 17:01:06,160
doesn't take any parameters and now if

25758
17:01:06,160 --> 17:01:08,240
we run this program it is going to say

25759
17:01:08,240 --> 17:01:10,480
hello world because this line here is

25760
17:01:10,480 --> 17:01:13,520
going to call this lambda function let's

25761
17:01:13,520 --> 17:01:15,436
bolt and see that

25762
17:01:15,436 --> 17:01:17,840
we're going to use gcc to build

25763
17:01:17,840 --> 17:01:21,276
so now if we clear and run rooster we're

25764
17:01:21,276 --> 17:01:23,276
going to see hello world we can call

25765
17:01:23,276 --> 17:01:25,276
this function multiple times because we

25766
17:01:25,276 --> 17:01:27,436
have a handle to it the handle is going

25767
17:01:27,436 --> 17:01:29,200
to be valid

25768
17:01:29,200 --> 17:01:30,880
throughout the scope of the main

25769
17:01:30,880 --> 17:01:32,956
function here so we're going to go down

25770
17:01:32,956 --> 17:01:35,520
and call it again and if we build we're

25771
17:01:35,520 --> 17:01:38,000
going to build with gcc the world is

25772
17:01:38,000 --> 17:01:40,956
good we can clear and run rooster we're

25773
17:01:40,956 --> 17:01:43,360
going to say hello world twice because

25774
17:01:43,360 --> 17:01:46,636
we are calling our lambda function twice

25775
17:01:46,636 --> 17:01:48,636
this is one way we have to call our

25776
17:01:48,636 --> 17:01:50,320
lambda function here

25777
17:01:50,320 --> 17:01:52,400
so we're going to comment this out

25778
17:01:52,400 --> 17:01:54,080
because we're going to see a few other

25779
17:01:54,080 --> 17:01:56,560
things and on top here what we were

25780
17:01:56,560 --> 17:01:58,956
doing is declaring around the function

25781
17:01:58,956 --> 17:02:01,200
and call it through an a now we're going

25782
17:02:01,200 --> 17:02:03,840
to go down set up a lambda function and

25783
17:02:03,840 --> 17:02:06,080
call it directly without giving it a

25784
17:02:06,080 --> 17:02:08,400
name because that's also a possibility

25785
17:02:08,400 --> 17:02:10,560
in c plus plus for that we're going to

25786
17:02:10,560 --> 17:02:12,560
grab our lambda function here and we're

25787
17:02:12,560 --> 17:02:14,560
going to copy it and we're going to say

25788
17:02:14,560 --> 17:02:16,880
declare a lambda function and call it

25789
17:02:16,880 --> 17:02:18,880
direct and the syntax to do that is

25790
17:02:18,880 --> 17:02:20,240
really simple

25791
17:02:20,240 --> 17:02:22,240
you set up your lambda function like we

25792
17:02:22,240 --> 17:02:24,400
have seen before you see this is our

25793
17:02:24,400 --> 17:02:26,720
lambda function statement here but

25794
17:02:26,720 --> 17:02:28,636
you're going to go to the closing curly

25795
17:02:28,636 --> 17:02:31,040
brace and add a pair

25796
17:02:31,040 --> 17:02:33,840
of parentheses this is going to declare

25797
17:02:33,840 --> 17:02:36,880
the lambda function and call it directly

25798
17:02:36,880 --> 17:02:39,116
notice that we don't have a handle to

25799
17:02:39,116 --> 17:02:41,596
this lambda function so if you do things

25800
17:02:41,596 --> 17:02:44,160
like this you will have only one chance

25801
17:02:44,160 --> 17:02:46,000
to call the lambda function so we're

25802
17:02:46,000 --> 17:02:48,400
going to say hello world once because we

25803
17:02:48,400 --> 17:02:50,796
are declaring the lambda function and

25804
17:02:50,796 --> 17:02:53,596
calling it directly here and after that

25805
17:02:53,596 --> 17:02:55,276
we're going to say done because we're

25806
17:02:55,276 --> 17:02:57,680
going to be hitting the end of the main

25807
17:02:57,680 --> 17:02:59,040
function here

25808
17:02:59,040 --> 17:03:00,796
let's build the program and show you

25809
17:03:00,796 --> 17:03:03,040
that we're going to build with gcc like

25810
17:03:03,040 --> 17:03:05,596
we always do we're going to clear

25811
17:03:05,596 --> 17:03:07,596
and run rooster this is going to say

25812
17:03:07,596 --> 17:03:09,756
hello world and we're going to be done

25813
17:03:09,756 --> 17:03:12,080
here because we are calling this lambda

25814
17:03:12,080 --> 17:03:15,520
function once again notice that now we

25815
17:03:15,520 --> 17:03:17,276
don't have a handle to this lambda

25816
17:03:17,276 --> 17:03:19,916
function so we really have one chance to

25817
17:03:19,916 --> 17:03:22,480
call this and you will do this if you

25818
17:03:22,480 --> 17:03:25,040
just want to set up some function that

25819
17:03:25,040 --> 17:03:27,436
you want to call directly and you don't

25820
17:03:27,436 --> 17:03:29,840
care about calling it ever again in your

25821
17:03:29,840 --> 17:03:32,080
c plus plus application and we're going

25822
17:03:32,080 --> 17:03:34,720
to see that we have many kinds of

25823
17:03:34,720 --> 17:03:37,200
problems where we want to do these kinds

25824
17:03:37,200 --> 17:03:38,240
of things

25825
17:03:38,240 --> 17:03:39,840
okay now that you have seen this the

25826
17:03:39,840 --> 17:03:42,080
next thing i want to show you is how to

25827
17:03:42,080 --> 17:03:44,160
set up a lambda function that takes

25828
17:03:44,160 --> 17:03:46,560
parameters and we're going to comment

25829
17:03:46,560 --> 17:03:48,636
out what we have on top here because we

25830
17:03:48,636 --> 17:03:51,916
don't want noise output on our terminal

25831
17:03:51,916 --> 17:03:53,596
and we're going to grab this lambda

25832
17:03:53,596 --> 17:03:56,160
function and adapt it

25833
17:03:56,160 --> 17:03:58,160
so let's copy it we're going to go down

25834
17:03:58,160 --> 17:04:00,720
here and put it in and we want to pass

25835
17:04:00,720 --> 17:04:02,796
two parameters now let's pass in double

25836
17:04:02,796 --> 17:04:04,480
parameters we're going to pass in double

25837
17:04:04,480 --> 17:04:07,360
a and double d you can do that

25838
17:04:07,360 --> 17:04:10,560
and inside the lambda function we can

25839
17:04:10,560 --> 17:04:13,596
print the sum of these two variables so

25840
17:04:13,596 --> 17:04:16,240
we're going to say a plus b for example

25841
17:04:16,240 --> 17:04:18,240
and we're going to print out whatever is

25842
17:04:18,240 --> 17:04:21,520
the result of a plus b let's do that and

25843
17:04:21,520 --> 17:04:22,880
after we do that you're going to see

25844
17:04:22,880 --> 17:04:26,000
that we get a compiler error because now

25845
17:04:26,000 --> 17:04:29,596
our lambda function is taking parameters

25846
17:04:29,596 --> 17:04:32,240
but we are calling that with an empty

25847
17:04:32,240 --> 17:04:34,080
list of parameters

25848
17:04:34,080 --> 17:04:36,560
so we need to give it something to sum

25849
17:04:36,560 --> 17:04:40,720
up let's give it 10.0 for example and a

25850
17:04:40,720 --> 17:04:43,360
5.0 and see what we get and after this

25851
17:04:43,360 --> 17:04:45,596
we need to put in our semicolon because

25852
17:04:45,596 --> 17:04:48,636
this is a z plus plus statement and any

25853
17:04:48,636 --> 17:04:51,436
c plus plus statement needs to end with

25854
17:04:51,436 --> 17:04:54,160
a semicolon now try to think about what

25855
17:04:54,160 --> 17:04:56,796
we are doing here we are setting up a

25856
17:04:56,796 --> 17:04:59,040
lambda function okay it's going to end

25857
17:04:59,040 --> 17:05:00,720
at this closing

25858
17:05:00,720 --> 17:05:03,276
curly brace and this lambda function is

25859
17:05:03,276 --> 17:05:05,436
going to take two parameters of double

25860
17:05:05,436 --> 17:05:06,320
type

25861
17:05:06,320 --> 17:05:08,320
and inside the lambda function we are

25862
17:05:08,320 --> 17:05:10,320
going to print out whatever is the sum

25863
17:05:10,320 --> 17:05:12,880
of these two parameters that we are

25864
17:05:12,880 --> 17:05:14,320
taking in here

25865
17:05:14,320 --> 17:05:16,080
after that we are calling our lambda

25866
17:05:16,080 --> 17:05:20,720
function with two variables 10.0 and 5.0

25867
17:05:20,720 --> 17:05:24,000
or i should say two double literals

25868
17:05:24,000 --> 17:05:25,680
that's what we are calling our lambda

25869
17:05:25,680 --> 17:05:28,560
function with and now if the program

25870
17:05:28,560 --> 17:05:30,796
runs the lambda function is going to be

25871
17:05:30,796 --> 17:05:32,636
called once and we're going to print out

25872
17:05:32,636 --> 17:05:35,276
whatever is the sum of these two numbers

25873
17:05:35,276 --> 17:05:37,916
and that's going to be 15. let's build

25874
17:05:37,916 --> 17:05:40,480
so we're going to build with gcc

25875
17:05:40,480 --> 17:05:42,796
the world is good we can clear and run

25876
17:05:42,796 --> 17:05:45,360
rooster we're going to see a plus b is

25877
17:05:45,360 --> 17:05:47,520
15. we are calling a lambda function

25878
17:05:47,520 --> 17:05:50,080
here if we put in a 50 here for example

25879
17:05:50,080 --> 17:05:52,080
we're going to get 60 printed out

25880
17:05:52,080 --> 17:05:54,320
because that's going to be our sum okay

25881
17:05:54,320 --> 17:05:56,480
let's boil it again and see that print

25882
17:05:56,480 --> 17:05:58,560
it down if we run rooster we're going to

25883
17:05:58,560 --> 17:06:01,680
see 60 because that's the sum of 10 and

25884
17:06:01,680 --> 17:06:02,880
50 here

25885
17:06:02,880 --> 17:06:05,360
another thing we can do is actually

25886
17:06:05,360 --> 17:06:07,360
not call the lambda function directly

25887
17:06:07,360 --> 17:06:09,360
here we can actually comment this out i

25888
17:06:09,360 --> 17:06:11,116
don't want to take this out because you

25889
17:06:11,116 --> 17:06:13,756
might want to use this as a reference so

25890
17:06:13,756 --> 17:06:15,756
we're going to comment this out and set

25891
17:06:15,756 --> 17:06:17,276
up another example

25892
17:06:17,276 --> 17:06:19,276
that is going to name our lambda

25893
17:06:19,276 --> 17:06:21,916
function and then we will have a handle

25894
17:06:21,916 --> 17:06:23,680
to the lambda function and we can call

25895
17:06:23,680 --> 17:06:25,360
it multiple times

25896
17:06:25,360 --> 17:06:28,240
so let's take out the call we are doing

25897
17:06:28,240 --> 17:06:30,000
here and we're going to assign our

25898
17:06:30,000 --> 17:06:32,560
lambda function to a variable we're

25899
17:06:32,560 --> 17:06:34,956
going to say auto func one we can call

25900
17:06:34,956 --> 17:06:38,080
this func one no problem and now

25901
17:06:38,080 --> 17:06:39,756
we can call this lambda function

25902
17:06:39,756 --> 17:06:42,480
multiple times for example we can say

25903
17:06:42,480 --> 17:06:46,320
funk one and pass in 10 and 20 okay and

25904
17:06:46,320 --> 17:06:50,080
we can say funk one and pass in five

25905
17:06:50,080 --> 17:06:52,480
and seven why not

25906
17:06:52,480 --> 17:06:54,400
if we run this program it is going to

25907
17:06:54,400 --> 17:06:56,796
print the sum of 10 and 20 and it is

25908
17:06:56,796 --> 17:06:59,360
going to print the sum of five and seven

25909
17:06:59,360 --> 17:07:01,116
and it is going to be calling this

25910
17:07:01,116 --> 17:07:03,680
lambda function multiple times hopefully

25911
17:07:03,680 --> 17:07:05,840
you can see that if you want a chance to

25912
17:07:05,840 --> 17:07:08,560
call your lambda function multiple times

25913
17:07:08,560 --> 17:07:10,796
you will need to give it a handle like

25914
17:07:10,796 --> 17:07:12,880
we are doing here and then you can use

25915
17:07:12,880 --> 17:07:14,160
that handle

25916
17:07:14,160 --> 17:07:16,400
multiple times and call your lambda

25917
17:07:16,400 --> 17:07:18,880
function however many times you want so

25918
17:07:18,880 --> 17:07:21,360
let's build this program and see what we

25919
17:07:21,360 --> 17:07:23,596
get on the console

25920
17:07:23,596 --> 17:07:26,320
i'm going to clear and run rooster

25921
17:07:26,320 --> 17:07:28,956
now we're going to see a plus b it's 30

25922
17:07:28,956 --> 17:07:31,520
as a result of this call here and we're

25923
17:07:31,520 --> 17:07:34,160
going to see a plus b is 12

25924
17:07:34,160 --> 17:07:36,956
as a result of this call here notice

25925
17:07:36,956 --> 17:07:40,400
that we are passing an integer literals

25926
17:07:40,400 --> 17:07:42,480
so the compiler is going to insert an

25927
17:07:42,480 --> 17:07:45,520
implicit conversion from and to double

25928
17:07:45,520 --> 17:07:47,520
because our lambda function here is

25929
17:07:47,520 --> 17:07:49,756
taking double type you really need to be

25930
17:07:49,756 --> 17:07:52,720
aware of these implicit conversions and

25931
17:07:52,720 --> 17:07:54,560
make sure they are working to your

25932
17:07:54,560 --> 17:07:56,796
advantage if they are working against

25933
17:07:56,796 --> 17:07:58,480
you trying to find a way to make your

25934
17:07:58,480 --> 17:08:01,840
code work exactly like you want because

25935
17:08:01,840 --> 17:08:03,680
we are learning about all these cool

25936
17:08:03,680 --> 17:08:06,080
tricks in c plus plus you're going to be

25937
17:08:06,080 --> 17:08:08,240
using them at your advantage okay

25938
17:08:08,240 --> 17:08:10,080
hopefully now you know how you can set

25939
17:08:10,080 --> 17:08:11,916
up a lambda function that takes

25940
17:08:11,916 --> 17:08:14,080
parameters we're going to go down and

25941
17:08:14,080 --> 17:08:16,636
comment this out because now we want to

25942
17:08:16,636 --> 17:08:19,116
see how we can return something from a

25943
17:08:19,116 --> 17:08:20,880
lambda function and we're going to be

25944
17:08:20,880 --> 17:08:22,796
using the same lambda function here so

25945
17:08:22,796 --> 17:08:24,400
let's grab it and we're going to say

25946
17:08:24,400 --> 17:08:26,636
lambda function that returns something

25947
17:08:26,636 --> 17:08:28,956
and we're going to set up our lambda

25948
17:08:28,956 --> 17:08:31,360
function here let's put that in place

25949
17:08:31,360 --> 17:08:32,560
correctly

25950
17:08:32,560 --> 17:08:35,756
and instead of printing out the sum of a

25951
17:08:35,756 --> 17:08:36,720
and b

25952
17:08:36,720 --> 17:08:39,116
we can return that we can go in our

25953
17:08:39,116 --> 17:08:41,680
lambda function and say return

25954
17:08:41,680 --> 17:08:44,560
a plus b okay now that we have this we

25955
17:08:44,560 --> 17:08:47,116
can either call it directly by saying

25956
17:08:47,116 --> 17:08:51,276
for example 10 and 20 but now if we try

25957
17:08:51,276 --> 17:08:54,160
and run this code it is not going to do

25958
17:08:54,160 --> 17:08:56,796
anything try to guess why

25959
17:08:56,796 --> 17:08:59,200
this lambda function is not printing to

25960
17:08:59,200 --> 17:09:01,276
the concept directly it is just

25961
17:09:01,276 --> 17:09:04,000
returning whatever is the sum of 10 and

25962
17:09:04,000 --> 17:09:04,956
20.

25963
17:09:04,956 --> 17:09:07,200
and if we return it we're not doing

25964
17:09:07,200 --> 17:09:09,276
anything with whatever is returned from

25965
17:09:09,276 --> 17:09:11,276
this lambda function so we're not going

25966
17:09:11,276 --> 17:09:12,880
to print anything and we're just going

25967
17:09:12,880 --> 17:09:14,480
to print done here

25968
17:09:14,480 --> 17:09:16,880
let's boil and make you see this because

25969
17:09:16,880 --> 17:09:18,480
you really need to be aware of these

25970
17:09:18,480 --> 17:09:19,680
little things

25971
17:09:19,680 --> 17:09:21,840
so the build is good we can clear and

25972
17:09:21,840 --> 17:09:24,160
run rooster we're going to see down our

25973
17:09:24,160 --> 17:09:26,720
lambda function is returning something

25974
17:09:26,720 --> 17:09:28,956
but we're not doing anything with the

25975
17:09:28,956 --> 17:09:30,400
return value

25976
17:09:30,400 --> 17:09:32,636
if we want to print the return value we

25977
17:09:32,636 --> 17:09:35,040
need to catch it somehow and we can put

25978
17:09:35,040 --> 17:09:36,880
that in a variable for example we can

25979
17:09:36,880 --> 17:09:39,840
say auto result and assign the return

25980
17:09:39,840 --> 17:09:42,636
value of our lambda function to this

25981
17:09:42,636 --> 17:09:44,956
variable now we have a chance to print

25982
17:09:44,956 --> 17:09:47,840
this for example by doing sddc out

25983
17:09:47,840 --> 17:09:49,916
result and we're going to

25984
17:09:49,916 --> 17:09:53,040
print that out and save result now if we

25985
17:09:53,040 --> 17:09:54,880
build this program it is going to print

25986
17:09:54,880 --> 17:09:57,360
whatever is the sum of 10 and 20. let's

25987
17:09:57,360 --> 17:09:58,956
do that and show you that this is

25988
17:09:58,956 --> 17:10:00,796
actually the case

25989
17:10:00,796 --> 17:10:04,636
so world is good so we can clear and run

25990
17:10:04,636 --> 17:10:08,720
rooster result is 30. if we pass in 10

25991
17:10:08,720 --> 17:10:11,520
and 50 for example we're going to get

25992
17:10:11,520 --> 17:10:14,240
the same thing let's pass in 60 here

25993
17:10:14,240 --> 17:10:16,400
so we're going to build with gcc the

25994
17:10:16,400 --> 17:10:18,636
build is good we can clear pretty quick

25995
17:10:18,636 --> 17:10:21,596
and run rooster now the sum is 70 and

25996
17:10:21,596 --> 17:10:23,840
this is how you can return stuff from

25997
17:10:23,840 --> 17:10:26,320
your lambda function and once you return

25998
17:10:26,320 --> 17:10:28,956
stuff you have to be sure you cut your

25999
17:10:28,956 --> 17:10:31,520
results and print them out another thing

26000
17:10:31,520 --> 17:10:33,756
you can do is print out the result

26001
17:10:33,756 --> 17:10:36,000
directly after you call your lambda

26002
17:10:36,000 --> 17:10:38,636
function so for example we can grab this

26003
17:10:38,636 --> 17:10:41,276
entire lambda function thing here and

26004
17:10:41,276 --> 17:10:44,080
put that in an sddc out statement so

26005
17:10:44,080 --> 17:10:46,320
we're going to put in a second one here

26006
17:10:46,320 --> 17:10:48,880
and say result or we can even comment

26007
17:10:48,880 --> 17:10:51,520
this out we don't want to be confused

26008
17:10:51,520 --> 17:10:53,360
when we look at the terminology we're

26009
17:10:53,360 --> 17:10:56,240
going to comment out the first sddc out

26010
17:10:56,240 --> 17:10:59,320
statement here and we're going to say

26011
17:10:59,320 --> 17:11:02,796
stdendl here and put in a placeholder

26012
17:11:02,796 --> 17:11:05,116
for our lambda function and we're going

26013
17:11:05,116 --> 17:11:06,560
to paste it in

26014
17:11:06,560 --> 17:11:08,636
if we do something like this again this

26015
17:11:08,636 --> 17:11:11,040
entire lambda function thing is going to

26016
17:11:11,040 --> 17:11:13,116
return the sum and that's what we're

26017
17:11:13,116 --> 17:11:15,840
going to print i realize this syntax is

26018
17:11:15,840 --> 17:11:18,560
really cryptic but it is going to work

26019
17:11:18,560 --> 17:11:21,276
let's try and build our program here the

26020
17:11:21,276 --> 17:11:23,680
world is good so we can clear and run

26021
17:11:23,680 --> 17:11:25,680
rooster we're going to see that result

26022
17:11:25,680 --> 17:11:29,040
is 70 and this is coming from our call

26023
17:11:29,040 --> 17:11:32,956
here which is nested inside our htdc out

26024
17:11:32,956 --> 17:11:35,520
statement you can do this if you want

26025
17:11:35,520 --> 17:11:37,520
another thing you can do as we have seen

26026
17:11:37,520 --> 17:11:40,160
before is give your lambda function a

26027
17:11:40,160 --> 17:11:42,796
name and call it repeatedly so for

26028
17:11:42,796 --> 17:11:44,796
example we can try and comment out what

26029
17:11:44,796 --> 17:11:47,040
we have here and set up another lambda

26030
17:11:47,040 --> 17:11:48,796
function because we

26031
17:11:48,796 --> 17:11:50,880
don't want to confuse you again so we're

26032
17:11:50,880 --> 17:11:53,756
going to grab our lambda function here

26033
17:11:53,756 --> 17:11:55,360
we're going to copy it because we don't

26034
17:11:55,360 --> 17:11:57,840
want to type this a thousand times

26035
17:11:57,840 --> 17:11:59,840
and we don't want to call this lambda

26036
17:11:59,840 --> 17:12:01,916
function directly instead we want to

26037
17:12:01,916 --> 17:12:03,596
give it a name and we're going to say

26038
17:12:03,596 --> 17:12:07,200
aro funk 2 and we're going to assign our

26039
17:12:07,200 --> 17:12:10,400
lambda function type to func one

26040
17:12:10,400 --> 17:12:12,880
now that we have this we can say auto

26041
17:12:12,880 --> 17:12:14,956
result 1 for example

26042
17:12:14,956 --> 17:12:17,276
and we can say func and we can pass in

26043
17:12:17,276 --> 17:12:19,756
whatever we want let's put in 23 and a

26044
17:12:19,756 --> 17:12:20,720
seven

26045
17:12:20,720 --> 17:12:23,680
and this is going to add up 23 and seven

26046
17:12:23,680 --> 17:12:25,276
we're going to grab the result and we're

26047
17:12:25,276 --> 17:12:27,756
going to assign that to result one

26048
17:12:27,756 --> 17:12:29,916
if we go down and say auto for example

26049
17:12:29,916 --> 17:12:33,276
result two and say for example funk one

26050
17:12:33,276 --> 17:12:34,636
and say

26051
17:12:34,636 --> 17:12:37,596
9 and 45

26052
17:12:37,596 --> 17:12:40,080
why not and go down and print out these

26053
17:12:40,080 --> 17:12:41,916
result variables we're going to see the

26054
17:12:41,916 --> 17:12:44,320
sums printed out and again the message

26055
17:12:44,320 --> 17:12:47,116
is that we can use this handle to call

26056
17:12:47,116 --> 17:12:49,200
our lambda function multiple times so

26057
17:12:49,200 --> 17:12:51,040
let's go down and print this out we're

26058
17:12:51,040 --> 17:12:52,240
going to say

26059
17:12:52,240 --> 17:12:54,636
result one and we're going to say result

26060
17:12:54,636 --> 17:12:56,636
one here we're going to go down and say

26061
17:12:56,636 --> 17:12:58,956
result two and we're going to print that

26062
17:12:58,956 --> 17:13:00,796
out and we can even call this lambda

26063
17:13:00,796 --> 17:13:03,680
function directly and put that in sddc

26064
17:13:03,680 --> 17:13:05,840
out here so let's say that we're going

26065
17:13:05,840 --> 17:13:08,636
to say result to 3 for example or direct

26066
17:13:08,636 --> 17:13:11,200
call i think this is descriptive enough

26067
17:13:11,200 --> 17:13:13,360
so we're going to say func

26068
17:13:13,360 --> 17:13:15,680
one the name of our lambda function or

26069
17:13:15,680 --> 17:13:18,080
the handle to the lambda function and we

26070
17:13:18,080 --> 17:13:20,956
can put in a five and a two for example

26071
17:13:20,956 --> 17:13:22,560
and we're going to see this print out

26072
17:13:22,560 --> 17:13:25,520
the result if we build our program let's

26073
17:13:25,520 --> 17:13:29,040
do that with gcc the bolt is going to be

26074
17:13:29,040 --> 17:13:32,000
good we can clear and run rooster we're

26075
17:13:32,000 --> 17:13:35,436
going to have result 1 is 30 which is 23

26076
17:13:35,436 --> 17:13:38,560
and 7 so the sum is 30. the second one

26077
17:13:38,560 --> 17:13:42,080
should say 54 because that's the sum and

26078
17:13:42,080 --> 17:13:44,240
the third one should say 7 because

26079
17:13:44,240 --> 17:13:47,436
that's the sum of 5 and 2 and it is what

26080
17:13:47,436 --> 17:13:49,276
we have here and after that we're going

26081
17:13:49,276 --> 17:13:51,680
to see that our program is done this is

26082
17:13:51,680 --> 17:13:54,160
how you can set up a lambda function

26083
17:13:54,160 --> 17:13:56,636
that returns something and we have seen

26084
17:13:56,636 --> 17:13:58,796
many ways we can work with us let's

26085
17:13:58,796 --> 17:14:01,040
comment this out because there is one

26086
17:14:01,040 --> 17:14:03,596
more thing i want you to see and that's

26087
17:14:03,596 --> 17:14:06,240
along the function whose return type is

26088
17:14:06,240 --> 17:14:08,956
specified explicitly okay we are going

26089
17:14:08,956 --> 17:14:11,040
to reuse the same lambda function we

26090
17:14:11,040 --> 17:14:12,796
have been using all along and we're

26091
17:14:12,796 --> 17:14:14,320
going to copy that

26092
17:14:14,320 --> 17:14:16,796
and we're going to go down and put it

26093
17:14:16,796 --> 17:14:19,840
down here and now we want to specify the

26094
17:14:19,840 --> 17:14:22,320
return type as a double the way we do

26095
17:14:22,320 --> 17:14:25,040
that we go after our parameter list and

26096
17:14:25,040 --> 17:14:27,680
we put in a dash symbol and we put in a

26097
17:14:27,680 --> 17:14:29,596
greater than symbol and then we're going

26098
17:14:29,596 --> 17:14:32,320
to specify the return type of our lambda

26099
17:14:32,320 --> 17:14:34,880
function let's say that we want our

26100
17:14:34,880 --> 17:14:37,596
return type to be ant this is how we say

26101
17:14:37,596 --> 17:14:39,916
it now our function here is going to

26102
17:14:39,916 --> 17:14:42,956
return end regardless of the types that

26103
17:14:42,956 --> 17:14:45,436
we put in so what the compiler is going

26104
17:14:45,436 --> 17:14:47,200
to do when we call this lambda function

26105
17:14:47,200 --> 17:14:48,956
it is going to take the parameters it is

26106
17:14:48,956 --> 17:14:50,480
going to add them up for example now

26107
17:14:50,480 --> 17:14:52,880
they are double so it's going to add a

26108
17:14:52,880 --> 17:14:54,956
and b as double it's going to produce a

26109
17:14:54,956 --> 17:14:57,040
double variable then it is going to

26110
17:14:57,040 --> 17:15:00,320
convert that to end and return it you

26111
17:15:00,320 --> 17:15:03,276
notice that now we have forced our

26112
17:15:03,276 --> 17:15:06,320
lambda function to really return a

26113
17:15:06,320 --> 17:15:07,520
specific

26114
17:15:07,520 --> 17:15:08,720
type here

26115
17:15:08,720 --> 17:15:11,520
before the return type was deduced from

26116
17:15:11,520 --> 17:15:14,160
the operation that we did here and

26117
17:15:14,160 --> 17:15:16,720
before we were returning double because

26118
17:15:16,720 --> 17:15:18,796
that's what the compiler was deducing

26119
17:15:18,796 --> 17:15:21,116
for a and b here to really drive the

26120
17:15:21,116 --> 17:15:24,000
point home let's assign this lambda

26121
17:15:24,000 --> 17:15:27,756
function to func one or func three let's

26122
17:15:27,756 --> 17:15:30,240
do that we're going to say func three

26123
17:15:30,240 --> 17:15:32,000
and this is a lambda function that is

26124
17:15:32,000 --> 17:15:35,520
going to explicitly return and and we're

26125
17:15:35,520 --> 17:15:36,956
going to set up another one which is

26126
17:15:36,956 --> 17:15:38,956
going to deduce the return type we're

26127
17:15:38,956 --> 17:15:40,720
not going to specify

26128
17:15:40,720 --> 17:15:42,956
the return type explicitly so we're

26129
17:15:42,956 --> 17:15:45,596
going to take out our return type here

26130
17:15:45,596 --> 17:15:46,880
let's do that

26131
17:15:46,880 --> 17:15:49,200
and we're going to go down and say auto

26132
17:15:49,200 --> 17:15:53,116
result 3 and we're going to say funk 3

26133
17:15:53,116 --> 17:15:56,240
and add up two double variables let's

26134
17:15:56,240 --> 17:15:58,480
set up these variables explicitly so

26135
17:15:58,480 --> 17:16:00,480
that you really see what is happening so

26136
17:16:00,480 --> 17:16:03,116
we're going to say it a and put in

26137
17:16:03,116 --> 17:16:05,276
a 6.9

26138
17:16:05,276 --> 17:16:08,080
why not and let's make this guy a double

26139
17:16:08,080 --> 17:16:10,160
because that's what our function here

26140
17:16:10,160 --> 17:16:12,240
expects and we're going to do another

26141
17:16:12,240 --> 17:16:14,956
one do double b and we're going to put

26142
17:16:14,956 --> 17:16:17,840
in a 3.5

26143
17:16:17,840 --> 17:16:20,560
for example and we are going to use this

26144
17:16:20,560 --> 17:16:22,480
variables as arguments here we're going

26145
17:16:22,480 --> 17:16:24,560
to say a and b and we're going to say

26146
17:16:24,560 --> 17:16:26,480
auto result

26147
17:16:26,480 --> 17:16:27,276
for

26148
17:16:27,276 --> 17:16:30,636
this should be funk 4 sorry for this

26149
17:16:30,636 --> 17:16:32,880
and i'm going to say result 4 and this

26150
17:16:32,880 --> 17:16:36,080
should say result i am making many typos

26151
17:16:36,080 --> 17:16:38,240
so we're going to assign our lambda

26152
17:16:38,240 --> 17:16:41,040
function the result of our lambda

26153
17:16:41,040 --> 17:16:44,480
function i should say to result for here

26154
17:16:44,480 --> 17:16:46,160
and we're going to pass in

26155
17:16:46,160 --> 17:16:47,596
a and b

26156
17:16:47,596 --> 17:16:50,956
now we want to see the types of result 3

26157
17:16:50,956 --> 17:16:53,840
and result 4 here we're going to go down

26158
17:16:53,840 --> 17:16:55,520
and print them out we're going to say

26159
17:16:55,520 --> 17:16:59,200
sddc out size of this is one way we have

26160
17:16:59,200 --> 17:17:00,400
to get

26161
17:17:00,400 --> 17:17:03,040
the types of our variables

26162
17:17:03,040 --> 17:17:05,040
we're going to pass in result three

26163
17:17:05,040 --> 17:17:07,596
we're going to say size of result three

26164
17:17:07,596 --> 17:17:09,916
and we're going to go down and say size

26165
17:17:09,916 --> 17:17:13,200
of result for okay we have our code in

26166
17:17:13,200 --> 17:17:15,436
place and what we want to see

26167
17:17:15,436 --> 17:17:18,796
is the type that is deduced by the func

26168
17:17:18,796 --> 17:17:22,720
3 lambda function here we are explicitly

26169
17:17:22,720 --> 17:17:25,040
turning the return type into end the

26170
17:17:25,040 --> 17:17:26,956
parameters we pass in are going to be

26171
17:17:26,956 --> 17:17:29,116
double that's what we have here we are

26172
17:17:29,116 --> 17:17:31,436
going to add up a and b and the result

26173
17:17:31,436 --> 17:17:33,596
of this is also going to be double but

26174
17:17:33,596 --> 17:17:35,596
the compiler is going to notice that we

26175
17:17:35,596 --> 17:17:39,116
are returning and explicitly here and it

26176
17:17:39,116 --> 17:17:41,756
is going to take this double result and

26177
17:17:41,756 --> 17:17:44,636
transform that to end and we're going to

26178
17:17:44,636 --> 17:17:45,436
get

26179
17:17:45,436 --> 17:17:47,040
and we're going to get the result of

26180
17:17:47,040 --> 17:17:49,756
that assigned to func 3 here for the

26181
17:17:49,756 --> 17:17:52,160
second lambda function here we are going

26182
17:17:52,160 --> 17:17:54,636
to automatically deduce the return type

26183
17:17:54,636 --> 17:17:57,276
so what we return here is going to be

26184
17:17:57,276 --> 17:17:59,680
a double type and we should see a size

26185
17:17:59,680 --> 17:18:02,480
of it for research 3 here printed out so

26186
17:18:02,480 --> 17:18:06,000
we should see a 4 on my system and for

26187
17:18:06,000 --> 17:18:08,400
the second statement here we should see

26188
17:18:08,400 --> 17:18:10,796
a size of double printed out this is one

26189
17:18:10,796 --> 17:18:13,436
way we have to try and prove this so

26190
17:18:13,436 --> 17:18:15,520
let's build this program and see what we

26191
17:18:15,520 --> 17:18:17,756
get okay the world is good we can clear

26192
17:18:17,756 --> 17:18:20,080
and run rooster and we're going to see

26193
17:18:20,080 --> 17:18:23,200
that this is exactly what we expect here

26194
17:18:23,200 --> 17:18:25,840
if we want we can even print result 3

26195
17:18:25,840 --> 17:18:28,480
and result 4 and see what we get so

26196
17:18:28,480 --> 17:18:31,360
let's do that we are learning so let's

26197
17:18:31,360 --> 17:18:32,956
experiment with this a little bit we're

26198
17:18:32,956 --> 17:18:36,000
going to say result 3 and we should go

26199
17:18:36,000 --> 17:18:39,520
back and say result three if i can type

26200
17:18:39,520 --> 17:18:42,000
e and dl here and we're going to go down

26201
17:18:42,000 --> 17:18:45,680
and say sddc out result for okay if we

26202
17:18:45,680 --> 17:18:47,200
build and run this

26203
17:18:47,200 --> 17:18:49,520
we're going to see the results printed

26204
17:18:49,520 --> 17:18:52,080
down the both is good we can clear and

26205
17:18:52,080 --> 17:18:53,520
run rooster

26206
17:18:53,520 --> 17:18:57,040
now we have result is 10 for the

26207
17:18:57,040 --> 17:18:59,596
first thing here for the

26208
17:18:59,596 --> 17:19:02,240
first lambda function and for the second

26209
17:19:02,240 --> 17:19:05,916
one result is 10.4 you can see that for

26210
17:19:05,916 --> 17:19:08,956
the first one the result was transformed

26211
17:19:08,956 --> 17:19:11,276
from double to and and for the second

26212
17:19:11,276 --> 17:19:13,436
one we deduced double so we still have

26213
17:19:13,436 --> 17:19:16,160
our decimal point here hopefully this

26214
17:19:16,160 --> 17:19:18,160
makes sense and this is really all we

26215
17:19:18,160 --> 17:19:20,880
set out to do in this lecture showing

26216
17:19:20,880 --> 17:19:22,720
you different ways you can set up your

26217
17:19:22,720 --> 17:19:25,040
lambda functions we saw the syntax of

26218
17:19:25,040 --> 17:19:27,276
setting up a lambda function we saw that

26219
17:19:27,276 --> 17:19:29,276
you can declare a lambda function and

26220
17:19:29,276 --> 17:19:32,000
call it through a name like func here we

26221
17:19:32,000 --> 17:19:34,160
went down and so that you can declare a

26222
17:19:34,160 --> 17:19:36,160
lambda function and call it directly

26223
17:19:36,160 --> 17:19:38,160
through the syntax you see here we saw

26224
17:19:38,160 --> 17:19:40,480
that how we could specify parameters to

26225
17:19:40,480 --> 17:19:42,956
our lambda function this is the syntax

26226
17:19:42,956 --> 17:19:44,400
and once you do this you have to

26227
17:19:44,400 --> 17:19:46,240
remember to call your lambda functions

26228
17:19:46,240 --> 17:19:48,956
with parameters like we see here we can

26229
17:19:48,956 --> 17:19:52,160
even use a handle given to our lambda

26230
17:19:52,160 --> 17:19:54,720
function and call our lambda function

26231
17:19:54,720 --> 17:19:57,200
multiple times after that we saw that we

26232
17:19:57,200 --> 17:19:59,040
could return something from a lambda

26233
17:19:59,040 --> 17:20:01,276
function and we had many chances to play

26234
17:20:01,276 --> 17:20:02,240
with us

26235
17:20:02,240 --> 17:20:03,436
and we

26236
17:20:03,436 --> 17:20:06,080
finished by looking how we could specify

26237
17:20:06,080 --> 17:20:09,116
the return type explicitly and the

26238
17:20:09,116 --> 17:20:12,160
syntax to do that is what you see here

26239
17:20:12,160 --> 17:20:13,756
we are going to stop here in this

26240
17:20:13,756 --> 17:20:15,596
lecture the next one we're going to see

26241
17:20:15,596 --> 17:20:18,720
how we can use our capture lists here

26242
17:20:18,720 --> 17:20:21,756
and make them do useful things

26243
17:20:21,756 --> 17:20:23,596
go ahead and finish up here

26244
17:20:23,596 --> 17:20:25,436
and meet me there

26245
17:20:25,436 --> 17:20:26,956
in this lecture we're going to see how

26246
17:20:26,956 --> 17:20:30,080
we can use capture lists in our lambda

26247
17:20:30,080 --> 17:20:32,880
functions and do some useful things we

26248
17:20:32,880 --> 17:20:35,680
have seen that the syntax of our lambda

26249
17:20:35,680 --> 17:20:38,240
functions includes these angle brackets

26250
17:20:38,240 --> 17:20:40,720
here but we haven't really used them to

26251
17:20:40,720 --> 17:20:43,276
do anything for what we have done in the

26252
17:20:43,276 --> 17:20:45,840
last lecture they were empty all the

26253
17:20:45,840 --> 17:20:48,160
time in this lecture we're going to use

26254
17:20:48,160 --> 17:20:50,400
them here is a simple example of how we

26255
17:20:50,400 --> 17:20:52,636
can use our capsule list

26256
17:20:52,636 --> 17:20:55,116
we have two variables a and b they are

26257
17:20:55,116 --> 17:20:57,116
of double type and they contain these

26258
17:20:57,116 --> 17:21:00,240
values 10 and 20. but sometimes we want

26259
17:21:00,240 --> 17:21:02,796
to use thanks outside the scope of the

26260
17:21:02,796 --> 17:21:04,320
lambda function

26261
17:21:04,320 --> 17:21:06,636
inside the lambda function here and if

26262
17:21:06,636 --> 17:21:08,636
you set up your lambda function with an

26263
17:21:08,636 --> 17:21:10,636
empty capture list suppose you don't

26264
17:21:10,636 --> 17:21:12,636
have these two guys in

26265
17:21:12,636 --> 17:21:14,796
and you try to use a and b like this

26266
17:21:14,796 --> 17:21:16,636
you're going to get a compiler error

26267
17:21:16,636 --> 17:21:17,840
because

26268
17:21:17,840 --> 17:21:20,956
the body of the lambda function doesn't

26269
17:21:20,956 --> 17:21:24,796
have access to the outer context here it

26270
17:21:24,796 --> 17:21:27,276
can only use things inside the lambda

26271
17:21:27,276 --> 17:21:29,840
functions or events that you pass to the

26272
17:21:29,840 --> 17:21:32,160
lambda function here but it can't

26273
17:21:32,160 --> 17:21:34,956
directly access things outside the

26274
17:21:34,956 --> 17:21:37,596
lambda functions and we can have access

26275
17:21:37,596 --> 17:21:40,160
to thanks that are declared and defined

26276
17:21:40,160 --> 17:21:42,636
outside the lambda function through our

26277
17:21:42,636 --> 17:21:44,880
capture list if you look here we are

26278
17:21:44,880 --> 17:21:47,756
saying a and b and this is the syntax we

26279
17:21:47,756 --> 17:21:49,520
have to capture

26280
17:21:49,520 --> 17:21:52,796
these two variables a and b and have

26281
17:21:52,796 --> 17:21:55,436
access to them inside our lambda

26282
17:21:55,436 --> 17:21:57,596
function here and this is what capture

26283
17:21:57,596 --> 17:22:00,160
lists are really for giving you access

26284
17:22:00,160 --> 17:22:03,436
to things that are declared outside the

26285
17:22:03,436 --> 17:22:05,436
scope of the lambda function because if

26286
17:22:05,436 --> 17:22:08,000
you really think about it this lambda

26287
17:22:08,000 --> 17:22:11,040
function thing we have here is really a

26288
17:22:11,040 --> 17:22:12,240
type

26289
17:22:12,240 --> 17:22:14,400
so it is its own thing

26290
17:22:14,400 --> 17:22:16,956
that has these behaviors well then so

26291
17:22:16,956 --> 17:22:19,360
that we can call it and do things but it

26292
17:22:19,360 --> 17:22:21,840
doesn't really have direct access to the

26293
17:22:21,840 --> 17:22:23,116
outside

26294
17:22:23,116 --> 17:22:25,276
where it was declared and you have to

26295
17:22:25,276 --> 17:22:27,436
give it access through the capture

26296
17:22:27,436 --> 17:22:29,520
mechanism here okay now that you know

26297
17:22:29,520 --> 17:22:31,116
this we're going to see different ways

26298
17:22:31,116 --> 17:22:33,596
we can use the capture mechanism one

26299
17:22:33,596 --> 17:22:36,160
thing we can do is capture by value and

26300
17:22:36,160 --> 17:22:38,080
if we capture by value what we're going

26301
17:22:38,080 --> 17:22:40,720
to have inside the lambda function is

26302
17:22:40,720 --> 17:22:42,636
going to be a copy suppose we have a

26303
17:22:42,636 --> 17:22:44,956
variable here which is c the value is

26304
17:22:44,956 --> 17:22:47,520
going to be 42 as you see here we're

26305
17:22:47,520 --> 17:22:49,276
going to set up a lambda function and

26306
17:22:49,276 --> 17:22:51,756
capture our c variable

26307
17:22:51,756 --> 17:22:54,480
by value in this lambda function here

26308
17:22:54,480 --> 17:22:56,480
and what we're going to do outside the

26309
17:22:56,480 --> 17:22:58,160
lambda function notice the lambda

26310
17:22:58,160 --> 17:23:00,400
function has a handle so we can call it

26311
17:23:00,400 --> 17:23:02,400
we're going to loop five times

26312
17:23:02,400 --> 17:23:04,480
and at each iteration we're going to

26313
17:23:04,480 --> 17:23:07,116
call our lambda function and print the

26314
17:23:07,116 --> 17:23:08,480
inner value here

26315
17:23:08,480 --> 17:23:10,400
but after that we're going to increment

26316
17:23:10,400 --> 17:23:12,636
our c variable and this is going to

26317
17:23:12,636 --> 17:23:14,240
increment the

26318
17:23:14,240 --> 17:23:16,796
outer variable here and what we want to

26319
17:23:16,796 --> 17:23:19,040
see is that the changes we are doing on

26320
17:23:19,040 --> 17:23:21,756
the outside here are picked up by the

26321
17:23:21,756 --> 17:23:23,840
inner value that we have in our lambda

26322
17:23:23,840 --> 17:23:26,400
function here and ahead to break it to

26323
17:23:26,400 --> 17:23:28,636
you this is going to not be the case

26324
17:23:28,636 --> 17:23:30,720
because what we have inside the lambda

26325
17:23:30,720 --> 17:23:33,436
function is a copy of the outside

26326
17:23:33,436 --> 17:23:35,200
variable here so what we're going to

26327
17:23:35,200 --> 17:23:38,000
have is for the outer value to go from

26328
17:23:38,000 --> 17:23:40,400
42 all the way to 47 we're going to go

26329
17:23:40,400 --> 17:23:42,956
five times incrementing this little guy

26330
17:23:42,956 --> 17:23:45,360
but the thing on the inside is not going

26331
17:23:45,360 --> 17:23:47,596
to change because it is a copy the

26332
17:23:47,596 --> 17:23:50,160
incrementation here is affecting the

26333
17:23:50,160 --> 17:23:52,796
outside variable here but it is not

26334
17:23:52,796 --> 17:23:55,116
affecting the copy we have inside our

26335
17:23:55,116 --> 17:23:57,680
lambda function so for all these loops

26336
17:23:57,680 --> 17:24:00,240
here we're going to see 42 print it down

26337
17:24:00,240 --> 17:24:02,000
and we're going to see this in a minute

26338
17:24:02,000 --> 17:24:04,160
when we hit visual studio code let's say

26339
17:24:04,160 --> 17:24:06,080
42 correctly

26340
17:24:06,080 --> 17:24:08,480
excuse my typing here okay so now you

26341
17:24:08,480 --> 17:24:10,636
know that we can capture by a value and

26342
17:24:10,636 --> 17:24:12,796
you know what this really means another

26343
17:24:12,796 --> 17:24:15,596
thing we can do is capture by reference

26344
17:24:15,596 --> 17:24:18,160
and the syntax to do that is to add an

26345
17:24:18,160 --> 17:24:20,956
ampersand symbol in front of the

26346
17:24:20,956 --> 17:24:22,956
variable that we capture here and if we

26347
17:24:22,956 --> 17:24:25,520
do this and run the semicolon we run in

26348
17:24:25,520 --> 17:24:27,916
the last lecture we're going to see now

26349
17:24:27,916 --> 17:24:30,636
that the changes we do on the outside

26350
17:24:30,636 --> 17:24:32,720
are going to be picked up by the inner

26351
17:24:32,720 --> 17:24:35,596
side of our lambda function because we

26352
17:24:35,596 --> 17:24:38,320
are capturing by reference what we have

26353
17:24:38,320 --> 17:24:41,116
inside our lambda function here is a

26354
17:24:41,116 --> 17:24:43,756
true reference to the outside the

26355
17:24:43,756 --> 17:24:45,360
variable here and we're going to see

26356
17:24:45,360 --> 17:24:48,320
that now the outside and the inside are

26357
17:24:48,320 --> 17:24:50,400
going to be incrementing together and

26358
17:24:50,400 --> 17:24:53,520
we're going to have 43 42 44 and things

26359
17:24:53,520 --> 17:24:55,840
like that printed out on the console

26360
17:24:55,840 --> 17:24:57,756
okay this is really all i have to share

26361
17:24:57,756 --> 17:24:59,916
with you in this lecture showing you how

26362
17:24:59,916 --> 17:25:02,480
you can use your capture lists and that

26363
17:25:02,480 --> 17:25:04,796
you can capture either by value or by

26364
17:25:04,796 --> 17:25:06,880
reference we're going to head over to

26365
17:25:06,880 --> 17:25:08,636
visual studio code and play with this a

26366
17:25:08,636 --> 17:25:11,200
little more okay here we are in our

26367
17:25:11,200 --> 17:25:13,436
working folder the current project is

26368
17:25:13,436 --> 17:25:16,160
capture lists we're going to grab our

26369
17:25:16,160 --> 17:25:18,080
template files pretty quick and we're

26370
17:25:18,080 --> 17:25:19,756
going to put them in place we're going

26371
17:25:19,756 --> 17:25:20,636
to

26372
17:25:20,636 --> 17:25:23,116
put them in the current project and

26373
17:25:23,116 --> 17:25:25,200
we're going to open this guy in visual

26374
17:25:25,200 --> 17:25:27,596
studio code by dragging and dropping in

26375
17:25:27,596 --> 17:25:29,840
place here and we're going to open our

26376
17:25:29,840 --> 17:25:33,360
main cpp file clean it up a little bit

26377
17:25:33,360 --> 17:25:35,520
and close the left pane here what we

26378
17:25:35,520 --> 17:25:38,160
want to do in here is uh learn a little

26379
17:25:38,160 --> 17:25:40,240
more about capture lists and we're going

26380
17:25:40,240 --> 17:25:42,880
to put in a piece of code to play with

26381
17:25:42,880 --> 17:25:46,400
just that we have two variables a and 10

26382
17:25:46,400 --> 17:25:49,436
here and we have our lambda function

26383
17:25:49,436 --> 17:25:51,436
setup and let's take out our capture

26384
17:25:51,436 --> 17:25:53,436
list so that you can see the compiler

26385
17:25:53,436 --> 17:25:54,720
error we see

26386
17:25:54,720 --> 17:25:57,680
if we try to use them as is here so we

26387
17:25:57,680 --> 17:25:59,596
have our two variables and we have a

26388
17:25:59,596 --> 17:26:02,636
lambda function set up here and inside

26389
17:26:02,636 --> 17:26:05,200
the lambda function notice that we are

26390
17:26:05,200 --> 17:26:08,080
trying to access the variables that have

26391
17:26:08,080 --> 17:26:10,240
been declared on the outside of the

26392
17:26:10,240 --> 17:26:12,636
lambda function here and by default if

26393
17:26:12,636 --> 17:26:14,240
we try to do this we're going to get a

26394
17:26:14,240 --> 17:26:16,240
compiler error because these two

26395
17:26:16,240 --> 17:26:19,200
variables don't exist in the scope of

26396
17:26:19,200 --> 17:26:21,200
the lambda function here let's bring up

26397
17:26:21,200 --> 17:26:23,840
a terminal and see what visual studio

26398
17:26:23,840 --> 17:26:25,756
code is saying about this

26399
17:26:25,756 --> 17:26:27,680
and it is going to say an enclosing

26400
17:26:27,680 --> 17:26:30,160
function local variable cannot be

26401
17:26:30,160 --> 17:26:31,916
referenced in

26402
17:26:31,916 --> 17:26:35,040
lambda body unless it is in the capture

26403
17:26:35,040 --> 17:26:36,796
list and you see that this is really

26404
17:26:36,796 --> 17:26:39,360
descriptive okay we have sent this error

26405
17:26:39,360 --> 17:26:41,200
but we want to see what the compiler

26406
17:26:41,200 --> 17:26:43,520
says about this we're going to pass this

26407
17:26:43,520 --> 17:26:46,720
through gcc and we should get a similar

26408
17:26:46,720 --> 17:26:49,360
error it is going to say a is not

26409
17:26:49,360 --> 17:26:52,000
captured and it is going to go down here

26410
17:26:52,000 --> 17:26:55,116
and say b is not captured here and this

26411
17:26:55,116 --> 17:26:57,360
is the error we are trying to use

26412
17:26:57,360 --> 17:27:00,560
outside variables in our lambda function

26413
17:27:00,560 --> 17:27:02,720
but to really do that we need to capture

26414
17:27:02,720 --> 17:27:03,840
a and b

26415
17:27:03,840 --> 17:27:06,160
and the syntax to capture our variables

26416
17:27:06,160 --> 17:27:09,360
is to put them inside our angle brackets

26417
17:27:09,360 --> 17:27:12,480
here with a comma separate to the list

26418
17:27:12,480 --> 17:27:14,636
of the variables that we want to capture

26419
17:27:14,636 --> 17:27:16,956
so we're going to say a comma b because

26420
17:27:16,956 --> 17:27:19,200
that's what we want to capture here and

26421
17:27:19,200 --> 17:27:20,956
the moment we do that

26422
17:27:20,956 --> 17:27:22,880
visual studio code should be happy it is

26423
17:27:22,880 --> 17:27:24,720
not happy i think we need to compile

26424
17:27:24,720 --> 17:27:27,916
this for it to be happy so let's do that

26425
17:27:27,916 --> 17:27:29,276
and you see now

26426
17:27:29,276 --> 17:27:32,240
our variables are being captured and we

26427
17:27:32,240 --> 17:27:35,116
are summing them up and we are printing

26428
17:27:35,116 --> 17:27:38,400
the result of adding them up here by

26429
17:27:38,400 --> 17:27:41,200
calling the function through a handle we

26430
17:27:41,200 --> 17:27:43,200
have set up here hopefully this is

26431
17:27:43,200 --> 17:27:45,436
really making sense let's build the

26432
17:27:45,436 --> 17:27:46,880
program again

26433
17:27:46,880 --> 17:27:49,276
so let's use the gcc

26434
17:27:49,276 --> 17:27:50,720
you're going to see that the world is

26435
17:27:50,720 --> 17:27:53,520
good we can clear and run rooster we

26436
17:27:53,520 --> 17:27:57,916
should see a plus b is 30 but the values

26437
17:27:57,916 --> 17:28:01,040
are getting inside the lambda function

26438
17:28:01,040 --> 17:28:03,200
through our capture list they are not

26439
17:28:03,200 --> 17:28:06,080
going through the parameter list here

26440
17:28:06,080 --> 17:28:08,080
this is really something you need to be

26441
17:28:08,080 --> 17:28:09,276
aware of

26442
17:28:09,276 --> 17:28:12,636
now that you know how capture lists work

26443
17:28:12,636 --> 17:28:15,200
let's see that you can capture either by

26444
17:28:15,200 --> 17:28:17,436
value or by reference and we're going to

26445
17:28:17,436 --> 17:28:20,000
see what that means exactly i am going

26446
17:28:20,000 --> 17:28:22,160
to go down here and put in a piece of

26447
17:28:22,160 --> 17:28:24,880
code to play with capturing by value

26448
17:28:24,880 --> 17:28:27,276
okay let's do that we have a variable

26449
17:28:27,276 --> 17:28:30,080
called c the value is 42

26450
17:28:30,080 --> 17:28:32,320
and we set up a lambda function which is

26451
17:28:32,320 --> 17:28:34,080
going to capture c

26452
17:28:34,080 --> 17:28:36,480
with this syntax here and this is the

26453
17:28:36,480 --> 17:28:38,480
default syntax we saw

26454
17:28:38,480 --> 17:28:40,880
like we did on top here so we are going

26455
17:28:40,880 --> 17:28:43,200
to be capturing like this and if we do

26456
17:28:43,200 --> 17:28:44,720
this we're going to be capturing by

26457
17:28:44,720 --> 17:28:46,720
value the meaning of that is that what

26458
17:28:46,720 --> 17:28:49,276
we have inside our lambda function is

26459
17:28:49,276 --> 17:28:51,596
not going to be the original value here

26460
17:28:51,596 --> 17:28:54,080
it is going to be a copy of what we have

26461
17:28:54,080 --> 17:28:55,116
there

26462
17:28:55,116 --> 17:28:57,840
what we can do here is use this thing in

26463
17:28:57,840 --> 17:29:00,320
a loop and really prove this

26464
17:29:00,320 --> 17:29:02,796
so we're going to loop five times from

26465
17:29:02,796 --> 17:29:05,200
zero all the way to four because this is

26466
17:29:05,200 --> 17:29:08,000
going to go until i is no longer less

26467
17:29:08,000 --> 17:29:09,276
than 5

26468
17:29:09,276 --> 17:29:11,040
and inside we're going to print the

26469
17:29:11,040 --> 17:29:13,116
outer value which is going to be

26470
17:29:13,116 --> 17:29:15,040
the c here after that we're going to

26471
17:29:15,040 --> 17:29:17,116
call our lambda function which is going

26472
17:29:17,116 --> 17:29:18,956
to predict the inner value in the lambda

26473
17:29:18,956 --> 17:29:21,200
function and we're going to see that the

26474
17:29:21,200 --> 17:29:23,916
incrementation we do on the outside

26475
17:29:23,916 --> 17:29:26,000
which is going to affect the outer value

26476
17:29:26,000 --> 17:29:28,480
here is going to be visible inside the

26477
17:29:28,480 --> 17:29:30,720
lambda function here and that's not

26478
17:29:30,720 --> 17:29:32,480
going to be the case the change we do

26479
17:29:32,480 --> 17:29:34,956
here is not going to be picked up by the

26480
17:29:34,956 --> 17:29:36,956
lambda function here because what we

26481
17:29:36,956 --> 17:29:39,276
have inside is a copy so what we're

26482
17:29:39,276 --> 17:29:41,596
going to see is for the outer value to

26483
17:29:41,596 --> 17:29:46,000
go from 42 43 43 45 and it is going to

26484
17:29:46,000 --> 17:29:48,320
go until we hit the end of this loop

26485
17:29:48,320 --> 17:29:51,116
here but the inside value is not going

26486
17:29:51,116 --> 17:29:53,520
to change because the change we do in

26487
17:29:53,520 --> 17:29:56,400
here is not going to affect the copy

26488
17:29:56,400 --> 17:29:59,276
that we have in our lambda function here

26489
17:29:59,276 --> 17:30:01,436
hopefully this makes sense and again if

26490
17:30:01,436 --> 17:30:03,520
you have a problem please make sure you

26491
17:30:03,520 --> 17:30:04,400
ask

26492
17:30:04,400 --> 17:30:05,756
through the

26493
17:30:05,756 --> 17:30:07,916
course platform and i will do the best i

26494
17:30:07,916 --> 17:30:10,080
can to help you out for now we're going

26495
17:30:10,080 --> 17:30:12,400
to build and run this program you see

26496
17:30:12,400 --> 17:30:15,520
the world is good so let's clear and run

26497
17:30:15,520 --> 17:30:17,756
rooster you're going to see outer value

26498
17:30:17,756 --> 17:30:21,596
is 43 outer value is 43 outer value is

26499
17:30:21,596 --> 17:30:25,520
44 outer value is 45 the outer value is

26500
17:30:25,520 --> 17:30:28,880
changing but the inner value is staying

26501
17:30:28,880 --> 17:30:30,560
at 42

26502
17:30:30,560 --> 17:30:32,000
as you see here

26503
17:30:32,000 --> 17:30:34,240
hopefully this proves that the outer

26504
17:30:34,240 --> 17:30:36,880
value and the inner value are two

26505
17:30:36,880 --> 17:30:39,200
different things but we can even go

26506
17:30:39,200 --> 17:30:41,680
further and print the addresses of the

26507
17:30:41,680 --> 17:30:43,680
outer value and the inner value let's do

26508
17:30:43,680 --> 17:30:44,400
that

26509
17:30:44,400 --> 17:30:47,040
we're going to add that to our statement

26510
17:30:47,040 --> 17:30:50,636
here and say the address of this guy

26511
17:30:50,636 --> 17:30:53,040
so we're going to say address of outer

26512
17:30:53,040 --> 17:30:55,916
value or say address of inner value we

26513
17:30:55,916 --> 17:30:57,680
can say it like that

26514
17:30:57,680 --> 17:31:00,560
to really be descriptive in our terminal

26515
17:31:00,560 --> 17:31:02,480
here so we're going to say the address

26516
17:31:02,480 --> 17:31:03,520
of c

26517
17:31:03,520 --> 17:31:05,596
and on the outer value we're going to

26518
17:31:05,596 --> 17:31:08,160
add another piece of information and say

26519
17:31:08,160 --> 17:31:10,956
address of outer value and we're going

26520
17:31:10,956 --> 17:31:13,360
to say the address of c

26521
17:31:13,360 --> 17:31:15,276
and this is going to pick up the outer

26522
17:31:15,276 --> 17:31:17,680
value that we have here and this is

26523
17:31:17,680 --> 17:31:20,636
going to use the inner value we have in

26524
17:31:20,636 --> 17:31:22,720
our lambda function here

26525
17:31:22,720 --> 17:31:24,956
let's try and work and hopefully these

26526
17:31:24,956 --> 17:31:27,520
two addresses the inner and outer

26527
17:31:27,520 --> 17:31:29,756
addresses are going to be different

26528
17:31:29,756 --> 17:31:31,756
that's what we want to see here and

26529
17:31:31,756 --> 17:31:34,720
really proving that what we have inside

26530
17:31:34,720 --> 17:31:37,200
the lambda function is a copy through

26531
17:31:37,200 --> 17:31:40,080
the capture mechanism so let's run the

26532
17:31:40,080 --> 17:31:42,560
program the world was good so the outer

26533
17:31:42,560 --> 17:31:45,360
value the address is the e4 the inner

26534
17:31:45,360 --> 17:31:48,636
value the address is de0 we are proving

26535
17:31:48,636 --> 17:31:50,720
that what we have inside our lambda

26536
17:31:50,720 --> 17:31:54,000
function is really a copy so this is how

26537
17:31:54,000 --> 17:31:56,796
you can capture by value and that's

26538
17:31:56,796 --> 17:31:58,956
going to make a copy but sometimes you

26539
17:31:58,956 --> 17:32:00,956
really want to capture by reference and

26540
17:32:00,956 --> 17:32:02,720
we're going to see how you can do that

26541
17:32:02,720 --> 17:32:05,116
so we're going to comment out the code

26542
17:32:05,116 --> 17:32:07,040
to capture by value here we're going to

26543
17:32:07,040 --> 17:32:09,756
grab the code and reuse it because

26544
17:32:09,756 --> 17:32:11,916
that's going to be very similar to what

26545
17:32:11,916 --> 17:32:14,080
we had before we're going to say capture

26546
17:32:14,080 --> 17:32:16,320
by reference we're going to put in our

26547
17:32:16,320 --> 17:32:18,636
code and we're going to change it a tiny

26548
17:32:18,636 --> 17:32:21,200
bit what we're going to do is add an

26549
17:32:21,200 --> 17:32:22,956
ampersand symbol

26550
17:32:22,956 --> 17:32:25,756
in front of our variable here that we

26551
17:32:25,756 --> 17:32:27,916
are capturing and we're going to say

26552
17:32:27,916 --> 17:32:29,116
ampersand

26553
17:32:29,116 --> 17:32:31,596
the moment we do this what we have

26554
17:32:31,596 --> 17:32:34,240
inside the lambda function is no longer

26555
17:32:34,240 --> 17:32:37,040
a copy it's going to be a true reference

26556
17:32:37,040 --> 17:32:40,240
to the outer value here and now the

26557
17:32:40,240 --> 17:32:43,360
changes we do to our outer value are

26558
17:32:43,360 --> 17:32:45,360
going to be visible inside the lambda

26559
17:32:45,360 --> 17:32:47,116
function here and you're going to see

26560
17:32:47,116 --> 17:32:49,596
the addresses to be the same

26561
17:32:49,596 --> 17:32:51,840
let's build and really see this we're

26562
17:32:51,840 --> 17:32:54,720
going to use gcc to build our program

26563
17:32:54,720 --> 17:32:57,200
the world is good we can clear now and

26564
17:32:57,200 --> 17:32:59,596
run rooster and we're going to see that

26565
17:32:59,596 --> 17:33:02,720
the outer value let's make sure we have

26566
17:33:02,720 --> 17:33:05,436
some spaces after these guys and let's

26567
17:33:05,436 --> 17:33:08,080
go up and do that and both again because

26568
17:33:08,080 --> 17:33:10,080
things are really cramped together and i

26569
17:33:10,080 --> 17:33:11,436
don't like this

26570
17:33:11,436 --> 17:33:13,520
so the boost is good we can clear and

26571
17:33:13,520 --> 17:33:14,880
run rooster

26572
17:33:14,880 --> 17:33:16,720
so we're going to see the outer value

26573
17:33:16,720 --> 17:33:18,560
and the inner value are changing

26574
17:33:18,560 --> 17:33:21,436
together and the addresses are now the

26575
17:33:21,436 --> 17:33:22,400
same

26576
17:33:22,400 --> 17:33:25,276
because we have captured by reference

26577
17:33:25,276 --> 17:33:27,840
the inner value and the outer value are

26578
17:33:27,840 --> 17:33:30,320
referencing the same variable we have

26579
17:33:30,320 --> 17:33:32,796
outside here this is really all we set

26580
17:33:32,796 --> 17:33:34,560
out to do in this lecture i hope you

26581
17:33:34,560 --> 17:33:37,116
found it interesting the main idea was

26582
17:33:37,116 --> 17:33:39,596
the capture mechanism we have with our

26583
17:33:39,596 --> 17:33:42,080
lambda functions to capture thanks

26584
17:33:42,080 --> 17:33:45,200
outside the context of lambda functions

26585
17:33:45,200 --> 17:33:47,756
we can capture by specifying a comma

26586
17:33:47,756 --> 17:33:50,000
separate to the list of the variables

26587
17:33:50,000 --> 17:33:52,240
that we want to capture and we have the

26588
17:33:52,240 --> 17:33:54,880
option to either capture by value by

26589
17:33:54,880 --> 17:33:55,916
using

26590
17:33:55,916 --> 17:33:57,916
the variable directly in the capture

26591
17:33:57,916 --> 17:34:01,200
list like we do here or by prepending an

26592
17:34:01,200 --> 17:34:03,756
ampersand symbol here and capture by

26593
17:34:03,756 --> 17:34:05,916
reference and you are going to have to

26594
17:34:05,916 --> 17:34:07,916
choose whichever way you want to capture

26595
17:34:07,916 --> 17:34:10,480
your variables now that you know about

26596
17:34:10,480 --> 17:34:12,320
all these options here

26597
17:34:12,320 --> 17:34:13,916
we are going to stop here in this

26598
17:34:13,916 --> 17:34:15,680
lecture in the next one we're going to

26599
17:34:15,680 --> 17:34:18,320
see how we can capture everything from

26600
17:34:18,320 --> 17:34:20,480
the outside context to the lambda

26601
17:34:20,480 --> 17:34:21,596
function

26602
17:34:21,596 --> 17:34:23,520
go ahead and finish up here

26603
17:34:23,520 --> 17:34:25,756
and meet me there in the last lecture we

26604
17:34:25,756 --> 17:34:28,320
saw that we could capture things outside

26605
17:34:28,320 --> 17:34:31,040
the context of the lambda function now

26606
17:34:31,040 --> 17:34:32,720
we want to see that we can capture

26607
17:34:32,720 --> 17:34:36,320
everything living outside the context of

26608
17:34:36,320 --> 17:34:38,480
the lambda function the syntax to do

26609
17:34:38,480 --> 17:34:41,276
that is ridiculously simple if you want

26610
17:34:41,276 --> 17:34:44,560
to capture everything by value you just

26611
17:34:44,560 --> 17:34:46,720
put an equal sign in your lambda

26612
17:34:46,720 --> 17:34:48,880
function capture list and if you do

26613
17:34:48,880 --> 17:34:50,880
something like this now you're going to

26614
17:34:50,880 --> 17:34:53,360
have access to everything outside the

26615
17:34:53,360 --> 17:34:55,436
scope of the lambda function for example

26616
17:34:55,436 --> 17:34:57,680
we can access the c variable here from

26617
17:34:57,680 --> 17:35:00,400
the lambda function but if we have any

26618
17:35:00,400 --> 17:35:02,956
more variables declared outside the

26619
17:35:02,956 --> 17:35:05,040
scope of the lambda function we will

26620
17:35:05,040 --> 17:35:08,320
have access to them inside our lambda

26621
17:35:08,320 --> 17:35:11,596
function here again this is enabled by

26622
17:35:11,596 --> 17:35:14,320
the syntax that we use here by putting

26623
17:35:14,320 --> 17:35:17,040
an equal sign inside a lambda function

26624
17:35:17,040 --> 17:35:19,360
notice that if you use the equal sign

26625
17:35:19,360 --> 17:35:21,276
like we do here we're going to be

26626
17:35:21,276 --> 17:35:23,916
capturing by value what we have inside

26627
17:35:23,916 --> 17:35:25,596
the lambda function is going to be a

26628
17:35:25,596 --> 17:35:28,400
copy if you don't want to capture all by

26629
17:35:28,400 --> 17:35:31,840
value you can capture all by reference

26630
17:35:31,840 --> 17:35:34,400
and again the syntax is really simple

26631
17:35:34,400 --> 17:35:37,040
all you have to do is put an ampersand

26632
17:35:37,040 --> 17:35:39,840
symbol inside your capture list the

26633
17:35:39,840 --> 17:35:41,436
moment you do this you're going to have

26634
17:35:41,436 --> 17:35:44,636
access to everything outside the context

26635
17:35:44,636 --> 17:35:47,040
of your lambda function but that's going

26636
17:35:47,040 --> 17:35:49,680
to be by reference what you have inside

26637
17:35:49,680 --> 17:35:51,756
the lambda function are going to be true

26638
17:35:51,756 --> 17:35:55,276
references to the outside variables and

26639
17:35:55,276 --> 17:35:58,796
you can do pretty nasty things with them

26640
17:35:58,796 --> 17:36:00,636
because the changes you do inside the

26641
17:36:00,636 --> 17:36:02,720
lambda function are going to be visible

26642
17:36:02,720 --> 17:36:05,520
outside the lambda function and any

26643
17:36:05,520 --> 17:36:07,436
change you do from the outside is also

26644
17:36:07,436 --> 17:36:09,840
going to be visible inside the lambda

26645
17:36:09,840 --> 17:36:12,080
function so if you do this make sure

26646
17:36:12,080 --> 17:36:14,240
this is what you want and you can use

26647
17:36:14,240 --> 17:36:16,720
this to your advantage okay now that you

26648
17:36:16,720 --> 17:36:18,320
know this we're going to head over to

26649
17:36:18,320 --> 17:36:20,080
visual studio code and play with us a

26650
17:36:20,080 --> 17:36:22,796
little more okay here we are in our

26651
17:36:22,796 --> 17:36:25,040
working folder the current project is

26652
17:36:25,040 --> 17:36:28,080
capture all lists we're going to

26653
17:36:28,080 --> 17:36:31,360
grab our template files pretty quick and

26654
17:36:31,360 --> 17:36:33,436
we're going to put them in place and

26655
17:36:33,436 --> 17:36:35,436
we're going to open this little guy in

26656
17:36:35,436 --> 17:36:37,840
visual studio code let's do that we are

26657
17:36:37,840 --> 17:36:40,160
going to have our folder open we can

26658
17:36:40,160 --> 17:36:43,840
open our main cpp file clean it up like

26659
17:36:43,840 --> 17:36:46,160
we always do and we're going to close

26660
17:36:46,160 --> 17:36:48,000
the left pane here the first thing we

26661
17:36:48,000 --> 17:36:50,320
want to do is to capture everything by

26662
17:36:50,320 --> 17:36:51,916
value and we're going to put in the code

26663
17:36:51,916 --> 17:36:54,400
to do that which should be very easy to

26664
17:36:54,400 --> 17:36:56,956
understand by now and again the syntax

26665
17:36:56,956 --> 17:36:59,840
to capture everything by value is by

26666
17:36:59,840 --> 17:37:02,720
putting an equal sign within your

26667
17:37:02,720 --> 17:37:05,040
capture list you have to put that within

26668
17:37:05,040 --> 17:37:07,116
these angle brackets and that's going to

26669
17:37:07,116 --> 17:37:09,436
capture everything by value now now if

26670
17:37:09,436 --> 17:37:11,200
we run the program we're going to see

26671
17:37:11,200 --> 17:37:14,320
that c has been captured by value if we

26672
17:37:14,320 --> 17:37:15,916
look around we're going to see that the

26673
17:37:15,916 --> 17:37:17,840
outer value is going to

26674
17:37:17,840 --> 17:37:20,400
change but the inner value is going to

26675
17:37:20,400 --> 17:37:22,880
stay the same this is the same behavior

26676
17:37:22,880 --> 17:37:24,796
we have seen before by capturing by

26677
17:37:24,796 --> 17:37:26,796
value so let's build again we're going

26678
17:37:26,796 --> 17:37:29,436
to build with gcc the world is good we

26679
17:37:29,436 --> 17:37:31,916
can clear and uh bring up a terminal so

26680
17:37:31,916 --> 17:37:34,160
that we can clear properly so let's do

26681
17:37:34,160 --> 17:37:37,116
clear and run rooster now we see that

26682
17:37:37,116 --> 17:37:39,436
the outer value is changing but the

26683
17:37:39,436 --> 17:37:42,796
inner value is not changing and again

26684
17:37:42,796 --> 17:37:46,160
this is classic capturing by value if

26685
17:37:46,160 --> 17:37:48,796
you want to capture all by reference

26686
17:37:48,796 --> 17:37:50,796
you're going to use the ampersand symbol

26687
17:37:50,796 --> 17:37:52,160
here and let's do that we're going to

26688
17:37:52,160 --> 17:37:55,040
comment this out and we're going to take

26689
17:37:55,040 --> 17:37:57,360
this out and uh

26690
17:37:57,360 --> 17:38:00,000
use the code here we can do that we're

26691
17:38:00,000 --> 17:38:02,560
going to go down and put in a code and

26692
17:38:02,560 --> 17:38:05,360
say that we are capturing by reference

26693
17:38:05,360 --> 17:38:08,480
we should say capturing all by reference

26694
17:38:08,480 --> 17:38:11,200
and all we have to do to make that work

26695
17:38:11,200 --> 17:38:14,000
by reference is to put our ampersand

26696
17:38:14,000 --> 17:38:17,520
symbol within this angle brackets here

26697
17:38:17,520 --> 17:38:19,200
and this is going to capture everything

26698
17:38:19,200 --> 17:38:21,360
by reference if we run now we're going

26699
17:38:21,360 --> 17:38:23,040
to see that the changes we do from the

26700
17:38:23,040 --> 17:38:25,596
outside are going to be visible from the

26701
17:38:25,596 --> 17:38:26,956
inside here

26702
17:38:26,956 --> 17:38:29,756
let's weld with gcc and see that this is

26703
17:38:29,756 --> 17:38:32,400
actually the case the bolt is good as

26704
17:38:32,400 --> 17:38:35,116
you see here we can clear and run the

26705
17:38:35,116 --> 17:38:36,796
rooster we're going to see that the

26706
17:38:36,796 --> 17:38:40,400
outer value is 42 the outer value is

26707
17:38:40,400 --> 17:38:42,880
changing and the inner value is changing

26708
17:38:42,880 --> 17:38:46,480
as you see in our output here and this

26709
17:38:46,480 --> 17:38:48,480
is really how you can capture

26710
17:38:48,480 --> 17:38:51,116
by reference just to play with this

26711
17:38:51,116 --> 17:38:52,560
we're going to set up another variable

26712
17:38:52,560 --> 17:38:55,756
call it d and we're going to say it

26713
17:38:55,756 --> 17:38:58,240
contains a 5 and we can try to print

26714
17:38:58,240 --> 17:39:00,480
that inside our inner value here and it

26715
17:39:00,480 --> 17:39:02,000
is going to work you're going to see

26716
17:39:02,000 --> 17:39:04,000
that it has been captured we can say

26717
17:39:04,000 --> 17:39:07,040
sddc out inner value let's say that it

26718
17:39:07,040 --> 17:39:09,360
is the d variable we are trying to

26719
17:39:09,360 --> 17:39:12,080
access here and we're going to say d and

26720
17:39:12,080 --> 17:39:14,480
it is going to be visible inside our

26721
17:39:14,480 --> 17:39:16,636
lambda function here because it was

26722
17:39:16,636 --> 17:39:19,520
captured by reference here let's build

26723
17:39:19,520 --> 17:39:22,480
again we're going to use gcc to do that

26724
17:39:22,480 --> 17:39:24,956
the bolt is good we can clear and if we

26725
17:39:24,956 --> 17:39:27,840
run booster we should see d printed out

26726
17:39:27,840 --> 17:39:29,520
multiple times d

26727
17:39:29,520 --> 17:39:30,240
d

26728
17:39:30,240 --> 17:39:30,880
d

26729
17:39:30,880 --> 17:39:34,160
d and we are able to access it through

26730
17:39:34,160 --> 17:39:36,400
the capture mechanism and we are

26731
17:39:36,400 --> 17:39:39,200
capturing everything in the context by

26732
17:39:39,200 --> 17:39:41,520
reference here this is really all we set

26733
17:39:41,520 --> 17:39:43,276
out to do in this lecture i hope you

26734
17:39:43,276 --> 17:39:45,756
found it interesting i hate to say it

26735
17:39:45,756 --> 17:39:48,560
but this happens to be the last lecture

26736
17:39:48,560 --> 17:39:50,956
in this chapter on lambda functions we

26737
17:39:50,956 --> 17:39:53,200
still have a lot to learn about lambda

26738
17:39:53,200 --> 17:39:55,680
functions but unfortunately we don't

26739
17:39:55,680 --> 17:39:57,756
really have enough tools to understand

26740
17:39:57,756 --> 17:39:59,840
that now but for now we're going to stop

26741
17:39:59,840 --> 17:40:01,436
here and learn a little more things

26742
17:40:01,436 --> 17:40:03,436
about c plus plus then we're going to

26743
17:40:03,436 --> 17:40:05,916
come back and see some crazy things you

26744
17:40:05,916 --> 17:40:08,880
can really do with lambda functions i

26745
17:40:08,880 --> 17:40:10,720
would like to welcome you in this new

26746
17:40:10,720 --> 17:40:12,560
chapter where we're going to be learning

26747
17:40:12,560 --> 17:40:14,956
about function templates function

26748
17:40:14,956 --> 17:40:18,000
templates are a mechanism we have in c

26749
17:40:18,000 --> 17:40:21,596
plus to set up blueprint for functions

26750
17:40:21,596 --> 17:40:24,720
and have one point of control to set up

26751
17:40:24,720 --> 17:40:26,560
the function but the compiler is going

26752
17:40:26,560 --> 17:40:28,720
to generate the actual function that

26753
17:40:28,720 --> 17:40:31,276
gets called when it sees the function

26754
17:40:31,276 --> 17:40:33,116
call so this is going to solve the

26755
17:40:33,116 --> 17:40:35,276
problem we had before with function

26756
17:40:35,276 --> 17:40:37,276
overloads if you look at the code here

26757
17:40:37,276 --> 17:40:39,596
we have multiple overloads for the

26758
17:40:39,596 --> 17:40:42,400
maximum function but what we really are

26759
17:40:42,400 --> 17:40:45,436
doing in the body of these functions

26760
17:40:45,436 --> 17:40:48,636
is the same and suppose you have

26761
17:40:48,636 --> 17:40:51,840
12 or 13 or 20 overloads of the same

26762
17:40:51,840 --> 17:40:53,840
function you're going to be basically

26763
17:40:53,840 --> 17:40:56,320
repeating the same logic in the bodies

26764
17:40:56,320 --> 17:40:58,080
of this function and this code

26765
17:40:58,080 --> 17:41:00,956
repetition is bad function templates are

26766
17:41:00,956 --> 17:41:02,720
an effort to

26767
17:41:02,720 --> 17:41:05,040
solve problems like this the way they

26768
17:41:05,040 --> 17:41:06,956
work you set up a blueprint for your

26769
17:41:06,956 --> 17:41:09,520
function and this is the syntax to do

26770
17:41:09,520 --> 17:41:12,080
something like that you say template

26771
17:41:12,080 --> 17:41:14,480
type name t here don't worry about this

26772
17:41:14,480 --> 17:41:16,000
syntax we're going to have a chance to

26773
17:41:16,000 --> 17:41:19,200
go through it in detail but if you do

26774
17:41:19,200 --> 17:41:21,436
things like this this is going to be a

26775
17:41:21,436 --> 17:41:24,400
blueprint for your maximum function and

26776
17:41:24,400 --> 17:41:26,320
the compiler is going to use this

26777
17:41:26,320 --> 17:41:30,000
blueprint to generate an actual function

26778
17:41:30,000 --> 17:41:31,756
when you call this function and this is

26779
17:41:31,756 --> 17:41:34,000
going to make things super easy i

26780
17:41:34,000 --> 17:41:36,160
realized some of this is really cryptic

26781
17:41:36,160 --> 17:41:39,116
so let's head over to the next lecture

26782
17:41:39,116 --> 17:41:41,596
and let you set up your very first

26783
17:41:41,596 --> 17:41:44,080
function template go ahead and finish up

26784
17:41:44,080 --> 17:41:46,636
here and meet me there in this lecture

26785
17:41:46,636 --> 17:41:49,040
we're going to set up our very first

26786
17:41:49,040 --> 17:41:51,436
function template and again function

26787
17:41:51,436 --> 17:41:54,240
templates are a mechanism we have in c

26788
17:41:54,240 --> 17:41:57,200
plus plus to avoid code repetition for

26789
17:41:57,200 --> 17:42:00,000
example if you are setting up function

26790
17:42:00,000 --> 17:42:02,880
overloads if you look here we have our

26791
17:42:02,880 --> 17:42:05,520
max function and we have multiple

26792
17:42:05,520 --> 17:42:07,680
overloads for this function we can call

26793
17:42:07,680 --> 17:42:10,880
it with and double and string view here

26794
17:42:10,880 --> 17:42:12,956
but if you look inside you see that we

26795
17:42:12,956 --> 17:42:15,680
really are repeating the same logic

26796
17:42:15,680 --> 17:42:18,240
and it is even possible to have dozens

26797
17:42:18,240 --> 17:42:21,596
of overloads if you want to support tons

26798
17:42:21,596 --> 17:42:23,680
of types for your function

26799
17:42:23,680 --> 17:42:27,040
and this code repetition is really bad

26800
17:42:27,040 --> 17:42:29,276
function templates are a mechanism we

26801
17:42:29,276 --> 17:42:32,000
have in place to avoid things like this

26802
17:42:32,000 --> 17:42:33,520
and what you do

26803
17:42:33,520 --> 17:42:36,160
you set up a function blueprint using

26804
17:42:36,160 --> 17:42:38,560
the syntax you see here and your

26805
17:42:38,560 --> 17:42:40,160
function template is going to be

26806
17:42:40,160 --> 17:42:41,596
prefixed

26807
17:42:41,596 --> 17:42:44,240
with this template type name teeth and

26808
17:42:44,240 --> 17:42:46,796
here type name t is going to be in this

26809
17:42:46,796 --> 17:42:48,560
angle brackets

26810
17:42:48,560 --> 17:42:50,000
and then you're going to put the

26811
17:42:50,000 --> 17:42:53,040
blueprint for your function t is a

26812
17:42:53,040 --> 17:42:55,436
placeholder for the types that you use

26813
17:42:55,436 --> 17:42:58,560
in your function you see that t is in

26814
17:42:58,560 --> 17:43:01,436
the return type here it's in the

26815
17:43:01,436 --> 17:43:03,756
parameters that we pass to the function

26816
17:43:03,756 --> 17:43:05,360
and because it is the same character

26817
17:43:05,360 --> 17:43:07,436
here all these things have to be of the

26818
17:43:07,436 --> 17:43:09,276
same type the return type the first

26819
17:43:09,276 --> 17:43:11,680
parameter the second parameter they have

26820
17:43:11,680 --> 17:43:14,400
to be of the same type okay so once you

26821
17:43:14,400 --> 17:43:16,320
have your function template set up like

26822
17:43:16,320 --> 17:43:17,916
this you're going to implement it like

26823
17:43:17,916 --> 17:43:20,480
we see down below here it is nothing

26824
17:43:20,480 --> 17:43:23,200
complicated we just set up the prototype

26825
17:43:23,200 --> 17:43:25,116
for the function on top

26826
17:43:25,116 --> 17:43:27,680
and inside we put our implementation you

26827
17:43:27,680 --> 17:43:30,240
see here we have separated this into

26828
17:43:30,240 --> 17:43:32,320
function declaration and function

26829
17:43:32,320 --> 17:43:34,796
definition but inside you see that it is

26830
17:43:34,796 --> 17:43:37,520
the same logic we had to compute our

26831
17:43:37,520 --> 17:43:39,916
maximum between these two parameters

26832
17:43:39,916 --> 17:43:42,720
that we pass to this function

26833
17:43:42,720 --> 17:43:45,596
so how does this work when the compiler

26834
17:43:45,596 --> 17:43:48,956
sees you call this max function for

26835
17:43:48,956 --> 17:43:51,916
example as we are doing here it's going

26836
17:43:51,916 --> 17:43:54,240
to look at the types that you pass in

26837
17:43:54,240 --> 17:43:56,796
and in this case a and b

26838
17:43:56,796 --> 17:43:59,436
are of ant type so it is going to

26839
17:43:59,436 --> 17:44:03,520
replace the t in here for and and it is

26840
17:44:03,520 --> 17:44:05,840
going to generate a function initial

26841
17:44:05,840 --> 17:44:06,880
code

26842
17:44:06,880 --> 17:44:08,880
and this really brings up a big point

26843
17:44:08,880 --> 17:44:10,720
about function templates many people

26844
17:44:10,720 --> 17:44:13,520
think that function templates are actual

26845
17:44:13,520 --> 17:44:16,160
c plus plus code they're not they're

26846
17:44:16,160 --> 17:44:18,796
just a blueprint from which the compiler

26847
17:44:18,796 --> 17:44:21,840
is going to generate the actual function

26848
17:44:21,840 --> 17:44:23,596
that is called by the compiler for

26849
17:44:23,596 --> 17:44:26,560
example when you issue a call like this

26850
17:44:26,560 --> 17:44:27,436
again

26851
17:44:27,436 --> 17:44:29,520
function templates are not real c plus

26852
17:44:29,520 --> 17:44:32,720
plus code they are just a blueprint that

26853
17:44:32,720 --> 17:44:35,040
the compiler uses to generate your

26854
17:44:35,040 --> 17:44:36,080
function

26855
17:44:36,080 --> 17:44:38,400
based on the arguments you pass to the

26856
17:44:38,400 --> 17:44:40,720
function when you call it so when we

26857
17:44:40,720 --> 17:44:43,276
issue the call like we do here an int

26858
17:44:43,276 --> 17:44:45,596
version of our maximum function is going

26859
17:44:45,596 --> 17:44:47,680
to be created so the compiler is

26860
17:44:47,680 --> 17:44:50,560
basically going to go in and replace n

26861
17:44:50,560 --> 17:44:52,796
and for t here the return type is going

26862
17:44:52,796 --> 17:44:54,636
to be nt the first parameter is going to

26863
17:44:54,636 --> 17:44:56,400
be end the second parameter is going to

26864
17:44:56,400 --> 17:44:57,680
be empty it's going to go in the

26865
17:44:57,680 --> 17:44:59,436
definition it's going to do that and

26866
17:44:59,436 --> 17:45:01,436
we're going to have an it function

26867
17:45:01,436 --> 17:45:04,240
if we issue a call with c and d like we

26868
17:45:04,240 --> 17:45:06,636
do here in the second line here then the

26869
17:45:06,636 --> 17:45:09,200
compiler is going to see that c and d

26870
17:45:09,200 --> 17:45:11,436
are of double type so it is going to

26871
17:45:11,436 --> 17:45:13,360
generate another function from this

26872
17:45:13,360 --> 17:45:14,956
blueprint here and it is going to

26873
17:45:14,956 --> 17:45:17,276
replace in double then we're going to

26874
17:45:17,276 --> 17:45:19,596
have another double function if we go to

26875
17:45:19,596 --> 17:45:21,040
the third line here we're going to do

26876
17:45:21,040 --> 17:45:22,636
the same we're going to call it with

26877
17:45:22,636 --> 17:45:24,956
strengths and it is going to generate a

26878
17:45:24,956 --> 17:45:27,680
stringed version of the maximum function

26879
17:45:27,680 --> 17:45:30,560
here so what we achieve with function

26880
17:45:30,560 --> 17:45:33,040
templates is to avoid

26881
17:45:33,040 --> 17:45:35,360
several overloads for the same function

26882
17:45:35,360 --> 17:45:37,520
and we have one point of control in our

26883
17:45:37,520 --> 17:45:40,560
code but the compiler is still going to

26884
17:45:40,560 --> 17:45:43,276
generate this function overloads but one

26885
17:45:43,276 --> 17:45:45,276
thing about this is that if a function

26886
17:45:45,276 --> 17:45:47,436
is not used for example if you never

26887
17:45:47,436 --> 17:45:50,480
call a maximum function with string

26888
17:45:50,480 --> 17:45:52,240
then the string version is never going

26889
17:45:52,240 --> 17:45:54,636
to be created the compiler is going to

26890
17:45:54,636 --> 17:45:57,276
generate the overloads that you only

26891
17:45:57,276 --> 17:45:59,436
call in your c plus plus program and

26892
17:45:59,436 --> 17:46:01,596
this is really all function templates

26893
17:46:01,596 --> 17:46:04,160
are all about they give you a mechanism

26894
17:46:04,160 --> 17:46:06,320
to set up a blueprint for your function

26895
17:46:06,320 --> 17:46:07,840
and then the compiler is going to

26896
17:46:07,840 --> 17:46:11,116
generate actual functions based on what

26897
17:46:11,116 --> 17:46:13,360
you call in your c plus plus code okay

26898
17:46:13,360 --> 17:46:14,796
we have saved this but i want to

26899
17:46:14,796 --> 17:46:16,796
emphasize this again

26900
17:46:16,796 --> 17:46:19,596
function templates are just blueprints

26901
17:46:19,596 --> 17:46:22,796
they're not real c plus plus could and

26902
17:46:22,796 --> 17:46:24,480
when we hit visual studio code in a

26903
17:46:24,480 --> 17:46:26,400
minute we're going to see a tool

26904
17:46:26,400 --> 17:46:29,520
that allows us to see how the compiler

26905
17:46:29,520 --> 17:46:32,480
instantiates your function templates

26906
17:46:32,480 --> 17:46:35,116
based on the arguments you call your

26907
17:46:35,116 --> 17:46:37,916
function with but keep this in mind

26908
17:46:37,916 --> 17:46:40,160
function templates are not real c plus

26909
17:46:40,160 --> 17:46:43,276
plus code the rio c plus plus functions

26910
17:46:43,276 --> 17:46:45,520
get generated by the compiler

26911
17:46:45,520 --> 17:46:47,916
when you call your function and another

26912
17:46:47,916 --> 17:46:50,636
thing i wanted to point out is that

26913
17:46:50,636 --> 17:46:53,680
once a function template instance is

26914
17:46:53,680 --> 17:46:55,680
generated for example the interversion

26915
17:46:55,680 --> 17:46:59,276
of our maximum function template then if

26916
17:46:59,276 --> 17:47:01,200
it is needed again the compiler is not

26917
17:47:01,200 --> 17:47:03,276
going to generate that again it's going

26918
17:47:03,276 --> 17:47:05,680
to see if there is one generator already

26919
17:47:05,680 --> 17:47:07,756
and it is going to reuse that okay this

26920
17:47:07,756 --> 17:47:09,436
is really all i have to share about

26921
17:47:09,436 --> 17:47:11,916
function templates at this point in this

26922
17:47:11,916 --> 17:47:14,000
chapter for now we're going to head over

26923
17:47:14,000 --> 17:47:15,916
to visual studio code and play with this

26924
17:47:15,916 --> 17:47:18,796
a little more okay here we are in our

26925
17:47:18,796 --> 17:47:21,360
working directory the current project is

26926
17:47:21,360 --> 17:47:23,116
trying out function templates we're

26927
17:47:23,116 --> 17:47:25,916
going to grab our template project and

26928
17:47:25,916 --> 17:47:27,756
one thing i should point out here is

26929
17:47:27,756 --> 17:47:30,320
that our template project has been now

26930
17:47:30,320 --> 17:47:34,080
updated to have the launch.json file

26931
17:47:34,080 --> 17:47:36,000
which is going to allow us to debug our

26932
17:47:36,000 --> 17:47:38,636
programs so you should use a template

26933
17:47:38,636 --> 17:47:41,520
that includes the launch.json file here

26934
17:47:41,520 --> 17:47:43,276
that's going to allow us to debug your

26935
17:47:43,276 --> 17:47:45,276
programs and we're going to do that in a

26936
17:47:45,276 --> 17:47:47,360
minute when we have set up the example

26937
17:47:47,360 --> 17:47:49,840
here so we're going to grab our template

26938
17:47:49,840 --> 17:47:52,880
files and put them in place and we're

26939
17:47:52,880 --> 17:47:54,956
going to open this little guy in visual

26940
17:47:54,956 --> 17:47:57,520
studio code by dragging and dropping on

26941
17:47:57,520 --> 17:48:00,320
top here this is going to do our job

26942
17:48:00,320 --> 17:48:02,320
then we're going to open up the main cpp

26943
17:48:02,320 --> 17:48:04,400
file and i think we should close the

26944
17:48:04,400 --> 17:48:06,560
left pane here we don't need it anymore

26945
17:48:06,560 --> 17:48:07,916
and we're going to clean this up a

26946
17:48:07,916 --> 17:48:10,240
little bit so one thing i want to do is

26947
17:48:10,240 --> 17:48:12,400
to first do things the bad way so we're

26948
17:48:12,400 --> 17:48:14,400
going to set up a max function

26949
17:48:14,400 --> 17:48:16,560
let's call this maximum

26950
17:48:16,560 --> 17:48:18,956
and it's going to take end parameters

26951
17:48:18,956 --> 17:48:21,596
and we're going to return the maximum

26952
17:48:21,596 --> 17:48:23,436
between a and b and the way we do that

26953
17:48:23,436 --> 17:48:26,320
we say a greater than b we are going to

26954
17:48:26,320 --> 17:48:28,160
use our ternary operator here we're

26955
17:48:28,160 --> 17:48:29,680
going to put a question mark we're going

26956
17:48:29,680 --> 17:48:32,480
to return a or b and this is going to be

26957
17:48:32,480 --> 17:48:34,796
our function but suppose we need another

26958
17:48:34,796 --> 17:48:38,000
function that works on doubles if we put

26959
17:48:38,000 --> 17:48:40,240
double arguments in here the compiler is

26960
17:48:40,240 --> 17:48:42,636
going to insert implicit conversions

26961
17:48:42,636 --> 17:48:45,436
from double to end this may seem to work

26962
17:48:45,436 --> 17:48:48,880
but suppose you use a parameter type

26963
17:48:48,880 --> 17:48:50,720
that is not convertible to end for

26964
17:48:50,720 --> 17:48:52,796
example you use a string or something

26965
17:48:52,796 --> 17:48:54,840
let's put in std string

26966
17:48:54,840 --> 17:48:57,680
here just for an example so we're going

26967
17:48:57,680 --> 17:49:01,200
to say maximum std strength

26968
17:49:01,200 --> 17:49:04,400
a and std strength b

26969
17:49:04,400 --> 17:49:06,080
and we should make these const

26970
17:49:06,080 --> 17:49:08,560
references because we're not interested

26971
17:49:08,560 --> 17:49:11,360
in modifying these strings here

26972
17:49:11,360 --> 17:49:13,436
let's finish the name here

26973
17:49:13,436 --> 17:49:16,160
and we're going to say const std string

26974
17:49:16,160 --> 17:49:18,320
reference a this is much better it's

26975
17:49:18,320 --> 17:49:20,560
going to avoid unnecessary copies of

26976
17:49:20,560 --> 17:49:23,436
strings and we're going to say const htd

26977
17:49:23,436 --> 17:49:25,116
string reference

26978
17:49:25,116 --> 17:49:27,840
be here then inside we're not going to

26979
17:49:27,840 --> 17:49:29,680
do anything different we're just going

26980
17:49:29,680 --> 17:49:32,400
to use the same logic okay let's do that

26981
17:49:32,400 --> 17:49:35,200
suppose you have another function

26982
17:49:35,200 --> 17:49:38,560
which takes what should i say long long

26983
17:49:38,560 --> 17:49:41,436
end if we need that we need to copy this

26984
17:49:41,436 --> 17:49:44,796
function and put that in okay we need to

26985
17:49:44,796 --> 17:49:46,480
do that and we're going to change this

26986
17:49:46,480 --> 17:49:48,796
to long long end and we're going to do

26987
17:49:48,796 --> 17:49:50,240
the same here

26988
17:49:50,240 --> 17:49:53,360
long long and our parameter and we're

26989
17:49:53,360 --> 17:49:55,916
going to say the same here and you see

26990
17:49:55,916 --> 17:49:58,160
we are setting up a lot of functions

26991
17:49:58,160 --> 17:50:00,720
with basically the same thing inside and

26992
17:50:00,720 --> 17:50:03,840
that this is a lot of code copies

26993
17:50:03,840 --> 17:50:06,636
suppose we have this function maybe 20

26994
17:50:06,636 --> 17:50:09,916
times it is possible or even worse the

26995
17:50:09,916 --> 17:50:12,320
logic in this function is really long

26996
17:50:12,320 --> 17:50:15,116
maybe 20 or 30 lines and we will have to

26997
17:50:15,116 --> 17:50:17,680
repeat this thing in aku so the

26998
17:50:17,680 --> 17:50:19,596
designers of the c plus plus language

26999
17:50:19,596 --> 17:50:22,320
saw this problem and they said why don't

27000
17:50:22,320 --> 17:50:25,360
we set up a one point of control

27001
17:50:25,360 --> 17:50:27,756
where we can set up our logic to do the

27002
17:50:27,756 --> 17:50:31,360
maximum and we let the compiler generate

27003
17:50:31,360 --> 17:50:32,720
actual

27004
17:50:32,720 --> 17:50:35,916
functions based on the arguments we call

27005
17:50:35,916 --> 17:50:39,436
our functions with and they came up with

27006
17:50:39,436 --> 17:50:41,040
function templates and that's what we're

27007
17:50:41,040 --> 17:50:42,400
going to see so we're going to take out

27008
17:50:42,400 --> 17:50:44,160
all the other functions and we're going

27009
17:50:44,160 --> 17:50:47,680
to turn this maximum and function into a

27010
17:50:47,680 --> 17:50:50,160
function template the syntax to do that

27011
17:50:50,160 --> 17:50:52,160
is ridiculously easy

27012
17:50:52,160 --> 17:50:54,000
so we're going to say template this is

27013
17:50:54,000 --> 17:50:56,000
what you say you put an angle bracket

27014
17:50:56,000 --> 17:50:58,720
and you say type name and you specify

27015
17:50:58,720 --> 17:51:01,436
the placeholder for the type in this

27016
17:51:01,436 --> 17:51:03,360
angle brackets here this is the syntax

27017
17:51:03,360 --> 17:51:04,720
you have to use

27018
17:51:04,720 --> 17:51:07,200
then you have to specify your function

27019
17:51:07,200 --> 17:51:10,400
in terms of this placeholder t it is

27020
17:51:10,400 --> 17:51:12,880
going to take the place of the type so

27021
17:51:12,880 --> 17:51:15,116
for example here we want to return and

27022
17:51:15,116 --> 17:51:17,116
we're going to change this to t and the

27023
17:51:17,116 --> 17:51:19,436
parameters are going to be taken by

27024
17:51:19,436 --> 17:51:21,916
value t and t

27025
17:51:21,916 --> 17:51:23,436
let's do that

27026
17:51:23,436 --> 17:51:26,320
and now we have a legal c plus plus

27027
17:51:26,320 --> 17:51:28,560
function template it is going to take

27028
17:51:28,560 --> 17:51:30,720
this template here and use it to

27029
17:51:30,720 --> 17:51:34,240
generate actual c plus plus functions so

27030
17:51:34,240 --> 17:51:36,160
for example if we go in the main

27031
17:51:36,160 --> 17:51:39,596
function here and say ent result

27032
17:51:39,596 --> 17:51:42,956
equals max maximum we should say and say

27033
17:51:42,956 --> 17:51:45,200
x and y for example let's create these

27034
17:51:45,200 --> 17:51:47,680
variables on top here so we're going to

27035
17:51:47,680 --> 17:51:49,916
say ent x and we're going to put in a

27036
17:51:49,916 --> 17:51:52,320
five and we're going to create a y and

27037
17:51:52,320 --> 17:51:55,436
put in a seven why not now this function

27038
17:51:55,436 --> 17:51:57,360
is going to store the result and print

27039
17:51:57,360 --> 17:51:58,636
it out

27040
17:51:58,636 --> 17:52:00,796
let's do that so that we can see that

27041
17:52:00,796 --> 17:52:02,480
this actually works so we're going to

27042
17:52:02,480 --> 17:52:05,596
say result and say results this is going

27043
17:52:05,596 --> 17:52:08,240
to do and if we build and run this

27044
17:52:08,240 --> 17:52:10,400
program we're going to use gcc you're

27045
17:52:10,400 --> 17:52:11,916
going to see that the world is going to

27046
17:52:11,916 --> 17:52:13,040
be good

27047
17:52:13,040 --> 17:52:15,520
and uh world finished successfully we

27048
17:52:15,520 --> 17:52:18,796
can run this program like we always do

27049
17:52:18,796 --> 17:52:20,956
let's bring up a terminal and clear a

27050
17:52:20,956 --> 17:52:23,276
little bit and run rooster you're going

27051
17:52:23,276 --> 17:52:24,636
to see that we're going to see that

27052
17:52:24,636 --> 17:52:27,200
result now is 7 because that's the

27053
17:52:27,200 --> 17:52:29,840
maximum you see it is working here so

27054
17:52:29,840 --> 17:52:33,116
how is this mechanism working here the

27055
17:52:33,116 --> 17:52:34,880
compiler is basically looking in the

27056
17:52:34,880 --> 17:52:37,360
main function here and it is noticing

27057
17:52:37,360 --> 17:52:39,756
the call and it is going to look around

27058
17:52:39,756 --> 17:52:43,040
and see if it can find a declaration for

27059
17:52:43,040 --> 17:52:44,796
the maximum function here it's not going

27060
17:52:44,796 --> 17:52:47,360
to find it because there is none then

27061
17:52:47,360 --> 17:52:49,116
it's going to look at the function

27062
17:52:49,116 --> 17:52:51,276
templates it has in here and it's going

27063
17:52:51,276 --> 17:52:54,080
to see that it can do a replacement and

27064
17:52:54,080 --> 17:52:56,400
replacing the types that we are passing

27065
17:52:56,400 --> 17:52:58,560
in here so it is going to do that it is

27066
17:52:58,560 --> 17:53:00,636
going to take this template and it is

27067
17:53:00,636 --> 17:53:02,320
going to replace

27068
17:53:02,320 --> 17:53:05,276
t by end and then it is going to

27069
17:53:05,276 --> 17:53:08,240
generate a function that basically looks

27070
17:53:08,240 --> 17:53:10,320
like what we have here we're going to

27071
17:53:10,320 --> 17:53:13,116
copy this and we're going to put this in

27072
17:53:13,116 --> 17:53:14,720
the compiler is going to take the first

27073
17:53:14,720 --> 17:53:16,400
t here it's going to turn that into a

27074
17:53:16,400 --> 17:53:18,320
net it's going to take the second one

27075
17:53:18,320 --> 17:53:20,240
here it's going to turn that into an end

27076
17:53:20,240 --> 17:53:23,040
it's going to take the third one here

27077
17:53:23,040 --> 17:53:25,596
and turn that into an it and we're going

27078
17:53:25,596 --> 17:53:28,080
to have a function definition for the

27079
17:53:28,080 --> 17:53:30,160
call here this is what the compiler is

27080
17:53:30,160 --> 17:53:31,360
going to do

27081
17:53:31,360 --> 17:53:33,916
one thing some of you might be thinking

27082
17:53:33,916 --> 17:53:36,720
is there a way to really prove this and

27083
17:53:36,720 --> 17:53:38,956
somebody was nice enough to design a

27084
17:53:38,956 --> 17:53:39,916
tool

27085
17:53:39,916 --> 17:53:41,436
to let us see

27086
17:53:41,436 --> 17:53:44,320
this function or template instances

27087
17:53:44,320 --> 17:53:46,720
generated by the compiler and i happen

27088
17:53:46,720 --> 17:53:49,200
to have that opened it is a web-based

27089
17:53:49,200 --> 17:53:51,596
tool so you can use this in your browser

27090
17:53:51,596 --> 17:53:53,720
just go to

27091
17:53:53,720 --> 17:53:55,276
cppinsights.io

27092
17:53:55,276 --> 17:53:57,360
and then we're going to grab the code we

27093
17:53:57,360 --> 17:54:01,200
had in our main cpp file we're going to

27094
17:54:01,200 --> 17:54:04,160
copy it all and we're going to go back

27095
17:54:04,160 --> 17:54:07,360
to our browser and remove whatever i had

27096
17:54:07,360 --> 17:54:09,040
in here because i don't want this

27097
17:54:09,040 --> 17:54:11,040
anymore and i'm going to put in my

27098
17:54:11,040 --> 17:54:13,200
function template if we want we can even

27099
17:54:13,200 --> 17:54:16,320
take this sddc out statement because we

27100
17:54:16,320 --> 17:54:18,320
don't want all the junk that comes with

27101
17:54:18,320 --> 17:54:21,756
that we are just interested in looking

27102
17:54:21,756 --> 17:54:24,240
at the template instances

27103
17:54:24,240 --> 17:54:26,560
generated by the compiler now that we

27104
17:54:26,560 --> 17:54:29,200
have the code in here we're going to see

27105
17:54:29,200 --> 17:54:31,436
what the compiler generates because of

27106
17:54:31,436 --> 17:54:33,596
the call we have here i think i could

27107
17:54:33,596 --> 17:54:35,436
increase the size of the font here so

27108
17:54:35,436 --> 17:54:36,720
that you guys

27109
17:54:36,720 --> 17:54:38,796
can see this i think this is a little

27110
17:54:38,796 --> 17:54:39,680
better

27111
17:54:39,680 --> 17:54:42,320
then if you hit this play button here

27112
17:54:42,320 --> 17:54:44,840
let's click on it it's going to do its

27113
17:54:44,840 --> 17:54:47,360
processing and then the code generated

27114
17:54:47,360 --> 17:54:48,956
by the compiler is going to show up to

27115
17:54:48,956 --> 17:54:51,360
the right here you see it has detected

27116
17:54:51,360 --> 17:54:52,636
that we have

27117
17:54:52,636 --> 17:54:55,200
called the function template on line 13

27118
17:54:55,200 --> 17:54:58,240
here you see this line is highlighted

27119
17:54:58,240 --> 17:54:59,680
and then if you go to the right we're

27120
17:54:59,680 --> 17:55:02,320
going to see the functions generated by

27121
17:55:02,320 --> 17:55:04,560
the compiler so if you go here you see

27122
17:55:04,560 --> 17:55:06,636
that we have an interversion

27123
17:55:06,636 --> 17:55:09,520
of our function template and another

27124
17:55:09,520 --> 17:55:12,240
thing i should prove here is that

27125
17:55:12,240 --> 17:55:14,720
template instances that are not needed

27126
17:55:14,720 --> 17:55:16,400
are not going to be generated by the

27127
17:55:16,400 --> 17:55:18,320
compiler another way to say this the

27128
17:55:18,320 --> 17:55:21,436
compiler is only going to generate the

27129
17:55:21,436 --> 17:55:24,480
template instances it needs and again a

27130
17:55:24,480 --> 17:55:27,200
template instance is what you have here

27131
17:55:27,200 --> 17:55:29,840
the function the actual function that is

27132
17:55:29,840 --> 17:55:32,560
callable by the compiler generated from

27133
17:55:32,560 --> 17:55:34,880
your blueprint so if for example we

27134
17:55:34,880 --> 17:55:37,520
change the type of our

27135
17:55:37,520 --> 17:55:39,916
parameters to double let's do that okay

27136
17:55:39,916 --> 17:55:42,636
so we changed our types to double we're

27137
17:55:42,636 --> 17:55:44,880
going to hit the play button again

27138
17:55:44,880 --> 17:55:46,636
you're going to see that now it is going

27139
17:55:46,636 --> 17:55:48,880
to generate a double function here you

27140
17:55:48,880 --> 17:55:51,276
see that here if we change this for

27141
17:55:51,276 --> 17:55:52,956
example to

27142
17:55:52,956 --> 17:55:55,840
what can we use let's use long long end

27143
17:55:55,840 --> 17:55:58,560
like we did in our lecture we can do

27144
17:55:58,560 --> 17:56:02,320
that we can say long long and and if we

27145
17:56:02,320 --> 17:56:04,560
hit the play button that's what is going

27146
17:56:04,560 --> 17:56:07,436
to be generated by the compiler so

27147
17:56:07,436 --> 17:56:10,160
hopefully this proves that the compiler

27148
17:56:10,160 --> 17:56:13,596
is only going to generate the instances

27149
17:56:13,596 --> 17:56:16,400
that are needed for the calls you do in

27150
17:56:16,400 --> 17:56:18,880
your c plus plus program and this is

27151
17:56:18,880 --> 17:56:21,116
really function templates are all about

27152
17:56:21,116 --> 17:56:22,956
okay now that you know this let's set up

27153
17:56:22,956 --> 17:56:25,040
a few more examples to see that this

27154
17:56:25,040 --> 17:56:26,480
really works

27155
17:56:26,480 --> 17:56:28,796
so let's change the types of these guys

27156
17:56:28,796 --> 17:56:29,680
to

27157
17:56:29,680 --> 17:56:32,160
double let's do that and we're going to

27158
17:56:32,160 --> 17:56:33,916
play with this a little more in visual

27159
17:56:33,916 --> 17:56:37,200
studio code and let's use double

27160
17:56:37,200 --> 17:56:41,956
liters 5.5 and 7 or

27161
17:56:41,956 --> 17:56:46,320
78.7 here let's do that 78.7 and we're

27162
17:56:46,320 --> 17:56:48,720
going to build this and one thing i

27163
17:56:48,720 --> 17:56:50,636
should point out is that template

27164
17:56:50,636 --> 17:56:52,880
instances are generated when the

27165
17:56:52,880 --> 17:56:55,200
compiler is doing its job and then they

27166
17:56:55,200 --> 17:56:56,880
are going to be put

27167
17:56:56,880 --> 17:56:59,520
in the binary representation of your

27168
17:56:59,520 --> 17:57:02,240
source code so the world is good as you

27169
17:57:02,240 --> 17:57:05,116
see here we can clear and run a rooster

27170
17:57:05,116 --> 17:57:08,320
we're going to see that the result is 78

27171
17:57:08,320 --> 17:57:11,200
and it is transformed to end because we

27172
17:57:11,200 --> 17:57:13,596
are assigning to end here to really get

27173
17:57:13,596 --> 17:57:15,436
to the correct results here we should

27174
17:57:15,436 --> 17:57:18,080
use auto type deduction if we do that

27175
17:57:18,080 --> 17:57:20,000
the compiler is going to deduce the type

27176
17:57:20,000 --> 17:57:22,480
of result here based on the return type

27177
17:57:22,480 --> 17:57:24,956
of this function or the function

27178
17:57:24,956 --> 17:57:27,360
template instance i should say

27179
17:57:27,360 --> 17:57:29,116
now we're going to change this to auto

27180
17:57:29,116 --> 17:57:31,360
to do auto type deduction

27181
17:57:31,360 --> 17:57:33,200
and if we both again we should see a

27182
17:57:33,200 --> 17:57:36,320
double printed out correctly the both is

27183
17:57:36,320 --> 17:57:38,720
good we can clear and run the rooster

27184
17:57:38,720 --> 17:57:41,276
now we have the correct value printed

27185
17:57:41,276 --> 17:57:44,796
out from our function template here

27186
17:57:44,796 --> 17:57:47,116
let's change this to std string we can

27187
17:57:47,116 --> 17:57:49,436
do that so let's include

27188
17:57:49,436 --> 17:57:50,240
a

27189
17:57:50,240 --> 17:57:52,080
the string library

27190
17:57:52,080 --> 17:57:53,840
and we're going to change these two guys

27191
17:57:53,840 --> 17:57:57,436
to std string why not std string x is

27192
17:57:57,436 --> 17:58:01,436
going to be a string electro let's use

27193
17:58:01,436 --> 17:58:04,720
hello for example and uh for

27194
17:58:04,720 --> 17:58:07,520
y we're going to say std strength and

27195
17:58:07,520 --> 17:58:10,080
we're going to put in a world here okay

27196
17:58:10,080 --> 17:58:12,080
this is going to do and you notice that

27197
17:58:12,080 --> 17:58:14,400
we don't even have a compiler error

27198
17:58:14,400 --> 17:58:16,560
visual studio code is not complaining

27199
17:58:16,560 --> 17:58:18,400
the compiler is going to look at the

27200
17:58:18,400 --> 17:58:21,116
types we call our function with then it

27201
17:58:21,116 --> 17:58:23,596
is going to generate is an sdd string

27202
17:58:23,596 --> 17:58:26,000
version of this function and what it is

27203
17:58:26,000 --> 17:58:28,880
going to do it's going to replace in t

27204
17:58:28,880 --> 17:58:31,916
and replace that for std strand we can

27205
17:58:31,916 --> 17:58:35,596
actually put this thing entirely in

27206
17:58:35,596 --> 17:58:37,596
cpp inside so let's copy this code

27207
17:58:37,596 --> 17:58:39,520
before we run it so that you can really

27208
17:58:39,520 --> 17:58:41,436
see what is happening here we're going

27209
17:58:41,436 --> 17:58:43,116
to take out whatever we had before we're

27210
17:58:43,116 --> 17:58:45,200
going to put in our code and then we're

27211
17:58:45,200 --> 17:58:46,880
going to hit the play button here it's

27212
17:58:46,880 --> 17:58:48,880
going to generate our thumb we wait for

27213
17:58:48,880 --> 17:58:51,200
it to do its thing and if you look here

27214
17:58:51,200 --> 17:58:54,080
you see that it has generated

27215
17:58:54,080 --> 17:58:56,520
std strength this is really a compiler

27216
17:58:56,520 --> 17:59:00,000
representation of std string we don't

27217
17:59:00,000 --> 17:59:02,080
have enough tools to really understand

27218
17:59:02,080 --> 17:59:04,880
this but hopefully you can see that it

27219
17:59:04,880 --> 17:59:06,956
has replaced t

27220
17:59:06,956 --> 17:59:09,436
with some other type we don't know yet

27221
17:59:09,436 --> 17:59:12,560
std basic string car it has a few things

27222
17:59:12,560 --> 17:59:14,956
inside that we don't really know yet we

27223
17:59:14,956 --> 17:59:17,360
will have to learn a few more things

27224
17:59:17,360 --> 17:59:19,840
about this as we progress in the course

27225
17:59:19,840 --> 17:59:21,200
but for now

27226
17:59:21,200 --> 17:59:23,276
i want to prove to you that the compiler

27227
17:59:23,276 --> 17:59:25,840
is doing the replacement you see t was

27228
17:59:25,840 --> 17:59:28,720
replaced by this thing here std basic

27229
17:59:28,720 --> 17:59:30,880
strength and we have angle brackets and

27230
17:59:30,880 --> 17:59:34,080
this entire thing is really hdd strength

27231
17:59:34,080 --> 17:59:36,240
in the eyes of the compiler okay now

27232
17:59:36,240 --> 17:59:37,916
that we know this let's go back to

27233
17:59:37,916 --> 17:59:40,400
visual studio code and run this we're

27234
17:59:40,400 --> 17:59:43,596
going to build with gcc as we always do

27235
17:59:43,596 --> 17:59:45,756
the world is good we can clear and run

27236
17:59:45,756 --> 17:59:46,880
rooster

27237
17:59:46,880 --> 17:59:49,040
going to see that the maximum is world

27238
17:59:49,040 --> 17:59:51,116
and this is going to be using the

27239
17:59:51,116 --> 17:59:53,040
greater than operator

27240
17:59:53,040 --> 17:59:55,116
and this is going to compare two

27241
17:59:55,116 --> 17:59:57,276
strengths based on this and we know that

27242
17:59:57,276 --> 18:00:00,160
w here comes after h

27243
18:00:00,160 --> 18:00:03,116
in lexicographical order so the

27244
18:00:03,116 --> 18:00:04,880
comparison that is done here is

27245
18:00:04,880 --> 18:00:06,400
lexicographical

27246
18:00:06,400 --> 18:00:08,880
for this strength here or i should say

27247
18:00:08,880 --> 18:00:11,276
it is comparing things in alphabetical

27248
18:00:11,276 --> 18:00:14,480
order in abcde and things like that okay

27249
18:00:14,480 --> 18:00:17,116
now hopefully you have a big idea about

27250
18:00:17,116 --> 18:00:18,636
function templates they are just

27251
18:00:18,636 --> 18:00:20,956
blueprints you use

27252
18:00:20,956 --> 18:00:23,916
to generate actual functions and this is

27253
18:00:23,916 --> 18:00:26,000
going to allow you to avoid multiple

27254
18:00:26,000 --> 18:00:28,000
function overloads as we have seen

27255
18:00:28,000 --> 18:00:28,956
before

27256
18:00:28,956 --> 18:00:30,956
one thing i want you to see

27257
18:00:30,956 --> 18:00:33,200
is that you have to be sure that the

27258
18:00:33,200 --> 18:00:36,160
logic you do inside your function is

27259
18:00:36,160 --> 18:00:38,636
supported by the types that you pass to

27260
18:00:38,636 --> 18:00:40,636
the function and i'm going to show you

27261
18:00:40,636 --> 18:00:42,080
what i mean here we're going to set up

27262
18:00:42,080 --> 18:00:43,756
another function template we're going to

27263
18:00:43,756 --> 18:00:46,000
say template type named we're going to

27264
18:00:46,000 --> 18:00:48,240
set up another one pedem and we're going

27265
18:00:48,240 --> 18:00:50,560
to use t here you can use

27266
18:00:50,560 --> 18:00:52,720
this however many times you want and

27267
18:00:52,720 --> 18:00:54,160
then we're going to set up the function

27268
18:00:54,160 --> 18:00:57,680
which is going to do a multiplication so

27269
18:00:57,680 --> 18:00:59,360
we're going to say t that's going to be

27270
18:00:59,360 --> 18:01:01,116
the return value and we're going to say

27271
18:01:01,116 --> 18:01:03,116
multiply and we're going to multiply two

27272
18:01:03,116 --> 18:01:05,680
parameters we're going to say t a and t

27273
18:01:05,680 --> 18:01:08,080
b okay and we're going to put in the

27274
18:01:08,080 --> 18:01:11,040
logic and we're going to just return a

27275
18:01:11,040 --> 18:01:12,880
multiplied by b this is our

27276
18:01:12,880 --> 18:01:16,160
multiplication operator in c plus plus

27277
18:01:16,160 --> 18:01:18,480
and we can use this function so for

27278
18:01:18,480 --> 18:01:21,116
example we can say we can comment this

27279
18:01:21,116 --> 18:01:23,116
out and we can set up two variables

27280
18:01:23,116 --> 18:01:25,680
we're going to say and x and we're going

27281
18:01:25,680 --> 18:01:27,436
to put in whatever we had before let's

27282
18:01:27,436 --> 18:01:28,796
put in five

27283
18:01:28,796 --> 18:01:31,680
and end to y we're going to say 7 i

27284
18:01:31,680 --> 18:01:33,360
think this is what we used before you

27285
18:01:33,360 --> 18:01:35,360
can really put in whatever you want and

27286
18:01:35,360 --> 18:01:37,200
now we're going to call the multiply

27287
18:01:37,200 --> 18:01:39,200
function template so what this is going

27288
18:01:39,200 --> 18:01:41,756
to do is to generate a function template

27289
18:01:41,756 --> 18:01:44,160
instance which is going to be of type

27290
18:01:44,160 --> 18:01:46,796
and it's going to do a replacement in

27291
18:01:46,796 --> 18:01:49,116
here and replace t with ant and then

27292
18:01:49,116 --> 18:01:51,040
we're going to multiply two end

27293
18:01:51,040 --> 18:01:52,560
parameters that are passed to this

27294
18:01:52,560 --> 18:01:55,116
function and we're going to return end

27295
18:01:55,116 --> 18:01:57,360
and if we do that we're going to get 35

27296
18:01:57,360 --> 18:01:59,276
printed out let's prove this we're going

27297
18:01:59,276 --> 18:02:02,080
to use gcc to bolt the bolt is good we

27298
18:02:02,080 --> 18:02:05,756
can clear and run rooster we get a 35 if

27299
18:02:05,756 --> 18:02:07,680
we change this to double it is going to

27300
18:02:07,680 --> 18:02:10,320
work so let's change this to double and

27301
18:02:10,320 --> 18:02:13,880
maybe put in five point one and

27302
18:02:13,880 --> 18:02:16,796
7.0 why not and then we're going to see

27303
18:02:16,796 --> 18:02:18,796
what we get we're going to build with

27304
18:02:18,796 --> 18:02:21,680
gcc the build is good we can clear run

27305
18:02:21,680 --> 18:02:23,000
rooster we get

27306
18:02:23,000 --> 18:02:26,000
35.7 this is what we expect

27307
18:02:26,000 --> 18:02:29,276
but watch what happens if we try

27308
18:02:29,276 --> 18:02:33,436
to use the std string types okay i want

27309
18:02:33,436 --> 18:02:35,840
you to see that so we're going to enable

27310
18:02:35,840 --> 18:02:38,956
our std strength variables here

27311
18:02:38,956 --> 18:02:41,200
and if we try to bolt we're going to get

27312
18:02:41,200 --> 18:02:43,520
a compiler error but i want you to try

27313
18:02:43,520 --> 18:02:45,520
and guess why why do we have this

27314
18:02:45,520 --> 18:02:48,400
compiler if we look at what gcc is

27315
18:02:48,400 --> 18:02:49,680
saying here

27316
18:02:49,680 --> 18:02:52,956
it is saying an instantiation of our

27317
18:02:52,956 --> 18:02:56,160
function template required from here and

27318
18:02:56,160 --> 18:02:58,560
no match for operator

27319
18:02:58,560 --> 18:03:01,040
multiplication here and this is the

27320
18:03:01,040 --> 18:03:02,240
problem

27321
18:03:02,240 --> 18:03:04,400
the compiler is going to do what it

27322
18:03:04,400 --> 18:03:06,480
knows to do it is going to do a

27323
18:03:06,480 --> 18:03:09,360
replacement in our function template and

27324
18:03:09,360 --> 18:03:11,436
it is going to replace t

27325
18:03:11,436 --> 18:03:13,840
by std strength because that's the type

27326
18:03:13,840 --> 18:03:16,400
we are using as an argument here the

27327
18:03:16,400 --> 18:03:19,360
problem is we can't really multiply two

27328
18:03:19,360 --> 18:03:21,596
strands if you try to multiply two

27329
18:03:21,596 --> 18:03:23,756
strands like we do here it's not going

27330
18:03:23,756 --> 18:03:26,480
to make sense what do you expect to get

27331
18:03:26,480 --> 18:03:28,636
if you multiply two strings it doesn't

27332
18:03:28,636 --> 18:03:30,400
make sense the compiler doesn't know

27333
18:03:30,400 --> 18:03:32,320
what to do with this operation it's

27334
18:03:32,320 --> 18:03:34,320
going to give you a compiler error okay

27335
18:03:34,320 --> 18:03:36,880
to really drive this home let's go back

27336
18:03:36,880 --> 18:03:39,276
to cpp insights

27337
18:03:39,276 --> 18:03:41,756
and put in the code here and see what is

27338
18:03:41,756 --> 18:03:43,840
generated by the compiler

27339
18:03:43,840 --> 18:03:45,756
you should use these tools to your

27340
18:03:45,756 --> 18:03:48,000
advantage because they really help in

27341
18:03:48,000 --> 18:03:50,480
understanding what is going on so let's

27342
18:03:50,480 --> 18:03:52,400
hit the play button here i just put in

27343
18:03:52,400 --> 18:03:54,240
my code and it is going to say

27344
18:03:54,240 --> 18:03:57,040
compilation failed because we have the

27345
18:03:57,040 --> 18:04:00,240
same error cpp insights needs to compile

27346
18:04:00,240 --> 18:04:01,916
the code correctly

27347
18:04:01,916 --> 18:04:05,116
to give you the template instantiations

27348
18:04:05,116 --> 18:04:07,436
but here you see that it is basically

27349
18:04:07,436 --> 18:04:10,240
giving us the same error let's try and

27350
18:04:10,240 --> 18:04:12,956
see the entire thing here and see if we

27351
18:04:12,956 --> 18:04:15,680
see the real error and we can't really

27352
18:04:15,680 --> 18:04:17,520
scroll around with this i'm having

27353
18:04:17,520 --> 18:04:20,000
trouble scrolling around here i can use

27354
18:04:20,000 --> 18:04:22,956
these buttons i guess okay so let's see

27355
18:04:22,956 --> 18:04:25,596
if we see the actual error and we're not

27356
18:04:25,596 --> 18:04:28,080
seeing it here auto result multiply

27357
18:04:28,080 --> 18:04:30,160
error generated so we're going to get an

27358
18:04:30,160 --> 18:04:32,320
error if we try to instantiate our

27359
18:04:32,320 --> 18:04:34,880
template with the types that we are

27360
18:04:34,880 --> 18:04:37,436
passing in here which are hdd strength

27361
18:04:37,436 --> 18:04:40,480
cpp insights isn't really helpful here

27362
18:04:40,480 --> 18:04:42,636
but hopefully you understand the problem

27363
18:04:42,636 --> 18:04:45,116
the problem is if the compiler tries to

27364
18:04:45,116 --> 18:04:49,040
generate a template instance using std

27365
18:04:49,040 --> 18:04:51,756
strand multiplying two strands isn't

27366
18:04:51,756 --> 18:04:53,520
going to make sense so the compiler is

27367
18:04:53,520 --> 18:04:55,596
going to give you a compiler error

27368
18:04:55,596 --> 18:04:57,916
because this is not supported so the

27369
18:04:57,916 --> 18:05:00,160
message here is that you should make

27370
18:05:00,160 --> 18:05:02,320
sure that the template instances

27371
18:05:02,320 --> 18:05:04,796
generated by the compilers support

27372
18:05:04,796 --> 18:05:08,000
whatever operations you are doing in the

27373
18:05:08,000 --> 18:05:10,160
body of your function template this is

27374
18:05:10,160 --> 18:05:11,840
the message here

27375
18:05:11,840 --> 18:05:13,360
another thing i want you to see before

27376
18:05:13,360 --> 18:05:15,596
we close this off i'm going to take out

27377
18:05:15,596 --> 18:05:16,400
this

27378
18:05:16,400 --> 18:05:18,400
problematic line here and we're going to

27379
18:05:18,400 --> 18:05:21,200
go back to our maximum function what i

27380
18:05:21,200 --> 18:05:23,276
want you to see is that if you pass

27381
18:05:23,276 --> 18:05:25,360
different types for this function

27382
18:05:25,360 --> 18:05:27,680
template you're going to get a compiler

27383
18:05:27,680 --> 18:05:30,000
error and what do i mean by that let's

27384
18:05:30,000 --> 18:05:32,560
take out our std strength because it's

27385
18:05:32,560 --> 18:05:35,680
no longer useful for our purposes here

27386
18:05:35,680 --> 18:05:38,796
and we're going to just use double and 8

27387
18:05:38,796 --> 18:05:42,240
parameters let's use ant here

27388
18:05:42,240 --> 18:05:43,520
and we

27389
18:05:43,520 --> 18:05:46,080
make this an intellectual

27390
18:05:46,080 --> 18:05:48,480
and then we call our maximum function

27391
18:05:48,480 --> 18:05:50,320
you see that we have a squiggly line

27392
18:05:50,320 --> 18:05:52,796
because the function template is forced

27393
18:05:52,796 --> 18:05:56,000
to use the same type for the return type

27394
18:05:56,000 --> 18:05:57,596
the first parameter and the second

27395
18:05:57,596 --> 18:06:00,160
parameter here because the placeholder

27396
18:06:00,160 --> 18:06:02,796
is the same so the compiler is supposed

27397
18:06:02,796 --> 18:06:04,956
to use the same thing for the first

27398
18:06:04,956 --> 18:06:07,520
argument here the second argument and

27399
18:06:07,520 --> 18:06:09,520
the return type that we get from this

27400
18:06:09,520 --> 18:06:11,680
maximum function here but the problem is

27401
18:06:11,680 --> 18:06:13,520
we are passing in parameters of

27402
18:06:13,520 --> 18:06:15,596
different types and this is going to

27403
18:06:15,596 --> 18:06:17,360
give us a compiler error because the

27404
18:06:17,360 --> 18:06:20,400
compiler want to know what to do with

27405
18:06:20,400 --> 18:06:23,520
the types that you pass in as arguments

27406
18:06:23,520 --> 18:06:26,636
and if we look at our problems tab here

27407
18:06:26,636 --> 18:06:29,116
visual studio code should give us an

27408
18:06:29,116 --> 18:06:31,840
error no match for operator uh this is

27409
18:06:31,840 --> 18:06:33,840
the error we had before we can try and

27410
18:06:33,840 --> 18:06:35,276
build again we're going to get a

27411
18:06:35,276 --> 18:06:38,320
compiler error again but this time it's

27412
18:06:38,320 --> 18:06:39,756
going to be different it's going to say

27413
18:06:39,756 --> 18:06:43,276
no instance of function template maximum

27414
18:06:43,276 --> 18:06:45,596
matches the argument list that we are

27415
18:06:45,596 --> 18:06:48,080
using here which is double and end

27416
18:06:48,080 --> 18:06:48,956
so

27417
18:06:48,956 --> 18:06:51,360
this is a problem but we will see ways

27418
18:06:51,360 --> 18:06:52,956
around this as we progress in the

27419
18:06:52,956 --> 18:06:55,596
chapter but what you should know

27420
18:06:55,596 --> 18:06:57,840
is that if we set up a function template

27421
18:06:57,840 --> 18:07:00,320
like this this is going to enforce for

27422
18:07:00,320 --> 18:07:03,040
all the types where we will place in t

27423
18:07:03,040 --> 18:07:05,596
to be the same if they're not the same

27424
18:07:05,596 --> 18:07:07,596
the compiler won't know how to do its

27425
18:07:07,596 --> 18:07:09,520
replacement and it is going to give you

27426
18:07:09,520 --> 18:07:11,596
a compiler error okay the last thing i

27427
18:07:11,596 --> 18:07:14,160
want you to see is that we can use the

27428
18:07:14,160 --> 18:07:17,436
debugger to debug function templates so

27429
18:07:17,436 --> 18:07:19,596
let's turn this back to end because we

27430
18:07:19,596 --> 18:07:21,436
wanted this to compile

27431
18:07:21,436 --> 18:07:24,560
so let's take out the decimal point here

27432
18:07:24,560 --> 18:07:27,596
so that we have proper intellectuals and

27433
18:07:27,596 --> 18:07:30,080
if we compile again this should compile

27434
18:07:30,080 --> 18:07:32,636
okay the world is good now what really

27435
18:07:32,636 --> 18:07:36,160
happens if you try to debug a program

27436
18:07:36,160 --> 18:07:36,956
with

27437
18:07:36,956 --> 18:07:38,480
function templates

27438
18:07:38,480 --> 18:07:40,720
are you going to be working on the

27439
18:07:40,720 --> 18:07:43,360
template instances because remember the

27440
18:07:43,360 --> 18:07:46,160
function templates are going to generate

27441
18:07:46,160 --> 18:07:48,480
function template instances with actual

27442
18:07:48,480 --> 18:07:50,880
types for example our template instance

27443
18:07:50,880 --> 18:07:53,116
here is going to have ants because we

27444
18:07:53,116 --> 18:07:56,956
are passing ant as argument here so how

27445
18:07:56,956 --> 18:07:59,116
are we exactly going to debug this let's

27446
18:07:59,116 --> 18:08:02,080
try this we're going to set up a break

27447
18:08:02,080 --> 18:08:03,360
point here

27448
18:08:03,360 --> 18:08:06,240
on the call to our maximum function

27449
18:08:06,240 --> 18:08:08,080
and we're going to start debugging we're

27450
18:08:08,080 --> 18:08:10,000
going to go to our

27451
18:08:10,000 --> 18:08:11,840
run tab here

27452
18:08:11,840 --> 18:08:13,520
and we're going to use the debugging

27453
18:08:13,520 --> 18:08:16,240
tools that come with gcc we have seen

27454
18:08:16,240 --> 18:08:18,796
how to do that in the last chapter and

27455
18:08:18,796 --> 18:08:20,560
we're going to start debugging let's

27456
18:08:20,560 --> 18:08:23,596
minimize this guy here so that we have

27457
18:08:23,596 --> 18:08:25,276
some breathing room

27458
18:08:25,276 --> 18:08:28,160
and we're going to run our debugger

27459
18:08:28,160 --> 18:08:30,880
let's maximize this a little bit

27460
18:08:30,880 --> 18:08:33,520
and push this a little to the left

27461
18:08:33,520 --> 18:08:35,200
and we're going to start debugging and

27462
18:08:35,200 --> 18:08:37,520
see what really happens here so we hit

27463
18:08:37,520 --> 18:08:39,276
the green button here we're going to

27464
18:08:39,276 --> 18:08:41,840
start debugging our code is building now

27465
18:08:41,840 --> 18:08:43,276
the build is done

27466
18:08:43,276 --> 18:08:45,680
the binary has been passed to the

27467
18:08:45,680 --> 18:08:48,240
debugger and now we have hit our break

27468
18:08:48,240 --> 18:08:50,796
point here so let's minimize this a

27469
18:08:50,796 --> 18:08:53,116
little bit so that we have an easier way

27470
18:08:53,116 --> 18:08:55,680
to see this we have hit or break point

27471
18:08:55,680 --> 18:08:57,360
you see the locals are what we have in

27472
18:08:57,360 --> 18:08:59,596
the main function which happens to be to

27473
18:08:59,596 --> 18:09:01,916
the top of the call stack here

27474
18:09:01,916 --> 18:09:03,596
okay now we want to jump into the

27475
18:09:03,596 --> 18:09:05,680
maximum function and see the types that

27476
18:09:05,680 --> 18:09:07,276
we have inside

27477
18:09:07,276 --> 18:09:09,596
so what we want to do here is head the

27478
18:09:09,596 --> 18:09:12,636
step into function and you notice it is

27479
18:09:12,636 --> 18:09:14,796
going to jump into our function template

27480
18:09:14,796 --> 18:09:17,756
here but the locals here are not giving

27481
18:09:17,756 --> 18:09:20,160
us the types and this is because this is

27482
18:09:20,160 --> 18:09:22,240
a function template it's not going to

27483
18:09:22,240 --> 18:09:24,320
give you the types

27484
18:09:24,320 --> 18:09:27,200
because it's not easy to get those here

27485
18:09:27,200 --> 18:09:30,160
but if we look at the call stack you see

27486
18:09:30,160 --> 18:09:32,400
that we have information about the types

27487
18:09:32,400 --> 18:09:34,160
of the function that is being called we

27488
18:09:34,160 --> 18:09:36,560
are calling it a and it b

27489
18:09:36,560 --> 18:09:38,480
and it is going to return and you see

27490
18:09:38,480 --> 18:09:40,636
that in the angle brackets here and

27491
18:09:40,636 --> 18:09:42,480
again this is possibly another way to

27492
18:09:42,480 --> 18:09:45,436
look at what template instances were

27493
18:09:45,436 --> 18:09:47,596
generated by the compiler because we see

27494
18:09:47,596 --> 18:09:49,520
the function called here is taken into

27495
18:09:49,520 --> 18:09:52,320
parameters and it is going to return end

27496
18:09:52,320 --> 18:09:54,880
let's kill our debugger because this is

27497
18:09:54,880 --> 18:09:57,116
really all we want to see and change the

27498
18:09:57,116 --> 18:09:59,200
types to double here and we're going to

27499
18:09:59,200 --> 18:10:01,596
see that the function to the top of the

27500
18:10:01,596 --> 18:10:03,520
call stack is going to be

27501
18:10:03,520 --> 18:10:06,240
taking double parameters so let's change

27502
18:10:06,240 --> 18:10:09,436
this back to five point something 5.5

27503
18:10:09,436 --> 18:10:13,360
maybe 7 and 0.9 why not and we're going

27504
18:10:13,360 --> 18:10:15,276
to print our results here

27505
18:10:15,276 --> 18:10:17,756
but uh what we really are interested in

27506
18:10:17,756 --> 18:10:21,436
is seeing the function template instance

27507
18:10:21,436 --> 18:10:23,360
generated by the compiler because of

27508
18:10:23,360 --> 18:10:25,200
this call here and we can do this

27509
18:10:25,200 --> 18:10:27,116
through the debugger this is a little

27510
18:10:27,116 --> 18:10:29,040
bit convoluted because you have to set

27511
18:10:29,040 --> 18:10:31,276
up breakpoints and whatever but it is

27512
18:10:31,276 --> 18:10:33,276
helpful if you don't want to use things

27513
18:10:33,276 --> 18:10:36,320
like cpp insights as we have seen before

27514
18:10:36,320 --> 18:10:38,320
and again this is also useful because

27515
18:10:38,320 --> 18:10:40,400
you will need to debug your code if it

27516
18:10:40,400 --> 18:10:42,480
is using function templates let's run

27517
18:10:42,480 --> 18:10:45,276
this to really prove our point here

27518
18:10:45,276 --> 18:10:47,276
the world is going to go through the

27519
18:10:47,276 --> 18:10:49,360
binary executable is going to be passed

27520
18:10:49,360 --> 18:10:50,240
into

27521
18:10:50,240 --> 18:10:52,080
the debugger and we're going to hit our

27522
18:10:52,080 --> 18:10:55,040
breakpoint here again you see our locals

27523
18:10:55,040 --> 18:10:57,680
are not giving us the types here but we

27524
18:10:57,680 --> 18:10:59,200
cannot use

27525
18:10:59,200 --> 18:11:01,116
the function call stack to really see

27526
18:11:01,116 --> 18:11:03,436
this we have hit the breakpoint here at

27527
18:11:03,436 --> 18:11:06,400
line 15 so we can step into the call

27528
18:11:06,400 --> 18:11:09,360
and if we hit the body of the maximum

27529
18:11:09,360 --> 18:11:12,880
function here and look at the call stack

27530
18:11:12,880 --> 18:11:15,520
we're going to see that the parameters

27531
18:11:15,520 --> 18:11:18,880
we have in our function call are of

27532
18:11:18,880 --> 18:11:21,116
double type and again this hopefully

27533
18:11:21,116 --> 18:11:22,720
proves to us

27534
18:11:22,720 --> 18:11:25,680
that the compiler has actually generated

27535
18:11:25,680 --> 18:11:26,956
a double

27536
18:11:26,956 --> 18:11:29,756
function template instance okay since we

27537
18:11:29,756 --> 18:11:31,680
are debugging we can actually try and

27538
18:11:31,680 --> 18:11:35,116
follow this program let's hit next so

27539
18:11:35,116 --> 18:11:37,200
that we can hit the end of this function

27540
18:11:37,200 --> 18:11:38,400
we can

27541
18:11:38,400 --> 18:11:40,956
finish it and hit the main function by

27542
18:11:40,956 --> 18:11:43,200
the moment we hit the main function

27543
18:11:43,200 --> 18:11:46,000
results is going to be 7.9 which is what

27544
18:11:46,000 --> 18:11:47,520
we have here and it is what we're going

27545
18:11:47,520 --> 18:11:49,756
to print we can just step over this

27546
18:11:49,756 --> 18:11:51,520
because we don't want to step into the

27547
18:11:51,520 --> 18:11:54,400
logics of sddc out so step over we're

27548
18:11:54,400 --> 18:11:56,240
going to print our result and our

27549
18:11:56,240 --> 18:11:58,400
debugging session is going to basically

27550
18:11:58,400 --> 18:12:01,040
end because we have hit the end of the

27551
18:12:01,040 --> 18:12:03,520
main function let's try and use the

27552
18:12:03,520 --> 18:12:06,160
compiler from microsoft to see the

27553
18:12:06,160 --> 18:12:08,480
information it gives us because these

27554
18:12:08,480 --> 18:12:10,480
things can be different depending on the

27555
18:12:10,480 --> 18:12:12,796
compiler and the debugging tools that

27556
18:12:12,796 --> 18:12:15,040
you are using we have the luxury to have

27557
18:12:15,040 --> 18:12:17,836
these two set up here so all we have to

27558
18:12:17,836 --> 18:12:19,756
do is switch the tool we want to use

27559
18:12:19,756 --> 18:12:22,244
here and this is going to be using the

27560
18:12:22,244 --> 18:12:24,720
one from microsoft if you are not on

27561
18:12:24,720 --> 18:12:27,436
windows or you don't want to use the

27562
18:12:27,436 --> 18:12:30,244
compiler from microsoft and its

27563
18:12:30,244 --> 18:12:33,116
debugging tools you can just use gcc and

27564
18:12:33,116 --> 18:12:35,360
its debugging tools here i just want you

27565
18:12:35,360 --> 18:12:37,116
to see different ways to do the same

27566
18:12:37,116 --> 18:12:39,436
things and that compilers and debuggers

27567
18:12:39,436 --> 18:12:42,080
can give us different information we're

27568
18:12:42,080 --> 18:12:44,000
going to try and debug with this so

27569
18:12:44,000 --> 18:12:46,000
we're going to hit the green button here

27570
18:12:46,000 --> 18:12:47,600
notice that this is going to be using

27571
18:12:47,600 --> 18:12:50,640
the compiler from microsoft if we look

27572
18:12:50,640 --> 18:12:53,116
at the world output here you see that we

27573
18:12:53,116 --> 18:12:55,600
are calling cl.exe

27574
18:12:55,600 --> 18:12:57,756
it is what we are using to build our

27575
18:12:57,756 --> 18:13:00,080
binary the binary is going to be passed

27576
18:13:00,080 --> 18:13:02,156
to the debugger and then we're going to

27577
18:13:02,156 --> 18:13:05,516
hit the breakpoint here as we know

27578
18:13:05,516 --> 18:13:07,600
and then we're going to have our output

27579
18:13:07,600 --> 18:13:10,000
here these are our locals

27580
18:13:10,000 --> 18:13:12,476
you see in the main function we don't

27581
18:13:12,476 --> 18:13:15,280
see the types of our locals why is that

27582
18:13:15,280 --> 18:13:17,600
i don't know why but we see the values

27583
18:13:17,600 --> 18:13:19,920
here in the main function

27584
18:13:19,920 --> 18:13:23,040
and if we hit the step into button to

27585
18:13:23,040 --> 18:13:25,756
jump into our maximum function a is

27586
18:13:25,756 --> 18:13:27,516
going to have this value b is going to

27587
18:13:27,516 --> 18:13:30,476
have this value and we look at the

27588
18:13:30,476 --> 18:13:32,244
template instance we can see the same

27589
18:13:32,244 --> 18:13:34,796
information but we are using a different

27590
18:13:34,796 --> 18:13:37,196
compiler this is really how you can

27591
18:13:37,196 --> 18:13:40,080
debug your code that uses function

27592
18:13:40,080 --> 18:13:42,556
templates and this is going to give us a

27593
18:13:42,556 --> 18:13:46,000
peek into the actual template instance

27594
18:13:46,000 --> 18:13:49,196
that was generated by our compiler this

27595
18:13:49,196 --> 18:13:51,360
is really all i had to share in this

27596
18:13:51,360 --> 18:13:53,436
lecture and before i let you go let's

27597
18:13:53,436 --> 18:13:55,516
summarize a little bit function

27598
18:13:55,516 --> 18:13:57,360
templates are blueprints we have seen

27599
18:13:57,360 --> 18:13:59,280
that the compiler is going to use those

27600
18:13:59,280 --> 18:14:01,600
to generate actual function template

27601
18:14:01,600 --> 18:14:04,400
instances real function definitions and

27602
18:14:04,400 --> 18:14:05,116
uh

27603
18:14:05,116 --> 18:14:07,196
declarations are going to be created

27604
18:14:07,196 --> 18:14:08,876
when you call the function with

27605
18:14:08,876 --> 18:14:11,516
arguments if the template parameters are

27606
18:14:11,516 --> 18:14:14,556
of the same type maybe t and t then the

27607
18:14:14,556 --> 18:14:16,476
arguments you call the function with

27608
18:14:16,476 --> 18:14:18,400
must also match otherwise you'll get a

27609
18:14:18,400 --> 18:14:20,556
compiler error we have seen this okay

27610
18:14:20,556 --> 18:14:22,876
here we have a point we haven't already

27611
18:14:22,876 --> 18:14:25,116
covered template instances won't always

27612
18:14:25,116 --> 18:14:27,360
do what you want a good example is when

27613
18:14:27,360 --> 18:14:29,196
you call our maximum function with

27614
18:14:29,196 --> 18:14:31,436
pointers so let's go back and really say

27615
18:14:31,436 --> 18:14:32,244
this

27616
18:14:32,244 --> 18:14:34,796
because i want this to cover as much as

27617
18:14:34,796 --> 18:14:37,360
possible about function templates

27618
18:14:37,360 --> 18:14:39,600
so let's go back to our code and we're

27619
18:14:39,600 --> 18:14:41,436
going to modify things a little bit okay

27620
18:14:41,436 --> 18:14:42,960
so what we're going to do here is take

27621
18:14:42,960 --> 18:14:44,400
out whatever we have here we're going to

27622
18:14:44,400 --> 18:14:47,280
set up into variables x and y

27623
18:14:47,280 --> 18:14:49,280
x is going to be 5 as we have seen

27624
18:14:49,280 --> 18:14:51,280
before and

27625
18:14:51,280 --> 18:14:54,320
y is going to be seven let's use this

27626
18:14:54,320 --> 18:14:55,516
and then we're going to set up two

27627
18:14:55,516 --> 18:14:57,116
pointer variables we're going to say

27628
18:14:57,116 --> 18:14:58,400
endpointer

27629
18:14:58,400 --> 18:15:00,556
px and we're going to initialize this

27630
18:15:00,556 --> 18:15:02,640
with the address of x nothing

27631
18:15:02,640 --> 18:15:04,640
sophisticated so far and we're going to

27632
18:15:04,640 --> 18:15:06,796
say end p y and we're going to

27633
18:15:06,796 --> 18:15:09,516
initialize this with the address of y we

27634
18:15:09,516 --> 18:15:11,756
can do this the problem is going to come

27635
18:15:11,756 --> 18:15:14,156
when we try to call our function here

27636
18:15:14,156 --> 18:15:15,436
with the

27637
18:15:15,436 --> 18:15:18,476
pointers let's use px and py to call

27638
18:15:18,476 --> 18:15:21,280
this function and py and what this is

27639
18:15:21,280 --> 18:15:24,244
going to do is to generate a template

27640
18:15:24,244 --> 18:15:26,476
instance that takes end pointer this is

27641
18:15:26,476 --> 18:15:28,080
what the compiler knows to do we're

27642
18:15:28,080 --> 18:15:30,000
going to take the types that we pass in

27643
18:15:30,000 --> 18:15:32,796
here which happen to be end pointer and

27644
18:15:32,796 --> 18:15:34,720
we're going to change the return type to

27645
18:15:34,720 --> 18:15:36,080
end pointer we're going to change the

27646
18:15:36,080 --> 18:15:37,920
first parameter to end pointer the

27647
18:15:37,920 --> 18:15:39,836
second parameter to end pointer and

27648
18:15:39,836 --> 18:15:41,920
we're going to compute the maximum

27649
18:15:41,920 --> 18:15:43,680
if we compute the maximum here we're

27650
18:15:43,680 --> 18:15:46,156
going to be comparing pointers okay

27651
18:15:46,156 --> 18:15:48,876
notice this and if we try to do that we

27652
18:15:48,876 --> 18:15:51,756
might not get what we want because what

27653
18:15:51,756 --> 18:15:55,280
we get now depends on the address used

27654
18:15:55,280 --> 18:15:57,360
to store these guys in memory hopefully

27655
18:15:57,360 --> 18:16:00,156
you can see that and let's try and debug

27656
18:16:00,156 --> 18:16:02,476
this program so that you can really see

27657
18:16:02,476 --> 18:16:06,876
this we're going to use the tools from g

27658
18:16:06,876 --> 18:16:09,040
plus plus or gcc

27659
18:16:09,040 --> 18:16:10,476
and we're going to try and debug it

27660
18:16:10,476 --> 18:16:13,280
let's do that it is going to run through

27661
18:16:13,280 --> 18:16:15,116
the debugger and what we're going to

27662
18:16:15,116 --> 18:16:18,000
have is our terminal here i think this

27663
18:16:18,000 --> 18:16:20,556
is not needed anymore so let's put this

27664
18:16:20,556 --> 18:16:23,196
to the right here and minimize a little

27665
18:16:23,196 --> 18:16:27,196
bit and now you notice that px contains

27666
18:16:27,196 --> 18:16:30,244
an address and py contains an address

27667
18:16:30,244 --> 18:16:32,244
hopefully you can see that in the body

27668
18:16:32,244 --> 18:16:34,000
of our template instance we're going to

27669
18:16:34,000 --> 18:16:36,720
be comparing these addresses because

27670
18:16:36,720 --> 18:16:38,796
we're comparing what we pass by value

27671
18:16:38,796 --> 18:16:40,796
here and what we pass are these two

27672
18:16:40,796 --> 18:16:43,920
addresses so whichever is the maximum in

27673
18:16:43,920 --> 18:16:46,080
these guys and i think that's going to

27674
18:16:46,080 --> 18:16:49,600
be dd4 here it is the maximum so

27675
18:16:49,600 --> 18:16:52,244
whatever is contained in px is going to

27676
18:16:52,244 --> 18:16:55,280
be considered the maximum let's kill

27677
18:16:55,280 --> 18:16:56,640
this because we have seen this

27678
18:16:56,640 --> 18:16:59,436
information so if we have a value in px

27679
18:16:59,436 --> 18:17:01,756
and that happens to be at a bigger

27680
18:17:01,756 --> 18:17:03,600
address it's going to be considered the

27681
18:17:03,600 --> 18:17:05,680
maximum let's see what we print if we

27682
18:17:05,680 --> 18:17:07,360
run this program we're going to build

27683
18:17:07,360 --> 18:17:10,876
with gcc let's do that the world is good

27684
18:17:10,876 --> 18:17:12,476
we can clear

27685
18:17:12,476 --> 18:17:15,516
and run rooster now you see result is

27686
18:17:15,516 --> 18:17:17,920
some address because we are returning a

27687
18:17:17,920 --> 18:17:20,000
pointer and printing that out but we can

27688
18:17:20,000 --> 18:17:22,400
easily dereference this and get to the

27689
18:17:22,400 --> 18:17:25,280
value inside this pointer let's build

27690
18:17:25,280 --> 18:17:28,244
again we can clear and run rooster this

27691
18:17:28,244 --> 18:17:30,796
is going to give us result is 5 and

27692
18:17:30,796 --> 18:17:32,244
hopefully you can see that this is

27693
18:17:32,244 --> 18:17:35,600
really bad and not correct we are trying

27694
18:17:35,600 --> 18:17:38,400
to compute the maximum between x and y

27695
18:17:38,400 --> 18:17:41,600
and we are seeing that the maximum is

27696
18:17:41,600 --> 18:17:44,556
five so how can five beat the maximum

27697
18:17:44,556 --> 18:17:46,960
between five and seven the problem is

27698
18:17:46,960 --> 18:17:49,360
we're not comparing the values here we

27699
18:17:49,360 --> 18:17:52,556
are comparing the addresses stored in

27700
18:17:52,556 --> 18:17:54,244
these pointers because that's what we

27701
18:17:54,244 --> 18:17:55,680
are passing here hopefully you can

27702
18:17:55,680 --> 18:17:57,836
really see this and we can prove this

27703
18:17:57,836 --> 18:18:00,796
again through our debugger we can run

27704
18:18:00,796 --> 18:18:03,280
this through the debugger we're going to

27705
18:18:03,280 --> 18:18:05,600
hit the breakpoint let's minimize this

27706
18:18:05,600 --> 18:18:07,680
so that we can see our terminal window

27707
18:18:07,680 --> 18:18:09,680
here and we're going to move this around

27708
18:18:09,680 --> 18:18:11,836
a little bit and now we have hit our

27709
18:18:11,836 --> 18:18:14,720
break point if we hit next to jump into

27710
18:18:14,720 --> 18:18:16,796
the function you see that what we are

27711
18:18:16,796 --> 18:18:20,000
really comparing are a and b here and a

27712
18:18:20,000 --> 18:18:22,720
contains a much larger address so it is

27713
18:18:22,720 --> 18:18:25,116
the pointer that is going to be returned

27714
18:18:25,116 --> 18:18:27,516
and if we dereference that we're going

27715
18:18:27,516 --> 18:18:29,680
to be dereferencing the pointer that

27716
18:18:29,680 --> 18:18:32,640
contains this x value and the message

27717
18:18:32,640 --> 18:18:35,436
here is that you should be careful

27718
18:18:35,436 --> 18:18:37,196
that your function templates are really

27719
18:18:37,196 --> 18:18:39,280
what doing what you want somebody might

27720
18:18:39,280 --> 18:18:41,600
do this if they are not careful just

27721
18:18:41,600 --> 18:18:43,680
pass in pointer and expect to get the

27722
18:18:43,680 --> 18:18:46,156
maximum but the compiler is just going

27723
18:18:46,156 --> 18:18:49,040
to compare pointer addresses and you're

27724
18:18:49,040 --> 18:18:50,960
going to get something you probably

27725
18:18:50,960 --> 18:18:53,360
don't expect okay this is what is meant

27726
18:18:53,360 --> 18:18:55,756
by template instances won't always do

27727
18:18:55,756 --> 18:18:57,600
what you want a good example is when you

27728
18:18:57,600 --> 18:18:59,836
call a maximum function with pointers

27729
18:18:59,836 --> 18:19:01,756
you're going to get a wrong value

27730
18:19:01,756 --> 18:19:04,000
possibly there are tools like cpp

27731
18:19:04,000 --> 18:19:05,920
insights which can show the template in

27732
18:19:05,920 --> 18:19:07,756
spatial instruments we have seen that

27733
18:19:07,756 --> 18:19:10,320
and again the arguments passed to a

27734
18:19:10,320 --> 18:19:12,156
function template must support the

27735
18:19:12,156 --> 18:19:14,796
operations that you are doing in your

27736
18:19:14,796 --> 18:19:16,556
function template we have seen an

27737
18:19:16,556 --> 18:19:18,244
example of this by setting up a

27738
18:19:18,244 --> 18:19:20,400
multiplication function template and we

27739
18:19:20,400 --> 18:19:22,720
saw that we had a compiler error if we

27740
18:19:22,720 --> 18:19:25,436
try to pass std strength arguments

27741
18:19:25,436 --> 18:19:27,756
because we can't multiply two strings

27742
18:19:27,756 --> 18:19:30,000
this is really all i had to share in

27743
18:19:30,000 --> 18:19:32,400
this lecture i apologize it turned out

27744
18:19:32,400 --> 18:19:35,040
to be lengthy but i really had to put

27745
18:19:35,040 --> 18:19:37,360
this in one lecture so that i can really

27746
18:19:37,360 --> 18:19:39,680
show you different sides of the same

27747
18:19:39,680 --> 18:19:42,080
things we are going to stop here in this

27748
18:19:42,080 --> 18:19:43,756
lecture and the next one we're going to

27749
18:19:43,756 --> 18:19:46,960
learn about template type deduction and

27750
18:19:46,960 --> 18:19:49,116
explicit arguments

27751
18:19:49,116 --> 18:19:50,960
go ahead and finish up here

27752
18:19:50,960 --> 18:19:52,640
and meet me there

27753
18:19:52,640 --> 18:19:53,920
in this lecture we're going to learn

27754
18:19:53,920 --> 18:19:56,640
about template type deduction and

27755
18:19:56,640 --> 18:19:59,680
explicit arguments what we mean by

27756
18:19:59,680 --> 18:20:02,960
template type deduction is the mechanism

27757
18:20:02,960 --> 18:20:04,960
the compiler uses

27758
18:20:04,960 --> 18:20:08,080
to deduce the type it would use to

27759
18:20:08,080 --> 18:20:10,476
set up our template instance from the

27760
18:20:10,476 --> 18:20:12,796
arguments that we passed to our function

27761
18:20:12,796 --> 18:20:14,244
call here

27762
18:20:14,244 --> 18:20:15,756
for example the compiler is going to

27763
18:20:15,756 --> 18:20:18,080
look at a and b here in a call to the

27764
18:20:18,080 --> 18:20:20,244
maximum function and it is going to

27765
18:20:20,244 --> 18:20:22,400
notice that they are of into type and

27766
18:20:22,400 --> 18:20:24,720
then it is going to say okay you are

27767
18:20:24,720 --> 18:20:27,280
calling your function with it types and

27768
18:20:27,280 --> 18:20:30,156
i see that your function templates takes

27769
18:20:30,156 --> 18:20:33,436
three replacers in here so i am going to

27770
18:20:33,436 --> 18:20:36,080
replace these guys with and and it is

27771
18:20:36,080 --> 18:20:38,080
going to guess that from the call that

27772
18:20:38,080 --> 18:20:40,640
you make here there's no other mechanism

27773
18:20:40,640 --> 18:20:42,796
to help the compiler out this is really

27774
18:20:42,796 --> 18:20:45,516
what template type deduction is about

27775
18:20:45,516 --> 18:20:47,360
and for the first example here we are

27776
18:20:47,360 --> 18:20:50,000
passing an end parameter so

27777
18:20:50,000 --> 18:20:52,080
nt is going to be deduced for the second

27778
18:20:52,080 --> 18:20:55,196
function call we are passing in double

27779
18:20:55,196 --> 18:20:57,436
parameter so a double function template

27780
18:20:57,436 --> 18:20:59,680
instance is going to be generated for

27781
18:20:59,680 --> 18:21:02,400
the third call here we are using std

27782
18:21:02,400 --> 18:21:04,156
string parameters

27783
18:21:04,156 --> 18:21:07,280
so we are going to deduce a template

27784
18:21:07,280 --> 18:21:10,080
instance that uses hdd string here this

27785
18:21:10,080 --> 18:21:12,476
is what we mean by template type

27786
18:21:12,476 --> 18:21:14,556
deduction but we have seen that

27787
18:21:14,556 --> 18:21:17,280
automatic template type deduction can

27788
18:21:17,280 --> 18:21:19,756
really have problems especially if you

27789
18:21:19,756 --> 18:21:22,556
pass parameters of different types for

27790
18:21:22,556 --> 18:21:24,720
example if we call a maximum function

27791
18:21:24,720 --> 18:21:26,320
here with

27792
18:21:26,320 --> 18:21:29,196
a and c which happen to be end and

27793
18:21:29,196 --> 18:21:31,040
double type then we're going to have a

27794
18:21:31,040 --> 18:21:33,436
problem because this function template

27795
18:21:33,436 --> 18:21:34,796
can't handle

27796
18:21:34,796 --> 18:21:37,516
parameters with different types because

27797
18:21:37,516 --> 18:21:40,080
the replacer is the same the compiler is

27798
18:21:40,080 --> 18:21:42,876
going to enforce that all the template

27799
18:21:42,876 --> 18:21:45,360
arguments are of the same type and the

27800
18:21:45,360 --> 18:21:47,116
template arguments are going to be what

27801
18:21:47,116 --> 18:21:49,516
you pass in here so a and b must be the

27802
18:21:49,516 --> 18:21:51,836
same if they happen to be not the same

27803
18:21:51,836 --> 18:21:53,836
for example ant and double you're going

27804
18:21:53,836 --> 18:21:55,516
to get a compiler error

27805
18:21:55,516 --> 18:21:57,436
now we're going to see that we can use

27806
18:21:57,436 --> 18:22:00,720
explicit template arguments and again i

27807
18:22:00,720 --> 18:22:02,556
want to make it very clear the

27808
18:22:02,556 --> 18:22:05,360
difference between a template parameter

27809
18:22:05,360 --> 18:22:07,756
and the template argument a template

27810
18:22:07,756 --> 18:22:09,756
parameter is what you have in your

27811
18:22:09,756 --> 18:22:12,156
function declaration or a definition so

27812
18:22:12,156 --> 18:22:15,040
what we have in our function setup here

27813
18:22:15,040 --> 18:22:16,476
are template

27814
18:22:16,476 --> 18:22:20,000
parameters ta here and tb are template

27815
18:22:20,000 --> 18:22:22,796
parameters but what we have when we call

27816
18:22:22,796 --> 18:22:25,360
a function template is going to be

27817
18:22:25,360 --> 18:22:28,476
template arguments for example c and d

27818
18:22:28,476 --> 18:22:29,360
here

27819
18:22:29,360 --> 18:22:31,600
are template arguments and we're going

27820
18:22:31,600 --> 18:22:34,080
to be using this terminology in this

27821
18:22:34,080 --> 18:22:36,720
chapter and many more chapters to come

27822
18:22:36,720 --> 18:22:38,556
in this course make sure this is super

27823
18:22:38,556 --> 18:22:40,720
clear so what we're going to look at is

27824
18:22:40,720 --> 18:22:44,796
using explicit template arguments and

27825
18:22:44,796 --> 18:22:46,400
what this means

27826
18:22:46,400 --> 18:22:48,640
is a mechanism through which you can

27827
18:22:48,640 --> 18:22:51,756
force the compiler to use some type to

27828
18:22:51,756 --> 18:22:53,920
generate your template instance and the

27829
18:22:53,920 --> 18:22:56,000
syntax to do this is really simple it is

27830
18:22:56,000 --> 18:22:58,640
what we have here we say maximum and we

27831
18:22:58,640 --> 18:23:00,400
put the type we want

27832
18:23:00,400 --> 18:23:03,116
to use to generate our template instance

27833
18:23:03,116 --> 18:23:05,040
in angle brackets like we see here so

27834
18:23:05,040 --> 18:23:07,116
this is going to use double so this is

27835
18:23:07,116 --> 18:23:10,000
going to explicitly tell the compiler we

27836
18:23:10,000 --> 18:23:12,400
want the double version called and it's

27837
18:23:12,400 --> 18:23:14,400
going to generate that and that's what

27838
18:23:14,400 --> 18:23:16,556
is going to be called by this call we

27839
18:23:16,556 --> 18:23:18,960
have here a good benefit with this is

27840
18:23:18,960 --> 18:23:21,436
that now this is going to support

27841
18:23:21,436 --> 18:23:24,080
template arguments of different types so

27842
18:23:24,080 --> 18:23:25,756
if we make the call like this the

27843
18:23:25,756 --> 18:23:27,756
compiler is going to see that uh-huh we

27844
18:23:27,756 --> 18:23:30,156
are calling with intent double types

27845
18:23:30,156 --> 18:23:33,680
because a is ant and c is double

27846
18:23:33,680 --> 18:23:36,156
but it's going to see that you want

27847
18:23:36,156 --> 18:23:36,876
the

27848
18:23:36,876 --> 18:23:39,920
double template instance generated now

27849
18:23:39,920 --> 18:23:42,400
the compiler will have the possibility

27850
18:23:42,400 --> 18:23:45,040
to do implicit conversions from other

27851
18:23:45,040 --> 18:23:47,756
types to double and if this implicit

27852
18:23:47,756 --> 18:23:50,000
conversion fails then we're going to get

27853
18:23:50,000 --> 18:23:52,156
a compiler error so if you look here for

27854
18:23:52,156 --> 18:23:53,116
example

27855
18:23:53,116 --> 18:23:54,876
this is the example for that we are

27856
18:23:54,876 --> 18:23:59,360
passing in a and e and a is ant and e is

27857
18:23:59,360 --> 18:24:02,000
an std strength we cannot do an implicit

27858
18:24:02,000 --> 18:24:03,600
conversion from

27859
18:24:03,600 --> 18:24:06,156
std strength to double so this is going

27860
18:24:06,156 --> 18:24:08,156
to give us a compiler error and this is

27861
18:24:08,156 --> 18:24:11,516
really all template type deduction and

27862
18:24:11,516 --> 18:24:14,080
explicit arguments are about we can use

27863
18:24:14,080 --> 18:24:15,836
these things to really make our code

27864
18:24:15,836 --> 18:24:18,640
easier now that you have this understood

27865
18:24:18,640 --> 18:24:20,156
we're going to head over to visual

27866
18:24:20,156 --> 18:24:21,680
studio code and play with this a little

27867
18:24:21,680 --> 18:24:24,156
more here we are in our working

27868
18:24:24,156 --> 18:24:26,244
directory the current project is

27869
18:24:26,244 --> 18:24:29,116
template type deductions and explicit

27870
18:24:29,116 --> 18:24:31,360
arguments we're going to grab our

27871
18:24:31,360 --> 18:24:33,836
template files pretty quick and put them

27872
18:24:33,836 --> 18:24:36,080
in place and after that we're going to

27873
18:24:36,080 --> 18:24:38,156
open this in visual studio code let's

27874
18:24:38,156 --> 18:24:40,556
drag and drop on top of visual studio

27875
18:24:40,556 --> 18:24:42,720
code here this is going to open our

27876
18:24:42,720 --> 18:24:46,400
folder and we can open our main cpp file

27877
18:24:46,400 --> 18:24:47,436
and

27878
18:24:47,436 --> 18:24:49,836
set up our function template let's clean

27879
18:24:49,836 --> 18:24:51,680
this up a little bit and we're going to

27880
18:24:51,680 --> 18:24:54,476
set up our function template let's type

27881
18:24:54,476 --> 18:24:56,400
this out to just to practice so we're

27882
18:24:56,400 --> 18:24:58,640
going to say template and we're going to

27883
18:24:58,640 --> 18:25:01,196
say type name and we're going to say t

27884
18:25:01,196 --> 18:25:02,960
and if you want you can put this on a

27885
18:25:02,960 --> 18:25:05,756
single line but i prefer to put this on

27886
18:25:05,756 --> 18:25:08,320
separate lines but let's show you that

27887
18:25:08,320 --> 18:25:10,476
so we're going to say t here and we're

27888
18:25:10,476 --> 18:25:12,320
going to say maximum and we're going to

27889
18:25:12,320 --> 18:25:14,400
say the parameters they are going to be

27890
18:25:14,400 --> 18:25:17,756
of type t and we can pass them by value

27891
18:25:17,756 --> 18:25:19,360
just for now and after this we're going

27892
18:25:19,360 --> 18:25:21,836
to go in the body of our function

27893
18:25:21,836 --> 18:25:23,600
template and then we can return

27894
18:25:23,600 --> 18:25:26,720
whichever parameter is the maximum we're

27895
18:25:26,720 --> 18:25:28,796
going to say a greater than b here we're

27896
18:25:28,796 --> 18:25:31,516
going to use our ternary operator and if

27897
18:25:31,516 --> 18:25:34,000
a is greater we're going to return a if

27898
18:25:34,000 --> 18:25:36,320
b is greater we're going to return b and

27899
18:25:36,320 --> 18:25:38,320
this is our function here okay now that

27900
18:25:38,320 --> 18:25:40,400
this function is set up let's set up a

27901
18:25:40,400 --> 18:25:42,720
few variables to really play with that

27902
18:25:42,720 --> 18:25:44,960
so we're going to include the string

27903
18:25:44,960 --> 18:25:46,876
library because we're going to be using

27904
18:25:46,876 --> 18:25:49,116
it a little bit and we're going to go

27905
18:25:49,116 --> 18:25:52,476
down in the main function and put in our

27906
18:25:52,476 --> 18:25:56,476
few variables we have a through f here a

27907
18:25:56,476 --> 18:26:00,156
and b are end c and d are of type double

27908
18:26:00,156 --> 18:26:04,156
and e and f are of type std strand the

27909
18:26:04,156 --> 18:26:06,244
first thing we can do we can say auto

27910
18:26:06,244 --> 18:26:09,196
max and we can assign whichever is the

27911
18:26:09,196 --> 18:26:11,920
maximum between a and b and once we do

27912
18:26:11,920 --> 18:26:13,756
this we're going to have that maximum

27913
18:26:13,756 --> 18:26:16,796
stored in max here but what i want you

27914
18:26:16,796 --> 18:26:19,680
to see is what the compiler does when it

27915
18:26:19,680 --> 18:26:22,640
sees the code like this the compiler has

27916
18:26:22,640 --> 18:26:25,116
no other outside help

27917
18:26:25,116 --> 18:26:28,320
to know the function template instance

27918
18:26:28,320 --> 18:26:30,476
it should really generate it is going to

27919
18:26:30,476 --> 18:26:33,040
look at the types we have here a and b

27920
18:26:33,040 --> 18:26:34,876
it's going to see that they are of type

27921
18:26:34,876 --> 18:26:38,000
and it's going to see that it can use

27922
18:26:38,000 --> 18:26:40,156
the function template we have here and

27923
18:26:40,156 --> 18:26:41,920
it's going to use that and generate a

27924
18:26:41,920 --> 18:26:43,280
template instance that it's going to

27925
18:26:43,280 --> 18:26:45,600
take and and it is going to call it to

27926
18:26:45,600 --> 18:26:48,080
get our maximum here again we can prove

27927
18:26:48,080 --> 18:26:50,080
this through the debugger we're going to

27928
18:26:50,080 --> 18:26:51,836
set up a breakpoint we're going to go to

27929
18:26:51,836 --> 18:26:55,280
our run tab here and we're going to run

27930
18:26:55,280 --> 18:26:57,360
this through our debugger

27931
18:26:57,360 --> 18:26:59,436
we're going to build our thing and when

27932
18:26:59,436 --> 18:27:01,920
we hit the main function you're going to

27933
18:27:01,920 --> 18:27:05,040
see that a is 10 b is 23 which is what

27934
18:27:05,040 --> 18:27:08,400
we have here cd we have our values n and

27935
18:27:08,400 --> 18:27:11,196
std string because it is a compound type

27936
18:27:11,196 --> 18:27:13,920
or a custom type we can expand on this

27937
18:27:13,920 --> 18:27:15,516
and really see more information about

27938
18:27:15,516 --> 18:27:17,680
this but we don't have enough tools to

27939
18:27:17,680 --> 18:27:19,836
really understand this by now so we're

27940
18:27:19,836 --> 18:27:22,796
going to just to use this as a wrapper

27941
18:27:22,796 --> 18:27:25,280
on our stream information here now we

27942
18:27:25,280 --> 18:27:27,360
want to call the maximum function and

27943
18:27:27,360 --> 18:27:30,244
see what was generated by the compiler

27944
18:27:30,244 --> 18:27:32,080
and we can step into this function

27945
18:27:32,080 --> 18:27:34,000
because we have hit the breakpoint by

27946
18:27:34,000 --> 18:27:34,796
now

27947
18:27:34,796 --> 18:27:37,280
so if we hit step into we're going to

27948
18:27:37,280 --> 18:27:39,280
step into this function and we're going

27949
18:27:39,280 --> 18:27:41,756
to see that it is an int function

27950
18:27:41,756 --> 18:27:44,244
instance that was generated this is

27951
18:27:44,244 --> 18:27:46,400
enough for our purposes

27952
18:27:46,400 --> 18:27:49,360
if we change our call here to use c and

27953
18:27:49,360 --> 18:27:51,116
d we're going to generate a double

27954
18:27:51,116 --> 18:27:53,360
instance so let's do that we're going to

27955
18:27:53,360 --> 18:27:55,360
generate a double instance and if we

27956
18:27:55,360 --> 18:27:56,960
print this out we're going to see this

27957
18:27:56,960 --> 18:27:59,196
printed out but we can use the debugger

27958
18:27:59,196 --> 18:28:01,116
to really prove this not that we know

27959
18:28:01,116 --> 18:28:03,196
how to use it we don't have to look

27960
18:28:03,196 --> 18:28:05,516
through the terminal output window but

27961
18:28:05,516 --> 18:28:07,280
you can do that if you want you can set

27962
18:28:07,280 --> 18:28:09,680
up sddc out and print max here you're

27963
18:28:09,680 --> 18:28:12,244
going to see it printed out so let's run

27964
18:28:12,244 --> 18:28:13,920
our debugger we're going to see the

27965
18:28:13,920 --> 18:28:16,400
template instance that was generated

27966
18:28:16,400 --> 18:28:18,400
through the divider we're going to hit

27967
18:28:18,400 --> 18:28:21,280
the breakpoint at line 17 here

27968
18:28:21,280 --> 18:28:23,516
if we step inside we're going to see the

27969
18:28:23,516 --> 18:28:25,836
local variables for our function here a

27970
18:28:25,836 --> 18:28:26,796
and b

27971
18:28:26,796 --> 18:28:29,116
and we're going to have the maximum

27972
18:28:29,116 --> 18:28:31,516
function to the top of the call stack

27973
18:28:31,516 --> 18:28:33,360
and you're going to see that it is a

27974
18:28:33,360 --> 18:28:35,836
double instance for our function

27975
18:28:35,836 --> 18:28:37,360
template here

27976
18:28:37,360 --> 18:28:39,920
okay this is what we mean by

27977
18:28:39,920 --> 18:28:43,196
template type deduction it is the

27978
18:28:43,196 --> 18:28:45,196
default mechanism

27979
18:28:45,196 --> 18:28:48,156
that the compiler uses to know

27980
18:28:48,156 --> 18:28:50,796
which template instance to generate from

27981
18:28:50,796 --> 18:28:53,196
your function calls but as we have seen

27982
18:28:53,196 --> 18:28:55,040
in the last lecture this can be

27983
18:28:55,040 --> 18:28:56,476
problematic

27984
18:28:56,476 --> 18:28:59,600
one way this can be bad is if you pass

27985
18:28:59,600 --> 18:29:02,080
different types to the maximum function

27986
18:29:02,080 --> 18:29:05,360
here let's pass in a and c for example

27987
18:29:05,360 --> 18:29:07,680
or a and d this is going to work equally

27988
18:29:07,680 --> 18:29:09,516
well you see that we get a compiler

27989
18:29:09,516 --> 18:29:12,476
error because the compiler now it says

27990
18:29:12,476 --> 18:29:15,680
that we are calling with different types

27991
18:29:15,680 --> 18:29:18,080
but the template parameters here are

27992
18:29:18,080 --> 18:29:20,080
really of the same type they should be

27993
18:29:20,080 --> 18:29:22,320
of the same type because t is going to

27994
18:29:22,320 --> 18:29:24,960
be replaced for a single time so the

27995
18:29:24,960 --> 18:29:26,876
call we do here is going to fail and if

27996
18:29:26,876 --> 18:29:28,960
we run this through the compiler again

27997
18:29:28,960 --> 18:29:31,280
let's do that we're going to use gcc

27998
18:29:31,280 --> 18:29:32,876
we're going to get a compiler error and

27999
18:29:32,876 --> 18:29:34,720
it is going to say deduce conflicting

28000
18:29:34,720 --> 18:29:36,796
types for parameter t

28001
18:29:36,796 --> 18:29:39,436
and then double so it can't really know

28002
18:29:39,436 --> 18:29:41,360
which one you want you want ent or

28003
18:29:41,360 --> 18:29:43,756
double the compiler doesn't know and it

28004
18:29:43,756 --> 18:29:46,640
is going to give us a compiler error but

28005
18:29:46,640 --> 18:29:48,400
now we're going to see a mechanism we

28006
18:29:48,400 --> 18:29:50,720
can use to make this work and that's

28007
18:29:50,720 --> 18:29:53,836
going to be explicit template arguments

28008
18:29:53,836 --> 18:29:56,720
okay what we can do to do this we can go

28009
18:29:56,720 --> 18:29:59,116
down and put in our call we're going to

28010
18:29:59,116 --> 18:30:02,244
say auto and say result or max we can

28011
18:30:02,244 --> 18:30:03,836
call this however we want we're going to

28012
18:30:03,836 --> 18:30:05,436
say the name of the function and we're

28013
18:30:05,436 --> 18:30:07,196
going to specify

28014
18:30:07,196 --> 18:30:10,080
the template type that we want generated

28015
18:30:10,080 --> 18:30:12,476
for our function template here so if we

28016
18:30:12,476 --> 18:30:14,876
do something like this with double

28017
18:30:14,876 --> 18:30:17,360
inside angle brackets here we're going

28018
18:30:17,360 --> 18:30:19,600
to be basically telling the compiler

28019
18:30:19,600 --> 18:30:22,556
please generate a double template

28020
18:30:22,556 --> 18:30:25,516
instance for this call we are doing here

28021
18:30:25,516 --> 18:30:28,000
so if we pass in c and d for example

28022
18:30:28,000 --> 18:30:29,600
this is going to give us what we want

28023
18:30:29,600 --> 18:30:31,836
and we can print this out if we

28024
18:30:31,836 --> 18:30:34,320
want so let's say max okay this is going

28025
18:30:34,320 --> 18:30:37,836
to work if we build let's build with gcc

28026
18:30:37,836 --> 18:30:39,280
let's use that

28027
18:30:39,280 --> 18:30:41,436
the build is going to be good because we

28028
18:30:41,436 --> 18:30:43,600
are passing any double

28029
18:30:43,600 --> 18:30:46,000
arguments and if we run this we should

28030
18:30:46,000 --> 18:30:48,640
see our maximum let's bring up a

28031
18:30:48,640 --> 18:30:51,360
terminal window and a visual studio code

28032
18:30:51,360 --> 18:30:53,680
here so that we can use that to see

28033
18:30:53,680 --> 18:30:55,680
things running we're going to clear and

28034
18:30:55,680 --> 18:30:57,920
run rooster you see that we have our

28035
18:30:57,920 --> 18:31:02,244
maximum here but using explicit template

28036
18:31:02,244 --> 18:31:04,556
arguments like we are doing here is

28037
18:31:04,556 --> 18:31:07,280
going to allow us to even pass different

28038
18:31:07,280 --> 18:31:10,080
types for our template arguments and for

28039
18:31:10,080 --> 18:31:12,080
example now we can change the first

28040
18:31:12,080 --> 18:31:14,476
argument here to ba which is going to be

28041
18:31:14,476 --> 18:31:16,400
an end and we're going to leave the

28042
18:31:16,400 --> 18:31:19,756
second one to bd which is of type double

28043
18:31:19,756 --> 18:31:21,920
now the compiler is going to see that

28044
18:31:21,920 --> 18:31:24,080
we're going to generate a template

28045
18:31:24,080 --> 18:31:26,960
instance of type double and it is going

28046
18:31:26,960 --> 18:31:28,960
to know that it can do implicit

28047
18:31:28,960 --> 18:31:31,756
conversions for the arguments we pass in

28048
18:31:31,756 --> 18:31:34,556
here so this is going to work if we pass

28049
18:31:34,556 --> 18:31:36,640
an argument that is implicitly

28050
18:31:36,640 --> 18:31:39,600
convertible to the type we passed in the

28051
18:31:39,600 --> 18:31:42,720
angle brackets here and let's debug this

28052
18:31:42,720 --> 18:31:44,960
again to show you that we're going to

28053
18:31:44,960 --> 18:31:47,516
generate a double template instance that

28054
18:31:47,516 --> 18:31:49,196
is going to be called and give us the

28055
18:31:49,196 --> 18:31:52,400
maximum that we print here so we can run

28056
18:31:52,400 --> 18:31:55,196
our debugger by hitting the green run

28057
18:31:55,196 --> 18:31:57,680
button here let's minimize this so that

28058
18:31:57,680 --> 18:31:59,196
we can see

28059
18:31:59,196 --> 18:32:02,000
our terminal window and it is down here

28060
18:32:02,000 --> 18:32:04,400
let's grab it and put it to the left so

28061
18:32:04,400 --> 18:32:07,040
that we can really see things printed

28062
18:32:07,040 --> 18:32:08,796
out as we debug

28063
18:32:08,796 --> 18:32:11,516
we have hit the breakpoint here and we

28064
18:32:11,516 --> 18:32:13,360
have our local variables you can look at

28065
18:32:13,360 --> 18:32:15,116
this if you want it is basically what we

28066
18:32:15,116 --> 18:32:17,280
have in the main function here but what

28067
18:32:17,280 --> 18:32:19,920
we want is to step into this maximum

28068
18:32:19,920 --> 18:32:20,876
function

28069
18:32:20,876 --> 18:32:22,640
and we're going to see

28070
18:32:22,640 --> 18:32:25,280
the template instance that was generated

28071
18:32:25,280 --> 18:32:27,756
you see that it is of a double type here

28072
18:32:27,756 --> 18:32:30,156
okay hopefully now you can see that even

28073
18:32:30,156 --> 18:32:34,000
if we passed different values for our

28074
18:32:34,000 --> 18:32:36,000
template arguments i should say

28075
18:32:36,000 --> 18:32:38,960
different types because a is of type and

28076
18:32:38,960 --> 18:32:42,080
and d is of type double but we're not

28077
18:32:42,080 --> 18:32:44,556
getting a compiler error the compiler is

28078
18:32:44,556 --> 18:32:47,436
going to insert implicit conversions

28079
18:32:47,436 --> 18:32:50,796
from whatever arguments we pass here to

28080
18:32:50,796 --> 18:32:53,600
the explicit template argument that we

28081
18:32:53,600 --> 18:32:56,400
specified here again the explicit

28082
18:32:56,400 --> 18:32:58,556
template argument like we are doing here

28083
18:32:58,556 --> 18:33:01,196
using the syntax with angle brackets and

28084
18:33:01,196 --> 18:33:03,516
putting in our type is going to tell the

28085
18:33:03,516 --> 18:33:06,400
compiler please use this type and

28086
18:33:06,400 --> 18:33:09,116
replace that for t in our function

28087
18:33:09,116 --> 18:33:11,680
template here and generate a template

28088
18:33:11,680 --> 18:33:14,156
instance we can call to service this

28089
18:33:14,156 --> 18:33:16,400
call here and we're going to do implicit

28090
18:33:16,400 --> 18:33:18,640
conversions basically from

28091
18:33:18,640 --> 18:33:20,556
and to double because that's what we

28092
18:33:20,556 --> 18:33:22,876
want then d is going to be of double

28093
18:33:22,876 --> 18:33:24,876
type we're not going to do any implicit

28094
18:33:24,876 --> 18:33:26,556
conversion then we're going to call this

28095
18:33:26,556 --> 18:33:28,476
function we're going to return a double

28096
18:33:28,476 --> 18:33:30,476
from it because that's our template

28097
18:33:30,476 --> 18:33:32,320
instance and we're going to print that

28098
18:33:32,320 --> 18:33:34,156
out here this is what is happening and

28099
18:33:34,156 --> 18:33:36,720
we can prove that a double instance was

28100
18:33:36,720 --> 18:33:39,436
generated through our call stack here we

28101
18:33:39,436 --> 18:33:42,640
see the maximum function is taking in

28102
18:33:42,640 --> 18:33:44,476
double parameters and it's going to

28103
18:33:44,476 --> 18:33:48,400
return double as our explicit

28104
18:33:48,400 --> 18:33:50,244
template argument here this is the

28105
18:33:50,244 --> 18:33:54,156
syntax that gcc uses is using but we

28106
18:33:54,156 --> 18:33:56,556
know now that it is a double template

28107
18:33:56,556 --> 18:33:59,360
instance for a function call here okay

28108
18:33:59,360 --> 18:34:02,000
if you're not happy with what we are

28109
18:34:02,000 --> 18:34:04,796
seeing with the debugger you can also

28110
18:34:04,796 --> 18:34:07,516
use cpp insights to really prove this

28111
18:34:07,516 --> 18:34:09,280
let's open this up we're going to say

28112
18:34:09,280 --> 18:34:11,600
cpp insights

28113
18:34:11,600 --> 18:34:13,836
let's do that and we're going to have it

28114
18:34:13,836 --> 18:34:16,000
open here okay we're going to

28115
18:34:16,000 --> 18:34:17,836
erase whatever we have in here and we're

28116
18:34:17,836 --> 18:34:20,476
going to put in another piece of code we

28117
18:34:20,476 --> 18:34:23,436
have our maximum function i should say

28118
18:34:23,436 --> 18:34:25,600
template function or function template

28119
18:34:25,600 --> 18:34:27,436
and we have alcohol here and it is

28120
18:34:27,436 --> 18:34:30,876
passing different types a and d remember

28121
18:34:30,876 --> 18:34:32,720
the last time we did something like this

28122
18:34:32,720 --> 18:34:35,600
by passing in different types for the

28123
18:34:35,600 --> 18:34:38,476
template argument this guy failed it

28124
18:34:38,476 --> 18:34:40,796
couldn't really generate a function

28125
18:34:40,796 --> 18:34:43,116
template instance because the template

28126
18:34:43,116 --> 18:34:45,920
parameters we have on top here specify

28127
18:34:45,920 --> 18:34:48,080
that these guys should be of the same

28128
18:34:48,080 --> 18:34:50,476
type but now we are able to use

28129
18:34:50,476 --> 18:34:53,516
different types as arguments because we

28130
18:34:53,516 --> 18:34:56,320
have an explicit argument specified

28131
18:34:56,320 --> 18:34:58,476
let's run this and see the template

28132
18:34:58,476 --> 18:35:00,960
instance that is generated and you can

28133
18:35:00,960 --> 18:35:02,960
see that it is of double type we

28134
18:35:02,960 --> 18:35:06,244
basically replaced every instance of t

28135
18:35:06,244 --> 18:35:08,960
here with double and this function is

28136
18:35:08,960 --> 18:35:11,280
going to be called to service the call

28137
18:35:11,280 --> 18:35:13,280
we are making here okay this is really

28138
18:35:13,280 --> 18:35:15,280
all we set out to do in this lecture i

28139
18:35:15,280 --> 18:35:17,196
hope you found it interesting the main

28140
18:35:17,196 --> 18:35:19,600
message was template type deduction a

28141
18:35:19,600 --> 18:35:22,796
default mechanism c plus plus uses to

28142
18:35:22,796 --> 18:35:24,960
know which template instances to

28143
18:35:24,960 --> 18:35:27,680
generate from your function calls but if

28144
18:35:27,680 --> 18:35:30,156
the defaults aren't working for you you

28145
18:35:30,156 --> 18:35:33,280
can use explicit template arguments to

28146
18:35:33,280 --> 18:35:36,400
specify the template instance you want

28147
18:35:36,400 --> 18:35:39,040
to generate it we are going to stop here

28148
18:35:39,040 --> 18:35:40,720
in this lecture in the next one we're

28149
18:35:40,720 --> 18:35:42,796
going to see how we can pass template

28150
18:35:42,796 --> 18:35:45,196
parameters by reference

28151
18:35:45,196 --> 18:35:47,516
go ahead and finish up here and meet me

28152
18:35:47,516 --> 18:35:49,116
there in this lecture we're going to

28153
18:35:49,116 --> 18:35:51,436
show you that you can pass your template

28154
18:35:51,436 --> 18:35:54,320
type parameters by reference and we're

28155
18:35:54,320 --> 18:35:56,244
going to look at a simple example to

28156
18:35:56,244 --> 18:35:58,320
really drive this home what we have seen

28157
18:35:58,320 --> 18:36:00,320
so far is that we can do things like

28158
18:36:00,320 --> 18:36:03,116
this and specify our t like this and

28159
18:36:03,116 --> 18:36:05,280
this is going to generate a template

28160
18:36:05,280 --> 18:36:08,476
instance that passes our arguments by

28161
18:36:08,476 --> 18:36:11,116
value for example if we pass in double a

28162
18:36:11,116 --> 18:36:13,756
and double b here for our maximum we're

28163
18:36:13,756 --> 18:36:16,244
going to generate a template instance

28164
18:36:16,244 --> 18:36:18,556
which takes double as parameters and

28165
18:36:18,556 --> 18:36:20,796
returns a double here and this is going

28166
18:36:20,796 --> 18:36:23,116
to be doing things by value okay this is

28167
18:36:23,116 --> 18:36:25,516
what i want you to focus on right now it

28168
18:36:25,516 --> 18:36:27,516
is that this is going to do things by

28169
18:36:27,516 --> 18:36:30,476
value so if we go in our function here

28170
18:36:30,476 --> 18:36:32,400
and compute the maximum you're going to

28171
18:36:32,400 --> 18:36:34,720
see that the addresses we have on the

28172
18:36:34,720 --> 18:36:37,196
outside are going to be different from

28173
18:36:37,196 --> 18:36:39,920
the addresses we have on the inside here

28174
18:36:39,920 --> 18:36:42,640
if we try to print them out but you can

28175
18:36:42,640 --> 18:36:44,960
also pass your template parameters by

28176
18:36:44,960 --> 18:36:47,436
reference and the syntax to do that is

28177
18:36:47,436 --> 18:36:50,000
ridiculously easy you just use this like

28178
18:36:50,000 --> 18:36:52,400
you would use any reference we say cast

28179
18:36:52,400 --> 18:36:54,640
t reference here and this is going to

28180
18:36:54,640 --> 18:36:58,000
just replace in whatever type that you

28181
18:36:58,000 --> 18:37:00,000
pass when you call the function here for

28182
18:37:00,000 --> 18:37:02,556
example here we are passing in double

28183
18:37:02,556 --> 18:37:05,516
arguments so this is going to deduce a

28184
18:37:05,516 --> 18:37:08,320
double template instance which basically

28185
18:37:08,320 --> 18:37:11,280
says cost double reference maximum cost

28186
18:37:11,280 --> 18:37:13,196
double reference a and cost double

28187
18:37:13,196 --> 18:37:15,436
reference b and this is going to be the

28188
18:37:15,436 --> 18:37:17,516
function that is called so this is going

28189
18:37:17,516 --> 18:37:20,320
to really do things by reference and the

28190
18:37:20,320 --> 18:37:22,640
values we have inside a function

28191
18:37:22,640 --> 18:37:25,680
template body here are going to be true

28192
18:37:25,680 --> 18:37:27,920
references to the values we have on the

28193
18:37:27,920 --> 18:37:29,680
outside if we happen to do any

28194
18:37:29,680 --> 18:37:31,600
modification inside the body of the

28195
18:37:31,600 --> 18:37:33,680
function the modification is going to be

28196
18:37:33,680 --> 18:37:35,920
visible on the outside what we're going

28197
18:37:35,920 --> 18:37:38,000
to be doing in this lecture is just

28198
18:37:38,000 --> 18:37:40,080
printing the addresses here and we're

28199
18:37:40,080 --> 18:37:42,080
going to see that they are the same here

28200
18:37:42,080 --> 18:37:45,436
on the outside and inside the body of

28201
18:37:45,436 --> 18:37:48,000
our function template here okay this is

28202
18:37:48,000 --> 18:37:50,320
what we want to really play with in this

28203
18:37:50,320 --> 18:37:52,720
lecture but before we head over to

28204
18:37:52,720 --> 18:37:54,960
visual studio code i want to show you

28205
18:37:54,960 --> 18:37:57,196
that you can confuse your compiler if

28206
18:37:57,196 --> 18:37:59,836
you are not careful if you set up these

28207
18:37:59,836 --> 18:38:02,400
two function templates you see here

28208
18:38:02,400 --> 18:38:04,556
they are going to be overloads and we

28209
18:38:04,556 --> 18:38:06,320
can use function overloads with

28210
18:38:06,320 --> 18:38:08,244
templates but for now we're just going

28211
18:38:08,244 --> 18:38:10,476
to focus on the parameters that we are

28212
18:38:10,476 --> 18:38:12,960
passing in here the first one is taken

28213
18:38:12,960 --> 18:38:15,116
thanks by volume

28214
18:38:15,116 --> 18:38:17,360
and the second one is taking thanks by

28215
18:38:17,360 --> 18:38:19,360
reference as we see here

28216
18:38:19,360 --> 18:38:21,600
and if we issue a call like this we're

28217
18:38:21,600 --> 18:38:24,000
going to have the same problem we have

28218
18:38:24,000 --> 18:38:26,556
seen with function overloads before this

28219
18:38:26,556 --> 18:38:28,320
is not going to know whether you are

28220
18:38:28,320 --> 18:38:30,640
calling by value or by reference and

28221
18:38:30,640 --> 18:38:32,800
this is going to cause a compiler error

28222
18:38:32,800 --> 18:38:34,720
i really want you to be aware of this

28223
18:38:34,720 --> 18:38:36,160
okay now that you know this we're going

28224
18:38:36,160 --> 18:38:38,160
to head over to visual studio code and

28225
18:38:38,160 --> 18:38:40,160
really play with us a little more okay

28226
18:38:40,160 --> 18:38:42,800
here we are in our working folder the

28227
18:38:42,800 --> 18:38:45,512
current project is template parameters

28228
18:38:45,512 --> 18:38:47,680
by reference we're going to grab our

28229
18:38:47,680 --> 18:38:50,800
template files and put them in place so

28230
18:38:50,800 --> 18:38:52,872
let's do that and we are going to open

28231
18:38:52,872 --> 18:38:55,512
this little guy in visual studio code by

28232
18:38:55,512 --> 18:38:58,080
dragging and dropping here the folder is

28233
18:38:58,080 --> 18:39:00,160
going to open up we're going to open it

28234
18:39:00,160 --> 18:39:02,080
and we're going to close the left pane

28235
18:39:02,080 --> 18:39:05,920
here and clean up our main file here and

28236
18:39:05,920 --> 18:39:08,000
we are going to put in our function

28237
18:39:08,000 --> 18:39:10,320
template one thing i want you to see in

28238
18:39:10,320 --> 18:39:12,400
this lecture is that it is possible to

28239
18:39:12,400 --> 18:39:14,480
separate these things into function

28240
18:39:14,480 --> 18:39:16,800
declaration and function definition

28241
18:39:16,800 --> 18:39:18,800
let's just try and do that here so that

28242
18:39:18,800 --> 18:39:20,872
you can really see this and then you're

28243
18:39:20,872 --> 18:39:22,552
going to have to choose what you like a

28244
18:39:22,552 --> 18:39:24,640
little more so let's grab a function

28245
18:39:24,640 --> 18:39:27,040
header here and use that as a prototype

28246
18:39:27,040 --> 18:39:29,280
we're going to put that in front of the

28247
18:39:29,280 --> 18:39:31,440
main function and that's going to be our

28248
18:39:31,440 --> 18:39:34,552
declaration and if we go down after the

28249
18:39:34,552 --> 18:39:37,192
main function here what we have is our

28250
18:39:37,192 --> 18:39:39,440
definition this could work and this is

28251
18:39:39,440 --> 18:39:41,832
going to generate template instances for

28252
18:39:41,832 --> 18:39:44,080
the calls we do in the main function

28253
18:39:44,080 --> 18:39:45,920
here okay now that we have this we can

28254
18:39:45,920 --> 18:39:47,920
head in the main function and really

28255
18:39:47,920 --> 18:39:50,320
play with the function template here

28256
18:39:50,320 --> 18:39:51,760
we're going to set up two double

28257
18:39:51,760 --> 18:39:53,600
parameters and we're going to call the

28258
18:39:53,600 --> 18:39:56,400
function for example we say addon result

28259
18:39:56,400 --> 18:39:58,640
and we're going to call the maximum

28260
18:39:58,640 --> 18:40:00,320
function and we're going to pass in a

28261
18:40:00,320 --> 18:40:02,552
and b this is going to do

28262
18:40:02,552 --> 18:40:05,040
default template type deduction and it

28263
18:40:05,040 --> 18:40:08,160
is going to generate a double function

28264
18:40:08,160 --> 18:40:10,320
template instance here but what we

28265
18:40:10,320 --> 18:40:12,080
really want to prove is that this is

28266
18:40:12,080 --> 18:40:14,480
going to pass things by value and one

28267
18:40:14,480 --> 18:40:16,720
way we have to prove this is to bridge

28268
18:40:16,720 --> 18:40:20,160
the addresses both on the outside and on

28269
18:40:20,160 --> 18:40:22,320
the inside of the function here you see

28270
18:40:22,320 --> 18:40:24,240
we are already doing that in our

28271
18:40:24,240 --> 18:40:26,240
function template body we are going to

28272
18:40:26,240 --> 18:40:28,640
print the address of a so we can really

28273
18:40:28,640 --> 18:40:32,080
grab this and we use this stdc out

28274
18:40:32,080 --> 18:40:33,280
statement

28275
18:40:33,280 --> 18:40:36,080
and we are going to change it to say out

28276
18:40:36,080 --> 18:40:37,512
here and we're going to print the

28277
18:40:37,512 --> 18:40:40,160
address of a let's grab this again and

28278
18:40:40,160 --> 18:40:42,800
use this after the function call and

28279
18:40:42,800 --> 18:40:44,720
what we expect to see

28280
18:40:44,720 --> 18:40:47,832
is some address on the outside so for

28281
18:40:47,832 --> 18:40:50,160
example we may have something like zero

28282
18:40:50,160 --> 18:40:54,640
x and a one one one abc which is some

28283
18:40:54,640 --> 18:40:57,040
hex number here and that's the same

28284
18:40:57,040 --> 18:40:59,192
thing we're going to have on the outside

28285
18:40:59,192 --> 18:41:01,120
because the value we have before the

28286
18:41:01,120 --> 18:41:04,000
function call and the value we have

28287
18:41:04,000 --> 18:41:05,832
after the function call are going to be

28288
18:41:05,832 --> 18:41:08,552
leaving at the same address but what we

28289
18:41:08,552 --> 18:41:11,192
have inside the function body is going

28290
18:41:11,192 --> 18:41:13,440
to be a copy so it's going to live at

28291
18:41:13,440 --> 18:41:15,680
some other address for example let's say

28292
18:41:15,680 --> 18:41:16,960
d a

28293
18:41:16,960 --> 18:41:19,120
and uh the main point here is that what

28294
18:41:19,120 --> 18:41:20,872
we have on the outside is going to be

28295
18:41:20,872 --> 18:41:22,552
different from what we have on the east

28296
18:41:22,552 --> 18:41:24,552
side and hopefully this is going to

28297
18:41:24,552 --> 18:41:27,192
prove that we are passing by value so

28298
18:41:27,192 --> 18:41:30,080
let's print out our maximum here and see

28299
18:41:30,080 --> 18:41:32,160
the addresses printed out we're going to

28300
18:41:32,160 --> 18:41:35,360
build with gcc and we're going to build

28301
18:41:35,360 --> 18:41:38,400
successfully we can bring up a terminal

28302
18:41:38,400 --> 18:41:40,240
to play with us a little more we can

28303
18:41:40,240 --> 18:41:42,480
clear and run rooster we're going to see

28304
18:41:42,480 --> 18:41:45,040
that the address on the outside ends in

28305
18:41:45,040 --> 18:41:48,720
dd8 and the address on the outside ends

28306
18:41:48,720 --> 18:41:51,512
with dd8 after the function call but

28307
18:41:51,512 --> 18:41:53,760
inside you see that we have a different

28308
18:41:53,760 --> 18:41:56,160
address and this is going to tell us

28309
18:41:56,160 --> 18:41:58,800
that we are passing by value and what we

28310
18:41:58,800 --> 18:42:01,360
have inside the body of the function is

28311
18:42:01,360 --> 18:42:04,400
basically a copy again i don't expect

28312
18:42:04,400 --> 18:42:06,720
you to see the same addresses as me here

28313
18:42:06,720 --> 18:42:08,552
because your operating system is going

28314
18:42:08,552 --> 18:42:10,872
to set up the addresses however it wants

28315
18:42:10,872 --> 18:42:13,040
the main point here is that the

28316
18:42:13,040 --> 18:42:15,280
addresses you see on the outside are

28317
18:42:15,280 --> 18:42:17,192
going to be different from the addresses

28318
18:42:17,192 --> 18:42:19,600
you see on the inside here and this

28319
18:42:19,600 --> 18:42:22,160
proves that we are passing by value but

28320
18:42:22,160 --> 18:42:24,640
what if you don't really want to pass by

28321
18:42:24,640 --> 18:42:27,120
value and make your function template

28322
18:42:27,120 --> 18:42:29,600
work by reference well we can do that we

28323
18:42:29,600 --> 18:42:31,512
can change our function here to do

28324
18:42:31,512 --> 18:42:33,600
things by reference and all we have to

28325
18:42:33,600 --> 18:42:34,400
do

28326
18:42:34,400 --> 18:42:37,512
is use t reference like this okay and

28327
18:42:37,512 --> 18:42:39,920
when we start using references we really

28328
18:42:39,920 --> 18:42:42,552
need to be careful and make sure people

28329
18:42:42,552 --> 18:42:45,440
don't modify things without our

28330
18:42:45,440 --> 18:42:48,080
knowledge and a good practice is to mark

28331
18:42:48,080 --> 18:42:50,640
your things as cost references so we're

28332
18:42:50,640 --> 18:42:52,640
going to do that and we are going to do

28333
18:42:52,640 --> 18:42:55,192
the same in our function definition so

28334
18:42:55,192 --> 18:42:57,360
we're going to change this to cost t

28335
18:42:57,360 --> 18:43:00,080
reference let's do that and let's say

28336
18:43:00,080 --> 18:43:02,720
cost t reference for the first parameter

28337
18:43:02,720 --> 18:43:05,192
here and say the same for the second

28338
18:43:05,192 --> 18:43:07,920
parameter here and this should be it we

28339
18:43:07,920 --> 18:43:10,320
shouldn't be able to use this reference

28340
18:43:10,320 --> 18:43:12,552
to modify the data inside the body of

28341
18:43:12,552 --> 18:43:14,552
the function and our function is a

28342
18:43:14,552 --> 18:43:16,872
little safer but what the compiler is

28343
18:43:16,872 --> 18:43:18,640
going to do is really what it's been

28344
18:43:18,640 --> 18:43:20,480
doing all along it's going to look at

28345
18:43:20,480 --> 18:43:22,160
the arguments that we pass to the

28346
18:43:22,160 --> 18:43:23,600
function call here it's going to see

28347
18:43:23,600 --> 18:43:26,080
that it is double and it's going to do

28348
18:43:26,080 --> 18:43:28,872
default template type deduction so it's

28349
18:43:28,872 --> 18:43:31,760
going to generate a double template

28350
18:43:31,760 --> 18:43:34,000
instance for the function template here

28351
18:43:34,000 --> 18:43:36,640
and it's going to replace in double and

28352
18:43:36,640 --> 18:43:38,080
we're going to have const double

28353
18:43:38,080 --> 18:43:40,480
reference maximum cost double reference

28354
18:43:40,480 --> 18:43:42,872
a constant double reference b

28355
18:43:42,872 --> 18:43:46,160
and we can prove this by going into cpp

28356
18:43:46,160 --> 18:43:48,480
insight i think we can do that so we are

28357
18:43:48,480 --> 18:43:51,040
here in cpp insights we can take out

28358
18:43:51,040 --> 18:43:52,960
whatever we had we're going to put in

28359
18:43:52,960 --> 18:43:55,512
new code here and we can

28360
18:43:55,512 --> 18:43:57,360
hit the run button

28361
18:43:57,360 --> 18:44:00,400
to generate our instances and here we

28362
18:44:00,400 --> 18:44:03,120
have our template instance here

28363
18:44:03,120 --> 18:44:05,680
generated you see that it is going to

28364
18:44:05,680 --> 18:44:08,872
generate a double version of our

28365
18:44:08,872 --> 18:44:10,720
function template here and this is what

28366
18:44:10,720 --> 18:44:13,280
we have so const double reference

28367
18:44:13,280 --> 18:44:16,240
maximum and it is going to put in a

28368
18:44:16,240 --> 18:44:18,400
double explicit argument here but this

28369
18:44:18,400 --> 18:44:20,640
is business of the compiler what we

28370
18:44:20,640 --> 18:44:23,440
really care about is that it generated a

28371
18:44:23,440 --> 18:44:25,440
double template instance for our

28372
18:44:25,440 --> 18:44:27,600
function template here now if we run

28373
18:44:27,600 --> 18:44:29,040
this it is going to be passing

28374
18:44:29,040 --> 18:44:31,512
parameters by reference and what we have

28375
18:44:31,512 --> 18:44:33,512
on the inside should have the same

28376
18:44:33,512 --> 18:44:36,160
address as what we have on the outside

28377
18:44:36,160 --> 18:44:37,512
here so

28378
18:44:37,512 --> 18:44:39,760
to really drive this home we should

28379
18:44:39,760 --> 18:44:40,960
change

28380
18:44:40,960 --> 18:44:44,080
our address to abc to comply with what

28381
18:44:44,080 --> 18:44:46,240
we have on the outside here we can try

28382
18:44:46,240 --> 18:44:48,240
and build our program we're going to use

28383
18:44:48,240 --> 18:44:50,400
the gcc to do that the build is going to

28384
18:44:50,400 --> 18:44:52,480
be good we're going to clear and if we

28385
18:44:52,480 --> 18:44:54,640
run rooster we should see the addresses

28386
18:44:54,640 --> 18:44:59,440
being the same out d e 0 in d e 0 and

28387
18:44:59,440 --> 18:45:02,480
out d e 0 and you see now we are passing

28388
18:45:02,480 --> 18:45:04,552
our parameters by reference and if you

28389
18:45:04,552 --> 18:45:07,040
want to set up a function template that

28390
18:45:07,040 --> 18:45:10,400
passes template parameters by reference

28391
18:45:10,400 --> 18:45:12,240
this is how you can do this

28392
18:45:12,240 --> 18:45:14,480
and i think we can also try and debug

28393
18:45:14,480 --> 18:45:16,552
this and see if we can see any more

28394
18:45:16,552 --> 18:45:18,960
information on how this works we're

28395
18:45:18,960 --> 18:45:21,760
going to hit our run tab here and we're

28396
18:45:21,760 --> 18:45:24,160
going to hit the green button to start

28397
18:45:24,160 --> 18:45:26,000
debugging this program we're going to be

28398
18:45:26,000 --> 18:45:29,600
using the debugging tools from gcc

28399
18:45:29,600 --> 18:45:32,320
and we see our local variables here we

28400
18:45:32,320 --> 18:45:35,360
have hit the breakpoint and we have the

28401
18:45:35,360 --> 18:45:37,120
main function to the top of the call

28402
18:45:37,120 --> 18:45:40,320
stack this is what we have here and if

28403
18:45:40,320 --> 18:45:42,480
we try and step into the maximum

28404
18:45:42,480 --> 18:45:44,240
function we're going to see that the

28405
18:45:44,240 --> 18:45:47,192
template instance now is using const

28406
18:45:47,192 --> 18:45:49,832
double references and this is the

28407
18:45:49,832 --> 18:45:52,720
template instance that was generated i

28408
18:45:52,720 --> 18:45:55,600
think this is all we can really see here

28409
18:45:55,600 --> 18:45:58,552
and let's stop this and show you one

28410
18:45:58,552 --> 18:46:00,080
last thing

28411
18:46:00,080 --> 18:46:01,832
what i'm going to show you is that you

28412
18:46:01,832 --> 18:46:03,832
can't really have

28413
18:46:03,832 --> 18:46:07,120
the function template that passes by

28414
18:46:07,120 --> 18:46:09,040
value and the other one passing by

28415
18:46:09,040 --> 18:46:10,800
reference if you do that you're going to

28416
18:46:10,800 --> 18:46:12,720
have problems when you issue the call

28417
18:46:12,720 --> 18:46:14,240
like this because the compiler is going

28418
18:46:14,240 --> 18:46:16,720
to be confused let's change the second

28419
18:46:16,720 --> 18:46:19,120
one here to pass by value so we're going

28420
18:46:19,120 --> 18:46:21,192
to remove the cost reference here i

28421
18:46:21,192 --> 18:46:22,960
think it's going to do let's do that

28422
18:46:22,960 --> 18:46:25,280
pretty quick we'll remove the cost and

28423
18:46:25,280 --> 18:46:28,240
the reference we remove the cost and the

28424
18:46:28,240 --> 18:46:31,120
reference here and we use this guy as

28425
18:46:31,120 --> 18:46:33,920
our function prototype in front of the

28426
18:46:33,920 --> 18:46:36,800
main function here and how can we say

28427
18:46:36,800 --> 18:46:39,360
that we're going to go on top here and

28428
18:46:39,360 --> 18:46:41,120
say that okay we're going to put our

28429
18:46:41,120 --> 18:46:43,680
semicolon and this is going to be our

28430
18:46:43,680 --> 18:46:45,832
declaration but the moment we do this

28431
18:46:45,832 --> 18:46:47,680
you see that our compiler is going to be

28432
18:46:47,680 --> 18:46:49,760
confused because we have two possible

28433
18:46:49,760 --> 18:46:52,400
candidates for the call here it can

28434
18:46:52,400 --> 18:46:55,192
either be by value or by reference and

28435
18:46:55,192 --> 18:46:56,960
if we try to build this program we're

28436
18:46:56,960 --> 18:46:59,280
going to get a compiler error and it is

28437
18:46:59,280 --> 18:47:01,040
basically going to be saying what is

28438
18:47:01,040 --> 18:47:03,360
wrong here so it's going to say call

28439
18:47:03,360 --> 18:47:05,760
overloaded maximum double ambiguous

28440
18:47:05,760 --> 18:47:08,720
because we have two candidates again one

28441
18:47:08,720 --> 18:47:11,512
by reference one by value and this call

28442
18:47:11,512 --> 18:47:14,240
can be surfaced by both of these

28443
18:47:14,240 --> 18:47:16,480
candidates here so the compiler is going

28444
18:47:16,480 --> 18:47:18,640
to give us a compiler error and we have

28445
18:47:18,640 --> 18:47:21,440
no choice but to use either of these two

28446
18:47:21,440 --> 18:47:23,680
but we can't have them all

28447
18:47:23,680 --> 18:47:26,000
in our code and for example if we take

28448
18:47:26,000 --> 18:47:28,552
out the one by value here and leaving

28449
18:47:28,552 --> 18:47:31,040
the one by reference so let's comment

28450
18:47:31,040 --> 18:47:32,640
this out again if we're boiled we're

28451
18:47:32,640 --> 18:47:34,800
going to bolt you see the world is good

28452
18:47:34,800 --> 18:47:36,400
and we're going to print our data

28453
18:47:36,400 --> 18:47:38,552
however we have it in our code we see

28454
18:47:38,552 --> 18:47:40,872
the addresses are the same and another

28455
18:47:40,872 --> 18:47:43,040
thing i don't think i really proved to

28456
18:47:43,040 --> 18:47:45,600
you is that we are passing by const

28457
18:47:45,600 --> 18:47:48,640
reference here so the template instance

28458
18:47:48,640 --> 18:47:50,400
that is going to be generated is going

28459
18:47:50,400 --> 18:47:52,480
to be passing by const double reference

28460
18:47:52,480 --> 18:47:54,400
because we are passing in double

28461
18:47:54,400 --> 18:47:57,512
parameters but because of this cost in

28462
18:47:57,512 --> 18:48:00,000
front of our arguments here we want to

28463
18:48:00,000 --> 18:48:03,120
be able to modify the data referenced by

28464
18:48:03,120 --> 18:48:05,440
this name here if we go inside for

28465
18:48:05,440 --> 18:48:08,080
example and say plus plus a try to

28466
18:48:08,080 --> 18:48:10,640
modify a in any way through this

28467
18:48:10,640 --> 18:48:12,160
reference we're going to get a compiler

28468
18:48:12,160 --> 18:48:13,920
error let's work again and we're going

28469
18:48:13,920 --> 18:48:17,192
to see that and uh world finished with

28470
18:48:17,192 --> 18:48:18,240
an error

28471
18:48:18,240 --> 18:48:20,160
and it is saying

28472
18:48:20,160 --> 18:48:22,800
increment of read only reference a

28473
18:48:22,800 --> 18:48:24,640
because we are passing by const

28474
18:48:24,640 --> 18:48:26,552
reference here so you should really

28475
18:48:26,552 --> 18:48:29,120
remember this even if we are doing the

28476
18:48:29,120 --> 18:48:31,440
things in the context of function

28477
18:48:31,440 --> 18:48:32,480
templates

28478
18:48:32,480 --> 18:48:34,080
this is really all we set out to do in

28479
18:48:34,080 --> 18:48:35,760
this lecture showing you that you can

28480
18:48:35,760 --> 18:48:38,160
set up function templates that take

28481
18:48:38,160 --> 18:48:41,040
parameters by reference and contrasting

28482
18:48:41,040 --> 18:48:43,512
this with passing by value and seeing

28483
18:48:43,512 --> 18:48:45,832
the differences between these two things

28484
18:48:45,832 --> 18:48:47,760
we're going to stop here in this lecture

28485
18:48:47,760 --> 18:48:49,280
and the next one we're going to learn

28486
18:48:49,280 --> 18:48:52,320
about template spatialization

28487
18:48:52,320 --> 18:48:54,552
go ahead and finish up here and meet me

28488
18:48:54,552 --> 18:48:55,512
there

28489
18:48:55,512 --> 18:48:56,800
in this lecture we're going to learn

28490
18:48:56,800 --> 18:48:59,680
about template specialization and this

28491
18:48:59,680 --> 18:49:02,160
is a feature we have in c plus plus to

28492
18:49:02,160 --> 18:49:05,600
bypass the default mechanism of how

28493
18:49:05,600 --> 18:49:08,240
function templates work in c plus plus

28494
18:49:08,240 --> 18:49:10,872
okay let's make myself super clear here

28495
18:49:10,872 --> 18:49:12,872
we have a simple function template we

28496
18:49:12,872 --> 18:49:15,192
have seen a thousand times by now it is

28497
18:49:15,192 --> 18:49:17,280
the maximum function and it is going to

28498
18:49:17,280 --> 18:49:20,240
compute the maximum between a and b here

28499
18:49:20,240 --> 18:49:22,400
and it is going to return that it is a

28500
18:49:22,400 --> 18:49:24,720
function template so if we pass in a and

28501
18:49:24,720 --> 18:49:26,552
b which are of type and we're going to

28502
18:49:26,552 --> 18:49:29,280
generate a net instance of the template

28503
18:49:29,280 --> 18:49:32,720
here if we pass in c and d of double

28504
18:49:32,720 --> 18:49:34,800
time we're going to generate a double

28505
18:49:34,800 --> 18:49:37,600
instance of the function template here

28506
18:49:37,600 --> 18:49:40,552
if we pass in hdd string parameters

28507
18:49:40,552 --> 18:49:43,360
we're going to generate an std string

28508
18:49:43,360 --> 18:49:45,600
instance of this template here and this

28509
18:49:45,600 --> 18:49:47,680
is going to basically be comparing the

28510
18:49:47,680 --> 18:49:49,680
parameters we pass so we're basically

28511
18:49:49,680 --> 18:49:52,320
going to say if a is greater than b then

28512
18:49:52,320 --> 18:49:55,512
return a if a is not greater than b then

28513
18:49:55,512 --> 18:49:58,080
return b okay that's going to work if

28514
18:49:58,080 --> 18:50:00,320
what we're doing is what we have here

28515
18:50:00,320 --> 18:50:02,400
but the moment we pass something like

28516
18:50:02,400 --> 18:50:06,000
what we have here closed car pointers

28517
18:50:06,000 --> 18:50:08,000
then we're going to have a problem

28518
18:50:08,000 --> 18:50:10,080
because we're going to be calling our

28519
18:50:10,080 --> 18:50:13,280
function template with cost car pointer

28520
18:50:13,280 --> 18:50:14,800
parameters

28521
18:50:14,800 --> 18:50:15,680
the

28522
18:50:15,680 --> 18:50:18,720
default mechanism is going to deduce

28523
18:50:18,720 --> 18:50:21,360
a template instance that works on cost

28524
18:50:21,360 --> 18:50:24,400
car pointer arguments here and what

28525
18:50:24,400 --> 18:50:26,000
we're going to be comparing now are

28526
18:50:26,000 --> 18:50:28,960
going to be pointers to the string

28527
18:50:28,960 --> 18:50:32,000
rather than the string data itself and

28528
18:50:32,000 --> 18:50:33,512
hopefully you can see that this is going

28529
18:50:33,512 --> 18:50:36,240
to be a problem template specialization

28530
18:50:36,240 --> 18:50:38,640
is a mechanism we have to tell the

28531
18:50:38,640 --> 18:50:41,600
compiler for a template function

28532
18:50:41,600 --> 18:50:44,160
if i pass you this type please don't do

28533
18:50:44,160 --> 18:50:47,360
the default thing you do of replacing in

28534
18:50:47,360 --> 18:50:48,240
the

28535
18:50:48,240 --> 18:50:50,960
argument type for the template parameter

28536
18:50:50,960 --> 18:50:53,440
instead use the implementation that i am

28537
18:50:53,440 --> 18:50:55,360
going to give you and you tell that to

28538
18:50:55,360 --> 18:50:57,600
the compiler using the syntax we have

28539
18:50:57,600 --> 18:51:00,552
here you put a template keyword here you

28540
18:51:00,552 --> 18:51:03,600
put an empty pair of angle brackets and

28541
18:51:03,600 --> 18:51:06,320
then you specify your function the way

28542
18:51:06,320 --> 18:51:08,240
you want it you see it's going to return

28543
18:51:08,240 --> 18:51:10,400
a const card pointer the function name

28544
18:51:10,400 --> 18:51:12,640
is maximum which should be the same as

28545
18:51:12,640 --> 18:51:14,400
the function template here

28546
18:51:14,400 --> 18:51:16,640
it's going to be specialized for const

28547
18:51:16,640 --> 18:51:19,512
car pointer so we specify an explicit

28548
18:51:19,512 --> 18:51:21,832
template argument here and then we pass

28549
18:51:21,832 --> 18:51:24,552
our parameters which are also of cost

28550
18:51:24,552 --> 18:51:27,120
card pointer and when we do this then we

28551
18:51:27,120 --> 18:51:29,360
can head in the body of the function and

28552
18:51:29,360 --> 18:51:31,440
do the comparison however we want okay

28553
18:51:31,440 --> 18:51:33,512
so how do we do this comparison here

28554
18:51:33,512 --> 18:51:36,160
here is a simple implementation of the

28555
18:51:36,160 --> 18:51:38,552
function template we just saw on the

28556
18:51:38,552 --> 18:51:40,720
previous slide you see that it really is

28557
18:51:40,720 --> 18:51:42,320
the same thing we have the template

28558
18:51:42,320 --> 18:51:44,800
keyword we have our angle brackets and

28559
18:51:44,800 --> 18:51:47,760
we have the function header here it's

28560
18:51:47,760 --> 18:51:50,080
going to return cost car pointer it's

28561
18:51:50,080 --> 18:51:52,320
going to be called maximum and an

28562
18:51:52,320 --> 18:51:55,040
explicit template argument is specified

28563
18:51:55,040 --> 18:51:57,440
within these angle brackets and then we

28564
18:51:57,440 --> 18:52:00,480
have our parameters what is really

28565
18:52:00,480 --> 18:52:02,480
important about this function is that

28566
18:52:02,480 --> 18:52:04,240
it's not going to do the comparison

28567
18:52:04,240 --> 18:52:06,160
we've been doing all along it's going to

28568
18:52:06,160 --> 18:52:08,080
use a built-in function

28569
18:52:08,080 --> 18:52:10,320
and it's a c plus plus standard library

28570
18:52:10,320 --> 18:52:12,800
which is specialized for comparing c

28571
18:52:12,800 --> 18:52:15,600
strings okay if we come at cpp reference

28572
18:52:15,600 --> 18:52:17,800
here and look at a function called

28573
18:52:17,800 --> 18:52:21,120
htrcmp we have seen this before i guess

28574
18:52:21,120 --> 18:52:23,040
it is going to compare two null

28575
18:52:23,040 --> 18:52:24,400
terminated byte strings

28576
18:52:24,400 --> 18:52:26,240
lexicographically and you see this is

28577
18:52:26,240 --> 18:52:28,872
really what we want we have two const

28578
18:52:28,872 --> 18:52:30,800
car pointers one is going to be the

28579
18:52:30,800 --> 18:52:32,320
first parameter the other is going to be

28580
18:52:32,320 --> 18:52:34,000
the second parameter we're going to

28581
18:52:34,000 --> 18:52:36,400
compare them and look at the return

28582
18:52:36,400 --> 18:52:38,160
value we get from this function we're

28583
18:52:38,160 --> 18:52:40,640
going to get a negative return value if

28584
18:52:40,640 --> 18:52:43,192
the first parameter comes before the

28585
18:52:43,192 --> 18:52:45,920
second parameter in lexicographical

28586
18:52:45,920 --> 18:52:48,080
order we're going to get a zero if they

28587
18:52:48,080 --> 18:52:49,360
are equal

28588
18:52:49,360 --> 18:52:51,600
and we're going to get a positive value

28589
18:52:51,600 --> 18:52:54,400
if the first parameter comes after the

28590
18:52:54,400 --> 18:52:57,120
second parameter in lexicographical

28591
18:52:57,120 --> 18:52:58,480
order so we're going to use this

28592
18:52:58,480 --> 18:53:00,640
information here and compare

28593
18:53:00,640 --> 18:53:03,512
our two c strings here and return

28594
18:53:03,512 --> 18:53:06,000
something in visual studio code okay so

28595
18:53:06,000 --> 18:53:07,600
this is the function here it's going to

28596
18:53:07,600 --> 18:53:10,800
be using the logic from hdr cmp

28597
18:53:10,800 --> 18:53:12,800
and notice what we return we're going to

28598
18:53:12,800 --> 18:53:15,192
return whichever strength

28599
18:53:15,192 --> 18:53:17,120
compares the greater to the other so

28600
18:53:17,120 --> 18:53:19,512
we're going to do strcmp we're going to

28601
18:53:19,512 --> 18:53:22,080
pass in our two arguments here and we're

28602
18:53:22,080 --> 18:53:23,512
going to say

28603
18:53:23,512 --> 18:53:26,080
if this returns something greater than 0

28604
18:53:26,080 --> 18:53:28,552
return a because in that case

28605
18:53:28,552 --> 18:53:31,080
a is greater than b

28606
18:53:31,080 --> 18:53:33,192
lexicographically this is the comparison

28607
18:53:33,192 --> 18:53:35,040
we want to do here and otherwise you're

28608
18:53:35,040 --> 18:53:36,640
going to return b and this is going to

28609
18:53:36,640 --> 18:53:38,872
compare our strings and not compare

28610
18:53:38,872 --> 18:53:41,120
pointers directly which is what we are

28611
18:53:41,120 --> 18:53:43,040
trying to avoid here and you see that

28612
18:53:43,040 --> 18:53:45,120
template specialization is really

28613
18:53:45,120 --> 18:53:48,480
helping out here now if we have this n

28614
18:53:48,480 --> 18:53:51,280
and the compiler sees a call like this

28615
18:53:51,280 --> 18:53:53,120
it's not going to compare pointers it's

28616
18:53:53,120 --> 18:53:55,680
going to use the template specialization

28617
18:53:55,680 --> 18:53:58,080
because the compiler knows that this is

28618
18:53:58,080 --> 18:53:59,280
a better

28619
18:53:59,280 --> 18:54:02,000
fit for the call that we are doing here

28620
18:54:02,000 --> 18:54:04,320
because we are passing cost card

28621
18:54:04,320 --> 18:54:06,480
pointers this is how template

28622
18:54:06,480 --> 18:54:08,872
specialization works and it can really

28623
18:54:08,872 --> 18:54:11,832
come in handy if you are doing things

28624
18:54:11,832 --> 18:54:14,160
that work with pointers we are going to

28625
18:54:14,160 --> 18:54:16,240
head over to visual studio code and play

28626
18:54:16,240 --> 18:54:18,160
with this a little more okay here we are

28627
18:54:18,160 --> 18:54:20,320
in our working folder the current

28628
18:54:20,320 --> 18:54:22,400
project is template specialization we're

28629
18:54:22,400 --> 18:54:25,192
going to grab our template files

28630
18:54:25,192 --> 18:54:27,512
we're going to put them in place and

28631
18:54:27,512 --> 18:54:29,440
we're going to open this in visual

28632
18:54:29,440 --> 18:54:32,240
studio code by dragging and dropping on

28633
18:54:32,240 --> 18:54:34,480
top of visual studio code here this is

28634
18:54:34,480 --> 18:54:36,080
going to open our project and we're

28635
18:54:36,080 --> 18:54:38,160
going to clean it up a little bit and

28636
18:54:38,160 --> 18:54:39,920
we're going to close the left pane here

28637
18:54:39,920 --> 18:54:41,832
we don't need it anymore the first thing

28638
18:54:41,832 --> 18:54:43,600
we're going to do is to put in our

28639
18:54:43,600 --> 18:54:46,000
function template the same thing we have

28640
18:54:46,000 --> 18:54:48,480
been doing for a gazillion times by now

28641
18:54:48,480 --> 18:54:50,800
the maximum function is going to return

28642
18:54:50,800 --> 18:54:53,680
whichever is greater between a and b and

28643
18:54:53,680 --> 18:54:55,760
it is doing this by value after that

28644
18:54:55,760 --> 18:54:57,440
we're going to head over in the main

28645
18:54:57,440 --> 18:54:59,600
function and set up a piece of code to

28646
18:54:59,600 --> 18:55:01,440
really play with us we're going to set

28647
18:55:01,440 --> 18:55:03,360
up a few variables and we're going to

28648
18:55:03,360 --> 18:55:06,960
call our functions so we're going to say

28649
18:55:06,960 --> 18:55:09,040
maximum a and b this is going to return

28650
18:55:09,040 --> 18:55:11,192
the maximum between a and b the compiler

28651
18:55:11,192 --> 18:55:14,000
is going to deduce that the template

28652
18:55:14,000 --> 18:55:16,160
instance should be of ant type so it's

28653
18:55:16,160 --> 18:55:18,240
going to generate that and call it it's

28654
18:55:18,240 --> 18:55:20,000
going to give us the return value here

28655
18:55:20,000 --> 18:55:22,000
we can print it out and see it and we're

28656
18:55:22,000 --> 18:55:23,920
going to basically do the same

28657
18:55:23,920 --> 18:55:26,640
for double type and the string types

28658
18:55:26,640 --> 18:55:27,920
here and you're going to see that this

28659
18:55:27,920 --> 18:55:30,080
is going to work just fine so let's

28660
18:55:30,080 --> 18:55:32,640
build this we're going to use gcc to do

28661
18:55:32,640 --> 18:55:35,920
that the bolt is good we can clear and i

28662
18:55:35,920 --> 18:55:38,480
bring up a terminal to run this

28663
18:55:38,480 --> 18:55:40,320
and really see the output here we can

28664
18:55:40,320 --> 18:55:43,680
clear and run rooster you see max end is

28665
18:55:43,680 --> 18:55:46,080
23 because that's what we have here max

28666
18:55:46,080 --> 18:55:48,080
double 34

28667
18:55:48,080 --> 18:55:50,720
and that's what we have here and we

28668
18:55:50,720 --> 18:55:53,600
called max double to be of int type we

28669
18:55:53,600 --> 18:55:55,920
should use auto type deduction here to

28670
18:55:55,920 --> 18:55:57,760
avoid these mistakes

28671
18:55:57,760 --> 18:55:59,920
because the compiler can do this better

28672
18:55:59,920 --> 18:56:00,960
than us

28673
18:56:00,960 --> 18:56:02,800
that's what we're going to do and we're

28674
18:56:02,800 --> 18:56:05,280
going to deduce max sdr here and we're

28675
18:56:05,280 --> 18:56:08,480
going to build again let's weld with gcc

28676
18:56:08,480 --> 18:56:10,960
because that's my favorite compiler i'm

28677
18:56:10,960 --> 18:56:13,512
going to clear and run rooster now we

28678
18:56:13,512 --> 18:56:16,000
have correct output we have 23 which is

28679
18:56:16,000 --> 18:56:18,320
the maximum between a and b

28680
18:56:18,320 --> 18:56:21,920
we have 34.7 which was deduced to be of

28681
18:56:21,920 --> 18:56:24,160
type double here and then we have the

28682
18:56:24,160 --> 18:56:26,640
maximum strength which happens to be

28683
18:56:26,640 --> 18:56:28,552
world here again

28684
18:56:28,552 --> 18:56:30,800
when comparing strengths the default is

28685
18:56:30,800 --> 18:56:32,440
going to compare them

28686
18:56:32,440 --> 18:56:35,120
lexicographically and what that means

28687
18:56:35,120 --> 18:56:38,240
the one that comes after the other in

28688
18:56:38,240 --> 18:56:40,000
alphabetical order is going to be

28689
18:56:40,000 --> 18:56:42,800
greater by that logic world is greater

28690
18:56:42,800 --> 18:56:45,280
than hello and it is what we are seeing

28691
18:56:45,280 --> 18:56:47,120
printed out here okay this is working

28692
18:56:47,120 --> 18:56:50,160
just fine but what if we use cost card

28693
18:56:50,160 --> 18:56:52,480
pointers and try to call our maximum

28694
18:56:52,480 --> 18:56:55,120
function template and by that i mean

28695
18:56:55,120 --> 18:56:57,040
doing something like this we have two

28696
18:56:57,040 --> 18:56:58,160
variables

28697
18:56:58,160 --> 18:57:01,600
g and h which are of type cost card

28698
18:57:01,600 --> 18:57:04,000
pointers so they are c strings they are

28699
18:57:04,000 --> 18:57:06,080
going to be now terminated because we

28700
18:57:06,080 --> 18:57:08,552
are initializing them with a string

28701
18:57:08,552 --> 18:57:10,960
electron and we are comparing them here

28702
18:57:10,960 --> 18:57:13,600
we are saying maximum g and h and we're

28703
18:57:13,600 --> 18:57:15,760
going to print whichever is the maximum

28704
18:57:15,760 --> 18:57:18,160
after we return that from the function

28705
18:57:18,160 --> 18:57:19,920
when the compiler sees the call like

28706
18:57:19,920 --> 18:57:21,512
this it's going to do what it knows to

28707
18:57:21,512 --> 18:57:23,680
do it's going to replace an

28708
18:57:23,680 --> 18:57:26,640
scar pointer in our function template

28709
18:57:26,640 --> 18:57:28,400
here so it's going to return cost card

28710
18:57:28,400 --> 18:57:30,080
pointer it's going to pass the

28711
18:57:30,080 --> 18:57:32,320
parameters as coast guard pointers and

28712
18:57:32,320 --> 18:57:33,600
we're going to be comparing these

28713
18:57:33,600 --> 18:57:36,080
pointers here and we're going to return

28714
18:57:36,080 --> 18:57:39,120
whichever pointer is greater again here

28715
18:57:39,120 --> 18:57:41,120
you must be noticing the problem we're

28716
18:57:41,120 --> 18:57:43,192
going to return whichever pointer is

28717
18:57:43,192 --> 18:57:45,360
greater and we're not going to be

28718
18:57:45,360 --> 18:57:47,832
returning the actual string data we're

28719
18:57:47,832 --> 18:57:50,400
going to be returning just the address

28720
18:57:50,400 --> 18:57:52,800
and this can be really wrong because if

28721
18:57:52,800 --> 18:57:55,512
the addresses happen to be messed up

28722
18:57:55,512 --> 18:57:57,832
we're going to get the wrong output so

28723
18:57:57,832 --> 18:58:00,720
let's try and prove this again for that

28724
18:58:00,720 --> 18:58:02,872
i am going to comment out what we had on

28725
18:58:02,872 --> 18:58:05,040
top here because this could mess things

28726
18:58:05,040 --> 18:58:06,400
up a little bit

28727
18:58:06,400 --> 18:58:08,640
so i'm going to comment all this now and

28728
18:58:08,640 --> 18:58:10,640
i am going to debug this

28729
18:58:10,640 --> 18:58:13,120
so we're going to look at this line here

28730
18:58:13,120 --> 18:58:15,360
and i think we should say

28731
18:58:15,360 --> 18:58:18,800
cos car pointer result and i say equals

28732
18:58:18,800 --> 18:58:22,160
max c mom g and h and i printed the

28733
18:58:22,160 --> 18:58:24,160
result here this is going to make it

28734
18:58:24,160 --> 18:58:26,080
easier to step into this function

28735
18:58:26,080 --> 18:58:29,440
without the noise from stdc out here so

28736
18:58:29,440 --> 18:58:31,440
we're going to set up our breakpoint

28737
18:58:31,440 --> 18:58:33,760
here we're going to hit our

28738
18:58:33,760 --> 18:58:36,000
run tab and we're going to debug this

28739
18:58:36,000 --> 18:58:37,512
program and we're going to hit this

28740
18:58:37,512 --> 18:58:40,400
breakpoint here let's see the types that

28741
18:58:40,400 --> 18:58:43,360
we have inside our function call

28742
18:58:43,360 --> 18:58:45,512
so now that we are here we're going to

28743
18:58:45,512 --> 18:58:48,720
see that our locals are g and h and they

28744
18:58:48,720 --> 18:58:51,832
contain our strength if we go inside

28745
18:58:51,832 --> 18:58:54,240
we're going to see that g is really a

28746
18:58:54,240 --> 18:58:56,400
pointer to the first element in our

28747
18:58:56,400 --> 18:58:59,280
string here and it contains

28748
18:58:59,280 --> 18:59:00,720
w here

28749
18:59:00,720 --> 18:59:03,280
which is what we have here

28750
18:59:03,280 --> 18:59:05,832
and h is going to be a pointer to a

28751
18:59:05,832 --> 18:59:08,000
that's what we have here okay

28752
18:59:08,000 --> 18:59:10,480
and result is going to contain some junk

28753
18:59:10,480 --> 18:59:13,040
data because it's not initialized yet

28754
18:59:13,040 --> 18:59:15,600
but we can step into this function

28755
18:59:15,600 --> 18:59:18,552
and see things happening a again is an

28756
18:59:18,552 --> 18:59:21,040
address and b is an address you see that

28757
18:59:21,040 --> 18:59:23,192
the debugger is really smart it's

28758
18:59:23,192 --> 18:59:25,360
noticing that this is a pointer to a

28759
18:59:25,360 --> 18:59:27,512
strength and it's going to show us the

28760
18:59:27,512 --> 18:59:29,832
string here but what we compare are

28761
18:59:29,832 --> 18:59:33,360
these two addresses and you see that b

28762
18:59:33,360 --> 18:59:36,240
lives in a larger address it leaves at

28763
18:59:36,240 --> 18:59:40,160
address that ends in 55 and a lives at

28764
18:59:40,160 --> 18:59:43,440
the address that ends in 50. so if we

28765
18:59:43,440 --> 18:59:45,920
really execute this function we're going

28766
18:59:45,920 --> 18:59:48,720
to return the pointer to b but you see

28767
18:59:48,720 --> 18:59:51,120
that b is not really the greater string

28768
18:59:51,120 --> 18:59:52,640
and this is really something bad you

28769
18:59:52,640 --> 18:59:54,640
should be aware of this this is what the

28770
18:59:54,640 --> 18:59:56,720
compiler is doing by default and it is

28771
18:59:56,720 --> 18:59:59,440
going to give us a result that is not

28772
18:59:59,440 --> 19:00:02,240
correct let's close this and see a way

28773
19:00:02,240 --> 19:00:05,120
we can solve this problem and we can use

28774
19:00:05,120 --> 19:00:07,680
template specialization for this what we

28775
19:00:07,680 --> 19:00:10,320
really need is a way to compare c

28776
19:00:10,320 --> 19:00:12,552
strings and not compare pointers like we

28777
19:00:12,552 --> 19:00:14,080
are doing here we're going to do that

28778
19:00:14,080 --> 19:00:16,720
using a template specialization

28779
19:00:16,720 --> 19:00:18,800
and the syntax for this to work you say

28780
19:00:18,800 --> 19:00:21,440
template and you specify an empty pair

28781
19:00:21,440 --> 19:00:24,320
of angle brackets and then you specify

28782
19:00:24,320 --> 19:00:26,400
whatever function you want to use so

28783
19:00:26,400 --> 19:00:28,160
we're going to go down here and specify

28784
19:00:28,160 --> 19:00:30,080
that we want to return the cost card

28785
19:00:30,080 --> 19:00:31,040
pointer

28786
19:00:31,040 --> 19:00:32,400
the function is going to be called

28787
19:00:32,400 --> 19:00:34,872
maximum we're going to specify an

28788
19:00:34,872 --> 19:00:38,080
explicit template argument which is of

28789
19:00:38,080 --> 19:00:40,400
const car pointer because we want this

28790
19:00:40,400 --> 19:00:42,872
template instance to work for scar

28791
19:00:42,872 --> 19:00:43,832
pointers

28792
19:00:43,832 --> 19:00:45,832
so once we have this end we're going to

28793
19:00:45,832 --> 19:00:47,680
specify our parameters we're going to

28794
19:00:47,680 --> 19:00:50,640
say cos car pointer a and cost car

28795
19:00:50,640 --> 19:00:53,040
pointer b and we're going to head into

28796
19:00:53,040 --> 19:00:55,760
the body of our function template here

28797
19:00:55,760 --> 19:00:58,160
now we have our two parameters and we're

28798
19:00:58,160 --> 19:01:00,480
going to compare them as if they were

28799
19:01:00,480 --> 19:01:02,800
const color strengths and we have seen

28800
19:01:02,800 --> 19:01:04,720
that we have a built-in facility from

28801
19:01:04,720 --> 19:01:07,360
the c plus plus standard library it is

28802
19:01:07,360 --> 19:01:10,640
this htr cmp function we can use it to

28803
19:01:10,640 --> 19:01:12,640
compare two strengths and we're going to

28804
19:01:12,640 --> 19:01:14,800
use the logic that we have here so if

28805
19:01:14,800 --> 19:01:17,192
the first parameter is less than the

28806
19:01:17,192 --> 19:01:19,360
second parameter i am talking in a

28807
19:01:19,360 --> 19:01:21,192
lexicographical order we're going to

28808
19:01:21,192 --> 19:01:23,040
return something negative if they are

28809
19:01:23,040 --> 19:01:24,872
equal dexicographically we're going to

28810
19:01:24,872 --> 19:01:27,512
return zero and if the

28811
19:01:27,512 --> 19:01:30,240
first parameter is greater than the

28812
19:01:30,240 --> 19:01:33,120
second parameter lexicographically we're

28813
19:01:33,120 --> 19:01:36,000
going to return a positive value so

28814
19:01:36,000 --> 19:01:38,872
let's transform this logic into a

28815
19:01:38,872 --> 19:01:41,120
ternary operator we're going to say

28816
19:01:41,120 --> 19:01:46,320
return sdd str cmp we can say that and

28817
19:01:46,320 --> 19:01:47,600
if you have access to this function

28818
19:01:47,600 --> 19:01:50,160
we're going to need to include c string

28819
19:01:50,160 --> 19:01:52,320
let's do that we're going to include the

28820
19:01:52,320 --> 19:01:55,440
c string library and now we can say this

28821
19:01:55,440 --> 19:01:58,160
and we're going to pass in a and b and

28822
19:01:58,160 --> 19:02:00,400
we're going to ask ourselves is this

28823
19:02:00,400 --> 19:02:02,480
greater than zero okay if it's greater

28824
19:02:02,480 --> 19:02:05,440
than zero then if the first parameter is

28825
19:02:05,440 --> 19:02:07,360
greater than the second parameter let's

28826
19:02:07,360 --> 19:02:09,832
see graphically so we're going to return

28827
19:02:09,832 --> 19:02:10,720
a

28828
19:02:10,720 --> 19:02:12,080
if it's not the case we're going to

28829
19:02:12,080 --> 19:02:14,320
return b this is our ternary operator

28830
19:02:14,320 --> 19:02:16,960
here and it is going to work now that we

28831
19:02:16,960 --> 19:02:19,360
have this n the compiler is going to

28832
19:02:19,360 --> 19:02:22,640
know we have a template specialization

28833
19:02:22,640 --> 19:02:25,040
for a const car pointer if we call the

28834
19:02:25,040 --> 19:02:27,040
function like we did here calling the

28835
19:02:27,040 --> 19:02:29,512
maximum function the compiler is not

28836
19:02:29,512 --> 19:02:31,760
going to use this function template we

28837
19:02:31,760 --> 19:02:34,240
have on top here it's going to see that

28838
19:02:34,240 --> 19:02:37,832
this template specialization is better

28839
19:02:37,832 --> 19:02:40,240
for the cost card pointer type that we

28840
19:02:40,240 --> 19:02:42,872
are passing here and now if we try to

28841
19:02:42,872 --> 19:02:45,120
build and run the program the boat is

28842
19:02:45,120 --> 19:02:47,512
going to be good if we clear and run

28843
19:02:47,512 --> 19:02:49,440
rooster we're going to see that now the

28844
19:02:49,440 --> 19:02:51,280
maximum is wild

28845
19:02:51,280 --> 19:02:54,320
let's see what we see if we don't have

28846
19:02:54,320 --> 19:02:56,320
this specialization and we're going to

28847
19:02:56,320 --> 19:02:58,240
comment this out because i don't think i

28848
19:02:58,240 --> 19:03:00,160
really showed you we're going to build

28849
19:03:00,160 --> 19:03:02,552
again and again if we do this

28850
19:03:02,552 --> 19:03:04,320
this function template is going to be

28851
19:03:04,320 --> 19:03:06,160
used and you know that it is going to

28852
19:03:06,160 --> 19:03:08,872
deduce a function that compares pointers

28853
19:03:08,872 --> 19:03:10,872
directly and that's going to be really

28854
19:03:10,872 --> 19:03:13,600
bad we can build this with gcc and

28855
19:03:13,600 --> 19:03:16,400
really see what we get as output we can

28856
19:03:16,400 --> 19:03:18,720
clear and run rooster now you see that

28857
19:03:18,720 --> 19:03:21,440
we are saying animal is the maximum

28858
19:03:21,440 --> 19:03:23,600
between these two guys but that's not

28859
19:03:23,600 --> 19:03:27,680
true animal is less than wild in

28860
19:03:27,680 --> 19:03:30,640
lexicographical order we need a way to

28861
19:03:30,640 --> 19:03:32,080
really compare

28862
19:03:32,080 --> 19:03:35,120
c strings properly and our template

28863
19:03:35,120 --> 19:03:36,640
specialization

28864
19:03:36,640 --> 19:03:40,240
is really doing that using the htd crmp

28865
19:03:40,240 --> 19:03:43,040
function and it is working pretty well

28866
19:03:43,040 --> 19:03:44,872
this is really all template

28867
19:03:44,872 --> 19:03:47,040
specialization is all about you're going

28868
19:03:47,040 --> 19:03:49,360
to do this if the default function

28869
19:03:49,360 --> 19:03:51,440
template you have is really not working

28870
19:03:51,440 --> 19:03:53,920
according to your needs for the type

28871
19:03:53,920 --> 19:03:56,320
that you want to use for this and use

28872
19:03:56,320 --> 19:03:58,000
this to your advantage because it's

28873
19:03:58,000 --> 19:04:00,160
available to you and now you know how to

28874
19:04:00,160 --> 19:04:02,320
use this the syntax is really simple you

28875
19:04:02,320 --> 19:04:04,640
say template and you say angle brackets

28876
19:04:04,640 --> 19:04:07,192
and then you specify whichever

28877
19:04:07,192 --> 19:04:09,600
implementation you want for your

28878
19:04:09,600 --> 19:04:12,000
specific type for example here our

28879
19:04:12,000 --> 19:04:14,000
specific type for which we want to

28880
19:04:14,000 --> 19:04:16,872
specify this function template is cost

28881
19:04:16,872 --> 19:04:17,760
card

28882
19:04:17,760 --> 19:04:20,552
you specify that as an explicit

28883
19:04:20,552 --> 19:04:22,400
template argument and then you specify

28884
19:04:22,400 --> 19:04:25,040
your return value your parameters and

28885
19:04:25,040 --> 19:04:27,360
you do whatever logic you need to do to

28886
19:04:27,360 --> 19:04:29,760
do things right in the body of this

28887
19:04:29,760 --> 19:04:32,320
template specialization here i would

28888
19:04:32,320 --> 19:04:34,552
like to welcome you in this new chapter

28889
19:04:34,552 --> 19:04:36,240
where we're going to be learning about

28890
19:04:36,240 --> 19:04:40,000
concepts concepts are a mechanism we can

28891
19:04:40,000 --> 19:04:42,320
use to set up constraints or

28892
19:04:42,320 --> 19:04:45,040
restrictions on the template parameters

28893
19:04:45,040 --> 19:04:47,512
in our function templates for example we

28894
19:04:47,512 --> 19:04:49,440
can use this technique to say that we

28895
19:04:49,440 --> 19:04:51,680
want our function to be only called with

28896
19:04:51,680 --> 19:04:53,680
integers and if you call it with

28897
19:04:53,680 --> 19:04:55,920
something that isn't an integer it's

28898
19:04:55,920 --> 19:04:58,080
going to give you a compiler one thing i

28899
19:04:58,080 --> 19:05:00,552
should emphasize is that concepts are

28900
19:05:00,552 --> 19:05:03,280
one of the big four features in c plus

28901
19:05:03,280 --> 19:05:05,120
plus 20. so we're going to be learning

28902
19:05:05,120 --> 19:05:07,280
about this in this chapter we have just

28903
19:05:07,280 --> 19:05:09,440
said that we use them to place

28904
19:05:09,440 --> 19:05:12,552
constraints on our template parameters

28905
19:05:12,552 --> 19:05:14,400
but we saw that we could do something

28906
19:05:14,400 --> 19:05:16,872
like that in the last chapter where we

28907
19:05:16,872 --> 19:05:19,120
could use type trades and static

28908
19:05:19,120 --> 19:05:21,680
concerns for example if you look at the

28909
19:05:21,680 --> 19:05:22,960
function here it's going to print a

28910
19:05:22,960 --> 19:05:25,360
number but we have a requirement for

28911
19:05:25,360 --> 19:05:28,160
this number to be an integral type

28912
19:05:28,160 --> 19:05:30,240
through the static assert that we have

28913
19:05:30,240 --> 19:05:32,480
here we're going to see that we can do

28914
19:05:32,480 --> 19:05:35,440
something really similar with concepts

28915
19:05:35,440 --> 19:05:37,760
but it's going to be much cleaner and

28916
19:05:37,760 --> 19:05:40,832
that the logic to enforce our

28917
19:05:40,832 --> 19:05:43,040
constraints is not going to be in the

28918
19:05:43,040 --> 19:05:45,192
function body it's going to be somewhat

28919
19:05:45,192 --> 19:05:47,360
in the function declaration in the

28920
19:05:47,360 --> 19:05:49,440
constraints that we put on the template

28921
19:05:49,440 --> 19:05:50,872
parameter here we're going to see

28922
19:05:50,872 --> 19:05:53,760
specific syntaxes of how you can do this

28923
19:05:53,760 --> 19:05:56,080
starting in the next lecture there are

28924
19:05:56,080 --> 19:05:59,040
two sides to concepts in c plus plus

28925
19:05:59,040 --> 19:06:01,280
there are standard built-in concepts

28926
19:06:01,280 --> 19:06:03,120
that come with the c plus plus

28927
19:06:03,120 --> 19:06:05,760
programming language but if for some

28928
19:06:05,760 --> 19:06:08,400
reason these happen not to be enough you

28929
19:06:08,400 --> 19:06:10,320
can build your own and we're going to

28930
19:06:10,320 --> 19:06:12,320
see how we can do that later in this

28931
19:06:12,320 --> 19:06:15,040
chapter here are a few examples of

28932
19:06:15,040 --> 19:06:17,280
concepts you can use in your c plus plus

28933
19:06:17,280 --> 19:06:19,600
program you can use the integral

28934
19:06:19,600 --> 19:06:21,920
concepts to enforce that your parameters

28935
19:06:21,920 --> 19:06:24,320
be integrals you can use the floating

28936
19:06:24,320 --> 19:06:26,400
point concept to enforce that your

28937
19:06:26,400 --> 19:06:29,040
template parameters be of floating point

28938
19:06:29,040 --> 19:06:31,120
type you can do all kinds of crazy

28939
19:06:31,120 --> 19:06:33,920
things okay concepts are really cool and

28940
19:06:33,920 --> 19:06:35,440
they are going to make your function

28941
19:06:35,440 --> 19:06:38,240
templates much safer to work with we are

28942
19:06:38,240 --> 19:06:40,320
going to stop here in this lecture and

28943
19:06:40,320 --> 19:06:42,872
show you how you can use concepts

28944
19:06:42,872 --> 19:06:45,040
starting in the next lecture go ahead

28945
19:06:45,040 --> 19:06:47,760
and finish up here and meet me there in

28946
19:06:47,760 --> 19:06:49,600
this lecture we're going to learn about

28947
19:06:49,600 --> 19:06:53,280
concepts again concepts are a mechanism

28948
19:06:53,280 --> 19:06:56,400
we have in place in c plus 20 to place

28949
19:06:56,400 --> 19:06:59,832
constraints on our function templates

28950
19:06:59,832 --> 19:07:01,760
for example we can use concepts to

28951
19:07:01,760 --> 19:07:03,120
specify

28952
19:07:03,120 --> 19:07:05,600
that we want our function template to

28953
19:07:05,600 --> 19:07:08,552
only be called with integers or doubles

28954
19:07:08,552 --> 19:07:10,640
or strings or whatever

28955
19:07:10,640 --> 19:07:13,680
and when somebody violates our concept

28956
19:07:13,680 --> 19:07:15,512
they're going to get a compiler error in

28957
19:07:15,512 --> 19:07:17,512
this lecture i am going to show you how

28958
19:07:17,512 --> 19:07:19,360
you can set up your concept and the

28959
19:07:19,360 --> 19:07:21,832
different syntaxes you can use and how

28960
19:07:21,832 --> 19:07:23,600
we can understand them

28961
19:07:23,600 --> 19:07:25,920
but before we do that please note that

28962
19:07:25,920 --> 19:07:28,480
there are two sides to concepts there

28963
19:07:28,480 --> 19:07:31,360
are concepts that are standard and built

28964
19:07:31,360 --> 19:07:34,320
into the c plus plus standard library

28965
19:07:34,320 --> 19:07:36,400
and those are ready to use and these are

28966
19:07:36,400 --> 19:07:37,920
what we're going to be using in this

28967
19:07:37,920 --> 19:07:40,720
lecture but know that you can also build

28968
19:07:40,720 --> 19:07:43,360
your own concepts and use them to do

28969
19:07:43,360 --> 19:07:45,760
whatever it is you want to do here are a

28970
19:07:45,760 --> 19:07:48,320
few examples of built-in concepts we can

28971
19:07:48,320 --> 19:07:50,320
use from the c plus plus standard

28972
19:07:50,320 --> 19:07:53,192
library we have for example a concept we

28973
19:07:53,192 --> 19:07:55,040
can use to enforce

28974
19:07:55,040 --> 19:07:57,680
that people call our functions only with

28975
19:07:57,680 --> 19:08:00,640
integral types if they violate this

28976
19:08:00,640 --> 19:08:02,552
they're going to get a compiler error we

28977
19:08:02,552 --> 19:08:04,800
can also enforce for our template

28978
19:08:04,800 --> 19:08:07,040
parameters to be floating point we can

28979
19:08:07,040 --> 19:08:09,192
do all kinds of crazy things okay now

28980
19:08:09,192 --> 19:08:11,280
that you know this let's see how we can

28981
19:08:11,280 --> 19:08:13,760
set up a concept on our function

28982
19:08:13,760 --> 19:08:16,240
templates and this is the first syntax

28983
19:08:16,240 --> 19:08:18,240
we're going to look at all you really

28984
19:08:18,240 --> 19:08:21,120
have to do is to put in your template

28985
19:08:21,120 --> 19:08:23,192
declaration like we have been doing all

28986
19:08:23,192 --> 19:08:26,160
along you also have to add in the

28987
19:08:26,160 --> 19:08:29,680
requires keyword here after the requires

28988
19:08:29,680 --> 19:08:31,512
keyword you're going to specify your

28989
19:08:31,512 --> 19:08:34,800
concept and specify your template

28990
19:08:34,800 --> 19:08:37,512
parameter in angle brackets here

28991
19:08:37,512 --> 19:08:39,920
when you have this thing in front of

28992
19:08:39,920 --> 19:08:42,240
your function template like we have here

28993
19:08:42,240 --> 19:08:44,552
the function template can only work

28994
19:08:44,552 --> 19:08:47,680
right if the concept in here is

28995
19:08:47,680 --> 19:08:50,400
satisfied and this concept in this case

28996
19:08:50,400 --> 19:08:53,280
is going to be satisfied if somebody

28997
19:08:53,280 --> 19:08:56,080
tries to call this function template

28998
19:08:56,080 --> 19:08:59,120
only with integral types if they violate

28999
19:08:59,120 --> 19:09:00,872
that again they are going to get a

29000
19:09:00,872 --> 19:09:03,192
compiler error okay once we have this

29001
19:09:03,192 --> 19:09:05,680
concept set up we can look at the piece

29002
19:09:05,680 --> 19:09:08,800
of code that tries to use it and try to

29003
19:09:08,800 --> 19:09:11,120
guess what is going to happen here is a

29004
19:09:11,120 --> 19:09:12,800
piece of code we would set up in the

29005
19:09:12,800 --> 19:09:15,192
main function and try to call a function

29006
19:09:15,192 --> 19:09:17,920
template we have two variables of car

29007
19:09:17,920 --> 19:09:20,480
type we know that car is an integral

29008
19:09:20,480 --> 19:09:23,680
type so if we issue a call like this

29009
19:09:23,680 --> 19:09:25,832
this call is going to work the template

29010
19:09:25,832 --> 19:09:28,160
instance is going to be generated and

29011
19:09:28,160 --> 19:09:29,920
it's going to be called and give us the

29012
19:09:29,920 --> 19:09:32,080
results that we can print here this is

29013
19:09:32,080 --> 19:09:35,040
right on the second piece of code here

29014
19:09:35,040 --> 19:09:38,160
we have two variables of type and

29015
19:09:38,160 --> 19:09:40,000
we're going to call them we're going to

29016
19:09:40,000 --> 19:09:42,640
call our function template with and

29017
19:09:42,640 --> 19:09:45,512
and this is also an integral type int is

29018
19:09:45,512 --> 19:09:47,280
an integral type so this is going to

29019
19:09:47,280 --> 19:09:50,000
generate our function template instance

29020
19:09:50,000 --> 19:09:51,600
and we're going to call it and get the

29021
19:09:51,600 --> 19:09:54,240
results that we print here and if we try

29022
19:09:54,240 --> 19:09:56,800
to call our function template with

29023
19:09:56,800 --> 19:09:58,400
double types

29024
19:09:58,400 --> 19:10:00,640
the concept is not going to be satisfied

29025
19:10:00,640 --> 19:10:02,400
and we're going to get some kind of

29026
19:10:02,400 --> 19:10:04,960
error and our function template instance

29027
19:10:04,960 --> 19:10:06,872
is not going to be generated this is

29028
19:10:06,872 --> 19:10:09,832
really how you can use concepts to force

29029
19:10:09,832 --> 19:10:13,120
some rules on users of your function

29030
19:10:13,120 --> 19:10:15,440
templates if i can say it like that we

29031
19:10:15,440 --> 19:10:17,512
have been able to do something like this

29032
19:10:17,512 --> 19:10:19,512
using typed traits and the static

29033
19:10:19,512 --> 19:10:22,240
asserts in the last chapter but concepts

29034
19:10:22,240 --> 19:10:24,872
are much cleaner and that they are kind

29035
19:10:24,872 --> 19:10:27,040
of built into the signature of your

29036
19:10:27,040 --> 19:10:28,800
function you don't have to go in the

29037
19:10:28,800 --> 19:10:30,872
body of your function and set up static

29038
19:10:30,872 --> 19:10:33,440
asserts the function is already

29039
19:10:33,440 --> 19:10:36,720
supporting concepts when you declare and

29040
19:10:36,720 --> 19:10:38,800
define it and this is really cool okay

29041
19:10:38,800 --> 19:10:40,960
this is our first syntax we can use to

29042
19:10:40,960 --> 19:10:43,192
set up concepts

29043
19:10:43,192 --> 19:10:45,360
for our function templates using the

29044
19:10:45,360 --> 19:10:47,680
requires close after our template

29045
19:10:47,680 --> 19:10:50,480
declaration and following that with

29046
19:10:50,480 --> 19:10:53,192
whatever concept we want to enforce on

29047
19:10:53,192 --> 19:10:55,360
our function template here please note

29048
19:10:55,360 --> 19:10:57,512
that you can also use type traits

29049
19:10:57,512 --> 19:10:58,720
directly

29050
19:10:58,720 --> 19:11:00,720
in the required clause here and this is

29051
19:11:00,720 --> 19:11:03,680
going to work and this really says that

29052
19:11:03,680 --> 19:11:05,680
all you really have to put after the

29053
19:11:05,680 --> 19:11:07,280
requires close

29054
19:11:07,280 --> 19:11:09,920
is an expression that can be evaluated

29055
19:11:09,920 --> 19:11:13,680
at compile time but also results in a

29056
19:11:13,680 --> 19:11:16,640
boolean value once you satisfy these few

29057
19:11:16,640 --> 19:11:19,360
requirements you can really set up your

29058
19:11:19,360 --> 19:11:21,512
concept however you want you just have

29059
19:11:21,512 --> 19:11:24,640
to be careful that the expiration can be

29060
19:11:24,640 --> 19:11:27,680
evaluated at compile time and that it

29061
19:11:27,680 --> 19:11:30,552
evaluates to a boolean value and when

29062
19:11:30,552 --> 19:11:32,720
the expression evaluates to true the

29063
19:11:32,720 --> 19:11:35,600
concept is going to succeed if the

29064
19:11:35,600 --> 19:11:37,832
expression evaluates to false you're

29065
19:11:37,832 --> 19:11:39,600
going to get a compiler error because

29066
19:11:39,600 --> 19:11:42,080
the concept is not satisfied this is how

29067
19:11:42,080 --> 19:11:44,160
these things work now that we have seen

29068
19:11:44,160 --> 19:11:46,800
the first syntax i think it is big time

29069
19:11:46,800 --> 19:11:48,872
we looked at the second way you can set

29070
19:11:48,872 --> 19:11:51,760
up concepts and that's going to be in

29071
19:11:51,760 --> 19:11:53,920
your template declaration you're going

29072
19:11:53,920 --> 19:11:55,832
to say template put in your angle

29073
19:11:55,832 --> 19:11:58,400
brackets and inside instead of saying

29074
19:11:58,400 --> 19:12:00,640
type name t like we have been doing all

29075
19:12:00,640 --> 19:12:03,512
along you just specify your concept

29076
19:12:03,512 --> 19:12:06,872
directly and save the template parameter

29077
19:12:06,872 --> 19:12:09,760
like this once you do this this concept

29078
19:12:09,760 --> 19:12:12,080
is going to be enforced on this function

29079
19:12:12,080 --> 19:12:14,160
template here this is just another

29080
19:12:14,160 --> 19:12:16,160
syntax to really do the same thing we

29081
19:12:16,160 --> 19:12:18,720
also have a third syntax we can use if

29082
19:12:18,720 --> 19:12:21,512
we use auto to set up our function

29083
19:12:21,512 --> 19:12:23,920
templates and the way this works is to

29084
19:12:23,920 --> 19:12:26,872
just add your concept in front of the

29085
19:12:26,872 --> 19:12:30,000
auto keyword and once you do this the

29086
19:12:30,000 --> 19:12:31,920
compiler is going to enforce for the

29087
19:12:31,920 --> 19:12:33,920
first parameter and the second parameter

29088
19:12:33,920 --> 19:12:35,280
to this function

29089
19:12:35,280 --> 19:12:38,960
to satisfy the integral concepts so if

29090
19:12:38,960 --> 19:12:41,280
you have to use auto to set up function

29091
19:12:41,280 --> 19:12:43,360
templates this is how you can use

29092
19:12:43,360 --> 19:12:45,600
concepts to constrain

29093
19:12:45,600 --> 19:12:47,832
ways in which people use your function

29094
19:12:47,832 --> 19:12:50,000
we still have another way we can use

29095
19:12:50,000 --> 19:12:52,872
concepts in c plus plus and this is how

29096
19:12:52,872 --> 19:12:54,720
you do it you specify your template

29097
19:12:54,720 --> 19:12:56,872
declaration like we have been doing all

29098
19:12:56,872 --> 19:12:59,760
along you specify your function template

29099
19:12:59,760 --> 19:13:02,872
but after the parameter list as we see

29100
19:13:02,872 --> 19:13:05,120
here you're going to put your requires

29101
19:13:05,120 --> 19:13:07,600
close and you can put that in this place

29102
19:13:07,600 --> 19:13:10,160
here and it is going to work i realize

29103
19:13:10,160 --> 19:13:12,552
these are many syntaxes to process for

29104
19:13:12,552 --> 19:13:14,552
the first time but some of these

29105
19:13:14,552 --> 19:13:16,480
syntaxes are going to work better in

29106
19:13:16,480 --> 19:13:19,440
some situations and they are there just

29107
19:13:19,440 --> 19:13:21,760
to make it flexible for you to use

29108
19:13:21,760 --> 19:13:24,240
concepts in your c plus plus code okay

29109
19:13:24,240 --> 19:13:26,240
now that we have seen different ways we

29110
19:13:26,240 --> 19:13:28,400
can set up concepts for our function

29111
19:13:28,400 --> 19:13:30,552
templates i think this big time we

29112
19:13:30,552 --> 19:13:32,872
headed over to visual studio code and

29113
19:13:32,872 --> 19:13:35,680
tried them out okay here we are in our

29114
19:13:35,680 --> 19:13:37,832
working folder the current chapter is

29115
19:13:37,832 --> 19:13:40,080
concepts the current lecture is using

29116
19:13:40,080 --> 19:13:42,640
concepts we're going to grab our

29117
19:13:42,640 --> 19:13:45,280
template files we are going to put them

29118
19:13:45,280 --> 19:13:46,480
in place

29119
19:13:46,480 --> 19:13:48,800
and we are going to open this thing in

29120
19:13:48,800 --> 19:13:50,800
visual studio code by dragging and

29121
19:13:50,800 --> 19:13:53,280
dropping on top of visual studio code

29122
19:13:53,280 --> 19:13:55,832
here we do that this is going to open

29123
19:13:55,832 --> 19:13:57,832
our folder we're going to open up our

29124
19:13:57,832 --> 19:14:01,440
main cpp file and close the sidebar here

29125
19:14:01,440 --> 19:14:02,960
and we're going to clean things up a

29126
19:14:02,960 --> 19:14:04,552
little bit and we're going to set up a

29127
19:14:04,552 --> 19:14:06,320
function template which is going to add

29128
19:14:06,320 --> 19:14:08,000
two numbers we already know how to do

29129
19:14:08,000 --> 19:14:10,080
that so we're going to say template type

29130
19:14:10,080 --> 19:14:12,400
name and it's going to have a template

29131
19:14:12,400 --> 19:14:14,872
parameter of t then we're going to set

29132
19:14:14,872 --> 19:14:17,040
up the function like we have been doing

29133
19:14:17,040 --> 19:14:19,192
all along we're going to say add we're

29134
19:14:19,192 --> 19:14:22,080
going to say t a and t b and this is

29135
19:14:22,080 --> 19:14:25,040
going to return the sum of a and b once

29136
19:14:25,040 --> 19:14:27,680
you have the function in we can go in

29137
19:14:27,680 --> 19:14:30,080
the main function and set up code that

29138
19:14:30,080 --> 19:14:32,400
would call this function and if we try

29139
19:14:32,400 --> 19:14:34,552
to compile this program it is going to

29140
19:14:34,552 --> 19:14:37,760
work now because we are not placing any

29141
19:14:37,760 --> 19:14:40,240
constraints on this function template

29142
19:14:40,240 --> 19:14:43,040
here let's try to build with gcc like we

29143
19:14:43,040 --> 19:14:45,192
have been doing all along you see it is

29144
19:14:45,192 --> 19:14:47,832
going to weld okay you see the world is

29145
19:14:47,832 --> 19:14:50,160
good world finished successfully and if

29146
19:14:50,160 --> 19:14:52,240
we want we can run this application and

29147
19:14:52,240 --> 19:14:54,640
it is going to print result a

29148
19:14:54,640 --> 19:14:57,760
result b let's take this out because we

29149
19:14:57,760 --> 19:14:59,680
haven't done this yet but it's not going

29150
19:14:59,680 --> 19:15:02,000
to print result c but if we want we can

29151
19:15:02,000 --> 19:15:03,920
really print it it's going to work so

29152
19:15:03,920 --> 19:15:04,960
let's

29153
19:15:04,960 --> 19:15:07,120
put that in and we're going to say

29154
19:15:07,120 --> 19:15:11,120
result c and print result c here and

29155
19:15:11,120 --> 19:15:13,440
world again let's world now to take this

29156
19:15:13,440 --> 19:15:14,800
into account

29157
19:15:14,800 --> 19:15:16,800
world is good we can bring up a terminal

29158
19:15:16,800 --> 19:15:19,600
to try this out and we can clear and run

29159
19:15:19,600 --> 19:15:22,400
rooster now you see result a is 30

29160
19:15:22,400 --> 19:15:24,872
because that's the sum of a and b here

29161
19:15:24,872 --> 19:15:27,680
result b should be 16 which is what we

29162
19:15:27,680 --> 19:15:31,360
have result c is 13 which is what we

29163
19:15:31,360 --> 19:15:34,000
should get by adding these two double

29164
19:15:34,000 --> 19:15:35,280
variables

29165
19:15:35,280 --> 19:15:38,480
now we wanted to constrain this function

29166
19:15:38,480 --> 19:15:41,920
to only work if somebody passes integral

29167
19:15:41,920 --> 19:15:44,240
types and when we put that constraint in

29168
19:15:44,240 --> 19:15:46,552
place it is going to work if we add up

29169
19:15:46,552 --> 19:15:49,760
two character variables because they are

29170
19:15:49,760 --> 19:15:52,160
integral types it's going to work if we

29171
19:15:52,160 --> 19:15:54,320
add up two integer variables because

29172
19:15:54,320 --> 19:15:57,040
they are integral types but once we hit

29173
19:15:57,040 --> 19:15:58,552
this guy here

29174
19:15:58,552 --> 19:16:00,552
with the double variables we should get

29175
19:16:00,552 --> 19:16:03,760
a compiler error because the constraint

29176
19:16:03,760 --> 19:16:05,920
is not satisfied let's do that we're

29177
19:16:05,920 --> 19:16:08,160
going to comment the double thing first

29178
19:16:08,160 --> 19:16:11,040
because we want to really isolate it and

29179
19:16:11,040 --> 19:16:13,120
see it and see the compiler error that

29180
19:16:13,120 --> 19:16:14,720
we get and we're going to add a

29181
19:16:14,720 --> 19:16:17,440
constraint to our function template

29182
19:16:17,440 --> 19:16:20,080
using concepts okay if you want to use

29183
19:16:20,080 --> 19:16:22,480
concepts in c plus plus 20 the first

29184
19:16:22,480 --> 19:16:24,480
thing you need to do is to include the

29185
19:16:24,480 --> 19:16:27,440
library that gives us access to concepts

29186
19:16:27,440 --> 19:16:28,960
and we're going to do that by saying

29187
19:16:28,960 --> 19:16:31,512
include concepts this is easy now that

29188
19:16:31,512 --> 19:16:33,440
we have this end we're going to use the

29189
19:16:33,440 --> 19:16:36,080
first syntax we saw in the slides and

29190
19:16:36,080 --> 19:16:38,400
we're going to add the requires close

29191
19:16:38,400 --> 19:16:40,552
after the template declaration

29192
19:16:40,552 --> 19:16:43,512
and we're going to say std integral and

29193
19:16:43,512 --> 19:16:45,040
we're going to say the template

29194
19:16:45,040 --> 19:16:46,640
parameter here i think this is the

29195
19:16:46,640 --> 19:16:49,600
syntax okay watch what happens if we do

29196
19:16:49,600 --> 19:16:52,400
this down in the code we are calling the

29197
19:16:52,400 --> 19:16:54,640
function with car types

29198
19:16:54,640 --> 19:16:55,512
and

29199
19:16:55,512 --> 19:16:57,192
integer types so this is going to

29200
19:16:57,192 --> 19:17:00,400
compile fine because the concept here

29201
19:17:00,400 --> 19:17:03,192
is satisfied this concept is going to

29202
19:17:03,192 --> 19:17:05,680
enforce for the template parameters we

29203
19:17:05,680 --> 19:17:08,720
call a function template with to be

29204
19:17:08,720 --> 19:17:12,080
integral types let's build and see if we

29205
19:17:12,080 --> 19:17:14,960
get to compile successfully you see both

29206
19:17:14,960 --> 19:17:16,872
finished good everything is going to

29207
19:17:16,872 --> 19:17:19,040
work and if we run our program we should

29208
19:17:19,040 --> 19:17:21,280
see results a and result to be printed

29209
19:17:21,280 --> 19:17:23,680
out let's run the program we see our

29210
19:17:23,680 --> 19:17:25,920
result here now we're going to comment

29211
19:17:25,920 --> 19:17:29,760
out the others and leave in the double

29212
19:17:29,760 --> 19:17:32,000
example and we're going to uncomment

29213
19:17:32,000 --> 19:17:33,832
that and i want you to see the problem

29214
19:17:33,832 --> 19:17:36,400
we get when we try to use

29215
19:17:36,400 --> 19:17:38,160
our function template with double

29216
19:17:38,160 --> 19:17:40,480
variables here you see visual studio

29217
19:17:40,480 --> 19:17:42,400
code is already complaining it is saying

29218
19:17:42,400 --> 19:17:44,800
there is something wrong if we look at

29219
19:17:44,800 --> 19:17:47,280
the problems tab is going to say no

29220
19:17:47,280 --> 19:17:48,960
instance of function template add

29221
19:17:48,960 --> 19:17:50,960
matches the argument list but this is

29222
19:17:50,960 --> 19:17:53,440
really not descriptive enough but the

29223
19:17:53,440 --> 19:17:56,640
problem is our concept is not satisfied

29224
19:17:56,640 --> 19:17:59,360
by calling our function template with

29225
19:17:59,360 --> 19:18:03,120
double types because we clearly said

29226
19:18:03,120 --> 19:18:05,600
that we want the function to only be

29227
19:18:05,600 --> 19:18:08,552
called with integral types let's build

29228
19:18:08,552 --> 19:18:10,480
our program we're going to pass this

29229
19:18:10,480 --> 19:18:12,080
through gcc

29230
19:18:12,080 --> 19:18:14,240
and we're going to get a compiler error

29231
19:18:14,240 --> 19:18:16,800
that says that some concept was

29232
19:18:16,800 --> 19:18:18,320
unsatisfied

29233
19:18:18,320 --> 19:18:21,512
and we see we see in function main

29234
19:18:21,512 --> 19:18:25,440
use of function t add with double with

29235
19:18:25,440 --> 19:18:28,480
unsatisfied constraints and this is

29236
19:18:28,480 --> 19:18:30,720
really clear when we see an error like

29237
19:18:30,720 --> 19:18:32,640
this we will go and look at the

29238
19:18:32,640 --> 19:18:35,192
constraints that the function has and

29239
19:18:35,192 --> 19:18:37,360
we're going to see if we satisfied those

29240
19:18:37,360 --> 19:18:39,600
constraints by calling

29241
19:18:39,600 --> 19:18:41,192
like we did in the main function here

29242
19:18:41,192 --> 19:18:42,960
and we will know that the function

29243
19:18:42,960 --> 19:18:45,600
doesn't support non-integral types and

29244
19:18:45,600 --> 19:18:48,080
we will fix this problem this is really

29245
19:18:48,080 --> 19:18:50,552
how concepts can help

29246
19:18:50,552 --> 19:18:53,440
in writing safer function templates now

29247
19:18:53,440 --> 19:18:55,680
that we have seen the first syntax i

29248
19:18:55,680 --> 19:18:57,832
think it is big time we looked at the

29249
19:18:57,832 --> 19:19:00,480
other syntaxes so let's do that let's

29250
19:19:00,480 --> 19:19:01,920
copy the code here because we're going

29251
19:19:01,920 --> 19:19:04,872
to be reusing this a couple of times and

29252
19:19:04,872 --> 19:19:07,120
adapt it instead of typing this entire

29253
19:19:07,120 --> 19:19:10,240
thing the second syntax involves getting

29254
19:19:10,240 --> 19:19:12,960
rid of the requires close all together

29255
19:19:12,960 --> 19:19:16,480
and just using the concept instead of

29256
19:19:16,480 --> 19:19:19,192
type name here so i'm going to say std

29257
19:19:19,192 --> 19:19:21,600
integral and this is going to be enough

29258
19:19:21,600 --> 19:19:23,920
this is going to tell the compiler to

29259
19:19:23,920 --> 19:19:27,040
enforce this concept for this function

29260
19:19:27,040 --> 19:19:27,832
call

29261
19:19:27,832 --> 19:19:31,192
for all the template parameters that go

29262
19:19:31,192 --> 19:19:33,920
in the place of t here i hope this makes

29263
19:19:33,920 --> 19:19:36,400
sense now if we go back we see that we

29264
19:19:36,400 --> 19:19:38,720
still have our squiggly lines here if we

29265
19:19:38,720 --> 19:19:41,040
try to compile we will get the same

29266
19:19:41,040 --> 19:19:43,360
compiler error okay and you see we have

29267
19:19:43,360 --> 19:19:46,320
the same compiler error function add t

29268
19:19:46,320 --> 19:19:49,192
called with unsatisfied constraints i

29269
19:19:49,192 --> 19:19:50,800
think if you go down we're going to see

29270
19:19:50,800 --> 19:19:53,600
even more stuff out of this it's going

29271
19:19:53,600 --> 19:19:57,832
to say required the satisfaction of std

29272
19:19:57,832 --> 19:20:00,640
integral with t but now we are trying to

29273
19:20:00,640 --> 19:20:03,192
call this with double so this is really

29274
19:20:03,192 --> 19:20:06,240
going to lead to a compiler error so

29275
19:20:06,240 --> 19:20:08,160
this is the second syntax and it is

29276
19:20:08,160 --> 19:20:10,400
going to do the same thing now that we

29277
19:20:10,400 --> 19:20:13,192
have seen this we also have a third way

29278
19:20:13,192 --> 19:20:15,600
we can do this and that's through the

29279
19:20:15,600 --> 19:20:18,720
auto mechanism let's set up a function

29280
19:20:18,720 --> 19:20:21,280
using auto so we're going to say auto

29281
19:20:21,280 --> 19:20:24,320
add auto a and auto b we have seen that

29282
19:20:24,320 --> 19:20:26,320
we can do that in the last chapter and

29283
19:20:26,320 --> 19:20:28,720
we're going to return a and b a plus b i

29284
19:20:28,720 --> 19:20:31,120
should say if we do this you see that

29285
19:20:31,120 --> 19:20:33,360
the squiggly line goes away and we can

29286
19:20:33,360 --> 19:20:35,920
add these things up and print the result

29287
19:20:35,920 --> 19:20:37,832
the return type is going to be deduced

29288
19:20:37,832 --> 19:20:40,240
by the compiler automatically but know

29289
19:20:40,240 --> 19:20:41,832
that this is going to generate a

29290
19:20:41,832 --> 19:20:44,240
function template behind the scenes this

29291
19:20:44,240 --> 19:20:46,320
is just a nicer syntax we have to use

29292
19:20:46,320 --> 19:20:48,960
auto to set up functions that work for

29293
19:20:48,960 --> 19:20:52,000
multiple types let's build and uh see

29294
19:20:52,000 --> 19:20:55,040
how gcc handles this the world is good

29295
19:20:55,040 --> 19:20:57,832
because we have no constraints here and

29296
19:20:57,832 --> 19:21:00,160
if we run our program it's going to work

29297
19:21:00,160 --> 19:21:03,120
it's going to give us 13 as the sum of

29298
19:21:03,120 --> 19:21:07,440
11.1 and 1.9 but we can also place

29299
19:21:07,440 --> 19:21:09,512
constraints on this function here and

29300
19:21:09,512 --> 19:21:12,640
you do that by specifying your concept

29301
19:21:12,640 --> 19:21:15,360
in front of the auto keyword here so for

29302
19:21:15,360 --> 19:21:18,640
example we can say std integral and std

29303
19:21:18,640 --> 19:21:21,040
integral fold the second parameter here

29304
19:21:21,040 --> 19:21:23,760
let's say that and once we do this if we

29305
19:21:23,760 --> 19:21:26,720
go down we should see our squiggly line

29306
19:21:26,720 --> 19:21:28,552
on the call of the function here because

29307
19:21:28,552 --> 19:21:31,360
now the way we are calling this function

29308
19:21:31,360 --> 19:21:34,160
is not valid the function clearly says

29309
19:21:34,160 --> 19:21:37,512
that it wants to be called only with

29310
19:21:37,512 --> 19:21:41,440
arguments that satisfy this concept here

29311
19:21:41,440 --> 19:21:43,680
if we're trying to build again with gcc

29312
19:21:43,680 --> 19:21:45,280
we're going to get the semicompiler

29313
19:21:45,280 --> 19:21:47,600
error let's do that and it's going to

29314
19:21:47,600 --> 19:21:50,120
say use function with

29315
19:21:50,120 --> 19:21:52,872
unsatisfied constraints the same error

29316
19:21:52,872 --> 19:21:55,832
and if we go down we should see that it

29317
19:21:55,832 --> 19:21:58,720
requires the integral

29318
19:21:58,720 --> 19:22:01,760
concept to be satisfied here so this is

29319
19:22:01,760 --> 19:22:03,832
the third syntax you can use if you

29320
19:22:03,832 --> 19:22:06,480
happen to be using the auto syntax for

29321
19:22:06,480 --> 19:22:08,640
your function templates let's comment

29322
19:22:08,640 --> 19:22:10,640
this out because we still have another

29323
19:22:10,640 --> 19:22:12,872
syntax we need to learn about this is

29324
19:22:12,872 --> 19:22:15,360
going to be our syntax three and we're

29325
19:22:15,360 --> 19:22:17,680
going to comment this out and the last

29326
19:22:17,680 --> 19:22:19,440
one involves

29327
19:22:19,440 --> 19:22:22,160
just leaving in our function template

29328
19:22:22,160 --> 19:22:23,832
let's copy this because i don't want to

29329
19:22:23,832 --> 19:22:26,080
type this again we're going to go down

29330
19:22:26,080 --> 19:22:28,160
and say syntax form and put in our

29331
19:22:28,160 --> 19:22:30,240
function template we're going to take

29332
19:22:30,240 --> 19:22:32,960
this requires close we're going to cut

29333
19:22:32,960 --> 19:22:36,240
it out and we're going to put it after

29334
19:22:36,240 --> 19:22:38,552
the function parameter list

29335
19:22:38,552 --> 19:22:40,480
like this and this is going to be valid

29336
19:22:40,480 --> 19:22:41,192
c

29337
19:22:41,192 --> 19:22:44,160
syntax to enforce a concept on your

29338
19:22:44,160 --> 19:22:46,800
function template if we go down you see

29339
19:22:46,800 --> 19:22:49,360
we have this wiggly line and i should

29340
19:22:49,360 --> 19:22:51,440
prove that this works with other

29341
19:22:51,440 --> 19:22:54,000
integral types here let's just comment

29342
19:22:54,000 --> 19:22:56,552
out the double line here and uncomment

29343
19:22:56,552 --> 19:22:59,920
the other we had for car and ant if we

29344
19:22:59,920 --> 19:23:01,920
try to build this program now it is

29345
19:23:01,920 --> 19:23:03,680
going to work fine because the

29346
19:23:03,680 --> 19:23:06,640
constraints are satisfied but the moment

29347
19:23:06,640 --> 19:23:09,832
we uncomment the calls with double types

29348
19:23:09,832 --> 19:23:12,080
we're going to get a squiggly line which

29349
19:23:12,080 --> 19:23:14,552
is a good warning that we have a problem

29350
19:23:14,552 --> 19:23:17,440
but if we ignore the squiggly lines

29351
19:23:17,440 --> 19:23:19,920
and adjust build with gcc we're going to

29352
19:23:19,920 --> 19:23:22,720
get the same compiler error and it's

29353
19:23:22,720 --> 19:23:25,512
going to say that to call our function

29354
19:23:25,512 --> 19:23:27,760
we need to satisfy

29355
19:23:27,760 --> 19:23:31,192
the integral concept for the arguments

29356
19:23:31,192 --> 19:23:33,280
that we pass here and the double

29357
19:23:33,280 --> 19:23:35,512
arguments we're passing in here are

29358
19:23:35,512 --> 19:23:37,760
violating our concept so we get a

29359
19:23:37,760 --> 19:23:40,080
compiler error this is really how you

29360
19:23:40,080 --> 19:23:43,192
can use concepts in c plus plus i tried

29361
19:23:43,192 --> 19:23:45,680
and came up with simple examples to show

29362
19:23:45,680 --> 19:23:47,832
you different syntaxes you can use

29363
19:23:47,832 --> 19:23:49,360
concepts with

29364
19:23:49,360 --> 19:23:52,000
and this is really it try to get

29365
19:23:52,000 --> 19:23:54,960
yourself familiar with these syntaxes

29366
19:23:54,960 --> 19:23:57,192
and it's not going to be really hard to

29367
19:23:57,192 --> 19:23:59,120
use concepts in your c plus plus

29368
19:23:59,120 --> 19:24:01,920
programs okay this is really all i had

29369
19:24:01,920 --> 19:24:04,552
to share in terms of the syntaxes you

29370
19:24:04,552 --> 19:24:07,760
can use with c plus plus 20 concepts if

29371
19:24:07,760 --> 19:24:09,512
you go to the documentation you're going

29372
19:24:09,512 --> 19:24:12,000
to have more information about this but

29373
19:24:12,000 --> 19:24:14,240
we're going to do a few more lectures to

29374
19:24:14,240 --> 19:24:16,720
really drive this dancehall for now you

29375
19:24:16,720 --> 19:24:19,680
can come to cpp reference here and see

29376
19:24:19,680 --> 19:24:22,552
more concepts that you can use we have a

29377
19:24:22,552 --> 19:24:25,280
lot of this and we can really use this

29378
19:24:25,280 --> 19:24:27,600
to tune our function templates however

29379
19:24:27,600 --> 19:24:29,760
we want okay for example you see our

29380
19:24:29,760 --> 19:24:31,760
integral concepts you see a floating

29381
19:24:31,760 --> 19:24:34,872
point concepts and there are even more

29382
19:24:34,872 --> 19:24:37,040
that are usable with

29383
19:24:37,040 --> 19:24:39,280
classes but we haven't learned about

29384
19:24:39,280 --> 19:24:41,440
classes yet and we will do that starting

29385
19:24:41,440 --> 19:24:43,832
at the next chapter but now i just want

29386
19:24:43,832 --> 19:24:47,120
you to be familiar with concepts that

29387
19:24:47,120 --> 19:24:49,680
were introduced in c plus plus 20. and

29388
19:24:49,680 --> 19:24:51,600
here is another piece of documentation

29389
19:24:51,600 --> 19:24:53,832
you can look at just to complement what

29390
19:24:53,832 --> 19:24:56,552
we are talking about in this chapter but

29391
19:24:56,552 --> 19:24:58,800
i wouldn't recommend reading this just

29392
19:24:58,800 --> 19:25:00,552
yet because it's just going to confuse

29393
19:25:00,552 --> 19:25:02,872
you there is a lot of things we still

29394
19:25:02,872 --> 19:25:04,640
need to learn to really be able to

29395
19:25:04,640 --> 19:25:06,640
understand this so try to go through

29396
19:25:06,640 --> 19:25:08,800
this chapter and i am going to try and

29397
19:25:08,800 --> 19:25:11,192
break this down in ways that you can

29398
19:25:11,192 --> 19:25:13,512
understand this the main message is that

29399
19:25:13,512 --> 19:25:16,240
there are more concepts here you can try

29400
19:25:16,240 --> 19:25:18,872
in your c plus plus code if it makes

29401
19:25:18,872 --> 19:25:20,800
sense for the problem you are trying to

29402
19:25:20,800 --> 19:25:23,040
solve with c plus plus we are going to

29403
19:25:23,040 --> 19:25:24,960
stop here in this lecture in the next

29404
19:25:24,960 --> 19:25:26,800
one we're going to show you how you can

29405
19:25:26,800 --> 19:25:29,760
set up your own concepts in c plus plus

29406
19:25:29,760 --> 19:25:32,000
go ahead and finish up here and meet me

29407
19:25:32,000 --> 19:25:33,832
there in this lecture we're going to see

29408
19:25:33,832 --> 19:25:36,720
how you can build your own concepts and

29409
19:25:36,720 --> 19:25:38,640
this is going to bring us into the

29410
19:25:38,640 --> 19:25:41,440
second part of concepts we can use in c

29411
19:25:41,440 --> 19:25:44,080
plus plus in the last lecture we used

29412
19:25:44,080 --> 19:25:46,480
the concepts from the standard library

29413
19:25:46,480 --> 19:25:48,480
that are built into the c plus plus

29414
19:25:48,480 --> 19:25:51,120
programming language starting in c plus

29415
19:25:51,120 --> 19:25:53,440
plus 20. in this one we're going to be

29416
19:25:53,440 --> 19:25:56,720
building our own concepts and without

29417
19:25:56,720 --> 19:25:59,120
waiting anymore let's see how you can do

29418
19:25:59,120 --> 19:26:01,360
that and this is the syntax you can use

29419
19:26:01,360 --> 19:26:03,680
to do that and it is really simple the

29420
19:26:03,680 --> 19:26:05,832
way you do that you say a template

29421
19:26:05,832 --> 19:26:08,320
declaration specifying the template

29422
19:26:08,320 --> 19:26:11,192
parameter you want to constrain and then

29423
19:26:11,192 --> 19:26:13,280
you say concept you say the keyword

29424
19:26:13,280 --> 19:26:16,320
concept you give your concept a name you

29425
19:26:16,320 --> 19:26:19,280
put the equal sign after that and then

29426
19:26:19,280 --> 19:26:22,000
you're going to specify the requirements

29427
19:26:22,000 --> 19:26:24,720
for your concept so for example here we

29428
19:26:24,720 --> 19:26:28,960
are using a type trait to specify that

29429
19:26:28,960 --> 19:26:31,360
this type trait is going to determine

29430
19:26:31,360 --> 19:26:34,080
what works for this concept here and

29431
19:26:34,080 --> 19:26:36,872
what this is going to do is to enforce

29432
19:26:36,872 --> 19:26:39,680
for our template parameter to only be

29433
19:26:39,680 --> 19:26:41,832
integral if it's not integral we're

29434
19:26:41,832 --> 19:26:43,832
going to get a compiler error and one

29435
19:26:43,832 --> 19:26:46,240
thing i should tell you is that the std

29436
19:26:46,240 --> 19:26:49,192
integral concept is exactly built like

29437
19:26:49,192 --> 19:26:51,512
this in the c plus plus standard library

29438
19:26:51,512 --> 19:26:53,600
this is really cool so if you want to

29439
19:26:53,600 --> 19:26:55,600
set up your own concept and you want to

29440
19:26:55,600 --> 19:26:58,000
do that using typed traits you can do

29441
19:26:58,000 --> 19:26:59,512
that like this and it is going to

29442
19:26:59,512 --> 19:27:03,040
enforce for your template parameters to

29443
19:27:03,040 --> 19:27:06,480
satisfy that typed rate or to be exact

29444
19:27:06,480 --> 19:27:09,360
this concept is going to be satisfied

29445
19:27:09,360 --> 19:27:12,400
when the type trait evaluates to true if

29446
19:27:12,400 --> 19:27:14,640
the typed rate evaluates to false at

29447
19:27:14,640 --> 19:27:17,120
compile time the concept is not going to

29448
19:27:17,120 --> 19:27:19,280
be satisfied that's another way to look

29449
19:27:19,280 --> 19:27:21,760
at that down here we have another syntax

29450
19:27:21,760 --> 19:27:24,320
we can use if we have multiple

29451
19:27:24,320 --> 19:27:26,800
statements in our concept all you have

29452
19:27:26,800 --> 19:27:30,160
to do is specify the concept keyword you

29453
19:27:30,160 --> 19:27:32,552
give it a name you go to the equal sign

29454
19:27:32,552 --> 19:27:35,440
and then you add a requires close the

29455
19:27:35,440 --> 19:27:37,512
requires close is going to specify the

29456
19:27:37,512 --> 19:27:39,512
template parameters for which you want

29457
19:27:39,512 --> 19:27:42,240
to enforce your concept and then you're

29458
19:27:42,240 --> 19:27:45,440
going to put a pair of curly braces and

29459
19:27:45,440 --> 19:27:48,000
inside that you're going to specify the

29460
19:27:48,000 --> 19:27:51,192
syntax you want your concept to satisfy

29461
19:27:51,192 --> 19:27:53,040
for example here we want

29462
19:27:53,040 --> 19:27:55,680
for the two parameters to be

29463
19:27:55,680 --> 19:27:58,552
supporting the multiplication operator

29464
19:27:58,552 --> 19:28:00,872
if this multiplication operator is not

29465
19:28:00,872 --> 19:28:03,040
supported for the template parameters

29466
19:28:03,040 --> 19:28:05,192
that we passed the concept is going to

29467
19:28:05,192 --> 19:28:09,120
fail and again i should emphasize that

29468
19:28:09,120 --> 19:28:11,600
this doesn't check for the value of a

29469
19:28:11,600 --> 19:28:13,760
multiplied by b it's just going to

29470
19:28:13,760 --> 19:28:16,160
enforce from the syntax to be supported

29471
19:28:16,160 --> 19:28:18,552
so for example if you call a function

29472
19:28:18,552 --> 19:28:21,680
template with this concept and you try

29473
19:28:21,680 --> 19:28:24,080
to pass in integers it's going to work

29474
19:28:24,080 --> 19:28:26,400
because you can multiply integers but if

29475
19:28:26,400 --> 19:28:29,440
you pass two strings this is going to

29476
19:28:29,440 --> 19:28:31,360
fail because it doesn't really make

29477
19:28:31,360 --> 19:28:33,760
sense to multiply strings okay this is

29478
19:28:33,760 --> 19:28:36,080
the syntax now we only have one

29479
19:28:36,080 --> 19:28:38,480
statement to enforce inside but if you

29480
19:28:38,480 --> 19:28:41,120
want you can even put more statements if

29481
19:28:41,120 --> 19:28:42,960
you go down here we have another example

29482
19:28:42,960 --> 19:28:45,680
called incrementable this is going to

29483
19:28:45,680 --> 19:28:48,000
require for the template parameter to be

29484
19:28:48,000 --> 19:28:50,640
incrementable we specify the concept key

29485
19:28:50,640 --> 19:28:53,512
world we say the concept name we put in

29486
19:28:53,512 --> 19:28:56,320
our equal sign and then we say requires

29487
19:28:56,320 --> 19:28:58,640
we put on template parameter and put in

29488
19:28:58,640 --> 19:29:01,192
our requirements for any template

29489
19:29:01,192 --> 19:29:04,720
parameter that is using this concept the

29490
19:29:04,720 --> 19:29:07,120
syntax here must make sense so you must

29491
19:29:07,120 --> 19:29:09,280
be able to take the value that you get

29492
19:29:09,280 --> 19:29:11,680
from here and for example say i plus

29493
19:29:11,680 --> 19:29:13,600
equals one this is going to be valid

29494
19:29:13,600 --> 19:29:16,320
syntax you're going to say plus plus a

29495
19:29:16,320 --> 19:29:18,240
and plus plus b all these are going to

29496
19:29:18,240 --> 19:29:21,440
be valid c plus plus syntaxes for the

29497
19:29:21,440 --> 19:29:23,600
template parameter that you try to call

29498
19:29:23,600 --> 19:29:26,000
this function template with and if this

29499
19:29:26,000 --> 19:29:27,832
doesn't work you're going to get a

29500
19:29:27,832 --> 19:29:30,160
compiler error because your template

29501
19:29:30,160 --> 19:29:32,720
argument isn't really satisfying this

29502
19:29:32,720 --> 19:29:34,960
concept so this is really how you can

29503
19:29:34,960 --> 19:29:37,832
set up your own concepts in c plus plus

29504
19:29:37,832 --> 19:29:40,000
once you have your own concepts set up

29505
19:29:40,000 --> 19:29:42,320
you can use them like we have been using

29506
19:29:42,320 --> 19:29:44,720
the other concept from the ziploc plus

29507
19:29:44,720 --> 19:29:47,280
standard library for example we can use

29508
19:29:47,280 --> 19:29:50,552
syntax one to put a requires clues and

29509
19:29:50,552 --> 19:29:53,760
say that we want to satisfy our own

29510
19:29:53,760 --> 19:29:56,552
concept with this particular syntax you

29511
19:29:56,552 --> 19:29:59,192
will have to put in these angle brackets

29512
19:29:59,192 --> 19:30:01,680
and put your template parameter inside

29513
19:30:01,680 --> 19:30:03,832
this is the syntax you have to use you

29514
19:30:03,832 --> 19:30:06,800
can also use syntax 2 and specify my

29515
19:30:06,800 --> 19:30:09,600
integral directly in this angle brackets

29516
19:30:09,600 --> 19:30:11,680
in your template declaration and this is

29517
19:30:11,680 --> 19:30:14,000
also going to work we can even use this

29518
19:30:14,000 --> 19:30:16,400
with the auto syntax for our function

29519
19:30:16,400 --> 19:30:18,552
templates it is going to work okay now

29520
19:30:18,552 --> 19:30:20,480
that you have sent this i think it is

29521
19:30:20,480 --> 19:30:22,552
time we headed over to visual studio

29522
19:30:22,552 --> 19:30:24,800
code and play with us a little more okay

29523
19:30:24,800 --> 19:30:27,360
here we are in our working folder the

29524
19:30:27,360 --> 19:30:29,512
current project is building your own

29525
19:30:29,512 --> 19:30:31,760
concepts we're going to grab our

29526
19:30:31,760 --> 19:30:34,000
template files like we always do and

29527
19:30:34,000 --> 19:30:35,920
we're going to put them in place and

29528
19:30:35,920 --> 19:30:38,480
we're going to open this thing in visual

29529
19:30:38,480 --> 19:30:41,360
studio code let's do that we have our

29530
19:30:41,360 --> 19:30:44,240
project open here or folder i should say

29531
19:30:44,240 --> 19:30:45,760
we're going to clean this up a little

29532
19:30:45,760 --> 19:30:47,832
bit and we're going to include our

29533
19:30:47,832 --> 19:30:50,720
concepts library and we wanted to set up

29534
19:30:50,720 --> 19:30:52,960
our own concept the first syntax we're

29535
19:30:52,960 --> 19:30:56,480
going to see is by using type trades and

29536
19:30:56,480 --> 19:30:59,280
we're going to say template type name t

29537
19:30:59,280 --> 19:31:01,440
and we're going to say this concept we

29538
19:31:01,440 --> 19:31:04,400
want this template parameter to satisfy

29539
19:31:04,400 --> 19:31:06,080
we're going to say concept and we're

29540
19:31:06,080 --> 19:31:08,720
going to say my integral which is going

29541
19:31:08,720 --> 19:31:10,552
to be the name of our concept we're

29542
19:31:10,552 --> 19:31:12,720
going to put an ecosign and then we're

29543
19:31:12,720 --> 19:31:14,000
going to say

29544
19:31:14,000 --> 19:31:18,552
std integral v and specify that we want

29545
19:31:18,552 --> 19:31:21,680
this type trait to be satisfied for this

29546
19:31:21,680 --> 19:31:23,920
concept here and after this we need to

29547
19:31:23,920 --> 19:31:26,400
put in our semicolon and i think we need

29548
19:31:26,400 --> 19:31:29,512
to include the type traits library

29549
19:31:29,512 --> 19:31:32,000
because we are using that we should say

29550
19:31:32,000 --> 19:31:35,440
std is integral so sorry for this and

29551
19:31:35,440 --> 19:31:37,440
this is going to work now okay now that

29552
19:31:37,440 --> 19:31:40,480
we have the concept set up we can use it

29553
19:31:40,480 --> 19:31:43,120
like we have been using other concept

29554
19:31:43,120 --> 19:31:45,192
for example we can set up a function

29555
19:31:45,192 --> 19:31:47,440
which is going to add up two numbers and

29556
19:31:47,440 --> 19:31:50,480
it is going to use this concept here we

29557
19:31:50,480 --> 19:31:52,872
have multiple syntaxes we can use so

29558
19:31:52,872 --> 19:31:54,640
let's go down and try this out we're

29559
19:31:54,640 --> 19:31:56,960
going to say template and say type name

29560
19:31:56,960 --> 19:31:59,360
t and we're going to require this

29561
19:31:59,360 --> 19:32:02,080
concept to be satisfied for our function

29562
19:32:02,080 --> 19:32:04,480
template we saw that we could use the

29563
19:32:04,480 --> 19:32:07,832
requires close here and say my integral

29564
19:32:07,832 --> 19:32:10,160
and say the template parameter we want

29565
19:32:10,160 --> 19:32:12,552
to enforce this on and after this we're

29566
19:32:12,552 --> 19:32:14,320
going to just put in our function

29567
19:32:14,320 --> 19:32:16,160
template we're going to say add what we

29568
19:32:16,160 --> 19:32:18,080
have been doing all along in the last

29569
19:32:18,080 --> 19:32:20,640
lecture we're going to say t a

29570
19:32:20,640 --> 19:32:23,760
and t b and we're going to return a plus

29571
19:32:23,760 --> 19:32:26,480
b now this function is going to support

29572
19:32:26,480 --> 19:32:28,872
our concept let's go down and set up two

29573
19:32:28,872 --> 19:32:31,440
variables we're going to say and x

29574
19:32:31,440 --> 19:32:33,920
and we're going to say 6 for example and

29575
19:32:33,920 --> 19:32:36,480
into y and i'm going to make this a 7

29576
19:32:36,480 --> 19:32:39,120
why not and we're going to say add

29577
19:32:39,120 --> 19:32:41,440
x and y once we do this you see that we

29578
19:32:41,440 --> 19:32:43,832
have no problem because the concept is

29579
19:32:43,832 --> 19:32:46,320
satisfied for the arguments that we are

29580
19:32:46,320 --> 19:32:49,832
passing in here the concept is satisfied

29581
19:32:49,832 --> 19:32:52,480
because the type trait here is going to

29582
19:32:52,480 --> 19:32:54,960
return true for this type here because

29583
19:32:54,960 --> 19:32:57,120
it is an integral type when the type

29584
19:32:57,120 --> 19:32:59,280
trait returns true then the concept is

29585
19:32:59,280 --> 19:33:01,760
going to be satisfied if the type trait

29586
19:33:01,760 --> 19:33:04,160
returns false the concept is going to

29587
19:33:04,160 --> 19:33:06,960
fail let's try and bolt and really drive

29588
19:33:06,960 --> 19:33:08,960
this home you see that the world is good

29589
19:33:08,960 --> 19:33:11,440
our function is working so the function

29590
19:33:11,440 --> 19:33:13,440
template and stands for this code here

29591
19:33:13,440 --> 19:33:15,600
is going to be successfully generated

29592
19:33:15,600 --> 19:33:17,832
and we're going to call it when the

29593
19:33:17,832 --> 19:33:19,192
program runs

29594
19:33:19,192 --> 19:33:21,832
now let's change the type of these guys

29595
19:33:21,832 --> 19:33:24,720
to double and try to violate our concept

29596
19:33:24,720 --> 19:33:26,960
and make it fail once we do this you see

29597
19:33:26,960 --> 19:33:29,440
the call here has a squiggly line and a

29598
19:33:29,440 --> 19:33:31,360
visual studio code is not going to say

29599
19:33:31,360 --> 19:33:34,000
that it is a concept problem which is a

29600
19:33:34,000 --> 19:33:36,960
shame but we can still run this through

29601
19:33:36,960 --> 19:33:39,192
the compiler and the compiler is going

29602
19:33:39,192 --> 19:33:41,280
to tell us what is wrong so it's going

29603
19:33:41,280 --> 19:33:44,640
to say use of function add with

29604
19:33:44,640 --> 19:33:47,440
unsatisfied constraints and if we go

29605
19:33:47,440 --> 19:33:49,360
down we're going to see the exact

29606
19:33:49,360 --> 19:33:52,320
constraints we violated and we're going

29607
19:33:52,320 --> 19:33:55,040
to say required for the satisfaction of

29608
19:33:55,040 --> 19:33:57,832
my integral with t we are calling this

29609
19:33:57,832 --> 19:33:59,920
with double and double is going to

29610
19:33:59,920 --> 19:34:03,280
evaluate this to false hopefully you can

29611
19:34:03,280 --> 19:34:05,040
see that you can really set up your own

29612
19:34:05,040 --> 19:34:08,000
concepts using the syntax here and we

29613
19:34:08,000 --> 19:34:09,680
can use our concept with all the

29614
19:34:09,680 --> 19:34:11,440
syntaxes we have seen in the last

29615
19:34:11,440 --> 19:34:13,600
lecture so for example we can take out

29616
19:34:13,600 --> 19:34:16,480
the requires close all together here and

29617
19:34:16,480 --> 19:34:18,800
say my integral in the

29618
19:34:18,800 --> 19:34:20,800
template declaration here so we're going

29619
19:34:20,800 --> 19:34:23,192
to say my integral and if we do this

29620
19:34:23,192 --> 19:34:25,832
we're going to fail again because the

29621
19:34:25,832 --> 19:34:28,240
concept is not going to be satisfied

29622
19:34:28,240 --> 19:34:30,400
we're going to have the same problem we

29623
19:34:30,400 --> 19:34:33,280
can change the syntax to use the auto

29624
19:34:33,280 --> 19:34:35,832
syntax but before we do that let's

29625
19:34:35,832 --> 19:34:39,280
change this back to type name t and then

29626
19:34:39,280 --> 19:34:42,160
put our requires close after the

29627
19:34:42,160 --> 19:34:44,640
parameter list of our function template

29628
19:34:44,640 --> 19:34:46,552
we're going to say requires

29629
19:34:46,552 --> 19:34:48,960
and we're going to say my integral and

29630
19:34:48,960 --> 19:34:51,760
specify the template parameter and this

29631
19:34:51,760 --> 19:34:54,000
is a valid function template with a

29632
19:34:54,000 --> 19:34:56,400
concept applied to app and if we both

29633
19:34:56,400 --> 19:34:57,600
again we're going to get the same

29634
19:34:57,600 --> 19:35:00,552
compiler error so you see the same error

29635
19:35:00,552 --> 19:35:03,440
and we can use the auto syntax let's do

29636
19:35:03,440 --> 19:35:05,600
that we're going to take out the

29637
19:35:05,600 --> 19:35:08,000
template declaration here we're going to

29638
19:35:08,000 --> 19:35:10,552
take out the requires close here and

29639
19:35:10,552 --> 19:35:14,552
we're going to change our t to auto and

29640
19:35:14,552 --> 19:35:16,000
the way we do that we're going to say

29641
19:35:16,000 --> 19:35:19,280
std no no std we are using our own

29642
19:35:19,280 --> 19:35:21,280
concept so we're going to say my

29643
19:35:21,280 --> 19:35:24,160
integral auto this is going to work and

29644
19:35:24,160 --> 19:35:26,800
we're going to say my integral auto and

29645
19:35:26,800 --> 19:35:29,280
my integral auto here the moment we do

29646
19:35:29,280 --> 19:35:31,832
this you see that we have squiggly lines

29647
19:35:31,832 --> 19:35:34,872
here because our concept is violated but

29648
19:35:34,872 --> 19:35:36,480
if we're trying to build again we're

29649
19:35:36,480 --> 19:35:38,800
going to use gcc to do that the build is

29650
19:35:38,800 --> 19:35:40,960
going to fail you see that the same

29651
19:35:40,960 --> 19:35:43,760
concept is violated and we are able to

29652
19:35:43,760 --> 19:35:46,872
use our concept throughout the four

29653
19:35:46,872 --> 19:35:49,120
syntaxes that we saw in the last lecture

29654
19:35:49,120 --> 19:35:50,800
and this is really cool now that we have

29655
19:35:50,800 --> 19:35:53,192
this we're going to comment this out and

29656
19:35:53,192 --> 19:35:55,192
we're going to see that we can set up

29657
19:35:55,192 --> 19:35:58,800
concepts that have requirements spanning

29658
19:35:58,800 --> 19:36:01,440
multiple statements or multiple lines

29659
19:36:01,440 --> 19:36:03,512
okay let's go down and do that suppose

29660
19:36:03,512 --> 19:36:05,920
we want to set up a concept that is

29661
19:36:05,920 --> 19:36:07,832
going to enforce for the templates

29662
19:36:07,832 --> 19:36:10,640
parameters to be multipliable

29663
19:36:10,640 --> 19:36:13,280
with the multiplication operator we have

29664
19:36:13,280 --> 19:36:15,680
here we can use this syntax here we're

29665
19:36:15,680 --> 19:36:17,440
going to put in our template declaration

29666
19:36:17,440 --> 19:36:19,280
we're going to say concept we're going

29667
19:36:19,280 --> 19:36:20,960
to say the concept name we're going to

29668
19:36:20,960 --> 19:36:22,872
put in an equal sign and then we're

29669
19:36:22,872 --> 19:36:25,680
going to put in a requires close

29670
19:36:25,680 --> 19:36:28,400
with our template parameters and and

29671
19:36:28,400 --> 19:36:30,400
after that we're going to put a pair of

29672
19:36:30,400 --> 19:36:33,120
curly braces and inside the curlies

29673
19:36:33,120 --> 19:36:35,680
we're going to put the requirements for

29674
19:36:35,680 --> 19:36:38,552
example in this case we require for the

29675
19:36:38,552 --> 19:36:41,192
template parameter here to support the

29676
19:36:41,192 --> 19:36:43,600
multiplication operator between two of

29677
19:36:43,600 --> 19:36:45,832
these types if the multiplication

29678
19:36:45,832 --> 19:36:48,000
operator is not supported we're going to

29679
19:36:48,000 --> 19:36:49,760
have a problem and that this is the

29680
19:36:49,760 --> 19:36:52,240
concept that is going to enforce that

29681
19:36:52,240 --> 19:36:54,080
one thing you should know is that this

29682
19:36:54,080 --> 19:36:56,080
is just going to check

29683
19:36:56,080 --> 19:37:00,080
that multiplying a and b is valid syntax

29684
19:37:00,080 --> 19:37:02,640
it's not going to check the value of a

29685
19:37:02,640 --> 19:37:04,640
multiplied by b and you should really

29686
19:37:04,640 --> 19:37:07,120
understand this now that we have this n

29687
19:37:07,120 --> 19:37:09,040
we can set up a function to use these

29688
19:37:09,040 --> 19:37:12,160
two guys why not use the function we

29689
19:37:12,160 --> 19:37:14,320
have seen before to add two numbers

29690
19:37:14,320 --> 19:37:16,320
let's do that and we're going to put in

29691
19:37:16,320 --> 19:37:18,400
our requires close and we're going to

29692
19:37:18,400 --> 19:37:22,640
require now to support the multipliable

29693
19:37:22,640 --> 19:37:24,720
concept and we're going to specify our

29694
19:37:24,720 --> 19:37:27,760
template parameter we have the concept n

29695
19:37:27,760 --> 19:37:30,080
so we can use that to do whatever we

29696
19:37:30,080 --> 19:37:32,240
want now we're going to say t

29697
19:37:32,240 --> 19:37:35,512
add and we're going to say t a and t b

29698
19:37:35,512 --> 19:37:38,240
and we're going to return a plus b this

29699
19:37:38,240 --> 19:37:40,240
is the same function we've been using

29700
19:37:40,240 --> 19:37:42,872
all along okay now we have our concept

29701
19:37:42,872 --> 19:37:45,120
in place and we have a function template

29702
19:37:45,120 --> 19:37:47,440
that is going to use this concept

29703
19:37:47,440 --> 19:37:51,440
let's see if we can add up x and y and

29704
19:37:51,440 --> 19:37:53,192
see what we get we're going to world

29705
19:37:53,192 --> 19:37:55,120
with gcc we're going to see that the

29706
19:37:55,120 --> 19:37:57,192
world is going to be good because our

29707
19:37:57,192 --> 19:38:01,040
concept here is satisfied we are passing

29708
19:38:01,040 --> 19:38:03,920
double types for our function template

29709
19:38:03,920 --> 19:38:06,400
and it is legal to multiply two double

29710
19:38:06,400 --> 19:38:08,400
variables if we multiply two doubles

29711
19:38:08,400 --> 19:38:10,240
we're going to get a value and that's

29712
19:38:10,240 --> 19:38:12,800
going to be valid c plus plus syntax but

29713
19:38:12,800 --> 19:38:15,040
let's see what happens if we try to

29714
19:38:15,040 --> 19:38:17,600
change our arguments to hdd strength

29715
19:38:17,600 --> 19:38:20,000
let's do that so we're going to say x is

29716
19:38:20,000 --> 19:38:22,640
hello and we're going to say why is

29717
19:38:22,640 --> 19:38:25,440
world why not let's go down and put in a

29718
19:38:25,440 --> 19:38:27,832
semicolon and the moment we do that you

29719
19:38:27,832 --> 19:38:30,800
see that we have a problem and visual

29720
19:38:30,800 --> 19:38:34,240
studio code is not good at this yet

29721
19:38:34,240 --> 19:38:36,400
but if we go inside

29722
19:38:36,400 --> 19:38:38,800
and run this through gcc we're going to

29723
19:38:38,800 --> 19:38:42,160
get that our concept is violated let's

29724
19:38:42,160 --> 19:38:44,240
look at the compiler error here it's

29725
19:38:44,240 --> 19:38:47,280
going to say constraints not satisfied

29726
19:38:47,280 --> 19:38:49,512
and it's going to tell us that we are

29727
19:38:49,512 --> 19:38:52,320
calling the add function with the values

29728
19:38:52,320 --> 19:38:54,800
that can't be multiplied it's going to

29729
19:38:54,800 --> 19:38:56,872
say the required expression here is

29730
19:38:56,872 --> 19:38:59,512
invalid and this is how you can set up a

29731
19:38:59,512 --> 19:39:01,680
concept like this and you can really use

29732
19:39:01,680 --> 19:39:02,800
this to

29733
19:39:02,800 --> 19:39:05,440
put constraints however you want on your

29734
19:39:05,440 --> 19:39:08,240
function templates but here we have just

29735
19:39:08,240 --> 19:39:11,040
used one statement inside our concept

29736
19:39:11,040 --> 19:39:13,920
here we can even put in more so to drive

29737
19:39:13,920 --> 19:39:15,512
this home we're going to set up another

29738
19:39:15,512 --> 19:39:17,832
concept let's go down and put that in

29739
19:39:17,832 --> 19:39:20,000
place the concept is going to be called

29740
19:39:20,000 --> 19:39:22,320
incremental it's going to be using the

29741
19:39:22,320 --> 19:39:24,640
same syntax we saw here but we're going

29742
19:39:24,640 --> 19:39:26,640
to be putting a requirement on the

29743
19:39:26,640 --> 19:39:29,192
template parameter here to support

29744
19:39:29,192 --> 19:39:32,080
incrementation and we want for every

29745
19:39:32,080 --> 19:39:34,800
type that goes in the place of t here we

29746
19:39:34,800 --> 19:39:37,512
must be able to say a plus equals one

29747
19:39:37,512 --> 19:39:40,400
this must be valid c plus plus syntax we

29748
19:39:40,400 --> 19:39:42,552
must be able to say plus plus a this

29749
19:39:42,552 --> 19:39:45,120
must be valid c plus plus syntax and we

29750
19:39:45,120 --> 19:39:47,600
must be able to say a plus plus this

29751
19:39:47,600 --> 19:39:50,720
must be valid c plus plus syntax

29752
19:39:50,720 --> 19:39:53,040
now that we have this we can change our

29753
19:39:53,040 --> 19:39:56,000
add function to use this concept why not

29754
19:39:56,000 --> 19:39:58,720
we're going to say incrementable and now

29755
19:39:58,720 --> 19:40:01,600
this function is going to be required to

29756
19:40:01,600 --> 19:40:04,400
use things that we can increment on and

29757
19:40:04,400 --> 19:40:06,800
you see it is failing already because we

29758
19:40:06,800 --> 19:40:08,720
can't really increment strengths what

29759
19:40:08,720 --> 19:40:10,872
does that even mean so let's build and

29760
19:40:10,872 --> 19:40:13,040
show you the compiler error okay you see

29761
19:40:13,040 --> 19:40:16,000
incremental is not satisfied and that

29762
19:40:16,000 --> 19:40:18,640
the required expressions aren't valid

29763
19:40:18,640 --> 19:40:21,832
you see plus plus a is not valid a plus

29764
19:40:21,832 --> 19:40:25,280
plus is not valid and a plus equals one

29765
19:40:25,280 --> 19:40:28,080
should not also be valid but we're not

29766
19:40:28,080 --> 19:40:30,240
seeing that here but hopefully you see

29767
19:40:30,240 --> 19:40:33,680
the message here that our concept is

29768
19:40:33,680 --> 19:40:36,400
failing here if we comment out our

29769
19:40:36,400 --> 19:40:39,120
strengths here and uncomment double all

29770
19:40:39,120 --> 19:40:40,872
these operations we have here are

29771
19:40:40,872 --> 19:40:43,440
supported for the double type

29772
19:40:43,440 --> 19:40:46,552
so we should not fail here if we try to

29773
19:40:46,552 --> 19:40:49,120
compile this because the concept is

29774
19:40:49,120 --> 19:40:50,872
going to be satisfied

29775
19:40:50,872 --> 19:40:53,440
let's use the gcc

29776
19:40:53,440 --> 19:40:55,440
compiler to build you see the build is

29777
19:40:55,440 --> 19:40:56,480
good now

29778
19:40:56,480 --> 19:40:58,720
and we can clear and we can bring up a

29779
19:40:58,720 --> 19:41:01,760
terminal to really see this that our

29780
19:41:01,760 --> 19:41:04,800
binary was generated let's do the ir

29781
19:41:04,800 --> 19:41:06,480
we're going to see our rooster

29782
19:41:06,480 --> 19:41:08,960
executable here and if we go down let's

29783
19:41:08,960 --> 19:41:10,872
say done we're going to see that if we

29784
19:41:10,872 --> 19:41:13,280
build again to bring this in

29785
19:41:13,280 --> 19:41:15,832
consideration clear run rooster the

29786
19:41:15,832 --> 19:41:18,000
program was generated and it is really

29787
19:41:18,000 --> 19:41:21,600
running because the concept here

29788
19:41:21,600 --> 19:41:23,280
is satisfied

29789
19:41:23,280 --> 19:41:27,600
with our call using double arguments

29790
19:41:27,600 --> 19:41:30,240
here okay so this is really all i set

29791
19:41:30,240 --> 19:41:32,160
out to share with you guys in this

29792
19:41:32,160 --> 19:41:34,640
lecture i hope you know the syntaxes you

29793
19:41:34,640 --> 19:41:37,120
can use to create your own concepts you

29794
19:41:37,120 --> 19:41:39,280
can either use type traits like we have

29795
19:41:39,280 --> 19:41:41,760
seen here and the syntax is to put the

29796
19:41:41,760 --> 19:41:45,600
keyword concept put in your concept name

29797
19:41:45,600 --> 19:41:47,920
put an ecosign and then specify your

29798
19:41:47,920 --> 19:41:50,160
type trait here this is going to work if

29799
19:41:50,160 --> 19:41:51,680
you need something a little more

29800
19:41:51,680 --> 19:41:53,760
complicated then you're going to use

29801
19:41:53,760 --> 19:41:55,920
this syntax here and put the

29802
19:41:55,920 --> 19:41:59,120
requirements for your concept in these

29803
19:41:59,120 --> 19:42:01,920
curly braces you can either put one

29804
19:42:01,920 --> 19:42:04,400
statement like we did here or you can

29805
19:42:04,400 --> 19:42:07,280
even put as many statements as you want

29806
19:42:07,280 --> 19:42:08,800
just remember to end them with

29807
19:42:08,800 --> 19:42:10,800
semicolons and another thing you

29808
19:42:10,800 --> 19:42:13,512
shouldn't really take lightly is that

29809
19:42:13,512 --> 19:42:16,320
this is just going to check for syntax

29810
19:42:16,320 --> 19:42:18,080
it's not going to check for the value

29811
19:42:18,080 --> 19:42:21,280
you get after you add one to a here for

29812
19:42:21,280 --> 19:42:23,120
example it's not going to check for the

29813
19:42:23,120 --> 19:42:25,360
value you get after you multiply b it's

29814
19:42:25,360 --> 19:42:28,552
just going to see that a multiply b

29815
19:42:28,552 --> 19:42:32,640
is valid syntax for the types that our

29816
19:42:32,640 --> 19:42:35,440
template parameter is using here we are

29817
19:42:35,440 --> 19:42:37,832
going to stop here in this lecture this

29818
19:42:37,832 --> 19:42:40,160
one we're going to zoom in a little more

29819
19:42:40,160 --> 19:42:43,040
on the requires close here go ahead and

29820
19:42:43,040 --> 19:42:44,320
finish up here

29821
19:42:44,320 --> 19:42:46,480
and meet me there in this lecture we're

29822
19:42:46,480 --> 19:42:49,120
going to learn about some more things we

29823
19:42:49,120 --> 19:42:52,080
can do with our requires close but

29824
19:42:52,080 --> 19:42:54,800
before we do that let's look at the

29825
19:42:54,800 --> 19:42:57,760
kinds of requirements we can put in our

29826
19:42:57,760 --> 19:43:00,640
requires close the first one is a simple

29827
19:43:00,640 --> 19:43:02,800
requirement which is what we have seen

29828
19:43:02,800 --> 19:43:04,960
so far we can also do a nested

29829
19:43:04,960 --> 19:43:06,480
requirement and we're going to learn

29830
19:43:06,480 --> 19:43:08,720
about this in a minute and we can do a

29831
19:43:08,720 --> 19:43:10,960
compound requirement which is going to

29832
19:43:10,960 --> 19:43:13,512
allow us to specify more things about

29833
19:43:13,512 --> 19:43:16,480
what we require for our concept there

29834
19:43:16,480 --> 19:43:19,192
are also type requirements but these are

29835
19:43:19,192 --> 19:43:21,120
really advanced for the scope of this

29836
19:43:21,120 --> 19:43:22,640
course so we're not going to talk about

29837
19:43:22,640 --> 19:43:24,480
these in this course what we're going to

29838
19:43:24,480 --> 19:43:27,760
look at are these three first here so

29839
19:43:27,760 --> 19:43:30,240
let's look at a simple requirement this

29840
19:43:30,240 --> 19:43:32,080
is what we have seen already here we

29841
19:43:32,080 --> 19:43:35,192
have our template declaration we have a

29842
19:43:35,192 --> 19:43:38,080
concept declared the concept name is

29843
19:43:38,080 --> 19:43:40,320
tiny type we're going to put in our

29844
19:43:40,320 --> 19:43:42,640
requires close we're going to put in our

29845
19:43:42,640 --> 19:43:45,192
parameter list and we're going to put in

29846
19:43:45,192 --> 19:43:48,000
our curly braces inside the requires

29847
19:43:48,000 --> 19:43:50,800
close we have a statement here which is

29848
19:43:50,800 --> 19:43:54,240
going to enforce that size of t is less

29849
19:43:54,240 --> 19:43:55,832
than 4.

29850
19:43:55,832 --> 19:43:58,080
and what this really means it's going to

29851
19:43:58,080 --> 19:44:01,280
check that size of t the syntax here is

29852
19:44:01,280 --> 19:44:04,000
correct and this can really throw people

29853
19:44:04,000 --> 19:44:06,480
off i have said this in the last lecture

29854
19:44:06,480 --> 19:44:09,120
but i set up this little example to

29855
19:44:09,120 --> 19:44:11,600
really drive this home and show you that

29856
19:44:11,600 --> 19:44:14,480
if you are not careful your concepts are

29857
19:44:14,480 --> 19:44:16,800
going to be really wrong this is going

29858
19:44:16,800 --> 19:44:19,280
to check for the syntax so for example

29859
19:44:19,280 --> 19:44:22,240
if we call a function template with this

29860
19:44:22,240 --> 19:44:25,192
concept with a car type

29861
19:44:25,192 --> 19:44:27,192
the concept is going to be satisfied

29862
19:44:27,192 --> 19:44:30,080
even if the size of the car is less than

29863
19:44:30,080 --> 19:44:32,552
4 obviously but that's not going to be

29864
19:44:32,552 --> 19:44:34,800
the job of this concept here this

29865
19:44:34,800 --> 19:44:37,680
concept is not going to enforce for the

29866
19:44:37,680 --> 19:44:40,160
expression here to evaluate to true it's

29867
19:44:40,160 --> 19:44:42,480
going to just check the syntax and if

29868
19:44:42,480 --> 19:44:45,920
you pass something smaller than a net in

29869
19:44:45,920 --> 19:44:48,640
a function template with this concept

29870
19:44:48,640 --> 19:44:50,872
this is going to be valid c plus plus

29871
19:44:50,872 --> 19:44:53,192
syntax so the concept is going to work

29872
19:44:53,192 --> 19:44:55,920
so now you must be asking how can i

29873
19:44:55,920 --> 19:44:58,720
enforce for the value of this expression

29874
19:44:58,720 --> 19:45:00,160
to be true

29875
19:45:00,160 --> 19:45:03,680
using concept well for that you will

29876
19:45:03,680 --> 19:45:06,720
have to use nested requirements and a

29877
19:45:06,720 --> 19:45:08,800
nested requirement is going to have

29878
19:45:08,800 --> 19:45:11,832
another requires keyword inserted in

29879
19:45:11,832 --> 19:45:14,552
front of it now if you use the syntax

29880
19:45:14,552 --> 19:45:16,720
like this now this is going to check

29881
19:45:16,720 --> 19:45:19,600
that size of t is actually less than 4.

29882
19:45:19,600 --> 19:45:22,080
if it's not less than 4 this is going to

29883
19:45:22,080 --> 19:45:24,480
return false here and the concept is

29884
19:45:24,480 --> 19:45:26,320
going to fail and this is how you can

29885
19:45:26,320 --> 19:45:29,360
use nested requirements to enforce for

29886
19:45:29,360 --> 19:45:31,920
some expressions to be true in your

29887
19:45:31,920 --> 19:45:33,832
requires close another kind of

29888
19:45:33,832 --> 19:45:35,680
requirement you can set up for your

29889
19:45:35,680 --> 19:45:38,872
concept is the compound requirement and

29890
19:45:38,872 --> 19:45:41,760
this is going to allow you to check if

29891
19:45:41,760 --> 19:45:43,760
something doesn't throw an exception you

29892
19:45:43,760 --> 19:45:46,552
can do that using the no accept keyword

29893
19:45:46,552 --> 19:45:48,160
but we're not going to use this now

29894
19:45:48,160 --> 19:45:50,960
because this is not in scope for what we

29895
19:45:50,960 --> 19:45:53,360
can do at this point in the course but

29896
19:45:53,360 --> 19:45:56,000
you can also check the return type of an

29897
19:45:56,000 --> 19:45:59,600
expression and divorce that it satisfies

29898
19:45:59,600 --> 19:46:02,480
some type trait for example so here we

29899
19:46:02,480 --> 19:46:05,760
are saying for our concept and if we

29900
19:46:05,760 --> 19:46:08,640
pass in two parameters the syntax for

29901
19:46:08,640 --> 19:46:11,680
adding a and b must be correct and

29902
19:46:11,680 --> 19:46:14,640
supported for those types but the result

29903
19:46:14,640 --> 19:46:18,080
of a and b must also be convertible to

29904
19:46:18,080 --> 19:46:20,160
ant and you can do something like this

29905
19:46:20,160 --> 19:46:21,680
and this is going to work you can

29906
19:46:21,680 --> 19:46:23,920
enforce these kinds of things using

29907
19:46:23,920 --> 19:46:26,480
compound requirements okay now that you

29908
19:46:26,480 --> 19:46:28,720
know about these kinds of requirements

29909
19:46:28,720 --> 19:46:31,680
you can put in your requires close let's

29910
19:46:31,680 --> 19:46:34,080
head over to visual studio code and play

29911
19:46:34,080 --> 19:46:36,000
with us a little more okay here we are

29912
19:46:36,000 --> 19:46:38,480
in our working folder the current

29913
19:46:38,480 --> 19:46:41,440
project is zooming in on requires close

29914
19:46:41,440 --> 19:46:43,920
we're going to grab our template files

29915
19:46:43,920 --> 19:46:46,080
and we're going to put them in place and

29916
19:46:46,080 --> 19:46:47,920
we're going to open that in visual

29917
19:46:47,920 --> 19:46:50,240
studio code pretty quick by dragging and

29918
19:46:50,240 --> 19:46:52,400
dropping here this is going to open up

29919
19:46:52,400 --> 19:46:54,240
our folder we're going to do the usual

29920
19:46:54,240 --> 19:46:56,240
we're going to close the pane here we're

29921
19:46:56,240 --> 19:46:59,120
going to clean things up a little bit

29922
19:46:59,120 --> 19:47:01,512
and we're going to include our concepts

29923
19:47:01,512 --> 19:47:03,920
library let's do that we are going to

29924
19:47:03,920 --> 19:47:05,680
set up a simple concept we're going to

29925
19:47:05,680 --> 19:47:07,512
say template and we're going to say what

29926
19:47:07,512 --> 19:47:10,080
the concept is the concept is going to

29927
19:47:10,080 --> 19:47:12,480
be called the tiny type and we're going

29928
19:47:12,480 --> 19:47:13,600
to say

29929
19:47:13,600 --> 19:47:16,800
what makes this concept a tiny time

29930
19:47:16,800 --> 19:47:19,360
we're going to put in our requires close

29931
19:47:19,360 --> 19:47:21,192
and we're going to put in the template

29932
19:47:21,192 --> 19:47:23,680
parameter call it t why not and we're

29933
19:47:23,680 --> 19:47:25,920
going to put in our closing semicolon

29934
19:47:25,920 --> 19:47:28,480
here now what is going to make this

29935
19:47:28,480 --> 19:47:31,280
concept a tiny type is that the size of

29936
19:47:31,280 --> 19:47:33,192
the template parameter view is going to

29937
19:47:33,192 --> 19:47:35,360
be less than four let's suppose we are

29938
19:47:35,360 --> 19:47:37,440
doing the function and we wanted to use

29939
19:47:37,440 --> 19:47:38,240
for

29940
19:47:38,240 --> 19:47:41,360
integral types that are smaller than

29941
19:47:41,360 --> 19:47:43,600
four bytes in memory suppose you want to

29942
19:47:43,600 --> 19:47:45,680
do this and it is useful

29943
19:47:45,680 --> 19:47:47,600
in the problem that you are trying to

29944
19:47:47,600 --> 19:47:49,680
solve in c plus plus the way we can

29945
19:47:49,680 --> 19:47:52,480
enforce this we can say size of t is

29946
19:47:52,480 --> 19:47:55,360
supposed to be less than four let's say

29947
19:47:55,360 --> 19:47:57,832
size of properly can't type can i okay

29948
19:47:57,832 --> 19:47:59,120
the moment we do this you're going to

29949
19:47:59,120 --> 19:48:01,192
see that this is valid c plus plus

29950
19:48:01,192 --> 19:48:03,360
syntax so we're not going to have any

29951
19:48:03,360 --> 19:48:06,000
squiggly lines but what you should know

29952
19:48:06,000 --> 19:48:08,552
is that this is a simple requirement in

29953
19:48:08,552 --> 19:48:11,040
c plus plus concepts and what this is

29954
19:48:11,040 --> 19:48:12,400
going to do

29955
19:48:12,400 --> 19:48:15,600
it's just going to enforce the syntax of

29956
19:48:15,600 --> 19:48:17,832
what we do here what we put here must be

29957
19:48:17,832 --> 19:48:20,552
valid c plus plus syntax so only

29958
19:48:20,552 --> 19:48:22,720
enforces syntax this is what you should

29959
19:48:22,720 --> 19:48:24,872
really remember okay now that we have

29960
19:48:24,872 --> 19:48:27,600
this end let's try it out and show you

29961
19:48:27,600 --> 19:48:30,000
some problems you can really run into

29962
19:48:30,000 --> 19:48:31,600
we're going to set up two character

29963
19:48:31,600 --> 19:48:33,440
variables we're going to call the first

29964
19:48:33,440 --> 19:48:35,280
one x we're going to initialize this

29965
19:48:35,280 --> 19:48:39,120
with 57 why not 67 and we're going to

29966
19:48:39,120 --> 19:48:41,440
put in the other variable which is going

29967
19:48:41,440 --> 19:48:44,960
to be y and it's going to have a 56 n

29968
19:48:44,960 --> 19:48:47,040
you can put in whatever you want just

29969
19:48:47,040 --> 19:48:49,120
make sure that you are within the range

29970
19:48:49,120 --> 19:48:51,832
of the card type which is between 0 and

29971
19:48:51,832 --> 19:48:54,400
255 if you remember okay now that we

29972
19:48:54,400 --> 19:48:56,960
have this n i realize we don't have a

29973
19:48:56,960 --> 19:48:59,920
function we can try this on let's set up

29974
19:48:59,920 --> 19:49:01,680
another function pretty quick we're

29975
19:49:01,680 --> 19:49:03,920
going to say tiny type auto we can do

29976
19:49:03,920 --> 19:49:06,400
that you already know this syntax and

29977
19:49:06,400 --> 19:49:09,440
we're going to say add tiny type auto a

29978
19:49:09,440 --> 19:49:12,552
and a tiny type auto p we can do that

29979
19:49:12,552 --> 19:49:15,192
and we're going to return a plus b now

29980
19:49:15,192 --> 19:49:18,080
that we have this let's say a and b down

29981
19:49:18,080 --> 19:49:19,600
here and call this function we're going

29982
19:49:19,600 --> 19:49:22,000
to say x and y and we're going to try

29983
19:49:22,000 --> 19:49:24,160
and compile this program and it is going

29984
19:49:24,160 --> 19:49:26,872
to compile fine because the type we are

29985
19:49:26,872 --> 19:49:29,192
using to call the function which is car

29986
19:49:29,192 --> 19:49:31,440
its size is going to be less than four

29987
19:49:31,440 --> 19:49:33,120
okay so this is going to work and it is

29988
19:49:33,120 --> 19:49:34,400
going to compile

29989
19:49:34,400 --> 19:49:36,720
let's build with gcc you're going to see

29990
19:49:36,720 --> 19:49:40,160
that the build is good let's try and uh

29991
19:49:40,160 --> 19:49:42,720
change the type here to end or even

29992
19:49:42,720 --> 19:49:45,360
double you know double is 8 bytes in

29993
19:49:45,360 --> 19:49:47,680
memory so we expect this to probably

29994
19:49:47,680 --> 19:49:49,920
give us something wrong double type is

29995
19:49:49,920 --> 19:49:52,320
eight bytes in memory so we expect the

29996
19:49:52,320 --> 19:49:54,240
size of t here

29997
19:49:54,240 --> 19:49:57,192
to be false because the size of t is

29998
19:49:57,192 --> 19:49:59,760
going to be eight and eight is not less

29999
19:49:59,760 --> 19:50:02,240
than four this is going to be false so

30000
19:50:02,240 --> 19:50:04,872
some might expect this concept here to

30001
19:50:04,872 --> 19:50:05,760
fail

30002
19:50:05,760 --> 19:50:08,552
but let's try and really prove you wrong

30003
19:50:08,552 --> 19:50:11,192
we're going to build with gcc and you

30004
19:50:11,192 --> 19:50:13,360
see it's building successfully what this

30005
19:50:13,360 --> 19:50:16,800
is really doing is that with simple

30006
19:50:16,800 --> 19:50:19,192
requirements like we have here c plus

30007
19:50:19,192 --> 19:50:21,360
plus is only going to enforce for this

30008
19:50:21,360 --> 19:50:24,640
to be valid c plus plus syntax and size

30009
19:50:24,640 --> 19:50:26,720
of t is less than four

30010
19:50:26,720 --> 19:50:29,360
is going to be valid c plus plus syntax

30011
19:50:29,360 --> 19:50:32,080
even if this expression here evaluates

30012
19:50:32,080 --> 19:50:34,480
to false this is not going to enforce

30013
19:50:34,480 --> 19:50:36,960
for the value of this expression to be

30014
19:50:36,960 --> 19:50:38,960
false you can't do that with simple

30015
19:50:38,960 --> 19:50:41,360
requirements what you will do is check

30016
19:50:41,360 --> 19:50:44,480
that this is valid syntax now what do we

30017
19:50:44,480 --> 19:50:46,720
do if we really want to enforce that

30018
19:50:46,720 --> 19:50:48,552
size of t should be

30019
19:50:48,552 --> 19:50:50,872
less than four if you want that you

30020
19:50:50,872 --> 19:50:53,832
should use nested requirements and the

30021
19:50:53,832 --> 19:50:55,600
syntax to do that is really simple we

30022
19:50:55,600 --> 19:50:58,080
can go down here and put that in we're

30023
19:50:58,080 --> 19:51:00,000
going to say requires we're going to add

30024
19:51:00,000 --> 19:51:02,800
a requires keyword in front of this then

30025
19:51:02,800 --> 19:51:04,960
we're going to put our expression here

30026
19:51:04,960 --> 19:51:06,800
let's copy it and put it in i don't want

30027
19:51:06,800 --> 19:51:09,600
to type this again the moment we do this

30028
19:51:09,600 --> 19:51:12,320
now compilation is going to fail if we

30029
19:51:12,320 --> 19:51:15,760
pass a type whose size is not less than

30030
19:51:15,760 --> 19:51:16,552
four

30031
19:51:16,552 --> 19:51:18,552
and let's try and build again you're

30032
19:51:18,552 --> 19:51:20,080
going to see that the world is going to

30033
19:51:20,080 --> 19:51:22,000
fail now and we're going to have a

30034
19:51:22,000 --> 19:51:24,552
failed concept and you see world

30035
19:51:24,552 --> 19:51:27,360
finished with errors we have constraints

30036
19:51:27,360 --> 19:51:29,680
not satisfied and if we go down here

30037
19:51:29,680 --> 19:51:31,512
we're going to see required for the

30038
19:51:31,512 --> 19:51:34,240
satisfaction of tiny type auto and we

30039
19:51:34,240 --> 19:51:37,512
passed in a double type whose size is 8

30040
19:51:37,512 --> 19:51:40,320
bytes in memory and it is less than four

30041
19:51:40,320 --> 19:51:43,120
bytes you see the requirement here it is

30042
19:51:43,120 --> 19:51:46,640
not satisfied we can do this using

30043
19:51:46,640 --> 19:51:49,192
nested requirements okay if we go down

30044
19:51:49,192 --> 19:51:51,680
for example and change this to car some

30045
19:51:51,680 --> 19:51:54,000
people call this char but i call this

30046
19:51:54,000 --> 19:51:56,720
car that's my habit if we change this to

30047
19:51:56,720 --> 19:51:57,680
car

30048
19:51:57,680 --> 19:51:59,120
and try to bolt again you're going to

30049
19:51:59,120 --> 19:52:01,680
see that it is going to weld fine

30050
19:52:01,680 --> 19:52:04,552
because now what is wrong here let's see

30051
19:52:04,552 --> 19:52:07,360
what we got wrong huh we are getting a

30052
19:52:07,360 --> 19:52:10,240
compiler error here what is the problem

30053
19:52:10,240 --> 19:52:11,760
it's going to say

30054
19:52:11,760 --> 19:52:14,720
let's go up and try to analyze this a

30055
19:52:14,720 --> 19:52:17,040
little bit it's saying deduce the return

30056
19:52:17,040 --> 19:52:19,512
type does not satisfy placeholder

30057
19:52:19,512 --> 19:52:21,192
constraints

30058
19:52:21,192 --> 19:52:23,760
and we are requiring for the return type

30059
19:52:23,760 --> 19:52:25,760
of this guy to be tiny time uh-huh i

30060
19:52:25,760 --> 19:52:28,000
think i know what the problem is the

30061
19:52:28,000 --> 19:52:30,872
problem is the arithmetic operations

30062
19:52:30,872 --> 19:52:32,720
like the addition we're doing here are

30063
19:52:32,720 --> 19:52:35,120
not supported for types which are

30064
19:52:35,120 --> 19:52:37,920
smaller than ant and is the smallest

30065
19:52:37,920 --> 19:52:40,000
type we can use with arithmetic

30066
19:52:40,000 --> 19:52:42,160
operations so what the compiler is going

30067
19:52:42,160 --> 19:52:44,160
to do is going to do implicit

30068
19:52:44,160 --> 19:52:47,512
conversions from car to end and inside

30069
19:52:47,512 --> 19:52:49,440
here what we will have are going to be

30070
19:52:49,440 --> 19:52:52,320
ant the result of this is going to be

30071
19:52:52,320 --> 19:52:54,480
ant and the return type is going to be

30072
19:52:54,480 --> 19:52:56,960
deduced to be at but ant

30073
19:52:56,960 --> 19:52:59,440
is going to violate the requirement we

30074
19:52:59,440 --> 19:53:01,920
have here which is saying that the size

30075
19:53:01,920 --> 19:53:04,160
of tiny type here should be less than

30076
19:53:04,160 --> 19:53:06,800
four and the return of ant is not less

30077
19:53:06,800 --> 19:53:09,680
than four so we can try and fix this by

30078
19:53:09,680 --> 19:53:12,080
putting an equal sign here and i think

30079
19:53:12,080 --> 19:53:14,480
it's going to work let's do that and

30080
19:53:14,480 --> 19:53:16,480
world again this is a good learning

30081
19:53:16,480 --> 19:53:18,320
experience and now you see that the

30082
19:53:18,320 --> 19:53:20,160
build is going to work because now the

30083
19:53:20,160 --> 19:53:22,480
return type is going to satisfy our

30084
19:53:22,480 --> 19:53:25,192
requirements so let's prove that we are

30085
19:53:25,192 --> 19:53:27,440
getting a net out of this actually we're

30086
19:53:27,440 --> 19:53:29,512
going to do our own result and we're

30087
19:53:29,512 --> 19:53:31,920
going to say equal and grab the result

30088
19:53:31,920 --> 19:53:33,920
of this guy we should really prove these

30089
19:53:33,920 --> 19:53:36,160
thanks and after this we're going to

30090
19:53:36,160 --> 19:53:38,800
print the results we can do that and we

30091
19:53:38,800 --> 19:53:41,440
can even go further and print the size

30092
19:53:41,440 --> 19:53:43,832
of result here so we're going to say

30093
19:53:43,832 --> 19:53:46,160
size of result okay now that we have

30094
19:53:46,160 --> 19:53:49,440
this end we can weld with gcc and the

30095
19:53:49,440 --> 19:53:52,480
world is good don't mind this squiggly

30096
19:53:52,480 --> 19:53:55,040
line it is probably visual studio code

30097
19:53:55,040 --> 19:53:56,720
messing with us you see that the world

30098
19:53:56,720 --> 19:54:00,640
is good we can now bring up a terminal

30099
19:54:00,640 --> 19:54:03,192
and run this and see the size of the

30100
19:54:03,192 --> 19:54:05,360
return type and really prove

30101
19:54:05,360 --> 19:54:07,832
that the compiler turned that into an

30102
19:54:07,832 --> 19:54:10,960
end even if we called our function with

30103
19:54:10,960 --> 19:54:13,512
car arguments this is interesting so

30104
19:54:13,512 --> 19:54:15,760
clear and run rooster now we're going to

30105
19:54:15,760 --> 19:54:18,480
see results is going to be 123 and the

30106
19:54:18,480 --> 19:54:21,040
size of the result is for even if we

30107
19:54:21,040 --> 19:54:24,160
passed in car types as our arguments

30108
19:54:24,160 --> 19:54:26,240
okay so hopefully this proves that you

30109
19:54:26,240 --> 19:54:29,040
can set up nested requirements to

30110
19:54:29,040 --> 19:54:31,600
enforce for the expression here to be

30111
19:54:31,600 --> 19:54:33,680
checked another type of requirement you

30112
19:54:33,680 --> 19:54:36,400
can do is a compound requirement let's

30113
19:54:36,400 --> 19:54:38,400
put this in and we're going to put in a

30114
19:54:38,400 --> 19:54:40,480
simple example to drive this home i

30115
19:54:40,480 --> 19:54:42,640
think i should take this function and

30116
19:54:42,640 --> 19:54:46,000
put that below our concepts so a

30117
19:54:46,000 --> 19:54:48,320
compound requirement looks like this you

30118
19:54:48,320 --> 19:54:51,192
put your expression in acrylics like

30119
19:54:51,192 --> 19:54:53,360
this and then you can even put

30120
19:54:53,360 --> 19:54:56,000
requirements on the values of the

30121
19:54:56,000 --> 19:54:58,000
expression for example we can enforce

30122
19:54:58,000 --> 19:55:00,720
that the value of a plus b here should

30123
19:55:00,720 --> 19:55:03,280
be convertible to and if it's not

30124
19:55:03,280 --> 19:55:05,920
convertible to end the concept here is

30125
19:55:05,920 --> 19:55:08,000
going to fail this is a compound

30126
19:55:08,000 --> 19:55:10,800
requirement you can even put no except

30127
19:55:10,800 --> 19:55:13,192
keywords in here but we're not going to

30128
19:55:13,192 --> 19:55:15,600
go this far because we haven't really

30129
19:55:15,600 --> 19:55:18,000
learned about exceptions so for now i'm

30130
19:55:18,000 --> 19:55:19,920
going to test this out i just wanted you

30131
19:55:19,920 --> 19:55:22,000
to be aware that you can do that now

30132
19:55:22,000 --> 19:55:24,320
that we have this concept n let's play

30133
19:55:24,320 --> 19:55:26,640
with it and see how we can make it break

30134
19:55:26,640 --> 19:55:29,120
thanks we're going to change our concept

30135
19:55:29,120 --> 19:55:31,600
to edible let's say edible here and

30136
19:55:31,600 --> 19:55:33,440
we're going to say edible and we're

30137
19:55:33,440 --> 19:55:34,480
going to

30138
19:55:34,480 --> 19:55:36,640
put in our car types here and it is

30139
19:55:36,640 --> 19:55:39,120
going to slay work because

30140
19:55:39,120 --> 19:55:42,160
we can add two car variables and this is

30141
19:55:42,160 --> 19:55:44,800
going to work because we can add two car

30142
19:55:44,800 --> 19:55:47,280
variables and this is valid syntax what

30143
19:55:47,280 --> 19:55:48,960
we're going to get out of that is going

30144
19:55:48,960 --> 19:55:50,960
to be an ant because remember the

30145
19:55:50,960 --> 19:55:52,960
compiler is going to insert implicit

30146
19:55:52,960 --> 19:55:55,760
conversions from card to end because it

30147
19:55:55,760 --> 19:55:58,960
can't really add two card types and is

30148
19:55:58,960 --> 19:56:01,920
the smallest thing you can do arithmetic

30149
19:56:01,920 --> 19:56:04,640
operations on so the result of this is

30150
19:56:04,640 --> 19:56:06,240
going to be an end so a lens is

30151
19:56:06,240 --> 19:56:07,832
convertible to an edge this is going to

30152
19:56:07,832 --> 19:56:10,160
work let's build and show you that this

30153
19:56:10,160 --> 19:56:12,552
is going to work we're going to weld

30154
19:56:12,552 --> 19:56:15,360
this with the gcc you see build is good

30155
19:56:15,360 --> 19:56:17,192
we can try and run this and see what we

30156
19:56:17,192 --> 19:56:20,000
get after calling the function we get

30157
19:56:20,000 --> 19:56:23,040
result is 123 and this is going to be

30158
19:56:23,040 --> 19:56:25,280
the size of four because we get a net

30159
19:56:25,280 --> 19:56:27,360
out of this let's try and change this to

30160
19:56:27,360 --> 19:56:29,600
double and see what we get so double

30161
19:56:29,600 --> 19:56:32,160
let's say double here and if we would we

30162
19:56:32,160 --> 19:56:34,720
expect this to work because adding up

30163
19:56:34,720 --> 19:56:36,552
two doubles is going to give you a

30164
19:56:36,552 --> 19:56:37,512
double

30165
19:56:37,512 --> 19:56:39,512
and we're going to return a double from

30166
19:56:39,512 --> 19:56:40,872
this function

30167
19:56:40,872 --> 19:56:43,920
and uh a double is convertible to a net

30168
19:56:43,920 --> 19:56:45,440
so we're going to return a double from

30169
19:56:45,440 --> 19:56:48,320
this guy and this should say eight now

30170
19:56:48,320 --> 19:56:49,832
because that's what we are returning

30171
19:56:49,832 --> 19:56:51,760
from the function here let's build with

30172
19:56:51,760 --> 19:56:54,000
gcc you see the both is good we can

30173
19:56:54,000 --> 19:56:56,720
clear and run rooster this is going to

30174
19:56:56,720 --> 19:57:00,000
say size of result is eight because now

30175
19:57:00,000 --> 19:57:01,920
what we are returning is going to be a

30176
19:57:01,920 --> 19:57:04,080
double from this function here and

30177
19:57:04,080 --> 19:57:07,280
double satisfies our concept adding up

30178
19:57:07,280 --> 19:57:10,160
two doubles is valid syntax and what we

30179
19:57:10,160 --> 19:57:12,160
get out of that is going to be a double

30180
19:57:12,160 --> 19:57:14,480
and a double is convertible to a net

30181
19:57:14,480 --> 19:57:16,720
this is going to work let's try and

30182
19:57:16,720 --> 19:57:19,280
change our parameters here to strength

30183
19:57:19,280 --> 19:57:21,440
we're going to comment out our x and y

30184
19:57:21,440 --> 19:57:23,512
variables here and we're going to set up

30185
19:57:23,512 --> 19:57:26,872
two strings going to say std string x

30186
19:57:26,872 --> 19:57:28,720
and we're going to say hello and you

30187
19:57:28,720 --> 19:57:30,552
know what we're going to say and why

30188
19:57:30,552 --> 19:57:33,280
we're going to say std strength y

30189
19:57:33,280 --> 19:57:35,920
and we're going to say world why not and

30190
19:57:35,920 --> 19:57:37,760
the moment we do this you see that we

30191
19:57:37,760 --> 19:57:40,552
have a problem why do we have a problem

30192
19:57:40,552 --> 19:57:44,000
because it is now a requirement for the

30193
19:57:44,000 --> 19:57:46,400
result of a and b to be convertible to

30194
19:57:46,400 --> 19:57:48,640
end remember that you can add up two

30195
19:57:48,640 --> 19:57:51,832
strands for example you can say auto s

30196
19:57:51,832 --> 19:57:55,040
and say x plus y this is going to work

30197
19:57:55,040 --> 19:57:57,040
because you can add up two strings and

30198
19:57:57,040 --> 19:57:58,872
this is going to concatenate them so

30199
19:57:58,872 --> 19:58:02,000
this is valid syntax why are we failing

30200
19:58:02,000 --> 19:58:04,552
here because we have a requirement for

30201
19:58:04,552 --> 19:58:07,192
this to be convertible to an end and the

30202
19:58:07,192 --> 19:58:09,760
strength isn't really convertible to an

30203
19:58:09,760 --> 19:58:12,400
end so this is going to fail let's build

30204
19:58:12,400 --> 19:58:14,640
this program and show you that this is

30205
19:58:14,640 --> 19:58:16,872
actually the case we're going to see

30206
19:58:16,872 --> 19:58:20,240
world finished with arrows and let's see

30207
19:58:20,240 --> 19:58:22,720
the error we have okay so constraints

30208
19:58:22,720 --> 19:58:25,280
not satisfied it's going to say required

30209
19:58:25,280 --> 19:58:28,320
the satisfaction of audible with auto

30210
19:58:28,320 --> 19:58:30,720
here in requirement and it's going to

30211
19:58:30,720 --> 19:58:31,512
say

30212
19:58:31,512 --> 19:58:34,240
a plus b does not satisfy the type

30213
19:58:34,240 --> 19:58:36,640
requirement because what we get after

30214
19:58:36,640 --> 19:58:39,920
adding a and b is not convertible to an

30215
19:58:39,920 --> 19:58:42,000
end and you see that here

30216
19:58:42,000 --> 19:58:44,640
a plus b convertible to an end this is

30217
19:58:44,640 --> 19:58:47,040
going to fail okay so let's try and

30218
19:58:47,040 --> 19:58:50,080
remove this requirement to convert to

30219
19:58:50,080 --> 19:58:52,720
end and see that this actually works

30220
19:58:52,720 --> 19:58:54,552
we're going to remove this i'm going to

30221
19:58:54,552 --> 19:58:56,160
cut this out

30222
19:58:56,160 --> 19:58:58,480
and try to build again i am going to use

30223
19:58:58,480 --> 19:59:00,960
gcc to build and now you see that this

30224
19:59:00,960 --> 19:59:03,360
is welding because we no longer

30225
19:59:03,360 --> 19:59:06,080
have the requirement of the return value

30226
19:59:06,080 --> 19:59:08,400
of this expression or result i should

30227
19:59:08,400 --> 19:59:11,120
say the result of this function

30228
19:59:11,120 --> 19:59:13,360
now doesn't have to be convertible to an

30229
19:59:13,360 --> 19:59:15,040
okay let's put this back because i want

30230
19:59:15,040 --> 19:59:17,360
you to see this later as a reference and

30231
19:59:17,360 --> 19:59:19,440
now you know how you can use compound

30232
19:59:19,440 --> 19:59:22,552
requirements to really put constraints

30233
19:59:22,552 --> 19:59:25,280
on your function templates this is

30234
19:59:25,280 --> 19:59:27,360
really all we set out to do in this

30235
19:59:27,360 --> 19:59:29,760
lecture i hope you found it interesting

30236
19:59:29,760 --> 19:59:32,640
i think i should comment out these guys

30237
19:59:32,640 --> 19:59:35,120
because i don't like to leave you with

30238
19:59:35,120 --> 19:59:37,920
code that has compiler errors let's turn

30239
19:59:37,920 --> 19:59:39,832
this back to double so that this works

30240
19:59:39,832 --> 19:59:41,920
we're going to weld again okay the world

30241
19:59:41,920 --> 19:59:44,240
is good and we are going to stop here in

30242
19:59:44,240 --> 19:59:45,920
this lecture in the next one we're going

30243
19:59:45,920 --> 19:59:48,480
to see how we can combine concepts and

30244
19:59:48,480 --> 19:59:50,552
do some crazy things

30245
19:59:50,552 --> 19:59:52,872
go ahead and finish up here and meet me

30246
19:59:52,872 --> 19:59:54,960
there in this lecture we're going to see

30247
19:59:54,960 --> 19:59:57,680
how we can combine concepts using

30248
19:59:57,680 --> 20:00:00,160
logical operators we can combine

30249
20:00:00,160 --> 20:00:03,280
concepts using the and operator and the

30250
20:00:03,280 --> 20:00:06,552
r operator as you see here let's look at

30251
20:00:06,552 --> 20:00:09,600
a simple example here we have a concept

30252
20:00:09,600 --> 20:00:12,080
it is time type we have seen before and

30253
20:00:12,080 --> 20:00:14,720
it's going to check that the size of the

30254
20:00:14,720 --> 20:00:17,120
template parameter we pass is less than

30255
20:00:17,120 --> 20:00:19,280
four it's going to enforce the syntax

30256
20:00:19,280 --> 20:00:21,600
with a simple requirement but it's also

30257
20:00:21,600 --> 20:00:23,680
going to enforce for the value of this

30258
20:00:23,680 --> 20:00:25,680
expression to be true if the value is

30259
20:00:25,680 --> 20:00:28,160
not true the concept is going to fail

30260
20:00:28,160 --> 20:00:30,552
and we are using a nested requirement

30261
20:00:30,552 --> 20:00:33,192
for this so this is our concept here

30262
20:00:33,192 --> 20:00:35,600
let's try and set up a function and see

30263
20:00:35,600 --> 20:00:38,480
how we can combine this concept with

30264
20:00:38,480 --> 20:00:41,440
other concepts here we have a function

30265
20:00:41,440 --> 20:00:43,440
it is going to return a t the name of

30266
20:00:43,440 --> 20:00:45,760
the function is func it is taking in our

30267
20:00:45,760 --> 20:00:48,160
parameter and here we have the body of

30268
20:00:48,160 --> 20:00:50,160
the function within these two curly

30269
20:00:50,160 --> 20:00:52,960
braces but what we have here is a

30270
20:00:52,960 --> 20:00:55,832
concept we want to apply to this

30271
20:00:55,832 --> 20:00:58,320
function here and the first line here is

30272
20:00:58,320 --> 20:01:00,320
going to show that we can combine the

30273
20:01:00,320 --> 20:01:01,440
concept

30274
20:01:01,440 --> 20:01:03,760
like we do here so this entire thing is

30275
20:01:03,760 --> 20:01:06,872
going to be a logical combination of

30276
20:01:06,872 --> 20:01:09,040
concepts so we can require that the

30277
20:01:09,040 --> 20:01:11,440
template parameter be either an integral

30278
20:01:11,440 --> 20:01:14,800
type or a floating point type using the

30279
20:01:14,800 --> 20:01:17,600
or operator here another thing we can do

30280
20:01:17,600 --> 20:01:20,160
is use the and operator as you see down

30281
20:01:20,160 --> 20:01:22,400
here in the second line and we're going

30282
20:01:22,400 --> 20:01:24,080
to require that

30283
20:01:24,080 --> 20:01:24,960
the

30284
20:01:24,960 --> 20:01:28,320
template parameter is both integral and

30285
20:01:28,320 --> 20:01:30,720
a tiny type and the compiler is going to

30286
20:01:30,720 --> 20:01:33,120
enforce these things as we are about to

30287
20:01:33,120 --> 20:01:35,120
see in a minute when we hit visual

30288
20:01:35,120 --> 20:01:37,832
studio code you can even specify your

30289
20:01:37,832 --> 20:01:40,640
concepts in place for example the third

30290
20:01:40,640 --> 20:01:43,280
line here is going to say we require for

30291
20:01:43,280 --> 20:01:46,160
the concept to be integral so it should

30292
20:01:46,160 --> 20:01:48,160
be an integral type and we're going to

30293
20:01:48,160 --> 20:01:51,760
specify our tiny type concept in place

30294
20:01:51,760 --> 20:01:54,640
you see we are doing that right here in

30295
20:01:54,640 --> 20:01:56,720
the function declaration and this is

30296
20:01:56,720 --> 20:01:58,480
going to work this is a valid c plus

30297
20:01:58,480 --> 20:02:01,192
plus syntax but i don't recommend this

30298
20:02:01,192 --> 20:02:02,640
because this is going to make your

30299
20:02:02,640 --> 20:02:05,600
function declarations really ugly so now

30300
20:02:05,600 --> 20:02:07,040
that you know this we're going to head

30301
20:02:07,040 --> 20:02:08,960
over to visual studio code and play with

30302
20:02:08,960 --> 20:02:11,040
this a little more it's just using the

30303
20:02:11,040 --> 20:02:14,240
or and and operator to combine concepts

30304
20:02:14,240 --> 20:02:16,800
okay here we are in our working folder

30305
20:02:16,800 --> 20:02:18,960
the current project is combining

30306
20:02:18,960 --> 20:02:21,192
concepts we're going to grab our

30307
20:02:21,192 --> 20:02:23,600
template files pretty quick and put them

30308
20:02:23,600 --> 20:02:25,760
in place and we're going to open this in

30309
20:02:25,760 --> 20:02:28,240
visual studio code as we always do by

30310
20:02:28,240 --> 20:02:30,320
dragging and dropping here we have our

30311
20:02:30,320 --> 20:02:32,800
file we're going to open that up and

30312
20:02:32,800 --> 20:02:34,960
close the left pane here i don't like it

30313
20:02:34,960 --> 20:02:37,440
and we're going to include our concepts

30314
20:02:37,440 --> 20:02:40,080
library let's do that we have this and

30315
20:02:40,080 --> 20:02:41,680
the first thing we're going to do is to

30316
20:02:41,680 --> 20:02:44,640
put in our tiny type concept here so it

30317
20:02:44,640 --> 20:02:47,120
is tiny type it's going to require that

30318
20:02:47,120 --> 20:02:49,360
the syntax for the size of t less than

30319
20:02:49,360 --> 20:02:51,192
4b supported this is a simple

30320
20:02:51,192 --> 20:02:53,120
requirement again and we're going to

30321
20:02:53,120 --> 20:02:56,240
require that this expression be true and

30322
20:02:56,240 --> 20:02:57,760
we're doing this

30323
20:02:57,760 --> 20:03:00,160
using a nested requirement okay now that

30324
20:03:00,160 --> 20:03:02,640
we have this concept we can combine this

30325
20:03:02,640 --> 20:03:05,600
with other concepts let's use the same

30326
20:03:05,600 --> 20:03:07,600
function we've been using all along so

30327
20:03:07,600 --> 20:03:09,680
we're going to say template type name

30328
20:03:09,680 --> 20:03:12,320
team and we're going to put in our

30329
20:03:12,320 --> 20:03:14,080
requires clause so we're going to say

30330
20:03:14,080 --> 20:03:17,440
requires we can use std intergroup and

30331
20:03:17,440 --> 20:03:18,640
say t

30332
20:03:18,640 --> 20:03:22,320
and say or it should be htd floating

30333
20:03:22,320 --> 20:03:24,800
point i think we have this end this is a

30334
20:03:24,800 --> 20:03:28,000
concept we have which is built into the

30335
20:03:28,000 --> 20:03:30,160
c plus plus standard library we can use

30336
20:03:30,160 --> 20:03:32,400
this now that we have this we can then

30337
20:03:32,400 --> 20:03:35,280
say the signature of a function t x is

30338
20:03:35,280 --> 20:03:38,240
going to add up t a and t b and it's

30339
20:03:38,240 --> 20:03:40,720
going to return the sum of a and b now

30340
20:03:40,720 --> 20:03:42,480
you can only call this function with

30341
20:03:42,480 --> 20:03:45,040
either integers or floating points if

30342
20:03:45,040 --> 20:03:47,680
you try to deviate from this the concept

30343
20:03:47,680 --> 20:03:49,440
is going to fail and we're going to get

30344
20:03:49,440 --> 20:03:51,832
a compiler error let's go down and try

30345
20:03:51,832 --> 20:03:54,080
this out we're going to say and x and

30346
20:03:54,080 --> 20:03:57,192
put in a 6 for example and into y and

30347
20:03:57,192 --> 20:03:59,440
put in a 4 and we're going to add this

30348
20:03:59,440 --> 20:04:02,160
up we're going to say add x and y and if

30349
20:04:02,160 --> 20:04:04,480
we do this this is going to work because

30350
20:04:04,480 --> 20:04:06,552
this is an integer so the concept here

30351
20:04:06,552 --> 20:04:09,760
is going to succeed let's weld with gcc

30352
20:04:09,760 --> 20:04:11,192
and show you that the build is good the

30353
20:04:11,192 --> 20:04:13,512
world is good so no problem we can

30354
20:04:13,512 --> 20:04:15,040
change this to double it is going to

30355
20:04:15,040 --> 20:04:17,920
work because double is a floating point

30356
20:04:17,920 --> 20:04:20,800
let's say double properly and if we blow

30357
20:04:20,800 --> 20:04:22,400
it again the bullet is going to go

30358
20:04:22,400 --> 20:04:25,120
through but if we try and use for

30359
20:04:25,120 --> 20:04:27,832
example a strength let's say std

30360
20:04:27,832 --> 20:04:30,640
strength string that's a strength and

30361
20:04:30,640 --> 20:04:32,800
we're going to change this into double

30362
20:04:32,800 --> 20:04:35,832
quotes we can do that and say std

30363
20:04:35,832 --> 20:04:39,192
strength and i put this in quotes again

30364
20:04:39,192 --> 20:04:42,240
double quotes okay if we do this you see

30365
20:04:42,240 --> 20:04:44,872
we have a squiggly line and if we walk

30366
20:04:44,872 --> 20:04:48,000
we're going to have violated our concept

30367
20:04:48,000 --> 20:04:50,800
because the parameters that we pass

30368
20:04:50,800 --> 20:04:53,192
don't satisfy this concept it's neither

30369
20:04:53,192 --> 20:04:55,832
an integral type or a floating point

30370
20:04:55,832 --> 20:04:58,240
type and if we go up here we're going to

30371
20:04:58,240 --> 20:05:01,120
see that we have violated a concept

30372
20:05:01,120 --> 20:05:03,832
constraint not satisfied and it's going

30373
20:05:03,832 --> 20:05:06,080
to say the concept that was not

30374
20:05:06,080 --> 20:05:09,040
satisfied here which is right here okay

30375
20:05:09,040 --> 20:05:11,120
you can combine two concepts using the

30376
20:05:11,120 --> 20:05:13,440
or operator but we can also use the and

30377
20:05:13,440 --> 20:05:14,480
operator

30378
20:05:14,480 --> 20:05:16,480
let's go down and try and put up a

30379
20:05:16,480 --> 20:05:18,872
simple example that is going to do that

30380
20:05:18,872 --> 20:05:21,040
now what we're going to require for

30381
20:05:21,040 --> 20:05:23,440
people to use this function is to

30382
20:05:23,440 --> 20:05:24,720
satisfy

30383
20:05:24,720 --> 20:05:27,832
both tiny type and integral so we're

30384
20:05:27,832 --> 20:05:30,800
going to say requires std integral i

30385
20:05:30,800 --> 20:05:32,552
think we have this n and we're going to

30386
20:05:32,552 --> 20:05:33,832
say and

30387
20:05:33,832 --> 20:05:35,440
tiny time and we're going to say our

30388
20:05:35,440 --> 20:05:38,080
template parameter here the moment we do

30389
20:05:38,080 --> 20:05:40,872
this and let's turn this back to being

30390
20:05:40,872 --> 20:05:44,000
at let's say ant x and put in a seven

30391
20:05:44,000 --> 20:05:46,960
what we had before and at y and let's

30392
20:05:46,960 --> 20:05:49,920
say four or a five doesn't matter

30393
20:05:49,920 --> 20:05:51,360
if we do this

30394
20:05:51,360 --> 20:05:54,872
let's see our thing again so tiny type

30395
20:05:54,872 --> 20:05:57,440
requires for the size to be less or

30396
20:05:57,440 --> 20:05:58,400
equal

30397
20:05:58,400 --> 20:06:00,720
to four so ant is going to work this is

30398
20:06:00,720 --> 20:06:02,400
going to build because the concept is

30399
20:06:02,400 --> 20:06:04,960
going to be satisfied it is both

30400
20:06:04,960 --> 20:06:07,120
integral and tiny type

30401
20:06:07,120 --> 20:06:10,000
let's work and see this run you see the

30402
20:06:10,000 --> 20:06:13,120
world is good our concept is satisfied

30403
20:06:13,120 --> 20:06:16,320
but the moment we try and use something

30404
20:06:16,320 --> 20:06:18,640
that is greater than four

30405
20:06:18,640 --> 20:06:20,640
we're going to have a problem

30406
20:06:20,640 --> 20:06:23,360
let's use a double for example we're

30407
20:06:23,360 --> 20:06:26,240
going to change this to double and world

30408
20:06:26,240 --> 20:06:29,040
we expect compilation to fail because

30409
20:06:29,040 --> 20:06:32,400
the type which is double doesn't satisfy

30410
20:06:32,400 --> 20:06:34,552
the tiny type concept and we're going to

30411
20:06:34,552 --> 20:06:36,960
see that here okay so we're going to see

30412
20:06:36,960 --> 20:06:39,360
weld finished with arrows and we're

30413
20:06:39,360 --> 20:06:41,760
going to have a lengthy error here but

30414
20:06:41,760 --> 20:06:44,480
the meat of this is that we have a

30415
20:06:44,480 --> 20:06:47,360
constraint which is not satisfied

30416
20:06:47,360 --> 20:06:48,960
and it is

30417
20:06:48,960 --> 20:06:51,680
that for required for the satisfaction

30418
20:06:51,680 --> 20:06:55,120
of std integral so double is not going

30419
20:06:55,120 --> 20:06:57,600
to satisfy this i think double was a

30420
20:06:57,600 --> 20:06:59,360
really bad example because it's not

30421
20:06:59,360 --> 20:07:01,680
integral so integral is going to fail

30422
20:07:01,680 --> 20:07:04,000
what if we pass in long ant okay which

30423
20:07:04,000 --> 20:07:05,040
is really

30424
20:07:05,040 --> 20:07:07,040
an integral type but it's not going to

30425
20:07:07,040 --> 20:07:10,320
satisfy tiny type so let's say long end

30426
20:07:10,320 --> 20:07:12,640
and we're going to build now we are

30427
20:07:12,640 --> 20:07:15,600
going to violate let's use long long ant

30428
20:07:15,600 --> 20:07:18,320
because i think long end is not large

30429
20:07:18,320 --> 20:07:20,552
enough so we're going to build now we're

30430
20:07:20,552 --> 20:07:23,280
going to fail because tiny type is not

30431
20:07:23,280 --> 20:07:25,600
satisfied you see required for a

30432
20:07:25,600 --> 20:07:27,920
dissatisfaction of tiny type and it's

30433
20:07:27,920 --> 20:07:31,040
going to say size of t is less than 4 is

30434
20:07:31,040 --> 20:07:34,400
not satisfied because guess what the

30435
20:07:34,400 --> 20:07:37,832
size of lung lung ant is greater than 4.

30436
20:07:37,832 --> 20:07:40,160
you can try and prove that by taking out

30437
20:07:40,160 --> 20:07:44,160
this guy here and saying stdc out size

30438
20:07:44,160 --> 20:07:47,440
of a long long end we're going to see

30439
20:07:47,440 --> 20:07:49,280
this print out

30440
20:07:49,280 --> 20:07:50,872
and if we're boiled now we're not going

30441
20:07:50,872 --> 20:07:52,552
to violate our concepts because we're

30442
20:07:52,552 --> 20:07:54,552
not calling the function

30443
20:07:54,552 --> 20:07:56,480
the word is going to be good what we

30444
20:07:56,480 --> 20:07:58,872
want to do is run the program and see

30445
20:07:58,872 --> 20:08:01,512
the size of lung lung ant we can do this

30446
20:08:01,512 --> 20:08:05,360
rooster eight the size of lung lung ant

30447
20:08:05,360 --> 20:08:08,240
is eight and it is going to violate our

30448
20:08:08,240 --> 20:08:11,512
tiny type concept okay you can do things

30449
20:08:11,512 --> 20:08:13,680
like this and combine the concepts but

30450
20:08:13,680 --> 20:08:16,640
we can even put our concepts in place we

30451
20:08:16,640 --> 20:08:19,280
can do something crazy and for example

30452
20:08:19,280 --> 20:08:21,680
say let's copy this and we're going to

30453
20:08:21,680 --> 20:08:24,640
go down and say requires integral but

30454
20:08:24,640 --> 20:08:27,040
we're going to put timely type in place

30455
20:08:27,040 --> 20:08:28,480
for example we're going to grab the

30456
20:08:28,480 --> 20:08:31,040
requires close here and copy it

30457
20:08:31,040 --> 20:08:33,760
and put that in place of tiny type here

30458
20:08:33,760 --> 20:08:35,512
we're going to do this

30459
20:08:35,512 --> 20:08:36,800
and you're going to see that this is

30460
20:08:36,800 --> 20:08:39,192
going to be valid c plus plus syntax if

30461
20:08:39,192 --> 20:08:41,280
we take out the semicolon because it

30462
20:08:41,280 --> 20:08:43,832
shouldn't be there but look at this this

30463
20:08:43,832 --> 20:08:45,440
is really ugly this is going to make

30464
20:08:45,440 --> 20:08:48,160
your functions really hard to read but

30465
20:08:48,160 --> 20:08:50,480
it is going to work exactly the same way

30466
20:08:50,480 --> 20:08:52,552
it did if we call this function we're

30467
20:08:52,552 --> 20:08:55,280
going to violate tiny type let's do that

30468
20:08:55,280 --> 20:08:57,512
we're going to build with gcc we have an

30469
20:08:57,512 --> 20:09:00,080
error let's bring this up so that we can

30470
20:09:00,080 --> 20:09:02,872
see what is wrong nested requirement

30471
20:09:02,872 --> 20:09:05,680
size of t is not satisfied this is a

30472
20:09:05,680 --> 20:09:08,480
syntax you can use but i don't really

30473
20:09:08,480 --> 20:09:10,160
recommend this because this is going to

30474
20:09:10,160 --> 20:09:12,480
make you code hard to read and this is

30475
20:09:12,480 --> 20:09:14,720
really all we set out to do in this

30476
20:09:14,720 --> 20:09:16,800
lecture looking at how we can combine

30477
20:09:16,800 --> 20:09:20,000
our concepts using the and operator and

30478
20:09:20,000 --> 20:09:22,960
the or operator and you can really use

30479
20:09:22,960 --> 20:09:26,000
this in all the syntaxes for concepts we

30480
20:09:26,000 --> 20:09:28,640
have seen but i just used this in this

30481
20:09:28,640 --> 20:09:30,960
lecture because it is simpler to show

30482
20:09:30,960 --> 20:09:32,640
we are going to stop here in this

30483
20:09:32,640 --> 20:09:34,480
lecture the next one we're going to look

30484
20:09:34,480 --> 20:09:37,512
at concepts and auto go ahead and finish

30485
20:09:37,512 --> 20:09:39,920
up here and meet me there in this

30486
20:09:39,920 --> 20:09:41,512
lecture we're going to zoom in on

30487
20:09:41,512 --> 20:09:44,160
concepts and the auto key world we have

30488
20:09:44,160 --> 20:09:46,000
already seen that we can do something

30489
20:09:46,000 --> 20:09:48,640
like this use the auto keywords with our

30490
20:09:48,640 --> 20:09:51,192
functions and let the compiler generate

30491
20:09:51,192 --> 20:09:53,360
a function template behind the scenes

30492
20:09:53,360 --> 20:09:55,280
and this worked pretty well we could use

30493
20:09:55,280 --> 20:09:58,320
this syntax to put constraints on our

30494
20:09:58,320 --> 20:10:00,480
other keywords and we saw that the

30495
20:10:00,480 --> 20:10:03,280
compiler could actually enforce this and

30496
20:10:03,280 --> 20:10:05,760
throw a compiler error if our concept

30497
20:10:05,760 --> 20:10:08,640
here is violated what i haven't shown

30498
20:10:08,640 --> 20:10:11,280
you is that you can even enforce

30499
20:10:11,280 --> 20:10:13,920
concepts on variables that you declare

30500
20:10:13,920 --> 20:10:15,920
you can do something like this set up a

30501
20:10:15,920 --> 20:10:18,000
variable say auto x and call the

30502
20:10:18,000 --> 20:10:21,120
variable x and enforce for the variable

30503
20:10:21,120 --> 20:10:23,680
to be an integral type i don't really

30504
20:10:23,680 --> 20:10:26,552
think you have much use for this because

30505
20:10:26,552 --> 20:10:29,040
once you call the function and assign a

30506
20:10:29,040 --> 20:10:31,832
value to a variable you already have an

30507
20:10:31,832 --> 20:10:34,080
idea of what is going to come out of the

30508
20:10:34,080 --> 20:10:36,480
function but if you have a use case for

30509
20:10:36,480 --> 20:10:38,720
something like this please go ahead and

30510
20:10:38,720 --> 20:10:40,552
use this it is going to enforce your

30511
20:10:40,552 --> 20:10:43,360
concepts you can even use concepts like

30512
20:10:43,360 --> 20:10:45,760
this set up a variable and assign a

30513
20:10:45,760 --> 20:10:48,400
literal to the variable name using the

30514
20:10:48,400 --> 20:10:51,512
auto keyword here but i personally find

30515
20:10:51,512 --> 20:10:54,320
this useless because you are putting in

30516
20:10:54,320 --> 20:10:55,832
the value yourself

30517
20:10:55,832 --> 20:10:58,872
why do you want to put a protection if

30518
20:10:58,872 --> 20:11:00,320
you know that you are putting in a

30519
20:11:00,320 --> 20:11:02,240
double literal then the variable should

30520
20:11:02,240 --> 20:11:05,040
be a double type i find this a little

30521
20:11:05,040 --> 20:11:07,440
bit useless but it is supported in c

30522
20:11:07,440 --> 20:11:09,360
plus plus if you have a use case for

30523
20:11:09,360 --> 20:11:11,832
this please go ahead and use this now

30524
20:11:11,832 --> 20:11:13,360
that you know this we're going to head

30525
20:11:13,360 --> 20:11:15,600
over to visual studio code and play with

30526
20:11:15,600 --> 20:11:18,240
us a little more okay here we are in our

30527
20:11:18,240 --> 20:11:20,320
working folder the current project is

30528
20:11:20,320 --> 20:11:22,872
concepts and auto we're going to grab

30529
20:11:22,872 --> 20:11:24,960
our template files and we're going to

30530
20:11:24,960 --> 20:11:27,120
put them in place and we're going to

30531
20:11:27,120 --> 20:11:29,440
open this up in visual studio code let's

30532
20:11:29,440 --> 20:11:31,360
do that pretty quick we're going to have

30533
20:11:31,360 --> 20:11:33,280
our folder open we're going to open the

30534
20:11:33,280 --> 20:11:36,400
main cpp file close the left pane and

30535
20:11:36,400 --> 20:11:38,552
clean things up a little bit and we're

30536
20:11:38,552 --> 20:11:41,360
going to include our concepts library

30537
20:11:41,360 --> 20:11:43,512
and we're going to put in our function

30538
20:11:43,512 --> 20:11:45,192
which is going to be using the auto

30539
20:11:45,192 --> 20:11:46,720
keywords to

30540
20:11:46,720 --> 20:11:49,600
really make the syntax nice and cool but

30541
20:11:49,600 --> 20:11:51,760
we're going to be constraining our auto

30542
20:11:51,760 --> 20:11:54,960
parameters here to use integral types if

30543
20:11:54,960 --> 20:11:56,640
we call this function with something

30544
20:11:56,640 --> 20:11:59,040
that is not an integer or any trigger

30545
20:11:59,040 --> 20:12:00,640
type really we're going to get a

30546
20:12:00,640 --> 20:12:02,872
compiler error so if we go down here for

30547
20:12:02,872 --> 20:12:05,720
example and say add and say

30548
20:12:05,720 --> 20:12:09,360
10.9 and 0.1 we're going to get a

30549
20:12:09,360 --> 20:12:14,160
compiler error because 10.9 and 0.1 are

30550
20:12:14,160 --> 20:12:16,640
double literals and we only support

30551
20:12:16,640 --> 20:12:19,120
integral types in this function here so

30552
20:12:19,120 --> 20:12:21,192
let's work and show you the error but

30553
20:12:21,192 --> 20:12:23,040
you must know this by now because we

30554
20:12:23,040 --> 20:12:25,440
have done this like a gazillion times

30555
20:12:25,440 --> 20:12:27,280
the concept integral is going to be

30556
20:12:27,280 --> 20:12:29,760
violated and it's going to say required

30557
20:12:29,760 --> 20:12:32,800
for the satisfaction of integral so the

30558
20:12:32,800 --> 20:12:34,720
concept is failing here we're going to

30559
20:12:34,720 --> 20:12:36,640
get a compiler error but if we change

30560
20:12:36,640 --> 20:12:39,600
this for example to 10 and 5 put in

30561
20:12:39,600 --> 20:12:41,600
whatever you want which is an integer

30562
20:12:41,600 --> 20:12:42,872
this is going to work we're going to

30563
20:12:42,872 --> 20:12:44,800
build with gcc

30564
20:12:44,800 --> 20:12:46,720
you see the wealth is good so you can

30565
20:12:46,720 --> 20:12:49,760
use auto with concepts like this we have

30566
20:12:49,760 --> 20:12:51,832
seen this syntax already a couple of

30567
20:12:51,832 --> 20:12:53,760
times in this chapter what we haven't

30568
20:12:53,760 --> 20:12:55,920
seen is that for example you can set up

30569
20:12:55,920 --> 20:12:59,040
a variable in main and call this x y

30570
20:12:59,040 --> 20:13:02,240
naught and say this variable should

30571
20:13:02,240 --> 20:13:05,192
satisfy the concept and specify the

30572
20:13:05,192 --> 20:13:06,960
concept you want for example let's say

30573
20:13:06,960 --> 20:13:09,280
std integral and if you do something

30574
20:13:09,280 --> 20:13:11,192
like this let's see what we get from

30575
20:13:11,192 --> 20:13:12,800
this we're going to world you see the

30576
20:13:12,800 --> 20:13:14,872
work is good because if we add up these

30577
20:13:14,872 --> 20:13:17,360
guys we're going to generate an integer

30578
20:13:17,360 --> 20:13:19,512
instance for this function and we're

30579
20:13:19,512 --> 20:13:22,080
going to deduce the return type as ant

30580
20:13:22,080 --> 20:13:23,832
so the return type is going to be

30581
20:13:23,832 --> 20:13:26,480
integral and it's going to be assignable

30582
20:13:26,480 --> 20:13:29,760
in our variable here but if we change to

30583
20:13:29,760 --> 20:13:31,680
floating point i think we have this

30584
20:13:31,680 --> 20:13:34,240
concept in place yes we do but it is

30585
20:13:34,240 --> 20:13:36,400
going to fail because what we get from

30586
20:13:36,400 --> 20:13:38,640
this function is going to be an integer

30587
20:13:38,640 --> 20:13:41,192
and we can't assign to this because this

30588
20:13:41,192 --> 20:13:43,120
concept here is saying

30589
20:13:43,120 --> 20:13:46,080
what you try to assign to this variable

30590
20:13:46,080 --> 20:13:48,240
here should be a floating point this is

30591
20:13:48,240 --> 20:13:50,000
the meaning here and if we do this we're

30592
20:13:50,000 --> 20:13:52,240
going to get to the error probably so we

30593
20:13:52,240 --> 20:13:54,800
have the arrow and it's going to say

30594
20:13:54,800 --> 20:13:57,440
constraint not satisfied and it is going

30595
20:13:57,440 --> 20:13:59,192
to say the

30596
20:13:59,192 --> 20:14:01,680
constraint we didn't satisfy which is

30597
20:14:01,680 --> 20:14:03,760
its floating point here this is how you

30598
20:14:03,760 --> 20:14:06,320
can put constraints on your variables

30599
20:14:06,320 --> 20:14:08,800
even when you are declaring them so

30600
20:14:08,800 --> 20:14:11,512
another thing we can try here is to

30601
20:14:11,512 --> 20:14:12,800
assign

30602
20:14:12,800 --> 20:14:15,360
a literal to this variable here let's

30603
20:14:15,360 --> 20:14:18,720
put in a 3.9 and see if this actually

30604
20:14:18,720 --> 20:14:20,552
boils and compiles

30605
20:14:20,552 --> 20:14:22,872
let's build with gcc

30606
20:14:22,872 --> 20:14:24,872
you see the build is good and the

30607
20:14:24,872 --> 20:14:27,832
requirement is for what we assigned to

30608
20:14:27,832 --> 20:14:30,480
this variable here should be a double

30609
20:14:30,480 --> 20:14:33,360
and a 3.9 is already a double so no

30610
20:14:33,360 --> 20:14:36,400
problem but if we try and make this

30611
20:14:36,400 --> 20:14:38,080
seven for example

30612
20:14:38,080 --> 20:14:40,640
this is going to fail so let's build

30613
20:14:40,640 --> 20:14:42,640
again you see the concept is going to

30614
20:14:42,640 --> 20:14:45,280
fail and this is how you can use these

30615
20:14:45,280 --> 20:14:48,552
things to constrain your variables i

30616
20:14:48,552 --> 20:14:50,720
personally find this a little bit

30617
20:14:50,720 --> 20:14:53,120
useless at least in this case here

30618
20:14:53,120 --> 20:14:56,552
because i know that i have an integer

30619
20:14:56,552 --> 20:14:57,680
literal

30620
20:14:57,680 --> 20:15:00,000
and i am assigning this to a variable

30621
20:15:00,000 --> 20:15:02,480
why do i need the help of concepts to

30622
20:15:02,480 --> 20:15:03,440
really

30623
20:15:03,440 --> 20:15:05,920
constrain my variable here but in the

30624
20:15:05,920 --> 20:15:07,832
case where you are calling a function

30625
20:15:07,832 --> 20:15:11,680
for example using a 5 and an 8

30626
20:15:11,680 --> 20:15:14,080
this can come in handy because it's not

30627
20:15:14,080 --> 20:15:16,800
easy to keep track of the return type

30628
20:15:16,800 --> 20:15:18,720
you get from a function because the

30629
20:15:18,720 --> 20:15:21,440
function might have a return expression

30630
20:15:21,440 --> 20:15:24,400
that has multiple different variables

30631
20:15:24,400 --> 20:15:26,552
and it's not easy to keep track of what

30632
20:15:26,552 --> 20:15:28,872
you get back from a function and you can

30633
20:15:28,872 --> 20:15:31,920
use a constraint like this to make sure

30634
20:15:31,920 --> 20:15:33,832
what you get from the function is what

30635
20:15:33,832 --> 20:15:35,920
you want and if it's not what you want

30636
20:15:35,920 --> 20:15:37,832
you're going to throw a compiler error

30637
20:15:37,832 --> 20:15:40,000
because the concept you use is going to

30638
20:15:40,000 --> 20:15:42,160
fail i would like to welcome you in this

30639
20:15:42,160 --> 20:15:43,832
new chapter where we're going to be

30640
20:15:43,832 --> 20:15:46,872
learning about classes classes are a

30641
20:15:46,872 --> 20:15:49,440
mechanism we have in c plus plus to

30642
20:15:49,440 --> 20:15:52,480
build our own types and use them like we

30643
20:15:52,480 --> 20:15:54,800
have been using other bulletin types

30644
20:15:54,800 --> 20:15:57,120
like and to double or whatever and we're

30645
20:15:57,120 --> 20:15:59,120
going to be able to do that by setting

30646
20:15:59,120 --> 20:16:03,280
up blueprints of our class types and

30647
20:16:03,280 --> 20:16:05,600
we're going to be using those blueprints

30648
20:16:05,600 --> 20:16:08,480
to build actual objects that we can use

30649
20:16:08,480 --> 20:16:10,640
in our c plus plus program so for

30650
20:16:10,640 --> 20:16:12,960
example we can have a class as a

30651
20:16:12,960 --> 20:16:16,160
blueprint and we can create real class

30652
20:16:16,160 --> 20:16:19,600
objects in our c plus plus program as we

30653
20:16:19,600 --> 20:16:21,760
need them and we're going to be learning

30654
20:16:21,760 --> 20:16:24,320
all about this in the next few chapters

30655
20:16:24,320 --> 20:16:25,920
we are going to head over in the next

30656
20:16:25,920 --> 20:16:28,320
lecture and let you set up your very

30657
20:16:28,320 --> 20:16:31,040
first c plus plus class go ahead and

30658
20:16:31,040 --> 20:16:33,760
finish up here and meet me there in this

30659
20:16:33,760 --> 20:16:35,920
lecture you are going to build your

30660
20:16:35,920 --> 20:16:39,192
first c plus plus class classes are a

30661
20:16:39,192 --> 20:16:42,080
mechanism we have in c plus plus to be

30662
20:16:42,080 --> 20:16:45,040
able to build our own types if you

30663
20:16:45,040 --> 20:16:47,280
remember so far in this course we have

30664
20:16:47,280 --> 20:16:50,000
been using basic types like ant and

30665
20:16:50,000 --> 20:16:50,960
double

30666
20:16:50,960 --> 20:16:53,360
and we were using them like this we said

30667
20:16:53,360 --> 20:16:55,600
the type of the variable we give the

30668
20:16:55,600 --> 20:16:57,360
name of the variable and then we

30669
20:16:57,360 --> 20:16:59,760
initialize this variable and we can use

30670
20:16:59,760 --> 20:17:03,280
this throughout our program now we are

30671
20:17:03,280 --> 20:17:05,920
at a point where we need to start

30672
20:17:05,920 --> 20:17:08,800
designing our own types suppose we want

30673
20:17:08,800 --> 20:17:12,720
to build our own type that models a

30674
20:17:12,720 --> 20:17:15,192
person for example suppose a person is

30675
20:17:15,192 --> 20:17:17,440
defined by the name

30676
20:17:17,440 --> 20:17:20,800
the age and the address and we want to

30677
20:17:20,800 --> 20:17:23,760
model persons in our program

30678
20:17:23,760 --> 20:17:27,120
and use them as players for example and

30679
20:17:27,120 --> 20:17:29,680
when we have the properties of a person

30680
20:17:29,680 --> 20:17:31,680
we can do all kinds of crazy things with

30681
20:17:31,680 --> 20:17:33,440
them we can make them jump up for

30682
20:17:33,440 --> 20:17:35,920
example if we are designing a game we

30683
20:17:35,920 --> 20:17:38,480
can make them run we can make them fly

30684
20:17:38,480 --> 20:17:40,800
we can do all kinds of crazy things in

30685
20:17:40,800 --> 20:17:42,240
this lecture we're going to use a

30686
20:17:42,240 --> 20:17:44,720
cylinder as an example and we're going

30687
20:17:44,720 --> 20:17:48,000
to model a cylinder in our c plus plus

30688
20:17:48,000 --> 20:17:51,120
program a cylinder is defined by two

30689
20:17:51,120 --> 20:17:54,000
things it has a base radius which is

30690
20:17:54,000 --> 20:17:56,872
modeled by this r you see here and it

30691
20:17:56,872 --> 20:17:58,240
has a height

30692
20:17:58,240 --> 20:18:00,720
and when we have this information about

30693
20:18:00,720 --> 20:18:03,512
our cylinder we can really do all kinds

30694
20:18:03,512 --> 20:18:05,280
of crazy things for example we can

30695
20:18:05,280 --> 20:18:08,552
compute its area the base area and the

30696
20:18:08,552 --> 20:18:10,872
formula to do that is pi

30697
20:18:10,872 --> 20:18:13,680
r squared this is a formula you get from

30698
20:18:13,680 --> 20:18:16,400
your basic mathematics education

30699
20:18:16,400 --> 20:18:18,160
you can compute the volume of the

30700
20:18:18,160 --> 20:18:21,512
cylinder and the formula to do that is

30701
20:18:21,512 --> 20:18:24,160
area multiplied by the height and we can

30702
20:18:24,160 --> 20:18:26,640
really do all kinds of crazy things with

30703
20:18:26,640 --> 20:18:30,000
the cylinder if we have this information

30704
20:18:30,000 --> 20:18:32,160
so we're going to use this information

30705
20:18:32,160 --> 20:18:35,680
and model a cylinder we can use in our c

30706
20:18:35,680 --> 20:18:38,160
plus plus program and we're going to be

30707
20:18:38,160 --> 20:18:41,040
using classes to do that the syntax to

30708
20:18:41,040 --> 20:18:43,192
set up your class in c plus plus it's

30709
20:18:43,192 --> 20:18:45,440
really simple you say class this is the

30710
20:18:45,440 --> 20:18:48,552
keyword you have to put in here you say

30711
20:18:48,552 --> 20:18:50,960
the name of your class in this case it

30712
20:18:50,960 --> 20:18:53,680
is cylander as you see here and then we

30713
20:18:53,680 --> 20:18:57,120
put a pair of curly braces in place the

30714
20:18:57,120 --> 20:18:59,760
start is on top here and the end is down

30715
20:18:59,760 --> 20:19:02,240
here and after your class definition

30716
20:19:02,240 --> 20:19:04,320
you're going to put a semicolon inside

30717
20:19:04,320 --> 20:19:07,120
the class we really have two parts we

30718
20:19:07,120 --> 20:19:09,440
have member variables which are going to

30719
20:19:09,440 --> 20:19:11,600
model the properties that your class is

30720
20:19:11,600 --> 20:19:14,240
going to have in this case we have two

30721
20:19:14,240 --> 20:19:16,872
properties that really define a cylinder

30722
20:19:16,872 --> 20:19:19,120
we have the best radius and we have the

30723
20:19:19,120 --> 20:19:21,760
height we have decided to model these

30724
20:19:21,760 --> 20:19:24,960
things as double types inside our class

30725
20:19:24,960 --> 20:19:27,600
and this is going to make the first part

30726
20:19:27,600 --> 20:19:30,720
of our class the member variables the

30727
20:19:30,720 --> 20:19:33,280
second part is going to be made of

30728
20:19:33,280 --> 20:19:37,360
behaviors or functions that do things on

30729
20:19:37,360 --> 20:19:40,640
the class using the properties and one

30730
20:19:40,640 --> 20:19:43,440
function we have is the volume function

30731
20:19:43,440 --> 20:19:45,440
which is going to help us compute the

30732
20:19:45,440 --> 20:19:48,720
volume of our cylinder here if you look

30733
20:19:48,720 --> 20:19:51,832
at its syntax it really is a function we

30734
20:19:51,832 --> 20:19:54,000
have a return type we have the name of

30735
20:19:54,000 --> 20:19:56,320
the function we have the parameter list

30736
20:19:56,320 --> 20:19:58,320
which is empty by now and we have our

30737
20:19:58,320 --> 20:20:01,680
curly braces that delimit the body of

30738
20:20:01,680 --> 20:20:03,832
our function inside the function we're

30739
20:20:03,832 --> 20:20:05,440
going to do nothing special we're just

30740
20:20:05,440 --> 20:20:08,240
going to return the volume of our

30741
20:20:08,240 --> 20:20:10,320
function here and if you remember the

30742
20:20:10,320 --> 20:20:13,040
volume is the base area

30743
20:20:13,040 --> 20:20:16,400
multiplied by the height and this thing

30744
20:20:16,400 --> 20:20:19,120
here is going to model the base area you

30745
20:20:19,120 --> 20:20:20,800
see it's pi

30746
20:20:20,800 --> 20:20:24,240
multiplied by the square of the radius

30747
20:20:24,240 --> 20:20:25,832
and then we're going to multiply this by

30748
20:20:25,832 --> 20:20:27,680
the height and we're going to return the

30749
20:20:27,680 --> 20:20:30,552
volume for use by whoever is calling

30750
20:20:30,552 --> 20:20:32,000
this function

30751
20:20:32,000 --> 20:20:34,160
one thing we haven't really talked about

30752
20:20:34,160 --> 20:20:36,720
is this public thing you see here

30753
20:20:36,720 --> 20:20:40,080
and what this says is that the members

30754
20:20:40,080 --> 20:20:42,160
that we have in this class are going to

30755
20:20:42,160 --> 20:20:44,960
be accessible from the outside of the

30756
20:20:44,960 --> 20:20:47,512
class for now we can't really understand

30757
20:20:47,512 --> 20:20:49,832
this but when we hit visual studio code

30758
20:20:49,832 --> 20:20:52,160
i'm going to show you what this exactly

30759
20:20:52,160 --> 20:20:53,192
means

30760
20:20:53,192 --> 20:20:55,680
now that we have the class declared we

30761
20:20:55,680 --> 20:20:58,000
can really use it like we use any other

30762
20:20:58,000 --> 20:21:00,552
types in c plus plus for example we can

30763
20:21:00,552 --> 20:21:03,120
head in our main function

30764
20:21:03,120 --> 20:21:05,280
and set up a variable called cylinder

30765
20:21:05,280 --> 20:21:07,512
one as you see here is type is going to

30766
20:21:07,512 --> 20:21:10,080
be cylinder and notice that this is

30767
20:21:10,080 --> 20:21:12,960
really a type that we build ourselves

30768
20:21:12,960 --> 20:21:15,120
and we can really use it like we use

30769
20:21:15,120 --> 20:21:17,760
other variables for example we can call

30770
20:21:17,760 --> 20:21:20,552
it function using the syntax here and

30771
20:21:20,552 --> 20:21:22,720
print the volume this is going to print

30772
20:21:22,720 --> 20:21:25,280
the volume using the volume function

30773
20:21:25,280 --> 20:21:27,832
that we just set up in a minute if we go

30774
20:21:27,832 --> 20:21:30,872
down we can modify things about our

30775
20:21:30,872 --> 20:21:33,512
cylinder for example we can use the dot

30776
20:21:33,512 --> 20:21:36,320
notation here to change the base radius

30777
20:21:36,320 --> 20:21:38,480
and change the height and if we try to

30778
20:21:38,480 --> 20:21:41,192
print the volume again this information

30779
20:21:41,192 --> 20:21:43,512
is going to be picked up and be used by

30780
20:21:43,512 --> 20:21:46,080
the volume function to compute the

30781
20:21:46,080 --> 20:21:48,480
volume of our cylinder here this is

30782
20:21:48,480 --> 20:21:50,400
really cool if you want you can also set

30783
20:21:50,400 --> 20:21:52,320
up another cylinder like we do here and

30784
20:21:52,320 --> 20:21:54,240
we're going to print the volume and we

30785
20:21:54,240 --> 20:21:56,872
can really do all kinds of crazy things

30786
20:21:56,872 --> 20:21:59,192
with our types like this okay this is

30787
20:21:59,192 --> 20:22:01,760
our class and we can really use it to do

30788
20:22:01,760 --> 20:22:04,800
a lot before we head over to visual

30789
20:22:04,800 --> 20:22:07,280
studio code and play with us i want to

30790
20:22:07,280 --> 20:22:09,920
bring to your attention that members of

30791
20:22:09,920 --> 20:22:11,280
a class

30792
20:22:11,280 --> 20:22:14,240
are private by default and what i mean

30793
20:22:14,240 --> 20:22:16,800
by that is that for example if we don't

30794
20:22:16,800 --> 20:22:19,832
put this public keywords in here we want

30795
20:22:19,832 --> 20:22:21,192
to be able

30796
20:22:21,192 --> 20:22:24,080
to use the volume function for example

30797
20:22:24,080 --> 20:22:27,280
like we have used it in our main

30798
20:22:27,280 --> 20:22:30,000
function as you see here

30799
20:22:30,000 --> 20:22:32,480
if the member is private it won't be

30800
20:22:32,480 --> 20:22:35,280
usable outside the class this is what we

30801
20:22:35,280 --> 20:22:37,512
mean here we are trying to use this

30802
20:22:37,512 --> 20:22:39,832
member in the main function

30803
20:22:39,832 --> 20:22:42,400
outside the class definition it won't be

30804
20:22:42,400 --> 20:22:45,360
accessible if it is private and we make

30805
20:22:45,360 --> 20:22:48,400
it public by putting the public keyword

30806
20:22:48,400 --> 20:22:50,480
and the column like we do here

30807
20:22:50,480 --> 20:22:52,720
everything after this public keyword is

30808
20:22:52,720 --> 20:22:55,120
going to be public until we change this

30809
20:22:55,120 --> 20:22:57,512
to private somewhere in our program if

30810
20:22:57,512 --> 20:23:00,400
we need that now that you have an idea

30811
20:23:00,400 --> 20:23:02,800
about how you can declare and use your

30812
20:23:02,800 --> 20:23:05,600
class in c plus plus let's head over to

30813
20:23:05,600 --> 20:23:07,440
visual studio code and play with us a

30814
20:23:07,440 --> 20:23:10,240
little more okay here we are in our

30815
20:23:10,240 --> 20:23:12,720
working folder the current project is

30816
20:23:12,720 --> 20:23:14,872
your first class you are going to build

30817
20:23:14,872 --> 20:23:17,360
your very first class in c plus plus

30818
20:23:17,360 --> 20:23:19,760
we're going to grab our template files

30819
20:23:19,760 --> 20:23:22,080
we're going to copy them and put them in

30820
20:23:22,080 --> 20:23:24,400
place and then we're going to open this

30821
20:23:24,400 --> 20:23:26,720
little guy in visual studio code by

30822
20:23:26,720 --> 20:23:29,120
dragging and dropping here this is going

30823
20:23:29,120 --> 20:23:31,040
to open our folder we're going to close

30824
20:23:31,040 --> 20:23:33,440
the left pane here and clean things up a

30825
20:23:33,440 --> 20:23:35,760
little bit the first thing we want to do

30826
20:23:35,760 --> 20:23:38,872
is to declare our class

30827
20:23:38,872 --> 20:23:40,640
but before we do that we're going to

30828
20:23:40,640 --> 20:23:43,040
need the pi variable because remember

30829
20:23:43,040 --> 20:23:45,120
we're going to model pi

30830
20:23:45,120 --> 20:23:48,000
for use in computing the area and the

30831
20:23:48,000 --> 20:23:51,192
volume of our cylinder that we want to

30832
20:23:51,192 --> 20:23:53,280
model like we did in the slides so the

30833
20:23:53,280 --> 20:23:54,960
way we're going to do that i am going to

30834
20:23:54,960 --> 20:23:57,192
declare a const variable and i am going

30835
20:23:57,192 --> 20:23:58,720
to call it pi

30836
20:23:58,720 --> 20:24:01,120
and i am going to initialize this with

30837
20:24:01,120 --> 20:24:04,480
pi to get pi i'm going to cheat a little

30838
20:24:04,480 --> 20:24:07,280
bit i'm going to go in my calculator and

30839
20:24:07,280 --> 20:24:10,240
let's see if i can get pi here and i

30840
20:24:10,240 --> 20:24:12,480
click on this and i'm going to grab pi

30841
20:24:12,480 --> 20:24:15,040
here and copy it this is the easiest way

30842
20:24:15,040 --> 20:24:17,832
i can find so i'm going to put it in

30843
20:24:17,832 --> 20:24:19,680
here and this is going to be our

30844
20:24:19,680 --> 20:24:21,760
variable now that we have this we're

30845
20:24:21,760 --> 20:24:24,320
going to set up our class and that to

30846
20:24:24,320 --> 20:24:27,512
define a class you say class you have to

30847
20:24:27,512 --> 20:24:29,760
put in this keyword and then we're going

30848
20:24:29,760 --> 20:24:31,600
to say the name of the class the name of

30849
20:24:31,600 --> 20:24:34,160
the class is going to be cylinder and

30850
20:24:34,160 --> 20:24:36,160
after we do this we're going to put a

30851
20:24:36,160 --> 20:24:38,960
pair of curly braces and we're going to

30852
20:24:38,960 --> 20:24:41,440
end this with a semi-colon you have to

30853
20:24:41,440 --> 20:24:43,680
remember this if you don't put it here

30854
20:24:43,680 --> 20:24:45,920
the ziploc plus compiler is going to

30855
20:24:45,920 --> 20:24:47,120
complain

30856
20:24:47,120 --> 20:24:49,832
now that we have the class blueprint

30857
20:24:49,832 --> 20:24:51,920
here we're going to put in our member

30858
20:24:51,920 --> 20:24:53,680
variable and these are going to be the

30859
20:24:53,680 --> 20:24:56,320
variables we use to model the base

30860
20:24:56,320 --> 20:24:58,960
radius and the height of our cylinder

30861
20:24:58,960 --> 20:25:01,040
we're going to put in a double variable

30862
20:25:01,040 --> 20:25:03,120
and we're going to call this base radius

30863
20:25:03,120 --> 20:25:05,512
and we're going to brace initialize this

30864
20:25:05,512 --> 20:25:07,760
to zero we can do this and we're going

30865
20:25:07,760 --> 20:25:10,240
to set up another one and call it height

30866
20:25:10,240 --> 20:25:12,480
and we're going to also initialize this

30867
20:25:12,480 --> 20:25:14,400
to zero okay now that we have this we're

30868
20:25:14,400 --> 20:25:17,512
going to put functions or methods in our

30869
20:25:17,512 --> 20:25:20,000
class and we do that by just putting the

30870
20:25:20,000 --> 20:25:22,400
function definition in our class so our

30871
20:25:22,400 --> 20:25:24,872
function is going to be returning double

30872
20:25:24,872 --> 20:25:26,640
because it's going to be returning the

30873
20:25:26,640 --> 20:25:27,832
volume

30874
20:25:27,832 --> 20:25:30,800
of our cylinder so it's going to return

30875
20:25:30,800 --> 20:25:32,400
double here the name is going to be

30876
20:25:32,400 --> 20:25:34,960
volume and it's going to be computing

30877
20:25:34,960 --> 20:25:37,360
the volume and returning that remember

30878
20:25:37,360 --> 20:25:40,080
the formula to compute the volume

30879
20:25:40,080 --> 20:25:42,960
is going to be pi we have a pi variable

30880
20:25:42,960 --> 20:25:45,440
on top and we're going to multiply by

30881
20:25:45,440 --> 20:25:48,160
this radius twice because the base

30882
20:25:48,160 --> 20:25:50,800
radius has to be squared let's do that

30883
20:25:50,800 --> 20:25:53,040
and multiply by base radius again and

30884
20:25:53,040 --> 20:25:55,040
then we're going to multiply by height

30885
20:25:55,040 --> 20:25:58,320
and notice that these are guys declared

30886
20:25:58,320 --> 20:26:00,552
in the body of the class if i can say

30887
20:26:00,552 --> 20:26:02,872
that this is the definition of the class

30888
20:26:02,872 --> 20:26:05,280
we are able to use this guys because we

30889
20:26:05,280 --> 20:26:08,160
are inside this class here okay now that

30890
20:26:08,160 --> 20:26:10,480
we have this our class is really defined

30891
20:26:10,480 --> 20:26:13,360
but we can't really use it quite yet

30892
20:26:13,360 --> 20:26:15,512
what do i mean by that let's go in the

30893
20:26:15,512 --> 20:26:17,600
main function and we're going to set up

30894
20:26:17,600 --> 20:26:20,240
a variable of type cylinder we can do

30895
20:26:20,240 --> 20:26:23,680
that and let's call this cylinder one if

30896
20:26:23,680 --> 20:26:26,400
we do this and try to compile this this

30897
20:26:26,400 --> 20:26:28,320
is going to work fine let's do that

30898
20:26:28,320 --> 20:26:29,440
we're going to

30899
20:26:29,440 --> 20:26:31,512
world with gcc

30900
20:26:31,512 --> 20:26:33,440
world finished successfully this is

30901
20:26:33,440 --> 20:26:36,000
welding but we have a function called

30902
20:26:36,000 --> 20:26:38,800
volume here and we can try and call it

30903
20:26:38,800 --> 20:26:42,000
using the dot notation that we saw in

30904
20:26:42,000 --> 20:26:44,080
the slides let's try and print the

30905
20:26:44,080 --> 20:26:46,800
volume of our cylinder here and see what

30906
20:26:46,800 --> 20:26:48,872
we get so we're going to say volume we

30907
20:26:48,872 --> 20:26:50,720
can save that and we're going to say

30908
20:26:50,720 --> 20:26:53,600
cylinder one and do volume okay let's

30909
20:26:53,600 --> 20:26:55,600
see if we can call this function here

30910
20:26:55,600 --> 20:26:57,440
and the moment we do that you see that

30911
20:26:57,440 --> 20:27:00,552
we have a squiggly line here so visual

30912
20:27:00,552 --> 20:27:02,800
studio code has detected that something

30913
20:27:02,800 --> 20:27:05,512
is wrong let's hit the problems tab here

30914
20:27:05,512 --> 20:27:08,000
and see what we get it's going to say

30915
20:27:08,000 --> 20:27:12,552
expected an identifier on line what this

30916
20:27:12,552 --> 20:27:14,720
is not making sense

30917
20:27:14,720 --> 20:27:17,680
uh we put three columns here let's

30918
20:27:17,680 --> 20:27:19,440
correct this a little bit

30919
20:27:19,440 --> 20:27:23,192
and the error is going to change to be

30920
20:27:23,192 --> 20:27:26,320
suddenly the volume declared at line 6

30921
20:27:26,320 --> 20:27:29,192
is inaccessible from this location here

30922
20:27:29,192 --> 20:27:31,832
this is what the error says and it is

30923
20:27:31,832 --> 20:27:33,192
not sensible

30924
20:27:33,192 --> 20:27:36,800
because members of the class are private

30925
20:27:36,800 --> 20:27:40,000
by default so they want to be accessible

30926
20:27:40,000 --> 20:27:42,080
from the outside of the class like we

30927
20:27:42,080 --> 20:27:44,160
are doing in the main function here

30928
20:27:44,160 --> 20:27:46,960
notice that we are able to access them

30929
20:27:46,960 --> 20:27:48,640
from the inside of the class you see

30930
20:27:48,640 --> 20:27:51,600
base radius is declared down here and we

30931
20:27:51,600 --> 20:27:53,760
are able to use in the function because

30932
20:27:53,760 --> 20:27:56,240
the function volume here is inside the

30933
20:27:56,240 --> 20:27:59,680
class so the members are accessible even

30934
20:27:59,680 --> 20:28:02,160
if they are private but private members

30935
20:28:02,160 --> 20:28:04,552
can't be accessible from the outside of

30936
20:28:04,552 --> 20:28:06,872
the class like we are doing in the main

30937
20:28:06,872 --> 20:28:08,552
function here that's why we have this

30938
20:28:08,552 --> 20:28:10,800
problem let's see what the compiler says

30939
20:28:10,800 --> 20:28:13,192
we're going to pass this through gcc and

30940
20:28:13,192 --> 20:28:14,960
we're going to get a compiler error that

30941
20:28:14,960 --> 20:28:18,320
we expect and the compiler is really

30942
20:28:18,320 --> 20:28:20,640
specific on this it's going to say

30943
20:28:20,640 --> 20:28:23,192
double cylinder volume the volume

30944
20:28:23,192 --> 20:28:26,080
function from the cylinder class is

30945
20:28:26,080 --> 20:28:28,872
private within this context and which

30946
20:28:28,872 --> 20:28:31,920
context the line 19 when we are trying

30947
20:28:31,920 --> 20:28:34,640
to use it in the main function so if you

30948
20:28:34,640 --> 20:28:37,280
really want thanks inside the class to

30949
20:28:37,280 --> 20:28:40,320
be accessible from the outside you need

30950
20:28:40,320 --> 20:28:43,120
to make them public and change them from

30951
20:28:43,120 --> 20:28:45,920
private how do we do that it is really

30952
20:28:45,920 --> 20:28:47,920
simple you use the syntax we saw in the

30953
20:28:47,920 --> 20:28:50,000
slides we're going to say public and put

30954
20:28:50,000 --> 20:28:53,040
a column here and when you do this it is

30955
20:28:53,040 --> 20:28:55,512
advised to align your things a little

30956
20:28:55,512 --> 20:28:58,400
bit properly so when we do this

30957
20:28:58,400 --> 20:29:01,440
everything after this public keyword is

30958
20:29:01,440 --> 20:29:04,160
going to be public in this class and it

30959
20:29:04,160 --> 20:29:07,440
will be accessible from the outside

30960
20:29:07,440 --> 20:29:09,360
let's try and build now but before we

30961
20:29:09,360 --> 20:29:11,512
build let's show you that the squiggly

30962
20:29:11,512 --> 20:29:14,480
line should be gone visual studio code

30963
20:29:14,480 --> 20:29:17,280
is still confused let's try and vault

30964
20:29:17,280 --> 20:29:19,512
let's pass this through gcc now you see

30965
20:29:19,512 --> 20:29:21,832
that the world is good okay now if you

30966
20:29:21,832 --> 20:29:23,680
try and print the volume here we're

30967
20:29:23,680 --> 20:29:26,160
going to get zero because the base

30968
20:29:26,160 --> 20:29:29,192
radius is braced initialized to zero the

30969
20:29:29,192 --> 20:29:31,680
height is zero and if we multiply like

30970
20:29:31,680 --> 20:29:33,120
this we're going to get a zero and

30971
20:29:33,120 --> 20:29:35,760
return that let's try and run this

30972
20:29:35,760 --> 20:29:37,832
program because we just build it

30973
20:29:37,832 --> 20:29:40,160
successfully we can bring up a terminal

30974
20:29:40,160 --> 20:29:43,280
to do that and let's clear and run

30975
20:29:43,280 --> 20:29:45,832
rooster and we can see that the volume

30976
20:29:45,832 --> 20:29:48,640
is zero and it is what we expect okay

30977
20:29:48,640 --> 20:29:50,960
now our class is working but there is

30978
20:29:50,960 --> 20:29:54,000
really something bad about it and

30979
20:29:54,000 --> 20:29:57,120
that is because the public keyword is

30980
20:29:57,120 --> 20:29:59,360
going to make everything public in this

30981
20:29:59,360 --> 20:30:01,512
class the member variables are also

30982
20:30:01,512 --> 20:30:04,080
going to be public so we can go down

30983
20:30:04,080 --> 20:30:06,080
here and print the base radius and the

30984
20:30:06,080 --> 20:30:08,000
height for example let's do that and

30985
20:30:08,000 --> 20:30:10,240
show you that this is the case so we're

30986
20:30:10,240 --> 20:30:12,800
going to say cylinder one and say base

30987
20:30:12,800 --> 20:30:15,760
radius this is going to print and we're

30988
20:30:15,760 --> 20:30:18,400
going to say hi we're going to print

30989
20:30:18,400 --> 20:30:21,040
this out if we try and print these guys

30990
20:30:21,040 --> 20:30:23,832
let's build and pass this through gcc

30991
20:30:23,832 --> 20:30:26,400
you see the bolt is good and if we clear

30992
20:30:26,400 --> 20:30:28,480
and run rooster we're going to see that

30993
20:30:28,480 --> 20:30:31,680
this radius and height are or accessible

30994
20:30:31,680 --> 20:30:33,600
to show you that this can also be

30995
20:30:33,600 --> 20:30:36,000
different from zero let's change the

30996
20:30:36,000 --> 20:30:38,640
base radius to one and the height to one

30997
20:30:38,640 --> 20:30:42,320
to make it a unit cylinder let's try and

30998
20:30:42,320 --> 20:30:44,480
weld we're going to change these guys to

30999
20:30:44,480 --> 20:30:46,920
one and the volume is going to be

31000
20:30:46,920 --> 20:30:49,832
3.14 or something let's run rooster

31001
20:30:49,832 --> 20:30:52,160
we're going to see our volume here and

31002
20:30:52,160 --> 20:30:54,480
we have the base radius and the height

31003
20:30:54,480 --> 20:30:57,360
but this is really bad design because

31004
20:30:57,360 --> 20:30:59,120
the member variables

31005
20:30:59,120 --> 20:31:01,192
in most cases you're going to want to

31006
20:31:01,192 --> 20:31:04,160
keep them private from the outside

31007
20:31:04,160 --> 20:31:07,040
because users of your class don't really

31008
20:31:07,040 --> 20:31:09,120
care about the member variables they

31009
20:31:09,120 --> 20:31:11,040
just want to do things with your class

31010
20:31:11,040 --> 20:31:12,872
for example calling the volume function

31011
20:31:12,872 --> 20:31:15,512
here so what we usually do in

31012
20:31:15,512 --> 20:31:18,720
practice is to flag our member variables

31013
20:31:18,720 --> 20:31:21,280
as private and we can do that using the

31014
20:31:21,280 --> 20:31:24,080
private keyword as we do here and at the

31015
20:31:24,080 --> 20:31:27,192
moment we do this everything after this

31016
20:31:27,192 --> 20:31:29,512
private keyword is going to be private

31017
20:31:29,512 --> 20:31:31,920
to the class it is only going to be

31018
20:31:31,920 --> 20:31:34,400
accessible from the inside of the class

31019
20:31:34,400 --> 20:31:36,552
but if we try to access that from the

31020
20:31:36,552 --> 20:31:38,320
outside we're going to get the same

31021
20:31:38,320 --> 20:31:41,280
compiler error we saw before when we

31022
20:31:41,280 --> 20:31:44,320
tried to access private stuff from the

31023
20:31:44,320 --> 20:31:46,320
class in the main function here visual

31024
20:31:46,320 --> 20:31:48,000
studio code is going to give us a

31025
20:31:48,000 --> 20:31:49,920
problem saying that these member

31026
20:31:49,920 --> 20:31:52,640
variables are not accessible from this

31027
20:31:52,640 --> 20:31:54,960
context here and if we pass this through

31028
20:31:54,960 --> 20:31:57,512
gcc we're going to get a clear compiler

31029
20:31:57,512 --> 20:32:00,160
error saying that the height

31030
20:32:00,160 --> 20:32:01,600
and the

31031
20:32:01,600 --> 20:32:04,720
base radius are now private in the class

31032
20:32:04,720 --> 20:32:07,120
and we can't access them from the

31033
20:32:07,120 --> 20:32:09,280
outside this is really what i wanted you

31034
20:32:09,280 --> 20:32:12,080
to see and this is good design okay now

31035
20:32:12,080 --> 20:32:14,640
that we have our class declared and that

31036
20:32:14,640 --> 20:32:16,960
we can use it in the main function i

31037
20:32:16,960 --> 20:32:19,440
want you to see that it is possible to

31038
20:32:19,440 --> 20:32:22,160
change these member variables but to do

31039
20:32:22,160 --> 20:32:24,720
that we will need to turn this back to

31040
20:32:24,720 --> 20:32:26,400
public and we're going to see a better

31041
20:32:26,400 --> 20:32:29,120
way to do this later but for now let's

31042
20:32:29,120 --> 20:32:30,872
make them public and show you that we

31043
20:32:30,872 --> 20:32:33,512
can change things around and make our

31044
20:32:33,512 --> 20:32:35,760
cylinders a little more interesting so

31045
20:32:35,760 --> 20:32:37,760
now that they are public we can go in

31046
20:32:37,760 --> 20:32:40,160
the main function and do crazy things

31047
20:32:40,160 --> 20:32:42,240
change the data for example we can

31048
20:32:42,240 --> 20:32:44,240
change our member variables to be

31049
20:32:44,240 --> 20:32:46,400
something else let's go down and say

31050
20:32:46,400 --> 20:32:49,832
cylinder one and say base radius we can

31051
20:32:49,832 --> 20:32:53,040
use the dot notation and put an ecosign

31052
20:32:53,040 --> 20:32:55,280
and give another value to our base

31053
20:32:55,280 --> 20:32:58,800
radius let's make it 10 for example and

31054
20:32:58,800 --> 20:33:01,120
change the height to be something else

31055
20:33:01,120 --> 20:33:03,192
we can change that and we're going to

31056
20:33:03,192 --> 20:33:06,480
put in a 3 for example why not now if we

31057
20:33:06,480 --> 20:33:08,480
print the volume again we're going to

31058
20:33:08,480 --> 20:33:10,640
get another value let's copy this and

31059
20:33:10,640 --> 20:33:12,400
put that down below

31060
20:33:12,400 --> 20:33:15,832
our changes here and if we build the

31061
20:33:15,832 --> 20:33:18,400
program it should well define the world

31062
20:33:18,400 --> 20:33:19,440
is good

31063
20:33:19,440 --> 20:33:22,400
so we can hit enter and clear and if we

31064
20:33:22,400 --> 20:33:24,240
run rooster we're going to get

31065
20:33:24,240 --> 20:33:25,872
the volume to be

31066
20:33:25,872 --> 20:33:29,600
3.14 first here the first line here and

31067
20:33:29,600 --> 20:33:31,280
the second line is going to give us

31068
20:33:31,280 --> 20:33:33,680
another volume and if we multiply these

31069
20:33:33,680 --> 20:33:35,920
guys with pi

31070
20:33:35,920 --> 20:33:38,320
and if we use our formula to compute the

31071
20:33:38,320 --> 20:33:39,920
volume we're going to basically get the

31072
20:33:39,920 --> 20:33:42,480
same thing let's try and prove this with

31073
20:33:42,480 --> 20:33:45,120
our calculator we have it around so we

31074
20:33:45,120 --> 20:33:48,240
have pi in here we're going to multiply

31075
20:33:48,240 --> 20:33:49,440
this with

31076
20:33:49,440 --> 20:33:51,440
100 which is

31077
20:33:51,440 --> 20:33:54,240
the radius squared we're going to put

31078
20:33:54,240 --> 20:33:56,640
100 here and we're going to multiply

31079
20:33:56,640 --> 20:33:58,960
this with 3 which is our height let's

31080
20:33:58,960 --> 20:34:01,720
put this in and we have

31081
20:34:01,720 --> 20:34:04,320
942.47 which is what we have here

31082
20:34:04,320 --> 20:34:06,400
roughly the same thing so you see that

31083
20:34:06,400 --> 20:34:08,320
our function is really computing our

31084
20:34:08,320 --> 20:34:10,800
volume we can even go down and change

31085
20:34:10,800 --> 20:34:12,800
the height to something else for example

31086
20:34:12,800 --> 20:34:15,760
we're going to change the height to

31087
20:34:15,760 --> 20:34:17,680
let's make an eight and i printed the

31088
20:34:17,680 --> 20:34:19,760
volume again you can keep playing with

31089
20:34:19,760 --> 20:34:22,400
us and really make it clear

31090
20:34:22,400 --> 20:34:24,720
that our volume function is computing

31091
20:34:24,720 --> 20:34:27,512
our volume using the data that we have

31092
20:34:27,512 --> 20:34:29,280
in the member variables this is the

31093
20:34:29,280 --> 20:34:32,080
message here let's build again the world

31094
20:34:32,080 --> 20:34:34,240
should be good we're going to clear and

31095
20:34:34,240 --> 20:34:36,872
run rooster now we see another

31096
20:34:36,872 --> 20:34:39,760
number for our volume and this is really

31097
20:34:39,760 --> 20:34:42,000
how you can declare a class again you

31098
20:34:42,000 --> 20:34:43,920
use the syntax you see here class you

31099
20:34:43,920 --> 20:34:46,720
say the class name you put a pair of

31100
20:34:46,720 --> 20:34:49,120
curly braces and you put your semicolon

31101
20:34:49,120 --> 20:34:50,640
don't forget this

31102
20:34:50,640 --> 20:34:53,192
members of your class are private by

31103
20:34:53,192 --> 20:34:55,760
default but you can make them public if

31104
20:34:55,760 --> 20:34:58,320
you want using the public keyword as we

31105
20:34:58,320 --> 20:35:00,240
did here inside your class you're going

31106
20:35:00,240 --> 20:35:02,080
to have two parts you're going to have

31107
20:35:02,080 --> 20:35:03,920
the member variables which are going to

31108
20:35:03,920 --> 20:35:06,800
be properties that define what your

31109
20:35:06,800 --> 20:35:09,360
class is and we're going to have

31110
20:35:09,360 --> 20:35:12,240
functions or methods let's say that and

31111
20:35:12,240 --> 20:35:14,800
these are going to be behaviors

31112
20:35:14,800 --> 20:35:17,280
of your class you're going to go through

31113
20:35:17,280 --> 20:35:19,832
these functions to make your classes do

31114
20:35:19,832 --> 20:35:21,920
things and once you have the class

31115
20:35:21,920 --> 20:35:24,160
definition in place you can use it to

31116
20:35:24,160 --> 20:35:25,120
create

31117
20:35:25,120 --> 20:35:27,600
variables as we do in the main function

31118
20:35:27,600 --> 20:35:30,320
here and the variables we create from

31119
20:35:30,320 --> 20:35:33,040
our class are usually called objects in

31120
20:35:33,040 --> 20:35:35,760
c plus plus terminology okay the class

31121
20:35:35,760 --> 20:35:39,040
is really a blueprint and we create

31122
20:35:39,040 --> 20:35:42,480
objects using that blueprint and objects

31123
20:35:42,480 --> 20:35:45,360
are going to have runtime data that we

31124
20:35:45,360 --> 20:35:47,440
store in our class okay so for example

31125
20:35:47,440 --> 20:35:49,920
if we hit this point here the base

31126
20:35:49,920 --> 20:35:52,000
radius is going to be 10 and the height

31127
20:35:52,000 --> 20:35:54,000
is going to be eight and that's going to

31128
20:35:54,000 --> 20:35:57,512
be runtime information for our class

31129
20:35:57,512 --> 20:36:00,160
object stored in this variable that we

31130
20:36:00,160 --> 20:36:03,280
call cylinder one here this is really

31131
20:36:03,280 --> 20:36:05,680
what i wanted you to see okay let's try

31132
20:36:05,680 --> 20:36:08,080
and recap what we know about classes so

31133
20:36:08,080 --> 20:36:10,872
far a class can have member variables

31134
20:36:10,872 --> 20:36:13,600
but so far we have used member variables

31135
20:36:13,600 --> 20:36:16,080
as stack variables if we go back for

31136
20:36:16,080 --> 20:36:18,720
example you see that we say base radius

31137
20:36:18,720 --> 20:36:21,040
here you notice it is not a pointer or a

31138
20:36:21,040 --> 20:36:23,192
reference or anything it is a stack

31139
20:36:23,192 --> 20:36:26,000
variable inside our class so member

31140
20:36:26,000 --> 20:36:29,440
variables can only be stack variables

31141
20:36:29,440 --> 20:36:32,320
like we have here but they can also be

31142
20:36:32,320 --> 20:36:34,640
pointers but they can never be

31143
20:36:34,640 --> 20:36:37,832
references and the reason is a reference

31144
20:36:37,832 --> 20:36:41,040
can never be left uninitialized and in

31145
20:36:41,040 --> 20:36:42,960
the classes when we declare member

31146
20:36:42,960 --> 20:36:45,600
variables the ability to leave them

31147
20:36:45,600 --> 20:36:48,480
uninitialized is really important and we

31148
20:36:48,480 --> 20:36:50,872
can't really do that with references i

31149
20:36:50,872 --> 20:36:53,512
can't really go into the details of that

31150
20:36:53,512 --> 20:36:56,240
as we will see that as we progress in

31151
20:36:56,240 --> 20:36:58,480
the chapter but know that member

31152
20:36:58,480 --> 20:37:00,320
variables can either be stacked

31153
20:37:00,320 --> 20:37:03,040
variables or pointers but they can never

31154
20:37:03,040 --> 20:37:05,760
be references in z plus okay that's what

31155
20:37:05,760 --> 20:37:08,000
we just said here members can't be

31156
20:37:08,000 --> 20:37:11,280
references classes can have functions or

31157
20:37:11,280 --> 20:37:13,832
methods that let them do things we saw

31158
20:37:13,832 --> 20:37:16,400
an example of this with our volume

31159
20:37:16,400 --> 20:37:19,192
function class methods have access to

31160
20:37:19,192 --> 20:37:21,760
the member variables regardless of

31161
20:37:21,760 --> 20:37:24,000
whether they are public or private we

31162
20:37:24,000 --> 20:37:26,720
have seen that the volume function will

31163
20:37:26,720 --> 20:37:30,000
have access to our member variables

31164
20:37:30,000 --> 20:37:32,400
regardless of whether it is public or

31165
20:37:32,400 --> 20:37:35,360
private and last but not least private

31166
20:37:35,360 --> 20:37:38,552
members of classes aren't accessible

31167
20:37:38,552 --> 20:37:40,872
from the outside as we saw in the main

31168
20:37:40,872 --> 20:37:43,120
function you can't access them from the

31169
20:37:43,120 --> 20:37:45,760
main function you can only do that from

31170
20:37:45,760 --> 20:37:47,760
the class definition itself this is

31171
20:37:47,760 --> 20:37:49,600
really all i had to share in this

31172
20:37:49,600 --> 20:37:52,000
lecture i hope you found it interesting

31173
20:37:52,000 --> 20:37:54,320
we are going to stop here in this one in

31174
20:37:54,320 --> 20:37:56,080
the next one we're going to see how

31175
20:37:56,080 --> 20:37:58,960
class objects are built

31176
20:37:58,960 --> 20:38:01,440
from constructors go ahead and finish up

31177
20:38:01,440 --> 20:38:04,160
here and meet me there in this lecture

31178
20:38:04,160 --> 20:38:06,800
we're going to learn about constructors

31179
20:38:06,800 --> 20:38:10,080
and constructors are special class

31180
20:38:10,080 --> 20:38:12,240
methods or functions

31181
20:38:12,240 --> 20:38:15,120
that are called by the compiler to

31182
20:38:15,120 --> 20:38:18,080
construct your class objects and they

31183
20:38:18,080 --> 20:38:20,720
are special because they have no return

31184
20:38:20,720 --> 20:38:23,120
type a constructor can never have a

31185
20:38:23,120 --> 20:38:26,080
return type as you see here they have

31186
20:38:26,080 --> 20:38:28,400
the same name as the class so for

31187
20:38:28,400 --> 20:38:31,040
example for our class in the last

31188
20:38:31,040 --> 20:38:33,600
lecture that was called silenter the

31189
20:38:33,600 --> 20:38:35,440
constructors are also going to have the

31190
20:38:35,440 --> 20:38:37,360
same name as the class they are going to

31191
20:38:37,360 --> 20:38:41,040
be called also slander constructors can

31192
20:38:41,040 --> 20:38:43,600
have parameters but if it makes sense

31193
20:38:43,600 --> 20:38:46,080
for whatever it is you are trying to do

31194
20:38:46,080 --> 20:38:48,480
you can also leave the parameters out

31195
20:38:48,480 --> 20:38:51,512
and constructors are usually used to

31196
20:38:51,512 --> 20:38:54,552
initialize the member variables and put

31197
20:38:54,552 --> 20:38:57,120
them in a state where you want them in

31198
20:38:57,120 --> 20:38:59,280
your c plus plus application

31199
20:38:59,280 --> 20:39:01,440
let's look at how you can declare

31200
20:39:01,440 --> 20:39:03,680
constructors for your classes

31201
20:39:03,680 --> 20:39:06,720
here is our cylinder class you see we

31202
20:39:06,720 --> 20:39:08,552
have our member variables we had they

31203
20:39:08,552 --> 20:39:11,360
are private now and we have

31204
20:39:11,360 --> 20:39:13,512
a public section which is going to have

31205
20:39:13,512 --> 20:39:15,760
our functions or behaviors as you see

31206
20:39:15,760 --> 20:39:17,832
here the member variables are what we

31207
20:39:17,832 --> 20:39:20,720
have seen from the last lecture but if

31208
20:39:20,720 --> 20:39:24,080
you look here we have a few new things

31209
20:39:24,080 --> 20:39:24,872
here

31210
20:39:24,872 --> 20:39:27,280
we have two things that look like

31211
20:39:27,280 --> 20:39:29,440
functions but they don't have return

31212
20:39:29,440 --> 20:39:30,960
values that's something you should

31213
20:39:30,960 --> 20:39:32,000
notice

31214
20:39:32,000 --> 20:39:34,480
they have a parameter list as you see

31215
20:39:34,480 --> 20:39:37,512
here and we have a pair of curly braces

31216
20:39:37,512 --> 20:39:39,680
because these are really functions and

31217
20:39:39,680 --> 20:39:41,920
these are special functions that are

31218
20:39:41,920 --> 20:39:44,640
going to be called by the compiler to

31219
20:39:44,640 --> 20:39:47,760
initialize your class objects if you

31220
20:39:47,760 --> 20:39:50,552
look here in this example we are

31221
20:39:50,552 --> 20:39:52,080
using the

31222
20:39:52,080 --> 20:39:54,320
constructor with no parameters to

31223
20:39:54,320 --> 20:39:57,120
initialize our member variables to 2 and

31224
20:39:57,120 --> 20:39:59,680
we have another constructor as you see

31225
20:39:59,680 --> 20:40:01,192
down here which is going to take

31226
20:40:01,192 --> 20:40:03,920
parameters directly and it's going to

31227
20:40:03,920 --> 20:40:06,320
take the radius parameter and the height

31228
20:40:06,320 --> 20:40:09,360
parameter the parameters are of double

31229
20:40:09,360 --> 20:40:11,512
type because that's what we expect in

31230
20:40:11,512 --> 20:40:14,000
our class and we are passing them by

31231
20:40:14,000 --> 20:40:16,480
value here because they are fundamental

31232
20:40:16,480 --> 20:40:18,872
types and we don't really mind copying

31233
20:40:18,872 --> 20:40:20,960
them but please keep in mind that they

31234
20:40:20,960 --> 20:40:23,832
are going to be passed by value and what

31235
20:40:23,832 --> 20:40:26,800
you have inside your constructor body

31236
20:40:26,800 --> 20:40:30,160
are going to be copies of the original

31237
20:40:30,160 --> 20:40:32,240
arguments that were passed to your

31238
20:40:32,240 --> 20:40:34,320
constructor and this is really how you

31239
20:40:34,320 --> 20:40:37,120
declare constructors for your c plus

31240
20:40:37,120 --> 20:40:39,120
plus classes constructors can either

31241
20:40:39,120 --> 20:40:41,440
have parameters like we have again on

31242
20:40:41,440 --> 20:40:44,320
this example here or they can have no

31243
20:40:44,320 --> 20:40:46,640
parameters and this is going to be a

31244
20:40:46,640 --> 20:40:48,480
default constructor we're going to see

31245
20:40:48,480 --> 20:40:50,872
that this is going to be called when you

31246
20:40:50,872 --> 20:40:52,320
try to create

31247
20:40:52,320 --> 20:40:55,680
variables of this cylinder type without

31248
20:40:55,680 --> 20:40:58,240
passing the parenthesis like we do when

31249
20:40:58,240 --> 20:40:59,920
we call this second constructor here

31250
20:40:59,920 --> 20:41:01,512
we're going to see this in a minute okay

31251
20:41:01,512 --> 20:41:03,600
this is all i think i have to share in

31252
20:41:03,600 --> 20:41:05,440
the slides about how you declare

31253
20:41:05,440 --> 20:41:08,000
constructors let's head over to visual

31254
20:41:08,000 --> 20:41:09,680
studio code and play with this a little

31255
20:41:09,680 --> 20:41:12,320
more okay here we are in our working

31256
20:41:12,320 --> 20:41:14,320
folder the current project is

31257
20:41:14,320 --> 20:41:17,680
constructors we're going to put in our

31258
20:41:17,680 --> 20:41:20,000
template files pretty quick let's do

31259
20:41:20,000 --> 20:41:22,000
that and we are going to open this in

31260
20:41:22,000 --> 20:41:24,320
visual studio code by dragging and

31261
20:41:24,320 --> 20:41:26,240
dropping on top here

31262
20:41:26,240 --> 20:41:28,552
this is going to open our folder let's

31263
20:41:28,552 --> 20:41:31,760
open our main cpp file

31264
20:41:31,760 --> 20:41:33,280
and we're going to take out what we

31265
20:41:33,280 --> 20:41:35,832
don't need in the main function and on

31266
20:41:35,832 --> 20:41:39,040
top here and i am going to reuse code

31267
20:41:39,040 --> 20:41:40,960
from the last lecture because we don't

31268
20:41:40,960 --> 20:41:43,600
want to type that again so let's put in

31269
20:41:43,600 --> 20:41:45,512
our class definition we have our

31270
20:41:45,512 --> 20:41:48,320
variable pi which is going to be used to

31271
20:41:48,320 --> 20:41:51,360
compute the volume in the class here and

31272
20:41:51,360 --> 20:41:53,680
we have member variables okay now that

31273
20:41:53,680 --> 20:41:56,080
we are here let's change the member

31274
20:41:56,080 --> 20:41:58,720
variables to be private because making

31275
20:41:58,720 --> 20:42:01,280
them public is really going to be bad

31276
20:42:01,280 --> 20:42:03,680
design it's going to expose them in the

31277
20:42:03,680 --> 20:42:05,760
main function and people can mess with

31278
20:42:05,760 --> 20:42:08,800
them and really change the logic of how

31279
20:42:08,800 --> 20:42:12,480
our class works without our concept it

31280
20:42:12,480 --> 20:42:14,872
is advised to make your member variables

31281
20:42:14,872 --> 20:42:17,120
private unless you really have a

31282
20:42:17,120 --> 20:42:20,080
compelling reasons to make them public

31283
20:42:20,080 --> 20:42:22,872
okay now that we have our class here

31284
20:42:22,872 --> 20:42:24,960
let's set up constructors for it so

31285
20:42:24,960 --> 20:42:26,552
we're going to go down here in the

31286
20:42:26,552 --> 20:42:29,040
public scope and say constructors and

31287
20:42:29,040 --> 20:42:30,872
we're going to set up the first

31288
20:42:30,872 --> 20:42:33,040
constructor which is not going to take

31289
20:42:33,040 --> 20:42:35,360
any parameter so we're going to say the

31290
20:42:35,360 --> 20:42:37,512
name of the class remember a constructor

31291
20:42:37,512 --> 20:42:40,320
doesn't have a return type and it has to

31292
20:42:40,320 --> 20:42:43,360
have the same name as the class so we

31293
20:42:43,360 --> 20:42:45,192
need to comply with that and we're going

31294
20:42:45,192 --> 20:42:48,720
to put our pair of curly braces and

31295
20:42:48,720 --> 20:42:50,240
inside we're going to initialize our

31296
20:42:50,240 --> 20:42:53,192
member variables however we want so what

31297
20:42:53,192 --> 20:42:54,480
we're going to do here we're going to

31298
20:42:54,480 --> 20:42:57,440
set the base radius to something let's

31299
20:42:57,440 --> 20:43:00,480
make it a 2 like we saw in the slides no

31300
20:43:00,480 --> 20:43:02,400
problem with that and we're going to set

31301
20:43:02,400 --> 20:43:04,640
the height to something else and we are

31302
20:43:04,640 --> 20:43:07,192
going to set the height to 2 as well we

31303
20:43:07,192 --> 20:43:10,160
can do that you can use what you want

31304
20:43:10,160 --> 20:43:13,192
and now we have our constructor and it

31305
20:43:13,192 --> 20:43:16,000
is initializing our thanks okay now that

31306
20:43:16,000 --> 20:43:18,400
we have the constructor in place

31307
20:43:18,400 --> 20:43:20,800
how is it really called by the compiler

31308
20:43:20,800 --> 20:43:23,832
and notice that our constructor is in

31309
20:43:23,832 --> 20:43:26,480
the public scope of the class

31310
20:43:26,480 --> 20:43:28,960
if it isn't public you want to be able

31311
20:43:28,960 --> 20:43:31,600
to access it from the outside and the

31312
20:43:31,600 --> 20:43:34,320
compiler will fail to build your objects

31313
20:43:34,320 --> 20:43:36,080
and we're going to see this in a minute

31314
20:43:36,080 --> 20:43:38,000
but before we do that let's try and

31315
20:43:38,000 --> 20:43:40,400
create a cylinder object now so we're

31316
20:43:40,400 --> 20:43:42,800
going to say cylinder and say cylinder

31317
20:43:42,800 --> 20:43:45,360
one like we did in the last lecture

31318
20:43:45,360 --> 20:43:48,720
and when we do this notice what we see

31319
20:43:48,720 --> 20:43:52,640
if we print the volume of our cylinder

31320
20:43:52,640 --> 20:43:55,280
object here this is an object because

31321
20:43:55,280 --> 20:43:58,240
we're creating this from our blueprint

31322
20:43:58,240 --> 20:44:00,240
which is the class definition here you

31323
20:44:00,240 --> 20:44:02,160
really need to know this this is a class

31324
20:44:02,160 --> 20:44:04,720
object let's say that and we're going to

31325
20:44:04,720 --> 20:44:06,720
print its volume we're going to say

31326
20:44:06,720 --> 20:44:08,800
cylinder one and we're going to call our

31327
20:44:08,800 --> 20:44:11,192
volume method we should say and if we

31328
20:44:11,192 --> 20:44:12,640
build you're going to see that this is

31329
20:44:12,640 --> 20:44:14,160
going to work but

31330
20:44:14,160 --> 20:44:16,160
the volume is not going to be coming

31331
20:44:16,160 --> 20:44:19,440
from the initial values we have here we

31332
20:44:19,440 --> 20:44:22,640
will have changed these guys to 2

31333
20:44:22,640 --> 20:44:25,120
from our constructor here because the

31334
20:44:25,120 --> 20:44:26,960
compiler is going to look at this line

31335
20:44:26,960 --> 20:44:29,832
here and see that we are trying to build

31336
20:44:29,832 --> 20:44:32,320
a silent object it's going to look at

31337
20:44:32,320 --> 20:44:34,240
the class definition and it is going to

31338
20:44:34,240 --> 20:44:36,960
say do i have any constructor

31339
20:44:36,960 --> 20:44:39,192
that i can use to build an object from

31340
20:44:39,192 --> 20:44:41,360
the syntax i see here and it's going to

31341
20:44:41,360 --> 20:44:43,832
see that it has a constructor that

31342
20:44:43,832 --> 20:44:45,680
doesn't take any parameter and it's

31343
20:44:45,680 --> 20:44:48,872
going to use it to build our object and

31344
20:44:48,872 --> 20:44:50,960
it's going to be using this information

31345
20:44:50,960 --> 20:44:53,680
to build our cylinder object so the base

31346
20:44:53,680 --> 20:44:55,512
radius is going to be two the height is

31347
20:44:55,512 --> 20:44:57,360
going to be two and it's going to use

31348
20:44:57,360 --> 20:44:59,832
that to compute the volume

31349
20:44:59,832 --> 20:45:01,680
that we print here you really need to

31350
20:45:01,680 --> 20:45:04,160
understand this let's vote

31351
20:45:04,160 --> 20:45:05,440
and see

31352
20:45:05,440 --> 20:45:08,872
if gcc accepts this you see the both is

31353
20:45:08,872 --> 20:45:11,680
good now we can bring up a terminal and

31354
20:45:11,680 --> 20:45:13,760
clear and run rooster you're going to

31355
20:45:13,760 --> 20:45:16,400
see that we have 25 something which is a

31356
20:45:16,400 --> 20:45:19,680
result of using this information we have

31357
20:45:19,680 --> 20:45:22,480
here if we take pi multiplied by this

31358
20:45:22,480 --> 20:45:24,960
base radius multiply by this base radius

31359
20:45:24,960 --> 20:45:27,280
again and multiply by height we're going

31360
20:45:27,280 --> 20:45:29,280
to get this here you can try this out it

31361
20:45:29,280 --> 20:45:31,680
is going to be what you see here and

31362
20:45:31,680 --> 20:45:34,720
this hopefully proves that the compiler

31363
20:45:34,720 --> 20:45:37,600
is using our constructor here but we can

31364
20:45:37,600 --> 20:45:39,512
also use a debugger

31365
20:45:39,512 --> 20:45:42,800
let's set up a breakpoint here

31366
20:45:42,800 --> 20:45:44,800
and we're going to run this through our

31367
20:45:44,800 --> 20:45:47,760
debugger we can come back to the run tab

31368
20:45:47,760 --> 20:45:48,480
here

31369
20:45:48,480 --> 20:45:50,400
as we have done before

31370
20:45:50,400 --> 20:45:52,800
and we're going to try and use the

31371
20:45:52,800 --> 20:45:55,192
debugging tools that come

31372
20:45:55,192 --> 20:45:57,680
with the gcc compiler that's what we can

31373
20:45:57,680 --> 20:46:00,080
use if you are on windows you can also

31374
20:46:00,080 --> 20:46:01,120
use the

31375
20:46:01,120 --> 20:46:03,440
tools that come with the compiler from

31376
20:46:03,440 --> 20:46:05,600
microsoft but we're not going to use

31377
20:46:05,600 --> 20:46:08,240
that now gcc is going to be fine we're

31378
20:46:08,240 --> 20:46:10,080
going to start the debugging and we

31379
20:46:10,080 --> 20:46:12,872
should hit our breakpoint when the build

31380
20:46:12,872 --> 20:46:15,440
is done let's wait a minute okay we have

31381
20:46:15,440 --> 20:46:17,192
hit our breakpoint

31382
20:46:17,192 --> 20:46:20,160
we can minimize this a little bit and i

31383
20:46:20,160 --> 20:46:22,480
show the terminal to the right here i

31384
20:46:22,480 --> 20:46:24,720
think we can do that let's do that let's

31385
20:46:24,720 --> 20:46:27,192
put that a little bit to the right here

31386
20:46:27,192 --> 20:46:29,280
and minimize a little bit okay we have

31387
20:46:29,280 --> 20:46:32,640
our thunk in place we have hit our break

31388
20:46:32,640 --> 20:46:34,480
point you see these are the local

31389
20:46:34,480 --> 20:46:36,800
variables we have here we have a

31390
20:46:36,800 --> 20:46:40,080
cylinder object which is not initialized

31391
20:46:40,080 --> 20:46:42,240
yet because you see what we have inside

31392
20:46:42,240 --> 20:46:45,440
is really junk data we haven't put in

31393
20:46:45,440 --> 20:46:48,480
anything yet but now that we are at this

31394
20:46:48,480 --> 20:46:51,120
break point here we can hit step into

31395
20:46:51,120 --> 20:46:54,640
and step into the code that constructs

31396
20:46:54,640 --> 20:46:57,360
our cylinder object because at this

31397
20:46:57,360 --> 20:47:01,120
point liner 25 here hasn't run yet so

31398
20:47:01,120 --> 20:47:02,872
we're going to step into and you're

31399
20:47:02,872 --> 20:47:05,360
going to see that we hit the constructor

31400
20:47:05,360 --> 20:47:08,552
for our cylinder object

31401
20:47:08,552 --> 20:47:09,360
and

31402
20:47:09,360 --> 20:47:11,760
this again proves that our constructor

31403
20:47:11,760 --> 20:47:14,240
is being used to build our cylinder

31404
20:47:14,240 --> 20:47:15,360
objects

31405
20:47:15,360 --> 20:47:17,120
now we can move to the next line we're

31406
20:47:17,120 --> 20:47:19,440
going to set up the base radius and if

31407
20:47:19,440 --> 20:47:22,240
we hit next here this is going to set

31408
20:47:22,240 --> 20:47:24,480
our base radius to 2

31409
20:47:24,480 --> 20:47:26,640
and you see that height is in one

31410
20:47:26,640 --> 20:47:29,280
because we haven't set it up yet but if

31411
20:47:29,280 --> 20:47:31,280
we execute this line you're going to see

31412
20:47:31,280 --> 20:47:33,040
that height is also going to change to

31413
20:47:33,040 --> 20:47:33,920
two

31414
20:47:33,920 --> 20:47:36,080
and now if we hit next we're going to

31415
20:47:36,080 --> 20:47:38,872
get out of our constructor and our

31416
20:47:38,872 --> 20:47:40,872
cylinder object will be already

31417
20:47:40,872 --> 20:47:43,512
constructed if we look again here we're

31418
20:47:43,512 --> 20:47:46,160
going to see that radius is 2 height is

31419
20:47:46,160 --> 20:47:49,040
2 and we can print the volume and if we

31420
20:47:49,040 --> 20:47:50,720
hit step over we're going to see our

31421
20:47:50,720 --> 20:47:53,280
volume printed out here hopefully again

31422
20:47:53,280 --> 20:47:56,400
this proves that our constructor here is

31423
20:47:56,400 --> 20:47:58,320
being used to build

31424
20:47:58,320 --> 20:48:01,440
objects and it is doing that because it

31425
20:48:01,440 --> 20:48:04,400
is the syntax here we don't pass any

31426
20:48:04,400 --> 20:48:07,440
parameter to our cylinder object as we

31427
20:48:07,440 --> 20:48:10,160
created so this must be calling the

31428
20:48:10,160 --> 20:48:12,800
default constructor which doesn't take

31429
20:48:12,800 --> 20:48:15,192
any parameter this is the message here

31430
20:48:15,192 --> 20:48:17,760
let's close our debugging session and

31431
20:48:17,760 --> 20:48:20,800
maximize our visual studio code instance

31432
20:48:20,800 --> 20:48:22,160
because we're going to set up another

31433
20:48:22,160 --> 20:48:23,832
constructor which is going to take

31434
20:48:23,832 --> 20:48:26,240
parameters now and you have seen the

31435
20:48:26,240 --> 20:48:28,552
syntax to do that in the slides it is

31436
20:48:28,552 --> 20:48:30,640
nothing complicated we're going to say

31437
20:48:30,640 --> 20:48:32,240
the name of the constructor which is

31438
20:48:32,240 --> 20:48:33,920
going to be the name of the class and

31439
20:48:33,920 --> 20:48:35,600
we're going to say double

31440
20:48:35,600 --> 20:48:38,872
and say rad param for radius and we're

31441
20:48:38,872 --> 20:48:40,160
going to say

31442
20:48:40,160 --> 20:48:42,640
height param for our

31443
20:48:42,640 --> 20:48:44,552
height and we're going to make this

31444
20:48:44,552 --> 20:48:46,080
double and after that we're going to

31445
20:48:46,080 --> 20:48:49,192
head in the body of our constructor and

31446
20:48:49,192 --> 20:48:51,832
we're going to initialize our guides to

31447
20:48:51,832 --> 20:48:54,240
the parameters that will pass to the

31448
20:48:54,240 --> 20:48:55,920
function here and this is really

31449
20:48:55,920 --> 20:48:58,080
powerful after we have this constructor

31450
20:48:58,080 --> 20:49:00,552
end we will be able to pass

31451
20:49:00,552 --> 20:49:02,800
parameters that will be used to

31452
20:49:02,800 --> 20:49:05,512
construct our cylinder object so we can

31453
20:49:05,512 --> 20:49:08,080
say base radius and pass in

31454
20:49:08,080 --> 20:49:11,192
red param and we can say height and say

31455
20:49:11,192 --> 20:49:13,512
height param here and these are going to

31456
20:49:13,512 --> 20:49:16,160
be used to construct our object now we

31457
20:49:16,160 --> 20:49:18,720
can head over in the main function and

31458
20:49:18,720 --> 20:49:20,872
change how we construct our cylinder

31459
20:49:20,872 --> 20:49:23,832
object if we want to use tan as the

31460
20:49:23,832 --> 20:49:25,440
radius and

31461
20:49:25,440 --> 20:49:27,680
five or four as the

31462
20:49:27,680 --> 20:49:29,832
height we can do that by passing

31463
20:49:29,832 --> 20:49:33,512
arguments to our constructor here

31464
20:49:33,512 --> 20:49:35,440
let's run this through the debugger

31465
20:49:35,440 --> 20:49:37,920
again and see that our information here

31466
20:49:37,920 --> 20:49:39,512
is being used

31467
20:49:39,512 --> 20:49:42,080
now this constructor here is going to be

31468
20:49:42,080 --> 20:49:44,552
chosen by the compiler because it is

31469
20:49:44,552 --> 20:49:47,040
more fitting for the call that we are

31470
20:49:47,040 --> 20:49:50,000
doing here let's run our debugging

31471
20:49:50,000 --> 20:49:53,120
session the program is going to be bolt

31472
20:49:53,120 --> 20:49:55,600
and we are going to try and maximize

31473
20:49:55,600 --> 20:49:58,480
this a little bit and bring up our

31474
20:49:58,480 --> 20:50:00,800
terminal output okay we have hit the

31475
20:50:00,800 --> 20:50:03,360
breakpoint here we can step into our

31476
20:50:03,360 --> 20:50:05,760
constructor and notice the constructor

31477
20:50:05,760 --> 20:50:08,000
that the compiler chooses our

31478
20:50:08,000 --> 20:50:10,400
constructor that takes parameters is

31479
20:50:10,400 --> 20:50:13,440
chosen here and we can do things inside

31480
20:50:13,440 --> 20:50:16,160
let's hit next we're going to initialize

31481
20:50:16,160 --> 20:50:18,960
the base radius to 10 and we're going to

31482
20:50:18,960 --> 20:50:21,360
initialize the height to

31483
20:50:21,360 --> 20:50:23,760
four okay we can see that to the left

31484
20:50:23,760 --> 20:50:26,320
here if we hit next the height is going

31485
20:50:26,320 --> 20:50:28,000
to be changed to four and our

31486
20:50:28,000 --> 20:50:29,680
constructor is going to be done we're

31487
20:50:29,680 --> 20:50:31,192
going to head over

31488
20:50:31,192 --> 20:50:33,440
in the main function again and if we

31489
20:50:33,440 --> 20:50:35,512
step over now we're going to print a new

31490
20:50:35,512 --> 20:50:38,160
volume which is based on the information

31491
20:50:38,160 --> 20:50:41,040
we used to construct our object here

31492
20:50:41,040 --> 20:50:43,760
this is really what constructors do they

31493
20:50:43,760 --> 20:50:46,640
are used by the compiler to build your

31494
20:50:46,640 --> 20:50:49,192
objects and we saw the syntax we can use

31495
20:50:49,192 --> 20:50:52,000
to set up constructors for our own

31496
20:50:52,000 --> 20:50:54,640
classes okay now you must be saying if

31497
20:50:54,640 --> 20:50:57,680
we need constructors to build our

31498
20:50:57,680 --> 20:50:58,960
objects

31499
20:50:58,960 --> 20:51:01,192
why was the code in the last lecture

31500
20:51:01,192 --> 20:51:02,400
working

31501
20:51:02,400 --> 20:51:04,320
in the last lecture we did something

31502
20:51:04,320 --> 20:51:06,960
like this we said cylinder cylinder one

31503
20:51:06,960 --> 20:51:10,080
cylinder one and this was welding and

31504
20:51:10,080 --> 20:51:12,800
compiling fine and let's try and take

31505
20:51:12,800 --> 20:51:15,040
out our constructors we can do that

31506
20:51:15,040 --> 20:51:17,760
let's comment them out and if you look

31507
20:51:17,760 --> 20:51:19,120
you're going to see that the code is

31508
20:51:19,120 --> 20:51:21,440
going to compile fine even if we don't

31509
20:51:21,440 --> 20:51:24,320
have any constructors in here let's

31510
20:51:24,320 --> 20:51:27,040
build with gcc to show you that the code

31511
20:51:27,040 --> 20:51:30,080
is going to compile both is good so how

31512
20:51:30,080 --> 20:51:32,240
is this working how is this

31513
20:51:32,240 --> 20:51:35,120
constructing our objects even if we

31514
20:51:35,120 --> 20:51:37,600
don't have any constructors in here well

31515
20:51:37,600 --> 20:51:40,160
the reason is the compiler is going to

31516
20:51:40,160 --> 20:51:42,872
set up its own constructor and what it

31517
20:51:42,872 --> 20:51:44,800
is going to set up is a constructor

31518
20:51:44,800 --> 20:51:47,360
which is really empty and doesn't have

31519
20:51:47,360 --> 20:51:49,680
anything inside it's basically going to

31520
20:51:49,680 --> 20:51:52,480
be as if we put in an empty constructor

31521
20:51:52,480 --> 20:51:54,800
let's copy this and actually show you

31522
20:51:54,800 --> 20:51:57,760
this we can do that and we're going to

31523
20:51:57,760 --> 20:52:00,400
make this constructor empty and not do

31524
20:52:00,400 --> 20:52:02,552
anything in the body this is the

31525
20:52:02,552 --> 20:52:04,720
constructor that your compiler is going

31526
20:52:04,720 --> 20:52:07,920
to generate and if we're both now and i

31527
20:52:07,920 --> 20:52:09,440
try to

31528
20:52:09,440 --> 20:52:11,512
set up a break point here you're going

31529
20:52:11,512 --> 20:52:13,920
to see that our empty constructor is

31530
20:52:13,920 --> 20:52:16,480
going to be chosen let's debug and show

31531
20:52:16,480 --> 20:52:18,160
you that okay you see that we're going

31532
20:52:18,160 --> 20:52:20,400
to hit the breakpoint here and if we

31533
20:52:20,400 --> 20:52:22,400
step into the compiler is going to

31534
20:52:22,400 --> 20:52:24,400
choose this guy and it's not going to do

31535
20:52:24,400 --> 20:52:27,192
anything so it's basically going to take

31536
20:52:27,192 --> 20:52:29,280
our member variables as

31537
20:52:29,280 --> 20:52:31,280
they are and it's going to use the

31538
20:52:31,280 --> 20:52:33,680
information to print the volume here we

31539
20:52:33,680 --> 20:52:34,400
can

31540
20:52:34,400 --> 20:52:35,920
hit next again

31541
20:52:35,920 --> 20:52:39,120
and get out of our constructor

31542
20:52:39,120 --> 20:52:41,192
and if we

31543
20:52:41,192 --> 20:52:44,640
step over we should print our volume

31544
20:52:44,640 --> 20:52:47,360
which is going to be 3.14 because the

31545
20:52:47,360 --> 20:52:48,480
compiler

31546
20:52:48,480 --> 20:52:50,872
just used the

31547
20:52:50,872 --> 20:52:53,120
initial values we have in our member

31548
20:52:53,120 --> 20:52:55,920
variables here so again the message is

31549
20:52:55,920 --> 20:52:58,640
if you don't have any constructor in

31550
20:52:58,640 --> 20:53:01,192
your class the compiler is going to

31551
20:53:01,192 --> 20:53:03,600
generate an empty constructor for you

31552
20:53:03,600 --> 20:53:05,512
and the empty constructor is going to

31553
20:53:05,512 --> 20:53:08,000
take no parameters and it's not going to

31554
20:53:08,000 --> 20:53:09,832
have anything in the body it's going to

31555
20:53:09,832 --> 20:53:13,040
be an empty constructor and it is called

31556
20:53:13,040 --> 20:53:15,832
a default constructor generated by the

31557
20:53:15,832 --> 20:53:18,240
compiler this is really all i had to

31558
20:53:18,240 --> 20:53:19,920
share in this lecture i hope you found

31559
20:53:19,920 --> 20:53:22,160
it interesting now you should have

31560
20:53:22,160 --> 20:53:24,240
enough knowledge to build your own

31561
20:53:24,240 --> 20:53:26,872
constructors for your classes we are

31562
20:53:26,872 --> 20:53:29,040
going to stop here in this lecture the

31563
20:53:29,040 --> 20:53:30,800
next one we're going to learn about

31564
20:53:30,800 --> 20:53:32,800
default constructors

31565
20:53:32,800 --> 20:53:34,640
go ahead and finish up here

31566
20:53:34,640 --> 20:53:36,480
and meet me there in this lecture we're

31567
20:53:36,480 --> 20:53:38,080
going to learn about default

31568
20:53:38,080 --> 20:53:40,800
constructors and this is a syntax you

31569
20:53:40,800 --> 20:53:43,512
can use to let the compiler

31570
20:53:43,512 --> 20:53:46,320
generate a default constructor for you

31571
20:53:46,320 --> 20:53:48,640
all you have to do is do things like

31572
20:53:48,640 --> 20:53:51,120
this you're going to say the name of the

31573
20:53:51,120 --> 20:53:52,800
constructor which is going to be the

31574
20:53:52,800 --> 20:53:54,400
same name as the class you're going to

31575
20:53:54,400 --> 20:53:56,872
put in an empty parameter list and then

31576
20:53:56,872 --> 20:53:59,832
you're going to say equals default

31577
20:53:59,832 --> 20:54:01,920
if you do this the compiler is going to

31578
20:54:01,920 --> 20:54:05,040
generate a default empty constructor for

31579
20:54:05,040 --> 20:54:05,832
you

31580
20:54:05,832 --> 20:54:07,920
in the last lecture we have seen that we

31581
20:54:07,920 --> 20:54:10,080
can set up our own constructors

31582
20:54:10,080 --> 20:54:13,040
basically like this what i haven't told

31583
20:54:13,040 --> 20:54:15,760
you is that the moment you set up your

31584
20:54:15,760 --> 20:54:19,192
own constructor the compiler is going to

31585
20:54:19,192 --> 20:54:22,080
not generate the default constructor and

31586
20:54:22,080 --> 20:54:24,480
if you want to keep the ability to

31587
20:54:24,480 --> 20:54:27,360
construct objects without passing

31588
20:54:27,360 --> 20:54:29,832
parameters you're going to have to put

31589
20:54:29,832 --> 20:54:32,080
in your own default constructor and you

31590
20:54:32,080 --> 20:54:35,360
can use this syntax here to do that

31591
20:54:35,360 --> 20:54:37,600
let's head over to visual studio code

31592
20:54:37,600 --> 20:54:39,680
and talk about this a little more okay

31593
20:54:39,680 --> 20:54:42,400
here we are in our working folder the

31594
20:54:42,400 --> 20:54:44,400
current project is defaulted

31595
20:54:44,400 --> 20:54:46,960
constructors we're going to grab our

31596
20:54:46,960 --> 20:54:49,040
template files and we're going to put

31597
20:54:49,040 --> 20:54:51,440
them in place and we are going to open

31598
20:54:51,440 --> 20:54:53,680
this in visual studio code by dragging

31599
20:54:53,680 --> 20:54:55,512
and dropping here and we're going to

31600
20:54:55,512 --> 20:54:58,400
open our main cpp file let's take out

31601
20:54:58,400 --> 20:55:00,800
what we don't need we're going to clean

31602
20:55:00,800 --> 20:55:03,040
the main function here and we are going

31603
20:55:03,040 --> 20:55:05,600
to bring in the class definition we had

31604
20:55:05,600 --> 20:55:07,512
in the last lecture

31605
20:55:07,512 --> 20:55:10,160
if you remember we had two constructors

31606
20:55:10,160 --> 20:55:12,800
and one constructor which didn't take

31607
20:55:12,800 --> 20:55:16,320
any parameter and another constructor

31608
20:55:16,320 --> 20:55:18,552
which was initializing our member

31609
20:55:18,552 --> 20:55:21,040
variables with parameters that we passed

31610
20:55:21,040 --> 20:55:24,000
in this parameter list here but in this

31611
20:55:24,000 --> 20:55:27,440
lecture let's take out this constructor

31612
20:55:27,440 --> 20:55:30,080
that doesn't take any parameter

31613
20:55:30,080 --> 20:55:32,720
and show you that when you set up your

31614
20:55:32,720 --> 20:55:35,280
own constructor the compiler is not

31615
20:55:35,280 --> 20:55:37,600
going to generate a default constructor

31616
20:55:37,600 --> 20:55:39,440
for you and we're going to lose the

31617
20:55:39,440 --> 20:55:42,552
ability to construct objects without

31618
20:55:42,552 --> 20:55:45,120
passing parameters the syntax we

31619
20:55:45,120 --> 20:55:46,720
basically see here we're going to say

31620
20:55:46,720 --> 20:55:49,512
cylinder and say cylinder one let's use

31621
20:55:49,512 --> 20:55:52,320
a lowercase c and if we do this you see

31622
20:55:52,320 --> 20:55:54,160
that we have a squiggly line the

31623
20:55:54,160 --> 20:55:56,400
compiler is not going to generate an

31624
20:55:56,400 --> 20:56:00,400
empty non-parameter taking constructor

31625
20:56:00,400 --> 20:56:02,000
because it sees that we have a

31626
20:56:02,000 --> 20:56:04,320
constructor here this is how c plus plus

31627
20:56:04,320 --> 20:56:07,192
compilers work if they see that you have

31628
20:56:07,192 --> 20:56:09,360
any constructor in your class they're

31629
20:56:09,360 --> 20:56:11,440
not going to generate a default empty

31630
20:56:11,440 --> 20:56:13,360
constructor and if we try to build we're

31631
20:56:13,360 --> 20:56:15,280
going to get an arrow that says

31632
20:56:15,280 --> 20:56:17,280
something like

31633
20:56:17,280 --> 20:56:19,280
we don't have a constructor that can

31634
20:56:19,280 --> 20:56:21,440
basically construct an object from the

31635
20:56:21,440 --> 20:56:23,920
line here it's going to say no matching

31636
20:56:23,920 --> 20:56:26,480
function call for cylinder cylinder you

31637
20:56:26,480 --> 20:56:28,240
see here it is trying to call a

31638
20:56:28,240 --> 20:56:30,872
constructor that doesn't take any

31639
20:56:30,872 --> 20:56:32,640
parameter but we have no such

31640
20:56:32,640 --> 20:56:35,600
constructor in our code we could go in

31641
20:56:35,600 --> 20:56:37,832
and put in that constructor

31642
20:56:37,832 --> 20:56:40,872
and for example say cylinder and put an

31643
20:56:40,872 --> 20:56:43,280
empty parameter list and put an empty

31644
20:56:43,280 --> 20:56:46,000
body now this line here is going to work

31645
20:56:46,000 --> 20:56:47,920
because we have a default empty

31646
20:56:47,920 --> 20:56:50,960
constructor and if we weld you see that

31647
20:56:50,960 --> 20:56:53,192
the build is going to be good okay we

31648
20:56:53,192 --> 20:56:56,552
are building fine but having to type all

31649
20:56:56,552 --> 20:56:59,680
this if what you really want is an empty

31650
20:56:59,680 --> 20:57:01,040
constructor

31651
20:57:01,040 --> 20:57:03,920
is too much type in and in c plus plus

31652
20:57:03,920 --> 20:57:06,240
we have a syntax we can use to let the

31653
20:57:06,240 --> 20:57:08,640
compiler generate this kind of

31654
20:57:08,640 --> 20:57:10,720
constructor for us and the way we do

31655
20:57:10,720 --> 20:57:13,760
that is say cylinder and we say the name

31656
20:57:13,760 --> 20:57:15,760
of the constructor we say equals and we

31657
20:57:15,760 --> 20:57:18,480
say default if we save this the compiler

31658
20:57:18,480 --> 20:57:20,320
is going to generate this constructor

31659
20:57:20,320 --> 20:57:22,400
for us and the line here is going to

31660
20:57:22,400 --> 20:57:25,440
work so let's bring this up and build

31661
20:57:25,440 --> 20:57:28,320
again we're going to build with gcc

31662
20:57:28,320 --> 20:57:29,760
you're going to see that the build is

31663
20:57:29,760 --> 20:57:32,872
good and we can bring up the terminal

31664
20:57:32,872 --> 20:57:35,440
and clear and run rooster we're not

31665
20:57:35,440 --> 20:57:37,280
going to see anything because we're not

31666
20:57:37,280 --> 20:57:40,720
printing the volume of our cylinder here

31667
20:57:40,720 --> 20:57:42,320
but we can do that let's call this

31668
20:57:42,320 --> 20:57:44,720
cylinder one to be consistent with what

31669
20:57:44,720 --> 20:57:46,800
we did in the last few lectures and

31670
20:57:46,800 --> 20:57:49,040
we're going to say hddc out and print

31671
20:57:49,040 --> 20:57:51,120
the volume of this cylinder we're going

31672
20:57:51,120 --> 20:57:54,320
to say volume and call our volume method

31673
20:57:54,320 --> 20:57:56,800
and now that we have this we can weld

31674
20:57:56,800 --> 20:57:58,960
we're going to use gcc to do that the

31675
20:57:58,960 --> 20:58:01,760
build is good we can go down and clear

31676
20:58:01,760 --> 20:58:03,512
and run rooster we're going to see that

31677
20:58:03,512 --> 20:58:06,000
we see our volume here and this is

31678
20:58:06,000 --> 20:58:08,000
really all i wanted to share with you in

31679
20:58:08,000 --> 20:58:10,400
this lecture that you can use this

31680
20:58:10,400 --> 20:58:13,280
default syntax here to set up an empty

31681
20:58:13,280 --> 20:58:16,400
default constructor for your classes and

31682
20:58:16,400 --> 20:58:18,800
one thing i haven't shown you

31683
20:58:18,800 --> 20:58:22,080
is that your constructors have to be

31684
20:58:22,080 --> 20:58:25,280
public to be able to be called like this

31685
20:58:25,280 --> 20:58:27,600
and to show you that let's go up and

31686
20:58:27,600 --> 20:58:29,832
actually change this to private and show

31687
20:58:29,832 --> 20:58:31,600
you what happens the moment we do this

31688
20:58:31,600 --> 20:58:33,512
we're going to get a squiggly line in

31689
20:58:33,512 --> 20:58:36,320
the main function here and if we try to

31690
20:58:36,320 --> 20:58:39,040
build but before we build let's show you

31691
20:58:39,040 --> 20:58:41,192
what visual studio code is saying it's

31692
20:58:41,192 --> 20:58:44,080
going to say cylinder cylinder declared

31693
20:58:44,080 --> 20:58:46,160
is inaccessible so you see the

31694
20:58:46,160 --> 20:58:49,120
constructor which is declared inside of

31695
20:58:49,120 --> 20:58:51,120
a class as private

31696
20:58:51,120 --> 20:58:54,000
it accessible from the outside when we

31697
20:58:54,000 --> 20:58:56,720
try to call it to build our cylinder

31698
20:58:56,720 --> 20:59:00,640
objects so for constructors to be usable

31699
20:59:00,640 --> 20:59:02,720
on the outside here and both your

31700
20:59:02,720 --> 20:59:05,360
objects they have to be public let's

31701
20:59:05,360 --> 20:59:08,400
build and see what gcc says about this

31702
20:59:08,400 --> 20:59:09,832
we basically going to have the same

31703
20:59:09,832 --> 20:59:12,480
error the constructor is private within

31704
20:59:12,480 --> 20:59:14,960
this context so we can't really call it

31705
20:59:14,960 --> 20:59:16,872
so if we want our code to build we need

31706
20:59:16,872 --> 20:59:19,512
to make our constructors public and this

31707
20:59:19,512 --> 20:59:20,640
is something

31708
20:59:20,640 --> 20:59:22,872
you need to know let's build again and

31709
20:59:22,872 --> 20:59:25,280
see that the cold is now building the

31710
20:59:25,280 --> 20:59:27,440
world is good and this is really all i

31711
20:59:27,440 --> 20:59:29,280
had to share in this lecture we are

31712
20:59:29,280 --> 20:59:31,360
going to stop here in this one in the

31713
20:59:31,360 --> 20:59:32,960
next one we're going to see how we can

31714
20:59:32,960 --> 20:59:36,640
use setters and getters to modify things

31715
20:59:36,640 --> 20:59:39,040
about our class objects

31716
20:59:39,040 --> 20:59:41,440
go ahead and finish up here and meet me

31717
20:59:41,440 --> 20:59:42,240
there

31718
20:59:42,240 --> 20:59:43,680
in this lecture we're going to learn

31719
20:59:43,680 --> 20:59:46,480
about setters and gators and these are

31720
20:59:46,480 --> 20:59:49,512
methods in our class that we can use to

31721
20:59:49,512 --> 20:59:52,552
read member variables or modify data in

31722
20:59:52,552 --> 20:59:55,120
our member variables let's look at a

31723
20:59:55,120 --> 20:59:58,080
simple example and by the way i am sorry

31724
20:59:58,080 --> 21:00:00,960
for my bad pronunciation of cylinder

31725
21:00:00,960 --> 21:00:03,600
here i have said it was cylinder and

31726
21:00:03,600 --> 21:00:05,832
after some careful thought i checked

31727
21:00:05,832 --> 21:00:08,640
online for the pronunciation on this and

31728
21:00:08,640 --> 21:00:11,120
i found that it was cylinder sorry for

31729
21:00:11,120 --> 21:00:13,920
this if it was bothering you i apologize

31730
21:00:13,920 --> 21:00:16,160
for the bad pronunciation and i am going

31731
21:00:16,160 --> 21:00:18,552
to do this right starting from now okay

31732
21:00:18,552 --> 21:00:21,600
here we have our cylinder class we have

31733
21:00:21,600 --> 21:00:23,920
a few member variables and we have the

31734
21:00:23,920 --> 21:00:26,800
base radius we have the height and now

31735
21:00:26,800 --> 21:00:28,872
we want to go through some public

31736
21:00:28,872 --> 21:00:31,280
functions to do operations on these

31737
21:00:31,280 --> 21:00:33,192
member variables because now that they

31738
21:00:33,192 --> 21:00:35,760
are private we can't really modify them

31739
21:00:35,760 --> 21:00:38,480
or manipulate them from the outside and

31740
21:00:38,480 --> 21:00:40,960
we really need to do things with them so

31741
21:00:40,960 --> 21:00:43,120
if we want to read things from them we

31742
21:00:43,120 --> 21:00:45,360
will use the getter functions

31743
21:00:45,360 --> 21:00:47,360
and if you look here this is a simple

31744
21:00:47,360 --> 21:00:50,240
function the only special thing about it

31745
21:00:50,240 --> 21:00:52,960
is that it leaves inside the class it

31746
21:00:52,960 --> 21:00:55,040
has a return value it has a function

31747
21:00:55,040 --> 21:00:56,872
name it has a parameter list and then

31748
21:00:56,872 --> 21:00:59,440
the body we're just going to return the

31749
21:00:59,440 --> 21:01:01,512
member variable of interest because this

31750
21:01:01,512 --> 21:01:04,240
is a getter we use that to get stuff

31751
21:01:04,240 --> 21:01:06,552
from the class this is the meaning here

31752
21:01:06,552 --> 21:01:08,400
here we have another getter function

31753
21:01:08,400 --> 21:01:10,400
which is going to return the height and

31754
21:01:10,400 --> 21:01:13,440
notice that these functions live in the

31755
21:01:13,440 --> 21:01:16,872
public scope of our class this is key

31756
21:01:16,872 --> 21:01:19,040
because we want to be able to go through

31757
21:01:19,040 --> 21:01:22,480
them to modify and do things with our

31758
21:01:22,480 --> 21:01:25,040
member variables but they will be used

31759
21:01:25,040 --> 21:01:27,920
from the outside so they must be public

31760
21:01:27,920 --> 21:01:29,832
otherwise they want to be accessible

31761
21:01:29,832 --> 21:01:33,120
from the outside we also have a pair of

31762
21:01:33,120 --> 21:01:35,192
setup functions they are going to be

31763
21:01:35,192 --> 21:01:38,320
modifying our member variables so set

31764
21:01:38,320 --> 21:01:40,720
base radius is going to take a parameter

31765
21:01:40,720 --> 21:01:42,872
that it's going to use to set a base

31766
21:01:42,872 --> 21:01:44,960
radius set height is going to do the

31767
21:01:44,960 --> 21:01:46,640
same it's going to take a parameter and

31768
21:01:46,640 --> 21:01:49,600
it's going to use that to assign a value

31769
21:01:49,600 --> 21:01:52,240
to our height member variable here and

31770
21:01:52,240 --> 21:01:55,040
because these functions are members of

31771
21:01:55,040 --> 21:01:56,160
the class

31772
21:01:56,160 --> 21:01:59,832
they have access to our member variables

31773
21:01:59,832 --> 21:02:02,552
regardless of whether they are public or

31774
21:02:02,552 --> 21:02:04,872
private so this is going to work we're

31775
21:02:04,872 --> 21:02:06,400
going to go through them from the

31776
21:02:06,400 --> 21:02:08,400
outside and they are going to do the

31777
21:02:08,400 --> 21:02:11,440
dairy work for us and do things using

31778
21:02:11,440 --> 21:02:14,160
our member variables to which we don't

31779
21:02:14,160 --> 21:02:15,760
have access to

31780
21:02:15,760 --> 21:02:17,600
from the outside this is the meaning

31781
21:02:17,600 --> 21:02:20,080
here now that you have an idea about

31782
21:02:20,080 --> 21:02:22,080
this we're going to head over to visual

31783
21:02:22,080 --> 21:02:23,760
studio code and play with us a little

31784
21:02:23,760 --> 21:02:26,720
more okay here we are in our working

31785
21:02:26,720 --> 21:02:28,960
folder the current project is setters

31786
21:02:28,960 --> 21:02:30,800
and getters we're going to grab our

31787
21:02:30,800 --> 21:02:33,120
template files pretty quick and put them

31788
21:02:33,120 --> 21:02:34,320
in place

31789
21:02:34,320 --> 21:02:36,960
setters and getters it is let's grab the

31790
21:02:36,960 --> 21:02:38,872
folder and we're going to open this in

31791
21:02:38,872 --> 21:02:40,800
video studio code by dragging and

31792
21:02:40,800 --> 21:02:42,872
dropping here this is going to open our

31793
21:02:42,872 --> 21:02:45,760
folder we're going to open our main cpp

31794
21:02:45,760 --> 21:02:47,680
file and we're going to clean it up a

31795
21:02:47,680 --> 21:02:49,832
little bit we are going to grab the

31796
21:02:49,832 --> 21:02:53,040
cylinder class from our previous lecture

31797
21:02:53,040 --> 21:02:55,680
and use that as a starting point here

31798
21:02:55,680 --> 21:02:57,920
and if you look we have a pair of

31799
21:02:57,920 --> 21:03:00,552
constructors here we have the volume

31800
21:03:00,552 --> 21:03:02,160
function which is going to give us the

31801
21:03:02,160 --> 21:03:04,960
volume of our cylinder here and we have

31802
21:03:04,960 --> 21:03:07,360
our member variables now what we want to

31803
21:03:07,360 --> 21:03:10,240
do is to be able to do things with these

31804
21:03:10,240 --> 21:03:13,120
member variables from the outside in the

31805
21:03:13,120 --> 21:03:15,192
main function here and we're going to go

31806
21:03:15,192 --> 21:03:17,512
through setter and getter methods which

31807
21:03:17,512 --> 21:03:20,480
must be public so let's do that so we're

31808
21:03:20,480 --> 21:03:22,872
going to set up our getter first so

31809
21:03:22,872 --> 21:03:25,280
we're going to say double get base

31810
21:03:25,280 --> 21:03:27,280
radius it's going to return double it's

31811
21:03:27,280 --> 21:03:29,760
not going to take anything and and in

31812
21:03:29,760 --> 21:03:32,160
the body we're just going to return our

31813
21:03:32,160 --> 21:03:34,400
radius let's return that okay so we're

31814
21:03:34,400 --> 21:03:36,320
going to set up another getter which is

31815
21:03:36,320 --> 21:03:38,480
going to give us the height and it's not

31816
21:03:38,480 --> 21:03:40,552
going to take anything and it's going to

31817
21:03:40,552 --> 21:03:43,512
just return our height member variable

31818
21:03:43,512 --> 21:03:46,160
now these are our getters they are going

31819
21:03:46,160 --> 21:03:49,040
to be getting things from the class

31820
21:03:49,040 --> 21:03:50,960
object we're going to set up other

31821
21:03:50,960 --> 21:03:52,720
functions that are going to be our

31822
21:03:52,720 --> 21:03:54,960
setters they're not going to return

31823
21:03:54,960 --> 21:03:57,120
anything and we're going to say set base

31824
21:03:57,120 --> 21:03:59,120
radius and it's going to take a double

31825
21:03:59,120 --> 21:04:01,360
parameter in and we're going to use that

31826
21:04:01,360 --> 21:04:03,280
to set our base radius so we're going to

31827
21:04:03,280 --> 21:04:05,440
say base radius and we're going to say

31828
21:04:05,440 --> 21:04:07,360
equals red parameter here and we're

31829
21:04:07,360 --> 21:04:09,832
going to do the same for our height so

31830
21:04:09,832 --> 21:04:11,680
it's not going to return anything the

31831
21:04:11,680 --> 21:04:13,512
function here and we're going to say set

31832
21:04:13,512 --> 21:04:15,280
height and we're going to take our

31833
21:04:15,280 --> 21:04:17,832
parameter n so i'm going to say double

31834
21:04:17,832 --> 21:04:20,240
height param and we're going to use that

31835
21:04:20,240 --> 21:04:21,040
to

31836
21:04:21,040 --> 21:04:22,080
assign

31837
21:04:22,080 --> 21:04:24,640
stuff to our member variable we're going

31838
21:04:24,640 --> 21:04:27,280
to say hi and we're going to say height

31839
21:04:27,280 --> 21:04:30,240
param okay so this is our thing here now

31840
21:04:30,240 --> 21:04:33,192
we have two functions to get stuff from

31841
21:04:33,192 --> 21:04:35,760
our class and we have two functions to

31842
21:04:35,760 --> 21:04:38,640
set data to our member variables here

31843
21:04:38,640 --> 21:04:41,040
and again remember that we can't have

31844
21:04:41,040 --> 21:04:44,240
direct access to these member variables

31845
21:04:44,240 --> 21:04:46,160
on the outside of the class and if we

31846
21:04:46,160 --> 21:04:48,000
want to do that we're going to be able

31847
21:04:48,000 --> 21:04:50,552
to do that through our setter and getter

31848
21:04:50,552 --> 21:04:52,872
functions now for these functions

31849
21:04:52,872 --> 21:04:54,552
setters and getters to be accessible

31850
21:04:54,552 --> 21:04:57,280
from the outside they needed to leave in

31851
21:04:57,280 --> 21:04:59,760
the public section of our class you see

31852
21:04:59,760 --> 21:05:01,680
this public keyword here is going to

31853
21:05:01,680 --> 21:05:05,192
apply to anything after it until we

31854
21:05:05,192 --> 21:05:07,920
change this to private software so the

31855
21:05:07,920 --> 21:05:10,080
public scope is basically going from the

31856
21:05:10,080 --> 21:05:11,832
constructors here

31857
21:05:11,832 --> 21:05:14,720
all the way to our set height function

31858
21:05:14,720 --> 21:05:17,192
and once we put this private keyword

31859
21:05:17,192 --> 21:05:19,280
here everything after that is going to

31860
21:05:19,280 --> 21:05:21,832
be private this is how these things work

31861
21:05:21,832 --> 21:05:23,832
so let's try and use this in main we're

31862
21:05:23,832 --> 21:05:25,920
going to set up a cylinder object

31863
21:05:25,920 --> 21:05:28,640
cylinder one and let's put in for

31864
21:05:28,640 --> 21:05:31,360
example two and three why not and now if

31865
21:05:31,360 --> 21:05:33,440
we want to have access to the base

31866
21:05:33,440 --> 21:05:36,552
radius remember if we tried to access

31867
21:05:36,552 --> 21:05:39,440
that directly let's say that if we try

31868
21:05:39,440 --> 21:05:41,760
to do something like cylinder one and

31869
21:05:41,760 --> 21:05:44,080
say base radius you're going to see that

31870
21:05:44,080 --> 21:05:45,680
we're going to have a squiggly line

31871
21:05:45,680 --> 21:05:47,192
meaning that there's something wrong

31872
21:05:47,192 --> 21:05:48,872
with our call here let's bring up a

31873
21:05:48,872 --> 21:05:49,920
terminal

31874
21:05:49,920 --> 21:05:51,760
and see what visual studio code thinks

31875
21:05:51,760 --> 21:05:53,440
about this membership base radius

31876
21:05:53,440 --> 21:05:55,440
declared this inaccessible here if we

31877
21:05:55,440 --> 21:05:57,440
try to weld we probably going to get a

31878
21:05:57,440 --> 21:05:59,600
compiler error that says that base

31879
21:05:59,600 --> 21:06:02,320
radius is private in this scope and

31880
21:06:02,320 --> 21:06:04,480
that's what we have here declare the

31881
21:06:04,480 --> 21:06:07,040
private here so we can't access this

31882
21:06:07,040 --> 21:06:09,440
from the main function here but now that

31883
21:06:09,440 --> 21:06:12,080
we have our getter functions we can go

31884
21:06:12,080 --> 21:06:14,552
through them and have access to

31885
21:06:14,552 --> 21:06:16,872
private member variables and notice that

31886
21:06:16,872 --> 21:06:19,760
because we are returning by value here

31887
21:06:19,760 --> 21:06:21,680
what return is going to be a copy you

31888
21:06:21,680 --> 21:06:24,400
really need to keep an eye for whether

31889
21:06:24,400 --> 21:06:26,400
what you are manipulating is the

31890
21:06:26,400 --> 21:06:29,600
original stuff or a copy so here we're

31891
21:06:29,600 --> 21:06:31,512
going to be returning by value and we're

31892
21:06:31,512 --> 21:06:33,920
going to return a copy but this is still

31893
21:06:33,920 --> 21:06:36,800
useful in some cases so here we can use

31894
21:06:36,800 --> 21:06:39,120
allocator let's take out this here and

31895
21:06:39,120 --> 21:06:42,240
say get base radius it is a method or a

31896
21:06:42,240 --> 21:06:45,280
function so we need to put our function

31897
21:06:45,280 --> 21:06:47,832
call here and now if we try to build

31898
21:06:47,832 --> 21:06:50,000
let's pass this through gcc and see what

31899
21:06:50,000 --> 21:06:52,960
we get you see the build is good we can

31900
21:06:52,960 --> 21:06:55,512
run this program let's clear and run

31901
21:06:55,512 --> 21:06:57,040
rooster you're going to see that the

31902
21:06:57,040 --> 21:06:59,512
base radius is two now now that we have

31903
21:06:59,512 --> 21:07:01,920
this sense we can actually modify stuff

31904
21:07:01,920 --> 21:07:05,440
about our cylinder here let's put in 10

31905
21:07:05,440 --> 21:07:07,832
and 10 just to be able to follow this

31906
21:07:07,832 --> 21:07:09,832
easily and we're going to print the

31907
21:07:09,832 --> 21:07:12,640
volume let's say volume and we're going

31908
21:07:12,640 --> 21:07:14,960
to say volume here we're not going to

31909
21:07:14,960 --> 21:07:16,720
use the getter here i'm going to say

31910
21:07:16,720 --> 21:07:19,040
volume this is going to print our volume

31911
21:07:19,040 --> 21:07:21,360
but we're going to modify our member

31912
21:07:21,360 --> 21:07:24,320
variables remember this is an object of

31913
21:07:24,320 --> 21:07:26,080
our cylinder class

31914
21:07:26,080 --> 21:07:28,800
so we're going to say cylinder 1 set

31915
21:07:28,800 --> 21:07:31,040
base radius we can do that and we can

31916
21:07:31,040 --> 21:07:33,680
change this to 100 for example and we

31917
21:07:33,680 --> 21:07:36,872
can change the height that height we can

31918
21:07:36,872 --> 21:07:39,360
use this member function because we have

31919
21:07:39,360 --> 21:07:41,832
it now and we're going to set this to 10

31920
21:07:41,832 --> 21:07:44,320
why not now if we print the volume

31921
21:07:44,320 --> 21:07:46,160
you're going to see that the volume has

31922
21:07:46,160 --> 21:07:49,440
changed because we are going through our

31923
21:07:49,440 --> 21:07:50,480
public

31924
21:07:50,480 --> 21:07:52,720
setter and getters methods so the

31925
21:07:52,720 --> 21:07:54,640
cylinder is now going to be using this

31926
21:07:54,640 --> 21:07:56,960
data and for the first case here the

31927
21:07:56,960 --> 21:07:59,040
cylinder is going to be using the data

31928
21:07:59,040 --> 21:08:01,440
we used in our constructor here let's

31929
21:08:01,440 --> 21:08:03,760
both and run this application the build

31930
21:08:03,760 --> 21:08:06,480
is good we can clear and run rooster now

31931
21:08:06,480 --> 21:08:07,832
for the first time we're going to see

31932
21:08:07,832 --> 21:08:10,400
that our volume is this number and for

31933
21:08:10,400 --> 21:08:13,040
the second time our volume is going to

31934
21:08:13,040 --> 21:08:16,160
be multiplied by 10 because we changed

31935
21:08:16,160 --> 21:08:19,360
the base radius to 100 and if you put

31936
21:08:19,360 --> 21:08:21,280
these numbers in you're going to see

31937
21:08:21,280 --> 21:08:23,360
that they make sense we are able to

31938
21:08:23,360 --> 21:08:26,320
modify our member variables through our

31939
21:08:26,320 --> 21:08:28,640
setter and getter functions and again

31940
21:08:28,640 --> 21:08:30,960
for this setter and getter functions to

31941
21:08:30,960 --> 21:08:33,440
work they have to be in the public scope

31942
21:08:33,440 --> 21:08:35,360
of your class because if you make them

31943
21:08:35,360 --> 21:08:36,872
private they're not going to be

31944
21:08:36,872 --> 21:08:38,960
accessible from the outside and you're

31945
21:08:38,960 --> 21:08:40,720
going to get a compiler error let's try

31946
21:08:40,720 --> 21:08:43,040
and do that we are learning so we're not

31947
21:08:43,040 --> 21:08:45,192
afraid to break things a little bit so

31948
21:08:45,192 --> 21:08:47,440
let's make them private we can do that

31949
21:08:47,440 --> 21:08:50,080
and bring this a little bit to the left

31950
21:08:50,080 --> 21:08:51,832
and at the moment we do that we should

31951
21:08:51,832 --> 21:08:54,400
have a few squiggly lines in our main

31952
21:08:54,400 --> 21:08:57,120
function and we do expect this because

31953
21:08:57,120 --> 21:08:59,512
they are private now so we have no

31954
21:08:59,512 --> 21:09:01,512
business accessing them from the main

31955
21:09:01,512 --> 21:09:04,160
function like this they are meant to be

31956
21:09:04,160 --> 21:09:06,320
used from the inside of the class if

31957
21:09:06,320 --> 21:09:08,400
they are private like this and if you

31958
21:09:08,400 --> 21:09:10,872
try to use them from the outside you're

31959
21:09:10,872 --> 21:09:13,192
going to get a compiler error let's pass

31960
21:09:13,192 --> 21:09:15,040
this through gcc to really see the

31961
21:09:15,040 --> 21:09:17,360
compiler error and we're going to get

31962
21:09:17,360 --> 21:09:20,080
set height is private from the context

31963
21:09:20,080 --> 21:09:22,720
of the main function and if we go up i

31964
21:09:22,720 --> 21:09:24,480
think we're going to see the same thing

31965
21:09:24,480 --> 21:09:28,080
for a set base radius and that's here

31966
21:09:28,080 --> 21:09:29,920
this is really all we set out to do in

31967
21:09:29,920 --> 21:09:32,080
this lecture showing you how you can use

31968
21:09:32,080 --> 21:09:34,320
setters and getters to manipulate your

31969
21:09:34,320 --> 21:09:36,960
member variables from the outside

31970
21:09:36,960 --> 21:09:39,360
and i hope you found this useful we are

31971
21:09:39,360 --> 21:09:41,120
going to stop here in this lecture in

31972
21:09:41,120 --> 21:09:42,720
the next one we're going to show you how

31973
21:09:42,720 --> 21:09:45,832
you can split your class across multiple

31974
21:09:45,832 --> 21:09:49,192
files but before i let you go let's fix

31975
21:09:49,192 --> 21:09:50,960
this so that we don't have a compiler

31976
21:09:50,960 --> 21:09:53,040
error here so we're going to remove this

31977
21:09:53,040 --> 21:09:55,680
private keyword we have put here and

31978
21:09:55,680 --> 21:09:57,600
we're going to build again to make sure

31979
21:09:57,600 --> 21:10:00,160
the world is good let's use gcc for that

31980
21:10:00,160 --> 21:10:03,040
the world is good and i will see you in

31981
21:10:03,040 --> 21:10:05,192
the next lecture go ahead and finish up

31982
21:10:05,192 --> 21:10:07,920
here and meet me there in this lecture i

31983
21:10:07,920 --> 21:10:10,080
am going to show you how we can split

31984
21:10:10,080 --> 21:10:13,120
our class information across multiple

31985
21:10:13,120 --> 21:10:16,080
files so far what we have been doing is

31986
21:10:16,080 --> 21:10:18,480
really cramping everything in the main

31987
21:10:18,480 --> 21:10:21,920
function we had our constant declaration

31988
21:10:21,920 --> 21:10:24,800
we had our cylinder class definition and

31989
21:10:24,800 --> 21:10:27,040
we had our main function to use these

31990
21:10:27,040 --> 21:10:30,240
things all cramped into the main cpp

31991
21:10:30,240 --> 21:10:32,240
file now we're going to see how we can

31992
21:10:32,240 --> 21:10:34,240
do things better the first thing we can

31993
21:10:34,240 --> 21:10:38,000
do is move our constant in another file

31994
21:10:38,000 --> 21:10:40,800
because if you think about it users of

31995
21:10:40,800 --> 21:10:43,360
your class in the main function don't

31996
21:10:43,360 --> 21:10:46,400
care about this constant pi because it

31997
21:10:46,400 --> 21:10:49,192
really is an implementation detail

31998
21:10:49,192 --> 21:10:51,600
that should leave somewhere else or even

31999
21:10:51,600 --> 21:10:53,600
inside the cylinder class but we're

32000
21:10:53,600 --> 21:10:55,920
going to put this in a separate file

32001
21:10:55,920 --> 21:10:57,920
because that's going to give us room to

32002
21:10:57,920 --> 21:11:00,640
put as a constant if we need to do that

32003
21:11:00,640 --> 21:11:03,360
so if we split things up like this

32004
21:11:03,360 --> 21:11:05,600
when we want to use the pi variable we

32005
21:11:05,600 --> 21:11:08,320
will need to include the constants file

32006
21:11:08,320 --> 21:11:10,400
because that's going to give us access

32007
21:11:10,400 --> 21:11:12,872
to it but we don't have to maintain it

32008
21:11:12,872 --> 21:11:15,040
in the main function so this is a little

32009
21:11:15,040 --> 21:11:17,120
better but another thing we can do is

32010
21:11:17,120 --> 21:11:19,832
remove the cylinder in another separate

32011
21:11:19,832 --> 21:11:22,640
file and do something like this so now

32012
21:11:22,640 --> 21:11:25,360
you see that our cylinder declaration

32013
21:11:25,360 --> 21:11:27,600
and definition has moved in a file

32014
21:11:27,600 --> 21:11:29,832
called cylinder.h

32015
21:11:29,832 --> 21:11:32,240
and we have our constant pi

32016
21:11:32,240 --> 21:11:33,832
living in another file called

32017
21:11:33,832 --> 21:11:35,512
constants.h

32018
21:11:35,512 --> 21:11:37,832
and if we want to use our cylinder class

32019
21:11:37,832 --> 21:11:40,640
like we have been using it all along we

32020
21:11:40,640 --> 21:11:43,120
will need to include the header that

32021
21:11:43,120 --> 21:11:45,280
brings it in and this is how we're going

32022
21:11:45,280 --> 21:11:47,600
to do it and we will be able to use it

32023
21:11:47,600 --> 21:11:50,240
in the main function if we set things up

32024
21:11:50,240 --> 21:11:52,872
like this but we can go even further we

32025
21:11:52,872 --> 21:11:55,512
can split our class declaration and

32026
21:11:55,512 --> 21:11:58,240
definition in two separate files what

32027
21:11:58,240 --> 21:11:59,600
we're going to have in the header is

32028
21:11:59,600 --> 21:12:01,512
going to be really a preview of the

32029
21:12:01,512 --> 21:12:02,400
class

32030
21:12:02,400 --> 21:12:05,192
and in the cpp file which is going to be

32031
21:12:05,192 --> 21:12:05,960
called

32032
21:12:05,960 --> 21:12:08,000
cylinder.cpp we're going to have the

32033
21:12:08,000 --> 21:12:11,440
implementation details of our class and

32034
21:12:11,440 --> 21:12:13,192
again this is going to make things a

32035
21:12:13,192 --> 21:12:15,680
little easier to manage because it's

32036
21:12:15,680 --> 21:12:17,600
really not good to have everything

32037
21:12:17,600 --> 21:12:20,720
cramped into your main cpp file it

32038
21:12:20,720 --> 21:12:23,512
should really have high level details

32039
21:12:23,512 --> 21:12:26,400
about how your application works and all

32040
21:12:26,400 --> 21:12:28,552
the low level details should be split

32041
21:12:28,552 --> 21:12:31,360
into different files this is good design

32042
21:12:31,360 --> 21:12:33,832
now that you have an idea about this

32043
21:12:33,832 --> 21:12:36,080
let's head over to visual studio code

32044
21:12:36,080 --> 21:12:37,760
and show you how you can do this okay

32045
21:12:37,760 --> 21:12:40,320
here we are in our working folder the

32046
21:12:40,320 --> 21:12:43,120
current project is class across multiple

32047
21:12:43,120 --> 21:12:46,400
files we're going to grab our template

32048
21:12:46,400 --> 21:12:48,640
files and put them in place and we're

32049
21:12:48,640 --> 21:12:50,640
going to open this in visual studio code

32050
21:12:50,640 --> 21:12:52,640
so that we can really play with us this

32051
21:12:52,640 --> 21:12:55,440
is going to open our folder we can open

32052
21:12:55,440 --> 21:12:58,400
the main cpp file we are going to clean

32053
21:12:58,400 --> 21:13:00,480
it up a little bit and we are going to

32054
21:13:00,480 --> 21:13:03,040
grab our class definition and put that

32055
21:13:03,040 --> 21:13:05,440
on top here so this is our cylinder

32056
21:13:05,440 --> 21:13:07,440
class we have the constructors we have

32057
21:13:07,440 --> 21:13:10,000
the functions the volume function here

32058
21:13:10,000 --> 21:13:12,080
and we have our setters and getters

32059
21:13:12,080 --> 21:13:14,552
inside down we have our member variables

32060
21:13:14,552 --> 21:13:16,720
which happen to be private to this class

32061
21:13:16,720 --> 21:13:19,440
here now what we want to do is to

32062
21:13:19,440 --> 21:13:20,400
organize

32063
21:13:20,400 --> 21:13:22,872
our code better and the first thing we

32064
21:13:22,872 --> 21:13:26,000
need to do is to move this constant from

32065
21:13:26,000 --> 21:13:28,800
the main file here because it's really

32066
21:13:28,800 --> 21:13:31,832
not that useful at this point here users

32067
21:13:31,832 --> 21:13:33,832
of your classes won't really care about

32068
21:13:33,832 --> 21:13:36,080
what pi is because it is an

32069
21:13:36,080 --> 21:13:38,320
implementation detail to the cylinder

32070
21:13:38,320 --> 21:13:40,320
class because we are using that to

32071
21:13:40,320 --> 21:13:42,800
compute our volume so this constant

32072
21:13:42,800 --> 21:13:45,192
really has no business being in the main

32073
21:13:45,192 --> 21:13:46,960
file we're going to move this in a

32074
21:13:46,960 --> 21:13:48,552
separate file we're going to set up a

32075
21:13:48,552 --> 21:13:50,240
new file we're going to come to the left

32076
21:13:50,240 --> 21:13:52,960
here click on the plus icon here that

32077
21:13:52,960 --> 21:13:55,040
says new file we're going to say

32078
21:13:55,040 --> 21:13:57,720
constants and we're going to call this

32079
21:13:57,720 --> 21:13:59,832
constants.h because it's going to be a

32080
21:13:59,832 --> 21:14:02,800
header file and we can just come from

32081
21:14:02,800 --> 21:14:03,832
the

32082
21:14:03,832 --> 21:14:06,320
main cpp file we're going to copy this

32083
21:14:06,320 --> 21:14:08,240
we're going to cut this actually and

32084
21:14:08,240 --> 21:14:11,120
we're going to put this in our separate

32085
21:14:11,120 --> 21:14:13,832
file which is constants.h

32086
21:14:13,832 --> 21:14:15,760
after we do this we're going to come in

32087
21:14:15,760 --> 21:14:18,160
our main cpp file and we're going to

32088
21:14:18,160 --> 21:14:20,800
include that header file so let's do

32089
21:14:20,800 --> 21:14:24,160
that we're going to include constants.h

32090
21:14:24,160 --> 21:14:25,600
and the moment we do that you're going

32091
21:14:25,600 --> 21:14:28,080
to see now visual studio code knows

32092
21:14:28,080 --> 21:14:30,720
where this constant is but we don't have

32093
21:14:30,720 --> 21:14:32,800
to deal with that directly here another

32094
21:14:32,800 --> 21:14:34,720
benefit of doing things like this is

32095
21:14:34,720 --> 21:14:37,280
that we can go in this header file and

32096
21:14:37,280 --> 21:14:40,400
declare thousands of other constants and

32097
21:14:40,400 --> 21:14:42,400
we can have access to them in the main

32098
21:14:42,400 --> 21:14:46,240
function by just using this single line

32099
21:14:46,240 --> 21:14:48,720
that includes our file here so this is

32100
21:14:48,720 --> 21:14:51,040
good design if we build our application

32101
21:14:51,040 --> 21:14:52,480
you're going to see that it is going to

32102
21:14:52,480 --> 21:14:54,800
work let's try and set up a cylinder

32103
21:14:54,800 --> 21:14:57,680
object we're going to say cylinder 1 and

32104
21:14:57,680 --> 21:15:00,720
we're going to put 10 and 10 n as our

32105
21:15:00,720 --> 21:15:02,552
parameters and we're going to print the

32106
21:15:02,552 --> 21:15:04,800
volume of this little guy so this is

32107
21:15:04,800 --> 21:15:07,192
easy to do now we're going to say volume

32108
21:15:07,192 --> 21:15:08,800
and we're going to print that out

32109
21:15:08,800 --> 21:15:10,800
cylinder one and we're going to call the

32110
21:15:10,800 --> 21:15:13,120
volume method and this is going to print

32111
21:15:13,120 --> 21:15:15,680
our thumb and again i am going to be

32112
21:15:15,680 --> 21:15:19,440
using the terms functions and methods

32113
21:15:19,440 --> 21:15:21,440
interchangeably in this course and what

32114
21:15:21,440 --> 21:15:23,760
i mean in the context of the class

32115
21:15:23,760 --> 21:15:25,600
that's going to be the member functions

32116
21:15:25,600 --> 21:15:27,680
of the class so don't be confused by

32117
21:15:27,680 --> 21:15:30,160
this right here if we build and run this

32118
21:15:30,160 --> 21:15:32,960
application it should be working right

32119
21:15:32,960 --> 21:15:35,680
because we have everything we need for

32120
21:15:35,680 --> 21:15:37,040
it to work

32121
21:15:37,040 --> 21:15:39,192
let's see if the world was good the

32122
21:15:39,192 --> 21:15:41,280
build was good we can bring up a

32123
21:15:41,280 --> 21:15:43,512
terminal and actually run this let's

32124
21:15:43,512 --> 21:15:45,832
clear and run rooster this is going to

32125
21:15:45,832 --> 21:15:47,832
print our volume so the code is working

32126
21:15:47,832 --> 21:15:49,920
right the second thing we want to do is

32127
21:15:49,920 --> 21:15:52,480
to move this class all together in

32128
21:15:52,480 --> 21:15:54,552
another file because we don't really

32129
21:15:54,552 --> 21:15:56,800
want to see it

32130
21:15:56,800 --> 21:15:59,120
here in the main function what we really

32131
21:15:59,120 --> 21:16:01,760
want is to use stuff and we don't care

32132
21:16:01,760 --> 21:16:04,400
about how those things are set up in the

32133
21:16:04,400 --> 21:16:07,440
same logic we used when we used std

32134
21:16:07,440 --> 21:16:09,600
strength we didn't really care about how

32135
21:16:09,600 --> 21:16:12,400
hdd strength is put together all we

32136
21:16:12,400 --> 21:16:14,640
really wanted was to include the class

32137
21:16:14,640 --> 21:16:18,080
that brings it in and use it in our code

32138
21:16:18,080 --> 21:16:20,160
we're going to be setting up the same

32139
21:16:20,160 --> 21:16:22,800
behavior for our cylinder class here and

32140
21:16:22,800 --> 21:16:24,720
it is going to be given in its own

32141
21:16:24,720 --> 21:16:27,280
separate file so let's set up another

32142
21:16:27,280 --> 21:16:28,872
header file we're going to call this

32143
21:16:28,872 --> 21:16:31,512
cylinder dot h and we're going to grab

32144
21:16:31,512 --> 21:16:33,920
our class definition all together so

32145
21:16:33,920 --> 21:16:36,720
we're going to go from the bottom here

32146
21:16:36,720 --> 21:16:39,280
and select everything that includes our

32147
21:16:39,280 --> 21:16:41,360
class we're going to cut this out we're

32148
21:16:41,360 --> 21:16:43,832
going to go in our cylinder header and

32149
21:16:43,832 --> 21:16:46,000
we're going to paste this in there and

32150
21:16:46,000 --> 21:16:47,680
we're going to come back to our main

32151
21:16:47,680 --> 21:16:50,160
file and include our cylinder class so

32152
21:16:50,160 --> 21:16:52,640
let's do that we're going to include and

32153
21:16:52,640 --> 21:16:54,872
we're going to say cylinder.h

32154
21:16:54,872 --> 21:16:56,960
and this is going to make things work

32155
21:16:56,960 --> 21:16:59,440
remember the preprocessor is going to

32156
21:16:59,440 --> 21:17:01,760
put these things on the preprocessor is

32157
21:17:01,760 --> 21:17:04,000
basically going to go in constants it's

32158
21:17:04,000 --> 21:17:06,320
going to take whatever is inside and

32159
21:17:06,320 --> 21:17:08,872
then it's going to paste that here and

32160
21:17:08,872 --> 21:17:11,280
it's going to take everything inside our

32161
21:17:11,280 --> 21:17:13,192
cylinder class and it's going to paste

32162
21:17:13,192 --> 21:17:15,760
that here so it's basically going to be

32163
21:17:15,760 --> 21:17:18,160
like we are declaring these things in

32164
21:17:18,160 --> 21:17:20,400
the main function but our code is going

32165
21:17:20,400 --> 21:17:23,040
to be better organized now if we try to

32166
21:17:23,040 --> 21:17:25,360
build this program it is going to world

32167
21:17:25,360 --> 21:17:27,920
exactly like it did because we have all

32168
21:17:27,920 --> 21:17:30,400
the information for its world let's

32169
21:17:30,400 --> 21:17:32,720
build world has finished successfully so

32170
21:17:32,720 --> 21:17:35,120
the world is good and we can run this

32171
21:17:35,120 --> 21:17:36,960
program and it's going to do what it was

32172
21:17:36,960 --> 21:17:39,192
doing all along we can clear and run

32173
21:17:39,192 --> 21:17:41,680
rooster don't worry about visual studio

32174
21:17:41,680 --> 21:17:43,512
code here i don't know what the problem

32175
21:17:43,512 --> 21:17:45,920
is with that it's just having ah it's

32176
21:17:45,920 --> 21:17:48,320
having a problem with the pi

32177
21:17:48,320 --> 21:17:50,320
constant here because it's not included

32178
21:17:50,320 --> 21:17:53,512
in here so what we can do is say include

32179
21:17:53,512 --> 21:17:56,720
and include our constants header and if

32180
21:17:56,720 --> 21:17:58,640
we do this the problem here is going to

32181
21:17:58,640 --> 21:18:01,360
go away but we're going to have a

32182
21:18:01,360 --> 21:18:03,360
problem if we're trying to run this

32183
21:18:03,360 --> 21:18:05,600
program now because try to think about

32184
21:18:05,600 --> 21:18:08,080
it in the main function we are including

32185
21:18:08,080 --> 21:18:09,920
the constants header

32186
21:18:09,920 --> 21:18:11,680
and in the

32187
21:18:11,680 --> 21:18:14,552
header of cylinder we are also including

32188
21:18:14,552 --> 21:18:17,440
this little guy here so if the processor

32189
21:18:17,440 --> 21:18:19,680
comes it's going to include

32190
21:18:19,680 --> 21:18:21,920
this and it's going to have this little

32191
21:18:21,920 --> 21:18:24,400
guy inside our main function and the

32192
21:18:24,400 --> 21:18:26,400
cylinder is also going to include this

32193
21:18:26,400 --> 21:18:29,040
because it's including this header so

32194
21:18:29,040 --> 21:18:31,440
when the preprocessor is done we're

32195
21:18:31,440 --> 21:18:34,000
going to have our constant here declared

32196
21:18:34,000 --> 21:18:36,240
twice and if we try to build this

32197
21:18:36,240 --> 21:18:38,320
program you can expect bad things to

32198
21:18:38,320 --> 21:18:40,720
happen because it's really not good to

32199
21:18:40,720 --> 21:18:43,512
have the same thing defined more than

32200
21:18:43,512 --> 21:18:47,040
once in your entire program and let's

32201
21:18:47,040 --> 21:18:48,720
try and build and show you this

32202
21:18:48,720 --> 21:18:50,240
hopefully we're going to get a compiler

32203
21:18:50,240 --> 21:18:51,040
error

32204
21:18:51,040 --> 21:18:53,040
and it's going to blow up in our face

32205
21:18:53,040 --> 21:18:55,440
it's going to say hero redefinition of

32206
21:18:55,440 --> 21:18:58,640
const double pi so what is going on here

32207
21:18:58,640 --> 21:19:01,760
we are including this thing twice once

32208
21:19:01,760 --> 21:19:04,320
here and at the second time it's coming

32209
21:19:04,320 --> 21:19:06,640
in directly from the cylinder class

32210
21:19:06,640 --> 21:19:09,280
because we are including that in this

32211
21:19:09,280 --> 21:19:11,920
location here and what the preprocessor

32212
21:19:11,920 --> 21:19:14,000
is basically going to do it's going to

32213
21:19:14,000 --> 21:19:16,552
copy the entire file here and it's going

32214
21:19:16,552 --> 21:19:19,832
to paste that in the place of cylinder.h

32215
21:19:19,832 --> 21:19:22,080
here and this constants header is

32216
21:19:22,080 --> 21:19:24,320
basically going to be included twice so

32217
21:19:24,320 --> 21:19:26,160
it's going to be redefined here that's

32218
21:19:26,160 --> 21:19:28,800
the problem we have one way we have to

32219
21:19:28,800 --> 21:19:32,160
solve this in c plus plus is by using

32220
21:19:32,160 --> 21:19:34,800
include chords and the way we do that we

32221
21:19:34,800 --> 21:19:37,680
come in our constants header and we say

32222
21:19:37,680 --> 21:19:39,440
pound if

32223
21:19:39,440 --> 21:19:40,552
and def

32224
21:19:40,552 --> 21:19:42,240
this is a way to say

32225
21:19:42,240 --> 21:19:45,040
if something is not defined yet and

32226
21:19:45,040 --> 21:19:48,000
let's say cylinder underscore h and

32227
21:19:48,000 --> 21:19:49,920
we're going to say define

32228
21:19:49,920 --> 21:19:52,480
cylinder underscore h and we're going to

32229
21:19:52,480 --> 21:19:56,160
come down to the end and say and f this

32230
21:19:56,160 --> 21:19:57,600
is a way we have to tell the

32231
21:19:57,600 --> 21:20:00,960
preprocessor to only do something or

32232
21:20:00,960 --> 21:20:03,600
include the code we have within these

32233
21:20:03,600 --> 21:20:07,832
things if the condition on top here is

32234
21:20:07,832 --> 21:20:10,720
satisfied so for example the code inside

32235
21:20:10,720 --> 21:20:14,080
here is going to be put in our c plus

32236
21:20:14,080 --> 21:20:15,440
source file

32237
21:20:15,440 --> 21:20:18,960
if the cylinder name here is not defined

32238
21:20:18,960 --> 21:20:21,360
in the eyes of the preprocessor so it's

32239
21:20:21,360 --> 21:20:24,400
going to say if cylinder underscore h is

32240
21:20:24,400 --> 21:20:26,872
not defined i am going to define that

32241
21:20:26,872 --> 21:20:29,360
and i am going to put this code here but

32242
21:20:29,360 --> 21:20:31,120
if it's already defined it's going to

32243
21:20:31,120 --> 21:20:32,872
skip all these things and it's not going

32244
21:20:32,872 --> 21:20:34,872
to include this okay so this is the

32245
21:20:34,872 --> 21:20:37,120
logic here and i noticed this is really

32246
21:20:37,120 --> 21:20:39,120
not a cylinder file so we're going to

32247
21:20:39,120 --> 21:20:41,120
change this to constants

32248
21:20:41,120 --> 21:20:44,000
underscore h let's say that and let's do

32249
21:20:44,000 --> 21:20:46,000
the same here and this is going to do

32250
21:20:46,000 --> 21:20:48,640
our thing and we're going to go in our

32251
21:20:48,640 --> 21:20:51,120
cylinder header and do the same thing

32252
21:20:51,120 --> 21:20:54,080
and put in our include guard it is

32253
21:20:54,080 --> 21:20:56,800
basically a guard that is going to guard

32254
21:20:56,800 --> 21:20:58,552
against something

32255
21:20:58,552 --> 21:21:01,440
being included more than once

32256
21:21:01,440 --> 21:21:03,832
so let's do that in our cylinder header

32257
21:21:03,832 --> 21:21:06,240
so we're going to wrap this inside our

32258
21:21:06,240 --> 21:21:08,872
include guards we're going to say if n

32259
21:21:08,872 --> 21:21:10,872
def you see visual studio code is really

32260
21:21:10,872 --> 21:21:12,552
helping out here and we're going to put

32261
21:21:12,552 --> 21:21:14,552
in the name we're going to use for this

32262
21:21:14,552 --> 21:21:16,872
this is a cylinder class so i think it

32263
21:21:16,872 --> 21:21:19,192
makes sense to call this cylinder

32264
21:21:19,192 --> 21:21:21,512
underscore h and we're going to do the

32265
21:21:21,512 --> 21:21:24,800
same thing here define cylinder and

32266
21:21:24,800 --> 21:21:27,360
we're going to end f at the end of the

32267
21:21:27,360 --> 21:21:29,440
file here so we're going to say end f

32268
21:21:29,440 --> 21:21:31,280
and again this is the syntax of the

32269
21:21:31,280 --> 21:21:33,680
preprocessor i don't want to get too

32270
21:21:33,680 --> 21:21:35,440
much into this because we will learn

32271
21:21:35,440 --> 21:21:37,920
about this later in the course but we

32272
21:21:37,920 --> 21:21:41,040
can now use this to guard against

32273
21:21:41,040 --> 21:21:44,232
something being included more than once

32274
21:21:44,232 --> 21:21:46,080
and if we're trying to build the program

32275
21:21:46,080 --> 21:21:48,080
now hopefully it's going to world let's

32276
21:21:48,080 --> 21:21:50,480
use the gcc and now you see that the

32277
21:21:50,480 --> 21:21:53,920
world is good even if we are including

32278
21:21:53,920 --> 21:21:56,552
the constant header multiple times in

32279
21:21:56,552 --> 21:21:59,680
the main file here we can even go down

32280
21:21:59,680 --> 21:22:02,000
and do that like a thousand times so

32281
21:22:02,000 --> 21:22:03,600
let's do that and you're going to see

32282
21:22:03,600 --> 21:22:05,920
that if we try to compile it is going to

32283
21:22:05,920 --> 21:22:09,440
boil define because now we have a guard

32284
21:22:09,440 --> 21:22:11,360
guarding against including this thing

32285
21:22:11,360 --> 21:22:13,360
more than once the preprocessor is

32286
21:22:13,360 --> 21:22:15,832
basically going to come in here and say

32287
21:22:15,832 --> 21:22:16,800
if

32288
21:22:16,800 --> 21:22:19,440
the constant's name is not defined i'm

32289
21:22:19,440 --> 21:22:21,920
going to define that name

32290
21:22:21,920 --> 21:22:24,160
and i am going to put the code here in

32291
21:22:24,160 --> 21:22:26,400
the source file that includes me

32292
21:22:26,400 --> 21:22:29,040
if it happens to be already defined this

32293
21:22:29,040 --> 21:22:30,960
condition here is going to fail it's not

32294
21:22:30,960 --> 21:22:33,920
going to do any more than in this file

32295
21:22:33,920 --> 21:22:35,680
the preprocessor is basically going to

32296
21:22:35,680 --> 21:22:38,000
give up on this file here this is what i

32297
21:22:38,000 --> 21:22:40,720
want you to know so now we should be

32298
21:22:40,720 --> 21:22:43,280
able to split our code into multiple

32299
21:22:43,280 --> 21:22:45,760
files and now that i think about it we

32300
21:22:45,760 --> 21:22:47,120
don't really need to include the

32301
21:22:47,120 --> 21:22:49,120
constants header here because it's going

32302
21:22:49,120 --> 21:22:51,440
to be broadened by the cylinder class

32303
21:22:51,440 --> 21:22:53,680
but it was a good opportunity to teach

32304
21:22:53,680 --> 21:22:56,160
you about the include guards here now

32305
21:22:56,160 --> 21:22:57,680
that you notice we're going to remove

32306
21:22:57,680 --> 21:22:59,280
this and we're going to build and show

32307
21:22:59,280 --> 21:23:01,920
you that this is going to work anyway so

32308
21:23:01,920 --> 21:23:04,640
weld is good we can run our program

32309
21:23:04,640 --> 21:23:06,960
clear and run rooster this is going to

32310
21:23:06,960 --> 21:23:08,552
work the last thing i want to show you

32311
21:23:08,552 --> 21:23:11,760
is that we can go even further and split

32312
21:23:11,760 --> 21:23:14,800
our class into two separate files

32313
21:23:14,800 --> 21:23:16,872
because people who come to the header

32314
21:23:16,872 --> 21:23:19,920
file are usually interested in your

32315
21:23:19,920 --> 21:23:23,192
class definition they are really not

32316
21:23:23,192 --> 21:23:25,280
interested in your implementation

32317
21:23:25,280 --> 21:23:27,512
details for example they want to see

32318
21:23:27,512 --> 21:23:30,232
that you have a volume function and they

32319
21:23:30,232 --> 21:23:32,160
want to know that they can call that

32320
21:23:32,160 --> 21:23:34,400
function but they don't really want to

32321
21:23:34,400 --> 21:23:36,640
know how you compute your volume and we

32322
21:23:36,640 --> 21:23:38,640
can really make events simple for them

32323
21:23:38,640 --> 21:23:41,512
and hide the implementation details in a

32324
21:23:41,512 --> 21:23:44,160
separate cpp file so let's do that we're

32325
21:23:44,160 --> 21:23:46,232
going to set up a new cpp file we're

32326
21:23:46,232 --> 21:23:48,960
going to call this cylinder that's cpp

32327
21:23:48,960 --> 21:23:50,480
and we're going to

32328
21:23:50,480 --> 21:23:53,192
move the implementations

32329
21:23:53,192 --> 21:23:55,280
of our functions

32330
21:23:55,280 --> 21:23:58,800
in the cpp file and i am doing this just

32331
21:23:58,800 --> 21:24:01,192
to show you that it is possible in

32332
21:24:01,192 --> 21:24:02,872
practice you're going to have to decide

32333
21:24:02,872 --> 21:24:04,552
for yourself what you want to keep in

32334
21:24:04,552 --> 21:24:06,640
the header file and what you want to

32335
21:24:06,640 --> 21:24:09,920
keep in the cpp file so the cylinder

32336
21:24:09,920 --> 21:24:11,512
default constructor here is going to

32337
21:24:11,512 --> 21:24:14,320
stay this way but we can move the other

32338
21:24:14,320 --> 21:24:16,960
constructor here in the cpp file and the

32339
21:24:16,960 --> 21:24:18,800
way we do that we're going to just grab

32340
21:24:18,800 --> 21:24:20,800
this and i am going to change this line

32341
21:24:20,800 --> 21:24:23,120
by line so that you can see this

32342
21:24:23,120 --> 21:24:25,120
and in the cpp file the first thing we

32343
21:24:25,120 --> 21:24:27,600
want to do is to include the cylinder

32344
21:24:27,600 --> 21:24:30,000
header because the implementations here

32345
21:24:30,000 --> 21:24:32,640
are going to be using this

32346
21:24:32,640 --> 21:24:33,760
and we're going to put in our

32347
21:24:33,760 --> 21:24:36,720
constructor and modify it to be fit for

32348
21:24:36,720 --> 21:24:39,760
living in a cpp file so let's come here

32349
21:24:39,760 --> 21:24:42,480
and do that the way we tell this that

32350
21:24:42,480 --> 21:24:44,400
this is really an implementation of a

32351
21:24:44,400 --> 21:24:47,192
function we have in our header here is

32352
21:24:47,192 --> 21:24:49,040
to put the class name in front we're

32353
21:24:49,040 --> 21:24:50,960
going to say cylinder and put two

32354
21:24:50,960 --> 21:24:53,192
columns the moment we do that the

32355
21:24:53,192 --> 21:24:55,120
compiler is going to know that this is

32356
21:24:55,120 --> 21:24:58,000
an implementation of a function we have

32357
21:24:58,000 --> 21:24:59,680
in our header file and this is the

32358
21:24:59,680 --> 21:25:02,640
function here and now we can take out

32359
21:25:02,640 --> 21:25:05,192
the body here and live this as a

32360
21:25:05,192 --> 21:25:07,512
prototype for the function which is our

32361
21:25:07,512 --> 21:25:09,760
constructor view we can do this

32362
21:25:09,760 --> 21:25:12,232
okay if we do this in world the code is

32363
21:25:12,232 --> 21:25:13,920
going to world it's going to construct

32364
21:25:13,920 --> 21:25:16,960
our objects let's go back in main cpb

32365
21:25:16,960 --> 21:25:18,232
and make sure that that's the

32366
21:25:18,232 --> 21:25:20,960
constructor we are using it is we can

32367
21:25:20,960 --> 21:25:24,160
weld and make sure that what we just did

32368
21:25:24,160 --> 21:25:26,320
didn't break anything we are building

32369
21:25:26,320 --> 21:25:28,872
and we can clear things up a little bit

32370
21:25:28,872 --> 21:25:31,280
and run rooster this is going to give us

32371
21:25:31,280 --> 21:25:34,480
our volume and we have started to split

32372
21:25:34,480 --> 21:25:35,920
things up

32373
21:25:35,920 --> 21:25:38,000
in our class here some things are going

32374
21:25:38,000 --> 21:25:40,080
to leave in the header file some other

32375
21:25:40,080 --> 21:25:41,280
things are going to leave in the

32376
21:25:41,280 --> 21:25:43,760
implementation file so we have moved our

32377
21:25:43,760 --> 21:25:45,512
constructor here let's move the volume

32378
21:25:45,512 --> 21:25:47,512
function we can grab it and i move

32379
21:25:47,512 --> 21:25:49,680
things line by line i think this is the

32380
21:25:49,680 --> 21:25:51,512
best way to learn

32381
21:25:51,512 --> 21:25:53,920
and i think we can move this things a

32382
21:25:53,920 --> 21:25:56,640
little bit to the left let's do that and

32383
21:25:56,640 --> 21:25:58,400
we're going to say that this is a

32384
21:25:58,400 --> 21:26:01,040
function implementation for some

32385
21:26:01,040 --> 21:26:03,120
function that is declared in the class

32386
21:26:03,120 --> 21:26:05,600
here so we're going to say cylinder and

32387
21:26:05,600 --> 21:26:07,680
we're going to put two columns this is

32388
21:26:07,680 --> 21:26:09,360
going to tell the compiler this is an

32389
21:26:09,360 --> 21:26:12,400
implementation of the function we have

32390
21:26:12,400 --> 21:26:15,600
in our class and the return type has to

32391
21:26:15,600 --> 21:26:18,720
live in front of this scope resolution

32392
21:26:18,720 --> 21:26:21,280
operator okay what we have here cylinder

32393
21:26:21,280 --> 21:26:23,760
column column is called the scope

32394
21:26:23,760 --> 21:26:26,080
resolution operator and is basically

32395
21:26:26,080 --> 21:26:29,192
telling the compiler that our function

32396
21:26:29,192 --> 21:26:32,400
called volume leaves in the scope of the

32397
21:26:32,400 --> 21:26:34,800
cylinder class this is what the syntax

32398
21:26:34,800 --> 21:26:37,120
here is saying and this little thing

32399
21:26:37,120 --> 21:26:39,192
here is called a scope resolution

32400
21:26:39,192 --> 21:26:40,400
operator

32401
21:26:40,400 --> 21:26:42,720
okay so we have moved our volume

32402
21:26:42,720 --> 21:26:45,360
function we can now take the body out

32403
21:26:45,360 --> 21:26:48,000
from the class and keep the prototype

32404
21:26:48,000 --> 21:26:50,232
here we can go down and really practice

32405
21:26:50,232 --> 21:26:52,232
on the setters and gators so let's do

32406
21:26:52,232 --> 21:26:54,232
that so we're going to grab them all

32407
21:26:54,232 --> 21:26:56,640
together because now you have the gist

32408
21:26:56,640 --> 21:26:59,360
about how this works we can copy them

32409
21:26:59,360 --> 21:27:02,400
and move them into the cpp file and

32410
21:27:02,400 --> 21:27:04,232
we're going to fix the code lined by

32411
21:27:04,232 --> 21:27:07,120
line here so let's make sure they are

32412
21:27:07,120 --> 21:27:11,040
aligned properly we have two left to do

32413
21:27:11,040 --> 21:27:13,280
let's do that and i really have to show

32414
21:27:13,280 --> 21:27:15,280
you this life because some people are

32415
21:27:15,280 --> 21:27:18,160
going to have problems regarding how i

32416
21:27:18,160 --> 21:27:20,640
did this so i want you to see this live

32417
21:27:20,640 --> 21:27:23,192
as i do this i'm not going to edit this

32418
21:27:23,192 --> 21:27:25,440
out so we're going to put our scope

32419
21:27:25,440 --> 21:27:28,000
resolution operator after our return

32420
21:27:28,000 --> 21:27:30,000
type here i'm going to say cylinder

32421
21:27:30,000 --> 21:27:32,640
cylinder can't type can i okay we have

32422
21:27:32,640 --> 21:27:35,680
this in and we can really copy this and

32423
21:27:35,680 --> 21:27:37,760
paste this into place wherever it is

32424
21:27:37,760 --> 21:27:40,320
needed so i'm going to paste that here i

32425
21:27:40,320 --> 21:27:42,480
am going to paste that here and i am

32426
21:27:42,480 --> 21:27:44,960
going to paste that here now we have

32427
21:27:44,960 --> 21:27:47,440
successfully moved all the functions in

32428
21:27:47,440 --> 21:27:49,720
the implementation file

32429
21:27:49,720 --> 21:27:52,800
cylinder.cpp and we can go back in our

32430
21:27:52,800 --> 21:27:54,960
header and remove the bodies because we

32431
21:27:54,960 --> 21:27:57,360
don't need them here if we keep them

32432
21:27:57,360 --> 21:27:59,040
here we're going to have two definitions

32433
21:27:59,040 --> 21:28:00,960
for this functions and we're going to

32434
21:28:00,960 --> 21:28:03,680
have compiler errors let's take this out

32435
21:28:03,680 --> 21:28:05,440
we're going to take the body out we're

32436
21:28:05,440 --> 21:28:07,360
going to take the body out and we're

32437
21:28:07,360 --> 21:28:09,360
going to take the body out let's do that

32438
21:28:09,360 --> 21:28:11,920
for a gate base radius here

32439
21:28:11,920 --> 21:28:14,320
and now if we build our program it

32440
21:28:14,320 --> 21:28:17,120
should work we're going to work with gcc

32441
21:28:17,120 --> 21:28:19,040
see the world is good and if we try to

32442
21:28:19,040 --> 21:28:21,360
run the program it should give us what

32443
21:28:21,360 --> 21:28:23,680
it was given before this is the volume

32444
21:28:23,680 --> 21:28:24,480
here

32445
21:28:24,480 --> 21:28:26,720
one thing i want you to see is that you

32446
21:28:26,720 --> 21:28:29,760
don't want to keep two definitions for

32447
21:28:29,760 --> 21:28:32,320
your functions so for example we can

32448
21:28:32,320 --> 21:28:34,720
grab the body here and bring this back

32449
21:28:34,720 --> 21:28:36,400
in the header file i want you to see

32450
21:28:36,400 --> 21:28:38,400
what's going to happen if you do that i

32451
21:28:38,400 --> 21:28:41,192
am going to paste that in here and i am

32452
21:28:41,192 --> 21:28:43,192
going to move things a little bit to the

32453
21:28:43,192 --> 21:28:46,000
right to align things properly here so

32454
21:28:46,000 --> 21:28:48,320
if we do this the compiler is going to

32455
21:28:48,320 --> 21:28:51,192
see that we are calling that constructor

32456
21:28:51,192 --> 21:28:53,040
and the compiler is going to have no

32457
21:28:53,040 --> 21:28:55,360
problem with us but once we hit the

32458
21:28:55,360 --> 21:28:57,832
linker stage the linker is going to find

32459
21:28:57,832 --> 21:28:59,760
that we have two definitions for the

32460
21:28:59,760 --> 21:29:02,000
constructor here we have one in the

32461
21:29:02,000 --> 21:29:04,320
header and we have one in the

32462
21:29:04,320 --> 21:29:07,040
implementation file and this is going to

32463
21:29:07,040 --> 21:29:09,600
raise a compiler error saying we have

32464
21:29:09,600 --> 21:29:12,400
two definitions for the constructor here

32465
21:29:12,400 --> 21:29:14,960
and the linker want to know which one to

32466
21:29:14,960 --> 21:29:17,040
use so it's going to give you an error

32467
21:29:17,040 --> 21:29:18,800
let's build and really show you this

32468
21:29:18,800 --> 21:29:21,192
because this can be hard to debug if you

32469
21:29:21,192 --> 21:29:22,872
don't know what is happening okay you

32470
21:29:22,872 --> 21:29:25,920
see we have world finished with errors

32471
21:29:25,920 --> 21:29:28,720
and the problem is cylinder cylinder

32472
21:29:28,720 --> 21:29:31,280
double double is redefined we don't want

32473
21:29:31,280 --> 21:29:33,680
to have two definitions for the sum

32474
21:29:33,680 --> 21:29:36,232
function so once you move things from

32475
21:29:36,232 --> 21:29:39,040
header to implementation file be sure

32476
21:29:39,040 --> 21:29:41,600
you don't have any more definitions left

32477
21:29:41,600 --> 21:29:43,760
in the header or you're going to have

32478
21:29:43,760 --> 21:29:46,552
really hard to debug problems

32479
21:29:46,552 --> 21:29:49,440
and now i think we have our program

32480
21:29:49,440 --> 21:29:52,720
organized fairly well for what we know

32481
21:29:52,720 --> 21:29:55,600
so far about c plus plus we have our

32482
21:29:55,600 --> 21:29:58,720
constants living in another header file

32483
21:29:58,720 --> 21:30:00,872
and we have learnt about include cards

32484
21:30:00,872 --> 21:30:03,280
what we can use to guard against our

32485
21:30:03,280 --> 21:30:05,600
stuff being included more than once by

32486
21:30:05,600 --> 21:30:08,232
the preprocessor we have our cylinder

32487
21:30:08,232 --> 21:30:10,480
class living in its own file and again

32488
21:30:10,480 --> 21:30:12,552
we have an include guard here and you

32489
21:30:12,552 --> 21:30:14,640
can see that this class now is really

32490
21:30:14,640 --> 21:30:16,872
easy to look at we can look at the

32491
21:30:16,872 --> 21:30:18,872
information about the member functions

32492
21:30:18,872 --> 21:30:21,120
we have for example we have a default

32493
21:30:21,120 --> 21:30:23,192
constructor we have a constructor that

32494
21:30:23,192 --> 21:30:25,600
takes two parameters but we don't see

32495
21:30:25,600 --> 21:30:28,400
the details about how these things do

32496
21:30:28,400 --> 21:30:30,720
their jobs for example we don't see the

32497
21:30:30,720 --> 21:30:33,440
details about how the volume is computed

32498
21:30:33,440 --> 21:30:36,552
those details are hidden in the cpp file

32499
21:30:36,552 --> 21:30:38,400
and if you want to see them you need to

32500
21:30:38,400 --> 21:30:40,872
go to this implementation file here this

32501
21:30:40,872 --> 21:30:43,600
is a good design and i encourage to

32502
21:30:43,600 --> 21:30:46,160
split your c plus plus programs in

32503
21:30:46,160 --> 21:30:48,000
multiple files like this this is going

32504
21:30:48,000 --> 21:30:50,160
to make your life easier in this lecture

32505
21:30:50,160 --> 21:30:52,400
we're going to see how we can manage our

32506
21:30:52,400 --> 21:30:55,512
class objects through pointers and in

32507
21:30:55,512 --> 21:30:58,320
most cases we need to manage our class

32508
21:30:58,320 --> 21:31:01,192
object through pointers if we are using

32509
21:31:01,192 --> 21:31:04,160
some form of dynamic memory allocation

32510
21:31:04,160 --> 21:31:06,400
here is a simple example we have our

32511
21:31:06,400 --> 21:31:08,960
cylinder class included and down here

32512
21:31:08,960 --> 21:31:11,120
you see that we can create cylinder

32513
21:31:11,120 --> 21:31:13,360
objects on the stack if we use the

32514
21:31:13,360 --> 21:31:15,920
syntax like we do here the objects are

32515
21:31:15,920 --> 21:31:18,080
going to be created on the stack and we

32516
21:31:18,080 --> 21:31:20,080
have seen that we can access the

32517
21:31:20,080 --> 21:31:22,720
behaviors or data inside our class

32518
21:31:22,720 --> 21:31:25,512
object using the data notation like we

32519
21:31:25,512 --> 21:31:27,360
do here for example here we are calling

32520
21:31:27,360 --> 21:31:30,400
our volume function but sometimes we

32521
21:31:30,400 --> 21:31:32,480
want to manage our objects through

32522
21:31:32,480 --> 21:31:35,040
pointers for example if you look at the

32523
21:31:35,040 --> 21:31:37,440
syntax we have here we are saying

32524
21:31:37,440 --> 21:31:40,400
cylinder and using the asterisk here

32525
21:31:40,400 --> 21:31:42,320
this is going to say that this is going

32526
21:31:42,320 --> 21:31:45,280
to be a pointer to a cylinder type

32527
21:31:45,280 --> 21:31:47,360
and i'm going to give it a name c2 and

32528
21:31:47,360 --> 21:31:51,192
we can allocate our object on the heap

32529
21:31:51,192 --> 21:31:53,680
using the new operator this is going to

32530
21:31:53,680 --> 21:31:56,720
dynamically allocate space from the heap

32531
21:31:56,720 --> 21:31:58,720
and that memory space is going to be

32532
21:31:58,720 --> 21:32:02,800
used to store our cylinder object now

32533
21:32:02,800 --> 21:32:04,960
the interesting thing is going to happen

32534
21:32:04,960 --> 21:32:08,080
when you try to access behaviors from

32535
21:32:08,080 --> 21:32:10,872
your cylinder object here for example if

32536
21:32:10,872 --> 21:32:13,360
we look at this line here we are trying

32537
21:32:13,360 --> 21:32:16,400
to print the volume of this cylinder and

32538
21:32:16,400 --> 21:32:18,232
you notice that we have to go through

32539
21:32:18,232 --> 21:32:20,800
ugly dereferencing here we have to

32540
21:32:20,800 --> 21:32:24,320
dereference the object and then call our

32541
21:32:24,320 --> 21:32:27,440
method through the dot operator here but

32542
21:32:27,440 --> 21:32:29,360
what i want you to see is that we can

32543
21:32:29,360 --> 21:32:31,600
avoid this ugly the reference that we

32544
21:32:31,600 --> 21:32:34,320
are doing here and use the pointer

32545
21:32:34,320 --> 21:32:37,440
access notation this dash greater than

32546
21:32:37,440 --> 21:32:40,080
symbol you see here is going to allow us

32547
21:32:40,080 --> 21:32:42,800
to access stuff directly using the

32548
21:32:42,800 --> 21:32:45,680
pointer to an object that is dynamically

32549
21:32:45,680 --> 21:32:48,400
allocated on the hip okay after we are

32550
21:32:48,400 --> 21:32:51,280
done using our cylinder object remember

32551
21:32:51,280 --> 21:32:53,680
it is memory that was dynamically

32552
21:32:53,680 --> 21:32:55,832
allocated from the hip we have to

32553
21:32:55,832 --> 21:32:57,680
release the memory so that it can be

32554
21:32:57,680 --> 21:33:00,320
used by the operating system and we

32555
21:33:00,320 --> 21:33:02,552
release the memory using the delete

32556
21:33:02,552 --> 21:33:05,680
operator as we do here okay the idea i

32557
21:33:05,680 --> 21:33:07,600
wanted to introduce here is that we can

32558
21:33:07,600 --> 21:33:10,552
use players to manage our cylinder

32559
21:33:10,552 --> 21:33:12,960
objects and this is one way we can do

32560
21:33:12,960 --> 21:33:16,000
this and once we are using a pointer as

32561
21:33:16,000 --> 21:33:19,040
a handle to our cylinder object we can

32562
21:33:19,040 --> 21:33:22,552
use the pointer access operator here to

32563
21:33:22,552 --> 21:33:25,600
access stuff from our class objects

32564
21:33:25,600 --> 21:33:27,760
easily and another thing you should know

32565
21:33:27,760 --> 21:33:29,440
is that we can actually create a

32566
21:33:29,440 --> 21:33:32,232
cylinder object and store in the address

32567
21:33:32,232 --> 21:33:34,552
of objects that we have on the stack and

32568
21:33:34,552 --> 21:33:36,160
we're going to see this in a minute when

32569
21:33:36,160 --> 21:33:38,800
we hit visual studio code now that you

32570
21:33:38,800 --> 21:33:41,832
have an idea about this let's head over

32571
21:33:41,832 --> 21:33:43,512
to visual studio code and play with this

32572
21:33:43,512 --> 21:33:46,232
a little more okay here we are in our

32573
21:33:46,232 --> 21:33:48,800
working folder the current project is

32574
21:33:48,800 --> 21:33:51,440
managing class objects through pointers

32575
21:33:51,440 --> 21:33:54,160
we can see the entire name here and now

32576
21:33:54,160 --> 21:33:56,080
we're not going to grab our template

32577
21:33:56,080 --> 21:33:58,800
project because we want to start from

32578
21:33:58,800 --> 21:34:02,000
the project we had in this lecture on a

32579
21:34:02,000 --> 21:34:04,320
class across multiple files so we're

32580
21:34:04,320 --> 21:34:06,640
going to go in that project and grab

32581
21:34:06,640 --> 21:34:08,400
everything from there

32582
21:34:08,400 --> 21:34:10,552
except for the executable because we

32583
21:34:10,552 --> 21:34:12,480
obviously don't want this

32584
21:34:12,480 --> 21:34:14,400
and we're going to go in our current

32585
21:34:14,400 --> 21:34:17,192
project and paste in the code and this

32586
21:34:17,192 --> 21:34:18,640
is going to give us a good starting

32587
21:34:18,640 --> 21:34:21,512
point so we can grab this and open

32588
21:34:21,512 --> 21:34:23,760
this project in visual studio code it's

32589
21:34:23,760 --> 21:34:25,280
going to open the folder and we're going

32590
21:34:25,280 --> 21:34:27,360
to have everything we want to start

32591
21:34:27,360 --> 21:34:29,512
doing what we want to do in this lecture

32592
21:34:29,512 --> 21:34:32,640
here so now we should have access to our

32593
21:34:32,640 --> 21:34:35,512
cylinder class and if you look here we

32594
21:34:35,512 --> 21:34:38,160
have an object of cylinder type already

32595
21:34:38,160 --> 21:34:41,760
created by this line on liner number six

32596
21:34:41,760 --> 21:34:43,600
here and we have seen that we can use

32597
21:34:43,600 --> 21:34:46,640
the syntax like cylinder volume here

32598
21:34:46,640 --> 21:34:49,760
using the dot call operator to access

32599
21:34:49,760 --> 21:34:53,120
stuff from our class object and this is

32600
21:34:53,120 --> 21:34:54,960
going to work but we want to see that we

32601
21:34:54,960 --> 21:34:57,120
can use pointers to manage our object

32602
21:34:57,120 --> 21:34:59,192
here and the first thing i want you to

32603
21:34:59,192 --> 21:35:01,680
see is that we can manage a stack object

32604
21:35:01,680 --> 21:35:04,320
through pointers and to really show this

32605
21:35:04,320 --> 21:35:06,232
off let's set up a

32606
21:35:06,232 --> 21:35:07,832
another variable it's going to be a

32607
21:35:07,832 --> 21:35:10,640
cylinder pointer and it's going to be p

32608
21:35:10,640 --> 21:35:12,720
cylinder one it's going to be a pointer

32609
21:35:12,720 --> 21:35:15,280
to cylinder one here that's what i mean

32610
21:35:15,280 --> 21:35:18,080
and we can give it an address of

32611
21:35:18,080 --> 21:35:20,640
cylinder one as a value so we can do

32612
21:35:20,640 --> 21:35:22,960
that for example and put in the address

32613
21:35:22,960 --> 21:35:25,832
of operator and this is going to work

32614
21:35:25,832 --> 21:35:27,832
now we can go through our pointer here

32615
21:35:27,832 --> 21:35:30,552
and do stuff with this cylinder object

32616
21:35:30,552 --> 21:35:32,872
but the syntax is going to be pretty

32617
21:35:32,872 --> 21:35:35,440
ugly so for example let's try and print

32618
21:35:35,440 --> 21:35:37,512
the volume of our cylinder

32619
21:35:37,512 --> 21:35:40,552
we're going to say htdcl and say volume

32620
21:35:40,552 --> 21:35:42,800
can save that and we're going to have to

32621
21:35:42,800 --> 21:35:45,040
go through the dereference operator so

32622
21:35:45,040 --> 21:35:47,512
if we do something like p cylinder one

32623
21:35:47,512 --> 21:35:50,232
and try to use the dot operator

32624
21:35:50,232 --> 21:35:53,120
you're going to see that we have the

32625
21:35:53,120 --> 21:35:56,080
volume function but if we try to call it

32626
21:35:56,080 --> 21:35:59,120
let's do that let's make sure we are

32627
21:35:59,120 --> 21:36:01,600
using the dot operator here if we try to

32628
21:36:01,600 --> 21:36:03,832
compile this program it's not going to

32629
21:36:03,832 --> 21:36:05,512
compile because

32630
21:36:05,512 --> 21:36:08,160
we are trying to call stuff from a

32631
21:36:08,160 --> 21:36:11,120
pointer and remember a pointer is just

32632
21:36:11,120 --> 21:36:13,360
going to store an address it doesn't

32633
21:36:13,360 --> 21:36:16,000
really have information about the type

32634
21:36:16,000 --> 21:36:18,480
that it is pointing to if we try to

32635
21:36:18,480 --> 21:36:20,000
compile this program we're going to get

32636
21:36:20,000 --> 21:36:22,720
a compiler error so let's use gcc to do

32637
21:36:22,720 --> 21:36:23,680
that

32638
21:36:23,680 --> 21:36:25,600
and we're going to get request for

32639
21:36:25,600 --> 21:36:28,960
member volume in pc lender 1. remember p

32640
21:36:28,960 --> 21:36:31,512
cylinder 1 is just a pointer it's not an

32641
21:36:31,512 --> 21:36:33,680
object so we can't really call the

32642
21:36:33,680 --> 21:36:35,680
volume function to f

32643
21:36:35,680 --> 21:36:38,232
if we want to use the dot call operator

32644
21:36:38,232 --> 21:36:40,080
here we have to the reference and

32645
21:36:40,080 --> 21:36:42,320
actually get to the actual

32646
21:36:42,320 --> 21:36:45,120
object that the pointer is pointing to

32647
21:36:45,120 --> 21:36:47,600
and we do that using the star operator

32648
21:36:47,600 --> 21:36:49,280
you already know how to dereference a

32649
21:36:49,280 --> 21:36:51,192
pointer so we can dereference our

32650
21:36:51,192 --> 21:36:53,360
pointer and then call the volume

32651
21:36:53,360 --> 21:36:55,680
function on what the pointer is pointing

32652
21:36:55,680 --> 21:36:57,360
to and this is going to work it's going

32653
21:36:57,360 --> 21:37:00,160
to print out volume let's build now now

32654
21:37:00,160 --> 21:37:02,160
that we are dereferencing correctly and

32655
21:37:02,160 --> 21:37:04,160
you see that this is going to work and

32656
21:37:04,160 --> 21:37:07,120
if we try to print this let's bring up a

32657
21:37:07,120 --> 21:37:09,440
terminal so that we can run this program

32658
21:37:09,440 --> 21:37:11,360
let's run rooster you're going to see

32659
21:37:11,360 --> 21:37:14,000
that we have our volume here so to

32660
21:37:14,000 --> 21:37:17,280
really get to what is pointed to

32661
21:37:17,280 --> 21:37:19,360
you need to use the reference operator

32662
21:37:19,360 --> 21:37:21,192
and then call whatever method you want

32663
21:37:21,192 --> 21:37:23,832
to call on your object but we can do

32664
21:37:23,832 --> 21:37:26,160
things even easier there is a syntax we

32665
21:37:26,160 --> 21:37:28,960
can use to use the pointer directly here

32666
21:37:28,960 --> 21:37:30,960
because going through all this

32667
21:37:30,960 --> 21:37:33,280
dereferencing ugliness is really not

32668
21:37:33,280 --> 21:37:35,280
cool so we're going to grab this and

32669
21:37:35,280 --> 21:37:37,832
show you that we can use the dash

32670
21:37:37,832 --> 21:37:40,480
greater than operator that's how i

32671
21:37:40,480 --> 21:37:41,680
called it

32672
21:37:41,680 --> 21:37:44,160
and if we use that we don't need to the

32673
21:37:44,160 --> 21:37:45,440
reference

32674
21:37:45,440 --> 21:37:48,480
all we need to do is use the dash

32675
21:37:48,480 --> 21:37:50,960
greater than symbol here and it's going

32676
21:37:50,960 --> 21:37:51,680
to

32677
21:37:51,680 --> 21:37:54,720
directly tell the compiler don't code

32678
21:37:54,720 --> 21:37:57,192
stuff on the pointer directly do the

32679
21:37:57,192 --> 21:37:59,440
reference the pointer internally and

32680
21:37:59,440 --> 21:38:01,512
then call the volume function on

32681
21:38:01,512 --> 21:38:04,232
whatever you get after referencing so

32682
21:38:04,232 --> 21:38:07,280
this is basically going to push the the

32683
21:38:07,280 --> 21:38:09,600
referencing ugliness here behind the

32684
21:38:09,600 --> 21:38:12,552
curtains of the compiler and we can use

32685
21:38:12,552 --> 21:38:15,120
a nice syntax like this and i think this

32686
21:38:15,120 --> 21:38:17,440
is much better than what we were doing

32687
21:38:17,440 --> 21:38:19,832
here so if we try to bolt now we're

32688
21:38:19,832 --> 21:38:21,680
going to build and print our volume

32689
21:38:21,680 --> 21:38:23,280
you're going to see the bolt is good you

32690
21:38:23,280 --> 21:38:26,080
can clear and run rooster you see we see

32691
21:38:26,080 --> 21:38:28,400
our volume here so this is what i want

32692
21:38:28,400 --> 21:38:31,920
you to see it is possible to manage your

32693
21:38:31,920 --> 21:38:35,192
cylinder objects through pointers and

32694
21:38:35,192 --> 21:38:37,040
this is one way we can do this by

32695
21:38:37,040 --> 21:38:39,760
managing a stack object through pointers

32696
21:38:39,760 --> 21:38:41,832
and this is what we are doing here if

32697
21:38:41,832 --> 21:38:44,160
you want to call stuff on your class

32698
21:38:44,160 --> 21:38:47,192
object you can either do the ugly stuff

32699
21:38:47,192 --> 21:38:50,000
we do here or you can use the nice

32700
21:38:50,000 --> 21:38:52,640
pointer access operator and it is going

32701
21:38:52,640 --> 21:38:54,552
to be cool okay now that we have seen

32702
21:38:54,552 --> 21:38:57,120
this let's see another use case in which

32703
21:38:57,120 --> 21:38:59,440
we're going to be creating a cylinder

32704
21:38:59,440 --> 21:39:01,680
object on the heap through the new

32705
21:39:01,680 --> 21:39:03,832
operator okay we can go down and save

32706
21:39:03,832 --> 21:39:06,160
that we're going to say cylinder pointer

32707
21:39:06,160 --> 21:39:07,680
it's going to be p

32708
21:39:07,680 --> 21:39:10,720
c lender 2. we can call it like this and

32709
21:39:10,720 --> 21:39:12,720
then we're going to say new cylinder and

32710
21:39:12,720 --> 21:39:15,040
you're going to see that we can call a

32711
21:39:15,040 --> 21:39:16,400
constructor

32712
21:39:16,400 --> 21:39:19,040
we have two types of constructors we can

32713
21:39:19,040 --> 21:39:21,920
call we're going to call our constructor

32714
21:39:21,920 --> 21:39:24,160
that takes two parameters and we can

32715
21:39:24,160 --> 21:39:26,720
pass in 100 and

32716
21:39:26,720 --> 21:39:29,760
100 why not oh let's put the two after

32717
21:39:29,760 --> 21:39:31,832
here we can put in whatever we want this

32718
21:39:31,832 --> 21:39:34,552
is going to create a new cylinder object

32719
21:39:34,552 --> 21:39:36,480
the space for the cylinder object is

32720
21:39:36,480 --> 21:39:38,872
going to be allocated on the hip so this

32721
21:39:38,872 --> 21:39:41,360
is a hip object and because we are using

32722
21:39:41,360 --> 21:39:43,360
the new operator here

32723
21:39:43,360 --> 21:39:45,280
the other thing you should have in mind

32724
21:39:45,280 --> 21:39:47,280
is that you will need to release this

32725
21:39:47,280 --> 21:39:49,760
memory and let's go and do that directly

32726
21:39:49,760 --> 21:39:52,080
this is a good practice because you will

32727
21:39:52,080 --> 21:39:54,720
forget to release your memory if you

32728
21:39:54,720 --> 21:39:56,800
don't really keep this in mind so we are

32729
21:39:56,800 --> 21:39:59,280
going to delete p cylinder 2 because

32730
21:39:59,280 --> 21:40:02,480
that's what we used to allocate our hip

32731
21:40:02,480 --> 21:40:05,192
memory here okay now that we have taken

32732
21:40:05,192 --> 21:40:07,680
care of memory management we can go in

32733
21:40:07,680 --> 21:40:10,480
and use our p cylinder to object

32734
21:40:10,480 --> 21:40:12,720
and for example we can print its volume

32735
21:40:12,720 --> 21:40:16,872
by using the stdc out statement here so

32736
21:40:16,872 --> 21:40:18,872
let's go down and save that

32737
21:40:18,872 --> 21:40:21,120
let's align this properly and we're

32738
21:40:21,120 --> 21:40:22,960
going to say volume

32739
21:40:22,960 --> 21:40:25,280
cylinder 2 to really make this super

32740
21:40:25,280 --> 21:40:27,280
clear and then we're going to say p

32741
21:40:27,280 --> 21:40:28,720
cylinder 2

32742
21:40:28,720 --> 21:40:30,800
and call the volume function here this

32743
21:40:30,800 --> 21:40:33,920
is going to work let's draw in world the

32744
21:40:33,920 --> 21:40:36,640
world is good we can clear and run

32745
21:40:36,640 --> 21:40:38,800
rooster this is going to give us our

32746
21:40:38,800 --> 21:40:41,040
volume and if we try and use this

32747
21:40:41,040 --> 21:40:43,040
information to create a cylinder we're

32748
21:40:43,040 --> 21:40:45,040
going to see that the volume is what we

32749
21:40:45,040 --> 21:40:47,760
see here we can even try and print its

32750
21:40:47,760 --> 21:40:49,360
base radius

32751
21:40:49,360 --> 21:40:52,640
let's do that we're going to say sdd cl

32752
21:40:52,640 --> 21:40:54,640
we're going to say p cylinder 2 and

32753
21:40:54,640 --> 21:40:56,960
we're going to say base radius we can

32754
21:40:56,960 --> 21:40:59,040
hit the dot operator here you're going

32755
21:40:59,040 --> 21:41:01,192
to see we're going to have a few options

32756
21:41:01,192 --> 21:41:03,680
in a visual studio code here if we

32757
21:41:03,680 --> 21:41:05,920
double click on get base radius here

32758
21:41:05,920 --> 21:41:07,680
you're going to see that visual studio

32759
21:41:07,680 --> 21:41:09,920
code is going to use the pointer access

32760
21:41:09,920 --> 21:41:12,080
operator here and this is really cool so

32761
21:41:12,080 --> 21:41:14,872
we can hit std and yeah we can close the

32762
21:41:14,872 --> 21:41:17,832
left pane here because we need some more

32763
21:41:17,832 --> 21:41:20,480
breathing space and if we try to

32764
21:41:20,480 --> 21:41:23,440
build and run this program and we have a

32765
21:41:23,440 --> 21:41:26,320
compiler error here and the reason is

32766
21:41:26,320 --> 21:41:29,040
get base radius is a function

32767
21:41:29,040 --> 21:41:32,640
if we go back in our cylinder class we

32768
21:41:32,640 --> 21:41:34,480
see that we have a function called get

32769
21:41:34,480 --> 21:41:37,512
base radius so if we want to call this

32770
21:41:37,512 --> 21:41:39,760
in the main function we need to call

32771
21:41:39,760 --> 21:41:42,400
that as a function so we need to put a

32772
21:41:42,400 --> 21:41:45,120
pair of parentheses here and if we build

32773
21:41:45,120 --> 21:41:47,280
we should build without a problem let's

32774
21:41:47,280 --> 21:41:48,400
do that again

32775
21:41:48,400 --> 21:41:50,480
you see the build is good and if we run

32776
21:41:50,480 --> 21:41:52,320
the program we're going to see exactly

32777
21:41:52,320 --> 21:41:54,960
what we expect let's run a rooster we're

32778
21:41:54,960 --> 21:41:58,320
going to see what we expect here and the

32779
21:41:58,320 --> 21:42:01,040
message here was really that you can

32780
21:42:01,040 --> 21:42:02,720
manage your

32781
21:42:02,720 --> 21:42:06,160
class object through pointers one case

32782
21:42:06,160 --> 21:42:07,920
is when you have a pointer that is

32783
21:42:07,920 --> 21:42:10,080
pointing to a stack object and we saw

32784
21:42:10,080 --> 21:42:12,320
that we could do that here we can also

32785
21:42:12,320 --> 21:42:15,120
use pointer notation to allocate

32786
21:42:15,120 --> 21:42:17,512
objects on the heap and point to them

32787
21:42:17,512 --> 21:42:19,920
with our pointer here and whenever we

32788
21:42:19,920 --> 21:42:21,600
are using a pointer we have the option

32789
21:42:21,600 --> 21:42:24,552
to use the pointer call operator here to

32790
21:42:24,552 --> 21:42:26,872
do things easily i am going to be

32791
21:42:26,872 --> 21:42:29,360
calling this the pointer call operator

32792
21:42:29,360 --> 21:42:32,000
to mean this from here on if we happen

32793
21:42:32,000 --> 21:42:34,080
to need this and you should know what i

32794
21:42:34,080 --> 21:42:36,720
mean by that this is really all i set

32795
21:42:36,720 --> 21:42:38,640
out to share in this lecture i hope you

32796
21:42:38,640 --> 21:42:40,720
found it interesting we are going to

32797
21:42:40,720 --> 21:42:42,800
stop here in this lecture the next one

32798
21:42:42,800 --> 21:42:44,320
we're going to learn about these

32799
21:42:44,320 --> 21:42:45,680
structures

32800
21:42:45,680 --> 21:42:48,080
go ahead and finish up here and meet me

32801
21:42:48,080 --> 21:42:49,832
there in this lecture we're going to

32802
21:42:49,832 --> 21:42:52,080
learn about these structures these

32803
21:42:52,080 --> 21:42:54,872
structures are spatial functions or

32804
21:42:54,872 --> 21:42:57,192
methods in a class that are called by

32805
21:42:57,192 --> 21:43:00,480
the compiler to destroy your object and

32806
21:43:00,480 --> 21:43:03,360
these are going to be especially useful

32807
21:43:03,360 --> 21:43:06,080
if you are for example allocating memory

32808
21:43:06,080 --> 21:43:07,832
in your constructors

32809
21:43:07,832 --> 21:43:10,232
let's look at the simple example here we

32810
21:43:10,232 --> 21:43:13,192
have a class called dog it has two

32811
21:43:13,192 --> 21:43:15,440
sections the public section and the

32812
21:43:15,440 --> 21:43:18,320
private section in the public section we

32813
21:43:18,320 --> 21:43:20,080
have two constructors a default

32814
21:43:20,080 --> 21:43:22,000
constructor that doesn't take any

32815
21:43:22,000 --> 21:43:24,640
parameter and a constructor that takes

32816
21:43:24,640 --> 21:43:26,480
two parameters n

32817
21:43:26,480 --> 21:43:29,040
the parameters are going to be used to

32818
21:43:29,040 --> 21:43:31,680
initialize our member variables and they

32819
21:43:31,680 --> 21:43:33,360
are passed by a value here for

32820
21:43:33,360 --> 21:43:35,920
simplicity and they are going to be used

32821
21:43:35,920 --> 21:43:38,320
to initialize these member variables

32822
21:43:38,320 --> 21:43:41,440
doug name dog breed and dog age

32823
21:43:41,440 --> 21:43:43,360
the special thing about this class is

32824
21:43:43,360 --> 21:43:46,400
that it has a destructor and you declare

32825
21:43:46,400 --> 21:43:49,120
the destructor using this

32826
21:43:49,120 --> 21:43:51,832
syntax here he puts a tilde character in

32827
21:43:51,832 --> 21:43:53,832
front you say the name of the class and

32828
21:43:53,832 --> 21:43:56,640
then you put an empty parameter list it

32829
21:43:56,640 --> 21:43:59,120
is also possible to declare a destructor

32830
21:43:59,120 --> 21:44:01,920
and put in its entire body in the header

32831
21:44:01,920 --> 21:44:04,400
and this is the syntax to do this

32832
21:44:04,400 --> 21:44:05,920
inside the body you're going to do

32833
21:44:05,920 --> 21:44:08,552
whatever it is you need to destroy your

32834
21:44:08,552 --> 21:44:11,360
object for example if the class here is

32835
21:44:11,360 --> 21:44:12,960
allocating some memory in the

32836
21:44:12,960 --> 21:44:15,760
constructor the destructor is the best

32837
21:44:15,760 --> 21:44:17,920
place to release that and this is an

32838
21:44:17,920 --> 21:44:20,320
example of how you can do that here is a

32839
21:44:20,320 --> 21:44:23,192
more direct example of how we allocate

32840
21:44:23,192 --> 21:44:26,400
for dynamic memory in the constructor

32841
21:44:26,400 --> 21:44:28,320
and release that memory in the

32842
21:44:28,320 --> 21:44:30,640
destructor we have our three variables

32843
21:44:30,640 --> 21:44:33,760
but we have chosen to allocate

32844
21:44:33,760 --> 21:44:36,720
our dog edge variable on the heap using

32845
21:44:36,720 --> 21:44:39,680
dynamic memory allocation and after we

32846
21:44:39,680 --> 21:44:41,832
dynamically allocate a piece of memory

32847
21:44:41,832 --> 21:44:44,552
to store our age variable we're going to

32848
21:44:44,552 --> 21:44:46,400
set that to 0 because we are in a

32849
21:44:46,400 --> 21:44:49,280
constructor if we are using the three

32850
21:44:49,280 --> 21:44:52,480
parameter constructor here we might use

32851
21:44:52,480 --> 21:44:55,760
the past parameter to initialize our age

32852
21:44:55,760 --> 21:44:58,160
variable but the important thing here is

32853
21:44:58,160 --> 21:45:00,080
that it is being

32854
21:45:00,080 --> 21:45:03,192
dynamically educated memory on the hip

32855
21:45:03,192 --> 21:45:07,600
here and when our object dies we need to

32856
21:45:07,600 --> 21:45:10,160
remember to release that memory and the

32857
21:45:10,160 --> 21:45:12,800
destructor is the best place to release

32858
21:45:12,800 --> 21:45:14,800
that memory as you see here we say

32859
21:45:14,800 --> 21:45:17,920
delete dark age when our object dies and

32860
21:45:17,920 --> 21:45:20,080
the compiler is going to call this

32861
21:45:20,080 --> 21:45:22,400
function when it's about to kill the

32862
21:45:22,400 --> 21:45:23,440
object

32863
21:45:23,440 --> 21:45:27,120
so you might ask when are destructors

32864
21:45:27,120 --> 21:45:29,192
really called we are going to start by

32865
21:45:29,192 --> 21:45:31,920
looking at obvious cases here for

32866
21:45:31,920 --> 21:45:34,552
example when a local stack object goes

32867
21:45:34,552 --> 21:45:36,000
out of scope

32868
21:45:36,000 --> 21:45:37,760
the destructor is going to be called

32869
21:45:37,760 --> 21:45:40,000
because that object is going to be wiped

32870
21:45:40,000 --> 21:45:42,232
out from memory so this is an obvious

32871
21:45:42,232 --> 21:45:43,192
case

32872
21:45:43,192 --> 21:45:45,280
in which the compiler will need to call

32873
21:45:45,280 --> 21:45:48,552
a destructor also when a hip object is

32874
21:45:48,552 --> 21:45:51,192
released from memory using delete the

32875
21:45:51,192 --> 21:45:53,360
destructor is also going to be called

32876
21:45:53,360 --> 21:45:55,512
but there are some indirect ways in

32877
21:45:55,512 --> 21:45:57,832
which the structures are also called for

32878
21:45:57,832 --> 21:45:59,920
example when an object is passed by a

32879
21:45:59,920 --> 21:46:01,760
value to a function

32880
21:46:01,760 --> 21:46:04,720
this is going to call the destructor to

32881
21:46:04,720 --> 21:46:07,600
kill the object when the object goes out

32882
21:46:07,600 --> 21:46:10,232
of scope in the function because when an

32883
21:46:10,232 --> 21:46:12,000
object is passed by value we're going to

32884
21:46:12,000 --> 21:46:14,160
have a copy in the local scope of the

32885
21:46:14,160 --> 21:46:17,192
function and when the function exits

32886
21:46:17,192 --> 21:46:19,120
that local copy is going to be killed

32887
21:46:19,120 --> 21:46:20,552
and we're going to see an example of

32888
21:46:20,552 --> 21:46:23,120
that another case where you might have

32889
21:46:23,120 --> 21:46:25,360
the the structure called is when a local

32890
21:46:25,360 --> 21:46:27,832
object is returned from a function

32891
21:46:27,832 --> 21:46:30,080
another copy is going to be created to

32892
21:46:30,080 --> 21:46:32,720
be used outside the function and the

32893
21:46:32,720 --> 21:46:34,960
copy inside the function is going to be

32894
21:46:34,960 --> 21:46:37,360
killed but this is not guaranteed as

32895
21:46:37,360 --> 21:46:40,480
some compiler may optimize your return

32896
21:46:40,480 --> 21:46:43,192
value and use some kind of reference so

32897
21:46:43,192 --> 21:46:44,640
you're not guaranteed to see this

32898
21:46:44,640 --> 21:46:47,440
behavior but it is possible to see it

32899
21:46:47,440 --> 21:46:49,360
now that you have an idea about

32900
21:46:49,360 --> 21:46:52,000
destructors it's time we headed over to

32901
21:46:52,000 --> 21:46:54,160
visual studio code and play with us a

32902
21:46:54,160 --> 21:46:56,800
little more okay here we are in our

32903
21:46:56,800 --> 21:46:58,960
working folder the current project is

32904
21:46:58,960 --> 21:47:00,960
the structures we're going to grab our

32905
21:47:00,960 --> 21:47:02,872
template files pretty quick and we're

32906
21:47:02,872 --> 21:47:05,192
going to put them in place and after

32907
21:47:05,192 --> 21:47:07,512
that we're going to open our folder in

32908
21:47:07,512 --> 21:47:09,512
visual studio code by dragging and

32909
21:47:09,512 --> 21:47:12,320
dropping here this is going to open our

32910
21:47:12,320 --> 21:47:15,440
folder and we will see our main cpp file

32911
21:47:15,440 --> 21:47:18,232
here we can open it and i clean up and

32912
21:47:18,232 --> 21:47:20,552
remove what we don't need we have an

32913
21:47:20,552 --> 21:47:22,960
unneeded breakpoint here we can remove

32914
21:47:22,960 --> 21:47:24,872
that and we're going to clean up the

32915
21:47:24,872 --> 21:47:26,720
main function the first thing we want to

32916
21:47:26,720 --> 21:47:29,680
do is to put in our dog class i am going

32917
21:47:29,680 --> 21:47:32,320
to just put this in here because i don't

32918
21:47:32,320 --> 21:47:34,080
want you to watch me type all this

32919
21:47:34,080 --> 21:47:36,160
that's just going to waste your time we

32920
21:47:36,160 --> 21:47:38,320
have two sections in the dog class we

32921
21:47:38,320 --> 21:47:40,800
have a public section which is going to

32922
21:47:40,800 --> 21:47:43,440
now contain our constructors and we have

32923
21:47:43,440 --> 21:47:45,040
a private section which is going to

32924
21:47:45,040 --> 21:47:47,360
contain three member variables we have

32925
21:47:47,360 --> 21:47:49,760
two strengths one for the name and the

32926
21:47:49,760 --> 21:47:52,080
other for the breed of our dog and we

32927
21:47:52,080 --> 21:47:54,320
have another one which is an end pointer

32928
21:47:54,320 --> 21:47:56,232
which is going to store the edge of the

32929
21:47:56,232 --> 21:47:59,040
dog and you see that this is initialized

32930
21:47:59,040 --> 21:48:00,800
to no pointer one thing you should

32931
21:48:00,800 --> 21:48:03,512
notice is that for our parameter taken

32932
21:48:03,512 --> 21:48:06,232
constructor we are passing the string

32933
21:48:06,232 --> 21:48:09,192
information here using string views to

32934
21:48:09,192 --> 21:48:12,640
avoid copies with the std string view

32935
21:48:12,640 --> 21:48:14,320
type you already know this because we

32936
21:48:14,320 --> 21:48:16,320
learned about this but for this to work

32937
21:48:16,320 --> 21:48:18,552
we will need to include a string view so

32938
21:48:18,552 --> 21:48:20,872
let's do that and now we have our class

32939
21:48:20,872 --> 21:48:23,440
and we can use it however we want

32940
21:48:23,440 --> 21:48:26,320
so but before we do we need to put in

32941
21:48:26,320 --> 21:48:29,192
the implementations for these functions

32942
21:48:29,192 --> 21:48:31,192
one way we can do that is do that

32943
21:48:31,192 --> 21:48:33,600
directly in the function here but i want

32944
21:48:33,600 --> 21:48:35,920
you to see that you can also do that

32945
21:48:35,920 --> 21:48:38,400
directly outside the class here i don't

32946
21:48:38,400 --> 21:48:40,160
think i have shown you this but it is

32947
21:48:40,160 --> 21:48:42,080
possible to do that so we're going to

32948
21:48:42,080 --> 21:48:44,872
grab the prototype for our constructor

32949
21:48:44,872 --> 21:48:47,832
and say the scope resolution operator

32950
21:48:47,832 --> 21:48:49,920
and we're going to just paste in what we

32951
21:48:49,920 --> 21:48:52,480
have copied which is the prototype here

32952
21:48:52,480 --> 21:48:54,552
and we're going to go inside put in our

32953
21:48:54,552 --> 21:48:56,232
body and in the body we're going to

32954
21:48:56,232 --> 21:48:59,040
initialize these three guys

32955
21:48:59,040 --> 21:49:01,040
so the name is going to be initialized

32956
21:49:01,040 --> 21:49:03,680
to nem param and the bridge is going to

32957
21:49:03,680 --> 21:49:06,720
be initialized to breed the param we can

32958
21:49:06,720 --> 21:49:09,440
do that and the age is going to be

32959
21:49:09,440 --> 21:49:12,552
dynamically allocated from the hip you

32960
21:49:12,552 --> 21:49:14,480
see that it is a pointer so we're going

32961
21:49:14,480 --> 21:49:17,440
to say ph equals new and because we're

32962
21:49:17,440 --> 21:49:20,720
going to allocate dynamic space to store

32963
21:49:20,720 --> 21:49:23,440
an end and we're going to put data in

32964
21:49:23,440 --> 21:49:26,400
using our good old dereference operator

32965
21:49:26,400 --> 21:49:28,160
we're going to say ph

32966
21:49:28,160 --> 21:49:31,600
equals whatever ph parameter they passed

32967
21:49:31,600 --> 21:49:33,360
and i think we should say edge here

32968
21:49:33,360 --> 21:49:35,192
because it's not a pointer so we're

32969
21:49:35,192 --> 21:49:37,600
going to say age i think this is going

32970
21:49:37,600 --> 21:49:40,552
to do better age param this is probably

32971
21:49:40,552 --> 21:49:42,080
going to be better and we're going to

32972
21:49:42,080 --> 21:49:45,040
say age param okay so now we have our

32973
21:49:45,040 --> 21:49:48,160
constructor n and it's going to allocate

32974
21:49:48,160 --> 21:49:50,552
memory from the heap and we're going to

32975
21:49:50,552 --> 21:49:53,680
put data in that new memory location

32976
21:49:53,680 --> 21:49:56,320
that has just been allocated to our

32977
21:49:56,320 --> 21:49:58,552
class here so this is our class and we

32978
21:49:58,552 --> 21:50:00,160
can go in the main function and really

32979
21:50:00,160 --> 21:50:02,800
use it however we want for example we

32980
21:50:02,800 --> 21:50:05,040
can set up a dog object so we're going

32981
21:50:05,040 --> 21:50:07,360
to say my dog and we're going to give it

32982
21:50:07,360 --> 21:50:09,360
a name the name is going to be fluffy

32983
21:50:09,360 --> 21:50:12,320
and we're going to put the breed in and

32984
21:50:12,320 --> 21:50:14,232
it's going to just be a shepherd and

32985
21:50:14,232 --> 21:50:16,232
we're going to put in the age which is

32986
21:50:16,232 --> 21:50:18,720
going to be for example a 2. let's say

32987
21:50:18,720 --> 21:50:20,800
our dog is 2 years old

32988
21:50:20,800 --> 21:50:22,872
this is valid c plus plus code it's

32989
21:50:22,872 --> 21:50:25,120
going to be setting up an object of our

32990
21:50:25,120 --> 21:50:27,832
class here and we can world to see that

32991
21:50:27,832 --> 21:50:29,760
this program is going to world without a

32992
21:50:29,760 --> 21:50:32,480
problem so both is good but if we run

32993
21:50:32,480 --> 21:50:34,000
the program we're not going to see

32994
21:50:34,000 --> 21:50:36,720
anything but we don't really need to see

32995
21:50:36,720 --> 21:50:38,552
our constructor here called because we

32996
21:50:38,552 --> 21:50:40,872
already know about constructors what we

32997
21:50:40,872 --> 21:50:43,192
want to learn about are these structures

32998
21:50:43,192 --> 21:50:45,920
and these are spatial methods that are

32999
21:50:45,920 --> 21:50:48,552
called by the compiler when your object

33000
21:50:48,552 --> 21:50:51,120
dies let's set up a destructor and see

33001
21:50:51,120 --> 21:50:54,080
it called when our dog objects die the

33002
21:50:54,080 --> 21:50:56,480
syntax to do that is to use the tilde

33003
21:50:56,480 --> 21:50:58,400
character here you're going to say the

33004
21:50:58,400 --> 21:51:00,080
name of the class you're going to put an

33005
21:51:00,080 --> 21:51:02,320
empty parameter list and if you want you

33006
21:51:02,320 --> 21:51:04,720
can put a body and do whatever you want

33007
21:51:04,720 --> 21:51:07,040
to do in the body of your destructor

33008
21:51:07,040 --> 21:51:10,232
here but again we're going to move the

33009
21:51:10,232 --> 21:51:13,120
entire definition of the destructor to

33010
21:51:13,120 --> 21:51:15,920
the outside so let's go down and save

33011
21:51:15,920 --> 21:51:17,600
that we're going to say the scope

33012
21:51:17,600 --> 21:51:19,280
resolution operator we're going to say

33013
21:51:19,280 --> 21:51:21,920
dog and we're going to put in our body

33014
21:51:21,920 --> 21:51:24,720
and the first thing we want to do in our

33015
21:51:24,720 --> 21:51:27,920
destructor is to release this memory

33016
21:51:27,920 --> 21:51:31,280
that was dynamically allocated for us if

33017
21:51:31,280 --> 21:51:33,440
we don't release it when this dark

33018
21:51:33,440 --> 21:51:35,832
object dies we're going to link memory

33019
21:51:35,832 --> 21:51:37,832
and that's really bad so let's do that

33020
21:51:37,832 --> 21:51:39,680
directly in the destructor we can say

33021
21:51:39,680 --> 21:51:42,872
delete and say ph this is going to

33022
21:51:42,872 --> 21:51:45,440
release the memory that was allocated in

33023
21:51:45,440 --> 21:51:48,080
the constructor here and we have access

33024
21:51:48,080 --> 21:51:51,120
to this ph variable because the

33025
21:51:51,120 --> 21:51:54,320
destructor is part of our class

33026
21:51:54,320 --> 21:51:56,640
any member function of your class is

33027
21:51:56,640 --> 21:51:58,640
going to have access to any member

33028
21:51:58,640 --> 21:52:00,960
variable even if it happens to be

33029
21:52:00,960 --> 21:52:02,080
private

33030
21:52:02,080 --> 21:52:05,040
okay so we forgot our tilde character

33031
21:52:05,040 --> 21:52:07,600
let's put that in here and this is going

33032
21:52:07,600 --> 21:52:10,080
to be valid c plus plus code but to

33033
21:52:10,080 --> 21:52:12,480
really see things happening here let's

33034
21:52:12,480 --> 21:52:14,800
put in an sddc out statement we're going

33035
21:52:14,800 --> 21:52:17,280
to say doug destructor called 4 and

33036
21:52:17,280 --> 21:52:19,040
we're going to say the name of the dog

33037
21:52:19,040 --> 21:52:21,040
let's say name and we're going to say

33038
21:52:21,040 --> 21:52:23,192
the same thing in the constructor we're

33039
21:52:23,192 --> 21:52:26,160
going to say hddcl and say dog

33040
21:52:26,160 --> 21:52:29,280
constructor cold for and we're going to

33041
21:52:29,280 --> 21:52:31,360
say the dog name going to use our member

33042
21:52:31,360 --> 21:52:33,680
variable and now we have our thing in

33043
21:52:33,680 --> 21:52:36,480
place we have the destructor declared in

33044
21:52:36,480 --> 21:52:39,120
the class definition and this is the

33045
21:52:39,120 --> 21:52:41,192
syntax again this is what we really want

33046
21:52:41,192 --> 21:52:43,192
to learn about in this lecture we have

33047
21:52:43,192 --> 21:52:45,440
the tilde character we have the class

33048
21:52:45,440 --> 21:52:48,480
name and we put an empty parameter list

33049
21:52:48,480 --> 21:52:50,800
let me tell you that it is not possible

33050
21:52:50,800 --> 21:52:53,760
to pass parameters to your destructor if

33051
21:52:53,760 --> 21:52:54,872
you do that you're going to get a

33052
21:52:54,872 --> 21:52:57,360
compiler error the structures will

33053
21:52:57,360 --> 21:53:00,872
always have no parameters in c plus plus

33054
21:53:00,872 --> 21:53:03,512
here we have the definition of our

33055
21:53:03,512 --> 21:53:05,760
destructor and it is going to release

33056
21:53:05,760 --> 21:53:07,760
whatever memory we have dynamically

33057
21:53:07,760 --> 21:53:10,480
allocated from the constructor here if

33058
21:53:10,480 --> 21:53:12,400
we run this program

33059
21:53:12,400 --> 21:53:14,000
we're going to see our constructor

33060
21:53:14,000 --> 21:53:16,552
called as a result of this line here

33061
21:53:16,552 --> 21:53:19,512
because we are constructing a dog object

33062
21:53:19,512 --> 21:53:20,960
and we're going to see the destructor

33063
21:53:20,960 --> 21:53:22,872
called when the main function is about

33064
21:53:22,872 --> 21:53:24,000
to end

33065
21:53:24,000 --> 21:53:26,160
let's put an stdc out state to mention

33066
21:53:26,160 --> 21:53:28,320
the main function here and say done just

33067
21:53:28,320 --> 21:53:31,040
to prove that we have hit the end of our

33068
21:53:31,040 --> 21:53:32,720
main function here i think this is

33069
21:53:32,720 --> 21:53:35,280
useful and we're going to build so let's

33070
21:53:35,280 --> 21:53:37,920
do that we're going to build with gcc

33071
21:53:37,920 --> 21:53:39,440
you're going to see that the world is

33072
21:53:39,440 --> 21:53:42,080
good so we can clear and run or program

33073
21:53:42,080 --> 21:53:44,872
let's hit enter here and clear and run

33074
21:53:44,872 --> 21:53:46,720
rooster you're going to see that the

33075
21:53:46,720 --> 21:53:49,192
constructor was called we are going to

33076
21:53:49,192 --> 21:53:52,000
say done when the main function is about

33077
21:53:52,000 --> 21:53:54,872
to end but before the main function ends

33078
21:53:54,872 --> 21:53:57,832
we're going to destroy any stack data

33079
21:53:57,832 --> 21:53:59,920
that we have in the main function and

33080
21:53:59,920 --> 21:54:02,720
our dog object is on the stats so it's

33081
21:54:02,720 --> 21:54:05,040
going to be destroyed as part of that

33082
21:54:05,040 --> 21:54:07,600
process and the destructor for dog is

33083
21:54:07,600 --> 21:54:09,512
going to be called and we're going to

33084
21:54:09,512 --> 21:54:11,512
release our memory and we're going to

33085
21:54:11,512 --> 21:54:13,760
say that dog destructor was called for

33086
21:54:13,760 --> 21:54:15,120
whatever name

33087
21:54:15,120 --> 21:54:18,320
we have assigned to our dog here so this

33088
21:54:18,320 --> 21:54:21,440
is how destructors are called when your

33089
21:54:21,440 --> 21:54:23,512
objects are killed

33090
21:54:23,512 --> 21:54:26,960
and we didn't put in the correct name

33091
21:54:26,960 --> 21:54:29,832
we said fluffy let's say fluffy because

33092
21:54:29,832 --> 21:54:31,600
that's what i wanted and now you see

33093
21:54:31,600 --> 21:54:33,680
that our destructor is really being

33094
21:54:33,680 --> 21:54:35,920
called and releasing memory however we

33095
21:54:35,920 --> 21:54:38,232
want but we can also go a little further

33096
21:54:38,232 --> 21:54:40,872
and show you another example of a case

33097
21:54:40,872 --> 21:54:42,872
where the structures are called and

33098
21:54:42,872 --> 21:54:45,360
we're going to look at a function that

33099
21:54:45,360 --> 21:54:47,760
sets up a local object of a dog we're

33100
21:54:47,760 --> 21:54:49,600
going to see the dog constructed and

33101
21:54:49,600 --> 21:54:51,920
we're going to see it destroyed when the

33102
21:54:51,920 --> 21:54:54,552
function is about to end let's do that

33103
21:54:54,552 --> 21:54:56,552
we're going to say void some funk and

33104
21:54:56,552 --> 21:54:58,552
it's going to be just some function to

33105
21:54:58,552 --> 21:55:00,720
play with us we're going to

33106
21:55:00,720 --> 21:55:04,160
move our dog declaration in some funk

33107
21:55:04,160 --> 21:55:05,192
here

33108
21:55:05,192 --> 21:55:07,120
and this is really it we're going to

33109
21:55:07,120 --> 21:55:08,720
call this function

33110
21:55:08,720 --> 21:55:10,080
and when we call it we're going to

33111
21:55:10,080 --> 21:55:12,160
construct the object here when the

33112
21:55:12,160 --> 21:55:14,400
function is about to end the compiler is

33113
21:55:14,400 --> 21:55:15,920
going to call the destructor because

33114
21:55:15,920 --> 21:55:18,160
it's going to destroy this object here

33115
21:55:18,160 --> 21:55:19,600
and we're going to see the destructor

33116
21:55:19,600 --> 21:55:22,552
called by that point the some funk

33117
21:55:22,552 --> 21:55:24,480
function is going to be popped off the

33118
21:55:24,480 --> 21:55:26,400
top of the stack we're going to hit the

33119
21:55:26,400 --> 21:55:27,920
main function here and we're going to

33120
21:55:27,920 --> 21:55:30,800
say done and the program is going to end

33121
21:55:30,800 --> 21:55:32,872
let's call some funky name here so we're

33122
21:55:32,872 --> 21:55:34,720
going to say some funk and we're going

33123
21:55:34,720 --> 21:55:37,440
to world to really see this happening so

33124
21:55:37,440 --> 21:55:39,832
we have worked successfully we can clear

33125
21:55:39,832 --> 21:55:41,920
clear properly and run rooster we're

33126
21:55:41,920 --> 21:55:44,000
going to see constructor called for

33127
21:55:44,000 --> 21:55:46,400
fluffy the structure called for fluffy

33128
21:55:46,400 --> 21:55:48,720
and you see done we have hit the main

33129
21:55:48,720 --> 21:55:51,440
function and really finished executing

33130
21:55:51,440 --> 21:55:54,000
our program here we can even see this

33131
21:55:54,000 --> 21:55:56,080
through the debugger we're going to set

33132
21:55:56,080 --> 21:55:59,192
up three break points one in the main

33133
21:55:59,192 --> 21:56:01,360
function here before we call the some

33134
21:56:01,360 --> 21:56:03,192
funk function we're going to set up

33135
21:56:03,192 --> 21:56:06,232
another one in our destructor before we

33136
21:56:06,232 --> 21:56:08,320
print the message here and we're going

33137
21:56:08,320 --> 21:56:11,040
to put another one in the constructor

33138
21:56:11,040 --> 21:56:13,360
when we are about to print this message

33139
21:56:13,360 --> 21:56:16,480
here on line 20. after we set up these

33140
21:56:16,480 --> 21:56:19,280
break points we kind of kill the

33141
21:56:19,280 --> 21:56:22,480
terminal here and minimize a little bit

33142
21:56:22,480 --> 21:56:24,800
let's kill these things here so that we

33143
21:56:24,800 --> 21:56:27,440
have a clean ah we have a lot of windows

33144
21:56:27,440 --> 21:56:30,480
here okay we have our editor here

33145
21:56:30,480 --> 21:56:34,160
and now if we go to the tab here that

33146
21:56:34,160 --> 21:56:37,120
says start or run we're going to be able

33147
21:56:37,120 --> 21:56:39,440
to click the green button here to start

33148
21:56:39,440 --> 21:56:42,080
our debugging session we are going to

33149
21:56:42,080 --> 21:56:44,320
have a terminal here so let's bring that

33150
21:56:44,320 --> 21:56:46,400
to the side so that we can see things

33151
21:56:46,400 --> 21:56:49,760
printed out nicely let's do like this

33152
21:56:49,760 --> 21:56:52,160
and now we have hit the break point in

33153
21:56:52,160 --> 21:56:54,640
the main function we can step into

33154
21:56:54,640 --> 21:56:56,800
the sum func function and we're going to

33155
21:56:56,800 --> 21:56:59,760
do that using the step into button here

33156
21:56:59,760 --> 21:57:01,440
let's click that we're going to jump

33157
21:57:01,440 --> 21:57:03,512
into some funk

33158
21:57:03,512 --> 21:57:06,160
now we have the option to step into but

33159
21:57:06,160 --> 21:57:09,512
this is going to jump us into the logic

33160
21:57:09,512 --> 21:57:12,552
of transforming the string literal here

33161
21:57:12,552 --> 21:57:15,040
into a string view because if you see

33162
21:57:15,040 --> 21:57:16,960
the constructor is going to take string

33163
21:57:16,960 --> 21:57:19,192
view parameters we can actually see this

33164
21:57:19,192 --> 21:57:20,400
let's try

33165
21:57:20,400 --> 21:57:22,232
and hit the step into button you see

33166
21:57:22,232 --> 21:57:24,872
that we are in the string view class and

33167
21:57:24,872 --> 21:57:27,512
we don't really want this so let's step

33168
21:57:27,512 --> 21:57:30,872
out and we're going to step over this

33169
21:57:30,872 --> 21:57:32,960
so that we can hit the next breakpoint

33170
21:57:32,960 --> 21:57:35,040
and you see the next breakpoint is in

33171
21:57:35,040 --> 21:57:38,400
our constructor and this proves that the

33172
21:57:38,400 --> 21:57:39,760
compiler is going to call our

33173
21:57:39,760 --> 21:57:42,800
constructor here to build our object

33174
21:57:42,800 --> 21:57:45,040
if we step over this we're going to

33175
21:57:45,040 --> 21:57:47,600
print the message from the constructor

33176
21:57:47,600 --> 21:57:50,000
and if we keep going we're going to get

33177
21:57:50,000 --> 21:57:51,120
out of

33178
21:57:51,120 --> 21:57:54,000
our constructor and you see where this

33179
21:57:54,000 --> 21:57:55,680
is going to go this is going to go in

33180
21:57:55,680 --> 21:57:58,480
the destructor because before we leave

33181
21:57:58,480 --> 21:58:01,512
the some func function our dot objects

33182
21:58:01,512 --> 21:58:03,600
is going to be destroyed so we're going

33183
21:58:03,600 --> 21:58:05,832
to release our memory and we're going to

33184
21:58:05,832 --> 21:58:08,800
branch the message from our constructor

33185
21:58:08,800 --> 21:58:12,000
and if we hit next and a step out of

33186
21:58:12,000 --> 21:58:14,080
this i think we can do that because this

33187
21:58:14,080 --> 21:58:16,400
is logic we don't want we're going to

33188
21:58:16,400 --> 21:58:19,920
try and step over this and now if we hit

33189
21:58:19,920 --> 21:58:22,000
next we're going to come back in some

33190
21:58:22,000 --> 21:58:24,080
funk and some funk is already going to

33191
21:58:24,080 --> 21:58:26,320
be finished and if we hit next we're

33192
21:58:26,320 --> 21:58:27,832
going to come back in main and we're

33193
21:58:27,832 --> 21:58:30,320
going to print done and the program is

33194
21:58:30,320 --> 21:58:32,720
basically going to be done hopefully you

33195
21:58:32,720 --> 21:58:34,080
can see that

33196
21:58:34,080 --> 21:58:36,552
the compiler is going to call our

33197
21:58:36,552 --> 21:58:39,360
destructor after it leaves some funk

33198
21:58:39,360 --> 21:58:41,512
here because it's going to be destroying

33199
21:58:41,512 --> 21:58:44,320
the local object that we have inside

33200
21:58:44,320 --> 21:58:46,720
some funk here so this is one case where

33201
21:58:46,720 --> 21:58:48,640
the destructor is going to be called by

33202
21:58:48,640 --> 21:58:51,512
the compiler and it is if you have a

33203
21:58:51,512 --> 21:58:54,720
local object that needs to be destroyed

33204
21:58:54,720 --> 21:58:57,280
when function scope finishes another

33205
21:58:57,280 --> 21:59:00,232
case where the destructor may be called

33206
21:59:00,232 --> 21:59:02,000
is if you pass

33207
21:59:02,000 --> 21:59:02,800
a

33208
21:59:02,800 --> 21:59:04,400
class object

33209
21:59:04,400 --> 21:59:07,512
parameter by value so let's change some

33210
21:59:07,512 --> 21:59:09,512
function here and make it take something

33211
21:59:09,512 --> 21:59:11,512
by value so we're going to pass a dog

33212
21:59:11,512 --> 21:59:14,480
inside and we're going to say dog param

33213
21:59:14,480 --> 21:59:16,480
this is going to do okay now that we

33214
21:59:16,480 --> 21:59:18,960
have changed some func here we can

33215
21:59:18,960 --> 21:59:21,040
really do all kinds of crazy things with

33216
21:59:21,040 --> 21:59:22,960
it for example we can set up our dog

33217
21:59:22,960 --> 21:59:26,000
object inside our main function here so

33218
21:59:26,000 --> 21:59:29,440
let's do that we can say dog and dog the

33219
21:59:29,440 --> 21:59:31,600
variable name is going to be dog we can

33220
21:59:31,600 --> 21:59:32,872
give it

33221
21:59:32,872 --> 21:59:35,192
a name which is going to be fluffy it's

33222
21:59:35,192 --> 21:59:37,440
going to have a breed of shepherd and we

33223
21:59:37,440 --> 21:59:39,600
can give it the age of 2 like we have

33224
21:59:39,600 --> 21:59:42,080
been doing all along we can call our

33225
21:59:42,080 --> 21:59:45,280
function with the dog object here but be

33226
21:59:45,280 --> 21:59:47,192
careful about what is going to happen

33227
21:59:47,192 --> 21:59:49,360
here when we do something like this

33228
21:59:49,360 --> 21:59:51,680
we're going to be passing by value and

33229
21:59:51,680 --> 21:59:53,600
the compiler is going to see that it

33230
21:59:53,600 --> 21:59:56,720
needs to copy a dog object

33231
21:59:56,720 --> 21:59:59,680
now we haven't really told our class

33232
21:59:59,680 --> 22:00:03,120
here how to copy dog objects and we do

33233
22:00:03,120 --> 22:00:05,360
that through constructors we call copy

33234
22:00:05,360 --> 22:00:07,680
constructors we haven't really learned

33235
22:00:07,680 --> 22:00:09,512
about yet but what the compiler is going

33236
22:00:09,512 --> 22:00:12,160
to do by default is copy these things

33237
22:00:12,160 --> 22:00:14,720
member by member so it's going to set up

33238
22:00:14,720 --> 22:00:16,872
a doug copy object which is going to be

33239
22:00:16,872 --> 22:00:20,000
initialized with empty strings and a

33240
22:00:20,000 --> 22:00:22,232
null pointer here and then it's going to

33241
22:00:22,232 --> 22:00:25,120
copy from our dog object

33242
22:00:25,120 --> 22:00:27,192
that we have here it's going to take the

33243
22:00:27,192 --> 22:00:29,600
name and copy that in the name member

33244
22:00:29,600 --> 22:00:31,920
variable of our dark copy it's going to

33245
22:00:31,920 --> 22:00:34,480
take the breed and copy that n in the

33246
22:00:34,480 --> 22:00:36,552
second member variable here and it's

33247
22:00:36,552 --> 22:00:38,960
going to take the age from our dog and

33248
22:00:38,960 --> 22:00:41,120
copy that in the problem is going to

33249
22:00:41,120 --> 22:00:42,960
come to this pointer here it's going to

33250
22:00:42,960 --> 22:00:45,600
copy the address and it's not going to

33251
22:00:45,600 --> 22:00:47,920
copy what it's pointed to and this is

33252
22:00:47,920 --> 22:00:50,080
going to be a recipe for a disaster i

33253
22:00:50,080 --> 22:00:51,680
don't really want to go through this

33254
22:00:51,680 --> 22:00:54,080
right now but if we try to run this

33255
22:00:54,080 --> 22:00:56,160
program it's not going to work like we

33256
22:00:56,160 --> 22:00:58,960
expect for example if we pass fluffy

33257
22:00:58,960 --> 22:01:01,192
here we're going to see

33258
22:01:01,192 --> 22:01:03,680
things that we don't expect so let's try

33259
22:01:03,680 --> 22:01:06,720
to build we're going to build with gcc

33260
22:01:06,720 --> 22:01:09,680
and the bolt is good so what we expect

33261
22:01:09,680 --> 22:01:11,920
is to have the constructor of fluffy

33262
22:01:11,920 --> 22:01:14,160
here called and we're going to copy the

33263
22:01:14,160 --> 22:01:17,360
dot object for use in some funk here and

33264
22:01:17,360 --> 22:01:20,000
to set up this copy it's not this

33265
22:01:20,000 --> 22:01:21,832
constructor here that is going to be

33266
22:01:21,832 --> 22:01:22,872
called

33267
22:01:22,872 --> 22:01:24,960
so it's not our constructor here which

33268
22:01:24,960 --> 22:01:26,552
is going to be called so we're not going

33269
22:01:26,552 --> 22:01:27,600
to see

33270
22:01:27,600 --> 22:01:30,320
this called for the copy that we set up

33271
22:01:30,320 --> 22:01:32,720
inside some funk another thing is

33272
22:01:32,720 --> 22:01:35,512
because now these two dog objects are

33273
22:01:35,512 --> 22:01:37,832
pointing to the same thing because what

33274
22:01:37,832 --> 22:01:41,440
we just copied is the address as we see

33275
22:01:41,440 --> 22:01:44,160
in our member variable here the two dog

33276
22:01:44,160 --> 22:01:46,000
objects are going to be pointing to the

33277
22:01:46,000 --> 22:01:48,400
same thing in memory and when we hit the

33278
22:01:48,400 --> 22:01:50,552
destructor we're going to call delete

33279
22:01:50,552 --> 22:01:52,640
twice and this is going to be a recipe

33280
22:01:52,640 --> 22:01:55,040
for disaster our application could

33281
22:01:55,040 --> 22:01:57,192
really crash you already know that

33282
22:01:57,192 --> 22:02:00,000
deleting a pointer twice is really bad

33283
22:02:00,000 --> 22:02:02,080
we shouldn't do this and we are doing

33284
22:02:02,080 --> 22:02:04,000
this here because we are copying i

33285
22:02:04,000 --> 22:02:06,400
realize this is a slightly confusing

33286
22:02:06,400 --> 22:02:07,440
example

33287
22:02:07,440 --> 22:02:09,600
but what i want you to know is that if

33288
22:02:09,600 --> 22:02:11,920
you pass a class object by value like

33289
22:02:11,920 --> 22:02:12,720
this

33290
22:02:12,720 --> 22:02:15,360
the copy you have inside is going to

33291
22:02:15,360 --> 22:02:18,160
cause for the destructor to be called

33292
22:02:18,160 --> 22:02:20,640
when the function exits because the copy

33293
22:02:20,640 --> 22:02:22,320
is going to be scoped inside the

33294
22:02:22,320 --> 22:02:24,640
function here so let's take out this

33295
22:02:24,640 --> 22:02:26,640
example because it really is confusing

33296
22:02:26,640 --> 22:02:28,720
but i hope you know that and i am going

33297
22:02:28,720 --> 22:02:30,720
to show you that another case where you

33298
22:02:30,720 --> 22:02:32,960
might see the destructor called is when

33299
22:02:32,960 --> 22:02:37,192
you call the destructor explicitly using

33300
22:02:37,192 --> 22:02:39,680
the delete operator on your object so we

33301
22:02:39,680 --> 22:02:41,920
can set up some func again let's do that

33302
22:02:41,920 --> 22:02:44,080
some funk and we're going to repurpose

33303
22:02:44,080 --> 22:02:45,680
it and inside we're going to set up a

33304
22:02:45,680 --> 22:02:48,960
dag object so let's grab this and reuse

33305
22:02:48,960 --> 22:02:51,512
that in our function here and we're

33306
22:02:51,512 --> 22:02:53,832
going to say dog pointer so let's say

33307
22:02:53,832 --> 22:02:56,800
dog pointer we're going to say p dog p

33308
22:02:56,800 --> 22:02:59,512
underscore dog it's going to be equals

33309
22:02:59,512 --> 22:03:02,400
to new dog and we're going to pass in

33310
22:03:02,400 --> 22:03:04,720
what we need to initialize our dog

33311
22:03:04,720 --> 22:03:07,040
object with this is going to create a

33312
22:03:07,040 --> 22:03:09,040
dark object on the hip and it is going

33313
22:03:09,040 --> 22:03:11,760
to be pointed to by p dog here

33314
22:03:11,760 --> 22:03:14,160
now i want you to see that if we don't

33315
22:03:14,160 --> 22:03:17,120
explicitly release the memory that we

33316
22:03:17,120 --> 22:03:20,000
allocate through the new operator we're

33317
22:03:20,000 --> 22:03:22,320
going to leak memory so we created an

33318
22:03:22,320 --> 22:03:24,960
object on the hip here but we're not

33319
22:03:24,960 --> 22:03:27,440
deleting that in some funk when some

33320
22:03:27,440 --> 22:03:29,280
funk exits we're going to lose this

33321
22:03:29,280 --> 22:03:31,600
pointer this variable because it is on

33322
22:03:31,600 --> 22:03:34,160
the stack itself and we won't have any

33323
22:03:34,160 --> 22:03:36,232
way to release this memory let's call

33324
22:03:36,232 --> 22:03:38,320
some funk here and really show you this

33325
22:03:38,320 --> 22:03:40,000
so we're going to call some funk and

33326
22:03:40,000 --> 22:03:42,480
we're going to build let's use gcc for

33327
22:03:42,480 --> 22:03:44,872
that the build is good we can bring this

33328
22:03:44,872 --> 22:03:47,280
up a little bit and clear and run

33329
22:03:47,280 --> 22:03:48,960
rooster we're going to see that the

33330
22:03:48,960 --> 22:03:51,280
constructor for fluffy was called

33331
22:03:51,280 --> 22:03:54,000
because of this new operator but we

33332
22:03:54,000 --> 22:03:55,680
didn't see the destructor called and

33333
22:03:55,680 --> 22:03:57,192
this is really bad

33334
22:03:57,192 --> 22:03:59,440
so for the destructor to be called we

33335
22:03:59,440 --> 22:04:02,080
need to explicitly release the memory in

33336
22:04:02,080 --> 22:04:04,720
this function here and we do that by

33337
22:04:04,720 --> 22:04:07,512
using the delete keyword and saying the

33338
22:04:07,512 --> 22:04:09,920
pointer that is pointing to the memory

33339
22:04:09,920 --> 22:04:12,232
that we want to release if we do this

33340
22:04:12,232 --> 22:04:14,320
this is going to cause for the the

33341
22:04:14,320 --> 22:04:16,960
structure of doubt to be called and if

33342
22:04:16,960 --> 22:04:18,720
we run we're going to see our destructor

33343
22:04:18,720 --> 22:04:20,480
called let's do that we're going to use

33344
22:04:20,480 --> 22:04:23,120
gcc the bolt is good you can clear and

33345
22:04:23,120 --> 22:04:25,120
run rooster now you see that the

33346
22:04:25,120 --> 22:04:27,440
constructor is called full fluffy and we

33347
22:04:27,440 --> 22:04:30,640
have the destructor cold this is really

33348
22:04:30,640 --> 22:04:32,552
all i wanted to share with you in this

33349
22:04:32,552 --> 22:04:35,192
lecture i apologize if you found it

33350
22:04:35,192 --> 22:04:37,680
confusing but if you have any problem i

33351
22:04:37,680 --> 22:04:40,552
am always available please do ask and i

33352
22:04:40,552 --> 22:04:42,872
will do the best i can to help you out

33353
22:04:42,872 --> 22:04:45,600
so the destructor is a special method

33354
22:04:45,600 --> 22:04:47,600
which is going to be called when your

33355
22:04:47,600 --> 22:04:50,080
object dies it is going to be called

33356
22:04:50,080 --> 22:04:52,320
when an object is passed by a value to a

33357
22:04:52,320 --> 22:04:54,480
function we have seen an example that

33358
22:04:54,480 --> 22:04:56,400
it's going to be called when a local

33359
22:04:56,400 --> 22:04:58,480
object is returned from a function by

33360
22:04:58,480 --> 22:05:00,872
value but this is going to be compiler

33361
22:05:00,872 --> 22:05:02,872
dependent because some compilers are

33362
22:05:02,872 --> 22:05:05,512
going to optimize this out and make it

33363
22:05:05,512 --> 22:05:08,080
look like when you returned by reference

33364
22:05:08,080 --> 22:05:10,160
so i don't want to go into this because

33365
22:05:10,160 --> 22:05:13,360
this is subject to compiler optimization

33366
22:05:13,360 --> 22:05:15,280
but other cases where you're going to

33367
22:05:15,280 --> 22:05:17,680
have your destructor called is when a

33368
22:05:17,680 --> 22:05:20,720
local stack object goes out of scope and

33369
22:05:20,720 --> 22:05:23,512
when a hip object is deleted

33370
22:05:23,512 --> 22:05:25,920
through the delete key world this is

33371
22:05:25,920 --> 22:05:27,680
really all i had to share in this

33372
22:05:27,680 --> 22:05:30,000
lecture i hope you found it interesting

33373
22:05:30,000 --> 22:05:32,000
we are going to stop here in this one

33374
22:05:32,000 --> 22:05:33,680
and the next one we're going to see the

33375
22:05:33,680 --> 22:05:36,480
order in which constructors and these

33376
22:05:36,480 --> 22:05:38,640
structures are called and you really

33377
22:05:38,640 --> 22:05:40,800
need to be aware of this

33378
22:05:40,800 --> 22:05:42,720
go ahead and finish up here

33379
22:05:42,720 --> 22:05:44,720
and meet me there

33380
22:05:44,720 --> 22:05:47,360
and this lecture i wanted to raise your

33381
22:05:47,360 --> 22:05:50,000
awareness on the order in which

33382
22:05:50,000 --> 22:05:52,480
constructors and the structures are

33383
22:05:52,480 --> 22:05:54,872
called suppose we have our class which

33384
22:05:54,872 --> 22:05:57,600
is dug here and we have the constructor

33385
22:05:57,600 --> 22:05:59,832
which is doing its thing in the body

33386
22:05:59,832 --> 22:06:02,320
here and we have the destructor which is

33387
22:06:02,320 --> 22:06:04,400
releasing our memory and printing

33388
22:06:04,400 --> 22:06:07,120
something out so suppose we have created

33389
22:06:07,120 --> 22:06:08,800
a few objects

33390
22:06:08,800 --> 22:06:10,872
of this class here and they have

33391
22:06:10,872 --> 22:06:13,280
different names and they have the same

33392
22:06:13,280 --> 22:06:15,512
breed and different edges as you see

33393
22:06:15,512 --> 22:06:16,400
here

33394
22:06:16,400 --> 22:06:19,360
and if we run this code in main

33395
22:06:19,360 --> 22:06:21,680
what do you think will see printed from

33396
22:06:21,680 --> 22:06:24,552
the constructors and the destructors if

33397
22:06:24,552 --> 22:06:26,872
you asked me and i was learning about c

33398
22:06:26,872 --> 22:06:28,872
plus plus i would say that the

33399
22:06:28,872 --> 22:06:30,552
constructors are going to be called in

33400
22:06:30,552 --> 22:06:33,440
order dog one dog two dog three dog four

33401
22:06:33,440 --> 22:06:35,360
they are going to be constructed in this

33402
22:06:35,360 --> 22:06:37,760
order and the destructors would be

33403
22:06:37,760 --> 22:06:40,400
called in the same order but this is not

33404
22:06:40,400 --> 22:06:42,720
true the destructors are going to be

33405
22:06:42,720 --> 22:06:45,600
called in the reverse order as you see

33406
22:06:45,600 --> 22:06:47,120
on the right here

33407
22:06:47,120 --> 22:06:48,720
so we're going to call this constructor

33408
22:06:48,720 --> 22:06:52,552
for doug d1 delegate2w3 doge4 which is

33409
22:06:52,552 --> 22:06:55,192
exactly what i expected but you're going

33410
22:06:55,192 --> 22:06:57,280
to see that the destructors are going to

33411
22:06:57,280 --> 22:07:00,400
be called in reverse order so the object

33412
22:07:00,400 --> 22:07:02,960
that was constructed last

33413
22:07:02,960 --> 22:07:05,512
is going to be destroyed first as you

33414
22:07:05,512 --> 22:07:07,680
see here and the object that was

33415
22:07:07,680 --> 22:07:09,600
constructed first is going to be

33416
22:07:09,600 --> 22:07:10,800
destroyed

33417
22:07:10,800 --> 22:07:14,232
last and the compiler follows this order

33418
22:07:14,232 --> 22:07:16,552
to make it easy for it to do things we

33419
22:07:16,552 --> 22:07:19,600
can't really get into those details but

33420
22:07:19,600 --> 22:07:21,192
for now we're going to head over to

33421
22:07:21,192 --> 22:07:23,120
visual studio code and play with us a

33422
22:07:23,120 --> 22:07:25,680
little more okay here we are in our

33423
22:07:25,680 --> 22:07:28,160
working folder the current project is

33424
22:07:28,160 --> 22:07:30,960
order of constructor and destructor

33425
22:07:30,960 --> 22:07:32,872
calls here we're going to grab our

33426
22:07:32,872 --> 22:07:35,280
template project pretty quick

33427
22:07:35,280 --> 22:07:37,832
and we're going to put them in place the

33428
22:07:37,832 --> 22:07:39,832
files i mean and we're going to open

33429
22:07:39,832 --> 22:07:41,920
this in visual studio code like we have

33430
22:07:41,920 --> 22:07:44,320
been doing all along this is going to

33431
22:07:44,320 --> 22:07:47,440
open up our folder we can close the left

33432
22:07:47,440 --> 22:07:50,872
sidebar here and let's clean up our main

33433
22:07:50,872 --> 22:07:53,120
function we are going to bring in the

33434
22:07:53,120 --> 22:07:55,920
class for dog from the last lecture this

33435
22:07:55,920 --> 22:07:58,080
is exactly what we had there

33436
22:07:58,080 --> 22:08:00,640
no change and we're going to include the

33437
22:08:00,640 --> 22:08:02,720
string review library for this to work

33438
22:08:02,720 --> 22:08:04,960
so we're going to include string view

33439
22:08:04,960 --> 22:08:06,960
here and once we do this we're going to

33440
22:08:06,960 --> 22:08:09,120
head over in the main function and set

33441
22:08:09,120 --> 22:08:10,552
up a few

33442
22:08:10,552 --> 22:08:13,440
objects of the dog class here but before

33443
22:08:13,440 --> 22:08:15,600
we go there notice that we have a few

33444
22:08:15,600 --> 22:08:18,872
htdc out statements in our constructor

33445
22:08:18,872 --> 22:08:21,360
and destructor and we want to see the

33446
22:08:21,360 --> 22:08:23,680
order in which they are called so we're

33447
22:08:23,680 --> 22:08:26,480
going to set up four objects of our dog

33448
22:08:26,480 --> 22:08:28,720
we're going to say dog dog one and we're

33449
22:08:28,720 --> 22:08:32,080
going to say the name to be won and it's

33450
22:08:32,080 --> 22:08:34,720
going to be a shepherd and it's going to

33451
22:08:34,720 --> 22:08:37,280
be for example 2 years old why not we

33452
22:08:37,280 --> 22:08:39,512
should say dog here and we are going to

33453
22:08:39,512 --> 22:08:41,832
copy these four times here and we're

33454
22:08:41,832 --> 22:08:44,000
going to call this dog 2

33455
22:08:44,000 --> 22:08:46,400
the other is going to be dog 3 and this

33456
22:08:46,400 --> 22:08:48,552
is going to be dog 4

33457
22:08:48,552 --> 22:08:50,552
and i'm going to say the same thing here

33458
22:08:50,552 --> 22:08:52,000
doggy two

33459
22:08:52,000 --> 22:08:54,400
three and four

33460
22:08:54,400 --> 22:08:56,640
the names are what is really important

33461
22:08:56,640 --> 22:08:58,320
because we're going to see them printed

33462
22:08:58,320 --> 22:09:00,320
out here but if you want you can change

33463
22:09:00,320 --> 22:09:03,280
the ages let's make this a three let's

33464
22:09:03,280 --> 22:09:05,680
make this a five let's make this a one

33465
22:09:05,680 --> 22:09:07,920
why not for dougie for and now we're

33466
22:09:07,920 --> 22:09:10,640
going to run our program if we run it

33467
22:09:10,640 --> 22:09:12,080
we're going to see the constructors

33468
22:09:12,080 --> 22:09:14,960
called in the order doggy one doggie 2

33469
22:09:14,960 --> 22:09:18,000
w3 dog e4 and the destructors are going

33470
22:09:18,000 --> 22:09:20,232
to be called in the reverse order

33471
22:09:20,232 --> 22:09:21,440
dogifur

33472
22:09:21,440 --> 22:09:23,832
all the way to doggy one let's boil and

33473
22:09:23,832 --> 22:09:26,160
show you that this is actually the case

33474
22:09:26,160 --> 22:09:28,640
so the build is good we can bring up a

33475
22:09:28,640 --> 22:09:31,600
terminal and really run this let's clear

33476
22:09:31,600 --> 22:09:34,000
and run rooster you're going to see that

33477
22:09:34,000 --> 22:09:36,400
dog constructor called for a doki one

33478
22:09:36,400 --> 22:09:38,720
all the way to dog e4 and now we have

33479
22:09:38,720 --> 22:09:41,760
the dagger destructor called from doge4

33480
22:09:41,760 --> 22:09:44,640
all the way to doge one and the compiler

33481
22:09:44,640 --> 22:09:47,120
is going to enforce this order for

33482
22:09:47,120 --> 22:09:49,832
calling constructors and destructors

33483
22:09:49,832 --> 22:09:52,480
because it makes it easy for it to

33484
22:09:52,480 --> 22:09:55,512
manage the memory of objects for example

33485
22:09:55,512 --> 22:09:58,160
if duck one has been around for a long

33486
22:09:58,160 --> 22:10:00,800
time and it has because it's going to be

33487
22:10:00,800 --> 22:10:03,040
around before a dog one

33488
22:10:03,040 --> 22:10:04,080
if you

33489
22:10:04,080 --> 22:10:06,080
delete duck one

33490
22:10:06,080 --> 22:10:09,120
after dog four here there might be other

33491
22:10:09,120 --> 22:10:11,760
objects that depend on dog one so that's

33492
22:10:11,760 --> 22:10:15,360
why the object that was created the last

33493
22:10:15,360 --> 22:10:18,320
is deleted first because chances for

33494
22:10:18,320 --> 22:10:21,192
other objects to depend on that last

33495
22:10:21,192 --> 22:10:23,680
object are really slim and you can

33496
22:10:23,680 --> 22:10:26,160
delete it without any problem but the

33497
22:10:26,160 --> 22:10:29,280
object that was created first might have

33498
22:10:29,280 --> 22:10:31,192
other dependencies and you're going to

33499
22:10:31,192 --> 22:10:34,720
be deleting dependent object first

33500
22:10:34,720 --> 22:10:36,800
before you delete that object i think

33501
22:10:36,800 --> 22:10:39,192
this is the logic the compiler follows

33502
22:10:39,192 --> 22:10:41,512
to really enforce this order here and

33503
22:10:41,512 --> 22:10:43,600
you need to be aware of that and make

33504
22:10:43,600 --> 22:10:46,320
sure that at any time in your c-plus

33505
22:10:46,320 --> 22:10:49,192
plus application this is working to your

33506
22:10:49,192 --> 22:10:51,680
advantage this is really all i had to

33507
22:10:51,680 --> 22:10:53,440
share in this lecture i hope you found

33508
22:10:53,440 --> 22:10:55,920
it interesting we are going to stop here

33509
22:10:55,920 --> 22:10:57,680
in this one and the next one we're going

33510
22:10:57,680 --> 22:11:00,640
to learn about the this pointer go ahead

33511
22:11:00,640 --> 22:11:03,440
and finish up here and meet me there

33512
22:11:03,440 --> 22:11:04,872
in this lecture we're going to learn

33513
22:11:04,872 --> 22:11:07,920
about the this pointer and this is a

33514
22:11:07,920 --> 22:11:11,040
special pointer that is maintained by c

33515
22:11:11,040 --> 22:11:14,160
plus plus to really help you manipulate

33516
22:11:14,160 --> 22:11:17,192
the current object and it is the current

33517
22:11:17,192 --> 22:11:20,320
object for which a given method is being

33518
22:11:20,320 --> 22:11:23,512
executed here is a simple example with

33519
22:11:23,512 --> 22:11:26,160
our dog class and we're going to show

33520
22:11:26,160 --> 22:11:28,552
some usefulness for the this pointer the

33521
22:11:28,552 --> 22:11:30,000
first thing we're going to look at is

33522
22:11:30,000 --> 22:11:32,480
the syntax for example here we might

33523
22:11:32,480 --> 22:11:35,600
need to print the address in memory

33524
22:11:35,600 --> 22:11:38,232
where the object was created and do that

33525
22:11:38,232 --> 22:11:40,552
from the inside of the function and to

33526
22:11:40,552 --> 22:11:42,320
do that we use the this pointer for

33527
22:11:42,320 --> 22:11:44,640
example we can put out a message and we

33528
22:11:44,640 --> 22:11:46,720
can do that through a statement like we

33529
22:11:46,720 --> 22:11:49,360
have here we are printing dog dog name

33530
22:11:49,360 --> 22:11:52,480
constructed at a given memory address

33531
22:11:52,480 --> 22:11:55,040
and we use the this keyword to get the

33532
22:11:55,040 --> 22:11:58,232
address of the character object for

33533
22:11:58,232 --> 22:12:00,960
which a specific method or function is

33534
22:12:00,960 --> 22:12:03,360
being called in this case it was the

33535
22:12:03,360 --> 22:12:06,160
constructor of the dot object here we

33536
22:12:06,160 --> 22:12:08,160
can also do the same thing for the other

33537
22:12:08,160 --> 22:12:10,552
constructor and you see we are using the

33538
22:12:10,552 --> 22:12:13,760
this pointer this is one of the uses you

33539
22:12:13,760 --> 22:12:16,480
have for the this pointer again the this

33540
22:12:16,480 --> 22:12:18,960
pointer is a special pointer that is

33541
22:12:18,960 --> 22:12:21,680
maintained by the c plus plus system and

33542
22:12:21,680 --> 22:12:23,440
it is going to be pointing to the

33543
22:12:23,440 --> 22:12:26,640
current object that is being manipulated

33544
22:12:26,640 --> 22:12:29,600
by the z plus plus run time and it's

33545
22:12:29,600 --> 22:12:31,600
going to be manipulated through a

33546
22:12:31,600 --> 22:12:35,120
special function of the class object

33547
22:12:35,120 --> 22:12:37,280
that is being called this is the meaning

33548
22:12:37,280 --> 22:12:40,640
here here is another use case for the

33549
22:12:40,640 --> 22:12:43,920
this pointer it may be used to resolve

33550
22:12:43,920 --> 22:12:47,120
conflicts when you have a parameter and

33551
22:12:47,120 --> 22:12:49,360
a member variable that are named the

33552
22:12:49,360 --> 22:12:51,192
same way for example here we are calling

33553
22:12:51,192 --> 22:12:54,232
the set name function it has a parameter

33554
22:12:54,232 --> 22:12:56,872
with a name doug name and it has a

33555
22:12:56,872 --> 22:12:59,680
member variable called dog name so if

33556
22:12:59,680 --> 22:13:02,160
you do a statement like we have on top

33557
22:13:02,160 --> 22:13:04,160
here the compiler is going to be

33558
22:13:04,160 --> 22:13:06,160
confused they're going to say dog name

33559
22:13:06,160 --> 22:13:09,040
equals dog name and it won't really know

33560
22:13:09,040 --> 22:13:11,512
which dog name you are referring to we

33561
22:13:11,512 --> 22:13:14,640
can resolve this conflict by saying

33562
22:13:14,640 --> 22:13:18,400
this and say pointer access notation

33563
22:13:18,400 --> 22:13:20,640
and say dog name and this thing here is

33564
22:13:20,640 --> 22:13:22,640
going to be the member variable and

33565
22:13:22,640 --> 22:13:24,320
we're going to be assigning to the

33566
22:13:24,320 --> 22:13:27,192
member variable from the parameter this

33567
22:13:27,192 --> 22:13:29,832
is the meaning here and we can use the

33568
22:13:29,832 --> 22:13:32,720
desperator to resolve such conflicts

33569
22:13:32,720 --> 22:13:34,960
another use we have for use pointer is

33570
22:13:34,960 --> 22:13:37,680
if we want to set up chained calls for

33571
22:13:37,680 --> 22:13:39,832
example using pointers and we might need

33572
22:13:39,832 --> 22:13:42,720
to do something like this so we have a

33573
22:13:42,720 --> 22:13:45,360
dog pointer set up on top here and we

33574
22:13:45,360 --> 22:13:48,320
can do something with our new object for

33575
22:13:48,320 --> 22:13:50,232
example we can call a function called

33576
22:13:50,232 --> 22:13:53,512
printful on a dog object after we print

33577
22:13:53,512 --> 22:13:55,512
the information we're going to set some

33578
22:13:55,512 --> 22:13:57,760
information on the doc and you see we

33579
22:13:57,760 --> 22:14:00,160
are setting all of the information

33580
22:14:00,160 --> 22:14:02,640
through one statement the way we achieve

33581
22:14:02,640 --> 22:14:05,120
this our setters are going to be

33582
22:14:05,120 --> 22:14:08,000
returning a pointer to the current

33583
22:14:08,000 --> 22:14:10,320
object and we're going to be grabbing

33584
22:14:10,320 --> 22:14:13,120
that return value and calling

33585
22:14:13,120 --> 22:14:15,120
on it directly because it's a pointer

33586
22:14:15,120 --> 22:14:17,440
and we are going to be using the pointer

33587
22:14:17,440 --> 22:14:19,680
access notation so we're going to call

33588
22:14:19,680 --> 22:14:21,760
set name set name is going to return a

33589
22:14:21,760 --> 22:14:23,680
pointer we're going to use that pointer

33590
22:14:23,680 --> 22:14:26,320
to say to the breed and set the breed is

33591
22:14:26,320 --> 22:14:28,000
going to return a pointer we're going to

33592
22:14:28,000 --> 22:14:30,720
use that pointer to set the age and

33593
22:14:30,720 --> 22:14:33,600
after this entire line all the

33594
22:14:33,600 --> 22:14:35,440
information is going to change about our

33595
22:14:35,440 --> 22:14:37,920
dog and we can see that here and after

33596
22:14:37,920 --> 22:14:39,920
we do whatever we want with our dog

33597
22:14:39,920 --> 22:14:41,760
object we're going to release it from

33598
22:14:41,760 --> 22:14:43,832
memory so this is another thing you can

33599
22:14:43,832 --> 22:14:46,872
achieve using the this pointer and this

33600
22:14:46,872 --> 22:14:49,280
is how you can set up these setters it

33601
22:14:49,280 --> 22:14:51,680
is nothing complicated we have set name

33602
22:14:51,680 --> 22:14:53,760
it's going to return the dot pointer and

33603
22:14:53,760 --> 22:14:56,640
we're going to return this okay and this

33604
22:14:56,640 --> 22:14:58,960
is going to be a pointer or the memory

33605
22:14:58,960 --> 22:15:02,232
address of the current object of the dog

33606
22:15:02,232 --> 22:15:04,800
class we have the same setup for seti

33607
22:15:04,800 --> 22:15:07,360
dog breed we return the dog pointer and

33608
22:15:07,360 --> 22:15:10,160
we return this the same setup for set

33609
22:15:10,160 --> 22:15:13,192
doug age we return a dog pointer and we

33610
22:15:13,192 --> 22:15:14,160
return

33611
22:15:14,160 --> 22:15:16,640
this we can do the same thing using

33612
22:15:16,640 --> 22:15:19,832
references but our setup is going to be

33613
22:15:19,832 --> 22:15:22,400
somewhat a little bit different

33614
22:15:22,400 --> 22:15:25,280
we have our dog object here and we're

33615
22:15:25,280 --> 22:15:27,832
going to do our change call here so

33616
22:15:27,832 --> 22:15:29,760
we're going to say set name through the

33617
22:15:29,760 --> 22:15:30,960
pointer

33618
22:15:30,960 --> 22:15:33,360
because we have a dot pointer here but

33619
22:15:33,360 --> 22:15:35,360
after that we're going to return a

33620
22:15:35,360 --> 22:15:38,480
reference from the functions here so set

33621
22:15:38,480 --> 22:15:39,920
name is going to return a reference

33622
22:15:39,920 --> 22:15:41,680
we're going to go through that reference

33623
22:15:41,680 --> 22:15:43,440
to set the breed

33624
22:15:43,440 --> 22:15:45,680
set dog breed is going to return a

33625
22:15:45,680 --> 22:15:47,600
reference and we are going to go through

33626
22:15:47,600 --> 22:15:50,720
that reference to set the dog age and if

33627
22:15:50,720 --> 22:15:52,800
we print the information now we're going

33628
22:15:52,800 --> 22:15:55,040
to see that we have new information in

33629
22:15:55,040 --> 22:15:57,832
our dog object and after we are done

33630
22:15:57,832 --> 22:16:00,232
with our dog object we have to remember

33631
22:16:00,232 --> 22:16:03,120
to release it from memory because it was

33632
22:16:03,120 --> 22:16:06,400
allocated dynamically from the heap here

33633
22:16:06,400 --> 22:16:09,040
is how you can set this up it really is

33634
22:16:09,040 --> 22:16:11,280
nothing complicated we just have our

33635
22:16:11,280 --> 22:16:13,760
setters and we are going to return a

33636
22:16:13,760 --> 22:16:16,400
reference but before we return through

33637
22:16:16,400 --> 22:16:18,480
the desperator we will need to

33638
22:16:18,480 --> 22:16:21,512
dereference the displayer and get to the

33639
22:16:21,512 --> 22:16:24,232
actual thing that is being pointed to

33640
22:16:24,232 --> 22:16:26,552
that's why we have this star operator

33641
22:16:26,552 --> 22:16:28,800
here and for the other setters we're

33642
22:16:28,800 --> 22:16:30,080
going to do the same thing we're going

33643
22:16:30,080 --> 22:16:31,832
to return a reference we're going to

33644
22:16:31,832 --> 22:16:34,872
return a dereferenced version of this

33645
22:16:34,872 --> 22:16:36,800
we're going to return a dog reference

33646
22:16:36,800 --> 22:16:38,552
for set dog age and we're going to

33647
22:16:38,552 --> 22:16:41,360
return a dereferenced this pointer

33648
22:16:41,360 --> 22:16:42,960
because this is the reference we are

33649
22:16:42,960 --> 22:16:46,080
returning here so this is what the this

33650
22:16:46,080 --> 22:16:48,480
pointer is about now we're going to head

33651
22:16:48,480 --> 22:16:50,480
over to visual studio code and play with

33652
22:16:50,480 --> 22:16:53,120
us a little more okay here we are in our

33653
22:16:53,120 --> 22:16:55,600
working folder the current project is

33654
22:16:55,600 --> 22:16:58,232
the displayer we're going to grab our

33655
22:16:58,232 --> 22:17:00,320
template files and we're going to put

33656
22:17:00,320 --> 22:17:02,480
them in place and then we're going to

33657
22:17:02,480 --> 22:17:04,720
open this in visual studio code by

33658
22:17:04,720 --> 22:17:06,960
dragging and dropping here this is going

33659
22:17:06,960 --> 22:17:08,800
to open our folder we're going to open

33660
22:17:08,800 --> 22:17:10,720
the main cpp file and we're going to

33661
22:17:10,720 --> 22:17:13,040
close the left sidebar here

33662
22:17:13,040 --> 22:17:15,280
so that we have some more space to work

33663
22:17:15,280 --> 22:17:18,232
with i am going to put in a version of

33664
22:17:18,232 --> 22:17:20,080
our dog class

33665
22:17:20,080 --> 22:17:23,280
it is pretty limited right now it just

33666
22:17:23,280 --> 22:17:25,680
has a destructor and a constructor and a

33667
22:17:25,680 --> 22:17:27,512
constructor and we have our member

33668
22:17:27,512 --> 22:17:29,360
variables and we're going to

33669
22:17:29,360 --> 22:17:31,280
tune this a little bit so that we can

33670
22:17:31,280 --> 22:17:33,680
work with us however we want the first

33671
22:17:33,680 --> 22:17:36,872
thing we want to do is to print the

33672
22:17:36,872 --> 22:17:40,000
addresses of dug objects that we

33673
22:17:40,000 --> 22:17:42,800
construct and destruct here and we're

33674
22:17:42,800 --> 22:17:45,120
going to do that in our constructor so

33675
22:17:45,120 --> 22:17:48,720
let's go to our hd dc out statement here

33676
22:17:48,720 --> 22:17:51,280
and we're going to say add to mean the

33677
22:17:51,280 --> 22:17:53,360
memory address where the object was

33678
22:17:53,360 --> 22:17:55,832
constructed and we're going to say this

33679
22:17:55,832 --> 22:17:59,120
so when we do this this is going to be

33680
22:17:59,120 --> 22:18:02,080
the address in memory of the current

33681
22:18:02,080 --> 22:18:05,040
object that is being constructed

33682
22:18:05,040 --> 22:18:07,440
by our constructor here and we're going

33683
22:18:07,440 --> 22:18:10,160
to say the same thing in our destructor

33684
22:18:10,160 --> 22:18:12,232
we're going to say at and we're going to

33685
22:18:12,232 --> 22:18:14,552
say the memory address where the current

33686
22:18:14,552 --> 22:18:17,760
object is being destroyed from so after

33687
22:18:17,760 --> 22:18:19,512
we do this

33688
22:18:19,512 --> 22:18:22,232
if we go in the main function and for

33689
22:18:22,232 --> 22:18:24,480
example set up a doug object we're going

33690
22:18:24,480 --> 22:18:26,720
to say dark we're going to say dog one

33691
22:18:26,720 --> 22:18:27,832
and we're going to give it the

33692
22:18:27,832 --> 22:18:30,080
information we're going to give it the

33693
22:18:30,080 --> 22:18:32,080
name which is going to be fluffy we're

33694
22:18:32,080 --> 22:18:33,680
going to give it the breed which is

33695
22:18:33,680 --> 22:18:35,280
going to be a shepherd and we're going

33696
22:18:35,280 --> 22:18:37,360
to give it the age of two like we have

33697
22:18:37,360 --> 22:18:39,192
been doing all along when we do

33698
22:18:39,192 --> 22:18:40,720
something like this this is going to

33699
22:18:40,720 --> 22:18:42,320
call the constructor because we are

33700
22:18:42,320 --> 22:18:45,360
trying to set up an object and before

33701
22:18:45,360 --> 22:18:47,360
the main function ends we're going to

33702
22:18:47,360 --> 22:18:49,360
call the destructor and we're going to

33703
22:18:49,360 --> 22:18:51,600
see things happening here let's say done

33704
22:18:51,600 --> 22:18:53,192
so that we know that the code is

33705
22:18:53,192 --> 22:18:55,600
actually running i'm going to say sddc

33706
22:18:55,600 --> 22:18:58,000
out done here okay we have the setup

33707
22:18:58,000 --> 22:18:58,872
done

33708
22:18:58,872 --> 22:19:01,512
we can uh build and run the application

33709
22:19:01,512 --> 22:19:04,080
we're going to use gcc to build and the

33710
22:19:04,080 --> 22:19:06,480
build is good we can bring up a terminal

33711
22:19:06,480 --> 22:19:09,512
to try and run the application and now

33712
22:19:09,512 --> 22:19:11,600
if we run rooster we're going to see

33713
22:19:11,600 --> 22:19:14,720
that dog constructor called for a fluffy

33714
22:19:14,720 --> 22:19:17,440
at this memory location and the current

33715
22:19:17,440 --> 22:19:20,000
object is this object here which is

33716
22:19:20,000 --> 22:19:21,920
being constructed and we're going to

33717
22:19:21,920 --> 22:19:23,920
have access to its memory through the

33718
22:19:23,920 --> 22:19:26,000
this pointer hopefully you can see how

33719
22:19:26,000 --> 22:19:29,440
powerful this is if we didn't have the

33720
22:19:29,440 --> 22:19:31,680
this pointer the only way to get the

33721
22:19:31,680 --> 22:19:32,872
address to

33722
22:19:32,872 --> 22:19:35,832
this object would be to grab the address

33723
22:19:35,832 --> 22:19:38,480
from the main function or from wherever

33724
22:19:38,480 --> 22:19:41,280
we are setting up our object here but we

33725
22:19:41,280 --> 22:19:44,232
have access to this address from the

33726
22:19:44,232 --> 22:19:46,640
inside of the functions for the class

33727
22:19:46,640 --> 22:19:48,872
and this is really cool so we can

33728
22:19:48,872 --> 22:19:51,760
manipulate these addresses if we need to

33729
22:19:51,760 --> 22:19:53,360
and we're going to show you another use

33730
22:19:53,360 --> 22:19:55,832
for this so suppose we need to set up

33731
22:19:55,832 --> 22:19:59,040
setters for our class here so we need a

33732
22:19:59,040 --> 22:20:01,360
setter to set the name the breed and to

33733
22:20:01,360 --> 22:20:03,600
set the age here so let's set up our

33734
22:20:03,600 --> 22:20:05,280
setters we're going to say setters and

33735
22:20:05,280 --> 22:20:07,600
we're going to say void set

33736
22:20:07,600 --> 22:20:10,960
name or let's be explicit set dog name

33737
22:20:10,960 --> 22:20:12,720
that's going to be better and we're

33738
22:20:12,720 --> 22:20:15,512
going to pass a string view we're going

33739
22:20:15,512 --> 22:20:18,320
to say stds friend of you and we're

33740
22:20:18,320 --> 22:20:20,080
going to say name program and we're

33741
22:20:20,080 --> 22:20:22,720
going to put the bodies in our class

33742
22:20:22,720 --> 22:20:25,192
here but i would encourage you to be

33743
22:20:25,192 --> 22:20:28,640
consistent if you are doing this in real

33744
22:20:28,640 --> 22:20:31,120
code we are learning here and we are

33745
22:20:31,120 --> 22:20:33,280
taking some shortcuts so that we can do

33746
22:20:33,280 --> 22:20:35,512
things simply but what we want to see

33747
22:20:35,512 --> 22:20:38,160
now is what happens if we have a

33748
22:20:38,160 --> 22:20:40,872
parameter named the same as a member

33749
22:20:40,872 --> 22:20:44,080
variable so how do you set

33750
22:20:44,080 --> 22:20:46,080
this name to the member variable called

33751
22:20:46,080 --> 22:20:48,400
the name so if you have a case like this

33752
22:20:48,400 --> 22:20:49,832
you're really going to be in trouble

33753
22:20:49,832 --> 22:20:52,160
because if you say name equals name

33754
22:20:52,160 --> 22:20:53,832
let's try this

33755
22:20:53,832 --> 22:20:55,760
we should get a compiler error or a

33756
22:20:55,760 --> 22:20:57,680
squiggly line because the compiler is

33757
22:20:57,680 --> 22:20:59,440
not going to know

33758
22:20:59,440 --> 22:21:01,440
which name are you using here is it the

33759
22:21:01,440 --> 22:21:03,360
memorial is it the parameter it's not

33760
22:21:03,360 --> 22:21:05,760
going to know and let's try to build and

33761
22:21:05,760 --> 22:21:07,600
see what we get we're going to use the

33762
22:21:07,600 --> 22:21:09,280
gcc

33763
22:21:09,280 --> 22:21:13,120
and surprisingly gcc is taking this

33764
22:21:13,120 --> 22:21:15,832
and it's probably knowing that we have a

33765
22:21:15,832 --> 22:21:17,832
member variable named name and it's

33766
22:21:17,832 --> 22:21:19,680
going to assign the parameter to that

33767
22:21:19,680 --> 22:21:22,960
member variable so behind the scenes gcc

33768
22:21:22,960 --> 22:21:25,832
is going to change this to this it's

33769
22:21:25,832 --> 22:21:29,280
going to use this name equals name

33770
22:21:29,280 --> 22:21:31,120
this is the syntax we want which is

33771
22:21:31,120 --> 22:21:34,080
really not confusing but what we have on

33772
22:21:34,080 --> 22:21:36,552
top here is going to be confusing and

33773
22:21:36,552 --> 22:21:38,552
some compilers are not even going to

33774
22:21:38,552 --> 22:21:40,960
take this let's leave this in and

33775
22:21:40,960 --> 22:21:43,040
actually build it in with us i want to

33776
22:21:43,040 --> 22:21:45,192
see that this actually works so we're

33777
22:21:45,192 --> 22:21:48,080
going to weld successfully and if we go

33778
22:21:48,080 --> 22:21:50,872
down in main and try to say

33779
22:21:50,872 --> 22:21:54,000
dog one set dog name let's say pumbaa

33780
22:21:54,000 --> 22:21:55,832
let's see what happens if we do

33781
22:21:55,832 --> 22:21:57,680
something like this we're going to try

33782
22:21:57,680 --> 22:22:00,160
and build again and gcc is going to take

33783
22:22:00,160 --> 22:22:02,232
this and this is really cool so let's

33784
22:22:02,232 --> 22:22:03,832
put in a function which is going to

33785
22:22:03,832 --> 22:22:06,720
print information about our dog we can

33786
22:22:06,720 --> 22:22:08,872
do that down here and it's going to

33787
22:22:08,872 --> 22:22:11,120
return nothing it's going to be called

33788
22:22:11,120 --> 22:22:13,512
print info and it's going to basically

33789
22:22:13,512 --> 22:22:15,512
print the name of the breed and the age

33790
22:22:15,512 --> 22:22:17,600
so it's going to say sddc out we're

33791
22:22:17,600 --> 22:22:19,600
going to say the address where the dot

33792
22:22:19,600 --> 22:22:21,120
object leaves

33793
22:22:21,120 --> 22:22:23,280
i think that's more meaningful we're

33794
22:22:23,280 --> 22:22:25,512
going to say this and then we're going

33795
22:22:25,512 --> 22:22:26,400
to

33796
22:22:26,400 --> 22:22:28,552
put a parenthesis and say the name i

33797
22:22:28,552 --> 22:22:32,400
think we can put a an angle bracket here

33798
22:22:32,400 --> 22:22:34,800
and say name and we're going to say the

33799
22:22:34,800 --> 22:22:38,800
dog name we can go down and say the age

33800
22:22:38,800 --> 22:22:41,120
or the breed and say the age and we're

33801
22:22:41,120 --> 22:22:43,440
going to dereference the age member

33802
22:22:43,440 --> 22:22:44,960
variable because it's a pointer we're

33803
22:22:44,960 --> 22:22:47,920
going to say the reference ph here and i

33804
22:22:47,920 --> 22:22:50,160
think this is going to be it now we can

33805
22:22:50,160 --> 22:22:53,440
put a new line character std e ndm and

33806
22:22:53,440 --> 22:22:56,480
if we go down now and say printable

33807
22:22:56,480 --> 22:22:58,640
before we set the name we're going to

33808
22:22:58,640 --> 22:22:59,760
say

33809
22:22:59,760 --> 22:23:01,120
dub1

33810
22:23:01,120 --> 22:23:02,872
printful we're going to print the

33811
22:23:02,872 --> 22:23:05,600
information about this dog and after we

33812
22:23:05,600 --> 22:23:07,680
set the dog name we're going to go down

33813
22:23:07,680 --> 22:23:10,160
and also say dog one principle you can

33814
22:23:10,160 --> 22:23:12,000
play with these things and i really

33815
22:23:12,000 --> 22:23:14,080
encourage you to do so so we're going to

33816
22:23:14,080 --> 22:23:16,640
build this we're going to use gcc so the

33817
22:23:16,640 --> 22:23:19,192
world is good we can clear and run

33818
22:23:19,192 --> 22:23:20,872
rooster this is going to say the

33819
22:23:20,872 --> 22:23:23,040
constructor was called for fluffy at the

33820
22:23:23,040 --> 22:23:24,552
given address

33821
22:23:24,552 --> 22:23:27,120
we're going to say the dog we're going

33822
22:23:27,120 --> 22:23:28,800
to print the information and we're going

33823
22:23:28,800 --> 22:23:31,920
to say it's a dog object at this address

33824
22:23:31,920 --> 22:23:34,080
the name is fluffy and we're going to

33825
22:23:34,080 --> 22:23:35,920
print the dog for the second time you're

33826
22:23:35,920 --> 22:23:37,920
going to see that the name is still

33827
22:23:37,920 --> 22:23:40,320
fluffy and we have a problem here why is

33828
22:23:40,320 --> 22:23:41,360
that

33829
22:23:41,360 --> 22:23:44,720
why is our object not being modified

33830
22:23:44,720 --> 22:23:48,232
let's go up and see our set dog name

33831
22:23:48,232 --> 22:23:50,640
function here so we're going to

33832
22:23:50,640 --> 22:23:53,040
remove this and we're going to use the

33833
22:23:53,040 --> 22:23:55,360
this pointer and we're going to

33834
22:23:55,360 --> 22:23:58,232
weld again and let's clear now and run

33835
22:23:58,232 --> 22:24:00,640
rooster and now you see that the changes

33836
22:24:00,640 --> 22:24:03,680
are actually making sense so what is

33837
22:24:03,680 --> 22:24:06,872
happening with the assignment here the

33838
22:24:06,872 --> 22:24:09,600
compiler is assigning the value of the

33839
22:24:09,600 --> 22:24:11,832
variable to the variable itself and this

33840
22:24:11,832 --> 22:24:14,080
is really doing nothing and it is not

33841
22:24:14,080 --> 22:24:16,400
what you expect i was fooled a little

33842
22:24:16,400 --> 22:24:18,400
bit by the compiler because this was

33843
22:24:18,400 --> 22:24:20,800
compiling but it's not going to do what

33844
22:24:20,800 --> 22:24:23,512
you want when you call set doug name you

33845
22:24:23,512 --> 22:24:26,160
probably want to take this name and

33846
22:24:26,160 --> 22:24:28,800
assign that to the member variable name

33847
22:24:28,800 --> 22:24:31,120
of this class but this is not what it's

33848
22:24:31,120 --> 22:24:33,360
going to do let's build again and really

33849
22:24:33,360 --> 22:24:34,800
show you this

33850
22:24:34,800 --> 22:24:37,280
so it is a really good advice to

33851
22:24:37,280 --> 22:24:39,192
practice and really try things out

33852
22:24:39,192 --> 22:24:41,192
yourself we're going to run a rooster

33853
22:24:41,192 --> 22:24:43,120
you're going to see that after we set

33854
22:24:43,120 --> 22:24:45,832
the dog name here to pumbaa and we try

33855
22:24:45,832 --> 22:24:47,680
to print the information the information

33856
22:24:47,680 --> 22:24:49,600
is not going to be end the name is not

33857
22:24:49,600 --> 22:24:51,680
going to be pumbaa for the second call

33858
22:24:51,680 --> 22:24:54,000
here and what this is really doing is

33859
22:24:54,000 --> 22:24:56,080
doing nothing here this does nothing and

33860
22:24:56,080 --> 22:24:58,232
you really need to know this if you want

33861
22:24:58,232 --> 22:24:59,600
to affect

33862
22:24:59,600 --> 22:25:01,512
your remember variable you will have to

33863
22:25:01,512 --> 22:25:03,120
go through the this pointer and this is

33864
22:25:03,120 --> 22:25:04,400
going to tell

33865
22:25:04,400 --> 22:25:07,360
take the name member variable of

33866
22:25:07,360 --> 22:25:10,160
the current object and assign the value

33867
22:25:10,160 --> 22:25:12,800
in name the name parameter to that and

33868
22:25:12,800 --> 22:25:15,040
that's going to set your name to

33869
22:25:15,040 --> 22:25:17,440
whatever new name you passed when you

33870
22:25:17,440 --> 22:25:20,160
called the set dog name function here so

33871
22:25:20,160 --> 22:25:22,160
hopefully you really understand this now

33872
22:25:22,160 --> 22:25:23,920
if we both are going to see that the

33873
22:25:23,920 --> 22:25:26,640
pumbaa name has been applied let's boil

33874
22:25:26,640 --> 22:25:29,120
again so we're going to clear and run

33875
22:25:29,120 --> 22:25:31,280
rooster and we're going to see now that

33876
22:25:31,280 --> 22:25:33,760
the name is pumbaa and there is some

33877
22:25:33,760 --> 22:25:35,360
annoying thing we have in our

33878
22:25:35,360 --> 22:25:37,760
constructors we don't have a space

33879
22:25:37,760 --> 22:25:40,800
before at here and it is really annoying

33880
22:25:40,800 --> 22:25:43,040
to look at here so let's build again and

33881
22:25:43,040 --> 22:25:45,280
fix this we are going to use gcc the

33882
22:25:45,280 --> 22:25:47,360
world is good we can clear and run

33883
22:25:47,360 --> 22:25:50,552
rooster and now we have what we want so

33884
22:25:50,552 --> 22:25:52,640
this is the second use case you might

33885
22:25:52,640 --> 22:25:55,832
have for this pointer through setters

33886
22:25:55,832 --> 22:25:58,480
let's use the parameter that is named

33887
22:25:58,480 --> 22:26:01,760
the same as your member variables so

33888
22:26:01,760 --> 22:26:03,192
we're going to set up all the other

33889
22:26:03,192 --> 22:26:05,040
setters we're going to set up a setter

33890
22:26:05,040 --> 22:26:07,600
for the breed we're going to say std

33891
22:26:07,600 --> 22:26:10,480
strength view and it's going to be breed

33892
22:26:10,480 --> 22:26:12,800
we can do that because now we have tools

33893
22:26:12,800 --> 22:26:14,400
to really do this properly we're going

33894
22:26:14,400 --> 22:26:17,120
to say this breed and we're going to say

33895
22:26:17,120 --> 22:26:20,000
equals read this is going to do and we

33896
22:26:20,000 --> 22:26:22,320
can set the age and we're going to say

33897
22:26:22,320 --> 22:26:24,232
void set age

33898
22:26:24,232 --> 22:26:26,080
dog age and we're going to pass in a

33899
22:26:26,080 --> 22:26:28,720
value and we're going to go inside what

33900
22:26:28,720 --> 22:26:31,040
is it called it's called ph i don't

33901
22:26:31,040 --> 22:26:32,640
think it makes sense to call the

33902
22:26:32,640 --> 22:26:35,760
parameter ph because it's not a pointer

33903
22:26:35,760 --> 22:26:37,760
so we're going to go inside and just the

33904
22:26:37,760 --> 22:26:39,440
reference of a pointer so we're going to

33905
22:26:39,440 --> 22:26:40,960
dereference that

33906
22:26:40,960 --> 22:26:43,360
and we're going to say this so we're

33907
22:26:43,360 --> 22:26:46,720
going to go inside and say this ph

33908
22:26:46,720 --> 22:26:49,512
equals h i think this is going to work

33909
22:26:49,512 --> 22:26:51,920
and we need to reference this pointer

33910
22:26:51,920 --> 22:26:53,600
because what we have as a member

33911
22:26:53,600 --> 22:26:55,680
variable is the pointer so we need to go

33912
22:26:55,680 --> 22:26:57,920
through the ugly syntax you see here and

33913
22:26:57,920 --> 22:26:59,760
this is going to set our age so we can

33914
22:26:59,760 --> 22:27:01,360
go through this and really change the

33915
22:27:01,360 --> 22:27:03,440
information so we're going to change the

33916
22:27:03,440 --> 22:27:06,800
breed here set dog breed let's go down

33917
22:27:06,800 --> 22:27:08,960
and choose that and we're going to say

33918
22:27:08,960 --> 22:27:11,440
wirefox terrier and we're going to go

33919
22:27:11,440 --> 22:27:13,440
down and set the age we're going to say

33920
22:27:13,440 --> 22:27:16,720
guilt 1 set dog age and we're going to

33921
22:27:16,720 --> 22:27:19,680
say for why not so we change the

33922
22:27:19,680 --> 22:27:22,160
information of our dog through our

33923
22:27:22,160 --> 22:27:24,080
setters here and we're going to print

33924
22:27:24,080 --> 22:27:25,600
new information

33925
22:27:25,600 --> 22:27:27,832
let's build again we're going to use gcc

33926
22:27:27,832 --> 22:27:30,000
for that the build is good we can clear

33927
22:27:30,000 --> 22:27:32,400
and run rooster this is going to give us

33928
22:27:32,400 --> 22:27:34,480
new information for the second print

33929
22:27:34,480 --> 22:27:37,192
here so name is going to be pumba breed

33930
22:27:37,192 --> 22:27:39,440
is going to be wirefox terrier and age

33931
22:27:39,440 --> 22:27:41,040
is going to be four and we have the

33932
22:27:41,040 --> 22:27:43,920
information for our dog object here okay

33933
22:27:43,920 --> 22:27:46,480
now we have this and we want to see how

33934
22:27:46,480 --> 22:27:48,960
we can set up chained calls

33935
22:27:48,960 --> 22:27:51,512
using the this pointer and in this case

33936
22:27:51,512 --> 22:27:53,832
we will be using pointers let's change

33937
22:27:53,832 --> 22:27:56,640
our setters to return dog pointers we

33938
22:27:56,640 --> 22:27:58,800
can do that and we're going to go down

33939
22:27:58,800 --> 22:28:00,400
to say to dog breed we're going to

33940
22:28:00,400 --> 22:28:02,160
return the dog pointer

33941
22:28:02,160 --> 22:28:04,872
and we're going to go to set dog age and

33942
22:28:04,872 --> 22:28:07,360
we're going to return a dog pointer now

33943
22:28:07,360 --> 22:28:09,512
after we do this we will need to return

33944
22:28:09,512 --> 22:28:11,120
these pointers and we're going to go

33945
22:28:11,120 --> 22:28:14,400
inside and say return this remember this

33946
22:28:14,400 --> 22:28:16,480
contains the memory of the current

33947
22:28:16,480 --> 22:28:19,192
object so we can return this and fit

33948
22:28:19,192 --> 22:28:21,832
that to a returned pointer so we can go

33949
22:28:21,832 --> 22:28:23,832
down in all the other functions and

33950
22:28:23,832 --> 22:28:25,440
really save this we're going to say

33951
22:28:25,440 --> 22:28:28,160
return thus we return the memory address

33952
22:28:28,160 --> 22:28:30,160
of the current object

33953
22:28:30,160 --> 22:28:32,552
through the setters that we are doing

33954
22:28:32,552 --> 22:28:34,720
here we're going to return this

33955
22:28:34,720 --> 22:28:38,000
and after we do this we can change the

33956
22:28:38,000 --> 22:28:40,000
setting we are doing here to b1

33957
22:28:40,000 --> 22:28:42,720
statement and we can comment this out i

33958
22:28:42,720 --> 22:28:44,400
think we can do that and what we're

33959
22:28:44,400 --> 22:28:47,360
going to say is dope one and we're going

33960
22:28:47,360 --> 22:28:48,320
to say

33961
22:28:48,320 --> 22:28:50,720
set dog name and we're going to pass in

33962
22:28:50,720 --> 22:28:53,192
pumbaa but this is going to return a

33963
22:28:53,192 --> 22:28:55,760
pointer now set dog name is returning a

33964
22:28:55,760 --> 22:28:58,232
pointer to the current object and you

33965
22:28:58,232 --> 22:29:00,400
can see that here this is what we are

33966
22:29:00,400 --> 22:29:02,640
returning so we can go through this

33967
22:29:02,640 --> 22:29:05,040
pointer and call some other functions

33968
22:29:05,040 --> 22:29:08,000
for example we can say set dot breed

33969
22:29:08,000 --> 22:29:10,232
directly and the visual studio code is

33970
22:29:10,232 --> 22:29:11,832
going to figure out that what we are

33971
22:29:11,832 --> 22:29:14,000
returning is a pointer and it's going to

33972
22:29:14,000 --> 22:29:16,960
change our access notation here to a

33973
22:29:16,960 --> 22:29:19,440
pointer axis notation and we're going to

33974
22:29:19,440 --> 22:29:22,000
use this in one single statement so

33975
22:29:22,000 --> 22:29:24,232
we're going to put in our breed and

33976
22:29:24,232 --> 22:29:26,160
we're going to call the function to set

33977
22:29:26,160 --> 22:29:28,480
the age okay you see that it uses

33978
22:29:28,480 --> 22:29:30,320
pointer access notation and this is

33979
22:29:30,320 --> 22:29:32,000
really cool so we're going to put in our

33980
22:29:32,000 --> 22:29:33,920
four and you're going to see that this

33981
22:29:33,920 --> 22:29:36,160
actually works and this is really cool

33982
22:29:36,160 --> 22:29:38,320
if you don't want to do thanks in three

33983
22:29:38,320 --> 22:29:41,600
steps you can give your users the option

33984
22:29:41,600 --> 22:29:44,080
to do things in one step using returned

33985
22:29:44,080 --> 22:29:46,160
pointers like this and this is really

33986
22:29:46,160 --> 22:29:48,320
cool i use this all the time for my

33987
22:29:48,320 --> 22:29:51,440
classes that i design in my applications

33988
22:29:51,440 --> 22:29:54,160
so if we're both we're going to see that

33989
22:29:54,160 --> 22:29:55,920
the world is good and we're going to

33990
22:29:55,920 --> 22:29:58,480
clear and run rooster we're going to see

33991
22:29:58,480 --> 22:30:01,512
that the information is n name is pumbaa

33992
22:30:01,512 --> 22:30:04,320
breed is waterfox terrier and the age is

33993
22:30:04,320 --> 22:30:06,800
for and we were able to do all these

33994
22:30:06,800 --> 22:30:09,920
changes in one go so we can even change

33995
22:30:09,920 --> 22:30:12,872
this to use references here we are using

33996
22:30:12,872 --> 22:30:15,192
pointers so let's say that we are using

33997
22:30:15,192 --> 22:30:17,440
pointers but we can also use references

33998
22:30:17,440 --> 22:30:20,552
let's go on top here and say that this

33999
22:30:20,552 --> 22:30:22,720
is using pointers and we're going to

34000
22:30:22,720 --> 22:30:24,800
comment this out but before we do we're

34001
22:30:24,800 --> 22:30:26,720
going to copy all this because we're

34002
22:30:26,720 --> 22:30:28,480
going to need that

34003
22:30:28,480 --> 22:30:29,920
and we're going to

34004
22:30:29,920 --> 22:30:31,600
comment all this out and we're going to

34005
22:30:31,600 --> 22:30:34,080
go down and say change calls using

34006
22:30:34,080 --> 22:30:36,080
references and we're going to go down

34007
22:30:36,080 --> 22:30:38,232
and put in our code and we're going to

34008
22:30:38,232 --> 22:30:41,120
change our setters to return references

34009
22:30:41,120 --> 22:30:43,512
instead of pointers we can do that so

34010
22:30:43,512 --> 22:30:45,600
we're going to change the star here to

34011
22:30:45,600 --> 22:30:48,080
an ampersand symbol here and this is

34012
22:30:48,080 --> 22:30:50,232
going to do the magic so we have a dog

34013
22:30:50,232 --> 22:30:52,320
reference returned from all these

34014
22:30:52,320 --> 22:30:54,480
functions so because we are no longer

34015
22:30:54,480 --> 22:30:56,640
returning a pointer returning this

34016
22:30:56,640 --> 22:30:58,552
directly is going to give us a compiler

34017
22:30:58,552 --> 22:31:00,872
error we need to dereference this

34018
22:31:00,872 --> 22:31:03,360
pointer and get to what what is pointed

34019
22:31:03,360 --> 22:31:05,760
to now the compiler will know that we

34020
22:31:05,760 --> 22:31:08,160
are returning a reference to the current

34021
22:31:08,160 --> 22:31:10,480
object and this is the syntax we can use

34022
22:31:10,480 --> 22:31:13,360
to do this let's go down and dereference

34023
22:31:13,360 --> 22:31:16,232
all the returned pointers and if we go

34024
22:31:16,232 --> 22:31:17,760
down we're going to see that this is

34025
22:31:17,760 --> 22:31:20,320
good already and we can go down and set

34026
22:31:20,320 --> 22:31:23,120
up our chained call using references and

34027
22:31:23,120 --> 22:31:25,192
we're going to go down and say dog one

34028
22:31:25,192 --> 22:31:27,760
we're going to set dog name and we're

34029
22:31:27,760 --> 22:31:29,760
going to pass in pumbaa

34030
22:31:29,760 --> 22:31:31,512
what we have been doing all along now

34031
22:31:31,512 --> 22:31:33,120
we're going to use the dot access

34032
22:31:33,120 --> 22:31:36,320
notation because what we are returning

34033
22:31:36,320 --> 22:31:38,872
is a reference and you're going to see

34034
22:31:38,872 --> 22:31:40,720
that visual studio code is going to pick

34035
22:31:40,720 --> 22:31:43,832
this up the breed is going to be wirefox

34036
22:31:43,832 --> 22:31:46,960
and we're going to say set dog age and

34037
22:31:46,960 --> 22:31:49,440
we're going to pass in our four and

34038
22:31:49,440 --> 22:31:51,512
you're going to see that this is valid c

34039
22:31:51,512 --> 22:31:53,600
plus syntax and if we print the

34040
22:31:53,600 --> 22:31:55,192
information we're going to have new

34041
22:31:55,192 --> 22:31:58,640
information applied to our dog object

34042
22:31:58,640 --> 22:32:00,960
here we can weld and see that this is

34043
22:32:00,960 --> 22:32:02,720
actually working you see the world is

34044
22:32:02,720 --> 22:32:05,440
good we can clear and run rooster and

34045
22:32:05,440 --> 22:32:07,280
we're going to see that information has

34046
22:32:07,280 --> 22:32:10,960
been applied to our dog object so these

34047
22:32:10,960 --> 22:32:12,400
are a few examples

34048
22:32:12,400 --> 22:32:14,720
showing some of the usefulness for the

34049
22:32:14,720 --> 22:32:16,552
this pointer we have seen that we can

34050
22:32:16,552 --> 22:32:18,960
use the this pointer to print the memory

34051
22:32:18,960 --> 22:32:21,760
address of the current object if we go

34052
22:32:21,760 --> 22:32:24,552
down and look at our constructor and the

34053
22:32:24,552 --> 22:32:26,872
destructor we are printing the address

34054
22:32:26,872 --> 22:32:29,512
of the current object in our debug

34055
22:32:29,512 --> 22:32:31,360
statement here and this is really cool

34056
22:32:31,360 --> 22:32:33,440
we can use the this pointer to resolve

34057
22:32:33,440 --> 22:32:35,920
conflicts in our setters for example we

34058
22:32:35,920 --> 22:32:38,232
can use a parameter that has the same

34059
22:32:38,232 --> 22:32:40,720
name as the member variable and it's not

34060
22:32:40,720 --> 22:32:43,192
going to be really confusing and lead to

34061
22:32:43,192 --> 22:32:45,600
bad results it's going to change the

34062
22:32:45,600 --> 22:32:48,320
actual member variable and change it to

34063
22:32:48,320 --> 22:32:50,080
whatever you pass as the parameter and

34064
22:32:50,080 --> 22:32:52,320
this is really cool we can also use the

34065
22:32:52,320 --> 22:32:55,040
this pointer to set up change calls for

34066
22:32:55,040 --> 22:32:56,872
our function and we have seen that we

34067
22:32:56,872 --> 22:32:58,800
can do that either through returning

34068
22:32:58,800 --> 22:33:00,872
pointers like we are doing here and

34069
22:33:00,872 --> 22:33:03,760
using the this pointer as a return

34070
22:33:03,760 --> 22:33:06,720
object for our function here or we can

34071
22:33:06,720 --> 22:33:09,512
use returned pointers to do this and if

34072
22:33:09,512 --> 22:33:11,440
we do that we're going to be able to

34073
22:33:11,440 --> 22:33:14,320
call our functions in one go like we are

34074
22:33:14,320 --> 22:33:17,280
doing here using pointers or do the same

34075
22:33:17,280 --> 22:33:20,232
thing using references like we are doing

34076
22:33:20,232 --> 22:33:22,872
here this is really all we set out to do

34077
22:33:22,872 --> 22:33:24,480
in this lecture i hope you found it

34078
22:33:24,480 --> 22:33:26,720
interesting we are going to stop here in

34079
22:33:26,720 --> 22:33:28,400
this one the next one we're going to

34080
22:33:28,400 --> 22:33:31,040
learn about struct go ahead and finish

34081
22:33:31,040 --> 22:33:33,280
up here and meet me there in this

34082
22:33:33,280 --> 22:33:35,192
lecture we're going to learn about the

34083
22:33:35,192 --> 22:33:37,360
struct keyword and this is another

34084
22:33:37,360 --> 22:33:40,160
syntax you can use to create classes in

34085
22:33:40,160 --> 22:33:42,640
your c plus plus program we have seen

34086
22:33:42,640 --> 22:33:44,552
that we can already use the class

34087
22:33:44,552 --> 22:33:47,360
keyword to create our classes i have to

34088
22:33:47,360 --> 22:33:49,280
break it to you that we can also use

34089
22:33:49,280 --> 22:33:51,920
struct to do the same so the syntax here

34090
22:33:51,920 --> 22:33:54,232
is going to create a class called cat

34091
22:33:54,232 --> 22:33:56,080
and it's going to have a member variable

34092
22:33:56,080 --> 22:33:58,320
called string name the difference

34093
22:33:58,320 --> 22:34:01,600
between struct and class is that for

34094
22:34:01,600 --> 22:34:04,720
classes members are going to be private

34095
22:34:04,720 --> 22:34:07,192
by default and when you do something

34096
22:34:07,192 --> 22:34:09,680
like this and create class objects you

34097
22:34:09,680 --> 22:34:11,680
want to be able to access the name here

34098
22:34:11,680 --> 22:34:13,680
directly for example from the main

34099
22:34:13,680 --> 22:34:15,512
function if you do that you're going to

34100
22:34:15,512 --> 22:34:17,920
get a compiler error because class

34101
22:34:17,920 --> 22:34:21,040
members are private by default but if

34102
22:34:21,040 --> 22:34:23,600
you use struct members are going to be

34103
22:34:23,600 --> 22:34:26,000
public by default and you will have

34104
22:34:26,000 --> 22:34:28,872
direct access from the outside this is

34105
22:34:28,872 --> 22:34:31,120
the only difference between class and

34106
22:34:31,120 --> 22:34:33,280
struct otherwise you can use them

34107
22:34:33,280 --> 22:34:35,440
interchangeably and they are going to do

34108
22:34:35,440 --> 22:34:37,360
the same things we have been seeing for

34109
22:34:37,360 --> 22:34:39,512
classes they really are the same things

34110
22:34:39,512 --> 22:34:41,512
the only difference is that classes are

34111
22:34:41,512 --> 22:34:43,512
going to have private member variables

34112
22:34:43,512 --> 22:34:46,640
by default and struct will have public

34113
22:34:46,640 --> 22:34:49,512
member variables by default but we can

34114
22:34:49,512 --> 22:34:51,832
change this defaults by putting in our

34115
22:34:51,832 --> 22:34:54,800
own public and private sections inside

34116
22:34:54,800 --> 22:34:57,192
our class so for example here you see

34117
22:34:57,192 --> 22:34:59,440
that we have changed our dog class to

34118
22:34:59,440 --> 22:35:01,600
have a public member variable through

34119
22:35:01,600 --> 22:35:04,160
the public keyword here and we can do

34120
22:35:04,160 --> 22:35:06,160
the same for cat for example we can put

34121
22:35:06,160 --> 22:35:08,232
in a public section and a private

34122
22:35:08,232 --> 22:35:10,232
section and it's going to behave like

34123
22:35:10,232 --> 22:35:12,800
classes we have been welding so far

34124
22:35:12,800 --> 22:35:15,360
one common use we have for struct is

34125
22:35:15,360 --> 22:35:19,120
when we have to set up classes that only

34126
22:35:19,120 --> 22:35:21,760
have public member variables for example

34127
22:35:21,760 --> 22:35:24,232
you can need to set up a point

34128
22:35:24,232 --> 22:35:26,960
model in your c plus plus program and

34129
22:35:26,960 --> 22:35:28,720
you can set up a class like this you can

34130
22:35:28,720 --> 22:35:30,800
say struct point you're going to put in

34131
22:35:30,800 --> 22:35:32,720
the member variables and they are going

34132
22:35:32,720 --> 22:35:34,720
to be directly accessible from the

34133
22:35:34,720 --> 22:35:36,720
outside and this is something you will

34134
22:35:36,720 --> 22:35:39,600
see a lot out there so this is really

34135
22:35:39,600 --> 22:35:41,680
all about struct we're going to head

34136
22:35:41,680 --> 22:35:43,680
over to visual studio code and play with

34137
22:35:43,680 --> 22:35:46,480
us a little more okay here we are in our

34138
22:35:46,480 --> 22:35:48,800
working folder the current project is

34139
22:35:48,800 --> 22:35:51,360
struct we're going to grab our template

34140
22:35:51,360 --> 22:35:53,192
files and we're going to put them in

34141
22:35:53,192 --> 22:35:56,480
place struct that's all project here

34142
22:35:56,480 --> 22:35:58,552
and we're going to open this in visual

34143
22:35:58,552 --> 22:36:00,160
studio code

34144
22:36:00,160 --> 22:36:02,232
let's grab extract and drag and drop on

34145
22:36:02,232 --> 22:36:04,232
top of visual studio code here this is

34146
22:36:04,232 --> 22:36:07,192
going to open our folder we can now open

34147
22:36:07,192 --> 22:36:09,920
the main cpp file and clean things up a

34148
22:36:09,920 --> 22:36:11,680
little bit okay so we're going to set up

34149
22:36:11,680 --> 22:36:13,920
a simple class called dog we're going to

34150
22:36:13,920 --> 22:36:16,480
say class dog and inside we're going to

34151
22:36:16,480 --> 22:36:18,800
have a member variable called name it's

34152
22:36:18,800 --> 22:36:21,192
going to be an std strand let's say dog

34153
22:36:21,192 --> 22:36:23,680
name or m name to mean that it is a

34154
22:36:23,680 --> 22:36:25,680
member variable this is a syntax you

34155
22:36:25,680 --> 22:36:28,400
will see a lot in c plus plus out there

34156
22:36:28,400 --> 22:36:30,552
so let's use this from now on we're

34157
22:36:30,552 --> 22:36:33,280
going to say m name and we're going to

34158
22:36:33,280 --> 22:36:36,080
have another class let's put our

34159
22:36:36,080 --> 22:36:38,320
semicolon we're going to use struct to

34160
22:36:38,320 --> 22:36:40,552
set up another one and it's going to be

34161
22:36:40,552 --> 22:36:43,040
called dog let's call this cat and we

34162
22:36:43,040 --> 22:36:44,960
are going to go inside and set up our

34163
22:36:44,960 --> 22:36:46,800
member variable we're going to say std

34164
22:36:46,800 --> 22:36:48,960
strength m name and it's not going to

34165
22:36:48,960 --> 22:36:51,680
have anything m so if we create objects

34166
22:36:51,680 --> 22:36:54,640
of these classes and try to access them

34167
22:36:54,640 --> 22:36:56,872
we're going to see the fundamental

34168
22:36:56,872 --> 22:36:59,040
difference between structure and dog

34169
22:36:59,040 --> 22:37:00,720
let's create a dog and we're going to

34170
22:37:00,720 --> 22:37:03,040
say dog one and we're going to create a

34171
22:37:03,040 --> 22:37:05,192
cat and we're going to say cat one and

34172
22:37:05,192 --> 22:37:08,872
if we do dog 1 and try to access the m

34173
22:37:08,872 --> 22:37:10,872
name member variable

34174
22:37:10,872 --> 22:37:13,192
maybe set it to something else let's say

34175
22:37:13,192 --> 22:37:15,120
fluffy we're going to have a compiler

34176
22:37:15,120 --> 22:37:18,320
error because members of a class are

34177
22:37:18,320 --> 22:37:20,480
private by default and we can't really

34178
22:37:20,480 --> 22:37:21,600
do this

34179
22:37:21,600 --> 22:37:23,440
so we are trying to access something

34180
22:37:23,440 --> 22:37:25,600
that is private from the outside we're

34181
22:37:25,600 --> 22:37:27,440
going to get a compiler error okay so we

34182
22:37:27,440 --> 22:37:29,680
have a squiggly line here but if we try

34183
22:37:29,680 --> 22:37:31,920
to do the same for a cat it's going to

34184
22:37:31,920 --> 22:37:34,320
go through because cat is destruct and

34185
22:37:34,320 --> 22:37:37,760
members of structs are public by default

34186
22:37:37,760 --> 22:37:39,440
let's do that and really show you this

34187
22:37:39,440 --> 22:37:41,920
we're going to say cat1 and we're going

34188
22:37:41,920 --> 22:37:44,160
to say m name and we're going to give it

34189
22:37:44,160 --> 22:37:47,440
a name and let's say johnny i am making

34190
22:37:47,440 --> 22:37:49,600
this up i don't know if there is any cat

34191
22:37:49,600 --> 22:37:51,760
named johnny but we're going to use this

34192
22:37:51,760 --> 22:37:53,280
and you're going to see that we don't

34193
22:37:53,280 --> 22:37:55,600
have any squiggly line we're going to

34194
22:37:55,600 --> 22:37:58,080
build and see if gcc is going to take

34195
22:37:58,080 --> 22:37:59,920
this it's going to take it the world is

34196
22:37:59,920 --> 22:38:02,720
good we can bring up a terminal and run

34197
22:38:02,720 --> 22:38:04,800
the program and we're not going to see

34198
22:38:04,800 --> 22:38:06,552
anything because we're not printing

34199
22:38:06,552 --> 22:38:09,120
anything from the main function here but

34200
22:38:09,120 --> 22:38:11,832
if we want we can print this name of our

34201
22:38:11,832 --> 22:38:15,040
cat we're going to say sddc out and say

34202
22:38:15,040 --> 22:38:17,600
cat one name and if we build we're going

34203
22:38:17,600 --> 22:38:20,480
to see that so the both should be good

34204
22:38:20,480 --> 22:38:23,512
it is good we can clear and run rooster

34205
22:38:23,512 --> 22:38:25,440
and we have johnny printed out and this

34206
22:38:25,440 --> 22:38:27,192
is the name of volca and this is really

34207
22:38:27,192 --> 22:38:29,920
the difference between class and strut

34208
22:38:29,920 --> 22:38:32,000
members of classes are going to be

34209
22:38:32,000 --> 22:38:34,480
private by default members of struct are

34210
22:38:34,480 --> 22:38:36,872
going to be public by default but we can

34211
22:38:36,872 --> 22:38:38,872
change these defaults for example let's

34212
22:38:38,872 --> 22:38:41,360
make everything public we can do that no

34213
22:38:41,360 --> 22:38:42,800
big deal here

34214
22:38:42,800 --> 22:38:45,680
and we can move this a little bit to the

34215
22:38:45,680 --> 22:38:48,800
right so that things are aligned nicely

34216
22:38:48,800 --> 22:38:51,600
and we can do the same for struct okay

34217
22:38:51,600 --> 22:38:54,800
so let's align this now if we do this we

34218
22:38:54,800 --> 22:38:56,872
will be able to go in the main function

34219
22:38:56,872 --> 22:38:58,800
and say dog name and change that and

34220
22:38:58,800 --> 22:39:00,480
we're going to be able to see that if we

34221
22:39:00,480 --> 22:39:03,832
print that out so let's go down and say

34222
22:39:03,832 --> 22:39:08,000
stdc out and say dog1 name and print

34223
22:39:08,000 --> 22:39:09,360
that out

34224
22:39:09,360 --> 22:39:11,120
and if we build now we're going to see

34225
22:39:11,120 --> 22:39:13,512
the name of our dog printed out okay

34226
22:39:13,512 --> 22:39:15,440
well this is good we can bring this up

34227
22:39:15,440 --> 22:39:18,320
and clear a little bit and run rooster

34228
22:39:18,320 --> 22:39:20,232
we're going to see fluffy our dog name

34229
22:39:20,232 --> 22:39:22,960
and johnny our cat name so this is

34230
22:39:22,960 --> 22:39:25,832
really all about classes and struct they

34231
22:39:25,832 --> 22:39:27,760
are the same things but the only

34232
22:39:27,760 --> 22:39:29,512
difference is the defaults that come

34233
22:39:29,512 --> 22:39:31,832
with these things but the common use we

34234
22:39:31,832 --> 22:39:34,800
have for struct is when we want to set

34235
22:39:34,800 --> 22:39:37,832
up a class that only has direct member

34236
22:39:37,832 --> 22:39:40,320
variables and we don't intend to put

34237
22:39:40,320 --> 22:39:43,040
methods into that class a good example

34238
22:39:43,040 --> 22:39:45,280
of this is the struct off point so

34239
22:39:45,280 --> 22:39:47,760
suppose we want to model points in our c

34240
22:39:47,760 --> 22:39:50,080
plus plus program so we can do something

34241
22:39:50,080 --> 22:39:52,232
like this and a point is going to have

34242
22:39:52,232 --> 22:39:55,040
two coordinates x and y we're going to

34243
22:39:55,040 --> 22:39:57,832
say double y and from this point on we

34244
22:39:57,832 --> 22:39:59,920
will be able to create point objects and

34245
22:39:59,920 --> 22:40:02,320
print them out however we want so for

34246
22:40:02,320 --> 22:40:04,800
example we can go down and say point

34247
22:40:04,800 --> 22:40:07,600
point one and from this point we can go

34248
22:40:07,600 --> 22:40:11,040
in and say 0.1 and say x and assign a

34249
22:40:11,040 --> 22:40:13,360
value to x let's put in a 10 and we're

34250
22:40:13,360 --> 22:40:17,040
going to go down and say point 1 y and

34251
22:40:17,040 --> 22:40:18,720
we're going to give it a value let's put

34252
22:40:18,720 --> 22:40:19,480
in

34253
22:40:19,480 --> 22:40:22,232
55.5 why not and we can do whatever we

34254
22:40:22,232 --> 22:40:24,232
want with this point for example we can

34255
22:40:24,232 --> 22:40:25,760
set up a function which is going to

34256
22:40:25,760 --> 22:40:28,232
print a point we can do that let's say

34257
22:40:28,232 --> 22:40:30,720
void print point and we're going to pass

34258
22:40:30,720 --> 22:40:33,192
the point by value or we can even use

34259
22:40:33,192 --> 22:40:35,040
references because this is going to be

34260
22:40:35,040 --> 22:40:37,600
an object const point reference i think

34261
22:40:37,600 --> 22:40:39,280
this is going to do and we're going to

34262
22:40:39,280 --> 22:40:41,760
go inside and print the information

34263
22:40:41,760 --> 22:40:43,040
we're going to say

34264
22:40:43,040 --> 22:40:45,600
hddc out point and we're going to put

34265
22:40:45,600 --> 22:40:48,232
the coordinates on we're going to say x

34266
22:40:48,232 --> 22:40:51,760
is going to be point x and y is going to

34267
22:40:51,760 --> 22:40:54,480
be point y why not and we're going to

34268
22:40:54,480 --> 22:40:57,120
put in our closing square bracket and

34269
22:40:57,120 --> 22:40:59,440
we're going to say stdndl

34270
22:40:59,440 --> 22:41:02,080
to put a new line character after our

34271
22:41:02,080 --> 22:41:04,552
print here now we can go down and say

34272
22:41:04,552 --> 22:41:07,680
print point and pass on point one

34273
22:41:07,680 --> 22:41:10,080
and if we do that we're going to build

34274
22:41:10,080 --> 22:41:11,760
and we're going to do that through gcc

34275
22:41:11,760 --> 22:41:14,480
you see the both is good now if we print

34276
22:41:14,480 --> 22:41:16,800
we should see the information about our

34277
22:41:16,800 --> 22:41:19,480
point and we see point x 1 y

34278
22:41:19,480 --> 22:41:21,192
55.5

34279
22:41:21,192 --> 22:41:22,400
and we see

34280
22:41:22,400 --> 22:41:26,640
point x is 10 y is 55.5

34281
22:41:26,640 --> 22:41:28,400
we can go down and change the

34282
22:41:28,400 --> 22:41:30,160
information about our point for example

34283
22:41:30,160 --> 22:41:33,440
we can copy this and go down and change

34284
22:41:33,440 --> 22:41:35,720
x to

34285
22:41:35,720 --> 22:41:37,440
40.4

34286
22:41:37,440 --> 22:41:39,872
and y to

34287
22:41:39,872 --> 22:41:42,800
2.7 why not and if we print the

34288
22:41:42,800 --> 22:41:44,552
information about our point we're going

34289
22:41:44,552 --> 22:41:46,480
to see that we have new information and

34290
22:41:46,480 --> 22:41:48,480
we're going to print point one and

34291
22:41:48,480 --> 22:41:50,000
therefore world we're going to see the

34292
22:41:50,000 --> 22:41:52,320
new information so the build is good we

34293
22:41:52,320 --> 22:41:55,120
can clear and run rooster now you see

34294
22:41:55,120 --> 22:41:57,120
new information in our point so this is

34295
22:41:57,120 --> 22:41:59,120
really the difference between class and

34296
22:41:59,120 --> 22:42:01,192
struct the only difference is going to

34297
22:42:01,192 --> 22:42:03,920
be in the defaults and struct is mostly

34298
22:42:03,920 --> 22:42:07,040
useful if you want to set up classes

34299
22:42:07,040 --> 22:42:09,920
that only have public member variables

34300
22:42:09,920 --> 22:42:12,232
and you don't really want to use

34301
22:42:12,232 --> 22:42:14,960
functions or methods in that class and

34302
22:42:14,960 --> 22:42:17,280
we have an example of that here and if

34303
22:42:17,280 --> 22:42:19,360
you have a case like that you will use

34304
22:42:19,360 --> 22:42:21,120
struct your code is going to be much

34305
22:42:21,120 --> 22:42:24,160
easier to read and understand from the

34306
22:42:24,160 --> 22:42:26,480
perspective of other c plus plus

34307
22:42:26,480 --> 22:42:29,040
developers we are going to stop here in

34308
22:42:29,040 --> 22:42:30,640
this lecture and the last one we're

34309
22:42:30,640 --> 22:42:34,000
going to learn about the size of objects

34310
22:42:34,000 --> 22:42:36,400
go ahead and finish up here and meet me

34311
22:42:36,400 --> 22:42:37,440
there

34312
22:42:37,440 --> 22:42:38,872
in this lecture we're going to learn

34313
22:42:38,872 --> 22:42:42,552
about sizes of class objects and try to

34314
22:42:42,552 --> 22:42:43,920
think about it

34315
22:42:43,920 --> 22:42:46,552
what are we going to see if we try to

34316
22:42:46,552 --> 22:42:49,440
print the size of our class here called

34317
22:42:49,440 --> 22:42:51,920
wrapper inside we have two member

34318
22:42:51,920 --> 22:42:54,640
variables which are of and type

34319
22:42:54,640 --> 22:42:56,480
and we have a member variable which is

34320
22:42:56,480 --> 22:43:00,000
of std string type what do you think

34321
22:43:00,000 --> 22:43:01,360
we'll see

34322
22:43:01,360 --> 22:43:04,000
when we print the size of this wrapper

34323
22:43:04,000 --> 22:43:05,832
object here

34324
22:43:05,832 --> 22:43:08,160
try to think about it so what c plus

34325
22:43:08,160 --> 22:43:11,120
plus does it's going to only account for

34326
22:43:11,120 --> 22:43:13,760
the size of your member variables so

34327
22:43:13,760 --> 22:43:15,760
it's going to add to the sizes of these

34328
22:43:15,760 --> 22:43:17,512
guys in memory so we know an end is

34329
22:43:17,512 --> 22:43:19,600
going to take four bytes in memory so

34330
22:43:19,600 --> 22:43:21,440
we're going to have eight bytes for

34331
22:43:21,440 --> 22:43:23,760
these two ants and we're going to have

34332
22:43:23,760 --> 22:43:26,160
an unspecified amount of memory for a

34333
22:43:26,160 --> 22:43:28,480
strength because a strength is

34334
22:43:28,480 --> 22:43:32,000
internally implemented as a class and it

34335
22:43:32,000 --> 22:43:35,440
stores its data as cost car pointers so

34336
22:43:35,440 --> 22:43:37,512
we have really a pointer

34337
22:43:37,512 --> 22:43:41,440
and the size of an object doesn't really

34338
22:43:41,440 --> 22:43:43,920
account for thanks you are referring to

34339
22:43:43,920 --> 22:43:46,400
using pointers it may count to the size

34340
22:43:46,400 --> 22:43:48,800
of the pointer itself but it's not going

34341
22:43:48,800 --> 22:43:51,512
to count what is pointed to and in the

34342
22:43:51,512 --> 22:43:53,280
case of string for example we really

34343
22:43:53,280 --> 22:43:54,640
want to know

34344
22:43:54,640 --> 22:43:57,040
the range of things that we are pointing

34345
22:43:57,040 --> 22:43:58,872
to so we're not going to have correct

34346
22:43:58,872 --> 22:44:01,832
information with hdd string here but in

34347
22:44:01,832 --> 22:44:04,400
general the size of an object is going

34348
22:44:04,400 --> 22:44:07,360
to be the sum of the sizes of its member

34349
22:44:07,360 --> 22:44:09,512
variables the functions are not going to

34350
22:44:09,512 --> 22:44:11,832
be counted then the functions are just

34351
22:44:11,832 --> 22:44:14,160
helper functions that live somewhere in

34352
22:44:14,160 --> 22:44:16,080
memory but they're not going to be

34353
22:44:16,080 --> 22:44:19,120
accounted for in the size of your object

34354
22:44:19,120 --> 22:44:21,360
another reason you might think functions

34355
22:44:21,360 --> 22:44:23,832
are not accounted for in the size of the

34356
22:44:23,832 --> 22:44:26,232
object is that really functions are

34357
22:44:26,232 --> 22:44:29,040
affiliated with the class itself

34358
22:44:29,040 --> 22:44:31,680
functions are not affiliated with class

34359
22:44:31,680 --> 22:44:33,760
objects the class is going to be the

34360
22:44:33,760 --> 22:44:35,360
blueprint from which we're going to

34361
22:44:35,360 --> 22:44:38,000
generate thousands of objects if we want

34362
22:44:38,000 --> 22:44:39,920
but the functions or the methods are

34363
22:44:39,920 --> 22:44:42,640
going to be associated to the blueprint

34364
22:44:42,640 --> 22:44:45,120
itself so it really wouldn't make sense

34365
22:44:45,120 --> 22:44:47,680
to associate the size of those functions

34366
22:44:47,680 --> 22:44:51,120
in memory to class objects now that you

34367
22:44:51,120 --> 22:44:53,440
have this idea let's head over to visual

34368
22:44:53,440 --> 22:44:54,960
studio code and play with this a little

34369
22:44:54,960 --> 22:44:57,512
more okay we have saved that the size is

34370
22:44:57,512 --> 22:44:59,512
mostly going to be the sum of the sizes

34371
22:44:59,512 --> 22:45:01,920
for the member variables but this is not

34372
22:45:01,920 --> 22:45:04,720
always correct because of a phenomenon

34373
22:45:04,720 --> 22:45:05,760
we called

34374
22:45:05,760 --> 22:45:07,920
boundary alignment

34375
22:45:07,920 --> 22:45:10,400
binary alignment is a thing most

34376
22:45:10,400 --> 22:45:13,120
compilers do when they have member

34377
22:45:13,120 --> 22:45:16,000
variables of different types and member

34378
22:45:16,000 --> 22:45:18,552
variables that have the size of four

34379
22:45:18,552 --> 22:45:20,720
bytes in memory are going to be stored

34380
22:45:20,720 --> 22:45:23,600
at memory locations that are multiples

34381
22:45:23,600 --> 22:45:26,480
of four and because of this phenomenon

34382
22:45:26,480 --> 22:45:29,760
we might have gaps between our memory if

34383
22:45:29,760 --> 22:45:32,000
we have variables for example that are

34384
22:45:32,000 --> 22:45:34,640
of two bytes in memory and four bytes in

34385
22:45:34,640 --> 22:45:36,800
memory and we're going to have gaps

34386
22:45:36,800 --> 22:45:39,680
inside and the size of the object is

34387
22:45:39,680 --> 22:45:42,232
going to be slightly off the sum we

34388
22:45:42,232 --> 22:45:44,800
might do for the sizes of our object i

34389
22:45:44,800 --> 22:45:46,960
realize this may be confusing we're

34390
22:45:46,960 --> 22:45:48,960
going to head over to visual studio code

34391
22:45:48,960 --> 22:45:50,720
and we're going to see a few examples

34392
22:45:50,720 --> 22:45:53,360
okay here we are in our working folder

34393
22:45:53,360 --> 22:45:56,000
the current project is size of class

34394
22:45:56,000 --> 22:45:58,720
objects we're going to grab our template

34395
22:45:58,720 --> 22:46:01,120
files pretty quick and we're going to

34396
22:46:01,120 --> 22:46:03,832
put them in place and we're going to

34397
22:46:03,832 --> 22:46:06,480
open our project in visual studio code

34398
22:46:06,480 --> 22:46:08,480
by dragging and dropping here we have

34399
22:46:08,480 --> 22:46:11,360
our main cpp file we can close the left

34400
22:46:11,360 --> 22:46:12,640
sidebar

34401
22:46:12,640 --> 22:46:15,040
and we can clean the main function here

34402
22:46:15,040 --> 22:46:16,552
we're going to set up a simple class

34403
22:46:16,552 --> 22:46:19,360
let's call this dog why not we have been

34404
22:46:19,360 --> 22:46:22,080
using dove so let's use this again

34405
22:46:22,080 --> 22:46:24,320
we're going to put our closing semicolon

34406
22:46:24,320 --> 22:46:26,480
we're going to put a public section and

34407
22:46:26,480 --> 22:46:29,192
it's going to just contain a constructor

34408
22:46:29,192 --> 22:46:30,960
and we're going to say dog and we're

34409
22:46:30,960 --> 22:46:32,872
going to use the default and we're going

34410
22:46:32,872 --> 22:46:35,680
to put in a private section and

34411
22:46:35,680 --> 22:46:38,552
in here we're going to put in a size t

34412
22:46:38,552 --> 22:46:39,600
and say

34413
22:46:39,600 --> 22:46:42,552
this is the leg count of the dog why not

34414
22:46:42,552 --> 22:46:45,192
let's say we are modeling this okay so

34415
22:46:45,192 --> 22:46:48,320
now we have our dog class in place we

34416
22:46:48,320 --> 22:46:50,552
can create objects of this dog class

34417
22:46:50,552 --> 22:46:52,080
we're going to say dog

34418
22:46:52,080 --> 22:46:54,552
dog one and if we do this we are

34419
22:46:54,552 --> 22:46:57,760
interested in knowing the size of our

34420
22:46:57,760 --> 22:46:59,280
dog class here

34421
22:46:59,280 --> 22:47:03,120
so we are going to say stdc out size of

34422
22:47:03,120 --> 22:47:06,160
dog and save that and uh fingers crossed

34423
22:47:06,160 --> 22:47:08,000
we're going to see the size of our dog

34424
22:47:08,000 --> 22:47:10,400
object here and try to guess what we're

34425
22:47:10,400 --> 22:47:12,640
going to get in the slides we have seen

34426
22:47:12,640 --> 22:47:15,512
that the size is mostly going to be

34427
22:47:15,512 --> 22:47:17,832
the sum of the size of the member

34428
22:47:17,832 --> 22:47:18,960
variables

34429
22:47:18,960 --> 22:47:21,600
and let's print the size of size t here

34430
22:47:21,600 --> 22:47:24,000
because size d is our only member

34431
22:47:24,000 --> 22:47:25,832
variable so i think it's going to be

34432
22:47:25,832 --> 22:47:28,480
helpful to see its size printed out

34433
22:47:28,480 --> 22:47:30,232
so we're going to have some context if

34434
22:47:30,232 --> 22:47:32,320
we do that we're going to say size of

34435
22:47:32,320 --> 22:47:34,872
size t and we're going to

34436
22:47:34,872 --> 22:47:36,800
save that and we're going to build this

34437
22:47:36,800 --> 22:47:38,872
program let's do that we're going to

34438
22:47:38,872 --> 22:47:41,120
pass this through gcc you see the both

34439
22:47:41,120 --> 22:47:42,232
is good

34440
22:47:42,232 --> 22:47:44,232
and we're going to bring up a terminal

34441
22:47:44,232 --> 22:47:47,040
and run this see what happens okay we

34442
22:47:47,040 --> 22:47:50,160
see size of size t is eight and the size

34443
22:47:50,160 --> 22:47:53,440
of our dark object is eight and this is

34444
22:47:53,440 --> 22:47:56,552
really cool because we see that the size

34445
22:47:56,552 --> 22:47:59,360
of our class object is really the size

34446
22:47:59,360 --> 22:48:00,960
of our

34447
22:48:00,960 --> 22:48:03,192
member variables that we have in here

34448
22:48:03,192 --> 22:48:05,192
let's set up another member variable and

34449
22:48:05,192 --> 22:48:07,192
really show you this so we're going to

34450
22:48:07,192 --> 22:48:10,080
have arm account okay so we are just

34451
22:48:10,080 --> 22:48:11,920
messing with us to learn

34452
22:48:11,920 --> 22:48:14,640
i don't aim for this class here to make

34453
22:48:14,640 --> 22:48:17,120
some sense practically we just want to

34454
22:48:17,120 --> 22:48:20,000
see how the member variables affect the

34455
22:48:20,000 --> 22:48:23,280
size of our class object now we have two

34456
22:48:23,280 --> 22:48:25,600
member variables and we're going to try

34457
22:48:25,600 --> 22:48:27,760
and world we're going to use gcc to do

34458
22:48:27,760 --> 22:48:30,160
that and we're going to clear and run

34459
22:48:30,160 --> 22:48:31,280
rooster

34460
22:48:31,280 --> 22:48:33,600
now you see that size of doug is 16 and

34461
22:48:33,600 --> 22:48:34,872
this is really

34462
22:48:34,872 --> 22:48:37,920
proven that the size of an object is

34463
22:48:37,920 --> 22:48:40,640
only accounting for the sizes of the

34464
22:48:40,640 --> 22:48:42,960
member variables it's not going to count

34465
22:48:42,960 --> 22:48:45,600
the functions that we have here so if

34466
22:48:45,600 --> 22:48:48,320
for example we had a function that says

34467
22:48:48,320 --> 22:48:50,400
printful and we have another one that

34468
22:48:50,400 --> 22:48:52,800
says do something this is not going to

34469
22:48:52,800 --> 22:48:55,360
change the size of our object because

34470
22:48:55,360 --> 22:48:58,720
functions aren't accounted for in the

34471
22:48:58,720 --> 22:49:01,192
size of our object here

34472
22:49:01,192 --> 22:49:04,400
so let's build and really show you this

34473
22:49:04,400 --> 22:49:06,552
the world is good we can clear and run

34474
22:49:06,552 --> 22:49:08,640
rooster we see that we have the same

34475
22:49:08,640 --> 22:49:11,920
sizes the size of dog is 16 the size of

34476
22:49:11,920 --> 22:49:14,872
size t is eight we can even use object

34477
22:49:14,872 --> 22:49:16,872
names here for example we are using the

34478
22:49:16,872 --> 22:49:19,440
class itself but we can use dog one here

34479
22:49:19,440 --> 22:49:20,480
and we're going to get the same

34480
22:49:20,480 --> 22:49:23,040
information let's both and we're going

34481
22:49:23,040 --> 22:49:25,760
to clear and run rooster

34482
22:49:25,760 --> 22:49:28,160
and you see that we have the same size

34483
22:49:28,160 --> 22:49:30,800
so if we change this thing to put in a

34484
22:49:30,800 --> 22:49:32,400
pointer we're going to see something

34485
22:49:32,400 --> 22:49:35,832
else let's put in an end pointer

34486
22:49:35,832 --> 22:49:38,480
and let's say ph like we have been doing

34487
22:49:38,480 --> 22:49:40,872
all along and see what we get and we

34488
22:49:40,872 --> 22:49:43,280
know that the size of a pointer on my

34489
22:49:43,280 --> 22:49:45,680
system let's print that out so that we

34490
22:49:45,680 --> 22:49:48,552
have no doubt let's for example say size

34491
22:49:48,552 --> 22:49:51,760
of end pointer is going to be size of

34492
22:49:51,760 --> 22:49:54,400
end pointer okay let's build we're going

34493
22:49:54,400 --> 22:49:55,280
to

34494
22:49:55,280 --> 22:49:58,000
pass this through gcc and the both is

34495
22:49:58,000 --> 22:50:00,400
going to be good we can clear and run

34496
22:50:00,400 --> 22:50:02,480
rooster we're going to see that we have

34497
22:50:02,480 --> 22:50:05,440
24 because we have two member variables

34498
22:50:05,440 --> 22:50:07,360
that are going to be eight bytes in

34499
22:50:07,360 --> 22:50:10,800
memory of size t they are of type size t

34500
22:50:10,800 --> 22:50:13,040
and we have a pointer which is going to

34501
22:50:13,040 --> 22:50:15,920
have a size of h in memory but we don't

34502
22:50:15,920 --> 22:50:18,552
care what this pointer is pointing to

34503
22:50:18,552 --> 22:50:20,400
if for example this pointer is pointing

34504
22:50:20,400 --> 22:50:22,480
to something really large

34505
22:50:22,480 --> 22:50:24,160
we don't care we're just going to

34506
22:50:24,160 --> 22:50:26,480
account for the end pointer here and

34507
22:50:26,480 --> 22:50:29,600
this is really phenomenal because if for

34508
22:50:29,600 --> 22:50:32,232
example we tried to set up an sdd string

34509
22:50:32,232 --> 22:50:33,280
object

34510
22:50:33,280 --> 22:50:35,832
and by now you should know that std

34511
22:50:35,832 --> 22:50:39,192
strand itself is implemented as a class

34512
22:50:39,192 --> 22:50:41,760
in c plus plus so it's really a class

34513
22:50:41,760 --> 22:50:44,080
and we can print its size so let's set

34514
22:50:44,080 --> 22:50:45,680
up a string object here we're going to

34515
22:50:45,680 --> 22:50:48,552
say std strung and we're going to say

34516
22:50:48,552 --> 22:50:50,800
name and we're going to initialize this

34517
22:50:50,800 --> 22:50:52,800
with hello world okay we're going to see

34518
22:50:52,800 --> 22:50:55,192
something really strange here so if we

34519
22:50:55,192 --> 22:50:57,120
print the size of name here we're going

34520
22:50:57,120 --> 22:51:00,232
to say size of name and we're going to

34521
22:51:00,232 --> 22:51:02,320
print that let's see what we get we're

34522
22:51:02,320 --> 22:51:03,760
going to run

34523
22:51:03,760 --> 22:51:05,600
and we're going to

34524
22:51:05,600 --> 22:51:08,640
see the block is good and can clear and

34525
22:51:08,640 --> 22:51:10,400
run roaster we're going to see that size

34526
22:51:10,400 --> 22:51:12,872
of name is 32.

34527
22:51:12,872 --> 22:51:16,400
let's change the text inside our string

34528
22:51:16,400 --> 22:51:18,080
and see that we change accordingly

34529
22:51:18,080 --> 22:51:20,160
because this can really be confusing

34530
22:51:20,160 --> 22:51:23,920
let's say i am the king of the universe

34531
22:51:23,920 --> 22:51:26,000
why not and we're going to build again

34532
22:51:26,000 --> 22:51:28,232
let's see what we get fingers crossed

34533
22:51:28,232 --> 22:51:30,552
this is going to blow your mind you see

34534
22:51:30,552 --> 22:51:32,720
we have the same size for name even if

34535
22:51:32,720 --> 22:51:35,360
we are changing the text in here so what

34536
22:51:35,360 --> 22:51:38,000
is really happening the strength is

34537
22:51:38,000 --> 22:51:41,440
storing our text here as cost card

34538
22:51:41,440 --> 22:51:42,400
pointer

34539
22:51:42,400 --> 22:51:45,280
and what we have is a pointer inside and

34540
22:51:45,280 --> 22:51:47,680
what we probably have inside

34541
22:51:47,680 --> 22:51:50,400
is a member variable which is a pointer

34542
22:51:50,400 --> 22:51:52,800
like we have here so what we will be

34543
22:51:52,800 --> 22:51:55,600
accounting for in the strength class is

34544
22:51:55,600 --> 22:51:57,760
the size of the pointer but it's not the

34545
22:51:57,760 --> 22:52:00,232
size of what is pointed to okay so the

34546
22:52:00,232 --> 22:52:03,280
car pointer may be pointing to thousands

34547
22:52:03,280 --> 22:52:06,000
of characters in memory but as long as

34548
22:52:06,000 --> 22:52:08,160
the compiler is concerned it's just

34549
22:52:08,160 --> 22:52:10,232
going to use the pointer member variable

34550
22:52:10,232 --> 22:52:12,232
and it's going to account for it in the

34551
22:52:12,232 --> 22:52:14,080
size of your object hopefully you can

34552
22:52:14,080 --> 22:52:15,512
understand why

34553
22:52:15,512 --> 22:52:18,000
the size of our string objects is going

34554
22:52:18,000 --> 22:52:19,440
to be the same

34555
22:52:19,440 --> 22:52:22,232
regardless of how large is this strand

34556
22:52:22,232 --> 22:52:24,400
this is really something you need to

34557
22:52:24,400 --> 22:52:26,320
understand otherwise this is going to

34558
22:52:26,320 --> 22:52:28,552
throw you off as you design your c plus

34559
22:52:28,552 --> 22:52:30,960
plus applications and this is really all

34560
22:52:30,960 --> 22:52:33,680
i had to share in this lecture the size

34561
22:52:33,680 --> 22:52:35,512
of your object is mostly going to be

34562
22:52:35,512 --> 22:52:37,512
determined by the

34563
22:52:37,512 --> 22:52:39,680
member variables you have and the size

34564
22:52:39,680 --> 22:52:41,920
is going to be the sum of the sizes of

34565
22:52:41,920 --> 22:52:44,720
your member variables i would like to

34566
22:52:44,720 --> 22:52:46,960
welcome you in this new chapter where

34567
22:52:46,960 --> 22:52:48,480
we're going to be learning about

34568
22:52:48,480 --> 22:52:51,280
inheritance and inheritance is a feature

34569
22:52:51,280 --> 22:52:54,000
that c plus plus provides

34570
22:52:54,000 --> 22:52:57,920
to allow us to build classes in terms of

34571
22:52:57,920 --> 22:52:59,440
other classes

34572
22:52:59,440 --> 22:53:01,192
and what i mean here is that we can

34573
22:53:01,192 --> 22:53:04,080
build complete hierarchies of classes

34574
22:53:04,080 --> 22:53:06,872
that depend on other classes for example

34575
22:53:06,872 --> 22:53:09,760
if we think of a person as a type we can

34576
22:53:09,760 --> 22:53:12,640
have different types of persons we can

34577
22:53:12,640 --> 22:53:15,192
have a doctor a doctor is a person we

34578
22:53:15,192 --> 22:53:18,232
can have a physician a physician is a

34579
22:53:18,232 --> 22:53:20,720
person we can have an engineer an

34580
22:53:20,720 --> 22:53:23,120
engineer as a person we can have really

34581
22:53:23,120 --> 22:53:25,920
all kinds of persons and we can capture

34582
22:53:25,920 --> 22:53:28,640
these kinds of relationships in c plus

34583
22:53:28,640 --> 22:53:31,192
plus using inheritance for example here

34584
22:53:31,192 --> 22:53:34,160
we have an inheritance hierarchy we can

34585
22:53:34,160 --> 22:53:36,552
set up a person type in our c plus

34586
22:53:36,552 --> 22:53:38,400
program and put in whatever member

34587
22:53:38,400 --> 22:53:42,232
variables we need to define a person for

34588
22:53:42,232 --> 22:53:44,400
whatever purposes we are building our c

34589
22:53:44,400 --> 22:53:46,800
plus plus application for once we have

34590
22:53:46,800 --> 22:53:49,192
this type we can build other types that

34591
22:53:49,192 --> 22:53:51,512
depend on this person for example we can

34592
22:53:51,512 --> 22:53:54,000
build an engineer type which is really

34593
22:53:54,000 --> 22:53:57,040
going to embody the person type inside

34594
22:53:57,040 --> 22:53:59,192
so what we will be doing is really

34595
22:53:59,192 --> 22:54:02,640
setting up a layer of a person type and

34596
22:54:02,640 --> 22:54:05,120
in our engineer type which is going to

34597
22:54:05,120 --> 22:54:08,080
depend on person we will boil the novel

34598
22:54:08,080 --> 22:54:10,720
layer on top of that and really reuse

34599
22:54:10,720 --> 22:54:13,360
that person type without having to

34600
22:54:13,360 --> 22:54:15,760
rebuild this from scratch hopefully you

34601
22:54:15,760 --> 22:54:17,512
can see that this is going to improve

34602
22:54:17,512 --> 22:54:20,000
code reuse we can also reuse this

34603
22:54:20,000 --> 22:54:22,080
engineer type and well the other types

34604
22:54:22,080 --> 22:54:23,832
on top of it for example we can have a

34605
22:54:23,832 --> 22:54:26,320
civil engineer we can have an electrical

34606
22:54:26,320 --> 22:54:28,400
engineer we can have all kinds of crazy

34607
22:54:28,400 --> 22:54:31,120
engineers modeled in our c plus plus

34608
22:54:31,120 --> 22:54:32,160
program

34609
22:54:32,160 --> 22:54:33,832
using the inheritance and this is going

34610
22:54:33,832 --> 22:54:36,552
to be really cool so this is what we are

34611
22:54:36,552 --> 22:54:39,040
going to be exploring in this chapter

34612
22:54:39,040 --> 22:54:41,360
looking at the facilities that c plus

34613
22:54:41,360 --> 22:54:44,552
plus provides to capture these kinds of

34614
22:54:44,552 --> 22:54:46,720
relationships in our c plus plus

34615
22:54:46,720 --> 22:54:49,680
programs please note that inheritance is

34616
22:54:49,680 --> 22:54:51,760
a really big feature and it is a

34617
22:54:51,760 --> 22:54:54,480
defining feature of object oriented

34618
22:54:54,480 --> 22:54:57,440
programming c plus plus object oriented

34619
22:54:57,440 --> 22:55:00,320
programming is a paradigm or a way of

34620
22:55:00,320 --> 22:55:03,360
thinking about programming that uses

34621
22:55:03,360 --> 22:55:05,920
objects and the most basic defining

34622
22:55:05,920 --> 22:55:08,232
feature of object oriented programming

34623
22:55:08,232 --> 22:55:10,872
in c plus plus is classes that we have

34624
22:55:10,872 --> 22:55:13,040
learned about using classes we can

34625
22:55:13,040 --> 22:55:15,760
define things for example we can set up

34626
22:55:15,760 --> 22:55:17,832
a car we can set up a house we can set

34627
22:55:17,832 --> 22:55:20,000
up a spaceship we can do all kinds of

34628
22:55:20,000 --> 22:55:22,080
crazy things with classes and ziplocs

34629
22:55:22,080 --> 22:55:24,552
plus inheritance is going to build on

34630
22:55:24,552 --> 22:55:27,360
top of classes and allow us to build

34631
22:55:27,360 --> 22:55:30,000
classes that depend on each other and

34632
22:55:30,000 --> 22:55:31,760
will the complete inheritance

34633
22:55:31,760 --> 22:55:34,000
hierarchies that are going to make our

34634
22:55:34,000 --> 22:55:36,160
design much easier to look at and

34635
22:55:36,160 --> 22:55:39,040
understand and work with okay so this is

34636
22:55:39,040 --> 22:55:41,512
what we are up against in this chapter

34637
22:55:41,512 --> 22:55:43,440
learning about inheritance and really

34638
22:55:43,440 --> 22:55:46,872
exposing you to as much as possible to

34639
22:55:46,872 --> 22:55:49,680
let you use inheritance in an easier way

34640
22:55:49,680 --> 22:55:52,080
in your c plus class programs we are

34641
22:55:52,080 --> 22:55:54,080
going to start in the next lecture and

34642
22:55:54,080 --> 22:55:56,960
try out inheritance for the first time

34643
22:55:56,960 --> 22:55:59,120
go ahead and finish up here and meet me

34644
22:55:59,120 --> 22:56:01,440
there in this lecture we're going to try

34645
22:56:01,440 --> 22:56:04,400
out inheritance for the first time in

34646
22:56:04,400 --> 22:56:05,680
this course

34647
22:56:05,680 --> 22:56:07,600
but before we do that let's remind

34648
22:56:07,600 --> 22:56:11,280
ourselves of what inheritance really is

34649
22:56:11,280 --> 22:56:13,512
inheritance is a feature we have in c

34650
22:56:13,512 --> 22:56:14,480
plus plus

34651
22:56:14,480 --> 22:56:17,680
to be able to build new classes in terms

34652
22:56:17,680 --> 22:56:20,720
of the classes we have predefined

34653
22:56:20,720 --> 22:56:23,040
and the new classes are going to be

34654
22:56:23,040 --> 22:56:25,360
stealing features from the already

34655
22:56:25,360 --> 22:56:28,400
pre-existing classes if i can say it

34656
22:56:28,400 --> 22:56:31,120
like that and the more classes we build

34657
22:56:31,120 --> 22:56:33,512
in terms of others we're going to end up

34658
22:56:33,512 --> 22:56:36,232
with what we call an inheritance tree

34659
22:56:36,232 --> 22:56:38,232
which is basically going to go from the

34660
22:56:38,232 --> 22:56:40,640
top to the bottom with the most

34661
22:56:40,640 --> 22:56:43,360
fundamental class on top and the derived

34662
22:56:43,360 --> 22:56:45,760
class at the bottom here we have a

34663
22:56:45,760 --> 22:56:48,000
simple example for example we can have a

34664
22:56:48,000 --> 22:56:49,512
person class

34665
22:56:49,512 --> 22:56:51,600
and this class may be

34666
22:56:51,600 --> 22:56:54,800
defining the basic features of a person

34667
22:56:54,800 --> 22:56:56,960
but based on that personal class we

34668
22:56:56,960 --> 22:57:00,400
might want to derive other classes that

34669
22:57:00,400 --> 22:57:03,512
build on top of this person class for

34670
22:57:03,512 --> 22:57:05,280
example we might want to define an

34671
22:57:05,280 --> 22:57:07,760
engineer and a doctor and we know that

34672
22:57:07,760 --> 22:57:10,400
an engineer is also a person so they are

34673
22:57:10,400 --> 22:57:12,960
going to inherit some features from the

34674
22:57:12,960 --> 22:57:15,512
person class the same goes for the

34675
22:57:15,512 --> 22:57:18,232
doctor class it is going to inherit

34676
22:57:18,232 --> 22:57:21,040
some features from person but all these

34677
22:57:21,040 --> 22:57:23,600
derived classes are also going to add

34678
22:57:23,600 --> 22:57:26,160
their own features to the person class

34679
22:57:26,160 --> 22:57:28,640
siplus plus allows us to build these

34680
22:57:28,640 --> 22:57:30,720
kinds of relationships

34681
22:57:30,720 --> 22:57:33,832
here is another simple example we have a

34682
22:57:33,832 --> 22:57:36,232
vehicle class to the top of our

34683
22:57:36,232 --> 22:57:39,280
inheritance hierarchy and below this

34684
22:57:39,280 --> 22:57:42,000
class we might derive a track class

34685
22:57:42,000 --> 22:57:44,320
which is also a vehicle we might have a

34686
22:57:44,320 --> 22:57:46,400
minivan we might have a truck we might

34687
22:57:46,400 --> 22:57:49,280
have a pickup truck we may really do all

34688
22:57:49,280 --> 22:57:52,000
kinds of crazy vehicles which are going

34689
22:57:52,000 --> 22:57:54,552
to inherit the basic features from the

34690
22:57:54,552 --> 22:57:57,192
vehicle class and add their own

34691
22:57:57,192 --> 22:57:58,800
specialization

34692
22:57:58,800 --> 22:58:00,872
on top of the vehicle class so this is

34693
22:58:00,872 --> 22:58:04,320
the basic idea behind inheritance in c

34694
22:58:04,320 --> 22:58:06,800
plus plus so the examples we're going to

34695
22:58:06,800 --> 22:58:09,040
do in this lecture

34696
22:58:09,040 --> 22:58:11,192
so here is a simple example of what

34697
22:58:11,192 --> 22:58:12,720
we're going to do in this lecture we're

34698
22:58:12,720 --> 22:58:14,552
going to set up a person class which is

34699
22:58:14,552 --> 22:58:17,040
going to be our base class

34700
22:58:17,040 --> 22:58:18,960
it is going to be defining two member

34701
22:58:18,960 --> 22:58:21,440
variables which are going to be of std

34702
22:58:21,440 --> 22:58:23,512
string type we're going to have a last

34703
22:58:23,512 --> 22:58:25,832
name for the person and the first name

34704
22:58:25,832 --> 22:58:27,192
for the person

34705
22:58:27,192 --> 22:58:30,480
we are going to derive from this class

34706
22:58:30,480 --> 22:58:32,872
and set up a player class

34707
22:58:32,872 --> 22:58:35,040
the player class is going to inherit

34708
22:58:35,040 --> 22:58:37,192
these features from the person class so

34709
22:58:37,192 --> 22:58:39,680
it is going to have a last name and a

34710
22:58:39,680 --> 22:58:42,552
first name built into it but that's

34711
22:58:42,552 --> 22:58:45,360
going to be our base or our starting

34712
22:58:45,360 --> 22:58:48,080
point we are going to add to this base

34713
22:58:48,080 --> 22:58:50,160
and add another member variable from

34714
22:58:50,160 --> 22:58:52,872
player and we're going to be having the

34715
22:58:52,872 --> 22:58:56,232
player class which is really a person

34716
22:58:56,232 --> 22:58:58,640
but it is going to add things to person

34717
22:58:58,640 --> 22:59:01,600
to customize on what we can do with a

34718
22:59:01,600 --> 22:59:02,552
player

34719
22:59:02,552 --> 22:59:05,120
that we wouldn't originally be able to

34720
22:59:05,120 --> 22:59:08,160
do or have with a person class this is

34721
22:59:08,160 --> 22:59:10,640
the basic idea okay now that we know

34722
22:59:10,640 --> 22:59:12,720
this we're going to set up our personal

34723
22:59:12,720 --> 22:59:14,480
class which is going to be our base

34724
22:59:14,480 --> 22:59:16,960
class it is going to have our two member

34725
22:59:16,960 --> 22:59:19,440
variables first the name and last name

34726
22:59:19,440 --> 22:59:20,640
we're going to have a bunch of

34727
22:59:20,640 --> 22:59:22,552
constructors and we're going to have a

34728
22:59:22,552 --> 22:59:25,192
stream output operator to be able to

34729
22:59:25,192 --> 22:59:27,600
print this on the console and see our

34730
22:59:27,600 --> 22:59:30,400
information here nothing special but now

34731
22:59:30,400 --> 22:59:33,040
that this class is done we can build

34732
22:59:33,040 --> 22:59:36,080
other classes on top of this class so

34733
22:59:36,080 --> 22:59:38,232
what we can do for example we can derive

34734
22:59:38,232 --> 22:59:40,000
a player class

34735
22:59:40,000 --> 22:59:41,920
so the syntax is what you see here we

34736
22:59:41,920 --> 22:59:45,680
say class player we say column column

34737
22:59:45,680 --> 22:59:47,832
and then we say public

34738
22:59:47,832 --> 22:59:50,160
and specify the class that we are

34739
22:59:50,160 --> 22:59:53,192
inheriting from so the parent class for

34740
22:59:53,192 --> 22:59:55,832
this class is going to be person or in

34741
22:59:55,832 --> 22:59:58,400
other words we're going to be deriving

34742
22:59:58,400 --> 23:00:00,552
from the person class and we're going to

34743
23:00:00,552 --> 23:00:03,600
be doing that publicly okay for now i

34744
23:00:03,600 --> 23:00:05,680
don't want you to worry too much about

34745
23:00:05,680 --> 23:00:07,600
this public keyword we're going to be

34746
23:00:07,600 --> 23:00:10,400
learning this in steps just know that

34747
23:00:10,400 --> 23:00:12,960
this is the syntax you use to derive

34748
23:00:12,960 --> 23:00:14,640
from another class

34749
23:00:14,640 --> 23:00:17,120
now the moment we do this the player

34750
23:00:17,120 --> 23:00:19,280
class is going to have the person

34751
23:00:19,280 --> 23:00:22,640
information embedded inside but we will

34752
23:00:22,640 --> 23:00:25,360
also have the ability to customize or

34753
23:00:25,360 --> 23:00:27,280
add other things

34754
23:00:27,280 --> 23:00:29,920
at the level of the player class this is

34755
23:00:29,920 --> 23:00:31,600
what we do we have a private member

34756
23:00:31,600 --> 23:00:34,800
variable and it is going to specify the

34757
23:00:34,800 --> 23:00:36,960
game at the player place we're going to

34758
23:00:36,960 --> 23:00:39,512
have our own set of constructors we can

34759
23:00:39,512 --> 23:00:42,720
really build player objects but they are

34760
23:00:42,720 --> 23:00:46,720
going to have a person part inside that

34761
23:00:46,720 --> 23:00:49,360
is going to store information about this

34762
23:00:49,360 --> 23:00:51,040
player person

34763
23:00:51,040 --> 23:00:52,960
you notice we don't have a member

34764
23:00:52,960 --> 23:00:54,720
variable here for the first name we

34765
23:00:54,720 --> 23:00:56,400
don't have a member variable here for

34766
23:00:56,400 --> 23:00:58,640
the last name but that information is

34767
23:00:58,640 --> 23:01:01,192
going to be baked into this player

34768
23:01:01,192 --> 23:01:03,760
object and this is really how

34769
23:01:03,760 --> 23:01:07,440
inheritance helps us out we can derive

34770
23:01:07,440 --> 23:01:08,960
from classes

34771
23:01:08,960 --> 23:01:11,832
and build on top of them without having

34772
23:01:11,832 --> 23:01:14,160
to redo the fundamental work to build

34773
23:01:14,160 --> 23:01:16,720
our base classes we can just build on

34774
23:01:16,720 --> 23:01:19,512
top of them and really do things faster

34775
23:01:19,512 --> 23:01:22,232
and more efficiently okay so here are a

34776
23:01:22,232 --> 23:01:24,080
few things you need to know about the

34777
23:01:24,080 --> 23:01:27,120
public inheritance that we just did and

34778
23:01:27,120 --> 23:01:29,832
we are saying public inheritance because

34779
23:01:29,832 --> 23:01:32,640
of the syntax we used here

34780
23:01:32,640 --> 23:01:35,512
public person this is doing public

34781
23:01:35,512 --> 23:01:37,680
inheritance and we're going to see what

34782
23:01:37,680 --> 23:01:40,640
this gives us so with public inheritance

34783
23:01:40,640 --> 23:01:43,600
derived classes can access and use

34784
23:01:43,600 --> 23:01:46,720
public members of the base class

34785
23:01:46,720 --> 23:01:49,600
but the derived class can't directly

34786
23:01:49,600 --> 23:01:52,000
access private members from the base

34787
23:01:52,000 --> 23:01:54,800
class i want you to let this sync end

34788
23:01:54,800 --> 23:01:58,552
what this means from the player class we

34789
23:01:58,552 --> 23:02:01,360
can't directly access the private member

34790
23:02:01,360 --> 23:02:04,232
variables we had in person remember our

34791
23:02:04,232 --> 23:02:07,040
first name and last name are private to

34792
23:02:07,040 --> 23:02:10,640
person and we can't directly access them

34793
23:02:10,640 --> 23:02:13,920
in any deriving class that is doing

34794
23:02:13,920 --> 23:02:17,512
public inheritance okay so in our player

34795
23:02:17,512 --> 23:02:19,832
class if we try to access the first name

34796
23:02:19,832 --> 23:02:21,512
and the last name we're going to have

34797
23:02:21,512 --> 23:02:23,360
compiler errors because we can't

34798
23:02:23,360 --> 23:02:25,760
directly access them but not to worry

34799
23:02:25,760 --> 23:02:27,920
here we can still go through

34800
23:02:27,920 --> 23:02:31,192
the public getters that we have in the

34801
23:02:31,192 --> 23:02:32,400
person class

34802
23:02:32,400 --> 23:02:34,960
to access the private member variables

34803
23:02:34,960 --> 23:02:37,040
from the base class and that's what

34804
23:02:37,040 --> 23:02:39,280
we're going to do in this lecture here

34805
23:02:39,280 --> 23:02:41,512
because we don't have access to more

34806
23:02:41,512 --> 23:02:43,360
powerful tools we're going to learn

34807
23:02:43,360 --> 23:02:46,232
about in the next few lectures the same

34808
23:02:46,232 --> 23:02:48,960
is also going to apply to friends of the

34809
23:02:48,960 --> 23:02:50,552
derived class

34810
23:02:50,552 --> 23:02:52,800
they are going to have access to private

34811
23:02:52,800 --> 23:02:55,760
members of the derived class but they

34812
23:02:55,760 --> 23:02:57,920
don't have access to

34813
23:02:57,920 --> 23:03:00,960
the private members of the base class if

34814
23:03:00,960 --> 23:03:04,480
you try to access the private parts of a

34815
23:03:04,480 --> 23:03:05,832
base class

34816
23:03:05,832 --> 23:03:08,640
from a friend of the derived class

34817
23:03:08,640 --> 23:03:10,640
you're going to have a bunch of compiler

34818
23:03:10,640 --> 23:03:11,680
errors

34819
23:03:11,680 --> 23:03:13,280
okay now that you know this we're going

34820
23:03:13,280 --> 23:03:15,512
to head over to visual studio code and

34821
23:03:15,512 --> 23:03:17,280
play with this a little more and really

34822
23:03:17,280 --> 23:03:18,872
drive this home

34823
23:03:18,872 --> 23:03:21,440
here we are in our working folder the

34824
23:03:21,440 --> 23:03:24,080
current project is first try on

34825
23:03:24,080 --> 23:03:26,552
inheritance we're going to grab our

34826
23:03:26,552 --> 23:03:28,720
template files and put them in place

34827
23:03:28,720 --> 23:03:30,080
let's do this

34828
23:03:30,080 --> 23:03:32,000
and we are going to open this in visual

34829
23:03:32,000 --> 23:03:34,080
studio code pretty quick by dragging and

34830
23:03:34,080 --> 23:03:36,872
dropping here let's do that properly and

34831
23:03:36,872 --> 23:03:38,960
we're going to have our main cpp file we

34832
23:03:38,960 --> 23:03:41,360
can clean this up a little bit and we're

34833
23:03:41,360 --> 23:03:43,760
going to add our classes the first class

34834
23:03:43,760 --> 23:03:46,400
we're going to add is the person class

34835
23:03:46,400 --> 23:03:48,480
so we are going to create its header

34836
23:03:48,480 --> 23:03:52,080
file and let's do the cpp file i am

34837
23:03:52,080 --> 23:03:54,552
going to grab the code i have lying on

34838
23:03:54,552 --> 23:03:56,872
my drive for the header here i am going

34839
23:03:56,872 --> 23:03:59,512
to put the class in we are including the

34840
23:03:59,512 --> 23:04:01,120
classes we're going to need we need

34841
23:04:01,120 --> 23:04:03,440
string and io stream here because we're

34842
23:04:03,440 --> 23:04:05,832
going to be outputting thanks through

34843
23:04:05,832 --> 23:04:08,000
the output stream operator

34844
23:04:08,000 --> 23:04:10,000
and down here we have our two member

34845
23:04:10,000 --> 23:04:12,400
variables we have first name and last

34846
23:04:12,400 --> 23:04:15,360
name they are of std string type and we

34847
23:04:15,360 --> 23:04:17,192
have a bunch of constructors here a

34848
23:04:17,192 --> 23:04:19,920
default constructor and one that takes

34849
23:04:19,920 --> 23:04:22,960
two parameters we are taking them by

34850
23:04:22,960 --> 23:04:26,000
copy here this is bad we should at least

34851
23:04:26,000 --> 23:04:28,232
pass them by reference here let's

34852
23:04:28,232 --> 23:04:29,512
correct this

34853
23:04:29,512 --> 23:04:31,440
pretty fast

34854
23:04:31,440 --> 23:04:33,360
and we're going to make the second one a

34855
23:04:33,360 --> 23:04:36,160
reference as well let's do this and we

34856
23:04:36,160 --> 23:04:38,232
have a destructor which is going to do

34857
23:04:38,232 --> 23:04:40,960
nothing because we really aren't doing

34858
23:04:40,960 --> 23:04:43,760
any dynamic memory allocation here we're

34859
23:04:43,760 --> 23:04:46,080
going to head over to the cpp file and

34860
23:04:46,080 --> 23:04:47,760
put in the code for that we're going to

34861
23:04:47,760 --> 23:04:50,160
include the person and we're going to do

34862
23:04:50,160 --> 23:04:51,832
our constructors put in the

34863
23:04:51,832 --> 23:04:54,320
implementations i should say and we're

34864
23:04:54,320 --> 23:04:56,232
going to pass our parameters by

34865
23:04:56,232 --> 23:04:59,280
reference again let's do this and our

34866
23:04:59,280 --> 23:05:01,440
constructor should be done now we have a

34867
23:05:01,440 --> 23:05:05,120
person class that we can use to derive

34868
23:05:05,120 --> 23:05:08,232
other classes and use this class as a

34869
23:05:08,232 --> 23:05:11,192
foundation to build other classes to

34870
23:05:11,192 --> 23:05:14,480
visualize this again our class person is

34871
23:05:14,480 --> 23:05:16,800
going to be the base class for our

34872
23:05:16,800 --> 23:05:18,320
player class

34873
23:05:18,320 --> 23:05:20,872
so if we build a player class it's going

34874
23:05:20,872 --> 23:05:22,080
to have

34875
23:05:22,080 --> 23:05:25,192
a person part of it which is going to be

34876
23:05:25,192 --> 23:05:27,120
the foundation on top of which we're

34877
23:05:27,120 --> 23:05:29,680
going to build notice that in player we

34878
23:05:29,680 --> 23:05:31,760
don't need to set up last name and first

34879
23:05:31,760 --> 23:05:34,080
name they are going to come from our

34880
23:05:34,080 --> 23:05:36,872
personal part of player all we need to

34881
23:05:36,872 --> 23:05:39,440
do in player is set up the game member

34882
23:05:39,440 --> 23:05:42,400
variable to make him a full player who

34883
23:05:42,400 --> 23:05:44,960
can have the game they happen to be

34884
23:05:44,960 --> 23:05:47,360
playing this is the idea here okay so

34885
23:05:47,360 --> 23:05:48,960
now that we know this we're going to put

34886
23:05:48,960 --> 23:05:50,800
in our player class we're going to

34887
23:05:50,800 --> 23:05:54,000
create the files for it let's do player

34888
23:05:54,000 --> 23:05:56,720
dot h we're going to put this in and

34889
23:05:56,720 --> 23:05:58,800
we're going to do player

34890
23:05:58,800 --> 23:06:01,512
that cpp we're going to put him and

34891
23:06:01,512 --> 23:06:03,600
we are going to hop over to the header

34892
23:06:03,600 --> 23:06:07,120
file and put in our code the class is

34893
23:06:07,120 --> 23:06:09,280
going to be player and it is going to be

34894
23:06:09,280 --> 23:06:11,600
inheriting from person this is the

34895
23:06:11,600 --> 23:06:14,960
syntax again we say colon colon we say

34896
23:06:14,960 --> 23:06:17,040
the kind of inheritance we want to do in

34897
23:06:17,040 --> 23:06:19,120
this case it is public and then we say

34898
23:06:19,120 --> 23:06:21,040
the class that we are going to be

34899
23:06:21,040 --> 23:06:24,232
inheriting from from this point on the

34900
23:06:24,232 --> 23:06:26,400
player class is going to have a person

34901
23:06:26,400 --> 23:06:28,232
part of it and we are going to prove

34902
23:06:28,232 --> 23:06:30,480
this in a minute when we run this code

34903
23:06:30,480 --> 23:06:32,720
here notice that we can build player

34904
23:06:32,720 --> 23:06:35,600
objects by just passing in the game

34905
23:06:35,600 --> 23:06:38,000
parameter here which is going to be used

34906
23:06:38,000 --> 23:06:40,960
to initialize our member variable let's

34907
23:06:40,960 --> 23:06:43,120
also make it a reference because this is

34908
23:06:43,120 --> 23:06:44,872
good practice it is going to avoid

34909
23:06:44,872 --> 23:06:47,832
copies you can even use string views but

34910
23:06:47,832 --> 23:06:50,080
that's going to be your choice

34911
23:06:50,080 --> 23:06:52,552
we are going to hop over to the cpp file

34912
23:06:52,552 --> 23:06:55,680
and put in our implementation

34913
23:06:55,680 --> 23:06:58,080
and this is going to complete our setup

34914
23:06:58,080 --> 23:07:00,400
for the player class which is going to

34915
23:07:00,400 --> 23:07:03,680
be inheriting from our person class here

34916
23:07:03,680 --> 23:07:06,800
we can actually head over to the main

34917
23:07:06,800 --> 23:07:09,920
cpp file and include the player class

34918
23:07:09,920 --> 23:07:11,760
let's do this we're going to say player

34919
23:07:11,760 --> 23:07:14,160
and we can create player objects let's

34920
23:07:14,160 --> 23:07:16,960
look at the code again for a player we

34921
23:07:16,960 --> 23:07:18,720
have a constructor which is going to

34922
23:07:18,720 --> 23:07:21,680
take a string parameter we can use this

34923
23:07:21,680 --> 23:07:24,720
to create a player and specify the game

34924
23:07:24,720 --> 23:07:26,552
they are going to be playing

34925
23:07:26,552 --> 23:07:27,280
but

34926
23:07:27,280 --> 23:07:30,800
for now we don't have enough tools to

34927
23:07:30,800 --> 23:07:33,440
put in the data that would initialize

34928
23:07:33,440 --> 23:07:36,320
the member variables in the base class

34929
23:07:36,320 --> 23:07:38,480
which is person here if we go back to

34930
23:07:38,480 --> 23:07:39,920
person we're going to see that we have

34931
23:07:39,920 --> 23:07:42,160
the first name and the last name

34932
23:07:42,160 --> 23:07:44,800
but in our player class

34933
23:07:44,800 --> 23:07:46,720
these member variables are going to be

34934
23:07:46,720 --> 23:07:49,760
inherited because a player is inheriting

34935
23:07:49,760 --> 23:07:52,720
from a person this is the syntax to do

34936
23:07:52,720 --> 23:07:55,920
that but even if the player class has a

34937
23:07:55,920 --> 23:07:58,872
person part inside of it we can't really

34938
23:07:58,872 --> 23:08:02,480
access private members from person

34939
23:08:02,480 --> 23:08:05,600
from a player object we're going to see

34940
23:08:05,600 --> 23:08:08,400
a few ways we can get around this and

34941
23:08:08,400 --> 23:08:11,040
one of those is to go public methods

34942
23:08:11,040 --> 23:08:13,832
from the person class to access

34943
23:08:13,832 --> 23:08:16,000
private parts of the person class this

34944
23:08:16,000 --> 23:08:17,600
is going to give us access to these

34945
23:08:17,600 --> 23:08:20,872
member variables if you go down in our

34946
23:08:20,872 --> 23:08:23,280
stream output operator you're going to

34947
23:08:23,280 --> 23:08:26,000
see that we are using these getters here

34948
23:08:26,000 --> 23:08:28,480
the parameter is a player objects that

34949
23:08:28,480 --> 23:08:31,280
we want to print out but to get access

34950
23:08:31,280 --> 23:08:33,680
to the names we are getting the first

34951
23:08:33,680 --> 23:08:36,320
name and the last name through our

34952
23:08:36,320 --> 23:08:39,040
getters here before we really explore

34953
23:08:39,040 --> 23:08:41,600
this any further i think it is a good

34954
23:08:41,600 --> 23:08:44,080
idea to go in the main cpp file and

34955
23:08:44,080 --> 23:08:46,480
create a player object so we're going to

34956
23:08:46,480 --> 23:08:48,400
do that we're going to say p1 and we're

34957
23:08:48,400 --> 23:08:50,960
going to specify that they play

34958
23:08:50,960 --> 23:08:54,232
basketball why not okay so we have our

34959
23:08:54,232 --> 23:08:56,080
player object

34960
23:08:56,080 --> 23:08:58,000
and we can really do all we want with

34961
23:08:58,000 --> 23:09:00,480
that for example we can print the

34962
23:09:00,480 --> 23:09:03,040
information about this player object if

34963
23:09:03,040 --> 23:09:05,600
you remember in player we have a stream

34964
23:09:05,600 --> 23:09:07,680
output operator which is going to print

34965
23:09:07,680 --> 23:09:09,600
all the information

34966
23:09:09,600 --> 23:09:12,720
and here we have a problem because this

34967
23:09:12,720 --> 23:09:16,000
guy is taking the data by reference

34968
23:09:16,000 --> 23:09:18,232
and this is not a reference this is a

34969
23:09:18,232 --> 23:09:20,552
temporary object that we are passing

34970
23:09:20,552 --> 23:09:21,512
here

34971
23:09:21,512 --> 23:09:24,552
so we could go back and change this to

34972
23:09:24,552 --> 23:09:27,600
take a string view parameter

34973
23:09:27,600 --> 23:09:29,600
let's go back and do that we're going to

34974
23:09:29,600 --> 23:09:32,480
include a string view here in player and

34975
23:09:32,480 --> 23:09:34,232
we're going to change our parameter to

34976
23:09:34,232 --> 23:09:37,760
be std string view by value and we're

34977
23:09:37,760 --> 23:09:40,720
going to do that in the cpp file let's

34978
23:09:40,720 --> 23:09:43,360
do that we're going to say std string

34979
23:09:43,360 --> 23:09:46,720
view and this should take care of our

34980
23:09:46,720 --> 23:09:48,400
problem here you see that the problem

34981
23:09:48,400 --> 23:09:50,720
goes away now that we have this guy we

34982
23:09:50,720 --> 23:09:53,600
can print it out we can say sddc out

34983
23:09:53,600 --> 23:09:56,400
player and i put the information out

34984
23:09:56,400 --> 23:09:58,552
okay so now that we have this we cannot

34985
23:09:58,552 --> 23:10:01,192
try and build our program we're going to

34986
23:10:01,192 --> 23:10:02,872
use gcc

34987
23:10:02,872 --> 23:10:05,120
our favorite compiler and you're going

34988
23:10:05,120 --> 23:10:07,280
to see that we have a problem undefined

34989
23:10:07,280 --> 23:10:10,400
reference to player destructor let's go

34990
23:10:10,400 --> 23:10:12,400
back in the header and see that we have

34991
23:10:12,400 --> 23:10:15,680
a destructor but we probably didn't put

34992
23:10:15,680 --> 23:10:18,960
a destructor in the cpp file so let's do

34993
23:10:18,960 --> 23:10:22,000
that or because we're not doing any

34994
23:10:22,000 --> 23:10:24,160
dynamic memory allocation we can even

34995
23:10:24,160 --> 23:10:27,040
completely take out this destructor and

34996
23:10:27,040 --> 23:10:28,720
we're just going to use the one the

34997
23:10:28,720 --> 23:10:31,040
compiler generates for us this is going

34998
23:10:31,040 --> 23:10:32,080
to be

34999
23:10:32,080 --> 23:10:34,480
much easier to handle in our code so we

35000
23:10:34,480 --> 23:10:37,512
can build again with gcc okay the world

35001
23:10:37,512 --> 23:10:40,872
is good we can run this program

35002
23:10:40,872 --> 23:10:43,120
and let's see if we have a powershell

35003
23:10:43,120 --> 23:10:44,800
window we don't we're going to bring up

35004
23:10:44,800 --> 23:10:47,600
a new one and we're going to run rooster

35005
23:10:47,600 --> 23:10:49,360
we should see information about our

35006
23:10:49,360 --> 23:10:52,640
player so player the game is basketball

35007
23:10:52,640 --> 23:10:55,280
the names are mysterious person because

35008
23:10:55,280 --> 23:10:58,232
that's the default data we inherit from

35009
23:10:58,232 --> 23:11:00,552
a person if you go back to person you're

35010
23:11:00,552 --> 23:11:02,232
going to see that

35011
23:11:02,232 --> 23:11:05,280
the default data in first name is

35012
23:11:05,280 --> 23:11:08,160
mysterious the default data in last name

35013
23:11:08,160 --> 23:11:11,280
is person and it is what we see printed

35014
23:11:11,280 --> 23:11:12,640
out here

35015
23:11:12,640 --> 23:11:15,192
in our powershell window when we print

35016
23:11:15,192 --> 23:11:18,720
information about our player object

35017
23:11:18,720 --> 23:11:20,400
another thing i want you to see is that

35018
23:11:20,400 --> 23:11:23,192
we can actually really prove

35019
23:11:23,192 --> 23:11:26,640
that any player object is going to have

35020
23:11:26,640 --> 23:11:28,552
a person part of it

35021
23:11:28,552 --> 23:11:31,280
backed in and that's going to be storing

35022
23:11:31,280 --> 23:11:34,160
the information that is modeled into our

35023
23:11:34,160 --> 23:11:36,720
person class and we can use a debugger

35024
23:11:36,720 --> 23:11:39,832
to do that for this to work i am going

35025
23:11:39,832 --> 23:11:43,512
to put a break point here on line 8

35026
23:11:43,512 --> 23:11:45,680
which is printing things out

35027
23:11:45,680 --> 23:11:48,080
this break point is going to be hit

35028
23:11:48,080 --> 23:11:50,800
after our object is set up and we can

35029
23:11:50,800 --> 23:11:53,920
really see the data inside this guy here

35030
23:11:53,920 --> 23:11:55,192
so what we're going to do we're going to

35031
23:11:55,192 --> 23:11:57,680
hit this run tab

35032
23:11:57,680 --> 23:11:59,920
and we're going to use g plus plus we're

35033
23:11:59,920 --> 23:12:01,680
going to use the debugging tools that

35034
23:12:01,680 --> 23:12:04,160
come with gcc because this is our

35035
23:12:04,160 --> 23:12:05,512
favorite we're going to hit the green

35036
23:12:05,512 --> 23:12:06,872
button here

35037
23:12:06,872 --> 23:12:09,192
this is going to start our debugging

35038
23:12:09,192 --> 23:12:12,000
session a binary is going to be built

35039
23:12:12,000 --> 23:12:14,000
and it is going to be plugged into our

35040
23:12:14,000 --> 23:12:16,160
debugger and we're going to hit a break

35041
23:12:16,160 --> 23:12:17,360
point here

35042
23:12:17,360 --> 23:12:19,192
now if you look on the left here you're

35043
23:12:19,192 --> 23:12:22,232
going to see a title that says locals

35044
23:12:22,232 --> 23:12:24,000
we're going to expand this and we're

35045
23:12:24,000 --> 23:12:27,040
going to see that the p1 object actually

35046
23:12:27,040 --> 23:12:29,920
has a person part of it and you see that

35047
23:12:29,920 --> 23:12:32,000
visual studio code is being helpful here

35048
23:12:32,000 --> 23:12:34,640
it is saying that this is the base class

35049
23:12:34,640 --> 23:12:36,320
and if we expand we're going to see that

35050
23:12:36,320 --> 23:12:38,320
we have our member variables we have

35051
23:12:38,320 --> 23:12:41,360
first name and last name and this is a

35052
23:12:41,360 --> 23:12:43,680
player object that we are looking at

35053
23:12:43,680 --> 23:12:46,640
don't forget that and on top of our

35054
23:12:46,640 --> 23:12:49,600
person part we also have our own member

35055
23:12:49,600 --> 23:12:51,920
variable which is the game that we play

35056
23:12:51,920 --> 23:12:53,760
and it is right here hopefully this

35057
23:12:53,760 --> 23:12:55,120
proves to you

35058
23:12:55,120 --> 23:12:58,480
that any derived class object is going

35059
23:12:58,480 --> 23:13:02,232
to have a base part embedded into it and

35060
23:13:02,232 --> 23:13:04,400
that's going to be the foundation on top

35061
23:13:04,400 --> 23:13:06,552
of which the derived class is going to

35062
23:13:06,552 --> 23:13:08,800
be building its own tank this is the

35063
23:13:08,800 --> 23:13:11,192
basic idea here okay now that you've

35064
23:13:11,192 --> 23:13:13,512
seen this we're going to kill our debug

35065
23:13:13,512 --> 23:13:14,640
session

35066
23:13:14,640 --> 23:13:17,600
and we're going to see some of the

35067
23:13:17,600 --> 23:13:19,680
things you need to be careful about when

35068
23:13:19,680 --> 23:13:21,760
doing public inheritance like we are

35069
23:13:21,760 --> 23:13:23,680
doing here the first thing i want you to

35070
23:13:23,680 --> 23:13:26,320
see is that you don't have access to

35071
23:13:26,320 --> 23:13:27,920
private parts

35072
23:13:27,920 --> 23:13:30,320
of the base class if you go back to

35073
23:13:30,320 --> 23:13:31,760
person here

35074
23:13:31,760 --> 23:13:33,760
let's kill this so that you're not

35075
23:13:33,760 --> 23:13:36,232
confused if we go back to our personal

35076
23:13:36,232 --> 23:13:38,232
class we're going to see that our first

35077
23:13:38,232 --> 23:13:41,040
name and last name are private

35078
23:13:41,040 --> 23:13:44,400
so they want to be accessible to any

35079
23:13:44,400 --> 23:13:45,440
class

35080
23:13:45,440 --> 23:13:48,640
that does public inheritance like we are

35081
23:13:48,640 --> 23:13:50,800
doing here they are just going to be

35082
23:13:50,800 --> 23:13:53,280
private they are going to be part of the

35083
23:13:53,280 --> 23:13:56,800
class but the derived class would have

35084
23:13:56,800 --> 23:13:59,360
access to them this is the idea here and

35085
23:13:59,360 --> 23:14:02,552
if we go in our output stream operator

35086
23:14:02,552 --> 23:14:05,440
and comment out what we have here and

35087
23:14:05,440 --> 23:14:08,160
try to directly access these member

35088
23:14:08,160 --> 23:14:10,480
variables let's do that i am going to

35089
23:14:10,480 --> 23:14:13,440
copy the code here and put that on top

35090
23:14:13,440 --> 23:14:16,720
and we are not going to go through the

35091
23:14:16,720 --> 23:14:19,920
getter methods from the base class we

35092
23:14:19,920 --> 23:14:22,960
are going to try and access m first name

35093
23:14:22,960 --> 23:14:25,120
let's go back and look at the names for

35094
23:14:25,120 --> 23:14:26,960
the member variables it is first name

35095
23:14:26,960 --> 23:14:29,192
and last name let's use that we're going

35096
23:14:29,192 --> 23:14:31,360
to say first name you see that through

35097
23:14:31,360 --> 23:14:34,320
intellisense but trying to access that

35098
23:14:34,320 --> 23:14:36,640
is going to give us squiggly lines you

35099
23:14:36,640 --> 23:14:38,400
see that we have this in our

35100
23:14:38,400 --> 23:14:40,872
autocomplete but we have squiggly lines

35101
23:14:40,872 --> 23:14:42,800
we can't access these if we try to

35102
23:14:42,800 --> 23:14:45,680
compile our program let's do that again

35103
23:14:45,680 --> 23:14:48,160
we're going to use gcc and we are going

35104
23:14:48,160 --> 23:14:50,232
to get compiler errors and the compiler

35105
23:14:50,232 --> 23:14:52,872
errors are basically going to say

35106
23:14:52,872 --> 23:14:55,120
first name is private within this

35107
23:14:55,120 --> 23:14:58,160
context again the meaning is that

35108
23:14:58,160 --> 23:15:02,000
first name is private to the base class

35109
23:15:02,000 --> 23:15:04,640
and we have no business accessing that

35110
23:15:04,640 --> 23:15:07,440
in a derived class which is

35111
23:15:07,440 --> 23:15:09,280
the player class here this is the

35112
23:15:09,280 --> 23:15:12,000
meaning so we can't really access that

35113
23:15:12,000 --> 23:15:14,480
okay i realize this is a global function

35114
23:15:14,480 --> 23:15:16,872
but even if we try to do that from a

35115
23:15:16,872 --> 23:15:19,440
member function let's do that from

35116
23:15:19,440 --> 23:15:22,080
a constructor we're going to try and say

35117
23:15:22,080 --> 23:15:24,720
first name okay i realize the access we

35118
23:15:24,720 --> 23:15:27,280
are trying to do from the output stream

35119
23:15:27,280 --> 23:15:29,440
operator is really not a good example

35120
23:15:29,440 --> 23:15:32,320
because this is not a member function it

35121
23:15:32,320 --> 23:15:35,120
is a global freestanding function so we

35122
23:15:35,120 --> 23:15:37,280
can try and change the first name and

35123
23:15:37,280 --> 23:15:38,960
last name from the constructor for

35124
23:15:38,960 --> 23:15:40,960
example and we're going to see that this

35125
23:15:40,960 --> 23:15:42,960
is not going to work either so we can

35126
23:15:42,960 --> 23:15:45,680
take this out and we're going to

35127
23:15:45,680 --> 23:15:48,400
remove our block comma so we're going to

35128
23:15:48,400 --> 23:15:51,120
take out what we just did here

35129
23:15:51,120 --> 23:15:53,120
and we're going to uncomment our good

35130
23:15:53,120 --> 23:15:55,512
code here which is using getter member

35131
23:15:55,512 --> 23:15:57,680
functions from the base class and we're

35132
23:15:57,680 --> 23:15:59,680
going to try and change

35133
23:15:59,680 --> 23:16:01,920
the first name and last name from the

35134
23:16:01,920 --> 23:16:05,280
base class and change those into our

35135
23:16:05,280 --> 23:16:07,760
constructor of the derived class we're

35136
23:16:07,760 --> 23:16:09,440
going to try and change for example the

35137
23:16:09,440 --> 23:16:12,000
first name and make it john and we're

35138
23:16:12,000 --> 23:16:14,232
going to take the last name and change

35139
23:16:14,232 --> 23:16:15,512
that to

35140
23:16:15,512 --> 23:16:18,000
snow let's do that and let's go back and

35141
23:16:18,000 --> 23:16:20,800
make sure we have the correct names

35142
23:16:20,800 --> 23:16:22,480
and you see that we have squiggly lines

35143
23:16:22,480 --> 23:16:24,720
we can't really do this because these

35144
23:16:24,720 --> 23:16:27,360
are private members of the base class

35145
23:16:27,360 --> 23:16:30,400
and we can't access them from a derived

35146
23:16:30,400 --> 23:16:33,280
class they are part of the player class

35147
23:16:33,280 --> 23:16:35,280
which is a derived class but we don't

35148
23:16:35,280 --> 23:16:37,680
have access to them we can't modify them

35149
23:16:37,680 --> 23:16:40,080
or do anything we can't read from them

35150
23:16:40,080 --> 23:16:41,760
we can't write from them this is the

35151
23:16:41,760 --> 23:16:43,920
message here if we try to build our

35152
23:16:43,920 --> 23:16:46,232
program we're going to use gcc to do

35153
23:16:46,232 --> 23:16:47,192
that

35154
23:16:47,192 --> 23:16:49,512
we are going to get compiler errors and

35155
23:16:49,512 --> 23:16:53,360
uh let's see the compiler error we get

35156
23:16:53,360 --> 23:16:55,680
again the error is that first name and

35157
23:16:55,680 --> 23:16:58,800
last name are private to the base class

35158
23:16:58,800 --> 23:17:01,440
and we have no business accessing them

35159
23:17:01,440 --> 23:17:03,680
from a derived class like we have here

35160
23:17:03,680 --> 23:17:06,160
so if you need any kind of access to a

35161
23:17:06,160 --> 23:17:07,192
private

35162
23:17:07,192 --> 23:17:10,320
member of the base class you will have

35163
23:17:10,320 --> 23:17:11,512
to go through

35164
23:17:11,512 --> 23:17:13,512
something that is public and a good

35165
23:17:13,512 --> 23:17:15,832
example is getter methods which are

35166
23:17:15,832 --> 23:17:17,600
going to allow you to

35167
23:17:17,600 --> 23:17:20,080
change things so for example if we want

35168
23:17:20,080 --> 23:17:22,480
the ability to change the first name and

35169
23:17:22,480 --> 23:17:24,232
the last name we can set up a bunch of

35170
23:17:24,232 --> 23:17:26,320
setter methods let's do that we're going

35171
23:17:26,320 --> 23:17:28,800
to say setters and we're going to say

35172
23:17:28,800 --> 23:17:29,832
void

35173
23:17:29,832 --> 23:17:30,872
set

35174
23:17:30,872 --> 23:17:33,192
first name and we are going to pass an

35175
23:17:33,192 --> 23:17:35,760
std strength view

35176
23:17:35,760 --> 23:17:37,680
let's do that we're going to say string

35177
23:17:37,680 --> 23:17:41,120
view here fn for first name

35178
23:17:41,120 --> 23:17:44,552
this is going to modify our class so we

35179
23:17:44,552 --> 23:17:46,800
are not going to mark this as a custom

35180
23:17:46,800 --> 23:17:48,400
member function and we're going to say

35181
23:17:48,400 --> 23:17:49,680
first name

35182
23:17:49,680 --> 23:17:51,120
equals

35183
23:17:51,120 --> 23:17:53,832
fn this is going to do

35184
23:17:53,832 --> 23:17:56,872
we are going to set up a setter for the

35185
23:17:56,872 --> 23:17:59,440
last name set and we're going to pass a

35186
23:17:59,440 --> 23:18:01,760
string view here and we're going to say

35187
23:18:01,760 --> 23:18:04,232
ln for the last name again this is not

35188
23:18:04,232 --> 23:18:06,400
going to be a cast member function so

35189
23:18:06,400 --> 23:18:09,280
we're going to say last name and we can

35190
23:18:09,280 --> 23:18:13,280
pass in ln as our new name here now that

35191
23:18:13,280 --> 23:18:16,320
we have these end we can take out

35192
23:18:16,320 --> 23:18:18,960
these things we have in the constructor

35193
23:18:18,960 --> 23:18:21,600
i think the job for this is done and

35194
23:18:21,600 --> 23:18:23,280
this is going to give you compiler

35195
23:18:23,280 --> 23:18:26,400
errors and we can go in our main cpp

35196
23:18:26,400 --> 23:18:28,080
file and change the names for this

35197
23:18:28,080 --> 23:18:31,440
person here for example we can say p1

35198
23:18:31,440 --> 23:18:32,320
set

35199
23:18:32,320 --> 23:18:35,600
first name we're going to pass john and

35200
23:18:35,600 --> 23:18:37,440
we can also set to the last name we're

35201
23:18:37,440 --> 23:18:40,160
going to say p1 set

35202
23:18:40,160 --> 23:18:43,040
last name and we're going to pass snow

35203
23:18:43,040 --> 23:18:44,960
and this is going to do if we build and

35204
23:18:44,960 --> 23:18:46,800
run this program we're going to see that

35205
23:18:46,800 --> 23:18:48,720
the world is going to be good this is

35206
23:18:48,720 --> 23:18:50,232
the first step

35207
23:18:50,232 --> 23:18:52,232
and if we run we should see the

35208
23:18:52,232 --> 23:18:54,552
information printed out we want to join

35209
23:18:54,552 --> 23:18:57,512
snow printed out and the game should be

35210
23:18:57,512 --> 23:18:58,800
basketball

35211
23:18:58,800 --> 23:19:01,440
let's clear and run rooster we're going

35212
23:19:01,440 --> 23:19:04,320
to see that the data is in here the name

35213
23:19:04,320 --> 23:19:06,720
the names are jon snow and we have our

35214
23:19:06,720 --> 23:19:09,600
game to be basketball here but notice

35215
23:19:09,600 --> 23:19:12,160
these are base methods and we are

35216
23:19:12,160 --> 23:19:15,680
calling them from a derived object and

35217
23:19:15,680 --> 23:19:18,480
this is living proof that the public

35218
23:19:18,480 --> 23:19:20,720
members from the base class are going to

35219
23:19:20,720 --> 23:19:23,360
be inherited and usable

35220
23:19:23,360 --> 23:19:26,960
from a derived class that does public

35221
23:19:26,960 --> 23:19:29,040
inheritance like we are doing here and

35222
23:19:29,040 --> 23:19:31,280
this is really the main message you can

35223
23:19:31,280 --> 23:19:33,600
inherit publicly and have access to

35224
23:19:33,600 --> 23:19:36,320
public stuff from the base class and use

35225
23:19:36,320 --> 23:19:39,760
them in your derived class but private

35226
23:19:39,760 --> 23:19:42,080
data is going to still be private to the

35227
23:19:42,080 --> 23:19:44,640
base class you can't use that in a

35228
23:19:44,640 --> 23:19:47,120
derived class this is the message here

35229
23:19:47,120 --> 23:19:49,040
and this is really all i wanted you to

35230
23:19:49,040 --> 23:19:52,000
see in this lecture the big thing is to

35231
23:19:52,000 --> 23:19:54,160
notice the syntax you use to do

35232
23:19:54,160 --> 23:19:57,440
inheritance and if you do this the

35233
23:19:57,440 --> 23:19:59,832
player class is going to be derived from

35234
23:19:59,832 --> 23:20:00,800
person

35235
23:20:00,800 --> 23:20:03,920
and it will have a person part

35236
23:20:03,920 --> 23:20:06,232
baked inside and we can build on that

35237
23:20:06,232 --> 23:20:09,040
foundation and for example put in our

35238
23:20:09,040 --> 23:20:11,440
own member variables and do all kinds of

35239
23:20:11,440 --> 23:20:12,960
crazy things

35240
23:20:12,960 --> 23:20:14,960
public stuff from the base class are

35241
23:20:14,960 --> 23:20:17,680
going to be inherited and usable from a

35242
23:20:17,680 --> 23:20:20,160
derived class we just saw that by

35243
23:20:20,160 --> 23:20:22,640
setting up a bunch of setters that live

35244
23:20:22,640 --> 23:20:25,360
in the public scope of the base class

35245
23:20:25,360 --> 23:20:28,552
and they were usable from the outside

35246
23:20:28,552 --> 23:20:31,680
because they will be inherited as public

35247
23:20:31,680 --> 23:20:34,400
in a derived class so we can really call

35248
23:20:34,400 --> 23:20:36,480
these methods and use them from the

35249
23:20:36,480 --> 23:20:38,720
outside like we are doing here but

35250
23:20:38,720 --> 23:20:41,120
private data from the base class is not

35251
23:20:41,120 --> 23:20:43,600
going to be accessible and usable from a

35252
23:20:43,600 --> 23:20:46,232
derived class and we saw that by setting

35253
23:20:46,232 --> 23:20:48,320
up this piece of code in the constructor

35254
23:20:48,320 --> 23:20:50,000
of player this is going to give us a

35255
23:20:50,000 --> 23:20:52,480
compiler error saying that first name

35256
23:20:52,480 --> 23:20:55,280
and last name are private to the base

35257
23:20:55,280 --> 23:20:57,760
class we are going to stop here in this

35258
23:20:57,760 --> 23:20:59,360
lecture in the next one we're going to

35259
23:20:59,360 --> 23:21:01,440
learn about another kind of access

35260
23:21:01,440 --> 23:21:04,552
specifier we have in c plus plus and

35261
23:21:04,552 --> 23:21:06,640
that is protected

35262
23:21:06,640 --> 23:21:08,872
so go ahead and finish up here and meet

35263
23:21:08,872 --> 23:21:10,320
me there

35264
23:21:10,320 --> 23:21:12,000
in this lecture we're going to learn

35265
23:21:12,000 --> 23:21:15,920
about the protected access specifier you

35266
23:21:15,920 --> 23:21:18,720
can use in your c plus plus class

35267
23:21:18,720 --> 23:21:20,640
and we're going to be reusing the same

35268
23:21:20,640 --> 23:21:22,232
example from the last lecture we're

35269
23:21:22,232 --> 23:21:23,920
going to have a person class which is

35270
23:21:23,920 --> 23:21:26,552
going to act as our base class and we're

35271
23:21:26,552 --> 23:21:28,872
going to be deriving from this person

35272
23:21:28,872 --> 23:21:32,080
and creating a new class called player

35273
23:21:32,080 --> 23:21:33,760
the player class is going to have a

35274
23:21:33,760 --> 23:21:35,920
person part baked in

35275
23:21:35,920 --> 23:21:38,552
and we can use this as a foundation to

35276
23:21:38,552 --> 23:21:40,960
build other fans in player class for

35277
23:21:40,960 --> 23:21:42,800
example we can set up our own member

35278
23:21:42,800 --> 23:21:45,120
variables and do all kinds of crazy

35279
23:21:45,120 --> 23:21:47,600
things and this is the setup we used in

35280
23:21:47,600 --> 23:21:49,832
the last lecture we set up a person

35281
23:21:49,832 --> 23:21:52,872
class and our members were private as

35282
23:21:52,872 --> 23:21:55,192
you saw here but in the last lecture we

35283
23:21:55,192 --> 23:21:56,320
saw that

35284
23:21:56,320 --> 23:21:58,320
private member variables are not going

35285
23:21:58,320 --> 23:22:01,192
to be accessible and usable from derived

35286
23:22:01,192 --> 23:22:05,192
classes that do public inheritance and

35287
23:22:05,192 --> 23:22:07,680
sometimes we want members from the base

35288
23:22:07,680 --> 23:22:10,232
class to at least be accessible and

35289
23:22:10,232 --> 23:22:14,320
usable from a derived class but still be

35290
23:22:14,320 --> 23:22:17,280
inaccessible from the outside and we can

35291
23:22:17,280 --> 23:22:20,160
achieve this using the protected access

35292
23:22:20,160 --> 23:22:22,640
specifier so for example we can change

35293
23:22:22,640 --> 23:22:24,800
the access specifier of our member

35294
23:22:24,800 --> 23:22:27,760
variables from private to protected and

35295
23:22:27,760 --> 23:22:30,320
at the moment we do this we will be able

35296
23:22:30,320 --> 23:22:32,960
to access for example read from and

35297
23:22:32,960 --> 23:22:35,920
write into these member variables from

35298
23:22:35,920 --> 23:22:38,552
derived classes so for example we will

35299
23:22:38,552 --> 23:22:41,440
be able to modify these guys from a

35300
23:22:41,440 --> 23:22:44,320
constructor of the derived class and we

35301
23:22:44,320 --> 23:22:46,232
thought that that was impossible from

35302
23:22:46,232 --> 23:22:48,960
the last lecture but still we want to be

35303
23:22:48,960 --> 23:22:51,440
able to use these from the outside of

35304
23:22:51,440 --> 23:22:54,080
our derived class which is person here

35305
23:22:54,080 --> 23:22:55,600
so we're going to still do public

35306
23:22:55,600 --> 23:22:57,920
inheritance like from the last lecture

35307
23:22:57,920 --> 23:23:00,400
but now that our member variables in the

35308
23:23:00,400 --> 23:23:03,192
base class are protected we will have

35309
23:23:03,192 --> 23:23:05,360
the ability to do whatever we want with

35310
23:23:05,360 --> 23:23:07,832
them in the derived class and when we

35311
23:23:07,832 --> 23:23:10,720
say in the derived class we mean from

35312
23:23:10,720 --> 23:23:13,280
any method from the derived class for

35313
23:23:13,280 --> 23:23:15,120
example we can go in our constructor

35314
23:23:15,120 --> 23:23:18,320
here and then set data into the member

35315
23:23:18,320 --> 23:23:20,640
variables from the base class and that's

35316
23:23:20,640 --> 23:23:23,192
going to work as we're going to see

35317
23:23:23,192 --> 23:23:25,040
in a minute now that you know this we're

35318
23:23:25,040 --> 23:23:26,960
going to head over to visual studio code

35319
23:23:26,960 --> 23:23:29,040
and play with this a little more okay

35320
23:23:29,040 --> 23:23:31,440
again our member variables from the base

35321
23:23:31,440 --> 23:23:34,080
class are going to be protected

35322
23:23:34,080 --> 23:23:36,552
okay so we can really say that here

35323
23:23:36,552 --> 23:23:38,800
let's say protected and at the moment we

35324
23:23:38,800 --> 23:23:41,440
do this they are going to be accessible

35325
23:23:41,440 --> 23:23:44,080
and usable from a derived class so from

35326
23:23:44,080 --> 23:23:46,232
the derived class we will have the first

35327
23:23:46,232 --> 23:23:48,160
name for example

35328
23:23:48,160 --> 23:23:50,320
so from the derived class we will have

35329
23:23:50,320 --> 23:23:52,960
our members baked then we will have a

35330
23:23:52,960 --> 23:23:55,440
last name and the first name and because

35331
23:23:55,440 --> 23:23:57,832
they are protected in the base class and

35332
23:23:57,832 --> 23:24:00,552
we are doing public inheritance we will

35333
23:24:00,552 --> 23:24:02,800
be able for example to set data into

35334
23:24:02,800 --> 23:24:04,720
these member variables from a derived

35335
23:24:04,720 --> 23:24:06,480
class and that's going to be

35336
23:24:06,480 --> 23:24:08,480
really cool now that you know this we're

35337
23:24:08,480 --> 23:24:10,552
going to head over to visual studio code

35338
23:24:10,552 --> 23:24:12,400
and play with us a little more okay so

35339
23:24:12,400 --> 23:24:15,600
here we are in our here we are in our

35340
23:24:15,600 --> 23:24:17,832
working folder the current project is

35341
23:24:17,832 --> 23:24:20,160
protected members we're going to grab

35342
23:24:20,160 --> 23:24:22,320
the code from the last lecture and reuse

35343
23:24:22,320 --> 23:24:24,720
that because that's going to have our

35344
23:24:24,720 --> 23:24:27,680
inheritance hierarchy already set up we

35345
23:24:27,680 --> 23:24:30,552
will have our person and player class

35346
23:24:30,552 --> 23:24:33,120
and we can reuse them we will have our

35347
23:24:33,120 --> 23:24:35,760
person and player classes and we will

35348
23:24:35,760 --> 23:24:38,960
reuse them without needing to completely

35349
23:24:38,960 --> 23:24:40,960
set them up from scratch that's going to

35350
23:24:40,960 --> 23:24:43,832
save us a few seconds so we're going to

35351
23:24:43,832 --> 23:24:45,832
put them in here

35352
23:24:45,832 --> 23:24:47,832
and we are going to open this little guy

35353
23:24:47,832 --> 23:24:49,600
in visual studio code by dragging and

35354
23:24:49,600 --> 23:24:51,512
dropping here and we will have our

35355
23:24:51,512 --> 23:24:53,760
person class which is going to be the

35356
23:24:53,760 --> 23:24:56,320
base class it's going to have our member

35357
23:24:56,320 --> 23:24:58,400
variables which are going to be private

35358
23:24:58,400 --> 23:25:00,640
from the last lecture we will have a

35359
23:25:00,640 --> 23:25:02,400
player class which is going to be

35360
23:25:02,400 --> 23:25:05,440
inherited publicly from the player

35361
23:25:05,440 --> 23:25:07,192
we will have a player class which is

35362
23:25:07,192 --> 23:25:09,512
going to be publicly inheriting from

35363
23:25:09,512 --> 23:25:12,080
person and we have our main cpp file

35364
23:25:12,080 --> 23:25:14,320
which is going to set up a player object

35365
23:25:14,320 --> 23:25:16,000
and try to use it and we're going to see

35366
23:25:16,000 --> 23:25:19,440
how this goes in this lecture so what we

35367
23:25:19,440 --> 23:25:21,360
want to do is to change the access

35368
23:25:21,360 --> 23:25:24,640
specifier in the base class and make

35369
23:25:24,640 --> 23:25:26,960
that protected we can do that we can say

35370
23:25:26,960 --> 23:25:29,360
protect it and this is going to change a

35371
23:25:29,360 --> 23:25:32,080
few things about this class what this is

35372
23:25:32,080 --> 23:25:33,192
going to do

35373
23:25:33,192 --> 23:25:35,760
if you do public inheritance from this

35374
23:25:35,760 --> 23:25:38,480
person class you will have the ability

35375
23:25:38,480 --> 23:25:40,640
to do whatever you want with these

35376
23:25:40,640 --> 23:25:43,680
member variables from a derived class

35377
23:25:43,680 --> 23:25:45,760
you will have the ability to write into

35378
23:25:45,760 --> 23:25:47,680
these member variables and change the

35379
23:25:47,680 --> 23:25:50,080
data that we have inside you will also

35380
23:25:50,080 --> 23:25:52,232
have the ability to read from them and

35381
23:25:52,232 --> 23:25:54,232
that's something we couldn't do from the

35382
23:25:54,232 --> 23:25:56,720
last lecture and this may come in handy

35383
23:25:56,720 --> 23:25:58,640
sometimes another thing you should know

35384
23:25:58,640 --> 23:26:01,040
is that these members are still not

35385
23:26:01,040 --> 23:26:03,600
going to be accessible from the outside

35386
23:26:03,600 --> 23:26:06,720
so from the standpoint of the main

35387
23:26:06,720 --> 23:26:08,872
function for example here they are going

35388
23:26:08,872 --> 23:26:11,600
to behave as if they are private because

35389
23:26:11,600 --> 23:26:13,600
they want to be accessible from the

35390
23:26:13,600 --> 23:26:16,872
outside they will only be accessible and

35391
23:26:16,872 --> 23:26:20,480
modifiable from derived classes

35392
23:26:20,480 --> 23:26:23,040
that do public inheritance this is

35393
23:26:23,040 --> 23:26:25,680
really important to understand now that

35394
23:26:25,680 --> 23:26:27,920
we have this we can really do all kinds

35395
23:26:27,920 --> 23:26:30,480
of crazy things for example we can go in

35396
23:26:30,480 --> 23:26:33,280
our constructor of player and comment

35397
23:26:33,280 --> 23:26:35,192
what wasn't working from the last

35398
23:26:35,192 --> 23:26:38,232
lecture and this is going to work now so

35399
23:26:38,232 --> 23:26:40,320
let's uncomment this and we're going to

35400
23:26:40,320 --> 23:26:42,080
see that the squiggly lines are going to

35401
23:26:42,080 --> 23:26:45,120
go away and if we build a player object

35402
23:26:45,120 --> 23:26:47,192
using this constructor we're going to

35403
23:26:47,192 --> 23:26:50,000
see that we're going to have jon snow in

35404
23:26:50,000 --> 23:26:52,480
even if we don't set using the setters

35405
23:26:52,480 --> 23:26:54,400
from the base class so we can take these

35406
23:26:54,400 --> 23:26:55,360
out

35407
23:26:55,360 --> 23:26:57,360
and if we print information about this

35408
23:26:57,360 --> 23:26:59,120
player we're going to see the game to be

35409
23:26:59,120 --> 23:27:01,920
basketball and the names are going to be

35410
23:27:01,920 --> 23:27:05,760
john snow because we are setting up this

35411
23:27:05,760 --> 23:27:08,080
in the constructor of player that's no

35412
23:27:08,080 --> 23:27:10,640
longer that's no longer going to be the

35413
23:27:10,640 --> 23:27:13,832
data we get from the constructor of a

35414
23:27:13,832 --> 23:27:17,192
person object which was here

35415
23:27:17,192 --> 23:27:20,480
in the base class let's try to build and

35416
23:27:20,480 --> 23:27:22,720
run this program so that you can really

35417
23:27:22,720 --> 23:27:25,832
see this i just used clan here but it is

35418
23:27:25,832 --> 23:27:28,400
also going to work no big deal here the

35419
23:27:28,400 --> 23:27:31,512
build is going to be good we can clear

35420
23:27:31,512 --> 23:27:34,000
and bring up a powershell window we can

35421
23:27:34,000 --> 23:27:36,080
use to run this program we're going to

35422
23:27:36,080 --> 23:27:37,760
say rooster and you're going to see that

35423
23:27:37,760 --> 23:27:40,000
player is going to be

35424
23:27:40,000 --> 23:27:42,320
having the information the game is going

35425
23:27:42,320 --> 23:27:44,640
to be basketball the names are going to

35426
23:27:44,640 --> 23:27:48,080
be jon snow and we are setting this data

35427
23:27:48,080 --> 23:27:50,552
from a derived class and we have the

35428
23:27:50,552 --> 23:27:53,360
ability to do this because these members

35429
23:27:53,360 --> 23:27:56,720
are now protected in the base class so

35430
23:27:56,720 --> 23:27:59,120
they are accessible and usable from a

35431
23:27:59,120 --> 23:28:00,640
derived class

35432
23:28:00,640 --> 23:28:02,400
now that we have this ability we can

35433
23:28:02,400 --> 23:28:06,080
really change how our class at least the

35434
23:28:06,080 --> 23:28:08,400
derived class works we're going to

35435
23:28:08,400 --> 23:28:12,400
change it to have two more parameters

35436
23:28:12,400 --> 23:28:14,400
and we're going to pass the first name

35437
23:28:14,400 --> 23:28:17,360
and the last name and pass this data

35438
23:28:17,360 --> 23:28:20,552
back into the base class by setting the

35439
23:28:20,552 --> 23:28:22,552
data in the body of the constructor this

35440
23:28:22,552 --> 23:28:24,640
is going to work so let's add our

35441
23:28:24,640 --> 23:28:26,960
parameters we're going to say std string

35442
23:28:26,960 --> 23:28:28,080
view

35443
23:28:28,080 --> 23:28:30,160
and this is going to be

35444
23:28:30,160 --> 23:28:32,800
first name param and we're going to put

35445
23:28:32,800 --> 23:28:34,800
in another one which is going to also be

35446
23:28:34,800 --> 23:28:37,360
a string view parameter and it's going

35447
23:28:37,360 --> 23:28:39,920
to be last name param we can say that

35448
23:28:39,920 --> 23:28:42,000
and we're going to hop over in our

35449
23:28:42,000 --> 23:28:44,552
implementation let's grab what we just

35450
23:28:44,552 --> 23:28:46,640
added because we will need to put that

35451
23:28:46,640 --> 23:28:50,760
in our cpp file we are going to go in

35452
23:28:50,760 --> 23:28:53,120
player.cpp and we're going to add this

35453
23:28:53,120 --> 23:28:55,600
data we're going to put that here

35454
23:28:55,600 --> 23:28:58,000
we can close the left sidebar to have

35455
23:28:58,000 --> 23:29:00,640
some more breathing room and then we're

35456
23:29:00,640 --> 23:29:03,280
going to not do

35457
23:29:03,280 --> 23:29:05,360
an initializer list here because this is

35458
23:29:05,360 --> 23:29:07,280
really going to be useless we are

35459
23:29:07,280 --> 23:29:10,232
changing data in the body anyway so what

35460
23:29:10,232 --> 23:29:11,280
we can do

35461
23:29:11,280 --> 23:29:14,400
is say game param or a game and we're

35462
23:29:14,400 --> 23:29:15,680
going to say

35463
23:29:15,680 --> 23:29:18,232
gamipuram i am really sorry i am not

35464
23:29:18,232 --> 23:29:21,040
following the same convention for the

35465
23:29:21,040 --> 23:29:23,832
naming of my member variables but we can

35466
23:29:23,832 --> 23:29:26,320
change this later so let's say first

35467
23:29:26,320 --> 23:29:29,120
name we are going to pass in first name

35468
23:29:29,120 --> 23:29:31,360
ram and for the last name we're going to

35469
23:29:31,360 --> 23:29:33,760
say last name param and that's going to

35470
23:29:33,760 --> 23:29:36,640
do now we have the ability to go in the

35471
23:29:36,640 --> 23:29:40,552
main cpp file and create player objects

35472
23:29:40,552 --> 23:29:42,720
and specify the first name and the last

35473
23:29:42,720 --> 23:29:45,120
name and this is going to be much more

35474
23:29:45,120 --> 23:29:47,192
flexible so let's go back to the

35475
23:29:47,192 --> 23:29:50,480
constructor and see the order of our

35476
23:29:50,480 --> 23:29:53,920
parameters game first name last name so

35477
23:29:53,920 --> 23:29:56,872
we can come here and say first name is

35478
23:29:56,872 --> 23:29:58,080
going to be

35479
23:29:58,080 --> 23:30:00,232
john and the last name is going to be

35480
23:30:00,232 --> 23:30:02,400
snow and if we build and run we're going

35481
23:30:02,400 --> 23:30:04,552
to see the information printed out here

35482
23:30:04,552 --> 23:30:06,480
and now we have the flexibility to be

35483
23:30:06,480 --> 23:30:08,480
able to specify this

35484
23:30:08,480 --> 23:30:10,640
in a constructor and this is going to

35485
23:30:10,640 --> 23:30:13,680
make the job of building our objects

35486
23:30:13,680 --> 23:30:16,720
much easier and we can forward this data

35487
23:30:16,720 --> 23:30:19,360
back into the base class using the

35488
23:30:19,360 --> 23:30:22,000
protected mechanism that we just learned

35489
23:30:22,000 --> 23:30:23,760
about in this lecture and this is really

35490
23:30:23,760 --> 23:30:26,080
cool so let's build we're going to pass

35491
23:30:26,080 --> 23:30:28,800
this through gcc and the world is going

35492
23:30:28,800 --> 23:30:31,512
to be good we can clear and run rooster

35493
23:30:31,512 --> 23:30:33,280
we're going to see that the data is

35494
23:30:33,280 --> 23:30:35,600
passed back to the base class this is

35495
23:30:35,600 --> 23:30:36,640
working

35496
23:30:36,640 --> 23:30:38,872
really well okay so this is really all i

35497
23:30:38,872 --> 23:30:41,600
wanted you to see in this lecture we can

35498
23:30:41,600 --> 23:30:44,080
set up protected member variables and

35499
23:30:44,080 --> 23:30:45,680
they are going to be accessible and

35500
23:30:45,680 --> 23:30:49,040
usable from any derived class that does

35501
23:30:49,040 --> 23:30:52,000
public inheritance but they want to be

35502
23:30:52,000 --> 23:30:54,640
accessible from the outside so if you

35503
23:30:54,640 --> 23:30:58,232
try and for example say p1 and say

35504
23:30:58,232 --> 23:31:01,120
first name and try to change that to

35505
23:31:01,120 --> 23:31:02,872
something else let's say daniel for

35506
23:31:02,872 --> 23:31:04,800
example you're going to have compiler

35507
23:31:04,800 --> 23:31:07,280
errors because this is not going to work

35508
23:31:07,280 --> 23:31:09,040
so let's try and build and show you the

35509
23:31:09,040 --> 23:31:11,832
compiler error okay so protected members

35510
23:31:11,832 --> 23:31:14,400
are not accessible from the outside

35511
23:31:14,400 --> 23:31:16,552
they will be just accessible from

35512
23:31:16,552 --> 23:31:19,760
derived classes or to be more specific

35513
23:31:19,760 --> 23:31:22,640
they are going to be accessible from

35514
23:31:22,640 --> 23:31:25,680
the members of the derived class and by

35515
23:31:25,680 --> 23:31:27,600
members i mean member functions because

35516
23:31:27,600 --> 23:31:29,360
that's where you will be accessing and

35517
23:31:29,360 --> 23:31:32,080
modifying stuff so let's go back to the

35518
23:31:32,080 --> 23:31:35,360
main cpp file and remove this

35519
23:31:35,360 --> 23:31:37,600
and this is really all i wanted to share

35520
23:31:37,600 --> 23:31:39,440
with you and i hope you found this

35521
23:31:39,440 --> 23:31:42,320
lecture interesting we are going to stop

35522
23:31:42,320 --> 23:31:43,760
here in this one

35523
23:31:43,760 --> 23:31:45,600
and in the next one we're going to zoom

35524
23:31:45,600 --> 23:31:48,800
in on the syntax here we are using to

35525
23:31:48,800 --> 23:31:51,832
derive from other classes we just did

35526
23:31:51,832 --> 23:31:54,080
the public inheritance here but in the

35527
23:31:54,080 --> 23:31:55,680
next lecture we're going to see that it

35528
23:31:55,680 --> 23:31:59,040
is possible to actually do protected and

35529
23:31:59,040 --> 23:32:01,120
private inheritance and we're going to

35530
23:32:01,120 --> 23:32:03,760
see what this means in the next lecture

35531
23:32:03,760 --> 23:32:06,000
so go ahead and finish up here and meet

35532
23:32:06,000 --> 23:32:07,760
me there in this lecture we're going to

35533
23:32:07,760 --> 23:32:11,280
learn about base class access specifiers

35534
23:32:11,280 --> 23:32:13,512
and in case you didn't know we have been

35535
23:32:13,512 --> 23:32:15,920
using base class access specifiers in

35536
23:32:15,920 --> 23:32:18,720
this chapter all along and to really

35537
23:32:18,720 --> 23:32:21,192
understand this let's look at our player

35538
23:32:21,192 --> 23:32:23,680
class which is inheriting from person

35539
23:32:23,680 --> 23:32:27,120
and we are doing public inheritance the

35540
23:32:27,120 --> 23:32:29,760
public keyword here is a base class

35541
23:32:29,760 --> 23:32:32,552
access specifier and it is going to

35542
23:32:32,552 --> 23:32:33,760
control

35543
23:32:33,760 --> 23:32:37,512
how accessible our base class members

35544
23:32:37,512 --> 23:32:40,552
from a derived class and we have three

35545
23:32:40,552 --> 23:32:43,120
options okay so if we do public

35546
23:32:43,120 --> 23:32:45,832
inheritance like we see here in our

35547
23:32:45,832 --> 23:32:47,680
player class

35548
23:32:47,680 --> 23:32:49,832
anything that is public in the base

35549
23:32:49,832 --> 23:32:52,000
class is also going to be public you see

35550
23:32:52,000 --> 23:32:54,800
m1 here is also public in the derived

35551
23:32:54,800 --> 23:32:55,760
class

35552
23:32:55,760 --> 23:32:57,680
anything that is protected is going to

35553
23:32:57,680 --> 23:33:00,480
stay protected and anything that is

35554
23:33:00,480 --> 23:33:02,960
private in the base class is also going

35555
23:33:02,960 --> 23:33:06,640
to stay private in the derived class

35556
23:33:06,640 --> 23:33:08,800
try and take a moment to look at this

35557
23:33:08,800 --> 23:33:09,832
again

35558
23:33:09,832 --> 23:33:13,040
the member access specifiers we have in

35559
23:33:13,040 --> 23:33:16,320
the base class are going to stay intact

35560
23:33:16,320 --> 23:33:17,512
if we do

35561
23:33:17,512 --> 23:33:20,400
public inheritance again anything that

35562
23:33:20,400 --> 23:33:22,720
is public in base is going to be public

35563
23:33:22,720 --> 23:33:25,360
and derived anything that is protected

35564
23:33:25,360 --> 23:33:27,832
in base is going to be protected and

35565
23:33:27,832 --> 23:33:30,960
derived and anything that is private in

35566
23:33:30,960 --> 23:33:32,640
base is going to be

35567
23:33:32,640 --> 23:33:36,000
private in derived this is one kind of

35568
23:33:36,000 --> 23:33:39,120
inheritance we can do in c plus plus but

35569
23:33:39,120 --> 23:33:42,720
we can also do protected inheritance and

35570
23:33:42,720 --> 23:33:44,872
the syntax to do that you just use the

35571
23:33:44,872 --> 23:33:47,360
protected keyword here you say class

35572
23:33:47,360 --> 23:33:49,760
player column column and specify that

35573
23:33:49,760 --> 23:33:52,872
you want to do protected inheritance and

35574
23:33:52,872 --> 23:33:55,360
then you specify the base class you want

35575
23:33:55,360 --> 23:33:58,320
to inherit from the moment you do this

35576
23:33:58,320 --> 23:34:00,232
anything that is public in the base

35577
23:34:00,232 --> 23:34:02,640
class is going to be protected in the

35578
23:34:02,640 --> 23:34:04,160
derived class

35579
23:34:04,160 --> 23:34:06,000
anything that is protected is going to

35580
23:34:06,000 --> 23:34:08,960
stay protected anything that is private

35581
23:34:08,960 --> 23:34:11,512
is going to be private

35582
23:34:11,512 --> 23:34:13,760
and in one way you can see that we can

35583
23:34:13,760 --> 23:34:17,360
use these base class access specifiers

35584
23:34:17,360 --> 23:34:18,960
to constrain

35585
23:34:18,960 --> 23:34:21,832
the access specifier in derived class

35586
23:34:21,832 --> 23:34:24,800
but we can't make the access specifiers

35587
23:34:24,800 --> 23:34:26,872
in derived class

35588
23:34:26,872 --> 23:34:28,960
more relaxed we can only make things

35589
23:34:28,960 --> 23:34:31,600
more constrained or more restricted for

35590
23:34:31,600 --> 23:34:33,832
example the m1 member variable was

35591
23:34:33,832 --> 23:34:36,720
public but now we have made it become

35592
23:34:36,720 --> 23:34:40,160
protected by using the protected base

35593
23:34:40,160 --> 23:34:42,872
access specifier here okay so now you

35594
23:34:42,872 --> 23:34:45,360
know that we can do public and protected

35595
23:34:45,360 --> 23:34:48,232
inheritance but it is also possible to

35596
23:34:48,232 --> 23:34:51,280
do private inheritance and you do that

35597
23:34:51,280 --> 23:34:54,232
by using a private base class access

35598
23:34:54,232 --> 23:34:56,640
specifier the moment you do this

35599
23:34:56,640 --> 23:34:58,400
anything that is public in the base

35600
23:34:58,400 --> 23:35:00,552
class is going to become private in the

35601
23:35:00,552 --> 23:35:03,360
derived class anything that is protected

35602
23:35:03,360 --> 23:35:05,120
in the base class is going to become

35603
23:35:05,120 --> 23:35:07,832
private in the derived class and

35604
23:35:07,832 --> 23:35:09,360
anything that is private is going to

35605
23:35:09,360 --> 23:35:12,160
stay private in the derived class and

35606
23:35:12,160 --> 23:35:13,680
again you see that this is going to

35607
23:35:13,680 --> 23:35:16,720
constrain thanks things that were public

35608
23:35:16,720 --> 23:35:18,960
are now private in derived and we can't

35609
23:35:18,960 --> 23:35:21,360
really do anything with them from any

35610
23:35:21,360 --> 23:35:23,832
other class that might derive from our

35611
23:35:23,832 --> 23:35:26,400
player class so this is the setup we

35612
23:35:26,400 --> 23:35:29,192
have okay to sum this up through the

35613
23:35:29,192 --> 23:35:31,512
base class access specifier we can

35614
23:35:31,512 --> 23:35:35,600
control how relaxed or constrained

35615
23:35:35,600 --> 23:35:38,480
is the access to base class members from

35616
23:35:38,480 --> 23:35:40,320
the derived class and this is really

35617
23:35:40,320 --> 23:35:42,320
important to understand if you want to

35618
23:35:42,320 --> 23:35:44,800
say as relaxed as they are in the base

35619
23:35:44,800 --> 23:35:47,280
class you can use public inheritance if

35620
23:35:47,280 --> 23:35:49,192
you want to constrain a little bit you

35621
23:35:49,192 --> 23:35:50,400
can use

35622
23:35:50,400 --> 23:35:52,320
protected inheritance and things are

35623
23:35:52,320 --> 23:35:54,480
going to be inherited as protected

35624
23:35:54,480 --> 23:35:57,680
except for the private data in the base

35625
23:35:57,680 --> 23:35:59,920
class if you want things to be super

35626
23:35:59,920 --> 23:36:02,080
constrained you can use the private

35627
23:36:02,080 --> 23:36:04,160
inheritance that we just learned about

35628
23:36:04,160 --> 23:36:06,160
and everything in your derived class is

35629
23:36:06,160 --> 23:36:09,440
going to be private and you can use this

35630
23:36:09,440 --> 23:36:11,512
if it makes sense for the application

35631
23:36:11,512 --> 23:36:14,080
you are designing and you can use these

35632
23:36:14,080 --> 23:36:16,160
kinds of features if they make sense for

35633
23:36:16,160 --> 23:36:18,552
whatever application you are designing

35634
23:36:18,552 --> 23:36:20,960
with c plus plus one thing you should

35635
23:36:20,960 --> 23:36:23,120
know though is that regardless of the

35636
23:36:23,120 --> 23:36:26,320
base class access specifier we use

35637
23:36:26,320 --> 23:36:29,192
private members of the base class can

35638
23:36:29,192 --> 23:36:32,160
never be accessible from a derived class

35639
23:36:32,160 --> 23:36:34,400
so anything that is private is going to

35640
23:36:34,400 --> 23:36:37,120
stay private and you have no way to

35641
23:36:37,120 --> 23:36:39,360
relax things a little bit that's not

35642
23:36:39,360 --> 23:36:40,960
going to work you should really know

35643
23:36:40,960 --> 23:36:43,360
this now that you know these kinds of

35644
23:36:43,360 --> 23:36:46,080
inheritances we can do in ziplus plus

35645
23:36:46,080 --> 23:36:47,680
we're going to head over to the next

35646
23:36:47,680 --> 23:36:49,760
lecture and play with them a little more

35647
23:36:49,760 --> 23:36:51,760
in this lecture we're going to play with

35648
23:36:51,760 --> 23:36:54,160
the base class access specifiers we

35649
23:36:54,160 --> 23:36:56,160
learned about in the last lecture in

35650
23:36:56,160 --> 23:36:58,160
other words we're going to play with

35651
23:36:58,160 --> 23:37:01,512
public protected and private inheritance

35652
23:37:01,512 --> 23:37:03,760
in visual studio code so let's review a

35653
23:37:03,760 --> 23:37:05,680
little bit what we talked about in the

35654
23:37:05,680 --> 23:37:07,680
last lecture we say that we can have

35655
23:37:07,680 --> 23:37:10,080
public inheritance and the syntax to do

35656
23:37:10,080 --> 23:37:12,960
that is what you see here and at the

35657
23:37:12,960 --> 23:37:15,120
moment you do this what was public in

35658
23:37:15,120 --> 23:37:17,040
the basic class is going to be public in

35659
23:37:17,040 --> 23:37:19,280
the derived class what was protected is

35660
23:37:19,280 --> 23:37:21,600
going to stay protected what was private

35661
23:37:21,600 --> 23:37:24,320
is going to become private in the

35662
23:37:24,320 --> 23:37:26,640
derived class in other words public

35663
23:37:26,640 --> 23:37:28,480
inheritance is really not going to

35664
23:37:28,480 --> 23:37:31,360
change the accessibility of the member

35665
23:37:31,360 --> 23:37:33,120
variables we have in the base class

35666
23:37:33,120 --> 23:37:35,832
we're going to inherit the data as it

35667
23:37:35,832 --> 23:37:38,552
was with the same access level we had in

35668
23:37:38,552 --> 23:37:40,552
the base class this is a defining

35669
23:37:40,552 --> 23:37:43,360
feature of public inheritance in c plus

35670
23:37:43,360 --> 23:37:45,680
plus we can also do protected

35671
23:37:45,680 --> 23:37:49,120
inheritance and what this is going to do

35672
23:37:49,120 --> 23:37:52,640
is to make protected the highest access

35673
23:37:52,640 --> 23:37:55,920
level we can have in the derived class

35674
23:37:55,920 --> 23:37:57,920
so anything that was public in the base

35675
23:37:57,920 --> 23:37:59,920
class is going to become protected

35676
23:37:59,920 --> 23:38:01,680
anything that was protected is going to

35677
23:38:01,680 --> 23:38:03,920
stay protected because that's the

35678
23:38:03,920 --> 23:38:05,920
highest level we can do now

35679
23:38:05,920 --> 23:38:07,760
and anything that was private in the

35680
23:38:07,760 --> 23:38:10,552
base class is going to be private in the

35681
23:38:10,552 --> 23:38:13,280
derived class we say private in the

35682
23:38:13,280 --> 23:38:15,280
sense that it is going to be private to

35683
23:38:15,280 --> 23:38:17,832
the base class so you can't really use

35684
23:38:17,832 --> 23:38:21,600
m3 from the player class in this case if

35685
23:38:21,600 --> 23:38:22,800
you're trying to do that you're going to

35686
23:38:22,800 --> 23:38:25,680
get a compiler error okay we can also do

35687
23:38:25,680 --> 23:38:28,552
private inheritance and the syntax to do

35688
23:38:28,552 --> 23:38:31,360
that is what you see here and now

35689
23:38:31,360 --> 23:38:33,440
private is going to be the highest level

35690
23:38:33,440 --> 23:38:34,720
we can do

35691
23:38:34,720 --> 23:38:37,120
in the player class in terms of the

35692
23:38:37,120 --> 23:38:39,600
members that we get from the base class

35693
23:38:39,600 --> 23:38:41,600
so anything that was public is going to

35694
23:38:41,600 --> 23:38:43,600
become private anything that was

35695
23:38:43,600 --> 23:38:45,760
protected is going to become private

35696
23:38:45,760 --> 23:38:48,000
anything that was private to the base

35697
23:38:48,000 --> 23:38:49,920
class is going to stay private to the

35698
23:38:49,920 --> 23:38:52,640
base class this is what we mean here but

35699
23:38:52,640 --> 23:38:53,760
now

35700
23:38:53,760 --> 23:38:58,552
m1 and m2 just became public to the

35701
23:38:58,552 --> 23:39:01,680
player class if anybody else tries to

35702
23:39:01,680 --> 23:39:04,800
derive or inherit from a player these

35703
23:39:04,800 --> 23:39:07,120
things are not going to be accessible

35704
23:39:07,120 --> 23:39:10,400
and this is in some way the player class

35705
23:39:10,400 --> 23:39:13,040
being selfish it is saying i am going to

35706
23:39:13,040 --> 23:39:15,680
get everything i can from my parent

35707
23:39:15,680 --> 23:39:18,480
class or my base class but i am going to

35708
23:39:18,480 --> 23:39:21,280
make it all mine nobody else can take

35709
23:39:21,280 --> 23:39:23,360
this and this is the kind of setup we

35710
23:39:23,360 --> 23:39:24,400
can achieve

35711
23:39:24,400 --> 23:39:27,040
with private inheritance okay so now

35712
23:39:27,040 --> 23:39:28,960
that we have this in mind we're going to

35713
23:39:28,960 --> 23:39:30,960
play with us in visual studio code we're

35714
23:39:30,960 --> 23:39:32,800
going to set up a bunch of classes we're

35715
23:39:32,800 --> 23:39:34,232
going to set up a personal class we're

35716
23:39:34,232 --> 23:39:36,552
going to be inheriting from we are going

35717
23:39:36,552 --> 23:39:38,640
to set up a nurse class which is going

35718
23:39:38,640 --> 23:39:41,360
to do protected inheritance and we're

35719
23:39:41,360 --> 23:39:43,440
going to set up an engineer class which

35720
23:39:43,440 --> 23:39:45,920
is going to do private inheritance and

35721
23:39:45,920 --> 23:39:47,760
we're going to really play with this and

35722
23:39:47,760 --> 23:39:50,320
see how this plays out in real c plus

35723
23:39:50,320 --> 23:39:52,720
plus code so let's do this here we are

35724
23:39:52,720 --> 23:39:54,960
in our working folder the current

35725
23:39:54,960 --> 23:39:58,960
project is base access specifier a demo

35726
23:39:58,960 --> 23:40:00,720
we're going to do a demo on this but

35727
23:40:00,720 --> 23:40:02,320
before we do that we're going to grab

35728
23:40:02,320 --> 23:40:05,760
our template files and put them in place

35729
23:40:05,760 --> 23:40:07,680
and we are going to open this little guy

35730
23:40:07,680 --> 23:40:09,760
in visual studio code by dragging and

35731
23:40:09,760 --> 23:40:11,920
dropping here this is going to give us a

35732
23:40:11,920 --> 23:40:13,680
good starting point we're going to have

35733
23:40:13,680 --> 23:40:16,080
our main cpp file we're going to clean

35734
23:40:16,080 --> 23:40:18,000
it up and we're going to set up our base

35735
23:40:18,000 --> 23:40:19,600
class which is going to be the person

35736
23:40:19,600 --> 23:40:22,480
class so let's put this in from scratch

35737
23:40:22,480 --> 23:40:24,720
we're going to add our files we're going

35738
23:40:24,720 --> 23:40:26,872
to say person page and we're going to

35739
23:40:26,872 --> 23:40:28,640
say person.cpp

35740
23:40:28,640 --> 23:40:30,872
we are going to hop over in our header

35741
23:40:30,872 --> 23:40:33,600
file and put in our code nothing special

35742
23:40:33,600 --> 23:40:35,920
so far we have an include gourd we have

35743
23:40:35,920 --> 23:40:37,832
our person class it has a bunch of

35744
23:40:37,832 --> 23:40:40,160
member variables we have the full name

35745
23:40:40,160 --> 23:40:42,960
which is public we have the age which is

35746
23:40:42,960 --> 23:40:45,680
protected and we have the address which

35747
23:40:45,680 --> 23:40:49,040
is private to this class here this is

35748
23:40:49,040 --> 23:40:51,280
going to be our starting point

35749
23:40:51,280 --> 23:40:53,600
we also have a bunch of constructors we

35750
23:40:53,600 --> 23:40:55,760
have a default one we also have another

35751
23:40:55,760 --> 23:40:57,920
one which is going to take all the data

35752
23:40:57,920 --> 23:41:00,552
we can use the constructor person object

35753
23:41:00,552 --> 23:41:03,120
and here we are passing a cost string by

35754
23:41:03,120 --> 23:41:05,440
reference i think we can fix this and

35755
23:41:05,440 --> 23:41:07,600
pass a string view this is going to be

35756
23:41:07,600 --> 23:41:10,232
better let's say string view and we're

35757
23:41:10,232 --> 23:41:12,480
going to change the first parameter here

35758
23:41:12,480 --> 23:41:15,680
to be an std string view by value this

35759
23:41:15,680 --> 23:41:18,000
is going to be much better okay we have

35760
23:41:18,000 --> 23:41:21,120
our class we can hop over in the cpp

35761
23:41:21,120 --> 23:41:24,080
file and put in our implementation we

35762
23:41:24,080 --> 23:41:26,080
are going to change the constructor a

35763
23:41:26,080 --> 23:41:28,320
little bit and make sure we are taking

35764
23:41:28,320 --> 23:41:31,120
an std string view by value and if you

35765
23:41:31,120 --> 23:41:33,440
wanted to type all this code you can get

35766
23:41:33,440 --> 23:41:36,080
it from the resource section of this

35767
23:41:36,080 --> 23:41:37,920
lecture i am going to attach all the

35768
23:41:37,920 --> 23:41:40,000
source code and you can download and use

35769
23:41:40,000 --> 23:41:42,232
this however you want to really make

35770
23:41:42,232 --> 23:41:44,720
your learning experience as pleasant as

35771
23:41:44,720 --> 23:41:46,960
possible so we have our constructor here

35772
23:41:46,960 --> 23:41:49,120
it is going to forward the data into our

35773
23:41:49,120 --> 23:41:50,960
member variables the full name is going

35774
23:41:50,960 --> 23:41:53,280
to go into our full name member variable

35775
23:41:53,280 --> 23:41:54,800
we're going to grab the age and the

35776
23:41:54,800 --> 23:41:56,400
address and we're going to store all

35777
23:41:56,400 --> 23:41:58,720
this information we also have an output

35778
23:41:58,720 --> 23:42:00,400
stream operator which is going to be

35779
23:42:00,400 --> 23:42:02,872
printing all this information here it is

35780
23:42:02,872 --> 23:42:04,872
going to go through the getters because

35781
23:42:04,872 --> 23:42:07,120
we have a person object passed as a

35782
23:42:07,120 --> 23:42:10,000
parameter here and this is going to work

35783
23:42:10,000 --> 23:42:12,400
we can go in the main cpp file and

35784
23:42:12,400 --> 23:42:15,192
include our person class and create an

35785
23:42:15,192 --> 23:42:17,192
object of it we can do something like

35786
23:42:17,192 --> 23:42:20,080
person person one and we can pass the

35787
23:42:20,080 --> 23:42:22,960
data that our constructor expects we can

35788
23:42:22,960 --> 23:42:25,760
pass in the full name the age and the

35789
23:42:25,760 --> 23:42:27,832
address so let's do that we're going to

35790
23:42:27,832 --> 23:42:30,800
say the full name daniel gray why not

35791
23:42:30,800 --> 23:42:33,512
and the age is going to be 27 we can put

35792
23:42:33,512 --> 23:42:35,360
in whatever we want and we're going to

35793
23:42:35,360 --> 23:42:37,832
put in the address we're going to say

35794
23:42:37,832 --> 23:42:40,800
blue sky streak you can say two three

35795
23:42:40,800 --> 23:42:43,360
three for example and say the number of

35796
23:42:43,360 --> 23:42:46,160
the house to b56 why not this is a

35797
23:42:46,160 --> 23:42:48,960
possible address for a person so we can

35798
23:42:48,960 --> 23:42:52,320
say person one or we can use htdc out to

35799
23:42:52,320 --> 23:42:54,552
print this out because we have an output

35800
23:42:54,552 --> 23:42:57,760
stream operator for our person class we

35801
23:42:57,760 --> 23:42:59,360
can do this we're going to say person

35802
23:42:59,360 --> 23:43:02,160
one and we're going to put him out and

35803
23:43:02,160 --> 23:43:04,000
if we build and run this program we're

35804
23:43:04,000 --> 23:43:06,832
going to see that this is going to work

35805
23:43:06,832 --> 23:43:09,360
hopefully and we have a problem because

35806
23:43:09,360 --> 23:43:11,760
we don't have a semicolon at the end of

35807
23:43:11,760 --> 23:43:14,320
line 6 here let's fix that we're going

35808
23:43:14,320 --> 23:43:17,120
to run this task to build with gcc the

35809
23:43:17,120 --> 23:43:19,040
builder is going to be good we can bring

35810
23:43:19,040 --> 23:43:21,512
up a powershell window

35811
23:43:21,512 --> 23:43:23,120
and we're going to use this to run our

35812
23:43:23,120 --> 23:43:25,600
program if we say rooster we're going to

35813
23:43:25,600 --> 23:43:27,832
see that we have the person printed down

35814
23:43:27,832 --> 23:43:30,480
the full name is daniel gray the age is

35815
23:43:30,480 --> 23:43:35,120
27 the address is blue sky street 233

35816
23:43:35,120 --> 23:43:38,000
and the number of the house is 56 so

35817
23:43:38,000 --> 23:43:40,400
this is a possible implementation for

35818
23:43:40,400 --> 23:43:42,720
the person class but we are really not

35819
23:43:42,720 --> 23:43:44,872
interested in setting up a prison class

35820
23:43:44,872 --> 23:43:46,872
and doing things with that we are

35821
23:43:46,872 --> 23:43:49,680
interested in inheriting from the person

35822
23:43:49,680 --> 23:43:52,872
class and learn about different kinds of

35823
23:43:52,872 --> 23:43:55,760
base class access specifiers we can do

35824
23:43:55,760 --> 23:43:57,512
so we're going to set up a player class

35825
23:43:57,512 --> 23:44:00,480
which is going to inherit publicly from

35826
23:44:00,480 --> 23:44:02,720
the person class let's do that we're

35827
23:44:02,720 --> 23:44:04,640
going to put in our player we're going

35828
23:44:04,640 --> 23:44:06,960
to put in the header file let's say

35829
23:44:06,960 --> 23:44:09,120
player not person and we're going to say

35830
23:44:09,120 --> 23:44:12,400
player.h we're going to put in a cpp

35831
23:44:12,400 --> 23:44:14,800
file we are going to hop over in the

35832
23:44:14,800 --> 23:44:17,832
header of player and put in our class

35833
23:44:17,832 --> 23:44:20,400
let's close the left sidebar here so

35834
23:44:20,400 --> 23:44:22,000
that you can really see everything we

35835
23:44:22,000 --> 23:44:23,920
have an include guard in

35836
23:44:23,920 --> 23:44:26,480
we have the class player declared it is

35837
23:44:26,480 --> 23:44:28,800
going to do public inheritance from

35838
23:44:28,800 --> 23:44:29,760
person

35839
23:44:29,760 --> 23:44:32,720
and what this is going to do is that

35840
23:44:32,720 --> 23:44:34,640
anything that is public in person is

35841
23:44:34,640 --> 23:44:37,512
going to stay public in player anything

35842
23:44:37,512 --> 23:44:39,360
that is protected is going to stay

35843
23:44:39,360 --> 23:44:41,040
protected in player

35844
23:44:41,040 --> 23:44:43,512
and anything that is

35845
23:44:43,512 --> 23:44:46,000
private is going to stay private so we

35846
23:44:46,000 --> 23:44:48,000
want to be able to access private data

35847
23:44:48,000 --> 23:44:50,480
from a person object for example we

35848
23:44:50,480 --> 23:44:52,080
can't access

35849
23:44:52,080 --> 23:44:54,400
the address member variable here because

35850
23:44:54,400 --> 23:44:57,192
it is private but we can use the full

35851
23:44:57,192 --> 23:44:58,872
name and the age

35852
23:44:58,872 --> 23:45:00,552
from the

35853
23:45:00,552 --> 23:45:02,160
derived class

35854
23:45:02,160 --> 23:45:05,040
let's make sure we have a cpp file and

35855
23:45:05,040 --> 23:45:07,600
before we try things out

35856
23:45:07,600 --> 23:45:09,832
so let's hop over to the cpp file and

35857
23:45:09,832 --> 23:45:12,800
put in a possible implementation we are

35858
23:45:12,800 --> 23:45:15,192
going to include the person and player

35859
23:45:15,192 --> 23:45:17,680
because we're going to be using these

35860
23:45:17,680 --> 23:45:20,080
and we are going to set up a constructor

35861
23:45:20,080 --> 23:45:22,720
which is not going to do anything for a

35862
23:45:22,720 --> 23:45:25,600
player we also have our output stream

35863
23:45:25,600 --> 23:45:27,120
operator which is going to print the

35864
23:45:27,120 --> 23:45:29,920
data it is going to be using the getters

35865
23:45:29,920 --> 23:45:32,400
we have in the base class and we have

35866
23:45:32,400 --> 23:45:33,832
access to them

35867
23:45:33,832 --> 23:45:36,480
because we are doing public inheritance

35868
23:45:36,480 --> 23:45:38,480
so they are going to be public and we

35869
23:45:38,480 --> 23:45:40,800
can call them from the outside like we

35870
23:45:40,800 --> 23:45:43,280
are doing here notice that this is an

35871
23:45:43,280 --> 23:45:46,232
outside player object and we are calling

35872
23:45:46,232 --> 23:45:48,552
our public members on it and this is

35873
23:45:48,552 --> 23:45:50,400
going to work we also have a destructor

35874
23:45:50,400 --> 23:45:52,000
and which is really not going to do

35875
23:45:52,000 --> 23:45:54,552
anything but we're going to keep it in

35876
23:45:54,552 --> 23:45:57,120
here because it's not going to hurt so

35877
23:45:57,120 --> 23:45:59,760
now what we want to try out

35878
23:45:59,760 --> 23:46:02,480
is to see if we can access thanks from

35879
23:46:02,480 --> 23:46:04,872
the base class the first thing we have

35880
23:46:04,872 --> 23:46:07,192
in the base class is the

35881
23:46:07,192 --> 23:46:09,680
full name and i think we can actually

35882
23:46:09,680 --> 23:46:12,872
copy these blanks or we cannot just use

35883
23:46:12,872 --> 23:46:15,832
them m full name mh and m address we're

35884
23:46:15,832 --> 23:46:18,320
going to try and use them in the derived

35885
23:46:18,320 --> 23:46:21,512
class so let's try and say m full name

35886
23:46:21,512 --> 23:46:24,000
and change the full name for example to

35887
23:46:24,000 --> 23:46:24,720
be

35888
23:46:24,720 --> 23:46:27,760
daniel gray or jon snow and we're going

35889
23:46:27,760 --> 23:46:28,720
to

35890
23:46:28,720 --> 23:46:30,640
change the age to be

35891
23:46:30,640 --> 23:46:33,360
55 why not and we're going to try and

35892
23:46:33,360 --> 23:46:36,160
access the address let's see what we

35893
23:46:36,160 --> 23:46:38,552
called our address member variable it is

35894
23:46:38,552 --> 23:46:40,960
m address we can grab that and use that

35895
23:46:40,960 --> 23:46:43,600
in our class if we try to access that

35896
23:46:43,600 --> 23:46:45,760
we're going to get a compiler error

35897
23:46:45,760 --> 23:46:47,440
because that's going to be

35898
23:46:47,440 --> 23:46:50,080
private to the base class you notice

35899
23:46:50,080 --> 23:46:52,400
that if we even try to put some junk

35900
23:46:52,400 --> 23:46:54,400
data we're going to have a squiggly line

35901
23:46:54,400 --> 23:46:57,512
because this is not accessible here and

35902
23:46:57,512 --> 23:46:59,360
visual studio code is going to say that

35903
23:46:59,360 --> 23:47:01,760
this is not accessible

35904
23:47:01,760 --> 23:47:04,320
because it is private to the base class

35905
23:47:04,320 --> 23:47:06,960
so we can access m full name because it

35906
23:47:06,960 --> 23:47:10,160
was inherited as public so this is going

35907
23:47:10,160 --> 23:47:13,680
to be okay we can use age because it was

35908
23:47:13,680 --> 23:47:17,120
inherited as protected we can use it in

35909
23:47:17,120 --> 23:47:19,680
a derived class but we can't use the

35910
23:47:19,680 --> 23:47:22,320
address because it was inherited as

35911
23:47:22,320 --> 23:47:24,872
private and it is private to the base

35912
23:47:24,872 --> 23:47:27,120
class so this is not going to work even

35913
23:47:27,120 --> 23:47:28,800
if we try to call biola code we're going

35914
23:47:28,800 --> 23:47:30,640
to get a compiler error let's try to do

35915
23:47:30,640 --> 23:47:32,480
that so that you can really see for

35916
23:47:32,480 --> 23:47:35,192
yourself okay so we have a compiler

35917
23:47:35,192 --> 23:47:39,192
error and this was declared in the base

35918
23:47:39,192 --> 23:47:41,120
class as private this is what the

35919
23:47:41,120 --> 23:47:43,600
compiler error is saying so we shouldn't

35920
23:47:43,600 --> 23:47:46,800
really be doing this the derived class

35921
23:47:46,800 --> 23:47:48,480
has no business

35922
23:47:48,480 --> 23:47:51,920
modifying a private member of the base

35923
23:47:51,920 --> 23:47:53,832
class this is the message here so we're

35924
23:47:53,832 --> 23:47:55,440
going to comment this out and say that

35925
23:47:55,440 --> 23:47:56,960
this is going to give you a compiler

35926
23:47:56,960 --> 23:47:59,760
error but we are also going to create a

35927
23:47:59,760 --> 23:48:02,552
player object and try to access these

35928
23:48:02,552 --> 23:48:05,280
guys and see how accesses from the

35929
23:48:05,280 --> 23:48:07,280
outside so we're going to go in the main

35930
23:48:07,280 --> 23:48:09,440
cpp file and we're going to include

35931
23:48:09,440 --> 23:48:12,080
player dot h and we're going to create a

35932
23:48:12,080 --> 23:48:14,720
player object we can put in a separator

35933
23:48:14,720 --> 23:48:17,600
and say a bunch of dashes here this is

35934
23:48:17,600 --> 23:48:19,360
going to do i think this is going to

35935
23:48:19,360 --> 23:48:21,600
work and we're going to create a player

35936
23:48:21,600 --> 23:48:24,480
object we can say player and player and

35937
23:48:24,480 --> 23:48:27,040
not put any parenthesis here this is

35938
23:48:27,040 --> 23:48:29,040
going to call the default constructor

35939
23:48:29,040 --> 23:48:33,040
that we have in our player class and we

35940
23:48:33,040 --> 23:48:35,120
can try to use this but before we do

35941
23:48:35,120 --> 23:48:37,192
let's try and build and see that this is

35942
23:48:37,192 --> 23:48:39,760
going to build just fine we're going to

35943
23:48:39,760 --> 23:48:42,320
work with gcc let's do that we're going

35944
23:48:42,320 --> 23:48:44,080
to see that the world is good we can try

35945
23:48:44,080 --> 23:48:47,192
and access stuff from this player object

35946
23:48:47,192 --> 23:48:50,720
we can say player and say m full name

35947
23:48:50,720 --> 23:48:52,480
you see that this is accessible we can

35948
23:48:52,480 --> 23:48:54,160
actually change this

35949
23:48:54,160 --> 23:48:58,160
to samwell jackson we can do that but if

35950
23:48:58,160 --> 23:49:01,192
we try and say player mh we're going to

35951
23:49:01,192 --> 23:49:03,280
see that this is not accessible here

35952
23:49:03,280 --> 23:49:06,480
because this was inherited as protected

35953
23:49:06,480 --> 23:49:07,920
if we go back to person we're going to

35954
23:49:07,920 --> 23:49:11,280
see that the age is protected so it will

35955
23:49:11,280 --> 23:49:14,080
be accessible in derived classes just

35956
23:49:14,080 --> 23:49:18,080
like we did in our play method of the

35957
23:49:18,080 --> 23:49:20,960
player class but we can't access the age

35958
23:49:20,960 --> 23:49:24,000
from the outside of a player object

35959
23:49:24,000 --> 23:49:25,280
because that's not going to be

35960
23:49:25,280 --> 23:49:27,280
accessible from the outside this is a

35961
23:49:27,280 --> 23:49:30,872
defining feature of the protected access

35962
23:49:30,872 --> 23:49:32,800
level so this is not going to work even

35963
23:49:32,800 --> 23:49:34,320
if we try to build we're going to get a

35964
23:49:34,320 --> 23:49:38,232
compiler error along the lines of this

35965
23:49:38,232 --> 23:49:41,760
is not accessible in this context and it

35966
23:49:41,760 --> 23:49:43,600
was declared in the base class so we

35967
23:49:43,600 --> 23:49:46,000
can't really access it from the outside

35968
23:49:46,000 --> 23:49:47,920
this is the compiler error here so we're

35969
23:49:47,920 --> 23:49:50,160
going to comment this out and say that

35970
23:49:50,160 --> 23:49:51,680
this is going to give you a compiler

35971
23:49:51,680 --> 23:49:53,600
error okay so i hope you know that you

35972
23:49:53,600 --> 23:49:55,760
can't even have a chance accessing a

35973
23:49:55,760 --> 23:49:59,040
private member of a base class from a

35974
23:49:59,040 --> 23:50:02,080
derived object in the main function like

35975
23:50:02,080 --> 23:50:05,280
we do here so if we try and do player

35976
23:50:05,280 --> 23:50:08,080
and say m address this is not going to

35977
23:50:08,080 --> 23:50:09,920
work okay so if we try to change this

35978
23:50:09,920 --> 23:50:12,080
for example to some junk data this is

35979
23:50:12,080 --> 23:50:13,360
not going to work we're going to get a

35980
23:50:13,360 --> 23:50:16,872
compiler error because this was declared

35981
23:50:16,872 --> 23:50:19,280
private in the base class and it is

35982
23:50:19,280 --> 23:50:20,872
private to the base class you can't

35983
23:50:20,872 --> 23:50:23,192
really access it from the outside you

35984
23:50:23,192 --> 23:50:25,192
can't even access it from a derived

35985
23:50:25,192 --> 23:50:28,000
class so let alone access this on the

35986
23:50:28,000 --> 23:50:29,832
outside in the main function so this is

35987
23:50:29,832 --> 23:50:31,280
not going to work it is going to give

35988
23:50:31,280 --> 23:50:33,360
you a compiler error but we're going to

35989
23:50:33,360 --> 23:50:35,192
weld and show you the compiler error

35990
23:50:35,192 --> 23:50:37,920
because we are learning here so we're

35991
23:50:37,920 --> 23:50:40,480
going to get a compiler error that says

35992
23:50:40,480 --> 23:50:43,680
m address is private within the context

35993
23:50:43,680 --> 23:50:45,760
where we are trying to use it so we

35994
23:50:45,760 --> 23:50:47,832
can't really use it from the outside

35995
23:50:47,832 --> 23:50:50,000
here again this is going to give us a

35996
23:50:50,000 --> 23:50:52,552
compiler error let's say that here and

35997
23:50:52,552 --> 23:50:55,040
this is really what i wanted you to

35998
23:50:55,040 --> 23:50:57,600
learn about public inheritance anything

35999
23:50:57,600 --> 23:50:59,512
that is public in the base class is

36000
23:50:59,512 --> 23:51:02,320
going to be public in the derived class

36001
23:51:02,320 --> 23:51:04,160
anything that is protected is going to

36002
23:51:04,160 --> 23:51:06,872
stay protected and what that means it

36003
23:51:06,872 --> 23:51:10,000
will be usable in the derived class but

36004
23:51:10,000 --> 23:51:12,640
you can't use that from the outside and

36005
23:51:12,640 --> 23:51:14,232
anything that is private in the base

36006
23:51:14,232 --> 23:51:16,320
class is going to stay private so you

36007
23:51:16,320 --> 23:51:18,640
can't use that from the derived class

36008
23:51:18,640 --> 23:51:20,872
and you can't even use that from the

36009
23:51:20,872 --> 23:51:22,640
outside like we are doing in the main

36010
23:51:22,640 --> 23:51:25,280
function here this is not going to work

36011
23:51:25,280 --> 23:51:27,600
okay so now that we have this in place

36012
23:51:27,600 --> 23:51:29,280
we're going to set up another class that

36013
23:51:29,280 --> 23:51:30,960
is going to do

36014
23:51:30,960 --> 23:51:33,040
protected inheritance and that's going

36015
23:51:33,040 --> 23:51:35,360
to be our nurse class so we're going to

36016
23:51:35,360 --> 23:51:38,080
put this in let's put in a nurse header

36017
23:51:38,080 --> 23:51:40,800
file this is going to be nurse.h we're

36018
23:51:40,800 --> 23:51:44,080
also going to put in nurse.cpp okay so

36019
23:51:44,080 --> 23:51:45,920
we're going to head over in the header

36020
23:51:45,920 --> 23:51:48,800
file and put in the code for our nurse

36021
23:51:48,800 --> 23:51:51,040
class we're going to say cluster nurse

36022
23:51:51,040 --> 23:51:53,280
and say protected to mean that we want

36023
23:51:53,280 --> 23:51:55,832
to do protected inheritance and what

36024
23:51:55,832 --> 23:51:57,440
this is going to do anything that is

36025
23:51:57,440 --> 23:52:00,400
public in the base class is going to be

36026
23:52:00,400 --> 23:52:03,280
protected in the derived class which is

36027
23:52:03,280 --> 23:52:05,120
our nurse class anything that is

36028
23:52:05,120 --> 23:52:07,360
protected is going to stay protected

36029
23:52:07,360 --> 23:52:09,192
anything that is private is going to

36030
23:52:09,192 --> 23:52:10,800
stay private

36031
23:52:10,800 --> 23:52:12,960
to the base class this is what we mean

36032
23:52:12,960 --> 23:52:15,280
here okay now that we have this end we

36033
23:52:15,280 --> 23:52:18,160
can put in the implementation for our

36034
23:52:18,160 --> 23:52:20,640
nurse class and we're going to have a

36035
23:52:20,640 --> 23:52:22,800
constructor and we're going to have our

36036
23:52:22,800 --> 23:52:24,800
output stream operator and we're going

36037
23:52:24,800 --> 23:52:26,720
to have a destructor which is really not

36038
23:52:26,720 --> 23:52:28,720
going to do anything because we don't

36039
23:52:28,720 --> 23:52:31,920
have any dynamic memory allocation in

36040
23:52:31,920 --> 23:52:33,192
our class

36041
23:52:33,192 --> 23:52:35,760
we are going to try and build this code

36042
23:52:35,760 --> 23:52:38,552
to see that it is going to work we have

36043
23:52:38,552 --> 23:52:41,192
a squiggly line in the main cpp file but

36044
23:52:41,192 --> 23:52:44,160
it was because of the line 15 here and

36045
23:52:44,160 --> 23:52:46,640
it has been commented down let's see if

36046
23:52:46,640 --> 23:52:49,192
we can build this program okay you see

36047
23:52:49,192 --> 23:52:51,120
that the world is going to be good and

36048
23:52:51,120 --> 23:52:52,720
we are able

36049
23:52:52,720 --> 23:52:54,320
to call

36050
23:52:54,320 --> 23:52:56,960
thanks from our output stream operator

36051
23:52:56,960 --> 23:52:59,760
you see we have an earth operand we are

36052
23:52:59,760 --> 23:53:03,280
able to call this gateful name and get

36053
23:53:03,280 --> 23:53:05,280
age member function

36054
23:53:05,280 --> 23:53:07,680
because they are now protected in the

36055
23:53:07,680 --> 23:53:09,920
nurse class but we are able to call them

36056
23:53:09,920 --> 23:53:11,512
from the outside

36057
23:53:11,512 --> 23:53:15,512
because this operator is a friend of our

36058
23:53:15,512 --> 23:53:18,080
nurse class here i want you to say this

36059
23:53:18,080 --> 23:53:20,160
some of you are going to ask

36060
23:53:20,160 --> 23:53:23,192
aren't we using an object and calling a

36061
23:53:23,192 --> 23:53:25,760
method using the dot operator this

36062
23:53:25,760 --> 23:53:28,400
qualifies as calling thanks from the

36063
23:53:28,400 --> 23:53:31,600
outside and yes that's true but this

36064
23:53:31,600 --> 23:53:34,640
method is really like a member function

36065
23:53:34,640 --> 23:53:38,000
in that it has access to private and

36066
23:53:38,000 --> 23:53:40,640
protected data from our nurse class and

36067
23:53:40,640 --> 23:53:43,192
the reason is it is a friend of the

36068
23:53:43,192 --> 23:53:45,360
nurse class here that's why we are able

36069
23:53:45,360 --> 23:53:46,480
to do

36070
23:53:46,480 --> 23:53:48,640
something like this but what i really

36071
23:53:48,640 --> 23:53:51,120
want you to see now that that doubt is

36072
23:53:51,120 --> 23:53:54,320
cleared is the kind of access we have to

36073
23:53:54,320 --> 23:53:56,720
thanks from the base class we will still

36074
23:53:56,720 --> 23:53:59,440
be able to use m full name here because

36075
23:53:59,440 --> 23:54:02,480
it was inherited as protected so we can

36076
23:54:02,480 --> 23:54:05,680
use it from a derived class we can say m

36077
23:54:05,680 --> 23:54:08,640
full name jon snow this is going to work

36078
23:54:08,640 --> 23:54:10,320
because this was

36079
23:54:10,320 --> 23:54:12,960
inherited as protected now it is

36080
23:54:12,960 --> 23:54:15,360
protected in the eyes of the nurse class

36081
23:54:15,360 --> 23:54:17,512
this is what we mean here so this is

36082
23:54:17,512 --> 23:54:19,680
okay this is going to work we can get

36083
23:54:19,680 --> 23:54:23,680
the age we can use that and we can say

36084
23:54:23,680 --> 23:54:25,832
john's and we can say

36085
23:54:25,832 --> 23:54:27,920
23 for example this is going to work

36086
23:54:27,920 --> 23:54:30,400
because this is protected but we can't

36087
23:54:30,400 --> 23:54:33,120
use the address if we do that we want to

36088
23:54:33,120 --> 23:54:34,720
be able to change it we will get a

36089
23:54:34,720 --> 23:54:37,360
compiler error because

36090
23:54:37,360 --> 23:54:39,440
this is private to the base class this

36091
23:54:39,440 --> 23:54:41,192
is the same thing we saw in the last

36092
23:54:41,192 --> 23:54:42,960
lecture this is going to give us a

36093
23:54:42,960 --> 23:54:45,040
compiler error if we try to build this

36094
23:54:45,040 --> 23:54:48,232
program let's try and build it to really

36095
23:54:48,232 --> 23:54:50,320
prove this the body is going to be good

36096
23:54:50,320 --> 23:54:53,440
without line 17 here but if we

36097
23:54:53,440 --> 23:54:55,512
uncommented and trying to build the

36098
23:54:55,512 --> 23:54:58,000
program let's do that we are going to

36099
23:54:58,000 --> 23:55:00,080
get a compiler error and the compiler

36100
23:55:00,080 --> 23:55:03,192
error is going to say let's go up and

36101
23:55:03,192 --> 23:55:05,600
see if we can get this message it's

36102
23:55:05,600 --> 23:55:06,800
going to say

36103
23:55:06,800 --> 23:55:10,000
m address is private within this context

36104
23:55:10,000 --> 23:55:12,400
where we are trying to use it and that's

36105
23:55:12,400 --> 23:55:15,120
line 17 of the nurse class if we go

36106
23:55:15,120 --> 23:55:16,960
there we're going to find the offending

36107
23:55:16,960 --> 23:55:18,800
line here so we're going to comment this

36108
23:55:18,800 --> 23:55:20,552
out and say that this is going to give

36109
23:55:20,552 --> 23:55:22,320
us a compiler error okay so you

36110
23:55:22,320 --> 23:55:24,640
shouldn't do this now that we know

36111
23:55:24,640 --> 23:55:26,960
things from the inside let's see how

36112
23:55:26,960 --> 23:55:28,232
things fair

36113
23:55:28,232 --> 23:55:31,192
on the outside we are going to hop over

36114
23:55:31,192 --> 23:55:34,400
to the main cpp file and include our

36115
23:55:34,400 --> 23:55:36,960
nurse class and we're going to create a

36116
23:55:36,960 --> 23:55:39,400
nurse object we can go down and say

36117
23:55:39,400 --> 23:55:42,160
stdcl and we're going to put in our

36118
23:55:42,160 --> 23:55:44,400
dashes and we're going to create a nurse

36119
23:55:44,400 --> 23:55:46,160
object i think we have a default

36120
23:55:46,160 --> 23:55:48,720
constructor for a nurse we're going to

36121
23:55:48,720 --> 23:55:51,600
say nurse 1 and we're going to basically

36122
23:55:51,600 --> 23:55:53,920
try and do the same things we did for

36123
23:55:53,920 --> 23:55:56,800
the player object from the outside if we

36124
23:55:56,800 --> 23:55:59,120
try to access the full name now it's not

36125
23:55:59,120 --> 23:56:01,360
going to be accessible because it was

36126
23:56:01,360 --> 23:56:02,640
inherited

36127
23:56:02,640 --> 23:56:06,080
with protected access level so if we do

36128
23:56:06,080 --> 23:56:08,720
nurse and say m full name you're going

36129
23:56:08,720 --> 23:56:11,120
to see that autocomplete is not here

36130
23:56:11,120 --> 23:56:13,192
this is a good sign that this is not

36131
23:56:13,192 --> 23:56:16,480
accessible from this place if we say

36132
23:56:16,480 --> 23:56:18,640
davy jones we're going to get a compiler

36133
23:56:18,640 --> 23:56:20,480
error and if we try to build we're going

36134
23:56:20,480 --> 23:56:23,440
to get a descriptive compiler error at

36135
23:56:23,440 --> 23:56:25,440
least i hope so let's build we're going

36136
23:56:25,440 --> 23:56:28,800
to see that with world with errors and

36137
23:56:28,800 --> 23:56:30,480
if we go up we're going to have our

36138
23:56:30,480 --> 23:56:33,192
error nurse was not declared in this

36139
23:56:33,192 --> 23:56:36,320
scope did you mean nurse one yes we met

36140
23:56:36,320 --> 23:56:38,640
nurse one sorry for that we're going to

36141
23:56:38,640 --> 23:56:41,680
build again thank you gcc for pointing

36142
23:56:41,680 --> 23:56:43,512
this out we are going to get another

36143
23:56:43,512 --> 23:56:46,480
kind of error and if we look at our

36144
23:56:46,480 --> 23:56:48,160
error here we're going to see that m

36145
23:56:48,160 --> 23:56:50,640
full name is inaccessible within this

36146
23:56:50,640 --> 23:56:54,000
context because it is a protected member

36147
23:56:54,000 --> 23:56:57,512
of the nurse class now it was inherited

36148
23:56:57,512 --> 23:57:00,400
as protected and we can't access it from

36149
23:57:00,400 --> 23:57:02,872
the outside we can access that from the

36150
23:57:02,872 --> 23:57:05,440
inside because it is protected but if we

36151
23:57:05,440 --> 23:57:07,360
try to access it from the outside we're

36152
23:57:07,360 --> 23:57:09,360
going to get a compiler error and this

36153
23:57:09,360 --> 23:57:11,280
is a defining feature

36154
23:57:11,280 --> 23:57:14,552
of protected inheritance even things

36155
23:57:14,552 --> 23:57:16,872
that were public in the base class are

36156
23:57:16,872 --> 23:57:19,440
going to become protected in the derived

36157
23:57:19,440 --> 23:57:21,600
class so this is the message here and

36158
23:57:21,600 --> 23:57:23,040
this is going to give us a compiler

36159
23:57:23,040 --> 23:57:25,680
error okay so if we also try to access

36160
23:57:25,680 --> 23:57:28,320
nurse 1 and say m

36161
23:57:28,320 --> 23:57:30,480
h this is also going to give us a

36162
23:57:30,480 --> 23:57:32,552
compiler arrow let's try to put in an

36163
23:57:32,552 --> 23:57:35,120
edge here let's put in 51. you're going

36164
23:57:35,120 --> 23:57:36,640
to see that we're going to get the same

36165
23:57:36,640 --> 23:57:38,080
kind of error

36166
23:57:38,080 --> 23:57:40,320
let's really try these things out and

36167
23:57:40,320 --> 23:57:43,360
learn about every possible way we can

36168
23:57:43,360 --> 23:57:45,040
set up these things

36169
23:57:45,040 --> 23:57:47,120
if we look at the error we're going to

36170
23:57:47,120 --> 23:57:49,600
see that image is protected within this

36171
23:57:49,600 --> 23:57:52,640
context so we can't really access it so

36172
23:57:52,640 --> 23:57:54,960
this is the compiler error we get and i

36173
23:57:54,960 --> 23:57:57,360
hope you know that if you try and access

36174
23:57:57,360 --> 23:57:59,040
the address you're also going to get a

36175
23:57:59,040 --> 23:58:01,440
compiler error because that's private to

36176
23:58:01,440 --> 23:58:04,232
the base class so we can't even use that

36177
23:58:04,232 --> 23:58:07,120
from a derived class like nurse here

36178
23:58:07,120 --> 23:58:08,872
that's not going to work let's say that

36179
23:58:08,872 --> 23:58:10,872
here we have a compiler error and we're

36180
23:58:10,872 --> 23:58:13,040
going to set up another class which is

36181
23:58:13,040 --> 23:58:16,000
going to inherit privately and see how

36182
23:58:16,000 --> 23:58:18,080
that works out the class is going to be

36183
23:58:18,080 --> 23:58:19,920
engineer we're going to see that the

36184
23:58:19,920 --> 23:58:22,720
error here goes away so let's create our

36185
23:58:22,720 --> 23:58:24,800
engineer class we're going to put in a

36186
23:58:24,800 --> 23:58:27,640
header file that's going to be our

36187
23:58:27,640 --> 23:58:31,760
engineer.h we are also going to put in

36188
23:58:31,760 --> 23:58:34,480
cpp okay so we're going to hop over to

36189
23:58:34,480 --> 23:58:37,120
our header file and put in our engineer

36190
23:58:37,120 --> 23:58:39,512
class we're going to say engineer and

36191
23:58:39,512 --> 23:58:42,232
say that we want to inherit privately

36192
23:58:42,232 --> 23:58:44,400
from the person class this is the syntax

36193
23:58:44,400 --> 23:58:46,480
here and this is going to do private

36194
23:58:46,480 --> 23:58:49,512
inheritance and what this means is that

36195
23:58:49,512 --> 23:58:51,120
anything that is public is going to

36196
23:58:51,120 --> 23:58:54,080
become private to this class anything

36197
23:58:54,080 --> 23:58:56,160
that is protected in the base class is

36198
23:58:56,160 --> 23:58:58,400
going to become private to this class

36199
23:58:58,400 --> 23:59:00,480
and anything that was private in the

36200
23:59:00,480 --> 23:59:03,280
base class is going to stay private we

36201
23:59:03,280 --> 23:59:06,552
won't have access to that whatsoever in

36202
23:59:06,552 --> 23:59:09,512
the derived class directly we are going

36203
23:59:09,512 --> 23:59:12,080
to hop over to the cpp file and put in

36204
23:59:12,080 --> 23:59:15,120
our implementations we're going to have

36205
23:59:15,120 --> 23:59:17,360
a default constructor for engineer which

36206
23:59:17,360 --> 23:59:19,512
is not going to be taking any parameter

36207
23:59:19,512 --> 23:59:21,512
we're going to have our output stream

36208
23:59:21,512 --> 23:59:24,000
operator which is going to still work

36209
23:59:24,000 --> 23:59:26,320
because it is a friend of the engineer

36210
23:59:26,320 --> 23:59:29,360
class so all these things that were

36211
23:59:29,360 --> 23:59:32,480
inherited to be private are going to be

36212
23:59:32,480 --> 23:59:35,600
private to the engineer class and any

36213
23:59:35,600 --> 23:59:37,832
friend of the engineer class will have

36214
23:59:37,832 --> 23:59:40,160
access to that that's why we are able to

36215
23:59:40,160 --> 23:59:42,872
call get full name get age and get

36216
23:59:42,872 --> 23:59:45,440
address here and get these things to

36217
23:59:45,440 --> 23:59:47,832
work okay now that this is out of the

36218
23:59:47,832 --> 23:59:50,872
way we can try and access our thanks

36219
23:59:50,872 --> 23:59:52,232
we're going to try and do the same

36220
23:59:52,232 --> 23:59:55,280
things we did in our nurse header we're

36221
23:59:55,280 --> 23:59:57,280
going to copy the code because we are

36222
23:59:57,280 --> 23:59:58,800
trying to access the same member

36223
23:59:58,800 --> 24:00:00,872
variables and we're going to see how

36224
24:00:00,872 --> 24:00:03,832
this fairs in our engineer class this is

36225
24:00:03,832 --> 24:00:06,480
going to save us a few seconds

36226
24:00:06,480 --> 24:00:08,552
if we try to access the full name this

36227
24:00:08,552 --> 24:00:10,720
is going to work because it is private

36228
24:00:10,720 --> 24:00:13,280
to this class if we try to access the

36229
24:00:13,280 --> 24:00:15,040
edge this is going to work because all

36230
24:00:15,040 --> 24:00:17,120
these guys are now private

36231
24:00:17,120 --> 24:00:20,160
to this class here but if we try to

36232
24:00:20,160 --> 24:00:22,720
access the address this is going to give

36233
24:00:22,720 --> 24:00:25,192
us a compiler error because address is

36234
24:00:25,192 --> 24:00:27,680
private to the base class if we go back

36235
24:00:27,680 --> 24:00:29,280
to person we're going to see that this

36236
24:00:29,280 --> 24:00:30,640
is the case

36237
24:00:30,640 --> 24:00:33,120
and if you try to inherit from this

36238
24:00:33,120 --> 24:00:35,600
class in any way you're not going to be

36239
24:00:35,600 --> 24:00:38,480
able to change this access level this

36240
24:00:38,480 --> 24:00:40,480
member variable is always going to stay

36241
24:00:40,480 --> 24:00:43,440
private to the base class and no derived

36242
24:00:43,440 --> 24:00:46,160
class will be able to modify or read

36243
24:00:46,160 --> 24:00:48,480
from this in any way so this is the

36244
24:00:48,480 --> 24:00:50,720
setup we have here if we try to build

36245
24:00:50,720 --> 24:00:52,640
we're going to get a compiler error

36246
24:00:52,640 --> 24:00:54,800
let's first take this out and show you

36247
24:00:54,800 --> 24:00:56,720
that this is going to build

36248
24:00:56,720 --> 24:00:59,832
just fine without this line here

36249
24:00:59,832 --> 24:01:02,000
and i am going to build again and show

36250
24:01:02,000 --> 24:01:04,640
you that if we bring that in we're going

36251
24:01:04,640 --> 24:01:06,552
to get a compiler error so the build is

36252
24:01:06,552 --> 24:01:08,960
good we can go back in our engineer

36253
24:01:08,960 --> 24:01:12,080
class and bring in the offending line we

36254
24:01:12,080 --> 24:01:14,640
can uncomment this and if we want we're

36255
24:01:14,640 --> 24:01:17,040
going to get a compiler error let's make

36256
24:01:17,040 --> 24:01:19,760
sure you see the compiler error here so

36257
24:01:19,760 --> 24:01:22,080
the world was finished with errors and

36258
24:01:22,080 --> 24:01:23,920
if we go up we're going to see that we

36259
24:01:23,920 --> 24:01:26,160
have an error here and the error is

36260
24:01:26,160 --> 24:01:28,960
going to say m address is private within

36261
24:01:28,960 --> 24:01:31,600
this context and the context is what we

36262
24:01:31,600 --> 24:01:34,640
have at line 17 in the

36263
24:01:34,640 --> 24:01:36,800
engineer class so we can go there and

36264
24:01:36,800 --> 24:01:38,960
find the offending line and we're going

36265
24:01:38,960 --> 24:01:40,640
to comment this out and this is going to

36266
24:01:40,640 --> 24:01:43,120
give us a compiler error now you know

36267
24:01:43,120 --> 24:01:45,760
this but this is how things are going to

36268
24:01:45,760 --> 24:01:48,480
work from the inside but we also need to

36269
24:01:48,480 --> 24:01:51,512
look at how things fare from the outside

36270
24:01:51,512 --> 24:01:54,480
let's go back in our main cpp file we

36271
24:01:54,480 --> 24:01:57,280
are going to include our engineer class

36272
24:01:57,280 --> 24:01:59,360
and we are going to create an engineer

36273
24:01:59,360 --> 24:02:02,320
object we can go down and say sddc out

36274
24:02:02,320 --> 24:02:05,040
and put in a bunch of dashes to separate

36275
24:02:05,040 --> 24:02:08,160
on thanks and we can create a

36276
24:02:08,160 --> 24:02:10,872
engineer object and that's going to be

36277
24:02:10,872 --> 24:02:14,160
engineer one and if we try to access the

36278
24:02:14,160 --> 24:02:15,832
full name that's not going to work

36279
24:02:15,832 --> 24:02:18,160
because it is now private

36280
24:02:18,160 --> 24:02:20,720
to the engineer class

36281
24:02:20,720 --> 24:02:23,760
if we say engineer one and try to say m

36282
24:02:23,760 --> 24:02:26,480
full name and try to change the name in

36283
24:02:26,480 --> 24:02:28,872
any way and say for example

36284
24:02:28,872 --> 24:02:31,832
olivier godson i am making this up i

36285
24:02:31,832 --> 24:02:34,480
don't know if this name exists but the

36286
24:02:34,480 --> 24:02:36,480
point is that this is not going to work

36287
24:02:36,480 --> 24:02:38,552
it is going to give you a compiler error

36288
24:02:38,552 --> 24:02:41,440
because m full name is now private to

36289
24:02:41,440 --> 24:02:44,720
the engineer class it was inherited to

36290
24:02:44,720 --> 24:02:47,120
be private to the engineer class and if

36291
24:02:47,120 --> 24:02:48,480
you try to do this you're going to get a

36292
24:02:48,480 --> 24:02:51,360
compiler error let's try and work with

36293
24:02:51,360 --> 24:02:53,760
gcc to really show you this and the

36294
24:02:53,760 --> 24:02:55,760
world is going to be finished with

36295
24:02:55,760 --> 24:02:57,440
errors and if we go up we're going to

36296
24:02:57,440 --> 24:02:58,960
find our error

36297
24:02:58,960 --> 24:03:01,440
full name is inaccessible from within

36298
24:03:01,440 --> 24:03:04,800
this context and the offending line is

36299
24:03:04,800 --> 24:03:09,280
at line 27 of the main cpp file if we go

36300
24:03:09,280 --> 24:03:11,440
there we're going to find our line and

36301
24:03:11,440 --> 24:03:12,872
we're going to say that this is going to

36302
24:03:12,872 --> 24:03:15,360
give us a compiler error so let's say

36303
24:03:15,360 --> 24:03:19,280
that and we can't even access the age

36304
24:03:19,280 --> 24:03:21,760
and the address member variables the age

36305
24:03:21,760 --> 24:03:24,232
is also going to be private to engineer

36306
24:03:24,232 --> 24:03:27,680
but the address is private to the base

36307
24:03:27,680 --> 24:03:28,720
class

36308
24:03:28,720 --> 24:03:30,960
so that's not going to work either so we

36309
24:03:30,960 --> 24:03:32,640
can't really access that from the

36310
24:03:32,640 --> 24:03:35,760
outside because it is now private to the

36311
24:03:35,760 --> 24:03:38,080
engineer class so let's go down and

36312
24:03:38,080 --> 24:03:40,080
really show you that we're going to go

36313
24:03:40,080 --> 24:03:43,920
down and say engineer one and say mh if

36314
24:03:43,920 --> 24:03:45,680
we try to do that that's not going to

36315
24:03:45,680 --> 24:03:47,512
work that's going to give us a compiler

36316
24:03:47,512 --> 24:03:49,280
error and if we try to build we're going

36317
24:03:49,280 --> 24:03:51,920
to get a compiler error along the same

36318
24:03:51,920 --> 24:03:54,400
lines as what we just got here

36319
24:03:54,400 --> 24:03:56,320
the book is going to finish with errors

36320
24:03:56,320 --> 24:03:58,232
and if we look at our error we're going

36321
24:03:58,232 --> 24:04:00,800
to see that mh is protected within this

36322
24:04:00,800 --> 24:04:04,720
context so we can't use it at line 28 of

36323
24:04:04,720 --> 24:04:07,360
the main cpp file this is going to give

36324
24:04:07,360 --> 24:04:09,512
us a compiler error let's do that we're

36325
24:04:09,512 --> 24:04:12,160
going to say that here and if we try and

36326
24:04:12,160 --> 24:04:15,440
access the m address member variable

36327
24:04:15,440 --> 24:04:17,600
that's not also going to work because

36328
24:04:17,600 --> 24:04:21,040
this is even more restricted for access

36329
24:04:21,040 --> 24:04:23,192
it is private to the base class so we

36330
24:04:23,192 --> 24:04:25,192
can't access it from a derived class

36331
24:04:25,192 --> 24:04:27,440
directly we can't even access that from

36332
24:04:27,440 --> 24:04:29,192
the outside so you should really know

36333
24:04:29,192 --> 24:04:31,920
this so if we put in some junk data here

36334
24:04:31,920 --> 24:04:33,920
and try to build this is going to give

36335
24:04:33,920 --> 24:04:36,872
us a compiler error that says that this

36336
24:04:36,872 --> 24:04:40,320
is not accessible from the main cpp file

36337
24:04:40,320 --> 24:04:43,280
like we are trying to do on line 29 here

36338
24:04:43,280 --> 24:04:45,360
so we're going to get an error and the

36339
24:04:45,360 --> 24:04:47,280
error is going to say m address is

36340
24:04:47,280 --> 24:04:50,000
private within this context and the

36341
24:04:50,000 --> 24:04:53,680
offending line is at 29 of the main cpp

36342
24:04:53,680 --> 24:04:55,280
file we're going to take this out and

36343
24:04:55,280 --> 24:04:56,720
we're going to say that this is going to

36344
24:04:56,720 --> 24:04:58,640
give us a compiler error this is really

36345
24:04:58,640 --> 24:05:01,120
all i wanted you to see in this lecture

36346
24:05:01,120 --> 24:05:03,360
and before we wrap this up let's try and

36347
24:05:03,360 --> 24:05:05,832
build again and make the error go away

36348
24:05:05,832 --> 24:05:08,720
because i don't like to leave you with

36349
24:05:08,720 --> 24:05:11,120
code that has compiler errors and the

36350
24:05:11,120 --> 24:05:13,760
book is good and this is really all i

36351
24:05:13,760 --> 24:05:16,232
wanted you to see in this lecture that

36352
24:05:16,232 --> 24:05:19,040
you can do all kinds of inheritances in

36353
24:05:19,040 --> 24:05:21,440
your c plus plus code you can do public

36354
24:05:21,440 --> 24:05:23,192
inheritance you can do protected

36355
24:05:23,192 --> 24:05:25,192
inheritance you can do private

36356
24:05:25,192 --> 24:05:27,360
inheritance and we had a chance to look

36357
24:05:27,360 --> 24:05:29,832
at all these scenarios in this lecture

36358
24:05:29,832 --> 24:05:32,640
here the message is the same as we saw

36359
24:05:32,640 --> 24:05:35,440
in the last lecture if you do public

36360
24:05:35,440 --> 24:05:37,832
inheritance anything that is public in

36361
24:05:37,832 --> 24:05:40,552
the base class is going to stay public

36362
24:05:40,552 --> 24:05:42,552
in the derived class anything that is

36363
24:05:42,552 --> 24:05:44,720
protected is going to stay protected

36364
24:05:44,720 --> 24:05:46,320
anything that is private is going to

36365
24:05:46,320 --> 24:05:49,040
stay private and this is really

36366
24:05:49,040 --> 24:05:52,080
misleading in a way the private data

36367
24:05:52,080 --> 24:05:54,160
from the base class is not going to be

36368
24:05:54,160 --> 24:05:56,800
private to the derived class it's going

36369
24:05:56,800 --> 24:06:00,800
to stay private to the base class so if

36370
24:06:00,800 --> 24:06:03,360
you try to use this in any way from the

36371
24:06:03,360 --> 24:06:04,640
derived class you're going to get

36372
24:06:04,640 --> 24:06:07,040
compiler errors because you can't access

36373
24:06:07,040 --> 24:06:10,160
that even if it is part of you player

36374
24:06:10,160 --> 24:06:12,720
has a person part of it but it can't

36375
24:06:12,720 --> 24:06:15,192
access private members from the base

36376
24:06:15,192 --> 24:06:17,280
class you should really know this we

36377
24:06:17,280 --> 24:06:19,512
have seen that we can also do protected

36378
24:06:19,512 --> 24:06:21,040
inheritance and that's going to

36379
24:06:21,040 --> 24:06:23,280
constrain events to have

36380
24:06:23,280 --> 24:06:25,680
the highest level of access to be

36381
24:06:25,680 --> 24:06:28,232
protected so anything that is public is

36382
24:06:28,232 --> 24:06:30,552
going to be stripped down to protected

36383
24:06:30,552 --> 24:06:33,120
access anything that is protected is

36384
24:06:33,120 --> 24:06:35,440
going to stay protected anything that is

36385
24:06:35,440 --> 24:06:38,080
private is going to be private to the

36386
24:06:38,080 --> 24:06:40,640
base class you should really make this

36387
24:06:40,640 --> 24:06:42,640
super clear we can also do private

36388
24:06:42,640 --> 24:06:45,040
inheritance as we saw and this is going

36389
24:06:45,040 --> 24:06:47,920
to strip down the highest level access

36390
24:06:47,920 --> 24:06:50,480
to be private so anything that is public

36391
24:06:50,480 --> 24:06:52,960
is going to be constrained to be private

36392
24:06:52,960 --> 24:06:54,872
anything that is protected is going to

36393
24:06:54,872 --> 24:06:57,832
be inherited as protected to the player

36394
24:06:57,832 --> 24:07:00,400
class but anything that was private in

36395
24:07:00,400 --> 24:07:03,120
the base class is going to stay private

36396
24:07:03,120 --> 24:07:05,680
to the base class even the player class

36397
24:07:05,680 --> 24:07:07,920
won't have access to this member

36398
24:07:07,920 --> 24:07:10,640
directly if we really need access to

36399
24:07:10,640 --> 24:07:12,872
private data from the base class we

36400
24:07:12,872 --> 24:07:15,040
might go through public getters or

36401
24:07:15,040 --> 24:07:17,512
anything we get from the base class but

36402
24:07:17,512 --> 24:07:20,320
we can't access m3 directly and use it

36403
24:07:20,320 --> 24:07:22,400
from the derived class that's going to

36404
24:07:22,400 --> 24:07:24,640
give us a compiler error this is really

36405
24:07:24,640 --> 24:07:26,800
all i wanted you to see in this lecture

36406
24:07:26,800 --> 24:07:29,192
and i hope you find this interesting we

36407
24:07:29,192 --> 24:07:31,280
are going to stop here in this lecture

36408
24:07:31,280 --> 24:07:32,872
in the next one we're going to try and

36409
24:07:32,872 --> 24:07:36,160
zoom in on private inheritance and show

36410
24:07:36,160 --> 24:07:38,160
you some things you really need to be

36411
24:07:38,160 --> 24:07:39,440
careful about

36412
24:07:39,440 --> 24:07:41,512
so go ahead and finish up here and meet

36413
24:07:41,512 --> 24:07:42,480
me there

36414
24:07:42,480 --> 24:07:44,400
in this lecture we're going to zoom in

36415
24:07:44,400 --> 24:07:47,120
on private inheritance and we're going

36416
24:07:47,120 --> 24:07:49,040
to see that the class that does a

36417
24:07:49,040 --> 24:07:52,400
private inheritance is really selfish

36418
24:07:52,400 --> 24:07:54,552
here is a simple structure we will be

36419
24:07:54,552 --> 24:07:56,552
using in this lecture here we will set

36420
24:07:56,552 --> 24:07:58,720
up a person class which is going to act

36421
24:07:58,720 --> 24:08:01,512
as our base class we are going to

36422
24:08:01,512 --> 24:08:04,080
inherit from this class privately and

36423
24:08:04,080 --> 24:08:06,400
create an engineer class

36424
24:08:06,400 --> 24:08:08,400
and what this is going to do it's going

36425
24:08:08,400 --> 24:08:12,000
to take everything from the class person

36426
24:08:12,000 --> 24:08:15,040
and make it private to the engineer

36427
24:08:15,040 --> 24:08:17,920
class so the m1 member variable which

36428
24:08:17,920 --> 24:08:20,232
was public in the base class is going to

36429
24:08:20,232 --> 24:08:22,960
be private to the engineer class this is

36430
24:08:22,960 --> 24:08:25,920
what we have here the m2 member variable

36431
24:08:25,920 --> 24:08:28,080
which was protected is going to become a

36432
24:08:28,080 --> 24:08:31,192
private in engineer that's what we have

36433
24:08:31,192 --> 24:08:32,080
here

36434
24:08:32,080 --> 24:08:34,400
and the m3 member variable which was

36435
24:08:34,400 --> 24:08:37,600
private to person class is going to stay

36436
24:08:37,600 --> 24:08:40,872
private to person in the eyes of

36437
24:08:40,872 --> 24:08:43,120
engineer this is the situation we have

36438
24:08:43,120 --> 24:08:45,280
here so the problem is going to really

36439
24:08:45,280 --> 24:08:48,232
show up when somebody else tries to

36440
24:08:48,232 --> 24:08:52,800
inherit from engineer because m1 and m2

36441
24:08:52,800 --> 24:08:55,832
are now private to engineer they will be

36442
24:08:55,832 --> 24:08:59,512
inherited but still inaccessible to the

36443
24:08:59,512 --> 24:09:03,120
civil engineer class here m1 and m2 will

36444
24:09:03,120 --> 24:09:07,192
be private to the engineer class but m3

36445
24:09:07,192 --> 24:09:10,320
will be private to the base class which

36446
24:09:10,320 --> 24:09:12,872
is person so hopefully you can see the

36447
24:09:12,872 --> 24:09:15,512
message that if a member variable is

36448
24:09:15,512 --> 24:09:16,552
private

36449
24:09:16,552 --> 24:09:19,120
it can't be inherited in any way it

36450
24:09:19,120 --> 24:09:21,040
doesn't matter which kind of inheritance

36451
24:09:21,040 --> 24:09:23,680
you do so starting from engineer which

36452
24:09:23,680 --> 24:09:28,400
has made m1 and m2 private to itself

36453
24:09:28,400 --> 24:09:31,040
it's no longer possible to forward these

36454
24:09:31,040 --> 24:09:34,720
guys down in the inheritance hierarchy

36455
24:09:34,720 --> 24:09:36,552
another way to look at this is to see

36456
24:09:36,552 --> 24:09:38,400
that the engineer class is really

36457
24:09:38,400 --> 24:09:41,440
selfish it is saying i am going to take

36458
24:09:41,440 --> 24:09:43,760
everything i can get from my parent

36459
24:09:43,760 --> 24:09:46,232
classes because i am

36460
24:09:46,232 --> 24:09:49,192
inheriting privately but nobody else

36461
24:09:49,192 --> 24:09:51,120
will be able to take things from me

36462
24:09:51,120 --> 24:09:52,960
because i'm going to make them private

36463
24:09:52,960 --> 24:09:55,832
to myself so even if civil engineer is

36464
24:09:55,832 --> 24:09:58,320
doing public inheritance

36465
24:09:58,320 --> 24:10:00,800
that's not going to give him any access

36466
24:10:00,800 --> 24:10:03,600
to these member variables which are now

36467
24:10:03,600 --> 24:10:06,160
private to the engineer class hopefully

36468
24:10:06,160 --> 24:10:08,960
you can really see this and private

36469
24:10:08,960 --> 24:10:12,000
inheritance is going to really constrain

36470
24:10:12,000 --> 24:10:14,960
what you can forward down to other

36471
24:10:14,960 --> 24:10:17,280
classes that are going to be inheriting

36472
24:10:17,280 --> 24:10:19,832
from you this is the message i am trying

36473
24:10:19,832 --> 24:10:22,720
to convey here okay so here is the same

36474
24:10:22,720 --> 24:10:25,192
example in code we have our person class

36475
24:10:25,192 --> 24:10:27,360
it's going to have our member variables

36476
24:10:27,360 --> 24:10:29,440
we're going to have the full name the

36477
24:10:29,440 --> 24:10:31,600
age and the address they are going to

36478
24:10:31,600 --> 24:10:35,040
have public protected and private access

36479
24:10:35,040 --> 24:10:37,600
we are going to inherit from person and

36480
24:10:37,600 --> 24:10:40,160
create our engineer class we are going

36481
24:10:40,160 --> 24:10:42,800
to privately inherit from person and

36482
24:10:42,800 --> 24:10:45,280
this is going to take everything we get

36483
24:10:45,280 --> 24:10:48,960
from person and make it private to the

36484
24:10:48,960 --> 24:10:51,512
engineer class and one exception is

36485
24:10:51,512 --> 24:10:52,800
going to be

36486
24:10:52,800 --> 24:10:55,440
what was already private to the base

36487
24:10:55,440 --> 24:10:57,600
class which is our person class here

36488
24:10:57,600 --> 24:11:00,080
this is going to still stay private to

36489
24:11:00,080 --> 24:11:03,040
the person class regardless of what kind

36490
24:11:03,040 --> 24:11:05,920
of inheritance you do from person but

36491
24:11:05,920 --> 24:11:08,000
any other thing if we have any member

36492
24:11:08,000 --> 24:11:10,640
variable which are public or protected

36493
24:11:10,640 --> 24:11:12,872
or even if we have some member functions

36494
24:11:12,872 --> 24:11:15,832
which are public or protected everything

36495
24:11:15,832 --> 24:11:18,480
is going to be private to the engineer

36496
24:11:18,480 --> 24:11:20,960
class because we have done private

36497
24:11:20,960 --> 24:11:24,400
inheritance here so if we inherit from

36498
24:11:24,400 --> 24:11:27,360
engineer and do any kind of inheritance

36499
24:11:27,360 --> 24:11:30,480
we are going to do the most relaxed kind

36500
24:11:30,480 --> 24:11:32,480
of inheritance which is going to keep

36501
24:11:32,480 --> 24:11:35,120
the kind of access we had in the base

36502
24:11:35,120 --> 24:11:37,600
class but this is not going to improve

36503
24:11:37,600 --> 24:11:40,160
anything everything is going to stay

36504
24:11:40,160 --> 24:11:43,680
private to the engineer class and the

36505
24:11:43,680 --> 24:11:45,440
civil engineer is really not going to

36506
24:11:45,440 --> 24:11:48,400
have any access to any member variable

36507
24:11:48,400 --> 24:11:50,720
or member function that is inherited

36508
24:11:50,720 --> 24:11:53,040
from the engineer class and we are going

36509
24:11:53,040 --> 24:11:54,720
to see this in a minute when we hit

36510
24:11:54,720 --> 24:11:56,960
visual studio code

36511
24:11:56,960 --> 24:11:59,680
so again if a class is doing private

36512
24:11:59,680 --> 24:12:01,920
inheritance it's really another way to

36513
24:12:01,920 --> 24:12:04,232
say this class is selfish it's going to

36514
24:12:04,232 --> 24:12:07,040
take everything it can from the parent

36515
24:12:07,040 --> 24:12:09,280
class but it's not going to forward

36516
24:12:09,280 --> 24:12:12,320
nothing to downstream inheritance

36517
24:12:12,320 --> 24:12:14,720
classes and this is the setup i really

36518
24:12:14,720 --> 24:12:17,760
want you to understand here and only do

36519
24:12:17,760 --> 24:12:20,160
private inheritance when you want this

36520
24:12:20,160 --> 24:12:22,480
kind of behavior now that you know this

36521
24:12:22,480 --> 24:12:23,832
we're going to head over to visual

36522
24:12:23,832 --> 24:12:25,680
studio code and play with us a little

36523
24:12:25,680 --> 24:12:26,552
more

36524
24:12:26,552 --> 24:12:29,280
here we are in our working folder the

36525
24:12:29,280 --> 24:12:32,320
current project is closing in on private

36526
24:12:32,320 --> 24:12:34,552
inheritance we're going to zoom in on

36527
24:12:34,552 --> 24:12:37,680
this and really understand the effects

36528
24:12:37,680 --> 24:12:40,080
of doing private inheritance we're going

36529
24:12:40,080 --> 24:12:42,000
to grab the code from the previous

36530
24:12:42,000 --> 24:12:43,760
lecture and we're going to grab the

36531
24:12:43,760 --> 24:12:45,192
engineer

36532
24:12:45,192 --> 24:12:46,400
and

36533
24:12:46,400 --> 24:12:49,040
the person class these are going to be

36534
24:12:49,040 --> 24:12:51,440
our starting point here make sure you

36535
24:12:51,440 --> 24:12:54,232
grab the dot vs code folder if you are

36536
24:12:54,232 --> 24:12:56,640
using vs code with this course that's

36537
24:12:56,640 --> 24:12:58,640
going to give you the basic settings we

36538
24:12:58,640 --> 24:13:01,600
need to do our c plus plus program i am

36539
24:13:01,600 --> 24:13:04,480
going to copy these guys down and put

36540
24:13:04,480 --> 24:13:07,832
these in our current project and again

36541
24:13:07,832 --> 24:13:10,480
make sure you have the main cpp file the

36542
24:13:10,480 --> 24:13:13,360
person class and the engineer class and

36543
24:13:13,360 --> 24:13:15,512
these are going to be our starting point

36544
24:13:15,512 --> 24:13:17,120
so we're going to open this little guy

36545
24:13:17,120 --> 24:13:19,192
in visual studio code by dragging and

36546
24:13:19,192 --> 24:13:22,232
dropping here we're going to look at our

36547
24:13:22,232 --> 24:13:25,040
main cpp program we are not going to

36548
24:13:25,040 --> 24:13:28,320
include nurse because we don't have this

36549
24:13:28,320 --> 24:13:29,760
included here

36550
24:13:29,760 --> 24:13:32,480
and we can really take out everything we

36551
24:13:32,480 --> 24:13:35,040
have in the main function we're going to

36552
24:13:35,040 --> 24:13:37,600
be adding our own thing here we also

36553
24:13:37,600 --> 24:13:40,080
don't need the player class here we're

36554
24:13:40,080 --> 24:13:42,320
just going to be using person and

36555
24:13:42,320 --> 24:13:45,040
engineer let's look at the person class

36556
24:13:45,040 --> 24:13:46,960
it is going to have the member variables

36557
24:13:46,960 --> 24:13:48,800
that we expect

36558
24:13:48,800 --> 24:13:50,720
we are going to have a public member

36559
24:13:50,720 --> 24:13:53,120
variable the full name a protected

36560
24:13:53,120 --> 24:13:55,832
member variable mh and a private member

36561
24:13:55,832 --> 24:13:58,480
variable m address here we are going to

36562
24:13:58,480 --> 24:14:01,512
create an engineer class which is going

36563
24:14:01,512 --> 24:14:04,640
to privately inherit from person

36564
24:14:04,640 --> 24:14:06,480
so it is going to make everything

36565
24:14:06,480 --> 24:14:09,192
private to itself the engineer class is

36566
24:14:09,192 --> 24:14:12,720
going to have a person part in at but

36567
24:14:12,720 --> 24:14:15,680
the member variables we get from the

36568
24:14:15,680 --> 24:14:17,832
person class are going to be stripped

36569
24:14:17,832 --> 24:14:22,000
down to private access level except for

36570
24:14:22,000 --> 24:14:24,400
the member variables which are already

36571
24:14:24,400 --> 24:14:26,640
private in the base class and that

36572
24:14:26,640 --> 24:14:29,192
happens to be the address so it doesn't

36573
24:14:29,192 --> 24:14:31,360
matter which kind of inheritance you do

36574
24:14:31,360 --> 24:14:33,600
the m address member variable is going

36575
24:14:33,600 --> 24:14:36,160
to still be not accessible to

36576
24:14:36,160 --> 24:14:38,552
inheritance classes this is going to

36577
24:14:38,552 --> 24:14:41,600
still be private to the base class which

36578
24:14:41,600 --> 24:14:44,480
is the person class here so the

36579
24:14:44,480 --> 24:14:46,640
full name is going to be stripped down

36580
24:14:46,640 --> 24:14:50,080
to private access level in engineer the

36581
24:14:50,080 --> 24:14:52,160
edge is also going to be stripped down

36582
24:14:52,160 --> 24:14:54,960
to private access and these are going to

36583
24:14:54,960 --> 24:14:58,640
be private now to the engineer class and

36584
24:14:58,640 --> 24:15:01,192
any class that tries to inherit from

36585
24:15:01,192 --> 24:15:03,832
engineer is not going to have access to

36586
24:15:03,832 --> 24:15:06,720
these guys so if we do any kind of

36587
24:15:06,720 --> 24:15:08,552
inheritance from engineer we want to

36588
24:15:08,552 --> 24:15:10,552
have access to full name we want to have

36589
24:15:10,552 --> 24:15:12,800
access to mh because these are going to

36590
24:15:12,800 --> 24:15:16,000
be private to this class here this is

36591
24:15:16,000 --> 24:15:18,160
the setup we want to understand in this

36592
24:15:18,160 --> 24:15:20,320
lecture so what we're going to do we're

36593
24:15:20,320 --> 24:15:22,000
going to set up a new class which is

36594
24:15:22,000 --> 24:15:25,120
going to inherit from our engineer class

36595
24:15:25,120 --> 24:15:28,000
and it is going to do public inheritance

36596
24:15:28,000 --> 24:15:29,760
and we're going to see how this works

36597
24:15:29,760 --> 24:15:31,680
we're going to create a civil engineer

36598
24:15:31,680 --> 24:15:33,440
class which is going to inherit from

36599
24:15:33,440 --> 24:15:35,512
engineer so let's do this we're going to

36600
24:15:35,512 --> 24:15:37,680
create a header file for our civil

36601
24:15:37,680 --> 24:15:40,000
engineer class and we're going to create

36602
24:15:40,000 --> 24:15:41,920
a cpp file

36603
24:15:41,920 --> 24:15:44,400
we are going to head over in our header

36604
24:15:44,400 --> 24:15:46,480
file and put in the class it's not going

36605
24:15:46,480 --> 24:15:49,440
to be anything sophisticated we're just

36606
24:15:49,440 --> 24:15:51,440
going to have in our include guard we're

36607
24:15:51,440 --> 24:15:53,440
going to create a civil engineer class

36608
24:15:53,440 --> 24:15:55,600
which is going to publicly inherit from

36609
24:15:55,600 --> 24:15:58,232
engineer but remember everything was

36610
24:15:58,232 --> 24:16:01,192
made private to the engineer class so

36611
24:16:01,192 --> 24:16:03,832
even if we're doing public inheritance

36612
24:16:03,832 --> 24:16:05,760
the full name member variable is going

36613
24:16:05,760 --> 24:16:08,080
to be private to engineer the age is

36614
24:16:08,080 --> 24:16:10,080
going to be private to engineer and

36615
24:16:10,080 --> 24:16:12,480
engineer won't have any access to these

36616
24:16:12,480 --> 24:16:14,872
guys but before we really play with that

36617
24:16:14,872 --> 24:16:17,360
we're going to put in our implementation

36618
24:16:17,360 --> 24:16:19,040
in the cpp file

36619
24:16:19,040 --> 24:16:21,280
so let's put in the code here we're

36620
24:16:21,280 --> 24:16:24,080
going to put in the implementation and

36621
24:16:24,080 --> 24:16:26,232
we're going to have our constructor in

36622
24:16:26,232 --> 24:16:29,192
place but notice what happens on our

36623
24:16:29,192 --> 24:16:32,480
output stream operator the output stream

36624
24:16:32,480 --> 24:16:35,512
operator is a friend of the civil

36625
24:16:35,512 --> 24:16:38,160
engineer class so it should have access

36626
24:16:38,160 --> 24:16:40,640
to anything we have in our civil

36627
24:16:40,640 --> 24:16:43,120
engineer class but notice what is

36628
24:16:43,120 --> 24:16:44,400
happening here

36629
24:16:44,400 --> 24:16:47,440
the get full name method is not working

36630
24:16:47,440 --> 24:16:49,920
because it has been made

36631
24:16:49,920 --> 24:16:53,120
private to the upstream class which

36632
24:16:53,120 --> 24:16:54,800
happens to be

36633
24:16:54,800 --> 24:16:57,192
our engineer class and we can't really

36634
24:16:57,192 --> 24:16:59,512
access them even if we know that they

36635
24:16:59,512 --> 24:17:02,720
are really part of the interface of the

36636
24:17:02,720 --> 24:17:04,960
person class we have them as public

36637
24:17:04,960 --> 24:17:08,232
members of the person class but when the

36638
24:17:08,232 --> 24:17:11,440
engineer class did private inheritance

36639
24:17:11,440 --> 24:17:14,552
it made everything that is not private

36640
24:17:14,552 --> 24:17:17,920
to person private to itself so these

36641
24:17:17,920 --> 24:17:20,320
gators are going to be private to

36642
24:17:20,320 --> 24:17:23,360
engineer when the engineer does private

36643
24:17:23,360 --> 24:17:25,760
inheritance the member variables which

36644
24:17:25,760 --> 24:17:27,760
are public and protected all these

36645
24:17:27,760 --> 24:17:30,232
things are going to be stripped down to

36646
24:17:30,232 --> 24:17:32,960
private access level so they are going

36647
24:17:32,960 --> 24:17:35,832
to be private to engineer and any kind

36648
24:17:35,832 --> 24:17:37,832
of inheritance you're going to do is not

36649
24:17:37,832 --> 24:17:39,920
going to change that they are going to

36650
24:17:39,920 --> 24:17:42,720
be inherited as private to the engineer

36651
24:17:42,720 --> 24:17:45,512
class that's why we can't even call them

36652
24:17:45,512 --> 24:17:48,720
from a function which is a friend of our

36653
24:17:48,720 --> 24:17:51,600
civil engineer class and we know that if

36654
24:17:51,600 --> 24:17:53,280
you mark something as a friend it's

36655
24:17:53,280 --> 24:17:55,680
really going to have access to anything

36656
24:17:55,680 --> 24:17:58,552
you have including private members but

36657
24:17:58,552 --> 24:18:01,600
we can't call any of the members from

36658
24:18:01,600 --> 24:18:03,680
the engineer class because everything is

36659
24:18:03,680 --> 24:18:06,000
now private to the engineer class this

36660
24:18:06,000 --> 24:18:08,000
is what i want you to see if you do

36661
24:18:08,000 --> 24:18:10,000
private inheritance this is going to

36662
24:18:10,000 --> 24:18:11,832
really strip down

36663
24:18:11,832 --> 24:18:14,480
anything from the upstream class and

36664
24:18:14,480 --> 24:18:16,960
make that private to the class that is

36665
24:18:16,960 --> 24:18:18,872
doing private inheritance this is the

36666
24:18:18,872 --> 24:18:22,000
message here and again if you go in any

36667
24:18:22,000 --> 24:18:24,320
method of the civil engineer class and

36668
24:18:24,320 --> 24:18:27,280
try to do any kind of access for example

36669
24:18:27,280 --> 24:18:29,360
calling the get full name

36670
24:18:29,360 --> 24:18:32,080
method is not going to board well we're

36671
24:18:32,080 --> 24:18:34,000
going to see that this is inaccessible

36672
24:18:34,000 --> 24:18:37,440
here if we try to access m full name

36673
24:18:37,440 --> 24:18:39,600
for example change this to be something

36674
24:18:39,600 --> 24:18:41,680
else let's say daniel

36675
24:18:41,680 --> 24:18:44,000
gray this is not going to work if you

36676
24:18:44,000 --> 24:18:46,080
try to access mh

36677
24:18:46,080 --> 24:18:48,552
and change it to 45 for example this is

36678
24:18:48,552 --> 24:18:50,640
not going to work we already know that

36679
24:18:50,640 --> 24:18:52,872
the address is private to person so we

36680
24:18:52,872 --> 24:18:54,480
shouldn't really try to access it

36681
24:18:54,480 --> 24:18:58,160
because it is inaccessible regardless of

36682
24:18:58,160 --> 24:19:00,960
any kind of inheritance you do but the

36683
24:19:00,960 --> 24:19:03,192
members that were public from person

36684
24:19:03,192 --> 24:19:06,080
can't be accessed from any class that is

36685
24:19:06,080 --> 24:19:09,440
inheriting from person even if we know

36686
24:19:09,440 --> 24:19:11,280
that these things are public or

36687
24:19:11,280 --> 24:19:13,760
protected in the person class

36688
24:19:13,760 --> 24:19:15,920
and this is really what i want you to

36689
24:19:15,920 --> 24:19:18,720
see if we try and build our program

36690
24:19:18,720 --> 24:19:20,320
we're going to get a bunch of compiler

36691
24:19:20,320 --> 24:19:22,872
errors saying that we can't access these

36692
24:19:22,872 --> 24:19:23,760
guys

36693
24:19:23,760 --> 24:19:26,960
from our civil engineer class we are

36694
24:19:26,960 --> 24:19:29,120
going to use the gcc compiler here

36695
24:19:29,120 --> 24:19:31,040
because it is our favorite and we're

36696
24:19:31,040 --> 24:19:33,280
going to see our compiler errors here

36697
24:19:33,280 --> 24:19:35,832
okay so we're going to get a bunch of

36698
24:19:35,832 --> 24:19:39,360
errors let's go up and see all of them

36699
24:19:39,360 --> 24:19:41,280
we're going to get an error saying that

36700
24:19:41,280 --> 24:19:44,832
getfullname is inaccessible within the

36701
24:19:44,832 --> 24:19:48,800
context of the c4 engineer header class

36702
24:19:48,800 --> 24:19:51,760
at line 13 we are calling this method

36703
24:19:51,760 --> 24:19:54,960
that's not going to work we have another

36704
24:19:54,960 --> 24:19:57,680
error here saying that the getfullname

36705
24:19:57,680 --> 24:20:01,040
method is not accessible from line 13 of

36706
24:20:01,040 --> 24:20:03,192
the civil engineer header

36707
24:20:03,192 --> 24:20:05,600
okay it is really the same error but if

36708
24:20:05,600 --> 24:20:07,832
we go down we see that we get a bunch of

36709
24:20:07,832 --> 24:20:10,800
other errors we have m full name which

36710
24:20:10,800 --> 24:20:13,832
is not accessible we have m edge which

36711
24:20:13,832 --> 24:20:16,232
is not accessible we can't really do

36712
24:20:16,232 --> 24:20:18,872
these kinds of things from the civil

36713
24:20:18,872 --> 24:20:20,872
engineer class because all these are

36714
24:20:20,872 --> 24:20:23,512
going to become private to the upstream

36715
24:20:23,512 --> 24:20:26,960
class that did private inheritance so

36716
24:20:26,960 --> 24:20:29,120
let's take this out and

36717
24:20:29,120 --> 24:20:32,000
show you that even if we can't access

36718
24:20:32,000 --> 24:20:34,872
these guys they are still part of our

36719
24:20:34,872 --> 24:20:36,552
civil engineer class and we're going to

36720
24:20:36,552 --> 24:20:39,280
use a debugger to do that i am going to

36721
24:20:39,280 --> 24:20:41,832
take out these things or i can comment

36722
24:20:41,832 --> 24:20:44,160
them out and say that they are going to

36723
24:20:44,160 --> 24:20:46,160
give you compiler errors i think this is

36724
24:20:46,160 --> 24:20:48,160
going to be more descriptive so let's

36725
24:20:48,160 --> 24:20:49,760
say compiler error

36726
24:20:49,760 --> 24:20:52,000
and access to the edge is also going to

36727
24:20:52,000 --> 24:20:54,400
give you a compiler error and we're

36728
24:20:54,400 --> 24:20:56,872
going to go down and show you that we're

36729
24:20:56,872 --> 24:20:59,120
also going to have the same problem in

36730
24:20:59,120 --> 24:21:01,760
our output stream operator so if you

36731
24:21:01,760 --> 24:21:04,232
really want your output stream operator

36732
24:21:04,232 --> 24:21:07,360
to work here what you can do is put some

36733
24:21:07,360 --> 24:21:09,192
public members

36734
24:21:09,192 --> 24:21:12,080
in the engineer class and make it give

36735
24:21:12,080 --> 24:21:15,120
you access to the members that were

36736
24:21:15,120 --> 24:21:18,232
eclipsed to private access in this class

36737
24:21:18,232 --> 24:21:20,400
here for example you can return the full

36738
24:21:20,400 --> 24:21:22,160
name you see that we can access that

36739
24:21:22,160 --> 24:21:24,400
here you can return the age but you

36740
24:21:24,400 --> 24:21:27,040
still don't have access to the m address

36741
24:21:27,040 --> 24:21:29,512
member variable because this is private

36742
24:21:29,512 --> 24:21:32,000
to the person class but i really don't

36743
24:21:32,000 --> 24:21:34,232
even want to do this because doing this

36744
24:21:34,232 --> 24:21:35,832
kind of design

36745
24:21:35,832 --> 24:21:39,040
is sign of bad design in the first place

36746
24:21:39,040 --> 24:21:41,600
so if you need to do those kinds of

36747
24:21:41,600 --> 24:21:44,000
getters and forward them down to

36748
24:21:44,000 --> 24:21:46,872
inheritance classes why not change the

36749
24:21:46,872 --> 24:21:49,600
design in the first place and not to do

36750
24:21:49,600 --> 24:21:52,080
private inheritance here for example if

36751
24:21:52,080 --> 24:21:54,480
you change this inheritance to protected

36752
24:21:54,480 --> 24:21:57,600
or public these members are going to be

36753
24:21:57,600 --> 24:22:00,960
directly automatically forwarded down to

36754
24:22:00,960 --> 24:22:04,080
any inheritance class so just know that

36755
24:22:04,080 --> 24:22:06,960
you can put in public getters that are

36756
24:22:06,960 --> 24:22:09,280
going to give access to the full name

36757
24:22:09,280 --> 24:22:11,680
and age but you still want to be able to

36758
24:22:11,680 --> 24:22:14,640
access the address member

36759
24:22:14,640 --> 24:22:17,120
from the inheritance class because this

36760
24:22:17,120 --> 24:22:19,832
is the design you achieve by marking

36761
24:22:19,832 --> 24:22:22,080
something as private in the base class

36762
24:22:22,080 --> 24:22:24,160
if you want the address to be forwarded

36763
24:22:24,160 --> 24:22:26,552
down you might change the access level

36764
24:22:26,552 --> 24:22:28,872
we have here and maybe make it protected

36765
24:22:28,872 --> 24:22:31,440
or public so this is the ideas i really

36766
24:22:31,440 --> 24:22:33,920
want you to grasp i am going to comment

36767
24:22:33,920 --> 24:22:36,552
out the offending code here because i

36768
24:22:36,552 --> 24:22:38,160
want you to be able to build this

36769
24:22:38,160 --> 24:22:41,040
program and see that even if we can't

36770
24:22:41,040 --> 24:22:43,832
access this get full name and get

36771
24:22:43,832 --> 24:22:46,800
address members from inheriting classes

36772
24:22:46,800 --> 24:22:49,832
they are still part of our interface we

36773
24:22:49,832 --> 24:22:52,400
just can't have access to them because

36774
24:22:52,400 --> 24:22:55,040
of the choices we have made in upstream

36775
24:22:55,040 --> 24:22:57,760
classes so what i am going to do i am

36776
24:22:57,760 --> 24:23:00,552
going to go in my main cpp file and i am

36777
24:23:00,552 --> 24:23:03,832
going to create an engineer object

36778
24:23:03,832 --> 24:23:06,720
i will also include civil engineer here

36779
24:23:06,720 --> 24:23:09,280
let's do that and i am going to create

36780
24:23:09,280 --> 24:23:12,000
an engineer object and i am going to

36781
24:23:12,000 --> 24:23:14,720
create a civil engineer object

36782
24:23:14,720 --> 24:23:18,640
and i am going to just say done here and

36783
24:23:18,640 --> 24:23:20,640
i am going to put the break point on

36784
24:23:20,640 --> 24:23:23,040
line 12. we are going to use a debugger

36785
24:23:23,040 --> 24:23:24,232
to really see

36786
24:23:24,232 --> 24:23:27,512
that engineer objects and the civil

36787
24:23:27,512 --> 24:23:29,360
engineer objects

36788
24:23:29,360 --> 24:23:32,232
still have a person part of them we just

36789
24:23:32,232 --> 24:23:34,640
can't access the interface that was

36790
24:23:34,640 --> 24:23:37,832
eclipsed by the engineer class so we are

36791
24:23:37,832 --> 24:23:41,280
going to hit the run tab here

36792
24:23:41,280 --> 24:23:43,120
and we are going to

36793
24:23:43,120 --> 24:23:45,832
start our debugging session by clicking

36794
24:23:45,832 --> 24:23:47,760
on the green button here

36795
24:23:47,760 --> 24:23:50,232
we are going to build our program and if

36796
24:23:50,232 --> 24:23:52,232
the build is good we're going to plug

36797
24:23:52,232 --> 24:23:55,120
the binary that was generated into our

36798
24:23:55,120 --> 24:23:57,512
debugger and we are going to hit our

36799
24:23:57,512 --> 24:24:00,080
break point in a minute once we hit our

36800
24:24:00,080 --> 24:24:02,552
break point we are going to look at the

36801
24:24:02,552 --> 24:24:04,400
local variables we have in the main

36802
24:24:04,400 --> 24:24:06,400
function we're going to see them on the

36803
24:24:06,400 --> 24:24:09,040
left here if we expand we're going to

36804
24:24:09,040 --> 24:24:12,232
see that we have an engineer one object

36805
24:24:12,232 --> 24:24:14,640
and we have a civil engineer one object

36806
24:24:14,640 --> 24:24:17,192
if we look at our engineer we're going

36807
24:24:17,192 --> 24:24:19,512
to see that we have a person part of

36808
24:24:19,512 --> 24:24:22,960
this which is our base class and if we

36809
24:24:22,960 --> 24:24:25,040
look at civil engineer it's also going

36810
24:24:25,040 --> 24:24:29,440
to have a base of engineer so any civil

36811
24:24:29,440 --> 24:24:32,480
engineer is also going to be an engineer

36812
24:24:32,480 --> 24:24:34,872
but the engineer part of the civil

36813
24:24:34,872 --> 24:24:38,552
engineer also has a person part of that

36814
24:24:38,552 --> 24:24:40,720
you should really see this information

36815
24:24:40,720 --> 24:24:42,552
and the main message i want to convey

36816
24:24:42,552 --> 24:24:45,192
here is that all these objects have a

36817
24:24:45,192 --> 24:24:48,160
person part of them we just can't access

36818
24:24:48,160 --> 24:24:51,600
that part in objects of our inheritance

36819
24:24:51,600 --> 24:24:54,552
classes because of the design decisions

36820
24:24:54,552 --> 24:24:57,280
we have made let's close this off now

36821
24:24:57,280 --> 24:24:59,600
that you have seen this and again

36822
24:24:59,600 --> 24:25:01,920
we are really working on this

36823
24:25:01,920 --> 24:25:04,720
inheritance hierarchy the base class is

36824
24:25:04,720 --> 24:25:05,760
person

36825
24:25:05,760 --> 24:25:07,280
and it's going to have these member

36826
24:25:07,280 --> 24:25:08,480
variables

36827
24:25:08,480 --> 24:25:10,960
but if we do private inheritance from

36828
24:25:10,960 --> 24:25:13,192
the person class anything that is not

36829
24:25:13,192 --> 24:25:16,480
public is going to be eclipsed down to

36830
24:25:16,480 --> 24:25:19,512
private level access so any other class

36831
24:25:19,512 --> 24:25:21,680
that is going to inherit from our

36832
24:25:21,680 --> 24:25:24,160
engineer class now is not going to have

36833
24:25:24,160 --> 24:25:26,552
direct access to these members because

36834
24:25:26,552 --> 24:25:29,040
they are going to become private to this

36835
24:25:29,040 --> 24:25:31,832
class here and that's the experience we

36836
24:25:31,832 --> 24:25:33,680
have if we try to

36837
24:25:33,680 --> 24:25:36,720
use any of this methods and members we

36838
24:25:36,720 --> 24:25:38,480
get from engineer

36839
24:25:38,480 --> 24:25:40,480
this is not going to work because they

36840
24:25:40,480 --> 24:25:41,760
are now

36841
24:25:41,760 --> 24:25:43,600
private to the engineer class this is

36842
24:25:43,600 --> 24:25:46,080
the message here so the get full name

36843
24:25:46,080 --> 24:25:47,440
get age

36844
24:25:47,440 --> 24:25:50,232
methods are not going to work if we try

36845
24:25:50,232 --> 24:25:52,872
to use the contract count member which

36846
24:25:52,872 --> 24:25:55,040
comes from the engineer class that's not

36847
24:25:55,040 --> 24:25:57,440
also going to work if we look in our

36848
24:25:57,440 --> 24:25:59,120
header and try to use any of these

36849
24:25:59,120 --> 24:26:00,552
members we're going to get compiler

36850
24:26:00,552 --> 24:26:02,800
errors because all these guys are now

36851
24:26:02,800 --> 24:26:05,440
private to the engineer class this is

36852
24:26:05,440 --> 24:26:07,512
really all i wanted to share in this

36853
24:26:07,512 --> 24:26:10,080
lecture let's head over to the cpp file

36854
24:26:10,080 --> 24:26:12,320
and comment this out again because i

36855
24:26:12,320 --> 24:26:14,480
don't want to leave you with these

36856
24:26:14,480 --> 24:26:16,640
compiler errors i hope you found this

36857
24:26:16,640 --> 24:26:19,280
lecture informative and fun

36858
24:26:19,280 --> 24:26:21,680
we are going to stop here in this one in

36859
24:26:21,680 --> 24:26:23,360
the next one we're going to see that we

36860
24:26:23,360 --> 24:26:26,552
can actually resurrect some members back

36861
24:26:26,552 --> 24:26:27,760
in scope

36862
24:26:27,760 --> 24:26:30,160
if they were eclipsed by the kind of

36863
24:26:30,160 --> 24:26:32,720
inheritance we did from an upstream

36864
24:26:32,720 --> 24:26:33,760
class

36865
24:26:33,760 --> 24:26:36,000
go ahead and finish up here and meet me

36866
24:26:36,000 --> 24:26:37,440
there

36867
24:26:37,440 --> 24:26:39,440
in this lecture we're going to explore

36868
24:26:39,440 --> 24:26:42,160
how we can resurrect members back in

36869
24:26:42,160 --> 24:26:44,960
scope so what do we mean here suppose we

36870
24:26:44,960 --> 24:26:47,920
have our trusty inheritance tree here we

36871
24:26:47,920 --> 24:26:50,320
have a base class person the engineer

36872
24:26:50,320 --> 24:26:52,480
class is going to do private inheritance

36873
24:26:52,480 --> 24:26:54,480
and it's going to really be selfish and

36874
24:26:54,480 --> 24:26:55,440
say

36875
24:26:55,440 --> 24:26:57,600
i am going to take everything i can from

36876
24:26:57,600 --> 24:27:00,640
the upstream person class but i am going

36877
24:27:00,640 --> 24:27:04,320
to make everything my own and nobody

36878
24:27:04,320 --> 24:27:06,960
inherited from me will have access to

36879
24:27:06,960 --> 24:27:10,232
these guys for example m1 and m2 are

36880
24:27:10,232 --> 24:27:12,552
going to be private to the engineer

36881
24:27:12,552 --> 24:27:13,512
class

36882
24:27:13,512 --> 24:27:16,320
starting here when the engineer class

36883
24:27:16,320 --> 24:27:19,040
does private inheritance so any other

36884
24:27:19,040 --> 24:27:21,440
class for example civil engineer which

36885
24:27:21,440 --> 24:27:23,360
is inheriting from

36886
24:27:23,360 --> 24:27:26,320
the engineer class in any way won't have

36887
24:27:26,320 --> 24:27:27,440
access

36888
24:27:27,440 --> 24:27:31,280
to the m1 and m2 member variables so

36889
24:27:31,280 --> 24:27:34,000
suppose for some reason that we have

36890
24:27:34,000 --> 24:27:36,872
this kind of setup here but again we

36891
24:27:36,872 --> 24:27:40,000
want some members to be accessible to

36892
24:27:40,000 --> 24:27:42,552
other downstream classes

36893
24:27:42,552 --> 24:27:45,120
suppose for example we want the m1

36894
24:27:45,120 --> 24:27:47,280
member variable to still be accessible

36895
24:27:47,280 --> 24:27:50,160
to downstream classes while we have done

36896
24:27:50,160 --> 24:27:52,640
private inheritance c plus plus is

36897
24:27:52,640 --> 24:27:55,040
really weird in a way it is going to

36898
24:27:55,040 --> 24:27:57,600
work hard to really prevent you to do

36899
24:27:57,600 --> 24:28:00,000
thanks and that gives you a back door

36900
24:28:00,000 --> 24:28:01,832
you can go through to

36901
24:28:01,832 --> 24:28:04,160
allow the same thing you were trying to

36902
24:28:04,160 --> 24:28:06,400
avoid in the same place it is the same

36903
24:28:06,400 --> 24:28:08,872
kind of logic we have here it allows you

36904
24:28:08,872 --> 24:28:11,832
to use private inheritance to prevent

36905
24:28:11,832 --> 24:28:15,120
downstream classes to access to anything

36906
24:28:15,120 --> 24:28:18,080
you get from upstream classes but then

36907
24:28:18,080 --> 24:28:20,160
again it allows you to change that and

36908
24:28:20,160 --> 24:28:23,280
relax the access to downstream classes

36909
24:28:23,280 --> 24:28:25,280
for example we can change the access of

36910
24:28:25,280 --> 24:28:29,280
m1 and m2 make it more relaxed make it

36911
24:28:29,280 --> 24:28:32,800
public or protected if we wanted that so

36912
24:28:32,800 --> 24:28:35,120
let's take a look at some code because i

36913
24:28:35,120 --> 24:28:36,872
know that these things can really be

36914
24:28:36,872 --> 24:28:39,360
confusing okay we are going to start

36915
24:28:39,360 --> 24:28:41,040
from a person class which is going to

36916
24:28:41,040 --> 24:28:43,512
have a bunch of member variables we will

36917
24:28:43,512 --> 24:28:45,192
also have a bunch of getters that are

36918
24:28:45,192 --> 24:28:46,720
going to return all these member

36919
24:28:46,720 --> 24:28:49,280
variables and we are going to do private

36920
24:28:49,280 --> 24:28:52,872
inheritance from person in an engineer

36921
24:28:52,872 --> 24:28:56,080
class this is going to strip down access

36922
24:28:56,080 --> 24:28:58,800
to the members we get from person

36923
24:28:58,800 --> 24:28:59,680
to

36924
24:28:59,680 --> 24:29:02,400
private level access for example they

36925
24:29:02,400 --> 24:29:04,552
get full name member function the gate

36926
24:29:04,552 --> 24:29:06,800
age the gate address member functions

36927
24:29:06,800 --> 24:29:09,832
are going to be private to the

36928
24:29:09,832 --> 24:29:12,800
engineer class now but for some reason

36929
24:29:12,800 --> 24:29:15,192
you might want to resurrect them

36930
24:29:15,192 --> 24:29:18,720
to a more relaxed access level and you

36931
24:29:18,720 --> 24:29:21,600
do that using the using keyword so the

36932
24:29:21,600 --> 24:29:23,360
first thing you need to do is to choose

36933
24:29:23,360 --> 24:29:24,960
the section in which you're going to be

36934
24:29:24,960 --> 24:29:27,120
putting these using statements for

36935
24:29:27,120 --> 24:29:29,192
example because we put them in a

36936
24:29:29,192 --> 24:29:31,120
protected section

36937
24:29:31,120 --> 24:29:32,640
all these guys are going to be

36938
24:29:32,640 --> 24:29:35,600
resurrected with a nexus level of

36939
24:29:35,600 --> 24:29:38,400
protected if we put them in a public

36940
24:29:38,400 --> 24:29:40,552
section they are going to be resurrected

36941
24:29:40,552 --> 24:29:43,760
with a public access level and they are

36942
24:29:43,760 --> 24:29:46,232
going to be accessible from inheriting

36943
24:29:46,232 --> 24:29:48,800
classes one thing you should know is

36944
24:29:48,800 --> 24:29:51,040
that you can't resurrect

36945
24:29:51,040 --> 24:29:54,400
something that is already private to an

36946
24:29:54,400 --> 24:29:56,960
upstream class for example we know that

36947
24:29:56,960 --> 24:29:58,872
our m address member variable was

36948
24:29:58,872 --> 24:30:01,440
private to the person class so we can't

36949
24:30:01,440 --> 24:30:04,232
really resurrect that in an inheritance

36950
24:30:04,232 --> 24:30:06,080
class if we do that we're going to get a

36951
24:30:06,080 --> 24:30:08,320
compiler error and hopefully this is

36952
24:30:08,320 --> 24:30:09,832
going to drive the point home that

36953
24:30:09,832 --> 24:30:12,080
private inheritance is really really

36954
24:30:12,080 --> 24:30:14,552
serious and that it's going to strip

36955
24:30:14,552 --> 24:30:17,512
down access to private level access in

36956
24:30:17,512 --> 24:30:20,640
an inheritance class and any downstream

36957
24:30:20,640 --> 24:30:23,040
inheritance class will never be able to

36958
24:30:23,040 --> 24:30:26,232
resurrect those member variables to a

36959
24:30:26,232 --> 24:30:29,600
more relaxed access level so because

36960
24:30:29,600 --> 24:30:32,320
everything here is inherited as private

36961
24:30:32,320 --> 24:30:35,280
by default any downstream inheriting

36962
24:30:35,280 --> 24:30:37,192
class will never be able to resurrect

36963
24:30:37,192 --> 24:30:39,512
these guys for example to public or

36964
24:30:39,512 --> 24:30:42,000
protected scope this is the message here

36965
24:30:42,000 --> 24:30:44,160
and you can use this kind of design if

36966
24:30:44,160 --> 24:30:46,320
you want that but personally i don't

36967
24:30:46,320 --> 24:30:48,000
like to do this because it's going to

36968
24:30:48,000 --> 24:30:50,160
make your code much more

36969
24:30:50,160 --> 24:30:52,960
hard to read and understand if you want

36970
24:30:52,960 --> 24:30:55,512
these guys to be public or protected why

36971
24:30:55,512 --> 24:30:58,160
not make them public or protected in the

36972
24:30:58,160 --> 24:31:00,232
first place and really not use private

36973
24:31:00,232 --> 24:31:03,040
inheritance that's going to be much more

36974
24:31:03,040 --> 24:31:05,360
direct to see and understand and your

36975
24:31:05,360 --> 24:31:07,832
code is going to be easier to work with

36976
24:31:07,832 --> 24:31:10,232
for you in the future or for some other

36977
24:31:10,232 --> 24:31:12,960
developers that will get to work on your

36978
24:31:12,960 --> 24:31:14,720
code in the future so this is the

36979
24:31:14,720 --> 24:31:16,800
message here you can use this feature to

36980
24:31:16,800 --> 24:31:18,800
resurrect members back

36981
24:31:18,800 --> 24:31:22,480
to a relaxed access level and now that

36982
24:31:22,480 --> 24:31:24,872
you have an idea about this we're going

36983
24:31:24,872 --> 24:31:27,040
to head over to visual studio code and

36984
24:31:27,040 --> 24:31:28,720
play with us a little more

36985
24:31:28,720 --> 24:31:31,192
here we are in our working folder the

36986
24:31:31,192 --> 24:31:33,832
current project is resurrecting members

36987
24:31:33,832 --> 24:31:36,160
back in context we are going to

36988
24:31:36,160 --> 24:31:38,400
completely reuse the code from the last

36989
24:31:38,400 --> 24:31:40,320
lecture because it's going to give us a

36990
24:31:40,320 --> 24:31:42,080
good starting point we can copy

36991
24:31:42,080 --> 24:31:44,800
everything except for the binary here we

36992
24:31:44,800 --> 24:31:47,832
don't need that in our current project

36993
24:31:47,832 --> 24:31:50,232
we're going to put in our starter code

36994
24:31:50,232 --> 24:31:51,920
and we're going to open this little guy

36995
24:31:51,920 --> 24:31:54,160
in visual studio code so we're going to

36996
24:31:54,160 --> 24:31:56,400
have our code we're going to have our

36997
24:31:56,400 --> 24:31:58,400
main function and we're going to have

36998
24:31:58,400 --> 24:32:00,552
all these objects created here i'm

36999
24:32:00,552 --> 24:32:02,232
really not sure if we're going to need

37000
24:32:02,232 --> 24:32:04,720
this yet so let's take this out and

37001
24:32:04,720 --> 24:32:06,400
we're going to look at our personal

37002
24:32:06,400 --> 24:32:08,640
class it is going to have our members

37003
24:32:08,640 --> 24:32:11,120
here and we are going to have a bunch of

37004
24:32:11,120 --> 24:32:13,192
getters which are going to be returning

37005
24:32:13,192 --> 24:32:15,120
these member variables and we have a

37006
24:32:15,120 --> 24:32:16,872
constructor here which is really going

37007
24:32:16,872 --> 24:32:19,360
to build a person object nothing

37008
24:32:19,360 --> 24:32:21,832
complicated here we have an engineer

37009
24:32:21,832 --> 24:32:23,680
class which is going to privately

37010
24:32:23,680 --> 24:32:26,552
inherit from person and we know that

37011
24:32:26,552 --> 24:32:29,440
this is going to eclipse everything that

37012
24:32:29,440 --> 24:32:32,640
is not private in the person class to

37013
24:32:32,640 --> 24:32:35,360
private level access so everything is

37014
24:32:35,360 --> 24:32:37,440
going to be private to the engineer

37015
24:32:37,440 --> 24:32:40,160
class now but sometimes we don't want to

37016
24:32:40,160 --> 24:32:43,040
do that for example if we go down in our

37017
24:32:43,040 --> 24:32:45,360
civil engineer class

37018
24:32:45,360 --> 24:32:46,960
we're going to see that

37019
24:32:46,960 --> 24:32:49,680
the get full name and the getage methods

37020
24:32:49,680 --> 24:32:51,360
are going to be private to the app

37021
24:32:51,360 --> 24:32:53,680
stream engineer class and that's going

37022
24:32:53,680 --> 24:32:56,552
to break the code for our output stream

37023
24:32:56,552 --> 24:32:58,720
operator and it's not going to work

37024
24:32:58,720 --> 24:33:00,800
because we want to have access to get

37025
24:33:00,800 --> 24:33:03,440
full name and get age and that's also

37026
24:33:03,440 --> 24:33:05,832
going to kill access we had on the get

37027
24:33:05,832 --> 24:33:08,320
address method which would give us

37028
24:33:08,320 --> 24:33:11,360
access to the address member that we

37029
24:33:11,360 --> 24:33:14,080
have in our person class let's make sure

37030
24:33:14,080 --> 24:33:16,232
we are looking at person

37031
24:33:16,232 --> 24:33:18,552
i am confused here we have a lot of

37032
24:33:18,552 --> 24:33:20,400
pieces of code here

37033
24:33:20,400 --> 24:33:23,040
where is the person header

37034
24:33:23,040 --> 24:33:25,120
it is down here so we have the get

37035
24:33:25,120 --> 24:33:27,280
address method which is going to return

37036
24:33:27,280 --> 24:33:29,680
the address we want to have access to

37037
24:33:29,680 --> 24:33:32,640
that in our civil engineer class to be

37038
24:33:32,640 --> 24:33:35,280
able to print all this information if we

37039
24:33:35,280 --> 24:33:37,760
also want to print the contract count we

37040
24:33:37,760 --> 24:33:40,872
can go in our engineer class and put in

37041
24:33:40,872 --> 24:33:43,040
a method which is going to return that

37042
24:33:43,040 --> 24:33:45,192
so we can say end

37043
24:33:45,192 --> 24:33:47,920
and say get contract count and this is

37044
24:33:47,920 --> 24:33:49,760
going to be a const member function

37045
24:33:49,760 --> 24:33:51,760
because it's not going to be modifying

37046
24:33:51,760 --> 24:33:53,920
our object we're just going to return a

37047
24:33:53,920 --> 24:33:55,760
value we're going to return the contract

37048
24:33:55,760 --> 24:33:58,400
count and we can go in our civil

37049
24:33:58,400 --> 24:34:01,920
engineer implementation file and change

37050
24:34:01,920 --> 24:34:03,280
this to say

37051
24:34:03,280 --> 24:34:04,552
operand

37052
24:34:04,552 --> 24:34:06,960
get contract account we can do that okay

37053
24:34:06,960 --> 24:34:08,960
we have this method now we want this to

37054
24:34:08,960 --> 24:34:11,120
work this is going to work because we

37055
24:34:11,120 --> 24:34:13,512
are doing public inheritance from the

37056
24:34:13,512 --> 24:34:15,920
civil engineer class but we want this to

37057
24:34:15,920 --> 24:34:18,160
work we want to get full name get age

37058
24:34:18,160 --> 24:34:20,640
and get address to work here and we can

37059
24:34:20,640 --> 24:34:23,760
use the using feature to resurrect these

37060
24:34:23,760 --> 24:34:26,872
members to an access level which will

37061
24:34:26,872 --> 24:34:29,680
allow our civil engineer class to pick

37062
24:34:29,680 --> 24:34:32,320
them up so we can go in our engineer

37063
24:34:32,320 --> 24:34:35,040
class and set up for example a public or

37064
24:34:35,040 --> 24:34:36,960
protected scope we're going to use

37065
24:34:36,960 --> 24:34:39,120
protected because we want these to only

37066
24:34:39,120 --> 24:34:40,960
be accessible from

37067
24:34:40,960 --> 24:34:42,960
inherited classes for example so we're

37068
24:34:42,960 --> 24:34:44,800
going to say protected and we're going

37069
24:34:44,800 --> 24:34:46,872
to say using this is the syntax we're

37070
24:34:46,872 --> 24:34:48,552
going to say person and we're going to

37071
24:34:48,552 --> 24:34:50,640
say get full name we're going to say

37072
24:34:50,640 --> 24:34:53,832
using person get age going to choose

37073
24:34:53,832 --> 24:34:55,832
this and we are going to say using

37074
24:34:55,832 --> 24:34:59,040
person and say get address i think we

37075
24:34:59,040 --> 24:35:01,440
have that method here the moment we do

37076
24:35:01,440 --> 24:35:03,360
this we're going to go in our civil

37077
24:35:03,360 --> 24:35:04,872
engineer class you're going to see that

37078
24:35:04,872 --> 24:35:07,760
it is going to work now because what we

37079
24:35:07,760 --> 24:35:11,680
just did is resurrect these members to

37080
24:35:11,680 --> 24:35:14,552
have protected access level in the

37081
24:35:14,552 --> 24:35:17,280
engineer class so the inheritance

37082
24:35:17,280 --> 24:35:18,960
classes are going to look at this and

37083
24:35:18,960 --> 24:35:21,920
see that they have a protected access

37084
24:35:21,920 --> 24:35:24,160
level in the engineer class and they are

37085
24:35:24,160 --> 24:35:26,552
going to be forwarded down to any

37086
24:35:26,552 --> 24:35:28,320
inheritance class we could also change

37087
24:35:28,320 --> 24:35:30,000
this to public this is also going to

37088
24:35:30,000 --> 24:35:32,232
work they are going to be inherited as

37089
24:35:32,232 --> 24:35:35,120
public and hopefully you can see that

37090
24:35:35,120 --> 24:35:37,280
any member that you resurrect it's going

37091
24:35:37,280 --> 24:35:39,760
to take the excess level of the section

37092
24:35:39,760 --> 24:35:42,872
where you resurrect it if we resurrect

37093
24:35:42,872 --> 24:35:45,512
them in a public scope they are going to

37094
24:35:45,512 --> 24:35:47,920
be resurrected with a public access

37095
24:35:47,920 --> 24:35:50,232
level if we resurrect them in a

37096
24:35:50,232 --> 24:35:52,800
protected scope they are going to be

37097
24:35:52,800 --> 24:35:54,800
resurrected with

37098
24:35:54,800 --> 24:35:56,960
protected access level and this is the

37099
24:35:56,960 --> 24:36:00,080
message here now if you happen to have a

37100
24:36:00,080 --> 24:36:03,440
bunch of overloads in an upstream class

37101
24:36:03,440 --> 24:36:06,480
for example suppose we have a bunch of

37102
24:36:06,480 --> 24:36:07,360
add

37103
24:36:07,360 --> 24:36:10,640
functions in the person class we can go

37104
24:36:10,640 --> 24:36:13,832
in and put in let's do that we can go

37105
24:36:13,832 --> 24:36:15,192
down and say

37106
24:36:15,192 --> 24:36:18,160
double or ent let's say and that's going

37107
24:36:18,160 --> 24:36:20,800
to be much simpler we can say add and

37108
24:36:20,800 --> 24:36:22,000
say end

37109
24:36:22,000 --> 24:36:25,120
a and say ent b and say ent c we're

37110
24:36:25,120 --> 24:36:26,320
going to have

37111
24:36:26,320 --> 24:36:28,720
three things that we are adding this is

37112
24:36:28,720 --> 24:36:31,040
going to be a const member function it's

37113
24:36:31,040 --> 24:36:33,280
not going to be modifying our members in

37114
24:36:33,280 --> 24:36:36,160
any way so we're going to return

37115
24:36:36,160 --> 24:36:38,080
a plus b

37116
24:36:38,080 --> 24:36:40,480
plus c this is something we can return

37117
24:36:40,480 --> 24:36:42,960
from a member function here

37118
24:36:42,960 --> 24:36:45,600
and we're going to do an overload of the

37119
24:36:45,600 --> 24:36:47,120
add member

37120
24:36:47,120 --> 24:36:49,120
to do

37121
24:36:49,120 --> 24:36:51,832
the addition of two parameters so we're

37122
24:36:51,832 --> 24:36:54,400
going to only have a and b and i think

37123
24:36:54,400 --> 24:36:57,512
we can use a and b in the first

37124
24:36:57,512 --> 24:36:59,760
overload here that's going to be much

37125
24:36:59,760 --> 24:37:01,832
easier to follow so we have one that

37126
24:37:01,832 --> 24:37:04,232
adds two parameters

37127
24:37:04,232 --> 24:37:05,600
and we have another one which is going

37128
24:37:05,600 --> 24:37:08,232
to add three parameters if we

37129
24:37:08,232 --> 24:37:11,192
privately inherit from person these guys

37130
24:37:11,192 --> 24:37:14,160
are going to be stripped down to private

37131
24:37:14,160 --> 24:37:17,120
level access in the engineer class and

37132
24:37:17,120 --> 24:37:19,920
they want to be accessible from in any

37133
24:37:19,920 --> 24:37:22,640
other downstream class so for example if

37134
24:37:22,640 --> 24:37:25,920
we head over in our civil engineer class

37135
24:37:25,920 --> 24:37:27,760
and try to say add

37136
24:37:27,760 --> 24:37:30,400
10 to two for example we're going to get

37137
24:37:30,400 --> 24:37:32,160
a compiler error because we don't have

37138
24:37:32,160 --> 24:37:35,120
access to this but we can also resurrect

37139
24:37:35,120 --> 24:37:38,640
these ad members in our engineer class

37140
24:37:38,640 --> 24:37:40,400
so let's go there and we're going to set

37141
24:37:40,400 --> 24:37:41,760
up a public

37142
24:37:41,760 --> 24:37:44,400
section in this class here and we're

37143
24:37:44,400 --> 24:37:47,920
going to say using person add this is

37144
24:37:47,920 --> 24:37:50,400
going to resurrect all the overloads

37145
24:37:50,400 --> 24:37:53,512
that we have in our upstream class and

37146
24:37:53,512 --> 24:37:55,192
this is going to be the case because we

37147
24:37:55,192 --> 24:37:57,512
resurrect only based on the name of the

37148
24:37:57,512 --> 24:37:58,400
function

37149
24:37:58,400 --> 24:37:59,120
and

37150
24:37:59,120 --> 24:38:02,000
the same name for a member function can

37151
24:38:02,000 --> 24:38:05,440
be shared by many overloads so if we do

37152
24:38:05,440 --> 24:38:08,320
this kind of resurrecting we are doing

37153
24:38:08,320 --> 24:38:10,000
for the add

37154
24:38:10,000 --> 24:38:12,160
member function from person we are going

37155
24:38:12,160 --> 24:38:14,720
to get all the overloads if we go in

37156
24:38:14,720 --> 24:38:17,360
civil engineer we will be able to use

37157
24:38:17,360 --> 24:38:19,120
the member function taking two

37158
24:38:19,120 --> 24:38:21,680
parameters we will also be able to use

37159
24:38:21,680 --> 24:38:24,320
the one that takes three parameters they

37160
24:38:24,320 --> 24:38:26,480
are all going to be resurrected here

37161
24:38:26,480 --> 24:38:28,872
this is the message i want to convey if

37162
24:38:28,872 --> 24:38:30,320
we do this you're going to see that this

37163
24:38:30,320 --> 24:38:32,552
is going to work and our code is going

37164
24:38:32,552 --> 24:38:35,920
to just world fine let's build and see

37165
24:38:35,920 --> 24:38:37,512
if the build is good actually we're

37166
24:38:37,512 --> 24:38:40,552
going to pass this through gcc the world

37167
24:38:40,552 --> 24:38:42,400
is going to be good so everything is

37168
24:38:42,400 --> 24:38:45,040
working just fine and the message i

37169
24:38:45,040 --> 24:38:47,040
really wanted to convey is that it is

37170
24:38:47,040 --> 24:38:49,360
possible to resurrect members

37171
24:38:49,360 --> 24:38:53,120
in a more resurrected access level if

37172
24:38:53,120 --> 24:38:56,232
you are inheriting using a really

37173
24:38:56,232 --> 24:39:00,160
constrained base class access specifier

37174
24:39:00,160 --> 24:39:02,720
for example we are inheriting using a

37175
24:39:02,720 --> 24:39:03,680
private

37176
24:39:03,680 --> 24:39:05,680
access specifier this is going to

37177
24:39:05,680 --> 24:39:07,512
eclipse everything we get from the

37178
24:39:07,512 --> 24:39:10,080
upstream class to private level but if

37179
24:39:10,080 --> 24:39:12,320
you think that's too much and you have a

37180
24:39:12,320 --> 24:39:15,120
few members that you would like to put

37181
24:39:15,120 --> 24:39:18,080
in a more relaxed access level you can

37182
24:39:18,080 --> 24:39:20,640
use this resurrecting feature and it is

37183
24:39:20,640 --> 24:39:23,192
going to make things accessible in

37184
24:39:23,192 --> 24:39:25,440
downstream classes if that's what you

37185
24:39:25,440 --> 24:39:27,760
want in your program and again i hope

37186
24:39:27,760 --> 24:39:29,360
this drives the point to home that

37187
24:39:29,360 --> 24:39:31,832
ziploc plus is going to sometimes work

37188
24:39:31,832 --> 24:39:34,320
really hard to prevent you from doing

37189
24:39:34,320 --> 24:39:36,872
one thing and then again give you a back

37190
24:39:36,872 --> 24:39:39,120
door you can go through to do that same

37191
24:39:39,120 --> 24:39:41,680
thing this is the same thing here we are

37192
24:39:41,680 --> 24:39:44,160
doing private inheritance but we aren't

37193
24:39:44,160 --> 24:39:46,080
allowed to

37194
24:39:46,080 --> 24:39:47,120
kill

37195
24:39:47,120 --> 24:39:48,000
or

37196
24:39:48,000 --> 24:39:50,960
relax the effects of private inheritance

37197
24:39:50,960 --> 24:39:54,080
by bringing things in a more relaxed

37198
24:39:54,080 --> 24:39:56,640
access level and you can use this if it

37199
24:39:56,640 --> 24:39:59,040
makes sense for your code again i don't

37200
24:39:59,040 --> 24:40:00,640
like this personally because it's going

37201
24:40:00,640 --> 24:40:02,872
to make code confusing if other

37202
24:40:02,872 --> 24:40:04,720
developers see that you are doing

37203
24:40:04,720 --> 24:40:06,480
private inheritance they are going to

37204
24:40:06,480 --> 24:40:08,480
expect everything from the app stream

37205
24:40:08,480 --> 24:40:10,160
class to be private

37206
24:40:10,160 --> 24:40:11,920
to the class that is doing private

37207
24:40:11,920 --> 24:40:14,080
inheritance and if they see that they

37208
24:40:14,080 --> 24:40:16,232
can use this thanks that should be

37209
24:40:16,232 --> 24:40:18,960
private by default and downstream

37210
24:40:18,960 --> 24:40:20,800
classes this is really going to confuse

37211
24:40:20,800 --> 24:40:23,360
them and it is going to cost them more

37212
24:40:23,360 --> 24:40:25,192
minutes to look at your code to really

37213
24:40:25,192 --> 24:40:27,440
understand what is going on so if you

37214
24:40:27,440 --> 24:40:29,680
really want this dance to be accessible

37215
24:40:29,680 --> 24:40:33,120
in downstream classes why not do public

37216
24:40:33,120 --> 24:40:35,600
or protected inheritance in the first

37217
24:40:35,600 --> 24:40:38,160
place this is my argument here but it is

37218
24:40:38,160 --> 24:40:40,552
going to be your choice my job here is

37219
24:40:40,552 --> 24:40:42,960
to make you aware of the possibilities

37220
24:40:42,960 --> 24:40:45,040
that you have in the ziploc plus

37221
24:40:45,040 --> 24:40:47,440
programming language okay the last thing

37222
24:40:47,440 --> 24:40:49,440
i want you to see in this lecture is

37223
24:40:49,440 --> 24:40:51,680
that if there is something that was

37224
24:40:51,680 --> 24:40:54,080
already private in an app stream class

37225
24:40:54,080 --> 24:40:56,320
you can't resurrect that if you try to

37226
24:40:56,320 --> 24:40:58,080
do that you're going to get a compiler

37227
24:40:58,080 --> 24:41:00,000
error this is also going to drive the

37228
24:41:00,000 --> 24:41:02,320
point home that you can also resurrect

37229
24:41:02,320 --> 24:41:04,720
member variables so far what we have

37230
24:41:04,720 --> 24:41:07,280
only resurrected was all member

37231
24:41:07,280 --> 24:41:09,920
functions and we can also resurrect

37232
24:41:09,920 --> 24:41:11,832
member variables so we're going to try

37233
24:41:11,832 --> 24:41:15,280
and resurrect the m address member in

37234
24:41:15,280 --> 24:41:17,760
the engineer class and let's see how

37235
24:41:17,760 --> 24:41:20,232
this works out so let's go in our

37236
24:41:20,232 --> 24:41:22,320
engineer class we can go in our

37237
24:41:22,320 --> 24:41:25,280
protected section we can do this really

37238
24:41:25,280 --> 24:41:27,192
in any kind of section we're going to

37239
24:41:27,192 --> 24:41:29,760
say using and we're going to say person

37240
24:41:29,760 --> 24:41:32,320
and we're going to say m address you see

37241
24:41:32,320 --> 24:41:34,400
that this is not going to be

37242
24:41:34,400 --> 24:41:36,552
available in autocomplete this is going

37243
24:41:36,552 --> 24:41:38,232
to be a sign that this is going to give

37244
24:41:38,232 --> 24:41:40,160
us a compiler error and if we're trying

37245
24:41:40,160 --> 24:41:41,680
to do that we're going to see that we're

37246
24:41:41,680 --> 24:41:43,440
going to get a compiler error the

37247
24:41:43,440 --> 24:41:46,080
message here is that if something is

37248
24:41:46,080 --> 24:41:50,400
already private in a nap stream class

37249
24:41:50,400 --> 24:41:53,040
you can't resurrect it it is it claps

37250
24:41:53,040 --> 24:41:54,000
down

37251
24:41:54,000 --> 24:41:55,120
forever

37252
24:41:55,120 --> 24:41:57,040
and hopefully this drives the point home

37253
24:41:57,040 --> 24:41:59,512
again that private inheritance is really

37254
24:41:59,512 --> 24:42:02,800
serious for example in our civil

37255
24:42:02,800 --> 24:42:06,000
engineer class we can't resurrect

37256
24:42:06,000 --> 24:42:08,400
something that was already eclipsed to

37257
24:42:08,400 --> 24:42:11,040
private level access by the engineer

37258
24:42:11,040 --> 24:42:14,080
class let's go in our personal class and

37259
24:42:14,080 --> 24:42:16,552
see if we have any other member function

37260
24:42:16,552 --> 24:42:17,760
we can

37261
24:42:17,760 --> 24:42:19,760
play with we're going to put in a member

37262
24:42:19,760 --> 24:42:21,920
function that says do something we're

37263
24:42:21,920 --> 24:42:23,600
going to say void

37264
24:42:23,600 --> 24:42:25,680
do something and it's going to be

37265
24:42:25,680 --> 24:42:27,760
constant it's just going to say hello we

37266
24:42:27,760 --> 24:42:29,440
can do something like this we are

37267
24:42:29,440 --> 24:42:30,640
learning

37268
24:42:30,640 --> 24:42:32,960
and this method is going to be eclipsed

37269
24:42:32,960 --> 24:42:36,000
down to private level access because we

37270
24:42:36,000 --> 24:42:37,920
are doing private inheritance from

37271
24:42:37,920 --> 24:42:40,960
person let's go back in our engineer and

37272
24:42:40,960 --> 24:42:42,800
comment this out because it is going to

37273
24:42:42,800 --> 24:42:44,552
give you a compiler error if you build

37274
24:42:44,552 --> 24:42:45,832
you're going to get

37275
24:42:45,832 --> 24:42:48,000
a weird compiler error i think i should

37276
24:42:48,000 --> 24:42:49,760
really show you this because we are

37277
24:42:49,760 --> 24:42:51,920
learning here so we're going to try and

37278
24:42:51,920 --> 24:42:53,920
build our program anyway we're going to

37279
24:42:53,920 --> 24:42:56,000
pass this through gcc

37280
24:42:56,000 --> 24:42:57,192
and we're going to see the kind of

37281
24:42:57,192 --> 24:42:59,360
compiler error we get

37282
24:42:59,360 --> 24:43:02,232
and we are going to see that there's no

37283
24:43:02,232 --> 24:43:05,600
member std this is a problem we just

37284
24:43:05,600 --> 24:43:09,040
introduced in our class here i think to

37285
24:43:09,040 --> 24:43:12,720
solve this problem we can just put our

37286
24:43:12,720 --> 24:43:15,760
definition in the cpp file we can do

37287
24:43:15,760 --> 24:43:18,160
that we're going to grab this and we're

37288
24:43:18,160 --> 24:43:20,440
going to put the definition in

37289
24:43:20,440 --> 24:43:23,120
person.cpp because we have io stream

37290
24:43:23,120 --> 24:43:25,512
included in there this is going to make

37291
24:43:25,512 --> 24:43:28,160
our code work much better let's do this

37292
24:43:28,160 --> 24:43:30,872
we're going to say void and say person

37293
24:43:30,872 --> 24:43:33,920
and we're going to say sddc out hello

37294
24:43:33,920 --> 24:43:36,320
this is going to fix our problem here

37295
24:43:36,320 --> 24:43:38,320
and the only problem we will have will

37296
24:43:38,320 --> 24:43:40,232
be in engineer

37297
24:43:40,232 --> 24:43:42,872
where we are trying to access things

37298
24:43:42,872 --> 24:43:46,232
that are now private to the base class

37299
24:43:46,232 --> 24:43:48,960
why do we have this weekly line here

37300
24:43:48,960 --> 24:43:50,872
let's take out this

37301
24:43:50,872 --> 24:43:53,040
and try to build really make sure that

37302
24:43:53,040 --> 24:43:55,760
this problem is not existent

37303
24:43:55,760 --> 24:43:58,960
and it was a visual studio code messing

37304
24:43:58,960 --> 24:44:02,400
with us so we're going to bring this in

37305
24:44:02,400 --> 24:44:03,680
and the world and we're going to see the

37306
24:44:03,680 --> 24:44:06,640
kind of compiler error we get here

37307
24:44:06,640 --> 24:44:09,040
this is what i am trying to make you see

37308
24:44:09,040 --> 24:44:10,640
you see the bullet is finished with

37309
24:44:10,640 --> 24:44:13,512
errors if we go back we're going to see

37310
24:44:13,512 --> 24:44:16,872
that string person m address is private

37311
24:44:16,872 --> 24:44:19,120
within this context we can't really

37312
24:44:19,120 --> 24:44:20,960
resurrect it if we do this we're going

37313
24:44:20,960 --> 24:44:23,680
to get this compiler error here this is

37314
24:44:23,680 --> 24:44:26,080
the message you shouldn't really try to

37315
24:44:26,080 --> 24:44:27,440
resurrect

37316
24:44:27,440 --> 24:44:30,232
something that is already private to an

37317
24:44:30,232 --> 24:44:32,080
upstream class and that's what we are

37318
24:44:32,080 --> 24:44:34,800
doing here we are trying to resurrect a

37319
24:44:34,800 --> 24:44:37,040
member which is private to person and

37320
24:44:37,040 --> 24:44:39,192
this is not allowed in c plus plus if we

37321
24:44:39,192 --> 24:44:41,440
do that we're going to get a compiler

37322
24:44:41,440 --> 24:44:42,480
error

37323
24:44:42,480 --> 24:44:44,400
okay so but what i want you to see here

37324
24:44:44,400 --> 24:44:48,232
is that a public member which was in the

37325
24:44:48,232 --> 24:44:51,360
base class was also eclipsed down to

37326
24:44:51,360 --> 24:44:54,720
private level access in engineer so if

37327
24:44:54,720 --> 24:44:57,360
we try and resurrect

37328
24:44:57,360 --> 24:45:00,000
the do something method in our civil

37329
24:45:00,000 --> 24:45:01,440
engineer class we're going to get a

37330
24:45:01,440 --> 24:45:03,832
compiler error so let's try and do that

37331
24:45:03,832 --> 24:45:06,080
we're going to put a public section why

37332
24:45:06,080 --> 24:45:08,232
not

37333
24:45:08,232 --> 24:45:10,400
and we're going to go down and say using

37334
24:45:10,400 --> 24:45:13,400
person

37335
24:45:13,512 --> 24:45:15,760
and it say do something we have this

37336
24:45:15,760 --> 24:45:17,680
method here but if we do this we're

37337
24:45:17,680 --> 24:45:20,000
going to get a compiler error because

37338
24:45:20,000 --> 24:45:22,872
this method is now private to the

37339
24:45:22,872 --> 24:45:25,440
engineer class and why is it private to

37340
24:45:25,440 --> 24:45:28,160
engineer well engineer is doing private

37341
24:45:28,160 --> 24:45:30,552
inheritance that's going to accept

37342
24:45:30,552 --> 24:45:33,280
everything to private level access by

37343
24:45:33,280 --> 24:45:36,000
default so this member is private to

37344
24:45:36,000 --> 24:45:39,280
engineer we are inheriting from engineer

37345
24:45:39,280 --> 24:45:41,440
in civil engineer

37346
24:45:41,440 --> 24:45:43,680
and this is going to be already private

37347
24:45:43,680 --> 24:45:46,160
to engineer and we can't resurrect this

37348
24:45:46,160 --> 24:45:49,440
back so if you eclipse something using

37349
24:45:49,440 --> 24:45:51,680
private inheritance you want to be able

37350
24:45:51,680 --> 24:45:54,960
to resurrect that to a more relaxed

37351
24:45:54,960 --> 24:45:58,000
access level in downstream classes this

37352
24:45:58,000 --> 24:45:59,832
is the message i am trying to convey

37353
24:45:59,832 --> 24:46:01,832
here so this is also going to give us a

37354
24:46:01,832 --> 24:46:03,280
compiler error

37355
24:46:03,280 --> 24:46:05,280
and if we try to build our program we're

37356
24:46:05,280 --> 24:46:07,192
going to see that let's pass this

37357
24:46:07,192 --> 24:46:09,680
through gcc we are going to see that's

37358
24:46:09,680 --> 24:46:12,080
the world finished with errors and if we

37359
24:46:12,080 --> 24:46:14,320
go back we are going to get some kind of

37360
24:46:14,320 --> 24:46:17,192
error that says that do something is

37361
24:46:17,192 --> 24:46:20,720
private to some class it is inaccessible

37362
24:46:20,720 --> 24:46:22,800
within this context this is the message

37363
24:46:22,800 --> 24:46:25,440
we get from this particular compiler we

37364
24:46:25,440 --> 24:46:28,480
are using but the bottom line is that

37365
24:46:28,480 --> 24:46:30,960
you shouldn't really try to resurrect

37366
24:46:30,960 --> 24:46:33,120
something that is already private to an

37367
24:46:33,120 --> 24:46:34,960
upstream class and this is what we are

37368
24:46:34,960 --> 24:46:37,120
doing here you shouldn't really do that

37369
24:46:37,120 --> 24:46:39,512
let's comment this out and get a code to

37370
24:46:39,512 --> 24:46:41,040
compile again

37371
24:46:41,040 --> 24:46:43,440
so the web is good and we are all fine

37372
24:46:43,440 --> 24:46:45,832
here this is really all i had to share

37373
24:46:45,832 --> 24:46:47,440
in this lecture i hope you found it

37374
24:46:47,440 --> 24:46:50,000
interesting we are going to stop here in

37375
24:46:50,000 --> 24:46:51,760
this one the next one we're going to

37376
24:46:51,760 --> 24:46:55,192
explore how constructors work with

37377
24:46:55,192 --> 24:46:56,552
inheritance

37378
24:46:56,552 --> 24:46:58,800
go ahead and finish up here and meet me

37379
24:46:58,800 --> 24:47:00,080
there

37380
24:47:00,080 --> 24:47:01,920
in this lecture we're going to zoom in

37381
24:47:01,920 --> 24:47:05,040
at how derived objects are built and

37382
24:47:05,040 --> 24:47:06,400
we're going to zoom in on the

37383
24:47:06,400 --> 24:47:09,280
constructors that we have been ignoring

37384
24:47:09,280 --> 24:47:12,480
on purpose so far so here we have the

37385
24:47:12,480 --> 24:47:14,720
inheritance hierarchy we will be using

37386
24:47:14,720 --> 24:47:17,040
it is what we are familiar with at this

37387
24:47:17,040 --> 24:47:19,192
point we have a personal class which is

37388
24:47:19,192 --> 24:47:20,872
going to be our base class we have an

37389
24:47:20,872 --> 24:47:23,120
engineer class which is now going to be

37390
24:47:23,120 --> 24:47:25,600
doing public inheritance because we have

37391
24:47:25,600 --> 24:47:29,192
seen enough of private inheritance our

37392
24:47:29,192 --> 24:47:31,760
engineer class is now going to be nice

37393
24:47:31,760 --> 24:47:32,800
and say

37394
24:47:32,800 --> 24:47:35,360
i am inheriting from person but i also

37395
24:47:35,360 --> 24:47:38,320
want my downstream classes to have

37396
24:47:38,320 --> 24:47:40,720
access to the cool stuff i am getting

37397
24:47:40,720 --> 24:47:42,720
from person this is how

37398
24:47:42,720 --> 24:47:45,512
our engineer class is behaving now we

37399
24:47:45,512 --> 24:47:47,440
are also going to have a civil engineer

37400
24:47:47,440 --> 24:47:49,512
class which is going to publicly inherit

37401
24:47:49,512 --> 24:47:52,000
from engineer but what we want to focus

37402
24:47:52,000 --> 24:47:55,440
on here is what we get from base classes

37403
24:47:55,440 --> 24:47:57,512
so the engineer class is going to have a

37404
24:47:57,512 --> 24:48:00,320
person part of that but it is also going

37405
24:48:00,320 --> 24:48:03,192
to build on top of that and add an

37406
24:48:03,192 --> 24:48:06,480
engineer level and customize what kind

37407
24:48:06,480 --> 24:48:09,760
of person it is so if we inherit from

37408
24:48:09,760 --> 24:48:12,000
engineer and that weld our civil

37409
24:48:12,000 --> 24:48:14,232
engineer class the first link to be

37410
24:48:14,232 --> 24:48:16,552
built by c plus plus is the person part

37411
24:48:16,552 --> 24:48:19,040
of this it is going to build an engineer

37412
24:48:19,040 --> 24:48:21,280
level of this and then we are going to

37413
24:48:21,280 --> 24:48:24,080
add a civil engineer level

37414
24:48:24,080 --> 24:48:27,920
to add the customizations that the civil

37415
24:48:27,920 --> 24:48:30,080
engineer class is adding

37416
24:48:30,080 --> 24:48:32,640
and a c plus plus is going to do this

37417
24:48:32,640 --> 24:48:35,440
using constructors by default we are

37418
24:48:35,440 --> 24:48:37,832
going to be using default constructors

37419
24:48:37,832 --> 24:48:40,160
if we don't specify a way for the

37420
24:48:40,160 --> 24:48:42,480
basical structure to be called c plus

37421
24:48:42,480 --> 24:48:44,000
plus is going to call the default

37422
24:48:44,000 --> 24:48:47,512
constructor to build your base objects

37423
24:48:47,512 --> 24:48:50,320
so if we set up something like this and

37424
24:48:50,320 --> 24:48:52,960
try to run a program we're going to get

37425
24:48:52,960 --> 24:48:54,872
output like this we're going to see that

37426
24:48:54,872 --> 24:48:56,640
the person default constructor is going

37427
24:48:56,640 --> 24:48:58,960
to be called first and notice that we

37428
24:48:58,960 --> 24:49:01,832
are building a civil engineer object so

37429
24:49:01,832 --> 24:49:04,160
the default constructor from the most

37430
24:49:04,160 --> 24:49:06,480
base class is going to be called then

37431
24:49:06,480 --> 24:49:08,552
we're going to be building an engineer

37432
24:49:08,552 --> 24:49:11,192
layer on top of the person stuff that we

37433
24:49:11,192 --> 24:49:13,680
get then we're going to build a civil

37434
24:49:13,680 --> 24:49:17,120
engineer layer on top of the engineer

37435
24:49:17,120 --> 24:49:19,360
stuff that we have already got and the

37436
24:49:19,360 --> 24:49:21,280
compiler is going to do this using the

37437
24:49:21,280 --> 24:49:23,512
default constructors by default so we're

37438
24:49:23,512 --> 24:49:25,120
going to call the default constructor

37439
24:49:25,120 --> 24:49:27,192
for person first we're going to call the

37440
24:49:27,192 --> 24:49:29,280
default constructor for engineer and

37441
24:49:29,280 --> 24:49:31,120
then we're going to call the default

37442
24:49:31,120 --> 24:49:33,360
constructor for civil engineer to

37443
24:49:33,360 --> 24:49:36,160
complete the construction of our object

37444
24:49:36,160 --> 24:49:38,000
the object will be complete at this

37445
24:49:38,000 --> 24:49:40,080
point and we will be able to use it

37446
24:49:40,080 --> 24:49:43,440
later on in our program here and

37447
24:49:43,440 --> 24:49:45,120
hopefully this is going to drive the

37448
24:49:45,120 --> 24:49:46,400
point home

37449
24:49:46,400 --> 24:49:49,040
that you should really really always

37450
24:49:49,040 --> 24:49:51,360
provide to the photoconstructors for

37451
24:49:51,360 --> 24:49:54,320
your classes because the compiler may

37452
24:49:54,320 --> 24:49:56,960
call these default constructors in

37453
24:49:56,960 --> 24:50:00,080
unexpected ways especially if your class

37454
24:50:00,080 --> 24:50:03,600
is part of an inheritance hierarchy for

37455
24:50:03,600 --> 24:50:05,760
example if somebody tries to build the

37456
24:50:05,760 --> 24:50:08,552
civil engineer object and you don't have

37457
24:50:08,552 --> 24:50:11,440
a default constructor for a person the

37458
24:50:11,440 --> 24:50:13,192
compiler is going to try and code that

37459
24:50:13,192 --> 24:50:14,872
and it's not going to find that and it

37460
24:50:14,872 --> 24:50:17,512
is going to throw a compiler error as we

37461
24:50:17,512 --> 24:50:20,320
are about to see in a minute okay so the

37462
24:50:20,320 --> 24:50:22,232
message really in this lecture is that

37463
24:50:22,232 --> 24:50:24,400
the most base part of your class is

37464
24:50:24,400 --> 24:50:27,120
going to be bolt so for example for our

37465
24:50:27,120 --> 24:50:28,640
civil engineer class we're going to

37466
24:50:28,640 --> 24:50:30,960
build the prison port first then we're

37467
24:50:30,960 --> 24:50:33,040
going to build the engineer park and

37468
24:50:33,040 --> 24:50:34,640
then we're going to build the civil

37469
24:50:34,640 --> 24:50:36,872
engineer part of that and then we're

37470
24:50:36,872 --> 24:50:39,680
going to finish the construction of our

37471
24:50:39,680 --> 24:50:42,320
object this is the message here now that

37472
24:50:42,320 --> 24:50:43,832
you notice we're going to head over to

37473
24:50:43,832 --> 24:50:45,760
visual studio code and play with this a

37474
24:50:45,760 --> 24:50:46,960
little more

37475
24:50:46,960 --> 24:50:49,760
here we are in our working folder the

37476
24:50:49,760 --> 24:50:52,400
current project is default argument

37477
24:50:52,400 --> 24:50:55,192
constructor with inheritance we are

37478
24:50:55,192 --> 24:50:56,960
going to reuse the code from the last

37479
24:50:56,960 --> 24:50:58,640
lecture because that's going to give us

37480
24:50:58,640 --> 24:51:01,280
the classes that we need to play

37481
24:51:01,280 --> 24:51:03,280
with what we want to do in this lecture

37482
24:51:03,280 --> 24:51:04,960
and that's playing with default

37483
24:51:04,960 --> 24:51:07,920
constructors let's put in our starter

37484
24:51:07,920 --> 24:51:09,512
code and we're going to open this little

37485
24:51:09,512 --> 24:51:12,160
guy in visual studio code let's do this

37486
24:51:12,160 --> 24:51:13,920
so we're going to have our classes we're

37487
24:51:13,920 --> 24:51:16,320
going to have the main function which we

37488
24:51:16,320 --> 24:51:17,832
can play with

37489
24:51:17,832 --> 24:51:20,720
and we are going to look at the person

37490
24:51:20,720 --> 24:51:23,040
class and make sure we have a default

37491
24:51:23,040 --> 24:51:25,760
constructor we are not going to default

37492
24:51:25,760 --> 24:51:28,000
it this time because we want to have a

37493
24:51:28,000 --> 24:51:32,480
body we can put our output statements in

37494
24:51:32,480 --> 24:51:34,160
so in this case we're going to go in the

37495
24:51:34,160 --> 24:51:36,320
cpp file and put in a default

37496
24:51:36,320 --> 24:51:38,080
constructor we're going to say person

37497
24:51:38,080 --> 24:51:41,512
and person and person here and this is

37498
24:51:41,512 --> 24:51:43,192
going to be our constructor we're going

37499
24:51:43,192 --> 24:51:47,040
to say stdcl defaults constructor for

37500
24:51:47,040 --> 24:51:48,720
person called

37501
24:51:48,720 --> 24:51:51,120
okay so the personal class is done we

37502
24:51:51,120 --> 24:51:53,680
have a default constructor that works as

37503
24:51:53,680 --> 24:51:56,480
we want and we're going to go to our

37504
24:51:56,480 --> 24:51:58,480
engineer class and we're going to change

37505
24:51:58,480 --> 24:52:01,120
it to do public inheritance i think this

37506
24:52:01,120 --> 24:52:03,440
is going to be much easier to deal with

37507
24:52:03,440 --> 24:52:04,232
now

37508
24:52:04,232 --> 24:52:06,960
and we're going to remove all these

37509
24:52:06,960 --> 24:52:09,440
resurrection we were doing here from the

37510
24:52:09,440 --> 24:52:11,512
last lecture because this is no longer

37511
24:52:11,512 --> 24:52:14,000
going to be needed

37512
24:52:14,000 --> 24:52:16,320
and what we really want is to look at

37513
24:52:16,320 --> 24:52:18,960
our default constructor which is really

37514
24:52:18,960 --> 24:52:21,120
in here already let's look at the

37515
24:52:21,120 --> 24:52:23,192
implementation all we really need to do

37516
24:52:23,192 --> 24:52:26,320
is put in sddc out and say default

37517
24:52:26,320 --> 24:52:27,760
constructor

37518
24:52:27,760 --> 24:52:28,872
for

37519
24:52:28,872 --> 24:52:30,000
engineer

37520
24:52:30,000 --> 24:52:31,040
called

37521
24:52:31,040 --> 24:52:33,760
and we're going to hop over to the civil

37522
24:52:33,760 --> 24:52:36,400
engineer class and see if we have a

37523
24:52:36,400 --> 24:52:38,960
default constructor and we do have it

37524
24:52:38,960 --> 24:52:41,360
and we're going to go to the cpp file

37525
24:52:41,360 --> 24:52:44,232
and say sddcl

37526
24:52:44,232 --> 24:52:46,720
default constructor called

37527
24:52:46,720 --> 24:52:49,360
for civil engineer

37528
24:52:49,360 --> 24:52:52,000
so this is going to basically do what we

37529
24:52:52,000 --> 24:52:54,720
want and what we really want to see

37530
24:52:54,720 --> 24:52:57,360
is how or the order in which our

37531
24:52:57,360 --> 24:52:59,680
constructors are going to be called if

37532
24:52:59,680 --> 24:53:02,720
we build a civil engineer object as we

37533
24:53:02,720 --> 24:53:04,640
have seen here the person part is going

37534
24:53:04,640 --> 24:53:06,552
to be built first so this is going to

37535
24:53:06,552 --> 24:53:08,872
call the constructor from person and

37536
24:53:08,872 --> 24:53:11,120
because we are not doing any kind of

37537
24:53:11,120 --> 24:53:13,600
customization on which constructor is

37538
24:53:13,600 --> 24:53:15,600
going to be called the compiler is going

37539
24:53:15,600 --> 24:53:17,440
to call the default constructor by

37540
24:53:17,440 --> 24:53:19,040
default so we're going to build the

37541
24:53:19,040 --> 24:53:21,192
person port first and we're going to see

37542
24:53:21,192 --> 24:53:22,872
the default constructor for a person

37543
24:53:22,872 --> 24:53:25,192
called after that we're going to build

37544
24:53:25,192 --> 24:53:27,760
the engineer part of us

37545
24:53:27,760 --> 24:53:29,440
and this is going to call the default

37546
24:53:29,440 --> 24:53:32,160
constructor for engineer and after that

37547
24:53:32,160 --> 24:53:34,640
we're going to weld the civil engineer

37548
24:53:34,640 --> 24:53:36,720
part of us and that's going to call the

37549
24:53:36,720 --> 24:53:39,512
civil engineer default constructor this

37550
24:53:39,512 --> 24:53:41,192
is what we want to see

37551
24:53:41,192 --> 24:53:44,800
if we build a civil engineer object so

37552
24:53:44,800 --> 24:53:47,120
we are going to hop over in the main cpp

37553
24:53:47,120 --> 24:53:49,040
file and actually build the civil

37554
24:53:49,040 --> 24:53:51,832
engineer object we're going to say civil

37555
24:53:51,832 --> 24:53:55,360
engineer and we're going to say ce1 we

37556
24:53:55,360 --> 24:53:57,440
can do that and we're going to see what

37557
24:53:57,440 --> 24:54:00,232
happens let's try and build this program

37558
24:54:00,232 --> 24:54:03,040
we're going to build that with gcc the

37559
24:54:03,040 --> 24:54:05,832
book is going to be good we could run it

37560
24:54:05,832 --> 24:54:08,320
let's bring up a powershell window we

37561
24:54:08,320 --> 24:54:10,000
can play with

37562
24:54:10,000 --> 24:54:13,040
we want to bring up a powershell window

37563
24:54:13,040 --> 24:54:14,640
we can clear

37564
24:54:14,640 --> 24:54:16,480
and run rooster

37565
24:54:16,480 --> 24:54:17,832
and you're going to see that default

37566
24:54:17,832 --> 24:54:20,000
constructor for a person called the

37567
24:54:20,000 --> 24:54:22,480
first constructor for engineer called

37568
24:54:22,480 --> 24:54:24,800
default constructor for

37569
24:54:24,800 --> 24:54:27,760
engineer called this is what we want to

37570
24:54:27,760 --> 24:54:30,080
see and hopefully this proves that the

37571
24:54:30,080 --> 24:54:31,832
compiler is really going to build a

37572
24:54:31,832 --> 24:54:35,280
civil engineer object in parts the

37573
24:54:35,280 --> 24:54:36,872
compiler is going to see that it is a

37574
24:54:36,872 --> 24:54:38,960
derived object and it's going to see all

37575
24:54:38,960 --> 24:54:41,680
the classes that this is deriving from

37576
24:54:41,680 --> 24:54:44,080
so it is going to build the most base

37577
24:54:44,080 --> 24:54:46,400
part first after that it is going to

37578
24:54:46,400 --> 24:54:48,720
build other layers until it reaches the

37579
24:54:48,720 --> 24:54:51,920
level where we are at at this civil

37580
24:54:51,920 --> 24:54:55,040
engineer objects again if we put another

37581
24:54:55,040 --> 24:54:57,512
statement out here i'm going to say

37582
24:54:57,512 --> 24:54:58,960
hello in here

37583
24:54:58,960 --> 24:55:01,920
and we're going to say sdd-endl

37584
24:55:01,920 --> 24:55:04,400
and i am doing this so that i just have

37585
24:55:04,400 --> 24:55:07,040
a point where i can put my breakpoint

37586
24:55:07,040 --> 24:55:09,440
some ides are not going to like it if

37587
24:55:09,440 --> 24:55:12,160
you put a breakpoint at an empty line so

37588
24:55:12,160 --> 24:55:14,640
that's why i am doing it here and i am

37589
24:55:14,640 --> 24:55:16,552
going to try and debug and really show

37590
24:55:16,552 --> 24:55:19,512
you that we have an engineer and a

37591
24:55:19,512 --> 24:55:21,600
person part in us i have shown you this

37592
24:55:21,600 --> 24:55:23,512
before but it doesn't really hurt to

37593
24:55:23,512 --> 24:55:24,872
repeat this

37594
24:55:24,872 --> 24:55:27,680
because debugging is really cool it's

37595
24:55:27,680 --> 24:55:30,232
going to give you more information than

37596
24:55:30,232 --> 24:55:32,320
you could ever ask for

37597
24:55:32,320 --> 24:55:34,960
we're going to hit our break point here

37598
24:55:34,960 --> 24:55:37,280
and if we look in our

37599
24:55:37,280 --> 24:55:39,280
locals we're going to have our civil

37600
24:55:39,280 --> 24:55:42,160
engineer object which is in scope now

37601
24:55:42,160 --> 24:55:44,080
and you see that we have an engineer

37602
24:55:44,080 --> 24:55:47,512
part of us and the engineer has a person

37603
24:55:47,512 --> 24:55:49,760
partner so what the compiler is really

37604
24:55:49,760 --> 24:55:51,760
going to do when it is building a civil

37605
24:55:51,760 --> 24:55:54,720
engineer object it is going to build the

37606
24:55:54,720 --> 24:55:57,280
most based part of us so it is going to

37607
24:55:57,280 --> 24:55:59,512
build a personal part after that it is

37608
24:55:59,512 --> 24:56:01,680
going to build an engineer layer on top

37609
24:56:01,680 --> 24:56:03,600
of that and then it is going to world

37610
24:56:03,600 --> 24:56:06,232
the servo engineer layer and that's what

37611
24:56:06,232 --> 24:56:09,120
we see in our output when we get to run

37612
24:56:09,120 --> 24:56:11,512
our program here if we go back we're

37613
24:56:11,512 --> 24:56:13,360
going to see that we still have our

37614
24:56:13,360 --> 24:56:15,512
binary we can still run it

37615
24:56:15,512 --> 24:56:17,760
let's bring up a terminal window we can

37616
24:56:17,760 --> 24:56:19,280
use to run this we're going to run

37617
24:56:19,280 --> 24:56:21,360
rooster and we're going to see the order

37618
24:56:21,360 --> 24:56:24,160
in which our constructors are called

37619
24:56:24,160 --> 24:56:26,160
this is really cool now that we have

37620
24:56:26,160 --> 24:56:28,480
just debugged this program you can take

37621
24:56:28,480 --> 24:56:30,400
out this hello line because it's really

37622
24:56:30,400 --> 24:56:32,960
useless and this is really what i wanted

37623
24:56:32,960 --> 24:56:35,360
you to see constructors are going to be

37624
24:56:35,360 --> 24:56:38,640
called in your inheritance hierarchy

37625
24:56:38,640 --> 24:56:41,192
starting from the most basic

37626
24:56:41,192 --> 24:56:44,160
going down to the most specialized one

37627
24:56:44,160 --> 24:56:45,680
so we're going to call the most best

37628
24:56:45,680 --> 24:56:47,680
constructor which is person and we're

37629
24:56:47,680 --> 24:56:49,920
going to keep going until we reach the

37630
24:56:49,920 --> 24:56:52,480
most specialized which is a civil

37631
24:56:52,480 --> 24:56:56,160
engineer here to build our object and

37632
24:56:56,160 --> 24:56:58,400
our object is really going to be build

37633
24:56:58,400 --> 24:57:00,960
up in layers this is the message i am

37634
24:57:00,960 --> 24:57:03,192
trying to convey here this is really all

37635
24:57:03,192 --> 24:57:05,120
i had to share in this lecture i hope

37636
24:57:05,120 --> 24:57:07,512
you found it interesting we are going to

37637
24:57:07,512 --> 24:57:09,832
stop here in this one the next one we're

37638
24:57:09,832 --> 24:57:11,832
going to see that we can actually

37639
24:57:11,832 --> 24:57:15,280
actively call a base class constructor

37640
24:57:15,280 --> 24:57:17,832
from our derived class and that's going

37641
24:57:17,832 --> 24:57:21,360
to add much more flexibility in how our

37642
24:57:21,360 --> 24:57:23,680
objects are built we are not going to

37643
24:57:23,680 --> 24:57:25,280
call the default constructor we're going

37644
24:57:25,280 --> 24:57:28,160
to be calling our own constructors and

37645
24:57:28,160 --> 24:57:30,552
have much more control on how our

37646
24:57:30,552 --> 24:57:34,320
derived objects are set up in the world

37647
24:57:34,320 --> 24:57:36,552
go ahead and finish up here and meet me

37648
24:57:36,552 --> 24:57:38,000
in the next lecture

37649
24:57:38,000 --> 24:57:40,232
in this lecture we're going to see a way

37650
24:57:40,232 --> 24:57:43,192
we can instruct for custom constructors

37651
24:57:43,192 --> 24:57:44,552
to be called

37652
24:57:44,552 --> 24:57:47,920
when our derived objects are being built

37653
24:57:47,920 --> 24:57:49,040
and set up

37654
24:57:49,040 --> 24:57:51,760
in the last lecture we saw a figure like

37655
24:57:51,760 --> 24:57:54,640
this we had an inheritance hierarchy

37656
24:57:54,640 --> 24:57:57,120
that went from person to engineer and to

37657
24:57:57,120 --> 24:57:59,832
civil engineer and we saw that if we set

37658
24:57:59,832 --> 24:58:02,080
up a civil engineer object a personal

37659
24:58:02,080 --> 24:58:04,320
part is going to be built first an

37660
24:58:04,320 --> 24:58:06,000
engineer part is going to be built on

37661
24:58:06,000 --> 24:58:08,000
top of that and the civil engineer part

37662
24:58:08,000 --> 24:58:09,600
of that is going to be

37663
24:58:09,600 --> 24:58:11,192
built and then we're going to have the

37664
24:58:11,192 --> 24:58:13,600
construction complete for our civil

37665
24:58:13,600 --> 24:58:16,552
engineer object but in the last lecture

37666
24:58:16,552 --> 24:58:18,872
we saw that this was calling the default

37667
24:58:18,872 --> 24:58:21,280
constructors and sometimes you don't

37668
24:58:21,280 --> 24:58:24,552
want this you want your objects built in

37669
24:58:24,552 --> 24:58:27,192
a specific way for example through a

37670
24:58:27,192 --> 24:58:29,040
bunch of parameters that you pass to

37671
24:58:29,040 --> 24:58:30,960
your constructor what if you want this

37672
24:58:30,960 --> 24:58:32,800
kind of setup this is what we are going

37673
24:58:32,800 --> 24:58:35,600
to learn about in this lecture and what

37674
24:58:35,600 --> 24:58:37,680
we want to end up with is something like

37675
24:58:37,680 --> 24:58:39,512
this we will be able to build a person

37676
24:58:39,512 --> 24:58:41,192
object by passing in a bunch of

37677
24:58:41,192 --> 24:58:43,192
parameters we can pass in

37678
24:58:43,192 --> 24:58:45,832
the full name we can pass in the age i

37679
24:58:45,832 --> 24:58:47,680
think this is the age we can pass in an

37680
24:58:47,680 --> 24:58:50,232
address we can build an engineer object

37681
24:58:50,232 --> 24:58:52,080
by passing in this kind of information

37682
24:58:52,080 --> 24:58:54,480
we can pass in the name the age and the

37683
24:58:54,480 --> 24:58:56,800
address but we can also pass in the

37684
24:58:56,800 --> 24:58:59,760
contract count i think this is the new

37685
24:58:59,760 --> 24:59:02,640
member variable we had in our engineer

37686
24:59:02,640 --> 24:59:04,872
class but we're not going to stop there

37687
24:59:04,872 --> 24:59:06,872
we can also build the civil engineer

37688
24:59:06,872 --> 24:59:08,872
object and we can pass in the

37689
24:59:08,872 --> 24:59:11,040
information again a civil engineer is

37690
24:59:11,040 --> 24:59:13,280
also a person so we're going to be

37691
24:59:13,280 --> 24:59:15,120
passing the information that is going to

37692
24:59:15,120 --> 24:59:16,872
initialize the person part and that

37693
24:59:16,872 --> 24:59:19,920
happens to be the name the age and the

37694
24:59:19,920 --> 24:59:22,720
address but a civil engineer is also an

37695
24:59:22,720 --> 24:59:24,232
engineer so we're going to pass

37696
24:59:24,232 --> 24:59:27,360
information that portrays to the level

37697
24:59:27,360 --> 24:59:28,960
of an engineer and that's going to be

37698
24:59:28,960 --> 24:59:31,192
the contract count and we're going to

37699
24:59:31,192 --> 24:59:33,512
pass the information to initialize the

37700
24:59:33,512 --> 24:59:36,640
civil engineer part of this object and

37701
24:59:36,640 --> 24:59:39,120
that's going to be the road strength

37702
24:59:39,120 --> 24:59:41,120
and hopefully from this you can see that

37703
24:59:41,120 --> 24:59:42,640
we need a way

37704
24:59:42,640 --> 24:59:44,960
to forward all this information to the

37705
24:59:44,960 --> 24:59:47,440
constructor where this information is

37706
24:59:47,440 --> 24:59:49,832
needed for example if we are building a

37707
24:59:49,832 --> 24:59:53,040
civil engineer object we want to forward

37708
24:59:53,040 --> 24:59:56,320
the name the age and the address to the

37709
24:59:56,320 --> 24:59:59,192
person part of us so we need to parse

37710
24:59:59,192 --> 25:00:01,512
this to our personal constructor in a

37711
25:00:01,512 --> 25:00:06,232
way we need to pass the 31 here to our

37712
25:00:06,232 --> 25:00:08,960
engineer constructor because this

37713
25:00:08,960 --> 25:00:12,000
information is going to be stored at our

37714
25:00:12,000 --> 25:00:14,720
engineer level and we need to store the

37715
25:00:14,720 --> 25:00:18,000
road strength information into the civil

37716
25:00:18,000 --> 25:00:20,720
engineer part of us because that's where

37717
25:00:20,720 --> 25:00:23,040
this member variable is declared

37718
25:00:23,040 --> 25:00:24,960
hopefully you can see the need to call

37719
25:00:24,960 --> 25:00:27,280
custom constructors which are not to

37720
25:00:27,280 --> 25:00:29,600
default these custom constructors are

37721
25:00:29,600 --> 25:00:32,160
going to allow us to forward information

37722
25:00:32,160 --> 25:00:35,280
when building our objects like we are

37723
25:00:35,280 --> 25:00:37,920
doing here in the main function so let's

37724
25:00:37,920 --> 25:00:40,320
see how we can do this some of you might

37725
25:00:40,320 --> 25:00:42,232
think uh-huh if i am building an

37726
25:00:42,232 --> 25:00:44,960
engineer object i can just grab the

37727
25:00:44,960 --> 25:00:47,120
information and pass that to my base

37728
25:00:47,120 --> 25:00:49,600
class and that is simple right so we can

37729
25:00:49,600 --> 25:00:51,512
grab all this information we can grab

37730
25:00:51,512 --> 25:00:54,480
the full name the age and the address

37731
25:00:54,480 --> 25:00:57,192
and pass that to our base class using

37732
25:00:57,192 --> 25:00:59,760
the syntaxes we have here if we are

37733
25:00:59,760 --> 25:01:01,600
doing public inheritance we're going to

37734
25:01:01,600 --> 25:01:03,600
have access to these guys anyway so we

37735
25:01:03,600 --> 25:01:06,400
can say full name equals full name mag

37736
25:01:06,400 --> 25:01:09,280
equals age and say m address equals

37737
25:01:09,280 --> 25:01:10,552
address

37738
25:01:10,552 --> 25:01:11,920
except

37739
25:01:11,920 --> 25:01:15,600
for the address is actually private to

37740
25:01:15,600 --> 25:01:18,720
the person class and we can't do

37741
25:01:18,720 --> 25:01:21,120
something like this if we try to access

37742
25:01:21,120 --> 25:01:23,280
the address member variable from the

37743
25:01:23,280 --> 25:01:25,680
base class and modify it we're going to

37744
25:01:25,680 --> 25:01:27,600
get a compiler error that says that the

37745
25:01:27,600 --> 25:01:30,320
address is actually private to the base

37746
25:01:30,320 --> 25:01:33,280
person class we can't do this so this is

37747
25:01:33,280 --> 25:01:35,680
not going to work okay some of you might

37748
25:01:35,680 --> 25:01:38,480
think uh-huh what if i try to use an

37749
25:01:38,480 --> 25:01:41,192
initializer list and do something like

37750
25:01:41,192 --> 25:01:43,680
this so i can say m full name and pass

37751
25:01:43,680 --> 25:01:46,480
in my information i can say mh and put

37752
25:01:46,480 --> 25:01:49,040
in my information i can say m address

37753
25:01:49,040 --> 25:01:50,800
and put in my information and then

37754
25:01:50,800 --> 25:01:52,232
initialize

37755
25:01:52,232 --> 25:01:54,720
the member variable that actually

37756
25:01:54,720 --> 25:01:57,280
belongs to the engineer class that we

37757
25:01:57,280 --> 25:02:00,000
are trying to build an object for here

37758
25:02:00,000 --> 25:02:01,680
and hopefully this is going to work

37759
25:02:01,680 --> 25:02:04,320
except the compiler is not also going to

37760
25:02:04,320 --> 25:02:07,192
accept this the reason is with

37761
25:02:07,192 --> 25:02:10,400
initializer lists you can't initialize a

37762
25:02:10,400 --> 25:02:13,192
member variable that doesn't belong to

37763
25:02:13,192 --> 25:02:15,440
the class that you are trying to build

37764
25:02:15,440 --> 25:02:17,832
an object for so for example here we are

37765
25:02:17,832 --> 25:02:20,800
trying to initialize m full name mh and

37766
25:02:20,800 --> 25:02:23,440
m address but these member variables

37767
25:02:23,440 --> 25:02:26,160
don't belong to the engineer class that

37768
25:02:26,160 --> 25:02:28,320
we are trying to build an object for so

37769
25:02:28,320 --> 25:02:30,232
we're going to get a compiler error here

37770
25:02:30,232 --> 25:02:32,552
this is not going to work it is not

37771
25:02:32,552 --> 25:02:34,480
engineer's job

37772
25:02:34,480 --> 25:02:37,512
to build or set up this member variables

37773
25:02:37,512 --> 25:02:40,160
so this is not going to work okay so

37774
25:02:40,160 --> 25:02:42,160
how are we supposed to forward

37775
25:02:42,160 --> 25:02:45,440
information from derived classes to base

37776
25:02:45,440 --> 25:02:46,640
classes

37777
25:02:46,640 --> 25:02:48,872
not to worry here we can still use

37778
25:02:48,872 --> 25:02:51,512
initializer lists but we are going to

37779
25:02:51,512 --> 25:02:54,232
use constructors whose job is going to

37780
25:02:54,232 --> 25:02:56,960
be to initialize these member variables

37781
25:02:56,960 --> 25:02:59,360
so if we are building an engineer object

37782
25:02:59,360 --> 25:03:01,280
and we have information that really

37783
25:03:01,280 --> 25:03:04,080
belongs to the person part of us we're

37784
25:03:04,080 --> 25:03:05,920
going to call the person constructor to

37785
25:03:05,920 --> 25:03:08,720
actually use this information to build

37786
25:03:08,720 --> 25:03:10,640
the personal part of us and we're going

37787
25:03:10,640 --> 25:03:13,120
to be calling the person constructor in

37788
25:03:13,120 --> 25:03:16,080
our initializer list here and after we

37789
25:03:16,080 --> 25:03:18,480
do that we're going to initialize a

37790
25:03:18,480 --> 25:03:20,800
member variable that actually belongs to

37791
25:03:20,800 --> 25:03:24,080
us in our initializer list this is going

37792
25:03:24,080 --> 25:03:25,920
to forward information from derived

37793
25:03:25,920 --> 25:03:28,640
classes in this case the engineer is the

37794
25:03:28,640 --> 25:03:30,872
derived class and the information is

37795
25:03:30,872 --> 25:03:33,280
going to be forwarded to the person

37796
25:03:33,280 --> 25:03:35,680
constructor which is our base class this

37797
25:03:35,680 --> 25:03:37,600
is how this is going to work

37798
25:03:37,600 --> 25:03:39,120
okay now that you know this we're going

37799
25:03:39,120 --> 25:03:41,192
to head over to visual studio code and

37800
25:03:41,192 --> 25:03:42,872
play with us a little more

37801
25:03:42,872 --> 25:03:45,280
here we are in our working folder the

37802
25:03:45,280 --> 25:03:47,680
current project is constructors with

37803
25:03:47,680 --> 25:03:50,320
inheritance we are going to grab the

37804
25:03:50,320 --> 25:03:52,160
code from the last lecture because

37805
25:03:52,160 --> 25:03:54,480
that's going to be our starting point

37806
25:03:54,480 --> 25:03:55,680
and we're going to

37807
25:03:55,680 --> 25:03:57,120
paste this

37808
25:03:57,120 --> 25:03:59,832
in our current project

37809
25:03:59,832 --> 25:04:02,080
we are going to open this little guy in

37810
25:04:02,080 --> 25:04:03,920
visual studio code by dragging and

37811
25:04:03,920 --> 25:04:06,320
dropping here and this is going to give

37812
25:04:06,320 --> 25:04:08,640
us our starter code we're going to have

37813
25:04:08,640 --> 25:04:11,040
a person class an engineer class and a

37814
25:04:11,040 --> 25:04:13,512
civil engineer class and this is

37815
25:04:13,512 --> 25:04:15,512
basically going to set up the hierarchy

37816
25:04:15,512 --> 25:04:18,640
we have here and what we want to achieve

37817
25:04:18,640 --> 25:04:21,360
is to be able to call our own custom

37818
25:04:21,360 --> 25:04:22,872
constructors

37819
25:04:22,872 --> 25:04:25,512
when we build our object in layers

37820
25:04:25,512 --> 25:04:27,512
information is going to be coming from a

37821
25:04:27,512 --> 25:04:29,512
civil engineer object

37822
25:04:29,512 --> 25:04:31,600
and we are going to initialize the

37823
25:04:31,600 --> 25:04:33,512
person part of us with relevant

37824
25:04:33,512 --> 25:04:34,400
information

37825
25:04:34,400 --> 25:04:36,232
we're going to initialize the engineer

37826
25:04:36,232 --> 25:04:38,640
part of us with relevant information and

37827
25:04:38,640 --> 25:04:40,480
we're going to initialize the civil

37828
25:04:40,480 --> 25:04:42,960
engineer part of us with relevant

37829
25:04:42,960 --> 25:04:44,800
information this is what we want to

37830
25:04:44,800 --> 25:04:47,760
achieve okay for that to work we need to

37831
25:04:47,760 --> 25:04:50,160
not call default constructors we want to

37832
25:04:50,160 --> 25:04:52,872
call actual constructors that are going

37833
25:04:52,872 --> 25:04:55,512
to grab the information and forward that

37834
25:04:55,512 --> 25:04:58,480
in our member variables for example in

37835
25:04:58,480 --> 25:05:00,160
person we have a constructor which is

37836
25:05:00,160 --> 25:05:01,920
going to take three pieces of

37837
25:05:01,920 --> 25:05:03,192
information

37838
25:05:03,192 --> 25:05:05,600
and it is going to pass this information

37839
25:05:05,600 --> 25:05:08,640
into our member variables we need to

37840
25:05:08,640 --> 25:05:11,360
apply a few changes here for example our

37841
25:05:11,360 --> 25:05:14,832
third parameter is passed as a cost

37842
25:05:14,832 --> 25:05:17,680
strength member type we are going to

37843
25:05:17,680 --> 25:05:20,000
change this to be std strength view

37844
25:05:20,000 --> 25:05:22,320
because this is going to save us

37845
25:05:22,320 --> 25:05:24,080
on copies

37846
25:05:24,080 --> 25:05:26,232
let's say string view here this is going

37847
25:05:26,232 --> 25:05:27,600
to work

37848
25:05:27,600 --> 25:05:30,320
and this is going to forward information

37849
25:05:30,320 --> 25:05:32,800
in a way we want we're going to change

37850
25:05:32,800 --> 25:05:36,640
our third parameter to bhtd string view

37851
25:05:36,640 --> 25:05:38,400
let's say string view here we're going

37852
25:05:38,400 --> 25:05:41,360
to say std string view this is what we

37853
25:05:41,360 --> 25:05:44,552
have in our header we're going to be

37854
25:05:44,552 --> 25:05:46,960
having the same signature for our

37855
25:05:46,960 --> 25:05:48,552
function here

37856
25:05:48,552 --> 25:05:50,552
and what is wrong

37857
25:05:50,552 --> 25:05:55,120
we have m full name mh and we have m

37858
25:05:55,120 --> 25:05:57,440
address here let's try to build and see

37859
25:05:57,440 --> 25:05:59,680
if the error goes away sometimes visual

37860
25:05:59,680 --> 25:06:02,400
studio code is playing games on us

37861
25:06:02,400 --> 25:06:03,920
if we get a compiler error we're going

37862
25:06:03,920 --> 25:06:05,760
to try and fix that you see that it is

37863
25:06:05,760 --> 25:06:08,000
visual studio code playing with us the

37864
25:06:08,000 --> 25:06:10,080
code is just fine here

37865
25:06:10,080 --> 25:06:10,960
so

37866
25:06:10,960 --> 25:06:13,192
we have our constructor for person it is

37867
25:06:13,192 --> 25:06:15,440
going to forward information using our

37868
25:06:15,440 --> 25:06:18,000
initializer list here we're going to

37869
25:06:18,000 --> 25:06:19,760
look at our

37870
25:06:19,760 --> 25:06:22,000
engineer class if we go there we're

37871
25:06:22,000 --> 25:06:23,920
going to see that we don't have any

37872
25:06:23,920 --> 25:06:26,000
constructor which is going to grab

37873
25:06:26,000 --> 25:06:29,280
information in any meaningful way and

37874
25:06:29,280 --> 25:06:31,920
put that in our class

37875
25:06:31,920 --> 25:06:34,320
so we are going to put in a constructor

37876
25:06:34,320 --> 25:06:37,040
that looks like the one we have in our

37877
25:06:37,040 --> 25:06:40,400
person class so we can just grab this i

37878
25:06:40,400 --> 25:06:42,552
like copy and pasting because that's

37879
25:06:42,552 --> 25:06:44,232
going to save me

37880
25:06:44,232 --> 25:06:46,552
a few seconds so i am going to put my

37881
25:06:46,552 --> 25:06:48,800
constructor here only it is not going to

37882
25:06:48,800 --> 25:06:50,552
be called the person it is going to be

37883
25:06:50,552 --> 25:06:53,040
engineer and i am going to add a

37884
25:06:53,040 --> 25:06:54,400
construct count

37885
25:06:54,400 --> 25:06:56,552
member and this is going to be an

37886
25:06:56,552 --> 25:06:59,600
integer here to keep things simpler

37887
25:06:59,600 --> 25:07:01,192
and we are going to put an

37888
25:07:01,192 --> 25:07:03,512
implementation of this constructor in

37889
25:07:03,512 --> 25:07:06,552
our engineer class we can go down here

37890
25:07:06,552 --> 25:07:08,160
and put that in front of other

37891
25:07:08,160 --> 25:07:10,232
constructors let's look at the order we

37892
25:07:10,232 --> 25:07:12,320
have in our

37893
25:07:12,320 --> 25:07:14,720
header because i like to be consistent

37894
25:07:14,720 --> 25:07:17,600
the default constructor is first so

37895
25:07:17,600 --> 25:07:19,680
this constructor is going to be second

37896
25:07:19,680 --> 25:07:21,760
and we're going to say that it belongs

37897
25:07:21,760 --> 25:07:23,920
to the engineer class

37898
25:07:23,920 --> 25:07:26,640
using a scope resolution operator here

37899
25:07:26,640 --> 25:07:28,480
and we are going to put in our

37900
25:07:28,480 --> 25:07:30,232
initializer list

37901
25:07:30,232 --> 25:07:33,832
now what we want to do is to call

37902
25:07:33,832 --> 25:07:36,232
the constructor for person to initialize

37903
25:07:36,232 --> 25:07:38,552
a person part of us and then we're going

37904
25:07:38,552 --> 25:07:40,000
to grab the information from the

37905
25:07:40,000 --> 25:07:41,512
contract count and we're going to

37906
25:07:41,512 --> 25:07:44,720
forward that in our own member variable

37907
25:07:44,720 --> 25:07:45,920
the way we're going to achieve this

37908
25:07:45,920 --> 25:07:47,360
we're going to call the person

37909
25:07:47,360 --> 25:07:49,512
constructor and we're going to pass in

37910
25:07:49,512 --> 25:07:51,832
the full name we're going to pass the

37911
25:07:51,832 --> 25:07:54,480
age and we're going to pass the address

37912
25:07:54,480 --> 25:07:56,872
and then we're going to initialize our

37913
25:07:56,872 --> 25:07:59,040
own member variable which is contract

37914
25:07:59,040 --> 25:08:00,872
count i think

37915
25:08:00,872 --> 25:08:02,960
let's go to the header and look at that

37916
25:08:02,960 --> 25:08:04,640
we're going to see that our member

37917
25:08:04,640 --> 25:08:06,232
variable is contract count so we're

37918
25:08:06,232 --> 25:08:08,552
going to say contract count and we're

37919
25:08:08,552 --> 25:08:11,512
going to say contract count param we're

37920
25:08:11,512 --> 25:08:13,832
going to name this differently because

37921
25:08:13,832 --> 25:08:16,552
we don't want issues with naming here so

37922
25:08:16,552 --> 25:08:19,680
let's name our parameter here param

37923
25:08:19,680 --> 25:08:21,360
this is going to not confuse the

37924
25:08:21,360 --> 25:08:23,832
compiler and once we have this end we

37925
25:08:23,832 --> 25:08:26,480
can just put in the body which is going

37926
25:08:26,480 --> 25:08:28,080
to be empty because all the

37927
25:08:28,080 --> 25:08:30,800
initialization is now done in our

37928
25:08:30,800 --> 25:08:32,800
initializer list here

37929
25:08:32,800 --> 25:08:34,960
so if we do this we're going to see that

37930
25:08:34,960 --> 25:08:37,040
the compiler is going to be happy with

37931
25:08:37,040 --> 25:08:39,760
our thing here we're going to go down in

37932
25:08:39,760 --> 25:08:40,800
our

37933
25:08:40,800 --> 25:08:43,280
civil engineer class

37934
25:08:43,280 --> 25:08:45,040
and we're going to grab the constructor

37935
25:08:45,040 --> 25:08:46,552
we have an engineer because we're going

37936
25:08:46,552 --> 25:08:48,720
to be using this as a starting point

37937
25:08:48,720 --> 25:08:51,192
we're going to copy it and go in our

37938
25:08:51,192 --> 25:08:52,800
civil engineer class we're going to see

37939
25:08:52,800 --> 25:08:54,080
that we don't have a customer

37940
25:08:54,080 --> 25:08:56,640
constructor we're going to put this and

37941
25:08:56,640 --> 25:08:58,832
we're going to name this civil

37942
25:08:58,832 --> 25:09:01,680
engineer and we're going to add a

37943
25:09:01,680 --> 25:09:03,832
speciality member

37944
25:09:03,832 --> 25:09:05,600
that we want to initialize so we're

37945
25:09:05,600 --> 25:09:06,800
going to say

37946
25:09:06,800 --> 25:09:08,800
std string view because we want to

37947
25:09:08,800 --> 25:09:10,640
forward string data we're going to say

37948
25:09:10,640 --> 25:09:13,600
std string view here and we're going to

37949
25:09:13,600 --> 25:09:16,960
say speciality and we are going to put

37950
25:09:16,960 --> 25:09:18,800
the implementation of this

37951
25:09:18,800 --> 25:09:22,480
in our cpp file for a civil engineer

37952
25:09:22,480 --> 25:09:24,552
we're going to put this below our

37953
25:09:24,552 --> 25:09:26,232
default constructor

37954
25:09:26,232 --> 25:09:29,192
let's grab this i lost the desk somehow

37955
25:09:29,192 --> 25:09:31,512
so we're going to copy

37956
25:09:31,512 --> 25:09:34,000
and we're going to paste down here

37957
25:09:34,000 --> 25:09:35,760
we're going to say that this constructor

37958
25:09:35,760 --> 25:09:38,480
belongs to the civil engineer class i'm

37959
25:09:38,480 --> 25:09:40,832
going to use our scope resolution

37960
25:09:40,832 --> 25:09:42,872
operator and after this we're going to

37961
25:09:42,872 --> 25:09:46,000
put our initializer list in civil

37962
25:09:46,000 --> 25:09:48,640
engineer we will call our engineer

37963
25:09:48,640 --> 25:09:50,552
constructor

37964
25:09:50,552 --> 25:09:53,512
and it is going to be taking four thanks

37965
25:09:53,512 --> 25:09:56,000
we're going to pass in the full name

37966
25:09:56,000 --> 25:09:57,512
we're going to pass in the age we're

37967
25:09:57,512 --> 25:09:59,600
going to pass in the address and we're

37968
25:09:59,600 --> 25:10:01,832
going to pass in the contract account

37969
25:10:01,832 --> 25:10:05,040
which we will get from our constructor

37970
25:10:05,040 --> 25:10:07,832
from civil engineer but we will also

37971
25:10:07,832 --> 25:10:11,040
initialize our specialty member

37972
25:10:11,040 --> 25:10:12,640
variables so we're going to say m

37973
25:10:12,640 --> 25:10:15,280
speciality and we're going to pass the

37974
25:10:15,280 --> 25:10:18,080
spatiality information here

37975
25:10:18,080 --> 25:10:20,160
and this is going to initialize our then

37976
25:10:20,160 --> 25:10:22,480
we're going to put in an empty body and

37977
25:10:22,480 --> 25:10:24,720
our information is going to be properly

37978
25:10:24,720 --> 25:10:28,960
forwarded to our base classes so if we

37979
25:10:28,960 --> 25:10:31,120
build the civil engineer object proper

37980
25:10:31,120 --> 25:10:32,960
information is going to be forwarded to

37981
25:10:32,960 --> 25:10:35,120
the engineer part of us

37982
25:10:35,120 --> 25:10:37,040
and the proper information is going to

37983
25:10:37,040 --> 25:10:40,640
be forwarded to the person part of us

37984
25:10:40,640 --> 25:10:43,280
now that we have this in place we can

37985
25:10:43,280 --> 25:10:47,360
put in our htdc out statements to let us

37986
25:10:47,360 --> 25:10:48,400
know

37987
25:10:48,400 --> 25:10:51,040
which constructor was actually called to

37988
25:10:51,040 --> 25:10:53,440
build authen we're going to say that it

37989
25:10:53,440 --> 25:10:56,320
was our custom constructor that was

37990
25:10:56,320 --> 25:10:57,920
called let's say that here we're going

37991
25:10:57,920 --> 25:10:59,040
to say

37992
25:10:59,040 --> 25:11:01,280
customer constructor called for civil

37993
25:11:01,280 --> 25:11:04,552
engineer we are going to go to our

37994
25:11:04,552 --> 25:11:07,512
engineer class and also say the same

37995
25:11:07,512 --> 25:11:11,040
thing let's go to this cpp file for that

37996
25:11:11,040 --> 25:11:13,512
and we're going to put in our htdc out

37997
25:11:13,512 --> 25:11:15,360
statement and we're going to say custom

37998
25:11:15,360 --> 25:11:18,320
constructor we can copy this to be

37999
25:11:18,320 --> 25:11:21,600
consistent with what we had in our

38000
25:11:21,600 --> 25:11:24,000
constructor default constructor i should

38001
25:11:24,000 --> 25:11:25,832
say and we're going to say custom

38002
25:11:25,832 --> 25:11:28,552
constructor called for our engineer

38003
25:11:28,552 --> 25:11:30,872
class we're going to go back to person

38004
25:11:30,872 --> 25:11:32,320
and we're going to go to the

38005
25:11:32,320 --> 25:11:34,640
implementation file and we're going to

38006
25:11:34,640 --> 25:11:36,720
copy the message from our default

38007
25:11:36,720 --> 25:11:38,720
constructor and we're going to put this

38008
25:11:38,720 --> 25:11:41,680
in and say that the custom constructor

38009
25:11:41,680 --> 25:11:44,400
was called for person here so now that

38010
25:11:44,400 --> 25:11:46,872
we have these guys in we can go to our

38011
25:11:46,872 --> 25:11:49,680
main cpp file and include the classes

38012
25:11:49,680 --> 25:11:52,720
they are included here we can try to

38013
25:11:52,720 --> 25:11:55,120
create a person object just like we saw

38014
25:11:55,120 --> 25:11:57,440
in the slides and we're going to try and

38015
25:11:57,440 --> 25:11:59,280
build this program and see which

38016
25:11:59,280 --> 25:12:01,512
constructor is called to set up this

38017
25:12:01,512 --> 25:12:03,040
person object

38018
25:12:03,040 --> 25:12:05,680
this shouldn't be rocket science by now

38019
25:12:05,680 --> 25:12:08,720
we know that our custom constructor is

38020
25:12:08,720 --> 25:12:10,552
going to be called because we are

38021
25:12:10,552 --> 25:12:13,192
passing three parameters which should be

38022
25:12:13,192 --> 25:12:15,440
forwarded to our member variables

38023
25:12:15,440 --> 25:12:18,640
through this initializer last so let's

38024
25:12:18,640 --> 25:12:21,512
build with gcc and make sure this is

38025
25:12:21,512 --> 25:12:23,680
what we expect we're going to use our

38026
25:12:23,680 --> 25:12:25,280
compiler here

38027
25:12:25,280 --> 25:12:27,440
the bolt is going to be good as you see

38028
25:12:27,440 --> 25:12:30,552
here and if we bring up our powershell

38029
25:12:30,552 --> 25:12:32,720
window and run rooster we're going to

38030
25:12:32,720 --> 25:12:34,800
see that our custom constructor is

38031
25:12:34,800 --> 25:12:37,600
called let's bring up the main cpp file

38032
25:12:37,600 --> 25:12:40,080
so that we can see our thing we are

38033
25:12:40,080 --> 25:12:42,160
passing this information here and we are

38034
25:12:42,160 --> 25:12:44,400
printing our person object and we're

38035
25:12:44,400 --> 25:12:46,320
going to see that the full name is jon

38036
25:12:46,320 --> 25:12:49,760
snow the age is 27 and the address is

38037
25:12:49,760 --> 25:12:52,232
winterfell called and all this gibberish

38038
25:12:52,232 --> 25:12:54,640
we have here our constructor is really

38039
25:12:54,640 --> 25:12:57,040
being called okay so this is working we

38040
25:12:57,040 --> 25:12:59,512
can also set up an engineer object and

38041
25:12:59,512 --> 25:13:01,440
see that the information is being

38042
25:13:01,440 --> 25:13:04,720
properly propagated to the person part

38043
25:13:04,720 --> 25:13:08,000
of our engineer object because engineer

38044
25:13:08,000 --> 25:13:10,552
is inheriting from person

38045
25:13:10,552 --> 25:13:12,480
we are passing the information for the

38046
25:13:12,480 --> 25:13:15,040
full name the age the address but we are

38047
25:13:15,040 --> 25:13:18,232
also passing in the contract count which

38048
25:13:18,232 --> 25:13:20,640
should be used to initialize the

38049
25:13:20,640 --> 25:13:23,832
engineer part of us so we are going to

38050
25:13:23,832 --> 25:13:26,720
run the task to build with gcc

38051
25:13:26,720 --> 25:13:28,232
the build is going to go through

38052
25:13:28,232 --> 25:13:31,040
successfully and we can bring up our

38053
25:13:31,040 --> 25:13:33,192
powershell window and run the program

38054
25:13:33,192 --> 25:13:34,080
again

38055
25:13:34,080 --> 25:13:36,000
we're going to see that we're going to

38056
25:13:36,000 --> 25:13:38,320
branch the information for person custom

38057
25:13:38,320 --> 25:13:41,040
constructor for person called but what

38058
25:13:41,040 --> 25:13:43,600
we really are interested in here

38059
25:13:43,600 --> 25:13:46,400
is seeing that the custom constructor

38060
25:13:46,400 --> 25:13:48,232
for person is called

38061
25:13:48,232 --> 25:13:51,280
for building our engineer object and

38062
25:13:51,280 --> 25:13:54,800
then we call the engineer constructor

38063
25:13:54,800 --> 25:13:57,120
and again this falls in line with what

38064
25:13:57,120 --> 25:13:59,512
we saw in the last lecture the most

38065
25:13:59,512 --> 25:14:01,680
based constructor is called first and

38066
25:14:01,680 --> 25:14:05,192
then the must specialize constructor is

38067
25:14:05,192 --> 25:14:07,192
called last in this case we are just

38068
25:14:07,192 --> 25:14:10,232
setting up thanks in such a way that our

38069
25:14:10,232 --> 25:14:13,600
custom constructors are called and we do

38070
25:14:13,600 --> 25:14:17,680
that from our engineer class by calling

38071
25:14:17,680 --> 25:14:21,440
the base constructor explicitly

38072
25:14:21,440 --> 25:14:23,832
using the syntax that we have here in

38073
25:14:23,832 --> 25:14:26,400
our initializer list after we have the

38074
25:14:26,400 --> 25:14:28,640
base constructor called we are going to

38075
25:14:28,640 --> 25:14:31,512
initialize our own member variables and

38076
25:14:31,512 --> 25:14:33,192
that's what we see

38077
25:14:33,192 --> 25:14:35,600
and in this way the information for the

38078
25:14:35,600 --> 25:14:37,760
current class will be initialized

38079
25:14:37,760 --> 25:14:40,232
properly and this is what we see here i

38080
25:14:40,232 --> 25:14:42,400
think this is a little bit misleading

38081
25:14:42,400 --> 25:14:44,480
because we still have the information

38082
25:14:44,480 --> 25:14:45,440
from

38083
25:14:45,440 --> 25:14:47,912
the person objects that we bought

38084
25:14:47,912 --> 25:14:50,872
printed out here we can comment this out

38085
25:14:50,872 --> 25:14:52,872
and build again we're going to pass this

38086
25:14:52,872 --> 25:14:55,280
through gcc to build our program the

38087
25:14:55,280 --> 25:14:57,440
build is going to be good we can

38088
25:14:57,440 --> 25:14:59,912
clear and run rooster and we're going to

38089
25:14:59,912 --> 25:15:01,512
see that the custom constructor is

38090
25:15:01,512 --> 25:15:04,320
called for a person to set up the person

38091
25:15:04,320 --> 25:15:07,040
part of us and then another layer of

38092
25:15:07,040 --> 25:15:09,192
engineer is going to be set up in our

38093
25:15:09,192 --> 25:15:12,800
object to initialize the contract count

38094
25:15:12,800 --> 25:15:15,192
member variable part of us and we're

38095
25:15:15,192 --> 25:15:16,872
going to have the information here so if

38096
25:15:16,872 --> 25:15:18,320
we print the full name we're going to

38097
25:15:18,320 --> 25:15:20,232
get daniel gray the age is going to be

38098
25:15:20,232 --> 25:15:22,552
41. the address is going to be the

38099
25:15:22,552 --> 25:15:24,800
gibberish we expect here and the

38100
25:15:24,800 --> 25:15:26,720
contract count is going to be passed in

38101
25:15:26,720 --> 25:15:29,280
successfully and this is really cool we

38102
25:15:29,280 --> 25:15:33,120
can also comment this out and set up a

38103
25:15:33,120 --> 25:15:36,160
civil engineer object we can do that

38104
25:15:36,160 --> 25:15:38,800
okay so let's go down and put this in

38105
25:15:38,800 --> 25:15:40,552
place we're going to create a civil

38106
25:15:40,552 --> 25:15:43,192
engineer object we can close up

38107
25:15:43,192 --> 25:15:45,832
the left side bar here to have some more

38108
25:15:45,832 --> 25:15:47,680
breathing room we're going to build a

38109
25:15:47,680 --> 25:15:49,512
civil engineer object we're going to

38110
25:15:49,512 --> 25:15:52,080
pass in full name age address contract

38111
25:15:52,080 --> 25:15:55,360
count and a speciality which i think we

38112
25:15:55,360 --> 25:15:59,040
expect from our civil engineer custom

38113
25:15:59,040 --> 25:16:00,400
constructor here

38114
25:16:00,400 --> 25:16:02,552
that's going to be an std strength

38115
25:16:02,552 --> 25:16:04,480
that's what we are passing in here i

38116
25:16:04,480 --> 25:16:06,552
should say that's going to be

38117
25:16:06,552 --> 25:16:09,760
a string view but we can pass in string

38118
25:16:09,760 --> 25:16:12,320
data just like this and the string view

38119
25:16:12,320 --> 25:16:13,680
is going to take

38120
25:16:13,680 --> 25:16:15,360
so what we're going to see here we're

38121
25:16:15,360 --> 25:16:17,192
going to see the person constructor

38122
25:16:17,192 --> 25:16:19,600
called the person custom constructor i

38123
25:16:19,600 --> 25:16:21,912
should say we're going to see the

38124
25:16:21,912 --> 25:16:24,800
engineer custom constructor called and

38125
25:16:24,800 --> 25:16:26,960
after that we're going to see

38126
25:16:26,960 --> 25:16:29,440
the civil engineer custom constructor

38127
25:16:29,440 --> 25:16:31,760
called to pass and forward all this

38128
25:16:31,760 --> 25:16:32,872
information

38129
25:16:32,872 --> 25:16:36,480
in related parts of our civil engineer

38130
25:16:36,480 --> 25:16:39,040
object let's build and see that this is

38131
25:16:39,040 --> 25:16:41,832
actually going to even compile

38132
25:16:41,832 --> 25:16:43,360
the book is going to be good we can

38133
25:16:43,360 --> 25:16:44,800
clear

38134
25:16:44,800 --> 25:16:46,552
and run rooster and we're going to see

38135
25:16:46,552 --> 25:16:49,040
that this is exactly what we expect the

38136
25:16:49,040 --> 25:16:50,872
custom constructor for person is going

38137
25:16:50,872 --> 25:16:53,120
to be called after that

38138
25:16:53,120 --> 25:16:54,960
the custom constructor for engineer is

38139
25:16:54,960 --> 25:16:57,512
going to be called and then the custom

38140
25:16:57,512 --> 25:17:00,000
constructor for a civil engineer is

38141
25:17:00,000 --> 25:17:01,512
going to be called

38142
25:17:01,512 --> 25:17:03,680
and this really falls in line with what

38143
25:17:03,680 --> 25:17:06,080
we expect if we are building a civil

38144
25:17:06,080 --> 25:17:08,872
engineer object and the civil engineer

38145
25:17:08,872 --> 25:17:11,912
class happens to be inheriting both from

38146
25:17:11,912 --> 25:17:15,280
engineer and from person we're going to

38147
25:17:15,280 --> 25:17:19,120
have the person part of us world first

38148
25:17:19,120 --> 25:17:20,872
and because of this we're going to see

38149
25:17:20,872 --> 25:17:23,120
the person constructor called but in

38150
25:17:23,120 --> 25:17:25,760
this lecture the rio focus is getting

38151
25:17:25,760 --> 25:17:28,160
our custom constructor called so the

38152
25:17:28,160 --> 25:17:30,160
person custom constructor is going to be

38153
25:17:30,160 --> 25:17:32,400
called after that we're going to call

38154
25:17:32,400 --> 25:17:34,720
the custom constructor for the engineer

38155
25:17:34,720 --> 25:17:37,120
part of us and that's going to set up

38156
25:17:37,120 --> 25:17:40,232
the engineer specific member variables

38157
25:17:40,232 --> 25:17:42,960
in our object after that we're going to

38158
25:17:42,960 --> 25:17:45,512
set up another layer of civil engineer

38159
25:17:45,512 --> 25:17:48,232
in our object and this is going to

38160
25:17:48,232 --> 25:17:50,160
initialize the member variable that

38161
25:17:50,160 --> 25:17:52,480
belongs to the civil engineer

38162
25:17:52,480 --> 25:17:55,512
part of us in our object so this is

38163
25:17:55,512 --> 25:17:58,400
really the main goal in this lecture

38164
25:17:58,400 --> 25:18:00,640
showing you that you can set up fans in

38165
25:18:00,640 --> 25:18:03,440
such a way that your custom constructors

38166
25:18:03,440 --> 25:18:06,400
are called when setting up your object

38167
25:18:06,400 --> 25:18:07,680
in layers

38168
25:18:07,680 --> 25:18:10,160
as you see here okay now that we have

38169
25:18:10,160 --> 25:18:12,640
this working i want you to see that

38170
25:18:12,640 --> 25:18:14,552
there are some bad ways to do these

38171
25:18:14,552 --> 25:18:16,552
things and some people are actually

38172
25:18:16,552 --> 25:18:19,600
going to try to set things up in that

38173
25:18:19,600 --> 25:18:22,552
way the first bad way is to try and

38174
25:18:22,552 --> 25:18:24,800
initialize our member variables in the

38175
25:18:24,800 --> 25:18:27,600
body of the class if you do things like

38176
25:18:27,600 --> 25:18:30,552
this again this is going to work because

38177
25:18:30,552 --> 25:18:32,800
full name and age are going to be

38178
25:18:32,800 --> 25:18:35,512
inherited publicly from the person class

38179
25:18:35,512 --> 25:18:38,080
so the code here is going to work but we

38180
25:18:38,080 --> 25:18:40,320
have no way to initialize the address

38181
25:18:40,320 --> 25:18:42,872
member variable because it is private to

38182
25:18:42,872 --> 25:18:45,440
the person class so if we try to access

38183
25:18:45,440 --> 25:18:47,440
that we're going to get a compiler error

38184
25:18:47,440 --> 25:18:49,832
let's try this out in code and see the

38185
25:18:49,832 --> 25:18:52,480
actual compiler error to try this out i

38186
25:18:52,480 --> 25:18:54,960
am going to comment out the good code

38187
25:18:54,960 --> 25:18:57,760
here and i am going to copy and put in

38188
25:18:57,760 --> 25:18:59,360
something that is going to be

38189
25:18:59,360 --> 25:19:02,232
problematic as we saw in the slides i am

38190
25:19:02,232 --> 25:19:04,480
going to paste in my constructor here i

38191
25:19:04,480 --> 25:19:07,192
should close my powershell window here

38192
25:19:07,192 --> 25:19:09,120
and i am going to take out my

38193
25:19:09,120 --> 25:19:11,360
initializer lust because we're not going

38194
25:19:11,360 --> 25:19:13,440
to be using that here

38195
25:19:13,440 --> 25:19:15,600
and we're going to just grab the data

38196
25:19:15,600 --> 25:19:19,512
and use that to initialize our data in

38197
25:19:19,512 --> 25:19:21,192
our member variable here so we're going

38198
25:19:21,192 --> 25:19:23,512
to grab the full name and say m full

38199
25:19:23,512 --> 25:19:26,640
name equals full name we can do that

38200
25:19:26,640 --> 25:19:29,680
we're going to say mh equals h that's

38201
25:19:29,680 --> 25:19:31,360
the information we get we're going to

38202
25:19:31,360 --> 25:19:34,160
say m address and you see that we don't

38203
25:19:34,160 --> 25:19:37,120
even have that in autocomplete so we're

38204
25:19:37,120 --> 25:19:38,720
going to pass the address we're going to

38205
25:19:38,720 --> 25:19:41,512
be stubborn and ignore these squiggly

38206
25:19:41,512 --> 25:19:43,600
lines and we're going to say m

38207
25:19:43,600 --> 25:19:45,760
speciality and we're going to grab the

38208
25:19:45,760 --> 25:19:49,192
speciality and pass that in but you see

38209
25:19:49,192 --> 25:19:51,912
that line 26 has a bunch of squiggly

38210
25:19:51,912 --> 25:19:52,872
lines

38211
25:19:52,872 --> 25:19:55,440
and the reason is the m address member

38212
25:19:55,440 --> 25:19:57,832
variable is invisible and not

38213
25:19:57,832 --> 25:20:00,872
manipulable from a civil engineer class

38214
25:20:00,872 --> 25:20:03,120
again the reason is that the address

38215
25:20:03,120 --> 25:20:05,680
member variable is private to the person

38216
25:20:05,680 --> 25:20:08,800
class so the civil engineer class has no

38217
25:20:08,800 --> 25:20:12,640
business initializing this in the body

38218
25:20:12,640 --> 25:20:15,512
this is not going to work so if we try

38219
25:20:15,512 --> 25:20:18,232
and build this we're going to pass this

38220
25:20:18,232 --> 25:20:20,800
through gcc we are going to see that the

38221
25:20:20,800 --> 25:20:22,960
world is going to finish with errors and

38222
25:20:22,960 --> 25:20:25,680
if we go up we're going to probably see

38223
25:20:25,680 --> 25:20:28,640
the error person m address is private

38224
25:20:28,640 --> 25:20:31,040
within this context and we have no

38225
25:20:31,040 --> 25:20:33,600
business accessing that in the civil

38226
25:20:33,600 --> 25:20:37,360
engineer cpp file at line 26 this is

38227
25:20:37,360 --> 25:20:39,512
what we see here and this is the

38228
25:20:39,512 --> 25:20:41,512
offending line we shouldn't really be

38229
25:20:41,512 --> 25:20:44,080
doing this if we comment out this line

38230
25:20:44,080 --> 25:20:46,000
this is going to work but our member

38231
25:20:46,000 --> 25:20:48,000
variable is going to be left

38232
25:20:48,000 --> 25:20:51,120
with a junk value and this is really not

38233
25:20:51,120 --> 25:20:54,000
good because our address that we worked

38234
25:20:54,000 --> 25:20:55,192
so hard

38235
25:20:55,192 --> 25:20:57,680
to set up in our parameter here is just

38236
25:20:57,680 --> 25:21:00,320
going to be ignored so this is bad you

38237
25:21:00,320 --> 25:21:02,160
shouldn't really be initializing your

38238
25:21:02,160 --> 25:21:04,400
member variables like this especially if

38239
25:21:04,400 --> 25:21:07,360
you have an inheritance hierarchy in

38240
25:21:07,360 --> 25:21:09,280
your classes so we're going to comment

38241
25:21:09,280 --> 25:21:11,832
this out and say that this is really bad

38242
25:21:11,832 --> 25:21:13,912
it's going to give you compiler errors

38243
25:21:13,912 --> 25:21:15,832
and some of you are going to say okay

38244
25:21:15,832 --> 25:21:18,232
this is not working but what if we try

38245
25:21:18,232 --> 25:21:21,360
to use an initializer list directly

38246
25:21:21,360 --> 25:21:23,760
let's see if that actually works

38247
25:21:23,760 --> 25:21:25,360
we are going to

38248
25:21:25,360 --> 25:21:27,912
set up another constructor here and we

38249
25:21:27,912 --> 25:21:30,720
are going to set up the data in our

38250
25:21:30,720 --> 25:21:33,120
initializer list we're going to say

38251
25:21:33,120 --> 25:21:34,832
let's say m full

38252
25:21:34,832 --> 25:21:37,760
name and pass in the full name we can do

38253
25:21:37,760 --> 25:21:39,912
that let's try this out we're going to

38254
25:21:39,912 --> 25:21:42,000
say mh

38255
25:21:42,000 --> 25:21:44,480
and we're going to pass age we can do

38256
25:21:44,480 --> 25:21:48,080
that and we're going to grab the address

38257
25:21:48,080 --> 25:21:50,552
and we're going to pass an address here

38258
25:21:50,552 --> 25:21:52,160
and after that we're going to say m

38259
25:21:52,160 --> 25:21:54,232
spatiality and we're going to pass in

38260
25:21:54,232 --> 25:21:56,640
our spatiality information

38261
25:21:56,640 --> 25:21:59,120
what if we do something like this but

38262
25:21:59,120 --> 25:22:00,232
you're going to see that we have

38263
25:22:00,232 --> 25:22:02,160
squiggly lines here and the problem with

38264
25:22:02,160 --> 25:22:05,120
this way of doing things is that the

38265
25:22:05,120 --> 25:22:08,640
civil engineer class has no business

38266
25:22:08,640 --> 25:22:10,800
initializing thanks

38267
25:22:10,800 --> 25:22:13,760
that belong to the person class in the

38268
25:22:13,760 --> 25:22:17,192
initializer list your initializer list

38269
25:22:17,192 --> 25:22:19,440
only has the capability to initialize

38270
25:22:19,440 --> 25:22:21,760
the member variables that belong to the

38271
25:22:21,760 --> 25:22:25,680
current class and m full name mh and m

38272
25:22:25,680 --> 25:22:28,080
address don't belong to the cipher

38273
25:22:28,080 --> 25:22:30,400
engineer class that's why we're going to

38274
25:22:30,400 --> 25:22:32,480
have a compiler error if we try to set

38275
25:22:32,480 --> 25:22:34,872
up things in this way if we're trying to

38276
25:22:34,872 --> 25:22:37,040
build the program we're going to get a

38277
25:22:37,040 --> 25:22:39,680
weird compiler error

38278
25:22:39,680 --> 25:22:41,040
we're going to see that the build is

38279
25:22:41,040 --> 25:22:43,440
going to finish with errors and it is

38280
25:22:43,440 --> 25:22:46,480
going to say expected initializer before

38281
25:22:46,480 --> 25:22:49,360
m full name

38282
25:22:49,360 --> 25:22:51,760
and we need a column column here sorry

38283
25:22:51,760 --> 25:22:54,232
for this so this is not the error we

38284
25:22:54,232 --> 25:22:56,400
expect but you see that the moment we do

38285
25:22:56,400 --> 25:22:58,720
this we have a bunch of squiggly lines

38286
25:22:58,720 --> 25:23:02,000
on full name age and address and let's

38287
25:23:02,000 --> 25:23:04,320
build and see the problem we have and

38288
25:23:04,320 --> 25:23:06,400
we're going to build with errors as we

38289
25:23:06,400 --> 25:23:08,800
see here if we go up

38290
25:23:08,800 --> 25:23:11,360
we are going to see our errors civil

38291
25:23:11,360 --> 25:23:13,832
engineer does not have any field called

38292
25:23:13,832 --> 25:23:16,160
m full name we're going to see that

38293
25:23:16,160 --> 25:23:18,320
civil engineer doesn't have any field

38294
25:23:18,320 --> 25:23:20,800
called mh and civil engineer doesn't

38295
25:23:20,800 --> 25:23:24,320
have any field named m full name or m

38296
25:23:24,320 --> 25:23:27,192
address here that's the problem we have

38297
25:23:27,192 --> 25:23:29,440
no business initializing these member

38298
25:23:29,440 --> 25:23:32,320
variables that don't belong to the civil

38299
25:23:32,320 --> 25:23:34,552
engineer class in the first place so

38300
25:23:34,552 --> 25:23:37,120
this is also not going to work the best

38301
25:23:37,120 --> 25:23:39,192
bet we have already is to call the best

38302
25:23:39,192 --> 25:23:42,232
constructor and let that initialize the

38303
25:23:42,232 --> 25:23:44,720
member variables that belong to our

38304
25:23:44,720 --> 25:23:46,480
upstream class

38305
25:23:46,480 --> 25:23:49,832
in the inheritance hierarchy for example

38306
25:23:49,832 --> 25:23:52,160
in our civil engineer constructor here

38307
25:23:52,160 --> 25:23:54,480
we need to call the engineer

38308
25:23:54,480 --> 25:23:57,760
constructor to initialize the engineer

38309
25:23:57,760 --> 25:23:59,440
part of us and we're going to be

38310
25:23:59,440 --> 25:24:01,440
forwarding the information the full name

38311
25:24:01,440 --> 25:24:03,360
the age the address and the contract

38312
25:24:03,360 --> 25:24:06,232
account the engineer class is in turn

38313
25:24:06,232 --> 25:24:08,552
going to call its base constructor to

38314
25:24:08,552 --> 25:24:10,720
forward the information about the full

38315
25:24:10,720 --> 25:24:13,120
name of the agent the address and it is

38316
25:24:13,120 --> 25:24:14,872
going to initialize its own member

38317
25:24:14,872 --> 25:24:17,192
variable m construct count and the

38318
25:24:17,192 --> 25:24:19,440
information is going to be passed in

38319
25:24:19,440 --> 25:24:21,600
correctly and if we try to build our

38320
25:24:21,600 --> 25:24:23,120
class now we're going to see that

38321
25:24:23,120 --> 25:24:25,512
everything is going to work and i really

38322
25:24:25,512 --> 25:24:27,512
wanted you to be aware of this because

38323
25:24:27,512 --> 25:24:29,360
the moment you understand this you're

38324
25:24:29,360 --> 25:24:31,040
going to set up your inheritance

38325
25:24:31,040 --> 25:24:33,120
hierarchies in a way that is going to

38326
25:24:33,120 --> 25:24:34,720
make sense and you're not going to be

38327
25:24:34,720 --> 25:24:37,760
getting all these weird compiler errors

38328
25:24:37,760 --> 25:24:39,912
this is really all we set out to do in

38329
25:24:39,912 --> 25:24:41,832
this lecture showing you how you can set

38330
25:24:41,832 --> 25:24:45,280
up your own custom constructors in your

38331
25:24:45,280 --> 25:24:48,160
own inheritance hierarchy and at the

38332
25:24:48,160 --> 25:24:49,912
moment you do that you're going to get

38333
25:24:49,912 --> 25:24:52,960
your classes called in the order that

38334
25:24:52,960 --> 25:24:54,960
you expect things are going to be set up

38335
25:24:54,960 --> 25:24:57,120
in layers the base constructors are

38336
25:24:57,120 --> 25:24:59,040
going to be called in a way that you

38337
25:24:59,040 --> 25:25:01,120
expect and your objects are going to be

38338
25:25:01,120 --> 25:25:03,512
built in a way that you can print them

38339
25:25:03,512 --> 25:25:06,080
and see the information that you expect

38340
25:25:06,080 --> 25:25:08,800
set up in your object if you want you

38341
25:25:08,800 --> 25:25:10,872
can also use a debugger to see the

38342
25:25:10,872 --> 25:25:13,360
information in your thumb so we're going

38343
25:25:13,360 --> 25:25:15,440
to set up a breakpoint here and we're

38344
25:25:15,440 --> 25:25:17,680
going to bring up our

38345
25:25:17,680 --> 25:25:19,512
debugging tab we're going to hit the

38346
25:25:19,512 --> 25:25:21,600
green button to start debugging this

38347
25:25:21,600 --> 25:25:24,232
program the binary is going to be set up

38348
25:25:24,232 --> 25:25:26,480
once the vote is good the binary is

38349
25:25:26,480 --> 25:25:29,360
going to be passed in our debugger and

38350
25:25:29,360 --> 25:25:31,600
we are going to hit our breakpoint in a

38351
25:25:31,600 --> 25:25:34,232
minute let's wait for this so we have

38352
25:25:34,232 --> 25:25:37,360
hit the break point at line 20 and if we

38353
25:25:37,360 --> 25:25:40,400
expand our civil engineer object in our

38354
25:25:40,400 --> 25:25:42,800
locals we're going to see that we have

38355
25:25:42,800 --> 25:25:46,000
an engineer part of us we can expand

38356
25:25:46,000 --> 25:25:48,552
that and see that we also have a person

38357
25:25:48,552 --> 25:25:49,832
part of us

38358
25:25:49,832 --> 25:25:51,512
if we look at person we're going to see

38359
25:25:51,512 --> 25:25:54,720
that the full name is we can see john

38360
25:25:54,720 --> 25:25:56,720
travolta which is what we are passing

38361
25:25:56,720 --> 25:26:00,640
here we can also look at our age the age

38362
25:26:00,640 --> 25:26:03,040
is 51 as you see here

38363
25:26:03,040 --> 25:26:05,600
and we're going to also have information

38364
25:26:05,600 --> 25:26:07,600
about our address

38365
25:26:07,600 --> 25:26:09,680
if we expand this we're going to see

38366
25:26:09,680 --> 25:26:13,280
that the address is this gibb brush that

38367
25:26:13,280 --> 25:26:16,400
we just put in tiny dog

38368
25:26:16,400 --> 25:26:19,040
42 stret and

38369
25:26:19,040 --> 25:26:21,360
number 89 we can see this information

38370
25:26:21,360 --> 25:26:23,192
here and you can really expand and see

38371
25:26:23,192 --> 25:26:26,400
all these things that make up our object

38372
25:26:26,400 --> 25:26:28,320
for example we can see the information

38373
25:26:28,320 --> 25:26:30,960
about the contract count which is 31 and

38374
25:26:30,960 --> 25:26:33,120
it is what we are passing when we build

38375
25:26:33,120 --> 25:26:35,832
this object here and the speciality

38376
25:26:35,832 --> 25:26:40,000
happens to be road strength as we see in

38377
25:26:40,000 --> 25:26:42,000
our locals here you can really see all

38378
25:26:42,000 --> 25:26:44,640
these things we are going to stop here

38379
25:26:44,640 --> 25:26:46,552
in this lecture in the next one we're

38380
25:26:46,552 --> 25:26:49,360
going to explore how copy constructors

38381
25:26:49,360 --> 25:26:53,120
work in our inheritance hierarchy so go

38382
25:26:53,120 --> 25:26:54,872
ahead and finish up here

38383
25:26:54,872 --> 25:26:56,400
and meet me there

38384
25:26:56,400 --> 25:26:59,192
in this lecture we want to explore how

38385
25:26:59,192 --> 25:27:01,440
copy constructors work

38386
25:27:01,440 --> 25:27:04,960
with our inheritance hierarchies and we

38387
25:27:04,960 --> 25:27:07,040
will still be using the same example we

38388
25:27:07,040 --> 25:27:09,440
have been using in this chapter we will

38389
25:27:09,440 --> 25:27:12,160
have this inheritance hierarchy and we

38390
25:27:12,160 --> 25:27:14,640
will still be using the same example we

38391
25:27:14,640 --> 25:27:17,040
have been using in this chapter the base

38392
25:27:17,040 --> 25:27:18,720
class is going to be person we're going

38393
25:27:18,720 --> 25:27:21,120
to be inheriting from that publicly to

38394
25:27:21,120 --> 25:27:24,232
create an engineer class and we will be

38395
25:27:24,232 --> 25:27:26,320
inheriting from the engineer class

38396
25:27:26,320 --> 25:27:28,800
publicly to create the civil engineer

38397
25:27:28,800 --> 25:27:31,040
class and with this we want to be able

38398
25:27:31,040 --> 25:27:34,000
to copy construct objects and the code

38399
25:27:34,000 --> 25:27:36,400
we want to be running is something like

38400
25:27:36,400 --> 25:27:38,872
this we have an engineer object we want

38401
25:27:38,872 --> 25:27:41,440
to be able to create another object from

38402
25:27:41,440 --> 25:27:44,160
this engineer object using the syntax

38403
25:27:44,160 --> 25:27:46,552
here and from what we already know this

38404
25:27:46,552 --> 25:27:48,872
is going to call our copy constructor

38405
25:27:48,872 --> 25:27:50,960
the funny thing is this is going to work

38406
25:27:50,960 --> 25:27:53,120
by default even if you don't put in your

38407
25:27:53,120 --> 25:27:55,360
copy constructor the reason is the

38408
25:27:55,360 --> 25:27:57,360
compiler is going to insert a copy

38409
25:27:57,360 --> 25:27:59,512
constructor for you and things are going

38410
25:27:59,512 --> 25:28:01,832
to be copied in a way that you expect

38411
25:28:01,832 --> 25:28:05,832
because none of our classes is using

38412
25:28:05,832 --> 25:28:08,400
dynamic memory allocation so everything

38413
25:28:08,400 --> 25:28:10,400
is just going to fall in place and it is

38414
25:28:10,400 --> 25:28:12,400
going to work but if you happen to need

38415
25:28:12,400 --> 25:28:14,320
to set up your own copy constructor

38416
25:28:14,320 --> 25:28:15,912
we're going to see how you could do that

38417
25:28:15,912 --> 25:28:17,680
in this lecture and we're going to start

38418
25:28:17,680 --> 25:28:19,280
by the base class we're going to set up

38419
25:28:19,280 --> 25:28:21,832
a copy constructor for the person class

38420
25:28:21,832 --> 25:28:24,552
and this is nothing complicated we just

38421
25:28:24,552 --> 25:28:26,720
pass our parameter by reference this is

38422
25:28:26,720 --> 25:28:28,872
going to be our source object and we

38423
25:28:28,872 --> 25:28:31,280
will be copying the data from our source

38424
25:28:31,280 --> 25:28:33,680
object to initialize the member

38425
25:28:33,680 --> 25:28:36,232
variables in the current object that we

38426
25:28:36,232 --> 25:28:39,120
are copying here again this is a copy

38427
25:28:39,120 --> 25:28:40,872
constructor which will be copy

38428
25:28:40,872 --> 25:28:43,120
constructing from the parameter that we

38429
25:28:43,120 --> 25:28:46,160
pass by reference now how do we do the

38430
25:28:46,160 --> 25:28:49,600
constructor for the engineer class which

38431
25:28:49,600 --> 25:28:52,080
happens to be inheriting from person try

38432
25:28:52,080 --> 25:28:54,160
to think about that one way to do things

38433
25:28:54,160 --> 25:28:56,552
is to set up things like this and this

38434
25:28:56,552 --> 25:28:59,512
will be just initializing the engineer

38435
25:28:59,512 --> 25:29:03,440
layer of our class but nothing is going

38436
25:29:03,440 --> 25:29:06,080
to be initializing the person part of us

38437
25:29:06,080 --> 25:29:07,760
and this is bad this is going to call

38438
25:29:07,760 --> 25:29:10,320
the default constructor to initialize

38439
25:29:10,320 --> 25:29:12,720
the person part of us and we will just

38440
25:29:12,720 --> 25:29:15,760
be left in with junk data that is

38441
25:29:15,760 --> 25:29:17,680
initializing the person object by

38442
25:29:17,680 --> 25:29:20,800
default and all the data we have in our

38443
25:29:20,800 --> 25:29:23,280
parameter engineer object is just going

38444
25:29:23,280 --> 25:29:26,160
to be lost for the person part of us so

38445
25:29:26,160 --> 25:29:28,480
we don't want to do this this is bad

38446
25:29:28,480 --> 25:29:30,960
design you shouldn't do this some of you

38447
25:29:30,960 --> 25:29:33,280
are going to say but what if we call the

38448
25:29:33,280 --> 25:29:35,192
best constructor we have seen that we

38449
25:29:35,192 --> 25:29:38,320
could do that right but remember this is

38450
25:29:38,320 --> 25:29:40,872
a copy constructor what we have on the

38451
25:29:40,872 --> 25:29:42,640
left is an object

38452
25:29:42,640 --> 25:29:45,440
and it happens to be that

38453
25:29:45,440 --> 25:29:47,680
if you set up a syntax like this with

38454
25:29:47,680 --> 25:29:49,832
the copy constructor the compiler is

38455
25:29:49,832 --> 25:29:52,160
going to set up a temporary person

38456
25:29:52,160 --> 25:29:55,120
object and a copy from that object to

38457
25:29:55,120 --> 25:29:57,912
initialize the person part of us so this

38458
25:29:57,912 --> 25:30:00,320
is going to be creating a temporary copy

38459
25:30:00,320 --> 25:30:02,960
object containing the same data we have

38460
25:30:02,960 --> 25:30:06,400
in our engineer object so to some extent

38461
25:30:06,400 --> 25:30:08,800
this is going to work but the problem we

38462
25:30:08,800 --> 25:30:11,680
still have is that we are using the m

38463
25:30:11,680 --> 25:30:14,400
address member variable directly from an

38464
25:30:14,400 --> 25:30:16,872
engineer object and from what we already

38465
25:30:16,872 --> 25:30:19,912
know this m address member variable is

38466
25:30:19,912 --> 25:30:22,320
private to the person class and we have

38467
25:30:22,320 --> 25:30:24,640
no business accessing this

38468
25:30:24,640 --> 25:30:26,720
from an engineer construct so this is

38469
25:30:26,720 --> 25:30:28,552
going to give us a compiler error but

38470
25:30:28,552 --> 25:30:31,040
you know that it is possible to set up a

38471
25:30:31,040 --> 25:30:34,080
getter in the engineer class that is

38472
25:30:34,080 --> 25:30:36,872
going to return this address and you can

38473
25:30:36,872 --> 25:30:38,960
call that together here and get this

38474
25:30:38,960 --> 25:30:41,360
thing to initialize your data this is

38475
25:30:41,360 --> 25:30:43,512
going to work but this is really weird

38476
25:30:43,512 --> 25:30:45,600
you shouldn't do this this is bad design

38477
25:30:45,600 --> 25:30:47,280
there is a better way i am going to show

38478
25:30:47,280 --> 25:30:49,360
you but before we look at that wave

38479
25:30:49,360 --> 25:30:51,760
let's try and summarize the problems we

38480
25:30:51,760 --> 25:30:54,480
have with this way of doing things this

38481
25:30:54,480 --> 25:30:56,160
is not going to be reusing the copy

38482
25:30:56,160 --> 25:30:59,120
constructor we have worked hard to set

38483
25:30:59,120 --> 25:31:01,832
up in person so this is just going to be

38484
25:31:01,832 --> 25:31:04,552
called duplication another thing is that

38485
25:31:04,552 --> 25:31:07,280
the m address member variable is private

38486
25:31:07,280 --> 25:31:10,080
to person so if we try and use it like

38487
25:31:10,080 --> 25:31:12,160
this we're going to get a compiler error

38488
25:31:12,160 --> 25:31:15,360
again it is possible to set up a getter

38489
25:31:15,360 --> 25:31:17,680
that could return that and we could use

38490
25:31:17,680 --> 25:31:20,160
that getter in this place but this is

38491
25:31:20,160 --> 25:31:23,680
bad design we are really forced to set

38492
25:31:23,680 --> 25:31:26,320
up a getter that is possibly only used

38493
25:31:26,320 --> 25:31:28,320
in this place that's bad design we don't

38494
25:31:28,320 --> 25:31:30,480
want to do something like this another

38495
25:31:30,480 --> 25:31:32,232
thing is that this is going to create a

38496
25:31:32,232 --> 25:31:35,192
temporary copy of person from which we

38497
25:31:35,192 --> 25:31:38,480
will be copying to initialize the person

38498
25:31:38,480 --> 25:31:40,800
part of us we don't want to be making

38499
25:31:40,800 --> 25:31:43,832
that copy because we hate copies in c

38500
25:31:43,832 --> 25:31:46,000
plus plus code so the best way to do

38501
25:31:46,000 --> 25:31:48,320
this is to set up your copy constructor

38502
25:31:48,320 --> 25:31:51,040
in this way we are going to say person

38503
25:31:51,040 --> 25:31:54,480
and directly passing our engineer object

38504
25:31:54,480 --> 25:31:56,800
the compiler is smart enough to see that

38505
25:31:56,800 --> 25:32:00,080
we are passing an engineer object to

38506
25:32:00,080 --> 25:32:03,040
initialize a person object and what the

38507
25:32:03,040 --> 25:32:05,760
compiler is going to do is really smart

38508
25:32:05,760 --> 25:32:09,040
suppose our engineer object is made up

38509
25:32:09,040 --> 25:32:11,360
of two layers the inner layer is going

38510
25:32:11,360 --> 25:32:14,160
to be containing the information about

38511
25:32:14,160 --> 25:32:16,800
the person part of us and the outer

38512
25:32:16,800 --> 25:32:18,960
layer is going to be containing the

38513
25:32:18,960 --> 25:32:21,760
engineer part of us okay so this is the

38514
25:32:21,760 --> 25:32:23,512
setup we have so the compiler is going

38515
25:32:23,512 --> 25:32:25,040
to see that we are passing in an

38516
25:32:25,040 --> 25:32:27,512
engineer object to initialize a person

38517
25:32:27,512 --> 25:32:29,680
object and what it is going to do is

38518
25:32:29,680 --> 25:32:31,912
really smart it is going to strip off

38519
25:32:31,912 --> 25:32:35,280
all this engineer part if i can describe

38520
25:32:35,280 --> 25:32:37,120
it like this we're going to strip off

38521
25:32:37,120 --> 25:32:39,280
all this engineer part

38522
25:32:39,280 --> 25:32:42,552
that we have in our engineer object and

38523
25:32:42,552 --> 25:32:45,680
we will be just left with the person

38524
25:32:45,680 --> 25:32:48,640
part that we passed then to initialize

38525
25:32:48,640 --> 25:32:50,480
our person object and this is really

38526
25:32:50,480 --> 25:32:52,872
smart and it is going to work so again

38527
25:32:52,872 --> 25:32:55,192
the syntax is what you see here

38528
25:32:55,192 --> 25:32:57,360
we say person we pass in our source

38529
25:32:57,360 --> 25:33:00,080
object and then we can initialize the

38530
25:33:00,080 --> 25:33:02,552
member variable that belong to the

38531
25:33:02,552 --> 25:33:04,232
engineer part of us we will be

38532
25:33:04,232 --> 25:33:06,480
initializing contract count and this is

38533
25:33:06,480 --> 25:33:08,000
going to work now that you know this

38534
25:33:08,000 --> 25:33:09,512
we're going to head over to visual

38535
25:33:09,512 --> 25:33:11,440
studio code and play with us a little

38536
25:33:11,440 --> 25:33:14,000
more here we are in our working folder

38537
25:33:14,000 --> 25:33:16,552
the current project is copy constructors

38538
25:33:16,552 --> 25:33:19,440
with inheritance we will be reusing the

38539
25:33:19,440 --> 25:33:22,080
code from the last lecture so we're

38540
25:33:22,080 --> 25:33:24,160
going to grab everything from that

38541
25:33:24,160 --> 25:33:26,720
except for the binary and we're going to

38542
25:33:26,720 --> 25:33:30,080
copy that and put that in our current

38543
25:33:30,080 --> 25:33:32,552
project let's do this and we are going

38544
25:33:32,552 --> 25:33:34,960
to open this bad boy in visual studio

38545
25:33:34,960 --> 25:33:37,512
code by dragging and dropping here and

38546
25:33:37,512 --> 25:33:40,160
we will have our starting point we will

38547
25:33:40,160 --> 25:33:42,720
have our person class the engineer class

38548
25:33:42,720 --> 25:33:46,080
and the civil engineer class and we will

38549
25:33:46,080 --> 25:33:49,192
just be doing public inheritance to make

38550
25:33:49,192 --> 25:33:51,280
things easier here so engineer is going

38551
25:33:51,280 --> 25:33:54,080
to publicly inherit from person and

38552
25:33:54,080 --> 25:33:56,232
civil engineer is going to publicly

38553
25:33:56,232 --> 25:33:58,872
inherit from engineer and this is

38554
25:33:58,872 --> 25:34:00,960
everything we had from the last lecture

38555
25:34:00,960 --> 25:34:03,600
nothing special but what we want is to

38556
25:34:03,600 --> 25:34:06,640
set up copy constructors in such a way

38557
25:34:06,640 --> 25:34:09,360
that we will be able to build objects

38558
25:34:09,360 --> 25:34:12,320
from others for example if we leave in

38559
25:34:12,320 --> 25:34:14,800
our engineer object i think this is what

38560
25:34:14,800 --> 25:34:16,872
we used in the slides we're going to

38561
25:34:16,872 --> 25:34:19,832
have our engineer 1 object

38562
25:34:19,832 --> 25:34:23,120
we want to be able to create a another

38563
25:34:23,120 --> 25:34:25,760
engineer let's say engineer two and

38564
25:34:25,760 --> 25:34:28,232
above that from engineer one the thing

38565
25:34:28,232 --> 25:34:31,120
that might be puzzling to some of you is

38566
25:34:31,120 --> 25:34:32,960
that this is going to work out of the

38567
25:34:32,960 --> 25:34:35,360
box even if we didn't really put in a

38568
25:34:35,360 --> 25:34:37,832
copy constructor but the thing is the

38569
25:34:37,832 --> 25:34:40,000
compiler is going to insert a copy

38570
25:34:40,000 --> 25:34:42,720
constructor for you but that constructor

38571
25:34:42,720 --> 25:34:45,440
is going to be memberwise

38572
25:34:45,440 --> 25:34:47,600
copy so it is basically going to be

38573
25:34:47,600 --> 25:34:50,232
copying thanks memberwise it is going to

38574
25:34:50,232 --> 25:34:52,400
take the contract count from engineer

38575
25:34:52,400 --> 25:34:55,440
one and copy that into engineer two and

38576
25:34:55,440 --> 25:34:57,192
we are basically going to have the same

38577
25:34:57,192 --> 25:34:58,552
data from

38578
25:34:58,552 --> 25:35:01,440
engineer one in engineer two let's try

38579
25:35:01,440 --> 25:35:03,832
and print engineer two can do that we're

38580
25:35:03,832 --> 25:35:06,400
going to say and two and we're going to

38581
25:35:06,400 --> 25:35:09,512
put this out and we are going to run the

38582
25:35:09,512 --> 25:35:12,232
task to build with gcc that's what we

38583
25:35:12,232 --> 25:35:14,000
want here and you're going to see that

38584
25:35:14,000 --> 25:35:16,552
it is going to work out of the box if we

38585
25:35:16,552 --> 25:35:19,040
bring up a powershell window and run

38586
25:35:19,040 --> 25:35:21,440
rooster we're going to see that we have

38587
25:35:21,440 --> 25:35:23,912
the data in here we have engineer full

38588
25:35:23,912 --> 25:35:26,160
name daniel gray that's the data we have

38589
25:35:26,160 --> 25:35:28,480
in engineer one but notice that we are

38590
25:35:28,480 --> 25:35:31,120
printing engineer two here the age is

38591
25:35:31,120 --> 25:35:33,280
going to be 41 and the address is going

38592
25:35:33,280 --> 25:35:35,832
to be exactly what we had in engineer

38593
25:35:35,832 --> 25:35:37,832
one and you're going to see that the

38594
25:35:37,832 --> 25:35:39,680
constructors are going to be called to

38595
25:35:39,680 --> 25:35:42,640
set up engineer 2 and the custom

38596
25:35:42,640 --> 25:35:44,320
constructor for a person is going to be

38597
25:35:44,320 --> 25:35:46,160
called the custom constructor for

38598
25:35:46,160 --> 25:35:47,912
engineer is going to be called and this

38599
25:35:47,912 --> 25:35:49,192
is exactly

38600
25:35:49,192 --> 25:35:52,000
what we expect here but what if we want

38601
25:35:52,000 --> 25:35:54,640
to set up our own copy constructor and

38602
25:35:54,640 --> 25:35:57,120
the need to do that might arise

38603
25:35:57,120 --> 25:35:59,760
if we happen to be doing some dynamic

38604
25:35:59,760 --> 25:36:02,800
memory allocation in our classes suppose

38605
25:36:02,800 --> 25:36:05,440
maybe person class has some dynamic

38606
25:36:05,440 --> 25:36:07,680
memory allocation it has some pointer

38607
25:36:07,680 --> 25:36:09,832
member variable and in the personal

38608
25:36:09,832 --> 25:36:12,400
custom constructor we are doing some

38609
25:36:12,400 --> 25:36:14,720
dynamic memory allocation to initialize

38610
25:36:14,720 --> 25:36:16,800
that pointer we may be doing the same

38611
25:36:16,800 --> 25:36:19,120
thing at the engineer level or the civil

38612
25:36:19,120 --> 25:36:21,512
engineer level and that will force you

38613
25:36:21,512 --> 25:36:23,832
to set up your own copy constructor and

38614
25:36:23,832 --> 25:36:25,360
we're going to see how you could do that

38615
25:36:25,360 --> 25:36:28,000
in your classes we are going to start

38616
25:36:28,000 --> 25:36:29,832
with the person class we're going to go

38617
25:36:29,832 --> 25:36:32,872
on top and set up a copy constructor in

38618
25:36:32,872 --> 25:36:35,600
front of our destructor here we're going

38619
25:36:35,600 --> 25:36:37,192
to say person and we're going to say

38620
25:36:37,192 --> 25:36:40,080
const person reference source

38621
25:36:40,080 --> 25:36:42,160
this is the syntax you use to set up

38622
25:36:42,160 --> 25:36:44,080
your copy constructor you already know

38623
25:36:44,080 --> 25:36:46,872
this from a previous chapter and we're

38624
25:36:46,872 --> 25:36:48,640
going to put in the implementation for

38625
25:36:48,640 --> 25:36:51,760
this we're going to go in the cpp file

38626
25:36:51,760 --> 25:36:54,872
before the destructor or we should go

38627
25:36:54,872 --> 25:36:55,832
after

38628
25:36:55,832 --> 25:36:58,320
our custom constructor it doesn't really

38629
25:36:58,320 --> 25:37:00,400
matter where you put this and we're

38630
25:37:00,400 --> 25:37:02,800
going to put in our scope resolution

38631
25:37:02,800 --> 25:37:05,192
operator let's do person here and we

38632
25:37:05,192 --> 25:37:07,440
will just be copying the data from the

38633
25:37:07,440 --> 25:37:09,912
source person so we're going to put in

38634
25:37:09,912 --> 25:37:12,160
our initializer list and we're going to

38635
25:37:12,160 --> 25:37:14,400
say m full name we're going to grab the

38636
25:37:14,400 --> 25:37:16,160
name from the source person we're going

38637
25:37:16,160 --> 25:37:18,720
to say source m full name we're going to

38638
25:37:18,720 --> 25:37:21,440
initialize the age we're going to say mh

38639
25:37:21,440 --> 25:37:23,912
and we're going to grab the age from the

38640
25:37:23,912 --> 25:37:26,640
source person so mh here

38641
25:37:26,640 --> 25:37:28,872
and we can go to the next line so that

38642
25:37:28,872 --> 25:37:31,512
we see the entire thing here and say m

38643
25:37:31,512 --> 25:37:34,160
address and we're going to say source

38644
25:37:34,160 --> 25:37:36,800
and say m address this is going to set

38645
25:37:36,800 --> 25:37:39,440
up our constructor and down below we can

38646
25:37:39,440 --> 25:37:41,512
put in our body this is going to work

38647
25:37:41,512 --> 25:37:43,600
but this is everything we have seen so

38648
25:37:43,600 --> 25:37:46,000
far this is nothing new the syntax to

38649
25:37:46,000 --> 25:37:47,832
set up your copy constructor you just

38650
25:37:47,832 --> 25:37:50,640
pass it by const reference if you don't

38651
25:37:50,640 --> 25:37:52,552
pass by reference here you're going to

38652
25:37:52,552 --> 25:37:55,680
get an endless chain of copy constructor

38653
25:37:55,680 --> 25:37:56,640
calls

38654
25:37:56,640 --> 25:37:58,552
if this is confusing to you please go

38655
25:37:58,552 --> 25:38:00,640
back to the chapter on classes you're

38656
25:38:00,640 --> 25:38:03,440
going to see everything about this and

38657
25:38:03,440 --> 25:38:05,680
this is really all we need to do here to

38658
25:38:05,680 --> 25:38:08,000
have a copy constructor for a person now

38659
25:38:08,000 --> 25:38:10,480
let's do things at the engineer level

38660
25:38:10,480 --> 25:38:13,192
we're going to go to our engineer class

38661
25:38:13,192 --> 25:38:15,192
and we need to set up a copy constructor

38662
25:38:15,192 --> 25:38:16,960
the syntax is going to be the same we're

38663
25:38:16,960 --> 25:38:19,440
going to say engineer and we will be

38664
25:38:19,440 --> 25:38:22,320
constructing from a cost engineer object

38665
25:38:22,320 --> 25:38:24,400
we pass as a parameter here so we're

38666
25:38:24,400 --> 25:38:27,440
going to say cost engineer by reference

38667
25:38:27,440 --> 25:38:29,680
and say source and the problem is going

38668
25:38:29,680 --> 25:38:32,480
to be how we implement this thing we're

38669
25:38:32,480 --> 25:38:34,720
going to copy this and go in our

38670
25:38:34,720 --> 25:38:37,832
engineer cpp file we're going to put our

38671
25:38:37,832 --> 25:38:40,160
copy constructor after our customer

38672
25:38:40,160 --> 25:38:42,160
constructor and we're going to put in

38673
25:38:42,160 --> 25:38:44,000
our scope resolution operator we're

38674
25:38:44,000 --> 25:38:46,000
going to say engineer and we're going to

38675
25:38:46,000 --> 25:38:48,480
put in our body let's go below and put

38676
25:38:48,480 --> 25:38:50,720
that in if we do things like this this

38677
25:38:50,720 --> 25:38:53,440
is just going to initialize our engineer

38678
25:38:53,440 --> 25:38:55,912
with junk data we don't want that but

38679
25:38:55,912 --> 25:38:58,480
some of you might say uh-huh i don't

38680
25:38:58,480 --> 25:39:01,680
know how to call my base constructor but

38681
25:39:01,680 --> 25:39:04,960
at least i can initialize my contract

38682
25:39:04,960 --> 25:39:07,360
count okay let's go back and see if we

38683
25:39:07,360 --> 25:39:09,600
have this member variable here yes it is

38684
25:39:09,600 --> 25:39:12,080
called contract count we can say

38685
25:39:12,080 --> 25:39:14,552
contract count here and we are going to

38686
25:39:14,552 --> 25:39:17,120
initialize this with source contract

38687
25:39:17,120 --> 25:39:19,280
count this is going to work but this is

38688
25:39:19,280 --> 25:39:21,760
going to call the default constructor of

38689
25:39:21,760 --> 25:39:24,400
person to initialize the person part of

38690
25:39:24,400 --> 25:39:27,600
us and let's go back in our main cpp

38691
25:39:27,600 --> 25:39:30,160
file and see what we are using to try

38692
25:39:30,160 --> 25:39:32,232
things out we are building an engineer

38693
25:39:32,232 --> 25:39:34,872
object from another let's try this out

38694
25:39:34,872 --> 25:39:37,512
and see if our copy constructor is

38695
25:39:37,512 --> 25:39:40,000
called here so we're going to say custom

38696
25:39:40,000 --> 25:39:42,800
copy constructor called for engineer

38697
25:39:42,800 --> 25:39:44,720
we're going to put in the message and

38698
25:39:44,720 --> 25:39:46,552
we're going to say custom copy

38699
25:39:46,552 --> 25:39:49,120
constructor and we're going to build our

38700
25:39:49,120 --> 25:39:51,760
code let's build we're going to pass

38701
25:39:51,760 --> 25:39:54,640
this through gcc to see what happens the

38702
25:39:54,640 --> 25:39:57,040
build is going to be good and let's see

38703
25:39:57,040 --> 25:39:58,872
what happens we're going to clear and

38704
25:39:58,872 --> 25:40:01,440
run rooster we are going to see that the

38705
25:40:01,440 --> 25:40:03,192
constructors are going to be called to

38706
25:40:03,192 --> 25:40:05,120
set up person one

38707
25:40:05,120 --> 25:40:07,760
but we see that the copy constructor for

38708
25:40:07,760 --> 25:40:10,000
engineer is called

38709
25:40:10,000 --> 25:40:11,912
and what i want to do to really make

38710
25:40:11,912 --> 25:40:14,080
this super clear is put a separator

38711
25:40:14,080 --> 25:40:16,320
between these two guys to really know

38712
25:40:16,320 --> 25:40:18,160
what is happening here i am going to put

38713
25:40:18,160 --> 25:40:20,400
in a bunch of dashes just like this i am

38714
25:40:20,400 --> 25:40:22,552
going to put in my new line character

38715
25:40:22,552 --> 25:40:24,400
and i am going to bolt again the bolt is

38716
25:40:24,400 --> 25:40:26,320
going to be good as you see here we can

38717
25:40:26,320 --> 25:40:29,512
clear and run rooster now we are going

38718
25:40:29,512 --> 25:40:31,680
to see that the default constructor for

38719
25:40:31,680 --> 25:40:34,320
person was called to set up the person

38720
25:40:34,320 --> 25:40:37,512
part of us in our engineer copy

38721
25:40:37,512 --> 25:40:40,640
constructor and the reason is we are not

38722
25:40:40,640 --> 25:40:43,600
doing anything to call the custom copy

38723
25:40:43,600 --> 25:40:46,400
constructor from person

38724
25:40:46,400 --> 25:40:48,160
and let's go back in person and make

38725
25:40:48,160 --> 25:40:50,872
sure we are printing proper information

38726
25:40:50,872 --> 25:40:52,400
to really see this

38727
25:40:52,400 --> 25:40:54,640
when we get to do this right we are not

38728
25:40:54,640 --> 25:40:57,280
putting in any message here so we should

38729
25:40:57,280 --> 25:40:59,680
do that we are going to say custom

38730
25:40:59,680 --> 25:41:02,552
constructor or custom copy constructor

38731
25:41:02,552 --> 25:41:05,280
called for person but this is not called

38732
25:41:05,280 --> 25:41:07,040
you see that we are calling the default

38733
25:41:07,040 --> 25:41:08,960
constructor and this is going to

38734
25:41:08,960 --> 25:41:12,080
initialize our person part with junk

38735
25:41:12,080 --> 25:41:14,232
data if we print engineer two here

38736
25:41:14,232 --> 25:41:15,600
you're going to see that the full name

38737
25:41:15,600 --> 25:41:18,160
is none the edge is zero and the address

38738
25:41:18,160 --> 25:41:21,040
is none so we are basically getting the

38739
25:41:21,040 --> 25:41:24,000
default data we have in our person

38740
25:41:24,000 --> 25:41:25,912
object let's go back and really show you

38741
25:41:25,912 --> 25:41:27,192
that the

38742
25:41:27,192 --> 25:41:29,440
default full name is going to be none

38743
25:41:29,440 --> 25:41:31,280
the default address is going to be none

38744
25:41:31,280 --> 25:41:33,360
of the edge is going to be 0 by default

38745
25:41:33,360 --> 25:41:36,400
and this is what we get because in our

38746
25:41:36,400 --> 25:41:38,872
copy constructor we're not doing

38747
25:41:38,872 --> 25:41:42,160
anything to get our customer constructor

38748
25:41:42,160 --> 25:41:44,720
in person to be called okay so this is

38749
25:41:44,720 --> 25:41:46,720
not going to work this is bad we don't

38750
25:41:46,720 --> 25:41:49,360
want to do something like this but let's

38751
25:41:49,360 --> 25:41:51,120
comment this out and show you another

38752
25:41:51,120 --> 25:41:53,832
way we might try to do things and we are

38753
25:41:53,832 --> 25:41:56,320
going to copy our copy constructor let's

38754
25:41:56,320 --> 25:41:58,080
go down and do this we're going to put

38755
25:41:58,080 --> 25:42:00,232
in another copy of this but we don't

38756
25:42:00,232 --> 25:42:03,040
want to just initialize our contract

38757
25:42:03,040 --> 25:42:04,800
count member variable

38758
25:42:04,800 --> 25:42:07,120
instead we want to do something else

38759
25:42:07,120 --> 25:42:09,120
we're going to put a comma here and

38760
25:42:09,120 --> 25:42:11,120
we're going to say person some of you

38761
25:42:11,120 --> 25:42:13,120
might be thinking what if we call the

38762
25:42:13,120 --> 25:42:16,000
base constructor directly we can do

38763
25:42:16,000 --> 25:42:17,832
something like this we can say person

38764
25:42:17,832 --> 25:42:20,960
and we can say source m full name we can

38765
25:42:20,960 --> 25:42:24,320
do that we can say source mh and some of

38766
25:42:24,320 --> 25:42:27,120
you are going to say source m address

38767
25:42:27,120 --> 25:42:29,912
let's do that source m address and we're

38768
25:42:29,912 --> 25:42:32,160
going to build the person object and use

38769
25:42:32,160 --> 25:42:35,360
that to initialize the person part of us

38770
25:42:35,360 --> 25:42:37,832
we are basically going to be calling the

38771
25:42:37,832 --> 25:42:40,720
other person constructor that we have

38772
25:42:40,720 --> 25:42:42,800
which takes three parameters this

38773
25:42:42,800 --> 25:42:44,872
constructor here this is what we are

38774
25:42:44,872 --> 25:42:46,320
trying to call

38775
25:42:46,320 --> 25:42:49,512
in our copy constructor but as we saw in

38776
25:42:49,512 --> 25:42:51,192
the slides this is going to have a bunch

38777
25:42:51,192 --> 25:42:53,192
of problems this is going to be creating

38778
25:42:53,192 --> 25:42:55,760
a temporary person object that we are

38779
25:42:55,760 --> 25:42:57,760
going to be copying from to set up the

38780
25:42:57,760 --> 25:43:00,080
person part of us but another problem we

38781
25:43:00,080 --> 25:43:01,600
have which is actually going to cause a

38782
25:43:01,600 --> 25:43:03,832
compiler error is that we don't have

38783
25:43:03,832 --> 25:43:06,320
access to the m address member variable

38784
25:43:06,320 --> 25:43:08,552
from an engineer constructor and this is

38785
25:43:08,552 --> 25:43:10,232
going to give us a compiler error let's

38786
25:43:10,232 --> 25:43:12,640
actually try and compile this program to

38787
25:43:12,640 --> 25:43:14,400
really show you this we are learning we

38788
25:43:14,400 --> 25:43:15,912
should really see

38789
25:43:15,912 --> 25:43:19,280
as many compiler errors as we can so the

38790
25:43:19,280 --> 25:43:21,912
world is finished with errors and if we

38791
25:43:21,912 --> 25:43:24,400
go up we're going to see that our error

38792
25:43:24,400 --> 25:43:27,440
is the m address member variable is

38793
25:43:27,440 --> 25:43:30,000
private to the person class and we have

38794
25:43:30,000 --> 25:43:32,640
no business accessing that in the

38795
25:43:32,640 --> 25:43:35,832
engineer cpp file at line 27 in our

38796
25:43:35,832 --> 25:43:38,552
constructor here and this is going to be

38797
25:43:38,552 --> 25:43:41,440
our offending line we can't do this one

38798
25:43:41,440 --> 25:43:44,000
could go in our person class and set up

38799
25:43:44,000 --> 25:43:46,000
a public getter method which is going to

38800
25:43:46,000 --> 25:43:48,960
be inherited by engineer and we could

38801
25:43:48,960 --> 25:43:50,872
call that to return the address let's

38802
25:43:50,872 --> 25:43:53,120
actually do that to show you that you

38803
25:43:53,120 --> 25:43:54,480
can do that

38804
25:43:54,480 --> 25:43:58,000
so we are going to go in and put in a

38805
25:43:58,000 --> 25:43:59,760
public method which is going to return

38806
25:43:59,760 --> 25:44:02,080
the address we actually have that here

38807
25:44:02,080 --> 25:44:04,480
so we can call that we can say

38808
25:44:04,480 --> 25:44:06,800
source get address this is going to work

38809
25:44:06,800 --> 25:44:09,120
this is going to set up our thumb

38810
25:44:09,120 --> 25:44:11,600
let's try to build because i think a

38811
25:44:11,600 --> 25:44:13,680
visual studio code is messing with us

38812
25:44:13,680 --> 25:44:15,912
here okay you see the both is good it is

38813
25:44:15,912 --> 25:44:18,160
visual studio code which wasn't

38814
25:44:18,160 --> 25:44:20,800
understanding our code here and if we

38815
25:44:20,800 --> 25:44:22,400
run our program we're going to see that

38816
25:44:22,400 --> 25:44:24,400
things are going to work exactly as we

38817
25:44:24,400 --> 25:44:26,232
expect let's actually

38818
25:44:26,232 --> 25:44:27,760
run the program here we're going to

38819
25:44:27,760 --> 25:44:30,320
clear and run rooster we're going to see

38820
25:44:30,320 --> 25:44:32,232
that now the information is being

38821
25:44:32,232 --> 25:44:34,960
forwarded properly but we are setting up

38822
25:44:34,960 --> 25:44:37,912
a temporary person copy which we are

38823
25:44:37,912 --> 25:44:39,440
copying from

38824
25:44:39,440 --> 25:44:42,080
to then forward the data to the person

38825
25:44:42,080 --> 25:44:45,512
part of us this is not good design and

38826
25:44:45,512 --> 25:44:47,680
what we really want is the setup that is

38827
25:44:47,680 --> 25:44:50,320
going to allow us to call the copy

38828
25:44:50,320 --> 25:44:53,120
constructor that we worked hard to set

38829
25:44:53,120 --> 25:44:55,512
up in our base class here let's go back

38830
25:44:55,512 --> 25:44:57,760
to person and see that if we go up we're

38831
25:44:57,760 --> 25:44:59,600
going to see that we have a copy

38832
25:44:59,600 --> 25:45:01,760
constructor we really worked hard to set

38833
25:45:01,760 --> 25:45:04,160
up we wanted to reuse this in our

38834
25:45:04,160 --> 25:45:06,640
engineer class and that's what we're

38835
25:45:06,640 --> 25:45:09,280
going to see here so this is working but

38836
25:45:09,280 --> 25:45:11,280
it is not optimal

38837
25:45:11,280 --> 25:45:14,000
and we should really try to reuse our

38838
25:45:14,000 --> 25:45:16,552
code as much as we can so what we're

38839
25:45:16,552 --> 25:45:19,512
going to do is set up a mechanism that

38840
25:45:19,512 --> 25:45:21,600
is going to reuse the copy constructor

38841
25:45:21,600 --> 25:45:24,400
we have in person and all we need to do

38842
25:45:24,400 --> 25:45:26,960
to get that to work we can say person

38843
25:45:26,960 --> 25:45:29,192
and then call the copy constructor of

38844
25:45:29,192 --> 25:45:32,320
person by directly passing in our source

38845
25:45:32,320 --> 25:45:35,040
object notice that we don't need to set

38846
25:45:35,040 --> 25:45:37,440
up a temporary person object we will

38847
25:45:37,440 --> 25:45:40,080
directly be copying from our engineer

38848
25:45:40,080 --> 25:45:42,320
object but this is going to do the

38849
25:45:42,320 --> 25:45:45,440
slicing we saw in the slides again if we

38850
25:45:45,440 --> 25:45:48,640
have two layers on our object the inner

38851
25:45:48,640 --> 25:45:50,800
layer is going to be the person part of

38852
25:45:50,800 --> 25:45:54,232
us and the outer green layer is going to

38853
25:45:54,232 --> 25:45:55,192
be

38854
25:45:55,192 --> 25:45:57,512
the engineer part of us

38855
25:45:57,512 --> 25:45:59,440
what the compiler is going to do the

38856
25:45:59,440 --> 25:46:01,120
compiler is going to see that we are

38857
25:46:01,120 --> 25:46:02,960
actually passing again

38858
25:46:02,960 --> 25:46:03,680
an

38859
25:46:03,680 --> 25:46:07,120
engineer object to initialize the person

38860
25:46:07,120 --> 25:46:08,960
part of us here and it is going to say

38861
25:46:08,960 --> 25:46:11,440
that we just need the red part we don't

38862
25:46:11,440 --> 25:46:13,832
need the green part here the compiler is

38863
25:46:13,832 --> 25:46:16,232
really smart so it is going to slice off

38864
25:46:16,232 --> 25:46:18,720
the outer engineer layer

38865
25:46:18,720 --> 25:46:20,640
and only leaving

38866
25:46:20,640 --> 25:46:21,832
the green

38867
25:46:21,832 --> 25:46:24,160
person part and it is going to use that

38868
25:46:24,160 --> 25:46:26,720
to initialize the person part of our

38869
25:46:26,720 --> 25:46:29,680
engineer object and this will be reusing

38870
25:46:29,680 --> 25:46:33,912
the copy constructor we have in our

38871
25:46:33,912 --> 25:46:35,760
person object then this is really cool

38872
25:46:35,760 --> 25:46:38,800
this is the optimal way to set up your

38873
25:46:38,800 --> 25:46:41,360
copical structures if you have an

38874
25:46:41,360 --> 25:46:44,232
inheritance hierarchy so let's try and

38875
25:46:44,232 --> 25:46:46,000
build the code again we're going to pass

38876
25:46:46,000 --> 25:46:48,720
this through gcc to see if this actually

38877
25:46:48,720 --> 25:46:50,480
works the bullet is going to be good we

38878
25:46:50,480 --> 25:46:52,720
can clear and run rooster we're going to

38879
25:46:52,720 --> 25:46:54,552
see that the copy constructor is going

38880
25:46:54,552 --> 25:46:56,872
to be called for person to set up the

38881
25:46:56,872 --> 25:46:59,440
person part of us and then the custom

38882
25:46:59,440 --> 25:47:01,280
copy constructor for engineer is going

38883
25:47:01,280 --> 25:47:03,600
to be called to set up the engineer part

38884
25:47:03,600 --> 25:47:06,320
of us and if we look at the information

38885
25:47:06,320 --> 25:47:08,480
we have in the main function you're

38886
25:47:08,480 --> 25:47:10,232
going to see that it is the same data

38887
25:47:10,232 --> 25:47:13,360
daniel gray for the full name ages 41

38888
25:47:13,360 --> 25:47:16,080
address is this gibberish here and the

38889
25:47:16,080 --> 25:47:18,552
contract count is 12 it is exactly what

38890
25:47:18,552 --> 25:47:21,280
we passed here and our copy constructor

38891
25:47:21,280 --> 25:47:23,680
is working now that we have this working

38892
25:47:23,680 --> 25:47:27,040
we can safely reuse the same ideas

38893
25:47:27,040 --> 25:47:30,720
in our civil engineer copy constructor

38894
25:47:30,720 --> 25:47:33,680
we can head over in our civil engineer

38895
25:47:33,680 --> 25:47:35,440
and set up the copy constructor so let's

38896
25:47:35,440 --> 25:47:37,440
do that we can

38897
25:47:37,440 --> 25:47:39,760
close the left sidebar here so that we

38898
25:47:39,760 --> 25:47:43,192
see the entire thing we are going to say

38899
25:47:43,192 --> 25:47:46,160
civil engineer and we want to set up a

38900
25:47:46,160 --> 25:47:47,912
copy constructor so we're going to say

38901
25:47:47,912 --> 25:47:51,040
cast civil engineer here and we will be

38902
25:47:51,040 --> 25:47:53,192
passing this by reference we're going to

38903
25:47:53,192 --> 25:47:55,912
say source and we're going to put the

38904
25:47:55,912 --> 25:47:59,360
implementation of this in our cpp file

38905
25:47:59,360 --> 25:48:02,400
we can hop over there and go below our

38906
25:48:02,400 --> 25:48:05,360
custom constructor we can put in our

38907
25:48:05,360 --> 25:48:06,720
constructor here we're going to say

38908
25:48:06,720 --> 25:48:09,192
civil engineer and put in our scope

38909
25:48:09,192 --> 25:48:11,040
resolution operator and we're going to

38910
25:48:11,040 --> 25:48:14,232
go down and put in the body and in our

38911
25:48:14,232 --> 25:48:16,160
initializer list we're going to call the

38912
25:48:16,160 --> 25:48:18,720
copy constructor from engineer because

38913
25:48:18,720 --> 25:48:21,760
remember civil engineer is inheriting

38914
25:48:21,760 --> 25:48:24,232
from the engineer class so we are going

38915
25:48:24,232 --> 25:48:27,040
to call the engineer copy constructor

38916
25:48:27,040 --> 25:48:29,360
we're going to pass in source and again

38917
25:48:29,360 --> 25:48:31,440
this is going to slice off the civil

38918
25:48:31,440 --> 25:48:35,040
engineer port and only use the engineer

38919
25:48:35,040 --> 25:48:37,760
part of us to construct an engineer

38920
25:48:37,760 --> 25:48:41,280
object from this sliced of engineer

38921
25:48:41,280 --> 25:48:44,160
object we get from our copy constructor

38922
25:48:44,160 --> 25:48:46,160
here and this is really cool after that

38923
25:48:46,160 --> 25:48:49,760
we will initialize our contract count

38924
25:48:49,760 --> 25:48:52,872
member variable oh it is m speciality if

38925
25:48:52,872 --> 25:48:55,280
i remember correctly and we're going to

38926
25:48:55,280 --> 25:48:58,640
grab a source m speciality and we will

38927
25:48:58,640 --> 25:49:01,280
use that to initialize the civil

38928
25:49:01,280 --> 25:49:04,400
engineer part of us here let's go in and

38929
25:49:04,400 --> 25:49:06,960
say that the custom copy constructor is

38930
25:49:06,960 --> 25:49:09,192
being called here and we're going to say

38931
25:49:09,192 --> 25:49:11,600
custom copy constructor called for a

38932
25:49:11,600 --> 25:49:14,320
civil engineer what did we do here we

38933
25:49:14,320 --> 25:49:18,000
said engineer let's do engineer this is

38934
25:49:18,000 --> 25:49:20,080
what we want and we're going to say

38935
25:49:20,080 --> 25:49:23,360
engineer here properly sorry for this

38936
25:49:23,360 --> 25:49:25,912
but this is no big deal and now that we

38937
25:49:25,912 --> 25:49:28,232
have this in place we can actually build

38938
25:49:28,232 --> 25:49:30,960
civil engineer objects and copy

38939
25:49:30,960 --> 25:49:32,800
constructed them we can

38940
25:49:32,800 --> 25:49:34,800
comment out the engineering stuff we

38941
25:49:34,800 --> 25:49:37,832
have and we can just put this in a black

38942
25:49:37,832 --> 25:49:39,680
comment and we're going to copy

38943
25:49:39,680 --> 25:49:42,480
construct civil engineers how cool is

38944
25:49:42,480 --> 25:49:44,552
that we're going to set up a civil

38945
25:49:44,552 --> 25:49:46,872
engineer let's do that

38946
25:49:46,872 --> 25:49:49,680
and this is going to be a civil engineer

38947
25:49:49,680 --> 25:49:51,440
and we're going to say daniel gray we're

38948
25:49:51,440 --> 25:49:53,040
going to put in all the data and we're

38949
25:49:53,040 --> 25:49:55,440
going to specify the speciality to be

38950
25:49:55,440 --> 25:49:57,360
road strength this is something i just

38951
25:49:57,360 --> 25:49:59,280
made up i don't even know

38952
25:49:59,280 --> 25:50:02,640
if this kind of speciality exists and we

38953
25:50:02,640 --> 25:50:04,552
will set up another civil engineer

38954
25:50:04,552 --> 25:50:07,832
object called n2 which we are going to

38955
25:50:07,832 --> 25:50:10,320
be copy constructing from and we will

38956
25:50:10,320 --> 25:50:13,192
see what happens when we copy construct

38957
25:50:13,192 --> 25:50:15,680
this thing here we should call our copy

38958
25:50:15,680 --> 25:50:18,400
constructor in civil engineer and the

38959
25:50:18,400 --> 25:50:21,440
things should propagate up all the way

38960
25:50:21,440 --> 25:50:23,280
to the person part of us and we're going

38961
25:50:23,280 --> 25:50:25,760
to see what happens let's build this

38962
25:50:25,760 --> 25:50:27,680
code we're going to pass this through

38963
25:50:27,680 --> 25:50:30,640
gcc as we always do the budget is going

38964
25:50:30,640 --> 25:50:32,720
to be good so this is good news we're

38965
25:50:32,720 --> 25:50:35,040
going to clear and run rooster and we're

38966
25:50:35,040 --> 25:50:36,552
going to see that the custom copy

38967
25:50:36,552 --> 25:50:38,720
constructor is called for person the

38968
25:50:38,720 --> 25:50:40,400
custom copy constructor is going to be

38969
25:50:40,400 --> 25:50:43,120
called for engineer and the custom copy

38970
25:50:43,120 --> 25:50:44,720
constructor is going to be called full

38971
25:50:44,720 --> 25:50:47,040
civil engineer and you see that things

38972
25:50:47,040 --> 25:50:49,192
are really propagating all the way to

38973
25:50:49,192 --> 25:50:51,440
the person part and we are calling and

38974
25:50:51,440 --> 25:50:53,680
reusing our copy constructors and this

38975
25:50:53,680 --> 25:50:55,360
is really cool if you go down you're

38976
25:50:55,360 --> 25:50:57,120
going to see that the information is

38977
25:50:57,120 --> 25:50:59,680
printed out correctly the full name is

38978
25:50:59,680 --> 25:51:02,080
daniel gray which we have in engineer

38979
25:51:02,080 --> 25:51:05,120
one the age is 41 the address is all

38980
25:51:05,120 --> 25:51:08,080
this gibberish the contract count is 12

38981
25:51:08,080 --> 25:51:10,960
and the speciality is road strength and

38982
25:51:10,960 --> 25:51:12,080
we are

38983
25:51:12,080 --> 25:51:15,192
properly reusing our copy constructors

38984
25:51:15,192 --> 25:51:18,080
in our inheritance hierarchy this is

38985
25:51:18,080 --> 25:51:19,912
really all i had to share in this

38986
25:51:19,912 --> 25:51:21,912
lecture again the syntax you should be

38987
25:51:21,912 --> 25:51:24,720
using to set up your copy constructors

38988
25:51:24,720 --> 25:51:26,960
is what we see here this is going to be

38989
25:51:26,960 --> 25:51:30,480
reusing the code we have in our upper

38990
25:51:30,480 --> 25:51:33,360
classes in our hierarchy we will be

38991
25:51:33,360 --> 25:51:35,760
avoiding the temporary copies we saw

38992
25:51:35,760 --> 25:51:37,832
when we called the other constructor

38993
25:51:37,832 --> 25:51:40,400
directly and this is much cleaner it is

38994
25:51:40,400 --> 25:51:43,360
reusing code we have in other classes we

38995
25:51:43,360 --> 25:51:45,512
are going to stop here in this lecture

38996
25:51:45,512 --> 25:51:47,120
in the next one we're going to see that

38997
25:51:47,120 --> 25:51:50,160
it is actually possible to inherit base

38998
25:51:50,160 --> 25:51:52,872
constructors go ahead and finish up here

38999
25:51:52,872 --> 25:51:55,120
and meet me there in this lecture we're

39000
25:51:55,120 --> 25:51:57,760
going to explore the fact that we can

39001
25:51:57,760 --> 25:52:00,872
inherit base constructors and use them

39002
25:52:00,872 --> 25:52:03,512
in our derived classes we will build

39003
25:52:03,512 --> 25:52:05,360
we're using the same hierarchy we have

39004
25:52:05,360 --> 25:52:07,440
been using so we will have the person

39005
25:52:07,440 --> 25:52:09,832
class and we will be inheriting from

39006
25:52:09,832 --> 25:52:12,480
this person to create an engineer class

39007
25:52:12,480 --> 25:52:14,160
and that's what we're going to be using

39008
25:52:14,160 --> 25:52:17,280
to learn about this concept here so the

39009
25:52:17,280 --> 25:52:20,160
personal class is what we know from the

39010
25:52:20,160 --> 25:52:22,720
previous lectures we have a bunch of

39011
25:52:22,720 --> 25:52:25,120
member variables here we have the full

39012
25:52:25,120 --> 25:52:27,680
name the age and the address and we have

39013
25:52:27,680 --> 25:52:29,832
a bunch of constructors now we have a

39014
25:52:29,832 --> 25:52:32,640
default constructor a custom constructor

39015
25:52:32,640 --> 25:52:35,440
and a copy constructor that we set up

39016
25:52:35,440 --> 25:52:38,320
tirelessly in the last lecture now what

39017
25:52:38,320 --> 25:52:40,800
do we mean when we say that we can

39018
25:52:40,800 --> 25:52:42,960
inherit a constructor well based

39019
25:52:42,960 --> 25:52:45,280
constructors are not inherited by

39020
25:52:45,280 --> 25:52:48,160
default and what we mean by that is that

39021
25:52:48,160 --> 25:52:51,512
by default it is really not possible

39022
25:52:51,512 --> 25:52:54,872
to get derived classes to use base

39023
25:52:54,872 --> 25:52:58,000
constructors to set up things but it is

39024
25:52:58,000 --> 25:53:00,232
possible to tell the compiler to use the

39025
25:53:00,232 --> 25:53:03,832
base constructor to set up our own

39026
25:53:03,832 --> 25:53:06,800
objects for example we can put our

39027
25:53:06,800 --> 25:53:08,800
statement here saying

39028
25:53:08,800 --> 25:53:12,160
using person column column person this

39029
25:53:12,160 --> 25:53:14,400
is going to tell the compiler when

39030
25:53:14,400 --> 25:53:17,600
welding engineer objects don't use your

39031
25:53:17,600 --> 25:53:20,400
own constructor set up a base like a

39032
25:53:20,400 --> 25:53:22,400
constructor which is going to only

39033
25:53:22,400 --> 25:53:25,760
initialize the base member variables and

39034
25:53:25,760 --> 25:53:27,360
the compiler is going to see this

39035
25:53:27,360 --> 25:53:30,000
statement and it is going to generate a

39036
25:53:30,000 --> 25:53:32,720
constructor for you that looks something

39037
25:53:32,720 --> 25:53:35,040
like this so it is going to be engineer

39038
25:53:35,040 --> 25:53:36,720
it is going to be taking in the full

39039
25:53:36,720 --> 25:53:39,360
name the age and the address and it is

39040
25:53:39,360 --> 25:53:41,280
going to be forwarding the work to

39041
25:53:41,280 --> 25:53:44,320
initialize your object to the person

39042
25:53:44,320 --> 25:53:46,720
class and this is all this constructor

39043
25:53:46,720 --> 25:53:48,872
is going to do hopefully you can see

39044
25:53:48,872 --> 25:53:51,512
that this is called inheriting a base

39045
25:53:51,512 --> 25:53:53,912
constructor because all this constructor

39046
25:53:53,912 --> 25:53:57,192
is really doing is initializing the base

39047
25:53:57,192 --> 25:54:00,000
member variables it's not initializing

39048
25:54:00,000 --> 25:54:03,120
any member variable that belongs to the

39049
25:54:03,120 --> 25:54:05,680
engineer class so the engineer part of

39050
25:54:05,680 --> 25:54:07,360
us is going to be basically empty

39051
25:54:07,360 --> 25:54:10,480
containing junk data that we get by just

39052
25:54:10,480 --> 25:54:12,960
calling the default constructor and we

39053
25:54:12,960 --> 25:54:15,760
will only be initializing the data

39054
25:54:15,760 --> 25:54:18,480
belonging to the person part of us this

39055
25:54:18,480 --> 25:54:20,960
is really what i want you to see again

39056
25:54:20,960 --> 25:54:23,760
the syntax is what we see here

39057
25:54:23,760 --> 25:54:25,440
this is going to tell the compiler to

39058
25:54:25,440 --> 25:54:27,440
generate a constructor that is only

39059
25:54:27,440 --> 25:54:30,232
going to initialize the base member

39060
25:54:30,232 --> 25:54:32,640
variables but this constructor will be

39061
25:54:32,640 --> 25:54:36,232
callable and usable from the engineer

39062
25:54:36,232 --> 25:54:37,192
class

39063
25:54:37,192 --> 25:54:39,512
okay so this is really what we mean

39064
25:54:39,512 --> 25:54:43,192
by inheriting constructors one thing you

39065
25:54:43,192 --> 25:54:45,120
should know is that the constructor is

39066
25:54:45,120 --> 25:54:47,192
going to be inherited with whatever

39067
25:54:47,192 --> 25:54:48,232
access

39068
25:54:48,232 --> 25:54:51,440
specifier it had in the base class so if

39069
25:54:51,440 --> 25:54:54,080
our constructor was in the public scope

39070
25:54:54,080 --> 25:54:56,000
it's going to be inherited with public

39071
25:54:56,000 --> 25:54:58,480
access so we will be able to use it from

39072
25:54:58,480 --> 25:55:01,280
the outside and world engineer objects

39073
25:55:01,280 --> 25:55:03,360
if it was in a protected scope we want

39074
25:55:03,360 --> 25:55:05,760
to be able to use it from the outside if

39075
25:55:05,760 --> 25:55:08,080
it was private we won't even be able to

39076
25:55:08,080 --> 25:55:10,160
use it from a derived class you should

39077
25:55:10,160 --> 25:55:12,400
really know that so it is going to be

39078
25:55:12,400 --> 25:55:15,280
inherited with whatever access specifier

39079
25:55:15,280 --> 25:55:18,640
we had in our base class now that we

39080
25:55:18,640 --> 25:55:20,872
know this let's see some things you

39081
25:55:20,872 --> 25:55:23,280
should really be careful about the first

39082
25:55:23,280 --> 25:55:25,760
is that copy constructors are not

39083
25:55:25,760 --> 25:55:28,232
inheritable if you try to do that you're

39084
25:55:28,232 --> 25:55:30,320
going to get a compiler error but you

39085
25:55:30,320 --> 25:55:32,400
won't usually notice this because the

39086
25:55:32,400 --> 25:55:34,400
compiler is going to insert copy

39087
25:55:34,400 --> 25:55:36,400
constructors for you anyway this is

39088
25:55:36,400 --> 25:55:38,160
going to become a problem if you are

39089
25:55:38,160 --> 25:55:40,960
doing some dynamic memory allocation and

39090
25:55:40,960 --> 25:55:42,960
you're going to get pointers copied this

39091
25:55:42,960 --> 25:55:44,960
is really bad if you don't know about

39092
25:55:44,960 --> 25:55:47,040
this please go back to the chapter on

39093
25:55:47,040 --> 25:55:49,360
classes and you're going to see all the

39094
25:55:49,360 --> 25:55:51,760
story about shallow copying and deep

39095
25:55:51,760 --> 25:55:53,912
copying we talked about these things

39096
25:55:53,912 --> 25:55:55,912
another thing you should know is that

39097
25:55:55,912 --> 25:55:58,160
inherited constructors are really based

39098
25:55:58,160 --> 25:56:00,400
constructors and what we mean by this is

39099
25:56:00,400 --> 25:56:03,512
that they will only be initializing the

39100
25:56:03,512 --> 25:56:05,912
base member variables because they are

39101
25:56:05,912 --> 25:56:07,912
based constructors they have no

39102
25:56:07,912 --> 25:56:10,400
knowledge of derived member variables

39103
25:56:10,400 --> 25:56:12,800
that's why they only initialize base

39104
25:56:12,800 --> 25:56:14,960
member variables again as we said the

39105
25:56:14,960 --> 25:56:17,280
constructors are inherited with whatever

39106
25:56:17,280 --> 25:56:19,512
access specifier they had in the base

39107
25:56:19,512 --> 25:56:21,680
class and it is possible to set up your

39108
25:56:21,680 --> 25:56:25,280
own constructors on top of the inherited

39109
25:56:25,280 --> 25:56:27,192
constructors and you can use these

39110
25:56:27,192 --> 25:56:28,872
things another thing i should really

39111
25:56:28,872 --> 25:56:30,552
tell you is that inheritance

39112
25:56:30,552 --> 25:56:32,720
constructors is going to make your code

39113
25:56:32,720 --> 25:56:34,960
really confusing it is a technical

39114
25:56:34,960 --> 25:56:37,600
possibility but i strongly advise

39115
25:56:37,600 --> 25:56:40,000
against using this in your code because

39116
25:56:40,000 --> 25:56:41,912
it is just going to confuse people

39117
25:56:41,912 --> 25:56:43,600
people are going to see for example an

39118
25:56:43,600 --> 25:56:45,600
engineer constructor and they are going

39119
25:56:45,600 --> 25:56:47,912
to think that that constructor is going

39120
25:56:47,912 --> 25:56:50,552
to even initializing the engineer member

39121
25:56:50,552 --> 25:56:52,872
variables but it's not going to do that

39122
25:56:52,872 --> 25:56:55,280
because it is a base constructor it's

39123
25:56:55,280 --> 25:56:57,600
only going to be initializing the base

39124
25:56:57,600 --> 25:56:59,832
member variables and that may lead to

39125
25:56:59,832 --> 25:57:02,160
some confusion or even really bad

39126
25:57:02,160 --> 25:57:04,552
problems in your code so don't use this

39127
25:57:04,552 --> 25:57:06,000
it is just going to make things

39128
25:57:06,000 --> 25:57:08,552
confusing but i wanted you to be aware

39129
25:57:08,552 --> 25:57:11,280
of this and if you see this kind of

39130
25:57:11,280 --> 25:57:14,232
setup in classes out there you will know

39131
25:57:14,232 --> 25:57:16,160
what they mean this is just going to

39132
25:57:16,160 --> 25:57:18,720
inherit a base constructor and use it to

39133
25:57:18,720 --> 25:57:20,872
build objects now that we know this

39134
25:57:20,872 --> 25:57:22,320
we're going to head over to visual

39135
25:57:22,320 --> 25:57:23,912
studio code and play with us a little

39136
25:57:23,912 --> 25:57:26,960
more here we are in our working folder

39137
25:57:26,960 --> 25:57:30,232
the current project is inheriting based

39138
25:57:30,232 --> 25:57:33,120
constructors we are going to steal code

39139
25:57:33,120 --> 25:57:35,440
from the last lecture and we will be

39140
25:57:35,440 --> 25:57:38,400
using the main cpp file the person class

39141
25:57:38,400 --> 25:57:40,800
and the engineer class this is just

39142
25:57:40,800 --> 25:57:43,512
going to be enough for our purposes here

39143
25:57:43,512 --> 25:57:45,512
we're going to go back in our current

39144
25:57:45,512 --> 25:57:48,320
project and we're going to put this in

39145
25:57:48,320 --> 25:57:50,480
and we will open this in visual studio

39146
25:57:50,480 --> 25:57:52,552
code by dragging and dropping here this

39147
25:57:52,552 --> 25:57:54,552
is going to give us our thumb

39148
25:57:54,552 --> 25:57:56,800
and let's go to person and see that we

39149
25:57:56,800 --> 25:57:59,512
have our constructors and we have a

39150
25:57:59,512 --> 25:58:01,360
default constructor we have a custom

39151
25:58:01,360 --> 25:58:03,512
constructor and we have a copy

39152
25:58:03,512 --> 25:58:05,512
constructor one thing you should know is

39153
25:58:05,512 --> 25:58:08,400
that copy constructors are not inherited

39154
25:58:08,400 --> 25:58:10,480
so you will need to set up your copy

39155
25:58:10,480 --> 25:58:12,872
constructors explicitly if you want to

39156
25:58:12,872 --> 25:58:14,960
use them know that they want to be

39157
25:58:14,960 --> 25:58:16,800
coming from the upstream class you

39158
25:58:16,800 --> 25:58:18,872
should know that okay so this is the

39159
25:58:18,872 --> 25:58:21,600
message here now let's look at our

39160
25:58:21,600 --> 25:58:23,600
engineer class the engineer class is

39161
25:58:23,600 --> 25:58:26,640
publicly inheriting from person and it

39162
25:58:26,640 --> 25:58:30,000
has a bunch of its own constructors but

39163
25:58:30,000 --> 25:58:32,480
what we want to do is to take out all

39164
25:58:32,480 --> 25:58:35,512
these constructors and we're going to

39165
25:58:35,512 --> 25:58:38,640
take them out i think we can uh yeah

39166
25:58:38,640 --> 25:58:40,320
we're going to take them out let's do

39167
25:58:40,320 --> 25:58:42,640
that and we're going to go in our cpp

39168
25:58:42,640 --> 25:58:44,800
file and also take out all these

39169
25:58:44,800 --> 25:58:46,800
constructors here we're going to comment

39170
25:58:46,800 --> 25:58:48,640
them out i think we can take out all

39171
25:58:48,640 --> 25:58:50,720
these bad code we got from previous

39172
25:58:50,720 --> 25:58:53,040
lectures and we're going to just comment

39173
25:58:53,040 --> 25:58:55,600
out our constructors we're going to

39174
25:58:55,600 --> 25:58:58,720
close them all with a blog comment and

39175
25:58:58,720 --> 25:59:01,832
what we are going to do in our class is

39176
25:59:01,832 --> 25:59:02,720
say

39177
25:59:02,720 --> 25:59:04,640
using person person we're going to say

39178
25:59:04,640 --> 25:59:07,360
using person person this is going to

39179
25:59:07,360 --> 25:59:10,400
inherit the constructors from person and

39180
25:59:10,400 --> 25:59:12,552
now that we have this in place the

39181
25:59:12,552 --> 25:59:14,640
compiler is really going to generate a

39182
25:59:14,640 --> 25:59:17,760
base like constructor in our engineer

39183
25:59:17,760 --> 25:59:19,760
class in other words we're going to have

39184
25:59:19,760 --> 25:59:22,080
a default engineer constructor which is

39185
25:59:22,080 --> 25:59:24,800
just going to not initialize anything we

39186
25:59:24,800 --> 25:59:27,040
are going to have a custom constructor

39187
25:59:27,040 --> 25:59:29,192
which is going to take three parameters

39188
25:59:29,192 --> 25:59:31,040
but it is going to be an engineer

39189
25:59:31,040 --> 25:59:33,040
constructor and let's prove this we're

39190
25:59:33,040 --> 25:59:35,912
going to go in our main cpp file and

39191
25:59:35,912 --> 25:59:37,440
we're going to take out everything we

39192
25:59:37,440 --> 25:59:40,000
have here and we don't have a civil

39193
25:59:40,000 --> 25:59:41,912
engineer file so we shouldn't really

39194
25:59:41,912 --> 25:59:44,080
include that and we are going to create

39195
25:59:44,080 --> 25:59:46,872
an engineer object we can say and one

39196
25:59:46,872 --> 25:59:48,872
using the default constructor we can try

39197
25:59:48,872 --> 25:59:50,320
and print that out and you're going to

39198
25:59:50,320 --> 25:59:53,360
see that this code seems to work in

39199
25:59:53,360 --> 25:59:55,120
visual studio code we can try and build

39200
25:59:55,120 --> 25:59:56,800
this we're going to pass this through

39201
25:59:56,800 --> 26:00:00,000
gcc and we are going to

39202
26:00:00,000 --> 26:00:02,552
set up a powershell window we can use to

39203
26:00:02,552 --> 26:00:04,320
run and see things

39204
26:00:04,320 --> 26:00:06,000
and we're going to see that the default

39205
26:00:06,000 --> 26:00:08,160
constructor for person was called to

39206
26:00:08,160 --> 26:00:10,232
initialize this guy

39207
26:00:10,232 --> 26:00:12,800
and the data is really junk data we have

39208
26:00:12,800 --> 26:00:15,512
in person so what the compiler is really

39209
26:00:15,512 --> 26:00:18,640
doing behind the scenes is to generate a

39210
26:00:18,640 --> 26:00:21,440
bezel-like constructor at the engineer

39211
26:00:21,440 --> 26:00:23,680
level and it is going to call the base

39212
26:00:23,680 --> 26:00:25,680
constructor to initialize the person

39213
26:00:25,680 --> 26:00:28,960
part of us so the data is just going to

39214
26:00:28,960 --> 26:00:31,040
be junk data we have in person and

39215
26:00:31,040 --> 26:00:32,480
you're going to see that the contract

39216
26:00:32,480 --> 26:00:34,552
count is going to be zero this is just a

39217
26:00:34,552 --> 26:00:36,640
default constructor which is just going

39218
26:00:36,640 --> 26:00:38,800
to grab whatever default data we have in

39219
26:00:38,800 --> 26:00:41,280
our object you see the contract count is

39220
26:00:41,280 --> 26:00:43,600
zero if we go back in person we're going

39221
26:00:43,600 --> 26:00:46,400
to see that the full name is none which

39222
26:00:46,400 --> 26:00:48,720
is what we see here the age is zero and

39223
26:00:48,720 --> 26:00:50,800
the address is none this is a default

39224
26:00:50,800 --> 26:00:53,512
constructor but we can even explicitly

39225
26:00:53,512 --> 26:00:55,360
pass in the data and that's going to

39226
26:00:55,360 --> 26:00:57,280
also work so we can pass in the full

39227
26:00:57,280 --> 26:00:58,640
name to be

39228
26:00:58,640 --> 26:01:00,872
daniel gray we can pass in the edge to

39229
26:01:00,872 --> 26:01:03,600
b23 for example and we can pass in a

39230
26:01:03,600 --> 26:01:05,360
junk address let's say something like

39231
26:01:05,360 --> 26:01:07,440
this and you see that this is going to

39232
26:01:07,440 --> 26:01:10,552
work even if we don't have any engineer

39233
26:01:10,552 --> 26:01:11,912
constructor

39234
26:01:11,912 --> 26:01:13,912
that takes three parameters let's go

39235
26:01:13,912 --> 26:01:15,512
back and you're going to see that all

39236
26:01:15,512 --> 26:01:18,800
our constructors are commented out but

39237
26:01:18,800 --> 26:01:20,640
this is working because we told the

39238
26:01:20,640 --> 26:01:23,360
compiler to generate

39239
26:01:23,360 --> 26:01:27,040
a base like constructor for our engineer

39240
26:01:27,040 --> 26:01:30,080
so it is going to also have in

39241
26:01:30,080 --> 26:01:33,192
an engineer constructor that looks like

39242
26:01:33,192 --> 26:01:35,832
this constructor here which takes in

39243
26:01:35,832 --> 26:01:38,400
three parameters and this is really cool

39244
26:01:38,400 --> 26:01:40,552
and this is really crucial to understand

39245
26:01:40,552 --> 26:01:42,080
so again we are going to set up a

39246
26:01:42,080 --> 26:01:44,480
constructor for engineer so it is going

39247
26:01:44,480 --> 26:01:46,640
to be an engineer constructor but it is

39248
26:01:46,640 --> 26:01:49,680
going to be taking three parameters just

39249
26:01:49,680 --> 26:01:51,760
like the person constructor here and

39250
26:01:51,760 --> 26:01:53,760
this is the message i really want to

39251
26:01:53,760 --> 26:01:55,832
convey here so if we run this code

39252
26:01:55,832 --> 26:01:57,192
you're going to see that it is going to

39253
26:01:57,192 --> 26:02:00,000
work it is going to call our baseline

39254
26:02:00,000 --> 26:02:02,232
constructor for engineer and we're going

39255
26:02:02,232 --> 26:02:04,400
to have the data forwarded and but

39256
26:02:04,400 --> 26:02:06,080
you're going to see that the contract

39257
26:02:06,080 --> 26:02:08,232
count is not going to be taken into

39258
26:02:08,232 --> 26:02:10,400
account so it is going to still contain

39259
26:02:10,400 --> 26:02:13,040
some default data if we try and pass

39260
26:02:13,040 --> 26:02:15,120
that in we're going to see that we're

39261
26:02:15,120 --> 26:02:16,872
going to get a compiler error because

39262
26:02:16,872 --> 26:02:19,440
now we have no such constructor that

39263
26:02:19,440 --> 26:02:21,600
takes four parameters the only one we

39264
26:02:21,600 --> 26:02:24,640
have is one that is generated because of

39265
26:02:24,640 --> 26:02:26,872
this statement here and this is going to

39266
26:02:26,872 --> 26:02:29,760
be a baseline constructor which is just

39267
26:02:29,760 --> 26:02:32,640
going to take three parameters just like

39268
26:02:32,640 --> 26:02:34,872
this constructor here and another thing

39269
26:02:34,872 --> 26:02:37,832
i don't think i made clear enough is

39270
26:02:37,832 --> 26:02:39,680
that this is going to bring in all the

39271
26:02:39,680 --> 26:02:41,832
constructors you have notice that we

39272
26:02:41,832 --> 26:02:44,160
just put in this statement but it is

39273
26:02:44,160 --> 26:02:46,480
going to grab all these constructors we

39274
26:02:46,480 --> 26:02:49,760
have except for the copy constructors

39275
26:02:49,760 --> 26:02:52,400
which are not inherited in c plus plus

39276
26:02:52,400 --> 26:02:54,400
so you should really know this if we

39277
26:02:54,400 --> 26:02:55,680
build this code we're going to get a

39278
26:02:55,680 --> 26:02:58,000
compiler error because the compiler

39279
26:02:58,000 --> 26:02:59,280
wants to know

39280
26:02:59,280 --> 26:03:01,912
what to do with the 45 parameter that we

39281
26:03:01,912 --> 26:03:04,080
have here but let's build and really

39282
26:03:04,080 --> 26:03:05,912
show you this you need to see this

39283
26:03:05,912 --> 26:03:08,872
compiler error with your own eyes let's

39284
26:03:08,872 --> 26:03:11,360
go in so the world is finished with

39285
26:03:11,360 --> 26:03:13,832
errors and we have an error saying no

39286
26:03:13,832 --> 26:03:15,440
matching function called to this

39287
26:03:15,440 --> 26:03:18,232
constructor which takes four parameters

39288
26:03:18,232 --> 26:03:19,912
if we take this out we're going to see

39289
26:03:19,912 --> 26:03:21,912
that this is going to work this is going

39290
26:03:21,912 --> 26:03:24,320
to use the compiler generated

39291
26:03:24,320 --> 26:03:25,600
constructor

39292
26:03:25,600 --> 26:03:28,232
as a result of this statement we have in

39293
26:03:28,232 --> 26:03:30,552
our code now if we will we're going to

39294
26:03:30,552 --> 26:03:32,480
see that this is going to work okay the

39295
26:03:32,480 --> 26:03:34,720
build is good can clear and run rooster

39296
26:03:34,720 --> 26:03:36,480
we're going to see that we have the full

39297
26:03:36,480 --> 26:03:39,680
name to be daniel gray we have the h2b23

39298
26:03:39,680 --> 26:03:41,912
we have our address which is really some

39299
26:03:41,912 --> 26:03:44,800
junk data and the contract count has no

39300
26:03:44,800 --> 26:03:47,680
data in it is just the default data we

39301
26:03:47,680 --> 26:03:50,320
have in our member variable here we have

39302
26:03:50,320 --> 26:03:53,040
no way to initialize this from a base

39303
26:03:53,040 --> 26:03:55,680
like a constructor but not everything is

39304
26:03:55,680 --> 26:03:58,000
really bad news if you don't want to be

39305
26:03:58,000 --> 26:04:00,080
limited by the constructors that are

39306
26:04:00,080 --> 26:04:02,640
generated by your compiler as a result

39307
26:04:02,640 --> 26:04:04,872
of inheritance you can set up your own

39308
26:04:04,872 --> 26:04:07,912
constructors for example we can uncover

39309
26:04:07,912 --> 26:04:10,720
our engineer constructor here and bring

39310
26:04:10,720 --> 26:04:12,960
it out of our comment we can do

39311
26:04:12,960 --> 26:04:15,600
something like this we can go in the

39312
26:04:15,600 --> 26:04:18,720
implementation file and also bring this

39313
26:04:18,720 --> 26:04:22,080
out of our comment section and now we

39314
26:04:22,080 --> 26:04:24,080
will be able to use this constructor

39315
26:04:24,080 --> 26:04:25,912
which is going to take the fourth

39316
26:04:25,912 --> 26:04:28,000
parameter here and do something with

39317
26:04:28,000 --> 26:04:31,120
that now if we go back in main the code

39318
26:04:31,120 --> 26:04:32,960
with three parameters is going to work

39319
26:04:32,960 --> 26:04:34,552
it is going to use the compiler

39320
26:04:34,552 --> 26:04:38,232
generated constructor but if we pass the

39321
26:04:38,232 --> 26:04:41,120
contract count to b4 this is also going

39322
26:04:41,120 --> 26:04:43,280
to work because it is going to be using

39323
26:04:43,280 --> 26:04:46,160
our own constructor here if we build the

39324
26:04:46,160 --> 26:04:47,680
code we're going to see that it is going

39325
26:04:47,680 --> 26:04:50,320
to work just fine let's use gcc to show

39326
26:04:50,320 --> 26:04:51,440
this

39327
26:04:51,440 --> 26:04:52,872
you're going to see that the world is

39328
26:04:52,872 --> 26:04:54,800
good we can clear

39329
26:04:54,800 --> 26:04:56,400
and run rooster

39330
26:04:56,400 --> 26:04:59,120
now our contract count is taken into

39331
26:04:59,120 --> 26:05:01,360
account this is really cool this is

39332
26:05:01,360 --> 26:05:03,440
really all i wanted you to see in this

39333
26:05:03,440 --> 26:05:06,080
lecture that you can let the compiler

39334
26:05:06,080 --> 26:05:09,120
generate the baseline constructor using

39335
26:05:09,120 --> 26:05:12,080
the syntax we have in our header here

39336
26:05:12,080 --> 26:05:14,552
this using statement can really show up

39337
26:05:14,552 --> 26:05:17,360
anywhere but it is going to inherit the

39338
26:05:17,360 --> 26:05:19,680
constructor with whatever access

39339
26:05:19,680 --> 26:05:22,480
specifier the constructor had in the

39340
26:05:22,480 --> 26:05:24,720
base class and you should really keep

39341
26:05:24,720 --> 26:05:27,680
these points in mind especially the last

39342
26:05:27,680 --> 26:05:29,192
one that

39343
26:05:29,192 --> 26:05:31,280
inheriting constructors is going to make

39344
26:05:31,280 --> 26:05:34,232
your code confusing people are going to

39345
26:05:34,232 --> 26:05:36,800
notice that they can call constructors

39346
26:05:36,800 --> 26:05:38,400
that are really not going to be

39347
26:05:38,400 --> 26:05:41,192
initializing derived member variables

39348
26:05:41,192 --> 26:05:43,512
and this may cause serious problems in

39349
26:05:43,512 --> 26:05:46,160
your code we are going to stop here in

39350
26:05:46,160 --> 26:05:48,232
this lecture in the next one we're going

39351
26:05:48,232 --> 26:05:51,440
to explore how inheritance works with

39352
26:05:51,440 --> 26:05:53,760
these structures so far we have been

39353
26:05:53,760 --> 26:05:56,080
ignoring the structures we are going to

39354
26:05:56,080 --> 26:05:58,640
focus on them in the next lecture so go

39355
26:05:58,640 --> 26:06:00,480
ahead and finish up here and meet me

39356
26:06:00,480 --> 26:06:02,232
there in this lecture we're going to

39357
26:06:02,232 --> 26:06:05,120
focus on how destructors work with

39358
26:06:05,120 --> 26:06:07,912
inheritance and suppose we have an

39359
26:06:07,912 --> 26:06:10,640
inheritance hierarchy like we have been

39360
26:06:10,640 --> 26:06:13,120
using all along in this chapter so our

39361
26:06:13,120 --> 26:06:15,192
base class is person we have the

39362
26:06:15,192 --> 26:06:17,040
engineer class which is publicly

39363
26:06:17,040 --> 26:06:19,192
inheriting from person and we have a

39364
26:06:19,192 --> 26:06:21,440
civil engineer class which is inheriting

39365
26:06:21,440 --> 26:06:25,120
from engineer publicly so when we create

39366
26:06:25,120 --> 26:06:28,232
a civil engineer object we have seen

39367
26:06:28,232 --> 26:06:31,040
that the burst part is built first so we

39368
26:06:31,040 --> 26:06:33,120
are going to build the personal part of

39369
26:06:33,120 --> 26:06:35,512
us we are going to build the engineer

39370
26:06:35,512 --> 26:06:37,680
part of us on top of that and we are

39371
26:06:37,680 --> 26:06:39,680
going to build the civil engineer part

39372
26:06:39,680 --> 26:06:42,552
of us on top of that so the constructors

39373
26:06:42,552 --> 26:06:44,320
are going to be called in this order we

39374
26:06:44,320 --> 26:06:46,552
will call the person constructor first

39375
26:06:46,552 --> 26:06:48,872
engineer constructor after that and then

39376
26:06:48,872 --> 26:06:51,440
a civil engineer constructor after that

39377
26:06:51,440 --> 26:06:54,800
to set up our civil engineer object the

39378
26:06:54,800 --> 26:06:57,280
thing i want you to see in this lecture

39379
26:06:57,280 --> 26:06:59,832
is that the structures are called in the

39380
26:06:59,832 --> 26:07:02,480
reverse order to that so the most

39381
26:07:02,480 --> 26:07:04,640
specialized destructor is going to be

39382
26:07:04,640 --> 26:07:07,440
called first then we're going to destroy

39383
26:07:07,440 --> 26:07:10,232
the engineer part of us and the person

39384
26:07:10,232 --> 26:07:13,040
part of us is going to be destroyed last

39385
26:07:13,040 --> 26:07:15,040
so we are going to construct things in

39386
26:07:15,040 --> 26:07:17,680
this order from the base part to the

39387
26:07:17,680 --> 26:07:20,232
most specialized one and then we are

39388
26:07:20,232 --> 26:07:24,160
going to destroy thanks in this order so

39389
26:07:24,160 --> 26:07:26,080
these structures are going to be called

39390
26:07:26,080 --> 26:07:28,640
in the reverse order than the

39391
26:07:28,640 --> 26:07:31,280
constructors that's the message i want

39392
26:07:31,280 --> 26:07:33,440
to convey here and we're going to set up

39393
26:07:33,440 --> 26:07:35,192
a simple example to play with us we're

39394
26:07:35,192 --> 26:07:37,440
going to create a civil engineer object

39395
26:07:37,440 --> 26:07:39,120
and we're going to see the order in

39396
26:07:39,120 --> 26:07:41,600
which these things are called and let's

39397
26:07:41,600 --> 26:07:43,760
head over to visual studio code and

39398
26:07:43,760 --> 26:07:46,400
actually do this here we are in our

39399
26:07:46,400 --> 26:07:48,960
working folder the current project is

39400
26:07:48,960 --> 26:07:51,680
inheritance and destructors we are going

39401
26:07:51,680 --> 26:07:54,080
to be reusing the code from a previous

39402
26:07:54,080 --> 26:07:56,640
lecture i don't think the last lecture

39403
26:07:56,640 --> 26:07:58,720
is a good example because we don't have

39404
26:07:58,720 --> 26:08:01,192
a civil engineer class so we are going

39405
26:08:01,192 --> 26:08:03,832
to go to the lecture before that and use

39406
26:08:03,832 --> 26:08:06,080
the code from our lecture or the copy

39407
26:08:06,080 --> 26:08:08,232
constructors with inheritance that's

39408
26:08:08,232 --> 26:08:10,160
going to give us all the classes we have

39409
26:08:10,160 --> 26:08:12,800
person engineer and civil engineer and

39410
26:08:12,800 --> 26:08:14,960
we need that in this lecture here so

39411
26:08:14,960 --> 26:08:17,360
let's grab all these things we're going

39412
26:08:17,360 --> 26:08:20,232
to copy them and put them in our current

39413
26:08:20,232 --> 26:08:21,512
object

39414
26:08:21,512 --> 26:08:24,400
which is inheritance and the structures

39415
26:08:24,400 --> 26:08:26,552
and we are going to open this in visual

39416
26:08:26,552 --> 26:08:28,800
studio code and it is going to be our

39417
26:08:28,800 --> 26:08:31,120
starting point here so we have person

39418
26:08:31,120 --> 26:08:33,512
engineer and civil engineer let's see

39419
26:08:33,512 --> 26:08:36,960
what we are doing and the main cpp file

39420
26:08:36,960 --> 26:08:39,512
we can take out all the junk here or we

39421
26:08:39,512 --> 26:08:42,480
can leave in the civil engineer object

39422
26:08:42,480 --> 26:08:44,232
we are creating here and we're going to

39423
26:08:44,232 --> 26:08:45,512
see how

39424
26:08:45,512 --> 26:08:48,320
the constructors and the instructors are

39425
26:08:48,320 --> 26:08:50,320
called we're going to go to person and

39426
26:08:50,320 --> 26:08:52,872
make sure we have a constructor and we

39427
26:08:52,872 --> 26:08:56,080
have a bunch of constructors and

39428
26:08:56,080 --> 26:08:58,960
let's go to the cpp file and see that we

39429
26:08:58,960 --> 26:09:01,512
have messages in our constructors this

39430
26:09:01,512 --> 26:09:02,800
is really

39431
26:09:02,800 --> 26:09:05,280
what we expect but we want to also put a

39432
26:09:05,280 --> 26:09:08,232
message in the destructor let's say sddc

39433
26:09:08,232 --> 26:09:11,360
out and say destructor for person called

39434
26:09:11,360 --> 26:09:13,512
this is going to do we're going to go in

39435
26:09:13,512 --> 26:09:15,280
our engineer class we're going to see

39436
26:09:15,280 --> 26:09:17,360
that we have a bunch of constructors we

39437
26:09:17,360 --> 26:09:19,280
have a destructor here we're going to

39438
26:09:19,280 --> 26:09:22,000
hop over in the cpp file

39439
26:09:22,000 --> 26:09:24,960
and make sure we take out the bad code

39440
26:09:24,960 --> 26:09:26,552
here because we don't really need that

39441
26:09:26,552 --> 26:09:29,832
we only need good code and we make sure

39442
26:09:29,832 --> 26:09:32,160
that we have output statements in our

39443
26:09:32,160 --> 26:09:34,000
constructors to know when they are

39444
26:09:34,000 --> 26:09:36,320
called looks like we are good we're

39445
26:09:36,320 --> 26:09:38,800
going to put an sddc out statement in

39446
26:09:38,800 --> 26:09:41,760
our destructor for engineer or engineer

39447
26:09:41,760 --> 26:09:43,832
called this is going to do and we are

39448
26:09:43,832 --> 26:09:46,320
going to hop over in our civil engineer

39449
26:09:46,320 --> 26:09:47,760
class we're going to have a bunch of

39450
26:09:47,760 --> 26:09:50,400
constructors we're going to have a civil

39451
26:09:50,400 --> 26:09:51,760
engineer

39452
26:09:51,760 --> 26:09:53,120
destructor

39453
26:09:53,120 --> 26:09:55,680
we can go in the cpp file and make sure

39454
26:09:55,680 --> 26:09:58,232
that we have output statements in our

39455
26:09:58,232 --> 26:10:00,872
civil engineer constructors looks like

39456
26:10:00,872 --> 26:10:02,960
we are good here we can take out all the

39457
26:10:02,960 --> 26:10:05,832
bad code we don't need and we are going

39458
26:10:05,832 --> 26:10:08,552
to put a message in our destructor here

39459
26:10:08,552 --> 26:10:11,192
so let's do that the the structure

39460
26:10:11,192 --> 26:10:14,080
called for civil engineer i think this

39461
26:10:14,080 --> 26:10:16,480
is going to be good enough let's go back

39462
26:10:16,480 --> 26:10:18,552
and make sure we have the same messages

39463
26:10:18,552 --> 26:10:20,552
here for engineer

39464
26:10:20,552 --> 26:10:22,720
and we have a destructor for person

39465
26:10:22,720 --> 26:10:24,960
called message and we're going to try

39466
26:10:24,960 --> 26:10:26,480
and run the code and see how

39467
26:10:26,480 --> 26:10:29,280
constructors and destructors are called

39468
26:10:29,280 --> 26:10:31,680
this is the order we want to make sure

39469
26:10:31,680 --> 26:10:34,080
we understand if you want you can even

39470
26:10:34,080 --> 26:10:36,320
use a debugger to follow things but i am

39471
26:10:36,320 --> 26:10:38,480
not going to do that here i am just

39472
26:10:38,480 --> 26:10:40,320
going to weld and show you the output

39473
26:10:40,320 --> 26:10:41,600
statements

39474
26:10:41,600 --> 26:10:43,440
hopefully that's going to be proof

39475
26:10:43,440 --> 26:10:44,320
enough

39476
26:10:44,320 --> 26:10:47,120
that things happen in the order that i

39477
26:10:47,120 --> 26:10:49,600
just described in the slides the build

39478
26:10:49,600 --> 26:10:51,832
is good we can clear we can bring up a

39479
26:10:51,832 --> 26:10:54,320
powershell window and then clear and

39480
26:10:54,320 --> 26:10:56,232
we're going to run rooster we're going

39481
26:10:56,232 --> 26:10:57,832
to see that the constructor is going to

39482
26:10:57,832 --> 26:11:01,440
be called for person for civil engineer

39483
26:11:01,440 --> 26:11:02,800
and you're going to see that things are

39484
26:11:02,800 --> 26:11:05,912
going to happen from the must-based

39485
26:11:05,912 --> 26:11:08,480
constructor to the most specialized

39486
26:11:08,480 --> 26:11:11,360
constructor so we are going to call

39487
26:11:11,360 --> 26:11:13,912
person engineer and civil engineer but

39488
26:11:13,912 --> 26:11:15,600
you're going to see that the structures

39489
26:11:15,600 --> 26:11:17,600
are going to be called in the reverse

39490
26:11:17,600 --> 26:11:18,480
order

39491
26:11:18,480 --> 26:11:20,480
the most specialized the destructor is

39492
26:11:20,480 --> 26:11:22,480
going to be called the first then we're

39493
26:11:22,480 --> 26:11:24,480
going to call the distractor for

39494
26:11:24,480 --> 26:11:26,320
engineer then we're going to call the

39495
26:11:26,320 --> 26:11:29,120
destructor for the base class so things

39496
26:11:29,120 --> 26:11:30,872
are going to be happening in reverse

39497
26:11:30,872 --> 26:11:33,600
order we will build thanks starting from

39498
26:11:33,600 --> 26:11:35,512
the base and then

39499
26:11:35,512 --> 26:11:38,160
finish by the most specialized class

39500
26:11:38,160 --> 26:11:40,960
which is doing the inheritance and then

39501
26:11:40,960 --> 26:11:42,960
we're going to call the destructor for

39502
26:11:42,960 --> 26:11:45,600
the most specialized class first and

39503
26:11:45,600 --> 26:11:48,232
then the destructor for the most based

39504
26:11:48,232 --> 26:11:50,640
class is going to be cold last you

39505
26:11:50,640 --> 26:11:52,400
should really make sure you understand

39506
26:11:52,400 --> 26:11:54,872
this because sometimes your things are

39507
26:11:54,872 --> 26:11:57,040
going to be depending on this order and

39508
26:11:57,040 --> 26:11:58,720
you need to understand this and this is

39509
26:11:58,720 --> 26:12:00,960
really the main message here that the

39510
26:12:00,960 --> 26:12:03,360
structures are ridiculed in the reverse

39511
26:12:03,360 --> 26:12:04,320
order

39512
26:12:04,320 --> 26:12:06,080
than the constructors

39513
26:12:06,080 --> 26:12:07,680
we are going to stop here in this

39514
26:12:07,680 --> 26:12:09,280
lecture in the next one we're going to

39515
26:12:09,280 --> 26:12:12,480
see that we can actually reuse names in

39516
26:12:12,480 --> 26:12:15,040
our inheritance hierarchy and we're

39517
26:12:15,040 --> 26:12:16,720
going to see how that works out in the

39518
26:12:16,720 --> 26:12:18,872
next lecture so go ahead and finish up

39519
26:12:18,872 --> 26:12:21,440
here and meet me there in this lecture

39520
26:12:21,440 --> 26:12:23,440
we're going to see that we can reuse

39521
26:12:23,440 --> 26:12:27,192
names in our inheritance hierarchy

39522
26:12:27,192 --> 26:12:29,760
and what we mean by that is that we can

39523
26:12:29,760 --> 26:12:32,400
have a parent class for example and have

39524
26:12:32,400 --> 26:12:34,960
a child class inheriting from the parent

39525
26:12:34,960 --> 26:12:38,640
class and have exactly the same names

39526
26:12:38,640 --> 26:12:41,280
for the member variables and types or

39527
26:12:41,280 --> 26:12:43,512
the same signatures for functions for

39528
26:12:43,512 --> 26:12:45,912
example in the parent class you see that

39529
26:12:45,912 --> 26:12:48,320
we have a member function called

39530
26:12:48,320 --> 26:12:50,480
printfur it is going to be printing some

39531
26:12:50,480 --> 26:12:53,600
information we can have a function named

39532
26:12:53,600 --> 26:12:56,400
exactly the same in the child class and

39533
26:12:56,400 --> 26:12:58,640
c plus plus is going to allow this we

39534
26:12:58,640 --> 26:13:00,640
can also do the same things for member

39535
26:13:00,640 --> 26:13:03,280
variables for example we have m var

39536
26:13:03,280 --> 26:13:06,720
which is of type and we have exactly the

39537
26:13:06,720 --> 26:13:09,832
same thing in our child class and c plus

39538
26:13:09,832 --> 26:13:12,232
plus is going to allow this now the

39539
26:13:12,232 --> 26:13:14,800
problem is if you create an object of

39540
26:13:14,800 --> 26:13:17,832
child which method will be called if you

39541
26:13:17,832 --> 26:13:20,080
call printvar now

39542
26:13:20,080 --> 26:13:23,120
what c plus plus does is it is going to

39543
26:13:23,120 --> 26:13:25,192
override or hide

39544
26:13:25,192 --> 26:13:27,280
things you have in the base class if you

39545
26:13:27,280 --> 26:13:30,080
happen to set up exactly the same thing

39546
26:13:30,080 --> 26:13:33,192
in a derived class so for example the

39547
26:13:33,192 --> 26:13:36,552
members in our child class are going to

39548
26:13:36,552 --> 26:13:39,040
hide the members we had in the base

39549
26:13:39,040 --> 26:13:41,600
class and if we call these methods on a

39550
26:13:41,600 --> 26:13:44,160
child object we are going to get the

39551
26:13:44,160 --> 26:13:46,960
versions in the child class called if we

39552
26:13:46,960 --> 26:13:49,600
call these methods on a parent object we

39553
26:13:49,600 --> 26:13:51,680
are going to get the parent version

39554
26:13:51,680 --> 26:13:53,360
called and we're going to see the data

39555
26:13:53,360 --> 26:13:55,360
in the parent class printed out this is

39556
26:13:55,360 --> 26:13:57,832
the message here it is possible to use

39557
26:13:57,832 --> 26:14:00,400
the same names in both parent and child

39558
26:14:00,400 --> 26:14:03,512
classes and if you do that things in

39559
26:14:03,512 --> 26:14:05,912
child classes are going to hide or

39560
26:14:05,912 --> 26:14:08,720
override what we had in the parent class

39561
26:14:08,720 --> 26:14:10,800
this is the message i want to convey

39562
26:14:10,800 --> 26:14:13,192
here and here is a simple example to

39563
26:14:13,192 --> 26:14:15,832
drive home how you can use these things

39564
26:14:15,832 --> 26:14:18,400
for example we can create a child object

39565
26:14:18,400 --> 26:14:20,400
using this syntax here

39566
26:14:20,400 --> 26:14:23,040
and if we call a method on the child

39567
26:14:23,040 --> 26:14:24,872
object this is going to call the method

39568
26:14:24,872 --> 26:14:27,760
in child but it is possible to force the

39569
26:14:27,760 --> 26:14:31,192
compiler to call the version in the base

39570
26:14:31,192 --> 26:14:32,960
class and you're going to see this

39571
26:14:32,960 --> 26:14:35,512
syntax used somewhere in your code out

39572
26:14:35,512 --> 26:14:38,872
there so the syntax is to say the object

39573
26:14:38,872 --> 26:14:41,440
name you put it up you say the name for

39574
26:14:41,440 --> 26:14:44,232
the parent class and then you call the

39575
26:14:44,232 --> 26:14:46,400
method using the scope resolution

39576
26:14:46,400 --> 26:14:48,480
operator here and this is going to hold

39577
26:14:48,480 --> 26:14:50,720
the method in the parent okay now that

39578
26:14:50,720 --> 26:14:52,160
you know this we're going to head over

39579
26:14:52,160 --> 26:14:54,160
to visual studio code and play with this

39580
26:14:54,160 --> 26:14:56,872
a little more here we are in our working

39581
26:14:56,872 --> 26:14:59,280
folder the current project is reused

39582
26:14:59,280 --> 26:15:02,400
symbols and inheritance we are going to

39583
26:15:02,400 --> 26:15:05,440
just grab the template files because we

39584
26:15:05,440 --> 26:15:07,280
are going to be building things from

39585
26:15:07,280 --> 26:15:09,440
scratch here and we're going to put in

39586
26:15:09,440 --> 26:15:12,400
our files no big deal here and we can

39587
26:15:12,400 --> 26:15:14,872
open this in visual studio code this is

39588
26:15:14,872 --> 26:15:18,080
going to give us a bare minimum main cpp

39589
26:15:18,080 --> 26:15:21,040
file we can clean it up a little bit and

39590
26:15:21,040 --> 26:15:22,960
we're going to set up our parent class

39591
26:15:22,960 --> 26:15:24,640
let's do that pretty fast we're going to

39592
26:15:24,640 --> 26:15:27,360
say parent and set up the header and

39593
26:15:27,360 --> 26:15:29,120
we're going to set up the implementation

39594
26:15:29,120 --> 26:15:32,000
cpp file we are going to set up the

39595
26:15:32,000 --> 26:15:35,600
header file and this is going to do

39596
26:15:35,600 --> 26:15:38,640
everything we want we have a constructor

39597
26:15:38,640 --> 26:15:40,872
which is really defaulted here so let's

39598
26:15:40,872 --> 26:15:43,512
say default and we cannot default the

39599
26:15:43,512 --> 26:15:45,600
destructor can we default it let's do

39600
26:15:45,600 --> 26:15:47,832
this and see what happens and we don't

39601
26:15:47,832 --> 26:15:50,400
really need to do anything in the cpp

39602
26:15:50,400 --> 26:15:52,320
file we can leave it empty this is not

39603
26:15:52,320 --> 26:15:54,960
going to hurt anything and with this we

39604
26:15:54,960 --> 26:15:57,512
can create parent objects let's do that

39605
26:15:57,512 --> 26:15:58,872
we're going to say

39606
26:15:58,872 --> 26:16:00,720
we're going to hop over to the main cpp

39607
26:16:00,720 --> 26:16:02,800
file and include current and make sure

39608
26:16:02,800 --> 26:16:04,800
that we can use that and we're going to

39609
26:16:04,800 --> 26:16:07,192
create a parent object let's do that

39610
26:16:07,192 --> 26:16:10,232
we're going to say parent p1 and say

39611
26:16:10,232 --> 26:16:13,040
p1 print values we can do that and we

39612
26:16:13,040 --> 26:16:15,280
can work and run this program i think it

39613
26:16:15,280 --> 26:16:17,760
is going to work just fine okay the

39614
26:16:17,760 --> 26:16:20,232
build is good we can clear or we can set

39615
26:16:20,232 --> 26:16:23,120
up a powershell window and a clear

39616
26:16:23,120 --> 26:16:25,360
and run rooster this is going to say the

39617
26:16:25,360 --> 26:16:27,912
value in parent is 100 which is what we

39618
26:16:27,912 --> 26:16:29,832
have by default here we have a simple

39619
26:16:29,832 --> 26:16:32,872
member variable which is of ant type it

39620
26:16:32,872 --> 26:16:35,600
is protected because we want it to be

39621
26:16:35,600 --> 26:16:38,320
inherited and we have a bunch of

39622
26:16:38,320 --> 26:16:40,000
constructors here we have a constructor

39623
26:16:40,000 --> 26:16:41,600
which is going to take a value but we're

39624
26:16:41,600 --> 26:16:43,360
not going to use that here the default

39625
26:16:43,360 --> 26:16:45,512
is just fine you can use that if you

39626
26:16:45,512 --> 26:16:47,680
want and we have a member function which

39627
26:16:47,680 --> 26:16:49,600
is going to print the value in parent

39628
26:16:49,600 --> 26:16:51,832
now that this is working we can set up a

39629
26:16:51,832 --> 26:16:53,680
child class which is going to be

39630
26:16:53,680 --> 26:16:56,232
inheriting from the parent class here so

39631
26:16:56,232 --> 26:16:58,080
let's do that we're going to set up the

39632
26:16:58,080 --> 26:17:01,192
child header file child dot h and we're

39633
26:17:01,192 --> 26:17:03,760
going to set up a cpp file for that that

39634
26:17:03,760 --> 26:17:06,552
cpp so we are going to put the data in

39635
26:17:06,552 --> 26:17:08,960
the header file again it is nothing

39636
26:17:08,960 --> 26:17:11,680
complicated it is just a simple class

39637
26:17:11,680 --> 26:17:13,680
which is going to be inheriting from

39638
26:17:13,680 --> 26:17:16,480
parent and we are going to have our own

39639
26:17:16,480 --> 26:17:17,832
member variable which is going to

39640
26:17:17,832 --> 26:17:20,160
eclipse what we had in the parent so the

39641
26:17:20,160 --> 26:17:22,720
names here must be the same m a member

39642
26:17:22,720 --> 26:17:25,912
of r if we go in parent it is m member

39643
26:17:25,912 --> 26:17:28,960
for and what we have in child is going

39644
26:17:28,960 --> 26:17:31,360
to eclipse what we had in the parent

39645
26:17:31,360 --> 26:17:34,080
class in other words if we print the

39646
26:17:34,080 --> 26:17:36,400
member variable in child we're going to

39647
26:17:36,400 --> 26:17:39,680
see 1000 printed out here we want to see

39648
26:17:39,680 --> 26:17:43,192
100 that we have in the parent printed

39649
26:17:43,192 --> 26:17:45,360
out hopefully this is going to drive the

39650
26:17:45,360 --> 26:17:48,000
point home that if you have members

39651
26:17:48,000 --> 26:17:50,400
named exactly the same

39652
26:17:50,400 --> 26:17:53,120
what you have in your derived classes is

39653
26:17:53,120 --> 26:17:56,080
going to eclipse or hide what we had in

39654
26:17:56,080 --> 26:17:57,832
the parent class this is the message

39655
26:17:57,832 --> 26:18:01,192
here but even if this is the case c plus

39656
26:18:01,192 --> 26:18:04,080
plus allows us to specify that we want

39657
26:18:04,080 --> 26:18:07,512
to grab the data in parent from a child

39658
26:18:07,512 --> 26:18:10,960
object for example in our show values

39659
26:18:10,960 --> 26:18:13,440
method we can print the value in child

39660
26:18:13,440 --> 26:18:16,232
directly using m member war but we can

39661
26:18:16,232 --> 26:18:18,552
also specify that we want the value in

39662
26:18:18,552 --> 26:18:21,192
the parent class because even if this is

39663
26:18:21,192 --> 26:18:24,720
a child object it has a current part of

39664
26:18:24,720 --> 26:18:27,360
it so we can access the data in parent

39665
26:18:27,360 --> 26:18:30,000
and print that if the data happens to be

39666
26:18:30,000 --> 26:18:32,720
accessible from our derived class and

39667
26:18:32,720 --> 26:18:34,720
that's why we set up our member variable

39668
26:18:34,720 --> 26:18:37,512
to be protected for it to be accessible

39669
26:18:37,512 --> 26:18:39,760
in our derived classes this is going to

39670
26:18:39,760 --> 26:18:41,832
allow us to print something like this

39671
26:18:41,832 --> 26:18:44,000
and this is going to really work now

39672
26:18:44,000 --> 26:18:46,232
that we have this in place we can go in

39673
26:18:46,232 --> 26:18:48,320
the main cpp file

39674
26:18:48,320 --> 26:18:50,960
and only include the child we can do

39675
26:18:50,960 --> 26:18:53,120
that and we're going to create a child

39676
26:18:53,120 --> 26:18:55,600
object or we can just take out

39677
26:18:55,600 --> 26:18:57,440
everything here

39678
26:18:57,440 --> 26:18:59,440
and adjust putting the code we can use

39679
26:18:59,440 --> 26:19:01,912
to play with this things we can create

39680
26:19:01,912 --> 26:19:03,680
the child object

39681
26:19:03,680 --> 26:19:06,160
and on this child we can print for we're

39682
26:19:06,160 --> 26:19:07,680
going to see that the data is going to

39683
26:19:07,680 --> 26:19:10,080
be printed out but we can also use this

39684
26:19:10,080 --> 26:19:13,192
syntax to print the data in the parent

39685
26:19:13,192 --> 26:19:14,800
part of us and we're going to see that

39686
26:19:14,800 --> 26:19:17,120
the data is printed out we can also show

39687
26:19:17,120 --> 26:19:20,160
the values and make sure we see this

39688
26:19:20,160 --> 26:19:22,720
from a member function of the child

39689
26:19:22,720 --> 26:19:25,192
class this is going to call this member

39690
26:19:25,192 --> 26:19:26,800
and we're going to get to the value in

39691
26:19:26,800 --> 26:19:28,480
child and we're going to get the value

39692
26:19:28,480 --> 26:19:31,832
in parent printed out on the console now

39693
26:19:31,832 --> 26:19:34,080
that we have this we can actually try

39694
26:19:34,080 --> 26:19:36,480
and work this we're going to use gcc to

39695
26:19:36,480 --> 26:19:37,512
do that

39696
26:19:37,512 --> 26:19:39,680
we're going to see that we're going to

39697
26:19:39,680 --> 26:19:42,160
finish building with errors what is the

39698
26:19:42,160 --> 26:19:44,320
problem here we have an undefined

39699
26:19:44,320 --> 26:19:46,872
reference to child destructor

39700
26:19:46,872 --> 26:19:49,192
we didn't put in a definition for the

39701
26:19:49,192 --> 26:19:52,000
child destructor so let's go there

39702
26:19:52,000 --> 26:19:54,800
and default it we can do that we're

39703
26:19:54,800 --> 26:19:56,552
going to say equals default and the

39704
26:19:56,552 --> 26:20:00,320
compiler is going to generate one for us

39705
26:20:00,320 --> 26:20:02,872
and now if we build we're going to build

39706
26:20:02,872 --> 26:20:05,192
with gcc again the bolt is going to be

39707
26:20:05,192 --> 26:20:08,000
good you can clear and run rooster and

39708
26:20:08,000 --> 26:20:09,512
we're going to see that the value in

39709
26:20:09,512 --> 26:20:12,720
child is 33 because we passed that in

39710
26:20:12,720 --> 26:20:15,360
explicitly and this is going to call the

39711
26:20:15,360 --> 26:20:17,680
constructor we have in child that

39712
26:20:17,680 --> 26:20:20,232
happens to be this guy here and you see

39713
26:20:20,232 --> 26:20:22,400
that we are really keeping things simple

39714
26:20:22,400 --> 26:20:24,480
we are not calling the base constructor

39715
26:20:24,480 --> 26:20:27,832
here the compiler is just going to call

39716
26:20:27,832 --> 26:20:30,232
the default constructor we have in

39717
26:20:30,232 --> 26:20:32,552
parent here and this is going to just

39718
26:20:32,552 --> 26:20:34,480
work the main message here is that you

39719
26:20:34,480 --> 26:20:37,600
can set up member variables and member

39720
26:20:37,600 --> 26:20:40,800
functions named exactly the same way in

39721
26:20:40,800 --> 26:20:43,192
the parent class and in child classes

39722
26:20:43,192 --> 26:20:45,360
and what you have in your derived

39723
26:20:45,360 --> 26:20:48,480
classes is going to hide what we have in

39724
26:20:48,480 --> 26:20:51,440
our current classes so if we call a

39725
26:20:51,440 --> 26:20:54,080
method on a child object for example

39726
26:20:54,080 --> 26:20:56,160
like we are doing here this is going to

39727
26:20:56,160 --> 26:20:58,232
call the method in child but we still

39728
26:20:58,232 --> 26:21:00,480
have the ability to call data in the

39729
26:21:00,480 --> 26:21:02,960
parent part of us and this is what we do

39730
26:21:02,960 --> 26:21:05,280
here i would like to welcome you in this

39731
26:21:05,280 --> 26:21:07,040
new chapter where we're going to be

39732
26:21:07,040 --> 26:21:09,760
learning about polymorphism and

39733
26:21:09,760 --> 26:21:12,800
polymorphism is the setup we can do in

39734
26:21:12,800 --> 26:21:15,280
our c plus plus programs

39735
26:21:15,280 --> 26:21:18,400
to use a base pointer and manage derived

39736
26:21:18,400 --> 26:21:21,040
objects suppose we have an inheritance

39737
26:21:21,040 --> 26:21:23,192
hierarchy like we have here we have

39738
26:21:23,192 --> 26:21:26,320
shaped as our base class and we can

39739
26:21:26,320 --> 26:21:28,872
inherit from oval and create a circle

39740
26:21:28,872 --> 26:21:31,360
class imagine that we can create all

39741
26:21:31,360 --> 26:21:34,160
kinds of crazy shapes that inherit from

39742
26:21:34,160 --> 26:21:36,400
shape in our simplest path program for

39743
26:21:36,400 --> 26:21:38,320
example we have a rectangle class we

39744
26:21:38,320 --> 26:21:40,400
have a triangle class we have all kinds

39745
26:21:40,400 --> 26:21:42,960
of crazy shapes now if we have this

39746
26:21:42,960 --> 26:21:45,680
inheritance hierarchy here is something

39747
26:21:45,680 --> 26:21:48,000
we might want to do we might want to set

39748
26:21:48,000 --> 26:21:50,720
up a base pointer that is managing a

39749
26:21:50,720 --> 26:21:53,600
derived object and set up code like this

39750
26:21:53,600 --> 26:21:56,400
for example we say shape pointer and i

39751
26:21:56,400 --> 26:21:58,480
set up a pointer variable here and use

39752
26:21:58,480 --> 26:22:01,440
this pointer to manage a circle object

39753
26:22:01,440 --> 26:22:04,232
that we dynamically allocate for on this

39754
26:22:04,232 --> 26:22:07,120
line here we can also do a shape pointer

39755
26:22:07,120 --> 26:22:09,600
that is managing a rectangle we can set

39756
26:22:09,600 --> 26:22:11,512
up a shape pointer that is managing a

39757
26:22:11,512 --> 26:22:14,232
novel object we can really set up a base

39758
26:22:14,232 --> 26:22:16,552
pointer that is managing any kind of

39759
26:22:16,552 --> 26:22:19,192
object we support in our inheritance

39760
26:22:19,192 --> 26:22:21,360
hierarchy now some of you are going to

39761
26:22:21,360 --> 26:22:23,680
ask a few questions one of them is going

39762
26:22:23,680 --> 26:22:27,040
to be is this even legal c plus plus

39763
26:22:27,040 --> 26:22:30,320
syntax and the answer is yes because if

39764
26:22:30,320 --> 26:22:33,440
circle is inherited somehow from shape a

39765
26:22:33,440 --> 26:22:35,280
circle is really a shape and if

39766
26:22:35,280 --> 26:22:37,912
rectangle is inheriting from shape it is

39767
26:22:37,912 --> 26:22:40,400
a shape and if we try to assign a circle

39768
26:22:40,400 --> 26:22:41,760
to a shape we're going to see that

39769
26:22:41,760 --> 26:22:44,320
that's going to work so this is valid c

39770
26:22:44,320 --> 26:22:46,960
plus plus syntax and we can do the same

39771
26:22:46,960 --> 26:22:49,120
thing using references as we see here we

39772
26:22:49,120 --> 26:22:50,872
can set up a reference that is going to

39773
26:22:50,872 --> 26:22:52,400
be managing

39774
26:22:52,400 --> 26:22:55,120
a circle object that we have through

39775
26:22:55,120 --> 26:22:57,512
circle one we can set up a reference to

39776
26:22:57,512 --> 26:22:59,832
manage a rectangle that we have in shape

39777
26:22:59,832 --> 26:23:02,320
two we can set up a reference to manage

39778
26:23:02,320 --> 26:23:04,640
an awful object we can really do all

39779
26:23:04,640 --> 26:23:05,912
these things

39780
26:23:05,912 --> 26:23:08,160
now some of you are asking

39781
26:23:08,160 --> 26:23:10,160
why would we want to do something like

39782
26:23:10,160 --> 26:23:12,480
this now try and think about your

39783
26:23:12,480 --> 26:23:14,960
inheritance hierarchy here and try to

39784
26:23:14,960 --> 26:23:17,600
think about what if you want to

39785
26:23:17,600 --> 26:23:20,080
draw this kind of ship for example if

39786
26:23:20,080 --> 26:23:22,800
you didn't use polymorphism you would

39787
26:23:22,800 --> 26:23:24,960
need to set up all kinds of crazy

39788
26:23:24,960 --> 26:23:27,912
methods to draw each kind of object and

39789
26:23:27,912 --> 26:23:29,912
we have no way around this because these

39790
26:23:29,912 --> 26:23:32,320
are different types if you have a method

39791
26:23:32,320 --> 26:23:34,480
that takes a novel and you pass in a

39792
26:23:34,480 --> 26:23:35,760
circle that's going to give you a

39793
26:23:35,760 --> 26:23:38,400
compiler error but with polymorphism we

39794
26:23:38,400 --> 26:23:40,480
can set up a single method which takes a

39795
26:23:40,480 --> 26:23:43,192
shape pointer or a shape reference

39796
26:23:43,192 --> 26:23:45,680
and we can pass in all kinds of crazy

39797
26:23:45,680 --> 26:23:48,640
objects whose class derive from shape so

39798
26:23:48,640 --> 26:23:50,552
for example we can pass in the address

39799
26:23:50,552 --> 26:23:52,232
of the circle and this function is going

39800
26:23:52,232 --> 26:23:54,232
to draw a circle we can pass in the

39801
26:23:54,232 --> 26:23:56,160
address of a rectangle this is going to

39802
26:23:56,160 --> 26:23:58,232
draw a rectangle we can pass in the

39803
26:23:58,232 --> 26:24:00,080
address of a novel and this is going to

39804
26:24:00,080 --> 26:24:02,320
draw a novel hopefully you can see how

39805
26:24:02,320 --> 26:24:04,720
this is useful we can even do this using

39806
26:24:04,720 --> 26:24:07,120
references so if we pass in a rectangle

39807
26:24:07,120 --> 26:24:09,120
this is going to draw a rectangle if we

39808
26:24:09,120 --> 26:24:11,360
pass in a circle this is going to draw a

39809
26:24:11,360 --> 26:24:14,320
circle you get the idea this is one of

39810
26:24:14,320 --> 26:24:17,120
the benefits of using polymorphism again

39811
26:24:17,120 --> 26:24:20,232
polymorphism is about using base class

39812
26:24:20,232 --> 26:24:23,512
pointers or references to manage derived

39813
26:24:23,512 --> 26:24:26,480
objects in our inheritance hierarchies

39814
26:24:26,480 --> 26:24:29,192
another benefit of polymorphism is to

39815
26:24:29,192 --> 26:24:31,512
allow us to be able to store

39816
26:24:31,512 --> 26:24:33,680
different kinds of objects in a single

39817
26:24:33,680 --> 26:24:36,552
collection remember an array can store

39818
26:24:36,552 --> 26:24:39,192
objects of different types if you say

39819
26:24:39,192 --> 26:24:41,600
tap an end array and try to store in a

39820
26:24:41,600 --> 26:24:43,192
string or a double you're going to get a

39821
26:24:43,192 --> 26:24:44,720
compiler error because that's not

39822
26:24:44,720 --> 26:24:47,512
allowed so if you have an array that is

39823
26:24:47,512 --> 26:24:49,912
going to store circles you can't put in

39824
26:24:49,912 --> 26:24:52,000
a novel you can't put in a rectangle you

39825
26:24:52,000 --> 26:24:54,872
can put in a star you can't really do

39826
26:24:54,872 --> 26:24:57,760
that because an array by design is going

39827
26:24:57,760 --> 26:25:00,480
to store objects of the same type but we

39828
26:25:00,480 --> 26:25:02,552
can avoid this limitation using

39829
26:25:02,552 --> 26:25:04,872
polymorphism again we can set up an

39830
26:25:04,872 --> 26:25:07,760
array that is going to store base class

39831
26:25:07,760 --> 26:25:10,552
pointers and we can store in all kinds

39832
26:25:10,552 --> 26:25:13,440
of crazy objects whose class derived

39833
26:25:13,440 --> 26:25:16,232
from this base class here so here we can

39834
26:25:16,232 --> 26:25:18,232
store in a circle object we can store in

39835
26:25:18,232 --> 26:25:20,232
a novel we can store in any kind of

39836
26:25:20,232 --> 26:25:23,192
object that is part of our inheritance

39837
26:25:23,192 --> 26:25:26,400
hierarchy with the base class as shape

39838
26:25:26,400 --> 26:25:28,160
and this is going to work and this is

39839
26:25:28,160 --> 26:25:29,832
going to be using polymorphism for

39840
26:25:29,832 --> 26:25:31,360
example if you look through this

39841
26:25:31,360 --> 26:25:33,832
collection calling the joe method for

39842
26:25:33,832 --> 26:25:35,512
the first element this is going to call

39843
26:25:35,512 --> 26:25:37,760
the draw method on the circle for the

39844
26:25:37,760 --> 26:25:39,192
second element we're going to call the

39845
26:25:39,192 --> 26:25:41,192
draw method on a novel and this is going

39846
26:25:41,192 --> 26:25:42,080
to be

39847
26:25:42,080 --> 26:25:43,760
really cool this is something we can

39848
26:25:43,760 --> 26:25:46,400
achieve with polymorphism and i want to

39849
26:25:46,400 --> 26:25:48,552
back up a little bit and talk about what

39850
26:25:48,552 --> 26:25:50,640
is really meant by polymorphism

39851
26:25:50,640 --> 26:25:53,760
polymorphism really means multiple forms

39852
26:25:53,760 --> 26:25:56,232
and in my opinion what this means is

39853
26:25:56,232 --> 26:25:58,720
that the base class pointer or base

39854
26:25:58,720 --> 26:26:01,360
class reference can take multiple forms

39855
26:26:01,360 --> 26:26:03,280
at one point it might be managing a

39856
26:26:03,280 --> 26:26:05,360
circle at one point it might be managing

39857
26:26:05,360 --> 26:26:07,280
a rectangle at one point it might be

39858
26:26:07,280 --> 26:26:10,080
managing a novel object so it is a basic

39859
26:26:10,080 --> 26:26:13,192
pointer but it can take multiple forms

39860
26:26:13,192 --> 26:26:14,960
because it can be managing multiple

39861
26:26:14,960 --> 26:26:18,400
kinds of objects whose class are part of

39862
26:26:18,400 --> 26:26:21,120
our inheritance hierarchy this is what

39863
26:26:21,120 --> 26:26:23,512
we mean by polymorphism so again the

39864
26:26:23,512 --> 26:26:25,680
idea is that we can use the base class

39865
26:26:25,680 --> 26:26:27,832
pointer or reference to manage all kinds

39866
26:26:27,832 --> 26:26:30,400
of crazy objects in our program and this

39867
26:26:30,400 --> 26:26:32,800
is going to have many benefits as we are

39868
26:26:32,800 --> 26:26:35,440
about to experience in this chapter here

39869
26:26:35,440 --> 26:26:37,760
i am really excited to be explaining

39870
26:26:37,760 --> 26:26:39,832
this to you this is one of the most

39871
26:26:39,832 --> 26:26:42,400
powerful features in c plus plus we are

39872
26:26:42,400 --> 26:26:44,320
going to start in the next lecture and

39873
26:26:44,320 --> 26:26:46,640
show you that you don't get polymorphism

39874
26:26:46,640 --> 26:26:49,280
by default in c plus plus and what you

39875
26:26:49,280 --> 26:26:52,000
get is static binding go ahead and

39876
26:26:52,000 --> 26:26:54,552
finish up here and meet me there

39877
26:26:54,552 --> 26:26:57,040
manage derived objects in our c plus

39878
26:26:57,040 --> 26:26:59,440
plus program hopefully this is going to

39879
26:26:59,440 --> 26:27:02,400
give you a clear idea on why we might

39880
26:27:02,400 --> 26:27:04,720
need to do this so let's look at our

39881
26:27:04,720 --> 26:27:06,400
classes that we're going to be using

39882
26:27:06,400 --> 26:27:08,232
here we're going to set up a shape class

39883
26:27:08,232 --> 26:27:10,552
which is going to be representing our

39884
26:27:10,552 --> 26:27:12,800
shapes this is going to be our base

39885
26:27:12,800 --> 26:27:15,360
class that's the basic use for this here

39886
26:27:15,360 --> 26:27:17,360
it has a simple member variable which is

39887
26:27:17,360 --> 26:27:20,000
going to store the description for our

39888
26:27:20,000 --> 26:27:22,720
shape it is also going to have our draw

39889
26:27:22,720 --> 26:27:24,640
method which is really not going to draw

39890
26:27:24,640 --> 26:27:26,800
anything it is just going to say the

39891
26:27:26,800 --> 26:27:29,680
description for our shape here once we

39892
26:27:29,680 --> 26:27:31,512
have this shape we can create other

39893
26:27:31,512 --> 26:27:33,512
shapes from it for example we can create

39894
26:27:33,512 --> 26:27:35,680
a novel class which is going to be

39895
26:27:35,680 --> 26:27:38,080
representing a shape like this it is

39896
26:27:38,080 --> 26:27:40,480
going to have two member variables one

39897
26:27:40,480 --> 26:27:43,192
is going to be mx radius the other is

39898
26:27:43,192 --> 26:27:45,512
going to be m y radius this may

39899
26:27:45,512 --> 26:27:47,120
represent

39900
26:27:47,120 --> 26:27:50,552
the radiuses for our oval here for

39901
26:27:50,552 --> 26:27:53,120
example the x radius might be something

39902
26:27:53,120 --> 26:27:55,360
like this the y radius might be

39903
26:27:55,360 --> 26:27:57,040
something like this and this is how

39904
26:27:57,040 --> 26:27:59,192
we're going to be representing

39905
26:27:59,192 --> 26:28:01,512
this shape here we also have a draw

39906
26:28:01,512 --> 26:28:03,040
method which is going to print the

39907
26:28:03,040 --> 26:28:05,832
information about this shape here it is

39908
26:28:05,832 --> 26:28:07,600
going to say the description that we're

39909
26:28:07,600 --> 26:28:09,760
going to be inheriting publicly from

39910
26:28:09,760 --> 26:28:12,000
shape but it is also going to say the

39911
26:28:12,000 --> 26:28:14,480
radius information for this shape it is

39912
26:28:14,480 --> 26:28:17,280
going to give us the x radius and the y

39913
26:28:17,280 --> 26:28:19,832
radius here and we have a bunch of

39914
26:28:19,832 --> 26:28:21,760
constructors here we have a default

39915
26:28:21,760 --> 26:28:23,512
constructor which is really not going to

39916
26:28:23,512 --> 26:28:25,832
do anything we also have a constructor

39917
26:28:25,832 --> 26:28:27,360
that is going to be taking two

39918
26:28:27,360 --> 26:28:30,552
parameters to forward the data in our

39919
26:28:30,552 --> 26:28:32,960
member variables here this is the kind

39920
26:28:32,960 --> 26:28:34,872
of class we're going to set up in our

39921
26:28:34,872 --> 26:28:37,600
program we also have another derived

39922
26:28:37,600 --> 26:28:40,552
class from oval and this is going to be

39923
26:28:40,552 --> 26:28:42,912
a circle class it is going to be a

39924
26:28:42,912 --> 26:28:47,192
specialization on oval in which both x

39925
26:28:47,192 --> 26:28:50,552
and y radius are equal so the x radius

39926
26:28:50,552 --> 26:28:52,480
is going to be something like this and

39927
26:28:52,480 --> 26:28:54,552
the y radius is going to be something

39928
26:28:54,552 --> 26:28:57,360
like this and both of these are going to

39929
26:28:57,360 --> 26:28:59,912
be equal so this is going to give us a

39930
26:28:59,912 --> 26:29:02,720
circle shape we also have a draw method

39931
26:29:02,720 --> 26:29:05,040
which is going to print the description

39932
26:29:05,040 --> 26:29:07,912
and the radius we can really pick any

39933
26:29:07,912 --> 26:29:10,320
radius we can pick the x radius we can

39934
26:29:10,320 --> 26:29:12,400
pick the y radius they are really going

39935
26:29:12,400 --> 26:29:14,552
to be the same because they are equal

39936
26:29:14,552 --> 26:29:17,360
for our circle shape we also have a

39937
26:29:17,360 --> 26:29:19,120
simple constructor which is going to

39938
26:29:19,120 --> 26:29:21,600
take the radius and we are going to be

39939
26:29:21,600 --> 26:29:23,440
using this radius

39940
26:29:23,440 --> 26:29:26,800
to forward the data to our oval part of

39941
26:29:26,800 --> 26:29:29,440
us and we're going to be setting this as

39942
26:29:29,440 --> 26:29:32,160
both x and y radius this is the setup we

39943
26:29:32,160 --> 26:29:34,640
have here okay now that we have our

39944
26:29:34,640 --> 26:29:37,040
inheritance hierarchy we're going to try

39945
26:29:37,040 --> 26:29:39,600
and use it and really explore the idea

39946
26:29:39,600 --> 26:29:42,400
of static binding in c plus plus

39947
26:29:42,400 --> 26:29:45,040
inheritance hierarchies so here we are

39948
26:29:45,040 --> 26:29:47,040
trying to create simple

39949
26:29:47,040 --> 26:29:50,160
objects of our classes we have a shape

39950
26:29:50,160 --> 26:29:52,640
object we have an oval object and we

39951
26:29:52,640 --> 26:29:55,440
have a circle object we are going to go

39952
26:29:55,440 --> 26:29:58,480
through a base pointer and try to manage

39953
26:29:58,480 --> 26:30:00,160
our objects here

39954
26:30:00,160 --> 26:30:02,000
in our first line we're going to set up

39955
26:30:02,000 --> 26:30:03,832
a shape pointer and we're going to store

39956
26:30:03,832 --> 26:30:06,872
in the address of shape one and what we

39957
26:30:06,872 --> 26:30:09,760
would want in our c plus plus program is

39958
26:30:09,760 --> 26:30:12,720
that if we call the draw method on this

39959
26:30:12,720 --> 26:30:15,192
shape pointer we would want the shape

39960
26:30:15,192 --> 26:30:17,680
draw method to be called because we have

39961
26:30:17,680 --> 26:30:20,552
a shape object stored in our base

39962
26:30:20,552 --> 26:30:22,960
pointer here or in other words we are

39963
26:30:22,960 --> 26:30:25,912
using a base pointer to manage this

39964
26:30:25,912 --> 26:30:28,552
object in memory down here we store a

39965
26:30:28,552 --> 26:30:32,080
novel object in our shape pointer or in

39966
26:30:32,080 --> 26:30:34,080
other words we're going to be using this

39967
26:30:34,080 --> 26:30:37,360
base pointer to manage an actual oval

39968
26:30:37,360 --> 26:30:40,000
object in memory and the setup we want

39969
26:30:40,000 --> 26:30:42,480
is that if we call the draw method on

39970
26:30:42,480 --> 26:30:44,872
this shape pointer now we are going to

39971
26:30:44,872 --> 26:30:47,832
get the oval draw method to be called

39972
26:30:47,832 --> 26:30:49,832
this is the setup we want

39973
26:30:49,832 --> 26:30:52,080
and down here we have another example

39974
26:30:52,080 --> 26:30:54,640
where we are using this base pointer to

39975
26:30:54,640 --> 26:30:57,680
manage a circle object we are going to

39976
26:30:57,680 --> 26:31:00,080
store the address of the circle object

39977
26:31:00,080 --> 26:31:02,000
in this base pointer this is how we do

39978
26:31:02,000 --> 26:31:04,480
this and when we call

39979
26:31:04,480 --> 26:31:07,760
a draw method on this base pointer we

39980
26:31:07,760 --> 26:31:10,552
want the circle draw method to be called

39981
26:31:10,552 --> 26:31:13,912
so with polymorphism what we really want

39982
26:31:13,912 --> 26:31:18,160
is to call a method on the base pointer

39983
26:31:18,160 --> 26:31:20,640
and get the most specific possible

39984
26:31:20,640 --> 26:31:23,360
method called on our pointer this is the

39985
26:31:23,360 --> 26:31:25,600
setup we want but this is not what we

39986
26:31:25,600 --> 26:31:28,400
get by default in c plus plus if we

39987
26:31:28,400 --> 26:31:31,192
happen to do this and run our program as

39988
26:31:31,192 --> 26:31:33,760
is now with the current knowledge that

39989
26:31:33,760 --> 26:31:36,080
we have on the first line here we're

39990
26:31:36,080 --> 26:31:37,832
going to get the shape draw method

39991
26:31:37,832 --> 26:31:40,000
called this is what we want but on the

39992
26:31:40,000 --> 26:31:42,000
second example here we will see that we

39993
26:31:42,000 --> 26:31:44,720
see the shape draw method also called

39994
26:31:44,720 --> 26:31:47,280
and on this line we will also see that

39995
26:31:47,280 --> 26:31:49,512
we get the shape draw method to be

39996
26:31:49,512 --> 26:31:52,080
called this is not what we want and this

39997
26:31:52,080 --> 26:31:54,960
is static binding so what is happening

39998
26:31:54,960 --> 26:31:58,000
here is the compiler is looking at the

39999
26:31:58,000 --> 26:32:00,872
type of the pointer and it is using that

40000
26:32:00,872 --> 26:32:03,912
to decide which draw method to call so

40001
26:32:03,912 --> 26:32:06,080
the compiler is so the compiler is

40002
26:32:06,080 --> 26:32:08,960
basically saying i have a shape pointer

40003
26:32:08,960 --> 26:32:11,440
so i am going to call the joe method on

40004
26:32:11,440 --> 26:32:14,080
the shape class down here it is going to

40005
26:32:14,080 --> 26:32:16,960
see that it also has a shape pointer and

40006
26:32:16,960 --> 26:32:19,512
it is going to call the draw method on

40007
26:32:19,512 --> 26:32:22,080
shape and down here it is going to see

40008
26:32:22,080 --> 26:32:24,552
that it has a shape pointer and it is

40009
26:32:24,552 --> 26:32:27,040
going to call the jaw method on the

40010
26:32:27,040 --> 26:32:30,000
shape class this is what static binding

40011
26:32:30,000 --> 26:32:31,760
is all about the compiler is going to

40012
26:32:31,760 --> 26:32:35,360
resolve the joe method statically and

40013
26:32:35,360 --> 26:32:37,680
what that means is that the compiler is

40014
26:32:37,680 --> 26:32:39,680
going to look at the type of the pointer

40015
26:32:39,680 --> 26:32:42,320
that we have and it is going to use that

40016
26:32:42,320 --> 26:32:46,000
to decide which joe method to call in

40017
26:32:46,000 --> 26:32:48,720
our inheritance hierarchy so this is the

40018
26:32:48,720 --> 26:32:51,040
default and it is called static binding

40019
26:32:51,040 --> 26:32:53,360
in c plus plus we also get the same

40020
26:32:53,360 --> 26:32:55,760
behavior if we try to use a base

40021
26:32:55,760 --> 26:32:58,640
reference to manage our actual object in

40022
26:32:58,640 --> 26:33:01,192
memory here we have the same kinds of

40023
26:33:01,192 --> 26:33:04,232
objects we had in a previous slide and

40024
26:33:04,232 --> 26:33:07,512
we are using a base reference to manage

40025
26:33:07,512 --> 26:33:10,640
our object and what we really want is

40026
26:33:10,640 --> 26:33:13,280
that if we go through a base reference

40027
26:33:13,280 --> 26:33:16,160
to call our draw method we will get the

40028
26:33:16,160 --> 26:33:19,512
most specific draw method called so if

40029
26:33:19,512 --> 26:33:22,080
our base reference is managing a shape

40030
26:33:22,080 --> 26:33:24,872
we will get the shape draw method called

40031
26:33:24,872 --> 26:33:27,440
if our base reference is managing an

40032
26:33:27,440 --> 26:33:30,000
alpha object we want the oval draw

40033
26:33:30,000 --> 26:33:33,360
method to be called here and if our base

40034
26:33:33,360 --> 26:33:36,320
reference is managing a circle object we

40035
26:33:36,320 --> 26:33:39,440
want the circle joe method called here

40036
26:33:39,440 --> 26:33:41,280
this is what we want but again the

40037
26:33:41,280 --> 26:33:43,192
compiler is just going to look at the

40038
26:33:43,192 --> 26:33:45,512
type of the reference so for the first

40039
26:33:45,512 --> 26:33:47,360
line here it's going to say i have a

40040
26:33:47,360 --> 26:33:50,000
shape reference so i am going to call

40041
26:33:50,000 --> 26:33:51,912
the shape draw method that's what we're

40042
26:33:51,912 --> 26:33:54,320
going to get here on the second line

40043
26:33:54,320 --> 26:33:56,160
here it's going to say uh-huh i have a

40044
26:33:56,160 --> 26:33:59,040
shape reference so i will call

40045
26:33:59,040 --> 26:34:01,040
the draw method of the shape class

40046
26:34:01,040 --> 26:34:02,400
that's what we're going to see here by

40047
26:34:02,400 --> 26:34:04,872
default and on this line here it is

40048
26:34:04,872 --> 26:34:07,360
going to say i have a shape reference so

40049
26:34:07,360 --> 26:34:09,512
i am going to call the draw method on

40050
26:34:09,512 --> 26:34:11,360
the shape class and this is the behavior

40051
26:34:11,360 --> 26:34:14,400
we get by default and this is static

40052
26:34:14,400 --> 26:34:16,960
binding in action okay so now that we

40053
26:34:16,960 --> 26:34:19,040
have seen what static binding is all

40054
26:34:19,040 --> 26:34:22,480
about let's re-examine the idea of why

40055
26:34:22,480 --> 26:34:24,960
we need polymorphism and i am going to

40056
26:34:24,960 --> 26:34:26,640
give you a simple example here suppose

40057
26:34:26,640 --> 26:34:29,120
we have a bunch of shapes we manage in

40058
26:34:29,120 --> 26:34:32,080
our programs and we want to draw all

40059
26:34:32,080 --> 26:34:34,552
these shapes if we want to draw a circle

40060
26:34:34,552 --> 26:34:37,120
with the current setup we have we would

40061
26:34:37,120 --> 26:34:39,360
set up a draw circle method if we want

40062
26:34:39,360 --> 26:34:41,360
to draw a novel we would need to set up

40063
26:34:41,360 --> 26:34:44,000
a draw over method and this will call

40064
26:34:44,000 --> 26:34:46,232
our circle draw method and this will

40065
26:34:46,232 --> 26:34:48,960
call our oval joe method this is going

40066
26:34:48,960 --> 26:34:51,120
to do what we want but try to think

40067
26:34:51,120 --> 26:34:54,160
about this if we have 100 shapes in our

40068
26:34:54,160 --> 26:34:57,832
program we will need to set up 100 such

40069
26:34:57,832 --> 26:34:59,600
methods and this is a mess i don't think

40070
26:34:59,600 --> 26:35:01,760
you want to do something like this

40071
26:35:01,760 --> 26:35:04,400
and we have another simple case that i

40072
26:35:04,400 --> 26:35:06,720
want you to consider suppose we want to

40073
26:35:06,720 --> 26:35:10,000
store all these objects in collections

40074
26:35:10,000 --> 26:35:12,000
and we're going to use an array to try

40075
26:35:12,000 --> 26:35:14,800
and drive this point home here if we

40076
26:35:14,800 --> 26:35:16,720
want to store these guys in collections

40077
26:35:16,720 --> 26:35:18,160
we will need to set up different

40078
26:35:18,160 --> 26:35:21,912
collections because as we have it now we

40079
26:35:21,912 --> 26:35:24,800
can't store different types in an array

40080
26:35:24,800 --> 26:35:27,120
so what we would need to do now is to

40081
26:35:27,120 --> 26:35:29,832
set up an array for circles and set up

40082
26:35:29,832 --> 26:35:32,640
an array for ovals and do more

40083
26:35:32,640 --> 26:35:34,480
collections for different kinds of

40084
26:35:34,480 --> 26:35:36,720
shapes that we support in our program

40085
26:35:36,720 --> 26:35:38,872
and if we want to draw them we have no

40086
26:35:38,872 --> 26:35:40,872
choice but to set up different kinds of

40087
26:35:40,872 --> 26:35:43,192
loops and each of these loops is going

40088
26:35:43,192 --> 26:35:44,960
to be looping on each of these

40089
26:35:44,960 --> 26:35:47,040
collections here hopefully you can see

40090
26:35:47,040 --> 26:35:49,040
that this is by design we don't want to

40091
26:35:49,040 --> 26:35:51,360
do this we want to set up something that

40092
26:35:51,360 --> 26:35:53,192
is really easier to manage in our

40093
26:35:53,192 --> 26:35:56,552
program and polymorphism was

40094
26:35:56,552 --> 26:35:59,040
and polymorphism and c plus plus was

40095
26:35:59,040 --> 26:36:02,320
designed to exactly solve this kind of

40096
26:36:02,320 --> 26:36:03,280
problem

40097
26:36:03,280 --> 26:36:05,040
what we really want in our c plus plus

40098
26:36:05,040 --> 26:36:08,160
programs is to set up one draw method

40099
26:36:08,160 --> 26:36:10,160
for example we can give it a base

40100
26:36:10,160 --> 26:36:12,720
pointer and it doesn't matter which kind

40101
26:36:12,720 --> 26:36:15,280
of object we pass it when we call this

40102
26:36:15,280 --> 26:36:17,760
we will get that method to be called at

40103
26:36:17,760 --> 26:36:20,872
run time when we actually need to draw

40104
26:36:20,872 --> 26:36:23,192
this shape if we pass in a circle this

40105
26:36:23,192 --> 26:36:25,280
is going to draw the draw method on a

40106
26:36:25,280 --> 26:36:28,800
circle if we pass in a novel it will

40107
26:36:28,800 --> 26:36:32,000
call the draw method on our oval object

40108
26:36:32,000 --> 26:36:34,552
if we pass in a rectangle for example it

40109
26:36:34,552 --> 26:36:36,800
is going to call the draw method on our

40110
26:36:36,800 --> 26:36:39,192
rectangle object this is what we want we

40111
26:36:39,192 --> 26:36:41,280
also want the same kind of setup if for

40112
26:36:41,280 --> 26:36:43,040
example our functions are taking

40113
26:36:43,040 --> 26:36:44,800
reference and this is what we're going

40114
26:36:44,800 --> 26:36:46,960
to get this is what we want with

40115
26:36:46,960 --> 26:36:49,280
polymorphism and this is really going to

40116
26:36:49,280 --> 26:36:51,760
improve on the design that we had

40117
26:36:51,760 --> 26:36:54,320
earlier when we needed to set up a

40118
26:36:54,320 --> 26:36:56,640
specific method for each shape and we

40119
26:36:56,640 --> 26:36:58,640
would end up with hundreds of draw

40120
26:36:58,640 --> 26:37:00,960
methods and that's really bad it's not

40121
26:37:00,960 --> 26:37:02,960
manageable this is also going to solve

40122
26:37:02,960 --> 26:37:05,360
our problem with collections

40123
26:37:05,360 --> 26:37:07,600
we really need to set up one collection

40124
26:37:07,600 --> 26:37:09,760
which is going to be taking into account

40125
26:37:09,760 --> 26:37:12,480
all the ships that we manage in our

40126
26:37:12,480 --> 26:37:15,280
inheritance hierarchy so the setup we do

40127
26:37:15,280 --> 26:37:16,640
is something like this we're going to

40128
26:37:16,640 --> 26:37:18,552
set up an array that is going to be

40129
26:37:18,552 --> 26:37:21,440
storing pointers to shape and we can

40130
26:37:21,440 --> 26:37:24,320
store in the address of a shape we can

40131
26:37:24,320 --> 26:37:26,400
store in the address of a novel we can

40132
26:37:26,400 --> 26:37:28,080
store in the address of the circle

40133
26:37:28,080 --> 26:37:30,000
because if you really think about it a

40134
26:37:30,000 --> 26:37:32,080
circle is a shape a novel is the shape

40135
26:37:32,080 --> 26:37:33,912
and the shape is the shape so this is

40136
26:37:33,912 --> 26:37:36,720
going to work and when we get to loop

40137
26:37:36,720 --> 26:37:38,552
through this collection and call the

40138
26:37:38,552 --> 26:37:41,192
draw method for the first item here we

40139
26:37:41,192 --> 26:37:43,440
will call the draw method on the shape

40140
26:37:43,440 --> 26:37:45,512
for the second element here we will call

40141
26:37:45,512 --> 26:37:48,960
the joe method on the oval object and

40142
26:37:48,960 --> 26:37:51,040
for the third element here we will call

40143
26:37:51,040 --> 26:37:54,000
the draw method on our circle object and

40144
26:37:54,000 --> 26:37:56,400
we will draw a shape a novel and a

40145
26:37:56,400 --> 26:37:59,120
circle with just one loop and this is

40146
26:37:59,120 --> 26:38:01,440
really cool this is the design we want

40147
26:38:01,440 --> 26:38:03,680
now this is not the default behavior we

40148
26:38:03,680 --> 26:38:06,232
get in our c plus plus classes if we set

40149
26:38:06,232 --> 26:38:08,400
up an inheritance hierarchy

40150
26:38:08,400 --> 26:38:10,800
with our draw methods what we get by

40151
26:38:10,800 --> 26:38:13,440
default is static binding but we will

40152
26:38:13,440 --> 26:38:16,640
see how we can get dynamic binding or

40153
26:38:16,640 --> 26:38:19,192
polymorphism in the next lecture for

40154
26:38:19,192 --> 26:38:20,872
this one we're going to explore static

40155
26:38:20,872 --> 26:38:22,640
binding and we're going to head over to

40156
26:38:22,640 --> 26:38:24,552
visual studio code and play with us a

40157
26:38:24,552 --> 26:38:27,192
little more here we are in our working

40158
26:38:27,192 --> 26:38:29,440
folder the current project is static

40159
26:38:29,440 --> 26:38:32,232
binding with inheritance we are going to

40160
26:38:32,232 --> 26:38:35,040
grab our template files this is going to

40161
26:38:35,040 --> 26:38:37,360
be our starting point here we're going

40162
26:38:37,360 --> 26:38:40,232
to put in these files and i am going to

40163
26:38:40,232 --> 26:38:42,872
put in our classes to save time

40164
26:38:42,872 --> 26:38:44,640
if you want you can download these

40165
26:38:44,640 --> 26:38:47,192
classes from the attached

40166
26:38:47,192 --> 26:38:48,960
resource section on this lecture you're

40167
26:38:48,960 --> 26:38:50,800
going to find them and you can use them

40168
26:38:50,800 --> 26:38:52,800
as a starting point this is going to

40169
26:38:52,800 --> 26:38:54,872
save us a few seconds because we don't

40170
26:38:54,872 --> 26:38:56,960
really want to type these classes you

40171
26:38:56,960 --> 26:38:59,192
already know how to create classes if

40172
26:38:59,192 --> 26:39:02,232
you made it this far in the course so i

40173
26:39:02,232 --> 26:39:04,640
am going to drag this and drop here to

40174
26:39:04,640 --> 26:39:07,040
open in visual studio code and this is

40175
26:39:07,040 --> 26:39:08,720
going to give us a good starting point

40176
26:39:08,720 --> 26:39:11,440
here we have a base class which is our

40177
26:39:11,440 --> 26:39:13,760
shape class it is going to have a simple

40178
26:39:13,760 --> 26:39:15,832
member variable which is going to be the

40179
26:39:15,832 --> 26:39:18,552
description one thing i think we need to

40180
26:39:18,552 --> 26:39:21,280
improve on this is to use a string view

40181
26:39:21,280 --> 26:39:23,760
to pass our parameter here

40182
26:39:23,760 --> 26:39:26,640
so let's include string view we can

40183
26:39:26,640 --> 26:39:28,400
include that here we're going to say

40184
26:39:28,400 --> 26:39:31,120
include string view because we are using

40185
26:39:31,120 --> 26:39:32,872
modern c plus plus and we're going to

40186
26:39:32,872 --> 26:39:36,480
change this to be an sdd string view by

40187
26:39:36,480 --> 26:39:39,192
value we can do this okay so we have our

40188
26:39:39,192 --> 26:39:41,680
class here and we have a draw method

40189
26:39:41,680 --> 26:39:43,512
which is really not going to do anything

40190
26:39:43,512 --> 26:39:45,280
special it's going to just print the

40191
26:39:45,280 --> 26:39:47,512
description here and we're going to see

40192
26:39:47,512 --> 26:39:50,720
it printed out on the output stream

40193
26:39:50,720 --> 26:39:53,760
if we look at the cpp file we just have

40194
26:39:53,760 --> 26:39:56,080
an implementation of our constructor and

40195
26:39:56,080 --> 26:39:58,720
we have a destructor we're going to fix

40196
26:39:58,720 --> 26:40:01,680
our parameter here to make it an std

40197
26:40:01,680 --> 26:40:05,192
string view let's look at our oval class

40198
26:40:05,192 --> 26:40:06,720
it is going to be

40199
26:40:06,720 --> 26:40:09,440
deriving publicly from shape

40200
26:40:09,440 --> 26:40:11,600
and we have a bunch of member variables

40201
26:40:11,600 --> 26:40:13,760
here two to be exact one is going to be

40202
26:40:13,760 --> 26:40:16,160
the x radius the other is going to be

40203
26:40:16,160 --> 26:40:19,360
our y radius we have a constructor here

40204
26:40:19,360 --> 26:40:21,120
which is going to be taking three

40205
26:40:21,120 --> 26:40:24,232
parameters two parameters for the data

40206
26:40:24,232 --> 26:40:28,400
for our radius here and we have a

40207
26:40:28,400 --> 26:40:30,480
third parameter which is going to store

40208
26:40:30,480 --> 26:40:33,120
our description data we're going to also

40209
26:40:33,120 --> 26:40:36,400
change this to bstd string view and this

40210
26:40:36,400 --> 26:40:38,960
is going to do we have a draw method

40211
26:40:38,960 --> 26:40:41,040
which is going to be printing the

40212
26:40:41,040 --> 26:40:44,480
description and our radius data and this

40213
26:40:44,480 --> 26:40:46,552
is really it we don't need anything

40214
26:40:46,552 --> 26:40:50,232
fancy here let's look at our oval cpp

40215
26:40:50,232 --> 26:40:51,832
file it is going to have the

40216
26:40:51,832 --> 26:40:54,400
implementation for our constructor

40217
26:40:54,400 --> 26:40:56,400
and our destructor here

40218
26:40:56,400 --> 26:40:59,440
we just need to change the type for our

40219
26:40:59,440 --> 26:41:01,912
description here and make this an sdd

40220
26:41:01,912 --> 26:41:04,400
string view let's do this and we will

40221
26:41:04,400 --> 26:41:06,960
look at our circle class which is going

40222
26:41:06,960 --> 26:41:10,000
to be inheriting from

40223
26:41:10,000 --> 26:41:12,640
publicly it won't have any member

40224
26:41:12,640 --> 26:41:14,232
variable because it's just going to

40225
26:41:14,232 --> 26:41:18,000
forward the data to the over portoverse

40226
26:41:18,000 --> 26:41:20,360
it doesn't really need to do any other

40227
26:41:20,360 --> 26:41:23,040
specialization but what we need is a

40228
26:41:23,040 --> 26:41:24,552
method which is going to return the

40229
26:41:24,552 --> 26:41:26,480
radius because we want to print that

40230
26:41:26,480 --> 26:41:30,080
here so we can head over in our oval

40231
26:41:30,080 --> 26:41:33,040
class and set up a protected section

40232
26:41:33,040 --> 26:41:34,960
which is going to give us these methods

40233
26:41:34,960 --> 26:41:36,960
here so i'm just going to put them in

40234
26:41:36,960 --> 26:41:39,440
here to save on some time it is

40235
26:41:39,440 --> 26:41:41,680
protected because we want this to be

40236
26:41:41,680 --> 26:41:44,720
usable in derived classes but we don't

40237
26:41:44,720 --> 26:41:47,512
want this usable from the outside this

40238
26:41:47,512 --> 26:41:49,600
is the setup we can achieve by making

40239
26:41:49,600 --> 26:41:52,480
these guys protected here get x rad is

40240
26:41:52,480 --> 26:41:55,512
going to return the x radius get y rad

40241
26:41:55,512 --> 26:41:57,832
is going to return the y radius they are

40242
26:41:57,832 --> 26:42:00,080
const because we don't intend for this

40243
26:42:00,080 --> 26:42:03,360
to modify our object and if we go in our

40244
26:42:03,360 --> 26:42:06,320
circle class this is going to work now

40245
26:42:06,320 --> 26:42:08,800
we will be able to print our

40246
26:42:08,800 --> 26:42:11,360
information on our circle object and we

40247
26:42:11,360 --> 26:42:14,800
will see on our output stream if we look

40248
26:42:14,800 --> 26:42:17,040
at the implementation of our circle

40249
26:42:17,040 --> 26:42:19,680
class it is nothing complicated it is

40250
26:42:19,680 --> 26:42:22,160
just going to take the double radius and

40251
26:42:22,160 --> 26:42:24,232
it is going to forward the data to the

40252
26:42:24,232 --> 26:42:27,680
oval part of us and our description here

40253
26:42:27,680 --> 26:42:29,832
will need to change

40254
26:42:29,832 --> 26:42:32,480
to take into account that we want to use

40255
26:42:32,480 --> 26:42:34,800
std string view here so let's change

40256
26:42:34,800 --> 26:42:38,960
this to bhd string view we can do that

40257
26:42:38,960 --> 26:42:42,160
and we are going to head over in our cpp

40258
26:42:42,160 --> 26:42:45,600
file and change that as well std string

40259
26:42:45,600 --> 26:42:48,552
view you can do that and now our classes

40260
26:42:48,552 --> 26:42:51,040
are really complete we can head over in

40261
26:42:51,040 --> 26:42:54,480
our main cpp file we can clean that up a

40262
26:42:54,480 --> 26:42:56,160
little bit and we're going to remove

40263
26:42:56,160 --> 26:42:58,080
what we don't need here

40264
26:42:58,080 --> 26:43:00,160
we are going to include our classes so

40265
26:43:00,160 --> 26:43:02,232
we're going to include shape let's do

40266
26:43:02,232 --> 26:43:03,040
that

40267
26:43:03,040 --> 26:43:05,832
we are going to put in oval let's do

40268
26:43:05,832 --> 26:43:09,280
that oval dot h and we are going to put

40269
26:43:09,280 --> 26:43:11,440
in circle and we are going to create

40270
26:43:11,440 --> 26:43:13,512
objects of these classes and try to

40271
26:43:13,512 --> 26:43:15,760
print their information so we're going

40272
26:43:15,760 --> 26:43:18,000
to set up a shape called the shape one

40273
26:43:18,000 --> 26:43:19,512
we're going to set up a novel called

40274
26:43:19,512 --> 26:43:21,600
oval one we're going to set up a circle

40275
26:43:21,600 --> 26:43:23,360
called circle one and we're going to see

40276
26:43:23,360 --> 26:43:25,832
what kind of information we see

40277
26:43:25,832 --> 26:43:28,720
if we try to call the job method again

40278
26:43:28,720 --> 26:43:30,640
in shape the draw method is just going

40279
26:43:30,640 --> 26:43:33,512
to say that we are calling shape joe

40280
26:43:33,512 --> 26:43:35,600
in alvo we are going to say that we are

40281
26:43:35,600 --> 26:43:38,000
drawing an oval and we're going to say

40282
26:43:38,000 --> 26:43:40,640
the description and the radius in circle

40283
26:43:40,640 --> 26:43:42,320
we're going to say that we are calling

40284
26:43:42,320 --> 26:43:44,800
the draw method on the circle object and

40285
26:43:44,800 --> 26:43:47,120
say the description and the radius here

40286
26:43:47,120 --> 26:43:49,512
this is the information we want so we

40287
26:43:49,512 --> 26:43:52,872
are going to try and build this program

40288
26:43:52,872 --> 26:43:55,680
using gcc our favorite compiler you can

40289
26:43:55,680 --> 26:43:57,760
really use any compiler you have your

40290
26:43:57,760 --> 26:44:00,080
hands on but we are going to use gcc

40291
26:44:00,080 --> 26:44:02,480
here because it is our favorite and

40292
26:44:02,480 --> 26:44:05,512
we're going to have a bunch of errors

40293
26:44:05,512 --> 26:44:08,232
what it is that we have here what is it

40294
26:44:08,232 --> 26:44:10,320
that we have here let's go in shape

40295
26:44:10,320 --> 26:44:11,360
header

40296
26:44:11,360 --> 26:44:14,960
at line 4 and see what we have and we

40297
26:44:14,960 --> 26:44:17,280
have a j here that we don't want let's

40298
26:44:17,280 --> 26:44:19,040
take this out and we're going to build

40299
26:44:19,040 --> 26:44:20,872
it and we're going to pass this through

40300
26:44:20,872 --> 26:44:23,512
gcc and the bolt is going to be good we

40301
26:44:23,512 --> 26:44:26,080
can bring up a powershell window to run

40302
26:44:26,080 --> 26:44:28,640
our program let's run rooster and we're

40303
26:44:28,640 --> 26:44:30,960
going to see that shape draw was called

40304
26:44:30,960 --> 26:44:33,832
drawing shape one you see we have just

40305
26:44:33,832 --> 26:44:36,720
created shape one here and we are

40306
26:44:36,720 --> 26:44:38,800
printing its information

40307
26:44:38,800 --> 26:44:41,360
we are going to call the oval drill

40308
26:44:41,360 --> 26:44:43,832
method and we're going to print

40309
26:44:43,832 --> 26:44:45,600
the information on that you see that it

40310
26:44:45,600 --> 26:44:48,000
is over one here and we're going to put

40311
26:44:48,000 --> 26:44:50,960
out our radius data x radius is going to

40312
26:44:50,960 --> 26:44:54,080
be 2 as we specified here y radius is

40313
26:44:54,080 --> 26:44:56,232
going to be 3.5 and this is our

40314
26:44:56,232 --> 26:44:58,800
information we are also going to call

40315
26:44:58,800 --> 26:45:01,120
the draw method on our circle object

40316
26:45:01,120 --> 26:45:03,600
this is what we get and we're going to

40317
26:45:03,600 --> 26:45:05,760
say we are drawing circle 1 and the

40318
26:45:05,760 --> 26:45:08,320
radius is going to be 3 3 this is our

40319
26:45:08,320 --> 26:45:11,440
information here but we don't want to go

40320
26:45:11,440 --> 26:45:14,160
through direct objects to manage our

40321
26:45:14,160 --> 26:45:16,800
data here what we want is to either go

40322
26:45:16,800 --> 26:45:20,320
through base pointers or base references

40323
26:45:20,320 --> 26:45:22,232
so we are going to set up a shape

40324
26:45:22,232 --> 26:45:24,160
pointer let's do that we're going to say

40325
26:45:24,160 --> 26:45:26,480
shift because that's our base class and

40326
26:45:26,480 --> 26:45:27,832
we're going to say

40327
26:45:27,832 --> 26:45:30,960
shape ptr to represent our pointer and

40328
26:45:30,960 --> 26:45:33,360
we're going to store in the address of

40329
26:45:33,360 --> 26:45:35,512
shape one we can do something like this

40330
26:45:35,512 --> 26:45:37,360
and that's really see what is happening

40331
26:45:37,360 --> 26:45:39,832
we're going to comment out our calls to

40332
26:45:39,832 --> 26:45:42,160
draw methods here and we're going to see

40333
26:45:42,160 --> 26:45:46,232
what happens so if we say shape ptr and

40334
26:45:46,232 --> 26:45:48,320
call the draw method we can do that

40335
26:45:48,320 --> 26:45:50,480
let's try and build our program

40336
26:45:50,480 --> 26:45:52,800
we're going to pass this through gcc

40337
26:45:52,800 --> 26:45:54,232
you're going to see that it is going to

40338
26:45:54,232 --> 26:45:56,080
work and it is going to do what we

40339
26:45:56,080 --> 26:45:58,400
expect if we run this program here you

40340
26:45:58,400 --> 26:46:00,640
can clear and run rooster we're going to

40341
26:46:00,640 --> 26:46:03,360
see that shape draw was called and we

40342
26:46:03,360 --> 26:46:05,440
are going to be drawing shape one here

40343
26:46:05,440 --> 26:46:08,232
this is what we expect but if we go down

40344
26:46:08,232 --> 26:46:11,192
and say we don't want to call the draw

40345
26:46:11,192 --> 26:46:13,680
method here we are going to store in

40346
26:46:13,680 --> 26:46:15,760
let's say shape ptr and we're going to

40347
26:46:15,760 --> 26:46:19,440
store in the address of our over one

40348
26:46:19,440 --> 26:46:20,480
object

40349
26:46:20,480 --> 26:46:23,832
and we want to call the draw method here

40350
26:46:23,832 --> 26:46:26,232
now if you do this as we saw in the

40351
26:46:26,232 --> 26:46:28,320
slides what we really want

40352
26:46:28,320 --> 26:46:32,160
is to get the draw method on our actual

40353
26:46:32,160 --> 26:46:35,120
oval object called and if we will for

40354
26:46:35,120 --> 26:46:37,040
example drawing things on the screen we

40355
26:46:37,040 --> 26:46:39,192
would draw a novel this is what we want

40356
26:46:39,192 --> 26:46:41,040
here but this is not what we're going to

40357
26:46:41,040 --> 26:46:42,720
get you're going to see that we still

40358
26:46:42,720 --> 26:46:43,832
get the

40359
26:46:43,832 --> 26:46:46,552
job method from the shape class called

40360
26:46:46,552 --> 26:46:48,400
and it is going to and it is going to

40361
26:46:48,400 --> 26:46:51,680
say drawing over one let's try and build

40362
26:46:51,680 --> 26:46:53,600
this program and i really want you to

40363
26:46:53,600 --> 26:46:55,912
see this so the builder is good we can

40364
26:46:55,912 --> 26:46:57,912
clear and run rooster you're going to

40365
26:46:57,912 --> 26:46:59,360
see

40366
26:46:59,360 --> 26:47:02,640
row even if we are storing again

40367
26:47:02,640 --> 26:47:03,912
a novel

40368
26:47:03,912 --> 26:47:07,120
object so this is the default behavior

40369
26:47:07,120 --> 26:47:09,280
we get and this is static binding that

40370
26:47:09,280 --> 26:47:12,640
we get by default in our inheritance

40371
26:47:12,640 --> 26:47:15,040
hierarchies so what the compiler is

40372
26:47:15,040 --> 26:47:16,640
really going to do here it's going to

40373
26:47:16,640 --> 26:47:19,040
look at the type of the pointer that we

40374
26:47:19,040 --> 26:47:21,360
have here it is going to say i have a

40375
26:47:21,360 --> 26:47:24,400
shape pointer so i am going to call the

40376
26:47:24,400 --> 26:47:26,872
jaw method on the shape type that i have

40377
26:47:26,872 --> 26:47:29,280
in my pointer here and we are going to

40378
26:47:29,280 --> 26:47:30,080
see

40379
26:47:30,080 --> 26:47:32,480
that this is calling the draw method on

40380
26:47:32,480 --> 26:47:35,680
our shape and this is not what we want

40381
26:47:35,680 --> 26:47:38,320
in most cases we are going to see that

40382
26:47:38,320 --> 26:47:41,120
we get the same behavior if we store an

40383
26:47:41,120 --> 26:47:43,512
a circle object let's do that we're

40384
26:47:43,512 --> 26:47:45,440
going to say shift pointer and we're

40385
26:47:45,440 --> 26:47:48,232
going to store in the address of our

40386
26:47:48,232 --> 26:47:50,480
circle one and then we're going to call

40387
26:47:50,480 --> 26:47:53,760
our draw method on our shape pointer

40388
26:47:53,760 --> 26:47:57,192
again this is going to draw a shape it's

40389
26:47:57,192 --> 26:47:59,680
not going to draw a circle that we

40390
26:47:59,680 --> 26:48:02,232
really are managing with our base

40391
26:48:02,232 --> 26:48:04,480
pointer here and some of you must be

40392
26:48:04,480 --> 26:48:05,600
thinking

40393
26:48:05,600 --> 26:48:09,192
why are we able to store circle pointers

40394
26:48:09,192 --> 26:48:11,680
for example in a shape well a circle is

40395
26:48:11,680 --> 26:48:14,320
a shape according to our inheritance

40396
26:48:14,320 --> 26:48:16,960
hierarchy if we take a closer look again

40397
26:48:16,960 --> 26:48:19,120
here you're going to see that oval is

40398
26:48:19,120 --> 26:48:22,960
going to be inheriting from shape

40399
26:48:22,960 --> 26:48:25,600
and the circle is going to be inheriting

40400
26:48:25,600 --> 26:48:28,640
from oval so from what we learned in the

40401
26:48:28,640 --> 26:48:30,000
last chapter

40402
26:48:30,000 --> 26:48:32,872
oval has a shape part in it and the

40403
26:48:32,872 --> 26:48:36,000
circle has a novel part in it which in

40404
26:48:36,000 --> 26:48:38,552
turn is going to have a shaped board in

40405
26:48:38,552 --> 26:48:40,720
it so from this understanding it

40406
26:48:40,720 --> 26:48:43,280
shouldn't really be surprising that we

40407
26:48:43,280 --> 26:48:45,760
are able to manage a

40408
26:48:45,760 --> 26:48:49,440
novel object with a shape pointer or the

40409
26:48:49,440 --> 26:48:52,000
fact that we are able to manage a circle

40410
26:48:52,000 --> 26:48:53,040
object

40411
26:48:53,040 --> 26:48:55,600
using a shape pointer this is why we are

40412
26:48:55,600 --> 26:48:58,320
able to do something like this okay so i

40413
26:48:58,320 --> 26:49:00,800
hope this is super clear but again we

40414
26:49:00,800 --> 26:49:03,280
are not getting the default behavior

40415
26:49:03,280 --> 26:49:05,512
that we want but we will see how we can

40416
26:49:05,512 --> 26:49:08,320
achieve that in the next lecture for now

40417
26:49:08,320 --> 26:49:10,720
i really want you to understand what

40418
26:49:10,720 --> 26:49:13,120
static binding is all about and it is

40419
26:49:13,120 --> 26:49:15,120
the fact that the compiler is going to

40420
26:49:15,120 --> 26:49:17,680
look at the type of the pointer here and

40421
26:49:17,680 --> 26:49:20,320
use that to decide which method it is

40422
26:49:20,320 --> 26:49:21,832
going to be calling

40423
26:49:21,832 --> 26:49:24,160
in our inheritance hierarchy the

40424
26:49:24,160 --> 26:49:25,600
compiler for example is going to see

40425
26:49:25,600 --> 26:49:28,400
that we have a circle object stored n at

40426
26:49:28,400 --> 26:49:31,192
lineup 25 here but when it wants to

40427
26:49:31,192 --> 26:49:34,480
decide which joe version to call it is

40428
26:49:34,480 --> 26:49:36,400
going to look at the type of this

40429
26:49:36,400 --> 26:49:38,800
pointer here and it is going to use that

40430
26:49:38,800 --> 26:49:41,360
to decide which draw method to call and

40431
26:49:41,360 --> 26:49:43,120
in this case it is going to call the

40432
26:49:43,120 --> 26:49:45,512
shape version because the type of this

40433
26:49:45,512 --> 26:49:48,232
pointer is shape okay so i really hope

40434
26:49:48,232 --> 26:49:50,640
this is super clear here we are going to

40435
26:49:50,640 --> 26:49:52,800
get the same behavior if we try to

40436
26:49:52,800 --> 26:49:55,832
manage our objects using references for

40437
26:49:55,832 --> 26:49:58,160
example if we go through a shape

40438
26:49:58,160 --> 26:49:59,680
reference let's do that we're going to

40439
26:49:59,680 --> 26:50:02,400
say shape reference and say shape ref

40440
26:50:02,400 --> 26:50:04,640
and we are going to store in shape one

40441
26:50:04,640 --> 26:50:06,960
for example let's do that

40442
26:50:06,960 --> 26:50:09,912
and we want to call the draw method on

40443
26:50:09,912 --> 26:50:13,040
ship reference let's do that so let's

40444
26:50:13,040 --> 26:50:15,440
call the joe method and you're going to

40445
26:50:15,440 --> 26:50:18,080
see that we will get the shape method

40446
26:50:18,080 --> 26:50:19,040
called

40447
26:50:19,040 --> 26:50:20,960
and this is really making sense because

40448
26:50:20,960 --> 26:50:23,120
we have a shape object

40449
26:50:23,120 --> 26:50:25,512
managed by this reference here so if we

40450
26:50:25,512 --> 26:50:27,192
build our program let's do that we're

40451
26:50:27,192 --> 26:50:29,360
going to pass this through gcc

40452
26:50:29,360 --> 26:50:31,040
you're going to see that we get what we

40453
26:50:31,040 --> 26:50:32,800
expect the build is going to be good

40454
26:50:32,800 --> 26:50:35,192
we're going to clear and run rooster and

40455
26:50:35,192 --> 26:50:37,680
we see shape drill called this is what

40456
26:50:37,680 --> 26:50:40,720
we want but if we use this reference to

40457
26:50:40,720 --> 26:50:43,120
manage derived object for example let's

40458
26:50:43,120 --> 26:50:45,680
put in over one we can do that we're

40459
26:50:45,680 --> 26:50:48,552
going to see that we don't get the most

40460
26:50:48,552 --> 26:50:51,760
specific draw method for oval here

40461
26:50:51,760 --> 26:50:54,400
called we will still get the method

40462
26:50:54,400 --> 26:50:56,320
for a shape called let's build and show

40463
26:50:56,320 --> 26:50:59,040
you this this is static binding again

40464
26:50:59,040 --> 26:51:01,280
okay the build is good we can clear and

40465
26:51:01,280 --> 26:51:02,800
run rooster we're going to see that

40466
26:51:02,800 --> 26:51:05,832
shape draw it is drawing we don't get

40467
26:51:05,832 --> 26:51:08,872
the ovo draw method called we get shape

40468
26:51:08,872 --> 26:51:10,960
drill method again the compiler is going

40469
26:51:10,960 --> 26:51:12,960
to look at the type of this reference by

40470
26:51:12,960 --> 26:51:15,192
default and it is going to use that to

40471
26:51:15,192 --> 26:51:17,832
decide which draw method to call if we

40472
26:51:17,832 --> 26:51:20,320
even put in a circle we are going to get

40473
26:51:20,320 --> 26:51:23,280
the same behavior let's build with gcc

40474
26:51:23,280 --> 26:51:25,512
the bolt is good we can clear and run

40475
26:51:25,512 --> 26:51:27,912
rooster we see that shape draw is called

40476
26:51:27,912 --> 26:51:29,512
and this is really not

40477
26:51:29,512 --> 26:51:31,832
what we want okay so this is static

40478
26:51:31,832 --> 26:51:34,232
binding and it is the default behavior

40479
26:51:34,232 --> 26:51:36,960
we get if we have an inheritance

40480
26:51:36,960 --> 26:51:40,320
hierarchy with the same method spread

40481
26:51:40,320 --> 26:51:43,192
across each derived class we're going to

40482
26:51:43,192 --> 26:51:45,600
get the shape version called even if

40483
26:51:45,600 --> 26:51:47,912
what we are really managing with a shape

40484
26:51:47,912 --> 26:51:50,480
pointer or a shape reference is a

40485
26:51:50,480 --> 26:51:52,480
derived object i really want you to

40486
26:51:52,480 --> 26:51:55,120
understand this now let's see why this

40487
26:51:55,120 --> 26:51:58,000
is really badly designed by default in c

40488
26:51:58,000 --> 26:52:00,400
plus plus if you happen to need to pass

40489
26:52:00,400 --> 26:52:02,872
ship parameters to functions for example

40490
26:52:02,872 --> 26:52:04,800
we might do something like this we might

40491
26:52:04,800 --> 26:52:06,960
need a function to draw a circle we

40492
26:52:06,960 --> 26:52:08,960
might need a function to draw a novel

40493
26:52:08,960 --> 26:52:11,680
and if you happen to have 100 objects

40494
26:52:11,680 --> 26:52:14,080
you can draw in your program you have no

40495
26:52:14,080 --> 26:52:17,192
choice but to set up 100 drawing methods

40496
26:52:17,192 --> 26:52:19,512
or functions this is really bad design

40497
26:52:19,512 --> 26:52:21,600
you don't want to do something like this

40498
26:52:21,600 --> 26:52:23,680
so what you would do in your program for

40499
26:52:23,680 --> 26:52:25,832
example is go down

40500
26:52:25,832 --> 26:52:27,680
and say drawing

40501
26:52:27,680 --> 26:52:29,760
and you would say for example draw

40502
26:52:29,760 --> 26:52:32,800
circle and pass in a circle and say draw

40503
26:52:32,800 --> 26:52:35,280
oval do we have a draw or full function

40504
26:52:35,280 --> 26:52:37,512
let's see yes we have that we can go

40505
26:52:37,512 --> 26:52:40,800
down and say draw oval and pass in our

40506
26:52:40,800 --> 26:52:43,280
oval one this is going to work just fine

40507
26:52:43,280 --> 26:52:44,872
but hopefully you can see that this is

40508
26:52:44,872 --> 26:52:47,600
bad design if you have a lot of shapes

40509
26:52:47,600 --> 26:52:50,000
in your program this is going to quickly

40510
26:52:50,000 --> 26:52:52,232
become and manageable and you don't want

40511
26:52:52,232 --> 26:52:54,800
to do something like this what we want

40512
26:52:54,800 --> 26:52:56,720
is to be able

40513
26:52:56,720 --> 26:52:59,760
to only have one method and get to the c

40514
26:52:59,760 --> 26:53:02,080
plus plus runtime to resolve which one

40515
26:53:02,080 --> 26:53:05,120
is called at runtime when we get to pass

40516
26:53:05,120 --> 26:53:08,080
our actual objects and we will only have

40517
26:53:08,080 --> 26:53:10,400
one function which is going to take into

40518
26:53:10,400 --> 26:53:13,192
account hundreds of shapes that we might

40519
26:53:13,192 --> 26:53:14,960
potentially have in our c plus plus

40520
26:53:14,960 --> 26:53:17,360
program this is going to be much easier

40521
26:53:17,360 --> 26:53:19,512
to manage and we will actually be able

40522
26:53:19,512 --> 26:53:22,160
to achieve this in the next lecture so

40523
26:53:22,160 --> 26:53:24,552
stay tuned for that another problem with

40524
26:53:24,552 --> 26:53:26,872
us is if you happen to need to store

40525
26:53:26,872 --> 26:53:29,440
these shapes in collections if you need

40526
26:53:29,440 --> 26:53:31,120
to set up something like this you will

40527
26:53:31,120 --> 26:53:33,600
have no choice but to set up different

40528
26:53:33,600 --> 26:53:36,800
collections for each type for example we

40529
26:53:36,800 --> 26:53:39,120
might set up a collection for a circle a

40530
26:53:39,120 --> 26:53:41,760
collection for oval and here we are just

40531
26:53:41,760 --> 26:53:44,480
using arrays to model our collections

40532
26:53:44,480 --> 26:53:46,400
this is really bad design if you happen

40533
26:53:46,400 --> 26:53:49,120
to have 100 shapes in your program you

40534
26:53:49,120 --> 26:53:52,552
will set up 100 such collections and the

40535
26:53:52,552 --> 26:53:54,400
only difference is that they are just

40536
26:53:54,400 --> 26:53:56,320
different types and this is really bad

40537
26:53:56,320 --> 26:53:58,000
design because even if they are

40538
26:53:58,000 --> 26:54:00,640
different types they are related and

40539
26:54:00,640 --> 26:54:02,720
they are all shapes in our c plus plus

40540
26:54:02,720 --> 26:54:05,192
program and what we really want is to

40541
26:54:05,192 --> 26:54:07,192
set up one collection which is going to

40542
26:54:07,192 --> 26:54:09,600
take into account all these kinds of

40543
26:54:09,600 --> 26:54:11,600
shapes that we might have in our c plus

40544
26:54:11,600 --> 26:54:14,000
plus program and we will be able to

40545
26:54:14,000 --> 26:54:16,480
achieve this again in the next lecture

40546
26:54:16,480 --> 26:54:18,320
but the whole point of this lecture was

40547
26:54:18,320 --> 26:54:20,640
to show you static binding that we get

40548
26:54:20,640 --> 26:54:22,800
by default with our inheritance

40549
26:54:22,800 --> 26:54:26,000
hierarchies static binding may be bad if

40550
26:54:26,000 --> 26:54:29,280
you really are managing a lot of related

40551
26:54:29,280 --> 26:54:31,680
objects in your c plus plus program

40552
26:54:31,680 --> 26:54:34,320
and all these objects have the same

40553
26:54:34,320 --> 26:54:35,360
method

40554
26:54:35,360 --> 26:54:38,400
that each derived class is specializing

40555
26:54:38,400 --> 26:54:40,800
but you want the most specialized method

40556
26:54:40,800 --> 26:54:43,912
to be called on the actual object that

40557
26:54:43,912 --> 26:54:46,800
you are managing with a base pointer or

40558
26:54:46,800 --> 26:54:48,960
a base reference hopefully this is super

40559
26:54:48,960 --> 26:54:51,440
clear i apologize this lecture turned

40560
26:54:51,440 --> 26:54:54,000
out to be really long but i wanted you

40561
26:54:54,000 --> 26:54:56,480
to make this super clear and everything

40562
26:54:56,480 --> 26:54:58,552
else we do in the reminder of this

40563
26:54:58,552 --> 26:55:00,640
chapter is really going to fall in place

40564
26:55:00,640 --> 26:55:02,640
so make sure you understand this and if

40565
26:55:02,640 --> 26:55:04,872
you have a problem do you ask me i will

40566
26:55:04,872 --> 26:55:07,040
do the best i can to help you out this

40567
26:55:07,040 --> 26:55:08,640
is really all i had to share in this

40568
26:55:08,640 --> 26:55:10,872
lecture i hope you found it interesting

40569
26:55:10,872 --> 26:55:12,720
we are going to stop here in this

40570
26:55:12,720 --> 26:55:14,400
lecture in the next one we're going to

40571
26:55:14,400 --> 26:55:16,872
show you how you can achieve dynamic

40572
26:55:16,872 --> 26:55:20,080
binding using virtual functions in c

40573
26:55:20,080 --> 26:55:21,192
plus plus

40574
26:55:21,192 --> 26:55:23,440
go ahead and finish up here and meet me

40575
26:55:23,440 --> 26:55:25,512
there in this lecture we're going to see

40576
26:55:25,512 --> 26:55:28,800
how we can achieve dynamic binding or

40577
26:55:28,800 --> 26:55:30,552
polymorphism

40578
26:55:30,552 --> 26:55:32,960
using virtual functions in our

40579
26:55:32,960 --> 26:55:35,280
inheritance hierarchies in the last

40580
26:55:35,280 --> 26:55:37,912
lecture we had a hierarchy like this

40581
26:55:37,912 --> 26:55:40,320
where the base class was shaped we had

40582
26:55:40,320 --> 26:55:43,280
an overclass which was publicly deriving

40583
26:55:43,280 --> 26:55:45,832
or inheriting from shape and we had a

40584
26:55:45,832 --> 26:55:48,000
circle class which was publicly

40585
26:55:48,000 --> 26:55:50,232
inherited from over and the problem we

40586
26:55:50,232 --> 26:55:53,280
had was that if we happen to be managing

40587
26:55:53,280 --> 26:55:56,480
oval or circle objects using

40588
26:55:56,480 --> 26:55:59,600
shape pointers or shape references we

40589
26:55:59,600 --> 26:56:02,080
don't get the correct methods called if

40590
26:56:02,080 --> 26:56:04,160
we call the draw method

40591
26:56:04,160 --> 26:56:07,512
on our base pointer or base reference

40592
26:56:07,512 --> 26:56:09,440
and this was really bad and this is

40593
26:56:09,440 --> 26:56:12,160
something we want in practical c plus

40594
26:56:12,160 --> 26:56:14,400
plus programs i am here to tell you in

40595
26:56:14,400 --> 26:56:16,400
this lecture that you can just achieve

40596
26:56:16,400 --> 26:56:17,192
that

40597
26:56:17,192 --> 26:56:20,160
by doing a tiny modification on your

40598
26:56:20,160 --> 26:56:22,640
inheritance hierarchy all you need to do

40599
26:56:22,640 --> 26:56:25,192
is to mark the methods you need to be

40600
26:56:25,192 --> 26:56:27,600
dynamically resolved

40601
26:56:27,600 --> 26:56:30,640
virtual and we do that by inserting this

40602
26:56:30,640 --> 26:56:33,832
virtual keyword in front of our function

40603
26:56:33,832 --> 26:56:35,440
so we're going to do that on our shape

40604
26:56:35,440 --> 26:56:37,600
class we're going to do that on our over

40605
26:56:37,600 --> 26:56:40,000
class and we're going to do that on our

40606
26:56:40,000 --> 26:56:42,800
circle class once we do this the c plus

40607
26:56:42,800 --> 26:56:45,280
plus compiler is going to know i want to

40608
26:56:45,280 --> 26:56:47,832
be looking at the type of the pointer or

40609
26:56:47,832 --> 26:56:50,160
reference to know which kind of method

40610
26:56:50,160 --> 26:56:53,360
to call and my inheritance hierarchy if

40611
26:56:53,360 --> 26:56:55,832
i happen to be using a base pointer or a

40612
26:56:55,832 --> 26:56:58,640
base reference to manage a derived

40613
26:56:58,640 --> 26:57:00,400
object and we're going to be making this

40614
26:57:00,400 --> 26:57:02,800
super clear in a minute and if you are

40615
26:57:02,800 --> 26:57:04,640
lost please bear with me you're going to

40616
26:57:04,640 --> 26:57:06,640
understand so let's do this we're going

40617
26:57:06,640 --> 26:57:10,080
to modify our shape class and change our

40618
26:57:10,080 --> 26:57:12,232
draw method to be virtual

40619
26:57:12,232 --> 26:57:14,480
as you see here we're going to head over

40620
26:57:14,480 --> 26:57:16,800
in our oval class we're going to modify

40621
26:57:16,800 --> 26:57:18,960
our draw method and mark it to be

40622
26:57:18,960 --> 26:57:21,760
virtual using the virtual keyword here

40623
26:57:21,760 --> 26:57:24,080
and we're going to move in our circle

40624
26:57:24,080 --> 26:57:27,912
class and change it to be virtual as you

40625
26:57:27,912 --> 26:57:29,760
see down here this is really all we need

40626
26:57:29,760 --> 26:57:30,720
to do

40627
26:57:30,720 --> 26:57:33,600
from what we had in the last lecture and

40628
26:57:33,600 --> 26:57:36,160
this is going to be magic let's look at

40629
26:57:36,160 --> 26:57:38,160
what we can achieve now we're going to

40630
26:57:38,160 --> 26:57:41,040
set up three objects shape oval and

40631
26:57:41,040 --> 26:57:43,192
circle as you see here and we're going

40632
26:57:43,192 --> 26:57:45,120
to be calling our method which is going

40633
26:57:45,120 --> 26:57:46,960
to be taking references and we're going

40634
26:57:46,960 --> 26:57:50,000
to see that we get the correct most

40635
26:57:50,000 --> 26:57:52,552
specific method called so for example

40636
26:57:52,552 --> 26:57:55,280
here we will call the shape joe down

40637
26:57:55,280 --> 26:57:57,512
here we will call the oval draw method

40638
26:57:57,512 --> 26:58:00,480
because we just passed in a novel object

40639
26:58:00,480 --> 26:58:02,720
and on the third line here we will get

40640
26:58:02,720 --> 26:58:05,360
the circle joe method called and we will

40641
26:58:05,360 --> 26:58:07,680
see it printed out on the console this

40642
26:58:07,680 --> 26:58:09,360
is really cool this is what we want to

40643
26:58:09,360 --> 26:58:12,000
achieve if we want to call our methods

40644
26:58:12,000 --> 26:58:14,800
that take pointers we can do that and on

40645
26:58:14,800 --> 26:58:16,872
the first line here we will call shape

40646
26:58:16,872 --> 26:58:19,192
draw on the second line here we will

40647
26:58:19,192 --> 26:58:21,832
call overdraw and on the third line here

40648
26:58:21,832 --> 26:58:24,080
we will call circuit draw this is what

40649
26:58:24,080 --> 26:58:26,320
we want to achieve and if we happen to

40650
26:58:26,320 --> 26:58:29,120
be setting up a roll base pointer like

40651
26:58:29,120 --> 26:58:31,120
we do here and store in

40652
26:58:31,120 --> 26:58:34,400
a derived object like this or another

40653
26:58:34,400 --> 26:58:36,800
way to say this if we happen to be using

40654
26:58:36,800 --> 26:58:39,440
this base pointer to manage a derived

40655
26:58:39,440 --> 26:58:42,160
object and we call the draw method on

40656
26:58:42,160 --> 26:58:44,800
the base pointer the compiler is going

40657
26:58:44,800 --> 26:58:47,280
to know that it will need to resolve

40658
26:58:47,280 --> 26:58:50,720
this draw method dynamically the reason

40659
26:58:50,720 --> 26:58:53,760
is this is a virtual method and if a

40660
26:58:53,760 --> 26:58:56,000
method is virtual the compiler want to

40661
26:58:56,000 --> 26:58:56,720
do

40662
26:58:56,720 --> 26:58:58,800
static binding like we did in the last

40663
26:58:58,800 --> 26:59:00,320
lecture the compiler is going to be

40664
26:59:00,320 --> 26:59:04,400
doing dynamic binding and with dynamic

40665
26:59:04,400 --> 26:59:06,160
binding the compiler is not going to

40666
26:59:06,160 --> 26:59:08,552
look at the type of the pointer it is

40667
26:59:08,552 --> 26:59:11,280
going to look at the type of the actual

40668
26:59:11,280 --> 26:59:14,552
object that the pointer is managing and

40669
26:59:14,552 --> 26:59:16,872
this is going to give us the behavior

40670
26:59:16,872 --> 26:59:19,040
that we wanted starting from the last

40671
26:59:19,040 --> 26:59:20,800
lecture okay now that you know this

40672
26:59:20,800 --> 26:59:22,232
we're going to head over to visual

40673
26:59:22,232 --> 26:59:24,080
studio code and play with us a little

40674
26:59:24,080 --> 26:59:26,960
more here we are in our working folder

40675
26:59:26,960 --> 26:59:29,760
the current project is polymorphism with

40676
26:59:29,760 --> 26:59:32,320
virtual functions we are going to be

40677
26:59:32,320 --> 26:59:34,320
reusing the code from the last lecture

40678
26:59:34,320 --> 26:59:35,680
because that's going to give us

40679
26:59:35,680 --> 26:59:37,440
everything we want

40680
26:59:37,440 --> 26:59:39,600
we will leave out the

40681
26:59:39,600 --> 26:59:42,160
binary file here which is rooster and

40682
26:59:42,160 --> 26:59:43,832
we're going to copy everything we want

40683
26:59:43,832 --> 26:59:46,000
we're going to put that in the current

40684
26:59:46,000 --> 26:59:48,480
project and we're going to open this in

40685
26:59:48,480 --> 26:59:51,120
visual studio code we are going to have

40686
26:59:51,120 --> 26:59:54,080
our main cpp file with a bunch of

40687
26:59:54,080 --> 26:59:55,512
methods here

40688
26:59:55,512 --> 26:59:58,232
and we will just need to modify this a

40689
26:59:58,232 --> 27:00:01,120
little bit to achieve dynamic binding as

40690
27:00:01,120 --> 27:00:03,600
we saw in the slides all we need to do

40691
27:00:03,600 --> 27:00:06,480
is to mark all these draw methods as

40692
27:00:06,480 --> 27:00:08,720
virtual so we're going to say virtual

40693
27:00:08,720 --> 27:00:11,600
void draw in the shape class we're going

40694
27:00:11,600 --> 27:00:14,000
to go in the oval class and do that

40695
27:00:14,000 --> 27:00:15,760
we're going to mark our method as

40696
27:00:15,760 --> 27:00:18,320
virtual and we are going to go in our

40697
27:00:18,320 --> 27:00:21,512
circle class and mark our draw method as

40698
27:00:21,512 --> 27:00:23,680
virtual let's do that and at the moment

40699
27:00:23,680 --> 27:00:25,760
we do this we're going to get dynamic

40700
27:00:25,760 --> 27:00:29,192
binding behavior in our inheritance

40701
27:00:29,192 --> 27:00:31,360
hierarchy here and this is really cool

40702
27:00:31,360 --> 27:00:34,160
so let's go back and try to play with

40703
27:00:34,160 --> 27:00:36,720
what we had before i am going to comment

40704
27:00:36,720 --> 27:00:39,512
out everything we had and we're going to

40705
27:00:39,512 --> 27:00:42,552
be doing things in step here let's go

40706
27:00:42,552 --> 27:00:45,360
through the code that uses base pointers

40707
27:00:45,360 --> 27:00:46,400
because

40708
27:00:46,400 --> 27:00:48,552
that's where we started out from in the

40709
27:00:48,552 --> 27:00:49,832
last lecture

40710
27:00:49,832 --> 27:00:52,320
and we are going to

40711
27:00:52,320 --> 27:00:54,400
mark that here let's put in some space

40712
27:00:54,400 --> 27:00:57,760
to make it easy to follow so we are

40713
27:00:57,760 --> 27:01:00,320
going to uncomment the line here that

40714
27:01:00,320 --> 27:01:02,552
calls the draw method when we have a

40715
27:01:02,552 --> 27:01:05,600
shape object stored in our base pointer

40716
27:01:05,600 --> 27:01:08,000
or when we are using a base pointer to

40717
27:01:08,000 --> 27:01:10,552
manage a shape object here we can also

40718
27:01:10,552 --> 27:01:12,640
comment out all these lines because we

40719
27:01:12,640 --> 27:01:15,040
don't want this to do anything

40720
27:01:15,040 --> 27:01:17,680
and let's see yes this is what we want

40721
27:01:17,680 --> 27:01:20,232
we are setting up our shapes and we are

40722
27:01:20,232 --> 27:01:22,720
using a base pointer to manage an actual

40723
27:01:22,720 --> 27:01:25,280
shape object and if we call the draw

40724
27:01:25,280 --> 27:01:27,512
method we expect this to call

40725
27:01:27,512 --> 27:01:29,440
shape draw and this is what we're going

40726
27:01:29,440 --> 27:01:31,120
to get let's build our program we're

40727
27:01:31,120 --> 27:01:33,832
going to pass this through gcc our

40728
27:01:33,832 --> 27:01:35,760
favorite compiler the build is going to

40729
27:01:35,760 --> 27:01:38,160
be good we can bring up a powershell

40730
27:01:38,160 --> 27:01:40,320
window we can use to play with us if we

40731
27:01:40,320 --> 27:01:42,000
call rooster we're going to see that

40732
27:01:42,000 --> 27:01:44,400
shape draw is called and we are drawing

40733
27:01:44,400 --> 27:01:46,552
shape one now if we change this to

40734
27:01:46,552 --> 27:01:49,360
manage an actual oval object we can do

40735
27:01:49,360 --> 27:01:51,440
that we can do that through this line

40736
27:01:51,440 --> 27:01:54,960
here and we expect this to call overdraw

40737
27:01:54,960 --> 27:01:57,280
and because the draw method is now

40738
27:01:57,280 --> 27:02:00,160
virtual this will use dynamic binding

40739
27:02:00,160 --> 27:02:02,480
again with dynamic binding we are

40740
27:02:02,480 --> 27:02:04,720
telling the compiler don't look at the

40741
27:02:04,720 --> 27:02:07,600
type of the base pointer look at the

40742
27:02:07,600 --> 27:02:10,552
type of the actual object that the

40743
27:02:10,552 --> 27:02:12,480
pointer is managing and the compiler is

40744
27:02:12,480 --> 27:02:14,640
going to see that this object is a novel

40745
27:02:14,640 --> 27:02:17,280
object and it will call

40746
27:02:17,280 --> 27:02:20,640
the oval version of the draw method here

40747
27:02:20,640 --> 27:02:22,160
and this is really cool this is what we

40748
27:02:22,160 --> 27:02:24,720
want let's run the task to build with

40749
27:02:24,720 --> 27:02:27,192
gcc again the world is going to be good

40750
27:02:27,192 --> 27:02:29,360
as you see here we can clear

40751
27:02:29,360 --> 27:02:31,832
and if we run booster look at this

40752
27:02:31,832 --> 27:02:34,232
overdraw calls and we are going to be

40753
27:02:34,232 --> 27:02:37,680
drawing our oval object and this is the

40754
27:02:37,680 --> 27:02:39,680
data we have inside we can use this

40755
27:02:39,680 --> 27:02:42,320
radius data to draw this on the screen

40756
27:02:42,320 --> 27:02:44,640
if that's what we are after in our c

40757
27:02:44,640 --> 27:02:46,400
plus plus program and this is really

40758
27:02:46,400 --> 27:02:49,280
cool we can even use our base pointer to

40759
27:02:49,280 --> 27:02:52,160
manage a circle object we can do that

40760
27:02:52,160 --> 27:02:54,232
and if we do that and call the joe

40761
27:02:54,232 --> 27:02:57,360
method because this draw method is now

40762
27:02:57,360 --> 27:03:00,000
virtual the compiler will note that it

40763
27:03:00,000 --> 27:03:02,552
doesn't need to look at the type of the

40764
27:03:02,552 --> 27:03:05,512
pointer that we are using to manage our

40765
27:03:05,512 --> 27:03:06,400
object

40766
27:03:06,400 --> 27:03:08,160
the compiler is going to look at the

40767
27:03:08,160 --> 27:03:11,192
type of the actual object that the base

40768
27:03:11,192 --> 27:03:13,512
pointer is managing and in this case it

40769
27:03:13,512 --> 27:03:16,000
happens to be a circle object so here we

40770
27:03:16,000 --> 27:03:19,192
will call circle draw and this is going

40771
27:03:19,192 --> 27:03:21,600
to draw a circle on the screen and this

40772
27:03:21,600 --> 27:03:23,680
is really going to be super cool so

40773
27:03:23,680 --> 27:03:26,232
let's pass this through gcc

40774
27:03:26,232 --> 27:03:28,232
and we're going to see this in action

40775
27:03:28,232 --> 27:03:29,760
the build is going to be good we can

40776
27:03:29,760 --> 27:03:32,160
clear and run rooster and you see that

40777
27:03:32,160 --> 27:03:34,552
we are drawing a circle and this is

40778
27:03:34,552 --> 27:03:37,120
really cool and just using virtual

40779
27:03:37,120 --> 27:03:40,000
functions we can really achieve powerful

40780
27:03:40,000 --> 27:03:42,232
features and you see that this wasn't

40781
27:03:42,232 --> 27:03:45,040
really hard to achieve all we had to do

40782
27:03:45,040 --> 27:03:48,872
was to mark our inherited methods as a

40783
27:03:48,872 --> 27:03:50,872
virtual and this is going to tell the

40784
27:03:50,872 --> 27:03:53,832
compiler to do dynamic binding and this

40785
27:03:53,832 --> 27:03:55,832
is going to be super cool let's see that

40786
27:03:55,832 --> 27:03:58,160
we can also achieve the same thing using

40787
27:03:58,160 --> 27:04:00,800
base references i am not going to run

40788
27:04:00,800 --> 27:04:03,680
the code where we are using a

40789
27:04:03,680 --> 27:04:06,320
base reference i am not going to be

40790
27:04:06,320 --> 27:04:08,872
running the code where we are using a

40791
27:04:08,872 --> 27:04:11,120
base reference to manage

40792
27:04:11,120 --> 27:04:12,640
a base

40793
27:04:12,640 --> 27:04:14,720
object because that's going to be really

40794
27:04:14,720 --> 27:04:17,440
boring but what we can do is put in an

40795
27:04:17,440 --> 27:04:19,192
awful object for example you can say

40796
27:04:19,192 --> 27:04:22,320
over one and say shape ref and call the

40797
27:04:22,320 --> 27:04:24,960
draw method again this is dynamic

40798
27:04:24,960 --> 27:04:27,040
binding because the draw method is

40799
27:04:27,040 --> 27:04:29,360
virtual so the compiler is not going to

40800
27:04:29,360 --> 27:04:31,600
look at the type of the reference to

40801
27:04:31,600 --> 27:04:33,832
decide which version of the draw method

40802
27:04:33,832 --> 27:04:36,552
to call it is going to look at the

40803
27:04:36,552 --> 27:04:39,680
actual object that this reference is

40804
27:04:39,680 --> 27:04:42,000
managing and it is going to see that the

40805
27:04:42,000 --> 27:04:44,720
type of the object is awful so c plus

40806
27:04:44,720 --> 27:04:48,000
plus is going to call the oval version

40807
27:04:48,000 --> 27:04:50,000
of the draw method that's what we're

40808
27:04:50,000 --> 27:04:52,552
going to get if we run this program here

40809
27:04:52,552 --> 27:04:54,160
let's build and see this we're going to

40810
27:04:54,160 --> 27:04:56,552
pass this through gcc the voltage should

40811
27:04:56,552 --> 27:04:59,040
be good as we see here we are going to

40812
27:04:59,040 --> 27:05:01,680
clear and run rooster you see we are

40813
27:05:01,680 --> 27:05:04,320
drawing oval if we happen to be using

40814
27:05:04,320 --> 27:05:06,720
this to manage our circle object let's

40815
27:05:06,720 --> 27:05:07,760
do that

40816
27:05:07,760 --> 27:05:10,400
we will see that we will get the circle

40817
27:05:10,400 --> 27:05:12,640
method called okay let's build and we're

40818
27:05:12,640 --> 27:05:14,640
going to pass this through gcc to do

40819
27:05:14,640 --> 27:05:16,480
that the both is going to be good we can

40820
27:05:16,480 --> 27:05:19,192
clear and run rooster you see that we

40821
27:05:19,192 --> 27:05:21,912
are drawing a circle because our base

40822
27:05:21,912 --> 27:05:25,680
pointer is now managing a circle object

40823
27:05:25,680 --> 27:05:29,040
now because we are using dynamic binding

40824
27:05:29,040 --> 27:05:32,000
or late binding as some people call it

40825
27:05:32,000 --> 27:05:33,912
we can really do all kinds of crazy

40826
27:05:33,912 --> 27:05:36,080
things the first thing we can achieve is

40827
27:05:36,080 --> 27:05:38,800
set up one single method which is really

40828
27:05:38,800 --> 27:05:41,360
going to draw any kind of shape we throw

40829
27:05:41,360 --> 27:05:43,280
at it so let's do something like this

40830
27:05:43,280 --> 27:05:44,872
we're going to say void and we're going

40831
27:05:44,872 --> 27:05:47,120
to say draw shape and it is going to

40832
27:05:47,120 --> 27:05:50,232
take a shape pointer let's say s and the

40833
27:05:50,232 --> 27:05:51,912
only thing we're going to do in this

40834
27:05:51,912 --> 27:05:54,720
function and say s draw this is going to

40835
27:05:54,720 --> 27:05:56,400
call the draw method on whatever

40836
27:05:56,400 --> 27:05:58,552
parameter that we pass in here

40837
27:05:58,552 --> 27:06:01,512
and watch this if we go down here and

40838
27:06:01,512 --> 27:06:04,552
uncomment this section on drawing shapes

40839
27:06:04,552 --> 27:06:08,000
if we say draw and pass in a circle for

40840
27:06:08,000 --> 27:06:10,320
example or let's pass an oval and do

40841
27:06:10,320 --> 27:06:13,040
this one level and to do this level by

40842
27:06:13,040 --> 27:06:15,040
level we're going to pass in over one

40843
27:06:15,040 --> 27:06:16,720
and we should pass an address because

40844
27:06:16,720 --> 27:06:18,872
this is taking a pointer let's so let's

40845
27:06:18,872 --> 27:06:21,512
do this and if we build and run this

40846
27:06:21,512 --> 27:06:23,280
program let's see what happens here

40847
27:06:23,280 --> 27:06:25,600
we're going to build with gcc the world

40848
27:06:25,600 --> 27:06:27,360
is going to be good as you see here if

40849
27:06:27,360 --> 27:06:30,400
we clear and run rooster you see

40850
27:06:30,400 --> 27:06:33,360
and let's take out this thing using base

40851
27:06:33,360 --> 27:06:35,600
references here because this is just

40852
27:06:35,600 --> 27:06:37,192
going to confuse us we're going to build

40853
27:06:37,192 --> 27:06:40,320
again and i use gcc for this the build

40854
27:06:40,320 --> 27:06:42,640
is going to be good within clear and run

40855
27:06:42,640 --> 27:06:44,800
rooster you see oval drill because we

40856
27:06:44,800 --> 27:06:47,912
are passing in a novel object if we pass

40857
27:06:47,912 --> 27:06:50,320
in our shape let's say shape one for

40858
27:06:50,320 --> 27:06:52,720
example we're going to build the book is

40859
27:06:52,720 --> 27:06:54,480
going to be good as you see here if we

40860
27:06:54,480 --> 27:06:57,440
clear and run rooster we're going to see

40861
27:06:57,440 --> 27:06:59,832
shape draw if we pass in circle let's do

40862
27:06:59,832 --> 27:07:00,872
that

40863
27:07:00,872 --> 27:07:02,552
and the bold again we're going to build

40864
27:07:02,552 --> 27:07:05,360
with gcc we're going to clear and run

40865
27:07:05,360 --> 27:07:07,120
rooster you're going to see that circle

40866
27:07:07,120 --> 27:07:09,360
draw is called and this is really cool

40867
27:07:09,360 --> 27:07:12,800
we can only use a single method and this

40868
27:07:12,800 --> 27:07:14,640
method is going to take any shape we

40869
27:07:14,640 --> 27:07:16,872
throw at it and it is going to draw it

40870
27:07:16,872 --> 27:07:19,600
if we happen to be having 100 kinds of

40871
27:07:19,600 --> 27:07:21,600
shapes in our program we can just for

40872
27:07:21,600 --> 27:07:23,280
example loop through a collection

40873
27:07:23,280 --> 27:07:25,600
containing those shapes and if we call

40874
27:07:25,600 --> 27:07:28,320
the draw method on any shape we store in

40875
27:07:28,320 --> 27:07:30,320
our collection we're going to get the

40876
27:07:30,320 --> 27:07:32,720
correct shape drone and this is super

40877
27:07:32,720 --> 27:07:35,040
cool this is really powerful and i hope

40878
27:07:35,040 --> 27:07:37,192
you are excited to be able to achieve

40879
27:07:37,192 --> 27:07:39,680
this in c plus plus now we can also

40880
27:07:39,680 --> 27:07:42,000
achieve the same thing by using a method

40881
27:07:42,000 --> 27:07:44,640
that takes a reference for example so we

40882
27:07:44,640 --> 27:07:48,480
can say void joe shape let's say v1 and

40883
27:07:48,480 --> 27:07:50,800
we're going to pass a reference

40884
27:07:50,800 --> 27:07:53,680
we can say const and pass a reference

40885
27:07:53,680 --> 27:07:56,552
and say sr to say ship reference we can

40886
27:07:56,552 --> 27:07:59,280
do that and we're going to say sjo we're

40887
27:07:59,280 --> 27:08:01,360
going to call the jaw method on this

40888
27:08:01,360 --> 27:08:03,440
reference and let's see what happens if

40889
27:08:03,440 --> 27:08:06,400
we try this out let's say sr that's what

40890
27:08:06,400 --> 27:08:08,800
we should say here and this is going to

40891
27:08:08,800 --> 27:08:11,600
be taken by our visual studio code

40892
27:08:11,600 --> 27:08:14,552
editor if we go in here and change this

40893
27:08:14,552 --> 27:08:15,760
to say

40894
27:08:15,760 --> 27:08:19,280
draw shape v1 we can pass in shape one

40895
27:08:19,280 --> 27:08:21,192
we can do that because this is taking a

40896
27:08:21,192 --> 27:08:22,552
reference now

40897
27:08:22,552 --> 27:08:25,512
if we build with gcc we are going to see

40898
27:08:25,512 --> 27:08:27,600
that the world is good we can clear

40899
27:08:27,600 --> 27:08:29,280
let's clear we're going to run the

40900
27:08:29,280 --> 27:08:31,280
rooster this is going to call shape draw

40901
27:08:31,280 --> 27:08:33,512
because we are using a reference to

40902
27:08:33,512 --> 27:08:36,000
manage a shaped object we can also pass

40903
27:08:36,000 --> 27:08:38,000
it over one and we're going to build

40904
27:08:38,000 --> 27:08:41,440
again and see how this works the bolt is

40905
27:08:41,440 --> 27:08:43,600
going to be good we can clear and run

40906
27:08:43,600 --> 27:08:45,440
rooster we're going to say overdraw and

40907
27:08:45,440 --> 27:08:47,760
we're going to see our information here

40908
27:08:47,760 --> 27:08:50,640
if we pass in our circle object

40909
27:08:50,640 --> 27:08:52,872
and the bolt we're going to pass this

40910
27:08:52,872 --> 27:08:55,192
through gcc the bolt is going to be good

40911
27:08:55,192 --> 27:08:57,440
we can clear and run rooster this is

40912
27:08:57,440 --> 27:08:59,600
going to draw a circle for us this is

40913
27:08:59,600 --> 27:09:02,320
really cool we have one method again

40914
27:09:02,320 --> 27:09:04,552
that is taking a parameter by reference

40915
27:09:04,552 --> 27:09:07,440
but we can use this method to draw any

40916
27:09:07,440 --> 27:09:09,912
kind of shape in our inheritance

40917
27:09:09,912 --> 27:09:12,232
hierarchy this is going to work really

40918
27:09:12,232 --> 27:09:15,192
well and it is doing dynamic binding

40919
27:09:15,192 --> 27:09:17,680
which is powered by virtual functions we

40920
27:09:17,680 --> 27:09:20,552
are using in our inheritance hierarchy

40921
27:09:20,552 --> 27:09:22,872
here you should really keep this in mind

40922
27:09:22,872 --> 27:09:25,680
now let's go back and see if we can even

40923
27:09:25,680 --> 27:09:28,720
use row pointers to do stuff i am going

40924
27:09:28,720 --> 27:09:30,640
to comment this out and i am going to

40925
27:09:30,640 --> 27:09:33,192
say roll pointers because i want you to

40926
27:09:33,192 --> 27:09:34,800
see something we're going to set up a

40927
27:09:34,800 --> 27:09:36,552
shape pointer we're going to say shape

40928
27:09:36,552 --> 27:09:37,760
ptr

40929
27:09:37,760 --> 27:09:40,000
do we have that on top here let's see if

40930
27:09:40,000 --> 27:09:41,280
we do

40931
27:09:41,280 --> 27:09:44,872
yes we have shape ptr so let's say shape

40932
27:09:44,872 --> 27:09:46,320
ptr

40933
27:09:46,320 --> 27:09:48,480
and pass it a novel object we're going

40934
27:09:48,480 --> 27:09:50,552
to pass a novel again and we're going to

40935
27:09:50,552 --> 27:09:53,280
pass the address of 01 this is going to

40936
27:09:53,280 --> 27:09:56,000
do we can call the draw method and get

40937
27:09:56,000 --> 27:09:58,320
it called polymorphically

40938
27:09:58,320 --> 27:10:00,960
or get it called using dynamic binding

40939
27:10:00,960 --> 27:10:03,192
we can say shape ptr

40940
27:10:03,192 --> 27:10:05,912
and say draw this is going to call the

40941
27:10:05,912 --> 27:10:08,800
correct version but one thing i want you

40942
27:10:08,800 --> 27:10:11,832
to see is that if a method is not

40943
27:10:11,832 --> 27:10:14,800
polymorphic or if a method is not

40944
27:10:14,800 --> 27:10:15,912
virtual

40945
27:10:15,912 --> 27:10:18,040
you want to get it called using

40946
27:10:18,040 --> 27:10:21,040
polymorphism for example if we go to our

40947
27:10:21,040 --> 27:10:22,800
oval class we're going to see that we

40948
27:10:22,800 --> 27:10:25,680
have a bunch of getters let's go in and

40949
27:10:25,680 --> 27:10:27,832
make them public so that they are

40950
27:10:27,832 --> 27:10:31,192
callable from the outside and if we try

40951
27:10:31,192 --> 27:10:33,160
and get this called

40952
27:10:33,160 --> 27:10:36,480
polymorphically or using dynamic binding

40953
27:10:36,480 --> 27:10:38,320
that's not going to work let's do that

40954
27:10:38,320 --> 27:10:41,120
we're going to say get x rad and the

40955
27:10:41,120 --> 27:10:42,960
reason we might want to do something

40956
27:10:42,960 --> 27:10:45,120
like this is because we have this method

40957
27:10:45,120 --> 27:10:46,000
here

40958
27:10:46,000 --> 27:10:49,440
and it is set up on our oval class

40959
27:10:49,440 --> 27:10:52,080
so because we are using a base pointer

40960
27:10:52,080 --> 27:10:54,960
to manage a novel object some of you

40961
27:10:54,960 --> 27:10:57,192
might think uh-huh i might be able to

40962
27:10:57,192 --> 27:11:00,232
call this method because i am able to

40963
27:11:00,232 --> 27:11:03,280
call the job method which is also in the

40964
27:11:03,280 --> 27:11:06,720
public scope of our overclass but that's

40965
27:11:06,720 --> 27:11:08,720
not going to work because this method

40966
27:11:08,720 --> 27:11:10,872
here is not virtual

40967
27:11:10,872 --> 27:11:14,320
dynamic binding or polymorphism is only

40968
27:11:14,320 --> 27:11:16,720
going to work if your methods are

40969
27:11:16,720 --> 27:11:19,760
virtual and they are set up across your

40970
27:11:19,760 --> 27:11:22,552
inheritance hierarchy so this is not

40971
27:11:22,552 --> 27:11:24,400
going to work if you try to do something

40972
27:11:24,400 --> 27:11:26,160
like this this is going to give you a

40973
27:11:26,160 --> 27:11:28,800
compiler error let's try and build and

40974
27:11:28,800 --> 27:11:30,552
see the compiler error and we're going

40975
27:11:30,552 --> 27:11:33,440
to see an error that says that no such

40976
27:11:33,440 --> 27:11:36,480
method on this object let's go here

40977
27:11:36,480 --> 27:11:38,320
class shape has no

40978
27:11:38,320 --> 27:11:41,360
class shape has no member name to get x

40979
27:11:41,360 --> 27:11:42,320
red

40980
27:11:42,320 --> 27:11:44,480
because the method is not virtual the

40981
27:11:44,480 --> 27:11:46,960
compiler is going to do static binding

40982
27:11:46,960 --> 27:11:49,512
and it is going to be using the type of

40983
27:11:49,512 --> 27:11:51,600
the pointer which is shaped to resolve

40984
27:11:51,600 --> 27:11:54,000
this method and it is going to see that

40985
27:11:54,000 --> 27:11:56,000
in shape we don't have a method called

40986
27:11:56,000 --> 27:11:58,400
get xrad and the compiler is going to

40987
27:11:58,400 --> 27:12:00,640
throw this compiler error here this is

40988
27:12:00,640 --> 27:12:02,800
what we get so this is not going to work

40989
27:12:02,800 --> 27:12:05,120
and i want you to be aware of this

40990
27:12:05,120 --> 27:12:06,960
another thing i want you to see

40991
27:12:06,960 --> 27:12:10,080
is that because we are using dynamic

40992
27:12:10,080 --> 27:12:11,600
binding now

40993
27:12:11,600 --> 27:12:14,080
we don't need we don't need to set up

40994
27:12:14,080 --> 27:12:16,720
all kinds of crazy collections to take

40995
27:12:16,720 --> 27:12:18,960
into account different shapes that we

40996
27:12:18,960 --> 27:12:22,160
have in our c plus plus program what

40997
27:12:22,160 --> 27:12:24,320
we're going to do here is use a base

40998
27:12:24,320 --> 27:12:27,192
pointer to manage the data that we store

40999
27:12:27,192 --> 27:12:30,480
in our array here so all i am going to

41000
27:12:30,480 --> 27:12:33,360
do is remove all this dirt here because

41001
27:12:33,360 --> 27:12:35,120
this is really dirt you don't want to do

41002
27:12:35,120 --> 27:12:37,120
something like that and we're going to

41003
27:12:37,120 --> 27:12:39,192
use a base pointer which is a shape

41004
27:12:39,192 --> 27:12:42,232
pointer and use that to set up an array

41005
27:12:42,232 --> 27:12:44,232
which can handle any kind of shape we

41006
27:12:44,232 --> 27:12:47,440
have in our inheritance hierarchy so we

41007
27:12:47,440 --> 27:12:50,000
can store it shape objects we can store

41008
27:12:50,000 --> 27:12:52,320
it over objects we can store in circle

41009
27:12:52,320 --> 27:12:54,960
objects and if we look like we do here

41010
27:12:54,960 --> 27:12:56,640
we're going to get the correct method

41011
27:12:56,640 --> 27:12:58,720
called and this is going to be super

41012
27:12:58,720 --> 27:13:01,192
cool so let's try and run this program

41013
27:13:01,192 --> 27:13:03,680
we're going to pass this through gcc why

41014
27:13:03,680 --> 27:13:05,912
do we have the red thing here let's

41015
27:13:05,912 --> 27:13:08,960
build and see if it goes away maybe this

41016
27:13:08,960 --> 27:13:11,192
is visual studio code having a problem

41017
27:13:11,192 --> 27:13:13,120
with our code the world is good so

41018
27:13:13,120 --> 27:13:15,360
visual studio code was playing with us

41019
27:13:15,360 --> 27:13:17,512
we're going to clear and run rooster

41020
27:13:17,512 --> 27:13:19,192
you're going to see that we're going to

41021
27:13:19,192 --> 27:13:22,552
be looping through this array here and

41022
27:13:22,552 --> 27:13:24,160
on the first iteration we're going to

41023
27:13:24,160 --> 27:13:26,160
call shape draw because the first thing

41024
27:13:26,160 --> 27:13:28,480
is the shape on the second iteration

41025
27:13:28,480 --> 27:13:30,552
we're going to call overdraw because the

41026
27:13:30,552 --> 27:13:33,192
second thing is a novel and we're going

41027
27:13:33,192 --> 27:13:34,160
to

41028
27:13:34,160 --> 27:13:36,720
hit the third iteration and call circle

41029
27:13:36,720 --> 27:13:39,280
draw because the third thing in this

41030
27:13:39,280 --> 27:13:41,832
collection is a circle hopefully you can

41031
27:13:41,832 --> 27:13:44,080
see that this is going to simplify our

41032
27:13:44,080 --> 27:13:47,192
programs a lot compared to what we were

41033
27:13:47,192 --> 27:13:48,480
able to do

41034
27:13:48,480 --> 27:13:50,160
in the last lecture and this is really

41035
27:13:50,160 --> 27:13:52,160
all i had to share in this lecture

41036
27:13:52,160 --> 27:13:54,720
showing you that you can achieve dynamic

41037
27:13:54,720 --> 27:13:58,480
binding or polymorphism or late binding

41038
27:13:58,480 --> 27:14:01,040
as some people call it using virtual

41039
27:14:01,040 --> 27:14:03,832
functions in your inheritance hierarchy

41040
27:14:03,832 --> 27:14:06,720
again all we had to do was mark our

41041
27:14:06,720 --> 27:14:09,512
member functions as a virtual and the

41042
27:14:09,512 --> 27:14:11,360
compiler is going to know that it can

41043
27:14:11,360 --> 27:14:14,160
set up dynamic polymorphism for your

41044
27:14:14,160 --> 27:14:17,040
types if you happen to be managing them

41045
27:14:17,040 --> 27:14:20,232
using a base pointer or a base reference

41046
27:14:20,232 --> 27:14:21,912
we are going to stop here in this

41047
27:14:21,912 --> 27:14:23,680
lecture and the next one we're going to

41048
27:14:23,680 --> 27:14:26,552
learn about slicing and the size of

41049
27:14:26,552 --> 27:14:28,800
polymorphic objects

41050
27:14:28,800 --> 27:14:31,120
go ahead and finish up here and meet me

41051
27:14:31,120 --> 27:14:32,872
there in this lecture we're going to

41052
27:14:32,872 --> 27:14:37,040
explore the size of polymorphic objects

41053
27:14:37,040 --> 27:14:40,160
or objects that use dynamic binding and

41054
27:14:40,160 --> 27:14:42,160
we're going to learn about the concept

41055
27:14:42,160 --> 27:14:45,192
of slicing if you happen to assign a

41056
27:14:45,192 --> 27:14:48,400
derived object to a base object we're

41057
27:14:48,400 --> 27:14:50,232
going to see how this works out in the

41058
27:14:50,232 --> 27:14:52,232
last two lectures we saw that we could

41059
27:14:52,232 --> 27:14:54,872
achieve static binding using a setup

41060
27:14:54,872 --> 27:14:57,192
like this we can set up an inheritance

41061
27:14:57,192 --> 27:15:00,000
hierarchy and we're going to have oval

41062
27:15:00,000 --> 27:15:02,800
derive or inherit from shape and we're

41063
27:15:02,800 --> 27:15:06,400
going to have circle inherit or derive

41064
27:15:06,400 --> 27:15:09,440
from over here and our methods are going

41065
27:15:09,440 --> 27:15:11,440
to be row they are not going to be

41066
27:15:11,440 --> 27:15:13,600
virtual on anything and this is going to

41067
27:15:13,600 --> 27:15:16,080
do static binding if you happen to

41068
27:15:16,080 --> 27:15:18,552
manage a derived object through a base

41069
27:15:18,552 --> 27:15:21,040
pointer or reference you want to get

41070
27:15:21,040 --> 27:15:23,360
dynamic holes you will get static

41071
27:15:23,360 --> 27:15:25,512
binding and the compiler will use the

41072
27:15:25,512 --> 27:15:28,000
base pointer or base reference to decide

41073
27:15:28,000 --> 27:15:31,120
which draw method to call on your object

41074
27:15:31,120 --> 27:15:32,872
we also saw that we could achieve

41075
27:15:32,872 --> 27:15:36,080
dynamic binding using virtual functions

41076
27:15:36,080 --> 27:15:38,640
and all we needed to do was mark our

41077
27:15:38,640 --> 27:15:41,680
methods as virtual in our inheritance

41078
27:15:41,680 --> 27:15:44,120
hierarchy here and this would give us

41079
27:15:44,120 --> 27:15:47,912
polymorphism or dynamic binding but one

41080
27:15:47,912 --> 27:15:50,232
thing you should know is that dynamic

41081
27:15:50,232 --> 27:15:52,480
binding is not free you're going to be

41082
27:15:52,480 --> 27:15:55,600
paying in terms of memory to get all

41083
27:15:55,600 --> 27:15:57,512
these cool things we saw in the last

41084
27:15:57,512 --> 27:15:59,192
lecture and we're going to be proving

41085
27:15:59,192 --> 27:16:01,360
that in this lecture what we're going to

41086
27:16:01,360 --> 27:16:03,512
be doing is basically set up our

41087
27:16:03,512 --> 27:16:05,912
inheritance hierarchy and we are going

41088
27:16:05,912 --> 27:16:08,400
to set that up in such a way that it is

41089
27:16:08,400 --> 27:16:10,232
going to be using static binding we're

41090
27:16:10,232 --> 27:16:12,000
going to see the sizes we get printed

41091
27:16:12,000 --> 27:16:14,400
out here and we're going to use dynamic

41092
27:16:14,400 --> 27:16:17,360
binding and compare the sizes and the

41093
27:16:17,360 --> 27:16:19,912
constitution is going to be that with

41094
27:16:19,912 --> 27:16:22,872
dynamic binding your objects are going

41095
27:16:22,872 --> 27:16:25,760
to be much larger because your simplest

41096
27:16:25,760 --> 27:16:28,800
plus program will need to keep track of

41097
27:16:28,800 --> 27:16:30,320
the information

41098
27:16:30,320 --> 27:16:32,960
that allows it to resolve

41099
27:16:32,960 --> 27:16:35,280
function calls dynamically and that

41100
27:16:35,280 --> 27:16:37,360
information is stored in what we call

41101
27:16:37,360 --> 27:16:40,320
virtual tables but i am not going to go

41102
27:16:40,320 --> 27:16:42,552
into that here because it is really out

41103
27:16:42,552 --> 27:16:45,512
of scope of a course like this but i

41104
27:16:45,512 --> 27:16:47,600
want you to be aware of this if you use

41105
27:16:47,600 --> 27:16:50,640
dynamic if you use dynamic binding your

41106
27:16:50,640 --> 27:16:53,280
objects are going to be much larger okay

41107
27:16:53,280 --> 27:16:55,040
the first thing i want to bring your

41108
27:16:55,040 --> 27:16:56,232
attention to

41109
27:16:56,232 --> 27:16:58,800
is object slicing and we're going to

41110
27:16:58,800 --> 27:17:01,040
look at a simple example here we have

41111
27:17:01,040 --> 27:17:03,512
our objects we have a shape object we

41112
27:17:03,512 --> 27:17:06,080
have an oval object and we have a circle

41113
27:17:06,080 --> 27:17:10,080
object and down here we want to assign

41114
27:17:10,080 --> 27:17:14,080
our circle object to a shape object

41115
27:17:14,080 --> 27:17:16,800
now notice that here we are not using a

41116
27:17:16,800 --> 27:17:19,192
pointer or a reference these are just

41117
27:17:19,192 --> 27:17:21,600
the row objects that we are assigning to

41118
27:17:21,600 --> 27:17:23,760
each other and what the competitor is

41119
27:17:23,760 --> 27:17:25,440
basically going to do

41120
27:17:25,440 --> 27:17:28,160
it's going to notice that a circle has a

41121
27:17:28,160 --> 27:17:30,872
shape according to it and it is going to

41122
27:17:30,872 --> 27:17:33,832
strip off the outer layers or in other

41123
27:17:33,832 --> 27:17:35,832
words it is going to strip off the

41124
27:17:35,832 --> 27:17:38,320
circle layer it is going to strip off

41125
27:17:38,320 --> 27:17:40,552
the oval layer and it is going to leave

41126
27:17:40,552 --> 27:17:43,360
in the shape part and that's what it is

41127
27:17:43,360 --> 27:17:46,400
going to assign to our shape object here

41128
27:17:46,400 --> 27:17:49,040
let's visualize this our shape class

41129
27:17:49,040 --> 27:17:51,360
looks like what we have here on the left

41130
27:17:51,360 --> 27:17:55,192
our oval class has a shape part into it

41131
27:17:55,192 --> 27:17:57,440
and our circle is going to have an over

41132
27:17:57,440 --> 27:17:59,832
part into it and that oval part is going

41133
27:17:59,832 --> 27:18:02,160
to have a shape part of it and this is

41134
27:18:02,160 --> 27:18:05,120
the setup that we have here now if we do

41135
27:18:05,120 --> 27:18:06,872
our assignment we're going to do

41136
27:18:06,872 --> 27:18:08,640
something like this the compiler is

41137
27:18:08,640 --> 27:18:10,400
going to see that we are already

41138
27:18:10,400 --> 27:18:12,552
assigning a circle

41139
27:18:12,552 --> 27:18:14,400
to a shape and the compiler is going to

41140
27:18:14,400 --> 27:18:16,640
notice that what we have on the left is

41141
27:18:16,640 --> 27:18:19,512
just a shape and we don't have enough

41142
27:18:19,512 --> 27:18:22,640
space to store information about oval

41143
27:18:22,640 --> 27:18:24,960
and the circle here so what the compiler

41144
27:18:24,960 --> 27:18:26,872
is going to do it is going to strip off

41145
27:18:26,872 --> 27:18:28,872
all these things that we don't really

41146
27:18:28,872 --> 27:18:31,680
need and it is going to leave in only

41147
27:18:31,680 --> 27:18:32,552
the

41148
27:18:32,552 --> 27:18:36,000
shape part that we can assign on what we

41149
27:18:36,000 --> 27:18:38,552
have to the left so it is going to strip

41150
27:18:38,552 --> 27:18:40,552
off all these stands and we are going to

41151
27:18:40,552 --> 27:18:42,480
be left with something like this and

41152
27:18:42,480 --> 27:18:44,480
then what we have on the right is going

41153
27:18:44,480 --> 27:18:46,640
to be assigned on the left and we will

41154
27:18:46,640 --> 27:18:50,320
have our data stored in our ship to

41155
27:18:50,320 --> 27:18:52,960
object and if we try to use it that's

41156
27:18:52,960 --> 27:18:55,192
what you're going to get in memory so

41157
27:18:55,192 --> 27:18:57,832
this is referred to as slicing again the

41158
27:18:57,832 --> 27:18:59,440
compiler is going to notice that it

41159
27:18:59,440 --> 27:19:01,512
doesn't really have enough space on the

41160
27:19:01,512 --> 27:19:03,040
left to store

41161
27:19:03,040 --> 27:19:04,872
everything we have to the right of the

41162
27:19:04,872 --> 27:19:07,512
assignment here and it is going to strip

41163
27:19:07,512 --> 27:19:09,680
off or slice off

41164
27:19:09,680 --> 27:19:12,640
everything we don't need and it is only

41165
27:19:12,640 --> 27:19:15,600
going to leave in the shape part and

41166
27:19:15,600 --> 27:19:18,720
that's what it is going to assign on our

41167
27:19:18,720 --> 27:19:21,440
object that we have on the left of the

41168
27:19:21,440 --> 27:19:23,760
assignment operator here and this is

41169
27:19:23,760 --> 27:19:27,280
referred to as slicing in c plus plus

41170
27:19:27,280 --> 27:19:29,360
terminology i just want you to be aware

41171
27:19:29,360 --> 27:19:31,512
of this and we're going to see a lot of

41172
27:19:31,512 --> 27:19:34,000
this starting from now now that you know

41173
27:19:34,000 --> 27:19:35,600
this we're going to head over to visual

41174
27:19:35,600 --> 27:19:37,440
studio code and play with this a little

41175
27:19:37,440 --> 27:19:40,160
more here we are in our working folder

41176
27:19:40,160 --> 27:19:42,800
the current project is size of

41177
27:19:42,800 --> 27:19:46,320
polymorphic objects and slicing we are

41178
27:19:46,320 --> 27:19:48,000
going to grab the code from the last

41179
27:19:48,000 --> 27:19:50,552
lecture so let's grab everything except

41180
27:19:50,552 --> 27:19:53,600
for the binary file we are going to copy

41181
27:19:53,600 --> 27:19:55,760
everything and we're going to put that

41182
27:19:55,760 --> 27:19:58,480
in the current folder and we're going to

41183
27:19:58,480 --> 27:20:00,552
open this little guy in visual studio

41184
27:20:00,552 --> 27:20:03,040
code by dragging and dropping here this

41185
27:20:03,040 --> 27:20:05,512
is going to give us our project and we

41186
27:20:05,512 --> 27:20:09,192
can head over in the main cpp file

41187
27:20:09,192 --> 27:20:11,512
and clean up all the mess we got from

41188
27:20:11,512 --> 27:20:14,232
the last previous lectures we can also

41189
27:20:14,232 --> 27:20:16,640
take out these functions because i don't

41190
27:20:16,640 --> 27:20:18,800
think we need them here

41191
27:20:18,800 --> 27:20:21,280
and we are going to check out on our

41192
27:20:21,280 --> 27:20:24,000
classes notice that we are using dynamic

41193
27:20:24,000 --> 27:20:26,720
polymorphism because we have virtual

41194
27:20:26,720 --> 27:20:29,192
functions here so if we happen to be

41195
27:20:29,192 --> 27:20:31,832
using base pointers or base references

41196
27:20:31,832 --> 27:20:35,040
to manage our derived objects we will

41197
27:20:35,040 --> 27:20:37,912
get polymorphic results okay the first

41198
27:20:37,912 --> 27:20:40,640
thing we want to see is the size of

41199
27:20:40,640 --> 27:20:43,680
objects for our classes here because we

41200
27:20:43,680 --> 27:20:46,400
are using virtual functions let's head

41201
27:20:46,400 --> 27:20:48,960
over in the main cpp file and we're

41202
27:20:48,960 --> 27:20:51,192
going to put in a piece of code which is

41203
27:20:51,192 --> 27:20:53,440
just going to use the size of operator

41204
27:20:53,440 --> 27:20:55,280
to print the sizes

41205
27:20:55,280 --> 27:20:58,400
of objects of these classes we can try

41206
27:20:58,400 --> 27:21:00,480
to build and run this program we're

41207
27:21:00,480 --> 27:21:02,872
going to use gcc here the world is just

41208
27:21:02,872 --> 27:21:05,600
going to be good we can bring up a

41209
27:21:05,600 --> 27:21:07,600
powershell window we can use to run

41210
27:21:07,600 --> 27:21:09,120
these programs

41211
27:21:09,120 --> 27:21:11,832
we're going to do that new terminal this

41212
27:21:11,832 --> 27:21:13,832
is going to bring us our window here we

41213
27:21:13,832 --> 27:21:16,480
can clear and run rooster we're going to

41214
27:21:16,480 --> 27:21:19,600
get 40 56 and 56

41215
27:21:19,600 --> 27:21:22,640
so you see that these are our sizes so

41216
27:21:22,640 --> 27:21:25,360
let's say that with uh dynamic is going

41217
27:21:25,360 --> 27:21:28,232
to be 40 for the base class with dynamic

41218
27:21:28,232 --> 27:21:31,280
portal morphism we're going to get 56

41219
27:21:31,280 --> 27:21:32,400
for the

41220
27:21:32,400 --> 27:21:35,040
oval object and we're going to get

41221
27:21:35,040 --> 27:21:38,320
dynamic 56 for the

41222
27:21:38,320 --> 27:21:41,040
circle object here now we're going to

41223
27:21:41,040 --> 27:21:44,720
remove the setup that uses polymorphism

41224
27:21:44,720 --> 27:21:46,232
and we're going to see the results that

41225
27:21:46,232 --> 27:21:48,640
we get all we need to do is to remove

41226
27:21:48,640 --> 27:21:51,040
the virtual keyword here we can comment

41227
27:21:51,040 --> 27:21:53,760
it out you can do something like this in

41228
27:21:53,760 --> 27:21:56,480
shape and we're going to hop over in

41229
27:21:56,480 --> 27:21:59,192
oval and comment out the virtual key

41230
27:21:59,192 --> 27:22:00,872
world we can do something like this and

41231
27:22:00,872 --> 27:22:02,320
this is going to

41232
27:22:02,320 --> 27:22:04,640
work without removing this completely

41233
27:22:04,640 --> 27:22:06,872
from our code because we still need to

41234
27:22:06,872 --> 27:22:09,680
leave this in as a reference we're going

41235
27:22:09,680 --> 27:22:12,160
to hop over to circle and do the same

41236
27:22:12,160 --> 27:22:13,120
thing

41237
27:22:13,120 --> 27:22:15,280
and now that we have this setup we can

41238
27:22:15,280 --> 27:22:17,912
hop over to our main cpp file we're

41239
27:22:17,912 --> 27:22:19,512
going to see that we don't have any

41240
27:22:19,512 --> 27:22:22,080
squiggly lines of some kind so this is

41241
27:22:22,080 --> 27:22:24,640
going to be accepted by the compiler but

41242
27:22:24,640 --> 27:22:26,720
if we build and run this program we're

41243
27:22:26,720 --> 27:22:28,960
going to see different sizes let's see

41244
27:22:28,960 --> 27:22:30,960
if the world is good it is good as you

41245
27:22:30,960 --> 27:22:33,912
see here we can clear and run rooster

41246
27:22:33,912 --> 27:22:36,080
now you see that with

41247
27:22:36,080 --> 27:22:39,912
static binding the base object is 32

41248
27:22:39,912 --> 27:22:43,600
bytes the awful object is going to be 48

41249
27:22:43,600 --> 27:22:45,120
and hopefully you can see that with

41250
27:22:45,120 --> 27:22:48,080
dynamic polymorphism our objects are

41251
27:22:48,080 --> 27:22:50,232
going to be much larger because the

41252
27:22:50,232 --> 27:22:52,160
compiler has to keep track of the

41253
27:22:52,160 --> 27:22:54,480
information that allows it to

41254
27:22:54,480 --> 27:22:56,720
dynamically resolve

41255
27:22:56,720 --> 27:22:59,192
virtual function calls that's why our

41256
27:22:59,192 --> 27:23:02,872
objects are larger with polymorphism and

41257
27:23:02,872 --> 27:23:04,960
you should know that you are not getting

41258
27:23:04,960 --> 27:23:07,680
polymorphic results for free you are

41259
27:23:07,680 --> 27:23:11,040
going to be paying in terms of much more

41260
27:23:11,040 --> 27:23:13,680
memory that you use for your objects in

41261
27:23:13,680 --> 27:23:16,080
your c plus plus programs this is the

41262
27:23:16,080 --> 27:23:17,912
first thing i want you to see in this

41263
27:23:17,912 --> 27:23:19,832
lecture the second thing i want you to

41264
27:23:19,832 --> 27:23:23,360
be aware of is the concept of slicing

41265
27:23:23,360 --> 27:23:25,192
and this is going to happen if you

41266
27:23:25,192 --> 27:23:27,440
happen to take a raw

41267
27:23:27,440 --> 27:23:30,552
derived object and assign that to a row

41268
27:23:30,552 --> 27:23:32,552
based object let's do something like

41269
27:23:32,552 --> 27:23:34,800
that we are going to create a circle

41270
27:23:34,800 --> 27:23:36,872
object and then we're going to say shape

41271
27:23:36,872 --> 27:23:39,360
and say shape here and we're going to

41272
27:23:39,360 --> 27:23:41,680
say equals circle one

41273
27:23:41,680 --> 27:23:43,512
this is something we could do

41274
27:23:43,512 --> 27:23:46,160
but notice that the compiler is not

41275
27:23:46,160 --> 27:23:48,320
giving us any kind of compiler error

41276
27:23:48,320 --> 27:23:50,080
because we can assign a circle to a

41277
27:23:50,080 --> 27:23:52,232
shape because a circle is really a shape

41278
27:23:52,232 --> 27:23:54,872
but from what we know in our inheritance

41279
27:23:54,872 --> 27:23:57,832
hierarchy a circle is really much more

41280
27:23:57,832 --> 27:24:00,320
than a row shape a circle has awful

41281
27:24:00,320 --> 27:24:03,440
information in it and it also has circle

41282
27:24:03,440 --> 27:24:05,760
information in it so it is really much

41283
27:24:05,760 --> 27:24:08,080
larger and much wider than a shape

41284
27:24:08,080 --> 27:24:10,320
object but the compiler is going to see

41285
27:24:10,320 --> 27:24:12,960
that we are trying to assign a circle to

41286
27:24:12,960 --> 27:24:15,120
a shape and it is going to be smart

41287
27:24:15,120 --> 27:24:16,552
enough to know

41288
27:24:16,552 --> 27:24:18,720
that we don't really need oval and

41289
27:24:18,720 --> 27:24:21,360
circle information in our shape object

41290
27:24:21,360 --> 27:24:23,680
that we are storing here so the compiler

41291
27:24:23,680 --> 27:24:26,160
is going to slice off circle and oval

41292
27:24:26,160 --> 27:24:29,040
information and it is going to leave in

41293
27:24:29,040 --> 27:24:30,960
shape information and that's the only

41294
27:24:30,960 --> 27:24:33,512
thing we will be able to use with this

41295
27:24:33,512 --> 27:24:35,440
shape variable that we have in our c

41296
27:24:35,440 --> 27:24:38,080
plus plus program so if we say shape

41297
27:24:38,080 --> 27:24:40,232
drill you can try to guess what we are

41298
27:24:40,232 --> 27:24:42,320
going to get and let's go back and

41299
27:24:42,320 --> 27:24:45,600
re-enable polymorphism because some of

41300
27:24:45,600 --> 27:24:47,192
you might think we are going to get

41301
27:24:47,192 --> 27:24:49,360
polymorphic results

41302
27:24:49,360 --> 27:24:51,680
with this setup here that's not what

41303
27:24:51,680 --> 27:24:54,552
we're going to get because we are not

41304
27:24:54,552 --> 27:24:57,120
going through bezel references or base

41305
27:24:57,120 --> 27:24:58,480
pointers to

41306
27:24:58,480 --> 27:25:01,040
do what we are doing in this example on

41307
27:25:01,040 --> 27:25:03,600
slicing here so because we are not using

41308
27:25:03,600 --> 27:25:06,160
base references or base pointers in this

41309
27:25:06,160 --> 27:25:08,480
line here the compiler is going to see

41310
27:25:08,480 --> 27:25:10,800
that these are raw objects and it is

41311
27:25:10,800 --> 27:25:13,280
going to do slicing and slice of things

41312
27:25:13,280 --> 27:25:16,480
we don't need in our shape variable

41313
27:25:16,480 --> 27:25:19,280
that we are setting up on line 16 here

41314
27:25:19,280 --> 27:25:21,680
so if we call the draw method this is

41315
27:25:21,680 --> 27:25:23,832
going to call shape draw

41316
27:25:23,832 --> 27:25:25,440
it is not going to do dynamic

41317
27:25:25,440 --> 27:25:27,832
polymorphism here you should be aware of

41318
27:25:27,832 --> 27:25:29,760
this if you're not using the base

41319
27:25:29,760 --> 27:25:32,080
pointers or references and you hope to

41320
27:25:32,080 --> 27:25:35,680
get dynamic polymorphism results i hate

41321
27:25:35,680 --> 27:25:37,040
to break it to you but you're going to

41322
27:25:37,040 --> 27:25:39,280
be disappointed because the compiler is

41323
27:25:39,280 --> 27:25:41,360
going to slice off derived class

41324
27:25:41,360 --> 27:25:43,680
information and all you're going to be

41325
27:25:43,680 --> 27:25:46,480
left with is base class information here

41326
27:25:46,480 --> 27:25:48,872
that's why this is going to call ship

41327
27:25:48,872 --> 27:25:51,120
draw let's build and run and really make

41328
27:25:51,120 --> 27:25:52,960
you see this this is going to go through

41329
27:25:52,960 --> 27:25:55,912
gcc our favorite compiler the bullet is

41330
27:25:55,912 --> 27:25:58,160
going to be good we cannot clear and run

41331
27:25:58,160 --> 27:26:00,400
rooster you're going to see that it is

41332
27:26:00,400 --> 27:26:03,192
going to say shape draw even if we try

41333
27:26:03,192 --> 27:26:06,640
to assign a circle to a shape here this

41334
27:26:06,640 --> 27:26:08,400
is going to disappoint us because this

41335
27:26:08,400 --> 27:26:11,040
is really going to slice off circle and

41336
27:26:11,040 --> 27:26:12,400
oval information

41337
27:26:12,400 --> 27:26:14,800
and it is just going to leave in the

41338
27:26:14,800 --> 27:26:18,480
shape nucleus that we have in our circle

41339
27:26:18,480 --> 27:26:19,760
object here

41340
27:26:19,760 --> 27:26:22,080
if i can say it like that this is really

41341
27:26:22,080 --> 27:26:23,912
all i had to share in this lecture i

41342
27:26:23,912 --> 27:26:26,080
hope you found it interesting we are

41343
27:26:26,080 --> 27:26:27,912
going to stop here in this lecture in

41344
27:26:27,912 --> 27:26:29,680
the next one we're going to see what

41345
27:26:29,680 --> 27:26:32,800
happens if we try to store polymorphic

41346
27:26:32,800 --> 27:26:35,040
objects in collections

41347
27:26:35,040 --> 27:26:37,280
go ahead and finish up here and meet me

41348
27:26:37,280 --> 27:26:39,280
there in this lecture we're going to

41349
27:26:39,280 --> 27:26:42,400
explore what happens if you try to

41350
27:26:42,400 --> 27:26:46,400
directly store polymorphic objects in a

41351
27:26:46,400 --> 27:26:48,640
collection like an array

41352
27:26:48,640 --> 27:26:50,872
in the last lecture we have seen that if

41353
27:26:50,872 --> 27:26:54,552
you assign a derived object to a base

41354
27:26:54,552 --> 27:26:55,760
object

41355
27:26:55,760 --> 27:26:58,320
the data from the derived object is

41356
27:26:58,320 --> 27:27:01,440
going to be basically sliced off if you

41357
27:27:01,440 --> 27:27:04,720
assign an oval to a shape the oval part

41358
27:27:04,720 --> 27:27:07,440
of the object is going to be sliced off

41359
27:27:07,440 --> 27:27:10,232
and we're going to be left with only

41360
27:27:10,232 --> 27:27:12,960
shaped data that we assigned to our

41361
27:27:12,960 --> 27:27:15,440
shape object we saw that this was

41362
27:27:15,440 --> 27:27:18,552
referred to as slicing in c plus plus

41363
27:27:18,552 --> 27:27:20,400
and the same is going to happen if you

41364
27:27:20,400 --> 27:27:23,192
assign a circle object to a shape the

41365
27:27:23,192 --> 27:27:25,280
circle information is going to be sliced

41366
27:27:25,280 --> 27:27:26,232
off

41367
27:27:26,232 --> 27:27:29,040
then the oval information is also going

41368
27:27:29,040 --> 27:27:31,040
to be sliced off and we're going to be

41369
27:27:31,040 --> 27:27:34,400
left with the inner shape part

41370
27:27:34,400 --> 27:27:38,080
that we assign to our shape object here

41371
27:27:38,080 --> 27:27:39,912
now i want you to see that this can

41372
27:27:39,912 --> 27:27:42,640
happen indirectly in ways that you might

41373
27:27:42,640 --> 27:27:45,512
not expect and we are going to use our

41374
27:27:45,512 --> 27:27:48,080
inheritance hierarchy again the base

41375
27:27:48,080 --> 27:27:50,552
class is going to be shape we're going

41376
27:27:50,552 --> 27:27:53,040
to inherit from that and get oval and

41377
27:27:53,040 --> 27:27:55,512
we're going to inherit from oval and get

41378
27:27:55,512 --> 27:27:57,760
our circle class here

41379
27:27:57,760 --> 27:28:00,640
so let's look at a piece of code here we

41380
27:28:00,640 --> 27:28:03,040
are creating a bunch of objects we have

41381
27:28:03,040 --> 27:28:06,080
a bunch of circles and ovals and we are

41382
27:28:06,080 --> 27:28:08,400
setting up an array that is going to

41383
27:28:08,400 --> 27:28:11,360
directly store shape objects

41384
27:28:11,360 --> 27:28:14,800
but what we are doing is storing our

41385
27:28:14,800 --> 27:28:19,360
pre created objects in our array here

41386
27:28:19,360 --> 27:28:22,000
and from what you already know if you

41387
27:28:22,000 --> 27:28:25,512
store objects in an array like this this

41388
27:28:25,512 --> 27:28:27,760
is going to create copies even if you

41389
27:28:27,760 --> 27:28:30,320
can't see that directly so what we have

41390
27:28:30,320 --> 27:28:33,360
in our array here is not dirt so what we

41391
27:28:33,360 --> 27:28:36,640
have in our array here is not any kind

41392
27:28:36,640 --> 27:28:39,040
of direct reference to the object we

41393
27:28:39,040 --> 27:28:42,400
have on top here these are just copies

41394
27:28:42,400 --> 27:28:44,320
and notice what is happening we are

41395
27:28:44,320 --> 27:28:47,120
copying derived objects

41396
27:28:47,120 --> 27:28:49,912
in spots that are designed to store

41397
27:28:49,912 --> 27:28:52,960
direct shape objects and you might guess

41398
27:28:52,960 --> 27:28:54,552
what this is going to do this is going

41399
27:28:54,552 --> 27:28:56,160
to slice off

41400
27:28:56,160 --> 27:28:59,192
circle and oval information and only

41401
27:28:59,192 --> 27:29:01,120
shape information is going to be stored

41402
27:29:01,120 --> 27:29:03,440
in this array here so if we happen to

41403
27:29:03,440 --> 27:29:05,680
look through this array like we do here

41404
27:29:05,680 --> 27:29:07,040
and try to

41405
27:29:07,040 --> 27:29:09,120
call the draw method

41406
27:29:09,120 --> 27:29:11,600
this is not going to call the most

41407
27:29:11,600 --> 27:29:14,720
specific drill method for circle or oval

41408
27:29:14,720 --> 27:29:16,872
this is just going to call the shape

41409
27:29:16,872 --> 27:29:19,832
version of our draw method here this is

41410
27:29:19,832 --> 27:29:22,400
something i want you to see okay some of

41411
27:29:22,400 --> 27:29:24,800
you might say what if i take my

41412
27:29:24,800 --> 27:29:27,280
shape information in here and assign

41413
27:29:27,280 --> 27:29:29,360
that to a pointer and then go through

41414
27:29:29,360 --> 27:29:31,680
that pointer to call the draw method

41415
27:29:31,680 --> 27:29:34,232
well i hate to break it to you but the

41416
27:29:34,232 --> 27:29:36,640
moment your data is sliced off in a

41417
27:29:36,640 --> 27:29:39,040
situation like this you'll never get

41418
27:29:39,040 --> 27:29:41,280
that data back so even if you try and

41419
27:29:41,280 --> 27:29:43,512
take the object and sign that to a

41420
27:29:43,512 --> 27:29:45,832
pointer or a reference you're never

41421
27:29:45,832 --> 27:29:48,872
going to get polymorphic data again the

41422
27:29:48,872 --> 27:29:51,120
data has been lost permanently and you

41423
27:29:51,120 --> 27:29:53,760
never get that so even if you try to go

41424
27:29:53,760 --> 27:29:55,680
through a pointer or a reference to

41425
27:29:55,680 --> 27:29:58,000
manage your object that we have in this

41426
27:29:58,000 --> 27:30:00,720
array if we call the draw method we want

41427
27:30:00,720 --> 27:30:03,280
to get polymorphic behavior we will get

41428
27:30:03,280 --> 27:30:06,080
to the shape version of our draw method

41429
27:30:06,080 --> 27:30:09,040
called so the data has been sliced off

41430
27:30:09,040 --> 27:30:11,912
permanently if we store our derived

41431
27:30:11,912 --> 27:30:15,192
objects in an array like this or even if

41432
27:30:15,192 --> 27:30:18,800
we directly assign a derived object to a

41433
27:30:18,800 --> 27:30:21,440
base object this is going to slice off

41434
27:30:21,440 --> 27:30:24,400
the data and we will never get it back

41435
27:30:24,400 --> 27:30:27,040
anyway you should really know this okay

41436
27:30:27,040 --> 27:30:29,680
anytime i try to explain this

41437
27:30:29,680 --> 27:30:31,680
students mostly come up with this

41438
27:30:31,680 --> 27:30:34,800
question what if i try to store

41439
27:30:34,800 --> 27:30:37,512
references in my array

41440
27:30:37,512 --> 27:30:39,760
and do something like this now this is

41441
27:30:39,760 --> 27:30:42,160
not going to work and this is not even

41442
27:30:42,160 --> 27:30:45,192
go past the compilation stage of your

41443
27:30:45,192 --> 27:30:48,080
program the reason is we can't store

41444
27:30:48,080 --> 27:30:50,800
references in a collection and the

41445
27:30:50,800 --> 27:30:53,040
reason has to do with the left

41446
27:30:53,040 --> 27:30:56,800
assignability rule you can't assign to a

41447
27:30:56,800 --> 27:30:59,600
reference and i changed the reference to

41448
27:30:59,600 --> 27:31:02,160
store somewhere else and it really drive

41449
27:31:02,160 --> 27:31:04,480
this home let's look at this example

41450
27:31:04,480 --> 27:31:07,040
here we have a variable called a it is

41451
27:31:07,040 --> 27:31:09,760
of entertype and we have a 56 value

41452
27:31:09,760 --> 27:31:12,232
inside and we set up a reference which

41453
27:31:12,232 --> 27:31:14,480
is going to be referencing the data we

41454
27:31:14,480 --> 27:31:17,440
have in a and down on this line here we

41455
27:31:17,440 --> 27:31:20,232
try to change the data in our reference

41456
27:31:20,232 --> 27:31:22,400
but this is not going to be changing

41457
27:31:22,400 --> 27:31:25,760
where this reference is pointing to or

41458
27:31:25,760 --> 27:31:28,480
where this reference is referencing this

41459
27:31:28,480 --> 27:31:32,320
will merely be changing the values in

41460
27:31:32,320 --> 27:31:35,912
our reference here and once we have this

41461
27:31:35,912 --> 27:31:38,480
reference we'll never be able to change

41462
27:31:38,480 --> 27:31:41,120
where it is pointing again so from this

41463
27:31:41,120 --> 27:31:42,800
hopefully you can understand that

41464
27:31:42,800 --> 27:31:46,080
references are not left assignable you

41465
27:31:46,080 --> 27:31:48,960
can't store thanks that are not left

41466
27:31:48,960 --> 27:31:51,192
assignable in an array

41467
27:31:51,192 --> 27:31:54,080
because an array is designed to modify

41468
27:31:54,080 --> 27:31:57,120
the data of what is stored inside so if

41469
27:31:57,120 --> 27:31:59,280
we set up an array like this

41470
27:31:59,280 --> 27:32:01,512
the compiler thinks that at some later

41471
27:32:01,512 --> 27:32:04,000
point you will want to assign

41472
27:32:04,000 --> 27:32:06,400
other data to what is already stored in

41473
27:32:06,400 --> 27:32:08,640
this array and there is a hard

41474
27:32:08,640 --> 27:32:10,960
requirement on the data you store in

41475
27:32:10,960 --> 27:32:13,600
your collections for the type of that

41476
27:32:13,600 --> 27:32:16,400
data at least to be left assignable

41477
27:32:16,400 --> 27:32:18,800
and references are not left assignable

41478
27:32:18,800 --> 27:32:21,040
so we can't store them in a collection

41479
27:32:21,040 --> 27:32:22,872
like this if we're trying to do this

41480
27:32:22,872 --> 27:32:25,192
we're going to get a compiler error but

41481
27:32:25,192 --> 27:32:26,960
again some of you are going to say what

41482
27:32:26,960 --> 27:32:28,800
if we store in pointers well this is

41483
27:32:28,800 --> 27:32:31,600
going to work this is the basic working

41484
27:32:31,600 --> 27:32:33,912
principle of polymorphism

41485
27:32:33,912 --> 27:32:36,320
going through base pointers to manage

41486
27:32:36,320 --> 27:32:39,480
derived objects this is going to use

41487
27:32:39,480 --> 27:32:42,000
polymorphism and here we will get the

41488
27:32:42,000 --> 27:32:44,552
most basic draw method called

41489
27:32:44,552 --> 27:32:46,960
so if our object is a circle we will

41490
27:32:46,960 --> 27:32:49,120
call the draw method on the circle

41491
27:32:49,120 --> 27:32:51,280
object if it is a novel we're going to

41492
27:32:51,280 --> 27:32:54,960
call the draw method for the over part

41493
27:32:54,960 --> 27:32:57,832
of our object here this is even going to

41494
27:32:57,832 --> 27:33:00,640
work if we go through smart pointers so

41495
27:33:00,640 --> 27:33:03,280
if we do something like this and store

41496
27:33:03,280 --> 27:33:06,160
in smart pointers and create our smart

41497
27:33:06,160 --> 27:33:08,640
pointers on the fly in our initializer

41498
27:33:08,640 --> 27:33:10,480
here this is going to work because

41499
27:33:10,480 --> 27:33:13,280
really a smart pointer is a wrapper on

41500
27:33:13,280 --> 27:33:16,080
top of the regular roll pointer in c

41501
27:33:16,080 --> 27:33:18,720
plus plus so again the message here is

41502
27:33:18,720 --> 27:33:21,120
that you need to be careful on what you

41503
27:33:21,120 --> 27:33:24,080
store in your collections if it is a raw

41504
27:33:24,080 --> 27:33:26,320
piece of ghana your data is going to be

41505
27:33:26,320 --> 27:33:29,912
sliced off if you store derived objects

41506
27:33:29,912 --> 27:33:32,320
in a collection that is designed to

41507
27:33:32,320 --> 27:33:33,360
store

41508
27:33:33,360 --> 27:33:36,232
base class data if you store any

41509
27:33:36,232 --> 27:33:38,160
references that's not even going to

41510
27:33:38,160 --> 27:33:40,720
compile but if you're storing any kind

41511
27:33:40,720 --> 27:33:43,512
of pointer row or smart this is going to

41512
27:33:43,512 --> 27:33:46,160
work because polymorphism was designed

41513
27:33:46,160 --> 27:33:48,400
in the first place to work with base

41514
27:33:48,400 --> 27:33:50,640
pointers that are managing derived

41515
27:33:50,640 --> 27:33:52,872
objects this is really cool and i want

41516
27:33:52,872 --> 27:33:55,280
you to be aware of this now that you

41517
27:33:55,280 --> 27:33:56,640
know this we're going to head over to

41518
27:33:56,640 --> 27:33:58,552
visual studio code and play with this a

41519
27:33:58,552 --> 27:34:01,192
little more here we are in our working

41520
27:34:01,192 --> 27:34:03,040
folder the current project is

41521
27:34:03,040 --> 27:34:05,512
polymorphic objects stored in

41522
27:34:05,512 --> 27:34:07,912
collections we are going to reuse the

41523
27:34:07,912 --> 27:34:10,160
code from the last lecture because we

41524
27:34:10,160 --> 27:34:13,440
need our inheritance hierarchy here and

41525
27:34:13,440 --> 27:34:15,680
this is going to serve us just well

41526
27:34:15,680 --> 27:34:17,360
we're going to copy this

41527
27:34:17,360 --> 27:34:20,160
and we are going to head over in our

41528
27:34:20,160 --> 27:34:22,400
current project and put in our code and

41529
27:34:22,400 --> 27:34:24,000
then we're going to open this in visual

41530
27:34:24,000 --> 27:34:26,000
studio code pretty quick let's do this

41531
27:34:26,000 --> 27:34:28,080
this is going to give us our code and we

41532
27:34:28,080 --> 27:34:30,080
have our shape class which is really

41533
27:34:30,080 --> 27:34:32,960
what we already know we have our oval

41534
27:34:32,960 --> 27:34:33,912
class

41535
27:34:33,912 --> 27:34:36,640
and we have our circle class take a good

41536
27:34:36,640 --> 27:34:39,280
look at this and what we want to see is

41537
27:34:39,280 --> 27:34:40,720
what happens

41538
27:34:40,720 --> 27:34:44,320
if we use different kinds of setups to

41539
27:34:44,320 --> 27:34:47,120
store objects of this inheritance

41540
27:34:47,120 --> 27:34:49,912
hierarchy in a collection like an array

41541
27:34:49,912 --> 27:34:52,872
let's go back to our main cpp file and

41542
27:34:52,872 --> 27:34:54,960
we are going to take out what we have in

41543
27:34:54,960 --> 27:34:56,552
here we're going to set up what we're

41544
27:34:56,552 --> 27:34:59,120
going to be using in this lecture we are

41545
27:34:59,120 --> 27:35:00,872
going to set up a bunch of objects that

41546
27:35:00,872 --> 27:35:02,872
we're going to be using here basically a

41547
27:35:02,872 --> 27:35:05,600
bunch of circles and ovals we can close

41548
27:35:05,600 --> 27:35:08,320
the left sidebar here and have some more

41549
27:35:08,320 --> 27:35:10,400
breathing room after this we're going to

41550
27:35:10,400 --> 27:35:12,872
set up an array which is going to store

41551
27:35:12,872 --> 27:35:16,480
copies of this object in this array here

41552
27:35:16,480 --> 27:35:18,960
which is called shapes one and after

41553
27:35:18,960 --> 27:35:20,720
this we're going to try and loop through

41554
27:35:20,720 --> 27:35:23,192
this array and try to do things with it

41555
27:35:23,192 --> 27:35:26,320
for example we can say for shape and we

41556
27:35:26,320 --> 27:35:30,080
may want to call the draw method on our

41557
27:35:30,080 --> 27:35:33,280
copy here so for example we can say s

41558
27:35:33,280 --> 27:35:35,512
and say draw going to see what happens

41559
27:35:35,512 --> 27:35:36,960
here and

41560
27:35:36,960 --> 27:35:39,120
let's say references because we don't

41561
27:35:39,120 --> 27:35:41,360
want copies in our

41562
27:35:41,360 --> 27:35:43,912
range based for loop here so this is

41563
27:35:43,912 --> 27:35:46,480
going to avoid copies we do in this loop

41564
27:35:46,480 --> 27:35:48,000
and we're going to be directly

41565
27:35:48,000 --> 27:35:50,232
referencing whatever we have in this

41566
27:35:50,232 --> 27:35:51,440
array here

41567
27:35:51,440 --> 27:35:53,832
now what do you expect to get we have

41568
27:35:53,832 --> 27:35:56,320
derived objects in this array

41569
27:35:56,320 --> 27:35:59,120
and with the setup we have here because

41570
27:35:59,120 --> 27:36:01,832
we are using virtual functions

41571
27:36:01,832 --> 27:36:04,160
one would expect to get

41572
27:36:04,160 --> 27:36:06,480
polymorphic behavior so here we would

41573
27:36:06,480 --> 27:36:08,160
expect to get the

41574
27:36:08,160 --> 27:36:11,192
joe versions in circle and oval to be

41575
27:36:11,192 --> 27:36:13,192
called but that's not what is going to

41576
27:36:13,192 --> 27:36:14,480
happen we're going to see that we're

41577
27:36:14,480 --> 27:36:16,800
going to be calling shape versions of

41578
27:36:16,800 --> 27:36:19,680
our draw methods let's try and build and

41579
27:36:19,680 --> 27:36:21,912
show you this we're going to world with

41580
27:36:21,912 --> 27:36:24,552
gcc our favorite compiler the build is

41581
27:36:24,552 --> 27:36:26,960
going to go through we can kill this and

41582
27:36:26,960 --> 27:36:29,512
bring up a powershell window to allow us

41583
27:36:29,512 --> 27:36:31,440
to run our program we're going to say

41584
27:36:31,440 --> 27:36:33,192
rooster here and you're going to see

41585
27:36:33,192 --> 27:36:36,400
that we are drawing circle one over one

41586
27:36:36,400 --> 27:36:38,720
circle two over two circle three oval

41587
27:36:38,720 --> 27:36:41,680
three but we are calling the shape

41588
27:36:41,680 --> 27:36:44,320
versions of our draw method

41589
27:36:44,320 --> 27:36:47,440
and the reason is we are slicing off

41590
27:36:47,440 --> 27:36:50,800
derived class information in our objects

41591
27:36:50,800 --> 27:36:53,192
the moment we try to make a copy and

41592
27:36:53,192 --> 27:36:56,800
copy in a spot that is designed to store

41593
27:36:56,800 --> 27:37:00,080
objects of the base class so this is

41594
27:37:00,080 --> 27:37:01,832
basically what we saw in the last

41595
27:37:01,832 --> 27:37:02,872
lecture

41596
27:37:02,872 --> 27:37:05,680
on the slicing but it is disguised

41597
27:37:05,680 --> 27:37:08,872
because we are storing data in an array

41598
27:37:08,872 --> 27:37:11,440
and when you store data in an array like

41599
27:37:11,440 --> 27:37:13,280
this you're going to be making copies

41600
27:37:13,280 --> 27:37:16,640
and storing copies in your array and in

41601
27:37:16,640 --> 27:37:18,160
any copy you make you're going to be

41602
27:37:18,160 --> 27:37:20,800
basically slicing off oval and circle

41603
27:37:20,800 --> 27:37:23,760
information and only storing in shape

41604
27:37:23,760 --> 27:37:26,552
information for our objects here this is

41605
27:37:26,552 --> 27:37:28,400
what the compiler is going to do and

41606
27:37:28,400 --> 27:37:30,800
that really try and prove this we can

41607
27:37:30,800 --> 27:37:34,000
try and print the size of these objects

41608
27:37:34,000 --> 27:37:36,800
and see the sizes of these objects in

41609
27:37:36,800 --> 27:37:39,192
this array here when we loop so for

41610
27:37:39,192 --> 27:37:43,760
example we can say stdc out size of

41611
27:37:43,760 --> 27:37:47,280
circle one do we have circle one yes we

41612
27:37:47,280 --> 27:37:49,760
do so we're going to say size of circle

41613
27:37:49,760 --> 27:37:50,960
one here

41614
27:37:50,960 --> 27:37:52,400
and we're going to put its size

41615
27:37:52,400 --> 27:37:55,040
information out here to be seen by

41616
27:37:55,040 --> 27:37:57,192
everybody we're going to say size of

41617
27:37:57,192 --> 27:37:59,040
circle one and we're going to print it

41618
27:37:59,040 --> 27:38:01,360
out and we are also going to print the

41619
27:38:01,360 --> 27:38:04,480
size of whatever iteration we are at in

41620
27:38:04,480 --> 27:38:06,400
our loop here that's the first thing

41621
27:38:06,400 --> 27:38:08,000
we're going to prep and we're going to

41622
27:38:08,000 --> 27:38:10,640
say size of object and we're going to

41623
27:38:10,640 --> 27:38:13,912
say size of s this is going to do

41624
27:38:13,912 --> 27:38:15,680
and we're going to loop and see if the

41625
27:38:15,680 --> 27:38:17,832
information we have on the outside is

41626
27:38:17,832 --> 27:38:20,480
the same as we have on the outside again

41627
27:38:20,480 --> 27:38:22,872
we are printing this information on the

41628
27:38:22,872 --> 27:38:24,800
direct object

41629
27:38:24,800 --> 27:38:28,000
which is really not yet in our array and

41630
27:38:28,000 --> 27:38:29,512
in fact we can

41631
27:38:29,512 --> 27:38:32,640
bring this in front of our array to make

41632
27:38:32,640 --> 27:38:35,760
this super clear and in our loop we are

41633
27:38:35,760 --> 27:38:38,160
printing information on a copy that we

41634
27:38:38,160 --> 27:38:41,120
have in our array because this is the

41635
27:38:41,120 --> 27:38:44,232
real deal we have in our array because

41636
27:38:44,232 --> 27:38:45,912
this is a reference hopefully this is

41637
27:38:45,912 --> 27:38:48,320
going to make sense and prove to you

41638
27:38:48,320 --> 27:38:51,192
that we are going to be working with

41639
27:38:51,192 --> 27:38:53,680
derived objects and the data is going to

41640
27:38:53,680 --> 27:38:57,120
be sliced off if we copy the data in our

41641
27:38:57,120 --> 27:38:58,960
array here this is what i want you to

41642
27:38:58,960 --> 27:39:01,120
see so we're going to run this again

41643
27:39:01,120 --> 27:39:03,192
we're going to pass this through gcc the

41644
27:39:03,192 --> 27:39:04,720
build is going to be good we're going to

41645
27:39:04,720 --> 27:39:06,080
clear

41646
27:39:06,080 --> 27:39:07,760
and run rooster

41647
27:39:07,760 --> 27:39:10,000
now let's look at what we have here size

41648
27:39:10,000 --> 27:39:12,872
of circle 1 is 56 but you're going to

41649
27:39:12,872 --> 27:39:16,000
see that the size for all our objects in

41650
27:39:16,000 --> 27:39:17,440
our array

41651
27:39:17,440 --> 27:39:20,720
has shrinked to 40 because derived class

41652
27:39:20,720 --> 27:39:23,192
information has been sliced off the

41653
27:39:23,192 --> 27:39:26,232
moment we copied our data in our array

41654
27:39:26,232 --> 27:39:28,552
here and this is what i want you to see

41655
27:39:28,552 --> 27:39:30,872
and i think we can even see this if we

41656
27:39:30,872 --> 27:39:33,832
go through our debugger for example we

41657
27:39:33,832 --> 27:39:36,552
can put a break point here

41658
27:39:36,552 --> 27:39:40,080
and uh open our run tab and if we try to

41659
27:39:40,080 --> 27:39:42,080
run our program through the debugger the

41660
27:39:42,080 --> 27:39:44,800
build is going to be good and the binary

41661
27:39:44,800 --> 27:39:47,600
is going to be passed into our debugger

41662
27:39:47,600 --> 27:39:49,280
and we're going to hit our break point

41663
27:39:49,280 --> 27:39:52,000
in a minute so let's wait for this and

41664
27:39:52,000 --> 27:39:54,160
we have hit our break point here but

41665
27:39:54,160 --> 27:39:56,000
what we can do now

41666
27:39:56,000 --> 27:39:59,120
is look at our local variables on the

41667
27:39:59,120 --> 27:40:01,760
left let's look at our array the array

41668
27:40:01,760 --> 27:40:03,832
is called ships

41669
27:40:03,832 --> 27:40:07,280
and if we go up we're going to see our

41670
27:40:07,280 --> 27:40:09,440
ships one array

41671
27:40:09,440 --> 27:40:11,280
and we're going to see that we have five

41672
27:40:11,280 --> 27:40:13,280
indexes here because we have six

41673
27:40:13,280 --> 27:40:14,872
elements inside

41674
27:40:14,872 --> 27:40:17,360
we can expand and see what we have at

41675
27:40:17,360 --> 27:40:19,680
index zero and you're going to see that

41676
27:40:19,680 --> 27:40:22,320
we just have description data because

41677
27:40:22,320 --> 27:40:24,552
this is a shape if we go back in our

41678
27:40:24,552 --> 27:40:26,480
class we're going to see that the only

41679
27:40:26,480 --> 27:40:28,480
thing we have in our shape class is

41680
27:40:28,480 --> 27:40:31,192
really a description member variable and

41681
27:40:31,192 --> 27:40:34,000
it is what we see in our array here just

41682
27:40:34,000 --> 27:40:36,320
description information because this is

41683
27:40:36,320 --> 27:40:39,040
a shaped object and we have lost or

41684
27:40:39,040 --> 27:40:41,360
derived class information and this is

41685
27:40:41,360 --> 27:40:43,600
really cool but if we go on top and for

41686
27:40:43,600 --> 27:40:45,832
example expand circle one we're going to

41687
27:40:45,832 --> 27:40:48,480
see that we have a novel part of us and

41688
27:40:48,480 --> 27:40:50,640
we have a ship part of us but these

41689
27:40:50,640 --> 27:40:53,360
events have been stripped off in our

41690
27:40:53,360 --> 27:40:56,552
array when we slice off the data from

41691
27:40:56,552 --> 27:40:59,440
derived objects to only store shape

41692
27:40:59,440 --> 27:41:01,832
information in our array here i hope

41693
27:41:01,832 --> 27:41:04,000
this makes sense now we're going to kill

41694
27:41:04,000 --> 27:41:06,080
our debugging session because we don't

41695
27:41:06,080 --> 27:41:08,480
need this anymore and we are going to

41696
27:41:08,480 --> 27:41:10,960
comment this out and see some other

41697
27:41:10,960 --> 27:41:13,440
things so we are going to

41698
27:41:13,440 --> 27:41:15,192
comment with our data here we're going

41699
27:41:15,192 --> 27:41:18,552
to say if you store row derived objects

41700
27:41:18,552 --> 27:41:21,360
in an array which was set up to store

41701
27:41:21,360 --> 27:41:23,440
base class object the data is going to

41702
27:41:23,440 --> 27:41:25,360
be sliced off this is something i want

41703
27:41:25,360 --> 27:41:27,680
you to know but some of you are going to

41704
27:41:27,680 --> 27:41:28,480
say

41705
27:41:28,480 --> 27:41:30,872
what if we store it in references okay

41706
27:41:30,872 --> 27:41:32,400
so let's try and do that we're going to

41707
27:41:32,400 --> 27:41:34,160
set up a piece of code like this and

41708
27:41:34,160 --> 27:41:35,832
we're going to set up an array called

41709
27:41:35,832 --> 27:41:38,400
shapes2 and this array is going to be

41710
27:41:38,400 --> 27:41:40,640
basically storing references to the

41711
27:41:40,640 --> 27:41:43,280
objects we have on top here and we're

41712
27:41:43,280 --> 27:41:44,800
going to see what happens you notice

41713
27:41:44,800 --> 27:41:47,832
that we have a squiggly line already and

41714
27:41:47,832 --> 27:41:50,480
this is saying this is not going to work

41715
27:41:50,480 --> 27:41:52,480
because references can't really be

41716
27:41:52,480 --> 27:41:54,400
stored in collections

41717
27:41:54,400 --> 27:41:56,720
again as we saw in the slides the reason

41718
27:41:56,720 --> 27:41:58,080
is because

41719
27:41:58,080 --> 27:42:00,960
references are not left assignable and

41720
27:42:00,960 --> 27:42:03,440
they can't be stored in a collection

41721
27:42:03,440 --> 27:42:06,480
like an array here the basic requirement

41722
27:42:06,480 --> 27:42:09,192
on the types that you can store in your

41723
27:42:09,192 --> 27:42:11,600
array is that they have to be left

41724
27:42:11,600 --> 27:42:15,120
assignable and our references are not

41725
27:42:15,120 --> 27:42:17,192
rest assignable so this is not going to

41726
27:42:17,192 --> 27:42:20,320
compile if we try to build our program

41727
27:42:20,320 --> 27:42:21,600
we're going to see that we're going to

41728
27:42:21,600 --> 27:42:24,080
get weird compiler errors

41729
27:42:24,080 --> 27:42:25,912
and the build is going to finish with

41730
27:42:25,912 --> 27:42:27,912
errors and if we go up we're going to

41731
27:42:27,912 --> 27:42:31,192
see that declaration of shapes to us

41732
27:42:31,192 --> 27:42:33,512
array of references and this is not

41733
27:42:33,512 --> 27:42:35,680
allowed you can't have an array of

41734
27:42:35,680 --> 27:42:38,480
references in c plus plus and this is

41735
27:42:38,480 --> 27:42:39,912
the reason why so we're going to get a

41736
27:42:39,912 --> 27:42:42,160
compiler error here okay so now you know

41737
27:42:42,160 --> 27:42:43,600
this but some of you are going to say

41738
27:42:43,600 --> 27:42:45,280
what if we go through pointers well

41739
27:42:45,280 --> 27:42:47,232
that's going to work because

41740
27:42:47,232 --> 27:42:50,720
polymorphism through virtual functions

41741
27:42:50,720 --> 27:42:53,040
was basically designed to work with base

41742
27:42:53,040 --> 27:42:55,680
pointers that are managing derived

41743
27:42:55,680 --> 27:42:58,232
objects and this is what we have here so

41744
27:42:58,232 --> 27:43:00,400
if we look we're going to be getting

41745
27:43:00,400 --> 27:43:03,440
polymorphic behavior and if we call our

41746
27:43:03,440 --> 27:43:05,512
draw method on our pointer here we're

41747
27:43:05,512 --> 27:43:08,480
going to get the most specific

41748
27:43:08,480 --> 27:43:10,872
joe method called and this is what we

41749
27:43:10,872 --> 27:43:13,040
want so we're going to try and weld this

41750
27:43:13,040 --> 27:43:14,720
again and show you that this is going to

41751
27:43:14,720 --> 27:43:16,552
work the build is going to be good we

41752
27:43:16,552 --> 27:43:17,680
can clear

41753
27:43:17,680 --> 27:43:20,080
and run rooster and we're going to see

41754
27:43:20,080 --> 27:43:22,480
that we are going to be looping around

41755
27:43:22,480 --> 27:43:24,080
and if we call the draw method we're

41756
27:43:24,080 --> 27:43:26,720
going to call the overdraw method circle

41757
27:43:26,720 --> 27:43:29,120
draw method overdraw method circle draw

41758
27:43:29,120 --> 27:43:31,360
method this is basically what we want

41759
27:43:31,360 --> 27:43:33,440
and we are going through base pointers

41760
27:43:33,440 --> 27:43:36,232
to really use polymorphism here this is

41761
27:43:36,232 --> 27:43:37,912
definitely going to work if you go

41762
27:43:37,912 --> 27:43:40,232
through smart pointers so let's comment

41763
27:43:40,232 --> 27:43:42,400
this out and set up another example to

41764
27:43:42,400 --> 27:43:44,552
really drive this home you can really

41765
27:43:44,552 --> 27:43:46,720
use any kind of smart pointer you can

41766
27:43:46,720 --> 27:43:50,160
use unique pointer or shared pointers so

41767
27:43:50,160 --> 27:43:52,640
here we will just be storing in shared

41768
27:43:52,640 --> 27:43:54,480
pointers because this is easier to

41769
27:43:54,480 --> 27:43:56,640
handle and we're going to head over to

41770
27:43:56,640 --> 27:43:58,800
the top and include the memory header if

41771
27:43:58,800 --> 27:44:01,192
you remember if you want to use smart

41772
27:44:01,192 --> 27:44:03,832
pointers in c plus plus you will have to

41773
27:44:03,832 --> 27:44:05,912
include the memory header which brings

41774
27:44:05,912 --> 27:44:08,640
in the data to set up smart pointers in

41775
27:44:08,640 --> 27:44:10,400
your surplus plus code

41776
27:44:10,400 --> 27:44:13,360
so this is going to look good now and if

41777
27:44:13,360 --> 27:44:14,960
we build we're going to get the most

41778
27:44:14,960 --> 27:44:18,000
specific version of our draw method

41779
27:44:18,000 --> 27:44:20,800
called through polymorphism that is

41780
27:44:20,800 --> 27:44:23,120
using virtual functions here so let's

41781
27:44:23,120 --> 27:44:24,872
build and show you that this is going to

41782
27:44:24,872 --> 27:44:26,872
work the book is going to be good we can

41783
27:44:26,872 --> 27:44:28,080
clear

41784
27:44:28,080 --> 27:44:30,552
and run rooster and we are going to get

41785
27:44:30,552 --> 27:44:33,680
our versions of draw called the version

41786
27:44:33,680 --> 27:44:36,160
for a circle and the version for oval

41787
27:44:36,160 --> 27:44:38,640
because we are using base pointers to

41788
27:44:38,640 --> 27:44:41,680
manage derived objects here and our

41789
27:44:41,680 --> 27:44:44,000
class inheritance hierarchy is using

41790
27:44:44,000 --> 27:44:46,480
virtual functions for the draw method

41791
27:44:46,480 --> 27:44:48,400
here so this is going to work this is

41792
27:44:48,400 --> 27:44:50,400
really all i wanted you to see in this

41793
27:44:50,400 --> 27:44:53,280
lecture you should be careful if you try

41794
27:44:53,280 --> 27:44:54,640
to store

41795
27:44:54,640 --> 27:44:58,320
derived objects in an array that was

41796
27:44:58,320 --> 27:45:01,680
designed to store base class data if you

41797
27:45:01,680 --> 27:45:03,760
are using raw data you're going to get

41798
27:45:03,760 --> 27:45:05,040
slicing

41799
27:45:05,040 --> 27:45:07,512
and you really need to be aware of this

41800
27:45:07,512 --> 27:45:09,680
because you want to have derived class

41801
27:45:09,680 --> 27:45:12,000
information if you try to store any

41802
27:45:12,000 --> 27:45:13,760
references this is not even going to

41803
27:45:13,760 --> 27:45:16,232
compile because references are not left

41804
27:45:16,232 --> 27:45:18,400
assignable but this is going to work if

41805
27:45:18,400 --> 27:45:20,960
you use role pointers or smart pointers

41806
27:45:20,960 --> 27:45:23,120
because polymorphism was basically

41807
27:45:23,120 --> 27:45:25,760
designed to work with base pointers or

41808
27:45:25,760 --> 27:45:28,720
references that are managing a derived

41809
27:45:28,720 --> 27:45:32,160
object which uses polymorphism we are

41810
27:45:32,160 --> 27:45:34,000
going to stop here in this lecture the

41811
27:45:34,000 --> 27:45:35,760
next one we're going to learn about the

41812
27:45:35,760 --> 27:45:39,192
override mechanism in c plus plus go

41813
27:45:39,192 --> 27:45:41,360
ahead and finish up here and meet me

41814
27:45:41,360 --> 27:45:42,872
there in this lecture we're going to

41815
27:45:42,872 --> 27:45:45,832
learn about the override specification

41816
27:45:45,832 --> 27:45:49,440
a kind of setup you can do to avoid

41817
27:45:49,440 --> 27:45:52,480
errors in your inheritance hierarchies

41818
27:45:52,480 --> 27:45:54,800
if you use virtual functions to set up

41819
27:45:54,800 --> 27:45:58,000
polymorphic behavior for your derived

41820
27:45:58,000 --> 27:46:00,640
objects and this is something that was

41821
27:46:00,640 --> 27:46:03,360
set up in ziplus plus to avoid easy to

41822
27:46:03,360 --> 27:46:04,720
make mistakes

41823
27:46:04,720 --> 27:46:07,440
for example if you have an inheritance

41824
27:46:07,440 --> 27:46:10,232
hierarchy like this you might be meaning

41825
27:46:10,232 --> 27:46:12,960
to set up a draw overrides for what we

41826
27:46:12,960 --> 27:46:15,440
have in the base class and an override

41827
27:46:15,440 --> 27:46:17,912
is really a must specific

41828
27:46:17,912 --> 27:46:20,552
method that you have in your derived

41829
27:46:20,552 --> 27:46:23,512
class to really hide what we had in the

41830
27:46:23,512 --> 27:46:25,760
base class for example the draw method

41831
27:46:25,760 --> 27:46:28,000
novel is going to be overriding or

41832
27:46:28,000 --> 27:46:30,400
hiding what we have in shape

41833
27:46:30,400 --> 27:46:32,480
and the draw method in circle is going

41834
27:46:32,480 --> 27:46:35,120
to be overriding or hiding what we have

41835
27:46:35,120 --> 27:46:38,000
in oval this is the idea here but as you

41836
27:46:38,000 --> 27:46:40,720
set up your overrides you might make

41837
27:46:40,720 --> 27:46:42,720
mistakes for example you may mean to say

41838
27:46:42,720 --> 27:46:46,640
draw and i use a w that is in uppercase

41839
27:46:46,640 --> 27:46:49,040
and that's going to be bad because what

41840
27:46:49,040 --> 27:46:51,280
you will be putting in oval is going to

41841
27:46:51,280 --> 27:46:54,160
be a completely separate method that is

41842
27:46:54,160 --> 27:46:56,232
different from what we have on the top

41843
27:46:56,232 --> 27:46:58,000
and this is going to be really bad

41844
27:46:58,000 --> 27:46:59,832
you're not going to get polymorphic

41845
27:46:59,832 --> 27:47:02,640
behavior for the draw method in oval

41846
27:47:02,640 --> 27:47:05,120
because we are simply not overriding the

41847
27:47:05,120 --> 27:47:07,440
jaw method from shape and this is going

41848
27:47:07,440 --> 27:47:10,320
to be bad so in ziploc plus we can avoid

41849
27:47:10,320 --> 27:47:14,232
these problems by explicitly specifying

41850
27:47:14,232 --> 27:47:16,960
that the draw method we have in alpha is

41851
27:47:16,960 --> 27:47:19,360
an override and we can add this

41852
27:47:19,360 --> 27:47:23,192
specification after our method header

41853
27:47:23,192 --> 27:47:25,440
and the c plus plus compiler is going to

41854
27:47:25,440 --> 27:47:28,232
enforce that we are actually overriding

41855
27:47:28,232 --> 27:47:31,040
a method that exists in our parents

41856
27:47:31,040 --> 27:47:34,232
class which happens to be shape here if

41857
27:47:34,232 --> 27:47:36,552
we have no method called draw in the

41858
27:47:36,552 --> 27:47:38,160
base class we're going to get a compiler

41859
27:47:38,160 --> 27:47:40,552
error because we want to be basically

41860
27:47:40,552 --> 27:47:42,960
overriding any method here this is going

41861
27:47:42,960 --> 27:47:45,680
to protect us from problems if we make

41862
27:47:45,680 --> 27:47:48,552
typos in setting up our polymorphic

41863
27:47:48,552 --> 27:47:51,192
methods here this is the main thing we

41864
27:47:51,192 --> 27:47:53,512
can achieve with the override

41865
27:47:53,512 --> 27:47:55,760
specification now that you know this

41866
27:47:55,760 --> 27:47:57,120
we're going to head over to visual

41867
27:47:57,120 --> 27:47:58,872
studio code and play with us a little

41868
27:47:58,872 --> 27:48:01,760
more here we are in our working folder

41869
27:48:01,760 --> 27:48:04,080
the current project is override here

41870
27:48:04,080 --> 27:48:05,600
we're going to grab the code from the

41871
27:48:05,600 --> 27:48:07,680
last lecture because we are basically

41872
27:48:07,680 --> 27:48:09,912
going to be reusing the same code over

41873
27:48:09,912 --> 27:48:10,872
and over

41874
27:48:10,872 --> 27:48:13,360
building on top of that if we need to do

41875
27:48:13,360 --> 27:48:16,160
that so we're going to put in our code

41876
27:48:16,160 --> 27:48:18,080
and we are going to open this in visual

41877
27:48:18,080 --> 27:48:19,832
studio code by dragging and dropping

41878
27:48:19,832 --> 27:48:22,160
here this is going to give us our code

41879
27:48:22,160 --> 27:48:24,080
and we can really do whatever we want

41880
27:48:24,080 --> 27:48:27,040
with that i think we can leave in the

41881
27:48:27,040 --> 27:48:29,912
code that is using the base pointer to

41882
27:48:29,912 --> 27:48:32,640
manage our derived objects i think this

41883
27:48:32,640 --> 27:48:34,320
is going to serve us

41884
27:48:34,320 --> 27:48:36,080
well enough and we can take out

41885
27:48:36,080 --> 27:48:37,760
everything else because that's just

41886
27:48:37,760 --> 27:48:40,232
going to be confusion we don't need all

41887
27:48:40,232 --> 27:48:42,960
this here this is going to be serving us

41888
27:48:42,960 --> 27:48:45,192
well now we want to learn about the

41889
27:48:45,192 --> 27:48:46,960
override key world

41890
27:48:46,960 --> 27:48:49,440
and to learn about that we're going to

41891
27:48:49,440 --> 27:48:52,232
introduce a title on purpose here for

41892
27:48:52,232 --> 27:48:55,440
example suppose we want to set up a draw

41893
27:48:55,440 --> 27:48:57,440
override and we use

41894
27:48:57,440 --> 27:49:00,000
an uppercase letter here for the w key

41895
27:49:00,000 --> 27:49:02,232
world i don't think this is really easy

41896
27:49:02,232 --> 27:49:04,800
to spot once you've made this mistake

41897
27:49:04,800 --> 27:49:06,480
and you're not going to be getting any

41898
27:49:06,480 --> 27:49:09,192
compiler error because

41899
27:49:09,192 --> 27:49:11,192
this is something valid you can set up a

41900
27:49:11,192 --> 27:49:14,872
completely new method and call it joe

41901
27:49:14,872 --> 27:49:16,960
and this is going to work but this will

41902
27:49:16,960 --> 27:49:20,400
be very hard to spot in your program and

41903
27:49:20,400 --> 27:49:22,232
the compiler won't protect you as we

41904
27:49:22,232 --> 27:49:24,552
just said if we build our program you're

41905
27:49:24,552 --> 27:49:26,232
going to see that it is going to bulk

41906
27:49:26,232 --> 27:49:29,760
just fine so let's pass this through gcc

41907
27:49:29,760 --> 27:49:31,512
the voltage is going to be good but we

41908
27:49:31,512 --> 27:49:33,912
want to get to the behavior that we want

41909
27:49:33,912 --> 27:49:36,320
i think we can take out this sddc out

41910
27:49:36,320 --> 27:49:39,440
statement inside our for loop here and

41911
27:49:39,440 --> 27:49:41,440
we can weld again this is going to be

41912
27:49:41,440 --> 27:49:44,400
less confusing okay so the build is good

41913
27:49:44,400 --> 27:49:47,680
we can bring up our powershell window

41914
27:49:47,680 --> 27:49:49,440
and i'm going to run rooster and see

41915
27:49:49,440 --> 27:49:51,440
what happens you're going to see that

41916
27:49:51,440 --> 27:49:53,280
for a circle we're going to draw a

41917
27:49:53,280 --> 27:49:54,320
circle

41918
27:49:54,320 --> 27:49:56,000
but for oval

41919
27:49:56,000 --> 27:49:58,080
we're going to be drawing shape so what

41920
27:49:58,080 --> 27:50:02,000
is happening here we are overriding our

41921
27:50:02,000 --> 27:50:04,640
joe method in the overclass so we should

41922
27:50:04,640 --> 27:50:07,192
get polymorphic behavior because this is

41923
27:50:07,192 --> 27:50:10,000
a virtual function and it is called draw

41924
27:50:10,000 --> 27:50:12,872
exactly the same thing like we had in

41925
27:50:12,872 --> 27:50:15,120
the base class except we've made a

41926
27:50:15,120 --> 27:50:17,912
really simple typo here but it is really

41927
27:50:17,912 --> 27:50:20,320
hard to track and get hold of we have

41928
27:50:20,320 --> 27:50:24,000
named our method draw but the w is in

41929
27:50:24,000 --> 27:50:26,080
uppercase so this is a completely

41930
27:50:26,080 --> 27:50:29,912
different method than the draw method we

41931
27:50:29,912 --> 27:50:33,040
originally intended to override in our

41932
27:50:33,040 --> 27:50:34,960
base class and this is really hard to

41933
27:50:34,960 --> 27:50:37,680
follow and keep track of we can protect

41934
27:50:37,680 --> 27:50:40,000
ourselves by adding the override

41935
27:50:40,000 --> 27:50:43,040
specification so if we say override the

41936
27:50:43,040 --> 27:50:44,960
compiler is going to help out and make

41937
27:50:44,960 --> 27:50:47,120
sure that we are actually trying to

41938
27:50:47,120 --> 27:50:49,912
override the method that exists in the

41939
27:50:49,912 --> 27:50:52,400
shape class and if it doesn't exist

41940
27:50:52,400 --> 27:50:54,000
we're going to get a compiler error then

41941
27:50:54,000 --> 27:50:55,680
we're going to look at this and really

41942
27:50:55,680 --> 27:50:57,912
spot this mistake here this is what you

41943
27:50:57,912 --> 27:51:00,640
can achieve with the override keyword

41944
27:51:00,640 --> 27:51:03,760
and in fact i do recommend and advise

41945
27:51:03,760 --> 27:51:06,320
you to use this in your inheritance

41946
27:51:06,320 --> 27:51:08,720
hierarchy if you happen to be using

41947
27:51:08,720 --> 27:51:10,400
virtual functions because

41948
27:51:10,400 --> 27:51:12,552
this is going to save you a lot of time

41949
27:51:12,552 --> 27:51:14,720
if you make mistakes like this so we're

41950
27:51:14,720 --> 27:51:16,400
going to try and run this and show you

41951
27:51:16,400 --> 27:51:18,800
the compiler error we get so let's do

41952
27:51:18,800 --> 27:51:20,400
that we're going to pass this through

41953
27:51:20,400 --> 27:51:22,800
gcc the board is going to

41954
27:51:22,800 --> 27:51:24,552
fail as we see here and we're going to

41955
27:51:24,552 --> 27:51:27,680
get a compiler saying errol virtual void

41956
27:51:27,680 --> 27:51:30,640
overall joe cost marked override but

41957
27:51:30,640 --> 27:51:33,832
does not override this is super clear we

41958
27:51:33,832 --> 27:51:36,552
are saying we want to override here but

41959
27:51:36,552 --> 27:51:39,440
we're not overriding any method called

41960
27:51:39,440 --> 27:51:42,000
joe with an uppercase because we don't

41961
27:51:42,000 --> 27:51:43,600
have that in shape here this is the

41962
27:51:43,600 --> 27:51:45,760
message once we see the problem we can

41963
27:51:45,760 --> 27:51:47,440
correct it we're going to use in

41964
27:51:47,440 --> 27:51:50,320
lowercase letter for w and this is going

41965
27:51:50,320 --> 27:51:52,552
to work just fine now we're going to use

41966
27:51:52,552 --> 27:51:55,280
the same mechanism to protect ourselves

41967
27:51:55,280 --> 27:51:57,832
from ourselves in circle class so we're

41968
27:51:57,832 --> 27:51:59,832
going to override our draw method but

41969
27:51:59,832 --> 27:52:01,512
we're going to say that we want to

41970
27:52:01,512 --> 27:52:04,960
override explicitly and if we're both

41971
27:52:04,960 --> 27:52:07,760
now let's pass this through gcc this is

41972
27:52:07,760 --> 27:52:09,680
going to build successfully and if we

41973
27:52:09,680 --> 27:52:11,192
run our program we're going to get

41974
27:52:11,192 --> 27:52:14,080
polymorphic behavior let's do that you

41975
27:52:14,080 --> 27:52:16,232
see that circle draw overdraw circle

41976
27:52:16,232 --> 27:52:18,480
draw overdraw this is what we expect

41977
27:52:18,480 --> 27:52:20,552
this is really cool this is really all i

41978
27:52:20,552 --> 27:52:22,400
had to share in this lecture i hope you

41979
27:52:22,400 --> 27:52:25,040
found it interesting use the override

41980
27:52:25,040 --> 27:52:27,512
keyword in your inheritance hierarchy

41981
27:52:27,512 --> 27:52:29,832
because that's going to protect you from

41982
27:52:29,832 --> 27:52:32,080
easy to make typos that are really going

41983
27:52:32,080 --> 27:52:35,040
to give you a hard time otherwise we are

41984
27:52:35,040 --> 27:52:37,040
going to stop here in this lecture in

41985
27:52:37,040 --> 27:52:38,800
the next one we're going to explore the

41986
27:52:38,800 --> 27:52:42,160
concepts of overriding and hiding in

41987
27:52:42,160 --> 27:52:43,280
detail

41988
27:52:43,280 --> 27:52:45,512
go ahead and finish up here and meet me

41989
27:52:45,512 --> 27:52:47,192
there in this lecture we're going to

41990
27:52:47,192 --> 27:52:50,232
zoom in on overloading overriding and

41991
27:52:50,232 --> 27:52:53,192
hiding we have seen that overriding is a

41992
27:52:53,192 --> 27:52:55,680
mechanism we have in c plus plus to be

41993
27:52:55,680 --> 27:52:57,192
able to set up

41994
27:52:57,192 --> 27:53:00,640
most specific versions of our virtual

41995
27:53:00,640 --> 27:53:03,120
methods in derived classes so for

41996
27:53:03,120 --> 27:53:05,600
example the draw method we have in oval

41997
27:53:05,600 --> 27:53:08,400
is overriding or eclipsing the one we

41998
27:53:08,400 --> 27:53:11,512
have in shape and the draw method in

41999
27:53:11,512 --> 27:53:13,760
circle is overriding

42000
27:53:13,760 --> 27:53:17,280
or hiding or eclipsing the one we have

42001
27:53:17,280 --> 27:53:20,232
in awful this is the concept here but

42002
27:53:20,232 --> 27:53:23,360
what happens if we introduce the concept

42003
27:53:23,360 --> 27:53:26,160
of overloading and mix that up with

42004
27:53:26,160 --> 27:53:28,640
overriding as we have seen so far so

42005
27:53:28,640 --> 27:53:30,800
suppose we do something like this this

42006
27:53:30,800 --> 27:53:33,832
is our shape class it is going to have

42007
27:53:33,832 --> 27:53:36,080
two versions of the draw method we have

42008
27:53:36,080 --> 27:53:38,872
one that takes one parameter for example

42009
27:53:38,872 --> 27:53:41,040
this could be the color that we want to

42010
27:53:41,040 --> 27:53:43,440
draw our shape with and another one is

42011
27:53:43,440 --> 27:53:45,832
not going to take any parameter and

42012
27:53:45,832 --> 27:53:49,040
these are two overloads of our virtual

42013
27:53:49,040 --> 27:53:51,360
method here so what is going to happen

42014
27:53:51,360 --> 27:53:54,232
in our derived classes that are going to

42015
27:53:54,232 --> 27:53:56,720
inherit this virtual method so let's

42016
27:53:56,720 --> 27:53:58,720
look at an example here we have a simple

42017
27:53:58,720 --> 27:54:01,120
example that is setting up objects of

42018
27:54:01,120 --> 27:54:03,512
our shapes we have a shape object we

42019
27:54:03,512 --> 27:54:05,760
have a novel object and we have a circle

42020
27:54:05,760 --> 27:54:08,480
object here if we call the draw method

42021
27:54:08,480 --> 27:54:10,960
on our most derived class which is

42022
27:54:10,960 --> 27:54:12,800
circle we're going to see that this is

42023
27:54:12,800 --> 27:54:14,400
going to work we can draw without a

42024
27:54:14,400 --> 27:54:16,480
parameter and we can draw with one

42025
27:54:16,480 --> 27:54:19,120
parameter which is going to be our color

42026
27:54:19,120 --> 27:54:21,512
depth this is going to work just fine we

42027
27:54:21,512 --> 27:54:23,280
will be reusing

42028
27:54:23,280 --> 27:54:25,760
our inherited method from the shape

42029
27:54:25,760 --> 27:54:28,080
class and this is really cool but what

42030
27:54:28,080 --> 27:54:31,600
happens if you override this method in

42031
27:54:31,600 --> 27:54:34,640
our overclass suppose we hijack the

42032
27:54:34,640 --> 27:54:36,872
inheritance process and set up another

42033
27:54:36,872 --> 27:54:40,640
draw method in our overclass and we only

42034
27:54:40,640 --> 27:54:44,160
override the overload that doesn't take

42035
27:54:44,160 --> 27:54:45,912
any parameter we can do something like

42036
27:54:45,912 --> 27:54:48,720
this but the moment you do this this is

42037
27:54:48,720 --> 27:54:51,440
going to only override this method and

42038
27:54:51,440 --> 27:54:53,912
it is going to hide all the other draw

42039
27:54:53,912 --> 27:54:57,600
methods that we had in our base class

42040
27:54:57,600 --> 27:54:59,120
which is shaped here and this is

42041
27:54:59,120 --> 27:55:01,600
something i want you to know so once you

42042
27:55:01,600 --> 27:55:04,480
override a single overload of your

42043
27:55:04,480 --> 27:55:06,232
virtual functions

42044
27:55:06,232 --> 27:55:08,480
all the other overloads are going to be

42045
27:55:08,480 --> 27:55:11,512
hidden and they won't be usable anymore

42046
27:55:11,512 --> 27:55:14,800
by downstream inheritance classes if you

42047
27:55:14,800 --> 27:55:17,040
want all the overloads to be available

42048
27:55:17,040 --> 27:55:19,120
to downstream inheritance

42049
27:55:19,120 --> 27:55:21,912
classes you have no choice but to

42050
27:55:21,912 --> 27:55:24,960
explicitly override each of them and

42051
27:55:24,960 --> 27:55:27,192
that's how it's going to work so if we

42052
27:55:27,192 --> 27:55:28,872
look at the example here we're going to

42053
27:55:28,872 --> 27:55:31,600
see that the draw call without a

42054
27:55:31,600 --> 27:55:33,600
parameter is going to work because this

42055
27:55:33,600 --> 27:55:37,440
is overridden in our oval class but if

42056
27:55:37,440 --> 27:55:39,832
we call the one which takes a parameter

42057
27:55:39,832 --> 27:55:42,320
this is going to be hidden at the oval

42058
27:55:42,320 --> 27:55:44,960
level and we want to have access to that

42059
27:55:44,960 --> 27:55:46,800
in circle and if we try to call this

42060
27:55:46,800 --> 27:55:48,552
we're going to get a compiler error

42061
27:55:48,552 --> 27:55:52,232
again the message is if you override one

42062
27:55:52,232 --> 27:55:56,160
overload of your virtual functions in

42063
27:55:56,160 --> 27:55:58,320
the base class all the other ones are

42064
27:55:58,320 --> 27:56:00,320
going to be hidden and you have no

42065
27:56:00,320 --> 27:56:03,120
choice but to explicitly override them

42066
27:56:03,120 --> 27:56:06,000
for them to be available and usable in

42067
27:56:06,000 --> 27:56:08,800
downstream classes this is the message i

42068
27:56:08,800 --> 27:56:10,800
wanted to convey here okay so now we

42069
27:56:10,800 --> 27:56:13,760
know this but what if we set up another

42070
27:56:13,760 --> 27:56:15,280
overload

42071
27:56:15,280 --> 27:56:17,912
downstream for example what if we go in

42072
27:56:17,912 --> 27:56:20,640
our oval class and set up another

42073
27:56:20,640 --> 27:56:22,800
overload which is going to have two

42074
27:56:22,800 --> 27:56:24,720
parameters for example we might have the

42075
27:56:24,720 --> 27:56:27,360
color depth and the color here that we

42076
27:56:27,360 --> 27:56:29,440
want to draw with okay so one thing you

42077
27:56:29,440 --> 27:56:31,680
should know is that this this method is

42078
27:56:31,680 --> 27:56:33,680
not going to participate in shape

42079
27:56:33,680 --> 27:56:37,040
polymorphism and what i mean is that if

42080
27:56:37,040 --> 27:56:38,800
we go through a base pointer or

42081
27:56:38,800 --> 27:56:41,600
reference to manage derived objects we

42082
27:56:41,600 --> 27:56:43,680
can't really call this method with shape

42083
27:56:43,680 --> 27:56:46,160
polymorphism so if we go through our

42084
27:56:46,160 --> 27:56:48,232
shape pointer or reference we want to be

42085
27:56:48,232 --> 27:56:50,552
really able to call this method if we

42086
27:56:50,552 --> 27:56:52,552
try to call it we will get a compiler

42087
27:56:52,552 --> 27:56:55,440
error the reason is this method is not

42088
27:56:55,440 --> 27:56:56,480
known

42089
27:56:56,480 --> 27:56:58,720
to the shape class that's why it's not

42090
27:56:58,720 --> 27:57:00,872
going to participate in shape

42091
27:57:00,872 --> 27:57:03,360
polymorphism the only methods that are

42092
27:57:03,360 --> 27:57:05,040
going to participate in shape

42093
27:57:05,040 --> 27:57:07,600
polymorphism are the methods that are

42094
27:57:07,600 --> 27:57:10,160
declared in the base class and they are

42095
27:57:10,160 --> 27:57:12,320
virtual this is the condition here and

42096
27:57:12,320 --> 27:57:15,192
if you violate this condition in any way

42097
27:57:15,192 --> 27:57:17,280
shape polymorphism or base class

42098
27:57:17,280 --> 27:57:19,280
polymorphism in this case is not going

42099
27:57:19,280 --> 27:57:21,192
to work and you will get a compiler

42100
27:57:21,192 --> 27:57:23,440
error so if you try to do something like

42101
27:57:23,440 --> 27:57:25,512
this and you want to call your draw

42102
27:57:25,512 --> 27:57:27,512
method with two parameters you're going

42103
27:57:27,512 --> 27:57:29,192
to get a bunch of compiler errors and

42104
27:57:29,192 --> 27:57:31,192
this is not going to work another thing

42105
27:57:31,192 --> 27:57:33,360
i want you to see is that if you assign

42106
27:57:33,360 --> 27:57:36,720
a derived object to a base object

42107
27:57:36,720 --> 27:57:40,400
your derived virtual functions are going

42108
27:57:40,400 --> 27:57:43,912
to be wiped out as part of the slicing

42109
27:57:43,912 --> 27:57:46,400
that we have learned about already so

42110
27:57:46,400 --> 27:57:49,192
the circle port is going to be wiped out

42111
27:57:49,192 --> 27:57:51,600
the oval part is going to be sliced off

42112
27:57:51,600 --> 27:57:54,000
and the draw method is going to go with

42113
27:57:54,000 --> 27:57:56,872
our oval part and we will only be left

42114
27:57:56,872 --> 27:57:59,120
with the shareport and if we try to call

42115
27:57:59,120 --> 27:58:01,040
this method here we will get a compiler

42116
27:58:01,040 --> 27:58:03,360
error because it's no longer available

42117
27:58:03,360 --> 27:58:05,600
it's been sliced off this is really what

42118
27:58:05,600 --> 27:58:07,760
i want you to see here now that we know

42119
27:58:07,760 --> 27:58:09,280
this we're going to head over to visual

42120
27:58:09,280 --> 27:58:11,120
studio code and play with this a little

42121
27:58:11,120 --> 27:58:13,832
more here we are in our working folder

42122
27:58:13,832 --> 27:58:16,232
the current project is overloading

42123
27:58:16,232 --> 27:58:18,720
overriding and hiding we want to explore

42124
27:58:18,720 --> 27:58:21,280
these concepts in a little more detail

42125
27:58:21,280 --> 27:58:22,720
we're going to grab the code from the

42126
27:58:22,720 --> 27:58:24,480
last lecture because that's going to be

42127
27:58:24,480 --> 27:58:26,160
a good starting point we're going to

42128
27:58:26,160 --> 27:58:28,232
take out the binary we don't want that

42129
27:58:28,232 --> 27:58:30,080
and we're going to copy and we're going

42130
27:58:30,080 --> 27:58:32,720
to put that in our current project here

42131
27:58:32,720 --> 27:58:34,872
this is going to do and we are going to

42132
27:58:34,872 --> 27:58:36,800
open this in visual studio code pretty

42133
27:58:36,800 --> 27:58:39,040
quick by dragging and dropping here and

42134
27:58:39,040 --> 27:58:41,192
we're going to see that we have a bunch

42135
27:58:41,192 --> 27:58:42,320
of

42136
27:58:42,320 --> 27:58:44,160
virtual functions here who just have the

42137
27:58:44,160 --> 27:58:47,192
draw version but we can set up an

42138
27:58:47,192 --> 27:58:49,512
overload of this draw method here this

42139
27:58:49,512 --> 27:58:51,600
is what we want to do so i am going to

42140
27:58:51,600 --> 27:58:54,000
go below here and set up an overload of

42141
27:58:54,000 --> 27:58:55,912
this method this is going to be taking

42142
27:58:55,912 --> 27:58:59,120
the color depth as a parameter and we

42143
27:58:59,120 --> 27:59:01,440
want to see how usable this is

42144
27:59:01,440 --> 27:59:04,320
downstream so we're going to go down in

42145
27:59:04,320 --> 27:59:06,872
the main cpp function

42146
27:59:06,872 --> 27:59:09,440
and take out what we don't need here we

42147
27:59:09,440 --> 27:59:12,000
really need a bunch of objects we can

42148
27:59:12,000 --> 27:59:15,120
set up circle one and over one and we

42149
27:59:15,120 --> 27:59:17,120
will see that we can call this method

42150
27:59:17,120 --> 27:59:19,192
we're going to say circle one draw

42151
27:59:19,192 --> 27:59:20,720
without a parameter and we're going to

42152
27:59:20,720 --> 27:59:24,552
say circle one draw and pass and 44 as

42153
27:59:24,552 --> 27:59:26,872
our parameter and let's go back and make

42154
27:59:26,872 --> 27:59:30,000
sure that we have our overload and this

42155
27:59:30,000 --> 27:59:32,720
is going to be taking the color depth

42156
27:59:32,720 --> 27:59:34,872
and let's try and build our program

42157
27:59:34,872 --> 27:59:37,192
because we have a squiggly line here

42158
27:59:37,192 --> 27:59:39,440
let's see if it is just a visual studio

42159
27:59:39,440 --> 27:59:41,360
code playing games with us we're going

42160
27:59:41,360 --> 27:59:43,600
to pass this through gcc and we will

42161
27:59:43,600 --> 27:59:45,912
have a compiler error here so what is

42162
27:59:45,912 --> 27:59:49,040
going on candidate virtual draw cost

42163
27:59:49,040 --> 27:59:51,912
let's go up and see what kind of problem

42164
27:59:51,912 --> 27:59:54,552
we have here ah this is the concept we

42165
27:59:54,552 --> 27:59:57,120
just talked about in the slides we are

42166
27:59:57,120 --> 28:00:00,480
setting up our overloads here but this

42167
28:00:00,480 --> 28:00:03,280
is being eclipsed by the overloads that

42168
28:00:03,280 --> 28:00:05,360
we are setting up in oval you see we

42169
28:00:05,360 --> 28:00:07,760
have a draw override and this is also

42170
28:00:07,760 --> 28:00:10,800
being eclipsed by the override we have

42171
28:00:10,800 --> 28:00:14,320
in our circle class here if we want the

42172
28:00:14,320 --> 28:00:16,552
two overloads we have from shape to be

42173
28:00:16,552 --> 28:00:18,400
available we can comment out the

42174
28:00:18,400 --> 28:00:20,720
overrides we have both in circle and

42175
28:00:20,720 --> 28:00:23,040
oval let's do that and that's going to

42176
28:00:23,040 --> 28:00:25,600
be available and usable so let's do that

42177
28:00:25,600 --> 28:00:26,960
this is a really good learning

42178
28:00:26,960 --> 28:00:30,480
opportunity and now if we go in main cpp

42179
28:00:30,480 --> 28:00:31,912
we're going to see that this is going to

42180
28:00:31,912 --> 28:00:34,480
become available so we can upload this

42181
28:00:34,480 --> 28:00:37,760
with gcc again to bring visual studio

42182
28:00:37,760 --> 28:00:40,232
code up to date and you see the build is

42183
28:00:40,232 --> 28:00:43,040
good and our methods are usable even

42184
28:00:43,040 --> 28:00:46,080
from derived classes so for example we

42185
28:00:46,080 --> 28:00:49,280
can also set up a novel object let's say

42186
28:00:49,280 --> 28:00:51,912
oval one and say draw this is going to

42187
28:00:51,912 --> 28:00:54,800
work if we say ovo one draw and pass in

42188
28:00:54,800 --> 28:00:57,832
a parameter let's put in 54 for example

42189
28:00:57,832 --> 28:00:59,832
this is going to do you're going to see

42190
28:00:59,832 --> 28:01:01,680
that this is going to be accepted by

42191
28:01:01,680 --> 28:01:05,040
visual studio code and if we weld and

42192
28:01:05,040 --> 28:01:07,512
run this program it is going to build it

42193
28:01:07,512 --> 28:01:09,912
is going to be calling the inherited

42194
28:01:09,912 --> 28:01:12,552
functions in oval and

42195
28:01:12,552 --> 28:01:15,440
circle here the boat is good we can kill

42196
28:01:15,440 --> 28:01:17,680
our terminal here and bring up a

42197
28:01:17,680 --> 28:01:19,680
powershell window we can use to run our

42198
28:01:19,680 --> 28:01:21,912
program we're going to see that we call

42199
28:01:21,912 --> 28:01:24,800
shape draw and shape draw because these

42200
28:01:24,800 --> 28:01:27,512
are inherited functions from

42201
28:01:27,512 --> 28:01:29,680
the shape class that's why we are saying

42202
28:01:29,680 --> 28:01:31,600
shape draw here and we're going to be

42203
28:01:31,600 --> 28:01:34,320
drawing a oval and a drawing with a

42204
28:01:34,320 --> 28:01:36,160
color depth we're going to be drawing

42205
28:01:36,160 --> 28:01:38,160
the circle and drawing with the color

42206
28:01:38,160 --> 28:01:40,160
depth here this is the message i want to

42207
28:01:40,160 --> 28:01:42,872
convey but the moment we override these

42208
28:01:42,872 --> 28:01:45,680
methods in any downstream class for

42209
28:01:45,680 --> 28:01:48,800
example if we go in our over class and

42210
28:01:48,800 --> 28:01:51,040
and comment out the override for the

42211
28:01:51,040 --> 28:01:53,760
draw method notice that we are just

42212
28:01:53,760 --> 28:01:56,960
overriding a single overload again if we

42213
28:01:56,960 --> 28:01:59,120
go back to our shape class we have an

42214
28:01:59,120 --> 28:02:01,440
overload that doesn't take any parameter

42215
28:02:01,440 --> 28:02:03,360
we also have an overload which is going

42216
28:02:03,360 --> 28:02:05,832
to take one parameter in oval we are

42217
28:02:05,832 --> 28:02:09,512
just going to override the overload that

42218
28:02:09,512 --> 28:02:11,512
doesn't take any parameter but this is

42219
28:02:11,512 --> 28:02:13,912
going to hide all the other overloads we

42220
28:02:13,912 --> 28:02:17,040
had for the draw method here and this is

42221
28:02:17,040 --> 28:02:19,192
the only overload that is going to be

42222
28:02:19,192 --> 28:02:20,400
available

42223
28:02:20,400 --> 28:02:23,192
in downstream classes so if we go back

42224
28:02:23,192 --> 28:02:24,720
in main we're going to see that the one

42225
28:02:24,720 --> 28:02:26,552
with a parameter is not going to work

42226
28:02:26,552 --> 28:02:27,760
and we're going to get a bunch of

42227
28:02:27,760 --> 28:02:30,232
compiler errors this is going to be the

42228
28:02:30,232 --> 28:02:32,872
case even in circle if we

42229
28:02:32,872 --> 28:02:35,280
uncomment this guy the others are going

42230
28:02:35,280 --> 28:02:37,832
to be eclipsed again the other one we

42231
28:02:37,832 --> 28:02:40,160
have is just the one with one parameter

42232
28:02:40,160 --> 28:02:42,320
but this is going to stay true even if

42233
28:02:42,320 --> 28:02:44,872
you have a hundred overloads all the

42234
28:02:44,872 --> 28:02:46,800
others are not going to be available if

42235
28:02:46,800 --> 28:02:49,600
you happen to only override one of the

42236
28:02:49,600 --> 28:02:51,832
overloads in other words

42237
28:02:51,832 --> 28:02:53,760
the other overloads are going to be

42238
28:02:53,760 --> 28:02:57,192
hidden by this one overall ride that you

42239
28:02:57,192 --> 28:02:59,280
are putting in your inheritance

42240
28:02:59,280 --> 28:03:01,680
hierarchy you should really know this if

42241
28:03:01,680 --> 28:03:03,912
you want this guide to be available in

42242
28:03:03,912 --> 28:03:06,400
downstream classes for example you can

42243
28:03:06,400 --> 28:03:09,280
also override that in derived classes

42244
28:03:09,280 --> 28:03:12,160
this is an option we can go in oval and

42245
28:03:12,160 --> 28:03:14,800
put in another overload for this this is

42246
28:03:14,800 --> 28:03:17,600
going to bring this back in scope so we

42247
28:03:17,600 --> 28:03:21,192
can say overdraw here with the color

42248
28:03:21,192 --> 28:03:23,360
depth i don't think we copied the right

42249
28:03:23,360 --> 28:03:25,912
thing we can grab this and go in oval

42250
28:03:25,912 --> 28:03:28,232
and put this in place this is going to

42251
28:03:28,232 --> 28:03:31,440
do we're going to say oval drawing and

42252
28:03:31,440 --> 28:03:33,832
we can go in circle and also put this

42253
28:03:33,832 --> 28:03:36,320
end this is an option and we're going to

42254
28:03:36,320 --> 28:03:39,760
say circle drawing and now you see that

42255
28:03:39,760 --> 28:03:41,912
the squiggly lines in main go away

42256
28:03:41,912 --> 28:03:44,552
because we have overridden all the

42257
28:03:44,552 --> 28:03:47,120
overloads okay if we build and run our

42258
28:03:47,120 --> 28:03:48,640
program we're going to see that this is

42259
28:03:48,640 --> 28:03:50,872
going to work as we expect the world is

42260
28:03:50,872 --> 28:03:53,440
going to be good and we can clear

42261
28:03:53,440 --> 28:03:55,120
and run rooster we're going to see that

42262
28:03:55,120 --> 28:03:58,080
overdraw called overdraw called we are

42263
28:03:58,080 --> 28:04:00,800
calling our derived overrides and this

42264
28:04:00,800 --> 28:04:03,120
is really cool this is what we want here

42265
28:04:03,120 --> 28:04:05,192
let's take this back because we don't

42266
28:04:05,192 --> 28:04:06,480
want these

42267
28:04:06,480 --> 28:04:09,440
overridden in our inherited classes so

42268
28:04:09,440 --> 28:04:12,232
we're going to take this out in oval

42269
28:04:12,232 --> 28:04:14,160
and we're going to take this out in

42270
28:04:14,160 --> 28:04:17,440
circle and i want you to see that shaped

42271
28:04:17,440 --> 28:04:20,232
polymorphism is not going to work if you

42272
28:04:20,232 --> 28:04:23,760
override your methods at a downstream

42273
28:04:23,760 --> 28:04:25,760
level so what we are going to do we are

42274
28:04:25,760 --> 28:04:28,232
going to go at the oval level and set up

42275
28:04:28,232 --> 28:04:31,760
another overload for the joe method here

42276
28:04:31,760 --> 28:04:33,912
but this draw method is not going to

42277
28:04:33,912 --> 28:04:36,400
participate in shape polymorphism

42278
28:04:36,400 --> 28:04:38,640
because it is really declared at the

42279
28:04:38,640 --> 28:04:41,832
oval level and any base pointer we have

42280
28:04:41,832 --> 28:04:44,232
or any shape pointer we have is not

42281
28:04:44,232 --> 28:04:46,080
going to have any knowledge of this

42282
28:04:46,080 --> 28:04:48,160
overload that we are about to set up

42283
28:04:48,160 --> 28:04:50,232
here this is what i want you to know

42284
28:04:50,232 --> 28:04:52,552
okay so we are going to go in our oval

42285
28:04:52,552 --> 28:04:54,872
class and set up that overload we can

42286
28:04:54,872 --> 28:04:58,160
set that up here it is going to be taken

42287
28:04:58,160 --> 28:05:00,480
two parameters one is going to be the

42288
28:05:00,480 --> 28:05:02,320
color depth the other is going to be the

42289
28:05:02,320 --> 28:05:05,192
color and we don't want to pass a string

42290
28:05:05,192 --> 28:05:07,360
by a value like this we can use std

42291
28:05:07,360 --> 28:05:10,480
string view and we can include that if

42292
28:05:10,480 --> 28:05:12,800
we need to but it looks like visual

42293
28:05:12,800 --> 28:05:15,280
studio code has got this from something

42294
28:05:15,280 --> 28:05:17,680
else we have included before but we can

42295
28:05:17,680 --> 28:05:19,760
include that explicitly to avoid

42296
28:05:19,760 --> 28:05:21,680
problems so let's do that we're going to

42297
28:05:21,680 --> 28:05:24,480
say stream view here and now we want to

42298
28:05:24,480 --> 28:05:26,232
see that this method is not going to

42299
28:05:26,232 --> 28:05:29,360
participate in shape polymorphism even

42300
28:05:29,360 --> 28:05:31,760
if it is a virtual functions the reason

42301
28:05:31,760 --> 28:05:34,000
is this is not going to be known by your

42302
28:05:34,000 --> 28:05:36,000
shape pointers because it is not

42303
28:05:36,000 --> 28:05:38,320
declared at the sherpa level here i

42304
28:05:38,320 --> 28:05:40,080
really want you to know this we're going

42305
28:05:40,080 --> 28:05:42,552
to take out everything we had here and

42306
28:05:42,552 --> 28:05:44,080
we can set up a shape pointer we're

42307
28:05:44,080 --> 28:05:47,040
going to say shape and say ship ptr and

42308
28:05:47,040 --> 28:05:49,360
we're going to set up a derived object

42309
28:05:49,360 --> 28:05:52,080
here we can say new and serious circle

42310
28:05:52,080 --> 28:05:54,232
and what do we need to build the circle

42311
28:05:54,232 --> 28:05:56,720
object we need the radius and the

42312
28:05:56,720 --> 28:05:58,800
description so we're going to put that

42313
28:05:58,800 --> 28:06:01,040
in place here the radius is going to be

42314
28:06:01,040 --> 28:06:03,360
something like 10 why not and the

42315
28:06:03,360 --> 28:06:05,120
description is going to be circle one

42316
28:06:05,120 --> 28:06:08,080
how creative and we want to see if our

42317
28:06:08,080 --> 28:06:10,552
method is available through polymorphism

42318
28:06:10,552 --> 28:06:12,480
and it is not going to be available

42319
28:06:12,480 --> 28:06:15,360
because the method was not declared at

42320
28:06:15,360 --> 28:06:18,320
the shape level so if we do shape ptr

42321
28:06:18,320 --> 28:06:20,872
and say draw and we have a method which

42322
28:06:20,872 --> 28:06:23,600
is going to take two parameters at the

42323
28:06:23,600 --> 28:06:26,000
oval level we have the color depth and

42324
28:06:26,000 --> 28:06:27,280
the color

42325
28:06:27,280 --> 28:06:30,160
so for example if we go in main and say

42326
28:06:30,160 --> 28:06:34,000
the color depth is 45.21

42327
28:06:34,000 --> 28:06:35,832
not let's say this is something that

42328
28:06:35,832 --> 28:06:37,832
makes sense or let's use

42329
28:06:37,832 --> 28:06:40,552
45 because this is an integer parameter

42330
28:06:40,552 --> 28:06:42,160
and we're going to pass in a string

42331
28:06:42,160 --> 28:06:44,480
let's say red you're going to see that

42332
28:06:44,480 --> 28:06:46,552
this is not going to compile

42333
28:06:46,552 --> 28:06:48,552
because the draw method with two

42334
28:06:48,552 --> 28:06:51,192
parameters is not known at the shape

42335
28:06:51,192 --> 28:06:53,360
level this is the message i want to

42336
28:06:53,360 --> 28:06:56,232
convey here so if you want your method

42337
28:06:56,232 --> 28:06:58,960
to be usable with polymorphism the

42338
28:06:58,960 --> 28:07:02,080
method has to show up at the top level

42339
28:07:02,080 --> 28:07:04,232
this is what i want you to see here if

42340
28:07:04,232 --> 28:07:05,600
we're trying to build this we're going

42341
28:07:05,600 --> 28:07:07,912
to get a compiler error and you need to

42342
28:07:07,912 --> 28:07:11,040
be aware of this but know that even if

42343
28:07:11,040 --> 28:07:12,720
this is not working with shape

42344
28:07:12,720 --> 28:07:15,640
polymorphism this can work with oval

42345
28:07:15,640 --> 28:07:18,320
polymorphism and this is an idea i am

42346
28:07:18,320 --> 28:07:20,800
going to explore in the next lecture

42347
28:07:20,800 --> 28:07:23,512
where we learn about the fact that polar

42348
28:07:23,512 --> 28:07:26,160
morphism can be set up at different

42349
28:07:26,160 --> 28:07:28,232
levels so we are going to stop here in

42350
28:07:28,232 --> 28:07:30,960
this lecture and explore that idea in

42351
28:07:30,960 --> 28:07:33,360
detail in the next lecture so go ahead

42352
28:07:33,360 --> 28:07:35,760
and finish up here and meet me there in

42353
28:07:35,760 --> 28:07:37,760
this lecture we're going to explore the

42354
28:07:37,760 --> 28:07:40,120
idea that we can do

42355
28:07:40,120 --> 28:07:43,360
polymorphism at different levels in our

42356
28:07:43,360 --> 28:07:45,280
inheritance hierarchy

42357
28:07:45,280 --> 28:07:48,080
suppose we have a hierarchy like we see

42358
28:07:48,080 --> 28:07:50,872
here the top level class is animal and

42359
28:07:50,872 --> 28:07:53,600
we can derive from animal and create a

42360
28:07:53,600 --> 28:07:56,720
feline animal we can derive from feline

42361
28:07:56,720 --> 28:07:59,680
and create a dog animal we can derive

42362
28:07:59,680 --> 28:08:02,480
from feline create a cat animal we can

42363
28:08:02,480 --> 28:08:04,640
also do it the other way and create a

42364
28:08:04,640 --> 28:08:07,360
bird which is also an animal a bird is

42365
28:08:07,360 --> 28:08:09,760
going to have its own methods and member

42366
28:08:09,760 --> 28:08:12,480
variables that make it a bird we can

42367
28:08:12,480 --> 28:08:15,040
derive from a bird create a pigeon and

42368
28:08:15,040 --> 28:08:17,440
we can derive from a bird and create a

42369
28:08:17,440 --> 28:08:18,480
crowd

42370
28:08:18,480 --> 28:08:20,232
and we can do all these things that

42371
28:08:20,232 --> 28:08:22,080
these animals do

42372
28:08:22,080 --> 28:08:24,320
so the idea i want to expose here is

42373
28:08:24,320 --> 28:08:26,400
that polymorphism

42374
28:08:26,400 --> 28:08:29,280
doesn't have to always only work on the

42375
28:08:29,280 --> 28:08:31,832
top level class if you have an

42376
28:08:31,832 --> 28:08:34,160
inheritance hierarchy like this if you

42377
28:08:34,160 --> 28:08:37,360
want you can declare a virtual method at

42378
28:08:37,360 --> 28:08:39,912
the feline level and make sure that

42379
28:08:39,912 --> 28:08:42,080
method is also available in deriving

42380
28:08:42,080 --> 28:08:44,320
class and you can set up feline

42381
28:08:44,320 --> 28:08:46,800
polymorphism if that makes sense for

42382
28:08:46,800 --> 28:08:49,360
your application following the same idea

42383
28:08:49,360 --> 28:08:51,760
you can also set up a virtual method in

42384
28:08:51,760 --> 28:08:54,160
the bird class and you can have that

42385
28:08:54,160 --> 28:08:56,552
method overridden in downstream

42386
28:08:56,552 --> 28:08:59,512
inheritance classes like pigeon and crow

42387
28:08:59,512 --> 28:09:02,320
and you can set up bird polymorphism in

42388
28:09:02,320 --> 28:09:04,960
your c plus plus program if that makes

42389
28:09:04,960 --> 28:09:07,040
sense of course you can still use animal

42390
28:09:07,040 --> 28:09:09,832
polymorphism if you want to do that and

42391
28:09:09,832 --> 28:09:12,080
that's going to work as well this is the

42392
28:09:12,080 --> 28:09:14,400
idea we're going to explore here okay so

42393
28:09:14,400 --> 28:09:17,040
with that inheritance hierarchy in mind

42394
28:09:17,040 --> 28:09:20,160
we can create animal polymorphism and

42395
28:09:20,160 --> 28:09:22,552
animal polymorphism is just going

42396
28:09:22,552 --> 28:09:25,192
through the animal base pointer and

42397
28:09:25,192 --> 28:09:28,400
using that to manage derived objects for

42398
28:09:28,400 --> 28:09:30,400
example here we have a dog we have a cat

42399
28:09:30,400 --> 28:09:32,552
we have a pigeon we have a crow we can

42400
28:09:32,552 --> 28:09:35,280
do animal polymorphism and storing any

42401
28:09:35,280 --> 28:09:37,040
kind of animal we have here you see we

42402
28:09:37,040 --> 28:09:39,360
are putting in a dog we are putting in a

42403
28:09:39,360 --> 28:09:41,280
cat we are putting in a pigeon and we

42404
28:09:41,280 --> 28:09:42,960
are putting in a crow

42405
28:09:42,960 --> 28:09:45,680
and if we do animal polymorphism and

42406
28:09:45,680 --> 28:09:48,320
call the breathe method which exists in

42407
28:09:48,320 --> 28:09:49,760
any kind of animal we have in our

42408
28:09:49,760 --> 28:09:52,320
program this is going to call the most

42409
28:09:52,320 --> 28:09:55,040
specific breathe method on each animal

42410
28:09:55,040 --> 28:09:56,552
and this is going to work really well

42411
28:09:56,552 --> 28:09:59,192
this is going to do animal polymorphism

42412
28:09:59,192 --> 28:10:01,040
following the same idea we can also do

42413
28:10:01,040 --> 28:10:04,080
feline polymorphism and in this case

42414
28:10:04,080 --> 28:10:06,800
feline is going to be acting as our base

42415
28:10:06,800 --> 28:10:09,440
pointer so again we have our dog we have

42416
28:10:09,440 --> 28:10:11,832
our cat we have our pigeon if we do

42417
28:10:11,832 --> 28:10:14,480
feline polymorphism we will have to put

42418
28:10:14,480 --> 28:10:17,280
in all kinds of crazy felines we have in

42419
28:10:17,280 --> 28:10:19,440
our program for example we can put in

42420
28:10:19,440 --> 28:10:21,680
dog and cat and this is going to work if

42421
28:10:21,680 --> 28:10:23,832
you do fill out a polymorphism like we

42422
28:10:23,832 --> 28:10:26,960
are doing here and put in an animal this

42423
28:10:26,960 --> 28:10:29,440
is not going to work because the animal

42424
28:10:29,440 --> 28:10:32,872
top level class is probably not going to

42425
28:10:32,872 --> 28:10:34,552
override the

42426
28:10:34,552 --> 28:10:37,280
virtual method we are interested in here

42427
28:10:37,280 --> 28:10:39,040
for example here we are calling the run

42428
28:10:39,040 --> 28:10:41,360
method and the run method is not set up

42429
28:10:41,360 --> 28:10:43,912
at the animal level let's go back and

42430
28:10:43,912 --> 28:10:46,480
look at our inheritance hierarchy here

42431
28:10:46,480 --> 28:10:49,040
you see this is our animal class our

42432
28:10:49,040 --> 28:10:51,192
virtual method is going to be breathed

42433
28:10:51,192 --> 28:10:53,120
because any kind of animal we have is

42434
28:10:53,120 --> 28:10:55,832
going to need to breathe but the run

42435
28:10:55,832 --> 28:10:59,120
method is set up at the feline level so

42436
28:10:59,120 --> 28:11:02,800
if we try and store an an animal in a

42437
28:11:02,800 --> 28:11:06,080
setup that uses filing polymorphism the

42438
28:11:06,080 --> 28:11:08,000
run method is not going to be available

42439
28:11:08,000 --> 28:11:09,600
and we're going to get a compiler error

42440
28:11:09,600 --> 28:11:11,440
so i want you to know this but we will

42441
28:11:11,440 --> 28:11:13,512
also see this in a minute when we hit

42442
28:11:13,512 --> 28:11:15,512
visual studio code to really play with

42443
28:11:15,512 --> 28:11:18,400
us okay we can also do bird polymorphism

42444
28:11:18,400 --> 28:11:20,480
and here you see we have two objects one

42445
28:11:20,480 --> 28:11:23,040
is a pigeon the other is a crow

42446
28:11:23,040 --> 28:11:25,360
and we're going to do bird polymorphism

42447
28:11:25,360 --> 28:11:28,400
here and what that means is that we will

42448
28:11:28,400 --> 28:11:31,440
use a bird pointer to manage all kinds

42449
28:11:31,440 --> 28:11:33,440
of crazy birds in our c plus plus

42450
28:11:33,440 --> 28:11:35,832
program for example we can use that to

42451
28:11:35,832 --> 28:11:37,600
manage a pigeon we can use that to

42452
28:11:37,600 --> 28:11:40,232
manage a crow and if we loop through our

42453
28:11:40,232 --> 28:11:43,512
birds and call the fly method the most

42454
28:11:43,512 --> 28:11:45,680
specific fly method is going to be

42455
28:11:45,680 --> 28:11:47,832
called in this case at the first

42456
28:11:47,832 --> 28:11:49,512
iteration we're going to call the fly

42457
28:11:49,512 --> 28:11:52,160
method on our pigeon object at the

42458
28:11:52,160 --> 28:11:53,912
second iteration we're going to call the

42459
28:11:53,912 --> 28:11:57,360
fly method on our crawl object here and

42460
28:11:57,360 --> 28:11:59,512
this is going to work now that you know

42461
28:11:59,512 --> 28:12:01,040
this we're going to head over to visual

42462
28:12:01,040 --> 28:12:02,872
studio code and play with this a little

42463
28:12:02,872 --> 28:12:06,000
more here we are in our working folder

42464
28:12:06,000 --> 28:12:08,800
the current project is polymorphism at

42465
28:12:08,800 --> 28:12:11,360
different levels we're going to grab our

42466
28:12:11,360 --> 28:12:13,512
template files let's grab it all we're

42467
28:12:13,512 --> 28:12:16,000
going to copy this and put this in our

42468
28:12:16,000 --> 28:12:17,760
current project

42469
28:12:17,760 --> 28:12:19,512
and we're going to open this little guy

42470
28:12:19,512 --> 28:12:22,080
in visual studio code like we always do

42471
28:12:22,080 --> 28:12:24,552
and before we open this up i am going to

42472
28:12:24,552 --> 28:12:27,040
put in the classes i have lying around

42473
28:12:27,040 --> 28:12:29,680
on my drive and these are going to be

42474
28:12:29,680 --> 28:12:32,480
the classes making up our inheritance

42475
28:12:32,480 --> 28:12:36,160
hierarchy here to make things go faster

42476
28:12:36,160 --> 28:12:38,160
if you want you can grab these classes

42477
28:12:38,160 --> 28:12:40,720
from the attached resource section on

42478
28:12:40,720 --> 28:12:42,640
this lecture you're going to find all

42479
28:12:42,640 --> 28:12:44,480
these files you can download them and

42480
28:12:44,480 --> 28:12:46,720
put them in your project and use that as

42481
28:12:46,720 --> 28:12:48,552
a starting point because you don't

42482
28:12:48,552 --> 28:12:50,320
really want to be creating all these

42483
28:12:50,320 --> 28:12:52,720
classes this is going to just waste your

42484
28:12:52,720 --> 28:12:55,040
time the basic idea i wanted to expose

42485
28:12:55,040 --> 28:12:58,080
here is doing polymorphism at different

42486
28:12:58,080 --> 28:13:00,232
levels so we're going to open this up in

42487
28:13:00,232 --> 28:13:02,000
visual studio code by dragging and

42488
28:13:02,000 --> 28:13:04,160
dropping here this is going to give us

42489
28:13:04,160 --> 28:13:06,720
our good starting point you see we have

42490
28:13:06,720 --> 28:13:09,120
a bunch of classes in here but all these

42491
28:13:09,120 --> 28:13:11,440
classes are really trying to set up the

42492
28:13:11,440 --> 28:13:14,000
inheritance hierarchy we have here the

42493
28:13:14,000 --> 28:13:15,832
top class is going to be the animal

42494
28:13:15,832 --> 28:13:16,800
class

42495
28:13:16,800 --> 28:13:19,120
we can derive from animal and create a

42496
28:13:19,120 --> 28:13:20,720
filler in a class

42497
28:13:20,720 --> 28:13:23,040
and we can derive from animal and also

42498
28:13:23,040 --> 28:13:26,000
create a bird class we can derive from

42499
28:13:26,000 --> 28:13:28,080
feline and create a dark we can derive

42500
28:13:28,080 --> 28:13:30,080
from feline and create a cat

42501
28:13:30,080 --> 28:13:32,400
and we can also derive from bird create

42502
28:13:32,400 --> 28:13:34,960
a pigeon we can also derive from bird

42503
28:13:34,960 --> 28:13:38,160
and create a crowd class and at each

42504
28:13:38,160 --> 28:13:39,912
level we're going to have a virtual

42505
28:13:39,912 --> 28:13:41,680
method that we set up

42506
28:13:41,680 --> 28:13:45,192
that other deriving classes can call

42507
28:13:45,192 --> 28:13:47,440
through polymorphism for example if we

42508
28:13:47,440 --> 28:13:49,680
do animal polymorphism we will get the

42509
28:13:49,680 --> 28:13:52,552
correct breathe method called regardless

42510
28:13:52,552 --> 28:13:55,280
of the actual object we are managing

42511
28:13:55,280 --> 28:13:57,280
with our animal pointer

42512
28:13:57,280 --> 28:14:00,000
if we do feline polymorphism we can

42513
28:14:00,000 --> 28:14:02,400
manage our objects through feline

42514
28:14:02,400 --> 28:14:05,192
pointers but we will get the correct run

42515
28:14:05,192 --> 28:14:07,912
method called regardless of which kind

42516
28:14:07,912 --> 28:14:10,400
of object we are calling this method on

42517
28:14:10,400 --> 28:14:13,040
so if we call the run method on a base

42518
28:14:13,040 --> 28:14:15,760
pointer managing a dog object we will

42519
28:14:15,760 --> 28:14:18,000
get the run method called on the dog

42520
28:14:18,000 --> 28:14:20,232
object this is what we mean here okay so

42521
28:14:20,232 --> 28:14:22,320
we have our classes here let's take a

42522
28:14:22,320 --> 28:14:25,440
closer look at our animal class it is

42523
28:14:25,440 --> 28:14:27,760
our top level class and it is going to

42524
28:14:27,760 --> 28:14:30,080
have a virtual method which is called

42525
28:14:30,080 --> 28:14:32,640
breathe it is caused because it is not

42526
28:14:32,640 --> 28:14:35,600
modifying our class here notice that we

42527
28:14:35,600 --> 28:14:37,680
don't have a virtual destructor because

42528
28:14:37,680 --> 28:14:40,232
i wanted to keep this simple but in your

42529
28:14:40,232 --> 28:14:42,960
practical object you should make your

42530
28:14:42,960 --> 28:14:45,600
destructors virtual if you happen to

42531
28:14:45,600 --> 28:14:47,680
have a virtual function in your class

42532
28:14:47,680 --> 28:14:49,832
here so for example we can even do that

42533
28:14:49,832 --> 28:14:51,680
let's make this virtual this is not

42534
28:14:51,680 --> 28:14:53,760
going to cost us anything

42535
28:14:53,760 --> 28:14:54,552
and

42536
28:14:54,552 --> 28:14:56,720
this is going to be our top class we

42537
28:14:56,720 --> 28:14:59,040
cannot look at the implementation file

42538
28:14:59,040 --> 28:15:01,192
it is not going to do anything special

42539
28:15:01,192 --> 28:15:03,440
it is just going to forward whatever

42540
28:15:03,440 --> 28:15:05,680
parameter we pass and use that to

42541
28:15:05,680 --> 28:15:07,912
initialize our member variable i think

42542
28:15:07,912 --> 28:15:10,552
we can also go in and change our

42543
28:15:10,552 --> 28:15:13,280
parameter to a string view so we can do

42544
28:15:13,280 --> 28:15:16,552
that hdd string view let's go in the cpp

42545
28:15:16,552 --> 28:15:18,640
file and also change that pretty quick

42546
28:15:18,640 --> 28:15:21,192
we're going to say std string view here

42547
28:15:21,192 --> 28:15:23,440
and this is our animal class we're going

42548
28:15:23,440 --> 28:15:26,720
to go in our feline class because that's

42549
28:15:26,720 --> 28:15:28,720
the deriving class

42550
28:15:28,720 --> 28:15:30,640
feline is going to be inheriting from

42551
28:15:30,640 --> 28:15:34,000
animal publicly just as we see here

42552
28:15:34,000 --> 28:15:35,600
we're not going to really do anything

42553
28:15:35,600 --> 28:15:37,280
special we're going to set up a member

42554
28:15:37,280 --> 28:15:39,680
variable called fur style

42555
28:15:39,680 --> 28:15:41,680
and we're going to forward the data from

42556
28:15:41,680 --> 28:15:43,512
our constructor and use that to

42557
28:15:43,512 --> 28:15:46,232
initialize stuff in our class here our

42558
28:15:46,232 --> 28:15:48,640
parameters are also going to be passed

42559
28:15:48,640 --> 28:15:51,680
as std string view types so let's do

42560
28:15:51,680 --> 28:15:54,552
that here and this is in place we also

42561
28:15:54,552 --> 28:15:57,192
have a virtual method which is called

42562
28:15:57,192 --> 28:16:00,080
run and inside we are just printing

42563
28:16:00,080 --> 28:16:02,320
which kind of object we have

42564
28:16:02,320 --> 28:16:05,192
and uh giving a hint on the method that

42565
28:16:05,192 --> 28:16:06,960
is being called here this is what we

42566
28:16:06,960 --> 28:16:09,512
just do here and we don't intend to

42567
28:16:09,512 --> 28:16:12,720
create feline objects directly that's

42568
28:16:12,720 --> 28:16:15,760
why we're not setting up any overrides

42569
28:16:15,760 --> 28:16:18,160
of the top that's why we are not setting

42570
28:16:18,160 --> 28:16:20,552
up any direct specific

42571
28:16:20,552 --> 28:16:22,640
overrides for these methods but we will

42572
28:16:22,640 --> 28:16:24,552
do that in downstream classes for

42573
28:16:24,552 --> 28:16:26,552
example dog and cat because that's going

42574
28:16:26,552 --> 28:16:28,960
to make sense there let's go in the cpp

42575
28:16:28,960 --> 28:16:31,680
file for feline and also change things a

42576
28:16:31,680 --> 28:16:33,680
little bit we're going to use std string

42577
28:16:33,680 --> 28:16:35,912
view parameters let's do that for the

42578
28:16:35,912 --> 28:16:38,400
second parameter as well and this is our

42579
28:16:38,400 --> 28:16:41,192
filling class so we can go in and look

42580
28:16:41,192 --> 28:16:43,912
at our dog class let's see if we can

42581
28:16:43,912 --> 28:16:46,480
find it and i don't think we made our

42582
28:16:46,480 --> 28:16:48,720
destructor in feline a virtual so let's

42583
28:16:48,720 --> 28:16:51,512
do that and look at our delta class

42584
28:16:51,512 --> 28:16:53,360
pretty quick here we have our dog it's

42585
28:16:53,360 --> 28:16:56,320
going to have no member variable at all

42586
28:16:56,320 --> 28:16:59,680
and it will just forward this data to

42587
28:16:59,680 --> 28:17:02,872
upstream classes but we can override our

42588
28:17:02,872 --> 28:17:05,280
breathe method we get from the animal

42589
28:17:05,280 --> 28:17:08,320
class we can do that and we are going to

42590
28:17:08,320 --> 28:17:11,120
say we can grab this entire thing and

42591
28:17:11,120 --> 28:17:13,360
we're going to go in dark we can do that

42592
28:17:13,360 --> 28:17:14,872
if we want we're going to put this

42593
28:17:14,872 --> 28:17:16,960
method down below here and we're going

42594
28:17:16,960 --> 28:17:18,800
to say breathe we're going to say that

42595
28:17:18,800 --> 28:17:21,832
this is overriding what we have on top

42596
28:17:21,832 --> 28:17:23,912
and we're going to say dog breathe

42597
28:17:23,912 --> 28:17:26,400
called this is going to do and we also

42598
28:17:26,400 --> 28:17:29,440
need to change our parameters to hdd

42599
28:17:29,440 --> 28:17:32,320
strength view let's do that this is

42600
28:17:32,320 --> 28:17:34,400
going to make things work better because

42601
28:17:34,400 --> 28:17:37,440
we will avoid unnecessary copies and we

42602
28:17:37,440 --> 28:17:40,000
will be able to pass string literals as

42603
28:17:40,000 --> 28:17:42,400
parameters to this constructor here this

42604
28:17:42,400 --> 28:17:44,800
is what we want to achieve with us we

42605
28:17:44,800 --> 28:17:47,832
can hit the cpp file for a dog class and

42606
28:17:47,832 --> 28:17:48,960
we're going to

42607
28:17:48,960 --> 28:17:51,680
change the parameters again std string

42608
28:17:51,680 --> 28:17:54,080
view and we're going to say std string

42609
28:17:54,080 --> 28:17:55,912
view as well here and we're going to go

42610
28:17:55,912 --> 28:17:58,000
to the header file again and make sure

42611
28:17:58,000 --> 28:18:00,160
we have a virtual destructor here

42612
28:18:00,160 --> 28:18:02,480
because this is good practice if you are

42613
28:18:02,480 --> 28:18:04,640
using virtual functions like we are

42614
28:18:04,640 --> 28:18:06,800
doing here we can grab our breathe

42615
28:18:06,800 --> 28:18:09,832
method and hop over to our cat class

42616
28:18:09,832 --> 28:18:12,400
again remember the inheritance hierarchy

42617
28:18:12,400 --> 28:18:15,192
we are going after is what we have here

42618
28:18:15,192 --> 28:18:17,512
so if you are confused please come back

42619
28:18:17,512 --> 28:18:18,960
and look at this you're going to really

42620
28:18:18,960 --> 28:18:20,960
understand what we are doing here we're

42621
28:18:20,960 --> 28:18:22,720
going to go to the dog class and make

42622
28:18:22,720 --> 28:18:25,192
sure it is working as we want so we just

42623
28:18:25,192 --> 28:18:28,160
did the dog class and we just made sure

42624
28:18:28,160 --> 28:18:30,320
it works like we want now we're going to

42625
28:18:30,320 --> 28:18:32,872
hop over to cat and make sure it is now

42626
28:18:32,872 --> 28:18:34,720
we're going to hop over to the cat class

42627
28:18:34,720 --> 28:18:37,760
and make sure it is overriding the brief

42628
28:18:37,760 --> 28:18:40,400
method to make sure the correct method

42629
28:18:40,400 --> 28:18:42,232
is called okay so let's do that we're

42630
28:18:42,232 --> 28:18:44,960
going to hop over to our cat class it is

42631
28:18:44,960 --> 28:18:46,080
going to

42632
28:18:46,080 --> 28:18:49,360
have its own meow method but it can also

42633
28:18:49,360 --> 28:18:52,080
override the breathe method we get from

42634
28:18:52,080 --> 28:18:54,480
the animal class so let's do that we can

42635
28:18:54,480 --> 28:18:55,600
grab this

42636
28:18:55,600 --> 28:18:58,480
and we can go to our cat class let's do

42637
28:18:58,480 --> 28:19:00,080
that we're going to put in our virtual

42638
28:19:00,080 --> 28:19:02,320
method and we're going to say cat

42639
28:19:02,320 --> 28:19:05,360
breathe and this is really all we also

42640
28:19:05,360 --> 28:19:08,232
need to set up our parameters correctly

42641
28:19:08,232 --> 28:19:11,360
using std string view let's do this std

42642
28:19:11,360 --> 28:19:14,320
string view and this is really all we

42643
28:19:14,320 --> 28:19:16,720
need to do here we can also make our

42644
28:19:16,720 --> 28:19:18,800
destructor virtual because this is good

42645
28:19:18,800 --> 28:19:21,600
practice we hop over in the cpp file and

42646
28:19:21,600 --> 28:19:24,480
change our parameters to be of type std

42647
28:19:24,480 --> 28:19:27,120
string view let's do this and this is

42648
28:19:27,120 --> 28:19:28,872
done we can really work with this

42649
28:19:28,872 --> 28:19:31,040
inheritance hierarchy here we're going

42650
28:19:31,040 --> 28:19:34,160
to also go pretty fast and work on the

42651
28:19:34,160 --> 28:19:36,960
other side of our inheritance hierarchy

42652
28:19:36,960 --> 28:19:39,440
we're going to work on birds let's look

42653
28:19:39,440 --> 28:19:41,760
at the bird class it is going to inherit

42654
28:19:41,760 --> 28:19:44,000
from animal it is not going to do

42655
28:19:44,000 --> 28:19:45,912
anything special really but we just want

42656
28:19:45,912 --> 28:19:48,160
to change the type of our parameters to

42657
28:19:48,160 --> 28:19:50,720
std string view and i'm going to do that

42658
28:19:50,720 --> 28:19:53,280
on the second parameter and we are going

42659
28:19:53,280 --> 28:19:55,512
to hop over in the cpp file and change

42660
28:19:55,512 --> 28:19:57,440
these things here let's do that we're

42661
28:19:57,440 --> 28:20:00,000
going to say std string view and do the

42662
28:20:00,000 --> 28:20:04,080
same thing here std string view and bird

42663
28:20:04,080 --> 28:20:06,960
is done we can grab our breathe method

42664
28:20:06,960 --> 28:20:09,280
for example let's go back to the top and

42665
28:20:09,280 --> 28:20:12,000
grab that from our animal class and

42666
28:20:12,000 --> 28:20:14,400
we're going to hop over to one kind of

42667
28:20:14,400 --> 28:20:16,720
bird we have in our program we can look

42668
28:20:16,720 --> 28:20:17,760
at

42669
28:20:17,760 --> 28:20:19,912
pigeon for example the last class here

42670
28:20:19,912 --> 28:20:21,440
we're going to override the breathe

42671
28:20:21,440 --> 28:20:24,080
method and i'm going to say pigeon

42672
28:20:24,080 --> 28:20:26,232
breathe and we are going to change the

42673
28:20:26,232 --> 28:20:28,720
type of our parameters here to std

42674
28:20:28,720 --> 28:20:30,960
string view and i'm going to do the same

42675
28:20:30,960 --> 28:20:34,080
here and let's hop over to the cpp file

42676
28:20:34,080 --> 28:20:36,960
and change the type of our parameter

42677
28:20:36,960 --> 28:20:38,872
let's do that for the second parameter

42678
28:20:38,872 --> 28:20:41,680
here this is done let's look at the

42679
28:20:41,680 --> 28:20:44,872
second kind of bird we have i think we

42680
28:20:44,872 --> 28:20:48,480
have the crow class we also want to

42681
28:20:48,480 --> 28:20:50,480
override the breathe method we're going

42682
28:20:50,480 --> 28:20:54,640
to say crow breathe and we can go up and

42683
28:20:54,640 --> 28:20:57,760
change our parameter to be of type std

42684
28:20:57,760 --> 28:20:59,760
string view and we're going to do that

42685
28:20:59,760 --> 28:21:02,160
here again if you are not interested in

42686
28:21:02,160 --> 28:21:04,640
these changes you can just grab the code

42687
28:21:04,640 --> 28:21:06,000
and you're going to have all these

42688
28:21:06,000 --> 28:21:08,400
classes ready for use i just wanted to

42689
28:21:08,400 --> 28:21:10,720
correct this little problem i had in my

42690
28:21:10,720 --> 28:21:13,120
classes on my drive because this is not

42691
28:21:13,120 --> 28:21:15,760
good to design in modern c plus plus we

42692
28:21:15,760 --> 28:21:17,760
wanted to do things proper because we

42693
28:21:17,760 --> 28:21:19,912
are really learning about modern c plus

42694
28:21:19,912 --> 28:21:22,640
plus here let's hop over to the cpp file

42695
28:21:22,640 --> 28:21:24,640
and finish this up we're going to change

42696
28:21:24,640 --> 28:21:28,080
the type to hdd stream view and uh let's

42697
28:21:28,080 --> 28:21:30,640
use view correctly and we're going to

42698
28:21:30,640 --> 28:21:32,960
say std string view on the second

42699
28:21:32,960 --> 28:21:35,440
parameter and this is done now we have

42700
28:21:35,440 --> 28:21:37,832
our inheritance hierarchy and we're

42701
28:21:37,832 --> 28:21:40,400
going to start by looking at animal

42702
28:21:40,400 --> 28:21:42,960
polymorphism again we just set up this

42703
28:21:42,960 --> 28:21:45,440
inheritance hierarchy now we are going

42704
28:21:45,440 --> 28:21:48,872
to try and do animal polymorphism okay

42705
28:21:48,872 --> 28:21:50,720
so now we're going to hop over to the

42706
28:21:50,720 --> 28:21:53,512
main cpp file and we are going to clean

42707
28:21:53,512 --> 28:21:55,680
it up a little bit remove whatever it is

42708
28:21:55,680 --> 28:21:58,720
we don't need we are going to put in our

42709
28:21:58,720 --> 28:22:00,720
includes we're going to include all of

42710
28:22:00,720 --> 28:22:04,080
the fans in our file here animal feline

42711
28:22:04,080 --> 28:22:06,480
dog cat bird pigeon and crow we're going

42712
28:22:06,480 --> 28:22:09,440
to include all this and we just want to

42713
28:22:09,440 --> 28:22:12,480
play with animal polymorphism here we

42714
28:22:12,480 --> 28:22:14,480
are going to set up a bunch of objects

42715
28:22:14,480 --> 28:22:17,040
and we're going to put in dog cat pigeon

42716
28:22:17,040 --> 28:22:19,832
and crow all kinds of crazy animals we

42717
28:22:19,832 --> 28:22:21,912
can create in our c plus plus program

42718
28:22:21,912 --> 28:22:24,480
and we're going to put them in an array

42719
28:22:24,480 --> 28:22:27,280
that is storing animal pointer and this

42720
28:22:27,280 --> 28:22:29,680
animal pointer is going to

42721
28:22:29,680 --> 28:22:32,800
enable polymorphism for our objects that

42722
28:22:32,800 --> 28:22:35,912
we have in here remember animal sets up

42723
28:22:35,912 --> 28:22:38,232
a virtual method called draw if we go

42724
28:22:38,232 --> 28:22:40,552
back we're going to find that and we

42725
28:22:40,552 --> 28:22:43,040
made sure to override this method in all

42726
28:22:43,040 --> 28:22:45,600
kinds of crazy animals we can create for

42727
28:22:45,600 --> 28:22:47,832
example in our cat we have a breathe

42728
28:22:47,832 --> 28:22:50,960
method overridden in our dog class we

42729
28:22:50,960 --> 28:22:53,192
have the breathe method overridden and

42730
28:22:53,192 --> 28:22:56,160
what we want to achieve in our main cpp

42731
28:22:56,160 --> 28:22:59,680
file let's go there if i can find it we

42732
28:22:59,680 --> 28:23:02,552
want to achieve a setup so that if we

42733
28:23:02,552 --> 28:23:04,000
call the breathe method we're going to

42734
28:23:04,000 --> 28:23:06,872
call the most specific breathe method on

42735
28:23:06,872 --> 28:23:09,280
our animal pointer here even if we are

42736
28:23:09,280 --> 28:23:11,600
calling that method on a base pointer

42737
28:23:11,600 --> 28:23:13,760
this is what we want to achieve this is

42738
28:23:13,760 --> 28:23:16,160
going to be animal polymorphism because

42739
28:23:16,160 --> 28:23:19,280
the base pointer is of animal type this

42740
28:23:19,280 --> 28:23:21,680
is what we mean here let's try and build

42741
28:23:21,680 --> 28:23:23,912
this program so if we look and call the

42742
28:23:23,912 --> 28:23:25,512
breathe method the correct breathe

42743
28:23:25,512 --> 28:23:27,680
method is going to be called and what we

42744
28:23:27,680 --> 28:23:29,832
expect for the first object which is a

42745
28:23:29,832 --> 28:23:31,912
dark object we're going to get the dark

42746
28:23:31,912 --> 28:23:34,160
breathe method called for the second

42747
28:23:34,160 --> 28:23:36,000
iteration the category breathe method is

42748
28:23:36,000 --> 28:23:38,640
going to be called for the third

42749
28:23:38,640 --> 28:23:41,440
for the third iteration the pigeon

42750
28:23:41,440 --> 28:23:43,360
breath method is going to be called for

42751
28:23:43,360 --> 28:23:45,512
the last iteration the

42752
28:23:45,512 --> 28:23:47,360
crow breathe method is going to be

42753
28:23:47,360 --> 28:23:49,680
called this is what we expect to see

42754
28:23:49,680 --> 28:23:52,000
if we run this program here so let's do

42755
28:23:52,000 --> 28:23:53,832
this we're going to pass this through

42756
28:23:53,832 --> 28:23:57,192
gcc our favorite compiler we can use any

42757
28:23:57,192 --> 28:23:59,912
compiler we want but gcc is going to do

42758
28:23:59,912 --> 28:24:02,080
in this case okay the build is good we

42759
28:24:02,080 --> 28:24:04,480
can bring up a powershell window to play

42760
28:24:04,480 --> 28:24:06,872
with and we're going to run rooster our

42761
28:24:06,872 --> 28:24:09,040
program and if we run this you're going

42762
28:24:09,040 --> 28:24:11,760
to see that in our loop the first

42763
28:24:11,760 --> 28:24:13,912
iteration is going to call dog breathe

42764
28:24:13,912 --> 28:24:16,080
because the first object is a dog the

42765
28:24:16,080 --> 28:24:18,080
second iteration is going to call cat

42766
28:24:18,080 --> 28:24:19,912
breathe because the second object is a

42767
28:24:19,912 --> 28:24:20,720
cat

42768
28:24:20,720 --> 28:24:22,400
the third iteration is going to call

42769
28:24:22,400 --> 28:24:24,640
pigeon breathe because the third object

42770
28:24:24,640 --> 28:24:26,800
is a pigeon and the last iteration is

42771
28:24:26,800 --> 28:24:29,120
going to call crow breathe because the

42772
28:24:29,120 --> 28:24:31,912
last object is a crow and notice that we

42773
28:24:31,912 --> 28:24:34,080
are calling the breathe method through a

42774
28:24:34,080 --> 28:24:36,680
base animal pointer and this is what

42775
28:24:36,680 --> 28:24:39,192
polymorphism is all about and what we

42776
28:24:39,192 --> 28:24:41,680
are doing here is animal polymorphism

42777
28:24:41,680 --> 28:24:44,232
but this is not what we are really after

42778
28:24:44,232 --> 28:24:46,552
in this lecture we want to see that we

42779
28:24:46,552 --> 28:24:48,080
can also do

42780
28:24:48,080 --> 28:24:50,400
feline and

42781
28:24:50,400 --> 28:24:52,960
bird polymorphism in our inheritance

42782
28:24:52,960 --> 28:24:55,040
hierarchy so we're going to put in a

42783
28:24:55,040 --> 28:24:58,320
separator let's do sddc out and put in a

42784
28:24:58,320 --> 28:25:00,872
bunch of dashes here or hyphens some

42785
28:25:00,872 --> 28:25:02,800
people call them like that doesn't

42786
28:25:02,800 --> 28:25:05,280
really matter and we're going to play

42787
28:25:05,280 --> 28:25:08,160
with feline polymorphism let's do this

42788
28:25:08,160 --> 28:25:10,480
we are going to go down and put in a

42789
28:25:10,480 --> 28:25:12,552
simple piece of coat that we're going to

42790
28:25:12,552 --> 28:25:15,120
be using to play with things here and

42791
28:25:15,120 --> 28:25:16,720
we're going to set up a bunch of objects

42792
28:25:16,720 --> 28:25:18,872
we have a dog we have a cat we have a

42793
28:25:18,872 --> 28:25:22,400
pigeon and we are going to use a feline

42794
28:25:22,400 --> 28:25:26,160
pointer to manage feline derived objects

42795
28:25:26,160 --> 28:25:27,760
for example we're going to use this

42796
28:25:27,760 --> 28:25:30,000
pointer to manage a dog and a cat but

42797
28:25:30,000 --> 28:25:31,760
one thing i want you to see is that if

42798
28:25:31,760 --> 28:25:34,000
you put in a pigeon for example this is

42799
28:25:34,000 --> 28:25:36,720
not going to work because a pigeon is

42800
28:25:36,720 --> 28:25:39,120
not a feline so the compiler is going to

42801
28:25:39,120 --> 28:25:41,120
give you a compiler error let's try and

42802
28:25:41,120 --> 28:25:43,192
do that we're going to try and put in

42803
28:25:43,192 --> 28:25:46,160
pigeon here pigeon 2 you can select this

42804
28:25:46,160 --> 28:25:47,832
and if we do that you're going to see

42805
28:25:47,832 --> 28:25:50,232
that we get a squeaky line this is the

42806
28:25:50,232 --> 28:25:51,912
sign that this is going to go wrong

42807
28:25:51,912 --> 28:25:53,120
because

42808
28:25:53,120 --> 28:25:55,680
we are storing in felines and the pigeon

42809
28:25:55,680 --> 28:25:58,960
is really not a feline even by our

42810
28:25:58,960 --> 28:26:01,280
inheritance hierarchy so the compiler is

42811
28:26:01,280 --> 28:26:02,872
going to give us a compiler error let's

42812
28:26:02,872 --> 28:26:04,960
try and weld to show you the compiler

42813
28:26:04,960 --> 28:26:07,440
error okay the world finished with

42814
28:26:07,440 --> 28:26:09,192
errors and if we go and we're going to

42815
28:26:09,192 --> 28:26:12,480
find that cannot convert pigeon to feed

42816
28:26:12,480 --> 28:26:14,800
line pointer so this is the error here

42817
28:26:14,800 --> 28:26:16,872
you can't do something like this even if

42818
28:26:16,872 --> 28:26:19,040
you create an animal object let's say

42819
28:26:19,040 --> 28:26:21,600
that we're going to go in and create

42820
28:26:21,600 --> 28:26:23,912
animal and we're going to say animal one

42821
28:26:23,912 --> 28:26:25,760
we can do that and we're going to pass

42822
28:26:25,760 --> 28:26:27,680
in the description i think we can do

42823
28:26:27,680 --> 28:26:30,000
that we can do something like this and

42824
28:26:30,000 --> 28:26:32,232
if we try and pass in the address of

42825
28:26:32,232 --> 28:26:34,552
animal one let's do that this is also

42826
28:26:34,552 --> 28:26:36,872
going to give us a compiler error

42827
28:26:36,872 --> 28:26:40,400
because animal is not a feline again if

42828
28:26:40,400 --> 28:26:42,720
you get confused come back and look at

42829
28:26:42,720 --> 28:26:45,280
our inheritance hierarchy here

42830
28:26:45,280 --> 28:26:47,512
what we are setting up in our code we

42831
28:26:47,512 --> 28:26:50,640
are using feline polymorphism but we

42832
28:26:50,640 --> 28:26:53,680
want to store an animal in a raid that

42833
28:26:53,680 --> 28:26:56,480
is storing felines and this is going to

42834
28:26:56,480 --> 28:26:59,040
be a problem because the compiler isn't

42835
28:26:59,040 --> 28:27:01,280
really going to be able to process this

42836
28:27:01,280 --> 28:27:03,440
our base pointer is a feline and we

42837
28:27:03,440 --> 28:27:06,000
should really be able to only store in

42838
28:27:06,000 --> 28:27:09,040
derived types from feline but we are

42839
28:27:09,040 --> 28:27:11,680
putting in a superclass or a parent

42840
28:27:11,680 --> 28:27:13,280
class of feline

42841
28:27:13,280 --> 28:27:16,680
which will not be able to have these

42842
28:27:16,680 --> 28:27:19,040
specializations that feline is doing so

42843
28:27:19,040 --> 28:27:20,800
the compiler is really saying this is

42844
28:27:20,800 --> 28:27:22,872
crazy i can't do this i am going to

42845
28:27:22,872 --> 28:27:24,800
throw a compiler error this is the

42846
28:27:24,800 --> 28:27:26,872
behavior we get here okay so this is

42847
28:27:26,872 --> 28:27:28,552
going to give us a compiler error and

42848
28:27:28,552 --> 28:27:30,320
let's run and see that we're going to

42849
28:27:30,320 --> 28:27:32,872
use gcc the book is going to finish with

42850
28:27:32,872 --> 28:27:34,960
an error and we are going to see that we

42851
28:27:34,960 --> 28:27:37,440
have an invalid conversion from animal

42852
28:27:37,440 --> 28:27:39,600
pointer to filament pointer this is what

42853
28:27:39,600 --> 28:27:41,600
we want to do here we want to convert an

42854
28:27:41,600 --> 28:27:45,440
animal pointer and store that in a slot

42855
28:27:45,440 --> 28:27:48,400
that is only supposed to store feline

42856
28:27:48,400 --> 28:27:50,640
pointers so this is not going to work

42857
28:27:50,640 --> 28:27:52,960
but if you do everything right and only

42858
28:27:52,960 --> 28:27:54,160
put in

42859
28:27:54,160 --> 28:27:56,320
derived types of feline you're going to

42860
28:27:56,320 --> 28:27:59,120
get the correct length to work and let's

42861
28:27:59,120 --> 28:28:02,080
look at our dog class let's open it

42862
28:28:02,080 --> 28:28:04,400
again we're going to look at dog and

42863
28:28:04,400 --> 28:28:07,512
we're going to have a run method but we

42864
28:28:07,512 --> 28:28:10,400
don't have that set up for our dog class

42865
28:28:10,400 --> 28:28:12,160
but we can do that pretty quick let's

42866
28:28:12,160 --> 28:28:14,080
look at cat and see if we have a run

42867
28:28:14,080 --> 28:28:16,872
method we don't but we can set that up

42868
28:28:16,872 --> 28:28:19,600
let's go to feline and copy our virtual

42869
28:28:19,600 --> 28:28:21,760
function we can do that

42870
28:28:21,760 --> 28:28:24,320
and we are going to go in dog

42871
28:28:24,320 --> 28:28:26,480
and set up another virtual method which

42872
28:28:26,480 --> 28:28:28,160
is going to be

42873
28:28:28,160 --> 28:28:30,800
run and this is going to be an override

42874
28:28:30,800 --> 28:28:33,280
of what we have in our inheritance

42875
28:28:33,280 --> 28:28:35,600
hierarchy so this is an override method

42876
28:28:35,600 --> 28:28:38,080
we are also going to do the same but

42877
28:28:38,080 --> 28:28:40,320
before we go let's say that this is the

42878
28:28:40,320 --> 28:28:42,800
dog class we are doing thanks from

42879
28:28:42,800 --> 28:28:44,960
we are going to grab this method again

42880
28:28:44,960 --> 28:28:46,960
and go in cat because that's another

42881
28:28:46,960 --> 28:28:49,440
feline we have in our program we can do

42882
28:28:49,440 --> 28:28:51,192
something like this and we're going to

42883
28:28:51,192 --> 28:28:53,040
say cat here

42884
28:28:53,040 --> 28:28:56,080
okay so now let's come back to maine

42885
28:28:56,080 --> 28:28:58,160
and we're going to weld again we're

42886
28:28:58,160 --> 28:29:00,640
going to pass this through gcc and we

42887
28:29:00,640 --> 28:29:03,280
still have a pigeon in here so this is

42888
28:29:03,280 --> 28:29:05,440
not good let's check this out

42889
28:29:05,440 --> 28:29:07,832
make sure that we only have a few lines

42890
28:29:07,832 --> 28:29:10,552
in this array here let's build again

42891
28:29:10,552 --> 28:29:12,480
okay you see the bolt is good

42892
28:29:12,480 --> 28:29:14,232
we can clear

42893
28:29:14,232 --> 28:29:16,080
and run rooster we're going to have our

42894
28:29:16,080 --> 28:29:18,160
separator here and you're going to see

42895
28:29:18,160 --> 28:29:20,872
that we are calling our dog method at

42896
28:29:20,872 --> 28:29:22,640
the first iteration because the first

42897
28:29:22,640 --> 28:29:26,000
object is a dog and we are calling a cat

42898
28:29:26,000 --> 28:29:28,640
running method because the second object

42899
28:29:28,640 --> 28:29:32,080
is a cat and this is filing polymorphism

42900
28:29:32,080 --> 28:29:34,320
in action hopefully this proves to you

42901
28:29:34,320 --> 28:29:37,280
that we can do polymorphism at different

42902
28:29:37,280 --> 28:29:39,600
levels depending on what we want to

42903
28:29:39,600 --> 28:29:42,480
achieve in our c plus plus program to

42904
28:29:42,480 --> 28:29:44,400
close off this lecture we are also going

42905
28:29:44,400 --> 28:29:47,120
to set up bird polymorphism let's do

42906
28:29:47,120 --> 28:29:49,120
that we're going to put in a separator

42907
28:29:49,120 --> 28:29:51,680
and we're going to say vertical demod

42908
28:29:51,680 --> 28:29:53,912
present and we are going to put in a

42909
28:29:53,912 --> 28:29:56,552
bunch of objects and set up a base

42910
28:29:56,552 --> 28:29:57,600
pointer

42911
28:29:57,600 --> 28:29:59,512
array which is going to be a bird

42912
28:29:59,512 --> 28:30:01,192
pointer array in this case and we're

42913
28:30:01,192 --> 28:30:03,832
going to be storing in derived objects

42914
28:30:03,832 --> 28:30:06,720
of the base pointer type so we are going

42915
28:30:06,720 --> 28:30:08,800
to be storing any derived objects of

42916
28:30:08,800 --> 28:30:11,360
bird and we have a pigeon and a crow and

42917
28:30:11,360 --> 28:30:13,680
this is the setup we want here now let's

42918
28:30:13,680 --> 28:30:17,040
go and look at the setup we have in our

42919
28:30:17,040 --> 28:30:19,280
pigeon for example we don't have a fly

42920
28:30:19,280 --> 28:30:21,280
method we just have a cool method

42921
28:30:21,280 --> 28:30:23,280
because the pigeon coos

42922
28:30:23,280 --> 28:30:26,000
if we go in our crow we're going to see

42923
28:30:26,000 --> 28:30:27,912
that we don't have

42924
28:30:27,912 --> 28:30:30,320
fly method we're just having the cow

42925
28:30:30,320 --> 28:30:32,720
method because the crowd calls

42926
28:30:32,720 --> 28:30:36,400
but if we call our fly method because we

42927
28:30:36,400 --> 28:30:38,800
don't have this method overridden in any

42928
28:30:38,800 --> 28:30:41,192
downstream classes of bird

42929
28:30:41,192 --> 28:30:42,800
we will get the

42930
28:30:42,800 --> 28:30:43,760
base

42931
28:30:43,760 --> 28:30:46,000
version of the fly method called so we

42932
28:30:46,000 --> 28:30:48,080
will get this method here

42933
28:30:48,080 --> 28:30:50,552
called i want you to see this let's hop

42934
28:30:50,552 --> 28:30:52,800
over to the main cpp file and make sure

42935
28:30:52,800 --> 28:30:54,872
we have the correct setup looks like

42936
28:30:54,872 --> 28:30:56,552
this is what we want we're going to

42937
28:30:56,552 --> 28:30:59,040
build this with gcc the book is going to

42938
28:30:59,040 --> 28:31:01,832
be good as we see here and we're going

42939
28:31:01,832 --> 28:31:04,640
to run now we're going to see bird fly

42940
28:31:04,640 --> 28:31:07,680
bird fly for pigeon one and crow one

42941
28:31:07,680 --> 28:31:11,440
but this is not using any derived method

42942
28:31:11,440 --> 28:31:14,320
that we have in our crow

42943
28:31:14,320 --> 28:31:16,400
and a pigeon class if you want you can

42944
28:31:16,400 --> 28:31:18,400
also override the

42945
28:31:18,400 --> 28:31:20,232
fly method and you're going to get that

42946
28:31:20,232 --> 28:31:22,872
called let's actually do that because

42947
28:31:22,872 --> 28:31:25,192
i'd like to show you things directly so

42948
28:31:25,192 --> 28:31:26,872
that you can really see with your own

42949
28:31:26,872 --> 28:31:29,360
eyes so we're going to go in bird and

42950
28:31:29,360 --> 28:31:31,512
grab the fly method and we're going to

42951
28:31:31,512 --> 28:31:34,552
override this in pigeon we can do that

42952
28:31:34,552 --> 28:31:37,760
and we're going to override here and we

42953
28:31:37,760 --> 28:31:40,720
are going to say pigeon here and we can

42954
28:31:40,720 --> 28:31:43,760
grab this and i put this method also in

42955
28:31:43,760 --> 28:31:46,960
the crowd class can do that and we're

42956
28:31:46,960 --> 28:31:49,760
going to say crow here now if we run

42957
28:31:49,760 --> 28:31:51,192
this program

42958
28:31:51,192 --> 28:31:53,680
using what we have in the main cpp file

42959
28:31:53,680 --> 28:31:55,192
for the first iteration we're going to

42960
28:31:55,192 --> 28:31:57,680
call the fly method on the pigeon object

42961
28:31:57,680 --> 28:31:59,512
because we have the fly method

42962
28:31:59,512 --> 28:32:02,080
overwritten at the pigeon level

42963
28:32:02,080 --> 28:32:03,832
as we see here this is right here

42964
28:32:03,832 --> 28:32:05,512
beneath our eyes and we're going to see

42965
28:32:05,512 --> 28:32:08,080
this in action if we run this program

42966
28:32:08,080 --> 28:32:10,000
here the same is going to happen for the

42967
28:32:10,000 --> 28:32:13,440
crow object here let's build with gcc to

42968
28:32:13,440 --> 28:32:15,120
really prove this the builder is going

42969
28:32:15,120 --> 28:32:17,192
to go through we can clear and run

42970
28:32:17,192 --> 28:32:18,872
rooster and we're going to see pigeon

42971
28:32:18,872 --> 28:32:21,760
fly crowd fly this is proving what we

42972
28:32:21,760 --> 28:32:23,832
set up in this lecture here this is

42973
28:32:23,832 --> 28:32:25,760
really all i had to share i hope you

42974
28:32:25,760 --> 28:32:27,760
found this interesting the main message

42975
28:32:27,760 --> 28:32:30,640
is that you can set up polymorphism at

42976
28:32:30,640 --> 28:32:32,872
different levels in your inheritance

42977
28:32:32,872 --> 28:32:35,192
hierarchy depending on what you want to

42978
28:32:35,192 --> 28:32:37,512
achieve in your c plus plus program we

42979
28:32:37,512 --> 28:32:39,680
saw that we could do the usual thing and

42980
28:32:39,680 --> 28:32:41,600
use the top level class

42981
28:32:41,600 --> 28:32:44,320
as the driver for our polymorphism and

42982
28:32:44,320 --> 28:32:47,040
we did animal polymorphism here but

42983
28:32:47,040 --> 28:32:49,440
nothing prevents you from doing feline

42984
28:32:49,440 --> 28:32:52,872
polymorphism or bird polymorphism as we

42985
28:32:52,872 --> 28:32:55,192
saw in this lecture we are going to stop

42986
28:32:55,192 --> 28:32:56,720
here in this one in the next one we're

42987
28:32:56,720 --> 28:32:59,280
going to see how we can do polymorphism

42988
28:32:59,280 --> 28:33:01,120
with static members

42989
28:33:01,120 --> 28:33:03,280
go ahead and finish up here and make me

42990
28:33:03,280 --> 28:33:05,120
there in this lecture we're going to

42991
28:33:05,120 --> 28:33:08,960
explore how inheritance and polymorphism

42992
28:33:08,960 --> 28:33:11,680
play out with static members that we

42993
28:33:11,680 --> 28:33:14,640
have in our classes and we're going to

42994
28:33:14,640 --> 28:33:17,120
be using this inheritance hierarchy here

42995
28:33:17,120 --> 28:33:18,640
our base class is going to be shape

42996
28:33:18,640 --> 28:33:21,040
we're going to inherit from that and

42997
28:33:21,040 --> 28:33:23,912
create an ellipse class let's look at

42998
28:33:23,912 --> 28:33:25,760
some code here so we're going to set up

42999
28:33:25,760 --> 28:33:28,720
our base class as shape as we said and

43000
28:33:28,720 --> 28:33:31,120
we're going to have one member variable

43001
28:33:31,120 --> 28:33:33,040
which is going to be our description

43002
28:33:33,040 --> 28:33:35,192
here we're going to have a constructor

43003
28:33:35,192 --> 28:33:36,800
and a destructor

43004
28:33:36,800 --> 28:33:37,912
and we're going to have a default

43005
28:33:37,912 --> 28:33:39,192
constructor which is really not

43006
28:33:39,192 --> 28:33:41,912
important here but notice that we have a

43007
28:33:41,912 --> 28:33:45,192
static member which is called m count

43008
28:33:45,192 --> 28:33:47,192
and if you remember a static member

43009
28:33:47,192 --> 28:33:48,320
variable

43010
28:33:48,320 --> 28:33:50,552
is a kind of variable which is

43011
28:33:50,552 --> 28:33:53,760
associated with the type itself it's not

43012
28:33:53,760 --> 28:33:56,080
associated with any object that you

43013
28:33:56,080 --> 28:33:58,640
create if you forgot this please go back

43014
28:33:58,640 --> 28:34:01,120
to our chapter on classes or user

43015
28:34:01,120 --> 28:34:03,192
defined types you're going to learn all

43016
28:34:03,192 --> 28:34:05,912
about static variables here we are just

43017
28:34:05,912 --> 28:34:08,160
exploring how they play out with

43018
28:34:08,160 --> 28:34:11,280
inheritance and polymorphism now we have

43019
28:34:11,280 --> 28:34:13,760
a shape class if we inherit from it and

43020
28:34:13,760 --> 28:34:16,160
create an ellipse class for example

43021
28:34:16,160 --> 28:34:18,640
we're going to have all the data that

43022
28:34:18,640 --> 28:34:21,440
was public in our base class to be

43023
28:34:21,440 --> 28:34:23,680
public in this class as well so by that

43024
28:34:23,680 --> 28:34:25,760
logic we are also going to get this

43025
28:34:25,760 --> 28:34:27,832
static variable inherited and we're

43026
28:34:27,832 --> 28:34:30,160
going to be able to access it from

43027
28:34:30,160 --> 28:34:32,872
ellipse objects let's try and use this

43028
28:34:32,872 --> 28:34:34,872
in code here to really drive the point

43029
28:34:34,872 --> 28:34:37,120
home here we are creating a batch of

43030
28:34:37,120 --> 28:34:39,912
shape objects here is our first shape we

43031
28:34:39,912 --> 28:34:42,080
print our static variable through this

43032
28:34:42,080 --> 28:34:44,080
syntax here because it is public we can

43033
28:34:44,080 --> 28:34:46,160
do this we're going to get a one because

43034
28:34:46,160 --> 28:34:48,872
we just have one shape here we create a

43035
28:34:48,872 --> 28:34:50,640
second shape and we print the count

43036
28:34:50,640 --> 28:34:52,552
we're going to get two because we just

43037
28:34:52,552 --> 28:34:55,192
have two shapes in here we create our

43038
28:34:55,192 --> 28:34:57,360
third shape and we try and print the

43039
28:34:57,360 --> 28:34:59,120
count we're going to get three and if

43040
28:34:59,120 --> 28:35:01,600
you wonder how we are incrementing this

43041
28:35:01,600 --> 28:35:04,000
static variable we may do this in our

43042
28:35:04,000 --> 28:35:05,600
constructor we're going to see how this

43043
28:35:05,600 --> 28:35:07,760
works exactly once we hit visual studio

43044
28:35:07,760 --> 28:35:09,760
code in a minute but note that every

43045
28:35:09,760 --> 28:35:11,360
time we create an object we're going to

43046
28:35:11,360 --> 28:35:13,680
be incrementing our static variable

43047
28:35:13,680 --> 28:35:16,232
that's why we see one two three as we

43048
28:35:16,232 --> 28:35:18,640
created these objects here this is the

43049
28:35:18,640 --> 28:35:21,192
logic now we have three shapes here we

43050
28:35:21,192 --> 28:35:23,832
go down and create a new object which is

43051
28:35:23,832 --> 28:35:26,400
of ellipse type if we print the shape

43052
28:35:26,400 --> 28:35:28,400
count we're going to get four because an

43053
28:35:28,400 --> 28:35:31,040
ellipse is a shape and ellipse is

43054
28:35:31,040 --> 28:35:33,600
inheriting the static variable from

43055
28:35:33,600 --> 28:35:35,912
shape so we're going to get a 4 printed

43056
28:35:35,912 --> 28:35:39,120
out here but if we also print ellipse

43057
28:35:39,120 --> 28:35:41,192
count we're going to get a 4

43058
28:35:41,192 --> 28:35:44,232
even if we really just have one ellipse

43059
28:35:44,232 --> 28:35:46,960
so the static variable from shape is

43060
28:35:46,960 --> 28:35:49,512
being inherited and used in our ellipse

43061
28:35:49,512 --> 28:35:52,080
class and this may not be

43062
28:35:52,080 --> 28:35:53,760
what we want so

43063
28:35:53,760 --> 28:35:55,680
the problem here is that the static

43064
28:35:55,680 --> 28:35:57,760
variable we are using in shape and

43065
28:35:57,760 --> 28:36:00,160
ellipse are the same because the one we

43066
28:36:00,160 --> 28:36:03,120
have in ellipse was inherited from shape

43067
28:36:03,120 --> 28:36:05,280
that's why we have these results here

43068
28:36:05,280 --> 28:36:08,160
but sometimes we just want to have

43069
28:36:08,160 --> 28:36:11,280
ellipse count to b1 here because in

43070
28:36:11,280 --> 28:36:13,600
reality we really have one ellipse so

43071
28:36:13,600 --> 28:36:16,160
how do we do that to get that behavior

43072
28:36:16,160 --> 28:36:18,160
you can also set up another static

43073
28:36:18,160 --> 28:36:20,960
variable named exactly the same way at

43074
28:36:20,960 --> 28:36:23,280
the ellipse level and you can do that

43075
28:36:23,280 --> 28:36:25,600
like this you can also override the gate

43076
28:36:25,600 --> 28:36:28,000
count method to return the current count

43077
28:36:28,000 --> 28:36:30,400
in ellipse this is going to work through

43078
28:36:30,400 --> 28:36:32,800
polymorphism because the getcount method

43079
28:36:32,800 --> 28:36:34,552
is a virtual function

43080
28:36:34,552 --> 28:36:36,552
if you call this method through a

43081
28:36:36,552 --> 28:36:38,800
basepointer you will get the correct one

43082
28:36:38,800 --> 28:36:40,800
called which is going to be the most

43083
28:36:40,800 --> 28:36:43,512
specific one through polymorphism but

43084
28:36:43,512 --> 28:36:45,600
what we want to see is how

43085
28:36:45,600 --> 28:36:47,360
things are going to work now that we

43086
28:36:47,360 --> 28:36:50,080
have a static variable which is named

43087
28:36:50,080 --> 28:36:53,280
exactly the same as the one we have in

43088
28:36:53,280 --> 28:36:56,080
our base class here the one in shape is

43089
28:36:56,080 --> 28:36:58,720
exactly named m count it is a static

43090
28:36:58,720 --> 28:37:01,680
variable of type and the one we have in

43091
28:37:01,680 --> 28:37:04,232
ellipse is also the same it is a static

43092
28:37:04,232 --> 28:37:07,512
variable called m count of type and but

43093
28:37:07,512 --> 28:37:08,480
now

43094
28:37:08,480 --> 28:37:10,232
ellipse is going to maintain its own

43095
28:37:10,232 --> 28:37:12,640
static variable and shape is going to

43096
28:37:12,640 --> 28:37:15,360
maintain its own static variable now we

43097
28:37:15,360 --> 28:37:17,680
are going to get this kind of behavior

43098
28:37:17,680 --> 28:37:20,160
we are going to see that if we try and

43099
28:37:20,160 --> 28:37:22,400
print the count of shapes we have we're

43100
28:37:22,400 --> 28:37:24,960
going to get a four here but now if we

43101
28:37:24,960 --> 28:37:27,040
try and print the count from ellipse

43102
28:37:27,040 --> 28:37:28,552
we're going to get a one because we

43103
28:37:28,552 --> 28:37:31,512
already have one ellipse and this is

43104
28:37:31,512 --> 28:37:33,440
working because ellipse is going to

43105
28:37:33,440 --> 28:37:35,360
maintain its own

43106
28:37:35,360 --> 28:37:37,040
static variable and this is going to

43107
28:37:37,040 --> 28:37:39,600
give you this behavior if it is what we

43108
28:37:39,600 --> 28:37:42,320
are after in our c plus plus program now

43109
28:37:42,320 --> 28:37:44,552
we can also go on and create a bunch of

43110
28:37:44,552 --> 28:37:46,720
other objects here we are going to store

43111
28:37:46,720 --> 28:37:48,720
them in this array which is going to be

43112
28:37:48,720 --> 28:37:51,912
storing shared pointers to shape

43113
28:37:51,912 --> 28:37:53,680
and we're going to store in derived

43114
28:37:53,680 --> 28:37:55,760
objects this is the syntax we can use to

43115
28:37:55,760 --> 28:37:58,080
do this and at the moment we do this

43116
28:37:58,080 --> 28:38:01,192
we're going to get six shapes because

43117
28:38:01,192 --> 28:38:03,912
in total we already have six shapes but

43118
28:38:03,912 --> 28:38:05,760
three of those shapes are going to be

43119
28:38:05,760 --> 28:38:07,832
ellipses and if we try to print the

43120
28:38:07,832 --> 28:38:09,832
ellipse count we're going to see that we

43121
28:38:09,832 --> 28:38:12,640
have three ellipses in our c plus plus

43122
28:38:12,640 --> 28:38:14,552
program and this is going to do

43123
28:38:14,552 --> 28:38:16,640
what we want another thing you could do

43124
28:38:16,640 --> 28:38:20,000
is also do shape polymorphism and call

43125
28:38:20,000 --> 28:38:22,000
the gatecount method and you're going to

43126
28:38:22,000 --> 28:38:24,160
get the correct getcount method and

43127
28:38:24,160 --> 28:38:27,280
print the most specific account if we

43128
28:38:27,280 --> 28:38:29,440
are calling that method on an ellipse

43129
28:38:29,440 --> 28:38:31,192
object for example we're going to print

43130
28:38:31,192 --> 28:38:33,680
three if we call that on a shape object

43131
28:38:33,680 --> 28:38:35,280
we're going to get sex and that's the

43132
28:38:35,280 --> 28:38:37,320
behavior we could achieve with

43133
28:38:37,320 --> 28:38:39,600
polymorphism with static member

43134
28:38:39,600 --> 28:38:41,512
variables and i really want you to be

43135
28:38:41,512 --> 28:38:43,600
aware of this now that you know this

43136
28:38:43,600 --> 28:38:44,872
we're going to head over to visual

43137
28:38:44,872 --> 28:38:46,720
studio code and play with us a little

43138
28:38:46,720 --> 28:38:49,600
more here we are in our working folder

43139
28:38:49,600 --> 28:38:52,080
the current project is inheritance and

43140
28:38:52,080 --> 28:38:54,720
polymorphism with static members we're

43141
28:38:54,720 --> 28:38:57,192
going to grab our template files and put

43142
28:38:57,192 --> 28:39:00,160
them in place and i am going to grab our

43143
28:39:00,160 --> 28:39:03,280
classes from my drive and use this as

43144
28:39:03,280 --> 28:39:05,512
the starting point again if you don't

43145
28:39:05,512 --> 28:39:08,080
want to type or create these classes you

43146
28:39:08,080 --> 28:39:10,320
can use the files provided in the

43147
28:39:10,320 --> 28:39:12,400
resource section of this lecture you can

43148
28:39:12,400 --> 28:39:14,320
download them and use them directly

43149
28:39:14,320 --> 28:39:16,232
without having to create them because we

43150
28:39:16,232 --> 28:39:18,640
are really interested in how static

43151
28:39:18,640 --> 28:39:22,000
members behave with our inheritance

43152
28:39:22,000 --> 28:39:24,552
hierarchy which happens to be setting up

43153
28:39:24,552 --> 28:39:26,232
polymorphism this is what we want to

43154
28:39:26,232 --> 28:39:28,480
learn about here i am going to open this

43155
28:39:28,480 --> 28:39:30,232
up in visual studio code and we're going

43156
28:39:30,232 --> 28:39:32,872
to take a good look at our classes the

43157
28:39:32,872 --> 28:39:34,800
base class is going to be shape which is

43158
28:39:34,800 --> 28:39:37,120
what we have here it's going to have a

43159
28:39:37,120 --> 28:39:39,832
virtual method which is get count here

43160
28:39:39,832 --> 28:39:42,960
and we have a static member which is of

43161
28:39:42,960 --> 28:39:44,320
type and

43162
28:39:44,320 --> 28:39:46,160
i am going to change my parameter here

43163
28:39:46,160 --> 28:39:48,400
to bsdd string view

43164
28:39:48,400 --> 28:39:50,000
because that's what we should do in

43165
28:39:50,000 --> 28:39:52,872
modern c plus plus let's look at the cpp

43166
28:39:52,872 --> 28:39:55,192
file for this and we're going to fix

43167
28:39:55,192 --> 28:39:57,120
this a little bit and we're going to hop

43168
28:39:57,120 --> 28:39:59,192
over back to the header file and look at

43169
28:39:59,192 --> 28:40:01,192
what we have we have a virtual method

43170
28:40:01,192 --> 28:40:03,280
which is going to return this count here

43171
28:40:03,280 --> 28:40:05,040
it is a const method because it's really

43172
28:40:05,040 --> 28:40:07,280
not going to modify it's just going to

43173
28:40:07,280 --> 28:40:09,192
return a copy of the count member

43174
28:40:09,192 --> 28:40:10,872
variable we have here

43175
28:40:10,872 --> 28:40:12,960
and this is a static member variable

43176
28:40:12,960 --> 28:40:16,160
notice that it is not in line so we will

43177
28:40:16,160 --> 28:40:18,872
need to define this in the cpp file

43178
28:40:18,872 --> 28:40:21,512
somewhere because this is a declaration

43179
28:40:21,512 --> 28:40:24,000
we need to put in a definition which is

43180
28:40:24,000 --> 28:40:26,160
what we have in our cpp file here

43181
28:40:26,160 --> 28:40:28,640
because we are doing thanks in the older

43182
28:40:28,640 --> 28:40:31,192
c plus plus way we are going to

43183
28:40:31,192 --> 28:40:34,080
increment our account member variable in

43184
28:40:34,080 --> 28:40:36,720
our constructor and this is going to

43185
28:40:36,720 --> 28:40:39,280
achieve the behavior we really want to

43186
28:40:39,280 --> 28:40:41,680
have the m count member variable which

43187
28:40:41,680 --> 28:40:43,832
is static incremented each time we'll

43188
28:40:43,832 --> 28:40:46,480
create a shape object here let's go back

43189
28:40:46,480 --> 28:40:49,192
and look at our destructor and make sure

43190
28:40:49,192 --> 28:40:51,760
that it is virtual because we have

43191
28:40:51,760 --> 28:40:53,600
virtual functions in this class and this

43192
28:40:53,600 --> 28:40:55,912
is the setup we have let's look at

43193
28:40:55,912 --> 28:40:58,000
ellipse and we're going to take out this

43194
28:40:58,000 --> 28:41:00,480
static member variable because

43195
28:41:00,480 --> 28:41:03,280
we don't want to set it up as of now we

43196
28:41:03,280 --> 28:41:05,832
will enable it in a minute let's make

43197
28:41:05,832 --> 28:41:07,760
sure we remove this

43198
28:41:07,760 --> 28:41:08,960
and

43199
28:41:08,960 --> 28:41:10,872
let's remove this because i don't want

43200
28:41:10,872 --> 28:41:13,760
this and now we can try to create

43201
28:41:13,760 --> 28:41:16,000
objects of our classes and see how these

43202
28:41:16,000 --> 28:41:19,040
guys play out we can also go in ellipse

43203
28:41:19,040 --> 28:41:22,640
and make sure the constructor is taken

43204
28:41:22,640 --> 28:41:25,280
std string views where we are needing

43205
28:41:25,280 --> 28:41:28,080
strings you can do that and hop over to

43206
28:41:28,080 --> 28:41:31,360
the cpp file and do that std string view

43207
28:41:31,360 --> 28:41:33,192
i think this is going to make a visual

43208
28:41:33,192 --> 28:41:35,360
studio code happy by now

43209
28:41:35,360 --> 28:41:37,832
we can hop over to the main cpp file and

43210
28:41:37,832 --> 28:41:40,552
clean it up a little bit and we are

43211
28:41:40,552 --> 28:41:42,000
going to

43212
28:41:42,000 --> 28:41:45,360
include ellipse and in our main function

43213
28:41:45,360 --> 28:41:47,192
we're going to create a bunch of objects

43214
28:41:47,192 --> 28:41:49,280
let's close the left sidebar here

43215
28:41:49,280 --> 28:41:51,360
because we don't really need that

43216
28:41:51,360 --> 28:41:53,280
anymore we're going to grab a shape

43217
28:41:53,280 --> 28:41:54,800
object and we're going to print the

43218
28:41:54,800 --> 28:41:56,872
shape count we expect to get a one

43219
28:41:56,872 --> 28:41:59,192
because we just have one shape at this

43220
28:41:59,192 --> 28:42:01,192
moment we're going to create a second

43221
28:42:01,192 --> 28:42:03,512
shape here and if we print the count

43222
28:42:03,512 --> 28:42:05,280
we're going to get two because we have

43223
28:42:05,280 --> 28:42:07,760
two shapes this is what we expect we

43224
28:42:07,760 --> 28:42:09,360
create another shape which is going to

43225
28:42:09,360 --> 28:42:11,120
be shape three here we print the count

43226
28:42:11,120 --> 28:42:12,800
we're going to get a three but the

43227
28:42:12,800 --> 28:42:14,720
problem is going to come when we create

43228
28:42:14,720 --> 28:42:17,040
an ellipse here if we create an ellipse

43229
28:42:17,040 --> 28:42:18,720
and print the count we're going to get a

43230
28:42:18,720 --> 28:42:21,040
four because we have four shapes in our

43231
28:42:21,040 --> 28:42:23,832
c plus plus program but if we print the

43232
28:42:23,832 --> 28:42:26,160
ellipse count here we expect to get a

43233
28:42:26,160 --> 28:42:28,160
one but that's not what we're going to

43234
28:42:28,160 --> 28:42:30,800
get we're going to get a 4 because the m

43235
28:42:30,800 --> 28:42:34,080
count variable in ellipse is inherited

43236
28:42:34,080 --> 28:42:36,232
from our shape class so it is going to

43237
28:42:36,232 --> 28:42:38,400
be the same thing we have in shape here

43238
28:42:38,400 --> 28:42:39,832
because if you go back you're going to

43239
28:42:39,832 --> 28:42:42,480
see that at this point ellipse doesn't

43240
28:42:42,480 --> 28:42:45,192
have a static variable m count of its

43241
28:42:45,192 --> 28:42:47,512
own so it's going to use the one it is

43242
28:42:47,512 --> 28:42:50,320
inheritance from the shape class this is

43243
28:42:50,320 --> 28:42:52,640
the behavior we're going to get here and

43244
28:42:52,640 --> 28:42:54,480
i want you to be aware of this if this

43245
28:42:54,480 --> 28:42:56,720
is what you want this is fine but in

43246
28:42:56,720 --> 28:42:58,960
most cases you will want this to be

43247
28:42:58,960 --> 28:43:01,512
different because you want very clear

43248
28:43:01,512 --> 28:43:04,000
information about how many objects of

43249
28:43:04,000 --> 28:43:05,440
each type you have created in your

43250
28:43:05,440 --> 28:43:08,160
z-plus plus program if it is just shaped

43251
28:43:08,160 --> 28:43:10,160
this is going to be really vague because

43252
28:43:10,160 --> 28:43:12,480
you want to know if it is an ellipse if

43253
28:43:12,480 --> 28:43:14,720
it is a rectangle if it is a triangle

43254
28:43:14,720 --> 28:43:16,640
this is not going to be super clear so

43255
28:43:16,640 --> 28:43:18,160
let's weld and really show you the

43256
28:43:18,160 --> 28:43:19,760
problem here we're going to pass this

43257
28:43:19,760 --> 28:43:22,400
through gcc our favorite compiler we can

43258
28:43:22,400 --> 28:43:24,320
also bring up the left sidebar no

43259
28:43:24,320 --> 28:43:26,232
problem here and we're going to bring up

43260
28:43:26,232 --> 28:43:28,720
a terminal window or a powershell window

43261
28:43:28,720 --> 28:43:30,080
i can say

43262
28:43:30,080 --> 28:43:31,680
we're going to clear

43263
28:43:31,680 --> 28:43:33,912
and run rooster you're going to see that

43264
28:43:33,912 --> 28:43:36,320
the shape count is going to be one two

43265
28:43:36,320 --> 28:43:37,120
three

43266
28:43:37,120 --> 28:43:39,512
and we have a five here

43267
28:43:39,512 --> 28:43:42,400
because we are also incrementing the m

43268
28:43:42,400 --> 28:43:44,872
count variable in our derived class so

43269
28:43:44,872 --> 28:43:47,280
we are incrementing twice if we create

43270
28:43:47,280 --> 28:43:50,000
an ellipse object let's show you this in

43271
28:43:50,000 --> 28:43:52,720
ellipse cpp we are incrementing the m

43272
28:43:52,720 --> 28:43:55,192
count member variable but in the base

43273
28:43:55,192 --> 28:43:58,080
class we are also implementing that in

43274
28:43:58,080 --> 28:44:00,960
the cpp file that's what we have here

43275
28:44:00,960 --> 28:44:03,360
and notice that the derived class is

43276
28:44:03,360 --> 28:44:06,400
also calling the base class

43277
28:44:06,400 --> 28:44:08,800
through our initializer lust here so

43278
28:44:08,800 --> 28:44:10,640
this is the behavior we have we

43279
28:44:10,640 --> 28:44:13,360
shouldn't be incrementing this because

43280
28:44:13,360 --> 28:44:15,760
ellipse doesn't have its own static

43281
28:44:15,760 --> 28:44:18,080
variable as of now now we're going to

43282
28:44:18,080 --> 28:44:20,800
build and really solve this problem now

43283
28:44:20,800 --> 28:44:22,480
you see the kinds of problems you can

43284
28:44:22,480 --> 28:44:24,872
run into if you have a static variable

43285
28:44:24,872 --> 28:44:27,120
that is named exactly the same way and

43286
28:44:27,120 --> 28:44:29,440
you have an inheritance hierarchy

43287
28:44:29,440 --> 28:44:31,680
really weird problems can pop up and you

43288
28:44:31,680 --> 28:44:34,552
need to be aware of this let's build and

43289
28:44:34,552 --> 28:44:36,080
see that the problem actually

43290
28:44:36,080 --> 28:44:38,480
disappeared okay the bolt is good we can

43291
28:44:38,480 --> 28:44:39,760
clear

43292
28:44:39,760 --> 28:44:41,440
and run rooster we're going to see that

43293
28:44:41,440 --> 28:44:43,912
now this is what we expect one two three

43294
28:44:43,912 --> 28:44:46,000
because we have three shapes created up

43295
28:44:46,000 --> 28:44:48,320
to this point here if we create an

43296
28:44:48,320 --> 28:44:50,000
ellipse that's going to be another shape

43297
28:44:50,000 --> 28:44:51,600
if we get the shape count we're going to

43298
28:44:51,600 --> 28:44:54,400
get a 4 but ellipse count is also giving

43299
28:44:54,400 --> 28:44:57,120
us a 4 because ellipse doesn't have its

43300
28:44:57,120 --> 28:44:59,280
own static variable to solve this

43301
28:44:59,280 --> 28:45:01,280
problem we can go to ellipse and set up

43302
28:45:01,280 --> 28:45:03,832
our own member variable at the ellipse

43303
28:45:03,832 --> 28:45:06,800
level so we can enable this and

43304
28:45:06,800 --> 28:45:08,400
uncomment it we're going to go to the

43305
28:45:08,400 --> 28:45:10,232
cpp file and make sure we are

43306
28:45:10,232 --> 28:45:12,800
incrementing to get the correct count

43307
28:45:12,800 --> 28:45:15,280
incremented here i think this is all we

43308
28:45:15,280 --> 28:45:17,192
need to do we are also going to

43309
28:45:17,192 --> 28:45:19,832
initialize the static variable we have

43310
28:45:19,832 --> 28:45:22,080
at the ellipse level this is going to do

43311
28:45:22,080 --> 28:45:24,960
what we want and we can build again now

43312
28:45:24,960 --> 28:45:27,192
we're going to get the behavior we want

43313
28:45:27,192 --> 28:45:29,440
because at this point we are going to

43314
28:45:29,440 --> 28:45:30,872
print a one

43315
28:45:30,872 --> 28:45:32,960
for the ellipse count and this really

43316
28:45:32,960 --> 28:45:35,360
makes sense because we have one ellipse

43317
28:45:35,360 --> 28:45:38,232
even if we have four shapes in total so

43318
28:45:38,232 --> 28:45:40,720
this is the design i think

43319
28:45:40,720 --> 28:45:43,912
makes more sense in our c plus plus

43320
28:45:43,912 --> 28:45:46,160
program here we are going to build this

43321
28:45:46,160 --> 28:45:48,720
again and pass this through gcc the

43322
28:45:48,720 --> 28:45:51,040
builder is going to be good we can clear

43323
28:45:51,040 --> 28:45:52,960
and run rooster now we're going to see

43324
28:45:52,960 --> 28:45:55,440
that we have four shapes and one ellipse

43325
28:45:55,440 --> 28:45:57,680
this is what we want now that we have

43326
28:45:57,680 --> 28:45:59,832
this we can really do all kinds of crazy

43327
28:45:59,832 --> 28:46:01,440
things hopefully you can see that the

43328
28:46:01,440 --> 28:46:04,552
static variable is working exactly as we

43329
28:46:04,552 --> 28:46:06,552
want we can print the ellipse count we

43330
28:46:06,552 --> 28:46:08,800
can print the shape count if that's what

43331
28:46:08,800 --> 28:46:11,192
we want in our c plus plus program but

43332
28:46:11,192 --> 28:46:12,832
we can also do shape

43333
28:46:12,832 --> 28:46:15,512
polymorphism and get the correct get

43334
28:46:15,512 --> 28:46:18,320
count method called in our c plus first

43335
28:46:18,320 --> 28:46:20,872
program for example if we call the

43336
28:46:20,872 --> 28:46:23,120
getcount method on the basepointer that

43337
28:46:23,120 --> 28:46:25,440
is managing a shape we're going to get

43338
28:46:25,440 --> 28:46:27,512
this one called if we have a best

43339
28:46:27,512 --> 28:46:29,280
pointer that is managing an ellipse

43340
28:46:29,280 --> 28:46:30,960
we're going to get to this one called

43341
28:46:30,960 --> 28:46:33,192
this is going to be super cool let's go

43342
28:46:33,192 --> 28:46:35,512
up in our program and set this up we're

43343
28:46:35,512 --> 28:46:37,760
going to do this on the fly let's say

43344
28:46:37,760 --> 28:46:40,000
shape polymorphism and we're going to

43345
28:46:40,000 --> 28:46:42,720
say shift pointer and it is going to be

43346
28:46:42,720 --> 28:46:45,040
an array let's say shapes this is going

43347
28:46:45,040 --> 28:46:46,720
to do and it is going to be just an

43348
28:46:46,720 --> 28:46:48,960
array and we're going to initialize this

43349
28:46:48,960 --> 28:46:51,360
and store in a bunch of objects let's

43350
28:46:51,360 --> 28:46:54,320
put in a closing brace here let's go up

43351
28:46:54,320 --> 28:46:56,232
and see what we have for example we have

43352
28:46:56,232 --> 28:46:59,192
shape one and ellipse one we can use

43353
28:46:59,192 --> 28:47:00,872
these we're going to put in the address

43354
28:47:00,872 --> 28:47:02,720
of shape one and we're going to put in

43355
28:47:02,720 --> 28:47:04,640
the address of ellipse one this is going

43356
28:47:04,640 --> 28:47:05,680
to do

43357
28:47:05,680 --> 28:47:07,512
and we can loop through these guys and

43358
28:47:07,512 --> 28:47:09,600
call the get count method so let's do

43359
28:47:09,600 --> 28:47:12,400
this we're going to say for auto s

43360
28:47:12,400 --> 28:47:14,400
and let's do a reference because we

43361
28:47:14,400 --> 28:47:17,360
don't want copies and we're going to say

43362
28:47:17,360 --> 28:47:19,512
in shapes and we're going to call the

43363
28:47:19,512 --> 28:47:21,912
gatecount method we're going to say s

43364
28:47:21,912 --> 28:47:24,640
and say getcount this is going to

43365
28:47:24,640 --> 28:47:26,480
give us the count and we can print this

43366
28:47:26,480 --> 28:47:29,192
out if we want we can say sddc out and

43367
28:47:29,192 --> 28:47:31,280
count and we're going to

43368
28:47:31,280 --> 28:47:33,832
put a new line character here to

43369
28:47:33,832 --> 28:47:35,680
separate these guys

43370
28:47:35,680 --> 28:47:37,280
and we can

43371
28:47:37,280 --> 28:47:39,440
put a separator here we can copy what we

43372
28:47:39,440 --> 28:47:41,440
just used in our c plus plus program

43373
28:47:41,440 --> 28:47:43,832
here just to make sure this is super

43374
28:47:43,832 --> 28:47:46,320
clear when we print things on the

43375
28:47:46,320 --> 28:47:47,912
terminal here we're going to build our

43376
28:47:47,912 --> 28:47:51,040
program and see if it actually works the

43377
28:47:51,040 --> 28:47:52,960
body is going to be good we can clear

43378
28:47:52,960 --> 28:47:55,440
and run rooster we're going to see that

43379
28:47:55,440 --> 28:47:57,600
the count is going to be 4 for the first

43380
28:47:57,600 --> 28:47:59,040
iteration because we're going to be

43381
28:47:59,040 --> 28:48:01,760
calling the get count method from

43382
28:48:01,760 --> 28:48:04,960
shape because that's our base pointer so

43383
28:48:04,960 --> 28:48:06,232
this is what we're going to get we're

43384
28:48:06,232 --> 28:48:08,400
going to print the m count member

43385
28:48:08,400 --> 28:48:10,720
variable from the base class that's why

43386
28:48:10,720 --> 28:48:13,280
we have a four but on the second

43387
28:48:13,280 --> 28:48:16,552
iteration the object is ellipse and we

43388
28:48:16,552 --> 28:48:18,552
are using polymorphism because we are

43389
28:48:18,552 --> 28:48:20,800
going through a base pointer and this

43390
28:48:20,800 --> 28:48:23,120
base pointer happens to support the

43391
28:48:23,120 --> 28:48:25,760
virtual method get count we will get the

43392
28:48:25,760 --> 28:48:28,552
most specific one called on the current

43393
28:48:28,552 --> 28:48:31,680
object that our base pointer is managing

43394
28:48:31,680 --> 28:48:33,600
here and this happens to be an ellipse

43395
28:48:33,600 --> 28:48:35,040
so we're going to call the ellipse

43396
28:48:35,040 --> 28:48:37,832
version of our virtual function here and

43397
28:48:37,832 --> 28:48:40,000
we will get a one because we really have

43398
28:48:40,000 --> 28:48:42,552
one ellipse in our c plus plus program

43399
28:48:42,552 --> 28:48:44,800
this is what we see here this is really

43400
28:48:44,800 --> 28:48:47,040
all i wanted you to see in this lecture

43401
28:48:47,040 --> 28:48:48,400
how you can use

43402
28:48:48,400 --> 28:48:50,872
static member variables with inheritance

43403
28:48:50,872 --> 28:48:53,192
and polymorphism and you need to be

43404
28:48:53,192 --> 28:48:55,280
aware of these little things that can

43405
28:48:55,280 --> 28:48:57,832
really be confusing especially for

43406
28:48:57,832 --> 28:48:59,912
beginners we are going to stop here in

43407
28:48:59,912 --> 28:49:01,680
this lecture the next one we're going to

43408
28:49:01,680 --> 28:49:04,640
learn about the final specification we

43409
28:49:04,640 --> 28:49:07,832
can use in our inheritance hierarchy go

43410
28:49:07,832 --> 28:49:09,912
ahead and finish up here and meet me

43411
28:49:09,912 --> 28:49:11,120
there

43412
28:49:11,120 --> 28:49:13,280
go ahead and finish up here and meet me

43413
28:49:13,280 --> 28:49:14,960
there in this lecture we're going to

43414
28:49:14,960 --> 28:49:18,960
learn about the final specifier used in

43415
28:49:18,960 --> 28:49:21,512
inheritance hierarchies this is going to

43416
28:49:21,512 --> 28:49:24,480
allow you to do one of two things you

43417
28:49:24,480 --> 28:49:26,800
will either be able to restrict how you

43418
28:49:26,800 --> 28:49:30,000
override methods in the derived classes

43419
28:49:30,000 --> 28:49:32,720
or you can restrict how you can derive

43420
28:49:32,720 --> 28:49:35,512
from base classes i know this is in the

43421
28:49:35,512 --> 28:49:37,040
air but we're going to look at a few

43422
28:49:37,040 --> 28:49:39,040
examples to really drive this home

43423
28:49:39,040 --> 28:49:41,512
suppose we have an inheritance hierarchy

43424
28:49:41,512 --> 28:49:43,440
like we see here the top class is animal

43425
28:49:43,440 --> 28:49:45,760
we can derive from this and have feline

43426
28:49:45,760 --> 28:49:47,760
you can have bird as a derived class

43427
28:49:47,760 --> 28:49:50,080
feline can be inherited to have a dog

43428
28:49:50,080 --> 28:49:52,720
and cat and you can derive from cat for

43429
28:49:52,720 --> 28:49:55,120
example to have wild cat and bulldog

43430
28:49:55,120 --> 28:49:57,192
from dog you can do all these things

43431
28:49:57,192 --> 28:49:59,512
here and this is inheritance hierarchy

43432
28:49:59,512 --> 28:50:01,512
we're going to be using to learn about

43433
28:50:01,512 --> 28:50:04,080
these things now here is a possible

43434
28:50:04,080 --> 28:50:06,000
implementation for the dog class which

43435
28:50:06,000 --> 28:50:08,320
is going to be inherited from feline

43436
28:50:08,320 --> 28:50:11,040
publicly as we see here but take a look

43437
28:50:11,040 --> 28:50:13,680
at the run method we are setting up in

43438
28:50:13,680 --> 28:50:17,360
dag we are appending a final specifier

43439
28:50:17,360 --> 28:50:20,320
and what this is going to mean is that

43440
28:50:20,320 --> 28:50:23,832
no downstream inheritance class will be

43441
28:50:23,832 --> 28:50:26,080
able to override the random method

43442
28:50:26,080 --> 28:50:28,232
further this is what we can achieve so

43443
28:50:28,232 --> 28:50:30,960
if we don't want our derived classes to

43444
28:50:30,960 --> 28:50:32,720
override our

43445
28:50:32,720 --> 28:50:35,512
virtual method we can mark that method

43446
28:50:35,512 --> 28:50:37,512
as final in our class and we are

43447
28:50:37,512 --> 28:50:40,000
basically saying i am going to put in my

43448
28:50:40,000 --> 28:50:42,720
implementation but i don't want any

43449
28:50:42,720 --> 28:50:46,400
deriving downstream class to override

43450
28:50:46,400 --> 28:50:48,720
this method further if they do that they

43451
28:50:48,720 --> 28:50:50,400
are going to get a compiler error and

43452
28:50:50,400 --> 28:50:52,720
this is something we can achieve using

43453
28:50:52,720 --> 28:50:55,760
the final specifier in our inheritance

43454
28:50:55,760 --> 28:50:57,912
hierarchy again in this case we are

43455
28:50:57,912 --> 28:51:00,480
using this to restrict

43456
28:51:00,480 --> 28:51:04,000
how people can override our own virtual

43457
28:51:04,000 --> 28:51:06,960
method in downstream classes or i

43458
28:51:06,960 --> 28:51:08,800
shouldn't really say our own method

43459
28:51:08,800 --> 28:51:11,440
because it may be coming from upstream

43460
28:51:11,440 --> 28:51:13,832
but you are restricting people from

43461
28:51:13,832 --> 28:51:16,552
overriding that method further in

43462
28:51:16,552 --> 28:51:18,872
downstream classes here okay so this is

43463
28:51:18,872 --> 28:51:21,512
the first use we have for the final

43464
28:51:21,512 --> 28:51:24,232
specifier but we can also restrict

43465
28:51:24,232 --> 28:51:27,760
people from inheriting altogether so

43466
28:51:27,760 --> 28:51:29,600
here we have a simple example to drive

43467
28:51:29,600 --> 28:51:32,160
this home we have our cat class it is

43468
28:51:32,160 --> 28:51:34,552
going to be inheriting from feline but

43469
28:51:34,552 --> 28:51:37,760
we are marking our cat class as final

43470
28:51:37,760 --> 28:51:40,080
and what this is going to mean if

43471
28:51:40,080 --> 28:51:43,360
anybody tries to inherit or derive from

43472
28:51:43,360 --> 28:51:45,832
cat in any way they are going to get a

43473
28:51:45,832 --> 28:51:47,512
compiler error and this is what we can

43474
28:51:47,512 --> 28:51:50,720
achieve with the final specifier again

43475
28:51:50,720 --> 28:51:52,480
there are two things you can restrict

43476
28:51:52,480 --> 28:51:55,280
how people override your virtual methods

43477
28:51:55,280 --> 28:51:58,000
if you want to restrict that from the

43478
28:51:58,000 --> 28:52:00,800
current class you can mark your virtual

43479
28:52:00,800 --> 28:52:03,280
method as final you can also restrict

43480
28:52:03,280 --> 28:52:05,600
how people inherit all together from

43481
28:52:05,600 --> 28:52:07,832
your class and if you want that behavior

43482
28:52:07,832 --> 28:52:11,040
you can mark your class as final using

43483
28:52:11,040 --> 28:52:13,120
the syntax we just saw in the slides

43484
28:52:13,120 --> 28:52:15,440
here okay now that you know these things

43485
28:52:15,440 --> 28:52:17,680
let's look at a few things that may be

43486
28:52:17,680 --> 28:52:20,160
interesting for example here is a simple

43487
28:52:20,160 --> 28:52:22,160
fact that you can create a class right

43488
28:52:22,160 --> 28:52:25,440
away in market as final and when you do

43489
28:52:25,440 --> 28:52:28,480
this nobody will be able to ever inherit

43490
28:52:28,480 --> 28:52:30,800
from this class in your program and if

43491
28:52:30,800 --> 28:52:33,120
we do this we will get a compiler error

43492
28:52:33,120 --> 28:52:35,600
for example this is one thing i find

43493
28:52:35,600 --> 28:52:37,912
interesting and i really wanted you to

43494
28:52:37,912 --> 28:52:40,000
know this another thing is that it is

43495
28:52:40,000 --> 28:52:42,400
possible to introduce useless virtual

43496
28:52:42,400 --> 28:52:45,360
methods in your inheritance hierarchy

43497
28:52:45,360 --> 28:52:48,080
for example if our cat class is marked

43498
28:52:48,080 --> 28:52:50,960
as final what this means is that nobody

43499
28:52:50,960 --> 28:52:53,512
will ever be able to inherit from this

43500
28:52:53,512 --> 28:52:55,600
class but we are going further in

43501
28:52:55,600 --> 28:52:57,680
setting up a virtual method which is

43502
28:52:57,680 --> 28:53:00,400
meant to be inherited or overwritten in

43503
28:53:00,400 --> 28:53:02,720
downstream classes but how do we get a

43504
28:53:02,720 --> 28:53:05,040
downstream class if we can't inherit

43505
28:53:05,040 --> 28:53:07,120
from the cat class which is marked final

43506
28:53:07,120 --> 28:53:10,320
so so we have conflicting ideas here on

43507
28:53:10,320 --> 28:53:12,320
one hand we are saying we can never

43508
28:53:12,320 --> 28:53:15,192
inherit from this grant class but on the

43509
28:53:15,192 --> 28:53:17,280
other hand we are setting up a method

43510
28:53:17,280 --> 28:53:20,232
that is meant to be used or specialized

43511
28:53:20,232 --> 28:53:22,640
in derived classes so this is something

43512
28:53:22,640 --> 28:53:24,720
that is interesting this code is going

43513
28:53:24,720 --> 28:53:27,760
to compile and i think maybe in future

43514
28:53:27,760 --> 28:53:29,680
standards of c plus plus they are going

43515
28:53:29,680 --> 28:53:31,912
to fix this problem and maybe give you a

43516
28:53:31,912 --> 28:53:33,512
compiler error if you try to do

43517
28:53:33,512 --> 28:53:35,440
something like this but at this point

43518
28:53:35,440 --> 28:53:37,280
you're not going to get a compiler error

43519
28:53:37,280 --> 28:53:39,040
this is just going to be valid c plus

43520
28:53:39,040 --> 28:53:41,680
plus syntax even if this is really weird

43521
28:53:41,680 --> 28:53:44,320
we have conflicting ideas here okay one

43522
28:53:44,320 --> 28:53:47,040
thing you should know though is that we

43523
28:53:47,040 --> 28:53:49,192
can override in a final class and this

43524
28:53:49,192 --> 28:53:50,720
is going to make sense because for

43525
28:53:50,720 --> 28:53:53,440
example the run method is coming from

43526
28:53:53,440 --> 28:53:55,192
the feline class

43527
28:53:55,192 --> 28:53:57,760
and here we are just specializing that

43528
28:53:57,760 --> 28:54:00,480
so we are marking that as an override

43529
28:54:00,480 --> 28:54:03,040
here even if this is the final class so

43530
28:54:03,040 --> 28:54:05,512
be careful this is valid c plus plus

43531
28:54:05,512 --> 28:54:07,680
syntax this is going to work just fine

43532
28:54:07,680 --> 28:54:09,512
another thing you can do which is pretty

43533
28:54:09,512 --> 28:54:11,912
useless in your c plus plus program is

43534
28:54:11,912 --> 28:54:14,720
to introduce a virtual method and mark

43535
28:54:14,720 --> 28:54:18,872
it as final right away so again this is

43536
28:54:18,872 --> 28:54:21,912
really weird we have two ideas that are

43537
28:54:21,912 --> 28:54:24,552
conflicting the virtual keyword means

43538
28:54:24,552 --> 28:54:27,040
that we want this to be visualized in

43539
28:54:27,040 --> 28:54:29,680
the downstream classes but again we are

43540
28:54:29,680 --> 28:54:32,400
saying this method is final so no

43541
28:54:32,400 --> 28:54:34,640
downstream class will override this if

43542
28:54:34,640 --> 28:54:36,080
they try to do that they are going to

43543
28:54:36,080 --> 28:54:38,320
get a compiler error so this is again a

43544
28:54:38,320 --> 28:54:40,960
bunch of conflicting ideas c plus plus

43545
28:54:40,960 --> 28:54:42,640
is going to allow this syntax this is

43546
28:54:42,640 --> 28:54:44,552
not going to give you a compiler error

43547
28:54:44,552 --> 28:54:46,720
but this is weird and you need to be

43548
28:54:46,720 --> 28:54:48,720
aware of this okay now that you know

43549
28:54:48,720 --> 28:54:50,480
these ideas we're going to head over to

43550
28:54:50,480 --> 28:54:53,192
visual studio code and play with the

43551
28:54:53,192 --> 28:54:55,832
final specifier in our inheritance

43552
28:54:55,832 --> 28:54:57,912
hierarchy we will be setting up this

43553
28:54:57,912 --> 28:55:00,320
kind of inheritance hierarchy and we

43554
28:55:00,320 --> 28:55:02,400
will set up a bunch of virtual methods

43555
28:55:02,400 --> 28:55:04,960
and mark them as final i think we will

43556
28:55:04,960 --> 28:55:07,512
do that in the dog class and we will

43557
28:55:07,512 --> 28:55:10,160
mark a bunch of classes as final and see

43558
28:55:10,160 --> 28:55:12,552
that if we inherit from them we're going

43559
28:55:12,552 --> 28:55:14,720
to get a bunch of compiler errors so

43560
28:55:14,720 --> 28:55:17,760
let's do this here we are in our working

43561
28:55:17,760 --> 28:55:21,120
folder the current project is final and

43562
28:55:21,120 --> 28:55:23,360
we are going to bring in our template

43563
28:55:23,360 --> 28:55:24,872
files pretty quick we're going to use

43564
28:55:24,872 --> 28:55:27,440
this as our starting point we're going

43565
28:55:27,440 --> 28:55:29,600
to put that in place

43566
28:55:29,600 --> 28:55:31,600
and i am going to put in a bunch of

43567
28:55:31,600 --> 28:55:34,000
classes i have lying around on my system

43568
28:55:34,000 --> 28:55:36,400
because i don't want to set up these

43569
28:55:36,400 --> 28:55:38,320
classes that would be a waste of your

43570
28:55:38,320 --> 28:55:40,800
time just know that we are trying to set

43571
28:55:40,800 --> 28:55:43,280
up this kind of inheritance hierarchy

43572
28:55:43,280 --> 28:55:45,760
animal is going to be our top dog or

43573
28:55:45,760 --> 28:55:47,600
animal is going to be our top class and

43574
28:55:47,600 --> 28:55:50,232
we will be inheriting from this creating

43575
28:55:50,232 --> 28:55:52,480
an inheritance hierarchy we can play

43576
28:55:52,480 --> 28:55:55,040
with in our code here okay so we are

43577
28:55:55,040 --> 28:55:57,280
going to open this up in visual studio

43578
28:55:57,280 --> 28:55:59,192
code so let's do that by dragging and

43579
28:55:59,192 --> 28:56:01,600
dropping here this is going to give us

43580
28:56:01,600 --> 28:56:04,080
all these crazy classes we have

43581
28:56:04,080 --> 28:56:06,400
the top class is going to be animal and

43582
28:56:06,400 --> 28:56:08,400
it is going to be defining the features

43583
28:56:08,400 --> 28:56:10,160
any kind of animal we support you know c

43584
28:56:10,160 --> 28:56:12,232
plus plus program is going to have for

43585
28:56:12,232 --> 28:56:14,720
example any kind of animal will need to

43586
28:56:14,720 --> 28:56:17,832
breathe and we will set up this virtual

43587
28:56:17,832 --> 28:56:19,192
method here

43588
28:56:19,192 --> 28:56:21,280
and we will be inheriting from this

43589
28:56:21,280 --> 28:56:24,000
animal class to create a feline class

43590
28:56:24,000 --> 28:56:26,232
and a bird class this is something we

43591
28:56:26,232 --> 28:56:28,400
did in a few previous lectures and we

43592
28:56:28,400 --> 28:56:30,160
are just reusing this inheritance

43593
28:56:30,160 --> 28:56:32,160
hierarchy here let's look at the feline

43594
28:56:32,160 --> 28:56:34,000
class the filament class is going to set

43595
28:56:34,000 --> 28:56:36,720
up a virtual method which is called run

43596
28:56:36,720 --> 28:56:39,040
and the method is going to be overridden

43597
28:56:39,040 --> 28:56:41,120
in the dog for example

43598
28:56:41,120 --> 28:56:43,760
we can override the run method but

43599
28:56:43,760 --> 28:56:47,360
notice that we are marking that as final

43600
28:56:47,360 --> 28:56:50,232
okay so look at this the method is final

43601
28:56:50,232 --> 28:56:52,480
and what this means is that

43602
28:56:52,480 --> 28:56:55,360
no downstream classes inheriting from

43603
28:56:55,360 --> 28:56:58,552
doug will ever be able to specialize or

43604
28:56:58,552 --> 28:57:01,280
override this method further if they try

43605
28:57:01,280 --> 28:57:03,280
to do that they will get a compiler

43606
28:57:03,280 --> 28:57:05,912
error notice that this may be our method

43607
28:57:05,912 --> 28:57:08,000
or it may be a method coming from

43608
28:57:08,000 --> 28:57:10,480
upstream classes in this case the run

43609
28:57:10,480 --> 28:57:13,040
method was introduced at the feline

43610
28:57:13,040 --> 28:57:16,232
level you see it was introduced here and

43611
28:57:16,232 --> 28:57:18,960
doug happens to be overriding this

43612
28:57:18,960 --> 28:57:21,040
method here that's why we have the

43613
28:57:21,040 --> 28:57:23,280
override key world but

43614
28:57:23,280 --> 28:57:25,280
at the same time we are going to mark it

43615
28:57:25,280 --> 28:57:26,640
as final

43616
28:57:26,640 --> 28:57:29,192
and prohibit or prevent

43617
28:57:29,192 --> 28:57:31,912
downstream classes from overriding this

43618
28:57:31,912 --> 28:57:35,360
method further if we look at our bulldog

43619
28:57:35,360 --> 28:57:37,912
class we're going to find the class to

43620
28:57:37,912 --> 28:57:42,160
inherit from dark we have our run method

43621
28:57:42,160 --> 28:57:44,480
here it is commented out at this moment

43622
28:57:44,480 --> 28:57:46,400
i just want you to see that our code is

43623
28:57:46,400 --> 28:57:48,872
just going to compile if we compile it

43624
28:57:48,872 --> 28:57:50,000
now

43625
28:57:50,000 --> 28:57:51,512
let's do this we're going to pass this

43626
28:57:51,512 --> 28:57:54,000
through gcc okay you see the bolt is

43627
28:57:54,000 --> 28:57:56,232
good and we have generated our binary

43628
28:57:56,232 --> 28:57:57,760
which is really not doing anything

43629
28:57:57,760 --> 28:58:00,232
because our main function is just some

43630
28:58:00,232 --> 28:58:02,640
dummy code we have here to make sure it

43631
28:58:02,640 --> 28:58:05,040
works with c plus plus 20 but what i

43632
28:58:05,040 --> 28:58:06,400
want you to see

43633
28:58:06,400 --> 28:58:09,440
is that if you go in bulldog let's go in

43634
28:58:09,440 --> 28:58:12,640
our bulldog class and uncomment

43635
28:58:12,640 --> 28:58:15,512
this class here or this virtual method

43636
28:58:15,512 --> 28:58:16,640
we're going to see that we're going to

43637
28:58:16,640 --> 28:58:18,320
get a compiler error we have a squiggly

43638
28:58:18,320 --> 28:58:21,120
line meaning that we did something wrong

43639
28:58:21,120 --> 28:58:23,760
and well let's look at the problems tab

43640
28:58:23,760 --> 28:58:26,160
from visual studio code here cannot

43641
28:58:26,160 --> 28:58:29,120
override find a function dog run this is

43642
28:58:29,120 --> 28:58:31,120
a final method from

43643
28:58:31,120 --> 28:58:33,832
the dog class if we try to override it

43644
28:58:33,832 --> 28:58:36,080
further we will get a compiler error

43645
28:58:36,080 --> 28:58:38,400
this is something we can achieve by

43646
28:58:38,400 --> 28:58:41,912
marking our virtual method as final as

43647
28:58:41,912 --> 28:58:44,552
we are doing here now if we try to build

43648
28:58:44,552 --> 28:58:46,000
this program we're going to get a

43649
28:58:46,000 --> 28:58:48,232
compiler error let's pass this through

43650
28:58:48,232 --> 28:58:51,600
gcc and let you see this okay you see we

43651
28:58:51,600 --> 28:58:54,872
get a compiler error and uh the error is

43652
28:58:54,872 --> 28:58:57,912
that we are overriding let's go up and

43653
28:58:57,912 --> 28:59:02,480
see the error here error and on line 12

43654
28:59:02,480 --> 28:59:05,280
in bulldog h we see that we are

43655
28:59:05,280 --> 28:59:08,320
overriding a final method virtual

43656
28:59:08,320 --> 28:59:11,600
void bulldog is a final function and we

43657
28:59:11,600 --> 28:59:14,000
are overriding this and this is going to

43658
28:59:14,000 --> 28:59:15,680
give us a compiler error this is the

43659
28:59:15,680 --> 28:59:17,680
behavior we get so the message here is

43660
28:59:17,680 --> 28:59:19,912
that you can go in your inheritance

43661
28:59:19,912 --> 28:59:22,320
hierarchy at any level and mark a

43662
28:59:22,320 --> 28:59:25,360
virtual method as final and prevent

43663
28:59:25,360 --> 28:59:27,440
download stream classes from

43664
28:59:27,440 --> 28:59:30,232
specializing or overriding that method

43665
28:59:30,232 --> 28:59:32,400
further and if they do that they will

43666
28:59:32,400 --> 28:59:34,480
get a compiler error this is something

43667
28:59:34,480 --> 28:59:36,080
we can achieve in our c plus plus

43668
28:59:36,080 --> 28:59:38,080
program another thing you can do with

43669
28:59:38,080 --> 28:59:40,720
the final specifier is that you can

43670
28:59:40,720 --> 28:59:43,680
prevent people from inheriting from your

43671
28:59:43,680 --> 28:59:47,120
class altogether let's go to our cat

43672
28:59:47,120 --> 28:59:49,040
class i think that's the example that

43673
28:59:49,040 --> 28:59:52,000
sets that up we have a cat class it is

43674
28:59:52,000 --> 28:59:54,552
going to be inheriting from feline but

43675
28:59:54,552 --> 28:59:57,280
the class is marked as final

43676
28:59:57,280 --> 28:59:59,512
now what this is going to do

43677
28:59:59,512 --> 29:00:01,600
it's going to throw a compiler error

43678
29:00:01,600 --> 29:00:04,160
anytime somebody tries to derive or

43679
29:00:04,160 --> 29:00:06,232
inherit from this class here so if

43680
29:00:06,232 --> 29:00:09,040
somebody tries to inherit from cat as we

43681
29:00:09,040 --> 29:00:11,832
are doing here create a wildcat from a

43682
29:00:11,832 --> 29:00:13,680
cat we are going to get a compiler error

43683
29:00:13,680 --> 29:00:16,160
because we can't inherit from cat

43684
29:00:16,160 --> 29:00:18,640
altogether it is a final class at this

43685
29:00:18,640 --> 29:00:22,160
moment okay so let's look at our wildcat

43686
29:00:22,160 --> 29:00:24,640
class it is going to try

43687
29:00:24,640 --> 29:00:25,832
and

43688
29:00:25,832 --> 29:00:29,192
derive from cat we can do something like

43689
29:00:29,192 --> 29:00:31,440
this we can remove our comments here and

43690
29:00:31,440 --> 29:00:33,280
if we try to do this we will get a

43691
29:00:33,280 --> 29:00:35,192
compiler arrow let's look at the cpp

43692
29:00:35,192 --> 29:00:37,440
file and see what we have it has nothing

43693
29:00:37,440 --> 29:00:39,912
special but if we try to do that and

43694
29:00:39,912 --> 29:00:42,800
inherit from cat we will get a compiler

43695
29:00:42,800 --> 29:00:45,360
error because the cat class is final and

43696
29:00:45,360 --> 29:00:47,680
you cannot derive from it if you do that

43697
29:00:47,680 --> 29:00:49,440
you will get a compiler error because

43698
29:00:49,440 --> 29:00:52,000
the cat class is final this is what i

43699
29:00:52,000 --> 29:00:54,320
want you to see here let's try and build

43700
29:00:54,320 --> 29:00:55,832
our program again we're going to pass

43701
29:00:55,832 --> 29:00:58,320
this through gcc and we will see our

43702
29:00:58,320 --> 29:01:00,552
compiler error okay the world is

43703
29:01:00,552 --> 29:01:03,120
finished with errors if we go up we will

43704
29:01:03,120 --> 29:01:06,400
see that we cannot derive from a final

43705
29:01:06,400 --> 29:01:08,640
base class if we do that we will get a

43706
29:01:08,640 --> 29:01:10,552
compiler error and this is what i want

43707
29:01:10,552 --> 29:01:12,552
you to see here okay now that we notice

43708
29:01:12,552 --> 29:01:14,720
we're going to take this back

43709
29:01:14,720 --> 29:01:17,280
and take out the compiler error here

43710
29:01:17,280 --> 29:01:19,360
because we want our code to compile

43711
29:01:19,360 --> 29:01:21,512
we're going to make sure it is compiling

43712
29:01:21,512 --> 29:01:23,832
fine okay now the code is compiling

43713
29:01:23,832 --> 29:01:25,832
because we are no longer trying to

43714
29:01:25,832 --> 29:01:29,280
inherit from cat and i want you to now

43715
29:01:29,280 --> 29:01:32,320
see a few interesting facts about the

43716
29:01:32,320 --> 29:01:35,120
final specifier when it works together

43717
29:01:35,120 --> 29:01:37,512
with virtual functions let's go to the

43718
29:01:37,512 --> 29:01:40,000
main cpp file and show you the first

43719
29:01:40,000 --> 29:01:42,232
fact and that's that you can create a

43720
29:01:42,232 --> 29:01:45,360
class right away and mark that as vinyl

43721
29:01:45,360 --> 29:01:48,160
as you create it as we do here if you do

43722
29:01:48,160 --> 29:01:50,320
that this class is going to not be

43723
29:01:50,320 --> 29:01:52,800
inheritable and if you try to inherit

43724
29:01:52,800 --> 29:01:54,640
from it you will get a compiler error

43725
29:01:54,640 --> 29:01:56,872
let's take out everything we have here

43726
29:01:56,872 --> 29:01:59,280
and just say hello in our main function

43727
29:01:59,280 --> 29:02:00,960
this is going to do just to have

43728
29:02:00,960 --> 29:02:02,552
something this is going to give us a

43729
29:02:02,552 --> 29:02:04,720
compiler error because we can't inherit

43730
29:02:04,720 --> 29:02:07,120
from a final class let's build and show

43731
29:02:07,120 --> 29:02:09,832
you the compiler error this is going to

43732
29:02:09,832 --> 29:02:12,160
go through gcc and the world is going to

43733
29:02:12,160 --> 29:02:14,960
finish with errors and that we have our

43734
29:02:14,960 --> 29:02:18,160
message here and we don't have the error

43735
29:02:18,160 --> 29:02:21,280
we expected because we forgot to put our

43736
29:02:21,280 --> 29:02:23,040
closing semicolon on our class

43737
29:02:23,040 --> 29:02:25,360
definition here but we can build again

43738
29:02:25,360 --> 29:02:28,000
and get our error okay the world is

43739
29:02:28,000 --> 29:02:29,912
finished with errors

43740
29:02:29,912 --> 29:02:32,080
and the error is going to be that we

43741
29:02:32,080 --> 29:02:34,320
cannot derive from a final class this is

43742
29:02:34,320 --> 29:02:36,552
what we expect here let's comment this

43743
29:02:36,552 --> 29:02:38,800
out because i just wanted you to see

43744
29:02:38,800 --> 29:02:41,600
this fact another interesting thing c

43745
29:02:41,600 --> 29:02:44,000
plus plus allows you to do

43746
29:02:44,000 --> 29:02:47,760
is to set up a new virtual method in a

43747
29:02:47,760 --> 29:02:50,080
final class let's first build and make

43748
29:02:50,080 --> 29:02:52,720
sure the compiler error here goes away

43749
29:02:52,720 --> 29:02:54,720
and i am going to show you that okay the

43750
29:02:54,720 --> 29:02:57,120
build is good let's go back in our final

43751
29:02:57,120 --> 29:02:59,360
class which is the cat class

43752
29:02:59,360 --> 29:03:02,160
if i remember correctly this is a final

43753
29:03:02,160 --> 29:03:04,800
class we can't derive from this class

43754
29:03:04,800 --> 29:03:06,960
but we can set up a virtual method for

43755
29:03:06,960 --> 29:03:07,912
example

43756
29:03:07,912 --> 29:03:10,872
the virtual method here called meow is

43757
29:03:10,872 --> 29:03:12,000
useless

43758
29:03:12,000 --> 29:03:14,480
why is it useless it is a virtual and

43759
29:03:14,480 --> 29:03:16,480
marking it virtual means that

43760
29:03:16,480 --> 29:03:19,040
you at least want people inheriting from

43761
29:03:19,040 --> 29:03:21,512
this class to inherit it and use it or

43762
29:03:21,512 --> 29:03:23,360
even better you want them to have the

43763
29:03:23,360 --> 29:03:25,512
ability to specialize

43764
29:03:25,512 --> 29:03:27,912
or override this method and make it to

43765
29:03:27,912 --> 29:03:30,720
do more specialized things but you can't

43766
29:03:30,720 --> 29:03:32,720
really do that because you can't derive

43767
29:03:32,720 --> 29:03:35,040
from this class all together so this is

43768
29:03:35,040 --> 29:03:37,280
something that c plus plus allows us to

43769
29:03:37,280 --> 29:03:39,600
do but this is a useless method which

43770
29:03:39,600 --> 29:03:42,320
will never be used in any way so this is

43771
29:03:42,320 --> 29:03:43,912
something i want you to be aware of but

43772
29:03:43,912 --> 29:03:45,760
this is going to compile again let's

43773
29:03:45,760 --> 29:03:47,832
pass this through gcc you're going to

43774
29:03:47,832 --> 29:03:49,440
see that this is going to compile and

43775
29:03:49,440 --> 29:03:51,280
work even if this method is really

43776
29:03:51,280 --> 29:03:53,440
useless i want you to be aware of this

43777
29:03:53,440 --> 29:03:55,360
okay so the build is good here okay so

43778
29:03:55,360 --> 29:03:58,800
this is our interesting fact number two

43779
29:03:58,800 --> 29:04:01,832
okay even if this method is useless

43780
29:04:01,832 --> 29:04:05,360
it is possible to specialize a method

43781
29:04:05,360 --> 29:04:07,832
coming from upstream classes from your

43782
29:04:07,832 --> 29:04:10,640
final class for example in feline we

43783
29:04:10,640 --> 29:04:11,760
have

43784
29:04:11,760 --> 29:04:14,720
a method called run which was introduced

43785
29:04:14,720 --> 29:04:17,360
there i think we can override this

43786
29:04:17,360 --> 29:04:19,760
method in our final class which is the

43787
29:04:19,760 --> 29:04:21,832
cat class here so this method is going

43788
29:04:21,832 --> 29:04:24,040
to be useless because it will be

43789
29:04:24,040 --> 29:04:26,480
specializing what we get from our

43790
29:04:26,480 --> 29:04:28,872
upstream class this is going to work

43791
29:04:28,872 --> 29:04:31,280
okay so since we are looking at a few

43792
29:04:31,280 --> 29:04:33,440
useless things you can do with final

43793
29:04:33,440 --> 29:04:35,192
combined with the

43794
29:04:35,192 --> 29:04:38,232
virtual mechanisms in c plus plus i want

43795
29:04:38,232 --> 29:04:40,400
you to see that it is possible to set up

43796
29:04:40,400 --> 29:04:44,080
a virtual method and mark it as a final

43797
29:04:44,080 --> 29:04:46,232
in the same declaration and we're going

43798
29:04:46,232 --> 29:04:48,160
to go to the bird class and really show

43799
29:04:48,160 --> 29:04:49,912
you that for example

43800
29:04:49,912 --> 29:04:52,552
we have a virtual method which is called

43801
29:04:52,552 --> 29:04:55,832
fly but this is marked final the moment

43802
29:04:55,832 --> 29:04:57,512
we declare it and this is going to be

43803
29:04:57,512 --> 29:04:59,832
contradicted for example the virtual

43804
29:04:59,832 --> 29:05:02,400
keyword means that people downstream

43805
29:05:02,400 --> 29:05:04,400
will be able to specialize this or

43806
29:05:04,400 --> 29:05:07,512
inherit this but at the same time we are

43807
29:05:07,512 --> 29:05:09,680
marking this guy as final so we are

43808
29:05:09,680 --> 29:05:12,720
saying nobody downstream will be able to

43809
29:05:12,720 --> 29:05:14,872
override this method if they do that

43810
29:05:14,872 --> 29:05:17,600
they will get a compiler error now which

43811
29:05:17,600 --> 29:05:19,832
one is going to win virtual or final

43812
29:05:19,832 --> 29:05:21,832
final is going to win because if you try

43813
29:05:21,832 --> 29:05:24,160
to override this method in downstream

43814
29:05:24,160 --> 29:05:26,400
classes you will get a compiler error

43815
29:05:26,400 --> 29:05:29,440
let's go down and look at one bird we

43816
29:05:29,440 --> 29:05:31,912
might have in our program for example we

43817
29:05:31,912 --> 29:05:34,000
might have a pigeon let's grab this

43818
29:05:34,000 --> 29:05:35,680
method and try to override it you're

43819
29:05:35,680 --> 29:05:37,120
going to see that we get a compiler

43820
29:05:37,120 --> 29:05:39,440
error we're going to go in pidgin and

43821
29:05:39,440 --> 29:05:41,912
put in the fly method and uh for example

43822
29:05:41,912 --> 29:05:44,160
we're going to say pigeon fly here and

43823
29:05:44,160 --> 29:05:46,080
we're going to say override we are

43824
29:05:46,080 --> 29:05:48,080
trying to override this method but we're

43825
29:05:48,080 --> 29:05:49,680
going to get a compiler error you see we

43826
29:05:49,680 --> 29:05:51,512
have a squiggly line because this is a

43827
29:05:51,512 --> 29:05:53,912
final method and we are trying to

43828
29:05:53,912 --> 29:05:57,120
override this in a downstream class

43829
29:05:57,120 --> 29:06:00,080
and this class is a downstream class

43830
29:06:00,080 --> 29:06:03,360
from bird and in bird we map this method

43831
29:06:03,360 --> 29:06:05,440
as final so this is not going to work

43832
29:06:05,440 --> 29:06:07,440
even if this is virtual you want to be

43833
29:06:07,440 --> 29:06:10,232
able to really use the virtual mechanism

43834
29:06:10,232 --> 29:06:12,552
because this is final if we try to

43835
29:06:12,552 --> 29:06:15,192
inherit from this if we try to override

43836
29:06:15,192 --> 29:06:17,360
this like we are doing in pigeon here we

43837
29:06:17,360 --> 29:06:19,512
will get the compiler error let's try

43838
29:06:19,512 --> 29:06:21,600
and build our program and we will see

43839
29:06:21,600 --> 29:06:24,160
that we get our trusty compiler error

43840
29:06:24,160 --> 29:06:25,760
the bullet is going to finish with

43841
29:06:25,760 --> 29:06:28,400
errors and if we go up we're going to

43842
29:06:28,400 --> 29:06:30,960
find our error we're going to say

43843
29:06:30,960 --> 29:06:33,912
virtual function fly overriding final

43844
29:06:33,912 --> 29:06:36,800
function we are overriding a final

43845
29:06:36,800 --> 29:06:39,040
virtual method and this is going to give

43846
29:06:39,040 --> 29:06:40,960
us a compiler error we can't do this

43847
29:06:40,960 --> 29:06:42,800
this is something you can do in your c

43848
29:06:42,800 --> 29:06:44,800
plus plus program so this is really

43849
29:06:44,800 --> 29:06:47,512
confusing because in bird the virtual

43850
29:06:47,512 --> 29:06:49,512
keyword suggests that you can really

43851
29:06:49,512 --> 29:06:52,000
specialize this in downstream class but

43852
29:06:52,000 --> 29:06:54,320
this is contradictant and c plus plus

43853
29:06:54,320 --> 29:06:55,912
allows you to do this you need to be

43854
29:06:55,912 --> 29:06:58,000
aware of this again if we don't override

43855
29:06:58,000 --> 29:07:00,080
this and leave this in the code is going

43856
29:07:00,080 --> 29:07:02,960
to compile but in my opinion this is

43857
29:07:02,960 --> 29:07:05,120
really confusing and you need to be

43858
29:07:05,120 --> 29:07:06,720
aware of this that's the whole point of

43859
29:07:06,720 --> 29:07:08,400
this lecture here let's make sure the

43860
29:07:08,400 --> 29:07:10,800
code is building and this is really all

43861
29:07:10,800 --> 29:07:13,120
i had to share in this lecture

43862
29:07:13,120 --> 29:07:15,360
introducing the final keyword to you you

43863
29:07:15,360 --> 29:07:17,832
can use it to restrict how people

43864
29:07:17,832 --> 29:07:20,872
override your virtual function or you

43865
29:07:20,872 --> 29:07:22,960
can use it to restrict

43866
29:07:22,960 --> 29:07:25,440
people from inheriting from your class

43867
29:07:25,440 --> 29:07:28,080
altogether and use these things if they

43868
29:07:28,080 --> 29:07:30,552
make sense for whatever application you

43869
29:07:30,552 --> 29:07:33,440
are designing with c plus plus we are

43870
29:07:33,440 --> 29:07:35,280
going to stop here in this lecture and

43871
29:07:35,280 --> 29:07:37,192
the next one i am going to show you a

43872
29:07:37,192 --> 29:07:39,832
secret you probably didn't know so go

43873
29:07:39,832 --> 29:07:42,000
ahead and finish up here and meet me

43874
29:07:42,000 --> 29:07:43,832
there in this lecture we're going to

43875
29:07:43,832 --> 29:07:46,320
explore how virtual functions or

43876
29:07:46,320 --> 29:07:48,960
polymorphism plays with default

43877
29:07:48,960 --> 29:07:51,280
arguments and when we say default

43878
29:07:51,280 --> 29:07:53,680
arguments we mean a setup like this we

43879
29:07:53,680 --> 29:07:55,680
have a virtual function here which is

43880
29:07:55,680 --> 29:07:58,400
called add it is going to return double

43881
29:07:58,400 --> 29:07:59,760
and it has

43882
29:07:59,760 --> 29:08:02,640
default parameters here for a and b and

43883
29:08:02,640 --> 29:08:05,360
the value is five here in our derived

43884
29:08:05,360 --> 29:08:07,760
class we also have the same function we

43885
29:08:07,760 --> 29:08:10,320
are overriding that and we have a

43886
29:08:10,320 --> 29:08:13,512
different set of values acting as our

43887
29:08:13,512 --> 29:08:15,832
default parameter here we are using 10

43888
29:08:15,832 --> 29:08:19,040
for a and b here and we want to see how

43889
29:08:19,040 --> 29:08:21,832
this plays with polymorphism now please

43890
29:08:21,832 --> 29:08:24,160
note that with polymorphism if we go

43891
29:08:24,160 --> 29:08:26,160
through a base pointer to manage a

43892
29:08:26,160 --> 29:08:29,512
derived class object what we want is to

43893
29:08:29,512 --> 29:08:32,320
call the most specific implementation of

43894
29:08:32,320 --> 29:08:34,720
the virtual function here for example if

43895
29:08:34,720 --> 29:08:37,592
we have a base pointer managing a

43896
29:08:37,592 --> 29:08:40,552
derived object and we call the add

43897
29:08:40,552 --> 29:08:43,280
method from a base pointer we will get

43898
29:08:43,280 --> 29:08:46,160
the most specific method here called

43899
29:08:46,160 --> 29:08:48,720
but what you get with these default

43900
29:08:48,720 --> 29:08:51,280
arguments is that the compiler is going

43901
29:08:51,280 --> 29:08:54,640
to use static binding to decide which

43902
29:08:54,640 --> 29:08:56,400
default parameters to pass to your

43903
29:08:56,400 --> 29:08:58,872
function so even if you will get this

43904
29:08:58,872 --> 29:09:01,440
method here called the compiler will

43905
29:09:01,440 --> 29:09:04,320
still use the default arguments we have

43906
29:09:04,320 --> 29:09:06,720
in our base class so we will call this

43907
29:09:06,720 --> 29:09:09,040
method here but we will use the default

43908
29:09:09,040 --> 29:09:11,760
arguments coming from the base class and

43909
29:09:11,760 --> 29:09:13,592
this is the behavior you need to be

43910
29:09:13,592 --> 29:09:15,912
aware of okay so another way to put this

43911
29:09:15,912 --> 29:09:18,800
is that default arguments are handled at

43912
29:09:18,800 --> 29:09:21,192
compile time the compiler is going to

43913
29:09:21,192 --> 29:09:23,512
wire these things at compile time where

43914
29:09:23,512 --> 29:09:25,760
you are building your application

43915
29:09:25,760 --> 29:09:28,232
and the virtual functions are called at

43916
29:09:28,232 --> 29:09:31,280
run time with polymorphism so if you use

43917
29:09:31,280 --> 29:09:33,440
default arguments with virtual functions

43918
29:09:33,440 --> 29:09:35,832
you might get weird results with

43919
29:09:35,832 --> 29:09:38,160
polymorphism because the default

43920
29:09:38,160 --> 29:09:40,400
arguments you will be using are going to

43921
29:09:40,400 --> 29:09:43,592
be decided by static binding but the

43922
29:09:43,592 --> 29:09:45,512
actual function that you get called is

43923
29:09:45,512 --> 29:09:48,400
going to be decided by dynamic binding

43924
29:09:48,400 --> 29:09:50,800
so we will call the virtual function in

43925
29:09:50,800 --> 29:09:53,280
our derived class but we will be using

43926
29:09:53,280 --> 29:09:55,512
the default arguments from the base

43927
29:09:55,512 --> 29:09:57,592
class this is the behavior we'll get you

43928
29:09:57,592 --> 29:09:59,760
need to be aware of this and make sure

43929
29:09:59,760 --> 29:10:02,232
this is what you desire my personal

43930
29:10:02,232 --> 29:10:04,320
preference is to not use default

43931
29:10:04,320 --> 29:10:06,480
parameters or default arguments with

43932
29:10:06,480 --> 29:10:08,552
virtual functions because this is really

43933
29:10:08,552 --> 29:10:10,552
going to make my code hard to follow and

43934
29:10:10,552 --> 29:10:13,120
hard to understand especially for other

43935
29:10:13,120 --> 29:10:15,280
developers that might have to work on my

43936
29:10:15,280 --> 29:10:17,912
code base in the future okay here is a

43937
29:10:17,912 --> 29:10:20,000
simple example we have a base pointer

43938
29:10:20,000 --> 29:10:22,232
which is going to be managing a derived

43939
29:10:22,232 --> 29:10:25,120
object and we will call the add function

43940
29:10:25,120 --> 29:10:27,592
here what do we expect to get well

43941
29:10:27,592 --> 29:10:29,760
because we have polymorphism here we

43942
29:10:29,760 --> 29:10:32,400
will call the most specific add function

43943
29:10:32,400 --> 29:10:34,552
here and that's going to be the add

43944
29:10:34,552 --> 29:10:37,760
function from our derived class

43945
29:10:37,760 --> 29:10:40,160
but the default argument we pass are not

43946
29:10:40,160 --> 29:10:42,720
going to be decided by the derived class

43947
29:10:42,720 --> 29:10:44,400
the default arguments are going to be

43948
29:10:44,400 --> 29:10:47,040
plugged in at compile time using static

43949
29:10:47,040 --> 29:10:49,832
binding so because the base pointer is a

43950
29:10:49,832 --> 29:10:52,232
base object we will be using the default

43951
29:10:52,232 --> 29:10:54,160
arguments from the base implementation

43952
29:10:54,160 --> 29:10:56,480
of the add method so we will just plug

43953
29:10:56,480 --> 29:10:59,192
in five and five so we will add five to

43954
29:10:59,192 --> 29:11:02,232
five and add a two that's why we get a

43955
29:11:02,232 --> 29:11:04,400
12 right here

43956
29:11:04,400 --> 29:11:06,872
and if we go through these references we

43957
29:11:06,872 --> 29:11:09,280
will get the same result because this is

43958
29:11:09,280 --> 29:11:12,720
going to enable or trigger polymorphic

43959
29:11:12,720 --> 29:11:15,912
behavior in our c-plus programs if we go

43960
29:11:15,912 --> 29:11:18,552
through direct objects we will be doing

43961
29:11:18,552 --> 29:11:21,040
static binding and we will use the

43962
29:11:21,040 --> 29:11:23,360
default arguments or device parameters

43963
29:11:23,360 --> 29:11:25,680
from our derived object and remember

43964
29:11:25,680 --> 29:11:27,680
that we use the value of 10 in there so

43965
29:11:27,680 --> 29:11:30,160
we are going to add 10 to 10 and add a 2

43966
29:11:30,160 --> 29:11:32,480
and we are going to get a 22 as you see

43967
29:11:32,480 --> 29:11:35,440
here through static binding if we do

43968
29:11:35,440 --> 29:11:38,552
slicing by assigning a derived object to

43969
29:11:38,552 --> 29:11:41,280
a base object the derived information is

43970
29:11:41,280 --> 29:11:44,160
going to be sliced off and if we add we

43971
29:11:44,160 --> 29:11:46,480
will use the default parameters from the

43972
29:11:46,480 --> 29:11:48,640
base class and we will use the

43973
29:11:48,640 --> 29:11:51,040
implementation in the base class so if

43974
29:11:51,040 --> 29:11:53,760
we come back to our code here we will

43975
29:11:53,760 --> 29:11:55,760
use the default arguments from the base

43976
29:11:55,760 --> 29:11:57,760
class and that's a five and a five we're

43977
29:11:57,760 --> 29:11:59,680
going to add them up because the body is

43978
29:11:59,680 --> 29:12:02,080
going to be from the base class remember

43979
29:12:02,080 --> 29:12:04,080
the derived information has been

43980
29:12:04,080 --> 29:12:07,120
completely sliced off so we are going to

43981
29:12:07,120 --> 29:12:09,040
add a five and a five and a one and

43982
29:12:09,040 --> 29:12:11,360
we're going to get 11 printed out if we

43983
29:12:11,360 --> 29:12:14,480
do slicing and that's the result we get

43984
29:12:14,480 --> 29:12:16,640
right here as a closing note before we

43985
29:12:16,640 --> 29:12:19,120
head over to visual studio code again

43986
29:12:19,120 --> 29:12:21,192
default arguments with virtual functions

43987
29:12:21,192 --> 29:12:23,440
can be very confusing they are best

43988
29:12:23,440 --> 29:12:25,680
avoided because they really are going to

43989
29:12:25,680 --> 29:12:28,320
give a hard time to anybody that is

43990
29:12:28,320 --> 29:12:30,232
going to be working on your code in the

43991
29:12:30,232 --> 29:12:31,832
future now that you know this we're

43992
29:12:31,832 --> 29:12:33,832
going to head over to visual studio code

43993
29:12:33,832 --> 29:12:35,440
and play with this a little more here we

43994
29:12:35,440 --> 29:12:38,080
are in our working folder the current

43995
29:12:38,080 --> 29:12:40,552
project is virtual functions with

43996
29:12:40,552 --> 29:12:42,400
default arguments we're going to grab

43997
29:12:42,400 --> 29:12:45,040
the code from our template project we're

43998
29:12:45,040 --> 29:12:47,040
going to copy this and put this in the

43999
29:12:47,040 --> 29:12:49,680
current project and i am going to grab

44000
29:12:49,680 --> 29:12:52,232
my classes base and derived that we are

44001
29:12:52,232 --> 29:12:54,640
going to be using here if you don't want

44002
29:12:54,640 --> 29:12:56,800
to type along you can grab the source

44003
29:12:56,800 --> 29:12:59,040
code from the resource section of the

44004
29:12:59,040 --> 29:13:00,000
course

44005
29:13:00,000 --> 29:13:01,680
if you don't want to type all these

44006
29:13:01,680 --> 29:13:04,160
classes or create them you can grab the

44007
29:13:04,160 --> 29:13:07,192
source code from the resource section on

44008
29:13:07,192 --> 29:13:08,552
this lecture you're going to download

44009
29:13:08,552 --> 29:13:10,552
this and use this you don't have to

44010
29:13:10,552 --> 29:13:12,720
waste time typing these things because

44011
29:13:12,720 --> 29:13:15,120
many of these things are already

44012
29:13:15,120 --> 29:13:17,280
familiar to you we're going to open this

44013
29:13:17,280 --> 29:13:19,040
in visual studio code and we're going to

44014
29:13:19,040 --> 29:13:21,360
have our classes here we have a base

44015
29:13:21,360 --> 29:13:23,440
class which is going to have a virtual

44016
29:13:23,440 --> 29:13:24,552
function

44017
29:13:24,552 --> 29:13:25,440
with

44018
29:13:25,440 --> 29:13:28,400
a pair of default arguments here we are

44019
29:13:28,400 --> 29:13:31,192
using 5 5 in our ad

44020
29:13:31,192 --> 29:13:33,120
virtual function here

44021
29:13:33,120 --> 29:13:35,440
and if we go and derived it is going to

44022
29:13:35,440 --> 29:13:38,000
derive publicly from base and it is

44023
29:13:38,000 --> 29:13:40,232
going to override our

44024
29:13:40,232 --> 29:13:42,872
virtual function here but notice that it

44025
29:13:42,872 --> 29:13:45,040
is going to set up its own

44026
29:13:45,040 --> 29:13:47,192
default parameters so if we do

44027
29:13:47,192 --> 29:13:49,040
polymorphism

44028
29:13:49,040 --> 29:13:51,192
and use the base pointer to call the add

44029
29:13:51,192 --> 29:13:53,440
method here we will get the most

44030
29:13:53,440 --> 29:13:56,872
specific or the most specialized version

44031
29:13:56,872 --> 29:13:58,960
of the add method called and this is

44032
29:13:58,960 --> 29:14:01,040
going to call this body here

44033
29:14:01,040 --> 29:14:03,592
but the parameters are going to be

44034
29:14:03,592 --> 29:14:06,400
decided by static binding so because we

44035
29:14:06,400 --> 29:14:08,960
will be going through a base pointer we

44036
29:14:08,960 --> 29:14:11,192
will use the default arguments from the

44037
29:14:11,192 --> 29:14:13,832
base class that's going to be five five

44038
29:14:13,832 --> 29:14:15,120
and we're going to play with this and

44039
29:14:15,120 --> 29:14:17,192
see what this is going to give us in the

44040
29:14:17,192 --> 29:14:19,912
main cpp file here let's clean up a

44041
29:14:19,912 --> 29:14:21,120
little bit we're going to remove

44042
29:14:21,120 --> 29:14:23,192
whatever we don't need here

44043
29:14:23,192 --> 29:14:25,680
and we are going to include our derived

44044
29:14:25,680 --> 29:14:28,160
class we can do that we are going to put

44045
29:14:28,160 --> 29:14:30,552
in our code to really play with us let's

44046
29:14:30,552 --> 29:14:32,552
remove these spaces because we don't

44047
29:14:32,552 --> 29:14:34,720
need them we are going to go through a

44048
29:14:34,720 --> 29:14:37,440
base pointer to manage a derived object

44049
29:14:37,440 --> 29:14:39,760
and this is a setup we can use to put

44050
29:14:39,760 --> 29:14:41,832
things in place here we are going to

44051
29:14:41,832 --> 29:14:44,160
call the add method notice that we are

44052
29:14:44,160 --> 29:14:46,720
not passing in any parameter because we

44053
29:14:46,720 --> 29:14:48,960
are going through a base pointer and the

44054
29:14:48,960 --> 29:14:51,080
add method is virtual

44055
29:14:51,080 --> 29:14:53,592
polymorphism will kick in and we will

44056
29:14:53,592 --> 29:14:55,680
get the derived version

44057
29:14:55,680 --> 29:14:59,440
of our add function code so we will call

44058
29:14:59,440 --> 29:15:02,000
this add function here but

44059
29:15:02,000 --> 29:15:04,232
be careful because we want to be using

44060
29:15:04,232 --> 29:15:06,872
these default parameters here if we did

44061
29:15:06,872 --> 29:15:10,320
we would add a 10 to a 10 and get to 22

44062
29:15:10,320 --> 29:15:12,720
in our main function here but that's not

44063
29:15:12,720 --> 29:15:14,960
going to be the case the compiler is

44064
29:15:14,960 --> 29:15:17,512
going to use static binding to decide

44065
29:15:17,512 --> 29:15:20,080
which default parameters to use either

44066
29:15:20,080 --> 29:15:22,080
those in the base class or those in the

44067
29:15:22,080 --> 29:15:24,480
derived class and notice that if we

44068
29:15:24,480 --> 29:15:26,872
hover over this add function you see

44069
29:15:26,872 --> 29:15:29,360
that the compiler has plugged down those

44070
29:15:29,360 --> 29:15:31,280
from the base class and that's what the

44071
29:15:31,280 --> 29:15:32,800
compiler is going to do so it is going

44072
29:15:32,800 --> 29:15:35,280
to add a five to a five and it is going

44073
29:15:35,280 --> 29:15:37,280
to add two to that i think that's what

44074
29:15:37,280 --> 29:15:40,552
we are doing in our derived version and

44075
29:15:40,552 --> 29:15:43,192
we are going to get to 12 printed out

44076
29:15:43,192 --> 29:15:45,512
let's build and see if this is actually

44077
29:15:45,512 --> 29:15:46,872
the case we're going to pass this

44078
29:15:46,872 --> 29:15:48,552
through gcc

44079
29:15:48,552 --> 29:15:51,040
and that's the compiler that is our

44080
29:15:51,040 --> 29:15:53,192
favorite now the book is going to be

44081
29:15:53,192 --> 29:15:55,680
good we can close this and bring up a

44082
29:15:55,680 --> 29:15:58,720
powershell window and if we run rooster

44083
29:15:58,720 --> 29:16:00,800
we're going to see that the arrived ad

44084
29:16:00,800 --> 29:16:03,680
was called and the result was 12 here

44085
29:16:03,680 --> 29:16:05,760
this is what we get again

44086
29:16:05,760 --> 29:16:08,080
the compiler is going to call the most

44087
29:16:08,080 --> 29:16:11,512
specialized virtual function override

44088
29:16:11,512 --> 29:16:14,320
here but it is going to use the default

44089
29:16:14,320 --> 29:16:16,400
parameters from the base class you

44090
29:16:16,400 --> 29:16:18,872
should really note this and this can

44091
29:16:18,872 --> 29:16:20,960
really be confusing especially if you

44092
29:16:20,960 --> 29:16:24,640
are a beginner to polymorphism if we go

44093
29:16:24,640 --> 29:16:27,040
through a base reference we will also

44094
29:16:27,040 --> 29:16:29,360
get polymorphic behavior

44095
29:16:29,360 --> 29:16:31,760
so if we have a derived object and we

44096
29:16:31,760 --> 29:16:34,232
set up a reference to that which is of

44097
29:16:34,232 --> 29:16:36,640
type base and we go through that base

44098
29:16:36,640 --> 29:16:38,720
reference and called the add method we

44099
29:16:38,720 --> 29:16:40,640
will get the most specialized add

44100
29:16:40,640 --> 29:16:42,480
version called so that's going to be

44101
29:16:42,480 --> 29:16:46,552
derived and but we will use the default

44102
29:16:46,552 --> 29:16:48,872
parameters from the base class because

44103
29:16:48,872 --> 29:16:50,872
which default arguments we use is

44104
29:16:50,872 --> 29:16:54,160
decided by using static binding that's

44105
29:16:54,160 --> 29:16:56,160
what we get here and official studio

44106
29:16:56,160 --> 29:16:58,160
code is really helpful here because if

44107
29:16:58,160 --> 29:17:00,232
we hover over the add function we're

44108
29:17:00,232 --> 29:17:02,480
going to see which default parameters

44109
29:17:02,480 --> 29:17:04,640
were plugged in by the compiler and you

44110
29:17:04,640 --> 29:17:06,960
see that they are those from the base

44111
29:17:06,960 --> 29:17:09,120
class so we are again going to add five

44112
29:17:09,120 --> 29:17:11,360
to a five and we are going to add a two

44113
29:17:11,360 --> 29:17:14,480
and we will get 12 printed out here if

44114
29:17:14,480 --> 29:17:16,320
we boil and run we're going to see that

44115
29:17:16,320 --> 29:17:18,800
this is the case the build is good we

44116
29:17:18,800 --> 29:17:20,000
can clear

44117
29:17:20,000 --> 29:17:21,912
and run rooster we're going to see that

44118
29:17:21,912 --> 29:17:23,680
with a base reference we're also going

44119
29:17:23,680 --> 29:17:26,872
to get a 12. we will get the most

44120
29:17:26,872 --> 29:17:28,232
specific

44121
29:17:28,232 --> 29:17:31,360
implementation of the add method called

44122
29:17:31,360 --> 29:17:33,832
but we will plug in the default

44123
29:17:33,832 --> 29:17:35,912
parameters from the base class i really

44124
29:17:35,912 --> 29:17:38,872
wanted this to be super clear if you set

44125
29:17:38,872 --> 29:17:40,720
up things in a way that you are going to

44126
29:17:40,720 --> 29:17:43,360
get static binding then if you are going

44127
29:17:43,360 --> 29:17:45,832
through a base object you will call the

44128
29:17:45,832 --> 29:17:48,080
base version of the add method and you

44129
29:17:48,080 --> 29:17:50,232
will use the default parameters from the

44130
29:17:50,232 --> 29:17:52,080
base class if you happen to be

44131
29:17:52,080 --> 29:17:54,960
manipulating a derived object you will

44132
29:17:54,960 --> 29:17:57,280
use the information in the derived class

44133
29:17:57,280 --> 29:17:59,512
the derived version of the add method is

44134
29:17:59,512 --> 29:18:01,280
going to be called and we are going to

44135
29:18:01,280 --> 29:18:03,680
use the default argument from the

44136
29:18:03,680 --> 29:18:06,960
derived class so if we set up another

44137
29:18:06,960 --> 29:18:09,192
example here we can set up a base object

44138
29:18:09,192 --> 29:18:11,592
for example we're going to say base and

44139
29:18:11,592 --> 29:18:13,040
say base

44140
29:18:13,040 --> 29:18:16,232
3 we can do that and we try to call the

44141
29:18:16,232 --> 29:18:19,120
add method we can say base 3 and say add

44142
29:18:19,120 --> 29:18:21,192
we can try and store this in our

44143
29:18:21,192 --> 29:18:23,360
research variable and we can print this

44144
29:18:23,360 --> 29:18:26,080
out we're going to say sdbcl row

44145
29:18:26,080 --> 29:18:28,480
research we can say something like this

44146
29:18:28,480 --> 29:18:30,552
and we're going to print out the result

44147
29:18:30,552 --> 29:18:32,480
here if we build and run we're going to

44148
29:18:32,480 --> 29:18:34,480
see that this is going to call

44149
29:18:34,480 --> 29:18:36,800
the base version of the add method and

44150
29:18:36,800 --> 29:18:38,232
it is going to use the default

44151
29:18:38,232 --> 29:18:40,960
parameters from the base if we go back

44152
29:18:40,960 --> 29:18:42,720
to base we're going to see that we are

44153
29:18:42,720 --> 29:18:46,000
going to add a 5 to a 5 and we will get

44154
29:18:46,000 --> 29:18:49,040
11 because we will plug in a 1 and

44155
29:18:49,040 --> 29:18:51,512
return the result here let's build and

44156
29:18:51,512 --> 29:18:53,592
run and see that this is actually the

44157
29:18:53,592 --> 29:18:55,832
case so this is going to be completely

44158
29:18:55,832 --> 29:18:58,800
doing static binding let's clear and run

44159
29:18:58,800 --> 29:19:00,400
you see that the world is good we're

44160
29:19:00,400 --> 29:19:02,160
going to run restaurant and we will get

44161
29:19:02,160 --> 29:19:04,400
11 printed out here hopefully you can

44162
29:19:04,400 --> 29:19:07,680
see this if you assign a derived object

44163
29:19:07,680 --> 29:19:08,552
to

44164
29:19:08,552 --> 29:19:11,680
a base object you will get slicing

44165
29:19:11,680 --> 29:19:14,000
let's see that we can actually do this

44166
29:19:14,000 --> 29:19:16,800
but before we do that i also want you to

44167
29:19:16,800 --> 29:19:19,040
see that you can also do

44168
29:19:19,040 --> 29:19:22,232
row direct objects of derived classes if

44169
29:19:22,232 --> 29:19:24,000
you do this you will

44170
29:19:24,000 --> 29:19:26,320
get the information from the derived

44171
29:19:26,320 --> 29:19:28,232
class we will use the body from the

44172
29:19:28,232 --> 29:19:30,872
derived class and we will use the

44173
29:19:30,872 --> 29:19:32,640
default parameters from the derived

44174
29:19:32,640 --> 29:19:35,680
class so we will take 10 and add a 10

44175
29:19:35,680 --> 29:19:37,832
and we will add the 2 to that and we

44176
29:19:37,832 --> 29:19:40,800
will get a 22 printed out i think we can

44177
29:19:40,800 --> 29:19:42,480
do this

44178
29:19:42,480 --> 29:19:43,280
so

44179
29:19:43,280 --> 29:19:45,760
let's put in a separator because that's

44180
29:19:45,760 --> 29:19:47,832
going to make it easier to follow these

44181
29:19:47,832 --> 29:19:50,160
lengths and we're going to build with

44182
29:19:50,160 --> 29:19:52,640
the gcc the both is going to be good

44183
29:19:52,640 --> 29:19:53,832
hopefully

44184
29:19:53,832 --> 29:19:56,160
the bulk is good we can clear

44185
29:19:56,160 --> 29:19:58,080
and run rooster and we're going to see

44186
29:19:58,080 --> 29:20:01,512
that we get a 22 here if we assign a

44187
29:20:01,512 --> 29:20:04,552
derived object to a base object directly

44188
29:20:04,552 --> 29:20:06,640
by doing something like this event we

44189
29:20:06,640 --> 29:20:09,040
don't need this guy here

44190
29:20:09,040 --> 29:20:12,400
we can remove this we have a base object

44191
29:20:12,400 --> 29:20:15,040
that we are setting up here and we are

44192
29:20:15,040 --> 29:20:17,512
assigning a derived object to this base

44193
29:20:17,512 --> 29:20:18,800
object here

44194
29:20:18,800 --> 29:20:21,440
if we call the add method we will get

44195
29:20:21,440 --> 29:20:24,080
the version from the base class because

44196
29:20:24,080 --> 29:20:26,480
mind your steps this is going to slice

44197
29:20:26,480 --> 29:20:29,120
off all the derived information because

44198
29:20:29,120 --> 29:20:31,040
we are not going through any kind of

44199
29:20:31,040 --> 29:20:32,960
base or reference so this is going to

44200
29:20:32,960 --> 29:20:35,680
slice off all the information we have in

44201
29:20:35,680 --> 29:20:37,192
the derived

44202
29:20:37,192 --> 29:20:39,760
object here and we will be left with the

44203
29:20:39,760 --> 29:20:42,552
base information and if we call the add

44204
29:20:42,552 --> 29:20:44,720
function here you see that we are using

44205
29:20:44,720 --> 29:20:46,480
the default parameters from the base

44206
29:20:46,480 --> 29:20:49,680
class and we will use the body of the

44207
29:20:49,680 --> 29:20:51,912
base class implementation here so we

44208
29:20:51,912 --> 29:20:54,872
will add a 5 to a 5 and we will add 1 to

44209
29:20:54,872 --> 29:20:57,592
that and we will get 11 printed out as

44210
29:20:57,592 --> 29:20:59,680
we see here let's build and actually

44211
29:20:59,680 --> 29:21:01,120
prove this we're going to pass this

44212
29:21:01,120 --> 29:21:02,960
through gcc the world is going to be

44213
29:21:02,960 --> 29:21:05,512
good we can clear and run rooster and we

44214
29:21:05,512 --> 29:21:07,760
are going to see that the result is

44215
29:21:07,760 --> 29:21:11,040
irreverent if we do row object

44216
29:21:11,040 --> 29:21:12,960
assignment here this is really all i

44217
29:21:12,960 --> 29:21:15,360
wanted you to see in this lecture that

44218
29:21:15,360 --> 29:21:17,440
you should really be careful if you are

44219
29:21:17,440 --> 29:21:19,440
using virtual functions

44220
29:21:19,440 --> 29:21:22,000
mixed up with default arguments the

44221
29:21:22,000 --> 29:21:24,232
compiler is not going to do dynamic

44222
29:21:24,232 --> 29:21:26,640
binding on the default parameters it is

44223
29:21:26,640 --> 29:21:29,360
going to decide which default parameters

44224
29:21:29,360 --> 29:21:32,960
to plug in at compile time using static

44225
29:21:32,960 --> 29:21:34,720
binding so the compiler is basically

44226
29:21:34,720 --> 29:21:36,960
going to look at the type of the pointer

44227
29:21:36,960 --> 29:21:39,592
or object that you have and it is going

44228
29:21:39,592 --> 29:21:41,760
to use that to decide which default

44229
29:21:41,760 --> 29:21:44,552
parameters to plug in so at this example

44230
29:21:44,552 --> 29:21:46,552
here for example at line 7 it is going

44231
29:21:46,552 --> 29:21:49,040
to see what kind of pointer do i have i

44232
29:21:49,040 --> 29:21:50,960
have a base pointer so i am going to use

44233
29:21:50,960 --> 29:21:53,360
the default parameters from the base

44234
29:21:53,360 --> 29:21:55,440
implementation and if you hover over

44235
29:21:55,440 --> 29:21:56,720
here you're going to see that it is

44236
29:21:56,720 --> 29:21:59,040
going to plug in a 5 and a 5. even if we

44237
29:21:59,040 --> 29:22:01,280
are using the most specialized add

44238
29:22:01,280 --> 29:22:04,160
version in our inheritance hierarchy the

44239
29:22:04,160 --> 29:22:06,000
compiler is going to still use the

44240
29:22:06,000 --> 29:22:08,232
default argument from the base

44241
29:22:08,232 --> 29:22:11,040
implementation down here on line 16 the

44242
29:22:11,040 --> 29:22:13,120
compiler is going to say which kind of

44243
29:22:13,120 --> 29:22:15,040
reference do i have it's going to say

44244
29:22:15,040 --> 29:22:17,280
base because that's what we have here so

44245
29:22:17,280 --> 29:22:18,720
it is going to use the default

44246
29:22:18,720 --> 29:22:21,280
parameters from base and that's what it

44247
29:22:21,280 --> 29:22:23,280
is going to plug in here 5 and 5 and

44248
29:22:23,280 --> 29:22:25,512
we're going to get this result here

44249
29:22:25,512 --> 29:22:28,232
down here on line 25 the compiler is

44250
29:22:28,232 --> 29:22:30,160
going to see which kind of object do i

44251
29:22:30,160 --> 29:22:32,872
have here this three is a base so i am

44252
29:22:32,872 --> 29:22:35,120
going to use the default parameters from

44253
29:22:35,120 --> 29:22:36,160
base

44254
29:22:36,160 --> 29:22:39,120
down below on line 31 the compiler is

44255
29:22:39,120 --> 29:22:40,552
going to look and see

44256
29:22:40,552 --> 29:22:42,800
which kind of object do i have here the

44257
29:22:42,800 --> 29:22:45,760
object is derived so i will plug in the

44258
29:22:45,760 --> 29:22:48,000
default parameters for it derived again

44259
29:22:48,000 --> 29:22:49,440
this is really what the compiler is

44260
29:22:49,440 --> 29:22:52,160
going to do with default parameters the

44261
29:22:52,160 --> 29:22:54,720
compiler is never going to do dynamic

44262
29:22:54,720 --> 29:22:56,800
binding and this is going to make your

44263
29:22:56,800 --> 29:23:00,160
code really confusing again my advice is

44264
29:23:00,160 --> 29:23:03,440
to avoid default arguments or devote

44265
29:23:03,440 --> 29:23:06,800
parameters if you are using polymorphism

44266
29:23:06,800 --> 29:23:09,512
in your inheritance hierarchy we are

44267
29:23:09,512 --> 29:23:11,592
going to stop here in this lecture and

44268
29:23:11,592 --> 29:23:13,440
the next one we're going to learn about

44269
29:23:13,440 --> 29:23:15,512
virtual destructors

44270
29:23:15,512 --> 29:23:17,832
go ahead and finish up here and meet me

44271
29:23:17,832 --> 29:23:19,832
there in this lecture we are going to

44272
29:23:19,832 --> 29:23:23,192
explore virtual destructors and these

44273
29:23:23,192 --> 29:23:25,832
are destructor methods you might want to

44274
29:23:25,832 --> 29:23:27,040
be called

44275
29:23:27,040 --> 29:23:30,400
using dynamic binding or polymorphic

44276
29:23:30,400 --> 29:23:31,592
behavior

44277
29:23:31,592 --> 29:23:33,040
we are going to be using this

44278
29:23:33,040 --> 29:23:34,800
inheritance hierarchy to play with

44279
29:23:34,800 --> 29:23:36,400
thanks so the animal class is going to

44280
29:23:36,400 --> 29:23:38,552
be our base class we are going to derive

44281
29:23:38,552 --> 29:23:41,040
from that publicly and have a feline

44282
29:23:41,040 --> 29:23:43,832
class and we are going to derive from

44283
29:23:43,832 --> 29:23:46,552
feline and have a dog class this is the

44284
29:23:46,552 --> 29:23:49,280
setup we are going to be using here

44285
29:23:49,280 --> 29:23:51,592
now let's look at some code we are going

44286
29:23:51,592 --> 29:23:53,760
to set up our animal class like there's

44287
29:23:53,760 --> 29:23:56,232
nothing really special here notice that

44288
29:23:56,232 --> 29:23:58,400
the destructor is a regular destructor

44289
29:23:58,400 --> 29:23:59,512
we have

44290
29:23:59,512 --> 29:24:03,192
we will derive from animal and create a

44291
29:24:03,192 --> 29:24:05,440
feline class which is going to set up

44292
29:24:05,440 --> 29:24:07,280
its own virtual function which is going

44293
29:24:07,280 --> 29:24:10,160
to be run if you want you can override

44294
29:24:10,160 --> 29:24:12,160
the breathe method but we don't want to

44295
29:24:12,160 --> 29:24:14,480
do that here because we just want to

44296
29:24:14,480 --> 29:24:15,512
focus

44297
29:24:15,512 --> 29:24:18,640
on the destructors here and the order in

44298
29:24:18,640 --> 29:24:20,960
which they are going to be called we are

44299
29:24:20,960 --> 29:24:23,832
going to derive from feline and set up a

44300
29:24:23,832 --> 29:24:26,552
dog class and this dog class is going to

44301
29:24:26,552 --> 29:24:29,040
set up its own virtual function and

44302
29:24:29,040 --> 29:24:31,120
notice that it has a destructor which is

44303
29:24:31,120 --> 29:24:33,680
really a regular destructor now once we

44304
29:24:33,680 --> 29:24:36,160
have this inheritance hierarchy set up

44305
29:24:36,160 --> 29:24:38,480
we might want to do something like this

44306
29:24:38,480 --> 29:24:40,552
we can create a dark object

44307
29:24:40,552 --> 29:24:43,512
and when it is time for this object to

44308
29:24:43,512 --> 29:24:46,640
be destroyed i want you to focus on the

44309
29:24:46,640 --> 29:24:48,552
order in which the destructors are going

44310
29:24:48,552 --> 29:24:50,800
to be called we have seen this before

44311
29:24:50,800 --> 29:24:53,192
the destructors are going to be called

44312
29:24:53,192 --> 29:24:56,640
from the specialized to the most base

44313
29:24:56,640 --> 29:24:58,872
implementation of the destructor so the

44314
29:24:58,872 --> 29:25:01,440
destructor for doug will be called first

44315
29:25:01,440 --> 29:25:03,192
then we will call the destructor for

44316
29:25:03,192 --> 29:25:05,760
feline then we will call the destructor

44317
29:25:05,760 --> 29:25:08,320
for animal now a problem is going to pop

44318
29:25:08,320 --> 29:25:11,192
up if we are using a base pointer to

44319
29:25:11,192 --> 29:25:14,480
manage a derived object with polymorphic

44320
29:25:14,480 --> 29:25:16,720
behavior that we might want for our

44321
29:25:16,720 --> 29:25:18,960
inheritance hierarchy here so we are

44322
29:25:18,960 --> 29:25:21,192
going to use an animal pointer to manage

44323
29:25:21,192 --> 29:25:23,680
a dark object like this and when it is

44324
29:25:23,680 --> 29:25:25,512
time to release the memory for this

44325
29:25:25,512 --> 29:25:26,720
object

44326
29:25:26,720 --> 29:25:29,912
we may be tempted to call the delete

44327
29:25:29,912 --> 29:25:33,040
operator on our animal pointer here but

44328
29:25:33,040 --> 29:25:34,720
this is only going to call the

44329
29:25:34,720 --> 29:25:36,000
destructor

44330
29:25:36,000 --> 29:25:38,800
for the base class and hopefully you can

44331
29:25:38,800 --> 29:25:41,040
see the problem here because our

44332
29:25:41,040 --> 29:25:44,232
destructors are not virtual the compiler

44333
29:25:44,232 --> 29:25:46,720
is going to use static binding to decide

44334
29:25:46,720 --> 29:25:48,960
which destructor to call so it is going

44335
29:25:48,960 --> 29:25:50,872
to look at the type of a pointer it is

44336
29:25:50,872 --> 29:25:52,232
going to see that it is an animal

44337
29:25:52,232 --> 29:25:54,000
pointer and it is going to decide to

44338
29:25:54,000 --> 29:25:56,872
call the destructor for animal here

44339
29:25:56,872 --> 29:25:59,120
that's why we get this reserve we are

44340
29:25:59,120 --> 29:26:01,440
managing an object which is not just an

44341
29:26:01,440 --> 29:26:04,160
animal it has derived information in it

44342
29:26:04,160 --> 29:26:06,800
but we are only calling the destructor

44343
29:26:06,800 --> 29:26:09,592
for the base part of this stun so any

44344
29:26:09,592 --> 29:26:11,680
piece of dynamic memory we might have

44345
29:26:11,680 --> 29:26:14,800
allocated in the constructors for feline

44346
29:26:14,800 --> 29:26:17,512
or dog is going to be leaked out because

44347
29:26:17,512 --> 29:26:20,480
remember even if this is a dark object

44348
29:26:20,480 --> 29:26:22,552
it is made up of base parts the

44349
29:26:22,552 --> 29:26:24,552
foundation for this is going to be

44350
29:26:24,552 --> 29:26:26,800
animal and on top of that we are going

44351
29:26:26,800 --> 29:26:29,440
to build a feline level and on top of

44352
29:26:29,440 --> 29:26:31,912
that we are going to build a dog level

44353
29:26:31,912 --> 29:26:34,160
in this case only the destructor for dog

44354
29:26:34,160 --> 29:26:37,512
is going to be called and any dynamic

44355
29:26:37,512 --> 29:26:40,232
memory that might have been allocated at

44356
29:26:40,232 --> 29:26:43,512
the feline and dog level is going to be

44357
29:26:43,512 --> 29:26:45,280
leaked out and this is something we

44358
29:26:45,280 --> 29:26:47,192
don't want you really need to keep your

44359
29:26:47,192 --> 29:26:49,512
eye out on this and this is something

44360
29:26:49,512 --> 29:26:51,360
really bad you really need to keep your

44361
29:26:51,360 --> 29:26:53,832
eye out for this so this is really a big

44362
29:26:53,832 --> 29:26:55,912
problem and to solve it we need the

44363
29:26:55,912 --> 29:26:58,400
destructors to be called using

44364
29:26:58,400 --> 29:27:01,280
polymorphism and you can set that up by

44365
29:27:01,280 --> 29:27:04,640
marking your destructors as a virtual if

44366
29:27:04,640 --> 29:27:06,872
you do this the compiler will know

44367
29:27:06,872 --> 29:27:08,872
that if you are going through a base

44368
29:27:08,872 --> 29:27:11,592
pointer to manage a derived object when

44369
29:27:11,592 --> 29:27:13,592
the time comes for the memory to be

44370
29:27:13,592 --> 29:27:15,512
released and you release the memory

44371
29:27:15,512 --> 29:27:17,912
through a base pointer the compiler is

44372
29:27:17,912 --> 29:27:19,912
going to call the most specific

44373
29:27:19,912 --> 29:27:22,320
destructor it can find and this is going

44374
29:27:22,320 --> 29:27:24,800
to solve our problem then we will reuse

44375
29:27:24,800 --> 29:27:27,192
the order we are familiar with the most

44376
29:27:27,192 --> 29:27:29,912
derived destructor will be called and it

44377
29:27:29,912 --> 29:27:32,160
will call its best destructor and that's

44378
29:27:32,160 --> 29:27:34,000
going to happen until we hit the most

44379
29:27:34,000 --> 29:27:36,720
base class in our inheritance hierarchy

44380
29:27:36,720 --> 29:27:38,480
and the memory is going to be released

44381
29:27:38,480 --> 29:27:40,640
exactly as we would want now that you

44382
29:27:40,640 --> 29:27:42,000
know this we're going to head over to

44383
29:27:42,000 --> 29:27:43,832
visual studio code and play with us a

44384
29:27:43,832 --> 29:27:46,552
little more here we are in our working

44385
29:27:46,552 --> 29:27:48,232
folder we are going to learn about

44386
29:27:48,232 --> 29:27:50,720
virtual destructors and before we do

44387
29:27:50,720 --> 29:27:52,720
that we're going to grab our template

44388
29:27:52,720 --> 29:27:55,280
files and put them in place let's do

44389
29:27:55,280 --> 29:27:57,280
that and i am going to put in the

44390
29:27:57,280 --> 29:27:59,680
classes that make up our inheritance

44391
29:27:59,680 --> 29:28:02,000
hierarchy our most based class is going

44392
29:28:02,000 --> 29:28:04,552
to be base our most based class is going

44393
29:28:04,552 --> 29:28:06,480
to be animal after that we're going to

44394
29:28:06,480 --> 29:28:08,720
derive we are going to derive from that

44395
29:28:08,720 --> 29:28:11,192
and create the feline class and we are

44396
29:28:11,192 --> 29:28:13,592
going to derive from feline and create a

44397
29:28:13,592 --> 29:28:16,160
dog class here this is the inheritance

44398
29:28:16,160 --> 29:28:18,552
hierarchy we talked about in our slides

44399
29:28:18,552 --> 29:28:20,400
okay we are going to open this up in

44400
29:28:20,400 --> 29:28:22,640
visual studio code and this is going to

44401
29:28:22,640 --> 29:28:25,360
give us our classes here and we are

44402
29:28:25,360 --> 29:28:27,440
going to remove these virtual keywords

44403
29:28:27,440 --> 29:28:29,192
because we want to see

44404
29:28:29,192 --> 29:28:31,912
what would happen if you don't mark your

44405
29:28:31,912 --> 29:28:34,400
destructors as a virtual we're going to

44406
29:28:34,400 --> 29:28:36,232
do that for feline we're going to do

44407
29:28:36,232 --> 29:28:38,480
that for doug let's remove the virtual

44408
29:28:38,480 --> 29:28:40,640
keyword here we're going to remove that

44409
29:28:40,640 --> 29:28:42,480
and we're going to remove that for the

44410
29:28:42,480 --> 29:28:44,800
animal class and we want to see the

44411
29:28:44,800 --> 29:28:47,192
implementations for our destructors for

44412
29:28:47,192 --> 29:28:49,512
animal we are just going to say that the

44413
29:28:49,512 --> 29:28:52,160
destructor for animal was called for

44414
29:28:52,160 --> 29:28:53,912
feline we're going to say the same thing

44415
29:28:53,912 --> 29:28:56,000
feline destructor called for doubt we're

44416
29:28:56,000 --> 29:28:57,680
going to say the same thing we're going

44417
29:28:57,680 --> 29:29:00,800
to say destructor for dog called here

44418
29:29:00,800 --> 29:29:04,640
we are using strengths as our parameters

44419
29:29:04,640 --> 29:29:07,040
here so i think it is a good idea to

44420
29:29:07,040 --> 29:29:09,192
change these guys to use string view i

44421
29:29:09,192 --> 29:29:10,400
am going to do that

44422
29:29:10,400 --> 29:29:12,552
and come back when this is done

44423
29:29:12,552 --> 29:29:15,280
okay this is done all our parameters are

44424
29:29:15,280 --> 29:29:18,552
of std string view type and now that we

44425
29:29:18,552 --> 29:29:20,872
have this inheritance hierarchy let's

44426
29:29:20,872 --> 29:29:23,680
make sure none of the destructors is

44427
29:29:23,680 --> 29:29:26,232
virtual this is the case here we can

44428
29:29:26,232 --> 29:29:29,592
head over to the main cpp file and use

44429
29:29:29,592 --> 29:29:31,760
this inheritance hierarchy here we're

44430
29:29:31,760 --> 29:29:34,160
going to crack it open and remove

44431
29:29:34,160 --> 29:29:36,640
whatever we don't need here

44432
29:29:36,640 --> 29:29:40,000
we are going to include our dog class

44433
29:29:40,000 --> 29:29:42,872
which is going to implicitly include or

44434
29:29:42,872 --> 29:29:44,800
its parent classes so we're going to

44435
29:29:44,800 --> 29:29:47,592
include dog.h here and we are going to

44436
29:29:47,592 --> 29:29:50,160
create a row.object by default here

44437
29:29:50,160 --> 29:29:52,400
we're going to say dog and let's say dog

44438
29:29:52,400 --> 29:29:55,040
one we can do that and we might not even

44439
29:29:55,040 --> 29:29:57,512
give it any parameter this is going to

44440
29:29:57,512 --> 29:29:59,512
call the default constructor and if we

44441
29:29:59,512 --> 29:30:01,912
go to doug we're going to see that it is

44442
29:30:01,912 --> 29:30:04,160
possible to specify information here

44443
29:30:04,160 --> 29:30:06,552
first style description but we're going

44444
29:30:06,552 --> 29:30:09,680
to ignore this and we just want to see

44445
29:30:09,680 --> 29:30:12,640
which order in which the destructors are

44446
29:30:12,640 --> 29:30:15,192
called let's build and run this program

44447
29:30:15,192 --> 29:30:17,440
we're going to pass this through gcc the

44448
29:30:17,440 --> 29:30:19,680
book is going to be good if we clear

44449
29:30:19,680 --> 29:30:21,832
let's bring up a powershell window to do

44450
29:30:21,832 --> 29:30:23,832
that we're going to clear

44451
29:30:23,832 --> 29:30:26,160
and run rooster you're going to see that

44452
29:30:26,160 --> 29:30:28,552
dog destructor was called feline

44453
29:30:28,552 --> 29:30:30,720
destructor was called animal destructor

44454
29:30:30,720 --> 29:30:32,480
was called and this is really cool this

44455
29:30:32,480 --> 29:30:36,000
is the order we expect by default but if

44456
29:30:36,000 --> 29:30:38,640
we don't do something like this and say

44457
29:30:38,640 --> 29:30:41,832
animal pointer and say p animal to mean

44458
29:30:41,832 --> 29:30:44,872
a pointer to animal and we say new dog

44459
29:30:44,872 --> 29:30:46,960
we're going to allocate a dog on the

44460
29:30:46,960 --> 29:30:48,960
heap and we're going to manage that

44461
29:30:48,960 --> 29:30:53,040
using a base pointer and if we try to

44462
29:30:53,040 --> 29:30:54,872
release the memory here let's do that

44463
29:30:54,872 --> 29:30:57,360
we're going to say delete p animal let's

44464
29:30:57,360 --> 29:31:00,080
see which destructor gets called here

44465
29:31:00,080 --> 29:31:02,080
because notice we are using a base

44466
29:31:02,080 --> 29:31:06,160
pointer to manage a must specific object

44467
29:31:06,160 --> 29:31:08,640
here which is a derived class of dog

44468
29:31:08,640 --> 29:31:11,360
indirectly and we will see that we don't

44469
29:31:11,360 --> 29:31:14,552
get the destructors called in the order

44470
29:31:14,552 --> 29:31:16,800
that we expect let's build and run this

44471
29:31:16,800 --> 29:31:18,960
program to really see this we're going

44472
29:31:18,960 --> 29:31:21,040
to use gcc to build it

44473
29:31:21,040 --> 29:31:23,280
the world is going to be good as you see

44474
29:31:23,280 --> 29:31:25,440
here we're going to clear

44475
29:31:25,440 --> 29:31:28,232
and run rooster now you see that only

44476
29:31:28,232 --> 29:31:31,592
the destructor for animal is called even

44477
29:31:31,592 --> 29:31:34,480
if we are really managing a dog object

44478
29:31:34,480 --> 29:31:36,320
for things to work really well we would

44479
29:31:36,320 --> 29:31:38,480
expect the destructor for duck to be

44480
29:31:38,480 --> 29:31:40,640
called and then the destructor for a

44481
29:31:40,640 --> 29:31:42,640
feline and then the destructor for

44482
29:31:42,640 --> 29:31:45,912
animal to release or the memory that

44483
29:31:45,912 --> 29:31:48,640
might have been allocated by these

44484
29:31:48,640 --> 29:31:51,440
parent classes for our dog class if you

44485
29:31:51,440 --> 29:31:53,832
go back in the cpp file for example for

44486
29:31:53,832 --> 29:31:55,592
each of these classes you're going to

44487
29:31:55,592 --> 29:31:57,512
see that the compiler is going to be

44488
29:31:57,512 --> 29:31:58,400
calling

44489
29:31:58,400 --> 29:32:00,480
each base class of the current level

44490
29:32:00,480 --> 29:32:02,872
that we are at in doug cpp we are going

44491
29:32:02,872 --> 29:32:05,440
to call the constructor for feline the

44492
29:32:05,440 --> 29:32:07,120
constructor for feline is going to be

44493
29:32:07,120 --> 29:32:09,512
called if it is doing any dynamic memory

44494
29:32:09,512 --> 29:32:11,360
allocation we need to release this

44495
29:32:11,360 --> 29:32:13,680
memory constructor for feline is also

44496
29:32:13,680 --> 29:32:15,680
going to call the constructor for animal

44497
29:32:15,680 --> 29:32:18,000
and if animal is doing any dynamic

44498
29:32:18,000 --> 29:32:19,832
memory allocation this is going to need

44499
29:32:19,832 --> 29:32:22,232
to be called but notice that we are just

44500
29:32:22,232 --> 29:32:25,192
colon the destructor for animal and if

44501
29:32:25,192 --> 29:32:27,512
we only call this destructor all of the

44502
29:32:27,512 --> 29:32:29,440
memory that was allocated by the filing

44503
29:32:29,440 --> 29:32:31,592
constructor is going to be leaked out

44504
29:32:31,592 --> 29:32:33,592
because only the animal destructor is

44505
29:32:33,592 --> 29:32:35,120
going to be called hopefully you can see

44506
29:32:35,120 --> 29:32:37,512
the problem here but this is not the

44507
29:32:37,512 --> 29:32:39,912
only problem the c plus plus standard

44508
29:32:39,912 --> 29:32:42,080
says that if you do something like we

44509
29:32:42,080 --> 29:32:45,512
are doing here and call a destructor

44510
29:32:45,512 --> 29:32:47,760
using a pointer to the base class but

44511
29:32:47,760 --> 29:32:49,832
that pointer happens to be managing a

44512
29:32:49,832 --> 29:32:52,232
derived object this is going to give you

44513
29:32:52,232 --> 29:32:54,000
undefined behavior so you're not

44514
29:32:54,000 --> 29:32:56,400
guaranteed to get to the same behavior

44515
29:32:56,400 --> 29:32:58,160
on different compilers on different

44516
29:32:58,160 --> 29:33:00,160
operating systems so this is something

44517
29:33:00,160 --> 29:33:02,552
really bad we want all the destructors

44518
29:33:02,552 --> 29:33:05,192
in our inheritance hierarchy to be

44519
29:33:05,192 --> 29:33:08,320
called to properly release the memory

44520
29:33:08,320 --> 29:33:10,320
that would potentially be dynamically

44521
29:33:10,320 --> 29:33:12,872
allocated by each level in our

44522
29:33:12,872 --> 29:33:14,872
constructor calls the fix for this is

44523
29:33:14,872 --> 29:33:17,192
really simple all you have to do is mark

44524
29:33:17,192 --> 29:33:20,080
your destructors as virtual and the

44525
29:33:20,080 --> 29:33:23,040
compiler will call the most specific

44526
29:33:23,040 --> 29:33:24,232
destructor

44527
29:33:24,232 --> 29:33:27,192
for your classes so all we need to do is

44528
29:33:27,192 --> 29:33:29,760
go in and mark these guys as virtual so

44529
29:33:29,760 --> 29:33:31,912
we're going to do that the base class

44530
29:33:31,912 --> 29:33:33,760
destructor is going to be marked as

44531
29:33:33,760 --> 29:33:35,832
virtual we're going to go to feline and

44532
29:33:35,832 --> 29:33:37,360
do the same thing we're going to mark

44533
29:33:37,360 --> 29:33:39,592
that as virtual and we're going to go to

44534
29:33:39,592 --> 29:33:40,480
dog

44535
29:33:40,480 --> 29:33:43,512
and mark its destructor as virtual we're

44536
29:33:43,512 --> 29:33:45,760
going to do something like this and now

44537
29:33:45,760 --> 29:33:48,000
notice we don't need to change any other

44538
29:33:48,000 --> 29:33:49,680
thing if we build our program we're

44539
29:33:49,680 --> 29:33:52,232
going to pass it through gcc it is going

44540
29:33:52,232 --> 29:33:54,872
to do exactly what we want because

44541
29:33:54,872 --> 29:33:57,760
now the compiler will resolve the calls

44542
29:33:57,760 --> 29:34:00,000
to the destructors polymorphically

44543
29:34:00,000 --> 29:34:01,680
because we are going through a base

44544
29:34:01,680 --> 29:34:03,832
pointer the compiler will call the most

44545
29:34:03,832 --> 29:34:05,832
specific implementation for this

44546
29:34:05,832 --> 29:34:07,912
structure because we are going through a

44547
29:34:07,912 --> 29:34:10,160
base pointer to call the destructor here

44548
29:34:10,160 --> 29:34:12,400
the compiler will call

44549
29:34:12,400 --> 29:34:15,440
the most specialized destructor we can

44550
29:34:15,440 --> 29:34:16,872
find and it is going to find the

44551
29:34:16,872 --> 29:34:19,512
destructor for duck which is going to be

44552
29:34:19,512 --> 29:34:21,760
the most specialized destructor we can

44553
29:34:21,760 --> 29:34:24,480
find in our inheritance hierarchy it is

44554
29:34:24,480 --> 29:34:26,640
going to call the dog destructor that's

44555
29:34:26,640 --> 29:34:29,512
going to go the destructor for feline in

44556
29:34:29,512 --> 29:34:32,000
turn and then that's going to call the

44557
29:34:32,000 --> 29:34:34,400
destructor for animal and our memory is

44558
29:34:34,400 --> 29:34:36,480
going to be released properly that's

44559
29:34:36,480 --> 29:34:38,400
what we're going to see here let's make

44560
29:34:38,400 --> 29:34:40,800
sure we weld this again because i'm not

44561
29:34:40,800 --> 29:34:43,680
sure if i actually built this the body

44562
29:34:43,680 --> 29:34:45,192
is going to be good anyway so we're

44563
29:34:45,192 --> 29:34:48,000
going to clear and run rooster now you

44564
29:34:48,000 --> 29:34:49,912
see that the duct destructor is called

44565
29:34:49,912 --> 29:34:51,912
the vlan destructor is called the animal

44566
29:34:51,912 --> 29:34:53,680
destructor is gold and everything is

44567
29:34:53,680 --> 29:34:56,400
just going to fall in place so my advice

44568
29:34:56,400 --> 29:34:58,800
if you are using virtual functions in

44569
29:34:58,800 --> 29:35:01,760
your inheritance hierarchy make sure you

44570
29:35:01,760 --> 29:35:04,872
also mark your destructors as virtual

44571
29:35:04,872 --> 29:35:06,800
this is going to save you future

44572
29:35:06,800 --> 29:35:09,592
headaches you might come in contact with

44573
29:35:09,592 --> 29:35:11,440
if you are using a base pointer to

44574
29:35:11,440 --> 29:35:13,760
manage a derived object and you are

44575
29:35:13,760 --> 29:35:15,760
doing some kind of dynamic memory

44576
29:35:15,760 --> 29:35:18,232
allocations in your constructors that's

44577
29:35:18,232 --> 29:35:20,872
going to release the memory properly if

44578
29:35:20,872 --> 29:35:23,360
you are releasing the memory through a

44579
29:35:23,360 --> 29:35:26,160
base pointer like we are doing on line 8

44580
29:35:26,160 --> 29:35:28,080
here this is really all i had to share

44581
29:35:28,080 --> 29:35:29,592
in this lecture i hope you found it

44582
29:35:29,592 --> 29:35:31,680
interesting we are going to stop here in

44583
29:35:31,680 --> 29:35:33,360
this one in the next one we're going to

44584
29:35:33,360 --> 29:35:36,160
learn about dynamic casts

44585
29:35:36,160 --> 29:35:38,400
go ahead and finish up here and meet me

44586
29:35:38,400 --> 29:35:40,232
there in this lecture we're going to

44587
29:35:40,232 --> 29:35:43,040
learn about dynamic casts and the

44588
29:35:43,040 --> 29:35:45,680
dynamic casts are a facility we have in

44589
29:35:45,680 --> 29:35:47,120
c plus plus

44590
29:35:47,120 --> 29:35:50,800
to do downstream transformations

44591
29:35:50,800 --> 29:35:54,000
between our polymorphic types

44592
29:35:54,000 --> 29:35:56,400
so if we have a base planer for example

44593
29:35:56,400 --> 29:35:59,440
we can transform it to a derived type

44594
29:35:59,440 --> 29:36:01,760
and be able to use it like we use any

44595
29:36:01,760 --> 29:36:04,480
row object for example if we do this

44596
29:36:04,480 --> 29:36:06,480
kind of transformation we will be able

44597
29:36:06,480 --> 29:36:09,192
to call non-polymorphic functions and

44598
29:36:09,192 --> 29:36:12,800
this may come in handy sometimes

44599
29:36:12,800 --> 29:36:14,720
this is the hierarchy we will be using

44600
29:36:14,720 --> 29:36:17,440
our top class will be animal here we

44601
29:36:17,440 --> 29:36:19,592
will derive from this and create our

44602
29:36:19,592 --> 29:36:21,760
feline class and we will be live from

44603
29:36:21,760 --> 29:36:25,360
feline and create our dog class here if

44604
29:36:25,360 --> 29:36:27,512
we have a base pointer pointing to a

44605
29:36:27,512 --> 29:36:29,912
dark object for example the most

44606
29:36:29,912 --> 29:36:32,232
specialized class we can have in our

44607
29:36:32,232 --> 29:36:35,360
inheritance hierarchy sometimes we might

44608
29:36:35,360 --> 29:36:39,120
want to transform from this base pointer

44609
29:36:39,120 --> 29:36:42,400
to the most derived object here and get

44610
29:36:42,400 --> 29:36:45,440
to the direct most derived object that

44611
29:36:45,440 --> 29:36:47,592
we can really call anything on if you

44612
29:36:47,592 --> 29:36:50,080
remember with a base planer like animal

44613
29:36:50,080 --> 29:36:52,800
here the only thing we can do is really

44614
29:36:52,800 --> 29:36:53,680
call

44615
29:36:53,680 --> 29:36:56,720
polymorphic or virtual functions but

44616
29:36:56,720 --> 29:36:58,800
sometimes we want to do much more than

44617
29:36:58,800 --> 29:37:01,040
this for example if we want to call

44618
29:37:01,040 --> 29:37:03,040
non-polymorphic functions this is not

44619
29:37:03,040 --> 29:37:04,872
going to work because the best pointer

44620
29:37:04,872 --> 29:37:07,280
has no knowledge of those functions so

44621
29:37:07,280 --> 29:37:09,912
if we need to do that explicitly

44622
29:37:09,912 --> 29:37:12,320
transforming from a base pointer to a

44623
29:37:12,320 --> 29:37:14,552
derived pointer is going to give us that

44624
29:37:14,552 --> 29:37:17,512
capability if the actual object we are

44625
29:37:17,512 --> 29:37:20,552
pointing at happens to have that method

44626
29:37:20,552 --> 29:37:22,552
okay so this is what we are after in

44627
29:37:22,552 --> 29:37:24,232
this lecture we want to be able to

44628
29:37:24,232 --> 29:37:27,360
transform from a base class pointer

44629
29:37:27,360 --> 29:37:30,080
or reference to a derived class pointer

44630
29:37:30,080 --> 29:37:32,640
or reference at runtime another way you

44631
29:37:32,640 --> 29:37:34,872
can text this is to think of the base

44632
29:37:34,872 --> 29:37:37,760
class pointer or reference as input and

44633
29:37:37,760 --> 29:37:40,232
we want to get a derived class pointer

44634
29:37:40,232 --> 29:37:43,192
or reference as output in our c plus

44635
29:37:43,192 --> 29:37:45,592
plus program and the main benefit of

44636
29:37:45,592 --> 29:37:47,552
this is to be able to call

44637
29:37:47,552 --> 29:37:50,400
non-polymorphic methods on derived

44638
29:37:50,400 --> 29:37:52,552
pointers or references this is going to

44639
29:37:52,552 --> 29:37:55,512
be super cool in some cases okay so

44640
29:37:55,512 --> 29:37:58,400
let's look at our inheritance hierarchy

44641
29:37:58,400 --> 29:38:00,400
here the top class is going to be animal

44642
29:38:00,400 --> 29:38:02,552
as you see here it's going to have a

44643
29:38:02,552 --> 29:38:04,960
single virtual method it's going to also

44644
29:38:04,960 --> 29:38:06,960
have a virtual disruptor because we know

44645
29:38:06,960 --> 29:38:09,360
how to do this now we can derive from

44646
29:38:09,360 --> 29:38:11,680
this and create our filling class which

44647
29:38:11,680 --> 29:38:12,872
is going to be

44648
29:38:12,872 --> 29:38:15,040
inheriting publicly it's going to have

44649
29:38:15,040 --> 29:38:17,192
its own run method and it's going to

44650
29:38:17,192 --> 29:38:19,832
declare its own other method which is

44651
29:38:19,832 --> 29:38:22,160
not virtual we can also derive from

44652
29:38:22,160 --> 29:38:25,192
feline and create a dog class this is

44653
29:38:25,192 --> 29:38:27,440
how we do this and we're going to set up

44654
29:38:27,440 --> 29:38:29,760
our own virtual method in dog which is

44655
29:38:29,760 --> 29:38:31,760
going to be bark and we can really do

44656
29:38:31,760 --> 29:38:34,080
anything we want with this inheritance

44657
29:38:34,080 --> 29:38:35,760
hierarchy okay what we're going to be

44658
29:38:35,760 --> 29:38:38,160
using as input is a base class pointer

44659
29:38:38,160 --> 29:38:40,480
or a base class reference and we set

44660
29:38:40,480 --> 29:38:43,512
them up here this is our base pointer

44661
29:38:43,512 --> 29:38:45,760
this is our base reference and we want

44662
29:38:45,760 --> 29:38:48,720
to go from these and create a derived

44663
29:38:48,720 --> 29:38:51,280
class pointer or reference that we can

44664
29:38:51,280 --> 29:38:52,960
use to even call

44665
29:38:52,960 --> 29:38:55,360
non-polymorphic functions and we can

44666
29:38:55,360 --> 29:38:58,232
achieve that using dynamic casts here

44667
29:38:58,232 --> 29:38:59,912
we're going to show you how you can cast

44668
29:38:59,912 --> 29:39:02,640
pointers again our animal base pointer

44669
29:39:02,640 --> 29:39:06,552
is going to act as our input and the

44670
29:39:06,552 --> 29:39:08,640
output is going to be what we want to

44671
29:39:08,640 --> 29:39:11,120
get out of this transformation

44672
29:39:11,120 --> 29:39:13,760
and all we do is say dynamic cast we

44673
29:39:13,760 --> 29:39:17,192
specify a pair of angle brackets inside

44674
29:39:17,192 --> 29:39:18,872
we're going to specify the output we

44675
29:39:18,872 --> 29:39:21,192
want to get and this is usually going to

44676
29:39:21,192 --> 29:39:24,000
be a derived class pointer so the base

44677
29:39:24,000 --> 29:39:25,912
class pointer is going to be within this

44678
29:39:25,912 --> 29:39:28,000
parenthesis and and it's going to be our

44679
29:39:28,000 --> 29:39:29,832
output and this is going to do the

44680
29:39:29,832 --> 29:39:31,680
transformation and it's going to give us

44681
29:39:31,680 --> 29:39:34,232
a result that we're going to be storing

44682
29:39:34,232 --> 29:39:37,440
in our feline pointer here and if this

44683
29:39:37,440 --> 29:39:41,192
succeeds we will have a valid feline

44684
29:39:41,192 --> 29:39:44,040
pointer here and we can use it to call

44685
29:39:44,040 --> 29:39:47,440
non-polymorphic or non-virtual functions

44686
29:39:47,440 --> 29:39:49,440
like we are doing here and this is super

44687
29:39:49,440 --> 29:39:51,512
cool another thing you can do with this

44688
29:39:51,512 --> 29:39:53,912
is use the result of this transformation

44689
29:39:53,912 --> 29:39:56,480
in a pointer check for example we can

44690
29:39:56,480 --> 29:39:58,800
check and see if this pointer is not a

44691
29:39:58,800 --> 29:40:01,040
null pointer if it's not a null pointer

44692
29:40:01,040 --> 29:40:03,592
we can call our non-polymorphic function

44693
29:40:03,592 --> 29:40:06,400
to it the result was successful but if

44694
29:40:06,400 --> 29:40:08,960
it's no pointer we're going to fail and

44695
29:40:08,960 --> 29:40:11,192
fall down here and we can say that we

44696
29:40:11,192 --> 29:40:14,400
couldn't cast to a feeling pointer and

44697
29:40:14,400 --> 29:40:16,232
some of you might ask

44698
29:40:16,232 --> 29:40:19,440
how can this transformation fail well if

44699
29:40:19,440 --> 29:40:22,872
we go back to our code here we have an

44700
29:40:22,872 --> 29:40:25,192
animal base pointer which is really

44701
29:40:25,192 --> 29:40:28,552
pointing to a feline object in memory

44702
29:40:28,552 --> 29:40:31,360
if we try and cast this animal pointer

44703
29:40:31,360 --> 29:40:32,720
to dog

44704
29:40:32,720 --> 29:40:34,832
suppose we want to do this kind of

44705
29:40:34,832 --> 29:40:37,120
transformation try to think about this

44706
29:40:37,120 --> 29:40:38,800
this is not going to work because we

44707
29:40:38,800 --> 29:40:41,040
really have no dog information in this

44708
29:40:41,040 --> 29:40:43,512
villain object and if we try to cast

44709
29:40:43,512 --> 29:40:45,912
this to dog the compiler will really

44710
29:40:45,912 --> 29:40:47,680
have no way to do this and the

44711
29:40:47,680 --> 29:40:50,640
transformation through dynamic cast will

44712
29:40:50,640 --> 29:40:53,912
fail and we will say the message here

44713
29:40:53,912 --> 29:40:55,280
meaning that we couldn't do the

44714
29:40:55,280 --> 29:40:58,080
transformation the user asked for so

44715
29:40:58,080 --> 29:41:00,232
here we can do the transformation and

44716
29:41:00,232 --> 29:41:02,720
transform from a base pointer to a

44717
29:41:02,720 --> 29:41:04,960
derived pointer but we can also

44718
29:41:04,960 --> 29:41:07,592
transform to a derived reference and i

44719
29:41:07,592 --> 29:41:09,592
am going to show you the syntax to do

44720
29:41:09,592 --> 29:41:11,592
that and it is super simple we say

44721
29:41:11,592 --> 29:41:14,552
dynamic cast and we specify our input

44722
29:41:14,552 --> 29:41:15,680
reference

44723
29:41:15,680 --> 29:41:17,440
notice that this is a reference you have

44724
29:41:17,440 --> 29:41:20,640
to put it it's not a pointer and you

44725
29:41:20,640 --> 29:41:23,680
specify the output within this angle

44726
29:41:23,680 --> 29:41:26,000
brackets here once you do this the

44727
29:41:26,000 --> 29:41:28,232
output of this is going to be a derived

44728
29:41:28,232 --> 29:41:30,400
reference and we're going to store this

44729
29:41:30,400 --> 29:41:33,760
in our feline reference here once we do

44730
29:41:33,760 --> 29:41:35,192
this transformation and the

44731
29:41:35,192 --> 29:41:36,960
transformation is successful we're going

44732
29:41:36,960 --> 29:41:39,120
to be able to call our non-polymorphic

44733
29:41:39,120 --> 29:41:41,512
function this is going to work but with

44734
29:41:41,512 --> 29:41:43,680
references we don't have the luxury to

44735
29:41:43,680 --> 29:41:45,512
do something like a pointer check

44736
29:41:45,512 --> 29:41:47,912
because there is no such thing as a null

44737
29:41:47,912 --> 29:41:50,400
reference a reference is always pointing

44738
29:41:50,400 --> 29:41:51,760
to something

44739
29:41:51,760 --> 29:41:54,080
and if the transformation fails we will

44740
29:41:54,080 --> 29:41:56,720
have some kind of invalid reference and

44741
29:41:56,720 --> 29:41:58,720
if this fails it is probably going to

44742
29:41:58,720 --> 29:42:01,360
blow up and give us undefined behavior

44743
29:42:01,360 --> 29:42:03,832
so you don't really want to do this i

44744
29:42:03,832 --> 29:42:06,400
usually don't recommend

44745
29:42:06,400 --> 29:42:08,552
doing this kind of transformation with

44746
29:42:08,552 --> 29:42:10,800
references unless you know

44747
29:42:10,800 --> 29:42:12,960
that the transformation is possible

44748
29:42:12,960 --> 29:42:15,760
beforehand what i usually recommend is

44749
29:42:15,760 --> 29:42:16,800
to

44750
29:42:16,800 --> 29:42:18,960
pass through pointers and it is even

44751
29:42:18,960 --> 29:42:21,360
possible to transform a base reference

44752
29:42:21,360 --> 29:42:24,552
into a derived pointer and the syntax to

44753
29:42:24,552 --> 29:42:27,192
do that is what you see here okay and uh

44754
29:42:27,192 --> 29:42:30,480
once we do a transformation to a pointer

44755
29:42:30,480 --> 29:42:32,400
if the transformation is successful

44756
29:42:32,400 --> 29:42:34,080
we're going to have a valid pointer in

44757
29:42:34,080 --> 29:42:36,400
here if the transformation fails we're

44758
29:42:36,400 --> 29:42:38,400
going to have a null pointer and the

44759
29:42:38,400 --> 29:42:40,960
check is going to draw us here and we're

44760
29:42:40,960 --> 29:42:43,280
going to print this message to say that

44761
29:42:43,280 --> 29:42:45,680
we can't do the transformation here okay

44762
29:42:45,680 --> 29:42:48,552
again the cast may fail if it fails

44763
29:42:48,552 --> 29:42:50,720
while we are trying to transform it to a

44764
29:42:50,720 --> 29:42:52,800
dog pointer we are going to fall down

44765
29:42:52,800 --> 29:42:55,592
here and say that the cast failed we can

44766
29:42:55,592 --> 29:42:56,960
also do the same thing through

44767
29:42:56,960 --> 29:42:59,120
references for example if we want to

44768
29:42:59,120 --> 29:43:01,120
transform this base reference to a

44769
29:43:01,120 --> 29:43:02,872
derived pointer

44770
29:43:02,872 --> 29:43:04,720
and this fails we're going to follow

44771
29:43:04,720 --> 29:43:06,800
here because of the check we are doing

44772
29:43:06,800 --> 29:43:08,720
here we can do something like this to

44773
29:43:08,720 --> 29:43:11,512
make our code much safer to work with

44774
29:43:11,512 --> 29:43:13,192
and another thing i should really point

44775
29:43:13,192 --> 29:43:15,440
out is that in practice

44776
29:43:15,440 --> 29:43:17,912
casting like this is usually done in

44777
29:43:17,912 --> 29:43:20,720
functions where you are passing a base

44778
29:43:20,720 --> 29:43:22,832
pointer or a base reference as a

44779
29:43:22,832 --> 29:43:25,832
parameter and in this function you

44780
29:43:25,832 --> 29:43:28,552
somehow need to call a non-polymorphic

44781
29:43:28,552 --> 29:43:30,480
function so you might do something like

44782
29:43:30,480 --> 29:43:32,232
this and take the pointer and turn that

44783
29:43:32,232 --> 29:43:34,640
into a derived pointer and if the

44784
29:43:34,640 --> 29:43:36,080
transformation is successful you're

44785
29:43:36,080 --> 29:43:37,912
going to call your method and if the

44786
29:43:37,912 --> 29:43:39,680
check fails you're going to follow here

44787
29:43:39,680 --> 29:43:42,000
and print an error message you can do

44788
29:43:42,000 --> 29:43:44,320
something like this with pointers and we

44789
29:43:44,320 --> 29:43:46,720
can do exactly the same thing with

44790
29:43:46,720 --> 29:43:48,872
references but here because we want to

44791
29:43:48,872 --> 29:43:51,120
do this check we're going to transform

44792
29:43:51,120 --> 29:43:53,512
our base reference into a derived

44793
29:43:53,512 --> 29:43:55,912
pointer and call our method on the

44794
29:43:55,912 --> 29:43:58,080
derived pointer instead this is going to

44795
29:43:58,080 --> 29:44:00,232
give us the ability to do this kind of

44796
29:44:00,232 --> 29:44:03,120
check to make our code much safer to

44797
29:44:03,120 --> 29:44:05,360
work with a word of caution here

44798
29:44:05,360 --> 29:44:08,400
overusing down casting is a sign of bad

44799
29:44:08,400 --> 29:44:10,872
design if you find yourself doing this

44800
29:44:10,872 --> 29:44:12,640
kind of thing a lot to call

44801
29:44:12,640 --> 29:44:15,192
non-polymorphic function that's maybe a

44802
29:44:15,192 --> 29:44:16,960
sign that you should make that

44803
29:44:16,960 --> 29:44:18,960
non-polymorphic function

44804
29:44:18,960 --> 29:44:21,120
polymorphic because that's going to save

44805
29:44:21,120 --> 29:44:22,400
you from doing this kind of

44806
29:44:22,400 --> 29:44:24,720
transformations a lot just make sure you

44807
29:44:24,720 --> 29:44:27,912
don't overuse this and do it in a few

44808
29:44:27,912 --> 29:44:30,160
cases where you really need to do this

44809
29:44:30,160 --> 29:44:31,680
kind of thing now that you know this

44810
29:44:31,680 --> 29:44:33,040
we're going to head over to visual

44811
29:44:33,040 --> 29:44:34,872
studio code and play with us a little

44812
29:44:34,872 --> 29:44:37,680
more here we are in our working folder

44813
29:44:37,680 --> 29:44:40,080
the current project is dynamic casts

44814
29:44:40,080 --> 29:44:43,192
we're going to grab our template files

44815
29:44:43,192 --> 29:44:44,640
and we're going to put them in place

44816
29:44:44,640 --> 29:44:46,872
let's do that and we are going to grab

44817
29:44:46,872 --> 29:44:49,440
the files that make up our inheritance

44818
29:44:49,440 --> 29:44:51,592
hierarchy we're going to put those in we

44819
29:44:51,592 --> 29:44:54,720
have animal dog and feline and this is

44820
29:44:54,720 --> 29:44:56,872
going to make up our inheritance

44821
29:44:56,872 --> 29:44:59,192
hierarchy here once we have this in

44822
29:44:59,192 --> 29:45:00,872
place we can open this up in visual

44823
29:45:00,872 --> 29:45:02,720
studio code by dragging and dropping

44824
29:45:02,720 --> 29:45:04,960
here and this is going to give us our

44825
29:45:04,960 --> 29:45:07,760
files okay we have our files in here we

44826
29:45:07,760 --> 29:45:10,080
can open up the animal class which is

44827
29:45:10,080 --> 29:45:12,320
our base class we can see that it is

44828
29:45:12,320 --> 29:45:14,000
really simple it's just going to have

44829
29:45:14,000 --> 29:45:16,160
one virtual method which is brief it's

44830
29:45:16,160 --> 29:45:18,400
going to have a single member variable

44831
29:45:18,400 --> 29:45:20,720
which is description here we can derive

44832
29:45:20,720 --> 29:45:22,720
from this and create our feline class

44833
29:45:22,720 --> 29:45:24,960
which is going to inherit publicly from

44834
29:45:24,960 --> 29:45:28,320
animal feline is going to set up its own

44835
29:45:28,320 --> 29:45:30,400
method which is non-virtual

44836
29:45:30,400 --> 29:45:32,400
and we will have a virtual method called

44837
29:45:32,400 --> 29:45:34,800
run we can override in downstream

44838
29:45:34,800 --> 29:45:37,192
classes if we want to do that and let's

44839
29:45:37,192 --> 29:45:39,680
look at the implementation for feline

44840
29:45:39,680 --> 29:45:41,680
cpp if you want to do that you can take

44841
29:45:41,680 --> 29:45:43,360
a look it's just going to forward the

44842
29:45:43,360 --> 29:45:46,480
construction to the base class to build

44843
29:45:46,480 --> 29:45:48,552
the base part of us

44844
29:45:48,552 --> 29:45:50,400
let's look at dog dog is going to

44845
29:45:50,400 --> 29:45:52,400
inherit from feline and it is going to

44846
29:45:52,400 --> 29:45:55,040
set up a simple virtual function called

44847
29:45:55,040 --> 29:45:56,800
work and it's going to have a virtual

44848
29:45:56,800 --> 29:45:58,480
destructor now we know that we should

44849
29:45:58,480 --> 29:45:59,760
really put in

44850
29:45:59,760 --> 29:46:02,232
virtual disruptors if we happen to even

44851
29:46:02,232 --> 29:46:04,960
have a single virtual method in our

44852
29:46:04,960 --> 29:46:06,800
inheritance hierarchy because that's

44853
29:46:06,800 --> 29:46:09,680
going to make events easier now we want

44854
29:46:09,680 --> 29:46:12,720
to go to the main cpp file and play with

44855
29:46:12,720 --> 29:46:14,872
dynamic casts we're going to remove

44856
29:46:14,872 --> 29:46:17,040
whatever it is we don't need here and

44857
29:46:17,040 --> 29:46:19,440
that we can include our most derived

44858
29:46:19,440 --> 29:46:22,400
class let's include doug here this is

44859
29:46:22,400 --> 29:46:24,720
going to implicitly include

44860
29:46:24,720 --> 29:46:27,592
both feline and animal because this

44861
29:46:27,592 --> 29:46:30,000
header is going to include its parent

44862
29:46:30,000 --> 29:46:32,160
and its parent is going to include its

44863
29:46:32,160 --> 29:46:34,872
own parent this is the logic here we are

44864
29:46:34,872 --> 29:46:37,832
going to start out by using a simple

44865
29:46:37,832 --> 29:46:39,680
example here and show you that you can't

44866
29:46:39,680 --> 29:46:42,960
really call non-polymorphic functions

44867
29:46:42,960 --> 29:46:45,440
from a base pointer that is managing the

44868
29:46:45,440 --> 29:46:48,400
derived object and here we have an

44869
29:46:48,400 --> 29:46:51,120
animal pointer it is a base pointer and

44870
29:46:51,120 --> 29:46:54,800
it is managing a real feline object in

44871
29:46:54,800 --> 29:46:57,280
memory but if we try and call a

44872
29:46:57,280 --> 29:46:59,512
non-virtual function through this base

44873
29:46:59,512 --> 29:47:01,912
pointer this is going to blow up this is

44874
29:47:01,912 --> 29:47:04,320
not going to work because

44875
29:47:04,320 --> 29:47:06,480
we can't really call a non-polymorphic

44876
29:47:06,480 --> 29:47:08,800
function through a base pointer because

44877
29:47:08,800 --> 29:47:10,800
that's not a virtual function the

44878
29:47:10,800 --> 29:47:12,800
requirement to be able to do this is for

44879
29:47:12,800 --> 29:47:15,760
the function to be virtual and do some

44880
29:47:15,760 --> 29:47:18,640
feeling thingy is not a virtual function

44881
29:47:18,640 --> 29:47:20,960
that we know at the base level so this

44882
29:47:20,960 --> 29:47:22,960
is not going to work by default and if

44883
29:47:22,960 --> 29:47:24,552
we're trying to build code like this

44884
29:47:24,552 --> 29:47:26,080
this is going to give us a compiler

44885
29:47:26,080 --> 29:47:28,872
error let's pass this through gcc we're

44886
29:47:28,872 --> 29:47:31,192
going to do that we are going to finish

44887
29:47:31,192 --> 29:47:33,192
the world with errors and if we go up

44888
29:47:33,192 --> 29:47:35,512
we're going to find that class animal

44889
29:47:35,512 --> 29:47:38,000
has no member name to do some feline

44890
29:47:38,000 --> 29:47:39,912
thingy so this is the compiler error

44891
29:47:39,912 --> 29:47:42,232
here this is not going to work if we

44892
29:47:42,232 --> 29:47:44,232
need to do something like this one

44893
29:47:44,232 --> 29:47:47,192
solution might be to do dynamic casts

44894
29:47:47,192 --> 29:47:48,960
that we are learning about in this

44895
29:47:48,960 --> 29:47:51,040
lecture here and the syntax is

44896
29:47:51,040 --> 29:47:53,832
ridiculously simple so we can go down

44897
29:47:53,832 --> 29:47:56,400
here and put in a simple separator to be

44898
29:47:56,400 --> 29:47:58,720
able to follow this lens on our

44899
29:47:58,720 --> 29:48:00,960
powershell window you can do this if you

44900
29:48:00,960 --> 29:48:03,440
want and we're going to do our dynamic

44901
29:48:03,440 --> 29:48:06,552
cast for example if we wanted to do a

44902
29:48:06,552 --> 29:48:09,360
transformation and transform this to a

44903
29:48:09,360 --> 29:48:12,320
dark object this would give us a problem

44904
29:48:12,320 --> 29:48:14,160
and let's try and look at this again we

44905
29:48:14,160 --> 29:48:16,720
have a feline object here and we are

44906
29:48:16,720 --> 29:48:19,192
managing this through a base pointer and

44907
29:48:19,192 --> 29:48:21,280
what we want to do is to take this space

44908
29:48:21,280 --> 29:48:23,680
pointer and turn it into

44909
29:48:23,680 --> 29:48:26,232
a dog object if you look at this

44910
29:48:26,232 --> 29:48:28,080
remember that we don't really have any

44911
29:48:28,080 --> 29:48:30,400
dog information in our feline object

44912
29:48:30,400 --> 29:48:32,480
this is going to just go up to the level

44913
29:48:32,480 --> 29:48:35,192
of feline but we want to transform this

44914
29:48:35,192 --> 29:48:37,592
to a dog to make this super clear let's

44915
29:48:37,592 --> 29:48:40,552
look at our inheritance hierarchy again

44916
29:48:40,552 --> 29:48:43,280
what we have is a feline object and the

44917
29:48:43,280 --> 29:48:45,360
information we have really goes up to

44918
29:48:45,360 --> 29:48:46,400
this level

44919
29:48:46,400 --> 29:48:48,552
and we are managing our feeling object

44920
29:48:48,552 --> 29:48:50,800
through a base pointer this is the setup

44921
29:48:50,800 --> 29:48:52,640
we have but we want to do the

44922
29:48:52,640 --> 29:48:54,720
transformation and turn this base

44923
29:48:54,720 --> 29:48:57,832
pointer into a dog object and this is

44924
29:48:57,832 --> 29:49:00,080
going to blow up especially if we have

44925
29:49:00,080 --> 29:49:02,640
any dog specific member variables this

44926
29:49:02,640 --> 29:49:04,232
is going to blow up this is not going to

44927
29:49:04,232 --> 29:49:06,960
work if we try to access dog information

44928
29:49:06,960 --> 29:49:07,832
through

44929
29:49:07,832 --> 29:49:09,832
what we get through the transformation

44930
29:49:09,832 --> 29:49:11,912
to animal to dog we're going to get a

44931
29:49:11,912 --> 29:49:13,440
crush because we have no such

44932
29:49:13,440 --> 29:49:15,280
information and we're going to look at a

44933
29:49:15,280 --> 29:49:17,592
simple example to really drive this home

44934
29:49:17,592 --> 29:49:19,592
so what we're going to do is go back to

44935
29:49:19,592 --> 29:49:21,592
our dog class and we're going to put in

44936
29:49:21,592 --> 29:49:23,440
a sample member variable we're going to

44937
29:49:23,440 --> 29:49:26,000
make it private and for example we can

44938
29:49:26,000 --> 29:49:28,400
make this a member variable to keep

44939
29:49:28,400 --> 29:49:30,400
track of the speed for the dock we can

44940
29:49:30,400 --> 29:49:32,552
do this and we're going to initialize

44941
29:49:32,552 --> 29:49:34,400
this to 0 by default and we're going to

44942
29:49:34,400 --> 29:49:36,800
set up a function which is going to

44943
29:49:36,800 --> 29:49:39,512
print some dog information let's go back

44944
29:49:39,512 --> 29:49:42,080
to feline and copy the do some feline

44945
29:49:42,080 --> 29:49:44,640
thingy method and we're going to do some

44946
29:49:44,640 --> 29:49:47,120
dog thingy that's what we're going to do

44947
29:49:47,120 --> 29:49:48,960
here i am going to put in this method

44948
29:49:48,960 --> 29:49:51,040
and adapt it a little bit we're going to

44949
29:49:51,040 --> 29:49:53,760
do some dog thingy and we're going to

44950
29:49:53,760 --> 29:49:56,552
account for that in the body but we also

44951
29:49:56,552 --> 29:49:58,552
want to print the speed for this dog

44952
29:49:58,552 --> 29:50:00,640
here so we're going to say speed and

44953
29:50:00,640 --> 29:50:03,040
we're going to print this out suppose we

44954
29:50:03,040 --> 29:50:05,040
have this kind of setup in our

44955
29:50:05,040 --> 29:50:07,832
inheritance hierarchy here a dark object

44956
29:50:07,832 --> 29:50:10,080
has some doubt specific information it

44957
29:50:10,080 --> 29:50:12,080
has an additional member variable which

44958
29:50:12,080 --> 29:50:14,400
is m speed here we won't worry about

44959
29:50:14,400 --> 29:50:16,320
initializing this from the constructor

44960
29:50:16,320 --> 29:50:17,912
you can do that if you want all we

44961
29:50:17,912 --> 29:50:21,360
really want is to add some extra data at

44962
29:50:21,360 --> 29:50:23,360
the dog level and we're going to see

44963
29:50:23,360 --> 29:50:25,760
that if we try to transform to doug this

44964
29:50:25,760 --> 29:50:27,912
is going to give us a few problems so

44965
29:50:27,912 --> 29:50:30,720
what we want is to turn this animal base

44966
29:50:30,720 --> 29:50:33,280
pointer into a dark object let's do this

44967
29:50:33,280 --> 29:50:34,400
we're going to

44968
29:50:34,400 --> 29:50:37,280
change this to dog and the result object

44969
29:50:37,280 --> 29:50:39,680
we get is going to be a dog pointer and

44970
29:50:39,680 --> 29:50:41,760
we want to call the do

44971
29:50:41,760 --> 29:50:43,912
some dog thingy

44972
29:50:43,912 --> 29:50:46,480
method on the pointer we get as a result

44973
29:50:46,480 --> 29:50:48,552
of this transformation here let's see

44974
29:50:48,552 --> 29:50:50,160
what happens you're going to see that

44975
29:50:50,160 --> 29:50:51,680
this is not going to give us any

44976
29:50:51,680 --> 29:50:53,760
indication that we are doing something

44977
29:50:53,760 --> 29:50:56,320
wrong but if the transformation here

44978
29:50:56,320 --> 29:50:59,192
fails this is going to silently fail and

44979
29:50:59,192 --> 29:51:01,912
store junk data in our feline pointer

44980
29:51:01,912 --> 29:51:04,000
here and here we're going to try and

44981
29:51:04,000 --> 29:51:07,192
call a method that is going to possibly

44982
29:51:07,192 --> 29:51:10,000
use some dog stuff on the feline object

44983
29:51:10,000 --> 29:51:12,232
this is going to blow up again we don't

44984
29:51:12,232 --> 29:51:14,320
have dog information in this feline

44985
29:51:14,320 --> 29:51:16,640
object and the do some dog thinking

44986
29:51:16,640 --> 29:51:18,552
method is going to try and print the

44987
29:51:18,552 --> 29:51:21,040
speed of the dog that we don't really

44988
29:51:21,040 --> 29:51:23,360
have we don't have any dog information

44989
29:51:23,360 --> 29:51:26,160
so we have no business accessing dog

44990
29:51:26,160 --> 29:51:28,232
information from this object to start

44991
29:51:28,232 --> 29:51:30,160
with so this is going to blow up and

44992
29:51:30,160 --> 29:51:32,160
it's probably going to give us a crash

44993
29:51:32,160 --> 29:51:34,080
let's try and build and see what happens

44994
29:51:34,080 --> 29:51:35,760
we're going to pass this through gcc

44995
29:51:35,760 --> 29:51:37,760
like we always do the boat is going to

44996
29:51:37,760 --> 29:51:40,000
go through you see that this is going to

44997
29:51:40,000 --> 29:51:43,360
even blow up at run time when users are

44998
29:51:43,360 --> 29:51:45,440
actually using your application this is

44999
29:51:45,440 --> 29:51:48,080
super dangerous we're going to run this

45000
29:51:48,080 --> 29:51:50,080
and see what happens you see doing some

45001
29:51:50,080 --> 29:51:51,912
dug thingy and it's going to try and

45002
29:51:51,912 --> 29:51:54,160
print the speed the compiler is really

45003
29:51:54,160 --> 29:51:56,232
trying its best but this is really going

45004
29:51:56,232 --> 29:51:59,440
to fail and we are crashing our program

45005
29:51:59,440 --> 29:52:02,480
if you go down here and say done to make

45006
29:52:02,480 --> 29:52:05,120
sure we know when the program is done

45007
29:52:05,120 --> 29:52:07,192
and we try and run our program again

45008
29:52:07,192 --> 29:52:09,280
let's pass this through gcc to take into

45009
29:52:09,280 --> 29:52:11,680
account this thing we have on line 20.

45010
29:52:11,680 --> 29:52:12,960
the book is going to be good you're

45011
29:52:12,960 --> 29:52:14,872
going to see that the computer is going

45012
29:52:14,872 --> 29:52:16,800
to try and really run this but it's

45013
29:52:16,800 --> 29:52:18,320
going to see that it doesn't really have

45014
29:52:18,320 --> 29:52:20,872
any dog information and the computer is

45015
29:52:20,872 --> 29:52:22,552
not going to succeed because we are

45016
29:52:22,552 --> 29:52:24,800
trying to access this dub specific

45017
29:52:24,800 --> 29:52:27,832
information really on a feline object so

45018
29:52:27,832 --> 29:52:29,592
we are going to get a crash again the

45019
29:52:29,592 --> 29:52:30,400
message

45020
29:52:30,400 --> 29:52:33,592
is that this dynamic casts can fail

45021
29:52:33,592 --> 29:52:35,912
and we need a better way to do some kind

45022
29:52:35,912 --> 29:52:38,800
of checks before we call our methods

45023
29:52:38,800 --> 29:52:41,360
here and we can do this by just using

45024
29:52:41,360 --> 29:52:43,192
the pointer we get from this

45025
29:52:43,192 --> 29:52:45,512
transformation here so we can say if

45026
29:52:45,512 --> 29:52:48,080
feline pointer and check and see if we

45027
29:52:48,080 --> 29:52:50,640
have some valid data in this villain

45028
29:52:50,640 --> 29:52:52,552
pointer and if that's the case we're

45029
29:52:52,552 --> 29:52:54,720
going to do whatever we want to do with

45030
29:52:54,720 --> 29:52:57,192
this pointer here okay so this is

45031
29:52:57,192 --> 29:52:58,720
something we can do

45032
29:52:58,720 --> 29:53:01,192
and if the transformation fails we're

45033
29:53:01,192 --> 29:53:03,512
going to fall in this else block and we

45034
29:53:03,512 --> 29:53:05,760
can put some nice message here instead

45035
29:53:05,760 --> 29:53:08,480
of letting the user crash at runtime

45036
29:53:08,480 --> 29:53:11,192
this is much better in my opinion so

45037
29:53:11,192 --> 29:53:13,120
we're going to say couldn't do the

45038
29:53:13,120 --> 29:53:16,320
transformation from animal pointer to

45039
29:53:16,320 --> 29:53:18,320
dog pointer because we really have no

45040
29:53:18,320 --> 29:53:20,640
dog information and this base pointer

45041
29:53:20,640 --> 29:53:22,552
that we have here this is something we

45042
29:53:22,552 --> 29:53:24,480
can do so we're going to say sddc out

45043
29:53:24,480 --> 29:53:27,680
i'm going to say stdendl here and we're

45044
29:53:27,680 --> 29:53:30,160
going to see what happens let's build

45045
29:53:30,160 --> 29:53:31,512
hopefully we're not going to get the

45046
29:53:31,512 --> 29:53:33,440
crash because we are doing something

45047
29:53:33,440 --> 29:53:35,832
smarter now we are checking to see

45048
29:53:35,832 --> 29:53:37,832
if we have any dog information in this

45049
29:53:37,832 --> 29:53:40,480
pointer before we call some doubt

45050
29:53:40,480 --> 29:53:42,720
specific method on this pointer here

45051
29:53:42,720 --> 29:53:44,872
this is the beauty of this we're going

45052
29:53:44,872 --> 29:53:47,440
to clear and run rooster now you see

45053
29:53:47,440 --> 29:53:49,120
couldn't do the transformation from

45054
29:53:49,120 --> 29:53:52,232
animal to dog and our program is no

45055
29:53:52,232 --> 29:53:54,960
longer crashing it is ending properly

45056
29:53:54,960 --> 29:53:56,872
and this is much better this is what you

45057
29:53:56,872 --> 29:53:59,040
should aim for so again the

45058
29:53:59,040 --> 29:54:01,360
transformations here may fail

45059
29:54:01,360 --> 29:54:02,160
but

45060
29:54:02,160 --> 29:54:04,800
if we turn this back to doing v-line

45061
29:54:04,800 --> 29:54:07,120
transformation let's do feline pointer

45062
29:54:07,120 --> 29:54:08,640
we're going to change this to fill in

45063
29:54:08,640 --> 29:54:11,512
pointer again and we're going to do some

45064
29:54:11,512 --> 29:54:13,760
feline thing now we're going to bolt

45065
29:54:13,760 --> 29:54:15,440
again and this is true

45066
29:54:15,440 --> 29:54:16,960
we're going to bolt again and this is

45067
29:54:16,960 --> 29:54:18,800
going to build successfully and it is

45068
29:54:18,800 --> 29:54:20,872
going to probably do some filament

45069
29:54:20,872 --> 29:54:23,360
thingy the build is good we can clear

45070
29:54:23,360 --> 29:54:25,280
and run rooster this is going to work

45071
29:54:25,280 --> 29:54:27,192
just fine and our program is going to

45072
29:54:27,192 --> 29:54:30,160
end properly so here we just saw that we

45073
29:54:30,160 --> 29:54:32,160
could do a transformation from a base

45074
29:54:32,160 --> 29:54:35,040
pointer to a derived pointer and this is

45075
29:54:35,040 --> 29:54:37,280
going to work just fine we can also do

45076
29:54:37,280 --> 29:54:40,000
the transformation for references let's

45077
29:54:40,000 --> 29:54:42,480
say that here and we're going to go down

45078
29:54:42,480 --> 29:54:44,480
and put in a simple example to drive

45079
29:54:44,480 --> 29:54:46,232
this home we're going to have a feline

45080
29:54:46,232 --> 29:54:48,320
object we're going to set up a reference

45081
29:54:48,320 --> 29:54:51,040
to it and if we try and call a

45082
29:54:51,040 --> 29:54:52,960
non-virtual method on this base

45083
29:54:52,960 --> 29:54:55,040
reference this is going to blow up

45084
29:54:55,040 --> 29:54:56,232
because

45085
29:54:56,232 --> 29:54:58,480
the base class has no information about

45086
29:54:58,480 --> 29:55:01,280
this non-virtual method that we declare

45087
29:55:01,280 --> 29:55:03,120
at the feline level this is going to

45088
29:55:03,120 --> 29:55:05,512
blow up if we try to build our program

45089
29:55:05,512 --> 29:55:06,640
we're going to see that we get a

45090
29:55:06,640 --> 29:55:09,832
compiler error saying no such method

45091
29:55:09,832 --> 29:55:10,720
as

45092
29:55:10,720 --> 29:55:12,400
do some feeling thing we're going to see

45093
29:55:12,400 --> 29:55:15,120
that here no member named

45094
29:55:15,120 --> 29:55:18,552
this way at the animal level

45095
29:55:18,552 --> 29:55:20,800
this is the compiler error we get if we

45096
29:55:20,800 --> 29:55:24,080
try to call a non-virtual method through

45097
29:55:24,080 --> 29:55:26,320
a base reference that we have here this

45098
29:55:26,320 --> 29:55:29,440
is not going to work but we can also do

45099
29:55:29,440 --> 29:55:32,320
a dynamic cast and transform from a base

45100
29:55:32,320 --> 29:55:33,680
reference to

45101
29:55:33,680 --> 29:55:35,912
a derived reference and the syntax to do

45102
29:55:35,912 --> 29:55:38,080
that is really here we're going to set

45103
29:55:38,080 --> 29:55:39,040
up a

45104
29:55:39,040 --> 29:55:41,040
derived reference in this case it's

45105
29:55:41,040 --> 29:55:43,120
going to be a feedline reference we're

45106
29:55:43,120 --> 29:55:45,192
going to initialize this with a dynamic

45107
29:55:45,192 --> 29:55:47,760
cast transformation and the result of

45108
29:55:47,760 --> 29:55:49,512
the cast is going to be used to

45109
29:55:49,512 --> 29:55:51,832
initialize this reference here and we're

45110
29:55:51,832 --> 29:55:53,512
going to be taking

45111
29:55:53,512 --> 29:55:56,400
a base reference and turning that into a

45112
29:55:56,400 --> 29:55:58,160
derived reference here this is the

45113
29:55:58,160 --> 29:56:00,720
syntax the output you desire is going to

45114
29:56:00,720 --> 29:56:03,440
be within this angle brackets and the

45115
29:56:03,440 --> 29:56:05,280
input is going to be through this

45116
29:56:05,280 --> 29:56:07,680
parenthesis here if this succeeds we

45117
29:56:07,680 --> 29:56:10,000
will be able to call our method here and

45118
29:56:10,000 --> 29:56:12,000
this is going to work just fine let's

45119
29:56:12,000 --> 29:56:13,512
try this out

45120
29:56:13,512 --> 29:56:16,480
we are going to put in a separator to be

45121
29:56:16,480 --> 29:56:18,872
able to follow these things let's put

45122
29:56:18,872 --> 29:56:22,872
that at line 24 here this is going to do

45123
29:56:22,872 --> 29:56:24,400
and we're going to try and build our

45124
29:56:24,400 --> 29:56:26,320
program we're going to pass this through

45125
29:56:26,320 --> 29:56:29,120
gcc the boat is good we can clear and

45126
29:56:29,120 --> 29:56:31,680
run rooster now we're going to see that

45127
29:56:31,680 --> 29:56:34,640
we are doing some filling thingy through

45128
29:56:34,640 --> 29:56:36,640
a reference and this is super cool we

45129
29:56:36,640 --> 29:56:38,320
can do this you can do this kind of

45130
29:56:38,320 --> 29:56:40,960
transformation here and at the end you

45131
29:56:40,960 --> 29:56:43,192
see that we are calling our destructors

45132
29:56:43,192 --> 29:56:45,760
on our objects and this is a good

45133
29:56:45,760 --> 29:56:48,320
reminder that we didn't properly release

45134
29:56:48,320 --> 29:56:50,720
the memory on this animal pointer that

45135
29:56:50,720 --> 29:56:51,760
we had

45136
29:56:51,760 --> 29:56:54,320
so we are going to go down at the end of

45137
29:56:54,320 --> 29:56:56,552
the program and release that memory this

45138
29:56:56,552 --> 29:56:58,872
is good practice and hopefully you can

45139
29:56:58,872 --> 29:57:02,080
see how easy it is to forget to release

45140
29:57:02,080 --> 29:57:04,552
some memory that you allocate for

45141
29:57:04,552 --> 29:57:06,720
with the new operator this is a good

45142
29:57:06,720 --> 29:57:08,960
learning experience here but this is a

45143
29:57:08,960 --> 29:57:10,720
good learning experience here but we're

45144
29:57:10,720 --> 29:57:12,232
going to fix this problem we're going to

45145
29:57:12,232 --> 29:57:13,912
say animal one and we're going to

45146
29:57:13,912 --> 29:57:16,320
release the memory now if we run the

45147
29:57:16,320 --> 29:57:18,080
program we're going to see that we are

45148
29:57:18,080 --> 29:57:21,680
releasing two objects when the program

45149
29:57:21,680 --> 29:57:23,912
ends we're going to clear and run

45150
29:57:23,912 --> 29:57:25,760
rooster and the destructor is going to

45151
29:57:25,760 --> 29:57:28,720
be called two times once for this guy

45152
29:57:28,720 --> 29:57:30,872
and a second for this guy this is what

45153
29:57:30,872 --> 29:57:33,680
we want and you see that because we have

45154
29:57:33,680 --> 29:57:36,400
virtual destructors in our classes we

45155
29:57:36,400 --> 29:57:39,192
are destroying at each level so here we

45156
29:57:39,192 --> 29:57:41,592
are destroying at the feline level and

45157
29:57:41,592 --> 29:57:43,760
we are destroying at the animal level

45158
29:57:43,760 --> 29:57:46,080
and this is going to properly release

45159
29:57:46,080 --> 29:57:48,400
the memory from our inheritance

45160
29:57:48,400 --> 29:57:50,480
hierarchy here so now you know that you

45161
29:57:50,480 --> 29:57:52,960
can do a transformation of references

45162
29:57:52,960 --> 29:57:54,960
using dynamic casts

45163
29:57:54,960 --> 29:57:57,592
but with dynamic cast we have no way to

45164
29:57:57,592 --> 29:58:00,000
check and see if the transformation was

45165
29:58:00,000 --> 29:58:03,040
successful again if we try to turn this

45166
29:58:03,040 --> 29:58:05,440
into a dark reference we can do that and

45167
29:58:05,440 --> 29:58:07,512
we're going to say dog reference here

45168
29:58:07,512 --> 29:58:10,552
and we will try and call the do some

45169
29:58:10,552 --> 29:58:13,120
duck thingy method this is not going to

45170
29:58:13,120 --> 29:58:14,872
give us an indication of a problem but

45171
29:58:14,872 --> 29:58:17,120
this is going to crash at runtime

45172
29:58:17,120 --> 29:58:18,800
because we don't really have any dog

45173
29:58:18,800 --> 29:58:20,400
information in our

45174
29:58:20,400 --> 29:58:23,360
original feline object here so if you

45175
29:58:23,360 --> 29:58:25,760
try and transform this reference into a

45176
29:58:25,760 --> 29:58:28,080
dog reference this is obviously not

45177
29:58:28,080 --> 29:58:29,912
going to work because we have no dog

45178
29:58:29,912 --> 29:58:32,232
information in this to start with let's

45179
29:58:32,232 --> 29:58:34,800
boil and show you the problem the book

45180
29:58:34,800 --> 29:58:37,120
is going to be good so we can clear

45181
29:58:37,120 --> 29:58:39,680
and run rooster you're going to see that

45182
29:58:39,680 --> 29:58:41,832
we are going to terminate our program

45183
29:58:41,832 --> 29:58:44,320
with the band cast and this is going to

45184
29:58:44,320 --> 29:58:46,232
crush you see that we don't get to the

45185
29:58:46,232 --> 29:58:48,960
point where we print done and we are not

45186
29:58:48,960 --> 29:58:50,640
even going to get a chance to release

45187
29:58:50,640 --> 29:58:52,480
the memory that we have allocated in

45188
29:58:52,480 --> 29:58:54,720
this main function hopefully you can see

45189
29:58:54,720 --> 29:58:56,872
that this is really bad so with

45190
29:58:56,872 --> 29:58:59,280
references we have no way

45191
29:58:59,280 --> 29:59:01,512
to check and see if the transformation

45192
29:59:01,512 --> 29:59:04,800
was successful and this is a limitation

45193
29:59:04,800 --> 29:59:07,280
that's why in most cases i usually do my

45194
29:59:07,280 --> 29:59:10,080
transformations through pointers and

45195
29:59:10,080 --> 29:59:12,000
there is a way you can even turn this

45196
29:59:12,000 --> 29:59:14,872
base reference into a base pointer and i

45197
29:59:14,872 --> 29:59:16,960
am going to show you how you can do that

45198
29:59:16,960 --> 29:59:19,512
so we are going to go down here and try

45199
29:59:19,512 --> 29:59:21,280
to change things a little bit we are

45200
29:59:21,280 --> 29:59:23,440
going to say doing proper checks with

45201
29:59:23,440 --> 29:59:25,592
references and we're going to put in a

45202
29:59:25,592 --> 29:59:28,000
piece of code to play with us and what

45203
29:59:28,000 --> 29:59:29,592
we're going to do we're going to take

45204
29:59:29,592 --> 29:59:30,552
the

45205
29:59:30,552 --> 29:59:33,592
base reference and turn that into a base

45206
29:59:33,592 --> 29:59:35,760
pointer this is the syntax here again

45207
29:59:35,760 --> 29:59:38,400
the input is the base reference but the

45208
29:59:38,400 --> 29:59:40,640
output we desire is a base pointer and

45209
29:59:40,640 --> 29:59:43,280
this is possible in c plus plus this is

45210
29:59:43,280 --> 29:59:45,440
going to work just fine now we are going

45211
29:59:45,440 --> 29:59:47,280
to go on top and comment this

45212
29:59:47,280 --> 29:59:49,760
problematic transformation we just tried

45213
29:59:49,760 --> 29:59:51,512
to do and we're going to try and build

45214
29:59:51,512 --> 29:59:53,912
and see if this is actually working

45215
29:59:53,912 --> 29:59:56,080
if this transformation succeeds we're

45216
29:59:56,080 --> 29:59:58,400
going to do some villain thingy if it

45217
29:59:58,400 --> 30:00:00,160
fails we're going to say couldn't cast

45218
30:00:00,160 --> 30:00:02,080
to feline reference and we're going to

45219
30:00:02,080 --> 30:00:04,232
say that we are sorry this is a good

45220
30:00:04,232 --> 30:00:06,640
output message if we get something wrong

45221
30:00:06,640 --> 30:00:08,640
we're going to build this with gcc and

45222
30:00:08,640 --> 30:00:11,192
see if this actually works the world is

45223
30:00:11,192 --> 30:00:12,872
good we can clear

45224
30:00:12,872 --> 30:00:15,512
and run rooster you see that this is

45225
30:00:15,512 --> 30:00:17,280
working just fine we're going to hit the

45226
30:00:17,280 --> 30:00:19,120
end of the program and we are going to

45227
30:00:19,120 --> 30:00:21,440
destroy our objects here this is super

45228
30:00:21,440 --> 30:00:22,320
cool

45229
30:00:22,320 --> 30:00:23,280
but

45230
30:00:23,280 --> 30:00:25,280
if we try and do the transformation and

45231
30:00:25,280 --> 30:00:27,912
transform it to a dark object even if we

45232
30:00:27,912 --> 30:00:29,592
know that we don't have any dog

45233
30:00:29,592 --> 30:00:32,232
information in this object that we are

45234
30:00:32,232 --> 30:00:34,800
referencing to start with we hope that

45235
30:00:34,800 --> 30:00:37,440
we're going to get a good message and

45236
30:00:37,440 --> 30:00:39,120
the program is going to end properly

45237
30:00:39,120 --> 30:00:41,440
we're not going to get a crush so let's

45238
30:00:41,440 --> 30:00:43,440
make sure we are transforming to dog

45239
30:00:43,440 --> 30:00:45,120
here we're going to pass a dog pointer

45240
30:00:45,120 --> 30:00:47,680
as our output and we're going to store

45241
30:00:47,680 --> 30:00:49,760
this as a dog pointer even if the name

45242
30:00:49,760 --> 30:00:52,400
is still vlan pointer hopefully this is

45243
30:00:52,400 --> 30:00:54,552
not going to confuse you even if this is

45244
30:00:54,552 --> 30:00:56,720
named feline pointer it is a dot pointer

45245
30:00:56,720 --> 30:00:59,280
here because we just want to see

45246
30:00:59,280 --> 30:01:01,512
if we get the error message that we have

45247
30:01:01,512 --> 30:01:03,832
here so we are turning this reference

45248
30:01:03,832 --> 30:01:06,960
into a pointer and the benefit of this

45249
30:01:06,960 --> 30:01:09,680
is that a pointer can store

45250
30:01:09,680 --> 30:01:12,160
null pointers and we can use this to our

45251
30:01:12,160 --> 30:01:14,400
advantage to check and see if the

45252
30:01:14,400 --> 30:01:16,800
transformation here was successful if it

45253
30:01:16,800 --> 30:01:19,192
was successful we will call some dog

45254
30:01:19,192 --> 30:01:22,232
thank method let's say that here and if

45255
30:01:22,232 --> 30:01:23,760
this fails we're going to say that we

45256
30:01:23,760 --> 30:01:26,552
couldn't transform to doug and this is

45257
30:01:26,552 --> 30:01:28,960
going to give us a nice message and our

45258
30:01:28,960 --> 30:01:30,960
program is not going to crash we're

45259
30:01:30,960 --> 30:01:33,440
going to build this again with gcc what

45260
30:01:33,440 --> 30:01:35,360
is going to be good as you see here

45261
30:01:35,360 --> 30:01:37,760
we're going to clear and run rooster now

45262
30:01:37,760 --> 30:01:39,512
you see that we are saying we couldn't

45263
30:01:39,512 --> 30:01:41,680
catch the dog reference and our program

45264
30:01:41,680 --> 30:01:44,080
is not crashing so if you have a

45265
30:01:44,080 --> 30:01:46,232
reference to start with and you want to

45266
30:01:46,232 --> 30:01:48,640
do some proper checks after you do the

45267
30:01:48,640 --> 30:01:51,192
transformation to a derived pointer or a

45268
30:01:51,192 --> 30:01:53,440
derived reference this is the best of

45269
30:01:53,440 --> 30:01:55,120
both worlds you can do something like

45270
30:01:55,120 --> 30:01:57,192
this and your program is going to be

45271
30:01:57,192 --> 30:01:59,440
much safer the last thing i want you to

45272
30:01:59,440 --> 30:02:02,400
see is that these kinds of dynamic casts

45273
30:02:02,400 --> 30:02:05,040
are really useful if you are passing

45274
30:02:05,040 --> 30:02:07,280
base pointer or base references into

45275
30:02:07,280 --> 30:02:10,720
functions and here i am going to put in

45276
30:02:10,720 --> 30:02:12,800
a bunch of functions the first one is

45277
30:02:12,800 --> 30:02:14,960
going to take a base pointer the second

45278
30:02:14,960 --> 30:02:16,720
one is going to take a base reference

45279
30:02:16,720 --> 30:02:18,552
and it is going to say do something with

45280
30:02:18,552 --> 30:02:20,720
animal pointer and do something with

45281
30:02:20,720 --> 30:02:22,552
animal reference and inside we're going

45282
30:02:22,552 --> 30:02:24,160
to do our thing here we're going to take

45283
30:02:24,160 --> 30:02:25,832
the animal pointer turn that into a

45284
30:02:25,832 --> 30:02:27,760
feline pointer and we're going to do our

45285
30:02:27,760 --> 30:02:29,280
proper check and we're going to do some

45286
30:02:29,280 --> 30:02:31,680
feline thingy if the transformation was

45287
30:02:31,680 --> 30:02:33,832
successful we can do something like this

45288
30:02:33,832 --> 30:02:36,160
we can also do exactly the same thing

45289
30:02:36,160 --> 30:02:37,912
with references we're going to take our

45290
30:02:37,912 --> 30:02:39,912
input reference we're going to turn that

45291
30:02:39,912 --> 30:02:42,320
into a derived object and we can call

45292
30:02:42,320 --> 30:02:44,552
our method on this pointer and we're

45293
30:02:44,552 --> 30:02:46,480
going to do proper chats because we have

45294
30:02:46,480 --> 30:02:49,120
a pointer which has a concept of node

45295
30:02:49,120 --> 30:02:51,120
pointer that we get if the

45296
30:02:51,120 --> 30:02:53,440
transformation here fails this is the

45297
30:02:53,440 --> 30:02:56,160
setup we can use in our c plus programs

45298
30:02:56,160 --> 30:02:58,000
and we can use these methods to get

45299
30:02:58,000 --> 30:03:00,480
derived pointers that we can call even

45300
30:03:00,480 --> 30:03:02,552
non-polymorphic functions on and this is

45301
30:03:02,552 --> 30:03:05,120
going to work really well so we can go

45302
30:03:05,120 --> 30:03:08,320
down and comment out everything i guess

45303
30:03:08,320 --> 30:03:11,120
to make this super easy to follow but i

45304
30:03:11,120 --> 30:03:12,480
don't think we need to comment out

45305
30:03:12,480 --> 30:03:14,320
everything we can just comment out what

45306
30:03:14,320 --> 30:03:16,160
we just did here and we're going to be

45307
30:03:16,160 --> 30:03:19,040
reusing the reference we have here and

45308
30:03:19,040 --> 30:03:21,040
the pointer we have all the way to the

45309
30:03:21,040 --> 30:03:23,192
top so we're going to go down and put in

45310
30:03:23,192 --> 30:03:25,360
a separator here we can do that and

45311
30:03:25,360 --> 30:03:27,280
because of this separator i don't think

45312
30:03:27,280 --> 30:03:30,080
we even need to comment things out we

45313
30:03:30,080 --> 30:03:31,592
can remove our comment and leave the

45314
30:03:31,592 --> 30:03:34,000
code in because i want you to see that

45315
30:03:34,000 --> 30:03:36,552
super easily and we're going to call our

45316
30:03:36,552 --> 30:03:37,832
functions here we're going to say do

45317
30:03:37,832 --> 30:03:40,000
something with animal pointer and we're

45318
30:03:40,000 --> 30:03:42,080
going to pass an animal one which is a

45319
30:03:42,080 --> 30:03:43,680
pointer and we're going to say do

45320
30:03:43,680 --> 30:03:46,080
something with animal ref

45321
30:03:46,080 --> 30:03:48,080
we can do something like this and we're

45322
30:03:48,080 --> 30:03:50,480
going to pass an animal

45323
30:03:50,480 --> 30:03:52,320
ref we have this reference here and we

45324
30:03:52,320 --> 30:03:54,160
can do something like this you're going

45325
30:03:54,160 --> 30:03:56,800
to see that this is not going to give us

45326
30:03:56,800 --> 30:03:58,480
any kind of problem and it is going to

45327
30:03:58,480 --> 30:04:00,232
work just fine that's world we're going

45328
30:04:00,232 --> 30:04:02,320
to pass this through gcc the photo is

45329
30:04:02,320 --> 30:04:04,400
going to be good we can clear and run

45330
30:04:04,400 --> 30:04:06,552
rooster and down here you see that in

45331
30:04:06,552 --> 30:04:08,720
function taking base pointer doing some

45332
30:04:08,720 --> 30:04:11,192
feline thingy in function taking some

45333
30:04:11,192 --> 30:04:13,512
biz reference doing some feeling thingy

45334
30:04:13,512 --> 30:04:15,592
and this is working really fine this is

45335
30:04:15,592 --> 30:04:18,480
what we want in our c plus plus programs

45336
30:04:18,480 --> 30:04:20,400
this is really all i wanted you to see

45337
30:04:20,400 --> 30:04:22,080
in this lecture hopefully you didn't

45338
30:04:22,080 --> 30:04:24,480
find it confusing again the message is

45339
30:04:24,480 --> 30:04:27,040
that you can do dynamic casts to

45340
30:04:27,040 --> 30:04:29,440
transform from a base pointer to a

45341
30:04:29,440 --> 30:04:32,640
derived pointer or to transform from a

45342
30:04:32,640 --> 30:04:35,440
base reference to a derived reference as

45343
30:04:35,440 --> 30:04:36,552
we did

45344
30:04:36,552 --> 30:04:39,440
right here but transforming to a derived

45345
30:04:39,440 --> 30:04:42,640
reference has a drawback in that you

45346
30:04:42,640 --> 30:04:45,040
don't have a way to check and see

45347
30:04:45,040 --> 30:04:47,512
if the transformation was successful so

45348
30:04:47,512 --> 30:04:49,360
if you want to be able to do chats you

45349
30:04:49,360 --> 30:04:51,192
can do something like this and turn a

45350
30:04:51,192 --> 30:04:53,760
base reference into a derived pointer

45351
30:04:53,760 --> 30:04:55,912
and then we can check and see if the

45352
30:04:55,912 --> 30:04:58,000
pointer is not a node pointer if it's a

45353
30:04:58,000 --> 30:04:59,440
no pointer we will know that the

45354
30:04:59,440 --> 30:05:01,512
transformation failed and we will print

45355
30:05:01,512 --> 30:05:03,360
a good error message if the

45356
30:05:03,360 --> 30:05:05,192
transformation was successful we will

45357
30:05:05,192 --> 30:05:07,680
have a valid pointer in here and we will

45358
30:05:07,680 --> 30:05:10,872
call our derived non-polymorphic method

45359
30:05:10,872 --> 30:05:13,120
on our pointer this is going to work

45360
30:05:13,120 --> 30:05:14,960
really fine the last thing i want you to

45361
30:05:14,960 --> 30:05:17,680
see before we wrap up this lecture is

45362
30:05:17,680 --> 30:05:20,552
that dynamic casts are only going to

45363
30:05:20,552 --> 30:05:23,280
work with polymorphic inheritance

45364
30:05:23,280 --> 30:05:26,232
hierarchies so for example if we try and

45365
30:05:26,232 --> 30:05:29,680
turn a double into a string obviously

45366
30:05:29,680 --> 30:05:31,040
that's not going to work with the

45367
30:05:31,040 --> 30:05:33,280
dynamic cast but let's try and do that

45368
30:05:33,280 --> 30:05:34,960
to really show you that this is going to

45369
30:05:34,960 --> 30:05:36,800
give us a problem we're going to say

45370
30:05:36,800 --> 30:05:38,720
sddc out and we're going to put in a

45371
30:05:38,720 --> 30:05:40,800
separator here and we're going to set up

45372
30:05:40,800 --> 30:05:42,960
two variables one is going to be a net

45373
30:05:42,960 --> 30:05:44,640
for example and we're going to say data

45374
30:05:44,640 --> 30:05:47,680
we're going to put in a 45 and if we do

45375
30:05:47,680 --> 30:05:50,232
a dynamic cast to an sdd string for

45376
30:05:50,232 --> 30:05:52,320
example that's not going to work we're

45377
30:05:52,320 --> 30:05:56,160
going to say std string yana str meaning

45378
30:05:56,160 --> 30:05:58,400
that this is a string we're going to say

45379
30:05:58,400 --> 30:06:00,800
dynamic cast let's say we want to turn

45380
30:06:00,800 --> 30:06:03,592
this into an sdd string for example and

45381
30:06:03,592 --> 30:06:05,440
the input is going to be our data if

45382
30:06:05,440 --> 30:06:06,872
you're trying to do something like this

45383
30:06:06,872 --> 30:06:08,480
this is going to blow up you see that

45384
30:06:08,480 --> 30:06:10,320
even visual studio code is giving us a

45385
30:06:10,320 --> 30:06:12,320
squiggly line so this is not going to

45386
30:06:12,320 --> 30:06:16,160
work just make sure you use dynamic cast

45387
30:06:16,160 --> 30:06:19,120
in an inheritance hierarchy that

45388
30:06:19,120 --> 30:06:22,320
supports virtual functions this is the

45389
30:06:22,320 --> 30:06:25,680
design purpose for the dynamic cast if

45390
30:06:25,680 --> 30:06:28,552
you use this outside this context you're

45391
30:06:28,552 --> 30:06:30,800
going to get undefined behavior or even

45392
30:06:30,800 --> 30:06:33,040
compiler errors if you are lucky let's

45393
30:06:33,040 --> 30:06:34,480
try and weld and show you this we're

45394
30:06:34,480 --> 30:06:36,720
going to pass this through gcc and we're

45395
30:06:36,720 --> 30:06:38,400
probably going to get an error saying

45396
30:06:38,400 --> 30:06:41,360
that we can't transform from an integer

45397
30:06:41,360 --> 30:06:43,512
to a string for example let's go here

45398
30:06:43,512 --> 30:06:46,480
cannot dynamic cast so basically it is

45399
30:06:46,480 --> 30:06:49,512
saying dynamic casts are meant to work

45400
30:06:49,512 --> 30:06:52,400
only with pointers or references but

45401
30:06:52,400 --> 30:06:55,832
even then let's see if we can transform

45402
30:06:55,832 --> 30:06:58,552
from an end pointer to a string pointer

45403
30:06:58,552 --> 30:07:01,120
let's try and do that let's say we want

45404
30:07:01,120 --> 30:07:04,400
to turn the address of data or let's set

45405
30:07:04,400 --> 30:07:06,640
up a pointer to be explicit we're going

45406
30:07:06,640 --> 30:07:09,280
to say data ptr and we're going to

45407
30:07:09,280 --> 30:07:11,760
initialize this with the address of data

45408
30:07:11,760 --> 30:07:13,592
we can do something like this and we're

45409
30:07:13,592 --> 30:07:17,040
going to cast data ptr to an std

45410
30:07:17,040 --> 30:07:18,960
strength pointer let's see if we can do

45411
30:07:18,960 --> 30:07:21,512
this because it is meant to cast

45412
30:07:21,512 --> 30:07:23,592
between pointers and references but you

45413
30:07:23,592 --> 30:07:26,160
see that this is even not going to work

45414
30:07:26,160 --> 30:07:28,000
so you shouldn't really do something

45415
30:07:28,000 --> 30:07:31,280
like this if your input and output are

45416
30:07:31,280 --> 30:07:33,680
not part of the same polymorphic

45417
30:07:33,680 --> 30:07:36,160
inheritance hierarchy again dynamic

45418
30:07:36,160 --> 30:07:38,232
casts are meant to cast

45419
30:07:38,232 --> 30:07:40,640
from base information to derived

45420
30:07:40,640 --> 30:07:43,680
information and the input and output

45421
30:07:43,680 --> 30:07:46,960
must be part of the same polymorphic

45422
30:07:46,960 --> 30:07:49,040
inheritance hierarchy this is the

45423
30:07:49,040 --> 30:07:51,440
information i am trying to convey here

45424
30:07:51,440 --> 30:07:53,360
so this is bad don't do something like

45425
30:07:53,360 --> 30:07:55,040
this if you do this you're going to get

45426
30:07:55,040 --> 30:07:57,192
undefined behavior or you're even going

45427
30:07:57,192 --> 30:07:59,360
to get a bunch of compiler errors if you

45428
30:07:59,360 --> 30:08:01,680
are lucky this is really all we set up

45429
30:08:01,680 --> 30:08:03,592
to do in this lecture showing you that

45430
30:08:03,592 --> 30:08:06,232
you can use dynamic casts we are going

45431
30:08:06,232 --> 30:08:08,232
to stop here in this lecture the next

45432
30:08:08,232 --> 30:08:10,640
one we're going to show you what happens

45433
30:08:10,640 --> 30:08:12,872
if you try to call a polymorphic

45434
30:08:12,872 --> 30:08:15,440
function from a destructor

45435
30:08:15,440 --> 30:08:17,592
go ahead and finish up here and meet me

45436
30:08:17,592 --> 30:08:19,912
there in this lecture i am going to give

45437
30:08:19,912 --> 30:08:23,512
you a warning and that is to never call

45438
30:08:23,512 --> 30:08:26,640
virtual functions from constructors or

45439
30:08:26,640 --> 30:08:29,192
destructors i am going to repeat this

45440
30:08:29,192 --> 30:08:32,080
never never call virtual or polymorphic

45441
30:08:32,080 --> 30:08:34,720
functions either from constructors or

45442
30:08:34,720 --> 30:08:36,800
destructors and we're going to explore

45443
30:08:36,800 --> 30:08:38,480
why we're going to be using this

45444
30:08:38,480 --> 30:08:39,912
inheritance hierarchy we're going to

45445
30:08:39,912 --> 30:08:42,160
have a base class called base how

45446
30:08:42,160 --> 30:08:44,400
creative we're going to inherit from

45447
30:08:44,400 --> 30:08:47,040
base and create derived which is our

45448
30:08:47,040 --> 30:08:49,440
inherited class and we're going to be

45449
30:08:49,440 --> 30:08:51,912
using this to explore why we can't call

45450
30:08:51,912 --> 30:08:54,320
virtual functions from constructors and

45451
30:08:54,320 --> 30:08:55,680
destructors

45452
30:08:55,680 --> 30:08:57,512
this is what our code is going to look

45453
30:08:57,512 --> 30:09:00,080
like the base class is going to have a

45454
30:09:00,080 --> 30:09:02,232
protected member variable it's going to

45455
30:09:02,232 --> 30:09:04,480
have a bunch of virtual functions

45456
30:09:04,480 --> 30:09:07,120
we will have a virtual function to set

45457
30:09:07,120 --> 30:09:09,192
things up and it is just going to set

45458
30:09:09,192 --> 30:09:11,912
the value of our member variable to 10

45459
30:09:11,912 --> 30:09:13,280
and we're going to have a virtual

45460
30:09:13,280 --> 30:09:15,280
function called cleanup which is going

45461
30:09:15,280 --> 30:09:17,512
to maybe do some cleanup we're going to

45462
30:09:17,512 --> 30:09:20,080
see how this works out we also have a

45463
30:09:20,080 --> 30:09:22,000
method to get the value but i don't

45464
30:09:22,000 --> 30:09:24,160
think we will use this but you can keep

45465
30:09:24,160 --> 30:09:26,800
this and if you want notice that we are

45466
30:09:26,800 --> 30:09:29,192
trying to call the setup method from the

45467
30:09:29,192 --> 30:09:30,720
constructor

45468
30:09:30,720 --> 30:09:32,872
and you see that we have a comment that

45469
30:09:32,872 --> 30:09:34,552
says that this is going to do static

45470
30:09:34,552 --> 30:09:36,320
binding but we're going to see why in a

45471
30:09:36,320 --> 30:09:38,872
minute so this is our base class we can

45472
30:09:38,872 --> 30:09:41,120
derive from this class and create our

45473
30:09:41,120 --> 30:09:42,960
derived class we're going to inherit

45474
30:09:42,960 --> 30:09:44,160
publicly

45475
30:09:44,160 --> 30:09:46,872
and we are going to override the methods

45476
30:09:46,872 --> 30:09:49,120
we have in the base class we're going to

45477
30:09:49,120 --> 30:09:51,192
override the setup method as you see

45478
30:09:51,192 --> 30:09:52,872
here we're going to override the cleanup

45479
30:09:52,872 --> 30:09:54,800
method and

45480
30:09:54,800 --> 30:09:56,640
our destructor is also going to be

45481
30:09:56,640 --> 30:09:58,872
virtual because we are good c plus plus

45482
30:09:58,872 --> 30:10:01,440
citizens and this is the setup we have

45483
30:10:01,440 --> 30:10:03,512
once you have your inheritance hierarchy

45484
30:10:03,512 --> 30:10:05,360
set up you're going to do something like

45485
30:10:05,360 --> 30:10:07,440
this because you want polymorphic

45486
30:10:07,440 --> 30:10:09,440
behavior you're going to set up the base

45487
30:10:09,440 --> 30:10:11,192
pointer and you're going to use that to

45488
30:10:11,192 --> 30:10:13,912
manage a derived object and you can do

45489
30:10:13,912 --> 30:10:16,080
something like this now

45490
30:10:16,080 --> 30:10:18,160
considering this statement here i want

45491
30:10:18,160 --> 30:10:20,720
you to think about the order in which

45492
30:10:20,720 --> 30:10:22,960
constructors and destructors are going

45493
30:10:22,960 --> 30:10:25,120
to be called we have touched on this

45494
30:10:25,120 --> 30:10:27,832
subject before and we are going to

45495
30:10:27,832 --> 30:10:29,760
revisit this because it is really

45496
30:10:29,760 --> 30:10:30,960
important

45497
30:10:30,960 --> 30:10:33,592
in terms of calling virtual functions in

45498
30:10:33,592 --> 30:10:35,832
destructors and destructors

45499
30:10:35,832 --> 30:10:37,832
so when we do something like this the

45500
30:10:37,832 --> 30:10:40,232
base part of this object is going to be

45501
30:10:40,232 --> 30:10:42,552
wealth first so we are going to call the

45502
30:10:42,552 --> 30:10:44,320
base constructor first we're going to

45503
30:10:44,320 --> 30:10:46,800
set up the best part of us after that

45504
30:10:46,800 --> 30:10:48,872
we're going to set up the derived part

45505
30:10:48,872 --> 30:10:50,400
of us and we're going to call the

45506
30:10:50,400 --> 30:10:52,160
derived constructor

45507
30:10:52,160 --> 30:10:54,960
and after the derived part of us is set

45508
30:10:54,960 --> 30:10:57,512
up we can use our object like we do

45509
30:10:57,512 --> 30:10:59,832
always so we're going to use our object

45510
30:10:59,832 --> 30:11:02,080
to do whatever it is we want to do when

45511
30:11:02,080 --> 30:11:04,720
the time comes for this object to be

45512
30:11:04,720 --> 30:11:07,120
destroyed we're going to destroy the

45513
30:11:07,120 --> 30:11:09,512
derived part first

45514
30:11:09,512 --> 30:11:11,760
and then we're going to destroy the base

45515
30:11:11,760 --> 30:11:13,440
part first

45516
30:11:13,440 --> 30:11:15,760
now that we have considered this order

45517
30:11:15,760 --> 30:11:17,512
try to think about the setup when we

45518
30:11:17,512 --> 30:11:20,080
call a virtual function

45519
30:11:20,080 --> 30:11:21,760
from a constructor that's what we're

45520
30:11:21,760 --> 30:11:23,512
going to look at first the best

45521
30:11:23,512 --> 30:11:25,592
constructor is going to be called but

45522
30:11:25,592 --> 30:11:27,760
notice that by the time we call the base

45523
30:11:27,760 --> 30:11:30,640
constructor the derived part of us won't

45524
30:11:30,640 --> 30:11:33,912
be set up yet so if we try to call a

45525
30:11:33,912 --> 30:11:36,960
virtual function in the base constructor

45526
30:11:36,960 --> 30:11:39,760
there won't be a derived part to call

45527
30:11:39,760 --> 30:11:42,720
the most specialized method for so the

45528
30:11:42,720 --> 30:11:44,640
compiler will notice that we don't have

45529
30:11:44,640 --> 30:11:47,040
a derived part yet we will be at this

45530
30:11:47,040 --> 30:11:49,592
stage building the base part and if we

45531
30:11:49,592 --> 30:11:52,000
call a virtual polymorphic function we

45532
30:11:52,000 --> 30:11:54,000
want the most specific parts to be

45533
30:11:54,000 --> 30:11:56,640
called which should live in the derived

45534
30:11:56,640 --> 30:11:58,720
part but we haven't done the derived

45535
30:11:58,720 --> 30:12:01,280
part yet we are still building the base

45536
30:12:01,280 --> 30:12:03,040
part of us so the compiler is going to

45537
30:12:03,040 --> 30:12:05,192
notice that we don't have a derived part

45538
30:12:05,192 --> 30:12:07,120
and it is going to call the base version

45539
30:12:07,120 --> 30:12:09,192
of our virtual function that's why we

45540
30:12:09,192 --> 30:12:11,440
said that if you call a virtual function

45541
30:12:11,440 --> 30:12:13,760
from a constructor or a destructor

45542
30:12:13,760 --> 30:12:15,360
you're going to get static binding

45543
30:12:15,360 --> 30:12:17,592
results if you call a virtual function

45544
30:12:17,592 --> 30:12:19,512
you want the most specific version

45545
30:12:19,512 --> 30:12:22,160
called but we don't have that yet in the

45546
30:12:22,160 --> 30:12:24,872
base part because the derived part

45547
30:12:24,872 --> 30:12:26,872
haven't been set up that's why we get

45548
30:12:26,872 --> 30:12:29,040
static binding results i hope this makes

45549
30:12:29,040 --> 30:12:30,800
sense and we're going to get to the same

45550
30:12:30,800 --> 30:12:32,800
result if you try to call a virtual

45551
30:12:32,800 --> 30:12:35,680
function from a destructor if we get to

45552
30:12:35,680 --> 30:12:37,680
the point where our object needs to be

45553
30:12:37,680 --> 30:12:39,592
destroyed the derived part is going to

45554
30:12:39,592 --> 30:12:41,680
be wiped out first we're going to be

45555
30:12:41,680 --> 30:12:43,440
left with the base destructor and when

45556
30:12:43,440 --> 30:12:46,000
we hit this base destructor and call a

45557
30:12:46,000 --> 30:12:47,512
virtual function

45558
30:12:47,512 --> 30:12:49,360
that would mean to call the most

45559
30:12:49,360 --> 30:12:50,640
specialized

45560
30:12:50,640 --> 30:12:54,080
version of that method but the derived

45561
30:12:54,080 --> 30:12:56,320
part of our object has been already

45562
30:12:56,320 --> 30:12:59,120
wiped down so this is no longer existent

45563
30:12:59,120 --> 30:13:00,800
and we are trying to call the method on

45564
30:13:00,800 --> 30:13:02,552
this so the compiler is going to do the

45565
30:13:02,552 --> 30:13:04,640
next best thing it can do it is going to

45566
30:13:04,640 --> 30:13:06,552
call the best version of our virtual

45567
30:13:06,552 --> 30:13:08,720
function and again we are going to get

45568
30:13:08,720 --> 30:13:11,832
static binding results that's why it

45569
30:13:11,832 --> 30:13:13,680
isn't really wise to call a virtual

45570
30:13:13,680 --> 30:13:16,320
function either from a constructor or a

45571
30:13:16,320 --> 30:13:18,232
destructor now some of you must be

45572
30:13:18,232 --> 30:13:20,960
asking what if i really need to do setup

45573
30:13:20,960 --> 30:13:22,872
and clean up in the way that we set up

45574
30:13:22,872 --> 30:13:25,280
these things in our classes what if this

45575
30:13:25,280 --> 30:13:27,040
method is really useful maybe it is

45576
30:13:27,040 --> 30:13:28,320
setting up things we're going to be

45577
30:13:28,320 --> 30:13:30,480
using in our application we really need

45578
30:13:30,480 --> 30:13:33,192
this and the most logical point to call

45579
30:13:33,192 --> 30:13:35,440
this is the base constructor well you

45580
30:13:35,440 --> 30:13:36,872
shouldn't really put these in a

45581
30:13:36,872 --> 30:13:39,592
constructor what you could do

45582
30:13:39,592 --> 30:13:42,640
is maybe call this virtual method on

45583
30:13:42,640 --> 30:13:45,592
your object directly when the object has

45584
30:13:45,592 --> 30:13:47,512
finished being a constructor that's

45585
30:13:47,512 --> 30:13:49,832
going to be a better place to do this

45586
30:13:49,832 --> 30:13:52,872
because if you put that in a constructor

45587
30:13:52,872 --> 30:13:54,872
or a destructor you're not going to get

45588
30:13:54,872 --> 30:13:56,872
dynamic binding results and that's going

45589
30:13:56,872 --> 30:13:59,832
to be really bad so to sum up calling a

45590
30:13:59,832 --> 30:14:01,192
virtual function

45591
30:14:01,192 --> 30:14:03,440
from a constructor or a destructor want

45592
30:14:03,440 --> 30:14:05,832
to give you polymorphic or dynamic

45593
30:14:05,832 --> 30:14:08,400
binding results the call will never go

45594
30:14:08,400 --> 30:14:10,320
to a more derived class than the

45595
30:14:10,320 --> 30:14:12,400
currently executing constructor or

45596
30:14:12,400 --> 30:14:13,680
disruptor

45597
30:14:13,680 --> 30:14:15,912
and we will get static binding results

45598
30:14:15,912 --> 30:14:18,720
this is the idea i want to convey here

45599
30:14:18,720 --> 30:14:21,592
and as a guideline you should never call

45600
30:14:21,592 --> 30:14:23,760
virtual functions or polymorphic

45601
30:14:23,760 --> 30:14:26,080
functions from constructors or

45602
30:14:26,080 --> 30:14:28,320
disruptors if you really need this the

45603
30:14:28,320 --> 30:14:31,440
next best thing you can do is to call

45604
30:14:31,440 --> 30:14:33,760
your virtual functions directly on your

45605
30:14:33,760 --> 30:14:36,400
object after the object has been

45606
30:14:36,400 --> 30:14:37,440
properly

45607
30:14:37,440 --> 30:14:39,440
set up we can do something like this and

45608
30:14:39,440 --> 30:14:41,680
call our setup method and then we can

45609
30:14:41,680 --> 30:14:43,512
call cleanup when we think that we need

45610
30:14:43,512 --> 30:14:46,000
to clean up and you call cleanup after

45611
30:14:46,000 --> 30:14:48,160
you construct the object and you call

45612
30:14:48,160 --> 30:14:50,480
delete after you clean up your object

45613
30:14:50,480 --> 30:14:52,872
this is going to do whatever it is you

45614
30:14:52,872 --> 30:14:54,800
want to do with your polymorphic

45615
30:14:54,800 --> 30:14:57,120
functions and the calls to these virtual

45616
30:14:57,120 --> 30:14:59,192
functions want to be leaving inside a

45617
30:14:59,192 --> 30:15:01,280
constructor or a disruptor and this is

45618
30:15:01,280 --> 30:15:03,040
going to work really well now that you

45619
30:15:03,040 --> 30:15:04,400
know this we're going to head over to

45620
30:15:04,400 --> 30:15:06,160
visual studio code and play with us a

45621
30:15:06,160 --> 30:15:08,960
little more here we are in our working

45622
30:15:08,960 --> 30:15:10,720
folder the current project is

45623
30:15:10,720 --> 30:15:13,192
polymorphic functions and the structures

45624
30:15:13,192 --> 30:15:15,360
we should really say with constructors

45625
30:15:15,360 --> 30:15:17,440
and instructors but this is going to do

45626
30:15:17,440 --> 30:15:20,160
we're going to grab our template files

45627
30:15:20,160 --> 30:15:22,480
and we're going to put them in place and

45628
30:15:22,480 --> 30:15:24,400
we are going to open this little guy in

45629
30:15:24,400 --> 30:15:26,080
visual studio code by dragging and

45630
30:15:26,080 --> 30:15:28,232
dropping here this is going to give us

45631
30:15:28,232 --> 30:15:30,800
our main cpp file we can clean up a

45632
30:15:30,800 --> 30:15:32,552
little bit remove whatever it is we

45633
30:15:32,552 --> 30:15:35,192
don't need and i am just going to put in

45634
30:15:35,192 --> 30:15:37,592
my classes i am going to do that in the

45635
30:15:37,592 --> 30:15:40,000
main cpp file because that's going to be

45636
30:15:40,000 --> 30:15:42,872
much easier to follow we have our base

45637
30:15:42,872 --> 30:15:44,960
class it is going to have a single

45638
30:15:44,960 --> 30:15:47,440
member variable called m value and we

45639
30:15:47,440 --> 30:15:50,552
will have a virtual destructor

45640
30:15:50,552 --> 30:15:52,640
we will have a bunch of virtual

45641
30:15:52,640 --> 30:15:54,640
functions one is going to be setup which

45642
30:15:54,640 --> 30:15:56,552
is going to set our value the other is

45643
30:15:56,552 --> 30:15:58,320
going to be cleanup which is going to be

45644
30:15:58,320 --> 30:16:00,720
doing some cleanup here we will also

45645
30:16:00,720 --> 30:16:03,280
have a getvalue method which will get

45646
30:16:03,280 --> 30:16:05,440
this value and print it out if we want

45647
30:16:05,440 --> 30:16:08,000
but it is really not that useful here we

45648
30:16:08,000 --> 30:16:10,080
will also create a derived class which

45649
30:16:10,080 --> 30:16:12,800
is going to inherit publicly from base

45650
30:16:12,800 --> 30:16:14,720
it is not going to have its own member

45651
30:16:14,720 --> 30:16:17,040
variable all it's going to do is set up

45652
30:16:17,040 --> 30:16:19,512
a bunch of overrides for

45653
30:16:19,512 --> 30:16:21,360
the virtual functions we have in the

45654
30:16:21,360 --> 30:16:23,760
base class we're going to override setup

45655
30:16:23,760 --> 30:16:25,592
and in derived we're going to set our

45656
30:16:25,592 --> 30:16:28,160
value to 100 and we're going to clean up

45657
30:16:28,160 --> 30:16:30,080
and put a message that we are cleaning

45658
30:16:30,080 --> 30:16:32,480
up here once we have this set up we can

45659
30:16:32,480 --> 30:16:34,872
head over in the main function and set

45660
30:16:34,872 --> 30:16:36,720
up a base pointer which is going to be

45661
30:16:36,720 --> 30:16:39,832
managing a derived object a classic

45662
30:16:39,832 --> 30:16:41,912
setup for polymorphic behavior so we're

45663
30:16:41,912 --> 30:16:44,160
going to say base and i'm going to say p

45664
30:16:44,160 --> 30:16:46,080
bass and we're going to say equals new

45665
30:16:46,080 --> 30:16:48,872
derived this is going to give us our

45666
30:16:48,872 --> 30:16:51,040
object which is managed by a base

45667
30:16:51,040 --> 30:16:53,192
pointer and one thing i didn't show you

45668
30:16:53,192 --> 30:16:55,592
is that we are calling the setup virtual

45669
30:16:55,592 --> 30:16:56,720
function

45670
30:16:56,720 --> 30:17:00,000
from the base constructor this is what

45671
30:17:00,000 --> 30:17:01,512
we want to see we want to see what is

45672
30:17:01,512 --> 30:17:04,400
happening here now if we call this setup

45673
30:17:04,400 --> 30:17:05,512
function

45674
30:17:05,512 --> 30:17:08,232
we would expect polymorphism to kick in

45675
30:17:08,232 --> 30:17:10,320
because this is a virtual function

45676
30:17:10,320 --> 30:17:12,640
if the derived part is available we will

45677
30:17:12,640 --> 30:17:15,280
call the most specific setup function

45678
30:17:15,280 --> 30:17:18,320
and that would set up the value to be

45679
30:17:18,320 --> 30:17:21,040
100 here if we get the value that's what

45680
30:17:21,040 --> 30:17:23,120
we would get let's see what we get here

45681
30:17:23,120 --> 30:17:25,280
if we try to get the

45682
30:17:25,280 --> 30:17:27,760
value that we have in this object here

45683
30:17:27,760 --> 30:17:30,480
so we will get auto value and we're

45684
30:17:30,480 --> 30:17:33,512
going to say p base get value we have

45685
30:17:33,512 --> 30:17:35,440
this function here and we will try to

45686
30:17:35,440 --> 30:17:37,512
print this out okay this is something we

45687
30:17:37,512 --> 30:17:40,080
can do in our c plus bus program and

45688
30:17:40,080 --> 30:17:41,592
we're going to see the value we get

45689
30:17:41,592 --> 30:17:43,512
because we are calling this virtual

45690
30:17:43,512 --> 30:17:45,912
function we expect polymorphism to kick

45691
30:17:45,912 --> 30:17:48,480
in and if polymorphism kicks in we're

45692
30:17:48,480 --> 30:17:50,640
going to call the most specialized

45693
30:17:50,640 --> 30:17:52,800
version of our virtual function here

45694
30:17:52,800 --> 30:17:54,480
that would be the override we have in

45695
30:17:54,480 --> 30:17:57,040
derived and that would give us 100. so

45696
30:17:57,040 --> 30:17:59,680
one would get to get 100 printed out

45697
30:17:59,680 --> 30:18:01,360
here but let's see what we get we're

45698
30:18:01,360 --> 30:18:04,080
going to run this through gcc our

45699
30:18:04,080 --> 30:18:05,832
favorite compiler the builder is going

45700
30:18:05,832 --> 30:18:08,480
to be good we can clear or bring up a

45701
30:18:08,480 --> 30:18:10,720
powershell window we're going to clear

45702
30:18:10,720 --> 30:18:13,040
now and run rooster we're going to see

45703
30:18:13,040 --> 30:18:14,960
that the base constructor is going to be

45704
30:18:14,960 --> 30:18:17,192
called base setup was called you see we

45705
30:18:17,192 --> 30:18:19,832
called the base version of this and the

45706
30:18:19,832 --> 30:18:22,480
derived constructor will be called and

45707
30:18:22,480 --> 30:18:24,232
we're going to see that the value

45708
30:18:24,232 --> 30:18:26,960
doesn't exist oh we didn't put the value

45709
30:18:26,960 --> 30:18:29,360
out let's do that my bad here we're

45710
30:18:29,360 --> 30:18:31,040
going to build again we're going to use

45711
30:18:31,040 --> 30:18:33,512
gcc to build and the world is good we

45712
30:18:33,512 --> 30:18:36,232
can clear and run rooster now we see

45713
30:18:36,232 --> 30:18:38,232
that the base setup method was called

45714
30:18:38,232 --> 30:18:41,440
and set the value to b10 and we are

45715
30:18:41,440 --> 30:18:43,680
really getting static binding results

45716
30:18:43,680 --> 30:18:46,080
because we are calling the setup

45717
30:18:46,080 --> 30:18:48,400
method from the base class and the base

45718
30:18:48,400 --> 30:18:50,800
version is being called so this is

45719
30:18:50,800 --> 30:18:54,000
classic static binding behavior but we

45720
30:18:54,000 --> 30:18:56,720
want polymorphic behavior to be working

45721
30:18:56,720 --> 30:19:00,000
here but we just saw the reason why this

45722
30:19:00,000 --> 30:19:02,640
is in the slides by the time we call

45723
30:19:02,640 --> 30:19:05,360
this virtual function we haven't set up

45724
30:19:05,360 --> 30:19:07,680
the derived part of us yet

45725
30:19:07,680 --> 30:19:11,040
and we have no way to call this virtual

45726
30:19:11,040 --> 30:19:13,912
function which lives in the derived part

45727
30:19:13,912 --> 30:19:16,000
of us so the compiler is going to do the

45728
30:19:16,000 --> 30:19:18,000
next best thing it can do it's going to

45729
30:19:18,000 --> 30:19:20,080
call the best version of this method and

45730
30:19:20,080 --> 30:19:22,480
we are going to get static binding

45731
30:19:22,480 --> 30:19:24,872
results and we are going to get the same

45732
30:19:24,872 --> 30:19:27,280
results if we try to call a virtual

45733
30:19:27,280 --> 30:19:30,080
function from the destructor for example

45734
30:19:30,080 --> 30:19:33,360
if we go in our destructor here

45735
30:19:33,360 --> 30:19:35,040
let's see if we can find it we're going

45736
30:19:35,040 --> 30:19:36,960
to go in our instructor here and say

45737
30:19:36,960 --> 30:19:39,120
this and say cleanup can do something

45738
30:19:39,120 --> 30:19:41,120
like this and you're going to see that

45739
30:19:41,120 --> 30:19:43,512
the cleanup version we call is the base

45740
30:19:43,512 --> 30:19:45,280
version of cleanup

45741
30:19:45,280 --> 30:19:47,280
and we don't really want to do something

45742
30:19:47,280 --> 30:19:49,912
like this we want the most derived

45743
30:19:49,912 --> 30:19:51,832
cleanup version to be called but we

45744
30:19:51,832 --> 30:19:54,232
won't get that because by the moment we

45745
30:19:54,232 --> 30:19:57,280
call this virtual function from our base

45746
30:19:57,280 --> 30:19:58,320
class

45747
30:19:58,320 --> 30:20:00,872
the derived part will already have been

45748
30:20:00,872 --> 30:20:03,512
wiped out so it won't be available and

45749
30:20:03,512 --> 30:20:06,480
the compiler will do the next best thing

45750
30:20:06,480 --> 30:20:08,640
it can do it is going to call the best

45751
30:20:08,640 --> 30:20:10,552
version of our cleanup function here i

45752
30:20:10,552 --> 30:20:12,872
hope this makes sense

45753
30:20:12,872 --> 30:20:14,872
again to really drive this home i

45754
30:20:14,872 --> 30:20:17,192
realize this can be confusing to many

45755
30:20:17,192 --> 30:20:19,760
people especially beginners if we are

45756
30:20:19,760 --> 30:20:21,280
calling a virtual function from a

45757
30:20:21,280 --> 30:20:23,760
constructor we will call that virtual

45758
30:20:23,760 --> 30:20:25,440
function when we hit the base

45759
30:20:25,440 --> 30:20:27,680
constructor but by the time we hit the

45760
30:20:27,680 --> 30:20:29,832
base constructor the derived part of us

45761
30:20:29,832 --> 30:20:32,640
hasn't been constructed yet so if we try

45762
30:20:32,640 --> 30:20:34,960
to call a polymorphic function needing

45763
30:20:34,960 --> 30:20:37,192
to hold the derived implementation that

45764
30:20:37,192 --> 30:20:39,512
won't be available and the compiler will

45765
30:20:39,512 --> 30:20:42,080
do the next best thing it can do it is

45766
30:20:42,080 --> 30:20:43,912
going to call the base version the same

45767
30:20:43,912 --> 30:20:45,512
phenomenon is going to happen in the

45768
30:20:45,512 --> 30:20:48,232
destructor when we are done using our

45769
30:20:48,232 --> 30:20:50,720
object we will destroy the derived part

45770
30:20:50,720 --> 30:20:53,512
information first and when we hit the

45771
30:20:53,512 --> 30:20:55,440
base destructor and call a virtual

45772
30:20:55,440 --> 30:20:57,440
function there won't be a most

45773
30:20:57,440 --> 30:20:59,760
specialized version of the virtual

45774
30:20:59,760 --> 30:21:02,160
function because the derived part has

45775
30:21:02,160 --> 30:21:04,160
been already destroyed and it doesn't

45776
30:21:04,160 --> 30:21:06,800
exist anymore so if we call a virtual

45777
30:21:06,800 --> 30:21:08,960
function from the base destructor we

45778
30:21:08,960 --> 30:21:10,872
will get the best version called and

45779
30:21:10,872 --> 30:21:13,040
this will give us static binding

45780
30:21:13,040 --> 30:21:15,040
behavior this is what we are

45781
30:21:15,040 --> 30:21:17,912
experiencing here okay so let's try and

45782
30:21:17,912 --> 30:21:20,640
run this program and see what we get we

45783
30:21:20,640 --> 30:21:22,480
will print out value here which is going

45784
30:21:22,480 --> 30:21:25,040
to give us static binding results but we

45785
30:21:25,040 --> 30:21:28,232
want to see which version of cleanup is

45786
30:21:28,232 --> 30:21:30,232
called this is what we want to see here

45787
30:21:30,232 --> 30:21:32,000
we're going to run the task to build

45788
30:21:32,000 --> 30:21:34,552
with gcc the world is going to be good

45789
30:21:34,552 --> 30:21:36,640
as usual we're going to clear and run

45790
30:21:36,640 --> 30:21:38,480
rooster and i'm going to see base

45791
30:21:38,480 --> 30:21:40,480
constructor called derived constructor

45792
30:21:40,480 --> 30:21:42,400
called and we're going to have a value

45793
30:21:42,400 --> 30:21:44,400
which is a junk value because we never

45794
30:21:44,400 --> 30:21:46,720
initialize this value but we don't see

45795
30:21:46,720 --> 30:21:49,360
our destructure is called what is going

45796
30:21:49,360 --> 30:21:50,480
on here

45797
30:21:50,480 --> 30:21:53,040
let's investigate this a little more the

45798
30:21:53,040 --> 30:21:55,680
reason is we are not explicitly

45799
30:21:55,680 --> 30:21:57,680
releasing this memory here through the

45800
30:21:57,680 --> 30:21:59,360
base pointer let's do that we're going

45801
30:21:59,360 --> 30:22:02,232
to delete p base here and we're going to

45802
30:22:02,232 --> 30:22:05,192
run again we're going to weld with gcc

45803
30:22:05,192 --> 30:22:07,680
now our destructors should be called

45804
30:22:07,680 --> 30:22:09,760
we're going to run rooster and we are

45805
30:22:09,760 --> 30:22:11,440
going to see that the base cleanup

45806
30:22:11,440 --> 30:22:13,360
version was called and again this is

45807
30:22:13,360 --> 30:22:16,080
giving us static binding results you

45808
30:22:16,080 --> 30:22:18,480
don't want something like this so if you

45809
30:22:18,480 --> 30:22:19,592
want to

45810
30:22:19,592 --> 30:22:22,000
get to this behavior i would advise not

45811
30:22:22,000 --> 30:22:24,480
to call the cleanup or setup functions

45812
30:22:24,480 --> 30:22:27,192
inside constructors or destructors and

45813
30:22:27,192 --> 30:22:28,872
that's the guideline i gave in the

45814
30:22:28,872 --> 30:22:30,960
slides you should really never call

45815
30:22:30,960 --> 30:22:32,960
virtual functions either from

45816
30:22:32,960 --> 30:22:35,912
constructors or disruptors especially if

45817
30:22:35,912 --> 30:22:38,720
you are doing this from a parent class

45818
30:22:38,720 --> 30:22:41,760
hoping to get the most specific virtual

45819
30:22:41,760 --> 30:22:44,800
function called through polymorphism if

45820
30:22:44,800 --> 30:22:46,960
you want to do that the best thing you

45821
30:22:46,960 --> 30:22:49,832
can do is to call the cleanup functions

45822
30:22:49,832 --> 30:22:50,800
and

45823
30:22:50,800 --> 30:22:52,480
is to call the setup and cleanup

45824
30:22:52,480 --> 30:22:54,872
functions after your object has been

45825
30:22:54,872 --> 30:22:57,512
properly constructed or before your

45826
30:22:57,512 --> 30:23:00,320
object gets to be destroyed so what you

45827
30:23:00,320 --> 30:23:03,760
can do here is call the setup method on

45828
30:23:03,760 --> 30:23:06,720
the pbes pointer here let's do that and

45829
30:23:06,720 --> 30:23:08,640
we're going to call setup this is going

45830
30:23:08,640 --> 30:23:10,800
to call our virtual function and we are

45831
30:23:10,800 --> 30:23:13,120
going to get polymorphic behavior this

45832
30:23:13,120 --> 30:23:15,760
is going to print a 100 as we expect

45833
30:23:15,760 --> 30:23:17,592
because it will call

45834
30:23:17,592 --> 30:23:20,872
the derived version of setup here and

45835
30:23:20,872 --> 30:23:24,000
before we delete our object we will need

45836
30:23:24,000 --> 30:23:26,320
to call the cleanup function if we need

45837
30:23:26,320 --> 30:23:28,640
to do some custom cleanup here so i'm

45838
30:23:28,640 --> 30:23:29,912
going to say

45839
30:23:29,912 --> 30:23:32,640
base and call the cleanup function and

45840
30:23:32,640 --> 30:23:35,120
this is going to give us the behavior we

45841
30:23:35,120 --> 30:23:37,760
want we're going to build our program

45842
30:23:37,760 --> 30:23:40,232
pass this through gcc the both is going

45843
30:23:40,232 --> 30:23:42,320
to be good we can clear

45844
30:23:42,320 --> 30:23:44,960
and run rooster and we are going to see

45845
30:23:44,960 --> 30:23:47,120
that this constructor was called derived

45846
30:23:47,120 --> 30:23:49,440
constructor was called we will call the

45847
30:23:49,440 --> 30:23:51,592
derived version of setup our value will

45848
30:23:51,592 --> 30:23:54,552
be 100 and when we get to release or

45849
30:23:54,552 --> 30:23:57,120
clean up our memory the derived version

45850
30:23:57,120 --> 30:23:59,680
of cleanup will be called and then we

45851
30:23:59,680 --> 30:24:01,912
will destroy the derived part of us and

45852
30:24:01,912 --> 30:24:04,320
then we will destroy the base part of us

45853
30:24:04,320 --> 30:24:07,192
this is going to work in line with the

45854
30:24:07,192 --> 30:24:09,440
behavior we are familiar with with

45855
30:24:09,440 --> 30:24:11,592
polymorphism and this is really cool so

45856
30:24:11,592 --> 30:24:13,592
this is what you should do you should

45857
30:24:13,592 --> 30:24:16,160
never call virtual functions from

45858
30:24:16,160 --> 30:24:18,160
distractors and constructors because

45859
30:24:18,160 --> 30:24:20,480
that's going to give you static binding

45860
30:24:20,480 --> 30:24:22,400
results and what you want in this case

45861
30:24:22,400 --> 30:24:23,440
is really

45862
30:24:23,440 --> 30:24:26,320
dynamic binding behavior this is really

45863
30:24:26,320 --> 30:24:28,080
all i have to share in this lecture i

45864
30:24:28,080 --> 30:24:30,320
hope you found it interesting we are

45865
30:24:30,320 --> 30:24:32,400
going to stop here in this one the next

45866
30:24:32,400 --> 30:24:34,160
one we're going to learn about the type

45867
30:24:34,160 --> 30:24:37,680
id operator that can come in handy

45868
30:24:37,680 --> 30:24:40,000
especially if you want to debug

45869
30:24:40,000 --> 30:24:42,320
polymorphic code in your c plus plus

45870
30:24:42,320 --> 30:24:45,120
program go ahead and finish up here and

45871
30:24:45,120 --> 30:24:47,040
meet me there in this lecture we're

45872
30:24:47,040 --> 30:24:48,720
going to learn about pure virtual

45873
30:24:48,720 --> 30:24:52,232
functions and abstract classes and pure

45874
30:24:52,232 --> 30:24:54,800
virtual functions are a mechanism we

45875
30:24:54,800 --> 30:24:56,720
have in c plus plus

45876
30:24:56,720 --> 30:24:59,680
to mean that the method isn't meant to

45877
30:24:59,680 --> 30:25:01,592
be implemented

45878
30:25:01,592 --> 30:25:03,832
in the base class

45879
30:25:03,832 --> 30:25:05,832
here we have a simple inheritance

45880
30:25:05,832 --> 30:25:08,720
hierarchy to try and drive this home the

45881
30:25:08,720 --> 30:25:11,120
base class is shape and we are deriving

45882
30:25:11,120 --> 30:25:13,760
from this class to create a circle class

45883
30:25:13,760 --> 30:25:16,160
and on the other side we are deriving to

45884
30:25:16,160 --> 30:25:18,800
create a rectangle class if we look in

45885
30:25:18,800 --> 30:25:20,552
the shape class we have two virtual

45886
30:25:20,552 --> 30:25:22,232
methods one is going to be used to

45887
30:25:22,232 --> 30:25:24,480
compute the perimeter of the shape

45888
30:25:24,480 --> 30:25:26,160
the other is going to be used to compute

45889
30:25:26,160 --> 30:25:28,552
the surface of the shape but if we go

45890
30:25:28,552 --> 30:25:30,960
down in our inheritance classes we're

45891
30:25:30,960 --> 30:25:32,320
going to see that we have the same

45892
30:25:32,320 --> 30:25:34,640
methods these are going to be overrides

45893
30:25:34,640 --> 30:25:37,440
of what we have in the base class

45894
30:25:37,440 --> 30:25:39,120
but the special thing about this

45895
30:25:39,120 --> 30:25:41,040
inheritance hierarchy

45896
30:25:41,040 --> 30:25:43,360
is that we don't have implementations

45897
30:25:43,360 --> 30:25:46,480
for these methods in the base class here

45898
30:25:46,480 --> 30:25:48,800
and this is by design if you think about

45899
30:25:48,800 --> 30:25:51,120
it this is an abstract shape we don't

45900
30:25:51,120 --> 30:25:52,800
know if it's a rectangle we don't know

45901
30:25:52,800 --> 30:25:54,552
if it's a circle we don't know if it is

45902
30:25:54,552 --> 30:25:57,440
a triangle so we don't really have

45903
30:25:57,440 --> 30:25:59,760
concrete information we can use

45904
30:25:59,760 --> 30:26:02,000
to properly compute its perimeter and

45905
30:26:02,000 --> 30:26:04,872
its surface so it makes sense to really

45906
30:26:04,872 --> 30:26:07,512
leave in the declaration for these

45907
30:26:07,512 --> 30:26:10,000
methods but leave the implementation

45908
30:26:10,000 --> 30:26:13,120
details to inheriting classes because

45909
30:26:13,120 --> 30:26:15,192
these classes are going to have concrete

45910
30:26:15,192 --> 30:26:17,760
information we can use to reliably

45911
30:26:17,760 --> 30:26:19,760
compute the perimeter and the surface

45912
30:26:19,760 --> 30:26:22,080
and we can get this information here

45913
30:26:22,080 --> 30:26:24,800
so in c plus plus we mean this kind of

45914
30:26:24,800 --> 30:26:27,120
design by setting up these methods as

45915
30:26:27,120 --> 30:26:29,360
pure virtual functions

45916
30:26:29,360 --> 30:26:30,872
and what this is going to tell the

45917
30:26:30,872 --> 30:26:33,512
compiler is these methods are not meant

45918
30:26:33,512 --> 30:26:36,400
to be implemented in the base class they

45919
30:26:36,400 --> 30:26:37,912
are meant to be

45920
30:26:37,912 --> 30:26:39,832
overridden and implemented by

45921
30:26:39,832 --> 30:26:42,720
inheritance classes and another side

45922
30:26:42,720 --> 30:26:45,360
effect of this is that the compiler is

45923
30:26:45,360 --> 30:26:47,280
going to prevent you from creating

45924
30:26:47,280 --> 30:26:50,000
objects of this class because it really

45925
30:26:50,000 --> 30:26:52,080
doesn't make sense to create an object

45926
30:26:52,080 --> 30:26:54,320
of shaping your design

45927
30:26:54,320 --> 30:26:56,232
if you want to be able to compute its

45928
30:26:56,232 --> 30:26:57,760
perimeter if you want to be able to

45929
30:26:57,760 --> 30:26:59,912
compute its surface so why bother

45930
30:26:59,912 --> 30:27:02,000
creating an object that you won't really

45931
30:27:02,000 --> 30:27:04,232
be using in your c plus plus program the

45932
30:27:04,232 --> 30:27:06,400
meaning for this base class is just to

45933
30:27:06,400 --> 30:27:10,232
be a an idea or a representation of a

45934
30:27:10,232 --> 30:27:12,552
shape without really going into the

45935
30:27:12,552 --> 30:27:14,872
concrete implementation of how that

45936
30:27:14,872 --> 30:27:16,480
shape really works

45937
30:27:16,480 --> 30:27:18,720
hopefully this makes sense so let's see

45938
30:27:18,720 --> 30:27:21,120
how we can do this in code here we have

45939
30:27:21,120 --> 30:27:23,280
a simple class which is going to be our

45940
30:27:23,280 --> 30:27:26,552
shape class we are going to have two

45941
30:27:26,552 --> 30:27:28,232
virtual functions we're going to have

45942
30:27:28,232 --> 30:27:30,232
the perimeter function we're going to

45943
30:27:30,232 --> 30:27:31,760
have the surface function these are

45944
30:27:31,760 --> 30:27:33,912
going to be virtual functions or virtual

45945
30:27:33,912 --> 30:27:36,872
member functions i should say but we are

45946
30:27:36,872 --> 30:27:38,400
going to make them

45947
30:27:38,400 --> 30:27:41,040
pure virtual functions by using the

45948
30:27:41,040 --> 30:27:43,040
syntax you see here so we're going to

45949
30:27:43,040 --> 30:27:46,232
prepare an echo zero and this is going

45950
30:27:46,232 --> 30:27:48,872
to tell the compiler that these are pure

45951
30:27:48,872 --> 30:27:51,280
virtual functions once you set up these

45952
30:27:51,280 --> 30:27:52,872
functions a few things are going to

45953
30:27:52,872 --> 30:27:55,680
happen in your class this class is going

45954
30:27:55,680 --> 30:27:58,640
to become an abstract class in that

45955
30:27:58,640 --> 30:28:00,720
you want to be able to create objects of

45956
30:28:00,720 --> 30:28:02,720
this class anymore if you try to do that

45957
30:28:02,720 --> 30:28:04,960
you will get a compiler error another

45958
30:28:04,960 --> 30:28:07,192
thing is that you don't need to put in

45959
30:28:07,192 --> 30:28:09,440
implementations for these methods

45960
30:28:09,440 --> 30:28:12,872
because you marked them as pure virtual

45961
30:28:12,872 --> 30:28:14,960
and what this means is that the

45962
30:28:14,960 --> 30:28:17,440
implementations will be put in by

45963
30:28:17,440 --> 30:28:20,640
inheriting downstream classes because

45964
30:28:20,640 --> 30:28:22,552
they will have concrete information to

45965
30:28:22,552 --> 30:28:25,192
compute the perimeter or the surface as

45966
30:28:25,192 --> 30:28:27,280
we have here so we don't need to bother

45967
30:28:27,280 --> 30:28:29,280
with definitions for these functions

45968
30:28:29,280 --> 30:28:31,120
here if you even try to put in a

45969
30:28:31,120 --> 30:28:32,872
definition here you're going to get a

45970
30:28:32,872 --> 30:28:35,040
compiler error because this is a virtual

45971
30:28:35,040 --> 30:28:37,512
function we have no business putting an

45972
30:28:37,512 --> 30:28:39,832
implementation in the base class here

45973
30:28:39,832 --> 30:28:42,160
these are meant to be implemented by

45974
30:28:42,160 --> 30:28:44,872
downstream inheritance classes okay once

45975
30:28:44,872 --> 30:28:47,192
we have our ship class and our

45976
30:28:47,192 --> 30:28:49,592
inheritance hierarchy we can try to run

45977
30:28:49,592 --> 30:28:52,400
this in our code for example if we try

45978
30:28:52,400 --> 30:28:54,320
and create a shape object we're going to

45979
30:28:54,320 --> 30:28:56,872
get a compiler error because shape is an

45980
30:28:56,872 --> 30:28:58,800
abstract class so we can't create

45981
30:28:58,800 --> 30:29:01,360
objects of it and i don't think i made

45982
30:29:01,360 --> 30:29:03,912
this super clear once you set up at

45983
30:29:03,912 --> 30:29:06,872
least one pure virtual function in your

45984
30:29:06,872 --> 30:29:09,512
class the class is automatically going

45985
30:29:09,512 --> 30:29:12,232
to become an abstract class and what

45986
30:29:12,232 --> 30:29:14,080
that means is that you want to be able

45987
30:29:14,080 --> 30:29:16,640
to create objects of this class so this

45988
30:29:16,640 --> 30:29:19,680
is an abstract class we have here and if

45989
30:29:19,680 --> 30:29:22,400
we try to create an object of it as we

45990
30:29:22,400 --> 30:29:24,960
are doing on this line here this is

45991
30:29:24,960 --> 30:29:27,512
going to give us a compiler error but we

45992
30:29:27,512 --> 30:29:30,552
can still use a base pointer to manage a

45993
30:29:30,552 --> 30:29:32,160
derived object

45994
30:29:32,160 --> 30:29:34,552
a common setup we do with polymorphism

45995
30:29:34,552 --> 30:29:36,080
so for example here we can set up a

45996
30:29:36,080 --> 30:29:38,552
shape pointer and use this to manage a

45997
30:29:38,552 --> 30:29:41,512
rectangle object if we call the surface

45998
30:29:41,512 --> 30:29:44,232
member function on our base pointer this

45999
30:29:44,232 --> 30:29:46,960
is going to do a polymorphic call and we

46000
30:29:46,960 --> 30:29:49,280
will get the surface of the rectangle

46001
30:29:49,280 --> 30:29:50,800
and we're going to print this out here

46002
30:29:50,800 --> 30:29:52,080
you're going to see that this is going

46003
30:29:52,080 --> 30:29:54,232
to work we can also use the base pointer

46004
30:29:54,232 --> 30:29:56,640
to manage a circle object as we see here

46005
30:29:56,640 --> 30:29:58,552
if we call the surface method this is

46006
30:29:58,552 --> 30:30:00,872
going to do polymorphism and it is going

46007
30:30:00,872 --> 30:30:03,440
to call the surface version of the

46008
30:30:03,440 --> 30:30:05,680
circle class and we can see it printed

46009
30:30:05,680 --> 30:30:07,592
out here this is the design we can

46010
30:30:07,592 --> 30:30:10,000
achieve even if shape is an abstract

46011
30:30:10,000 --> 30:30:12,800
class we can't create direct objects of

46012
30:30:12,800 --> 30:30:15,592
shape as we are doing here but we can

46013
30:30:15,592 --> 30:30:18,720
use a base pointer or a shape pointer to

46014
30:30:18,720 --> 30:30:21,040
manage derived object through

46015
30:30:21,040 --> 30:30:23,912
polymorphism and you need to be aware of

46016
30:30:23,912 --> 30:30:26,080
this okay now that you have an idea

46017
30:30:26,080 --> 30:30:28,720
about what a pure virtual function is

46018
30:30:28,720 --> 30:30:31,192
and what an abstract class is

46019
30:30:31,192 --> 30:30:33,832
let's see a few ideas you need to keep

46020
30:30:33,832 --> 30:30:36,400
in mind if your class has at least one

46021
30:30:36,400 --> 30:30:39,280
pure virtual function it will become an

46022
30:30:39,280 --> 30:30:41,512
abstract class you already know this you

46023
30:30:41,512 --> 30:30:43,440
can't create objects of an abstract

46024
30:30:43,440 --> 30:30:45,440
class if you try to do that you will get

46025
30:30:45,440 --> 30:30:47,760
a compiler error another thing i don't

46026
30:30:47,760 --> 30:30:50,400
think amid super clear is that derived

46027
30:30:50,400 --> 30:30:53,440
classes from an abstract class must

46028
30:30:53,440 --> 30:30:56,872
explicitly override all the pure virtual

46029
30:30:56,872 --> 30:30:59,280
functions from the base class

46030
30:30:59,280 --> 30:31:01,440
if you leave in any

46031
30:31:01,440 --> 30:31:03,832
pure virtual class that you don't put in

46032
30:31:03,832 --> 30:31:06,640
an implementation in for your derived

46033
30:31:06,640 --> 30:31:08,232
class is also going to become an

46034
30:31:08,232 --> 30:31:10,320
abstract class and you want to be able

46035
30:31:10,320 --> 30:31:12,000
to create objects of that you need to

46036
30:31:12,000 --> 30:31:13,760
keep this in mind another thing you

46037
30:31:13,760 --> 30:31:16,720
can't do you can't call the pure virtual

46038
30:31:16,720 --> 30:31:17,912
functions

46039
30:31:17,912 --> 30:31:20,480
from the constructor of the abstract

46040
30:31:20,480 --> 30:31:22,000
class if you do this you're going to get

46041
30:31:22,000 --> 30:31:24,160
a compiler error because we don't have

46042
30:31:24,160 --> 30:31:26,552
implementations for these things so this

46043
30:31:26,552 --> 30:31:28,800
is not going to work the constructor of

46044
30:31:28,800 --> 30:31:31,760
our abstract class is used by deriving

46045
30:31:31,760 --> 30:31:34,480
classes to build the base part of our

46046
30:31:34,480 --> 30:31:37,120
derived objects but they are not meant

46047
30:31:37,120 --> 30:31:39,760
to be used from the outside because we

46048
30:31:39,760 --> 30:31:41,440
can't really create an object of an

46049
30:31:41,440 --> 30:31:43,912
abstract class so now that you notice

46050
30:31:43,912 --> 30:31:45,192
we're going to head over to visual

46051
30:31:45,192 --> 30:31:47,040
studio code and play with this a little

46052
30:31:47,040 --> 30:31:50,160
more here we are in our working folder

46053
30:31:50,160 --> 30:31:52,480
the current project is pure virtual

46054
30:31:52,480 --> 30:31:55,680
functions and abstract classes we are

46055
30:31:55,680 --> 30:31:58,160
going to grab our template files and put

46056
30:31:58,160 --> 30:32:00,232
them in place and we're going to paste

46057
30:32:00,232 --> 30:32:03,040
them in this project here and we are

46058
30:32:03,040 --> 30:32:05,592
going to grab the files that make up our

46059
30:32:05,592 --> 30:32:07,592
inheritance hierarchy you are going to

46060
30:32:07,592 --> 30:32:09,512
get these files from the resource

46061
30:32:09,512 --> 30:32:11,440
section of the course if you want you

46062
30:32:11,440 --> 30:32:13,592
can download them and use them like i am

46063
30:32:13,592 --> 30:32:16,480
using them here or even better you can

46064
30:32:16,480 --> 30:32:19,192
type the code and see how these things

46065
30:32:19,192 --> 30:32:21,192
really work that's the best way to learn

46066
30:32:21,192 --> 30:32:23,680
i do recommend that but we want to save

46067
30:32:23,680 --> 30:32:25,832
on time here so i am just going to reuse

46068
30:32:25,832 --> 30:32:28,480
these glasses that i have lying on my

46069
30:32:28,480 --> 30:32:30,400
drive i am going to open this in visual

46070
30:32:30,400 --> 30:32:32,400
studio code by dragging and dropping

46071
30:32:32,400 --> 30:32:35,680
here we have our shape class here this

46072
30:32:35,680 --> 30:32:38,080
is going to be our base class you're

46073
30:32:38,080 --> 30:32:40,640
going to see that we have our member

46074
30:32:40,640 --> 30:32:42,080
variable which is going to be the

46075
30:32:42,080 --> 30:32:45,040
description for our shape we have a

46076
30:32:45,040 --> 30:32:47,680
bunch of constructors here but the most

46077
30:32:47,680 --> 30:32:50,232
important thing here is that we have a

46078
30:32:50,232 --> 30:32:53,192
bunch of pure virtual functions here and

46079
30:32:53,192 --> 30:32:54,872
if you go in the cpp file you're going

46080
30:32:54,872 --> 30:32:56,080
to see that we don't have

46081
30:32:56,080 --> 30:32:58,720
implementations then for the perimeter

46082
30:32:58,720 --> 30:33:01,512
and surface functions these are pure

46083
30:33:01,512 --> 30:33:03,360
virtual functions and we have no

46084
30:33:03,360 --> 30:33:05,912
business putting in an implementation in

46085
30:33:05,912 --> 30:33:08,320
the base class once we have these

46086
30:33:08,320 --> 30:33:11,120
virtual functions in and mark them as

46087
30:33:11,120 --> 30:33:14,400
pure virtual functions by prepending n

46088
30:33:14,400 --> 30:33:16,800
equals zero here this class here is

46089
30:33:16,800 --> 30:33:19,440
going to become an abstract class and

46090
30:33:19,440 --> 30:33:21,760
what that means is that we can't create

46091
30:33:21,760 --> 30:33:24,640
objects of this class it is meant ready

46092
30:33:24,640 --> 30:33:28,000
to be inherited from and downstream

46093
30:33:28,000 --> 30:33:30,552
inheritance classes are going to be

46094
30:33:30,552 --> 30:33:32,000
forced to

46095
30:33:32,000 --> 30:33:34,400
override these methods here otherwise

46096
30:33:34,400 --> 30:33:36,480
they are themselves going to become

46097
30:33:36,480 --> 30:33:38,640
abstract classes we're going to have a

46098
30:33:38,640 --> 30:33:40,800
chance to look at this here we also have

46099
30:33:40,800 --> 30:33:42,640
our rectangle class which is going to be

46100
30:33:42,640 --> 30:33:44,960
inheriting from shape it is going to

46101
30:33:44,960 --> 30:33:47,192
override our two methods we're going to

46102
30:33:47,192 --> 30:33:49,040
override the perimeter function we're

46103
30:33:49,040 --> 30:33:50,960
going to override the surface function

46104
30:33:50,960 --> 30:33:53,280
for rectangle the perimeter is computed

46105
30:33:53,280 --> 30:33:55,760
this way we're going to multiply

46106
30:33:55,760 --> 30:33:58,720
the width by two and the height by two

46107
30:33:58,720 --> 30:34:00,800
and we're going to add these two things

46108
30:34:00,800 --> 30:34:02,720
up we're going to compute the surface by

46109
30:34:02,720 --> 30:34:04,960
multiplying width and height and this is

46110
30:34:04,960 --> 30:34:06,872
going to give us the data we want we can

46111
30:34:06,872 --> 30:34:08,960
look at circle it is going to also

46112
30:34:08,960 --> 30:34:10,960
inherit from shape and it is going to

46113
30:34:10,960 --> 30:34:13,360
override our methods here if we want we

46114
30:34:13,360 --> 30:34:16,800
can even put in a radius and a variable

46115
30:34:16,800 --> 30:34:19,680
to keep track of pi we can do this you

46116
30:34:19,680 --> 30:34:21,760
can really do this however you want this

46117
30:34:21,760 --> 30:34:23,680
is just going to allow us to compute the

46118
30:34:23,680 --> 30:34:26,080
surface relatively easily in this class

46119
30:34:26,080 --> 30:34:28,232
here let's look at the implementation

46120
30:34:28,232 --> 30:34:30,400
nothing special here this is just going

46121
30:34:30,400 --> 30:34:32,720
to forward the construction of the base

46122
30:34:32,720 --> 30:34:34,480
part of us to the

46123
30:34:34,480 --> 30:34:36,640
base constructor and this is going to do

46124
30:34:36,640 --> 30:34:38,960
whatever it is we want to do here let's

46125
30:34:38,960 --> 30:34:40,960
head over to the main cpp file and

46126
30:34:40,960 --> 30:34:43,040
actually use these things

46127
30:34:43,040 --> 30:34:46,000
we are going to include circle and

46128
30:34:46,000 --> 30:34:49,120
rectangle let's do that circle dot h and

46129
30:34:49,120 --> 30:34:51,760
we're going to put in rectangle that h

46130
30:34:51,760 --> 30:34:54,320
and we're going to first try and create

46131
30:34:54,320 --> 30:34:56,720
a shape object let's do that we're going

46132
30:34:56,720 --> 30:34:59,912
to say shape and say shape pointer and

46133
30:34:59,912 --> 30:35:02,400
this is going to be new shape we can use

46134
30:35:02,400 --> 30:35:04,640
a default constructor and if we do

46135
30:35:04,640 --> 30:35:05,912
something like this you're going to see

46136
30:35:05,912 --> 30:35:07,760
that we're going to have a compiler

46137
30:35:07,760 --> 30:35:10,000
error here we have a squiggly line but

46138
30:35:10,000 --> 30:35:12,960
if we bring up a terminal window and

46139
30:35:12,960 --> 30:35:15,440
look at the problems tab we're going to

46140
30:35:15,440 --> 30:35:18,400
see that object of abstract class type

46141
30:35:18,400 --> 30:35:20,800
shape is not allowed so shape is an

46142
30:35:20,800 --> 30:35:22,800
abstract class now

46143
30:35:22,800 --> 30:35:25,040
and why is it an abstract class because

46144
30:35:25,040 --> 30:35:28,160
we have an at least one pure virtual

46145
30:35:28,160 --> 30:35:30,480
function here we actually have two and

46146
30:35:30,480 --> 30:35:32,960
this is going to make our shape class an

46147
30:35:32,960 --> 30:35:35,512
abstract class what that means is that

46148
30:35:35,512 --> 30:35:37,912
we can't create objects of this class

46149
30:35:37,912 --> 30:35:39,360
and if we do that we're going to get a

46150
30:35:39,360 --> 30:35:41,832
compiler error let's try and build this

46151
30:35:41,832 --> 30:35:43,512
program we're going to pass this through

46152
30:35:43,512 --> 30:35:46,232
gcc our favorite compiler we are going

46153
30:35:46,232 --> 30:35:48,000
to see that the bolt is going to fail

46154
30:35:48,000 --> 30:35:50,000
we're going to have a bunch of errors if

46155
30:35:50,000 --> 30:35:53,360
we go up and look at the error we have

46156
30:35:53,360 --> 30:35:56,552
invalid new expression of abstract class

46157
30:35:56,552 --> 30:35:58,320
type shape

46158
30:35:58,320 --> 30:36:00,640
so we can't really create an object of

46159
30:36:00,640 --> 30:36:03,040
this let's go down and see what these

46160
30:36:03,040 --> 30:36:05,760
errors are saying note because the

46161
30:36:05,760 --> 30:36:07,760
following virtual functions are pure

46162
30:36:07,760 --> 30:36:10,232
within shape and they are going to try

46163
30:36:10,232 --> 30:36:12,552
and really be helpful in the errors that

46164
30:36:12,552 --> 30:36:15,040
they give here and all they are saying

46165
30:36:15,040 --> 30:36:17,512
is that we can't create objects of this

46166
30:36:17,512 --> 30:36:19,760
class because we have pure virtual

46167
30:36:19,760 --> 30:36:22,160
functions inside okay now you know this

46168
30:36:22,160 --> 30:36:24,800
if a class is abstract you can't create

46169
30:36:24,800 --> 30:36:27,360
objects of that class but you can still

46170
30:36:27,360 --> 30:36:29,912
use a base pointer to manage derived

46171
30:36:29,912 --> 30:36:32,800
objects of that class so let's comment

46172
30:36:32,800 --> 30:36:35,192
this out because this is going to make

46173
30:36:35,192 --> 30:36:37,592
our code not compile and we're going to

46174
30:36:37,592 --> 30:36:39,040
say that this is going to give us a

46175
30:36:39,040 --> 30:36:41,440
compiler error and we're going to try

46176
30:36:41,440 --> 30:36:43,592
and use the base pointer to manage a

46177
30:36:43,592 --> 30:36:46,160
rectangle object we can do this so we're

46178
30:36:46,160 --> 30:36:48,480
going to set up a shape pointer and it

46179
30:36:48,480 --> 30:36:50,552
is going to be managing the memory of a

46180
30:36:50,552 --> 30:36:52,640
rectangle object we're going to go

46181
30:36:52,640 --> 30:36:54,400
through the base pointer and call the

46182
30:36:54,400 --> 30:36:56,800
surface method and this is going to call

46183
30:36:56,800 --> 30:36:59,120
the implementation in rectangle because

46184
30:36:59,120 --> 30:37:01,040
our base pointer is really managing the

46185
30:37:01,040 --> 30:37:03,360
rectangle object if you want you can

46186
30:37:03,360 --> 30:37:06,160
even use the type id operator to print

46187
30:37:06,160 --> 30:37:08,720
the dynamic type of this shape rect

46188
30:37:08,720 --> 30:37:10,160
pointer you're going to see that it is

46189
30:37:10,160 --> 30:37:12,080
managing a rectangle you can actually do

46190
30:37:12,080 --> 30:37:13,592
this because we learned about that in

46191
30:37:13,592 --> 30:37:15,832
the last lecture so let's practice that

46192
30:37:15,832 --> 30:37:18,480
we're going to say dynamic type of shape

46193
30:37:18,480 --> 30:37:21,512
wrap and we're going to say type id and

46194
30:37:21,512 --> 30:37:23,280
we're going to de-reference the pointer

46195
30:37:23,280 --> 30:37:25,040
we're going to say shipwrecked and we're

46196
30:37:25,040 --> 30:37:27,040
going to print the name of this and

46197
30:37:27,040 --> 30:37:29,512
we're going to see it print out on our

46198
30:37:29,512 --> 30:37:31,832
powershell window and after this we are

46199
30:37:31,832 --> 30:37:33,912
going to print the surface that we got

46200
30:37:33,912 --> 30:37:36,552
from this call here and we're going to

46201
30:37:36,552 --> 30:37:39,120
see what this gives us let's try and

46202
30:37:39,120 --> 30:37:40,872
build this program we're going to pass

46203
30:37:40,872 --> 30:37:43,680
it through gcc our favorite compiler the

46204
30:37:43,680 --> 30:37:45,192
bullet is going to be good we're going

46205
30:37:45,192 --> 30:37:47,360
to clear and run rooster we're going to

46206
30:37:47,360 --> 30:37:50,000
see that the dynamic type is rectangle

46207
30:37:50,000 --> 30:37:52,232
you can see that right here so the base

46208
30:37:52,232 --> 30:37:54,800
pointer is really managing a rectangle

46209
30:37:54,800 --> 30:37:57,592
object and this is what we have here and

46210
30:37:57,592 --> 30:37:59,912
if we call the surface method we will be

46211
30:37:59,912 --> 30:38:03,280
calling the method on the dynamic type

46212
30:38:03,280 --> 30:38:04,960
so we will be calling this surface

46213
30:38:04,960 --> 30:38:07,680
method on the rectangle class and we

46214
30:38:07,680 --> 30:38:08,720
will be

46215
30:38:08,720 --> 30:38:11,192
using the implementation we have here so

46216
30:38:11,192 --> 30:38:13,512
the surface function that is going to be

46217
30:38:13,512 --> 30:38:16,480
called is what we have on line 20 in

46218
30:38:16,480 --> 30:38:18,720
rectangle here and this is going to just

46219
30:38:18,720 --> 30:38:21,360
be a multiplication of width and height

46220
30:38:21,360 --> 30:38:24,080
and we're going to get 100 here because

46221
30:38:24,080 --> 30:38:26,400
our width and height happen to be

46222
30:38:26,400 --> 30:38:28,800
10 and 10 so multiplying this is going

46223
30:38:28,800 --> 30:38:31,680
to give us 100 as we see here this is

46224
30:38:31,680 --> 30:38:33,512
really cool this is what we expect we

46225
30:38:33,512 --> 30:38:36,160
can even use our base pointer to manage

46226
30:38:36,160 --> 30:38:38,400
a circle object so let's do that we're

46227
30:38:38,400 --> 30:38:40,320
going to put in a separator to be able

46228
30:38:40,320 --> 30:38:43,760
to follow this easily and our output so

46229
30:38:43,760 --> 30:38:46,232
let's say stdndl here and we're going to

46230
30:38:46,232 --> 30:38:48,320
put in the code so we're going to set up

46231
30:38:48,320 --> 30:38:50,232
a base pointer which is really going to

46232
30:38:50,232 --> 30:38:53,120
be managing a circle object here and we

46233
30:38:53,120 --> 30:38:55,680
will call our surface method this is

46234
30:38:55,680 --> 30:38:57,592
going to call this method

46235
30:38:57,592 --> 30:38:59,512
polymorphically because surface is a

46236
30:38:59,512 --> 30:39:00,960
virtual function

46237
30:39:00,960 --> 30:39:03,680
so we will get polymorphism here and we

46238
30:39:03,680 --> 30:39:05,512
will call the surface method on the

46239
30:39:05,512 --> 30:39:07,832
circle object which is really our

46240
30:39:07,832 --> 30:39:09,760
dynamic type if we print this out we're

46241
30:39:09,760 --> 30:39:12,160
going to see the surface printed out but

46242
30:39:12,160 --> 30:39:14,960
if we want we can even print the dynamic

46243
30:39:14,960 --> 30:39:16,720
type of our

46244
30:39:16,720 --> 30:39:18,320
base pointer here so we're going to do

46245
30:39:18,320 --> 30:39:20,720
the same thing we did for rectangle we

46246
30:39:20,720 --> 30:39:23,592
can use our type id operator to print

46247
30:39:23,592 --> 30:39:26,480
the dynamic type of shape circle and

46248
30:39:26,480 --> 30:39:28,640
we're going to say shape circle here and

46249
30:39:28,640 --> 30:39:31,120
this is going to do what we want let's

46250
30:39:31,120 --> 30:39:32,872
look at this we're going to be printing

46251
30:39:32,872 --> 30:39:35,592
the surface here this is exactly what we

46252
30:39:35,592 --> 30:39:37,592
want so let's build and run we're going

46253
30:39:37,592 --> 30:39:40,000
to pass this through gcc the bolt is

46254
30:39:40,000 --> 30:39:41,912
going to go through as you see here if

46255
30:39:41,912 --> 30:39:42,960
we clear

46256
30:39:42,960 --> 30:39:45,360
and run rooster we're going to see that

46257
30:39:45,360 --> 30:39:47,912
the dynamic type is now a circle so the

46258
30:39:47,912 --> 30:39:50,400
base pointer or the shape pointer we

46259
30:39:50,400 --> 30:39:52,640
have here is really managing

46260
30:39:52,640 --> 30:39:55,512
a circle object polymorphically so if we

46261
30:39:55,512 --> 30:39:57,832
call a virtual function on this base

46262
30:39:57,832 --> 30:39:59,912
pointer it is going to call

46263
30:39:59,912 --> 30:40:01,120
the most

46264
30:40:01,120 --> 30:40:03,592
specific implementation of the surface

46265
30:40:03,592 --> 30:40:05,912
object we have and that happens to be

46266
30:40:05,912 --> 30:40:08,000
for this circle object here this is what

46267
30:40:08,000 --> 30:40:08,960
i mean

46268
30:40:08,960 --> 30:40:10,720
if we compute the surface we're going to

46269
30:40:10,720 --> 30:40:12,480
see that it is going to be using the

46270
30:40:12,480 --> 30:40:14,872
data we have here and we will get this

46271
30:40:14,872 --> 30:40:17,440
number as our surface if you plug this

46272
30:40:17,440 --> 30:40:18,640
in you're going to see that this is

46273
30:40:18,640 --> 30:40:21,040
really right so this is really all i had

46274
30:40:21,040 --> 30:40:23,592
to share in this lecture we can set up

46275
30:40:23,592 --> 30:40:26,640
pure virtual functions in a base class

46276
30:40:26,640 --> 30:40:28,400
and what that's going to do it is going

46277
30:40:28,400 --> 30:40:31,760
to make our class an abstract class but

46278
30:40:31,760 --> 30:40:33,592
we want also be able to put in

46279
30:40:33,592 --> 30:40:35,680
implementations for these

46280
30:40:35,680 --> 30:40:37,592
methods anymore in the base class

46281
30:40:37,592 --> 30:40:39,512
because they are meant to be

46282
30:40:39,512 --> 30:40:41,680
overwritten and implemented by

46283
30:40:41,680 --> 30:40:44,720
downstream inheritance classes so if you

46284
30:40:44,720 --> 30:40:46,640
go in here and try to put in an

46285
30:40:46,640 --> 30:40:49,192
implementation we will probably get a

46286
30:40:49,192 --> 30:40:50,960
compiler error because this is not

46287
30:40:50,960 --> 30:40:53,120
allowed you see we have a problem here

46288
30:40:53,120 --> 30:40:55,280
if we try to build we will get a weird

46289
30:40:55,280 --> 30:40:57,280
compiler error let's make sure we see

46290
30:40:57,280 --> 30:40:59,832
the compiler error so world finished

46291
30:40:59,832 --> 30:41:02,872
with errors and we are going to see

46292
30:41:02,872 --> 30:41:05,192
what's the problem here let's go up and

46293
30:41:05,192 --> 30:41:06,232
see

46294
30:41:06,232 --> 30:41:09,832
pure specifier on function definition so

46295
30:41:09,832 --> 30:41:12,640
this is not allowed so we are really

46296
30:41:12,640 --> 30:41:15,592
conflicting ourselves here we are

46297
30:41:15,592 --> 30:41:18,000
marking this function as a pure virtual

46298
30:41:18,000 --> 30:41:19,040
function

46299
30:41:19,040 --> 30:41:22,320
and what that means and a pure virtual

46300
30:41:22,320 --> 30:41:24,000
functions isn't meant to have a

46301
30:41:24,000 --> 30:41:26,400
definition but we are also putting in a

46302
30:41:26,400 --> 30:41:28,000
definition here so the compiler is going

46303
30:41:28,000 --> 30:41:29,912
to be confused this is not something we

46304
30:41:29,912 --> 30:41:32,160
should be doing another thing i want to

46305
30:41:32,160 --> 30:41:34,800
point out before we wrap up this lecture

46306
30:41:34,800 --> 30:41:35,912
is that

46307
30:41:35,912 --> 30:41:39,680
downstream inheriting classes are forced

46308
30:41:39,680 --> 30:41:42,160
to override and implement all the pure

46309
30:41:42,160 --> 30:41:44,720
virtual functions from the class that

46310
30:41:44,720 --> 30:41:47,440
they inherit from if they don't do that

46311
30:41:47,440 --> 30:41:49,440
they are themselves going to become

46312
30:41:49,440 --> 30:41:51,440
abstract and we want to be able to

46313
30:41:51,440 --> 30:41:54,232
create objects of them so let's try and

46314
30:41:54,232 --> 30:41:56,080
for example comment out the surface

46315
30:41:56,080 --> 30:41:58,232
implementation here and that's going to

46316
30:41:58,232 --> 30:42:02,000
make our circle class an abstract class

46317
30:42:02,000 --> 30:42:03,912
and if we try to create an object with

46318
30:42:03,912 --> 30:42:06,000
circle we will get a compiler error

46319
30:42:06,000 --> 30:42:08,640
because now circle is an abstract class

46320
30:42:08,640 --> 30:42:10,232
let's try and build and show you the

46321
30:42:10,232 --> 30:42:12,480
compiler error and this can really be

46322
30:42:12,480 --> 30:42:15,280
confusing if you are a beginner on this

46323
30:42:15,280 --> 30:42:17,760
you will be wondering why you can't

46324
30:42:17,760 --> 30:42:20,720
create objects of your class even if you

46325
30:42:20,720 --> 30:42:23,832
didn't really explicitly put in any pure

46326
30:42:23,832 --> 30:42:26,232
virtual function the reason is we are

46327
30:42:26,232 --> 30:42:29,360
inheriting from an abstract class that

46328
30:42:29,360 --> 30:42:32,720
has two pure virtual functions but we

46329
30:42:32,720 --> 30:42:35,760
are only overriding one pure virtual

46330
30:42:35,760 --> 30:42:38,160
function we need to override all of them

46331
30:42:38,160 --> 30:42:40,400
otherwise our class is also going to be

46332
30:42:40,400 --> 30:42:42,720
an abstract class let's look at the

46333
30:42:42,720 --> 30:42:44,640
compiler error we are getting here let's

46334
30:42:44,640 --> 30:42:47,440
go up and see if we can find it we are

46335
30:42:47,440 --> 30:42:49,912
going to say in function in main

46336
30:42:49,912 --> 30:42:52,480
evaluate new expression of abstract

46337
30:42:52,480 --> 30:42:55,120
class type circle we are trying to

46338
30:42:55,120 --> 30:42:58,160
create an object from an abstract class

46339
30:42:58,160 --> 30:43:00,232
this is the error we have here and you

46340
30:43:00,232 --> 30:43:01,832
should really note this

46341
30:43:01,832 --> 30:43:04,400
so let's go back and make sure we are

46342
30:43:04,400 --> 30:43:06,552
overriding all these stunts because we

46343
30:43:06,552 --> 30:43:08,720
need to do that to be able to create

46344
30:43:08,720 --> 30:43:11,512
objects of a circle and now this is

46345
30:43:11,512 --> 30:43:14,080
going to work exactly as it should let's

46346
30:43:14,080 --> 30:43:16,160
build and make sure of that the bullet

46347
30:43:16,160 --> 30:43:18,232
is going to be good we are fine this is

46348
30:43:18,232 --> 30:43:20,800
working exactly as we want this is

46349
30:43:20,800 --> 30:43:22,480
really all i wanted you to see in this

46350
30:43:22,480 --> 30:43:24,720
lecture i hope you found it interesting

46351
30:43:24,720 --> 30:43:27,120
we are going to stop here in this one

46352
30:43:27,120 --> 30:43:28,960
the next one we're going to learn about

46353
30:43:28,960 --> 30:43:31,592
interfaces in c plus plus and they are

46354
30:43:31,592 --> 30:43:33,440
going to be reusing the knowledge we

46355
30:43:33,440 --> 30:43:35,360
learned about in this lecture go ahead

46356
30:43:35,360 --> 30:43:37,832
and finish up here and meet me there in

46357
30:43:37,832 --> 30:43:39,360
this lecture we're going to see that we

46358
30:43:39,360 --> 30:43:43,120
can model interfaces in c plus plus

46359
30:43:43,120 --> 30:43:45,592
using abstract classes

46360
30:43:45,592 --> 30:43:47,280
and now there's a lot of things that

46361
30:43:47,280 --> 30:43:50,000
might not make sense in what i just said

46362
30:43:50,000 --> 30:43:52,480
so let's break this apart an interface

46363
30:43:52,480 --> 30:43:55,912
can be thought of as an abstract class

46364
30:43:55,912 --> 30:43:59,440
with only pure virtual functions and no

46365
30:43:59,440 --> 30:44:02,080
member variable so if you have a setup

46366
30:44:02,080 --> 30:44:03,832
like that you can call that thing an

46367
30:44:03,832 --> 30:44:06,232
interface let's look at a simple example

46368
30:44:06,232 --> 30:44:08,160
here here we have a simple class called

46369
30:44:08,160 --> 30:44:10,232
stream insertable you see that it

46370
30:44:10,232 --> 30:44:12,872
doesn't have any member variable it only

46371
30:44:12,872 --> 30:44:16,232
has a pure virtual function here and a

46372
30:44:16,232 --> 30:44:18,232
helper function that we could set up to

46373
30:44:18,232 --> 30:44:20,400
help us do a few things the only

46374
30:44:20,400 --> 30:44:23,832
specification to make this an interface

46375
30:44:23,832 --> 30:44:26,720
is to have in only pure virtual

46376
30:44:26,720 --> 30:44:29,512
functions and no member variables if you

46377
30:44:29,512 --> 30:44:31,360
have in a member variable this is going

46378
30:44:31,360 --> 30:44:33,760
to stop becoming an interface in c plus

46379
30:44:33,760 --> 30:44:35,440
plus okay so you can think of an

46380
30:44:35,440 --> 30:44:38,000
interface as an abstract class

46381
30:44:38,000 --> 30:44:40,960
with at least one pure virtual function

46382
30:44:40,960 --> 30:44:43,120
and no member variable that's going to

46383
30:44:43,120 --> 30:44:45,440
make it an interface down here you see

46384
30:44:45,440 --> 30:44:48,160
that an interface can be thought of as a

46385
30:44:48,160 --> 30:44:51,120
specification of something that will be

46386
30:44:51,120 --> 30:44:54,080
fully implemented in a derived class

46387
30:44:54,080 --> 30:44:56,552
but the specification itself is going to

46388
30:44:56,552 --> 30:44:59,680
reside in the abstract class another way

46389
30:44:59,680 --> 30:45:02,552
to think about an interface is to treat

46390
30:45:02,552 --> 30:45:05,040
an interface as a thing

46391
30:45:05,040 --> 30:45:07,280
you can attach to your types to give

46392
30:45:07,280 --> 30:45:10,320
them superpowers for example this stream

46393
30:45:10,320 --> 30:45:12,160
insertable interface

46394
30:45:12,160 --> 30:45:14,480
has a single job and that's going to

46395
30:45:14,480 --> 30:45:17,912
allow our types to insert data into

46396
30:45:17,912 --> 30:45:20,872
output streams like sddc out this is the

46397
30:45:20,872 --> 30:45:22,800
only thing this interface is going to

46398
30:45:22,800 --> 30:45:25,440
add to our times so we can take this

46399
30:45:25,440 --> 30:45:27,360
interface and attach that to a point

46400
30:45:27,360 --> 30:45:29,360
class for example and we will

46401
30:45:29,360 --> 30:45:31,760
automatically be able to print point

46402
30:45:31,760 --> 30:45:34,480
objects to the output stream and we want

46403
30:45:34,480 --> 30:45:37,040
to need to overload the stream output

46404
30:45:37,040 --> 30:45:39,592
operator in the point class we can do

46405
30:45:39,592 --> 30:45:41,680
the same thing to our bird class we can

46406
30:45:41,680 --> 30:45:44,160
do the same thing to our dog class and

46407
30:45:44,160 --> 30:45:46,080
we will be able to print these things

46408
30:45:46,080 --> 30:45:48,232
without having to overload the stream

46409
30:45:48,232 --> 30:45:50,400
output operator hopefully you can see

46410
30:45:50,400 --> 30:45:53,512
how powerful this is if we manage to set

46411
30:45:53,512 --> 30:45:55,680
up this kind of relationship between our

46412
30:45:55,680 --> 30:45:58,720
type and our interfaces so again an

46413
30:45:58,720 --> 30:46:00,800
interface is something you can attach to

46414
30:46:00,800 --> 30:46:03,592
your types to give them powers or

46415
30:46:03,592 --> 30:46:05,832
features that they originally didn't

46416
30:46:05,832 --> 30:46:07,912
have and that's going to save you from

46417
30:46:07,912 --> 30:46:10,232
having to implement these features

46418
30:46:10,232 --> 30:46:12,400
separately in each class for real time

46419
30:46:12,400 --> 30:46:14,400
so this is a huge time saver now you

46420
30:46:14,400 --> 30:46:16,800
must be asking how do i take my

46421
30:46:16,800 --> 30:46:19,440
interface and attach it to my type well

46422
30:46:19,440 --> 30:46:22,080
the way c plus plus does this you have

46423
30:46:22,080 --> 30:46:25,760
to inherit from the interface from your

46424
30:46:25,760 --> 30:46:28,160
type to attach the interface to your

46425
30:46:28,160 --> 30:46:30,080
type so for example if we wanted to

46426
30:46:30,080 --> 30:46:32,872
attach this interface to our point class

46427
30:46:32,872 --> 30:46:34,720
what we would do is something like this

46428
30:46:34,720 --> 30:46:37,440
we would set up our point class

46429
30:46:37,440 --> 30:46:40,720
and inherit from our interface which is

46430
30:46:40,720 --> 30:46:42,800
stream insertable the moment we do this

46431
30:46:42,800 --> 30:46:44,720
our point is going to be able to print

46432
30:46:44,720 --> 30:46:47,192
thanks to the console through the stream

46433
30:46:47,192 --> 30:46:49,512
output operator but hopefully you can

46434
30:46:49,512 --> 30:46:52,160
see that something is missing how does

46435
30:46:52,160 --> 30:46:55,040
our point class know how to print stuff

46436
30:46:55,040 --> 30:46:57,360
if we go up and look at our stream

46437
30:46:57,360 --> 30:46:59,592
insertable interface we're going to see

46438
30:46:59,592 --> 30:47:02,160
that it is declaring a stream output

46439
30:47:02,160 --> 30:47:05,040
operator it is this thing that is used

46440
30:47:05,040 --> 30:47:07,592
to print data to the output stream you

46441
30:47:07,592 --> 30:47:09,680
see this is a regular output stream

46442
30:47:09,680 --> 30:47:12,960
operator we will be printing to sddo

46443
30:47:12,960 --> 30:47:16,000
stream and the object is named out here

46444
30:47:16,000 --> 30:47:18,160
and we will be printing whatever operand

46445
30:47:18,160 --> 30:47:20,080
that is passed as a second parameter

46446
30:47:20,080 --> 30:47:22,400
here but the catches

46447
30:47:22,400 --> 30:47:24,552
we will need to set up a virtual

46448
30:47:24,552 --> 30:47:25,592
function

46449
30:47:25,592 --> 30:47:28,080
that will need to be implemented by

46450
30:47:28,080 --> 30:47:31,680
whoever inherits from our interface here

46451
30:47:31,680 --> 30:47:34,080
and this is going to be super powerful

46452
30:47:34,080 --> 30:47:36,160
we are going to take over the job to

46453
30:47:36,160 --> 30:47:38,872
print to the output stream but we will

46454
30:47:38,872 --> 30:47:42,232
let inheriting download classes to

46455
30:47:42,232 --> 30:47:44,232
specify what we print and they are going

46456
30:47:44,232 --> 30:47:47,760
to specify that in this virtual method

46457
30:47:47,760 --> 30:47:49,832
let's look at our point class again and

46458
30:47:49,832 --> 30:47:52,640
really put the puzzles together here and

46459
30:47:52,640 --> 30:47:55,280
understand how this works okay this is

46460
30:47:55,280 --> 30:47:57,832
our point class and it is going to be

46461
30:47:57,832 --> 30:48:00,552
inheriting from our interface and it is

46462
30:48:00,552 --> 30:48:02,872
going to implement our virtual function

46463
30:48:02,872 --> 30:48:04,720
here we are going to set it up here and

46464
30:48:04,720 --> 30:48:07,040
we are going to mark it as an override

46465
30:48:07,040 --> 30:48:09,280
because it is overriding a method that

46466
30:48:09,280 --> 30:48:11,192
comes from our stream insertable

46467
30:48:11,192 --> 30:48:13,120
interface here and it is going to

46468
30:48:13,120 --> 30:48:16,160
specify which data we print to the

46469
30:48:16,160 --> 30:48:18,160
output stream and how the data is going

46470
30:48:18,160 --> 30:48:20,552
to be printed out you can specify

46471
30:48:20,552 --> 30:48:22,640
these things here we're going to format

46472
30:48:22,640 --> 30:48:24,320
the data in a point and we're going to

46473
30:48:24,320 --> 30:48:27,040
be using these square brackets to put mx

46474
30:48:27,040 --> 30:48:30,000
and my here and notice that this is an

46475
30:48:30,000 --> 30:48:33,760
override so the inheritance class has

46476
30:48:33,760 --> 30:48:36,000
all the information we need to put in

46477
30:48:36,000 --> 30:48:38,552
our output stream operator and we will

46478
30:48:38,552 --> 30:48:40,800
do that through our stream insert

46479
30:48:40,800 --> 30:48:43,120
override here now let's go back to our

46480
30:48:43,120 --> 30:48:46,552
stream insertable interface to see how

46481
30:48:46,552 --> 30:48:48,960
our output stream operator actually

46482
30:48:48,960 --> 30:48:51,592
works what we have here is what would be

46483
30:48:51,592 --> 30:48:53,512
a header and this is going to just put

46484
30:48:53,512 --> 30:48:55,760
in a declaration for this but we can

46485
30:48:55,760 --> 30:48:58,400
even look at its implementation the

46486
30:48:58,400 --> 30:49:00,640
implementation for our output stream

46487
30:49:00,640 --> 30:49:02,720
operator may look something like this we

46488
30:49:02,720 --> 30:49:04,552
are going to pass in the first operand

46489
30:49:04,552 --> 30:49:06,872
and the second operand here but notice

46490
30:49:06,872 --> 30:49:09,192
what we are doing here we are going to

46491
30:49:09,192 --> 30:49:10,000
call

46492
30:49:10,000 --> 30:49:13,192
the stream insert virtual function on

46493
30:49:13,192 --> 30:49:16,400
our operand here and this is going to

46494
30:49:16,400 --> 30:49:17,360
call

46495
30:49:17,360 --> 30:49:20,320
the most specific implementation we can

46496
30:49:20,320 --> 30:49:22,872
find for the stream insert if we are

46497
30:49:22,872 --> 30:49:24,720
trying to print a circle for example

46498
30:49:24,720 --> 30:49:27,592
this is going to call the stream insert

46499
30:49:27,592 --> 30:49:30,320
override on a circle object if we are

46500
30:49:30,320 --> 30:49:32,872
trying to print a point this is going to

46501
30:49:32,872 --> 30:49:35,440
call this method on our point object and

46502
30:49:35,440 --> 30:49:37,512
this is going to use polymorphism

46503
30:49:37,512 --> 30:49:40,232
because our second operand here is pass

46504
30:49:40,232 --> 30:49:42,480
by reference hopefully you can see how

46505
30:49:42,480 --> 30:49:44,480
this is super powerful i know this is

46506
30:49:44,480 --> 30:49:46,552
convoluted because we are jumping around

46507
30:49:46,552 --> 30:49:49,040
trying to explain this but i couldn't

46508
30:49:49,040 --> 30:49:51,360
really come up with an easier way to put

46509
30:49:51,360 --> 30:49:54,160
this we have to try this encode to

46510
30:49:54,160 --> 30:49:57,192
really see the power of this but this is

46511
30:49:57,192 --> 30:49:59,680
really the power of interfaces we can

46512
30:49:59,680 --> 30:50:02,000
design our features and wrap them in an

46513
30:50:02,000 --> 30:50:04,480
interface and we can really attach that

46514
30:50:04,480 --> 30:50:06,552
interface to any type we have in our c

46515
30:50:06,552 --> 30:50:09,040
plus plus program and that type is going

46516
30:50:09,040 --> 30:50:11,512
to automatically inherit the features

46517
30:50:11,512 --> 30:50:14,080
that we have set up in our interface for

46518
30:50:14,080 --> 30:50:16,400
example now that we have attached this

46519
30:50:16,400 --> 30:50:19,280
interface to our point here we can print

46520
30:50:19,280 --> 30:50:21,440
our points on the output stream and this

46521
30:50:21,440 --> 30:50:23,360
is going to work automatically you see

46522
30:50:23,360 --> 30:50:25,512
that we don't need to set up an output

46523
30:50:25,512 --> 30:50:28,320
stream operator on our class altogether

46524
30:50:28,320 --> 30:50:30,800
we can even go further and attach this

46525
30:50:30,800 --> 30:50:33,360
interface to a full inheritance

46526
30:50:33,360 --> 30:50:35,912
hierarchy for example if we have our

46527
30:50:35,912 --> 30:50:38,552
base class to be animal and we inherit

46528
30:50:38,552 --> 30:50:40,552
from this class to create all kinds of

46529
30:50:40,552 --> 30:50:43,760
crazy classes we can go on and attach

46530
30:50:43,760 --> 30:50:46,480
our interface to the base class here and

46531
30:50:46,480 --> 30:50:49,592
this is going to make all our classes in

46532
30:50:49,592 --> 30:50:52,000
our inheritance hierarchy have the

46533
30:50:52,000 --> 30:50:54,480
features that the interface has brought

46534
30:50:54,480 --> 30:50:57,192
to the base class so for example we can

46535
30:50:57,192 --> 30:50:59,760
attach our interface to the animal class

46536
30:50:59,760 --> 30:51:02,480
by inheriting from stream insertable

46537
30:51:02,480 --> 30:51:05,040
here and this is going to give our

46538
30:51:05,040 --> 30:51:08,400
animal the powers to be printed out to

46539
30:51:08,400 --> 30:51:10,872
output streams and this is going to be

46540
30:51:10,872 --> 30:51:13,120
powered by the virtual function that we

46541
30:51:13,120 --> 30:51:15,592
are overriding here you see

46542
30:51:15,592 --> 30:51:18,480
we are going to specify which data to

46543
30:51:18,480 --> 30:51:20,640
print in our animal class and how the

46544
30:51:20,640 --> 30:51:22,872
data is going to be printed out here and

46545
30:51:22,872 --> 30:51:24,960
we can do that in this override and this

46546
30:51:24,960 --> 30:51:27,040
is super powerful once we do this we're

46547
30:51:27,040 --> 30:51:28,960
going to go to each class in our

46548
30:51:28,960 --> 30:51:31,680
inheritance hierarchy and implement the

46549
30:51:31,680 --> 30:51:33,280
stream insert

46550
30:51:33,280 --> 30:51:35,592
override because if we don't do that

46551
30:51:35,592 --> 30:51:37,192
this class is also going to become an

46552
30:51:37,192 --> 30:51:40,000
abstract class because it is inheriting

46553
30:51:40,000 --> 30:51:42,400
from a class that has a pure virtual

46554
30:51:42,400 --> 30:51:45,280
function remember if you inherit from a

46555
30:51:45,280 --> 30:51:48,320
class that has at least one pure virtual

46556
30:51:48,320 --> 30:51:51,120
function you will be forced to implement

46557
30:51:51,120 --> 30:51:54,000
all the pure virtual functions that come

46558
30:51:54,000 --> 30:51:55,832
from your parent class if you don't do

46559
30:51:55,832 --> 30:51:58,232
that you are going to become an abstract

46560
30:51:58,232 --> 30:52:00,160
class yourself and we don't really want

46561
30:52:00,160 --> 30:52:02,640
that that's why we are overriding the

46562
30:52:02,640 --> 30:52:05,192
stream insert override here and with

46563
30:52:05,192 --> 30:52:07,280
this we are going to specify which

46564
30:52:07,280 --> 30:52:09,360
information to print from our object

46565
30:52:09,360 --> 30:52:11,592
here and here we are going to put out

46566
30:52:11,592 --> 30:52:14,080
the description and the wing color and

46567
30:52:14,080 --> 30:52:16,480
this is the format we specify here and

46568
30:52:16,480 --> 30:52:18,800
this method is going to be called by our

46569
30:52:18,800 --> 30:52:21,192
output stream operator which is coming

46570
30:52:21,192 --> 30:52:24,232
from our stream insertable interface

46571
30:52:24,232 --> 30:52:26,232
hopefully you can see how this is super

46572
30:52:26,232 --> 30:52:28,000
powerful okay now that you know this

46573
30:52:28,000 --> 30:52:29,360
we're going to head over to visual

46574
30:52:29,360 --> 30:52:31,120
studio code and play with us a little

46575
30:52:31,120 --> 30:52:34,080
more here we are in our working folder

46576
30:52:34,080 --> 30:52:36,960
the current project is abstract classes

46577
30:52:36,960 --> 30:52:39,832
as interfaces we're going to grab our

46578
30:52:39,832 --> 30:52:42,960
template files and put the data in place

46579
30:52:42,960 --> 30:52:45,040
and i'm going to copy this and put that

46580
30:52:45,040 --> 30:52:46,232
in here

46581
30:52:46,232 --> 30:52:48,160
we are going to put in the files we're

46582
30:52:48,160 --> 30:52:50,480
going to be using in our inheritance

46583
30:52:50,480 --> 30:52:52,960
hierarchy you see we have our animal

46584
30:52:52,960 --> 30:52:55,512
hierarchy here you can grab these files

46585
30:52:55,512 --> 30:52:58,160
from the resource section of this

46586
30:52:58,160 --> 30:53:00,080
lecture and you can reuse them like we

46587
30:53:00,080 --> 30:53:02,480
are using here or if you want you can

46588
30:53:02,480 --> 30:53:04,160
even type this but i don't really

46589
30:53:04,160 --> 30:53:05,912
recommend this because this is too much

46590
30:53:05,912 --> 30:53:07,912
typing we just want to learn about

46591
30:53:07,912 --> 30:53:10,080
interfaces here and that's what you

46592
30:53:10,080 --> 30:53:11,832
should focus on so we're going to open

46593
30:53:11,832 --> 30:53:14,320
this up in videos video code and this is

46594
30:53:14,320 --> 30:53:16,552
going to give us all the files we need

46595
30:53:16,552 --> 30:53:18,960
we're going to look at the top class and

46596
30:53:18,960 --> 30:53:21,192
we will see that it is inheriting from

46597
30:53:21,192 --> 30:53:24,400
our stream insertable interface so let's

46598
30:53:24,400 --> 30:53:27,120
look at our stream insertable interface

46599
30:53:27,120 --> 30:53:29,040
because this is the focus of this

46600
30:53:29,040 --> 30:53:32,080
lecture here so it is a regular class as

46601
30:53:32,080 --> 30:53:33,832
you see here it is class stream

46602
30:53:33,832 --> 30:53:35,680
insertable we're going to set up an

46603
30:53:35,680 --> 30:53:38,400
output stream operator and it is really

46604
30:53:38,400 --> 30:53:40,720
like any other output stream operator

46605
30:53:40,720 --> 30:53:42,080
you have seen we're going to pass the

46606
30:53:42,080 --> 30:53:44,640
second operand by reference

46607
30:53:44,640 --> 30:53:47,280
and we are going to specify our pure

46608
30:53:47,280 --> 30:53:49,512
virtual function which is going to be

46609
30:53:49,512 --> 30:53:52,000
implemented by downstream inheriting

46610
30:53:52,000 --> 30:53:54,800
classes from this class here and this is

46611
30:53:54,800 --> 30:53:57,440
going to set up polymorphism and what

46612
30:53:57,440 --> 30:53:58,872
this will do

46613
30:53:58,872 --> 30:54:02,000
is if we call this method on our second

46614
30:54:02,000 --> 30:54:04,400
operand here we are going to call this

46615
30:54:04,400 --> 30:54:06,800
method polymorphically so if you are

46616
30:54:06,800 --> 30:54:08,480
trying to print a point we are going to

46617
30:54:08,480 --> 30:54:10,552
call this method on a point object and

46618
30:54:10,552 --> 30:54:12,960
we will print it out exactly how the

46619
30:54:12,960 --> 30:54:15,360
point wants to be printed if we are

46620
30:54:15,360 --> 30:54:17,680
printing a circle we will call this

46621
30:54:17,680 --> 30:54:20,080
stream insert method on the circle and

46622
30:54:20,080 --> 30:54:22,720
we will print a circle exactly how a

46623
30:54:22,720 --> 30:54:25,360
circle wants to be printed out let's

46624
30:54:25,360 --> 30:54:27,760
look at the implementation and it is

46625
30:54:27,760 --> 30:54:29,680
nothing really complicated we're going

46626
30:54:29,680 --> 30:54:32,480
to specify our output stream object as

46627
30:54:32,480 --> 30:54:34,872
the first parameter here and the second

46628
30:54:34,872 --> 30:54:37,040
parameter is what we want to print out

46629
30:54:37,040 --> 30:54:39,192
we will pass this by reference and this

46630
30:54:39,192 --> 30:54:41,760
is going to allow us to do polymorphism

46631
30:54:41,760 --> 30:54:43,592
remember that stream insertable is

46632
30:54:43,592 --> 30:54:45,760
really going to become our top base

46633
30:54:45,760 --> 30:54:48,872
class so we will basically be setting up

46634
30:54:48,872 --> 30:54:51,592
stream insertable polymorphism here you

46635
30:54:51,592 --> 30:54:53,512
need to keep this in mind we are going

46636
30:54:53,512 --> 30:54:56,552
to call our stream insert method on our

46637
30:54:56,552 --> 30:54:58,160
operand and we're going to pass the

46638
30:54:58,160 --> 30:55:00,480
stream output we want to print on and

46639
30:55:00,480 --> 30:55:02,960
we're going to return this output stream

46640
30:55:02,960 --> 30:55:05,512
to really make this behave

46641
30:55:05,512 --> 30:55:08,552
like a regular output stream operator to

46642
30:55:08,552 --> 30:55:11,512
allow output chaining in our operator

46643
30:55:11,512 --> 30:55:14,232
here once we have this stream insertable

46644
30:55:14,232 --> 30:55:16,400
interface we can really use it however

46645
30:55:16,400 --> 30:55:19,280
we want let's head over to the main cpp

46646
30:55:19,280 --> 30:55:22,080
file and try to play with us so what we

46647
30:55:22,080 --> 30:55:25,120
are going to do is crack this open and

46648
30:55:25,120 --> 30:55:27,280
we are going to remove whatever it is we

46649
30:55:27,280 --> 30:55:30,640
don't need we are going to include our

46650
30:55:30,640 --> 30:55:32,640
interface so we're going to include

46651
30:55:32,640 --> 30:55:35,232
stream insertable let's do that

46652
30:55:35,232 --> 30:55:37,760
insertable.h i think this is the name

46653
30:55:37,760 --> 30:55:39,592
and we're going to set up a point class

46654
30:55:39,592 --> 30:55:42,400
which we wish to be printed out on the

46655
30:55:42,400 --> 30:55:44,720
output stream notice that we want to

46656
30:55:44,720 --> 30:55:47,360
inherit from stream insertable and what

46657
30:55:47,360 --> 30:55:50,000
this is really doing is attaching the

46658
30:55:50,000 --> 30:55:52,872
interface to the point class here and

46659
30:55:52,872 --> 30:55:55,592
because this stream insertable

46660
30:55:55,592 --> 30:55:58,552
interface has a pure virtual function

46661
30:55:58,552 --> 30:56:00,000
we need to

46662
30:56:00,000 --> 30:56:02,872
override this pure virtual function here

46663
30:56:02,872 --> 30:56:04,800
if we don't we want to be able to create

46664
30:56:04,800 --> 30:56:07,040
objects of our point here let's go down

46665
30:56:07,040 --> 30:56:08,480
and show you that we're going to get

46666
30:56:08,480 --> 30:56:11,040
that problem if we don't do that we're

46667
30:56:11,040 --> 30:56:12,800
going to say point

46668
30:56:12,800 --> 30:56:15,832
and say p1 and for example put in 10 and

46669
30:56:15,832 --> 30:56:16,872
20

46670
30:56:16,872 --> 30:56:19,192
we will have a compiler error because

46671
30:56:19,192 --> 30:56:22,080
now the point class is an abstract class

46672
30:56:22,080 --> 30:56:24,720
because it is inherited from a class

46673
30:56:24,720 --> 30:56:27,280
that has a pure virtual function and it

46674
30:56:27,280 --> 30:56:29,680
is not overriding that pure virtual

46675
30:56:29,680 --> 30:56:30,640
function

46676
30:56:30,640 --> 30:56:34,512
so in other words this class still has a

46677
30:56:34,512 --> 30:56:37,192
non-implemented pure virtual function

46678
30:56:37,192 --> 30:56:38,800
that's why it is

46679
30:56:38,800 --> 30:56:41,120
an abstract class and we can't create an

46680
30:56:41,120 --> 30:56:43,440
object of it if we're trying to run this

46681
30:56:43,440 --> 30:56:45,192
code we're going to pass this through

46682
30:56:45,192 --> 30:56:48,320
gcc we will get a compiler okay we have

46683
30:56:48,320 --> 30:56:50,232
a compiler error here and we need to fix

46684
30:56:50,232 --> 30:56:52,960
this all we need to do is to implement

46685
30:56:52,960 --> 30:56:55,832
the interface that comes from our stream

46686
30:56:55,832 --> 30:56:58,552
insertable interface here so we can grab

46687
30:56:58,552 --> 30:57:01,512
our pure virtual function and implement

46688
30:57:01,512 --> 30:57:05,280
it in our main cpp file for the point

46689
30:57:05,280 --> 30:57:07,440
class we're going to put it in here and

46690
30:57:07,440 --> 30:57:10,640
we will remove the pure virtual function

46691
30:57:10,640 --> 30:57:12,552
specifier here and we will put in an

46692
30:57:12,552 --> 30:57:15,040
implementation we want to specify that

46693
30:57:15,040 --> 30:57:17,280
this is an override of a method that is

46694
30:57:17,280 --> 30:57:21,360
coming from our upstream parent class

46695
30:57:21,360 --> 30:57:23,040
and we are going to head over in the

46696
30:57:23,040 --> 30:57:25,680
body of our function and put in the

46697
30:57:25,680 --> 30:57:27,760
information we want to put out

46698
30:57:27,760 --> 30:57:29,912
this is a point object so we just want

46699
30:57:29,912 --> 30:57:33,592
to print the m x coordinate and the m y

46700
30:57:33,592 --> 30:57:36,080
coordinate here and this is the format

46701
30:57:36,080 --> 30:57:39,592
that we want and at this moment the job

46702
30:57:39,592 --> 30:57:41,680
of this function is really done

46703
30:57:41,680 --> 30:57:44,720
and it will be picked up polymorphically

46704
30:57:44,720 --> 30:57:46,800
if somebody tries to call this on a

46705
30:57:46,800 --> 30:57:49,360
point object through polymorphism and

46706
30:57:49,360 --> 30:57:50,960
this is going to work now that we have

46707
30:57:50,960 --> 30:57:53,192
this point we can try and build and make

46708
30:57:53,192 --> 30:57:55,512
sure this is working let's make sure we

46709
30:57:55,512 --> 30:57:57,760
don't have the compiler error anymore

46710
30:57:57,760 --> 30:57:59,912
the world finished successfully so we

46711
30:57:59,912 --> 30:58:02,400
are cool here but what we want to see is

46712
30:58:02,400 --> 30:58:04,400
that we are able to print

46713
30:58:04,400 --> 30:58:06,320
point objects because that's the whole

46714
30:58:06,320 --> 30:58:09,592
point of attaching this interface to our

46715
30:58:09,592 --> 30:58:11,680
point class here so what we are going to

46716
30:58:11,680 --> 30:58:13,280
do is print this out we're going to say

46717
30:58:13,280 --> 30:58:15,832
sddc out we're going to say p1 and we're

46718
30:58:15,832 --> 30:58:18,552
going to say p1 here this is how we

46719
30:58:18,552 --> 30:58:21,040
would use our output stream operator you

46720
30:58:21,040 --> 30:58:22,800
see we don't have a compiler error this

46721
30:58:22,800 --> 30:58:25,040
is really magic some of you are going to

46722
30:58:25,040 --> 30:58:27,280
ask how is this even working somebody is

46723
30:58:27,280 --> 30:58:28,720
going to look at your class they are

46724
30:58:28,720 --> 30:58:30,400
going to look you don't have an output

46725
30:58:30,400 --> 30:58:32,720
stream operator but you can print your

46726
30:58:32,720 --> 30:58:35,512
objects so how is this working well this

46727
30:58:35,512 --> 30:58:37,280
is working through the magic of

46728
30:58:37,280 --> 30:58:40,000
interfaces we are attaching this

46729
30:58:40,000 --> 30:58:43,120
interface to our point class and this is

46730
30:58:43,120 --> 30:58:45,512
going to give our class the powers that

46731
30:58:45,512 --> 30:58:47,592
come from this interface and one of

46732
30:58:47,592 --> 30:58:50,232
those powers is to use the output stream

46733
30:58:50,232 --> 30:58:52,552
operator we get from this interface we

46734
30:58:52,552 --> 30:58:54,872
can use that directly and what this is

46735
30:58:54,872 --> 30:58:56,160
going to do let's look at the

46736
30:58:56,160 --> 30:58:58,552
implementation of this interface this is

46737
30:58:58,552 --> 30:59:01,512
going to just call the stream insert

46738
30:59:01,512 --> 30:59:04,480
virtual method on the object that we

46739
30:59:04,480 --> 30:59:07,040
pass as a second parameter in this

46740
30:59:07,040 --> 30:59:09,512
operator here and the second parameter

46741
30:59:09,512 --> 30:59:11,360
happens to be the point that we are

46742
30:59:11,360 --> 30:59:13,912
printing here so what this is really

46743
30:59:13,912 --> 30:59:15,192
going to do

46744
30:59:15,192 --> 30:59:17,360
is something like this we're going to

46745
30:59:17,360 --> 30:59:19,680
try and figure out what the compiler is

46746
30:59:19,680 --> 30:59:22,720
going to try and do we are going to say

46747
30:59:22,720 --> 30:59:25,280
p1 and we're going to say operator

46748
30:59:25,280 --> 30:59:27,440
stream output and we're going to say

46749
30:59:27,440 --> 30:59:30,232
stdc out that's the stream we want to be

46750
30:59:30,232 --> 30:59:32,080
printing to

46751
30:59:32,080 --> 30:59:34,552
and the point we want to print is p1

46752
30:59:34,552 --> 30:59:36,232
this is basically what the compiler is

46753
30:59:36,232 --> 30:59:38,640
going to do and it is going to print our

46754
30:59:38,640 --> 30:59:41,040
thumb and this method is available in

46755
30:59:41,040 --> 30:59:43,680
our stream insertable header and it is a

46756
30:59:43,680 --> 30:59:46,720
friend of our interface that's why we

46757
30:59:46,720 --> 30:59:49,040
are able to do something like this

46758
30:59:49,040 --> 30:59:51,360
accessing the data from our interface

46759
30:59:51,360 --> 30:59:52,872
let's build and actually show you that

46760
30:59:52,872 --> 30:59:54,232
this is going to work we're going to

46761
30:59:54,232 --> 30:59:57,120
pass this through our gcc compiler the

46762
30:59:57,120 --> 30:59:58,800
build is going to be good so we can

46763
30:59:58,800 --> 31:00:01,360
clear not clear we're going to control z

46764
31:00:01,360 --> 31:00:03,280
on this and we're going to bring up a

46765
31:00:03,280 --> 31:00:05,440
powershell window and we're going to

46766
31:00:05,440 --> 31:00:07,440
clear this time and run rooster you see

46767
31:00:07,440 --> 31:00:09,040
that we are creating our point here and

46768
31:00:09,040 --> 31:00:10,872
this is really cool we can even

46769
31:00:10,872 --> 31:00:13,360
uncomment this and we're going to use

46770
31:00:13,360 --> 31:00:15,760
sddc out because the compiler is going

46771
31:00:15,760 --> 31:00:18,232
to take this and turn that into this and

46772
31:00:18,232 --> 31:00:21,360
we have the ability to have code that is

46773
31:00:21,360 --> 31:00:23,440
much more readable by c plus plus

46774
31:00:23,440 --> 31:00:25,592
developers out there we're going to

46775
31:00:25,592 --> 31:00:27,760
build and run this again the build is

46776
31:00:27,760 --> 31:00:30,160
going to be good we can clear and run

46777
31:00:30,160 --> 31:00:32,160
rooster and this is going to print our

46778
31:00:32,160 --> 31:00:34,872
point here this is really cool but this

46779
31:00:34,872 --> 31:00:37,192
is not the end of our store we can even

46780
31:00:37,192 --> 31:00:40,552
print an entire inheritance hierarchy

46781
31:00:40,552 --> 31:00:43,760
look at what we did at our animal class

46782
31:00:43,760 --> 31:00:47,040
here we attached this interface to our

46783
31:00:47,040 --> 31:00:49,760
animal class and the moment we do that

46784
31:00:49,760 --> 31:00:52,640
we need to override the pure virtual

46785
31:00:52,640 --> 31:00:53,592
function

46786
31:00:53,592 --> 31:00:55,592
that comes with this interface and

46787
31:00:55,592 --> 31:00:57,912
that's what we did down here we have

46788
31:00:57,912 --> 31:01:00,552
overwritten the stream insert

46789
31:01:00,552 --> 31:01:02,000
virtual function

46790
31:01:02,000 --> 31:01:04,232
and in the body we're going to specify

46791
31:01:04,232 --> 31:01:06,400
which data we want to print and how to

46792
31:01:06,400 --> 31:01:08,800
print that data that's the whole point

46793
31:01:08,800 --> 31:01:11,360
of this override we are doing here we

46794
31:01:11,360 --> 31:01:14,160
are going to do the same thing in each

46795
31:01:14,160 --> 31:01:16,480
inheritance class from animal for

46796
31:01:16,480 --> 31:01:18,400
example if we go to feline we're going

46797
31:01:18,400 --> 31:01:20,720
to do exactly the same thing we are

46798
31:01:20,720 --> 31:01:23,280
going to inherit from animal and this

46799
31:01:23,280 --> 31:01:25,512
will indirectly inherit from our

46800
31:01:25,512 --> 31:01:26,872
interface so

46801
31:01:26,872 --> 31:01:28,872
we need to override

46802
31:01:28,872 --> 31:01:31,040
the pure virtual function that comes

46803
31:01:31,040 --> 31:01:33,360
with that interface and we do that here

46804
31:01:33,360 --> 31:01:35,192
we're going to specify which data we

46805
31:01:35,192 --> 31:01:36,552
want to print in this case we're going

46806
31:01:36,552 --> 31:01:39,280
to put the description out and the first

46807
31:01:39,280 --> 31:01:42,232
style and we are going to specify the

46808
31:01:42,232 --> 31:01:44,232
format in which we want the data to be

46809
31:01:44,232 --> 31:01:46,320
printed out again that's the whole point

46810
31:01:46,320 --> 31:01:49,440
of overriding this virtual function here

46811
31:01:49,440 --> 31:01:51,360
we're going to do the same thing on each

46812
31:01:51,360 --> 31:01:53,512
inheritance class in our inheritance

46813
31:01:53,512 --> 31:01:55,832
hierarchy for example we did the exact

46814
31:01:55,832 --> 31:01:57,592
same thing for doug

46815
31:01:57,592 --> 31:02:00,400
we did the exact same thing for a cat

46816
31:02:00,400 --> 31:02:02,400
and we're going to do the same thing on

46817
31:02:02,400 --> 31:02:05,440
our bird classes that's exactly what we

46818
31:02:05,440 --> 31:02:08,552
do here specify which data to print out

46819
31:02:08,552 --> 31:02:10,400
and how the data is going to be printed

46820
31:02:10,400 --> 31:02:13,912
out and this stream insert override is

46821
31:02:13,912 --> 31:02:16,640
going to be picked up by our interface

46822
31:02:16,640 --> 31:02:19,912
when we get to call the output stream

46823
31:02:19,912 --> 31:02:22,160
operator here notice that we are calling

46824
31:02:22,160 --> 31:02:24,640
this thing polymorphically we are

46825
31:02:24,640 --> 31:02:27,192
calling our stream insert

46826
31:02:27,192 --> 31:02:30,400
method on a reference that we pass here

46827
31:02:30,400 --> 31:02:32,552
and this is going to resolve this using

46828
31:02:32,552 --> 31:02:34,960
dynamic binding this is going to work

46829
31:02:34,960 --> 31:02:37,280
really well now that we have this setup

46830
31:02:37,280 --> 31:02:39,592
we can head over to the main cpp file

46831
31:02:39,592 --> 31:02:42,080
and really do all kinds of crazy things

46832
31:02:42,080 --> 31:02:44,800
let's put in a separator here and we are

46833
31:02:44,800 --> 31:02:46,000
going to

46834
31:02:46,000 --> 31:02:49,120
play with us we are going to include the

46835
31:02:49,120 --> 31:02:52,232
classes we need to set up our animals

46836
31:02:52,232 --> 31:02:54,160
and we are going to put them in here we

46837
31:02:54,160 --> 31:02:56,800
have animal feline dog cat bird pigeon

46838
31:02:56,800 --> 31:02:59,192
and crow the moment we do this we don't

46839
31:02:59,192 --> 31:03:01,120
need to put in this stream insertable

46840
31:03:01,120 --> 31:03:02,872
because it is coming in directly from

46841
31:03:02,872 --> 31:03:04,720
this but we don't need to worry about

46842
31:03:04,720 --> 31:03:07,280
this because we have include guards in

46843
31:03:07,280 --> 31:03:09,592
but we are going to be using smart

46844
31:03:09,592 --> 31:03:12,080
pointers so let's include the memory

46845
31:03:12,080 --> 31:03:14,960
header and we can set up an animal and

46846
31:03:14,960 --> 31:03:16,800
try to print it out we will be using

46847
31:03:16,800 --> 31:03:18,960
polymorphism so we will go through a

46848
31:03:18,960 --> 31:03:22,080
base pointer to animal and use that to

46849
31:03:22,080 --> 31:03:24,320
manage a dog object here we are just

46850
31:03:24,320 --> 31:03:26,720
going to pass in the data and we will

46851
31:03:26,720 --> 31:03:29,680
try to print this animal out notice that

46852
31:03:29,680 --> 31:03:31,912
we are going through a base pointer

46853
31:03:31,912 --> 31:03:34,080
calling the output stream operator so

46854
31:03:34,080 --> 31:03:35,912
this is going to resolve

46855
31:03:35,912 --> 31:03:37,760
the call to stream insert

46856
31:03:37,760 --> 31:03:40,160
polymorphically and it is going to print

46857
31:03:40,160 --> 31:03:42,872
this information at the dog level and

46858
31:03:42,872 --> 31:03:45,512
what i mean by that is that if we go in

46859
31:03:45,512 --> 31:03:47,440
dog we're going to find our stream

46860
31:03:47,440 --> 31:03:49,360
insert that's going to print this

46861
31:03:49,360 --> 31:03:50,800
information here

46862
31:03:50,800 --> 31:03:52,872
like we want to print a dog and this is

46863
31:03:52,872 --> 31:03:55,592
super powerful hopefully you can see how

46864
31:03:55,592 --> 31:03:57,512
cool this is we're going to try and

46865
31:03:57,512 --> 31:03:59,192
build this program we're going to pass

46866
31:03:59,192 --> 31:04:01,440
this through gcc the boat is going to be

46867
31:04:01,440 --> 31:04:03,912
good we can clear and run rooster we're

46868
31:04:03,912 --> 31:04:06,552
going to see that we print this as a dog

46869
31:04:06,552 --> 31:04:08,960
even if we used a base pointer to try

46870
31:04:08,960 --> 31:04:11,512
and print this out how cool is this we

46871
31:04:11,512 --> 31:04:14,400
can even use this to set up a bird and

46872
31:04:14,400 --> 31:04:16,000
print it out we're going to set up a

46873
31:04:16,000 --> 31:04:18,000
base pointer that is going to be

46874
31:04:18,000 --> 31:04:20,232
managing a bird you can see that we are

46875
31:04:20,232 --> 31:04:21,832
using a unique pointer here you can

46876
31:04:21,832 --> 31:04:23,832
really use any kind of smart pointer you

46877
31:04:23,832 --> 31:04:25,512
want we're going to print this out and

46878
31:04:25,512 --> 31:04:28,160
this will be printed out like a bird

46879
31:04:28,160 --> 31:04:30,160
wants to be printed out and that's going

46880
31:04:30,160 --> 31:04:31,680
to be using

46881
31:04:31,680 --> 31:04:34,640
the override from our bird class and

46882
31:04:34,640 --> 31:04:36,400
that's going to say bird is going to put

46883
31:04:36,400 --> 31:04:38,160
out the description it's going to put

46884
31:04:38,160 --> 31:04:39,592
out the wing color and this is really

46885
31:04:39,592 --> 31:04:42,080
going to work really well we're going to

46886
31:04:42,080 --> 31:04:44,552
pass this through gcc again the world is

46887
31:04:44,552 --> 31:04:46,640
going to be good we can clear and run

46888
31:04:46,640 --> 31:04:48,480
rooster you see that we are printing out

46889
31:04:48,480 --> 31:04:51,760
bird here and this is using polymorphism

46890
31:04:51,760 --> 31:04:54,960
combined with interfaces and this can

46891
31:04:54,960 --> 31:04:57,512
come in handy if this helps your

46892
31:04:57,512 --> 31:04:59,760
application depending on what you want

46893
31:04:59,760 --> 31:05:02,000
to achieve with zipclose plus we can

46894
31:05:02,000 --> 31:05:05,040
even put our animal data in an array and

46895
31:05:05,040 --> 31:05:07,440
try to print that out so we're going to

46896
31:05:07,440 --> 31:05:10,000
put out a separator to be able to follow

46897
31:05:10,000 --> 31:05:13,760
this nicely in our output terminal this

46898
31:05:13,760 --> 31:05:15,912
is going to do and we're going to go

46899
31:05:15,912 --> 31:05:17,832
down and put in the code to play with us

46900
31:05:17,832 --> 31:05:20,080
we're going to share an array of shared

46901
31:05:20,080 --> 31:05:22,232
pointers this is how we do this and

46902
31:05:22,232 --> 31:05:24,080
we're going to initialize this with all

46903
31:05:24,080 --> 31:05:26,232
kinds of crazy animals we're going to

46904
31:05:26,232 --> 31:05:28,080
put in a dog we're going to put in a cat

46905
31:05:28,080 --> 31:05:29,512
we're going to put in a crow and a

46906
31:05:29,512 --> 31:05:32,480
pigeon and we will be managing this

46907
31:05:32,480 --> 31:05:34,480
through base pointers notice that this

46908
31:05:34,480 --> 31:05:37,040
is an array of base pointers

46909
31:05:37,040 --> 31:05:39,512
and we're going to be calling the output

46910
31:05:39,512 --> 31:05:42,232
stream operator polymorphically so for

46911
31:05:42,232 --> 31:05:44,160
the first element here we will print a

46912
31:05:44,160 --> 31:05:47,040
dog how a dog wants to be printed out so

46913
31:05:47,040 --> 31:05:49,680
we will be using the stream insert

46914
31:05:49,680 --> 31:05:51,832
override from the dog class if we go

46915
31:05:51,832 --> 31:05:53,040
there we're going to see that we're

46916
31:05:53,040 --> 31:05:56,000
going to prefix our data with dog if we

46917
31:05:56,000 --> 31:05:57,592
hit the second element we're going to

46918
31:05:57,592 --> 31:05:59,912
print this like a cat wants to be

46919
31:05:59,912 --> 31:06:01,832
printed down the third element is going

46920
31:06:01,832 --> 31:06:04,320
to be printed out as a crow the fourth

46921
31:06:04,320 --> 31:06:06,080
element is going to be printed out as a

46922
31:06:06,080 --> 31:06:08,080
pigeon and this is going to fall in and

46923
31:06:08,080 --> 31:06:08,872
work

46924
31:06:08,872 --> 31:06:11,192
right away down here you see that we are

46925
31:06:11,192 --> 31:06:13,360
looping calling our output stream

46926
31:06:13,360 --> 31:06:14,800
operator and this is going to work

46927
31:06:14,800 --> 31:06:17,120
really well let's try and build this

46928
31:06:17,120 --> 31:06:18,800
program we're going to pass this through

46929
31:06:18,800 --> 31:06:21,280
gcc the build is going to be good so we

46930
31:06:21,280 --> 31:06:23,760
can clear and run rooster and you're

46931
31:06:23,760 --> 31:06:25,760
going to see that we are printing our

46932
31:06:25,760 --> 31:06:27,440
information here the first thing is a

46933
31:06:27,440 --> 31:06:30,000
dog the second thing is a cat the third

46934
31:06:30,000 --> 31:06:32,232
thing is a crew the fourth fan is a

46935
31:06:32,232 --> 31:06:34,720
pigeon and this is working really well

46936
31:06:34,720 --> 31:06:37,440
hopefully you can see how interfaces can

46937
31:06:37,440 --> 31:06:40,400
be powerful in your c plus plus design

46938
31:06:40,400 --> 31:06:42,552
use this if it makes sense for whatever

46939
31:06:42,552 --> 31:06:44,232
application you are designing with z

46940
31:06:44,232 --> 31:06:46,800
plus plus my main goal here is to

46941
31:06:46,800 --> 31:06:50,232
introduce you to the idea of interfaces

46942
31:06:50,232 --> 31:06:52,640
and how powerful they can be again an

46943
31:06:52,640 --> 31:06:54,480
interface is something you can attach to

46944
31:06:54,480 --> 31:06:56,400
your type in c plus plus

46945
31:06:56,400 --> 31:06:58,160
and at the moment you attach that

46946
31:06:58,160 --> 31:07:00,400
interface to your type your type is

46947
31:07:00,400 --> 31:07:02,480
going to have the powers that come with

46948
31:07:02,480 --> 31:07:05,360
that interface and all you need to do in

46949
31:07:05,360 --> 31:07:08,160
your deriving classes is to implement

46950
31:07:08,160 --> 31:07:10,160
the virtual functions that come with

46951
31:07:10,160 --> 31:07:12,800
that interface and the interface will

46952
31:07:12,800 --> 31:07:14,800
pick them up and use them to do whatever

46953
31:07:14,800 --> 31:07:16,480
it is you want to do

46954
31:07:16,480 --> 31:07:18,720
polymorphically and that's going to be

46955
31:07:18,720 --> 31:07:21,120
really cool we are going to stop here in

46956
31:07:21,120 --> 31:07:23,360
this lecture this one we're going to try

46957
31:07:23,360 --> 31:07:26,320
and recap what we saw in this chapter

46958
31:07:26,320 --> 31:07:28,640
go ahead and finish up here and meet me

46959
31:07:28,640 --> 31:07:31,120
there

